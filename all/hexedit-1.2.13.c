/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 90 "/usr/include/stdio.h"
typedef __off_t off_t;
#line 324 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef int wchar_t;
#line 150 "/usr/include/curses.h"
typedef unsigned long chtype;
#line 358
struct _win_st;
#line 358 "/usr/include/curses.h"
typedef struct _win_st WINDOW;
#line 360 "/usr/include/curses.h"
typedef chtype attr_t;
#line 390 "/usr/include/curses.h"
struct __anonstruct_cchar_t_29 {
   attr_t attr ;
   wchar_t chars[5] ;
};
#line 390 "/usr/include/curses.h"
typedef struct __anonstruct_cchar_t_29 cchar_t;
#line 405
struct ldat;
#line 407 "/usr/include/curses.h"
struct pdat {
   short _pad_y ;
   short _pad_x ;
   short _pad_top ;
   short _pad_left ;
   short _pad_bottom ;
   short _pad_right ;
};
#line 407 "/usr/include/curses.h"
struct _win_st {
   short _cury ;
   short _curx ;
   short _maxy ;
   short _maxx ;
   short _begy ;
   short _begx ;
   short _flags ;
   attr_t _attrs ;
   chtype _bkgd ;
   _Bool _notimeout ;
   _Bool _clear ;
   _Bool _leaveok ;
   _Bool _scroll ;
   _Bool _idlok ;
   _Bool _idcok ;
   _Bool _immed ;
   _Bool _sync ;
   _Bool _use_keypad ;
   int _delay ;
   struct ldat *_line ;
   short _regtop ;
   short _regbottom ;
   int _parx ;
   int _pary ;
   WINDOW *_parent ;
   struct pdat _pad ;
   short _yoffset ;
   cchar_t _bkgrnd ;
};
#line 65 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
enum __anonenum_modeType_59 {
    bySector = 0,
    maximized = 1,
    LAST = 2
} ;
#line 65 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
typedef enum __anonenum_modeType_59 modeType;
#line 66 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
struct __anonstruct_modeParams_60 {
   int blocSize ;
   int lineLength ;
   int page ;
};
#line 66 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
typedef struct __anonstruct_modeParams_60 modeParams;
#line 81 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
struct _typePage {
   struct _typePage *next ;
   off_t base ;
   int size ;
   unsigned char *vals ;
};
#line 81 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
typedef struct _typePage typePage;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_8 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_9 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_8 __wait_terminated ;
   struct __anonstruct___wait_stopped_9 __wait_stopped ;
};
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 810 "/usr/include/curses.h"
extern int wgetch(WINDOW * ) ;
#line 1386
extern WINDOW *stdscr ;
#line 34 "/usr/include/libgen.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) __xpg_basename)(char *__path ) ;
#line 70 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
modeParams modes[2] ;
#line 71
modeType mode ;
#line 72
int colored ;
#line 73
char *usage ;
#line 94 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
off_t lastEditedLoc  ;
#line 94 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
off_t biggestLoc  ;
#line 94 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
off_t fileSize  ;
#line 95 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
off_t mark_min  ;
#line 95 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
off_t mark_max  ;
#line 95 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
off_t mark_set  ;
#line 96 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
off_t base  ;
#line 96 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
off_t oldbase  ;
#line 97 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
int normalSpaces  ;
#line 97 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
int cursor  ;
#line 97 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
int cursorOffset  ;
#line 97 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
int hexOrAscii  ;
#line 98 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
int blocSize  ;
#line 98 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
int lineLength  ;
#line 98 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
int colsUsed  ;
#line 98 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
int page  ;
#line 99 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
int isReadOnly  ;
#line 99 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
int fd  ;
#line 99 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
int nbBytes  ;
#line 99 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
int oldcursor  ;
#line 99 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
int oldattr  ;
#line 99 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
int oldcursorOffset  ;
#line 100 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
int sizeCopyBuffer  ;
#line 100 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
int *bufferAttr  ;
#line 101 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
char *progName  ;
#line 101 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
char *fileName  ;
#line 101 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
char *baseName  ;
#line 102 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
unsigned char *buffer  ;
#line 102 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
unsigned char *copyBuffer  ;
#line 103 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
typePage *edited  ;
#line 105
char *lastFindFile ;
#line 105
char *lastYankToAFile ;
#line 105
char *lastAskHexString ;
#line 105
char *lastAskAsciiString ;
#line 105
char *lastFillWithStringHexa ;
#line 105
char *lastFillWithStringAscii ;
#line 112
int key_to_function(int key ) ;
#line 113
void init(void) ;
#line 114
void quit(void) ;
#line 116
void openFile(void) ;
#line 117
void readFile(void) ;
#line 118
int findFile(void) ;
#line 132
void discardEdited(void) ;
#line 150
void initCurses(void) ;
#line 151
void exitCurses(void) ;
#line 152
void display(void) ;
#line 189
int streq(char const   *s1 , char const   *s2 ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.c"
char *lastFindFile  =    (char *)((void *)0);
#line 34 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.c"
char *lastYankToAFile  =    (char *)((void *)0);
#line 34 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.c"
char *lastAskHexString  =    (char *)((void *)0);
#line 34 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.c"
char *lastAskAsciiString  =    (char *)((void *)0);
#line 34 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.c"
char *lastFillWithStringHexa  =    (char *)((void *)0);
#line 34 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.c"
char *lastFillWithStringAscii  =    (char *)((void *)0);
#line 37 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.c"
modeParams modes[2]  = {      {8, 16, 256}, 
        {4, 0, 0}};
#line 41 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.c"
modeType mode  =    (modeType )1;
#line 42 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.c"
int colored  =    0;
#line 44 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.c"
char *usage  =    (char *)"usage: %s [-s | --sector] [-m | --maximize] [--color] [-h | --help] filename\n";
#line 54 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.c"
int main(int argc , char **argv ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 56
  progName = __xpg_basename(*(argv + 0));
#line 57
  argv ++;
#line 57
  argc --;
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    if (! (argc > 0)) {
#line 59
      goto while_break;
    }
    {
#line 61
    tmp___3 = streq((char const   *)*argv, "-s");
    }
#line 61
    if (tmp___3) {
#line 62
      mode = (modeType )0;
    } else {
      {
#line 61
      tmp___4 = streq((char const   *)*argv, "--sector");
      }
#line 61
      if (tmp___4) {
#line 62
        mode = (modeType )0;
      } else {
        {
#line 63
        tmp___1 = streq((char const   *)*argv, "-m");
        }
#line 63
        if (tmp___1) {
#line 64
          mode = (modeType )1;
        } else {
          {
#line 63
          tmp___2 = streq((char const   *)*argv, "--maximize");
          }
#line 63
          if (tmp___2) {
#line 64
            mode = (modeType )1;
          } else {
            {
#line 66
            tmp___0 = streq((char const   *)*argv, "--color");
            }
#line 66
            if (tmp___0) {
#line 67
              colored = 1;
            } else {
              {
#line 69
              tmp = streq((char const   *)*argv, "--");
              }
#line 69
              if (tmp) {
#line 70
                argv ++;
#line 70
                argc --;
#line 71
                goto while_break;
              } else
#line 72
              if ((int )*(*(argv + 0)) == 45) {
                {
#line 74
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)usage,
                        progName);
#line 74
                exit(1);
                }
              } else {
#line 75
                goto while_break;
              }
            }
          }
        }
      }
    }
#line 59
    argv ++;
#line 59
    argc --;
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  if (argc > 1) {
    {
#line 77
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)usage,
            progName);
#line 77
    exit(1);
    }
  }
  {
#line 79
  init();
  }
#line 80
  if (argc == 1) {
    {
#line 81
    fileName = strdup((char const   *)*argv);
#line 82
    openFile();
    }
  }
  {
#line 84
  initCurses();
  }
#line 85
  if ((unsigned long )fileName == (unsigned long )((void *)0)) {
    {
#line 86
    tmp___5 = findFile();
    }
#line 86
    if (! tmp___5) {
      {
#line 87
      exitCurses();
#line 88
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: No such file\n",
              progName);
#line 88
      exit(1);
      }
    }
    {
#line 90
    openFile();
    }
  }
  {
#line 92
  readFile();
  }
  {
#line 93
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 93
    display();
#line 93
    tmp___6 = wgetch(stdscr);
#line 93
    tmp___7 = key_to_function(tmp___6);
    }
#line 93
    if (! tmp___7) {
#line 93
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 95
  quit();
  }
#line 96
  return (0);
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.c"
void init(void) 
{ 


  {
#line 106
  page = 0;
#line 107
  normalSpaces = 3;
#line 108
  hexOrAscii = 1;
#line 109
  copyBuffer = (unsigned char *)((void *)0);
#line 110
  edited = (typePage *)((void *)0);
#line 111
  return;
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.c"
void quit(void) 
{ 


  {
  {
#line 115
  exitCurses();
#line 116
  free((void *)fileName);
#line 117
  free((void *)buffer);
#line 118
  free((void *)bufferAttr);
  }
#line 119
  if (copyBuffer) {
    {
#line 119
    free((void *)copyBuffer);
    }
  }
  {
#line 120
  discardEdited();
  }
#line 121
  if (lastFindFile) {
    {
#line 121
    free((void *)lastFindFile);
    }
  }
#line 121
  if (lastYankToAFile) {
    {
#line 121
    free((void *)lastYankToAFile);
    }
  }
#line 121
  if (lastAskHexString) {
    {
#line 121
    free((void *)lastAskHexString);
    }
  }
#line 121
  if (lastAskAsciiString) {
    {
#line 121
    free((void *)lastAskAsciiString);
    }
  }
#line 121
  if (lastFillWithStringHexa) {
    {
#line 121
    free((void *)lastFillWithStringHexa);
    }
  }
#line 121
  if (lastFillWithStringAscii) {
    {
#line 121
    free((void *)lastFillWithStringAscii);
    }
  }
  {
#line 122
  exit(0);
  }
}
}
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 608 "/usr/include/curses.h"
extern int echo(void) ;
#line 611
extern int endwin(void) ;
#line 632
extern WINDOW *initscr(void) ;
#line 634
extern int init_pair(short  , short  , short  ) ;
#line 647
extern int keypad(WINDOW * , _Bool  ) ;
#line 711
extern int noecho(void) ;
#line 723
extern int printw(char const   *  , ...) ;
#line 727
extern int raw(void) ;
#line 764
extern int start_color(void) ;
#line 774
extern int ungetch(int  ) ;
#line 801
extern int wclear(WINDOW * ) ;
#line 803
extern int wclrtoeol(WINDOW * ) ;
#line 811
extern int wgetnstr(WINDOW * , char * , int  ) ;
#line 824
extern int wmove(WINDOW * , int  , int  ) ;
#line 829
extern int wrefresh(WINDOW * ) ;
#line 899
extern int use_default_colors(void) ;
#line 1390
extern int COLS ;
#line 1392
extern int LINES ;
#line 111 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
off_t getfilesize(void) ;
#line 115
int tryloc(off_t loc ) ;
#line 119
int computeLineSize(void) ;
#line 120
int computeCursorXCurrentPos(void) ;
#line 121
int computeCursorXPos(int cursor___0 , int hexOrAscii___0 ) ;
#line 122
void updateMarked(void) ;
#line 142
int move_cursor(off_t delta ) ;
#line 143
int set_cursor(off_t loc ) ;
#line 144
int move_base(off_t delta ) ;
#line 145
int set_base(off_t loc ) ;
#line 153
void displayLine(int offset , int max ) ;
#line 154
void clr_line(int line ) ;
#line 155
void displayCentered(char *msg , int line ) ;
#line 156
void displayOneLineMessage(char *msg ) ;
#line 157
void displayTwoLineMessage(char *msg1 , char *msg2 ) ;
#line 158
void displayMessageAndWaitForKey(char *msg ) ;
#line 159
int displayMessageAndGetString(char *msg , char **last , char *p , int p_size ) ;
#line 160
void ungetstr(char *s ) ;
#line 161
int get_number(off_t *i ) ;
#line 190
int strbeginswith(char const   *a , char const   *prefix ) ;
#line 192
off_t myfloor(off_t a , off_t b ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/display.c"
int move_cursor(off_t delta ) 
{ 
  int tmp ;

  {
  {
#line 21
  tmp = set_cursor((base + (off_t )cursor) + delta);
  }
#line 21
  return (tmp);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/display.c"
int set_cursor(off_t loc ) 
{ 
  int tmp ;
  off_t tmp___0 ;
  int tmp___1 ;
  off_t tmp___2 ;
  int tmp___3 ;

  {
#line 26
  if (loc < 0L) {
#line 26
    if (base % (long )lineLength) {
#line 27
      loc = (off_t )0;
    }
  }
  {
#line 29
  tmp = tryloc(loc);
  }
#line 29
  if (! tmp) {
#line 30
    return (0);
  }
#line 32
  if (loc < base) {
#line 33
    if (loc - base % (long )lineLength < 0L) {
      {
#line 34
      set_base((off_t )0);
      }
    } else {
      {
#line 35
      tmp___0 = myfloor(loc - base % (long )lineLength, (off_t )lineLength);
#line 35
      tmp___1 = move_base((tmp___0 + base % (long )lineLength) - base);
      }
#line 35
      if (! tmp___1) {
#line 36
        return (0);
      }
    }
#line 37
    cursor = (int )(loc - base);
  } else
#line 38
  if (loc >= base + (off_t )page) {
    {
#line 39
    tmp___2 = myfloor(loc - base % (long )lineLength, (off_t )lineLength);
#line 39
    tmp___3 = move_base((((tmp___2 + base % (long )lineLength) - (off_t )page) + (off_t )lineLength) - base);
    }
#line 39
    if (! tmp___3) {
#line 40
      return (0);
    }
#line 41
    cursor = (int )(loc - base);
  } else
#line 42
  if (loc > base + (off_t )nbBytes) {
#line 43
    return (0);
  } else {
#line 45
    cursor = (int )(loc - base);
  }
#line 47
  if (mark_set) {
    {
#line 48
    updateMarked();
    }
  }
#line 50
  return (1);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/display.c"
int move_base(off_t delta ) 
{ 
  int tmp ;

  {
#line 55
  if ((unsigned int )mode == 0U) {
#line 56
    if (delta > 0L) {
#line 56
      if (delta < (off_t )page) {
#line 57
        delta = (off_t )page;
      } else {
#line 56
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 58
    if (delta < 0L) {
#line 58
      if (delta > (off_t )(- page)) {
#line 59
        delta = (off_t )(- page);
      }
    }
  }
  {
#line 61
  tmp = set_base(base + delta);
  }
#line 61
  return (tmp);
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/display.c"
int set_base(off_t loc ) 
{ 
  int tmp ;
  off_t tmp___0 ;

  {
#line 66
  if (loc < 0L) {
#line 66
    loc = (off_t )0;
  }
  {
#line 68
  tmp = tryloc(loc);
  }
#line 68
  if (! tmp) {
#line 68
    return (0);
  }
  {
#line 69
  base = loc;
#line 70
  readFile();
  }
#line 72
  if ((unsigned int )mode != 0U) {
#line 72
    if (nbBytes < page - lineLength) {
#line 72
      if (base != 0L) {
        {
#line 73
        tmp___0 = myfloor((off_t )((page - nbBytes) - lineLength), (off_t )lineLength);
#line 73
        base -= tmp___0;
        }
#line 74
        if (base < 0L) {
#line 74
          base = (off_t )0;
        }
        {
#line 75
        readFile();
        }
      }
    }
  }
#line 78
  if (cursor > nbBytes) {
#line 78
    cursor = nbBytes;
  }
#line 79
  return (1);
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/display.c"
int computeLineSize(void) 
{ 
  int tmp ;

  {
  {
#line 83
  tmp = computeCursorXPos(lineLength - 1, 0);
  }
#line 83
  return (tmp + 1);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/display.c"
int computeCursorXCurrentPos(void) 
{ 
  int tmp ;

  {
  {
#line 84
  tmp = computeCursorXPos(cursor, hexOrAscii);
  }
#line 84
  return (tmp);
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/display.c"
int computeCursorXPos(int cursor___0 , int hexOrAscii___0 ) 
{ 
  int r ;
  int x ;
  int h ;
  int tmp ;
  int tmp___0 ;

  {
#line 87
  r = 11;
#line 88
  x = cursor___0 % lineLength;
#line 89
  if (hexOrAscii___0) {
#line 89
    tmp = x;
  } else {
#line 89
    tmp = lineLength - 1;
  }
#line 89
  h = tmp;
#line 91
  if (hexOrAscii___0) {
#line 91
    if (cursorOffset) {
#line 91
      tmp___0 = 1;
    } else {
#line 91
      tmp___0 = 0;
    }
  } else {
#line 91
    tmp___0 = 0;
  }
#line 91
  r += (normalSpaces * (h % blocSize) + (h / blocSize) * (normalSpaces * blocSize + 1)) + tmp___0;
#line 93
  if (! hexOrAscii___0) {
#line 93
    r += (x + normalSpaces) + 1;
  }
#line 95
  return (r);
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/display.c"
void initCurses(void) 
{ 
  off_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 105
  initscr();
  }
#line 108
  if (colored) {
    {
#line 109
    start_color();
#line 110
    use_default_colors();
#line 111
    init_pair((short)1, (short)1, (short)-1);
#line 112
    init_pair((short)2, (short)2, (short)-1);
#line 113
    init_pair((short)3, (short)4, (short)-1);
    }
  }
  {
#line 117
  wrefresh(stdscr);
#line 118
  raw();
#line 119
  noecho();
#line 120
  keypad(stdscr, (_Bool)1);
  }
#line 122
  if ((unsigned int )mode == 0U) {
    {
#line 123
    lineLength = modes[0].lineLength;
#line 124
    page = modes[0].page;
#line 125
    tmp = myfloor((off_t )((LINES - 1) * lineLength), (off_t )page);
#line 125
    page = (int )tmp;
#line 126
    blocSize = modes[0].blocSize;
#line 127
    tmp___0 = computeLineSize();
    }
#line 127
    if (tmp___0 > COLS) {
      {
#line 127
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: term is too small for sectored view (width)\n",
              progName);
#line 127
      exit(1);
      }
    }
#line 128
    if (page == 0) {
      {
#line 128
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: term is too small for sectored view (height)\n",
              progName);
#line 128
      exit(1);
      }
    }
  } else {
#line 130
    if (LINES <= 4) {
      {
#line 130
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: term is too small (height)\n",
              progName);
#line 130
      exit(1);
      }
    }
#line 132
    blocSize = modes[1].blocSize;
#line 133
    lineLength = blocSize;
    {
#line 133
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 133
      tmp___1 = computeLineSize();
      }
#line 133
      if (! (tmp___1 <= COLS)) {
#line 133
        goto while_break;
      }
#line 133
      lineLength += blocSize;
    }
    while_break: /* CIL Label */ ;
    }
#line 134
    lineLength -= blocSize;
#line 135
    if (lineLength == 0) {
      {
#line 135
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: term is too small (width)\n",
              progName);
#line 135
      exit(1);
      }
    }
#line 137
    page = lineLength * (LINES - 1);
  }
  {
#line 139
  colsUsed = computeLineSize();
#line 140
  tmp___2 = malloc((size_t )page);
#line 140
  buffer = (unsigned char *)tmp___2;
#line 141
  tmp___3 = malloc((unsigned long )page * sizeof(*bufferAttr));
#line 141
  bufferAttr = (int *)tmp___3;
  }
#line 142
  return;
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/display.c"
void exitCurses(void) 
{ 


  {
  {
#line 146
  close(fd);
#line 147
  wclear(stdscr);
#line 148
  wrefresh(stdscr);
#line 149
  endwin();
  }
#line 150
  return;
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/display.c"
void display(void) 
{ 
  int i ;
  int j ;
  off_t tmp ;
  off_t tmp___0 ;
  int tmp___1 ;

  {
#line 156
  i = 0;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! (i < nbBytes)) {
#line 156
      goto while_break;
    }
    {
#line 157
    wmove(stdscr, i / lineLength, 0);
#line 158
    displayLine(i, nbBytes);
#line 156
    i += lineLength;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 160
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 160
    if (! (i < page)) {
#line 160
      goto while_break___0;
    }
    {
#line 162
    wmove(stdscr, i / lineLength, 0);
#line 163
    j = 0;
    }
    {
#line 163
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 163
      if (! (j < colsUsed)) {
#line 163
        goto while_break___1;
      }
      {
#line 163
      printw(" ");
#line 163
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 164
    wmove(stdscr, i / lineLength, 0);
    }
    {
#line 165
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 165
      if ((unsigned long )oldattr != 0UL) {
#line 165
        if (stdscr) {
#line 165
          stdscr->_attrs = 0UL;
        }
#line 165
        oldattr = 0;
      }
      {
#line 165
      printw("%08lX", (int )(base + (off_t )i));
      }
#line 165
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 160
    i += lineLength;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 168
  if (stdscr) {
#line 168
    stdscr->_attrs = 0UL;
  }
  {
#line 169
  wmove(stdscr, LINES - 1, 0);
#line 170
  i = 0;
  }
  {
#line 170
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 170
    if (! (i < colsUsed)) {
#line 170
      goto while_break___3;
    }
    {
#line 170
    printw("-");
#line 170
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 171
  wmove(stdscr, LINES - 1, 0);
  }
#line 172
  if (isReadOnly) {
#line 172
    i = '%';
  } else
#line 173
  if (edited) {
#line 173
    i = '*';
  } else {
#line 174
    i = '-';
  }
  {
#line 175
  printw("-%c%c  %s       --0x%llX", i, i, baseName, base + (off_t )cursor);
  }
#line 176
  if (fileSize > lastEditedLoc) {
#line 176
    tmp___0 = fileSize;
  } else {
#line 176
    tmp___0 = lastEditedLoc;
  }
#line 176
  if (tmp___0) {
    {
#line 176
    tmp = getfilesize();
#line 176
    printw("/0x%llX", tmp);
    }
  }
#line 177
  if ((unsigned int )mode == 0U) {
    {
#line 177
    printw("--sector %lld", (base + (off_t )cursor) / 512L);
    }
  }
  {
#line 179
  tmp___1 = computeCursorXCurrentPos();
#line 179
  wmove(stdscr, cursor / lineLength, tmp___1);
  }
#line 180
  return;
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/display.c"
void displayLine(int offset , int max ) 
{ 
  int i ;
  char const   *tmp ;
  chtype tmp___0 ;
  chtype tmp___1 ;
  chtype tmp___2 ;
  chtype tmp___3 ;
  chtype tmp___4 ;
  chtype tmp___5 ;
  chtype tmp___6 ;
  chtype tmp___7 ;
  chtype tmp___8 ;
  chtype tmp___9 ;
  chtype tmp___10 ;
  chtype tmp___11 ;

  {
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    if ((unsigned long )oldattr != 0UL) {
#line 186
      if (stdscr) {
#line 186
        stdscr->_attrs = 0UL;
      }
#line 186
      oldattr = 0;
    }
    {
#line 186
    printw("%08lX   ", (int )(base + (off_t )offset));
    }
#line 186
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  i = offset;
  {
#line 187
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 187
    if (! (i < offset + lineLength)) {
#line 187
      goto while_break___0;
    }
#line 188
    if (i > offset) {
      {
#line 188
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 188
        if ((unsigned long )oldattr & ~ ((unsigned long )*(bufferAttr + i) & (1UL << 18))) {
#line 188
          if (stdscr) {
#line 188
            stdscr->_attrs = ((unsigned long )*(bufferAttr + i) & (1UL << 18)) & (unsigned long )oldattr;
          }
#line 188
          oldattr = (int )((unsigned long )oldattr & ((unsigned long )*(bufferAttr + i) & (1UL << 18)));
        }
#line 188
        if ((i - offset) % blocSize) {
#line 188
          tmp = " ";
        } else {
#line 188
          tmp = "  ";
        }
        {
#line 188
        printw(tmp);
        }
#line 188
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 189
    if (i < max) {
      {
#line 190
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 190
        if (! colored) {
#line 190
          tmp___11 = (chtype )0;
        } else {
#line 190
          if ((int )*(buffer + i) == 0) {
#line 190
            tmp___10 = 1UL << 8;
          } else {
#line 190
            if ((int )*(buffer + i) < 32) {
#line 190
              tmp___9 = 2UL << 8;
            } else {
#line 190
              if ((int )*(buffer + i) >= 127) {
#line 190
                tmp___8 = 3UL << 8;
              } else {
#line 190
                tmp___8 = (chtype )0;
              }
#line 190
              tmp___9 = tmp___8;
            }
#line 190
            tmp___10 = tmp___9;
          }
#line 190
          tmp___11 = tmp___10;
        }
#line 190
        if ((unsigned long )oldattr != (tmp___11 | (unsigned long )*(bufferAttr + i))) {
#line 190
          if (stdscr) {
#line 190
            if (! colored) {
#line 190
              tmp___3 = (chtype )0;
            } else {
#line 190
              if ((int )*(buffer + i) == 0) {
#line 190
                tmp___2 = 1UL << 8;
              } else {
#line 190
                if ((int )*(buffer + i) < 32) {
#line 190
                  tmp___1 = 2UL << 8;
                } else {
#line 190
                  if ((int )*(buffer + i) >= 127) {
#line 190
                    tmp___0 = 3UL << 8;
                  } else {
#line 190
                    tmp___0 = (chtype )0;
                  }
#line 190
                  tmp___1 = tmp___0;
                }
#line 190
                tmp___2 = tmp___1;
              }
#line 190
              tmp___3 = tmp___2;
            }
#line 190
            stdscr->_attrs = tmp___3 | (unsigned long )*(bufferAttr + i);
          }
#line 190
          if (! colored) {
#line 190
            tmp___7 = (chtype )0;
          } else {
#line 190
            if ((int )*(buffer + i) == 0) {
#line 190
              tmp___6 = 1UL << 8;
            } else {
#line 190
              if ((int )*(buffer + i) < 32) {
#line 190
                tmp___5 = 2UL << 8;
              } else {
#line 190
                if ((int )*(buffer + i) >= 127) {
#line 190
                  tmp___4 = 3UL << 8;
                } else {
#line 190
                  tmp___4 = (chtype )0;
                }
#line 190
                tmp___5 = tmp___4;
              }
#line 190
              tmp___6 = tmp___5;
            }
#line 190
            tmp___7 = tmp___6;
          }
#line 190
          oldattr = (int )(tmp___7 | (unsigned long )*(bufferAttr + i));
        }
        {
#line 190
        printw("%02X", (int )*(buffer + i));
        }
#line 190
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
#line 199
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 199
        if ((unsigned long )oldattr != 0UL) {
#line 199
          if (stdscr) {
#line 199
            stdscr->_attrs = 0UL;
          }
#line 199
          oldattr = 0;
        }
        {
#line 199
        printw("  ");
        }
#line 199
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 187
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 201
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 201
    if ((unsigned long )oldattr != 0UL) {
#line 201
      if (stdscr) {
#line 201
        stdscr->_attrs = 0UL;
      }
#line 201
      oldattr = 0;
    }
    {
#line 201
    printw("  ");
    }
#line 201
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 202
  i = offset;
  {
#line 202
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 202
    if (! (i < offset + lineLength)) {
#line 202
      goto while_break___5;
    }
#line 203
    if (i >= max) {
      {
#line 203
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 203
        if ((unsigned long )oldattr != 0UL) {
#line 203
          if (stdscr) {
#line 203
            stdscr->_attrs = 0UL;
          }
#line 203
          oldattr = 0;
        }
        {
#line 203
        printw(" ");
        }
#line 203
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    } else
#line 204
    if ((int )*(buffer + i) >= 32) {
#line 204
      if ((int )*(buffer + i) < 127) {
        {
#line 204
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 204
          if (oldattr != *(bufferAttr + i)) {
#line 204
            if (stdscr) {
#line 204
              stdscr->_attrs = (attr_t )*(bufferAttr + i);
            }
#line 204
            oldattr = *(bufferAttr + i);
          }
          {
#line 204
          printw("%c", (int )*(buffer + i));
          }
#line 204
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
      } else {
#line 204
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 205
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 205
        if (oldattr != *(bufferAttr + i)) {
#line 205
          if (stdscr) {
#line 205
            stdscr->_attrs = (attr_t )*(bufferAttr + i);
          }
#line 205
          oldattr = *(bufferAttr + i);
        }
        {
#line 205
        printw(".");
        }
#line 205
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
    }
#line 202
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 207
  return;
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/display.c"
void clr_line(int line ) 
{ 


  {
  {
#line 209
  wmove(stdscr, line, 0);
#line 209
  wclrtoeol(stdscr);
  }
#line 209
  return;
}
}
#line 211 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/display.c"
void displayCentered(char *msg , int line ) 
{ 
  size_t tmp ;

  {
  {
#line 213
  clr_line(line);
#line 214
  tmp = strlen((char const   *)msg);
#line 214
  wmove(stdscr, line, (int )(((size_t )COLS - tmp) / 2UL));
  }
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if ((unsigned long )oldattr != 0UL) {
#line 215
      if (stdscr) {
#line 215
        stdscr->_attrs = 0UL;
      }
#line 215
      oldattr = 0;
    }
    {
#line 215
    printw("%s", msg);
    }
#line 215
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 216
  return;
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/display.c"
void displayOneLineMessage(char *msg ) 
{ 
  int center ;

  {
  {
#line 220
  center = (page / lineLength) / 2;
#line 221
  clr_line(center - 1);
#line 222
  clr_line(center + 1);
#line 223
  displayCentered(msg, center);
  }
#line 224
  return;
}
}
#line 226 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/display.c"
void displayTwoLineMessage(char *msg1 , char *msg2 ) 
{ 
  int center ;

  {
  {
#line 228
  center = (page / lineLength) / 2;
#line 229
  clr_line(center - 2);
#line 230
  clr_line(center + 1);
#line 231
  displayCentered(msg1, center - 1);
#line 232
  displayCentered(msg2, center);
  }
#line 233
  return;
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/display.c"
void displayMessageAndWaitForKey(char *msg ) 
{ 


  {
  {
#line 237
  displayTwoLineMessage(msg, (char *)"(press any key)");
#line 238
  wgetch(stdscr);
  }
#line 239
  return;
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/display.c"
int displayMessageAndGetString(char *msg , char **last , char *p , int p_size ) 
{ 
  int ret ;

  {
  {
#line 243
  ret = 1;
#line 245
  displayOneLineMessage(msg);
#line 246
  ungetstr(*last);
#line 247
  echo();
#line 248
  wgetnstr(stdscr, p, p_size - 1);
#line 249
  noecho();
  }
#line 250
  if ((int )*p == 0) {
#line 251
    if (*last) {
      {
#line 251
      strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)*last);
      }
    } else {
#line 251
      ret = 0;
    }
  } else {
#line 253
    if (*last) {
      {
#line 253
      free((void *)*last);
      }
    }
    {
#line 254
    *last = strdup((char const   *)p);
    }
  }
#line 256
  return (ret);
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/display.c"
void ungetstr(char *s ) 
{ 
  char *p ;
  size_t tmp ;

  {
#line 262
  if (s) {
    {
#line 263
    tmp = strlen((char const   *)s);
#line 263
    p = (s + tmp) - 1;
    }
    {
#line 263
    while (1) {
      while_continue: /* CIL Label */ ;
#line 263
      if (! ((unsigned long )p >= (unsigned long )s)) {
#line 263
        goto while_break;
      }
      {
#line 263
      ungetch((int )*p);
#line 263
      p --;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 264
  return;
}
}
#line 266 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/display.c"
int get_number(off_t *i ) 
{ 
  int err ;
  char tmp[4096] ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 270
  echo();
#line 271
  wgetnstr(stdscr, tmp, 4095);
#line 272
  noecho();
#line 273
  tmp___1 = strbeginswith((char const   *)(tmp), "0x");
  }
#line 273
  if (tmp___1) {
    {
#line 274
    tmp___0 = strlen("0x");
#line 274
    err = sscanf((char const   */* __restrict  */)(tmp + tmp___0), (char const   */* __restrict  */)"%llx",
                 i);
    }
  } else {
    {
#line 276
    err = sscanf((char const   */* __restrict  */)(tmp), (char const   */* __restrict  */)"%lld",
                 i);
    }
  }
#line 277
  return (err == 1);
}
}
#line 846 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 214
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 176 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
void markSelectedRegion(void) ;
#line 200
int is_file(char *name ) ;
#line 206
void LSEEK(int fd___0 , off_t where ) ;
#line 207
int LSEEK_(int fd___0 , off_t where ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/file.c"
void openFile(void) 
{ 
  struct stat st ;
  int tmp ;
  unsigned long i ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 23
  tmp = is_file(fileName);
  }
#line 23
  if (! tmp) {
    {
#line 24
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: Not a file.\n",
            progName, fileName);
#line 25
    exit(1);
    }
  }
  {
#line 29
  fd = open((char const   *)fileName, 2);
  }
#line 29
  if (fd == -1) {
    {
#line 30
    isReadOnly = 1;
#line 31
    fd = open((char const   *)fileName, 0);
    }
#line 31
    if (fd == -1) {
#line 32
      if (page) {
        {
#line 32
        exitCurses();
        }
      }
#line 33
      if ((int )*(fileName + 0) == 45) {
        {
#line 33
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)usage,
                progName);
#line 33
        exit(1);
        }
      }
      {
#line 34
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
              progName);
#line 35
      perror((char const   *)fileName);
#line 36
      exit(1);
      }
    }
  } else {
#line 38
    isReadOnly = 0;
  }
  {
#line 39
  baseName = __xpg_basename(fileName);
#line 40
  mark_set = (off_t )0;
#line 41
  cursorOffset = 0;
#line 41
  cursor = cursorOffset;
#line 41
  base = (off_t )cursor;
#line 41
  lastEditedLoc = base;
#line 44
  tmp___1 = fstat(fd, & st);
  }
#line 44
  if (tmp___1 != -1) {
#line 44
    if (st.st_size > 0L) {
#line 45
      fileSize = st.st_size;
    } else {
#line 44
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 49
    tmp___0 = ioctl(fd, (unsigned long )((unsigned int )(18 << 8) | 96U), & i);
    }
#line 49
    if (tmp___0 == 0) {
#line 50
      fileSize = (off_t )i * 512L;
    } else {
#line 53
      fileSize = (off_t )0;
    }
  }
#line 55
  biggestLoc = fileSize;
#line 56
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/file.c"
void readFile(void) 
{ 
  typePage *p ;
  off_t i ;
  ssize_t tmp ;
  off_t tmp___0 ;

  {
  {
#line 63
  memset((void *)buffer, 0, (unsigned long )page * sizeof(*buffer));
#line 65
  LSEEK(fd, base);
#line 66
  tmp = read(fd, (void *)buffer, (size_t )page);
#line 66
  nbBytes = (int )tmp;
  }
#line 67
  if (nbBytes < 0) {
#line 68
    nbBytes = 0;
  } else
#line 69
  if (nbBytes) {
#line 69
    if (base + (off_t )nbBytes > biggestLoc) {
#line 70
      biggestLoc = base + (off_t )nbBytes;
    }
  }
  {
#line 71
  memset((void *)bufferAttr, 0, (unsigned long )page * sizeof(*bufferAttr));
#line 72
  p = edited;
  }
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 72
    if (! p) {
#line 72
      goto while_break;
    }
#line 73
    if (base > p->base) {
#line 73
      i = base;
    } else {
#line 73
      i = p->base;
    }
    {
#line 73
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 73
      if (p->base + (off_t )p->size < base + (off_t )page) {
#line 73
        tmp___0 = p->base + (off_t )p->size;
      } else {
#line 73
        tmp___0 = base + (off_t )page;
      }
#line 73
      if (! (i < tmp___0)) {
#line 73
        goto while_break___0;
      }
#line 74
      if ((int )*(buffer + (i - base)) != (int )*(p->vals + (i - p->base))) {
#line 75
        *(buffer + (i - base)) = *(p->vals + (i - p->base));
#line 76
        *(bufferAttr + (i - base)) = (int )((unsigned long )*(bufferAttr + (i - base)) | (1UL << 21));
      }
#line 73
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 79
    if (p->base + (off_t )p->size > base + (off_t )nbBytes) {
      {
#line 80
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 80
        if (p->base + (off_t )p->size > base + (off_t )nbBytes) {
#line 80
          if (! (nbBytes < page)) {
#line 80
            goto while_break___1;
          }
        } else {
#line 80
          goto while_break___1;
        }
#line 81
        *(bufferAttr + nbBytes) = (int )((unsigned long )*(bufferAttr + nbBytes) | (1UL << 21));
#line 80
        nbBytes ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 72
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  if (mark_set) {
    {
#line 84
    markSelectedRegion();
    }
  }
#line 86
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/file.c"
int findFile(void) 
{ 
  char *p ;
  char tmp[4096] ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 91
  if (lastFindFile) {
    {
#line 91
    tmp___0 = strdup((char const   *)lastFindFile);
#line 91
    p = tmp___0;
    }
  } else {
#line 91
    p = (char *)((void *)0);
  }
  {
#line 92
  tmp___1 = displayMessageAndGetString((char *)"File name: ", & p, tmp, (int )sizeof(tmp));
  }
#line 92
  if (! tmp___1) {
#line 92
    return (0);
  }
  {
#line 93
  tmp___2 = is_file(tmp);
  }
#line 93
  if (! tmp___2) {
#line 93
    return (0);
  }
#line 94
  if (lastFindFile) {
    {
#line 94
    free((void *)lastFindFile);
    }
  }
#line 94
  lastFindFile = fileName;
#line 95
  fileName = p;
#line 96
  return (1);
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/file.c"
off_t getfilesize(void) 
{ 
  off_t tmp ;

  {
#line 102
  if (lastEditedLoc > biggestLoc) {
#line 102
    tmp = lastEditedLoc;
  } else {
#line 102
    tmp = biggestLoc;
  }
#line 102
  return (tmp);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/file.c"
int tryloc(off_t loc ) 
{ 
  char c ;
  int tmp ;
  ssize_t tmp___0 ;

  {
#line 115
  if (loc < 0L) {
#line 116
    return (0);
  }
#line 117
  if (loc <= lastEditedLoc) {
#line 118
    return (1);
  }
#line 120
  if (loc <= biggestLoc) {
#line 121
    return (1);
  }
  {
#line 123
  tmp = LSEEK_(fd, loc - 1L);
  }
#line 123
  if (tmp != -1) {
    {
#line 123
    tmp___0 = read(fd, (void *)(& c), (size_t )1);
    }
#line 123
    if (tmp___0 == 1L) {
#line 125
      biggestLoc = loc;
#line 126
      return (1);
    }
  }
#line 128
  return (0);
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/file.c"
int is_file(char *name ) 
{ 
  struct stat st ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 134
  tmp = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& st));
  }
#line 134
  if (tmp != -1) {
#line 134
    if (! ((st.st_mode & 61440U) == 16384U)) {
#line 134
      tmp___0 = 1;
    } else {
#line 134
      tmp___0 = 0;
    }
  } else {
#line 134
    tmp___0 = 0;
  }
#line 134
  return (tmp___0);
}
}
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 1016
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ftruncate)(int __fd ,
                                                                                __off_t __length ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 102 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 123 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
int ask_about_save(void) ;
#line 124
int ask_about_save_and_redisplay(void) ;
#line 125
void ask_about_save_and_quit(void) ;
#line 126
int setTo(int c ) ;
#line 127
void setToChar(int i , unsigned char c ) ;
#line 134
void removeFromEdited(off_t base___0 , int size ) ;
#line 136
void freePage(typePage *page___0 ) ;
#line 167
void search_forward(void) ;
#line 168
void search_backward(void) ;
#line 177
void unmarkAll(void) ;
#line 178
void markIt(int i ) ;
#line 180
void copy_region(void) ;
#line 181
void yank(void) ;
#line 182
void yank_to_a_file(void) ;
#line 183
void fill_with_string(void) ;
#line 193
int setLowBits(int p , int val ) ;
#line 194
int setHighBits(int p , int val ) ;
#line 196
int hexCharToInt(int c ) ;
#line 197
int not(int b ) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/interact.c"
static void goto_char(void) ;
#line 21
static void goto_sector(void) ;
#line 22
static void save_buffer(void) ;
#line 23
static void escaped_command(void) ;
#line 24
static void help(void) ;
#line 25
static void short_help(void) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/interact.c"
static void forward_char(void) 
{ 


  {
#line 34
  if (! hexOrAscii) {
    {
#line 35
    move_cursor((off_t )1);
    }
  } else
#line 34
  if (cursorOffset) {
    {
#line 35
    move_cursor((off_t )1);
    }
  }
#line 36
  if (hexOrAscii) {
#line 36
    cursorOffset = (cursorOffset + 1) % 2;
  }
#line 37
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/interact.c"
static void backward_char(void) 
{ 


  {
#line 41
  if (! hexOrAscii) {
    {
#line 42
    move_cursor((off_t )-1);
    }
  } else
#line 41
  if (! cursorOffset) {
    {
#line 42
    move_cursor((off_t )-1);
    }
  }
#line 43
  if (hexOrAscii) {
#line 43
    cursorOffset = (cursorOffset + 1) % 2;
  }
#line 44
  return;
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/interact.c"
static void next_line(void) 
{ 


  {
  {
#line 48
  move_cursor((off_t )lineLength);
  }
#line 49
  return;
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/interact.c"
static void previous_line(void) 
{ 


  {
  {
#line 53
  move_cursor((off_t )(- lineLength));
  }
#line 54
  return;
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/interact.c"
static void forward_chars(void) 
{ 


  {
  {
#line 58
  move_cursor((off_t )blocSize);
  }
#line 59
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/interact.c"
static void backward_chars(void) 
{ 


  {
  {
#line 63
  move_cursor((off_t )(- blocSize));
  }
#line 64
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/interact.c"
static void next_lines(void) 
{ 


  {
  {
#line 68
  move_cursor((off_t )(lineLength * blocSize));
  }
#line 69
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/interact.c"
static void previous_lines(void) 
{ 


  {
  {
#line 73
  move_cursor((off_t )(- lineLength * blocSize));
  }
#line 74
  return;
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/interact.c"
static void beginning_of_line(void) 
{ 


  {
  {
#line 78
  cursorOffset = 0;
#line 79
  move_cursor((off_t )(- (cursor % lineLength)));
  }
#line 80
  return;
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/interact.c"
static void end_of_line(void) 
{ 
  int tmp ;

  {
  {
#line 84
  cursorOffset = 0;
#line 85
  tmp = move_cursor((off_t )((lineLength - 1) - cursor % lineLength));
  }
#line 85
  if (! tmp) {
    {
#line 86
    move_cursor((off_t )(nbBytes - cursor));
    }
  }
#line 87
  return;
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/interact.c"
static void scroll_up(void) 
{ 


  {
  {
#line 91
  move_base((off_t )page);
  }
#line 93
  if (mark_set) {
    {
#line 94
    updateMarked();
    }
  }
#line 95
  return;
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/interact.c"
static void scroll_down(void) 
{ 


  {
  {
#line 99
  move_base((off_t )(- page));
  }
#line 101
  if (mark_set) {
    {
#line 102
    updateMarked();
    }
  }
#line 103
  return;
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/interact.c"
static void beginning_of_buffer(void) 
{ 


  {
  {
#line 107
  cursorOffset = 0;
#line 108
  set_cursor((off_t )0);
  }
#line 109
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/interact.c"
static void end_of_buffer(void) 
{ 
  off_t s ;
  off_t tmp ;
  off_t tmp___0 ;

  {
  {
#line 113
  tmp = getfilesize();
#line 113
  s = tmp;
#line 114
  cursorOffset = 0;
  }
#line 115
  if ((unsigned int )mode == 0U) {
    {
#line 115
    tmp___0 = myfloor(s, (off_t )page);
#line 115
    set_base(tmp___0);
    }
  }
  {
#line 116
  set_cursor(s);
  }
#line 117
  return;
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/interact.c"
static void suspend(void) 
{ 
  __pid_t tmp ;

  {
  {
#line 119
  tmp = getpid();
#line 119
  kill(tmp, 20);
  }
#line 119
  return;
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/interact.c"
static void undo(void) 
{ 


  {
  {
#line 120
  discardEdited();
#line 120
  readFile();
  }
#line 120
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/interact.c"
static void quoted_insert(void) 
{ 
  int tmp ;

  {
  {
#line 121
  tmp = wgetch(stdscr);
#line 121
  setTo(tmp);
  }
#line 121
  return;
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/interact.c"
static void toggle(void) 
{ 


  {
#line 122
  hexOrAscii = (hexOrAscii + 1) % 2;
#line 122
  return;
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/interact.c"
static void recenter(void) 
{ 


  {
#line 126
  if (cursor) {
    {
#line 127
    base += (off_t )cursor;
#line 128
    cursor = 0;
#line 129
    readFile();
    }
  }
#line 131
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/interact.c"
static void find_file(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 135
  tmp = ask_about_save_and_redisplay();
  }
#line 135
  if (! tmp) {
#line 135
    return;
  }
  {
#line 136
  tmp___0 = findFile();
  }
#line 136
  if (! tmp___0) {
    {
#line 136
    displayMessageAndWaitForKey((char *)"No such file or directory");
    }
#line 136
    return;
  }
  {
#line 137
  openFile();
#line 138
  readFile();
  }
#line 139
  return;
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/interact.c"
static void redisplay(void) 
{ 


  {
  {
#line 141
  wclear(stdscr);
  }
#line 141
  return;
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/interact.c"
static void delete_backward_char(void) 
{ 
  int tmp ;

  {
  {
#line 145
  backward_char();
#line 146
  removeFromEdited(base + (off_t )cursor, 1);
#line 147
  readFile();
#line 148
  cursorOffset = 0;
#line 149
  tmp = tryloc(base + (off_t )cursor);
  }
#line 149
  if (! tmp) {
    {
#line 149
    end_of_buffer();
    }
  }
#line 150
  return;
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/interact.c"
static void delete_backward_chars(void) 
{ 
  int tmp ;

  {
  {
#line 154
  backward_chars();
#line 155
  removeFromEdited(base + (off_t )cursor, blocSize);
#line 156
  readFile();
#line 157
  cursorOffset = 0;
#line 158
  tmp = tryloc(base + (off_t )cursor);
  }
#line 158
  if (! tmp) {
    {
#line 158
    end_of_buffer();
    }
  }
#line 159
  return;
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/interact.c"
static void truncate_file(void) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 163
  displayOneLineMessage((char *)"Really truncate here? (y/N)");
#line 164
  tmp___2 = wgetch(stdscr);
#line 164
  tmp___3 = tolower(tmp___2);
  }
#line 164
  if (tmp___3 == 121) {
#line 165
    if (biggestLoc > base + (off_t )cursor) {
      {
#line 165
      tmp___1 = ftruncate(fd, base + (off_t )cursor);
      }
#line 165
      if (tmp___1 == -1) {
        {
#line 166
        tmp = __errno_location();
#line 166
        tmp___0 = strerror(*tmp);
#line 166
        displayMessageAndWaitForKey(tmp___0);
        }
      } else {
#line 165
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 168
      removeFromEdited(base + (off_t )cursor, (int )(lastEditedLoc - (base + (off_t )cursor)));
      }
#line 169
      if (mark_set) {
#line 170
        if (mark_min >= base + (off_t )cursor) {
          {
#line 171
          unmarkAll();
          }
        } else
#line 170
        if (mark_max >= base + (off_t )cursor) {
          {
#line 171
          unmarkAll();
          }
        }
      }
#line 173
      if (biggestLoc > base + (off_t )cursor) {
#line 174
        biggestLoc = base + (off_t )cursor;
      }
      {
#line 175
      readFile();
      }
    }
  }
#line 178
  return;
}
}
#line 180 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/interact.c"
static void firstTimeHelp(void) 
{ 
  int firstTime ;

  {
#line 182
  firstTime = 1;
#line 184
  if (firstTime) {
    {
#line 185
    firstTime = 0;
#line 186
    short_help();
    }
  }
#line 188
  return;
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/interact.c"
static void set_mark_command(void) 
{ 
  int tmp ;

  {
  {
#line 192
  unmarkAll();
#line 193
  tmp = not((int )mark_set);
#line 193
  mark_set = (off_t )tmp;
  }
#line 193
  if (mark_set) {
    {
#line 194
    markIt(cursor);
#line 195
    mark_max = base + (off_t )cursor;
#line 195
    mark_min = mark_max;
    }
  }
#line 197
  return;
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/interact.c"
int setTo(int c ) 
{ 
  int val ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 204
  if (cursor > nbBytes) {
#line 204
    return (0);
  }
#line 205
  if (hexOrAscii) {
    {
#line 206
    tmp = __ctype_b_loc();
    }
#line 206
    if (! ((int const   )*(*tmp + c) & 4096)) {
#line 206
      return (0);
    }
    {
#line 207
    val = hexCharToInt(c);
    }
#line 208
    if (cursorOffset) {
      {
#line 208
      tmp___0 = setLowBits((int )*(buffer + cursor), val);
#line 208
      val = tmp___0;
      }
    } else {
      {
#line 208
      tmp___1 = setHighBits((int )*(buffer + cursor), val);
#line 208
      val = tmp___1;
      }
    }
  } else {
#line 210
    val = c;
  }
#line 212
  if (isReadOnly) {
    {
#line 213
    displayMessageAndWaitForKey((char *)"File is read-only!");
    }
  } else {
    {
#line 215
    setToChar(cursor, (unsigned char )val);
#line 216
    forward_char();
    }
  }
#line 218
  return (1);
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/interact.c"
int ask_about_save(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 229
  if (edited) {
    {
#line 230
    displayOneLineMessage((char *)"Save changes (Yes/No/Cancel) ?");
#line 232
    tmp = wgetch(stdscr);
#line 232
    tmp___0 = tolower(tmp);
    }
    {
#line 234
    if (tmp___0 == 121) {
#line 234
      goto case_121;
    }
#line 235
    if (tmp___0 == 110) {
#line 235
      goto case_110;
    }
#line 237
    goto switch_default;
    case_121: /* CIL Label */ 
    {
#line 234
    save_buffer();
    }
#line 234
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 235
    discardEdited();
    }
#line 235
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 238
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 240
    return (1);
  }
#line 242
  return (-1);
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/interact.c"
int ask_about_save_and_redisplay(void) 
{ 
  int b ;
  int tmp ;

  {
  {
#line 247
  tmp = ask_about_save();
#line 247
  b = tmp;
  }
#line 248
  if (b == 1) {
    {
#line 249
    readFile();
#line 250
    display();
    }
  }
#line 252
  return (b);
}
}
#line 255 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/interact.c"
void ask_about_save_and_quit(void) 
{ 
  int tmp ;

  {
  {
#line 257
  tmp = ask_about_save();
  }
#line 257
  if (tmp) {
    {
#line 257
    quit();
    }
  }
#line 258
  return;
}
}
#line 260 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/interact.c"
static void goto_char(void) 
{ 
  off_t i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 264
  displayOneLineMessage((char *)"New position ? ");
#line 265
  ungetstr((char *)"0x");
#line 266
  tmp = get_number(& i);
  }
#line 266
  if (tmp) {
    {
#line 266
    tmp___0 = set_cursor(i);
    }
#line 266
    if (! tmp___0) {
      {
#line 266
      displayMessageAndWaitForKey((char *)"Invalid position!");
      }
    }
  } else {
    {
#line 266
    displayMessageAndWaitForKey((char *)"Invalid position!");
    }
  }
#line 267
  return;
}
}
#line 269 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/interact.c"
static void goto_sector(void) 
{ 
  off_t i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 273
  displayOneLineMessage((char *)"New sector ? ");
#line 274
  tmp = get_number(& i);
  }
#line 274
  if (tmp) {
    {
#line 274
    tmp___0 = set_base(i * 512L);
    }
#line 274
    if (tmp___0) {
      {
#line 275
      set_cursor(i * 512L);
      }
    } else {
      {
#line 277
      displayMessageAndWaitForKey((char *)"Invalid sector!");
      }
    }
  } else {
    {
#line 277
    displayMessageAndWaitForKey((char *)"Invalid sector!");
    }
  }
#line 278
  return;
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/interact.c"
static void save_buffer(void) 
{ 
  int displayedmessage ;
  typePage *p ;
  typePage *q ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;
  off_t tmp___3 ;

  {
#line 284
  displayedmessage = 0;
#line 286
  p = edited;
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 286
    if (! p) {
#line 286
      goto while_break;
    }
    {
#line 287
    tmp___1 = LSEEK_(fd, p->base);
    }
#line 287
    if (tmp___1 == -1) {
#line 287
      goto _L;
    } else {
      {
#line 287
      tmp___2 = write(fd, (void const   *)p->vals, (size_t )p->size);
      }
#line 287
      if (tmp___2 == -1L) {
        _L: /* CIL Label */ 
#line 288
        if (! displayedmessage) {
          {
#line 289
          tmp = __errno_location();
#line 289
          tmp___0 = strerror(*tmp);
#line 289
          displayMessageAndWaitForKey(tmp___0);
#line 290
          displayedmessage = 1;
          }
        }
      }
    }
    {
#line 292
    q = p->next;
#line 293
    freePage(p);
#line 286
    p = q;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 295
  edited = (typePage *)((void *)0);
#line 296
  if (lastEditedLoc > fileSize) {
#line 296
    fileSize = lastEditedLoc;
  }
  {
#line 297
  lastEditedLoc = (off_t )0;
#line 298
  memset((void *)bufferAttr, 0, (unsigned long )page * sizeof(*bufferAttr));
  }
#line 299
  if (displayedmessage) {
    {
#line 300
    displayMessageAndWaitForKey((char *)"Unwritten changes have been discarded");
#line 301
    readFile();
    }
#line 302
    if (cursor > nbBytes) {
      {
#line 302
      tmp___3 = getfilesize();
#line 302
      set_cursor(tmp___3);
      }
    }
  }
#line 304
  if (mark_set) {
    {
#line 304
    markSelectedRegion();
    }
  }
#line 305
  return;
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/interact.c"
static void help(void) 
{ 
  char *args[3] ;
  int status ;
  __pid_t tmp ;

  {
  {
#line 312
  args[0] = (char *)"man";
#line 313
  args[1] = (char *)"hexedit";
#line 314
  args[2] = (char *)((void *)0);
#line 315
  endwin();
#line 316
  tmp = fork();
  }
#line 316
  if (tmp == 0) {
    {
#line 317
    execvp((char const   *)args[0], (char * const  *)(args));
#line 318
    exit(1);
    }
  }
  {
#line 320
  wait((union wait *)(& status));
#line 321
  wrefresh(stdscr);
#line 322
  raw();
  }
#line 323
  return;
}
}
#line 325 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/interact.c"
static void short_help(void) 
{ 


  {
  {
#line 327
  displayMessageAndWaitForKey((char *)"Unknown command, press F1 for help");
  }
#line 328
  return;
}
}
#line 335 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/interact.c"
int key_to_function(int key ) 
{ 
  int tmp ;

  {
#line 337
  oldcursor = cursor;
#line 338
  oldcursorOffset = cursorOffset;
#line 339
  oldbase = base;
  {
#line 345
  if (key == 6) {
#line 345
    goto case_6;
  }
#line 345
  if (key == 261) {
#line 345
    goto case_6;
  }
#line 350
  if (key == 2) {
#line 350
    goto case_2;
  }
#line 350
  if (key == 260) {
#line 350
    goto case_2;
  }
#line 355
  if (key == 14) {
#line 355
    goto case_14;
  }
#line 355
  if (key == 258) {
#line 355
    goto case_14;
  }
#line 360
  if (key == 16) {
#line 360
    goto case_16;
  }
#line 360
  if (key == 259) {
#line 360
    goto case_16;
  }
#line 364
  if (key == 230) {
#line 364
    goto case_230;
  }
#line 368
  if (key == 226) {
#line 368
    goto case_226;
  }
#line 372
  if (key == 238) {
#line 372
    goto case_238;
  }
#line 376
  if (key == 240) {
#line 376
    goto case_240;
  }
#line 381
  if (key == 262) {
#line 381
    goto case_262;
  }
#line 381
  if (key == 1) {
#line 381
    goto case_262;
  }
#line 386
  if (key == 360) {
#line 386
    goto case_360;
  }
#line 386
  if (key == 5) {
#line 386
    goto case_360;
  }
#line 392
  if (key == 270) {
#line 392
    goto case_270;
  }
#line 392
  if (key == 22) {
#line 392
    goto case_270;
  }
#line 392
  if (key == 338) {
#line 392
    goto case_270;
  }
#line 398
  if (key == 269) {
#line 398
    goto case_269;
  }
#line 398
  if (key == 246) {
#line 398
    goto case_269;
  }
#line 398
  if (key == 339) {
#line 398
    goto case_269;
  }
#line 403
  if (key == 188) {
#line 403
    goto case_188;
  }
#line 403
  if (key == 60) {
#line 403
    goto case_188;
  }
#line 408
  if (key == 190) {
#line 408
    goto case_190;
  }
#line 408
  if (key == 62) {
#line 408
    goto case_190;
  }
#line 413
  if (key == 26) {
#line 413
    goto case_26;
  }
#line 413
  if (key == 407) {
#line 413
    goto case_26;
  }
#line 418
  if (key == 31) {
#line 418
    goto case_31;
  }
#line 418
  if (key == 21) {
#line 418
    goto case_31;
  }
#line 422
  if (key == 17) {
#line 422
    goto case_17;
  }
#line 427
  if (key == 9) {
#line 427
    goto case_9;
  }
#line 427
  if (key == 20) {
#line 427
    goto case_9;
  }
#line 432
  if (key == 19) {
#line 432
    goto case_19;
  }
#line 432
  if (key == 47) {
#line 432
    goto case_19;
  }
#line 436
  if (key == 18) {
#line 436
    goto case_18;
  }
#line 441
  if (key == 268) {
#line 441
    goto case_268;
  }
#line 441
  if (key == 7) {
#line 441
    goto case_268;
  }
#line 445
  if (key == 236) {
#line 445
    goto case_236;
  }
#line 451
  if (key == 343) {
#line 451
    goto case_343;
  }
#line 451
  if (key == 13) {
#line 451
    goto case_343;
  }
#line 451
  if (key == 10) {
#line 451
    goto case_343;
  }
#line 456
  if (key == 266) {
#line 456
    goto case_266;
  }
#line 456
  if (key == 23) {
#line 456
    goto case_266;
  }
#line 460
  if (key == 27) {
#line 460
    goto case_27;
  }
#line 465
  if (key == 232) {
#line 465
    goto case_232;
  }
#line 465
  if (key == 265) {
#line 465
    goto case_232;
  }
#line 470
  if (key == 15) {
#line 470
    goto case_15;
  }
#line 470
  if (key == 267) {
#line 470
    goto case_15;
  }
#line 474
  if (key == 12) {
#line 474
    goto case_12;
  }
#line 479
  if (key == 263) {
#line 479
    goto case_263;
  }
#line 479
  if (key == 8) {
#line 479
    goto case_263;
  }
#line 483
  if (key == 136) {
#line 483
    goto case_136;
  }
#line 488
  if (key == 273) {
#line 488
    goto case_273;
  }
#line 488
  if (key == 0) {
#line 488
    goto case_273;
  }
#line 496
  if (key == 127) {
#line 496
    goto case_127;
  }
#line 496
  if (key == 271) {
#line 496
    goto case_127;
  }
#line 496
  if (key == 330) {
#line 496
    goto case_127;
  }
#line 496
  if (key == 247) {
#line 496
    goto case_127;
  }
#line 496
  if (key == 4) {
#line 496
    goto case_127;
  }
#line 502
  if (key == 272) {
#line 502
    goto case_272;
  }
#line 502
  if (key == 331) {
#line 502
    goto case_272;
  }
#line 502
  if (key == 25) {
#line 502
    goto case_272;
  }
#line 507
  if (key == 275) {
#line 507
    goto case_275;
  }
#line 507
  if (key == 249) {
#line 507
    goto case_275;
  }
#line 512
  if (key == 233) {
#line 512
    goto case_233;
  }
#line 512
  if (key == 276) {
#line 512
    goto case_233;
  }
#line 516
  if (key == 3) {
#line 516
    goto case_3;
  }
#line 520
  if (key == 244) {
#line 520
    goto case_244;
  }
#line 526
  if (key == 24) {
#line 526
    goto case_24;
  }
#line 526
  if (key == 274) {
#line 526
    goto case_24;
  }
#line 526
  if (key == 264) {
#line 526
    goto case_24;
  }
#line 530
  goto switch_default;
  case_6: /* CIL Label */ 
  case_261: /* CIL Label */ 
  {
#line 346
  forward_char();
  }
#line 347
  goto switch_break;
  case_2: /* CIL Label */ 
  case_260: /* CIL Label */ 
  {
#line 351
  backward_char();
  }
#line 352
  goto switch_break;
  case_14: /* CIL Label */ 
  case_258: /* CIL Label */ 
  {
#line 356
  next_line();
  }
#line 357
  goto switch_break;
  case_16: /* CIL Label */ 
  case_259: /* CIL Label */ 
  {
#line 361
  previous_line();
  }
#line 362
  goto switch_break;
  case_230: /* CIL Label */ 
  {
#line 365
  forward_chars();
  }
#line 366
  goto switch_break;
  case_226: /* CIL Label */ 
  {
#line 369
  backward_chars();
  }
#line 370
  goto switch_break;
  case_238: /* CIL Label */ 
  {
#line 373
  next_lines();
  }
#line 374
  goto switch_break;
  case_240: /* CIL Label */ 
  {
#line 377
  previous_lines();
  }
#line 378
  goto switch_break;
  case_262: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 382
  beginning_of_line();
  }
#line 383
  goto switch_break;
  case_360: /* CIL Label */ 
  case_5: /* CIL Label */ 
  {
#line 387
  end_of_line();
  }
#line 388
  goto switch_break;
  case_270: /* CIL Label */ 
  case_22: /* CIL Label */ 
  case_338: /* CIL Label */ 
  {
#line 393
  scroll_up();
  }
#line 394
  goto switch_break;
  case_269: /* CIL Label */ 
  case_246: /* CIL Label */ 
  case_339: /* CIL Label */ 
  {
#line 399
  scroll_down();
  }
#line 400
  goto switch_break;
  case_188: /* CIL Label */ 
  case_60: /* CIL Label */ 
  {
#line 404
  beginning_of_buffer();
  }
#line 405
  goto switch_break;
  case_190: /* CIL Label */ 
  case_62: /* CIL Label */ 
  {
#line 409
  end_of_buffer();
  }
#line 410
  goto switch_break;
  case_26: /* CIL Label */ 
  case_407: /* CIL Label */ 
  {
#line 414
  suspend();
  }
#line 415
  goto switch_break;
  case_31: /* CIL Label */ 
  case_21: /* CIL Label */ 
  {
#line 419
  undo();
  }
#line 420
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 423
  quoted_insert();
  }
#line 424
  goto switch_break;
  case_9: /* CIL Label */ 
  case_20: /* CIL Label */ 
  {
#line 428
  toggle();
  }
#line 429
  goto switch_break;
  case_19: /* CIL Label */ 
  case_47: /* CIL Label */ 
  {
#line 433
  search_forward();
  }
#line 434
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 437
  search_backward();
  }
#line 438
  goto switch_break;
  case_268: /* CIL Label */ 
  case_7: /* CIL Label */ 
  {
#line 442
  goto_char();
  }
#line 443
  goto switch_break;
  case_236: /* CIL Label */ 
  {
#line 446
  recenter();
  }
#line 447
  goto switch_break;
  case_343: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_10: /* CIL Label */ 
#line 452
  if ((unsigned int )mode == 0U) {
    {
#line 452
    goto_sector();
    }
  } else {
    {
#line 452
    goto_char();
    }
  }
#line 453
  goto switch_break;
  case_266: /* CIL Label */ 
  case_23: /* CIL Label */ 
  {
#line 457
  save_buffer();
  }
#line 458
  goto switch_break;
  case_27: /* CIL Label */ 
  {
#line 461
  escaped_command();
  }
#line 462
  goto switch_break;
  case_232: /* CIL Label */ 
  case_265: /* CIL Label */ 
  {
#line 466
  help();
  }
#line 467
  goto switch_break;
  case_15: /* CIL Label */ 
  case_267: /* CIL Label */ 
  {
#line 471
  find_file();
  }
#line 472
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 475
  redisplay();
  }
#line 476
  goto switch_break;
  case_263: /* CIL Label */ 
  case_8: /* CIL Label */ 
  {
#line 480
  delete_backward_char();
  }
#line 481
  goto switch_break;
  case_136: /* CIL Label */ 
  {
#line 484
  delete_backward_chars();
  }
#line 485
  goto switch_break;
  case_273: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 489
  set_mark_command();
  }
#line 490
  goto switch_break;
  case_127: /* CIL Label */ 
  case_271: /* CIL Label */ 
  case_330: /* CIL Label */ 
  case_247: /* CIL Label */ 
  case_4: /* CIL Label */ 
  {
#line 497
  copy_region();
  }
#line 498
  goto switch_break;
  case_272: /* CIL Label */ 
  case_331: /* CIL Label */ 
  case_25: /* CIL Label */ 
  {
#line 503
  yank();
  }
#line 504
  goto switch_break;
  case_275: /* CIL Label */ 
  case_249: /* CIL Label */ 
  {
#line 508
  yank_to_a_file();
  }
#line 509
  goto switch_break;
  case_233: /* CIL Label */ 
  case_276: /* CIL Label */ 
  {
#line 513
  fill_with_string();
  }
#line 514
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 517
  quit();
  }
#line 518
  goto switch_break;
  case_244: /* CIL Label */ 
  {
#line 521
  truncate_file();
  }
#line 522
  goto switch_break;
  case_24: /* CIL Label */ 
  case_274: /* CIL Label */ 
  case_264: /* CIL Label */ 
  {
#line 527
  ask_about_save_and_quit();
  }
#line 528
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 531
  if (key >= 256) {
    {
#line 531
    firstTimeHelp();
    }
  } else {
    {
#line 531
    tmp = setTo(key);
    }
#line 531
    if (! tmp) {
      {
#line 531
      firstTimeHelp();
      }
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 534
  return (1);
}
}
#line 539 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/interact.c"
static void escaped_command(void) 
{ 
  char tmp[4096] ;
  int c ;
  int i ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;

  {
  {
#line 544
  c = wgetch(stdscr);
  }
  {
#line 548
  if (c == 102) {
#line 548
    goto case_102;
  }
#line 548
  if (c == 261) {
#line 548
    goto case_102;
  }
#line 553
  if (c == 98) {
#line 553
    goto case_98;
  }
#line 553
  if (c == 260) {
#line 553
    goto case_98;
  }
#line 558
  if (c == 110) {
#line 558
    goto case_110;
  }
#line 558
  if (c == 258) {
#line 558
    goto case_110;
  }
#line 563
  if (c == 112) {
#line 563
    goto case_112;
  }
#line 563
  if (c == 259) {
#line 563
    goto case_112;
  }
#line 567
  if (c == 118) {
#line 567
    goto case_118;
  }
#line 572
  if (c == 60) {
#line 572
    goto case_60;
  }
#line 572
  if (c == 262) {
#line 572
    goto case_60;
  }
#line 577
  if (c == 62) {
#line 577
    goto case_62;
  }
#line 577
  if (c == 360) {
#line 577
    goto case_62;
  }
#line 581
  if (c == 108) {
#line 581
    goto case_108;
  }
#line 585
  if (c == 104) {
#line 585
    goto case_104;
  }
#line 589
  if (c == 8) {
#line 589
    goto case_8;
  }
#line 593
  if (c == 119) {
#line 593
    goto case_119;
  }
#line 597
  if (c == 121) {
#line 597
    goto case_121;
  }
#line 601
  if (c == 105) {
#line 601
    goto case_105;
  }
#line 605
  if (c == 116) {
#line 605
    goto case_116;
  }
#line 609
  if (c == 27) {
#line 609
    goto case_27;
  }
#line 660
  if (c == 91) {
#line 660
    goto case_91;
  }
#line 694
  goto switch_default___0;
  case_102: /* CIL Label */ 
  case_261: /* CIL Label */ 
  {
#line 549
  forward_chars();
  }
#line 550
  goto switch_break;
  case_98: /* CIL Label */ 
  case_260: /* CIL Label */ 
  {
#line 554
  backward_chars();
  }
#line 555
  goto switch_break;
  case_110: /* CIL Label */ 
  case_258: /* CIL Label */ 
  {
#line 559
  next_lines();
  }
#line 560
  goto switch_break;
  case_112: /* CIL Label */ 
  case_259: /* CIL Label */ 
  {
#line 564
  previous_lines();
  }
#line 565
  goto switch_break;
  case_118: /* CIL Label */ 
  {
#line 568
  scroll_down();
  }
#line 569
  goto switch_break;
  case_60: /* CIL Label */ 
  case_262: /* CIL Label */ 
  {
#line 573
  beginning_of_buffer();
  }
#line 574
  goto switch_break;
  case_62: /* CIL Label */ 
  case_360: /* CIL Label */ 
  {
#line 578
  end_of_buffer();
  }
#line 579
  goto switch_break;
  case_108: /* CIL Label */ 
  {
#line 582
  recenter();
  }
#line 583
  goto switch_break;
  case_104: /* CIL Label */ 
  {
#line 586
  help();
  }
#line 587
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 590
  delete_backward_chars();
  }
#line 591
  goto switch_break;
  case_119: /* CIL Label */ 
  {
#line 594
  copy_region();
  }
#line 595
  goto switch_break;
  case_121: /* CIL Label */ 
  {
#line 598
  yank_to_a_file();
  }
#line 599
  goto switch_break;
  case_105: /* CIL Label */ 
  {
#line 602
  fill_with_string();
  }
#line 603
  goto switch_break;
  case_116: /* CIL Label */ 
  {
#line 606
  truncate_file();
  }
#line 607
  goto switch_break;
  case_27: /* CIL Label */ 
  {
#line 610
  c = wgetch(stdscr);
  }
#line 611
  if (c == 79) {
    {
#line 612
    c = wgetch(stdscr);
    }
    {
#line 614
    if (c == 67) {
#line 614
      goto case_67;
    }
#line 618
    if (c == 68) {
#line 618
      goto case_68;
    }
#line 622
    if (c == 66) {
#line 622
      goto case_66;
    }
#line 626
    if (c == 65) {
#line 626
      goto case_65;
    }
#line 630
    if (c == 72) {
#line 630
      goto case_72;
    }
#line 634
    if (c == 70) {
#line 634
      goto case_70;
    }
#line 638
    if (c == 80) {
#line 638
      goto case_80;
    }
#line 642
    if (c == 81) {
#line 642
      goto case_81;
    }
#line 646
    if (c == 82) {
#line 646
      goto case_82;
    }
#line 650
    if (c == 83) {
#line 650
      goto case_83;
    }
#line 654
    goto switch_default;
    case_67: /* CIL Label */ 
    {
#line 615
    forward_chars();
    }
#line 616
    goto switch_break___0;
    case_68: /* CIL Label */ 
    {
#line 619
    backward_chars();
    }
#line 620
    goto switch_break___0;
    case_66: /* CIL Label */ 
    {
#line 623
    next_lines();
    }
#line 624
    goto switch_break___0;
    case_65: /* CIL Label */ 
    {
#line 627
    previous_lines();
    }
#line 628
    goto switch_break___0;
    case_72: /* CIL Label */ 
    {
#line 631
    beginning_of_buffer();
    }
#line 632
    goto switch_break___0;
    case_70: /* CIL Label */ 
    {
#line 635
    end_of_buffer();
    }
#line 636
    goto switch_break___0;
    case_80: /* CIL Label */ 
    {
#line 639
    help();
    }
#line 640
    goto switch_break___0;
    case_81: /* CIL Label */ 
    {
#line 643
    save_buffer();
    }
#line 644
    goto switch_break___0;
    case_82: /* CIL Label */ 
    {
#line 647
    find_file();
    }
#line 648
    goto switch_break___0;
    case_83: /* CIL Label */ 
    {
#line 651
    goto_char();
    }
#line 652
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 655
    firstTimeHelp();
    }
    switch_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 657
    firstTimeHelp();
    }
  }
#line 658
  goto switch_break;
  case_91: /* CIL Label */ 
#line 661
  i = 0;
  {
#line 661
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 661
    c = wgetch(stdscr);
#line 661
    tmp[i] = (char )c;
#line 661
    tmp___0 = __ctype_b_loc();
    }
#line 661
    if (! ((int const   )*(*tmp___0 + c) & 2048)) {
#line 661
      goto while_break;
    }
#line 661
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 662
  tmp[i + 1] = (char )'\000';
#line 665
  tmp___26 = streq((char const   *)(tmp), "2~");
  }
#line 665
  if (tmp___26) {
    {
#line 665
    yank();
    }
  } else {
    {
#line 666
    tmp___25 = streq((char const   *)(tmp), "5~");
    }
#line 666
    if (tmp___25) {
      {
#line 666
      scroll_down();
      }
    } else {
      {
#line 667
      tmp___24 = streq((char const   *)(tmp), "6~");
      }
#line 667
      if (tmp___24) {
        {
#line 667
        scroll_up();
        }
      } else {
        {
#line 668
        tmp___23 = streq((char const   *)(tmp), "7~");
        }
#line 668
        if (tmp___23) {
          {
#line 668
          beginning_of_buffer();
          }
        } else {
          {
#line 669
          tmp___22 = streq((char const   *)(tmp), "8~");
          }
#line 669
          if (tmp___22) {
            {
#line 669
            end_of_buffer();
            }
          } else {
            {
#line 670
            tmp___21 = streq((char const   *)(tmp), "010q");
            }
#line 670
            if (tmp___21) {
              {
#line 670
              ask_about_save_and_quit();
              }
            } else {
              {
#line 671
              tmp___20 = streq((char const   *)(tmp), "193z");
              }
#line 671
              if (tmp___20) {
                {
#line 671
                fill_with_string();
                }
              } else {
                {
#line 672
                tmp___19 = streq((char const   *)(tmp), "214z");
                }
#line 672
                if (tmp___19) {
                  {
#line 672
                  beginning_of_line();
                  }
                } else {
                  {
#line 673
                  tmp___18 = streq((char const   *)(tmp), "216z");
                  }
#line 673
                  if (tmp___18) {
                    {
#line 673
                    scroll_down();
                    }
                  } else {
                    {
#line 674
                    tmp___17 = streq((char const   *)(tmp), "220z");
                    }
#line 674
                    if (tmp___17) {
                      {
#line 674
                      end_of_line();
                      }
                    } else {
                      {
#line 675
                      tmp___16 = streq((char const   *)(tmp), "222z");
                      }
#line 675
                      if (tmp___16) {
                        {
#line 675
                        scroll_up();
                        }
                      } else {
                        {
#line 676
                        tmp___15 = streq((char const   *)(tmp), "233z");
                        }
#line 676
                        if (tmp___15) {
                          {
#line 676
                          ask_about_save_and_quit();
                          }
                        } else {
                          {
#line 677
                          tmp___14 = streq((char const   *)(tmp), "234z");
                          }
#line 677
                          if (tmp___14) {
                            {
#line 677
                            yank_to_a_file();
                            }
                          } else {
                            {
#line 678
                            tmp___13 = streq((char const   *)(tmp), "247z");
                            }
#line 678
                            if (tmp___13) {
                              {
#line 678
                              yank();
                              }
                            } else {
                              {
#line 679
                              tmp___12 = streq((char const   *)(tmp), "11~");
                              }
#line 679
                              if (tmp___12) {
                                {
#line 679
                                help();
                                }
                              } else {
                                {
#line 680
                                tmp___11 = streq((char const   *)(tmp), "12~");
                                }
#line 680
                                if (tmp___11) {
                                  {
#line 680
                                  save_buffer();
                                  }
                                } else {
                                  {
#line 681
                                  tmp___10 = streq((char const   *)(tmp), "13~");
                                  }
#line 681
                                  if (tmp___10) {
                                    {
#line 681
                                    find_file();
                                    }
                                  } else {
                                    {
#line 682
                                    tmp___9 = streq((char const   *)(tmp), "14~");
                                    }
#line 682
                                    if (tmp___9) {
                                      {
#line 682
                                      goto_char();
                                      }
                                    } else {
                                      {
#line 683
                                      tmp___8 = streq((char const   *)(tmp), "15~");
                                      }
#line 683
                                      if (tmp___8) {
                                        {
#line 683
                                        scroll_down();
                                        }
                                      } else {
                                        {
#line 684
                                        tmp___7 = streq((char const   *)(tmp), "17~");
                                        }
#line 684
                                        if (tmp___7) {
                                          {
#line 684
                                          scroll_up();
                                          }
                                        } else {
                                          {
#line 685
                                          tmp___6 = streq((char const   *)(tmp), "18~");
                                          }
#line 685
                                          if (tmp___6) {
                                            {
#line 685
                                            copy_region();
                                            }
                                          } else {
                                            {
#line 686
                                            tmp___5 = streq((char const   *)(tmp),
                                                            "19~");
                                            }
#line 686
                                            if (tmp___5) {
                                              {
#line 686
                                              yank();
                                              }
                                            } else {
                                              {
#line 687
                                              tmp___4 = streq((char const   *)(tmp),
                                                              "20~");
                                              }
#line 687
                                              if (tmp___4) {
                                                {
#line 687
                                                set_mark_command();
                                                }
                                              } else {
                                                {
#line 688
                                                tmp___3 = streq((char const   *)(tmp),
                                                                "21~");
                                                }
#line 688
                                                if (tmp___3) {
                                                  {
#line 688
                                                  ask_about_save_and_quit();
                                                  }
                                                } else {
                                                  {
#line 689
                                                  tmp___2 = streq((char const   *)(tmp),
                                                                  "23~");
                                                  }
#line 689
                                                  if (tmp___2) {
                                                    {
#line 689
                                                    yank_to_a_file();
                                                    }
                                                  } else {
                                                    {
#line 690
                                                    tmp___1 = streq((char const   *)(tmp),
                                                                    "24~");
                                                    }
#line 690
                                                    if (tmp___1) {
                                                      {
#line 690
                                                      fill_with_string();
                                                      }
                                                    } else {
                                                      {
#line 691
                                                      firstTimeHelp();
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 692
  goto switch_break;
  switch_default___0: /* CIL Label */ 
  {
#line 695
  firstTimeHelp();
  }
  switch_break: /* CIL Label */ ;
  }
#line 697
  return;
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 710 "/usr/include/curses.h"
extern int nodelay(WINDOW * , _Bool  ) ;
#line 198 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
char *mymemmem(char *a , int sizea , char *b , int sizeb ) ;
#line 199
char *mymemrmem(char *a , int sizea , char *b , int sizeb ) ;
#line 201
int hexStringToBinString(char *p , int *l ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/search.c"
static int searchA(char **string , int *sizea , char *tmp , int tmp_size ) ;
#line 20
static void searchB(off_t loc , char *string ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/search.c"
static int searchA(char **string , int *sizea , char *tmp , int tmp_size ) 
{ 
  char *msg ;
  char const   *tmp___0 ;
  char **last ;
  char **tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;

  {
#line 27
  if (hexOrAscii) {
#line 27
    tmp___0 = "Hexa string to search: ";
  } else {
#line 27
    tmp___0 = "Ascii string to search: ";
  }
#line 27
  msg = (char *)tmp___0;
#line 28
  if (hexOrAscii) {
#line 28
    tmp___1 = & lastAskHexString;
  } else {
#line 28
    tmp___1 = & lastAskAsciiString;
  }
  {
#line 28
  last = tmp___1;
#line 30
  tmp___2 = ask_about_save_and_redisplay();
  }
#line 30
  if (! tmp___2) {
#line 30
    return (0);
  }
  {
#line 31
  tmp___3 = displayMessageAndGetString(msg, last, tmp, tmp_size);
  }
#line 31
  if (! tmp___3) {
#line 31
    return (0);
  }
  {
#line 33
  tmp___4 = strlen((char const   *)tmp);
#line 33
  *sizea = (int )tmp___4;
  }
#line 34
  if (hexOrAscii) {
    {
#line 34
    tmp___5 = hexStringToBinString(tmp, sizea);
    }
#line 34
    if (! tmp___5) {
#line 34
      return (0);
    }
  }
  {
#line 36
  tmp___6 = malloc((size_t )*sizea);
#line 36
  *string = (char *)tmp___6;
#line 37
  memcpy((void */* __restrict  */)*string, (void const   */* __restrict  */)tmp, (size_t )*sizea);
#line 39
  nodelay(stdscr, (_Bool)1);
#line 40
  displayTwoLineMessage((char *)"searching...", (char *)"(press any key to cancel)");
  }
#line 41
  return (1);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/search.c"
static void searchB(off_t loc , char *string ) 
{ 


  {
  {
#line 46
  nodelay(stdscr, (_Bool)0);
#line 47
  free((void *)string);
  }
#line 49
  if (loc >= 0L) {
    {
#line 49
    set_cursor(loc);
    }
  } else
#line 51
  if (loc == -3L) {
    {
#line 51
    displayMessageAndWaitForKey((char *)"not found");
    }
  }
#line 53
  return;
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/search.c"
void search_forward(void) 
{ 
  char *p ;
  char *string ;
  char tmp[4096] ;
  char tmpstr[4096] ;
  int quit___0 ;
  int sizea ;
  int sizeb ;
  off_t blockstart ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  off_t tmp___4 ;

  {
  {
#line 61
  tmp___0 = searchA(& string, & sizea, tmp, (int )sizeof(tmp));
  }
#line 61
  if (! tmp___0) {
#line 61
    return;
  }
#line 62
  quit___0 = -1;
#line 63
  blockstart = ((base + (off_t )cursor) - 4096L) + (off_t )sizea;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 65
    blockstart += (off_t )((4096 - sizea) + 1);
#line 66
    tmp___1 = LSEEK_(fd, blockstart);
    }
#line 66
    if (tmp___1 == -1) {
#line 66
      quit___0 = -3;
#line 66
      goto while_break;
    }
    {
#line 67
    tmp___3 = read(fd, (void *)(tmp), (size_t )4096);
#line 67
    sizeb = (int )tmp___3;
    }
#line 67
    if (sizeb < sizea) {
#line 67
      quit___0 = -3;
    } else {
      {
#line 68
      tmp___2 = wgetch(stdscr);
      }
#line 68
      if (tmp___2 != -1) {
#line 68
        quit___0 = -2;
      } else {
        {
#line 69
        p = mymemmem(tmp, sizeb, string, sizea);
        }
#line 69
        if (p) {
#line 69
          quit___0 = (int )(p - tmp);
        }
      }
    }
    {
#line 71
    sprintf((char */* __restrict  */)(tmpstr), (char const   */* __restrict  */)"searching... 0x%08llX",
            (long long )blockstart);
#line 72
    nodelay(stdscr, (_Bool)1);
#line 73
    displayTwoLineMessage(tmpstr, (char *)"(press any key to cancel)");
    }
#line 64
    if (! (quit___0 == -1)) {
#line 64
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  if (quit___0 >= 0) {
#line 77
    tmp___4 = blockstart;
  } else {
#line 77
    tmp___4 = (off_t )0;
  }
  {
#line 77
  searchB((off_t )quit___0 + tmp___4, string);
  }
#line 78
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/search.c"
void search_backward(void) 
{ 
  char *p ;
  char *string ;
  char tmp[4096] ;
  char tmpstr[4096] ;
  int quit___0 ;
  int sizea ;
  int sizeb ;
  off_t blockstart ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  off_t tmp___4 ;

  {
  {
#line 86
  tmp___0 = searchA(& string, & sizea, tmp, (int )sizeof(tmp));
  }
#line 86
  if (! tmp___0) {
#line 86
    return;
  }
#line 87
  quit___0 = -1;
#line 88
  blockstart = ((base + (off_t )cursor) - (off_t )sizea) + 1L;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    blockstart -= (off_t )((4096 - sizea) + 1);
#line 91
    sizeb = 4096;
#line 92
    if (blockstart < 0L) {
#line 92
      sizeb = (int )((off_t )sizeb - - blockstart);
#line 92
      blockstart = (off_t )0;
    }
#line 94
    if (sizeb < sizea) {
#line 94
      quit___0 = -3;
    } else {
      {
#line 96
      tmp___1 = LSEEK_(fd, blockstart);
      }
#line 96
      if (tmp___1 == -1) {
#line 96
        quit___0 = -3;
#line 96
        goto while_break;
      }
      {
#line 97
      tmp___3 = read(fd, (void *)(tmp), (size_t )sizeb);
      }
#line 97
      if ((ssize_t )sizeb != tmp___3) {
#line 97
        quit___0 = -3;
      } else {
        {
#line 98
        tmp___2 = wgetch(stdscr);
        }
#line 98
        if (tmp___2 != -1) {
#line 98
          quit___0 = -2;
        } else {
          {
#line 99
          p = mymemrmem(tmp, sizeb, string, sizea);
          }
#line 99
          if (p) {
#line 99
            quit___0 = (int )(p - tmp);
          }
        }
      }
    }
    {
#line 102
    sprintf((char */* __restrict  */)(tmpstr), (char const   */* __restrict  */)"searching... 0x%08llX",
            (long long )blockstart);
#line 103
    nodelay(stdscr, (_Bool)1);
#line 104
    displayTwoLineMessage(tmpstr, (char *)"(press any key to cancel)");
    }
#line 89
    if (! (quit___0 == -1)) {
#line 89
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  if (quit___0 >= 0) {
#line 108
    tmp___4 = blockstart;
  } else {
#line 108
    tmp___4 = (off_t )0;
  }
  {
#line 108
  searchB((off_t )quit___0 + tmp___4, string);
  }
#line 109
  return;
}
}
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 133 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
void addToEdited(off_t base___0 , int size , unsigned char *vals ) ;
#line 135
typePage *newPage(off_t base___0 , int size ) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/page.c"
void setToChar(int i , unsigned char c ) 
{ 


  {
#line 22
  if (i >= nbBytes) {
    {
#line 23
    *(buffer + i) = c;
#line 24
    *(bufferAttr + i) = (int )((unsigned long )*(bufferAttr + i) | (1UL << 21));
#line 25
    addToEdited(base + (off_t )i, 1, & c);
#line 26
    nbBytes = i + 1;
    }
  } else
#line 27
  if ((int )*(buffer + i) != (int )c) {
    {
#line 28
    *(buffer + i) = c;
#line 29
    *(bufferAttr + i) = (int )((unsigned long )*(bufferAttr + i) | (1UL << 21));
#line 30
    addToEdited(base + (off_t )i, 1, & c);
    }
  }
#line 32
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/page.c"
void updatelastEditedLoc(void) 
{ 
  typePage *p ;

  {
#line 40
  lastEditedLoc = (off_t )0;
#line 41
  p = edited;
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
#line 41
    if (! p) {
#line 41
      goto while_break;
    }
#line 42
    if (p->base + (off_t )p->size > lastEditedLoc) {
#line 43
      lastEditedLoc = p->base + (off_t )p->size;
    }
#line 41
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 45
  return;
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/page.c"
void discardEdited(void) 
{ 
  typePage *p ;
  typePage *q ;

  {
#line 50
  p = edited;
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    if (! p) {
#line 50
      goto while_break;
    }
    {
#line 51
    q = p->next;
#line 52
    freePage(p);
#line 50
    p = q;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  edited = (typePage *)((void *)0);
#line 55
  lastEditedLoc = (off_t )0;
#line 56
  if (base + (off_t )cursor > biggestLoc) {
    {
#line 56
    set_cursor(biggestLoc);
    }
  }
#line 57
  if (mark_max >= biggestLoc) {
#line 57
    mark_max = biggestLoc - 1L;
  }
#line 58
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/page.c"
void addToEdited(off_t base___0 , int size , unsigned char *vals ) 
{ 
  typePage *p ;
  typePage *q ;
  off_t min ;
  off_t max ;
  unsigned char *s ;
  void *tmp ;
  void *tmp___0 ;
  unsigned char *s___0 ;
  void *tmp___1 ;
  typePage *r ;
  typePage *tmp___2 ;

  {
#line 62
  q = (typePage *)((void *)0);
#line 63
  p = edited;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! p) {
#line 63
      goto while_break;
    }
#line 64
    if (base___0 + (off_t )size <= p->base) {
#line 64
      goto while_break;
    }
#line 65
    if (base___0 <= p->base) {
#line 65
      if (p->base + (off_t )p->size <= base___0 + (off_t )size) {
#line 66
        if (q) {
#line 66
          q->next = p->next;
        } else {
#line 66
          edited = p->next;
        }
        {
#line 67
        freePage(p);
#line 67
        p = q;
        }
#line 68
        if ((unsigned long )q == (unsigned long )((void *)0)) {
#line 69
          p = edited;
#line 70
          goto while_break;
        }
      }
    }
#line 63
    q = p;
#line 63
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  if (q) {
#line 75
    if (base___0 <= q->base + (off_t )q->size) {
#line 75
      if (q->base <= base___0 + (off_t )size) {
#line 79
        if (q->base < base___0) {
#line 79
          min = q->base;
        } else {
#line 79
          min = base___0;
        }
#line 80
        if (p) {
#line 80
          if (base___0 + (off_t )size == p->base) {
            {
#line 81
            max = p->base + (off_t )p->size;
#line 82
            tmp = malloc((size_t )(max - min));
#line 82
            s = (unsigned char *)tmp;
#line 83
            memcpy((void */* __restrict  */)((s + q->base) - min), (void const   */* __restrict  */)q->vals,
                   (size_t )q->size);
#line 84
            memcpy((void */* __restrict  */)((s + base___0) - min), (void const   */* __restrict  */)vals,
                   (size_t )size);
#line 85
            memcpy((void */* __restrict  */)((s + p->base) - min), (void const   */* __restrict  */)p->vals,
                   (size_t )p->size);
#line 86
            free((void *)q->vals);
#line 86
            q->vals = s;
#line 87
            q->next = p->next;
#line 88
            freePage(p);
            }
          } else {
#line 80
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 90
          if (q->base + (off_t )q->size > base___0 + (off_t )size) {
#line 90
            max = q->base + (off_t )q->size;
          } else {
#line 90
            max = base___0 + (off_t )size;
          }
          {
#line 91
          tmp___0 = malloc((size_t )(max - min));
#line 91
          s = (unsigned char *)tmp___0;
#line 92
          memcpy((void */* __restrict  */)((s + q->base) - min), (void const   */* __restrict  */)q->vals,
                 (size_t )q->size);
#line 93
          memcpy((void */* __restrict  */)((s + base___0) - min), (void const   */* __restrict  */)vals,
                 (size_t )size);
#line 94
          free((void *)q->vals);
#line 94
          q->vals = s;
          }
        }
#line 96
        q->base = min;
#line 97
        q->size = (int )(max - min);
      } else {
#line 75
        goto _L___2;
      }
    } else {
#line 75
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 98
  if (p) {
#line 98
    if (base___0 + (off_t )size == p->base) {
      {
#line 99
      tmp___1 = malloc((size_t )((p->base + (off_t )p->size) - base___0));
#line 99
      s___0 = (unsigned char *)tmp___1;
#line 100
      memcpy((void */* __restrict  */)s___0, (void const   */* __restrict  */)vals,
             (size_t )size);
#line 101
      memcpy((void */* __restrict  */)((s___0 + p->base) - base___0), (void const   */* __restrict  */)p->vals,
             (size_t )p->size);
#line 102
      free((void *)p->vals);
#line 102
      p->vals = s___0;
#line 103
      p->size = (int )((p->base + (off_t )p->size) - base___0);
#line 104
      p->base = base___0;
      }
    } else {
#line 98
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 106
    tmp___2 = newPage(base___0, size);
#line 106
    r = tmp___2;
#line 107
    memcpy((void */* __restrict  */)r->vals, (void const   */* __restrict  */)vals,
           (size_t )size);
    }
#line 108
    if (q) {
#line 108
      q->next = r;
    } else {
#line 108
      edited = r;
    }
#line 109
    r->next = p;
  }
  {
#line 111
  updatelastEditedLoc();
  }
#line 112
  return;
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/page.c"
void removeFromEdited(off_t base___0 , int size ) 
{ 
  typePage *p ;
  typePage *q ;

  {
#line 116
  q = (typePage *)((void *)0);
#line 117
  p = edited;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! p) {
#line 117
      goto while_break;
    }
#line 118
    if (base___0 + (off_t )size <= p->base) {
#line 118
      goto while_break;
    }
#line 119
    if (base___0 <= p->base) {
#line 120
      if (p->base + (off_t )p->size <= base___0 + (off_t )size) {
#line 121
        if (q) {
#line 121
          q->next = p->next;
        } else {
#line 121
          edited = p->next;
        }
        {
#line 122
        freePage(p);
#line 123
        p = q;
        }
      } else {
        {
#line 125
        p->size = (int )((off_t )p->size - ((base___0 + (off_t )size) - p->base));
#line 126
        memmove((void *)p->vals, (void const   *)(((p->vals + base___0) + size) - p->base),
                (size_t )p->size);
#line 127
        p->base = base___0 + (off_t )size;
        }
      }
    } else
#line 129
    if (p->base + (off_t )p->size <= base___0 + (off_t )size) {
#line 130
      if (base___0 < p->base + (off_t )p->size) {
#line 130
        p->size = (int )((off_t )p->size - ((p->base + (off_t )p->size) - base___0));
      }
    } else {
      {
#line 132
      q = newPage(base___0 + (off_t )size, (int )(((p->base + (off_t )p->size) - base___0) - (off_t )size));
#line 133
      memcpy((void */* __restrict  */)q->vals, (void const   */* __restrict  */)(((p->vals + base___0) + size) - p->base),
             (size_t )q->size);
#line 134
      q->next = p->next;
#line 135
      p->next = q;
#line 136
      p->size = (int )((off_t )p->size - ((p->base + (off_t )p->size) - base___0));
      }
#line 137
      goto while_break;
    }
#line 117
    if (p) {
#line 117
      q = p;
#line 117
      p = p->next;
    } else {
#line 117
      q = (typePage *)((void *)0);
#line 117
      p = edited;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 140
  updatelastEditedLoc();
  }
#line 141
  return;
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/page.c"
typePage *newPage(off_t base___0 , int size ) 
{ 
  typePage *p ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 145
  tmp = malloc(sizeof(typePage ));
#line 145
  p = (typePage *)tmp;
#line 146
  p->base = base___0;
#line 147
  p->size = size;
#line 148
  tmp___0 = malloc((size_t )size);
#line 148
  p->vals = (unsigned char *)tmp___0;
  }
#line 149
  return (p);
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/page.c"
void freePage(typePage *page___0 ) 
{ 


  {
  {
#line 154
  free((void *)page___0->vals);
#line 155
  free((void *)page___0);
  }
#line 156
  return;
}
}
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 121
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memrchr)(void const   *__s ,
                                                                                                int __c ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 382
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,3), __leaf__)) memmem)(void const   *__haystack ,
                                                                                                 size_t __haystacklen ,
                                                                                                 void const   *__needle ,
                                                                                                 size_t __needlelen )  __attribute__((__pure__)) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 195 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
char *strconcat3(char *a , char *b , char *c ) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/misc.c"
int LSEEK_(int fd___0 , off_t where ) 
{ 
  off_t result ;
  int tmp ;

  {
  {
#line 24
  result = lseek(fd___0, where, 0);
  }
#line 25
  if (result == where) {
#line 25
    tmp = 1;
  } else {
#line 25
    tmp = -1;
  }
#line 25
  return (tmp);
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/misc.c"
void LSEEK(int fd___0 , off_t where ) 
{ 
  off_t result ;

  {
  {
#line 32
  result = lseek(fd___0, where, 0);
  }
#line 33
  if (result != where) {
    {
#line 34
    exitCurses();
#line 35
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"the long seek failed (%lld instead of %lld), leaving :(\n",
            (long long )result, (long long )where);
#line 36
    exit(1);
    }
  }
#line 38
  return;
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/misc.c"
int streq(char const   *s1 , char const   *s2 ) 
{ 
  int tmp ;

  {
  {
#line 75
  tmp = strcmp(s1, s2);
  }
#line 75
  return (tmp == 0);
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/misc.c"
off_t myfloor(off_t a , off_t b ) 
{ 


  {
#line 76
  return (a - a % b);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/misc.c"
int setLowBits(int p , int val ) 
{ 


  {
#line 77
  return ((p & 240) + val);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/misc.c"
int setHighBits(int p , int val ) 
{ 


  {
#line 78
  return ((p & 15) + val * 16);
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/misc.c"
int strbeginswith(char const   *a , char const   *prefix ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 82
  tmp = strlen(prefix);
#line 82
  tmp___0 = strncmp(a, prefix, tmp);
  }
#line 82
  return (tmp___0 == 0);
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/misc.c"
char *strconcat3(char *a , char *b , char *c ) 
{ 
  size_t la ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t lb ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t lc ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  char *p ;
  void *tmp___5 ;

  {
#line 87
  if (a) {
    {
#line 87
    tmp = strlen((char const   *)a);
#line 87
    tmp___0 = tmp;
    }
  } else {
#line 87
    tmp___0 = (size_t )0;
  }
#line 87
  la = tmp___0;
#line 88
  if (b) {
    {
#line 88
    tmp___1 = strlen((char const   *)b);
#line 88
    tmp___2 = tmp___1;
    }
  } else {
#line 88
    tmp___2 = (size_t )0;
  }
#line 88
  lb = tmp___2;
#line 89
  if (c) {
    {
#line 89
    tmp___3 = strlen((char const   *)c);
#line 89
    tmp___4 = tmp___3;
    }
  } else {
#line 89
    tmp___4 = (size_t )0;
  }
  {
#line 89
  lc = tmp___4;
#line 90
  tmp___5 = malloc(((la + lb) + lc) + 1UL);
#line 90
  p = (char *)tmp___5;
  }
#line 91
  if (a) {
    {
#line 91
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)a, la);
    }
  }
#line 92
  if (b) {
    {
#line 92
    memcpy((void */* __restrict  */)(p + la), (void const   */* __restrict  */)b,
           lb);
    }
  }
#line 93
  if (c) {
    {
#line 93
    memcpy((void */* __restrict  */)((p + la) + lb), (void const   */* __restrict  */)c,
           lc);
    }
  }
#line 94
  *(p + ((la + lb) + lc)) = (char )'\000';
#line 95
  return (p);
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/misc.c"
int hexCharToInt(int c ) 
{ 
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
  {
#line 100
  tmp = __ctype_b_loc();
  }
#line 100
  if ((int const   )*(*tmp + c) & 2048) {
#line 100
    return (c - 48);
  }
  {
#line 101
  tmp___0 = tolower(c);
  }
#line 101
  return ((tmp___0 - 97) + 10);
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/misc.c"
int not(int b ) 
{ 
  int tmp ;

  {
#line 104
  if (b) {
#line 104
    tmp = 0;
  } else {
#line 104
    tmp = 1;
  }
#line 104
  return (tmp);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/misc.c"
char *mymemmem(char *a , int sizea , char *b , int sizeb ) 
{ 
  void *tmp ;

  {
  {
#line 119
  tmp = memmem((void const   *)a, (size_t )sizea, (void const   *)b, (size_t )sizeb);
  }
#line 119
  return ((char *)tmp);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/misc.c"
char *mymemrmem(char *a , int sizea , char *b , int sizeb ) 
{ 
  char *p ;
  int i ;
  int tmp ;
  void *tmp___0 ;

  {
#line 142
  i = (sizea - sizeb) + 1;
#line 144
  if (i <= 0) {
#line 144
    return ((char *)((void *)0));
  }
#line 146
  a += sizea - 1;
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 147
    tmp___0 = memrchr((void const   *)((a - i) + 1), (int )*(b + (sizeb - 1)), (size_t )i);
#line 147
    p = (char *)tmp___0;
    }
#line 147
    if (! p) {
#line 147
      goto while_break;
    }
    {
#line 149
    tmp = memcmp((void const   *)((p - sizeb) + 1), (void const   *)b, (size_t )(sizeb - 1));
    }
#line 149
    if (tmp == 0) {
#line 149
      return (p);
    }
#line 147
    i = (int )((long )i - ((a - p) + 1L));
#line 147
    a = p - 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 151
  return ((char *)((void *)0));
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/misc.c"
int hexStringToBinString(char *p , int *l ) 
{ 
  int i ;
  unsigned short const   **tmp ;
  int (*tmp___0)(int p , int val ) ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 160
  i = 0;
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    if (! (i < *l)) {
#line 160
      goto while_break;
    }
    {
#line 161
    tmp = __ctype_b_loc();
    }
#line 161
    if (! ((int const   )*(*tmp + (int )*(p + i)) & 4096)) {
      {
#line 162
      displayMessageAndWaitForKey((char *)"Invalid hexa string");
      }
#line 163
      return (0);
    }
#line 165
    if (i % 2) {
#line 165
      tmp___0 = & setLowBits;
    } else {
#line 165
      tmp___0 = & setHighBits;
    }
    {
#line 165
    tmp___1 = hexCharToInt((int )*(p + i));
#line 165
    tmp___2 = (*tmp___0)((int )*(p + i / 2), tmp___1);
#line 165
    *(p + i / 2) = (char )tmp___2;
#line 160
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 168
  if (*l % 2) {
    {
#line 169
    displayMessageAndWaitForKey((char *)"Must be an even number of chars");
    }
#line 170
    return (0);
  }
#line 172
  *l /= 2;
#line 173
  return (1);
}
}
#line 192 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) creat)(char const   *__file , mode_t __mode ) ;
#line 174 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/hexedit.h"
void markRegion(off_t a , off_t b ) ;
#line 175
void unmarkRegion(off_t a , off_t b ) ;
#line 179
void unmarkIt(int i ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/mark.c"
void markRegion(off_t a , off_t b ) 
{ 
  int i ;
  off_t tmp ;

  {
#line 22
  if (a - base > 0L) {
#line 22
    i = (int )(a - base);
  } else {
#line 22
    i = 0;
  }
  {
#line 22
  while (1) {
    while_continue: /* CIL Label */ ;
#line 22
    if (b - base < (off_t )(nbBytes - 1)) {
#line 22
      tmp = b - base;
    } else {
#line 22
      tmp = (off_t )(nbBytes - 1);
    }
#line 22
    if (! ((off_t )i <= tmp)) {
#line 22
      goto while_break;
    }
    {
#line 22
    markIt(i);
#line 22
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 22
  return;
}
}
#line 23 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/mark.c"
void unmarkRegion(off_t a , off_t b ) 
{ 
  int i ;
  off_t tmp ;

  {
#line 23
  if (a - base > 0L) {
#line 23
    i = (int )(a - base);
  } else {
#line 23
    i = 0;
  }
  {
#line 23
  while (1) {
    while_continue: /* CIL Label */ ;
#line 23
    if (b - base < (off_t )(nbBytes - 1)) {
#line 23
      tmp = b - base;
    } else {
#line 23
      tmp = (off_t )(nbBytes - 1);
    }
#line 23
    if (! ((off_t )i <= tmp)) {
#line 23
      goto while_break;
    }
    {
#line 23
    unmarkIt(i);
#line 23
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 23
  return;
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/mark.c"
void markSelectedRegion(void) 
{ 


  {
  {
#line 24
  markRegion(mark_min, mark_max);
  }
#line 24
  return;
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/mark.c"
void unmarkAll(void) 
{ 


  {
  {
#line 25
  unmarkRegion(base, (base + (off_t )nbBytes) - 1L);
  }
#line 25
  return;
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/mark.c"
void markIt(int i ) 
{ 


  {
#line 26
  *(bufferAttr + i) = (int )((unsigned long )*(bufferAttr + i) | (1UL << 18));
#line 26
  return;
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/mark.c"
void unmarkIt(int i ) 
{ 


  {
#line 27
  *(bufferAttr + i) = (int )((unsigned long )*(bufferAttr + i) & ~ (1UL << 18));
#line 27
  return;
}
}
#line 29 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/mark.c"
void copy_region(void) 
{ 
  typePage *p ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  ssize_t tmp___5 ;
  off_t min ;
  off_t tmp___6 ;
  off_t tmp___7 ;
  off_t tmp___8 ;

  {
#line 33
  if (! mark_set) {
    {
#line 33
    displayMessageAndWaitForKey((char *)"Nothing to copy");
    }
#line 33
    return;
  }
#line 34
  sizeCopyBuffer = (int )((mark_max - mark_min) + 1L);
#line 35
  if (sizeCopyBuffer == 0) {
#line 35
    return;
  }
#line 36
  if (sizeCopyBuffer > 1048576) {
    {
#line 37
    displayTwoLineMessage((char *)"Hey, don\'t you think that\'s too big?!", (char *)"Really copy (Yes/No)");
#line 38
    tmp = wgetch(stdscr);
#line 38
    tmp___0 = tolower(tmp);
    }
#line 38
    if (tmp___0 != 121) {
#line 38
      return;
    }
  }
#line 40
  if (copyBuffer) {
    {
#line 40
    free((void *)copyBuffer);
    }
  }
  {
#line 41
  tmp___1 = malloc((size_t )sizeCopyBuffer);
#line 41
  copyBuffer = (unsigned char *)tmp___1;
  }
#line 41
  if ((unsigned long )copyBuffer == (unsigned long )((void *)0)) {
    {
#line 42
    displayMessageAndWaitForKey((char *)"Can\'t allocate that much memory");
    }
#line 43
    return;
  }
  {
#line 45
  tmp___4 = LSEEK_(fd, mark_min);
  }
#line 45
  if (tmp___4 == -1) {
    {
#line 46
    tmp___2 = __errno_location();
#line 46
    tmp___3 = strerror(*tmp___2);
#line 46
    displayMessageAndWaitForKey(tmp___3);
    }
#line 47
    return;
  } else {
    {
#line 45
    tmp___5 = read(fd, (void *)copyBuffer, (size_t )sizeCopyBuffer);
    }
#line 45
    if (tmp___5 == -1L) {
      {
#line 46
      tmp___2 = __errno_location();
#line 46
      tmp___3 = strerror(*tmp___2);
#line 46
      displayMessageAndWaitForKey(tmp___3);
      }
#line 47
      return;
    }
  }
#line 50
  p = edited;
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    if (! p) {
#line 50
      goto while_break;
    }
#line 51
    if (mark_min < p->base + (off_t )p->size) {
#line 51
      if (p->base <= mark_max) {
#line 52
        if (p->base < mark_min) {
#line 52
          tmp___6 = p->base;
        } else {
#line 52
          tmp___6 = mark_min;
        }
#line 52
        min = tmp___6;
#line 53
        if (p->base + (off_t )p->size < mark_max) {
#line 53
          tmp___7 = p->base + (off_t )p->size;
        } else {
#line 53
          tmp___7 = mark_max;
        }
#line 53
        if (p->base > mark_min) {
#line 53
          tmp___8 = p->base;
        } else {
#line 53
          tmp___8 = mark_min;
        }
        {
#line 53
        memcpy((void */* __restrict  */)((copyBuffer + p->base) - min), (void const   */* __restrict  */)((p->vals + mark_min) - min),
               (size_t )((tmp___7 - tmp___8) + 1L));
        }
      }
    }
#line 50
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 58
  unmarkAll();
#line 59
  mark_set = (off_t )0;
  }
#line 60
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/mark.c"
void yank(void) 
{ 


  {
#line 64
  if ((unsigned long )copyBuffer == (unsigned long )((void *)0)) {
    {
#line 64
    displayMessageAndWaitForKey((char *)"Nothing to paste");
    }
#line 64
    return;
  }
#line 65
  if (isReadOnly) {
    {
#line 65
    displayMessageAndWaitForKey((char *)"File is read-only!");
    }
#line 65
    return;
  }
  {
#line 66
  addToEdited(base + (off_t )cursor, sizeCopyBuffer, copyBuffer);
#line 67
  readFile();
  }
#line 68
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/mark.c"
void yank_to_a_file(void) 
{ 
  char tmp[4096] ;
  int f ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 75
  if ((unsigned long )copyBuffer == (unsigned long )((void *)0)) {
    {
#line 75
    displayMessageAndWaitForKey((char *)"Nothing to paste");
    }
#line 75
    return;
  }
  {
#line 77
  tmp___0 = displayMessageAndGetString((char *)"File name: ", & lastYankToAFile, tmp,
                                       (int )sizeof(tmp));
  }
#line 77
  if (! tmp___0) {
#line 77
    return;
  }
  {
#line 79
  f = open((char const   *)(tmp), 0);
  }
#line 79
  if (f != -1) {
    {
#line 80
    close(f);
#line 81
    displayTwoLineMessage((char *)"File exists", (char *)"Overwrite it (Yes/No)");
#line 82
    tmp___1 = wgetch(stdscr);
#line 82
    tmp___2 = tolower(tmp___1);
    }
#line 82
    if (tmp___2 != 121) {
#line 82
      return;
    }
  }
  {
#line 84
  f = creat((char const   *)(tmp), (mode_t )438);
  }
#line 84
  if (f == -1) {
    {
#line 85
    tmp___3 = __errno_location();
#line 85
    tmp___4 = strerror(*tmp___3);
#line 85
    displayMessageAndWaitForKey(tmp___4);
    }
  } else {
    {
#line 84
    tmp___5 = write(f, (void const   *)copyBuffer, (size_t )sizeCopyBuffer);
    }
#line 84
    if (tmp___5 == -1L) {
      {
#line 85
      tmp___3 = __errno_location();
#line 85
      tmp___4 = strerror(*tmp___3);
#line 85
      displayMessageAndWaitForKey(tmp___4);
      }
    }
  }
  {
#line 88
  close(f);
  }
#line 89
  return;
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/mark.c"
void fill_with_string(void) 
{ 
  char *msg ;
  char const   *tmp ;
  char **last ;
  char **tmp___0 ;
  char tmp2[4096] ;
  unsigned char *tmp1 ;
  int i ;
  int l1 ;
  int l2 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  unsigned short const   **tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;

  {
#line 93
  if (hexOrAscii) {
#line 93
    tmp = "Hexa string to fill with: ";
  } else {
#line 93
    tmp = "Ascii string to fill with: ";
  }
#line 93
  msg = (char *)tmp;
#line 94
  if (hexOrAscii) {
#line 94
    tmp___0 = & lastFillWithStringHexa;
  } else {
#line 94
    tmp___0 = & lastFillWithStringAscii;
  }
#line 94
  last = tmp___0;
#line 99
  if (! mark_set) {
#line 99
    return;
  }
#line 100
  if (isReadOnly) {
    {
#line 100
    displayMessageAndWaitForKey((char *)"File is read-only!");
    }
#line 100
    return;
  }
#line 101
  if (sizeCopyBuffer > 1048576) {
    {
#line 102
    displayTwoLineMessage((char *)"Hey, don\'t you think that\'s too big?!", (char *)"Really fill (Yes/No)");
#line 103
    tmp___1 = wgetch(stdscr);
#line 103
    tmp___2 = tolower(tmp___1);
    }
#line 103
    if (tmp___2 != 121) {
#line 103
      return;
    }
  }
  {
#line 105
  tmp___3 = displayMessageAndGetString(msg, last, tmp2, (int )sizeof(tmp2));
  }
#line 105
  if (! tmp___3) {
#line 105
    return;
  }
  {
#line 106
  l1 = (int )((mark_max - mark_min) + 1L);
#line 107
  tmp___4 = strlen((char const   *)(tmp2));
#line 107
  l2 = (int )tmp___4;
  }
#line 108
  if (hexOrAscii) {
    {
#line 109
    tmp___8 = strlen((char const   *)(tmp2));
    }
#line 109
    if (tmp___8 == 1UL) {
      {
#line 110
      tmp___5 = __ctype_b_loc();
      }
#line 110
      if (! ((int const   )*(*tmp___5 + (int )tmp2[0]) & 4096)) {
        {
#line 110
        displayMessageAndWaitForKey((char *)"Invalid hexa string");
        }
#line 110
        return;
      }
      {
#line 111
      tmp___6 = hexCharToInt((int )tmp2[0]);
#line 111
      tmp2[0] = (char )tmp___6;
      }
    } else {
      {
#line 112
      tmp___7 = hexStringToBinString(tmp2, & l2);
      }
#line 112
      if (! tmp___7) {
#line 112
        return;
      }
    }
  }
  {
#line 114
  tmp___9 = malloc((size_t )l1);
#line 114
  tmp1 = (unsigned char *)tmp___9;
#line 115
  i = 0;
  }
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    if (! (i < (l1 - l2) + 1)) {
#line 115
      goto while_break;
    }
    {
#line 115
    memcpy((void */* __restrict  */)(tmp1 + i), (void const   */* __restrict  */)(tmp2),
           (size_t )l2);
#line 115
    i += l2;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 116
  memcpy((void */* __restrict  */)(tmp1 + i), (void const   */* __restrict  */)(tmp2),
         (size_t )(l1 - i));
#line 117
  addToEdited(mark_min, l1, tmp1);
#line 118
  readFile();
#line 119
  free((void *)tmp1);
  }
#line 120
  return;
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/hexedit-1.2.13/mark.c"
void updateMarked(void) 
{ 
  off_t tmp ;
  off_t tmp___0 ;

  {
#line 125
  if (base + (off_t )cursor > oldbase + (off_t )oldcursor) {
#line 127
    if (mark_min == mark_max) {
#line 128
      mark_max = base + (off_t )cursor;
    } else
#line 129
    if (oldbase + (off_t )oldcursor == mark_min) {
#line 130
      if (base + (off_t )cursor <= mark_max) {
        {
#line 131
        mark_min = base + (off_t )cursor;
#line 132
        unmarkRegion(oldbase + (off_t )oldcursor, mark_min - 1L);
        }
      } else {
        {
#line 134
        unmarkRegion(oldbase + (off_t )oldcursor, mark_max);
#line 135
        mark_min = mark_max;
#line 136
        mark_max = base + (off_t )cursor;
        }
      }
    } else {
#line 139
      mark_max = base + (off_t )cursor;
    }
  } else
#line 142
  if (base + (off_t )cursor < oldbase + (off_t )oldcursor) {
#line 143
    if (mark_min == mark_max) {
#line 144
      mark_min = base + (off_t )cursor;
    } else
#line 145
    if (oldbase + (off_t )oldcursor == mark_max) {
#line 146
      if (base + (off_t )cursor >= mark_min) {
        {
#line 147
        mark_max = base + (off_t )cursor;
#line 148
        unmarkRegion(mark_max + 1L, oldbase + (off_t )oldcursor);
        }
      } else {
        {
#line 150
        unmarkRegion(mark_min, oldbase + (off_t )oldcursor);
#line 151
        markRegion(base + (off_t )cursor, mark_min - 1L);
#line 152
        mark_max = mark_min;
#line 153
        mark_min = base + (off_t )cursor;
        }
      }
    } else {
#line 156
      mark_min = base + (off_t )cursor;
    }
  }
  {
#line 159
  tmp___0 = getfilesize();
  }
#line 159
  if (mark_max >= tmp___0) {
    {
#line 159
    tmp = getfilesize();
#line 159
    mark_max = tmp - 1L;
    }
  }
  {
#line 160
  markSelectedRegion();
  }
#line 161
  return;
}
}
