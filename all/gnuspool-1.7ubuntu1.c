/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 75 "../src/hdrs/defaults.h"
typedef int netid_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 18 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/remote.h"
struct remote {
   char hostname[14] ;
   char alias[14] ;
   char dosuser[15] ;
   netid_t hostid ;
   unsigned short ht_flags ;
   unsigned short ht_timeout ;
};
#line 18 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/hostedit.h"
enum Stype {
    SORT_NONE = 0,
    SORT_HNAME = 1,
    SORT_IP = 2
} ;
#line 19
enum IPatype {
    NO_IPADDR = 0,
    IPADDR_IP = 1,
    IPADDR_NAME = 2
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 150 "/usr/include/curses.h"
typedef unsigned long chtype;
#line 358
struct _win_st;
#line 358 "/usr/include/curses.h"
typedef struct _win_st WINDOW;
#line 360 "/usr/include/curses.h"
typedef chtype attr_t;
#line 405
struct ldat;
#line 407 "/usr/include/curses.h"
struct pdat {
   short _pad_y ;
   short _pad_x ;
   short _pad_top ;
   short _pad_left ;
   short _pad_bottom ;
   short _pad_right ;
};
#line 407 "/usr/include/curses.h"
struct _win_st {
   short _cury ;
   short _curx ;
   short _maxy ;
   short _maxx ;
   short _begy ;
   short _begx ;
   short _flags ;
   attr_t _attrs ;
   chtype _bkgd ;
   _Bool _notimeout ;
   _Bool _clear ;
   _Bool _leaveok ;
   _Bool _scroll ;
   _Bool _idlok ;
   _Bool _idcok ;
   _Bool _immed ;
   _Bool _sync ;
   _Bool _use_keypad ;
   int _delay ;
   struct ldat *_line ;
   short _regtop ;
   short _regbottom ;
   int _parx ;
   int _pary ;
   WINDOW *_parent ;
   struct pdat _pad ;
   short _yoffset ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 34 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 48 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 23 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/hdefs.h"
struct filelist {
   struct filelist *next ;
   char *name ;
};
#line 28 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/hdefs.h"
struct hadhelp {
   struct hadhelp *had_next ;
   long had_value ;
   long had_state ;
   char had_char ;
};
#line 35 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/hdefs.h"
struct helpfile {
   FILE *hf_filep ;
   char *hf_name ;
   char *hf_subdir ;
   struct hadhelp *hf_hash[127] ;
};
#line 42 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/hdefs.h"
struct helpfile_list {
   struct helpfile_list *hfl_next ;
   struct helpfile *hfl_hf ;
   unsigned int hfl_flags ;
};
#line 48 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/hdefs.h"
struct program {
   char *prog_name ;
   struct helpfile *prog_hf ;
};
#line 53 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/hdefs.h"
struct program_list {
   struct program_list *pl_next ;
   struct program *pl_prog ;
};
#line 58 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/hdefs.h"
struct module {
   struct module *mod_next ;
   char *mod_name ;
   char *mod_subdir ;
   struct program_list *mod_pl ;
   unsigned short *mod_scanned ;
};
#line 77 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/hdefs.h"
struct valname {
   struct valname *vn_next ;
   char *vn_string ;
   short vn_value ;
   unsigned short vn_flags ;
   struct helpfile_list *vn_hlist ;
};
#line 98 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/hdefs.h"
union __anonunion_val_un_29 {
   struct valexpr *val_right ;
   struct valname *val_name ;
   long val_value ;
};
#line 98 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/hdefs.h"
struct valexpr {
   unsigned char val_op ;
   struct valexpr *val_left ;
   union __anonunion_val_un_29 val_un ;
};
#line 112 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/hdefs.h"
struct textlist {
   struct textlist *tl_next ;
   char *tl_text ;
};
#line 66 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/hdefs.h"
struct module_list {
   struct module_list *ml_next ;
   struct module *ml_mod ;
};
#line 69 "msgparse.y"
union YYSTYPE {
   char ch ;
   int num ;
   char *str ;
   struct valname *vname ;
   struct valexpr *vexpr ;
   struct module_list *mlist ;
   struct program *pgm ;
   struct program_list *plist ;
   struct textlist *tlist ;
   struct filelist *flist ;
};
#line 69 "msgparse.y"
typedef union YYSTYPE YYSTYPE;
#line 197 "y.tab.c"
typedef unsigned char yytype_uint8;
#line 204 "y.tab.c"
typedef signed char yytype_int8;
#line 218 "y.tab.c"
typedef short yytype_int16;
#line 349 "y.tab.c"
union yyalloc {
   yytype_int16 yyss ;
   YYSTYPE yyvs ;
};
#line 51 "lex.yy.c"
typedef short flex_int16_t;
#line 52 "lex.yy.c"
typedef int flex_int32_t;
#line 153
struct yy_buffer_state;
#line 153 "lex.yy.c"
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#line 184 "lex.yy.c"
typedef size_t yy_size_t;
#line 189 "lex.yy.c"
struct yy_buffer_state {
   FILE *yy_input_file ;
   char *yy_ch_buf ;
   char *yy_buf_pos ;
   yy_size_t yy_buf_size ;
   int yy_n_chars ;
   int yy_is_our_buffer ;
   int yy_is_interactive ;
   int yy_at_bol ;
   int yy_bs_lineno ;
   int yy_bs_column ;
   int yy_fill_buffer ;
   int yy_buffer_status ;
};
#line 335 "lex.yy.c"
typedef unsigned char YY_CHAR;
#line 339 "lex.yy.c"
typedef int yy_state_type;
#line 71 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/hdefs.h"
struct macro {
   struct macro *macro_next ;
   char *macro_name ;
   struct module_list *macro_ml ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 144 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __key_t;
#line 177 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __syscall_ulong_t;
#line 122 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __key_t key_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/ipc.h"
struct ipc_perm {
   __key_t __key ;
   __uid_t uid ;
   __gid_t gid ;
   __uid_t cuid ;
   __gid_t cgid ;
   unsigned short mode ;
   unsigned short __pad1 ;
   unsigned short __seq ;
   unsigned short __pad2 ;
   __syscall_ulong_t __glibc_reserved1 ;
   __syscall_ulong_t __glibc_reserved2 ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/shm.h"
typedef __syscall_ulong_t shmatt_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/shm.h"
struct shmid_ds {
   struct ipc_perm shm_perm ;
   size_t shm_segsz ;
   __time_t shm_atime ;
   __time_t shm_dtime ;
   __time_t shm_ctime ;
   __pid_t shm_cpid ;
   __pid_t shm_lpid ;
   shmatt_t shm_nattch ;
   __syscall_ulong_t __glibc_reserved4 ;
   __syscall_ulong_t __glibc_reserved5 ;
};
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 116 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 123 "/usr/include/netdb.h"
extern void endhostent(void) ;
#line 137
extern struct hostent *gethostbyaddr(void const   *__addr , __socklen_t __len , int __type ) ;
#line 144
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 34 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t ( __attribute__((__leaf__)) inet_addr)(char const   *__cp ) ;
#line 53
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 765
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 315
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 879 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                                                  size_t __len ) ;
#line 82 "../src/hdrs/incl_unix.h"
int ncstrcmp(char const   *a , char const   *b ) ;
#line 83
int ncstrncmp(char const   *a , char const   *b , int n ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/hostedit.h"
void end_hostfile(void) ;
#line 23
void load_hostfile(char const   *fname ) ;
#line 24
void dump_hostfile(FILE *outf ) ;
#line 25
struct remote *get_hostfile(char const   *fname ) ;
#line 26
char *phname(netid_t ipadd , enum IPatype  const  asip ) ;
#line 27
void addhostentry(struct remote  const  *arp ) ;
#line 28
void sortit(void) ;
#line 29
int hnameclashes(char const   *newname ) ;
#line 30
char *ipclashes(netid_t const   newip ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/hostedit.h"
struct remote *hostlist  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/hostedit.h"
int hostnum  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/hostedit.h"
int hostmax  ;
#line 34 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/hostedit.h"
char defcluser[12]  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/hostedit.h"
netid_t myhostid  ;
#line 36
char hostf_errors ;
#line 41
enum Stype sort_type ;
#line 42
enum IPatype hadlocaddr ;
#line 33 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/parsehtab.c"
enum IPatype hadlocaddr  =    (enum IPatype )0;
#line 44 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/parsehtab.c"
char hostf_errors  =    (char)0;
#line 46 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/parsehtab.c"
enum Stype sort_type  =    (enum Stype )0;
#line 48 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/parsehtab.c"
void memory_out(void) 
{ 


  {
  {
#line 50
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Run out of memory\n");
#line 51
  exit(255);
  }
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/parsehtab.c"
int ncstrcmp(char const   *a , char const   *b ) 
{ 
  int ac ;
  int bc ;

  {
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 59
    ac = toupper((int )*a);
#line 60
    bc = toupper((int )*b);
    }
#line 61
    if (ac == 0) {
#line 62
      return (ac - bc);
    } else
#line 61
    if (bc == 0) {
#line 62
      return (ac - bc);
    } else
#line 61
    if (ac != bc) {
#line 62
      return (ac - bc);
    }
#line 63
    a ++;
#line 64
    b ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/parsehtab.c"
int ncstrncmp(char const   *a , char const   *b , int n ) 
{ 
  int ac ;
  int bc ;
  char const   *tmp ;
  char const   *tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 72
    n --;
#line 72
    if (! (n >= 0)) {
#line 72
      goto while_break;
    }
#line 73
    tmp = a;
#line 73
    a ++;
#line 73
    ac = (int )*tmp;
#line 74
    tmp___0 = b;
#line 74
    b ++;
#line 74
    bc = (int )*tmp___0;
#line 75
    if (ac == 0) {
#line 76
      return (ac - bc);
    } else
#line 75
    if (bc == 0) {
#line 76
      return (ac - bc);
    }
    {
#line 77
    tmp___1 = __ctype_b_loc();
    }
#line 77
    if ((int const   )*(*tmp___1 + ac) & 512) {
#line 78
      ac += -32;
    }
    {
#line 79
    tmp___2 = __ctype_b_loc();
    }
#line 79
    if ((int const   )*(*tmp___2 + bc) & 512) {
#line 80
      bc += -32;
    }
#line 81
    if (ac != bc) {
#line 82
      return (ac - bc);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  return (0);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/parsehtab.c"
static int spliton(char **result , char *string , char const   *delims ) 
{ 
  int parsecnt ;
  int resc ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 93
  parsecnt = 1;
#line 94
  resc = 1;
#line 98
  *(result + 0) = string;
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 99
    string = strpbrk((char const   *)string, delims);
    }
#line 99
    if (! string) {
#line 99
      goto while_break;
    }
#line 100
    tmp = string;
#line 100
    string ++;
#line 100
    *tmp = (char )'\000';
    {
#line 101
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 101
      tmp___0 = strchr(delims, (int )*string);
      }
#line 101
      if (! tmp___0) {
#line 101
        goto while_break___0;
      }
#line 102
      string ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 103
    if (! *string) {
#line 104
      goto while_break;
    }
#line 105
    *(result + parsecnt) = string;
#line 106
    resc ++;
#line 107
    parsecnt ++;
#line 107
    if (parsecnt >= 5) {
#line 108
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 110
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 110
    if (! (parsecnt < 6)) {
#line 110
      goto while_break___1;
    }
#line 111
    tmp___1 = parsecnt;
#line 111
    parsecnt ++;
#line 111
    *(result + tmp___1) = (char *)0;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 112
  return (resc);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/parsehtab.c"
char *shortestalias(struct hostent  const  *hp ) 
{ 
  char **ap ;
  char *which ;
  int minlen ;
  int ln ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 117
  which = (char *)0;
#line 118
  minlen = 1000;
#line 120
  ap = (char **)hp->h_aliases;
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if (! *ap) {
#line 120
      goto while_break;
    }
    {
#line 121
    tmp = strlen((char const   *)*ap);
#line 121
    ln = (int )tmp;
    }
#line 121
    if (ln < minlen) {
#line 122
      minlen = ln;
#line 123
      which = *ap;
    }
#line 120
    ap ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 125
  tmp___0 = strlen((char const   *)hp->h_name);
  }
#line 125
  if (minlen < (int )tmp___0) {
#line 126
    return (which);
  }
#line 127
  return ((char *)0);
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/parsehtab.c"
static struct remote hostresult  ;
#line 135 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/parsehtab.c"
char const   locaddr[13]  = 
#line 135
  {      (char const   )'l',      (char const   )'o',      (char const   )'c',      (char const   )'a', 
        (char const   )'l',      (char const   )'a',      (char const   )'d',      (char const   )'d', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
        (char const   )'\000'};
#line 135 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/parsehtab.c"
char const   probestring[6]  = {      (char const   )'p',      (char const   )'r',      (char const   )'o',      (char const   )'b', 
        (char const   )'e',      (char const   )'\000'};
#line 135 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/parsehtab.c"
char const   manualstring[7]  = {      (char const   )'m',      (char const   )'a',      (char const   )'n',      (char const   )'u', 
        (char const   )'a',      (char const   )'l',      (char const   )'\000'};
#line 135 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/parsehtab.c"
char const   dosname[4]  = {      (char const   )'d',      (char const   )'o',      (char const   )'s',      (char const   )'\000'};
#line 135 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/parsehtab.c"
char const   clname[7]  = {      (char const   )'c',      (char const   )'l',      (char const   )'i',      (char const   )'e', 
        (char const   )'n',      (char const   )'t',      (char const   )'\000'};
#line 135 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/parsehtab.c"
char const   dosuname[8]  = 
#line 135
  {      (char const   )'d',      (char const   )'o',      (char const   )'s',      (char const   )'u', 
        (char const   )'s',      (char const   )'e',      (char const   )'r',      (char const   )'\000'};
#line 135 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/parsehtab.c"
char const   cluname[11]  = 
#line 135
  {      (char const   )'c',      (char const   )'l',      (char const   )'i',      (char const   )'e', 
        (char const   )'n',      (char const   )'t',      (char const   )'u',      (char const   )'s', 
        (char const   )'e',      (char const   )'r',      (char const   )'\000'};
#line 135 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/parsehtab.c"
char const   extname[9]  = 
#line 135
  {      (char const   )'e',      (char const   )'x',      (char const   )'t',      (char const   )'e', 
        (char const   )'r',      (char const   )'n',      (char const   )'a',      (char const   )'l', 
        (char const   )'\000'};
#line 135 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/parsehtab.c"
char const   pwcknam[6]  = {      (char const   )'p',      (char const   )'w',      (char const   )'c',      (char const   )'h', 
        (char const   )'k',      (char const   )'\000'};
#line 135 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/parsehtab.c"
char const   trustnam[8]  = 
#line 135
  {      (char const   )'t',      (char const   )'r',      (char const   )'u',      (char const   )'s', 
        (char const   )'t',      (char const   )'e',      (char const   )'d',      (char const   )'\000'};
#line 135 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/parsehtab.c"
char const   defclient[8]  = 
#line 135
  {      (char const   )'d',      (char const   )'e',      (char const   )'f',      (char const   )'a', 
        (char const   )'u',      (char const   )'l',      (char const   )'t',      (char const   )'\000'};
#line 147 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/parsehtab.c"
static FILE *hfile  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/parsehtab.c"
void end_hostfile(void) 
{ 


  {
#line 151
  if (hfile) {
#line 151
    if ((unsigned long )hfile != (unsigned long )stdin) {
      {
#line 152
      fclose(hfile);
#line 153
      hfile = (FILE *)0;
      }
    }
  }
#line 155
  return;
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/parsehtab.c"
struct remote *get_hostfile(char const   *fname ) 
{ 
  struct hostent *hp ;
  int hadlines ;
  char in_line[200] ;
  char myname[256] ;
  int tmp ;
  char *hostp ;
  int lng ;
  size_t tmp___0 ;
  char *bits[6] ;
  unsigned short const   **tmp___1 ;
  char *alp ;
  int tmp___2 ;
  unsigned int totim ;
  unsigned int flags ;
  in_addr_t tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  unsigned short const   **tmp___8 ;
  char **fp ;
  char *bitsf[6] ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *bp ;
  char *ep ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char *bp___0 ;
  char *ep___0 ;
  struct passwd *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  netid_t ina ;
  in_addr_t tmp___20 ;
  unsigned short const   **tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;

  {
#line 160
  hadlines = -1;
#line 166
  if (! hfile) {
    {
#line 169
    myhostid = (netid_t )0L;
#line 170
    myname[sizeof(myname) - 1UL] = (char )'\000';
#line 171
    gethostname(myname, sizeof(myname) - 1UL);
#line 172
    hp = gethostbyname((char const   *)(myname));
    }
#line 172
    if (hp) {
#line 173
      myhostid = *((netid_t *)*(hp->h_addr_list + 0));
    }
#line 174
    if (! fname) {
#line 175
      hfile = stdin;
    } else {
      {
#line 174
      tmp = strcmp(fname, "-");
      }
#line 174
      if (tmp == 0) {
#line 175
        hfile = stdin;
      } else {
        {
#line 177
        hfile = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"r");
        }
#line 178
        if (! hfile) {
#line 179
          return ((struct remote *)0);
        }
      }
    }
  }
  next_host: 
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 186
    tmp___23 = fgets((char */* __restrict  */)(in_line), (int )sizeof(in_line), (FILE */* __restrict  */)hfile);
    }
#line 186
    if (! tmp___23) {
#line 186
      goto while_break;
    }
    {
#line 188
    tmp___0 = strlen((char const   *)(in_line));
#line 188
    lng = (int )(tmp___0 - 1UL);
    }
#line 191
    if ((int )in_line[lng] == 10) {
#line 192
      in_line[lng] = (char )'\000';
    }
#line 197
    hostp = in_line;
    {
#line 197
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 197
      tmp___1 = __ctype_b_loc();
      }
#line 197
      if (! ((int const   )*(*tmp___1 + (int )*hostp) & 8192)) {
#line 197
        goto while_break___0;
      }
#line 197
      hostp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 199
    if (! *hostp) {
#line 200
      goto while_continue;
    } else
#line 199
    if ((int )*hostp == 35) {
#line 200
      goto while_continue;
    }
    {
#line 206
    hadlines ++;
#line 208
    tmp___22 = spliton(bits, hostp, " \t");
    }
#line 208
    if (tmp___22 < 2) {
      {
#line 214
      tmp___2 = ncstrcmp(locaddr, (char const   *)hostp);
      }
#line 214
      if (tmp___2 == 0) {
#line 215
        goto while_continue;
      }
      {
#line 217
      hp = gethostbyname((char const   *)hostp);
      }
#line 217
      if (hp) {
#line 217
        if (*((netid_t *)*(hp->h_addr_list + 0)) == myhostid) {
#line 218
          goto while_continue;
        }
      } else {
#line 218
        goto while_continue;
      }
      {
#line 223
      strncpy((char */* __restrict  */)(hostresult.hostname), (char const   */* __restrict  */)hp->h_name,
              (size_t )13);
#line 224
      alp = shortestalias((struct hostent  const  *)hp);
      }
#line 224
      if (alp) {
        {
#line 225
        strncpy((char */* __restrict  */)(hostresult.alias), (char const   */* __restrict  */)alp,
                (size_t )13);
        }
      } else {
#line 227
        hostresult.alias[0] = (char )'\000';
      }
#line 228
      hostresult.ht_flags = (unsigned short)0;
#line 229
      hostresult.ht_timeout = (unsigned short)1000;
#line 230
      hostresult.hostid = *((netid_t *)*(hp->h_addr_list + 0));
    } else {
      {
#line 237
      totim = 1000U;
#line 238
      flags = 0U;
#line 240
      tmp___5 = ncstrcmp(locaddr, (char const   *)bits[0]);
      }
#line 240
      if (tmp___5 == 0) {
#line 245
        if (hadlines > 0) {
          {
#line 246
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Local address line in host file in wrong place\n");
#line 247
          hostf_errors = (char)1;
          }
#line 248
          goto while_continue;
        }
        {
#line 251
        tmp___4 = __ctype_b_loc();
        }
#line 251
        if ((int const   )*(*tmp___4 + (int )*(bits[1] + 0)) & 2048) {
          {
#line 257
          tmp___3 = inet_addr((char const   *)bits[1]);
#line 257
          myhostid = (netid_t )tmp___3;
#line 259
          hadlocaddr = (enum IPatype )1;
          }
        } else {
          {
#line 261
          hp = gethostbyname((char const   *)bits[1]);
          }
#line 261
          if (hp) {
#line 269
            myhostid = *((netid_t *)*(hp->h_addr_list + 0));
#line 270
            hadlocaddr = (enum IPatype )2;
          } else
#line 262
          if ((long )myhostid == 0L) {
            {
#line 263
            hostf_errors = (char)1;
#line 264
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown host name %s\n",
                    bits[1]);
            }
#line 265
            goto while_continue;
          }
        }
#line 272
        goto while_continue;
      }
      {
#line 278
      tmp___6 = strcmp((char const   *)bits[1], "-");
      }
#line 278
      if (tmp___6 == 0) {
#line 279
        bits[1] = (char *)0;
      }
#line 284
      if (bits[3]) {
        {
#line 284
        tmp___8 = __ctype_b_loc();
        }
#line 284
        if ((int const   )*(*tmp___8 + (int )*(bits[3] + 0)) & 2048) {
          {
#line 285
          tmp___7 = atoi((char const   *)bits[3]);
#line 285
          totim = (unsigned int )tmp___7;
          }
#line 286
          if (totim == 0U) {
#line 287
            totim = 1000U;
          } else
#line 286
          if (totim > 30000U) {
#line 287
            totim = 1000U;
          }
        }
      }
#line 292
      if (bits[2]) {
        {
#line 295
        spliton(bitsf, bits[2], ",");
#line 297
        fp = bitsf;
        }
        {
#line 297
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 297
          if (! *fp) {
#line 297
            goto while_break___1;
          }
          {
#line 299
          if ((int )*(*fp) == 80) {
#line 299
            goto case_80;
          }
#line 299
          if ((int )*(*fp) == 112) {
#line 299
            goto case_80;
          }
#line 309
          if ((int )*(*fp) == 109) {
#line 309
            goto case_109;
          }
#line 309
          if ((int )*(*fp) == 77) {
#line 309
            goto case_109;
          }
#line 315
          if ((int )*(*fp) == 101) {
#line 315
            goto case_101;
          }
#line 315
          if ((int )*(*fp) == 69) {
#line 315
            goto case_101;
          }
#line 323
          if ((int )*(*fp) == 116) {
#line 323
            goto case_116;
          }
#line 323
          if ((int )*(*fp) == 84) {
#line 323
            goto case_116;
          }
#line 331
          if ((int )*(*fp) == 100) {
#line 331
            goto case_100;
          }
#line 331
          if ((int )*(*fp) == 68) {
#line 331
            goto case_100;
          }
#line 331
          if ((int )*(*fp) == 99) {
#line 331
            goto case_100;
          }
#line 331
          if ((int )*(*fp) == 67) {
#line 331
            goto case_100;
          }
#line 382
          goto switch_default;
          case_80: /* CIL Label */ 
          case_112: /* CIL Label */ 
          {
#line 300
          tmp___9 = ncstrcmp((char const   *)*fp, probestring);
          }
#line 300
          if (tmp___9 == 0) {
#line 301
            flags |= (unsigned int )(1 << 1);
#line 302
            goto __Cont;
          }
          {
#line 304
          tmp___10 = ncstrcmp((char const   *)*fp, pwcknam);
          }
#line 304
          if (tmp___10 == 0) {
#line 305
            flags |= (unsigned int )(1 << 4);
#line 306
            goto __Cont;
          }
          case_109: /* CIL Label */ 
          case_77: /* CIL Label */ 
          {
#line 310
          tmp___11 = ncstrcmp((char const   *)*fp, manualstring);
          }
#line 310
          if (tmp___11 == 0) {
#line 311
            flags |= (unsigned int )(1 << 2);
#line 312
            goto __Cont;
          }
          case_101: /* CIL Label */ 
          case_69: /* CIL Label */ 
          {
#line 316
          tmp___12 = ncstrcmp((char const   *)*fp, extname);
          }
#line 316
          if (tmp___12 == 0) {
#line 318
            flags |= (unsigned int )(1 << 3);
#line 319
            hostresult.dosuser[0] = (char )'\000';
#line 320
            goto __Cont;
          }
          case_116: /* CIL Label */ 
          case_84: /* CIL Label */ 
          {
#line 324
          tmp___13 = ncstrcmp((char const   *)*fp, trustnam);
          }
#line 324
          if (tmp___13 == 0) {
#line 325
            flags |= (unsigned int )(1 << 6);
#line 326
            goto __Cont;
          }
          case_100: /* CIL Label */ 
          case_68: /* CIL Label */ 
          case_99: /* CIL Label */ 
          case_67: /* CIL Label */ 
          {
#line 333
          tmp___15 = ncstrncmp((char const   *)*fp, dosuname, (int )(sizeof(dosuname) - 1UL));
          }
#line 333
          if (tmp___15 == 0) {
#line 333
            goto _L;
          } else {
            {
#line 333
            tmp___16 = ncstrncmp((char const   *)*fp, cluname, (int )(sizeof(cluname) - 1UL));
            }
#line 333
            if (tmp___16 == 0) {
              _L: /* CIL Label */ 
              {
#line 335
              flags |= (unsigned int )((1 << 3) | (1 << 5));
#line 336
              bp = strchr((char const   *)*fp, '(');
              }
#line 336
              if (bp) {
                {
#line 336
                ep = strchr((char const   *)*fp, ')');
                }
#line 336
                if (ep) {
#line 339
                  *ep = (char )'\000';
#line 340
                  bp ++;
#line 341
                  if (ep - bp > 14L) {
                    {
#line 342
                    hostresult.dosuser[14] = (char )'\000';
#line 343
                    strncpy((char */* __restrict  */)(hostresult.dosuser), (char const   */* __restrict  */)bp,
                            (size_t )14);
                    }
                  } else {
                    {
#line 346
                    strcpy((char */* __restrict  */)(hostresult.dosuser), (char const   */* __restrict  */)bp);
                    }
                  }
                } else {
#line 337
                  hostresult.dosuser[0] = (char )'\000';
                }
              } else {
#line 337
                hostresult.dosuser[0] = (char )'\000';
              }
              {
#line 349
              tmp___14 = strcmp((char const   *)bits[0], defclient);
              }
#line 349
              if (tmp___14 == 0) {
                {
#line 350
                strcpy((char */* __restrict  */)(defcluser), (char const   */* __restrict  */)bits[1]);
                }
#line 351
                goto next_host;
              }
#line 353
              goto __Cont;
            }
          }
          {
#line 355
          tmp___18 = ncstrncmp((char const   *)*fp, dosname, (int )(sizeof(dosname) - 1UL));
          }
#line 355
          if (tmp___18 == 0) {
#line 355
            goto _L___0;
          } else {
            {
#line 355
            tmp___19 = ncstrncmp((char const   *)*fp, clname, (int )(sizeof(clname) - 1UL));
            }
#line 355
            if (tmp___19 == 0) {
              _L___0: /* CIL Label */ 
              {
#line 357
              flags |= (unsigned int )(1 << 3);
#line 359
              bp___0 = strchr((char const   *)*fp, '(');
              }
#line 359
              if (bp___0) {
                {
#line 359
                ep___0 = strchr((char const   *)*fp, ')');
                }
#line 359
                if (ep___0) {
                  {
#line 362
                  *ep___0 = (char )'\000';
#line 363
                  bp___0 ++;
#line 364
                  tmp___17 = getpwnam((char const   *)bp___0);
                  }
#line 364
                  if (tmp___17) {
#line 370
                    if (ep___0 - bp___0 > 11L) {
                      {
#line 371
                      hostresult.dosuser[11] = (char )'\000';
#line 372
                      strncpy((char */* __restrict  */)(hostresult.dosuser), (char const   */* __restrict  */)bp___0,
                              (size_t )11);
                      }
                    } else {
                      {
#line 375
                      strcpy((char */* __restrict  */)(hostresult.dosuser), (char const   */* __restrict  */)bp___0);
                      }
                    }
                  } else {
                    {
#line 365
                    hostresult.dosuser[0] = (char )'\000';
#line 366
                    flags |= (unsigned int )(1 << 4);
#line 367
                    hostf_errors = (char )((int )hostf_errors + 1);
#line 368
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown user %s in host file\n",
                            bp___0);
                    }
                  }
                } else {
#line 360
                  hostresult.dosuser[0] = (char )'\000';
                }
              } else {
#line 360
                hostresult.dosuser[0] = (char )'\000';
              }
#line 377
              goto __Cont;
            }
          }
          switch_default: /* CIL Label */ 
          {
#line 383
          hostf_errors = (char)1;
#line 384
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown flags keyword %s in host file\n",
                  *fp);
          }
          switch_break: /* CIL Label */ ;
          }
          __Cont: /* CIL Label */ 
#line 297
          fp ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 388
      if (flags & (unsigned int )(1 << 5)) {
        {
#line 393
        strncpy((char */* __restrict  */)(hostresult.hostname), (char const   */* __restrict  */)bits[0],
                (size_t )13);
        }
#line 395
        if (bits[1]) {
          {
#line 396
          strncpy((char */* __restrict  */)(hostresult.alias), (char const   */* __restrict  */)bits[1],
                  (size_t )13);
          }
        } else {
#line 398
          hostresult.alias[0] = (char )'\000';
        }
#line 399
        hostresult.hostid = 0;
      } else {
        {
#line 401
        tmp___21 = __ctype_b_loc();
        }
#line 401
        if ((int const   )*(*tmp___21 + (int )*hostp) & 2048) {
#line 410
          if (! bits[1]) {
            {
#line 411
            hostf_errors = (char)1;
#line 412
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No alias field for host IP given as address %s\n",
                    hostp);
            }
#line 413
            goto while_continue;
          }
          {
#line 419
          tmp___20 = inet_addr((char const   *)hostp);
#line 419
          ina = (netid_t )tmp___20;
          }
#line 421
          if ((long )ina == -1L) {
            {
#line 422
            hostf_errors = (char)1;
#line 423
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid/duplicated IP address %s in host file\n",
                    hostp);
            }
#line 424
            goto while_continue;
          } else
#line 421
          if (ina == myhostid) {
            {
#line 422
            hostf_errors = (char)1;
#line 423
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid/duplicated IP address %s in host file\n",
                    hostp);
            }
#line 424
            goto while_continue;
          }
          {
#line 426
          flags |= 1U;
#line 427
          strncpy((char */* __restrict  */)(hostresult.hostname), (char const   */* __restrict  */)bits[1],
                  (size_t )13);
#line 428
          hostresult.alias[0] = (char )'\000';
#line 429
          hostresult.hostid = ina;
          }
        } else {
          {
#line 435
          hp = gethostbyname((char const   *)hostp);
          }
#line 435
          if (hp) {
#line 435
            if (*((netid_t *)*(hp->h_addr_list + 0)) == myhostid) {
              {
#line 436
              hostf_errors = (char)1;
#line 437
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown host %s in host file\n",
                      hostp);
              }
#line 438
              goto while_continue;
            }
          } else {
            {
#line 436
            hostf_errors = (char)1;
#line 437
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown host %s in host file\n",
                    hostp);
            }
#line 438
            goto while_continue;
          }
          {
#line 440
          strncpy((char */* __restrict  */)(hostresult.hostname), (char const   */* __restrict  */)bits[0],
                  (size_t )13);
          }
#line 441
          if (bits[1]) {
            {
#line 442
            strncpy((char */* __restrict  */)(hostresult.alias), (char const   */* __restrict  */)bits[1],
                    (size_t )13);
            }
          } else {
#line 444
            hostresult.alias[0] = (char )'\000';
          }
#line 445
          hostresult.hostid = *((netid_t *)*(hp->h_addr_list + 0));
        }
      }
#line 447
      hostresult.ht_flags = (unsigned short )flags;
#line 448
      hostresult.ht_timeout = (unsigned short )totim;
    }
#line 450
    return (& hostresult);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 452
  endhostent();
  }
#line 453
  return ((struct remote *)0);
}
}
#line 456 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/parsehtab.c"
static void checkhlistsize(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 458
  if (hostnum >= hostmax) {
#line 459
    if (hostlist) {
      {
#line 460
      hostmax += 10;
#line 461
      tmp = realloc((void *)((char *)hostlist), (unsigned long )((unsigned int )hostmax) * sizeof(struct remote ));
#line 461
      hostlist = (struct remote *)tmp;
      }
    } else {
      {
#line 464
      hostmax = 20;
#line 465
      tmp___0 = malloc(20UL * sizeof(struct remote ));
#line 465
      hostlist = (struct remote *)tmp___0;
      }
    }
#line 467
    if (! hostlist) {
      {
#line 468
      memory_out();
      }
    }
  }
#line 470
  return;
}
}
#line 472 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/parsehtab.c"
void addhostentry(struct remote  const  *arp ) 
{ 
  int tmp ;

  {
  {
#line 474
  checkhlistsize();
#line 475
  tmp = hostnum;
#line 475
  hostnum ++;
#line 475
  *(hostlist + tmp) = (struct remote )*arp;
  }
#line 476
  return;
}
}
#line 478 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/parsehtab.c"
void load_hostfile(char const   *fname ) 
{ 
  struct remote *inp ;
  int tmp ;

  {
  {
#line 482
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 482
    inp = get_hostfile(fname);
    }
#line 482
    if (! inp) {
#line 482
      goto while_break;
    }
    {
#line 483
    checkhlistsize();
#line 484
    tmp = hostnum;
#line 484
    hostnum ++;
#line 484
    *(hostlist + tmp) = *inp;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 486
  end_hostfile();
  }
#line 487
  return;
}
}
#line 489 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/parsehtab.c"
char *phname(netid_t ipadd , enum IPatype  const  asip ) 
{ 
  struct in_addr ina_str ;
  char *tmp ;
  struct hostent *hp ;
  struct hostent *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 491
  if ((unsigned int const   )asip == 1U) {
    {
#line 493
    ina_str.s_addr = (in_addr_t )ipadd;
#line 494
    tmp = inet_ntoa(ina_str);
    }
#line 494
    return (tmp);
  } else {
    {
#line 497
    tmp___0 = gethostbyaddr((void const   *)((char *)(& ipadd)), (__socklen_t )sizeof(ipadd),
                            2);
#line 497
    hp = tmp___0;
    }
#line 498
    if (hp) {
#line 498
      tmp___1 = (char const   *)hp->h_name;
    } else {
#line 498
      tmp___1 = "<unknown>";
    }
#line 498
    return ((char *)tmp___1);
  }
}
}
#line 502 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/parsehtab.c"
void dump_hostfile(FILE *outf ) 
{ 
  int cnt ;
  time_t t ;
  time_t tmp ;
  struct tm *tp ;
  struct tm *tmp___0 ;
  char *tmp___1 ;
  struct remote *hlp ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  int had___0 ;
  char *tmp___5 ;
  char const   *tmp___6 ;

  {
  {
#line 505
  tmp = time((time_t *)0);
#line 505
  t = tmp;
#line 506
  tmp___0 = localtime((time_t const   *)(& t));
#line 506
  tp = tmp___0;
#line 508
  fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"# Host file created on %.2d/%.2d/%.2d at %.2d:%.2d:%.2d\n\n",
          tp->tm_mday, tp->tm_mon + 1, tp->tm_year % 100, tp->tm_hour, tp->tm_min,
          tp->tm_sec);
  }
#line 512
  if ((unsigned int )hadlocaddr != 0U) {
    {
#line 513
    tmp___1 = phname(myhostid, (enum IPatype  const  )hadlocaddr);
#line 513
    fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"%s\t%s\n\n",
            locaddr, tmp___1);
    }
  }
#line 515
  cnt = 0;
  {
#line 515
  while (1) {
    while_continue: /* CIL Label */ ;
#line 515
    if (! (cnt < hostnum)) {
#line 515
      goto while_break;
    }
#line 516
    hlp = hostlist + cnt;
#line 517
    if ((int )hlp->ht_flags & (1 << 3)) {
#line 518
      if ((int )hlp->ht_flags & (1 << 5)) {
#line 519
        if (hlp->alias[0]) {
#line 519
          tmp___2 = (char const   *)(hlp->alias);
        } else {
#line 519
          tmp___2 = "-";
        }
        {
#line 519
        fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"%s\t%s\t%s",
                hlp->hostname, tmp___2, cluname);
        }
      } else
#line 520
      if ((int )hlp->ht_flags & 1) {
        {
#line 521
        tmp___3 = phname(hlp->hostid, (enum IPatype  const  )1);
#line 521
        fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"%s\t%s\t%s",
                tmp___3, hlp->hostname, clname);
        }
      } else {
#line 523
        if (hlp->alias[0]) {
#line 523
          tmp___4 = (char const   *)(hlp->alias);
        } else {
#line 523
          tmp___4 = "-";
        }
        {
#line 523
        fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"%s\t%s\t%s",
                hlp->hostname, tmp___4, clname);
        }
      }
#line 524
      if (hlp->dosuser[0]) {
        {
#line 525
        fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"(%s)",
                hlp->dosuser);
        }
      }
#line 526
      if ((int )hlp->ht_flags & (1 << 4)) {
        {
#line 527
        fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)",%s",
                pwcknam);
        }
      }
    } else {
#line 530
      had___0 = '\t';
#line 531
      if ((int )hlp->ht_flags & 1) {
        {
#line 532
        tmp___5 = phname(hlp->hostid, (enum IPatype  const  )1);
#line 532
        fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"%s\t%s",
                tmp___5, hlp->hostname);
        }
      } else {
#line 534
        if (hlp->alias[0]) {
#line 534
          tmp___6 = (char const   *)(hlp->alias);
        } else {
#line 534
          tmp___6 = "-";
        }
        {
#line 534
        fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"%s\t%s",
                hlp->hostname, tmp___6);
        }
      }
#line 535
      if ((int )hlp->ht_flags & (1 << 1)) {
        {
#line 536
        fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"%c%s",
                had___0, probestring);
#line 537
        had___0 = ',';
        }
      }
#line 539
      if ((int )hlp->ht_flags & (1 << 2)) {
        {
#line 540
        fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"%c%s",
                had___0, manualstring);
#line 541
        had___0 = ',';
        }
      }
#line 543
      if ((int )hlp->ht_flags & (1 << 6)) {
        {
#line 544
        fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"%c%s",
                had___0, trustnam);
#line 545
        had___0 = ',';
        }
      }
    }
#line 548
    if ((int )hlp->ht_timeout != 1000) {
      {
#line 549
      fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"\t%u",
              (int )hlp->ht_timeout);
      }
    }
    {
#line 550
    _IO_putc('\n', outf);
#line 515
    cnt ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 552
  if (defcluser[0]) {
    {
#line 553
    fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"%s\t%s\t%s\n",
            defclient, defcluser, cluname);
    }
  }
#line 554
  return;
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/parsehtab.c"
int sort_rout(struct remote *a , struct remote *b ) 
{ 
  int tmp ;
  int tmp___0 ;
  netid_t na ;
  uint32_t tmp___1 ;
  netid_t nb ;
  uint32_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 558
  if ((int )a->ht_flags & (1 << 5)) {
#line 559
    if ((int )b->ht_flags & (1 << 5)) {
      {
#line 559
      tmp = strcmp((char const   *)(a->hostname), (char const   *)(b->hostname));
#line 559
      tmp___0 = tmp;
      }
    } else {
#line 559
      tmp___0 = 1;
    }
#line 559
    return (tmp___0);
  }
#line 560
  if ((int )b->ht_flags & (1 << 5)) {
#line 561
    return (-1);
  }
#line 562
  if ((unsigned int )sort_type == 2U) {
    {
#line 563
    tmp___1 = ntohl((uint32_t )a->hostid);
#line 563
    na = (netid_t )tmp___1;
#line 563
    tmp___2 = ntohl((uint32_t )b->hostid);
#line 563
    nb = (netid_t )tmp___2;
    }
#line 564
    if (na < nb) {
#line 564
      tmp___4 = -1;
    } else {
#line 564
      if (na == nb) {
#line 564
        tmp___3 = 0;
      } else {
#line 564
        tmp___3 = 1;
      }
#line 564
      tmp___4 = tmp___3;
    }
#line 564
    return (tmp___4);
  }
#line 566
  if ((int )a->ht_flags & (1 << 3)) {
#line 567
    if ((int )b->ht_flags & (1 << 3)) {
      {
#line 567
      tmp___5 = strcmp((char const   *)(a->hostname), (char const   *)(b->hostname));
#line 567
      tmp___6 = tmp___5;
      }
    } else {
#line 567
      tmp___6 = 1;
    }
#line 567
    return (tmp___6);
  }
#line 568
  if ((int )b->ht_flags & (1 << 3)) {
#line 569
    return (-1);
  }
  {
#line 570
  tmp___7 = strcmp((char const   *)(a->hostname), (char const   *)(b->hostname));
  }
#line 570
  return (tmp___7);
}
}
#line 573 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/parsehtab.c"
void sortit(void) 
{ 


  {
#line 575
  if ((unsigned int )sort_type != 0U) {
    {
#line 576
    qsort((void *)hostlist, (size_t )((unsigned int )hostnum), sizeof(struct remote ),
          (int (*)(void const   * , void const   * ))(& sort_rout));
    }
  }
#line 577
  return;
}
}
#line 579 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/parsehtab.c"
int hnameclashes(char const   *newname ) 
{ 
  int cnt ;
  struct remote *rp ;
  int tmp ;
  int tmp___0 ;

  {
#line 583
  cnt = 0;
  {
#line 583
  while (1) {
    while_continue: /* CIL Label */ ;
#line 583
    if (! (cnt < hostnum)) {
#line 583
      goto while_break;
    }
#line 584
    rp = hostlist + cnt;
#line 585
    if ((int )rp->ht_flags & (1 << 5)) {
#line 586
      goto __Cont;
    }
    {
#line 587
    tmp = strcmp((char const   *)(rp->hostname), newname);
    }
#line 587
    if (tmp == 0) {
#line 588
      return (1);
    } else {
      {
#line 587
      tmp___0 = strcmp((char const   *)(rp->alias), newname);
      }
#line 587
      if (tmp___0 == 0) {
#line 588
        return (1);
      }
    }
    __Cont: /* CIL Label */ 
#line 583
    cnt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 590
  return (0);
}
}
#line 593 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/parsehtab.c"
char *ipclashes(netid_t const   newip ) 
{ 
  int cnt ;
  struct remote *rp ;

  {
#line 596
  cnt = 0;
  {
#line 596
  while (1) {
    while_continue: /* CIL Label */ ;
#line 596
    if (! (cnt < hostnum)) {
#line 596
      goto while_break;
    }
#line 597
    rp = hostlist + cnt;
#line 598
    if ((int )rp->ht_flags & (1 << 5)) {
#line 599
      goto __Cont;
    }
#line 600
    if (rp->hostid == (netid_t )newip) {
#line 601
      return (rp->hostname);
    }
    __Cont: /* CIL Label */ 
#line 596
    cnt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 603
  return ((char *)0);
}
}
#line 611 "/usr/include/curses.h"
extern int endwin(void) ;
#line 632
extern WINDOW *initscr(void) ;
#line 647
extern int keypad(WINDOW * , _Bool  ) ;
#line 674
extern int mvprintw(int  , int  , char const   *  , ...) ;
#line 711
extern int noecho(void) ;
#line 712
extern int nonl(void) ;
#line 723
extern int printw(char const   *  , ...) ;
#line 727
extern int raw(void) ;
#line 785
extern int waddch(WINDOW * , chtype const    ) ;
#line 788
extern int waddnstr(WINDOW * , char const   * , int  ) ;
#line 794
extern int wattr_on(WINDOW * , attr_t  , void * ) ;
#line 795
extern int wattr_off(WINDOW * , attr_t  , void * ) ;
#line 801
extern int wclear(WINDOW * ) ;
#line 803
extern int wclrtoeol(WINDOW * ) ;
#line 810
extern int wgetch(WINDOW * ) ;
#line 824
extern int wmove(WINDOW * , int  , int  ) ;
#line 829
extern int wrefresh(WINDOW * ) ;
#line 1386
extern WINDOW *stdscr ;
#line 1392
extern int LINES ;
#line 63 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
#line 74
extern  __attribute__((__nothrow__, __noreturn__)) void longjmp(struct __jmp_buf_tag *__env ,
                                                                int __val ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/hostedit.h"
void proc_hostfile(void) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/cursproc.c"
jmp_buf escj  ;
#line 50 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/cursproc.c"
int ask(int const   row , char const   *quest , int const   dflt ) 
{ 
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 52
  wmove(stdscr, (int )row, 0);
#line 53
  wclrtoeol(stdscr);
  }
#line 54
  if (dflt) {
#line 54
    tmp = 'Y';
  } else {
#line 54
    tmp = 'N';
  }
  {
#line 54
  printw("%s? [%c] ", quest, tmp);
#line 55
  wrefresh(stdscr);
  }
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 57
    tmp___0 = wgetch(stdscr);
    }
    {
#line 62
    if (tmp___0 == 121) {
#line 62
      goto case_121;
    }
#line 62
    if (tmp___0 == 89) {
#line 62
      goto case_121;
    }
#line 66
    if (tmp___0 == 110) {
#line 66
      goto case_110;
    }
#line 66
    if (tmp___0 == 78) {
#line 66
      goto case_110;
    }
#line 70
    if (tmp___0 == 27) {
#line 70
      goto case_27;
    }
#line 58
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 59
    if (dflt) {
#line 59
      tmp___1 = "Yes";
    } else {
#line 59
      tmp___1 = "No";
    }
    {
#line 59
    printw(tmp___1);
#line 60
    wrefresh(stdscr);
    }
#line 61
    return ((int )dflt);
    case_121: /* CIL Label */ 
    case_89: /* CIL Label */ 
    {
#line 63
    printw("Yes");
#line 64
    wrefresh(stdscr);
    }
#line 65
    return (1);
    case_110: /* CIL Label */ 
    case_78: /* CIL Label */ 
    {
#line 67
    printw("No");
#line 68
    wrefresh(stdscr);
    }
#line 69
    return (0);
    case_27: /* CIL Label */ 
    {
#line 71
    longjmp((struct __jmp_buf_tag *)(escj), 1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/cursproc.c"
unsigned int askn(int const   row , char const   *msg ) 
{ 
  int ch ;
  int starta ;
  unsigned int result ;

  {
  {
#line 81
  mvprintw((int )row, 0, "%s: ", msg);
  }
#line 82
  if (stdscr) {
#line 82
    ch = (int )stdscr->_cury;
  } else {
#line 82
    ch = -1;
  }
#line 82
  if (stdscr) {
#line 82
    starta = (int )stdscr->_curx;
  } else {
#line 82
    starta = -1;
  }
  {
#line 83
  wrefresh(stdscr);
#line 85
  result = 0U;
  }
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 89
    ch = wgetch(stdscr);
    }
    {
#line 93
    if (ch == 27) {
#line 93
      goto case_27;
    }
#line 97
    if (ch == 57) {
#line 97
      goto case_57;
    }
#line 97
    if (ch == 56) {
#line 97
      goto case_57;
    }
#line 97
    if (ch == 55) {
#line 97
      goto case_57;
    }
#line 97
    if (ch == 54) {
#line 97
      goto case_57;
    }
#line 97
    if (ch == 53) {
#line 97
      goto case_57;
    }
#line 97
    if (ch == 52) {
#line 97
      goto case_57;
    }
#line 97
    if (ch == 51) {
#line 97
      goto case_57;
    }
#line 97
    if (ch == 50) {
#line 97
      goto case_57;
    }
#line 97
    if (ch == 49) {
#line 97
      goto case_57;
    }
#line 97
    if (ch == 48) {
#line 97
      goto case_57;
    }
#line 114
    if (ch == 8) {
#line 114
      goto case_8;
    }
#line 114
    if (ch == 263) {
#line 114
      goto case_8;
    }
#line 114
    if (ch == 330) {
#line 114
      goto case_8;
    }
#line 114
    if (ch == 260) {
#line 114
      goto case_8;
    }
#line 122
    if (ch == 13) {
#line 122
      goto case_13;
    }
#line 122
    if (ch == 10) {
#line 122
      goto case_13;
    }
#line 122
    if (ch == 343) {
#line 122
      goto case_13;
    }
#line 90
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 91
    goto __Cont;
    case_27: /* CIL Label */ 
    {
#line 94
    longjmp((struct __jmp_buf_tag *)(escj), 1);
    }
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
#line 99
    result = (result * 10U + (unsigned int )ch) - 48U;
    redisp: 
    {
#line 101
    mvprintw((int )row, starta, "%6u", result);
#line 102
    wrefresh(stdscr);
    }
#line 103
    goto __Cont;
    case_8: /* CIL Label */ 
    case_263: /* CIL Label */ 
    case_330: /* CIL Label */ 
    case_260: /* CIL Label */ 
#line 115
    result /= 10U;
#line 116
    goto redisp;
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_343: /* CIL Label */ 
#line 123
    return (result);
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/cursproc.c"
void asktimeout(struct remote *rp , int const   row ) 
{ 
  unsigned int tmp ;
  int tmp___0 ;

  {
  {
#line 130
  tmp___0 = ask(row, "Default timeout value OK", (int const   )1);
  }
#line 130
  if (tmp___0) {
#line 131
    rp->ht_timeout = (unsigned short)1000;
  } else {
    {
#line 133
    tmp = askn(row + 2, "Timeout value");
#line 133
    rp->ht_timeout = (unsigned short )tmp;
    }
  }
#line 134
  return;
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/cursproc.c"
enum IPatype askhname(char *hnp , int const   row , char const   *htype , struct remote *rp ) 
{ 
  int ch ;
  int starta ;
  int cnt ;
  int tmp ;
  int tmp___0 ;
  netid_t resip ;
  in_addr_t tmp___1 ;
  char *tmp___2 ;
  struct hostent *hp ;
  int tmp___3 ;
  char *cp ;
  unsigned short const   **tmp___4 ;

  {
  {
#line 140
  mvprintw((int )row, 0, "%s: ", htype);
  }
#line 141
  if (stdscr) {
#line 141
    ch = (int )stdscr->_cury;
  } else {
#line 141
    ch = -1;
  }
#line 141
  if (stdscr) {
#line 141
    starta = (int )stdscr->_curx;
  } else {
#line 141
    starta = -1;
  }
  {
#line 142
  wrefresh(stdscr);
#line 144
  cnt = 0;
  }
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 148
    ch = wgetch(stdscr);
    }
    {
#line 152
    if (ch == 27) {
#line 152
      goto case_27;
    }
#line 169
    if (ch == 90) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 89) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 88) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 87) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 86) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 85) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 84) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 83) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 82) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 81) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 80) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 79) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 78) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 77) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 76) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 75) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 74) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 73) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 72) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 71) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 70) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 69) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 68) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 67) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 66) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 65) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 122) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 121) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 120) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 119) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 118) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 117) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 116) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 115) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 114) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 113) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 112) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 111) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 110) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 109) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 108) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 107) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 106) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 105) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 104) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 103) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 102) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 101) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 100) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 99) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 98) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 97) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 57) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 56) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 55) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 54) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 53) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 52) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 51) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 50) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 49) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 48) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 95) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 45) {
#line 169
      goto case_90;
    }
#line 169
    if (ch == 46) {
#line 169
      goto case_90;
    }
#line 186
    if (ch == 8) {
#line 186
      goto case_8;
    }
#line 186
    if (ch == 263) {
#line 186
      goto case_8;
    }
#line 186
    if (ch == 330) {
#line 186
      goto case_8;
    }
#line 186
    if (ch == 260) {
#line 186
      goto case_8;
    }
#line 200
    if (ch == 13) {
#line 200
      goto case_13;
    }
#line 200
    if (ch == 10) {
#line 200
      goto case_13;
    }
#line 200
    if (ch == 343) {
#line 200
      goto case_13;
    }
#line 149
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 150
    goto __Cont;
    case_27: /* CIL Label */ 
    {
#line 153
    longjmp((struct __jmp_buf_tag *)(escj), 1);
    }
    case_90: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_88: /* CIL Label */ 
    case_87: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_83: /* CIL Label */ 
    case_82: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_79: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_74: /* CIL Label */ 
    case_73: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_122: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_120: /* CIL Label */ 
    case_119: /* CIL Label */ 
    case_118: /* CIL Label */ 
    case_117: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_114: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_111: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_108: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_106: /* CIL Label */ 
    case_105: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_97: /* CIL Label */ 
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
    case_95: /* CIL Label */ 
    case_45: /* CIL Label */ 
    case_46: /* CIL Label */ 
#line 170
    if (cnt >= 14) {
#line 171
      goto __Cont;
    }
    {
#line 172
    tmp = cnt;
#line 172
    cnt ++;
#line 172
    *(hnp + tmp) = (char )ch;
#line 173
    waddch(stdscr, (chtype const   )ch);
#line 174
    wrefresh(stdscr);
    }
#line 175
    goto __Cont;
    case_8: /* CIL Label */ 
    case_263: /* CIL Label */ 
    case_330: /* CIL Label */ 
    case_260: /* CIL Label */ 
#line 187
    if (cnt > 0) {
      {
#line 188
      cnt --;
#line 189
      *(hnp + cnt) = (char )'\000';
#line 190
      tmp___0 = wmove(stdscr, (int )row, starta + cnt);
      }
#line 190
      if (! (tmp___0 == -1)) {
        {
#line 190
        waddch(stdscr, (chtype const   )' ');
        }
      }
      {
#line 191
      wmove(stdscr, (int )row, starta + cnt);
#line 192
      wrefresh(stdscr);
      }
    }
#line 194
    goto __Cont;
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_343: /* CIL Label */ 
#line 201
    if (cnt <= 0) {
      {
#line 202
      wmove(stdscr, (int )(row - 1), 0);
#line 203
      wclrtoeol(stdscr);
      }
#line 204
      if (stdscr) {
#line 204
        stdscr->_attrs = 1UL << 16;
      }
      {
#line 205
      waddnstr(stdscr, "You must give some host name", -1);
      }
#line 206
      goto switch_break;
    }
#line 208
    *(hnp + cnt) = (char )'\000';
#line 209
    if (rp) {
      {
#line 209
      tmp___4 = __ctype_b_loc();
      }
#line 209
      if ((int const   )*(*tmp___4 + (int )*(hnp + 0)) & 2048) {
        {
#line 216
        tmp___1 = inet_addr((char const   *)hnp);
#line 216
        resip = (netid_t )tmp___1;
        }
#line 218
        if ((long )resip != -1L) {
          {
#line 219
          tmp___2 = ipclashes((netid_t const   )resip);
          }
#line 219
          if (tmp___2) {
            {
#line 220
            wmove(stdscr, (int )(row - 1), 0);
#line 221
            wclrtoeol(stdscr);
            }
#line 222
            if (stdscr) {
#line 222
              stdscr->_attrs = 1UL << 16;
            }
            {
#line 223
            printw("%s clashes with existing IP addr", hnp);
            }
#line 224
            goto switch_break;
          }
#line 226
          rp->hostid = resip;
#line 227
          rp->ht_flags = (unsigned short )((int )rp->ht_flags | 1);
#line 228
          return ((enum IPatype )1);
        }
        {
#line 230
        wmove(stdscr, (int )(row - 1), 0);
#line 231
        wclrtoeol(stdscr);
        }
#line 232
        if (stdscr) {
#line 232
          stdscr->_attrs = 1UL << 16;
        }
        {
#line 233
        printw("%s is not a valid IP addr", hnp);
        }
#line 234
        goto switch_break;
      } else {
#line 209
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 238
      tmp___3 = hnameclashes((char const   *)hnp);
      }
#line 238
      if (tmp___3) {
        {
#line 239
        wmove(stdscr, (int )(row - 1), 0);
#line 240
        wclrtoeol(stdscr);
        }
#line 241
        if (stdscr) {
#line 241
          stdscr->_attrs = 1UL << 16;
        }
        {
#line 242
        printw("%s clashes with existing name", hnp);
        }
#line 243
        goto switch_break;
      }
      {
#line 245
      hp = gethostbyname((char const   *)hnp);
      }
#line 246
      if (hp) {
        {
#line 248
        cp = ipclashes((netid_t const   )*((netid_t *)*(hp->h_addr_list + 0)));
        }
#line 248
        if (cp) {
          {
#line 249
          wmove(stdscr, (int )(row - 1), 0);
#line 250
          wclrtoeol(stdscr);
          }
#line 251
          if (stdscr) {
#line 251
            stdscr->_attrs = 1UL << 16;
          }
          {
#line 252
          printw("IP addr for %s clashes with existing for %s", hnp, cp);
          }
#line 253
          goto switch_break;
        }
#line 255
        if (rp) {
#line 256
          rp->hostid = *((netid_t *)*(hp->h_addr_list + 0));
        }
#line 257
        return ((enum IPatype )2);
      }
      {
#line 259
      wmove(stdscr, (int )(row - 1), 0);
#line 260
      wclrtoeol(stdscr);
      }
#line 261
      if (stdscr) {
#line 261
        stdscr->_attrs = 1UL << 16;
      }
      {
#line 262
      printw("%s is not a valid host name", hnp);
      }
#line 263
      goto switch_break;
    }
    switch_break: /* CIL Label */ ;
    }
#line 266
    if (stdscr) {
#line 266
      stdscr->_attrs = 0UL;
    }
    {
#line 267
    wmove(stdscr, (int )row, starta + cnt);
#line 268
    wrefresh(stdscr);
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 273 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/cursproc.c"
void askalias(struct remote *rp , int const   row , int const   musthave ) 
{ 
  int ch ;
  int starta ;
  int cnt ;
  char *hnp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;

  {
#line 278
  if (musthave) {
    {
#line 279
    hnp = rp->hostname;
#line 280
    mvprintw((int )row, 0, "Please give a name for this machine: ");
    }
  } else {
    {
#line 283
    hnp = rp->alias;
#line 284
    tmp___1 = strlen((char const   *)(rp->hostname));
    }
#line 284
    if (tmp___1 > 8UL) {
#line 284
      tmp___0 = " (probably a good idea)";
    } else {
#line 284
      tmp___0 = "";
    }
    {
#line 284
    mvprintw((int )row, 0, "Any alias for %s%s: ", rp->hostname, tmp___0);
    }
  }
#line 287
  if (stdscr) {
#line 287
    ch = (int )stdscr->_cury;
  } else {
#line 287
    ch = -1;
  }
#line 287
  if (stdscr) {
#line 287
    starta = (int )stdscr->_curx;
  } else {
#line 287
    starta = -1;
  }
  {
#line 288
  wrefresh(stdscr);
#line 290
  cnt = 0;
  }
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 294
    ch = wgetch(stdscr);
    }
    {
#line 298
    if (ch == 27) {
#line 298
      goto case_27;
    }
#line 315
    if (ch == 90) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 89) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 88) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 87) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 86) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 85) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 84) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 83) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 82) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 81) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 80) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 79) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 78) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 77) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 76) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 75) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 74) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 73) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 72) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 71) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 70) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 69) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 68) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 67) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 66) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 65) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 122) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 121) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 120) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 119) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 118) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 117) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 116) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 115) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 114) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 113) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 112) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 111) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 110) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 109) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 108) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 107) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 106) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 105) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 104) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 103) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 102) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 101) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 100) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 99) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 98) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 97) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 57) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 56) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 55) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 54) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 53) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 52) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 51) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 50) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 49) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 48) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 95) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 45) {
#line 315
      goto case_90;
    }
#line 315
    if (ch == 46) {
#line 315
      goto case_90;
    }
#line 332
    if (ch == 8) {
#line 332
      goto case_8;
    }
#line 332
    if (ch == 263) {
#line 332
      goto case_8;
    }
#line 332
    if (ch == 330) {
#line 332
      goto case_8;
    }
#line 332
    if (ch == 260) {
#line 332
      goto case_8;
    }
#line 346
    if (ch == 13) {
#line 346
      goto case_13;
    }
#line 346
    if (ch == 10) {
#line 346
      goto case_13;
    }
#line 346
    if (ch == 343) {
#line 346
      goto case_13;
    }
#line 295
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 296
    goto __Cont;
    case_27: /* CIL Label */ 
    {
#line 299
    longjmp((struct __jmp_buf_tag *)(escj), 1);
    }
    case_90: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_88: /* CIL Label */ 
    case_87: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_83: /* CIL Label */ 
    case_82: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_79: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_74: /* CIL Label */ 
    case_73: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_122: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_120: /* CIL Label */ 
    case_119: /* CIL Label */ 
    case_118: /* CIL Label */ 
    case_117: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_114: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_111: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_108: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_106: /* CIL Label */ 
    case_105: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_97: /* CIL Label */ 
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
    case_95: /* CIL Label */ 
    case_45: /* CIL Label */ 
    case_46: /* CIL Label */ 
#line 316
    if (cnt >= 14) {
#line 317
      goto __Cont;
    }
    {
#line 318
    tmp___2 = cnt;
#line 318
    cnt ++;
#line 318
    *(hnp + tmp___2) = (char )ch;
#line 319
    waddch(stdscr, (chtype const   )ch);
#line 320
    wrefresh(stdscr);
    }
#line 321
    goto __Cont;
    case_8: /* CIL Label */ 
    case_263: /* CIL Label */ 
    case_330: /* CIL Label */ 
    case_260: /* CIL Label */ 
#line 333
    if (cnt > 0) {
      {
#line 334
      cnt --;
#line 335
      *(hnp + cnt) = (char )'\000';
#line 336
      tmp___3 = wmove(stdscr, (int )row, starta + cnt);
      }
#line 336
      if (! (tmp___3 == -1)) {
        {
#line 336
        waddch(stdscr, (chtype const   )' ');
        }
      }
      {
#line 337
      wmove(stdscr, (int )row, starta + cnt);
#line 338
      wrefresh(stdscr);
      }
    }
#line 340
    goto __Cont;
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_343: /* CIL Label */ 
#line 347
    *(hnp + cnt) = (char )'\000';
#line 348
    if (cnt <= 0) {
#line 349
      if (! musthave) {
#line 350
        return;
      }
      {
#line 351
      wmove(stdscr, (int )(row - 1), 0);
#line 352
      wclrtoeol(stdscr);
      }
#line 353
      if (stdscr) {
#line 353
        stdscr->_attrs = 1UL << 16;
      }
      {
#line 354
      waddnstr(stdscr, "You must give some name for this host", -1);
      }
#line 355
      goto switch_break;
    }
    {
#line 357
    tmp___4 = __ctype_b_loc();
    }
#line 357
    if ((int const   )*(*tmp___4 + (int )*(hnp + 0)) & 2048) {
      {
#line 358
      wmove(stdscr, (int )(row - 1), 0);
#line 359
      wclrtoeol(stdscr);
      }
#line 360
      if (stdscr) {
#line 360
        stdscr->_attrs = 1UL << 16;
      }
      {
#line 361
      printw("%s is not a valid alias name", hnp);
      }
#line 362
      goto switch_break;
    }
    {
#line 364
    tmp___5 = hnameclashes((char const   *)hnp);
    }
#line 364
    if (tmp___5) {
      {
#line 365
      wmove(stdscr, (int )(row - 1), 0);
#line 366
      wclrtoeol(stdscr);
      }
#line 367
      if (stdscr) {
#line 367
        stdscr->_attrs = 1UL << 16;
      }
      {
#line 368
      printw("%s is already a host/alias name", hnp);
      }
#line 369
      goto switch_break;
    }
#line 371
    return;
    switch_break: /* CIL Label */ ;
    }
#line 373
    if (stdscr) {
#line 373
      stdscr->_attrs = 0UL;
    }
    {
#line 374
    wmove(stdscr, (int )row, starta + cnt);
#line 375
    wrefresh(stdscr);
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 379 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/cursproc.c"
void askuser(char *unam , int const   row , char const   *msg , int const   validate ,
             int const   nonull ) 
{ 
  int ch ;
  int starta ;
  int cnt ;
  int tmp ;
  int tmp___0 ;
  struct passwd *tmp___1 ;

  {
  {
#line 383
  mvprintw((int )row, 0, "%s: ", msg);
  }
#line 384
  if (stdscr) {
#line 384
    ch = (int )stdscr->_cury;
  } else {
#line 384
    ch = -1;
  }
#line 384
  if (stdscr) {
#line 384
    starta = (int )stdscr->_curx;
  } else {
#line 384
    starta = -1;
  }
  {
#line 385
  wrefresh(stdscr);
#line 387
  cnt = 0;
  }
  {
#line 389
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 391
    ch = wgetch(stdscr);
    }
    {
#line 394
    if (ch == 27) {
#line 394
      goto case_27;
    }
#line 397
    if (ch == 95) {
#line 397
      goto case_95;
    }
#line 397
    if (ch == 45) {
#line 397
      goto case_95;
    }
#line 397
    if (ch == 46) {
#line 397
      goto case_95;
    }
#line 401
    if (ch == 57) {
#line 401
      goto case_57;
    }
#line 401
    if (ch == 56) {
#line 401
      goto case_57;
    }
#line 401
    if (ch == 55) {
#line 401
      goto case_57;
    }
#line 401
    if (ch == 54) {
#line 401
      goto case_57;
    }
#line 401
    if (ch == 53) {
#line 401
      goto case_57;
    }
#line 401
    if (ch == 52) {
#line 401
      goto case_57;
    }
#line 401
    if (ch == 51) {
#line 401
      goto case_57;
    }
#line 401
    if (ch == 50) {
#line 401
      goto case_57;
    }
#line 401
    if (ch == 49) {
#line 401
      goto case_57;
    }
#line 401
    if (ch == 48) {
#line 401
      goto case_57;
    }
#line 415
    if (ch == 90) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 89) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 88) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 87) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 86) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 85) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 84) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 83) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 82) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 81) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 80) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 79) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 78) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 77) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 76) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 75) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 74) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 73) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 72) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 71) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 70) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 69) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 68) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 67) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 66) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 65) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 122) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 121) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 120) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 119) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 118) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 117) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 116) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 115) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 114) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 113) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 112) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 111) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 110) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 109) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 108) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 107) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 106) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 105) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 104) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 103) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 102) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 101) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 100) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 99) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 98) {
#line 415
      goto case_90;
    }
#line 415
    if (ch == 97) {
#line 415
      goto case_90;
    }
#line 431
    if (ch == 8) {
#line 431
      goto case_8;
    }
#line 431
    if (ch == 263) {
#line 431
      goto case_8;
    }
#line 431
    if (ch == 330) {
#line 431
      goto case_8;
    }
#line 431
    if (ch == 260) {
#line 431
      goto case_8;
    }
#line 445
    if (ch == 13) {
#line 445
      goto case_13;
    }
#line 445
    if (ch == 10) {
#line 445
      goto case_13;
    }
#line 445
    if (ch == 343) {
#line 445
      goto case_13;
    }
#line 392
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 393
    goto __Cont;
    case_27: /* CIL Label */ 
    {
#line 395
    longjmp((struct __jmp_buf_tag *)(escj), 1);
    }
    case_95: /* CIL Label */ 
    case_45: /* CIL Label */ 
    case_46: /* CIL Label */ 
#line 398
    if (validate) {
#line 399
      goto __Cont;
    }
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
#line 402
    if (cnt <= 0) {
#line 402
      if (validate) {
#line 403
        goto __Cont;
      }
    }
    case_90: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_88: /* CIL Label */ 
    case_87: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_83: /* CIL Label */ 
    case_82: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_79: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_74: /* CIL Label */ 
    case_73: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_122: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_120: /* CIL Label */ 
    case_119: /* CIL Label */ 
    case_118: /* CIL Label */ 
    case_117: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_114: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_111: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_108: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_106: /* CIL Label */ 
    case_105: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_97: /* CIL Label */ 
#line 416
    if (cnt >= 11) {
#line 417
      goto __Cont;
    }
    {
#line 418
    tmp = cnt;
#line 418
    cnt ++;
#line 418
    *(unam + tmp) = (char )ch;
#line 419
    waddch(stdscr, (chtype const   )ch);
#line 420
    wrefresh(stdscr);
    }
#line 421
    goto __Cont;
    case_8: /* CIL Label */ 
    case_263: /* CIL Label */ 
    case_330: /* CIL Label */ 
    case_260: /* CIL Label */ 
#line 432
    if (cnt > 0) {
      {
#line 433
      cnt --;
#line 434
      *(unam + cnt) = (char )'\000';
#line 435
      tmp___0 = wmove(stdscr, (int )row, starta + cnt);
      }
#line 435
      if (! (tmp___0 == -1)) {
        {
#line 435
        waddch(stdscr, (chtype const   )' ');
        }
      }
      {
#line 436
      wmove(stdscr, (int )row, starta + cnt);
#line 437
      wrefresh(stdscr);
      }
    }
#line 439
    goto __Cont;
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_343: /* CIL Label */ 
#line 446
    if (cnt <= 0) {
#line 446
      if (nonull) {
        {
#line 447
        wmove(stdscr, (int )(row - 1), 0);
#line 448
        wclrtoeol(stdscr);
        }
#line 449
        if (stdscr) {
#line 449
          stdscr->_attrs = 1UL << 16;
        }
        {
#line 450
        waddnstr(stdscr, "You must give some user", -1);
        }
#line 451
        if (stdscr) {
#line 451
          stdscr->_attrs = 0UL;
        }
        {
#line 452
        wmove(stdscr, (int )row, starta + cnt);
#line 453
        wrefresh(stdscr);
        }
#line 454
        goto __Cont;
      }
    }
#line 456
    *(unam + cnt) = (char )'\000';
#line 457
    if (validate) {
      {
#line 457
      tmp___1 = getpwnam((char const   *)unam);
      }
#line 457
      if (! tmp___1) {
        {
#line 458
        wmove(stdscr, (int )(row - 1), 0);
#line 459
        wclrtoeol(stdscr);
        }
#line 460
        if (stdscr) {
#line 460
          stdscr->_attrs = 1UL << 16;
        }
        {
#line 461
        printw("%s is not a valid user", unam);
        }
#line 462
        if (stdscr) {
#line 462
          stdscr->_attrs = 0UL;
        }
        {
#line 463
        wmove(stdscr, (int )row, starta + cnt);
#line 464
        wrefresh(stdscr);
        }
#line 465
        goto __Cont;
      }
    }
#line 467
    return;
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 472 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/cursproc.c"
void proc_addunixhost(void) 
{ 
  struct remote resrp ;
  enum IPatype tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 476
  memset((void *)(& resrp), '\000', sizeof(resrp));
#line 478
  wclear(stdscr);
#line 479
  tmp = askhname(resrp.hostname, (int const   )2, "Unix host name", & resrp);
#line 479
  askalias(& resrp, (int const   )4, (int const   )((unsigned int )tmp == 1U));
#line 480
  tmp___0 = ask((int const   )6, "Probe (check alive) before connecting", (int const   )1);
  }
#line 480
  if (tmp___0) {
#line 481
    resrp.ht_flags = (unsigned short )((int )resrp.ht_flags | (1 << 1));
  }
  {
#line 482
  tmp___1 = ask((int const   )8, "Trust host with user information", (int const   )1);
  }
#line 482
  if (tmp___1) {
#line 483
    resrp.ht_flags = (unsigned short )((int )resrp.ht_flags | (1 << 6));
  }
  {
#line 484
  tmp___2 = ask((int const   )10, "Manual Connections only", (int const   )0);
  }
#line 484
  if (tmp___2) {
#line 485
    resrp.ht_flags = (unsigned short )((int )resrp.ht_flags | (1 << 2));
  }
  {
#line 487
  asktimeout(& resrp, (int const   )12);
#line 488
  addhostentry((struct remote  const  *)(& resrp));
  }
#line 489
  return;
}
}
#line 491 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/cursproc.c"
void proc_addwinhost(void) 
{ 
  int nxtrow ;
  struct remote resrp ;
  enum IPatype tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 496
  memset((void *)(& resrp), '\000', sizeof(resrp));
#line 498
  resrp.ht_flags = (unsigned short )((int )resrp.ht_flags | (1 << 3));
#line 500
  wclear(stdscr);
#line 501
  nxtrow = 10;
#line 503
  tmp___1 = ask((int const   )2, "Specific Windows Host (Y) or `roaming user\' (N)",
                (int const   )1);
  }
#line 503
  if (tmp___1) {
    {
#line 504
    tmp = askhname(resrp.hostname, (int const   )4, "Windows client host name", & resrp);
#line 504
    askalias(& resrp, (int const   )6, (int const   )((unsigned int )tmp == 1U));
#line 505
    askuser(resrp.dosuser, (int const   )8, "Default user", (int const   )1, (int const   )0);
    }
  } else {
    {
#line 508
    resrp.ht_flags = (unsigned short )((int )resrp.ht_flags | (1 << 5));
#line 509
    askuser(resrp.hostname, (int const   )4, "Unix user name", (int const   )1, (int const   )1);
#line 510
    askuser(resrp.alias, (int const   )6, "Windows user name", (int const   )0, (int const   )0);
#line 511
    tmp___0 = ask((int const   )8, "Do you want to specify a default machine name",
                  (int const   )0);
    }
#line 511
    if (tmp___0) {
      {
#line 512
      askhname(resrp.dosuser, (int const   )10, "Default unix host name", (struct remote *)0);
#line 513
      nxtrow = 12;
      }
    }
  }
  {
#line 516
  tmp___2 = ask((int const   )nxtrow, "Password-check user(s)", (int const   )0);
  }
#line 516
  if (tmp___2) {
#line 517
    resrp.ht_flags = (unsigned short )((int )resrp.ht_flags | (1 << 4));
  }
  {
#line 519
  asktimeout(& resrp, (int const   )(nxtrow + 2));
#line 520
  addhostentry((struct remote  const  *)(& resrp));
  }
#line 521
  return;
}
}
#line 523 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/cursproc.c"
void proc_addhost(void) 
{ 
  int tmp ;

  {
  {
#line 525
  wclear(stdscr);
#line 526
  tmp = ask((int const   )(LINES / 2), "Is new entry a Unix host(Y) or Client(N)",
            (int const   )1);
  }
#line 526
  if (tmp) {
    {
#line 527
    proc_addunixhost();
    }
  } else {
    {
#line 529
    proc_addwinhost();
    }
  }
#line 530
  return;
}
}
#line 532 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/cursproc.c"
void proc_chnghost(struct remote *rp ) 
{ 
  int changes ;
  int nxtline ;
  struct remote resrp ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  int tmp___11 ;
  char const   *tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  char const   *tmp___18 ;
  int tmp___19 ;
  char const   *tmp___20 ;
  int tmp___21 ;
  char const   *tmp___22 ;
  int tmp___23 ;
  char const   *tmp___24 ;
  int tmp___25 ;
  unsigned int tmp___26 ;
  int tmp___27 ;

  {
  {
#line 534
  changes = 0;
#line 534
  nxtline = 0;
#line 536
  resrp = *rp;
#line 538
  wclear(stdscr);
  }
#line 540
  if ((int )resrp.ht_flags & (1 << 3)) {
#line 541
    if ((int )resrp.ht_flags & (1 << 5)) {
#line 542
      if (resrp.dosuser[0]) {
#line 542
        tmp = (char const   *)(resrp.dosuser);
      } else {
#line 542
        tmp = "<none>";
      }
#line 542
      if (resrp.alias[0]) {
#line 542
        tmp___0 = (char const   *)(resrp.alias);
      } else {
#line 542
        tmp___0 = "<none>";
      }
      {
#line 542
      mvprintw(nxtline, 0, "Roaming user %s windows %s default client %s", resrp.hostname,
               tmp___0, tmp);
#line 546
      nxtline += 2;
#line 547
      tmp___1 = ask((int const   )nxtline, "Change Unix user name", (int const   )0);
      }
#line 547
      if (tmp___1) {
        {
#line 548
        nxtline += 2;
#line 549
        askuser(resrp.hostname, (int const   )nxtline, "New unix user", (int const   )1,
                (int const   )1);
#line 550
        changes ++;
#line 551
        nxtline += 2;
        }
      }
#line 553
      if (resrp.alias[0]) {
#line 553
        tmp___2 = "Change windows user/alias";
      } else {
#line 553
        tmp___2 = "Specify windows/user/alias";
      }
      {
#line 553
      tmp___3 = ask((int const   )nxtline, tmp___2, (int const   )0);
      }
#line 553
      if (tmp___3) {
        {
#line 554
        nxtline += 2;
#line 555
        askuser(resrp.alias, (int const   )nxtline, "Windows user", (int const   )0,
                (int const   )0);
#line 556
        changes ++;
#line 557
        nxtline += 2;
        }
      }
#line 559
      if (resrp.dosuser[0]) {
#line 559
        tmp___4 = "Change default client";
      } else {
#line 559
        tmp___4 = "Specify default client";
      }
      {
#line 559
      tmp___5 = ask((int const   )nxtline, tmp___4, (int const   )0);
      }
#line 559
      if (tmp___5) {
        {
#line 560
        nxtline += 2;
#line 561
        askhname(resrp.dosuser, (int const   )nxtline, "Default unix host name", (struct remote *)0);
#line 562
        changes ++;
#line 563
        nxtline += 2;
        }
      }
    } else {
#line 567
      if ((int )resrp.ht_flags & 1) {
        {
#line 568
        tmp___6 = phname(resrp.hostid, (enum IPatype  const  )0);
#line 568
        mvprintw(nxtline, 0, "Windows client %s named %s", tmp___6, resrp.hostname);
        }
      } else {
        {
#line 570
        mvprintw(nxtline, 0, "Windows client %s", resrp.hostname);
        }
#line 571
        if (resrp.alias[0]) {
          {
#line 572
          printw(" alias %s", resrp.alias);
          }
        }
      }
#line 574
      if (resrp.dosuser[0]) {
        {
#line 575
        printw("Default user %s", resrp.dosuser);
        }
      }
#line 576
      nxtline += 2;
#line 577
      if ((int )resrp.ht_flags & 1) {
        {
#line 578
        tmp___7 = ask((int const   )nxtline, "Change host name", (int const   )0);
        }
#line 578
        if (tmp___7) {
          {
#line 579
          nxtline += 2;
#line 580
          askalias(& resrp, (int const   )nxtline, (int const   )1);
#line 581
          changes ++;
#line 582
          nxtline += 2;
          }
        }
#line 584
        if (resrp.dosuser[0]) {
#line 584
          tmp___8 = "Change default client";
        } else {
#line 584
          tmp___8 = "Specify default client";
        }
        {
#line 584
        tmp___9 = ask((int const   )nxtline, tmp___8, (int const   )0);
        }
#line 584
        if (tmp___9) {
          {
#line 585
          nxtline += 2;
#line 586
          askhname(resrp.dosuser, (int const   )nxtline, "Host name", (struct remote *)0);
#line 587
          nxtline += 2;
#line 588
          changes ++;
          }
        }
      } else {
#line 592
        if (resrp.alias[0]) {
#line 592
          tmp___10 = "Change alias name";
        } else {
#line 592
          tmp___10 = "Specify alias name";
        }
        {
#line 592
        tmp___11 = ask((int const   )nxtline, tmp___10, (int const   )0);
        }
#line 592
        if (tmp___11) {
          {
#line 593
          nxtline += 2;
#line 594
          askalias(& resrp, (int const   )nxtline, (int const   )0);
#line 595
          changes ++;
#line 596
          nxtline += 2;
          }
        }
#line 598
        if (resrp.dosuser[0]) {
#line 598
          tmp___12 = "Change default user";
        } else {
#line 598
          tmp___12 = "Specify default user";
        }
        {
#line 598
        tmp___13 = ask((int const   )nxtline, tmp___12, (int const   )0);
        }
#line 598
        if (tmp___13) {
          {
#line 599
          nxtline += 2;
#line 600
          askuser(resrp.dosuser, (int const   )nxtline, "Default user", (int const   )1,
                  (int const   )0);
#line 601
          changes ++;
#line 602
          nxtline += 2;
          }
        }
      }
    }
#line 607
    if ((int )resrp.ht_flags & (1 << 4)) {
#line 607
      tmp___14 = "Turn off password check";
    } else {
#line 607
      tmp___14 = "Turn on password check";
    }
    {
#line 607
    tmp___15 = ask((int const   )nxtline, tmp___14, (int const   )0);
    }
#line 607
    if (tmp___15) {
#line 608
      nxtline += 2;
#line 609
      changes ++;
#line 610
      resrp.ht_flags = (unsigned short )((int )resrp.ht_flags ^ (1 << 4));
    }
  } else {
#line 614
    if ((int )resrp.ht_flags & 1) {
      {
#line 615
      tmp___16 = phname(resrp.hostid, (enum IPatype  const  )0);
#line 615
      mvprintw(nxtline, 0, "Unix host %s named %s", tmp___16, resrp.hostname);
      }
    } else {
      {
#line 617
      mvprintw(nxtline, 0, "Unix host %s", resrp.hostname);
      }
#line 618
      if (resrp.alias[0]) {
        {
#line 619
        printw(" alias %s", resrp.alias);
        }
      }
    }
#line 621
    nxtline += 2;
#line 622
    if ((int )resrp.ht_flags & 1) {
      {
#line 623
      tmp___17 = ask((int const   )nxtline, "Change host name", (int const   )0);
      }
#line 623
      if (tmp___17) {
        {
#line 624
        nxtline += 2;
#line 625
        askalias(& resrp, (int const   )nxtline, (int const   )1);
#line 626
        changes ++;
        }
      }
    } else {
#line 629
      if (resrp.alias[0]) {
#line 629
        tmp___18 = "Change alias name";
      } else {
#line 629
        tmp___18 = "Specify alias name";
      }
      {
#line 629
      tmp___19 = ask((int const   )nxtline, tmp___18, (int const   )0);
      }
#line 629
      if (tmp___19) {
        {
#line 630
        nxtline += 2;
#line 631
        askalias(& resrp, (int const   )nxtline, (int const   )0);
#line 632
        changes ++;
        }
      }
    }
#line 634
    nxtline += 2;
#line 635
    if ((int )resrp.ht_flags & (1 << 1)) {
#line 635
      tmp___20 = "Turn off probe";
    } else {
#line 635
      tmp___20 = "Turn on probe";
    }
    {
#line 635
    tmp___21 = ask((int const   )nxtline, tmp___20, (int const   )0);
    }
#line 635
    if (tmp___21) {
#line 636
      changes ++;
#line 637
      resrp.ht_flags = (unsigned short )((int )resrp.ht_flags ^ (1 << 1));
    }
#line 639
    nxtline += 2;
#line 640
    if ((int )resrp.ht_flags & (1 << 2)) {
#line 640
      tmp___22 = "Turn off manual connect";
    } else {
#line 640
      tmp___22 = "Turn on manual connect";
    }
    {
#line 640
    tmp___23 = ask((int const   )nxtline, tmp___22, (int const   )0);
    }
#line 640
    if (tmp___23) {
#line 641
      changes ++;
#line 642
      resrp.ht_flags = (unsigned short )((int )resrp.ht_flags ^ (1 << 2));
    }
#line 644
    nxtline += 2;
#line 645
    if ((int )resrp.ht_flags & (1 << 6)) {
#line 645
      tmp___24 = "Turn off trust";
    } else {
#line 645
      tmp___24 = "Turn on trust";
    }
    {
#line 645
    tmp___25 = ask((int const   )nxtline, tmp___24, (int const   )0);
    }
#line 645
    if (tmp___25) {
#line 646
      changes ++;
#line 647
      resrp.ht_flags = (unsigned short )((int )resrp.ht_flags ^ (1 << 6));
    }
#line 649
    nxtline += 2;
  }
#line 652
  if ((int )resrp.ht_timeout != 1000) {
    {
#line 653
    mvprintw(nxtline, 0, "Timeout value is set to %u (default %u).", (int )resrp.ht_timeout,
             1000);
    }
  } else {
    {
#line 655
    mvprintw(nxtline, 0, "Timeout set to default of %u", (int )resrp.ht_timeout);
    }
  }
  {
#line 657
  tmp___27 = ask((int const   )(nxtline + 2), "Change it", (int const   )0);
  }
#line 657
  if (tmp___27) {
    {
#line 658
    tmp___26 = askn((int const   )(nxtline + 4), "New timeout value");
#line 658
    resrp.ht_timeout = (unsigned short )tmp___26;
#line 659
    changes ++;
    }
  }
#line 661
  if (changes) {
#line 662
    *rp = resrp;
  }
#line 663
  return;
}
}
#line 665 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/cursproc.c"
void proc_locaddr(void) 
{ 
  int nxtline ;
  struct hostent *hp ;
  char myname[256] ;
  int tmp ;
  struct remote dummr ;
  int tmp___0 ;

  {
  {
#line 667
  nxtline = LINES / 3;
#line 669
  wclear(stdscr);
  }
#line 671
  if ((unsigned int )hadlocaddr != 0U) {
    {
#line 672
    tmp = ask((int const   )nxtline, "Local address set, do you want to unset it",
              (int const   )0);
    }
#line 672
    if (tmp) {
      {
#line 675
      myname[sizeof(myname) - 1UL] = (char )'\000';
#line 676
      gethostname(myname, sizeof(myname) - 1UL);
#line 677
      hp = gethostbyname((char const   *)(myname));
      }
#line 677
      if (hp) {
#line 678
        myhostid = *((netid_t *)*(hp->h_addr_list + 0));
#line 679
        hadlocaddr = (enum IPatype )0;
      }
    }
  } else {
    {
#line 683
    tmp___0 = ask((int const   )nxtline, "Do you want to set a local address", (int const   )0);
    }
#line 683
    if (tmp___0) {
      {
#line 685
      memset((void *)(& dummr), '\000', sizeof(dummr));
#line 686
      hadlocaddr = askhname(dummr.hostname, (int const   )(nxtline + 2), "Local address",
                            & dummr);
#line 687
      myhostid = dummr.hostid;
      }
    }
  }
#line 689
  return;
}
}
#line 691 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/cursproc.c"
void proc_defuser(void) 
{ 
  int nxtline ;
  int tmp ;
  char wuser[12] ;
  int tmp___0 ;

  {
  {
#line 693
  nxtline = LINES / 3;
#line 695
  wclear(stdscr);
  }
#line 697
  if (defcluser[0]) {
    {
#line 698
    tmp = ask((int const   )nxtline, "Default user set, do you want to unset it",
              (int const   )0);
    }
#line 698
    if (tmp) {
#line 699
      defcluser[0] = (char )'\000';
    }
  } else {
    {
#line 701
    tmp___0 = ask((int const   )nxtline, "Do you want to set a default client user name",
                  (int const   )0);
    }
#line 701
    if (tmp___0) {
      {
#line 703
      askuser(wuser, (int const   )(nxtline + 1), "Default user", (int const   )1,
              (int const   )1);
#line 704
      strcpy((char */* __restrict  */)(defcluser), (char const   */* __restrict  */)(wuser));
      }
    }
  }
#line 706
  return;
}
}
#line 708 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/cursproc.c"
void enhancep(char const   *str ) 
{ 


  {
  {
#line 710
  while (1) {
    while_continue: /* CIL Label */ ;
#line 710
    if (! *str) {
#line 710
      goto while_break;
    }
#line 711
    if ((int const   )*str == 38) {
#line 712
      str ++;
#line 712
      if (! *str) {
#line 713
        return;
      }
      {
#line 715
      wattr_on(stdscr, 1UL << 17, (void *)0);
#line 719
      waddch(stdscr, (chtype const   )*str);
#line 721
      wattr_off(stdscr, 1UL << 17, (void *)0);
      }
    } else {
      {
#line 727
      waddch(stdscr, (chtype const   )*str);
      }
    }
#line 728
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 730
  return;
}
}
#line 732 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/cursproc.c"
void disp_hostlist(int const   startrow ) 
{ 
  int cnt ;
  int row ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  struct remote *rp ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 736
  wclear(stdscr);
#line 738
  enhancep("&add host &change host &delete host &local addr default &user &quit");
#line 739
  mvprintw(1, 0, "Host");
#line 740
  mvprintw(1, 20, "Alias");
#line 741
  mvprintw(1, 35, "IP Addr");
#line 742
  mvprintw(2, 0, "Unix");
#line 743
  mvprintw(2, 12, "Win");
#line 744
  mvprintw(2, 60, "User");
#line 745
  mvprintw(2, 51, "Dft mc");
  }
#line 747
  if ((unsigned int )hadlocaddr != 0U) {
    {
#line 748
    mvprintw(3, 0, "Local Address:");
    }
#line 749
    if ((unsigned int )hadlocaddr == 2U) {
      {
#line 750
      tmp = phname(myhostid, (enum IPatype  const  )2);
#line 750
      printw("%s", tmp);
      }
    }
  } else {
    {
#line 753
    tmp___0 = phname(myhostid, (enum IPatype  const  )2);
#line 753
    mvprintw(3, 0, "Current: %s", tmp___0);
    }
  }
  {
#line 754
  tmp___1 = phname(myhostid, (enum IPatype  const  )1);
#line 754
  mvprintw(3, 35, (char const   *)tmp___1);
  }
#line 755
  if (defcluser[0]) {
    {
#line 756
    mvprintw(4, 0, "Default client user: %s", defcluser);
    }
  }
#line 758
  row = 5;
#line 758
  cnt = (int )startrow;
  {
#line 758
  while (1) {
    while_continue: /* CIL Label */ ;
#line 758
    if (row < LINES) {
#line 758
      if (! (cnt < hostnum)) {
#line 758
        goto while_break;
      }
    } else {
#line 758
      goto while_break;
    }
#line 759
    rp = hostlist + cnt;
#line 760
    if ((int )rp->ht_flags & (1 << 3)) {
#line 761
      if ((int )rp->ht_flags & (1 << 5)) {
        {
#line 762
        mvprintw(row, 0, "%s", rp->hostname);
        }
#line 763
        if (rp->alias[0]) {
          {
#line 764
          mvprintw(row, 12, "%s", rp->alias);
          }
        }
        {
#line 765
        mvprintw(row, 35, "Roam");
        }
#line 766
        if (rp->dosuser[0]) {
          {
#line 767
          mvprintw(row, 51, "%s", rp->dosuser);
          }
        }
      } else {
#line 770
        if ((int )rp->ht_flags & 1) {
          {
#line 771
          tmp___2 = phname(rp->hostid, (enum IPatype  const  )1);
#line 771
          mvprintw(row, 0, "%s", tmp___2);
#line 772
          mvprintw(row, 20, "%s", rp->hostname);
          }
        } else {
          {
#line 775
          mvprintw(row, 0, "%s", rp->hostname);
          }
#line 776
          if (rp->alias[0]) {
            {
#line 777
            mvprintw(row, 20, (char const   *)(rp->alias));
            }
          }
          {
#line 778
          tmp___3 = phname(rp->hostid, (enum IPatype  const  )1);
#line 778
          mvprintw(row, 35, "%s", tmp___3);
          }
        }
        {
#line 780
        mvprintw(row, 51, "Client");
        }
#line 781
        if (rp->dosuser[0]) {
          {
#line 782
          mvprintw(row, 60, "%s", rp->dosuser);
          }
        }
      }
#line 784
      if ((int )rp->ht_flags & (1 << 4)) {
        {
#line 785
        mvprintw(row, 70, "Pwchk");
        }
      }
    } else {
#line 788
      if ((int )rp->ht_flags & 1) {
        {
#line 789
        tmp___4 = phname(rp->hostid, (enum IPatype  const  )1);
#line 789
        mvprintw(row, 0, "%s", tmp___4);
#line 790
        mvprintw(row, 20, "%s", rp->hostname);
        }
      } else {
        {
#line 793
        mvprintw(row, 0, "%s", rp->hostname);
        }
#line 794
        if (rp->alias[0]) {
          {
#line 795
          mvprintw(row, 20, (char const   *)(rp->alias));
          }
        }
        {
#line 796
        tmp___5 = phname(rp->hostid, (enum IPatype  const  )1);
#line 796
        mvprintw(row, 35, "%s", tmp___5);
        }
      }
#line 799
      if ((int )rp->ht_flags & (1 << 1)) {
        {
#line 800
        mvprintw(row, 51, "probe");
        }
      }
#line 801
      if ((int )rp->ht_flags & (1 << 2)) {
        {
#line 802
        mvprintw(row, 57, "manual");
        }
      }
#line 803
      if ((int )rp->ht_flags & (1 << 6)) {
        {
#line 804
        mvprintw(row, 65, "trusted");
        }
      }
    }
#line 806
    if ((int )rp->ht_timeout != 1000) {
      {
#line 807
      mvprintw(row, 77, "TO");
      }
    }
#line 758
    row ++;
#line 758
    cnt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 809
  return;
}
}
#line 811 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/cursproc.c"
void proc_hostfile(void) 
{ 
  int topline ;
  int currline ;
  int ch ;
  int tmp ;

  {
  {
#line 815
  initscr();
#line 816
  raw();
#line 817
  nonl();
#line 818
  noecho();
#line 819
  keypad(stdscr, (_Bool)1);
#line 821
  currline = 0;
#line 821
  topline = currline;
#line 823
  _setjmp((struct __jmp_buf_tag *)(escj));
  }
  refill: 
  {
#line 825
  disp_hostlist((int const   )topline);
  }
  {
#line 827
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 830
    wmove(stdscr, (currline - topline) + 5, 0);
#line 831
    wrefresh(stdscr);
#line 833
    ch = wgetch(stdscr);
    }
    {
#line 836
    if (ch == 113) {
#line 836
      goto case_113;
    }
#line 845
    if (ch == 56) {
#line 845
      goto case_56;
    }
#line 845
    if (ch == 107) {
#line 845
      goto case_56;
    }
#line 845
    if (ch == 259) {
#line 845
      goto case_56;
    }
#line 866
    if (ch == 80) {
#line 866
      goto case_80;
    }
#line 866
    if (ch == 339) {
#line 866
      goto case_80;
    }
#line 866
    if (ch == 370) {
#line 866
      goto case_80;
    }
#line 874
    if (ch == 50) {
#line 874
      goto case_50;
    }
#line 874
    if (ch == 106) {
#line 874
      goto case_50;
    }
#line 874
    if (ch == 258) {
#line 874
      goto case_50;
    }
#line 893
    if (ch == 78) {
#line 893
      goto case_78;
    }
#line 893
    if (ch == 338) {
#line 893
      goto case_78;
    }
#line 893
    if (ch == 367) {
#line 893
      goto case_78;
    }
#line 897
    if (ch == 100) {
#line 897
      goto case_100;
    }
#line 916
    if (ch == 97) {
#line 916
      goto case_97;
    }
#line 920
    if (ch == 99) {
#line 920
      goto case_99;
    }
#line 926
    if (ch == 108) {
#line 926
      goto case_108;
    }
#line 930
    if (ch == 117) {
#line 930
      goto case_117;
    }
#line 834
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 835
    goto switch_break;
    case_113: /* CIL Label */ 
    {
#line 837
    wclear(stdscr);
#line 838
    wrefresh(stdscr);
#line 839
    endwin();
    }
#line 840
    return;
    case_56: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_259: /* CIL Label */ 
#line 846
    currline --;
    decrest: 
#line 848
    if (currline >= topline) {
#line 849
      goto __Cont;
    }
#line 850
    if (topline <= 0) {
#line 851
      currline = 0;
#line 852
      goto __Cont;
    }
#line 854
    topline = currline;
#line 855
    if (topline >= 0) {
#line 856
      goto refill;
    }
#line 857
    currline = 0;
#line 857
    topline = currline;
#line 858
    goto __Cont;
    case_80: /* CIL Label */ 
    case_339: /* CIL Label */ 
    case_370: /* CIL Label */ 
#line 867
    currline -= LINES - 5;
#line 868
    goto decrest;
    case_50: /* CIL Label */ 
    case_106: /* CIL Label */ 
    case_258: /* CIL Label */ 
#line 875
    currline ++;
    increst: 
#line 877
    if (currline >= hostnum) {
#line 878
      currline = hostnum - 1;
#line 879
      if (currline < 0) {
#line 880
        currline = 0;
      }
    }
#line 882
    if (currline - topline < LINES - 5) {
#line 883
      goto __Cont;
    }
#line 884
    topline = ((currline + 5) - LINES) - 1;
#line 885
    goto refill;
    case_78: /* CIL Label */ 
    case_338: /* CIL Label */ 
    case_367: /* CIL Label */ 
#line 894
    currline += LINES - 5;
#line 895
    goto increst;
    case_100: /* CIL Label */ 
#line 898
    if (hostnum <= 0) {
#line 899
      goto __Cont;
    }
    {
#line 900
    tmp = ask((int const   )((currline - topline) + 5), "Sure about deleting that",
              (int const   )0);
    }
#line 900
    if (tmp) {
#line 901
      hostnum --;
#line 902
      ch = currline;
      {
#line 902
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 902
        if (! (ch < hostnum)) {
#line 902
          goto while_break___0;
        }
#line 903
        *(hostlist + ch) = *(hostlist + (ch + 1));
#line 902
        ch ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 904
      if (currline >= hostnum) {
#line 905
        currline --;
#line 906
        if (currline < topline) {
#line 907
          topline = currline;
#line 908
          if (topline < 0) {
#line 909
            topline = 0;
#line 909
            currline = topline;
          }
        }
      }
    }
    {
#line 913
    disp_hostlist((int const   )topline);
    }
#line 914
    goto __Cont;
    case_97: /* CIL Label */ 
    {
#line 917
    proc_addhost();
    }
#line 918
    goto refill;
    case_99: /* CIL Label */ 
#line 921
    if (hostnum <= 0) {
#line 922
      goto __Cont;
    }
    {
#line 923
    proc_chnghost(hostlist + currline);
    }
#line 924
    goto refill;
    case_108: /* CIL Label */ 
    {
#line 927
    proc_locaddr();
    }
#line 928
    goto refill;
    case_117: /* CIL Label */ 
    {
#line 931
    proc_defuser();
    }
#line 932
    goto refill;
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 278
extern FILE *freopen(char const   * __restrict  __filename , char const   * __restrict  __modes ,
                     FILE * __restrict  __stream ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 531
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/hostedit.c"
int main(int argc , char **argv ) 
{ 
  int ch ;
  int outfd ;
  int inplace ;
  FILE *outfil ;
  char *inf ;
  char *outf ;
  FILE *tmp ;
  FILE *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 31
  inplace = 0;
#line 33
  inf = (char *)0;
#line 33
  outf = (char *)0;
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 37
    ch = getopt(argc, (char * const  *)argv, "Io:s:");
    }
#line 37
    if (! (ch != -1)) {
#line 37
      goto while_break;
    }
    {
#line 42
    if (ch == 73) {
#line 42
      goto case_73;
    }
#line 45
    if (ch == 111) {
#line 45
      goto case_111;
    }
#line 48
    if (ch == 115) {
#line 48
      goto case_115;
    }
#line 39
    goto switch_default;
    switch_default: /* CIL Label */ 
    {
#line 40
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [-I] [-o file] [file]\n",
            *(argv + 0));
    }
#line 41
    return (1);
    case_73: /* CIL Label */ 
#line 43
    inplace ++;
#line 44
    goto while_continue;
    case_111: /* CIL Label */ 
#line 46
    outf = optarg;
#line 47
    goto while_continue;
    case_115: /* CIL Label */ 
    {
#line 53
    if ((int )*(optarg + 0) == 104) {
#line 53
      goto case_104;
    }
#line 56
    if ((int )*(optarg + 0) == 105) {
#line 56
      goto case_105;
    }
#line 50
    goto switch_default___0;
    switch_default___0: /* CIL Label */ 
#line 51
    sort_type = (enum Stype )0;
#line 52
    goto while_continue;
    case_104: /* CIL Label */ 
#line 54
    sort_type = (enum Stype )1;
#line 55
    goto while_continue;
    case_105: /* CIL Label */ 
#line 57
    sort_type = (enum Stype )2;
#line 58
    goto while_continue;
    switch_break___0: /* CIL Label */ ;
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  if (*(argv + optind)) {
#line 64
    inf = *(argv + optind);
  } else
#line 65
  if (inplace) {
    {
#line 66
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-I option requires file arg\n");
    }
#line 67
    return (1);
  }
#line 70
  if (outf) {
#line 71
    if (inplace) {
      {
#line 72
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-I option and -o %s option are not compatible\n",
              outf);
      }
#line 73
      return (1);
    }
    {
#line 75
    tmp = freopen((char const   */* __restrict  */)outf, (char const   */* __restrict  */)"w",
                  (FILE */* __restrict  */)stdout);
    }
#line 75
    if (! tmp) {
      {
#line 76
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open output file %s\n",
              outf);
      }
#line 77
      return (2);
    }
  }
  {
#line 81
  load_hostfile((char const   *)inf);
  }
#line 82
  if (hostf_errors) {
    {
#line 83
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: There were error(s) in your host file!\n");
#line 84
    fflush(stderr);
#line 85
    sleep(2U);
    }
  }
#line 88
  if (inplace) {
    {
#line 88
    tmp___0 = freopen((char const   */* __restrict  */)inf, (char const   */* __restrict  */)"w",
                      (FILE */* __restrict  */)stdout);
    }
#line 88
    if (! tmp___0) {
      {
#line 89
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot reopen input file %s for writing\n",
              inf);
      }
#line 90
      return (5);
    }
  }
  {
#line 93
  sortit();
#line 95
  outfd = dup(1);
#line 96
  outfil = fdopen(outfd, "w");
  }
#line 96
  if (! outfil) {
    {
#line 97
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot dup output file\n");
    }
#line 98
    return (3);
  }
  {
#line 100
  close(0);
#line 101
  close(1);
#line 102
  close(2);
#line 103
  tmp___1 = open("/dev/tty", 2);
#line 103
  tmp___2 = dup(tmp___1);
#line 103
  tmp___3 = dup(tmp___2);
  }
#line 103
  if (tmp___3 < 0) {
    {
#line 104
    exit(99);
    }
  }
  {
#line 105
  proc_hostfile();
#line 106
  dump_hostfile(outfil);
  }
#line 107
  return (0);
}
}
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 263
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 321
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 208
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) rewinddir)(DIR *__dirp ) ;
#line 790 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) link)(char const   *__from ,
                                                                                             char const   *__to ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 126 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/hdefs.h"
struct valname *lookupname(char const   *name ) ;
#line 133
long evaluate(struct valexpr *ve ) ;
#line 147
void scanmodules(void) ;
#line 147
void scanmodule(struct module *mp ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/helpparse.c"
static char codelst[10]  = 
#line 29 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/helpparse.c"
  {      (char )'E',      (char )'H',      (char )'P',      (char )'Q', 
        (char )'A',      (char )'K',      (char )'N',      (char )'S', 
        (char )'X',      (char )'\000'};
#line 30
struct helpfile helpfiles[10] ;
#line 31
int errors ;
#line 31
int line_count ;
#line 31
int pass1 ;
#line 33 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/helpparse.c"
char *srcdir  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/helpparse.c"
char *destdir  ;
#line 34 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/helpparse.c"
static FILE *kdescrfile  ;
#line 38
void resetlex(void) ;
#line 39
void nomem(void) ;
#line 40
int yyparse(void) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/helpparse.c"
void add_helpref(struct valname *vp , struct module *mp , unsigned int flags ) 
{ 
  struct program_list *pl ;
  struct helpfile *hf ;
  struct helpfile_list *hfl ;
  void *tmp ;

  {
#line 52
  pl = mp->mod_pl;
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (! pl) {
#line 52
      goto while_break;
    }
#line 53
    hf = (pl->pl_prog)->prog_hf;
#line 54
    hfl = vp->vn_hlist;
    {
#line 54
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 54
      if (! hfl) {
#line 54
        goto while_break___0;
      }
#line 55
      if ((unsigned long )hfl->hfl_hf == (unsigned long )hf) {
#line 56
        hfl->hfl_flags |= flags;
#line 57
        goto nxt;
      }
#line 54
      hfl = hfl->hfl_next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 59
    tmp = malloc(sizeof(struct helpfile_list ));
#line 59
    hfl = (struct helpfile_list *)tmp;
    }
#line 60
    if (! hfl) {
      {
#line 61
      nomem();
      }
    }
#line 62
    hfl->hfl_hf = hf;
#line 63
    hfl->hfl_next = vp->vn_hlist;
#line 64
    hfl->hfl_flags = flags;
#line 65
    vp->vn_hlist = hfl;
    nxt: 
#line 52
    pl = pl->pl_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/helpparse.c"
void record_help(struct helpfile *hf , char const   htype , long const   h1 , long const   h2 ) 
{ 
  unsigned long hashval ;
  struct hadhelp *hv ;
  void *tmp ;

  {
#line 73
  hashval = (unsigned long )(((long const   )((int )htype * 97) + h2 * 13L) + h1) % 127UL;
#line 76
  hv = hf->hf_hash[hashval];
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! hv) {
#line 76
      goto while_break;
    }
#line 77
    if ((int )hv->had_char == (int )htype) {
#line 77
      if (hv->had_value == (long )h1) {
#line 77
        if (hv->had_state == (long )h2) {
          {
#line 78
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: duplicate %ld %c %ld in help file %s\n",
                  h2, (int const   )htype, h1, hf->hf_name);
          }
#line 79
          return;
        }
      }
    }
#line 76
    hv = hv->had_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 82
  tmp = malloc(sizeof(struct hadhelp ));
#line 82
  hv = (struct hadhelp *)tmp;
  }
#line 82
  if (! hv) {
    {
#line 83
    nomem();
    }
  }
#line 84
  hv->had_next = hf->hf_hash[hashval];
#line 85
  hf->hf_hash[hashval] = hv;
#line 86
  hv->had_value = (long )h1;
#line 87
  hv->had_state = (long )h2;
#line 88
  hv->had_char = (char )htype;
#line 89
  return;
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/helpparse.c"
void scanmodule(struct module *mp ) 
{ 
  FILE *modin ;
  FILE *modout ;
  int mod_line ;
  int vp_count ;
  int vncount ;
  int cnt ;
  int ch ;
  unsigned int flags ;
  long finger ;
  struct valname *vp ;
  struct valname *vp_list[5] ;
  char valnbuf[100] ;
  char mod_path[4096] ;
  int tmp ;
  char mod_path___0[4096] ;
  int cnt___0 ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 95
  mod_line = 1;
#line 96
  vp_count = 0;
#line 102
  if (mp->mod_subdir) {
    {
#line 104
    sprintf((char */* __restrict  */)(mod_path), (char const   */* __restrict  */)"%s/%s/%s",
            srcdir, mp->mod_subdir, mp->mod_name);
#line 105
    modin = fopen((char const   */* __restrict  */)(mod_path), (char const   */* __restrict  */)"r");
    }
#line 106
    if (! modin) {
      {
#line 107
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Sorry cannot open source file %s\n",
              mod_path);
#line 108
      exit(20);
      }
    }
    {
#line 110
    sprintf((char */* __restrict  */)(mod_path), (char const   */* __restrict  */)"%s/%s/%s",
            destdir, mp->mod_subdir, mp->mod_name);
#line 111
    modout = fopen((char const   */* __restrict  */)(mod_path), (char const   */* __restrict  */)"w");
    }
#line 112
    if (! modout) {
      {
#line 113
      sprintf((char */* __restrict  */)(mod_path), (char const   */* __restrict  */)"%s/%s",
              destdir, mp->mod_subdir);
#line 114
      tmp = mkdir((char const   *)(mod_path), (__mode_t )511);
      }
#line 114
      if (tmp < 0) {
        {
#line 115
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Sorry cannot make subdirectory %s in %s\n",
                mp->mod_subdir, destdir);
#line 116
        exit(21);
        }
      }
      {
#line 118
      sprintf((char */* __restrict  */)(mod_path), (char const   */* __restrict  */)"%s/%s/%s",
              destdir, mp->mod_subdir, mp->mod_name);
#line 119
      modout = fopen((char const   */* __restrict  */)(mod_path), (char const   */* __restrict  */)"w");
      }
#line 120
      if (! modout) {
        {
#line 121
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Sorry cannot write dest file %s\n",
                mod_path);
#line 122
        exit(22);
        }
      }
    }
  } else {
    {
#line 128
    sprintf((char */* __restrict  */)(mod_path___0), (char const   */* __restrict  */)"%s/%s",
            srcdir, mp->mod_name);
#line 129
    modin = fopen((char const   */* __restrict  */)(mod_path___0), (char const   */* __restrict  */)"r");
    }
#line 130
    if (! modin) {
      {
#line 131
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Sorry cannot open source file %s\n",
              mod_path___0);
#line 132
      exit(20);
      }
    }
    {
#line 134
    sprintf((char */* __restrict  */)(mod_path___0), (char const   */* __restrict  */)"%s/%s",
            destdir, mp->mod_name);
#line 135
    modout = fopen((char const   */* __restrict  */)(mod_path___0), (char const   */* __restrict  */)"w");
    }
#line 136
    if (! modout) {
      {
#line 137
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Sorry cannot write dest file %s\n",
              mod_path___0);
#line 138
      exit(22);
      }
    }
  }
  restart: 
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 143
    ch = _IO_getc(modin);
    }
#line 143
    if (! (ch != -1)) {
#line 143
      goto while_break;
    }
#line 144
    if (ch == 10) {
#line 145
      if (vp_count > 0) {
        {
#line 147
        fputs((char const   */* __restrict  */)"\t/* ", (FILE */* __restrict  */)modout);
#line 148
        cnt___0 = 0;
        }
        {
#line 148
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 148
          if (! (cnt___0 < vp_count)) {
#line 148
            goto while_break___0;
          }
          {
#line 149
          fprintf((FILE */* __restrict  */)modout, (char const   */* __restrict  */)"{%s} ",
                  (vp_list[cnt___0])->vn_string);
#line 148
          cnt___0 ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 150
        fputs((char const   */* __restrict  */)"*/", (FILE */* __restrict  */)modout);
#line 151
        vp_count = 0;
        }
      }
      {
#line 153
      mod_line ++;
#line 154
      _IO_putc(ch, modout);
      }
#line 155
      goto while_continue;
    }
#line 157
    if (ch != 36) {
      {
#line 158
      _IO_putc(ch, modout);
      }
#line 159
      goto while_continue;
    }
    {
#line 161
    finger = ftell(modin);
#line 162
    flags = 0U;
    }
    {
#line 163
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 164
      ch = _IO_getc(modin);
      }
      {
#line 170
      if (ch == 69) {
#line 170
        goto case_69;
      }
#line 171
      if (ch == 72) {
#line 171
        goto case_72;
      }
#line 172
      if (ch == 80) {
#line 172
        goto case_80;
      }
#line 173
      if (ch == 81) {
#line 173
        goto case_81;
      }
#line 174
      if (ch == 82) {
#line 174
        goto case_82;
      }
#line 175
      if (ch == 65) {
#line 175
        goto case_65;
      }
#line 176
      if (ch == 78) {
#line 176
        goto case_78;
      }
#line 177
      if (ch == 75) {
#line 177
        goto case_75;
      }
#line 178
      if (ch == 83) {
#line 178
        goto case_83;
      }
#line 179
      if (ch == 88) {
#line 179
        goto case_88;
      }
#line 180
      if (ch == 123) {
#line 180
        goto case_123;
      }
#line 166
      goto switch_default;
      switch_default: /* CIL Label */ 
      {
#line 167
      fseek(modin, finger, 0);
#line 168
      _IO_putc('$', modout);
      }
#line 169
      goto restart;
      case_69: /* CIL Label */ 
#line 170
      flags |= 1U;
#line 170
      goto switch_break;
      case_72: /* CIL Label */ 
#line 171
      flags |= (unsigned int )(1 << 1);
#line 171
      goto switch_break;
      case_80: /* CIL Label */ 
#line 172
      flags |= (unsigned int )(1 << 2);
#line 172
      goto switch_break;
      case_81: /* CIL Label */ 
#line 173
      flags |= (unsigned int )(1 << 3);
#line 173
      goto switch_break;
      case_82: /* CIL Label */ 
#line 174
      flags |= (unsigned int )(1 << 3);
#line 174
      goto switch_break;
      case_65: /* CIL Label */ 
#line 175
      flags |= (unsigned int )(1 << 4);
#line 175
      goto switch_break;
      case_78: /* CIL Label */ 
#line 176
      flags |= (unsigned int )(1 << 6);
#line 176
      goto switch_break;
      case_75: /* CIL Label */ 
#line 177
      flags |= (unsigned int )(1 << 5);
#line 177
      goto switch_break;
      case_83: /* CIL Label */ 
#line 178
      flags |= (unsigned int )(1 << 7);
#line 178
      goto switch_break;
      case_88: /* CIL Label */ 
#line 179
      flags |= (unsigned int )(1 << 8);
#line 179
      goto switch_break;
      case_123: /* CIL Label */ 
#line 180
      goto getstr;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    getstr: 
#line 184
    if (! flags) {
      {
#line 185
      fseek(modin, finger, 0);
#line 186
      _IO_putc('$', modout);
      }
#line 187
      goto restart;
    }
#line 189
    vncount = 0;
    {
#line 190
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 191
      ch = _IO_getc(modin);
      }
#line 192
      if (ch == 125) {
#line 193
        goto while_break___2;
      }
#line 194
      if (ch == -1) {
        {
#line 195
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unterminated $ construct module %s line %d\n",
                mp->mod_name, mod_line);
#line 196
        fseek(modin, finger, 0);
#line 197
        _IO_putc('$', modout);
#line 198
        errors ++;
        }
#line 199
        goto restart;
      } else
#line 194
      if (ch == 10) {
        {
#line 195
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unterminated $ construct module %s line %d\n",
                mp->mod_name, mod_line);
#line 196
        fseek(modin, finger, 0);
#line 197
        _IO_putc('$', modout);
#line 198
        errors ++;
        }
#line 199
        goto restart;
      } else
#line 194
      if ((unsigned long )vncount >= sizeof(valnbuf) - 2UL) {
        {
#line 195
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unterminated $ construct module %s line %d\n",
                mp->mod_name, mod_line);
#line 196
        fseek(modin, finger, 0);
#line 197
        _IO_putc('$', modout);
#line 198
        errors ++;
        }
#line 199
        goto restart;
      }
#line 201
      tmp___0 = vncount;
#line 201
      vncount ++;
#line 201
      valnbuf[tmp___0] = (char )ch;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 203
    valnbuf[vncount] = (char )'\000';
#line 204
    vp = lookupname((char const   *)(valnbuf));
    }
#line 205
    if (! ((int )vp->vn_flags & (1 << 15))) {
      {
#line 206
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Undefined name {%s} module %s line %d\n",
              valnbuf, mp->mod_name, mod_line);
#line 207
      errors ++;
      }
    } else
#line 209
    if (((unsigned int )vp->vn_flags & flags) != flags) {
#line 210
      cnt = 0;
      {
#line 210
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 210
        if (! ((unsigned long )cnt < sizeof(codelst) - 1UL)) {
#line 210
          goto while_break___3;
        }
#line 211
        if (flags & (unsigned int )(1 << cnt)) {
#line 211
          if (! ((int )vp->vn_flags & (1 << cnt))) {
            {
#line 212
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No %c definition for {%s} required module %s line %d\n",
                    (int )codelst[cnt], valnbuf, mp->mod_name, mod_line);
#line 214
            errors ++;
            }
          }
        }
#line 210
        cnt ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    {
#line 218
    tmp___1 = vp_count;
#line 218
    vp_count ++;
#line 218
    vp_list[tmp___1] = vp;
#line 219
    fprintf((FILE */* __restrict  */)modout, (char const   */* __restrict  */)"%d",
            (int )vp->vn_value);
#line 220
    add_helpref(vp, mp, flags);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 222
  fclose(modin);
#line 223
  fclose(modout);
  }
#line 224
  return;
}
}
#line 226 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/helpparse.c"
void valname_usage(struct valexpr *ve , unsigned int const   flags ) 
{ 


  {
  {
#line 229
  if ((int )ve->val_op == 2) {
#line 229
    goto case_2;
  }
#line 236
  if ((int )ve->val_op == 37) {
#line 236
    goto case_37;
  }
#line 236
  if ((int )ve->val_op == 47) {
#line 236
    goto case_37;
  }
#line 236
  if ((int )ve->val_op == 42) {
#line 236
    goto case_37;
  }
#line 236
  if ((int )ve->val_op == 45) {
#line 236
    goto case_37;
  }
#line 236
  if ((int )ve->val_op == 43) {
#line 236
    goto case_37;
  }
#line 228
  goto switch_break;
  case_2: /* CIL Label */ 
#line 230
  (ve->val_un.val_name)->vn_flags = (unsigned short )((unsigned int const   )(ve->val_un.val_name)->vn_flags | flags);
#line 231
  goto switch_break;
  case_37: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_43: /* CIL Label */ 
  {
#line 237
  valname_usage(ve->val_left, flags);
#line 238
  valname_usage(ve->val_un.val_right, flags);
  }
#line 239
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 241
  return;
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/helpparse.c"
static unsigned int helpusedin(struct valexpr *ve , struct helpfile *hf ) 
{ 
  struct helpfile_list *hfl ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 250
  if ((int )ve->val_op == 2) {
#line 250
    goto case_2;
  }
#line 259
  if ((int )ve->val_op == 37) {
#line 259
    goto case_37;
  }
#line 259
  if ((int )ve->val_op == 47) {
#line 259
    goto case_37;
  }
#line 259
  if ((int )ve->val_op == 42) {
#line 259
    goto case_37;
  }
#line 259
  if ((int )ve->val_op == 45) {
#line 259
    goto case_37;
  }
#line 259
  if ((int )ve->val_op == 43) {
#line 259
    goto case_37;
  }
#line 248
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 249
  return (0U);
  case_2: /* CIL Label */ 
#line 251
  hfl = (ve->val_un.val_name)->vn_hlist;
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (! hfl) {
#line 251
      goto while_break;
    }
#line 252
    if ((unsigned long )hfl->hfl_hf == (unsigned long )hf) {
#line 253
      return (hfl->hfl_flags);
    }
#line 251
    hfl = hfl->hfl_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 254
  return (0U);
  case_37: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_43: /* CIL Label */ 
  {
#line 260
  tmp = helpusedin(ve->val_left, hf);
#line 260
  tmp___0 = helpusedin(ve->val_un.val_right, hf);
  }
#line 260
  return (tmp | tmp___0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 264 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/helpparse.c"
static void dumpexpr(struct valexpr *ve ) 
{ 


  {
  {
#line 270
  if ((int )ve->val_op == 0) {
#line 270
    goto case_0;
  }
#line 273
  if ((int )ve->val_op == 1) {
#line 273
    goto case_1;
  }
#line 276
  if ((int )ve->val_op == 2) {
#line 276
    goto case_2;
  }
#line 279
  if ((int )ve->val_op == 3) {
#line 279
    goto case_3;
  }
#line 290
  if ((int )ve->val_op == 37) {
#line 290
    goto case_37;
  }
#line 290
  if ((int )ve->val_op == 47) {
#line 290
    goto case_37;
  }
#line 290
  if ((int )ve->val_op == 42) {
#line 290
    goto case_37;
  }
#line 290
  if ((int )ve->val_op == 45) {
#line 290
    goto case_37;
  }
#line 290
  if ((int )ve->val_op == 43) {
#line 290
    goto case_37;
  }
#line 267
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 268
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"???");
  }
#line 269
  return;
  case_0: /* CIL Label */ 
  {
#line 271
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%ld",
          ve->val_un.val_value);
  }
#line 272
  return;
  case_1: /* CIL Label */ 
  {
#line 274
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\'%c\'",
          (int )((char )ve->val_un.val_value));
  }
#line 275
  return;
  case_2: /* CIL Label */ 
  {
#line 277
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"{%s}",
          (ve->val_un.val_name)->vn_string);
  }
#line 278
  return;
  case_3: /* CIL Label */ 
  {
#line 280
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ROUND(");
#line 281
  dumpexpr(ve->val_left);
#line 282
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)", ");
#line 283
  dumpexpr(ve->val_un.val_right);
#line 284
  _IO_putc(')', stderr);
  }
#line 285
  return;
  case_37: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_43: /* CIL Label */ 
  {
#line 291
  _IO_putc('(', stderr);
#line 292
  dumpexpr(ve->val_left);
#line 293
  _IO_putc((int )ve->val_op, stderr);
#line 294
  dumpexpr(ve->val_un.val_right);
#line 295
  _IO_putc(')', stderr);
  }
#line 296
  return;
  switch_break: /* CIL Label */ ;
  }
}
}
#line 300 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/helpparse.c"
static void putcomment(char *comment , FILE *f ) 
{ 


  {
  {
#line 302
  while (1) {
    while_continue: /* CIL Label */ ;
#line 302
    if (! *comment) {
#line 302
      goto while_break;
    }
    {
#line 303
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 303
      if (! ((int )*comment == 10)) {
#line 303
        goto while_break___0;
      }
      {
#line 304
      _IO_putc('\n', f);
#line 305
      comment ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 307
    if (! *comment) {
#line 308
      goto while_break;
    }
    {
#line 309
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"# ");
    }
    {
#line 310
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 311
      _IO_putc((int )*comment, f);
#line 312
      comment ++;
      }
#line 310
      if (*comment) {
#line 310
        if (! ((int )*comment != 10)) {
#line 310
          goto while_break___1;
        }
      } else {
#line 310
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 315
  _IO_putc('\n', f);
  }
#line 316
  return;
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/helpparse.c"
void apphelps(char *comment , struct valexpr *stateexpr , char *helptypes , struct valexpr *ve ,
              struct filelist *flst , struct textlist *tl ) 
{ 
  int cnt ;
  int rcnt ;
  int rccnt ;
  long ev1 ;
  long ev2 ;
  unsigned int flgs ;
  struct textlist *ctl ;
  char *chelptypes ;
  char *str ;
  struct helpfile *hf ;
  struct helpfile *helps_used[10] ;
  unsigned int helps_flags[10] ;
  char *fname ;
  int tmp ;
  unsigned int tmp___0 ;
  char *comm ;

  {
#line 328
  rcnt = 0;
#line 330
  if (flst) {
#line 332
    flgs = 0U;
#line 333
    chelptypes = helptypes;
    {
#line 333
    while (1) {
      while_continue: /* CIL Label */ ;
#line 333
      if (! *chelptypes) {
#line 333
        goto while_break;
      }
#line 334
      cnt = 0;
      {
#line 334
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 334
        if (! ((unsigned long )cnt < sizeof(codelst) - 1UL)) {
#line 334
          goto while_break___0;
        }
#line 335
        if ((int )codelst[cnt] == (int )*chelptypes) {
#line 336
          flgs |= (unsigned int )(1 << cnt);
#line 337
          goto while_break___0;
        }
#line 334
        cnt ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 333
      chelptypes ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 339
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 340
      fname = flst->name;
#line 341
      cnt = 0;
      {
#line 341
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 341
        if (cnt < 10) {
#line 341
          if (! helpfiles[cnt].hf_name) {
#line 341
            goto while_break___2;
          }
        } else {
#line 341
          goto while_break___2;
        }
        {
#line 342
        tmp = strcmp((char const   *)helpfiles[cnt].hf_name, (char const   *)fname);
        }
#line 342
        if (tmp == 0) {
#line 343
          rccnt = 0;
          {
#line 343
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 343
            if (! (rccnt < rcnt)) {
#line 343
              goto while_break___3;
            }
#line 344
            if ((unsigned long )helps_used[rccnt] == (unsigned long )(& helpfiles[cnt])) {
#line 345
              helps_flags[rccnt] |= flgs;
#line 346
              goto gotit;
            }
#line 343
            rccnt ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 348
          helps_used[rcnt] = & helpfiles[cnt];
#line 349
          helps_flags[rcnt] = flgs;
#line 350
          rcnt ++;
          gotit: ;
        }
#line 341
        cnt ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 339
      flst = flst->next;
#line 339
      if (! flst) {
#line 339
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 357
  cnt = 0;
  {
#line 357
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 357
    if (cnt < 10) {
#line 357
      if (! helpfiles[cnt].hf_name) {
#line 357
        goto while_break___4;
      }
    } else {
#line 357
      goto while_break___4;
    }
    {
#line 358
    flgs = helpusedin(ve, & helpfiles[cnt]);
    }
#line 359
    if (stateexpr) {
      {
#line 360
      tmp___0 = helpusedin(stateexpr, & helpfiles[cnt]);
#line 360
      flgs |= tmp___0;
      }
    }
#line 361
    if (flgs) {
#line 362
      rccnt = 0;
      {
#line 362
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 362
        if (! (rccnt < rcnt)) {
#line 362
          goto while_break___5;
        }
#line 363
        if ((unsigned long )helps_used[rccnt] == (unsigned long )(& helpfiles[cnt])) {
#line 364
          helps_flags[rccnt] |= flgs;
#line 365
          goto dunf;
        }
#line 362
        rccnt ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 367
      helps_used[rcnt] = & helpfiles[cnt];
#line 368
      helps_flags[rcnt] = flgs;
#line 369
      rcnt ++;
      dunf: ;
    }
#line 357
    cnt ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 375
  if (rcnt <= 0) {
    {
#line 376
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Help text definition at line %d not used anywhere: ",
            line_count);
#line 377
    dumpexpr(ve);
#line 378
    _IO_putc('\n', stderr);
    }
#line 379
    return;
  }
#line 382
  cnt = 0;
  {
#line 382
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 382
    if (! (cnt < rcnt)) {
#line 382
      goto while_break___6;
    }
#line 383
    comm = comment;
#line 384
    hf = helps_used[cnt];
#line 385
    ctl = tl;
#line 387
    chelptypes = helptypes;
    {
#line 387
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 387
      if (! *chelptypes) {
#line 387
        goto while_break___7;
      }
      {
#line 389
      if ((int )*chelptypes == 78) {
#line 389
        goto case_78;
      }
#line 400
      if ((int )*chelptypes == 83) {
#line 400
        goto case_83;
      }
#line 402
      if ((int )*chelptypes == 80) {
#line 402
        goto case_80;
      }
#line 412
      if ((int )*chelptypes == 65) {
#line 412
        goto case_65;
      }
#line 416
      if ((int )*chelptypes == 75) {
#line 416
        goto case_75;
      }
#line 442
      if ((int )*chelptypes == 81) {
#line 442
        goto case_81;
      }
#line 459
      if ((int )*chelptypes == 82) {
#line 459
        goto case_82;
      }
#line 476
      if ((int )*chelptypes == 88) {
#line 476
        goto case_88;
      }
#line 480
      if ((int )*chelptypes == 72) {
#line 480
        goto case_72;
      }
#line 484
      if ((int )*chelptypes == 69) {
#line 484
        goto case_69;
      }
#line 388
      goto switch_break;
      case_78: /* CIL Label */ 
#line 390
      if (! (helps_flags[cnt] & (unsigned int )(1 << 6))) {
#line 391
        goto __Cont;
      }
#line 392
      if (stateexpr) {
#line 393
        if (comm) {
          {
#line 394
          putcomment(comm, hf->hf_filep);
#line 395
          comm = (char *)0;
          }
        }
        {
#line 397
        ev1 = evaluate(ve);
#line 397
        ev2 = evaluate(stateexpr);
#line 397
        fprintf((FILE */* __restrict  */)hf->hf_filep, (char const   */* __restrict  */)"%ldN%ld\n",
                ev2, ev1);
#line 398
        record_help(hf, (char const   )'N', (long const   )ev1, (long const   )ev2);
        }
      }
      case_83: /* CIL Label */ 
#line 401
      goto __Cont;
      case_80: /* CIL Label */ 
#line 403
      if (! (helps_flags[cnt] & (unsigned int )(1 << 2))) {
#line 404
        goto switch_break;
      }
#line 405
      if (comm) {
        {
#line 406
        putcomment(comm, hf->hf_filep);
#line 407
        comm = (char *)0;
        }
      }
      {
#line 409
      ev1 = evaluate(ve);
#line 409
      fprintf((FILE */* __restrict  */)hf->hf_filep, (char const   */* __restrict  */)"%ldP:%s\n",
              ev1, ctl->tl_text);
#line 410
      record_help(hf, (char const   )'P', (long const   )ev1, (long const   )0L);
      }
#line 411
      goto switch_break;
      case_65: /* CIL Label */ 
#line 413
      if (! (helps_flags[cnt] & (unsigned int )(1 << 4))) {
#line 414
        goto switch_break;
      }
#line 415
      goto akrest;
      case_75: /* CIL Label */ 
#line 417
      if (! (helps_flags[cnt] & (unsigned int )(1 << 5))) {
#line 418
        goto switch_break;
      }
      akrest: 
#line 420
      str = ctl->tl_text;
#line 421
      if (comm) {
        {
#line 422
        putcomment(comm, hf->hf_filep);
#line 423
        comm = (char *)0;
        }
      }
      {
#line 425
      ev1 = evaluate(ve);
#line 426
      ev2 = 0L;
      }
#line 427
      if (stateexpr) {
        {
#line 428
        ev2 = evaluate(stateexpr);
#line 428
        fprintf((FILE */* __restrict  */)hf->hf_filep, (char const   */* __restrict  */)"%ld%c%ld:%s\n",
                ev2, (int )*chelptypes, ev1, str);
        }
      } else {
        {
#line 430
        fprintf((FILE */* __restrict  */)hf->hf_filep, (char const   */* __restrict  */)"%c%ld:%s\n",
                (int )*chelptypes, ev1, str);
        }
      }
      {
#line 431
      record_help(hf, (char const   )*chelptypes, (long const   )ev1, (long const   )ev2);
      }
#line 432
      if (kdescrfile) {
#line 432
        if ((int )*chelptypes == 75) {
#line 432
          if ((int )ve->val_op == 2) {
            {
#line 433
            fprintf((FILE */* __restrict  */)kdescrfile, (char const   */* __restrict  */)"%s: ",
                    hf->hf_name);
            }
#line 434
            if (stateexpr) {
              {
#line 435
              fprintf((FILE */* __restrict  */)kdescrfile, (char const   */* __restrict  */)"%ld STATE",
                      ev2);
              }
            } else {
              {
#line 437
              fprintf((FILE */* __restrict  */)kdescrfile, (char const   */* __restrict  */)"GLOBAL");
              }
            }
            {
#line 438
            fprintf((FILE */* __restrict  */)kdescrfile, (char const   */* __restrict  */)" %ld {%s}\n",
                    ev1, (ve->val_un.val_name)->vn_string);
            }
          }
        }
      }
#line 440
      goto switch_break;
      case_81: /* CIL Label */ 
#line 443
      if (! (helps_flags[cnt] & (unsigned int )(1 << 3))) {
#line 444
        goto switch_break;
      }
#line 445
      str = ctl->tl_text;
#line 446
      if (comm) {
        {
#line 447
        putcomment(comm, hf->hf_filep);
#line 448
        comm = (char *)0;
        }
      }
      {
#line 450
      ev1 = evaluate(ve);
#line 451
      ev2 = 0L;
      }
#line 452
      if (stateexpr) {
        {
#line 453
        ev2 = evaluate(stateexpr);
#line 453
        fprintf((FILE */* __restrict  */)hf->hf_filep, (char const   */* __restrict  */)"%ldA%ld:%s\n",
                ev1, ev2, str);
        }
      } else {
        {
#line 455
        fprintf((FILE */* __restrict  */)hf->hf_filep, (char const   */* __restrict  */)"%ldA:%s\n",
                ev1, str);
        }
      }
      {
#line 456
      record_help(hf, (char const   )'Q', (long const   )ev1, (long const   )ev2);
      }
#line 457
      goto switch_break;
      case_82: /* CIL Label */ 
#line 460
      if (! (helps_flags[cnt] & (unsigned int )(1 << 3))) {
#line 461
        goto switch_break;
      }
#line 462
      str = ctl->tl_text;
#line 463
      if (comm) {
        {
#line 464
        putcomment(comm, hf->hf_filep);
#line 465
        comm = (char *)0;
        }
      }
      {
#line 467
      ev1 = evaluate(ve);
#line 468
      ev2 = 0L;
      }
#line 469
      if (stateexpr) {
        {
#line 470
        ev2 = evaluate(stateexpr);
#line 470
        fprintf((FILE */* __restrict  */)hf->hf_filep, (char const   */* __restrict  */)"%ldAD%ld:%s\n",
                ev1, ev2, str);
        }
      } else {
        {
#line 472
        fprintf((FILE */* __restrict  */)hf->hf_filep, (char const   */* __restrict  */)"%ldAD:%s\n",
                ev1, str);
        }
      }
      {
#line 473
      record_help(hf, (char const   )'Q', (long const   )ev1, (long const   )ev2);
      }
#line 474
      goto switch_break;
      case_88: /* CIL Label */ 
#line 477
      if (! (helps_flags[cnt] & (unsigned int )(1 << 8))) {
#line 478
        goto switch_break;
      }
#line 479
      goto herest;
      case_72: /* CIL Label */ 
#line 481
      if (! (helps_flags[cnt] & (unsigned int )(1 << 1))) {
#line 482
        goto switch_break;
      }
#line 483
      goto herest;
      case_69: /* CIL Label */ 
#line 485
      if (! (helps_flags[cnt] & 1U)) {
#line 486
        goto switch_break;
      }
      herest: 
#line 488
      str = ctl->tl_text;
#line 489
      if (comm) {
        {
#line 490
        putcomment(comm, hf->hf_filep);
#line 491
        comm = (char *)0;
        }
      }
      {
#line 493
      ev1 = evaluate(ve);
#line 494
      record_help(hf, (char const   )*chelptypes, (long const   )ev1, (long const   )0L);
      }
      {
#line 495
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 495
        if (! *str) {
#line 495
          goto while_break___8;
        }
        {
#line 496
        fprintf((FILE */* __restrict  */)hf->hf_filep, (char const   */* __restrict  */)"%c%ld:",
                (int )*chelptypes, ev1);
        }
        {
#line 497
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 497
          if (*str) {
#line 497
            if (! ((int )*str != 10)) {
#line 497
              goto while_break___9;
            }
          } else {
#line 497
            goto while_break___9;
          }
          {
#line 498
          _IO_putc((int )*str, hf->hf_filep);
#line 499
          str ++;
          }
        }
        while_break___9: /* CIL Label */ ;
        }
#line 501
        if ((int )*str == 10) {
          {
#line 502
          _IO_putc('\n', hf->hf_filep);
#line 503
          str ++;
          }
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 506
      _IO_putc('\n', hf->hf_filep);
      }
#line 507
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 509
      ctl = ctl->tl_next;
      __Cont: /* CIL Label */ 
#line 387
      chelptypes ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 382
    cnt ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 512
  return;
}
}
#line 514 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/helpparse.c"
void inithelps(void) 
{ 
  int cnt ;
  int ch ;
  struct helpfile *hf ;
  FILE *hlpin ;
  char hlp_path[4096] ;
  int tmp ;
  char hlp_path___0[4096] ;

  {
#line 520
  cnt = 0;
  {
#line 520
  while (1) {
    while_continue: /* CIL Label */ ;
#line 520
    if (cnt < 10) {
#line 520
      if (! helpfiles[cnt].hf_name) {
#line 520
        goto while_break;
      }
    } else {
#line 520
      goto while_break;
    }
#line 521
    hf = & helpfiles[cnt];
#line 522
    if (hf->hf_subdir) {
      {
#line 524
      sprintf((char */* __restrict  */)(hlp_path), (char const   */* __restrict  */)"%s/%s/%s",
              srcdir, hf->hf_subdir, hf->hf_name);
#line 525
      hlpin = fopen((char const   */* __restrict  */)(hlp_path), (char const   */* __restrict  */)"r");
      }
#line 526
      if (! hlpin) {
        {
#line 527
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Sorry cannot open source file %s\n",
                hlp_path);
#line 528
        exit(20);
        }
      }
      {
#line 530
      sprintf((char */* __restrict  */)(hlp_path), (char const   */* __restrict  */)"%s/%s/%s",
              destdir, hf->hf_subdir, hf->hf_name);
#line 531
      hf->hf_filep = fopen((char const   */* __restrict  */)(hlp_path), (char const   */* __restrict  */)"w");
      }
#line 532
      if (! hf->hf_filep) {
        {
#line 533
        sprintf((char */* __restrict  */)(hlp_path), (char const   */* __restrict  */)"%s/%s",
                destdir, hf->hf_subdir);
#line 534
        tmp = mkdir((char const   *)(hlp_path), (__mode_t )511);
        }
#line 534
        if (tmp < 0) {
          {
#line 535
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Sorry cannot make subdirectory %s in %s\n",
                  hf->hf_subdir, destdir);
#line 536
          exit(21);
          }
        }
        {
#line 538
        sprintf((char */* __restrict  */)(hlp_path), (char const   */* __restrict  */)"%s/%s/%s",
                destdir, hf->hf_subdir, hf->hf_name);
#line 539
        hf->hf_filep = fopen((char const   */* __restrict  */)(hlp_path), (char const   */* __restrict  */)"w");
        }
#line 540
        if (! hf->hf_filep) {
          {
#line 541
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Sorry cannot write dest file %s\n",
                  hlp_path);
#line 542
          exit(22);
          }
        }
      }
    } else {
      {
#line 548
      sprintf((char */* __restrict  */)(hlp_path___0), (char const   */* __restrict  */)"%s/%s",
              srcdir, hf->hf_name);
#line 549
      hlpin = fopen((char const   */* __restrict  */)(hlp_path___0), (char const   */* __restrict  */)"r");
      }
#line 550
      if (! hlpin) {
        {
#line 551
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Sorry cannot open source file %s\n",
                hlp_path___0);
#line 552
        exit(20);
        }
      }
      {
#line 554
      sprintf((char */* __restrict  */)(hlp_path___0), (char const   */* __restrict  */)"%s/%s",
              destdir, hf->hf_name);
#line 555
      hf->hf_filep = fopen((char const   */* __restrict  */)(hlp_path___0), (char const   */* __restrict  */)"w");
      }
#line 556
      if (! hf->hf_filep) {
        {
#line 557
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Sorry cannot write dest file %s\n",
                hlp_path___0);
#line 558
        exit(22);
        }
      }
    }
    {
#line 562
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 562
      ch = _IO_getc(hlpin);
      }
#line 562
      if (! (ch != -1)) {
#line 562
        goto while_break___0;
      }
      {
#line 563
      _IO_putc(ch, hf->hf_filep);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 564
    fclose(hlpin);
#line 520
    cnt ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 566
  return;
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/helpparse.c"
void closehelps(void) 
{ 
  int cnt ;

  {
#line 572
  cnt = 0;
  {
#line 572
  while (1) {
    while_continue: /* CIL Label */ ;
#line 572
    if (cnt < 10) {
#line 572
      if (! helpfiles[cnt].hf_name) {
#line 572
        goto while_break;
      }
    } else {
#line 572
      goto while_break;
    }
    {
#line 573
    fclose(helpfiles[cnt].hf_filep);
#line 572
    cnt ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 574
  return;
}
}
#line 576 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/helpparse.c"
static void nuke_dests(char *dst ) 
{ 
  DIR *dd ;
  struct dirent *dp ;
  struct stat dbuf ;
  char dpath[4096] ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 583
  dd = opendir((char const   *)dst);
  }
#line 583
  if (! dd) {
#line 584
    return;
  }
  {
#line 586
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 586
    dp = readdir(dd);
    }
#line 586
    if (! dp) {
#line 586
      goto while_break;
    }
#line 587
    if ((int )dp->d_name[0] == 46) {
#line 587
      if ((int )dp->d_name[1] == 0) {
#line 588
        goto while_continue;
      } else
#line 587
      if ((int )dp->d_name[1] == 46) {
#line 587
        if ((int )dp->d_name[2] == 0) {
#line 588
          goto while_continue;
        }
      }
    }
    {
#line 589
    sprintf((char */* __restrict  */)(dpath), (char const   */* __restrict  */)"%s/%s",
            dst, dp->d_name);
#line 590
    tmp = lstat((char const   */* __restrict  */)(dpath), (struct stat */* __restrict  */)(& dbuf));
    }
#line 590
    if (tmp < 0) {
#line 591
      goto while_continue;
    } else
#line 590
    if ((dbuf.st_mode & 61440U) != 16384U) {
#line 591
      goto while_continue;
    }
    {
#line 592
    nuke_dests(dpath);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 595
  rewinddir(dd);
  }
  {
#line 596
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 596
    dp = readdir(dd);
    }
#line 596
    if (! dp) {
#line 596
      goto while_break___0;
    }
#line 597
    if ((int )dp->d_name[0] == 46) {
#line 597
      if ((int )dp->d_name[1] == 0) {
#line 598
        goto while_continue___0;
      } else
#line 597
      if ((int )dp->d_name[1] == 46) {
#line 597
        if ((int )dp->d_name[2] == 0) {
#line 598
          goto while_continue___0;
        }
      }
    }
    {
#line 599
    sprintf((char */* __restrict  */)(dpath), (char const   */* __restrict  */)"%s/%s",
            dst, dp->d_name);
#line 600
    tmp___0 = lstat((char const   */* __restrict  */)(dpath), (struct stat */* __restrict  */)(& dbuf));
    }
#line 600
    if (tmp___0 < 0) {
#line 601
      goto while_continue___0;
    } else
#line 600
    if ((dbuf.st_mode & 61440U) != 32768U) {
#line 601
      goto while_continue___0;
    }
    {
#line 602
    unlink((char const   *)(dpath));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 604
  closedir(dd);
  }
#line 605
  return;
}
}
#line 607 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/helpparse.c"
static void mod_copy(char *src , char *dst ) 
{ 
  DIR *sd ;
  struct dirent *dp ;
  struct stat sbuf ;
  struct stat dbuf ;
  char spath[4096] ;
  char dpath[4096] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 614
  sd = opendir((char const   *)src);
  }
#line 614
  if (! sd) {
    {
#line 615
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Sorry cannot open source dir %s\n",
            src);
#line 616
    exit(25);
    }
  }
  {
#line 619
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 619
    dp = readdir(sd);
    }
#line 619
    if (! dp) {
#line 619
      goto while_break;
    }
#line 620
    if ((int )dp->d_name[0] == 46) {
#line 620
      if ((int )dp->d_name[1] == 0) {
#line 621
        goto while_continue;
      } else
#line 620
      if ((int )dp->d_name[1] == 46) {
#line 620
        if ((int )dp->d_name[2] == 0) {
#line 621
          goto while_continue;
        }
      }
    }
    {
#line 622
    sprintf((char */* __restrict  */)(spath), (char const   */* __restrict  */)"%s/%s",
            src, dp->d_name);
#line 623
    sprintf((char */* __restrict  */)(dpath), (char const   */* __restrict  */)"%s/%s",
            dst, dp->d_name);
#line 624
    tmp = lstat((char const   */* __restrict  */)(spath), (struct stat */* __restrict  */)(& sbuf));
    }
#line 624
    if (tmp < 0) {
#line 625
      goto while_continue;
    }
    {
#line 626
    tmp___0 = lstat((char const   */* __restrict  */)(dpath), (struct stat */* __restrict  */)(& dbuf));
    }
#line 626
    if (tmp___0 >= 0) {
#line 627
      if ((sbuf.st_mode & 61440U) != (dbuf.st_mode & 61440U)) {
#line 628
        if ((dbuf.st_mode & 61440U) == 40960U) {
#line 629
          goto while_continue;
        }
        {
#line 630
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Confused by clashing type of %s\n",
                dpath);
#line 631
        exit(26);
        }
      }
#line 633
      if ((sbuf.st_mode & 61440U) == 16384U) {
        {
#line 634
        mod_copy(spath, dpath);
        }
      }
#line 635
      goto while_continue;
    }
#line 637
    if ((sbuf.st_mode & 61440U) == 32768U) {
#line 637
      goto _L;
    } else
#line 637
    if ((sbuf.st_mode & 61440U) == 40960U) {
      _L: /* CIL Label */ 
      {
#line 638
      tmp___1 = link((char const   *)(spath), (char const   *)(dpath));
      }
#line 638
      if (tmp___1 < 0) {
        {
#line 639
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to link %s to %s\n",
                spath, dpath);
#line 640
        exit(27);
        }
      }
    } else
#line 643
    if ((sbuf.st_mode & 61440U) == 16384U) {
      {
#line 644
      tmp___2 = strcmp((char const   *)(dp->d_name), "RCS");
      }
#line 644
      if (tmp___2 == 0) {
#line 645
        goto while_continue;
      } else {
        {
#line 644
        tmp___3 = strcmp((char const   *)(dp->d_name), "U");
        }
#line 644
        if (tmp___3 == 0) {
#line 645
          goto while_continue;
        } else {
          {
#line 644
          tmp___4 = strcmp((char const   *)(dp->d_name), "config");
          }
#line 644
          if (tmp___4 == 0) {
#line 645
            goto while_continue;
          }
        }
      }
      {
#line 646
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Creating directory %s\n",
              dpath);
#line 647
      tmp___5 = mkdir((char const   *)(dpath), (__mode_t )511);
      }
#line 647
      if (tmp___5 < 0) {
        {
#line 648
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Sorry cannot make dest directory %s\n",
                dpath);
#line 649
        exit(29);
        }
      }
      {
#line 651
      mod_copy(spath, dpath);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 654
  closedir(sd);
  }
#line 655
  return;
}
}
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 117 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/hdefs.h"
void throwaway_expr(struct valexpr *ve ) ;
#line 117
void macro_define(char *name , char *subdir , struct module_list *mlist ) ;
#line 117
void free_modlist(struct module_list *ml ) ;
#line 117
void define_helpsfor(char *name , char *subdir , struct program_list *pl ) ;
#line 117
void assign_progmods(struct program *prog , char *subdir , struct module_list *ml ) ;
#line 117
void throwaway_strs(struct textlist *tl ) ;
#line 128
struct valexpr *alloc_expr(void) ;
#line 128
struct valexpr *make_value(int const   n ) ;
#line 128
struct valexpr *make_name(struct valname *vn ) ;
#line 135
struct module_list *alloc_module(char *name , char *subdir ) ;
#line 135
struct module_list *lookupallocmods(char *name ) ;
#line 141
struct program *find_program(char *name ) ;
#line 143
struct program_list *alloc_proglist(char *name ) ;
#line 145
struct textlist *alloc_textlist(char *string ) ;
#line 24 "msgparse.y"
int yylex(void) ;
#line 27
void merge_helps(struct valexpr *src , struct valexpr *dest ) ;
#line 29 "msgparse.y"
int errors  =    0;
#line 29 "msgparse.y"
int pass1  =    1;
#line 34 "msgparse.y"
struct valname *last_assign  ;
#line 35 "msgparse.y"
struct valexpr *last_expr  ;
#line 36 "msgparse.y"
long last_value  ;
#line 40 "msgparse.y"
static char htlist[11]  ;
#line 42 "msgparse.y"
void yyerror(char *msg ) 
{ 


  {
  {
#line 44
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Parse error: %s on line %d\n",
          msg, line_count);
#line 45
  errors ++;
  }
#line 46
  return;
}
}
#line 422 "y.tab.c"
static yytype_uint8 const   yytranslate[273]  = 
#line 422 "y.tab.c"
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )7,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )5,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )28,      (yytype_uint8 const   )4,      (yytype_uint8 const   )2,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )24,      (yytype_uint8 const   )23, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )25,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16,      (yytype_uint8 const   )17, 
        (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )22};
#line 536 "y.tab.c"
static yytype_uint8 const   yyr1[66]  = 
#line 536
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )33,      (yytype_uint8 const   )33,      (yytype_uint8 const   )33, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )35, 
        (yytype_uint8 const   )36,      (yytype_uint8 const   )37,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )39,      (yytype_uint8 const   )40,      (yytype_uint8 const   )41,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )43,      (yytype_uint8 const   )44,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )46,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )48,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )50,      (yytype_uint8 const   )50,      (yytype_uint8 const   )51, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )52,      (yytype_uint8 const   )53,      (yytype_uint8 const   )54, 
        (yytype_uint8 const   )54,      (yytype_uint8 const   )55,      (yytype_uint8 const   )55,      (yytype_uint8 const   )56, 
        (yytype_uint8 const   )56,      (yytype_uint8 const   )57,      (yytype_uint8 const   )58,      (yytype_uint8 const   )58, 
        (yytype_uint8 const   )58,      (yytype_uint8 const   )58,      (yytype_uint8 const   )59,      (yytype_uint8 const   )59, 
        (yytype_uint8 const   )59,      (yytype_uint8 const   )59,      (yytype_uint8 const   )59,      (yytype_uint8 const   )59, 
        (yytype_uint8 const   )59,      (yytype_uint8 const   )59,      (yytype_uint8 const   )59,      (yytype_uint8 const   )59, 
        (yytype_uint8 const   )59,      (yytype_uint8 const   )59,      (yytype_uint8 const   )60,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )61};
#line 548 "y.tab.c"
static yytype_uint8 const   yyr2[66]  = 
#line 548
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )6,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )5,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )6,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )7,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1};
#line 562 "y.tab.c"
static yytype_uint8 const   yydefact[107]  = 
#line 562
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )18,      (yytype_uint8 const   )22,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )28,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )4,      (yytype_uint8 const   )0,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )41,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )28,      (yytype_uint8 const   )25,      (yytype_uint8 const   )0,      (yytype_uint8 const   )33, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )0,      (yytype_uint8 const   )23,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )14,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )50,      (yytype_uint8 const   )51,      (yytype_uint8 const   )53,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )54,      (yytype_uint8 const   )29,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )43,      (yytype_uint8 const   )0,      (yytype_uint8 const   )34, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )10,      (yytype_uint8 const   )0,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )19,      (yytype_uint8 const   )13,      (yytype_uint8 const   )15, 
        (yytype_uint8 const   )58,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )36,      (yytype_uint8 const   )0,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )11,      (yytype_uint8 const   )12,      (yytype_uint8 const   )17,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )35,      (yytype_uint8 const   )56,      (yytype_uint8 const   )57, 
        (yytype_uint8 const   )59,      (yytype_uint8 const   )60,      (yytype_uint8 const   )61,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )39,      (yytype_uint8 const   )46,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )40,      (yytype_uint8 const   )62,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )48,      (yytype_uint8 const   )0,      (yytype_uint8 const   )38,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )30,      (yytype_uint8 const   )63,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )55,      (yytype_uint8 const   )0,      (yytype_uint8 const   )64};
#line 578 "y.tab.c"
static yytype_int8 const   yydefgoto[32]  = 
#line 578
  {      (yytype_int8 const   )-1,      (yytype_int8 const   )5,      (yytype_int8 const   )6,      (yytype_int8 const   )7, 
        (yytype_int8 const   )8,      (yytype_int8 const   )56,      (yytype_int8 const   )57,      (yytype_int8 const   )9, 
        (yytype_int8 const   )40,      (yytype_int8 const   )41,      (yytype_int8 const   )10,      (yytype_int8 const   )14, 
        (yytype_int8 const   )60,      (yytype_int8 const   )61,      (yytype_int8 const   )58,      (yytype_int8 const   )22, 
        (yytype_int8 const   )23,      (yytype_int8 const   )24,      (yytype_int8 const   )25,      (yytype_int8 const   )26, 
        (yytype_int8 const   )54,      (yytype_int8 const   )49,      (yytype_int8 const   )74,      (yytype_int8 const   )89, 
        (yytype_int8 const   )94,      (yytype_int8 const   )35,      (yytype_int8 const   )52,      (yytype_int8 const   )53, 
        (yytype_int8 const   )98,      (yytype_int8 const   )50,      (yytype_int8 const   )101,      (yytype_int8 const   )102};
#line 589 "y.tab.c"
static yytype_int8 const   yypact[107]  = 
#line 589
  {      (yytype_int8 const   )2,      (yytype_int8 const   )-21,      (yytype_int8 const   )1,      (yytype_int8 const   )5, 
        (yytype_int8 const   )-7,      (yytype_int8 const   )37,      (yytype_int8 const   )38,      (yytype_int8 const   )-43, 
        (yytype_int8 const   )-43,      (yytype_int8 const   )-43,      (yytype_int8 const   )-43,      (yytype_int8 const   )-43, 
        (yytype_int8 const   )-7,      (yytype_int8 const   )-43,      (yytype_int8 const   )-7,      (yytype_int8 const   )22, 
        (yytype_int8 const   )16,      (yytype_int8 const   )-43,      (yytype_int8 const   )-21,      (yytype_int8 const   )-43, 
        (yytype_int8 const   )18,      (yytype_int8 const   )-43,      (yytype_int8 const   )15,      (yytype_int8 const   )-43, 
        (yytype_int8 const   )-43,      (yytype_int8 const   )-43,      (yytype_int8 const   )35,      (yytype_int8 const   )28, 
        (yytype_int8 const   )33,      (yytype_int8 const   )34,      (yytype_int8 const   )49,      (yytype_int8 const   )58, 
        (yytype_int8 const   )-43,      (yytype_int8 const   )-43,      (yytype_int8 const   )52,      (yytype_int8 const   )44, 
        (yytype_int8 const   )-7,      (yytype_int8 const   )56,      (yytype_int8 const   )-43,      (yytype_int8 const   )-43, 
        (yytype_int8 const   )-3,      (yytype_int8 const   )-43,      (yytype_int8 const   )58,      (yytype_int8 const   )48, 
        (yytype_int8 const   )-43,      (yytype_int8 const   )-43,      (yytype_int8 const   )-43,      (yytype_int8 const   )58, 
        (yytype_int8 const   )-43,      (yytype_int8 const   )-43,      (yytype_int8 const   )118,      (yytype_int8 const   )-43, 
        (yytype_int8 const   )51,      (yytype_int8 const   )-43,      (yytype_int8 const   )42,      (yytype_int8 const   )-43, 
        (yytype_int8 const   )-22,      (yytype_int8 const   )-43,      (yytype_int8 const   )65,      (yytype_int8 const   )-43, 
        (yytype_int8 const   )19,      (yytype_int8 const   )-43,      (yytype_int8 const   )-43,      (yytype_int8 const   )-43, 
        (yytype_int8 const   )-43,      (yytype_int8 const   )58,      (yytype_int8 const   )85,      (yytype_int8 const   )58, 
        (yytype_int8 const   )58,      (yytype_int8 const   )58,      (yytype_int8 const   )58,      (yytype_int8 const   )58, 
        (yytype_int8 const   )52,      (yytype_int8 const   )-43,      (yytype_int8 const   )47,      (yytype_int8 const   )-43, 
        (yytype_int8 const   )-43,      (yytype_int8 const   )-43,      (yytype_int8 const   )-43,      (yytype_int8 const   )-43, 
        (yytype_int8 const   )3,      (yytype_int8 const   )-43,      (yytype_int8 const   )39,      (yytype_int8 const   )39, 
        (yytype_int8 const   )-43,      (yytype_int8 const   )-43,      (yytype_int8 const   )-43,      (yytype_int8 const   )-43, 
        (yytype_int8 const   )61,      (yytype_int8 const   )69,      (yytype_int8 const   )95,      (yytype_int8 const   )58, 
        (yytype_int8 const   )-43,      (yytype_int8 const   )-43,      (yytype_int8 const   )68,      (yytype_int8 const   )-43, 
        (yytype_int8 const   )-43,      (yytype_int8 const   )58,      (yytype_int8 const   )-43,      (yytype_int8 const   )90, 
        (yytype_int8 const   )-43,      (yytype_int8 const   )75,      (yytype_int8 const   )-43,      (yytype_int8 const   )118, 
        (yytype_int8 const   )-43,      (yytype_int8 const   )68,      (yytype_int8 const   )-43};
#line 605 "y.tab.c"
static yytype_int8 const   yypgoto[32]  = 
#line 605
  {      (yytype_int8 const   )-43,      (yytype_int8 const   )-43,      (yytype_int8 const   )-43,      (yytype_int8 const   )80, 
        (yytype_int8 const   )-43,      (yytype_int8 const   )-43,      (yytype_int8 const   )53,      (yytype_int8 const   )-43, 
        (yytype_int8 const   )-43,      (yytype_int8 const   )64,      (yytype_int8 const   )-43,      (yytype_int8 const   )-43, 
        (yytype_int8 const   )-43,      (yytype_int8 const   )45,      (yytype_int8 const   )10,      (yytype_int8 const   )-43, 
        (yytype_int8 const   )86,      (yytype_int8 const   )-43,      (yytype_int8 const   )-43,      (yytype_int8 const   )-43, 
        (yytype_int8 const   )-43,      (yytype_int8 const   )76,      (yytype_int8 const   )-43,      (yytype_int8 const   )-43, 
        (yytype_int8 const   )-43,      (yytype_int8 const   )-43,      (yytype_int8 const   )-43,      (yytype_int8 const   )41, 
        (yytype_int8 const   )-43,      (yytype_int8 const   )-42,      (yytype_int8 const   )-43,      (yytype_int8 const   )9};
#line 618 "y.tab.c"
static yytype_int8 const   yytable[126]  = 
#line 618
  {      (yytype_int8 const   )64,      (yytype_int8 const   )75,      (yytype_int8 const   )11,      (yytype_int8 const   )1, 
        (yytype_int8 const   )15,      (yytype_int8 const   )66,      (yytype_int8 const   )67,      (yytype_int8 const   )68, 
        (yytype_int8 const   )69,      (yytype_int8 const   )70,      (yytype_int8 const   )71,      (yytype_int8 const   )2, 
        (yytype_int8 const   )3,      (yytype_int8 const   )39,      (yytype_int8 const   )16,      (yytype_int8 const   )-2, 
        (yytype_int8 const   )32,      (yytype_int8 const   )12,      (yytype_int8 const   )4,      (yytype_int8 const   )15, 
        (yytype_int8 const   )62,      (yytype_int8 const   )13,      (yytype_int8 const   )27,      (yytype_int8 const   )80, 
        (yytype_int8 const   )28,      (yytype_int8 const   )82,      (yytype_int8 const   )83,      (yytype_int8 const   )84, 
        (yytype_int8 const   )85,      (yytype_int8 const   )86,      (yytype_int8 const   )-31,      (yytype_int8 const   )91, 
        (yytype_int8 const   )90,      (yytype_int8 const   )19,      (yytype_int8 const   )20,      (yytype_int8 const   )59, 
        (yytype_int8 const   )-31,      (yytype_int8 const   )17,      (yytype_int8 const   )29,      (yytype_int8 const   )18, 
        (yytype_int8 const   )30,      (yytype_int8 const   )-31,      (yytype_int8 const   )78,      (yytype_int8 const   )31, 
        (yytype_int8 const   )69,      (yytype_int8 const   )70,      (yytype_int8 const   )71,      (yytype_int8 const   )2, 
        (yytype_int8 const   )3,      (yytype_int8 const   )99,      (yytype_int8 const   )34,      (yytype_int8 const   )42, 
        (yytype_int8 const   )36,      (yytype_int8 const   )-31,      (yytype_int8 const   )4,      (yytype_int8 const   )103, 
        (yytype_int8 const   )19,      (yytype_int8 const   )20,      (yytype_int8 const   )37,      (yytype_int8 const   )-31, 
        (yytype_int8 const   )43,      (yytype_int8 const   )38,      (yytype_int8 const   )42,      (yytype_int8 const   )73, 
        (yytype_int8 const   )-31,      (yytype_int8 const   )39,      (yytype_int8 const   )44,      (yytype_int8 const   )45, 
        (yytype_int8 const   )51,      (yytype_int8 const   )46,      (yytype_int8 const   )47,      (yytype_int8 const   )43, 
        (yytype_int8 const   )59,      (yytype_int8 const   )47,      (yytype_int8 const   )65,      (yytype_int8 const   )88, 
        (yytype_int8 const   )48,      (yytype_int8 const   )44,      (yytype_int8 const   )45,      (yytype_int8 const   )72, 
        (yytype_int8 const   )46,      (yytype_int8 const   )77,      (yytype_int8 const   )92,      (yytype_int8 const   )93, 
        (yytype_int8 const   )47,      (yytype_int8 const   )100,      (yytype_int8 const   )21,      (yytype_int8 const   )48, 
        (yytype_int8 const   )67,      (yytype_int8 const   )68,      (yytype_int8 const   )69,      (yytype_int8 const   )70, 
        (yytype_int8 const   )71,      (yytype_int8 const   )67,      (yytype_int8 const   )68,      (yytype_int8 const   )69, 
        (yytype_int8 const   )70,      (yytype_int8 const   )71,      (yytype_int8 const   )67,      (yytype_int8 const   )68, 
        (yytype_int8 const   )69,      (yytype_int8 const   )70,      (yytype_int8 const   )71,      (yytype_int8 const   )105, 
        (yytype_int8 const   )63,      (yytype_int8 const   )79,      (yytype_int8 const   )95,      (yytype_int8 const   )96, 
        (yytype_int8 const   )33,      (yytype_int8 const   )76,      (yytype_int8 const   )0,      (yytype_int8 const   )55, 
        (yytype_int8 const   )81,      (yytype_int8 const   )87,      (yytype_int8 const   )106,      (yytype_int8 const   )0, 
        (yytype_int8 const   )0,      (yytype_int8 const   )104,      (yytype_int8 const   )0,      (yytype_int8 const   )0, 
        (yytype_int8 const   )97,      (yytype_int8 const   )67,      (yytype_int8 const   )68,      (yytype_int8 const   )69, 
        (yytype_int8 const   )70,      (yytype_int8 const   )71};
#line 635 "y.tab.c"
static yytype_int8 const   yycheck[126]  = 
#line 635
  {      (yytype_int8 const   )42,      (yytype_int8 const   )23,      (yytype_int8 const   )23,      (yytype_int8 const   )1, 
        (yytype_int8 const   )26,      (yytype_int8 const   )47,      (yytype_int8 const   )3,      (yytype_int8 const   )4, 
        (yytype_int8 const   )5,      (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )9, 
        (yytype_int8 const   )10,      (yytype_int8 const   )16,      (yytype_int8 const   )4,      (yytype_int8 const   )0, 
        (yytype_int8 const   )1,      (yytype_int8 const   )16,      (yytype_int8 const   )16,      (yytype_int8 const   )26, 
        (yytype_int8 const   )23,      (yytype_int8 const   )16,      (yytype_int8 const   )12,      (yytype_int8 const   )65, 
        (yytype_int8 const   )14,      (yytype_int8 const   )67,      (yytype_int8 const   )68,      (yytype_int8 const   )69, 
        (yytype_int8 const   )70,      (yytype_int8 const   )71,      (yytype_int8 const   )15,      (yytype_int8 const   )28, 
        (yytype_int8 const   )74,      (yytype_int8 const   )18,      (yytype_int8 const   )19,      (yytype_int8 const   )16, 
        (yytype_int8 const   )21,      (yytype_int8 const   )0,      (yytype_int8 const   )16,      (yytype_int8 const   )1, 
        (yytype_int8 const   )24,      (yytype_int8 const   )26,      (yytype_int8 const   )23,      (yytype_int8 const   )25, 
        (yytype_int8 const   )5,      (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )9, 
        (yytype_int8 const   )10,      (yytype_int8 const   )91,      (yytype_int8 const   )15,      (yytype_int8 const   )4, 
        (yytype_int8 const   )24,      (yytype_int8 const   )15,      (yytype_int8 const   )16,      (yytype_int8 const   )97, 
        (yytype_int8 const   )18,      (yytype_int8 const   )19,      (yytype_int8 const   )25,      (yytype_int8 const   )21, 
        (yytype_int8 const   )13,      (yytype_int8 const   )27,      (yytype_int8 const   )4,      (yytype_int8 const   )21, 
        (yytype_int8 const   )26,      (yytype_int8 const   )16,      (yytype_int8 const   )19,      (yytype_int8 const   )20, 
        (yytype_int8 const   )16,      (yytype_int8 const   )22,      (yytype_int8 const   )26,      (yytype_int8 const   )13, 
        (yytype_int8 const   )16,      (yytype_int8 const   )26,      (yytype_int8 const   )26,      (yytype_int8 const   )28, 
        (yytype_int8 const   )29,      (yytype_int8 const   )19,      (yytype_int8 const   )20,      (yytype_int8 const   )28, 
        (yytype_int8 const   )22,      (yytype_int8 const   )16,      (yytype_int8 const   )21,      (yytype_int8 const   )14, 
        (yytype_int8 const   )26,      (yytype_int8 const   )17,      (yytype_int8 const   )6,      (yytype_int8 const   )29, 
        (yytype_int8 const   )3,      (yytype_int8 const   )4,      (yytype_int8 const   )5,      (yytype_int8 const   )6, 
        (yytype_int8 const   )7,      (yytype_int8 const   )3,      (yytype_int8 const   )4,      (yytype_int8 const   )5, 
        (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )3,      (yytype_int8 const   )4, 
        (yytype_int8 const   )5,      (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )28, 
        (yytype_int8 const   )40,      (yytype_int8 const   )60,      (yytype_int8 const   )11,      (yytype_int8 const   )12, 
        (yytype_int8 const   )22,      (yytype_int8 const   )56,      (yytype_int8 const   )-1,      (yytype_int8 const   )35, 
        (yytype_int8 const   )27,      (yytype_int8 const   )72,      (yytype_int8 const   )105,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )27,      (yytype_int8 const   )-1,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )25,      (yytype_int8 const   )3,      (yytype_int8 const   )4,      (yytype_int8 const   )5, 
        (yytype_int8 const   )6,      (yytype_int8 const   )7};
#line 654 "y.tab.c"
static yytype_uint8 const   yystos[107]  = 
#line 654
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )16,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32,      (yytype_uint8 const   )33, 
        (yytype_uint8 const   )34,      (yytype_uint8 const   )37,      (yytype_uint8 const   )40,      (yytype_uint8 const   )23, 
        (yytype_uint8 const   )16,      (yytype_uint8 const   )16,      (yytype_uint8 const   )41,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )44,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )18, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )33,      (yytype_uint8 const   )45,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )48,      (yytype_uint8 const   )49,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )44,      (yytype_uint8 const   )16,      (yytype_uint8 const   )24,      (yytype_uint8 const   )25, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )46,      (yytype_uint8 const   )15,      (yytype_uint8 const   )55, 
        (yytype_uint8 const   )24,      (yytype_uint8 const   )25,      (yytype_uint8 const   )27,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )39,      (yytype_uint8 const   )4,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )22,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )51,      (yytype_uint8 const   )59,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )56,      (yytype_uint8 const   )57,      (yytype_uint8 const   )50,      (yytype_uint8 const   )51, 
        (yytype_uint8 const   )35,      (yytype_uint8 const   )36,      (yytype_uint8 const   )44,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )43,      (yytype_uint8 const   )23,      (yytype_uint8 const   )39, 
        (yytype_uint8 const   )59,      (yytype_uint8 const   )26,      (yytype_uint8 const   )59,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )28,      (yytype_uint8 const   )21,      (yytype_uint8 const   )52,      (yytype_uint8 const   )23, 
        (yytype_uint8 const   )36,      (yytype_uint8 const   )16,      (yytype_uint8 const   )23,      (yytype_uint8 const   )43, 
        (yytype_uint8 const   )59,      (yytype_uint8 const   )27,      (yytype_uint8 const   )59,      (yytype_uint8 const   )59, 
        (yytype_uint8 const   )59,      (yytype_uint8 const   )59,      (yytype_uint8 const   )59,      (yytype_uint8 const   )57, 
        (yytype_uint8 const   )28,      (yytype_uint8 const   )53,      (yytype_uint8 const   )59,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )14,      (yytype_uint8 const   )54,      (yytype_uint8 const   )11, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )25,      (yytype_uint8 const   )58,      (yytype_uint8 const   )59, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )60,      (yytype_uint8 const   )61,      (yytype_uint8 const   )59, 
        (yytype_uint8 const   )27,      (yytype_uint8 const   )28,      (yytype_uint8 const   )61};
#line 1156 "y.tab.c"
static void yydestruct(char const   *yymsg , int yytype , YYSTYPE *yyvaluep ) 
{ 


  {
#line 1168
  if (! yymsg) {
#line 1169
    yymsg = "Deleting";
  }
  {
#line 1175
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1176
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1178
  return;
}
}
#line 1200 "y.tab.c"
int yychar  ;
#line 1203 "y.tab.c"
YYSTYPE yylval  ;
#line 1206 "y.tab.c"
int yynerrs  ;
#line 1227 "y.tab.c"
int yyparse(void) 
{ 
  int yystate ;
  int yyn ;
  int yyresult ;
  int yyerrstatus ;
  int yytoken ;
  yytype_int16 yyssa[200] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  YYSTYPE yyvsa[200] ;
  YYSTYPE *yyvs ;
  YYSTYPE *yyvsp ;
  unsigned long yystacksize ;
  YYSTYPE yyval ;
  int yylen ;
  unsigned long yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc *yyptr ;
  void *tmp ;
  unsigned long yynewbytes ;
  unsigned long yynewbytes___0 ;
  struct module_list *ml ;
  struct program_list *pl ;
  struct program *res ;
  struct program *tmp___0 ;
  struct module_list *ml___0 ;
  int lc ;
  int n ;
  int htcnt ;
  int tlcnt ;
  struct textlist *tl ;
  char *tmp___1 ;
  unsigned int uflags ;
  struct filelist *c ;
  struct filelist *n___0 ;
  char *cp ;
  struct valname *vn ;
  void *tmp___2 ;
  int cnt ;
  int tmp___3 ;
  struct textlist *tl___0 ;

  {
#line 1243
  yytoken = 0;
#line 1261
  yyss = yyssa;
#line 1266
  yyvs = yyvsa;
#line 1273
  yystacksize = 200UL;
#line 1282
  yylen = 0;
#line 1286
  yystate = 0;
#line 1287
  yyerrstatus = 0;
#line 1288
  yynerrs = 0;
#line 1289
  yychar = -2;
#line 1296
  yyssp = yyss;
#line 1297
  yyvsp = yyvs;
#line 1299
  goto yysetstate;
  yynewstate: 
#line 1307
  yyssp ++;
  yysetstate: 
#line 1310
  *yyssp = (yytype_int16 )yystate;
#line 1312
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1315
    yysize = (unsigned long )((yyssp - yyss) + 1L);
#line 1344
    if (10000UL <= yystacksize) {
#line 1345
      goto yyexhaustedlab;
    }
#line 1346
    yystacksize *= 2UL;
#line 1347
    if (10000UL < yystacksize) {
#line 1348
      yystacksize = 10000UL;
    }
    {
#line 1351
    yyss1 = yyss;
#line 1352
    tmp = malloc(yystacksize * (sizeof(yytype_int16 ) + sizeof(YYSTYPE )) + (sizeof(union yyalloc ) - 1UL));
#line 1352
    yyptr = (union yyalloc *)tmp;
    }
#line 1354
    if (! yyptr) {
#line 1355
      goto yyexhaustedlab;
    }
    {
#line 1356
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1356
      __builtin_memcpy((void *)(& yyptr->yyss), (void const   *)yyss, yysize * sizeof(*yyss));
#line 1356
      yyss = & yyptr->yyss;
#line 1356
      yynewbytes = yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1UL);
#line 1356
      yyptr += yynewbytes / sizeof(*yyptr);
      }
#line 1356
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1357
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1357
      __builtin_memcpy((void *)(& yyptr->yyvs), (void const   *)yyvs, yysize * sizeof(*yyvs));
#line 1357
      yyvs = & yyptr->yyvs;
#line 1357
      yynewbytes___0 = yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1UL);
#line 1357
      yyptr += yynewbytes___0 / sizeof(*yyptr);
      }
#line 1357
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1360
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
#line 1361
      free((void *)yyss1);
      }
    }
#line 1366
    yyssp = (yyss + yysize) - 1;
#line 1367
    yyvsp = (yyvs + yysize) - 1;
#line 1373
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1374
      goto yyabortlab;
    }
  }
#line 1379
  goto yybackup;
  yybackup: 
#line 1390
  yyn = (int )yypact[yystate];
#line 1391
  if (yyn == -43) {
#line 1392
    goto yydefault;
  }
#line 1397
  if (yychar == -2) {
    {
#line 1400
    yychar = yylex();
    }
  }
#line 1403
  if (yychar <= 0) {
#line 1405
    yytoken = 0;
#line 1405
    yychar = yytoken;
  } else
#line 1410
  if ((unsigned int )yychar <= 272U) {
#line 1410
    yytoken = (int )yytranslate[yychar];
  } else {
#line 1410
    yytoken = 2;
  }
#line 1416
  yyn += yytoken;
#line 1417
  if (yyn < 0) {
#line 1418
    goto yydefault;
  } else
#line 1417
  if (125 < yyn) {
#line 1418
    goto yydefault;
  } else
#line 1417
  if ((int const   )yycheck[yyn] != (int const   )yytoken) {
#line 1418
    goto yydefault;
  }
#line 1419
  yyn = (int )yytable[yyn];
#line 1420
  if (yyn <= 0) {
#line 1422
    if (yyn == 0) {
#line 1423
      goto yyerrlab;
    } else
#line 1422
    if (yyn == -32) {
#line 1423
      goto yyerrlab;
    }
#line 1424
    yyn = - yyn;
#line 1425
    goto yyreduce;
  }
#line 1428
  if (yyn == 17) {
#line 1429
    goto yyacceptlab;
  }
#line 1433
  if (yyerrstatus) {
#line 1434
    yyerrstatus --;
  }
#line 1440
  if (yychar != 0) {
#line 1441
    yychar = -2;
  }
#line 1443
  yystate = yyn;
#line 1444
  yyvsp ++;
#line 1444
  *yyvsp = yylval;
#line 1446
  goto yynewstate;
  yydefault: 
#line 1453
  yyn = (int )yydefact[yystate];
#line 1454
  if (yyn == 0) {
#line 1455
    goto yyerrlab;
  }
#line 1456
  goto yyreduce;
  yyreduce: 
#line 1464
  yylen = (int )yyr2[yyn];
#line 1474
  yyval = *(yyvsp + (1 - yylen));
  {
#line 1480
  if (yyn == 9) {
#line 1480
    goto case_9;
  }
#line 101
  if (yyn == 11) {
#line 101 "msgparse.y"
    goto case_11;
  }
#line 113
  if (yyn == 12) {
#line 113
    goto case_12;
  }
#line 122
  if (yyn == 13) {
#line 122
    goto case_13;
  }
#line 131
  if (yyn == 15) {
#line 131
    goto case_15;
  }
#line 143
  if (yyn == 16) {
#line 143
    goto case_16;
  }
#line 151
  if (yyn == 17) {
#line 151
    goto case_17;
  }
#line 159
  if (yyn == 18) {
#line 159
    goto case_18;
  }
#line 169
  if (yyn == 20) {
#line 169
    goto case_20;
  }
#line 180
  if (yyn == 21) {
#line 180
    goto case_21;
  }
#line 186
  if (yyn == 22) {
#line 186
    goto case_22;
  }
#line 192
  if (yyn == 23) {
#line 192
    goto case_23;
  }
#line 200
  if (yyn == 28) {
#line 200
    goto case_28;
  }
#line 216
  if (yyn == 29) {
#line 216
    goto case_29;
  }
#line 237
  if (yyn == 30) {
#line 237
    goto case_30;
  }
#line 288
  if (yyn == 31) {
#line 288
    goto case_31;
  }
#line 292
  if (yyn == 33) {
#line 292
    goto case_33;
  }
#line 300
  if (yyn == 35) {
#line 300
    goto case_35;
  }
#line 308
  if (yyn == 36) {
#line 308
    goto case_36;
  }
#line 316
  if (yyn == 37) {
#line 316
    goto case_37;
  }
#line 325
  if (yyn == 38) {
#line 325
    goto case_38;
  }
#line 345
  if (yyn == 39) {
#line 345
    goto case_39;
  }
#line 351
  if (yyn == 40) {
#line 351
    goto case_40;
  }
#line 356
  if (yyn == 41) {
#line 356
    goto case_41;
  }
#line 362
  if (yyn == 42) {
#line 362
    goto case_42;
  }
#line 367
  if (yyn == 44) {
#line 367
    goto case_44;
  }
#line 376
  if (yyn == 45) {
#line 376
    goto case_45;
  }
#line 395
  if (yyn == 46) {
#line 395
    goto case_46;
  }
#line 401
  if (yyn == 47) {
#line 401
    goto case_47;
  }
#line 406
  if (yyn == 48) {
#line 406
    goto case_48;
  }
#line 411
  if (yyn == 49) {
#line 411
    goto case_49;
  }
#line 416
  if (yyn == 50) {
#line 416
    goto case_50;
  }
#line 422
  if (yyn == 51) {
#line 422
    goto case_51;
  }
#line 427
  if (yyn == 52) {
#line 427
    goto case_52;
  }
#line 432
  if (yyn == 53) {
#line 432
    goto case_53;
  }
#line 438
  if (yyn == 54) {
#line 438
    goto case_54;
  }
#line 443
  if (yyn == 55) {
#line 443
    goto case_55;
  }
#line 451
  if (yyn == 56) {
#line 451
    goto case_56;
  }
#line 459
  if (yyn == 57) {
#line 459
    goto case_57;
  }
#line 467
  if (yyn == 58) {
#line 467
    goto case_58;
  }
#line 478
  if (yyn == 59) {
#line 478
    goto case_59;
  }
#line 486
  if (yyn == 60) {
#line 486
    goto case_60;
  }
#line 494
  if (yyn == 61) {
#line 494
    goto case_61;
  }
#line 502
  if (yyn == 62) {
#line 502
    goto case_62;
  }
#line 506
  if (yyn == 63) {
#line 506
    goto case_63;
  }
#line 511
  if (yyn == 64) {
#line 511
    goto case_64;
  }
#line 524
  if (yyn == 65) {
#line 524
    goto case_65___0;
  }
#line 1971 "y.tab.c"
  goto switch_default;
  case_9: /* CIL Label */ 
#line 94
  if (pass1) {
    {
#line 95
    macro_define((yyvsp + -4)->str, (yyvsp + -3)->str, (yyvsp + -1)->mlist);
    }
  } else {
    {
#line 97 "msgparse.y"
    free((void *)(yyvsp + -4)->str);
    }
  }
#line 99
  goto switch_break;
  case_11: /* CIL Label */ 
#line 104
  if (pass1) {
#line 106
    ml = (yyvsp + -1)->mlist;
    {
#line 106
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 106
      if (! ml->ml_next) {
#line 106
        goto while_break___1;
      }
#line 106
      ml = ml->ml_next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 108
    ml->ml_next = (yyvsp + 0)->mlist;
  }
#line 111
  goto switch_break;
  case_12: /* CIL Label */ 
#line 115
  if (pass1) {
    {
#line 116
    yyval.mlist = alloc_module((yyvsp + 0)->str, (yyvsp + -1)->str);
    }
  } else {
    {
#line 118
    free((void *)(yyvsp + 0)->str);
    }
  }
#line 120
  goto switch_break;
  case_13: /* CIL Label */ 
#line 124
  if (pass1) {
    {
#line 125
    define_helpsfor((yyvsp + -4)->str, (yyvsp + -3)->str, (yyvsp + -1)->plist);
    }
  } else {
    {
#line 127
    free((void *)(yyvsp + -4)->str);
    }
  }
#line 129
  goto switch_break;
  case_15: /* CIL Label */ 
#line 134
  if (pass1) {
#line 136
    pl = (yyvsp + -1)->plist;
    {
#line 136
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 136
      if (! pl->pl_next) {
#line 136
        goto while_break___2;
      }
#line 136
      pl = pl->pl_next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 138
    pl->pl_next = (yyvsp + 0)->plist;
  }
#line 141
  goto switch_break;
  case_16: /* CIL Label */ 
#line 145
  if (pass1) {
    {
#line 146
    yyval.plist = alloc_proglist((yyvsp + 0)->str);
    }
  }
  {
#line 147
  free((void *)(yyvsp + 0)->str);
  }
#line 149
  goto switch_break;
  case_17: /* CIL Label */ 
#line 153
  if (pass1) {
    {
#line 154
    assign_progmods((yyvsp + -4)->pgm, (yyvsp + -3)->str, (yyvsp + -1)->mlist);
    }
  }
  {
#line 155
  free_modlist((yyvsp + -1)->mlist);
  }
#line 157
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 161
  tmp___0 = find_program((yyvsp + 0)->str);
#line 161
  res = tmp___0;
  }
#line 162
  if (! res) {
    {
#line 163
    yyerror((char *)"Undefined program name");
    }
  }
  {
#line 164
  yyval.pgm = res;
#line 165
  free((void *)(yyvsp + 0)->str);
  }
#line 167
  goto switch_break;
  case_20: /* CIL Label */ 
#line 174
  ml___0 = (yyvsp + -1)->mlist;
  {
#line 174
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 174
    if (! ml___0->ml_next) {
#line 174
      goto while_break___3;
    }
#line 174
    ml___0 = ml___0->ml_next;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 176
  ml___0->ml_next = (yyvsp + 0)->mlist;
#line 178
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 182
  yyval.mlist = lookupallocmods((yyvsp + 0)->str);
  }
#line 184
  goto switch_break;
  case_22: /* CIL Label */ 
#line 188
  yyval.str = (char *)0;
#line 190
  goto switch_break;
  case_23: /* CIL Label */ 
#line 193
  if (pass1) {
#line 194
    yyval.str = (yyvsp + -1)->str;
  } else {
    {
#line 196
    free((void *)(yyvsp + -1)->str);
    }
  }
#line 198
  goto switch_break;
  case_28: /* CIL Label */ 
#line 209
  lc = line_count;
  {
#line 210
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 210
    yylex();
    }
#line 210
    if (! (line_count == lc)) {
#line 210
      goto while_break___4;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 212
  yychar = -2;
#line 214
  goto switch_break;
  case_29: /* CIL Label */ 
#line 218
  if (pass1) {
#line 219
    if ((int )((yyvsp + -2)->vname)->vn_flags & (1 << 15)) {
      {
#line 220
      yyerror((char *)"Symbol value redefined");
      }
    } else {
      {
#line 222
      last_value = evaluate((yyvsp + 0)->vexpr);
#line 222
      ((yyvsp + -2)->vname)->vn_value = (short )last_value;
#line 223
      ((yyvsp + -2)->vname)->vn_flags = (unsigned short )((int )((yyvsp + -2)->vname)->vn_flags | (1 << 15));
      }
    }
  } else {
    {
#line 227
    last_value = evaluate((yyvsp + 0)->vexpr);
    }
  }
#line 228
  last_assign = (yyvsp + -2)->vname;
#line 229
  if (last_expr) {
    {
#line 230
    throwaway_expr(last_expr);
#line 231
    last_expr = (struct valexpr *)0;
    }
  }
  {
#line 233
  throwaway_expr((yyvsp + 0)->vexpr);
  }
#line 235
  goto switch_break;
  case_30: /* CIL Label */ 
#line 239
  htcnt = 0;
#line 239
  tlcnt = 0;
#line 241
  n = 0;
  {
#line 241
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 241
    if (n < 11) {
#line 241
      if (! *((yyvsp + -3)->str + n)) {
#line 241
        goto while_break___5;
      }
    } else {
#line 241
      goto while_break___5;
    }
    {
#line 242
    tmp___1 = strchr("EHPAKQRX", (int )htlist[n]);
    }
#line 242
    if (tmp___1) {
#line 243
      htcnt ++;
    }
#line 241
    n ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 244
  tl = (yyvsp + 0)->tlist;
  {
#line 244
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 244
    if (! tl) {
#line 244
      goto while_break___6;
    }
#line 245
    tlcnt ++;
#line 244
    tl = tl->tl_next;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 246
  if (tlcnt != htcnt) {
    {
#line 247
    yyerror((char *)"Help types and text lists do not match");
    }
  }
#line 249
  if (pass1) {
#line 250
    uflags = 0U;
#line 251
    n = 0;
    {
#line 251
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 251
      if (n < 11) {
#line 251
        if (! *((yyvsp + -3)->str + n)) {
#line 251
          goto while_break___7;
        }
      } else {
#line 251
        goto while_break___7;
      }
      {
#line 253
      if ((int )*((yyvsp + -3)->str + n) == 69) {
#line 253
        goto case_69;
      }
#line 254
      if ((int )*((yyvsp + -3)->str + n) == 72) {
#line 254
        goto case_72;
      }
#line 255
      if ((int )*((yyvsp + -3)->str + n) == 80) {
#line 255
        goto case_80;
      }
#line 256
      if ((int )*((yyvsp + -3)->str + n) == 81) {
#line 256
        goto case_81;
      }
#line 257
      if ((int )*((yyvsp + -3)->str + n) == 82) {
#line 257
        goto case_82;
      }
#line 258
      if ((int )*((yyvsp + -3)->str + n) == 65) {
#line 258
        goto case_65;
      }
#line 259
      if ((int )*((yyvsp + -3)->str + n) == 75) {
#line 259
        goto case_75;
      }
#line 260
      if ((int )*((yyvsp + -3)->str + n) == 78) {
#line 260
        goto case_78;
      }
#line 261
      if ((int )*((yyvsp + -3)->str + n) == 83) {
#line 261
        goto case_83;
      }
#line 262
      if ((int )*((yyvsp + -3)->str + n) == 88) {
#line 262
        goto case_88;
      }
#line 252
      goto switch_break___0;
      case_69: /* CIL Label */ 
#line 253
      uflags |= 1U;
#line 253
      goto switch_break___0;
      case_72: /* CIL Label */ 
#line 254
      uflags |= (unsigned int )(1 << 1);
#line 254
      goto switch_break___0;
      case_80: /* CIL Label */ 
#line 255
      uflags |= (unsigned int )(1 << 2);
#line 255
      goto switch_break___0;
      case_81: /* CIL Label */ 
#line 256
      uflags |= (unsigned int )(1 << 3);
#line 256
      goto switch_break___0;
      case_82: /* CIL Label */ 
#line 257
      uflags |= (unsigned int )((1 << 3) | (1 << 14));
#line 257
      goto switch_break___0;
      case_65: /* CIL Label */ 
#line 258
      uflags |= (unsigned int )(1 << 4);
#line 258
      goto switch_break___0;
      case_75: /* CIL Label */ 
#line 259
      uflags |= (unsigned int )(1 << 5);
#line 259
      goto switch_break___0;
      case_78: /* CIL Label */ 
#line 260
      uflags |= (unsigned int )(1 << 6);
#line 260
      goto switch_break___0;
      case_83: /* CIL Label */ 
#line 261
      uflags |= (unsigned int )(1 << 7);
#line 261
      goto switch_break___0;
      case_88: /* CIL Label */ 
#line 262
      uflags |= (unsigned int )(1 << 8);
#line 262
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 251
      n ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 264
    valname_usage((yyvsp + -2)->vexpr, (unsigned int const   )uflags);
    }
  } else {
#line 267
    if ((yyvsp + -1)->num) {
#line 267
      if (last_expr) {
        {
#line 268
        merge_helps(last_expr, (yyvsp + -2)->vexpr);
        }
      }
    }
    {
#line 269
    apphelps((yyvsp + -6)->str, (yyvsp + -4)->vexpr, (yyvsp + -3)->str, (yyvsp + -2)->vexpr,
             (yyvsp + -5)->flist, (yyvsp + 0)->tlist);
    }
  }
#line 271
  if ((yyvsp + -6)->str) {
    {
#line 272
    free((void *)(yyvsp + -6)->str);
    }
  }
#line 273
  if ((yyvsp + -5)->flist) {
#line 274
    c = (yyvsp + -5)->flist;
    {
#line 275
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 276
      n___0 = c->next;
#line 277
      free((void *)c->name);
#line 278
      free((void *)((char *)c));
#line 275
      c = n___0;
      }
#line 275
      if (! c) {
#line 275
        goto while_break___8;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
  }
  {
#line 281
  throwaway_strs((yyvsp + 0)->tlist);
  }
#line 282
  if (last_expr) {
    {
#line 283
    throwaway_expr(last_expr);
    }
  }
#line 284
  last_expr = (yyvsp + -2)->vexpr;
#line 286
  goto switch_break;
  case_31: /* CIL Label */ 
#line 289
  yyval.str = (char *)0;
#line 290
  goto switch_break;
  case_33: /* CIL Label */ 
#line 296
  yyval.vexpr = (struct valexpr *)0;
#line 298
  goto switch_break;
  case_35: /* CIL Label */ 
#line 304
  yyval.vexpr = (yyvsp + -1)->vexpr;
#line 306
  goto switch_break;
  case_36: /* CIL Label */ 
  {
#line 310
  memset((void *)(htlist), '\000', sizeof(htlist));
#line 311
  htlist[0] = (yyvsp + 0)->ch;
#line 312
  yyval.str = htlist;
  }
#line 314
  goto switch_break;
  case_37: /* CIL Label */ 
#line 317
  cp = htlist;
  {
#line 318
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 318
    if (! *cp) {
#line 318
      goto while_break___9;
    }
#line 319
    cp ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 320
  *cp = (yyvsp + 0)->ch;
#line 321
  yyval.str = htlist;
#line 323
  goto switch_break;
  case_38: /* CIL Label */ 
#line 327
  if ((yyvsp + 0)->vexpr) {
#line 328
    if ((int )((yyvsp + -1)->vexpr)->val_op != 2) {
      {
#line 329
      yyerror((char *)"Cannot assign to expression");
      }
    } else {
#line 331
      vn = ((yyvsp + -1)->vexpr)->val_un.val_name;
#line 332
      if (pass1) {
#line 332
        if ((int )vn->vn_flags & (1 << 15)) {
          {
#line 333
          yyerror((char *)"Symbol value redefined in message def");
          }
        }
      }
      {
#line 334
      vn->vn_flags = (unsigned short )((int )vn->vn_flags | (1 << 15));
#line 335
      last_assign = vn;
#line 336
      last_value = evaluate((yyvsp + 0)->vexpr);
#line 336
      vn->vn_value = (short )last_value;
      }
    }
  } else {
    {
#line 340
    last_value = evaluate((yyvsp + -1)->vexpr);
    }
  }
#line 341
  yyval.vexpr = (yyvsp + -1)->vexpr;
#line 343
  goto switch_break;
  case_39: /* CIL Label */ 
#line 347
  yyval.num = 0;
#line 349
  goto switch_break;
  case_40: /* CIL Label */ 
#line 352
  yyval.num = 1;
#line 354
  goto switch_break;
  case_41: /* CIL Label */ 
#line 358
  yyval.flist = (struct filelist *)0;
#line 360
  goto switch_break;
  case_42: /* CIL Label */ 
#line 363
  yyval.flist = (yyvsp + 0)->flist;
#line 365
  goto switch_break;
  case_44: /* CIL Label */ 
#line 371
  ((yyvsp + 0)->flist)->next = (yyvsp + -2)->flist;
#line 372
  yyval.flist = (yyvsp + 0)->flist;
#line 374
  goto switch_break;
  case_45: /* CIL Label */ 
  {
#line 378
  tmp___2 = malloc(sizeof(struct filelist ));
#line 378
  yyval.flist = (struct filelist *)tmp___2;
  }
#line 378
  if (! yyval.flist) {
    {
#line 379
    nomem();
    }
  }
#line 380
  (yyval.flist)->next = (struct filelist *)0;
#line 381
  (yyval.flist)->name = (yyvsp + 0)->str;
#line 382
  if (pass1) {
#line 384
    cnt = 0;
    {
#line 384
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 384
      if (cnt < 10) {
#line 384
        if (! helpfiles[cnt].hf_name) {
#line 384
          goto while_break___10;
        }
      } else {
#line 384
        goto while_break___10;
      }
      {
#line 385
      tmp___3 = strcmp((char const   *)(yyvsp + 0)->str, (char const   *)helpfiles[cnt].hf_name);
      }
#line 385
      if (tmp___3 == 0) {
#line 386
        goto ok;
      }
#line 384
      cnt ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 387
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown help file %s on line %d\n",
            (yyvsp + 0)->str, line_count);
#line 388
    errors ++;
    }
  }
  ok: ;
#line 393
  goto switch_break;
  case_46: /* CIL Label */ 
#line 397
  yyval.vexpr = (struct valexpr *)0;
#line 399
  goto switch_break;
  case_47: /* CIL Label */ 
  {
#line 402
  yyval.vexpr = make_value((int const   )(last_value + 1L));
  }
#line 404
  goto switch_break;
  case_48: /* CIL Label */ 
  {
#line 407
  yyval.vexpr = make_value((int const   )(last_value - 1L));
  }
#line 409
  goto switch_break;
  case_49: /* CIL Label */ 
#line 412
  yyval.vexpr = (yyvsp + 0)->vexpr;
#line 414
  goto switch_break;
  case_50: /* CIL Label */ 
  {
#line 418
  yyval.vexpr = make_name((yyvsp + 0)->vname);
  }
#line 420
  goto switch_break;
  case_51: /* CIL Label */ 
  {
#line 423
  yyval.vexpr = make_value((int const   )(yyvsp + 0)->num);
  }
#line 425
  goto switch_break;
  case_52: /* CIL Label */ 
  {
#line 428
  yyval.vexpr = make_value((int const   )last_value);
  }
#line 430
  goto switch_break;
  case_53: /* CIL Label */ 
  {
#line 433
  yyval.vexpr = make_value((int const   )(yyvsp + 0)->ch);
#line 434
  (yyval.vexpr)->val_op = (unsigned char)1;
  }
#line 436
  goto switch_break;
  case_54: /* CIL Label */ 
#line 439
  yyval.vexpr = (yyvsp + 0)->vexpr;
#line 441
  goto switch_break;
  case_55: /* CIL Label */ 
  {
#line 444
  yyval.vexpr = alloc_expr();
#line 445
  (yyval.vexpr)->val_op = (unsigned char)3;
#line 446
  (yyval.vexpr)->val_left = (yyvsp + -3)->vexpr;
#line 447
  (yyval.vexpr)->val_un.val_right = (yyvsp + -1)->vexpr;
  }
#line 449
  goto switch_break;
  case_56: /* CIL Label */ 
  {
#line 452
  yyval.vexpr = alloc_expr();
#line 453
  (yyval.vexpr)->val_op = (unsigned char )(yyvsp + -1)->ch;
#line 454
  (yyval.vexpr)->val_left = (yyvsp + -2)->vexpr;
#line 455
  (yyval.vexpr)->val_un.val_right = (yyvsp + 0)->vexpr;
  }
#line 457
  goto switch_break;
  case_57: /* CIL Label */ 
  {
#line 460
  yyval.vexpr = alloc_expr();
#line 461
  (yyval.vexpr)->val_op = (unsigned char )(yyvsp + -1)->ch;
#line 462
  (yyval.vexpr)->val_left = (yyvsp + -2)->vexpr;
#line 463
  (yyval.vexpr)->val_un.val_right = (yyvsp + 0)->vexpr;
  }
#line 465
  goto switch_break;
  case_58: /* CIL Label */ 
  {
#line 468
  yyval.vexpr = alloc_expr();
#line 469
  (yyval.vexpr)->val_op = (unsigned char )(yyvsp + -1)->ch;
#line 470
  (yyval.vexpr)->val_un.val_right = (yyvsp + 0)->vexpr;
#line 471
  (yyval.vexpr)->val_left = alloc_expr();
#line 472
  ((yyval.vexpr)->val_left)->val_op = (unsigned char)0;
#line 473
  ((yyval.vexpr)->val_left)->val_left = (struct valexpr *)0;
#line 474
  ((yyval.vexpr)->val_left)->val_un.val_value = 0L;
  }
#line 476
  goto switch_break;
  case_59: /* CIL Label */ 
  {
#line 479
  yyval.vexpr = alloc_expr();
#line 480
  (yyval.vexpr)->val_op = (unsigned char )(yyvsp + -1)->ch;
#line 481
  (yyval.vexpr)->val_left = (yyvsp + -2)->vexpr;
#line 482
  (yyval.vexpr)->val_un.val_right = (yyvsp + 0)->vexpr;
  }
#line 484
  goto switch_break;
  case_60: /* CIL Label */ 
  {
#line 487
  yyval.vexpr = alloc_expr();
#line 488
  (yyval.vexpr)->val_op = (unsigned char )(yyvsp + -1)->ch;
#line 489
  (yyval.vexpr)->val_left = (yyvsp + -2)->vexpr;
#line 490
  (yyval.vexpr)->val_un.val_right = (yyvsp + 0)->vexpr;
  }
#line 492
  goto switch_break;
  case_61: /* CIL Label */ 
  {
#line 495
  yyval.vexpr = alloc_expr();
#line 496
  (yyval.vexpr)->val_op = (unsigned char )(yyvsp + -1)->ch;
#line 497
  (yyval.vexpr)->val_left = (yyvsp + -2)->vexpr;
#line 498
  (yyval.vexpr)->val_un.val_right = (yyvsp + 0)->vexpr;
  }
#line 500
  goto switch_break;
  case_62: /* CIL Label */ 
#line 503
  yyval.tlist = (struct textlist *)0;
#line 504
  goto switch_break;
  case_63: /* CIL Label */ 
#line 507
  yyval.tlist = (yyvsp + 0)->tlist;
#line 509
  goto switch_break;
  case_64: /* CIL Label */ 
#line 512
  if ((yyvsp + -2)->tlist) {
#line 514
    tl___0 = (yyvsp + -2)->tlist;
    {
#line 514
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 514
      if (! tl___0->tl_next) {
#line 514
        goto while_break___11;
      }
#line 514
      tl___0 = tl___0->tl_next;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 516
    tl___0->tl_next = (yyvsp + 0)->tlist;
#line 517
    yyval.tlist = (yyvsp + -2)->tlist;
  } else {
#line 520
    yyval.tlist = (yyvsp + 0)->tlist;
  }
#line 522
  goto switch_break;
  case_65___0: /* CIL Label */ 
  {
#line 526
  yyval.tlist = alloc_textlist((yyvsp + 0)->str);
  }
#line 528
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1971 "y.tab.c"
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1975
  yyvsp -= yylen;
#line 1975
  yyssp -= yylen;
#line 1976
  yylen = 0;
#line 1979
  yyvsp ++;
#line 1979
  *yyvsp = yyval;
#line 1986
  yyn = (int )yyr1[yyn];
#line 1988
  yystate = (int )((int const   )yypgoto[yyn - 30] + (int const   )*yyssp);
#line 1989
  if (0 <= yystate) {
#line 1989
    if (yystate <= 125) {
#line 1989
      if ((int const   )yycheck[yystate] == (int const   )*yyssp) {
#line 1990
        yystate = (int )yytable[yystate];
      } else {
#line 1992
        yystate = (int )yydefgoto[yyn - 30];
      }
    } else {
#line 1992
      yystate = (int )yydefgoto[yyn - 30];
    }
  } else {
#line 1992
    yystate = (int )yydefgoto[yyn - 30];
  }
#line 1994
  goto yynewstate;
  yyerrlab: 
#line 2002
  if (! yyerrstatus) {
    {
#line 2004
    yynerrs ++;
#line 2006
    yyerror((char *)"syntax error");
    }
  }
#line 2044
  if (yyerrstatus == 3) {
#line 2049
    if (yychar <= 0) {
#line 2052
      if (yychar == 0) {
#line 2053
        goto yyabortlab;
      }
    } else {
      {
#line 2057
      yydestruct("Error: discarding", yytoken, & yylval);
#line 2059
      yychar = -2;
      }
    }
  }
#line 2065
  goto yyerrlab1;
#line 2081
  yyvsp -= yylen;
#line 2081
  yyssp -= yylen;
#line 2082
  yylen = 0;
#line 2084
  yystate = (int )*yyssp;
#line 2085
  goto yyerrlab1;
  yyerrlab1: 
#line 2092
  yyerrstatus = 3;
  {
#line 2094
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 2096
    yyn = (int )yypact[yystate];
#line 2097
    if (yyn != -43) {
#line 2099
      yyn ++;
#line 2100
      if (0 <= yyn) {
#line 2100
        if (yyn <= 125) {
#line 2100
          if ((int const   )yycheck[yyn] == 1) {
#line 2102
            yyn = (int )yytable[yyn];
#line 2103
            if (0 < yyn) {
#line 2104
              goto while_break___12;
            }
          }
        }
      }
    }
#line 2109
    if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 2110
      goto yyabortlab;
    }
    {
#line 2113
    yydestruct("Error: popping", (int )yystos[yystate], yyvsp);
#line 2115
    yyvsp --;
#line 2115
    yyssp --;
#line 2116
    yystate = (int )*yyssp;
    }
  }
  while_break___12: /* CIL Label */ ;
  }
#line 2120
  if (yyn == 17) {
#line 2121
    goto yyacceptlab;
  }
#line 2123
  yyvsp ++;
#line 2123
  *yyvsp = yylval;
#line 2129
  yystate = yyn;
#line 2130
  goto yynewstate;
  yyacceptlab: 
#line 2137
  yyresult = 0;
#line 2138
  goto yyreturn;
  yyabortlab: 
#line 2144
  yyresult = 1;
#line 2145
  goto yyreturn;
  yyexhaustedlab: 
  {
#line 2152
  yyerror((char *)"memory exhausted");
#line 2153
  yyresult = 2;
  }
  yyreturn: 
#line 2158
  if (yychar != 0) {
#line 2158
    if (yychar != -2) {
      {
#line 2159
      yydestruct("Cleanup: discarding lookahead", yytoken, & yylval);
      }
    }
  }
#line 2163
  yyvsp -= yylen;
#line 2163
  yyssp -= yylen;
  {
#line 2165
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 2165
    if (! ((unsigned long )yyssp != (unsigned long )yyss)) {
#line 2165
      goto while_break___13;
    }
    {
#line 2167
    yydestruct("Cleanup: popping", (int )yystos[*yyssp], yyvsp);
#line 2169
    yyvsp --;
#line 2169
    yyssp --;
    }
  }
  while_break___13: /* CIL Label */ ;
  }
#line 2172
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
#line 2173
    free((void *)yyss);
    }
  }
#line 2180
  return (yyresult);
}
}
#line 709 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 826
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) clearerr)(FILE *__stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 156 "lex.yy.c"
int yyleng  ;
#line 158
FILE *yyin ;
#line 158
FILE *yyout ;
#line 253 "lex.yy.c"
static size_t yy_buffer_stack_top  =    (size_t )0;
#line 254 "lex.yy.c"
static size_t yy_buffer_stack_max  =    (size_t )0;
#line 255 "lex.yy.c"
static YY_BUFFER_STATE *yy_buffer_stack  =    (YY_BUFFER_STATE *)0;
#line 273 "lex.yy.c"
static char yy_hold_char  ;
#line 274 "lex.yy.c"
static int yy_n_chars  ;
#line 278 "lex.yy.c"
static char *yy_c_buf_p  =    (char *)0;
#line 279 "lex.yy.c"
static int yy_init  =    0;
#line 280 "lex.yy.c"
static int yy_start  =    0;
#line 285 "lex.yy.c"
static int yy_did_buffer_switch_on_eof  ;
#line 287
void yyrestart(FILE *input_file ) ;
#line 288
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer ) ;
#line 289
YY_BUFFER_STATE yy_create_buffer(FILE *file , int size ) ;
#line 290
void yy_delete_buffer(YY_BUFFER_STATE b ) ;
#line 291
void yy_flush_buffer(YY_BUFFER_STATE b ) ;
#line 292
void yypush_buffer_state(YY_BUFFER_STATE new_buffer ) ;
#line 293
void yypop_buffer_state(void) ;
#line 295
static void yyensure_buffer_stack(void) ;
#line 296
static void yy_load_buffer_state(void) ;
#line 297
static void yy_init_buffer(YY_BUFFER_STATE b , FILE *file ) ;
#line 301
YY_BUFFER_STATE yy_scan_buffer(char *base , yy_size_t size ) ;
#line 302
YY_BUFFER_STATE yy_scan_string(char const   *yystr ) ;
#line 303
YY_BUFFER_STATE yy_scan_bytes(char const   *yybytes , int _yybytes_len ) ;
#line 305
void *yyalloc(yy_size_t size ) ;
#line 306
void *yyrealloc(void *ptr , yy_size_t size ) ;
#line 307
void yyfree(void *ptr ) ;
#line 337 "lex.yy.c"
FILE *yyin  =    (FILE *)0;
#line 337 "lex.yy.c"
FILE *yyout  =    (FILE *)0;
#line 341
int yylineno ;
#line 343 "lex.yy.c"
int yylineno  =    1;
#line 345 "lex.yy.c"
char *yytext  ;
#line 348
static yy_state_type yy_get_previous_state(void) ;
#line 349
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) ;
#line 350
static int yy_get_next_buffer(void) ;
#line 351
static void yy_fatal_error(char const   *msg ) ;
#line 372 "lex.yy.c"
static flex_int16_t const   yy_accept[59]  = 
#line 372
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )21, 
        (flex_int16_t const   )19,      (flex_int16_t const   )15,      (flex_int16_t const   )16,      (flex_int16_t const   )17, 
        (flex_int16_t const   )19,      (flex_int16_t const   )11,      (flex_int16_t const   )19,      (flex_int16_t const   )11, 
        (flex_int16_t const   )11,      (flex_int16_t const   )14,      (flex_int16_t const   )2,      (flex_int16_t const   )19, 
        (flex_int16_t const   )19,      (flex_int16_t const   )19,      (flex_int16_t const   )19,      (flex_int16_t const   )2, 
        (flex_int16_t const   )18,      (flex_int16_t const   )11,      (flex_int16_t const   )15,      (flex_int16_t const   )0, 
        (flex_int16_t const   )1,      (flex_int16_t const   )0,      (flex_int16_t const   )9,      (flex_int16_t const   )10, 
        (flex_int16_t const   )14,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )12,      (flex_int16_t const   )13,      (flex_int16_t const   )8,      (flex_int16_t const   )8, 
        (flex_int16_t const   )8,      (flex_int16_t const   )8,      (flex_int16_t const   )8,      (flex_int16_t const   )8, 
        (flex_int16_t const   )6,      (flex_int16_t const   )8,      (flex_int16_t const   )8,      (flex_int16_t const   )8, 
        (flex_int16_t const   )8,      (flex_int16_t const   )8,      (flex_int16_t const   )8,      (flex_int16_t const   )8, 
        (flex_int16_t const   )5,      (flex_int16_t const   )3,      (flex_int16_t const   )8,      (flex_int16_t const   )8, 
        (flex_int16_t const   )4,      (flex_int16_t const   )7,      (flex_int16_t const   )0};
#line 382 "lex.yy.c"
static flex_int32_t const   yy_ec[256]  = 
#line 382
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )3,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )4,      (flex_int32_t const   )5, 
        (flex_int32_t const   )1,      (flex_int32_t const   )6,      (flex_int32_t const   )1,      (flex_int32_t const   )7, 
        (flex_int32_t const   )6,      (flex_int32_t const   )6,      (flex_int32_t const   )6,      (flex_int32_t const   )8, 
        (flex_int32_t const   )6,      (flex_int32_t const   )9,      (flex_int32_t const   )10,      (flex_int32_t const   )11, 
        (flex_int32_t const   )12,      (flex_int32_t const   )12,      (flex_int32_t const   )12,      (flex_int32_t const   )12, 
        (flex_int32_t const   )12,      (flex_int32_t const   )12,      (flex_int32_t const   )12,      (flex_int32_t const   )12, 
        (flex_int32_t const   )12,      (flex_int32_t const   )12,      (flex_int32_t const   )6,      (flex_int32_t const   )6, 
        (flex_int32_t const   )1,      (flex_int32_t const   )6,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )6,      (flex_int32_t const   )13,      (flex_int32_t const   )14,      (flex_int32_t const   )15, 
        (flex_int32_t const   )16,      (flex_int32_t const   )17,      (flex_int32_t const   )18,      (flex_int32_t const   )14, 
        (flex_int32_t const   )13,      (flex_int32_t const   )19,      (flex_int32_t const   )14,      (flex_int32_t const   )13, 
        (flex_int32_t const   )20,      (flex_int32_t const   )21,      (flex_int32_t const   )22,      (flex_int32_t const   )23, 
        (flex_int32_t const   )24,      (flex_int32_t const   )25,      (flex_int32_t const   )26,      (flex_int32_t const   )27, 
        (flex_int32_t const   )14,      (flex_int32_t const   )28,      (flex_int32_t const   )14,      (flex_int32_t const   )14, 
        (flex_int32_t const   )13,      (flex_int32_t const   )29,      (flex_int32_t const   )14,      (flex_int32_t const   )30, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )31, 
        (flex_int32_t const   )1,      (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14, 
        (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14, 
        (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14, 
        (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14, 
        (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14, 
        (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14, 
        (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )32, 
        (flex_int32_t const   )1,      (flex_int32_t const   )33,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 414 "lex.yy.c"
static flex_int32_t const   yy_meta[34]  = 
#line 414
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )2, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4, 
        (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4, 
        (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4, 
        (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4, 
        (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )1,      (flex_int32_t const   )4, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 422 "lex.yy.c"
static flex_int16_t const   yy_base[64]  = 
#line 422
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )83, 
        (flex_int16_t const   )84,      (flex_int16_t const   )80,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )78,      (flex_int16_t const   )84,      (flex_int16_t const   )0,      (flex_int16_t const   )72, 
        (flex_int16_t const   )70,      (flex_int16_t const   )66,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )54,      (flex_int16_t const   )59,      (flex_int16_t const   )52,      (flex_int16_t const   )17, 
        (flex_int16_t const   )84,      (flex_int16_t const   )41,      (flex_int16_t const   )71,      (flex_int16_t const   )69, 
        (flex_int16_t const   )84,      (flex_int16_t const   )64,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )58,      (flex_int16_t const   )0,      (flex_int16_t const   )45,      (flex_int16_t const   )50, 
        (flex_int16_t const   )51,      (flex_int16_t const   )41,      (flex_int16_t const   )37,      (flex_int16_t const   )31, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )0,      (flex_int16_t const   )34, 
        (flex_int16_t const   )43,      (flex_int16_t const   )33,      (flex_int16_t const   )32,      (flex_int16_t const   )37, 
        (flex_int16_t const   )0,      (flex_int16_t const   )36,      (flex_int16_t const   )37,      (flex_int16_t const   )37, 
        (flex_int16_t const   )39,      (flex_int16_t const   )29,      (flex_int16_t const   )22,      (flex_int16_t const   )12, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )10,      (flex_int16_t const   )19, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )84,      (flex_int16_t const   )40, 
        (flex_int16_t const   )44,      (flex_int16_t const   )31,      (flex_int16_t const   )48,      (flex_int16_t const   )50};
#line 433 "lex.yy.c"
static flex_int16_t const   yy_def[64]  = 
#line 433
  {      (flex_int16_t const   )0,      (flex_int16_t const   )58,      (flex_int16_t const   )1,      (flex_int16_t const   )58, 
        (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58, 
        (flex_int16_t const   )59,      (flex_int16_t const   )58,      (flex_int16_t const   )60,      (flex_int16_t const   )58, 
        (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )61,      (flex_int16_t const   )61, 
        (flex_int16_t const   )61,      (flex_int16_t const   )61,      (flex_int16_t const   )61,      (flex_int16_t const   )61, 
        (flex_int16_t const   )58,      (flex_int16_t const   )62,      (flex_int16_t const   )58,      (flex_int16_t const   )59, 
        (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58, 
        (flex_int16_t const   )58,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63, 
        (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )62, 
        (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )63,      (flex_int16_t const   )63, 
        (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63, 
        (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63, 
        (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63, 
        (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63, 
        (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )0,      (flex_int16_t const   )58, 
        (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58};
#line 444 "lex.yy.c"
static flex_int16_t const   yy_nxt[118]  = 
#line 444
  {      (flex_int16_t const   )0,      (flex_int16_t const   )4,      (flex_int16_t const   )5,      (flex_int16_t const   )6, 
        (flex_int16_t const   )7,      (flex_int16_t const   )8,      (flex_int16_t const   )9,      (flex_int16_t const   )10, 
        (flex_int16_t const   )11,      (flex_int16_t const   )12,      (flex_int16_t const   )4,      (flex_int16_t const   )9, 
        (flex_int16_t const   )13,      (flex_int16_t const   )14,      (flex_int16_t const   )15,      (flex_int16_t const   )16, 
        (flex_int16_t const   )17,      (flex_int16_t const   )14,      (flex_int16_t const   )15,      (flex_int16_t const   )15, 
        (flex_int16_t const   )15,      (flex_int16_t const   )18,      (flex_int16_t const   )14,      (flex_int16_t const   )15, 
        (flex_int16_t const   )14,      (flex_int16_t const   )14,      (flex_int16_t const   )19,      (flex_int16_t const   )14, 
        (flex_int16_t const   )15,      (flex_int16_t const   )15,      (flex_int16_t const   )20,      (flex_int16_t const   )4, 
        (flex_int16_t const   )21,      (flex_int16_t const   )9,      (flex_int16_t const   )33,      (flex_int16_t const   )29, 
        (flex_int16_t const   )57,      (flex_int16_t const   )56,      (flex_int16_t const   )55,      (flex_int16_t const   )54, 
        (flex_int16_t const   )34,      (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )23, 
        (flex_int16_t const   )23,      (flex_int16_t const   )25,      (flex_int16_t const   )53,      (flex_int16_t const   )25, 
        (flex_int16_t const   )25,      (flex_int16_t const   )35,      (flex_int16_t const   )35,      (flex_int16_t const   )35, 
        (flex_int16_t const   )35,      (flex_int16_t const   )38,      (flex_int16_t const   )38,      (flex_int16_t const   )52, 
        (flex_int16_t const   )51,      (flex_int16_t const   )50,      (flex_int16_t const   )49,      (flex_int16_t const   )48, 
        (flex_int16_t const   )47,      (flex_int16_t const   )46,      (flex_int16_t const   )45,      (flex_int16_t const   )44, 
        (flex_int16_t const   )36,      (flex_int16_t const   )43,      (flex_int16_t const   )42,      (flex_int16_t const   )41, 
        (flex_int16_t const   )40,      (flex_int16_t const   )39,      (flex_int16_t const   )28,      (flex_int16_t const   )37, 
        (flex_int16_t const   )24,      (flex_int16_t const   )22,      (flex_int16_t const   )36,      (flex_int16_t const   )32, 
        (flex_int16_t const   )31,      (flex_int16_t const   )30,      (flex_int16_t const   )28,      (flex_int16_t const   )27, 
        (flex_int16_t const   )26,      (flex_int16_t const   )24,      (flex_int16_t const   )22,      (flex_int16_t const   )58, 
        (flex_int16_t const   )3,      (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58, 
        (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58, 
        (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58, 
        (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58, 
        (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58, 
        (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58, 
        (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58, 
        (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58, 
        (flex_int16_t const   )58,      (flex_int16_t const   )58};
#line 461 "lex.yy.c"
static flex_int16_t const   yy_chk[118]  = 
#line 461
  {      (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )19,      (flex_int16_t const   )61, 
        (flex_int16_t const   )55,      (flex_int16_t const   )54,      (flex_int16_t const   )51,      (flex_int16_t const   )50, 
        (flex_int16_t const   )19,      (flex_int16_t const   )59,      (flex_int16_t const   )59,      (flex_int16_t const   )59, 
        (flex_int16_t const   )59,      (flex_int16_t const   )60,      (flex_int16_t const   )49,      (flex_int16_t const   )60, 
        (flex_int16_t const   )60,      (flex_int16_t const   )62,      (flex_int16_t const   )62,      (flex_int16_t const   )62, 
        (flex_int16_t const   )62,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )48, 
        (flex_int16_t const   )47,      (flex_int16_t const   )46,      (flex_int16_t const   )45,      (flex_int16_t const   )43, 
        (flex_int16_t const   )42,      (flex_int16_t const   )41,      (flex_int16_t const   )40,      (flex_int16_t const   )39, 
        (flex_int16_t const   )35,      (flex_int16_t const   )34,      (flex_int16_t const   )33,      (flex_int16_t const   )32, 
        (flex_int16_t const   )31,      (flex_int16_t const   )30,      (flex_int16_t const   )28,      (flex_int16_t const   )25, 
        (flex_int16_t const   )23,      (flex_int16_t const   )22,      (flex_int16_t const   )21,      (flex_int16_t const   )18, 
        (flex_int16_t const   )17,      (flex_int16_t const   )16,      (flex_int16_t const   )13,      (flex_int16_t const   )12, 
        (flex_int16_t const   )11,      (flex_int16_t const   )8,      (flex_int16_t const   )5,      (flex_int16_t const   )3, 
        (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58, 
        (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58, 
        (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58, 
        (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58, 
        (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58, 
        (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58, 
        (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58, 
        (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58, 
        (flex_int16_t const   )58,      (flex_int16_t const   )58};
#line 478 "lex.yy.c"
static yy_state_type yy_last_accepting_state  ;
#line 479 "lex.yy.c"
static char *yy_last_accepting_cpos  ;
#line 481
int yy_flex_debug ;
#line 482 "lex.yy.c"
int yy_flex_debug  =    0;
#line 124 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/hdefs.h"
char *stracpy(char const   *str ) ;
#line 23 "msglex.l"
int line_count  =    1;
#line 25 "msglex.l"
static char filenbuf[256]  ;
#line 779 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 534 "lex.yy.c"
static int yy_init_globals(void) ;
#line 539
int yylex_destroy(void) ;
#line 541
int yyget_debug(void) ;
#line 543
void yyset_debug(int bdebug ) ;
#line 549
FILE *yyget_in(void) ;
#line 551
void yyset_in(FILE *in_str ) ;
#line 553
FILE *yyget_out(void) ;
#line 555
void yyset_out(FILE *out_str ) ;
#line 557
int yyget_leng(void) ;
#line 559
char *yyget_text(void) ;
#line 561
int yyget_lineno(void) ;
#line 563
void yyset_lineno(int line_number ) ;
#line 573
extern int yywrap(void) ;
#line 577
static void yyunput(int c , char *yy_bp ) ;
#line 592
static int input(void) ;
#line 694 "lex.yy.c"
int yylex(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  YY_BUFFER_STATE tmp ;
  register YY_CHAR yy_c ;
  int ch ;
  int start_line ;
  unsigned int lng ;
  char inbuf[2048] ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  int ch___0 ;
  int start_line___0 ;
  unsigned int lng___0 ;
  char inbuf___0[2048] ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 705
  if (! yy_init) {
#line 707
    yy_init = 1;
#line 713
    if (! yy_start) {
#line 714
      yy_start = 1;
    }
#line 716
    if (! yyin) {
#line 717
      yyin = stdin;
    }
#line 719
    if (! yyout) {
#line 720
      yyout = stdout;
    }
#line 722
    if (yy_buffer_stack) {
#line 722
      tmp = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 722
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
#line 722
    if (! tmp) {
      {
#line 723
      yyensure_buffer_stack();
#line 724
      *(yy_buffer_stack + yy_buffer_stack_top) = yy_create_buffer(yyin, 16384);
      }
    }
    {
#line 728
    yy_load_buffer_state();
    }
  }
  {
#line 731
  while (1) {
    while_continue: /* CIL Label */ ;
#line 733
    yy_cp = yy_c_buf_p;
#line 736
    *yy_cp = yy_hold_char;
#line 741
    yy_bp = yy_cp;
#line 743
    yy_current_state = yy_start;
    yy_match: 
    {
#line 745
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 747
      yy_c = (YY_CHAR )yy_ec[(unsigned int )((unsigned char )*yy_cp)];
#line 748
      if (yy_accept[yy_current_state]) {
#line 750
        yy_last_accepting_state = yy_current_state;
#line 751
        yy_last_accepting_cpos = yy_cp;
      }
      {
#line 753
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 753
        if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 753
          goto while_break___1;
        }
#line 755
        yy_current_state = (int )yy_def[yy_current_state];
#line 756
        if (yy_current_state >= 59) {
#line 757
          yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 759
      yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 760
      yy_cp ++;
#line 745
      if (! ((int const   )yy_base[yy_current_state] != 84)) {
#line 745
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    yy_find_action: 
#line 765
    yy_act = (int )yy_accept[yy_current_state];
#line 766
    if (yy_act == 0) {
#line 768
      yy_cp = yy_last_accepting_cpos;
#line 769
      yy_current_state = yy_last_accepting_state;
#line 770
      yy_act = (int )yy_accept[yy_current_state];
    }
#line 773
    yytext = yy_bp;
#line 773
    yyleng = (int )((size_t )(yy_cp - yy_bp));
#line 773
    yy_hold_char = *yy_cp;
#line 773
    *yy_cp = (char )'\000';
#line 773
    yy_c_buf_p = yy_cp;
    do_action: 
    {
#line 779
    if (yy_act == 0) {
#line 779
      goto case_0;
    }
#line 786
    if (yy_act == 1) {
#line 786
      goto case_1;
    }
#line 32
    if (yy_act == 2) {
#line 32 "msglex.l"
      goto case_2;
    }
#line 34
    if (yy_act == 3) {
#line 34
      goto case_3;
    }
#line 36
    if (yy_act == 4) {
#line 36
      goto case_4;
    }
#line 37
    if (yy_act == 5) {
#line 37
      goto case_5;
    }
#line 38
    if (yy_act == 6) {
#line 38
      goto case_6;
    }
#line 39
    if (yy_act == 7) {
#line 39
      goto case_7;
    }
#line 40
    if (yy_act == 8) {
#line 40
      goto case_8;
    }
#line 49
    if (yy_act == 9) {
#line 49
      goto case_9;
    }
#line 51
    if (yy_act == 10) {
#line 51
      goto case_10;
    }
#line 53
    if (yy_act == 11) {
#line 53
      goto case_11;
    }
#line 55
    if (yy_act == 12) {
#line 55
      goto case_12;
    }
#line 62
    if (yy_act == 13) {
#line 62
      goto case_13;
    }
#line 64
    if (yy_act == 14) {
#line 64
      goto case_14;
    }
#line 66
    if (yy_act == 15) {
#line 66
      goto case_15;
    }
#line 68
    if (yy_act == 16) {
#line 68
      goto case_16;
    }
#line 70
    if (yy_act == 17) {
#line 70
      goto case_17;
    }
#line 119
    if (yy_act == 18) {
#line 119
      goto case_18;
    }
#line 167
    if (yy_act == 19) {
#line 167
      goto case_19;
    }
#line 172
    if (yy_act == 20) {
#line 172
      goto case_20;
    }
#line 999
    if (yy_act == 22) {
#line 999 "lex.yy.c"
      goto case_22;
    }
#line 1002
    if (yy_act == 21) {
#line 1002
      goto case_21;
    }
#line 1124
    goto switch_default;
    case_0: /* CIL Label */ 
#line 781
    *yy_cp = yy_hold_char;
#line 782
    yy_cp = yy_last_accepting_cpos;
#line 783
    yy_current_state = yy_last_accepting_state;
#line 784
    goto yy_find_action;
    case_1: /* CIL Label */ 
#line 787
    *yy_cp = yy_hold_char;
#line 788
    yy_cp --;
#line 788
    yy_c_buf_p = yy_cp;
#line 789
    yytext = yy_bp;
#line 789
    yyleng = (int )((size_t )(yy_cp - yy_bp));
#line 789
    yy_hold_char = *yy_cp;
#line 789
    *yy_cp = (char )'\000';
#line 789
    yy_c_buf_p = yy_cp;
#line 31 "msglex.l"
    goto switch_break;
    case_2: /* CIL Label */ 
#line 32
    yylval.ch = *(yytext + 0);
#line 32
    return (271);
#line 33
    goto switch_break;
    case_3: /* CIL Label */ 
#line 34
    return (259);
#line 35
    goto switch_break;
    case_4: /* CIL Label */ 
#line 35
    return (260);
#line 36
    goto switch_break;
    case_5: /* CIL Label */ 
#line 36
    return (263);
#line 37
    goto switch_break;
    case_6: /* CIL Label */ 
#line 37
    return (264);
#line 38
    goto switch_break;
    case_7: /* CIL Label */ 
#line 38
    return (265);
#line 39
    goto switch_break;
    case_8: /* CIL Label */ 
#line 41
    if ((unsigned long )yyleng >= sizeof(filenbuf) - 1UL) {
      {
#line 42
      strncpy((char */* __restrict  */)(filenbuf), (char const   */* __restrict  */)yytext,
              sizeof(filenbuf) - 1UL);
      }
    } else {
      {
#line 44
      strcpy((char */* __restrict  */)(filenbuf), (char const   */* __restrict  */)yytext);
      }
    }
    {
#line 45
    yylval.str = stracpy((char const   *)(filenbuf));
    }
#line 46
    return (266);
#line 48
    goto switch_break;
    case_9: /* CIL Label */ 
#line 49
    return (261);
#line 50
    goto switch_break;
    case_10: /* CIL Label */ 
#line 51
    return (262);
#line 52
    goto switch_break;
    case_11: /* CIL Label */ 
#line 53
    yylval.ch = *(yytext + 0);
#line 53
    return ((int )*(yytext + 0));
#line 54
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 56
    *(yytext + (yyleng - 1)) = (char )'\000';
#line 57
    yylval.vname = lookupname((char const   *)(yytext + 1));
#line 58
    *(yytext + (yyleng - 1)) = (char )'}';
    }
#line 59
    return (269);
#line 61
    goto switch_break;
    case_13: /* CIL Label */ 
#line 62
    yylval.ch = *(yytext + 1);
#line 62
    return (272);
#line 63
    goto switch_break;
    case_14: /* CIL Label */ 
    {
#line 64
    yylval.num = atoi((char const   *)yytext);
    }
#line 64
    return (270);
#line 65
    goto switch_break;
    case_15: /* CIL Label */ 
#line 67
    goto switch_break;
    case_16: /* CIL Label */ 
#line 68
    line_count ++;
#line 69
    goto switch_break;
    case_17: /* CIL Label */ 
#line 72
    start_line = line_count;
#line 73
    lng = 0U;
    {
#line 76
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 77
      ch = input();
      }
#line 78
      if (ch == -1) {
#line 79
        return (0);
      }
#line 80
      if (ch == 10) {
#line 81
        line_count ++;
      } else
#line 82
      if (ch == 92) {
        {
#line 83
        ch = input();
        }
#line 84
        if (ch == -1) {
#line 85
          return (0);
        }
#line 86
        if (ch == 10) {
#line 87
          line_count ++;
#line 88
          goto __Cont;
        }
#line 90
        if (ch != 34) {
#line 91
          tmp___0 = lng;
#line 91
          lng ++;
#line 91
          inbuf[tmp___0] = (char )'\\';
        }
      } else
#line 93
      if (ch == 34) {
        {
#line 94
        ch = input();
        }
#line 95
        if (ch != 34) {
#line 96
          goto while_break___2;
        }
      }
#line 98
      tmp___1 = lng;
#line 98
      lng ++;
#line 98
      inbuf[tmp___1] = (char )ch;
#line 99
      if ((unsigned long )lng >= sizeof(inbuf) - 2UL) {
        {
#line 100
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"String overflow/unterminated on line %d started line %d\n",
                line_count, start_line);
#line 102
        errors ++;
        }
        {
#line 103
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 103
          if (ch != 34) {
#line 103
            if (! (ch != -1)) {
#line 103
              goto while_break___3;
            }
          } else {
#line 103
            goto while_break___3;
          }
          {
#line 104
          ch = input();
          }
#line 105
          if (ch == 10) {
#line 106
            line_count ++;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 108
        if (ch == -1) {
#line 109
          return (0);
        }
#line 110
        goto while_break___2;
      }
      __Cont: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 113
    yyunput(ch, yytext);
#line 114
    inbuf[lng] = (char )'\000';
#line 115
    yylval.str = stracpy((char const   *)(inbuf));
    }
#line 116
    return (267);
#line 118
    goto switch_break;
    case_18: /* CIL Label */ 
#line 121
    start_line___0 = line_count;
#line 122
    lng___0 = 0U;
    {
#line 125
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 126
      ch___0 = input();
      }
#line 127
      if (ch___0 == -1) {
#line 128
        return (0);
      }
#line 129
      if (ch___0 == 10) {
#line 130
        line_count ++;
      } else
#line 131
      if (ch___0 == 92) {
        {
#line 132
        ch___0 = input();
        }
#line 133
        if (ch___0 == -1) {
#line 134
          return (0);
        }
#line 135
        if (ch___0 == 10) {
#line 136
          line_count ++;
#line 137
          goto __Cont___0;
        }
#line 139
        if (ch___0 != 93) {
#line 140
          tmp___2 = lng___0;
#line 140
          lng___0 ++;
#line 140
          inbuf___0[tmp___2] = (char )'\\';
        }
      } else
#line 142
      if (ch___0 == 93) {
        {
#line 143
        ch___0 = input();
        }
#line 144
        goto while_break___4;
      }
#line 146
      tmp___3 = lng___0;
#line 146
      lng___0 ++;
#line 146
      inbuf___0[tmp___3] = (char )ch___0;
#line 147
      if ((unsigned long )lng___0 >= sizeof(inbuf___0) - 2UL) {
        {
#line 148
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Comment overflow/unterminated on line %d started line %d\n",
                line_count, start_line___0);
#line 150
        errors ++;
        }
        {
#line 151
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 151
          if (ch___0 != 93) {
#line 151
            if (! (ch___0 != -1)) {
#line 151
              goto while_break___5;
            }
          } else {
#line 151
            goto while_break___5;
          }
          {
#line 152
          ch___0 = input();
          }
#line 153
          if (ch___0 == 10) {
#line 154
            line_count ++;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
#line 156
        if (ch___0 == -1) {
#line 157
          return (0);
        }
#line 158
        goto while_break___4;
      }
      __Cont___0: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 161
    yyunput(ch___0, yytext);
#line 162
    inbuf___0[lng___0] = (char )'\000';
#line 163
    yylval.str = stracpy((char const   *)(inbuf___0));
    }
#line 164
    return (268);
#line 166
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 168
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Had a \'%c\' on line %d\n",
            (int )*(yytext + 0), line_count);
#line 169
    errors ++;
    }
#line 171
    goto switch_break;
    case_20: /* CIL Label */ 
    {
#line 171
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 171
      fwrite((void const   */* __restrict  */)yytext, (size_t )yyleng, (size_t )1,
             (FILE */* __restrict  */)yyout);
      }
#line 171
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 172
    goto switch_break;
    case_22: /* CIL Label */ 
#line 1000 "lex.yy.c"
    return (0);
    case_21: /* CIL Label */ 
#line 1005
    yy_amount_of_matched_text = (int )(yy_cp - yytext) - 1;
#line 1008
    *yy_cp = yy_hold_char;
#line 1011
    if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status == 0) {
#line 1022
      yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars;
#line 1023
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_input_file = yyin;
#line 1024
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status = 1;
    }
#line 1034
    if ((unsigned long )yy_c_buf_p <= (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars)) {
      {
#line 1038
      yy_c_buf_p = yytext + yy_amount_of_matched_text;
#line 1040
      yy_current_state = yy_get_previous_state();
#line 1051
      yy_next_state = yy_try_NUL_trans(yy_current_state);
#line 1053
      yy_bp = yytext + 0;
      }
#line 1055
      if (yy_next_state) {
#line 1058
        yy_c_buf_p ++;
#line 1058
        yy_cp = yy_c_buf_p;
#line 1059
        yy_current_state = yy_next_state;
#line 1060
        goto yy_match;
      } else {
#line 1065
        yy_cp = yy_c_buf_p;
#line 1066
        goto yy_find_action;
      }
    } else {
      {
#line 1070
      tmp___4 = yy_get_next_buffer();
      }
      {
#line 1072
      if (tmp___4 == 1) {
#line 1072
        goto case_1___0;
      }
#line 1101
      if (tmp___4 == 0) {
#line 1101
        goto case_0___0;
      }
#line 1111
      if (tmp___4 == 2) {
#line 1111
        goto case_2___0;
      }
#line 1070
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
      {
#line 1074
      yy_did_buffer_switch_on_eof = 0;
#line 1076
      tmp___5 = yywrap();
      }
#line 1076
      if (tmp___5) {
#line 1087
        yy_c_buf_p = yytext + 0;
#line 1089
        yy_act = (21 + (yy_start - 1) / 2) + 1;
#line 1090
        goto do_action;
      } else
#line 1095
      if (! yy_did_buffer_switch_on_eof) {
        {
#line 1096
        yyrestart(yyin);
        }
      }
#line 1098
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
      {
#line 1102
      yy_c_buf_p = yytext + yy_amount_of_matched_text;
#line 1105
      yy_current_state = yy_get_previous_state();
#line 1107
      yy_cp = yy_c_buf_p;
#line 1108
      yy_bp = yytext + 0;
      }
#line 1109
      goto yy_match;
      case_2___0: /* CIL Label */ 
      {
#line 1112
      yy_c_buf_p = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars;
#line 1115
      yy_current_state = yy_get_previous_state();
#line 1117
      yy_cp = yy_c_buf_p;
#line 1118
      yy_bp = yytext + 0;
      }
#line 1119
      goto yy_find_action;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1121
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1125
    yy_fatal_error("fatal flex scanner internal error--no action found");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1138 "lex.yy.c"
static int yy_get_next_buffer(void) 
{ 
  register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int num_to_read ;
  YY_BUFFER_STATE b ;
  YY_BUFFER_STATE tmp___1 ;
  int yy_c_buf_p_offset ;
  int new_size ;
  void *tmp___2 ;
  int c ;
  size_t n ;
  size_t tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  yy_size_t new_size___0 ;
  void *tmp___10 ;

  {
#line 1140
  dest = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf;
#line 1141
  source = yytext;
#line 1145
  if ((unsigned long )yy_c_buf_p > (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + (yy_n_chars + 1))) {
    {
#line 1146
    yy_fatal_error("fatal flex scanner internal error--end of buffer missed");
    }
  }
#line 1149
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_fill_buffer == 0) {
#line 1151
    if (yy_c_buf_p - yytext == 1L) {
#line 1156
      return (1);
    } else {
#line 1164
      return (2);
    }
  }
#line 1171
  number_to_move = (int )(yy_c_buf_p - yytext) - 1;
#line 1173
  i = 0;
  {
#line 1173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1173
    if (! (i < number_to_move)) {
#line 1173
      goto while_break;
    }
#line 1174
    tmp = dest;
#line 1174
    dest ++;
#line 1174
    tmp___0 = source;
#line 1174
    source ++;
#line 1174
    *tmp = *tmp___0;
#line 1173
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1176
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status == 2) {
#line 1180
    yy_n_chars = 0;
#line 1180
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  } else {
#line 1184
    num_to_read = (int )(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1UL);
    {
#line 1187
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1187
      if (! (num_to_read <= 0)) {
#line 1187
        goto while_break___0;
      }
#line 1191
      if (yy_buffer_stack) {
#line 1191
        tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
      } else {
#line 1191
        tmp___1 = (YY_BUFFER_STATE )((void *)0);
      }
#line 1191
      b = tmp___1;
#line 1193
      yy_c_buf_p_offset = (int )(yy_c_buf_p - b->yy_ch_buf);
#line 1196
      if (b->yy_is_our_buffer) {
#line 1198
        new_size = (int )(b->yy_buf_size * 2UL);
#line 1200
        if (new_size <= 0) {
#line 1201
          b->yy_buf_size += b->yy_buf_size / 8UL;
        } else {
#line 1203
          b->yy_buf_size *= 2UL;
        }
        {
#line 1205
        tmp___2 = yyrealloc((void *)b->yy_ch_buf, b->yy_buf_size + 2UL);
#line 1205
        b->yy_ch_buf = (char *)tmp___2;
        }
      } else {
#line 1211
        b->yy_ch_buf = (char *)0;
      }
#line 1213
      if (! b->yy_ch_buf) {
        {
#line 1214
        yy_fatal_error("fatal error - scanner input buffer overflow");
        }
      }
#line 1217
      yy_c_buf_p = b->yy_ch_buf + yy_c_buf_p_offset;
#line 1219
      num_to_read = (int )(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1UL);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1224
    if (num_to_read > 8192) {
#line 1225
      num_to_read = 8192;
    }
#line 1228
    if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_is_interactive) {
#line 1228
      c = '*';
#line 1228
      n = (size_t )0;
      {
#line 1228
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1228
        if (n < (size_t )num_to_read) {
          {
#line 1228
          c = _IO_getc(yyin);
          }
#line 1228
          if (c != -1) {
#line 1228
            if (! (c != 10)) {
#line 1228
              goto while_break___1;
            }
          } else {
#line 1228
            goto while_break___1;
          }
        } else {
#line 1228
          goto while_break___1;
        }
#line 1228
        *(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move) + n) = (char )c;
#line 1228
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1228
      if (c == 10) {
#line 1228
        tmp___3 = n;
#line 1228
        n ++;
#line 1228
        *(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move) + tmp___3) = (char )c;
      }
#line 1228
      if (c == -1) {
        {
#line 1228
        tmp___4 = ferror(yyin);
        }
#line 1228
        if (tmp___4) {
          {
#line 1228
          yy_fatal_error("input in flex scanner failed");
          }
        }
      }
#line 1228
      yy_n_chars = (int )n;
    } else {
      {
#line 1228
      tmp___5 = __errno_location();
#line 1228
      *tmp___5 = 0;
      }
      {
#line 1228
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1228
        tmp___8 = fread((void */* __restrict  */)((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move),
                        (size_t )1, (size_t )num_to_read, (FILE */* __restrict  */)yyin);
#line 1228
        yy_n_chars = (int )tmp___8;
        }
#line 1228
        if (yy_n_chars == 0) {
          {
#line 1228
          tmp___9 = ferror(yyin);
          }
#line 1228
          if (! tmp___9) {
#line 1228
            goto while_break___2;
          }
        } else {
#line 1228
          goto while_break___2;
        }
        {
#line 1228
        tmp___6 = __errno_location();
        }
#line 1228
        if (*tmp___6 != 4) {
          {
#line 1228
          yy_fatal_error("input in flex scanner failed");
          }
#line 1228
          goto while_break___2;
        }
        {
#line 1228
        tmp___7 = __errno_location();
#line 1228
        *tmp___7 = 0;
#line 1228
        clearerr(yyin);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1231
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
#line 1234
  if (yy_n_chars == 0) {
#line 1236
    if (number_to_move == 0) {
      {
#line 1238
      ret_val = 1;
#line 1239
      yyrestart(yyin);
      }
    } else {
#line 1244
      ret_val = 2;
#line 1245
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status = 2;
    }
  } else {
#line 1251
    ret_val = 0;
  }
#line 1253
  if ((yy_size_t )(yy_n_chars + number_to_move) > (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size) {
    {
#line 1255
    new_size___0 = (yy_size_t )((yy_n_chars + number_to_move) + (yy_n_chars >> 1));
#line 1256
    tmp___10 = yyrealloc((void *)(*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf,
                         new_size___0);
#line 1256
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf = (char *)tmp___10;
    }
#line 1257
    if (! (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf) {
      {
#line 1258
      yy_fatal_error("out of dynamic memory in yy_get_next_buffer()");
      }
    }
  }
#line 1261
  yy_n_chars += number_to_move;
#line 1262
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars) = (char)0;
#line 1263
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + (yy_n_chars + 1)) = (char)0;
#line 1265
  yytext = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + 0;
#line 1267
  return (ret_val);
}
}
#line 1272 "lex.yy.c"
static yy_state_type yy_get_previous_state(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  flex_int32_t tmp ;

  {
#line 1277
  yy_current_state = yy_start;
#line 1279
  yy_cp = yytext + 0;
  {
#line 1279
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1279
    if (! ((unsigned long )yy_cp < (unsigned long )yy_c_buf_p)) {
#line 1279
      goto while_break;
    }
#line 1281
    if (*yy_cp) {
#line 1281
      tmp = yy_ec[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 1281
      tmp = (flex_int32_t const   )1;
    }
#line 1281
    yy_c = (YY_CHAR )tmp;
#line 1282
    if (yy_accept[yy_current_state]) {
#line 1284
      yy_last_accepting_state = yy_current_state;
#line 1285
      yy_last_accepting_cpos = yy_cp;
    }
    {
#line 1287
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1287
      if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1287
        goto while_break___0;
      }
#line 1289
      yy_current_state = (int )yy_def[yy_current_state];
#line 1290
      if (yy_current_state >= 59) {
#line 1291
        yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1293
    yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1279
    yy_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1296
  return (yy_current_state);
}
}
#line 1304 "lex.yy.c"
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) 
{ 
  register int yy_is_jam ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  int tmp ;

  {
#line 1307
  yy_cp = yy_c_buf_p;
#line 1309
  yy_c = (YY_CHAR )1;
#line 1310
  if (yy_accept[yy_current_state]) {
#line 1312
    yy_last_accepting_state = yy_current_state;
#line 1313
    yy_last_accepting_cpos = yy_cp;
  }
  {
#line 1315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1315
    if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1315
      goto while_break;
    }
#line 1317
    yy_current_state = (int )yy_def[yy_current_state];
#line 1318
    if (yy_current_state >= 59) {
#line 1319
      yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1321
  yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1322
  yy_is_jam = yy_current_state == 58;
#line 1324
  if (yy_is_jam) {
#line 1324
    tmp = 0;
  } else {
#line 1324
    tmp = yy_current_state;
  }
#line 1324
  return (tmp);
}
}
#line 1327 "lex.yy.c"
static void yyunput(int c , char *yy_bp ) 
{ 
  register char *yy_cp ;
  register int number_to_move ;
  register char *dest ;
  register char *source ;

  {
#line 1331
  yy_cp = yy_c_buf_p;
#line 1334
  *yy_cp = yy_hold_char;
#line 1336
  if ((unsigned long )yy_cp < (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + 2)) {
#line 1339
    number_to_move = yy_n_chars + 2;
#line 1340
    dest = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size + 2UL);
#line 1342
    source = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move;
    {
#line 1345
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1345
      if (! ((unsigned long )source > (unsigned long )(*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf)) {
#line 1345
        goto while_break;
      }
#line 1346
      dest --;
#line 1346
      source --;
#line 1346
      *dest = *source;
    }
    while_break: /* CIL Label */ ;
    }
#line 1348
    yy_cp += (int )(dest - source);
#line 1349
    yy_bp += (int )(dest - source);
#line 1350
    yy_n_chars = (int )(*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size;
#line 1350
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
#line 1353
    if ((unsigned long )yy_cp < (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + 2)) {
      {
#line 1354
      yy_fatal_error("flex scanner push-back overflow");
      }
    }
  }
#line 1357
  yy_cp --;
#line 1357
  *yy_cp = (char )c;
#line 1359
  yytext = yy_bp;
#line 1360
  yy_hold_char = *yy_cp;
#line 1361
  yy_c_buf_p = yy_cp;
#line 1362
  return;
}
}
#line 1368 "lex.yy.c"
static int input(void) 
{ 
  int c ;
  int offset ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1374
  *yy_c_buf_p = yy_hold_char;
#line 1376
  if ((int )*yy_c_buf_p == 0) {
#line 1382
    if ((unsigned long )yy_c_buf_p < (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars)) {
#line 1384
      *yy_c_buf_p = (char )'\000';
    } else {
      {
#line 1388
      offset = (int )(yy_c_buf_p - yytext);
#line 1389
      yy_c_buf_p ++;
#line 1391
      tmp = yy_get_next_buffer();
      }
      {
#line 1393
      if (tmp == 2) {
#line 1393
        goto case_2;
      }
#line 1409
      if (tmp == 1) {
#line 1409
        goto case_1;
      }
#line 1423
      if (tmp == 0) {
#line 1423
        goto case_0;
      }
#line 1391
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 1405
      yyrestart(yyin);
      }
      case_1: /* CIL Label */ 
      {
#line 1411
      tmp___0 = yywrap();
      }
#line 1411
      if (tmp___0) {
#line 1412
        return (-1);
      }
#line 1414
      if (! yy_did_buffer_switch_on_eof) {
        {
#line 1415
        yyrestart(yyin);
        }
      }
      {
#line 1419
      tmp___1 = input();
      }
#line 1419
      return (tmp___1);
      case_0: /* CIL Label */ 
#line 1424
      yy_c_buf_p = yytext + offset;
#line 1425
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 1430
  c = (int )*((unsigned char *)yy_c_buf_p);
#line 1431
  *yy_c_buf_p = (char )'\000';
#line 1432
  yy_c_buf_p ++;
#line 1432
  yy_hold_char = *yy_c_buf_p;
#line 1434
  return (c);
}
}
#line 1443 "lex.yy.c"
void yyrestart(FILE *input_file ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1446
  if (yy_buffer_stack) {
#line 1446
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1446
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1446
  if (! tmp) {
    {
#line 1447
    yyensure_buffer_stack();
#line 1448
    *(yy_buffer_stack + yy_buffer_stack_top) = yy_create_buffer(yyin, 16384);
    }
  }
#line 1452
  if (yy_buffer_stack) {
#line 1452
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1452
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1452
  yy_init_buffer(tmp___0, input_file);
#line 1453
  yy_load_buffer_state();
  }
#line 1454
  return;
}
}
#line 1460 "lex.yy.c"
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1468
  yyensure_buffer_stack();
  }
#line 1469
  if (yy_buffer_stack) {
#line 1469
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1469
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1469
  if ((unsigned long )tmp == (unsigned long )new_buffer) {
#line 1470
    return;
  }
#line 1472
  if (yy_buffer_stack) {
#line 1472
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1472
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1472
  if (tmp___0) {
#line 1475
    *yy_c_buf_p = yy_hold_char;
#line 1476
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos = yy_c_buf_p;
#line 1477
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
  {
#line 1480
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
#line 1481
  yy_load_buffer_state();
#line 1488
  yy_did_buffer_switch_on_eof = 1;
  }
#line 1489
  return;
}
}
#line 1491 "lex.yy.c"
static void yy_load_buffer_state(void) 
{ 


  {
#line 1493
  yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars;
#line 1494
  yy_c_buf_p = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos;
#line 1494
  yytext = yy_c_buf_p;
#line 1495
  yyin = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_input_file;
#line 1496
  yy_hold_char = *yy_c_buf_p;
#line 1497
  return;
}
}
#line 1505 "lex.yy.c"
YY_BUFFER_STATE yy_create_buffer(FILE *file , int size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 1509
  tmp = yyalloc(sizeof(struct yy_buffer_state ));
#line 1509
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1510
  if (! b) {
    {
#line 1511
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");
    }
  }
  {
#line 1513
  b->yy_buf_size = (yy_size_t )size;
#line 1518
  tmp___0 = yyalloc(b->yy_buf_size + 2UL);
#line 1518
  b->yy_ch_buf = (char *)tmp___0;
  }
#line 1519
  if (! b->yy_ch_buf) {
    {
#line 1520
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");
    }
  }
  {
#line 1522
  b->yy_is_our_buffer = 1;
#line 1524
  yy_init_buffer(b, file);
  }
#line 1526
  return (b);
}
}
#line 1533 "lex.yy.c"
void yy_delete_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 1536
  if (! b) {
#line 1537
    return;
  }
#line 1539
  if (yy_buffer_stack) {
#line 1539
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1539
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1539
  if ((unsigned long )b == (unsigned long )tmp) {
#line 1540
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )0;
  }
#line 1542
  if (b->yy_is_our_buffer) {
    {
#line 1543
    yyfree((void *)b->yy_ch_buf);
    }
  }
  {
#line 1545
  yyfree((void *)b);
  }
#line 1546
  return;
}
}
#line 1556 "lex.yy.c"
static void yy_init_buffer(YY_BUFFER_STATE b , FILE *file ) 
{ 
  int oerrno ;
  int *tmp ;
  YY_BUFFER_STATE tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 1559
  tmp = __errno_location();
#line 1559
  oerrno = *tmp;
#line 1561
  yy_flush_buffer(b);
#line 1563
  b->yy_input_file = file;
#line 1564
  b->yy_fill_buffer = 1;
  }
#line 1570
  if (yy_buffer_stack) {
#line 1570
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1570
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1570
  if ((unsigned long )b != (unsigned long )tmp___0) {
#line 1571
    b->yy_bs_lineno = 1;
#line 1572
    b->yy_bs_column = 0;
  }
#line 1575
  if (file) {
    {
#line 1575
    tmp___1 = fileno(file);
#line 1575
    tmp___2 = isatty(tmp___1);
#line 1575
    b->yy_is_interactive = tmp___2 > 0;
    }
  } else {
#line 1575
    b->yy_is_interactive = 0;
  }
  {
#line 1577
  tmp___3 = __errno_location();
#line 1577
  *tmp___3 = oerrno;
  }
#line 1578
  return;
}
}
#line 1584 "lex.yy.c"
void yy_flush_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 1586
  if (! b) {
#line 1587
    return;
  }
#line 1589
  b->yy_n_chars = 0;
#line 1595
  *(b->yy_ch_buf + 0) = (char)0;
#line 1596
  *(b->yy_ch_buf + 1) = (char)0;
#line 1598
  b->yy_buf_pos = b->yy_ch_buf + 0;
#line 1600
  b->yy_at_bol = 1;
#line 1601
  b->yy_buffer_status = 0;
#line 1603
  if (yy_buffer_stack) {
#line 1603
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1603
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1603
  if ((unsigned long )b == (unsigned long )tmp) {
    {
#line 1604
    yy_load_buffer_state();
    }
  }
#line 1605
  return;
}
}
#line 1613 "lex.yy.c"
void yypush_buffer_state(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1615
  if ((unsigned long )new_buffer == (unsigned long )((void *)0)) {
#line 1616
    return;
  }
  {
#line 1618
  yyensure_buffer_stack();
  }
#line 1621
  if (yy_buffer_stack) {
#line 1621
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1621
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1621
  if (tmp) {
#line 1624
    *yy_c_buf_p = yy_hold_char;
#line 1625
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos = yy_c_buf_p;
#line 1626
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
#line 1630
  if (yy_buffer_stack) {
#line 1630
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1630
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1630
  if (tmp___0) {
#line 1631
    yy_buffer_stack_top ++;
  }
  {
#line 1632
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
#line 1635
  yy_load_buffer_state();
#line 1636
  yy_did_buffer_switch_on_eof = 1;
  }
#line 1637
  return;
}
}
#line 1643 "lex.yy.c"
void yypop_buffer_state(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
#line 1645
  if (yy_buffer_stack) {
#line 1645
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1645
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1645
  if (! tmp) {
#line 1646
    return;
  }
#line 1648
  if (yy_buffer_stack) {
#line 1648
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1648
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1648
  yy_delete_buffer(tmp___0);
#line 1649
  *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
  }
#line 1650
  if (yy_buffer_stack_top > 0UL) {
#line 1651
    yy_buffer_stack_top --;
  }
#line 1653
  if (yy_buffer_stack) {
#line 1653
    tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1653
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1653
  if (tmp___1) {
    {
#line 1654
    yy_load_buffer_state();
#line 1655
    yy_did_buffer_switch_on_eof = 1;
    }
  }
#line 1657
  return;
}
}
#line 1662 "lex.yy.c"
static void yyensure_buffer_stack(void) 
{ 
  int num_to_alloc ;
  void *tmp ;
  int grow_size ;
  void *tmp___0 ;

  {
#line 1666
  if (! yy_buffer_stack) {
    {
#line 1672
    num_to_alloc = 1;
#line 1673
    tmp = yyalloc((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 1673
    yy_buffer_stack = (struct yy_buffer_state **)tmp;
    }
#line 1676
    if (! yy_buffer_stack) {
      {
#line 1677
      yy_fatal_error("out of dynamic memory in yyensure_buffer_stack()");
      }
    }
    {
#line 1679
    memset((void *)yy_buffer_stack, 0, (unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 1681
    yy_buffer_stack_max = (size_t )num_to_alloc;
#line 1682
    yy_buffer_stack_top = (size_t )0;
    }
#line 1683
    return;
  }
#line 1686
  if (yy_buffer_stack_top >= yy_buffer_stack_max - 1UL) {
    {
#line 1689
    grow_size = 8;
#line 1691
    num_to_alloc = (int )(yy_buffer_stack_max + (size_t )grow_size);
#line 1692
    tmp___0 = yyrealloc((void *)yy_buffer_stack, (unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 1692
    yy_buffer_stack = (struct yy_buffer_state **)tmp___0;
    }
#line 1696
    if (! yy_buffer_stack) {
      {
#line 1697
      yy_fatal_error("out of dynamic memory in yyensure_buffer_stack()");
      }
    }
    {
#line 1700
    memset((void *)(yy_buffer_stack + yy_buffer_stack_max), 0, (unsigned long )grow_size * sizeof(struct yy_buffer_state *));
#line 1701
    yy_buffer_stack_max = (size_t )num_to_alloc;
    }
  }
#line 1703
  return;
}
}
#line 1711 "lex.yy.c"
YY_BUFFER_STATE yy_scan_buffer(char *base , yy_size_t size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 1715
  if (size < 2UL) {
#line 1719
    return ((YY_BUFFER_STATE )0);
  } else
#line 1715
  if ((int )*(base + (size - 2UL)) != 0) {
#line 1719
    return ((YY_BUFFER_STATE )0);
  } else
#line 1715
  if ((int )*(base + (size - 1UL)) != 0) {
#line 1719
    return ((YY_BUFFER_STATE )0);
  }
  {
#line 1721
  tmp = yyalloc(sizeof(struct yy_buffer_state ));
#line 1721
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1722
  if (! b) {
    {
#line 1723
    yy_fatal_error("out of dynamic memory in yy_scan_buffer()");
    }
  }
  {
#line 1725
  b->yy_buf_size = size - 2UL;
#line 1726
  tmp___0 = base;
#line 1726
  b->yy_ch_buf = tmp___0;
#line 1726
  b->yy_buf_pos = tmp___0;
#line 1727
  b->yy_is_our_buffer = 0;
#line 1728
  b->yy_input_file = (FILE *)0;
#line 1729
  b->yy_n_chars = (int )b->yy_buf_size;
#line 1730
  b->yy_is_interactive = 0;
#line 1731
  b->yy_at_bol = 1;
#line 1732
  b->yy_fill_buffer = 0;
#line 1733
  b->yy_buffer_status = 0;
#line 1735
  yy_switch_to_buffer(b);
  }
#line 1737
  return (b);
}
}
#line 1748 "lex.yy.c"
YY_BUFFER_STATE yy_scan_string(char const   *yystr ) 
{ 
  size_t tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1751
  tmp = strlen(yystr);
#line 1751
  tmp___0 = yy_scan_bytes(yystr, (int )tmp);
  }
#line 1751
  return (tmp___0);
}
}
#line 1761 "lex.yy.c"
YY_BUFFER_STATE yy_scan_bytes(char const   *yybytes , int _yybytes_len ) 
{ 
  YY_BUFFER_STATE b ;
  char *buf ;
  yy_size_t n ;
  int i ;
  void *tmp ;
  char tmp___0 ;

  {
  {
#line 1769
  n = (yy_size_t )(_yybytes_len + 2);
#line 1770
  tmp = yyalloc(n);
#line 1770
  buf = (char *)tmp;
  }
#line 1771
  if (! buf) {
    {
#line 1772
    yy_fatal_error("out of dynamic memory in yy_scan_bytes()");
    }
  }
#line 1774
  i = 0;
  {
#line 1774
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1774
    if (! (i < _yybytes_len)) {
#line 1774
      goto while_break;
    }
#line 1775
    *(buf + i) = (char )*(yybytes + i);
#line 1774
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1777
  tmp___0 = (char)0;
#line 1777
  *(buf + (_yybytes_len + 1)) = tmp___0;
#line 1777
  *(buf + _yybytes_len) = tmp___0;
#line 1779
  b = yy_scan_buffer(buf, n);
  }
#line 1780
  if (! b) {
    {
#line 1781
    yy_fatal_error("bad buffer in yy_scan_bytes()");
    }
  }
#line 1786
  b->yy_is_our_buffer = 1;
#line 1788
  return (b);
}
}
#line 1795 "lex.yy.c"
static void yy_fatal_error(char const   *msg ) 
{ 


  {
  {
#line 1797
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
#line 1798
  exit(2);
  }
}
}
#line 1823 "lex.yy.c"
int yyget_lineno(void) 
{ 


  {
#line 1826
  return (yylineno);
}
}
#line 1832 "lex.yy.c"
FILE *yyget_in(void) 
{ 


  {
#line 1834
  return (yyin);
}
}
#line 1840 "lex.yy.c"
FILE *yyget_out(void) 
{ 


  {
#line 1842
  return (yyout);
}
}
#line 1848 "lex.yy.c"
int yyget_leng(void) 
{ 


  {
#line 1850
  return (yyleng);
}
}
#line 1857 "lex.yy.c"
char *yyget_text(void) 
{ 


  {
#line 1859
  return (yytext);
}
}
#line 1866 "lex.yy.c"
void yyset_lineno(int line_number ) 
{ 


  {
#line 1869
  yylineno = line_number;
#line 1870
  return;
}
}
#line 1878 "lex.yy.c"
void yyset_in(FILE *in_str ) 
{ 


  {
#line 1880
  yyin = in_str;
#line 1881
  return;
}
}
#line 1883 "lex.yy.c"
void yyset_out(FILE *out_str ) 
{ 


  {
#line 1885
  yyout = out_str;
#line 1886
  return;
}
}
#line 1888 "lex.yy.c"
int yyget_debug(void) 
{ 


  {
#line 1890
  return (yy_flex_debug);
}
}
#line 1893 "lex.yy.c"
void yyset_debug(int bdebug ) 
{ 


  {
#line 1895
  yy_flex_debug = bdebug;
#line 1896
  return;
}
}
#line 1898 "lex.yy.c"
static int yy_init_globals(void) 
{ 


  {
#line 1904
  yy_buffer_stack = (YY_BUFFER_STATE *)0;
#line 1905
  yy_buffer_stack_top = (size_t )0;
#line 1906
  yy_buffer_stack_max = (size_t )0;
#line 1907
  yy_c_buf_p = (char *)0;
#line 1908
  yy_init = 0;
#line 1909
  yy_start = 0;
#line 1916
  yyin = (FILE *)0;
#line 1917
  yyout = (FILE *)0;
#line 1923
  return (0);
}
}
#line 1927 "lex.yy.c"
int yylex_destroy(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1931
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1931
    if (yy_buffer_stack) {
#line 1931
      tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 1931
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
#line 1931
    if (! tmp___0) {
#line 1931
      goto while_break;
    }
#line 1932
    if (yy_buffer_stack) {
#line 1932
      tmp = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 1932
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
    {
#line 1932
    yy_delete_buffer(tmp);
#line 1933
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
#line 1934
    yypop_buffer_state();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1938
  yyfree((void *)yy_buffer_stack);
#line 1939
  yy_buffer_stack = (YY_BUFFER_STATE *)((void *)0);
#line 1943
  yy_init_globals();
  }
#line 1945
  return (0);
}
}
#line 1972 "lex.yy.c"
void *yyalloc(yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 1974
  tmp = malloc(size);
  }
#line 1974
  return (tmp);
}
}
#line 1977 "lex.yy.c"
void *yyrealloc(void *ptr , yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 1986
  tmp = realloc((void *)((char *)ptr), size);
  }
#line 1986
  return (tmp);
}
}
#line 1989 "lex.yy.c"
void yyfree(void *ptr ) 
{ 


  {
  {
#line 1991
  free((void *)((char *)ptr));
  }
#line 1992
  return;
}
}
#line 174 "msglex.l"
void resetlex(void) 
{ 


  {
  {
#line 176
  yyrestart(yyin);
  }
#line 177
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/hdefs.h"
struct valexpr *make_sum(struct valname *vn , char const   op , int const   n ) ;
#line 135
struct module_list *alloc_modlist(void) ;
#line 139
struct helpfile *find_help(char *name , char *subdir ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/alloc.c"
struct helpfile helpfiles[10]  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/alloc.c"
struct program programs[60]  ;
#line 31 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/alloc.c"
struct macro *macrohashtab[59]  ;
#line 32 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/alloc.c"
struct module *modhashtab[59]  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/alloc.c"
struct valname *valhash[521]  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/alloc.c"
void nomem(void) 
{ 


  {
  {
#line 37
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Ran out of memory\n");
#line 38
  exit(255);
  }
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/alloc.c"
char *stracpy(char const   *str ) 
{ 
  char *result ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 44
  tmp = strlen(str);
#line 44
  tmp___0 = malloc((size_t )((unsigned int )(tmp + 1UL)));
#line 44
  result = (char *)tmp___0;
  }
#line 44
  if (! result) {
    {
#line 45
    nomem();
    }
  }
  {
#line 46
  strcpy((char */* __restrict  */)result, (char const   */* __restrict  */)str);
  }
#line 47
  return (result);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/alloc.c"
static unsigned int vhashcalc(char const   *name ) 
{ 
  unsigned int result ;
  char const   *tmp ;

  {
#line 52
  result = 0U;
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if (! *name) {
#line 53
      goto while_break;
    }
#line 54
    tmp = name;
#line 54
    name ++;
#line 54
    result = (result << 1) ^ (unsigned int )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  return (result % 521U);
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/alloc.c"
struct valname *lookupname(char const   *name ) 
{ 
  struct valname *hp ;
  unsigned int hashval ;
  unsigned int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 61
  tmp = vhashcalc(name);
#line 61
  hashval = tmp;
#line 63
  hp = valhash[hashval];
  }
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! hp) {
#line 63
      goto while_break;
    }
    {
#line 64
    tmp___0 = strcmp((char const   *)hp->vn_string, name);
    }
#line 64
    if (tmp___0 == 0) {
#line 65
      return (hp);
    }
#line 63
    hp = hp->vn_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 66
  tmp___1 = malloc(sizeof(struct valname ));
#line 66
  hp = (struct valname *)tmp___1;
  }
#line 66
  if (! hp) {
    {
#line 67
    nomem();
    }
  }
  {
#line 68
  hp->vn_next = valhash[hashval];
#line 69
  valhash[hashval] = hp;
#line 70
  hp->vn_string = stracpy(name);
#line 71
  hp->vn_flags = (unsigned short)0;
#line 72
  hp->vn_value = (short)-32768;
#line 73
  hp->vn_hlist = (struct helpfile_list *)0;
  }
#line 74
  return (hp);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/alloc.c"
struct valexpr *alloc_expr(void) 
{ 
  struct valexpr *result ;
  void *tmp ;

  {
  {
#line 79
  tmp = malloc(sizeof(struct valexpr ));
#line 79
  result = (struct valexpr *)tmp;
  }
#line 80
  if (! result) {
    {
#line 81
    nomem();
    }
  }
#line 82
  return (result);
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/alloc.c"
struct valexpr *make_name(struct valname *vn ) 
{ 
  struct valexpr *result ;
  struct valexpr *tmp ;

  {
  {
#line 87
  tmp = alloc_expr();
#line 87
  result = tmp;
#line 88
  result->val_op = (unsigned char)2;
#line 89
  result->val_left = (struct valexpr *)0;
#line 90
  result->val_un.val_name = vn;
  }
#line 91
  return (result);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/alloc.c"
struct valexpr *make_value(int const   n ) 
{ 
  struct valexpr *result ;
  struct valexpr *tmp ;

  {
  {
#line 97
  tmp = alloc_expr();
#line 97
  result = tmp;
#line 99
  result->val_op = (unsigned char)0;
#line 100
  result->val_left = (struct valexpr *)0;
#line 101
  result->val_un.val_value = (long )n;
  }
#line 102
  return (result);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/alloc.c"
struct valexpr *make_sum(struct valname *vn , char const   op , int const   n ) 
{ 
  struct valexpr *result ;
  struct valexpr *tmp ;

  {
  {
#line 107
  tmp = alloc_expr();
#line 107
  result = tmp;
#line 108
  result->val_op = (unsigned char )op;
#line 109
  result->val_left = make_name(vn);
#line 110
  result->val_un.val_right = make_value(n);
  }
#line 111
  return (result);
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/alloc.c"
static jmp_buf jb  ;
#line 116 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/alloc.c"
static long eval(struct valexpr *ve ) 
{ 
  long l ;
  long tmp ;
  long r ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;

  {
  {
#line 123
  if ((int )ve->val_op == 2) {
#line 123
    goto case_2;
  }
#line 131
  if ((int )ve->val_op == 1) {
#line 131
    goto case_1;
  }
#line 131
  if ((int )ve->val_op == 0) {
#line 131
    goto case_1;
  }
#line 133
  if ((int )ve->val_op == 3) {
#line 133
    goto case_3;
  }
#line 140
  if ((int )ve->val_op == 43) {
#line 140
    goto case_43;
  }
#line 142
  if ((int )ve->val_op == 45) {
#line 142
    goto case_45;
  }
#line 144
  if ((int )ve->val_op == 42) {
#line 144
    goto case_42;
  }
#line 146
  if ((int )ve->val_op == 47) {
#line 146
    goto case_47;
  }
#line 148
  if ((int )ve->val_op == 37) {
#line 148
    goto case_37;
  }
#line 119
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 120
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Funny operator??\n");
#line 121
  errors ++;
#line 122
  longjmp((struct __jmp_buf_tag *)(jb), 1);
  }
  case_2: /* CIL Label */ 
#line 124
  if (! ((int )(ve->val_un.val_name)->vn_flags & (1 << 15))) {
    {
#line 125
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Undefined name %s near line %d\n",
            (ve->val_un.val_name)->vn_string, line_count);
#line 126
    errors ++;
#line 127
    longjmp((struct __jmp_buf_tag *)(jb), 1);
    }
  }
#line 129
  return ((long )(ve->val_un.val_name)->vn_value);
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 132
  return (ve->val_un.val_value);
  case_3: /* CIL Label */ 
  {
#line 135
  tmp = eval(ve->val_left);
#line 135
  l = tmp;
#line 135
  tmp___0 = eval(ve->val_un.val_right);
#line 135
  r = tmp___0;
  }
#line 136
  if (r <= 1L) {
#line 137
    return (l);
  }
#line 138
  return ((l / r + 1L) * r);
  case_43: /* CIL Label */ 
  {
#line 141
  tmp___1 = eval(ve->val_left);
#line 141
  tmp___2 = eval(ve->val_un.val_right);
  }
#line 141
  return (tmp___1 + tmp___2);
  case_45: /* CIL Label */ 
  {
#line 143
  tmp___3 = eval(ve->val_left);
#line 143
  tmp___4 = eval(ve->val_un.val_right);
  }
#line 143
  return (tmp___3 - tmp___4);
  case_42: /* CIL Label */ 
  {
#line 145
  tmp___5 = eval(ve->val_left);
#line 145
  tmp___6 = eval(ve->val_un.val_right);
  }
#line 145
  return (tmp___5 * tmp___6);
  case_47: /* CIL Label */ 
  {
#line 147
  tmp___7 = eval(ve->val_left);
#line 147
  tmp___8 = eval(ve->val_un.val_right);
  }
#line 147
  return (tmp___7 / tmp___8);
  case_37: /* CIL Label */ 
  {
#line 149
  tmp___9 = eval(ve->val_left);
#line 149
  tmp___10 = eval(ve->val_un.val_right);
  }
#line 149
  return (tmp___9 % tmp___10);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/alloc.c"
long evaluate(struct valexpr *ve ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
  {
#line 155
  tmp = _setjmp((struct __jmp_buf_tag *)(jb));
  }
#line 155
  if (tmp) {
#line 156
    return (-32768L);
  }
  {
#line 157
  tmp___0 = eval(ve);
  }
#line 157
  return (tmp___0);
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/alloc.c"
void throwaway_expr(struct valexpr *ve ) 
{ 


  {
  {
#line 168
  if ((int )ve->val_op == 3) {
#line 168
    goto case_3;
  }
#line 168
  if ((int )ve->val_op == 37) {
#line 168
    goto case_3;
  }
#line 168
  if ((int )ve->val_op == 47) {
#line 168
    goto case_3;
  }
#line 168
  if ((int )ve->val_op == 42) {
#line 168
    goto case_3;
  }
#line 168
  if ((int )ve->val_op == 45) {
#line 168
    goto case_3;
  }
#line 168
  if ((int )ve->val_op == 43) {
#line 168
    goto case_3;
  }
#line 162
  goto switch_break;
  case_3: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_43: /* CIL Label */ 
  {
#line 169
  throwaway_expr(ve->val_left);
#line 170
  throwaway_expr(ve->val_un.val_right);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 172
  free((void *)((char *)ve));
  }
#line 173
  return;
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/alloc.c"
unsigned int mhashcalc(char *name ) 
{ 
  unsigned int result ;
  char *tmp ;

  {
#line 181
  result = 0U;
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if (! *name) {
#line 183
      goto while_break;
    }
#line 184
    tmp = name;
#line 184
    name ++;
#line 184
    result = (result << 1) ^ (unsigned int )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 185
  return (result % 59U);
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/alloc.c"
void macro_define(char *name , char *subdir , struct module_list *mlist ) 
{ 
  unsigned int mhash ;
  unsigned int tmp ;
  struct macro *mp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 190
  tmp = mhashcalc(name);
#line 190
  mhash = tmp;
#line 193
  mp = macrohashtab[mhash];
  }
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 193
    if (! mp) {
#line 193
      goto while_break;
    }
    {
#line 194
    tmp___0 = strcmp((char const   *)mp->macro_name, (char const   *)name);
    }
#line 194
    if (tmp___0 == 0) {
      {
#line 195
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Macro %s is redefined line %d\n",
              name, line_count);
#line 196
      errors ++;
      }
#line 197
      return;
    }
#line 193
    mp = mp->macro_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 200
  tmp___1 = malloc(sizeof(struct macro ));
#line 200
  mp = (struct macro *)tmp___1;
  }
#line 201
  if (! mp) {
    {
#line 202
    nomem();
    }
  }
#line 203
  mp->macro_next = macrohashtab[mhash];
#line 204
  macrohashtab[mhash] = mp;
#line 205
  mp->macro_name = name;
#line 206
  mp->macro_ml = mlist;
#line 207
  if (subdir) {
    {
#line 208
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 208
      if (! mlist) {
#line 208
        goto while_break___0;
      }
#line 209
      if (! (mlist->ml_mod)->mod_subdir) {
#line 210
        (mlist->ml_mod)->mod_subdir = subdir;
      }
#line 208
      mlist = mlist->ml_next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 211
  return;
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/alloc.c"
struct module_list *alloc_modlist(void) 
{ 
  struct module_list *res ;
  void *tmp ;

  {
  {
#line 215
  tmp = malloc(sizeof(struct module_list ));
#line 215
  res = (struct module_list *)tmp;
  }
#line 217
  if (! res) {
    {
#line 218
    nomem();
    }
  }
#line 219
  res->ml_next = (struct module_list *)0;
#line 220
  res->ml_mod = (struct module *)0;
#line 221
  return (res);
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/alloc.c"
struct module_list *alloc_module(char *name , char *subdir ) 
{ 
  unsigned int mhash ;
  unsigned int tmp ;
  struct module *mp ;
  struct module_list *result ;
  struct module_list *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 226
  tmp = mhashcalc(name);
#line 226
  mhash = tmp;
#line 228
  tmp___0 = alloc_modlist();
#line 228
  result = tmp___0;
#line 230
  mp = modhashtab[mhash];
  }
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! mp) {
#line 230
      goto while_break;
    }
    {
#line 231
    tmp___1 = strcmp((char const   *)mp->mod_name, (char const   *)name);
    }
#line 231
    if (tmp___1 == 0) {
#line 232
      result->ml_mod = mp;
#line 233
      if (! mp->mod_subdir) {
#line 234
        mp->mod_subdir = subdir;
      }
#line 235
      return (result);
    }
#line 230
    mp = mp->mod_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 238
  tmp___2 = malloc(sizeof(struct module ));
#line 238
  mp = (struct module *)tmp___2;
  }
#line 239
  if (! mp) {
    {
#line 240
    nomem();
    }
  }
#line 241
  mp->mod_next = modhashtab[mhash];
#line 242
  modhashtab[mhash] = mp;
#line 243
  mp->mod_name = name;
#line 244
  mp->mod_subdir = subdir;
#line 245
  mp->mod_pl = (struct program_list *)0;
#line 246
  mp->mod_scanned = (unsigned short *)0;
#line 247
  result->ml_mod = mp;
#line 248
  return (result);
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/alloc.c"
void free_modlist(struct module_list *ml ) 
{ 
  struct module_list *nxt ;

  {
  {
#line 253
  while (1) {
    while_continue: /* CIL Label */ ;
#line 253
    if (! ml) {
#line 253
      goto while_break;
    }
    {
#line 254
    nxt = ml->ml_next;
#line 255
    free((void *)ml);
#line 256
    ml = nxt;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 258
  return;
}
}
#line 260 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/alloc.c"
struct module_list *copy_modlist(struct module_list *src ) 
{ 
  struct module_list *res ;

  {
#line 262
  res = (struct module_list *)0;
#line 264
  if (src) {
    {
#line 265
    res = alloc_modlist();
#line 266
    res->ml_mod = src->ml_mod;
#line 267
    res->ml_next = copy_modlist(src->ml_next);
    }
  }
#line 269
  return (res);
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/alloc.c"
struct module_list *lookupallocmods(char *name ) 
{ 
  struct macro *mp ;
  unsigned int tmp ;
  struct module_list *tmp___0 ;
  int tmp___1 ;
  struct module_list *tmp___2 ;
  struct module_list *tmp___3 ;

  {
  {
#line 276
  tmp = mhashcalc(name);
#line 276
  mp = macrohashtab[tmp];
  }
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;
#line 276
    if (! mp) {
#line 276
      goto while_break;
    }
    {
#line 277
    tmp___1 = strcmp((char const   *)name, (char const   *)mp->macro_name);
    }
#line 277
    if (tmp___1 == 0) {
      {
#line 278
      tmp___0 = copy_modlist(mp->macro_ml);
      }
#line 278
      return (tmp___0);
    }
#line 276
    mp = mp->macro_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 280
  tmp___2 = alloc_module(name, (char *)0);
#line 280
  tmp___3 = copy_modlist(tmp___2);
  }
#line 280
  return (tmp___3);
}
}
#line 284 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/alloc.c"
struct helpfile *find_help(char *name , char *subdir ) 
{ 
  int cnt ;
  int tmp ;
  int tmp___0 ;

  {
#line 288
  cnt = 0;
  {
#line 288
  while (1) {
    while_continue: /* CIL Label */ ;
#line 288
    if (! (cnt < 10)) {
#line 288
      goto while_break;
    }
#line 289
    if (! helpfiles[cnt].hf_name) {
#line 290
      goto while_break;
    }
    {
#line 291
    tmp = strcmp((char const   *)name, (char const   *)helpfiles[cnt].hf_name);
    }
#line 291
    if (tmp != 0) {
#line 292
      goto __Cont;
    }
#line 293
    if (subdir) {
#line 294
      if (! helpfiles[cnt].hf_subdir) {
#line 295
        goto __Cont;
      }
      {
#line 296
      tmp___0 = strcmp((char const   *)helpfiles[cnt].hf_subdir, (char const   *)subdir);
      }
#line 296
      if (tmp___0 != 0) {
#line 297
        goto __Cont;
      }
      {
#line 298
      free((void *)name);
#line 299
      free((void *)subdir);
      }
#line 300
      return (& helpfiles[cnt]);
    } else {
#line 303
      if (helpfiles[cnt].hf_subdir) {
#line 304
        goto __Cont;
      }
      {
#line 305
      free((void *)name);
      }
#line 306
      return (& helpfiles[cnt]);
    }
    __Cont: /* CIL Label */ 
#line 288
    cnt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 309
  if (cnt >= 10) {
    {
#line 310
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Sorry too many help files\n");
#line 311
    exit(254);
    }
  }
#line 313
  helpfiles[cnt].hf_name = name;
#line 314
  helpfiles[cnt].hf_subdir = subdir;
#line 315
  return (& helpfiles[cnt]);
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/alloc.c"
struct program *find_program(char *name ) 
{ 
  int cnt ;
  int tmp ;

  {
#line 321
  cnt = 0;
  {
#line 321
  while (1) {
    while_continue: /* CIL Label */ ;
#line 321
    if (! (cnt < 60)) {
#line 321
      goto while_break;
    }
#line 322
    if (! programs[cnt].prog_name) {
#line 323
      goto while_break;
    }
    {
#line 324
    tmp = strcmp((char const   *)programs[cnt].prog_name, (char const   *)name);
    }
#line 324
    if (tmp == 0) {
#line 325
      return (& programs[cnt]);
    }
#line 321
    cnt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 327
  if (cnt >= 60) {
    {
#line 328
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Sorry too many programs\n");
#line 329
    exit(253);
    }
  }
  {
#line 331
  programs[cnt].prog_name = stracpy((char const   *)name);
#line 332
  programs[cnt].prog_hf = (struct helpfile *)0;
  }
#line 333
  return (& programs[cnt]);
}
}
#line 336 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/alloc.c"
void define_helpsfor(char *name , char *subdir , struct program_list *pl ) 
{ 
  struct helpfile *whichh ;
  struct helpfile *tmp ;
  struct program *prog ;

  {
  {
#line 338
  tmp = find_help(name, subdir);
#line 338
  whichh = tmp;
  }
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (! pl) {
#line 341
      goto while_break;
    }
#line 342
    prog = pl->pl_prog;
#line 343
    if (prog->prog_hf) {
#line 344
      if ((unsigned long )prog->prog_hf != (unsigned long )whichh) {
        {
#line 345
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Program %s has helpfile defined twice as %s and %s\n",
                prog->prog_name, whichh->hf_name, (prog->prog_hf)->hf_name);
#line 347
        errors ++;
        }
      }
    } else {
#line 351
      prog->prog_hf = whichh;
    }
#line 352
    pl = pl->pl_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 354
  return;
}
}
#line 356 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/alloc.c"
struct program_list *alloc_pl(void) 
{ 
  struct program_list *res ;
  void *tmp ;

  {
  {
#line 358
  tmp = malloc(sizeof(struct program_list ));
#line 358
  res = (struct program_list *)tmp;
  }
#line 359
  if (! res) {
    {
#line 360
    nomem();
    }
  }
#line 361
  res->pl_next = (struct program_list *)0;
#line 362
  res->pl_prog = (struct program *)0;
#line 363
  return (res);
}
}
#line 366 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/alloc.c"
struct program_list *alloc_proglist(char *name ) 
{ 
  struct program *prog ;
  struct program *tmp ;
  struct program_list *res ;
  struct program_list *tmp___0 ;

  {
  {
#line 368
  tmp = find_program(name);
#line 368
  prog = tmp;
#line 369
  tmp___0 = alloc_pl();
#line 369
  res = tmp___0;
#line 370
  res->pl_prog = prog;
  }
#line 371
  return (res);
}
}
#line 374 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/alloc.c"
void assign_progmods(struct program *prog , char *subdir , struct module_list *ml ) 
{ 
  struct module *mod ;
  struct program_list *pl ;

  {
  {
#line 379
  while (1) {
    while_continue: /* CIL Label */ ;
#line 379
    if (! ml) {
#line 379
      goto while_break;
    }
#line 380
    mod = ml->ml_mod;
#line 381
    pl = mod->mod_pl;
    {
#line 381
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 381
      if (! pl) {
#line 381
        goto while_break___0;
      }
#line 382
      if ((unsigned long )pl->pl_prog == (unsigned long )prog) {
#line 383
        goto dun;
      }
#line 381
      pl = pl->pl_next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 384
    pl = alloc_pl();
#line 385
    pl->pl_prog = prog;
#line 386
    pl->pl_next = mod->mod_pl;
#line 387
    mod->mod_pl = pl;
    }
#line 388
    if (! mod->mod_subdir) {
#line 389
      mod->mod_subdir = subdir;
    }
    dun: 
#line 391
    ml = ml->ml_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 393
  return;
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/alloc.c"
struct textlist *alloc_textlist(char *string ) 
{ 
  struct textlist *result ;
  void *tmp ;

  {
  {
#line 397
  tmp = malloc(sizeof(struct textlist ));
#line 397
  result = (struct textlist *)tmp;
#line 399
  result->tl_text = string;
#line 400
  result->tl_next = (struct textlist *)0;
  }
#line 401
  return (result);
}
}
#line 404 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/alloc.c"
void throwaway_strs(struct textlist *tl ) 
{ 
  struct textlist *nxt ;

  {
  {
#line 406
  while (1) {
    while_continue: /* CIL Label */ ;
#line 406
    if (! tl) {
#line 406
      goto while_break;
    }
    {
#line 407
    nxt = tl->tl_next;
#line 408
    free((void *)tl->tl_text);
#line 409
    free((void *)((char *)tl));
#line 410
    tl = nxt;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 412
  return;
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/alloc.c"
void scanmodules(void) 
{ 
  unsigned int cnt ;
  struct module *mp ;

  {
#line 419
  cnt = 0U;
  {
#line 419
  while (1) {
    while_continue: /* CIL Label */ ;
#line 419
    if (! (cnt < 59U)) {
#line 419
      goto while_break;
    }
#line 420
    mp = modhashtab[cnt];
    {
#line 420
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 420
      if (! mp) {
#line 420
        goto while_break___0;
      }
      {
#line 421
      scanmodule(mp);
#line 420
      mp = mp->mod_next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 419
    cnt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 422
  return;
}
}
#line 424 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/alloc.c"
static void merge_helpname_name(struct valname *src , struct valname *dest ) 
{ 


  {
#line 426
  if (! dest->vn_hlist) {
#line 427
    dest->vn_hlist = src->vn_hlist;
  }
#line 428
  return;
}
}
#line 430 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/alloc.c"
void merge_helpname(struct valname *src , struct valexpr *dest ) 
{ 


  {
  {
#line 435
  if ((int )dest->val_op == 2) {
#line 435
    goto case_2;
  }
#line 443
  if ((int )dest->val_op == 37) {
#line 443
    goto case_37;
  }
#line 443
  if ((int )dest->val_op == 47) {
#line 443
    goto case_37;
  }
#line 443
  if ((int )dest->val_op == 42) {
#line 443
    goto case_37;
  }
#line 443
  if ((int )dest->val_op == 45) {
#line 443
    goto case_37;
  }
#line 443
  if ((int )dest->val_op == 43) {
#line 443
    goto case_37;
  }
#line 443
  if ((int )dest->val_op == 3) {
#line 443
    goto case_37;
  }
#line 433
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 434
  return;
  case_2: /* CIL Label */ 
  {
#line 436
  merge_helpname_name(src, dest->val_un.val_name);
  }
#line 437
  return;
  case_37: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 444
  merge_helpname(src, dest->val_left);
#line 445
  merge_helpname(src, dest->val_un.val_right);
  }
#line 446
  return;
  switch_break: /* CIL Label */ ;
  }
}
}
#line 450 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/alloc.c"
void merge_helps(struct valexpr *src , struct valexpr *dest ) 
{ 


  {
  {
#line 455
  if ((int )src->val_op == 2) {
#line 455
    goto case_2;
  }
#line 463
  if ((int )src->val_op == 37) {
#line 463
    goto case_37;
  }
#line 463
  if ((int )src->val_op == 47) {
#line 463
    goto case_37;
  }
#line 463
  if ((int )src->val_op == 42) {
#line 463
    goto case_37;
  }
#line 463
  if ((int )src->val_op == 45) {
#line 463
    goto case_37;
  }
#line 463
  if ((int )src->val_op == 43) {
#line 463
    goto case_37;
  }
#line 463
  if ((int )src->val_op == 3) {
#line 463
    goto case_37;
  }
#line 453
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 454
  return;
  case_2: /* CIL Label */ 
  {
#line 456
  merge_helpname(src->val_un.val_name, dest);
  }
#line 457
  return;
  case_37: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 464
  merge_helps(src->val_left, dest);
#line 465
  merge_helps(src->val_un.val_right, dest);
  }
#line 466
  return;
  switch_break: /* CIL Label */ ;
  }
}
}
#line 195 "/usr/include/stdio.h"
extern FILE *tmpfile(void) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 305 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) l64a)(long __n ) ;
#line 374
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 675 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 948
extern char *( __attribute__((__nonnull__(1))) getpass)(char const   *__prompt ) ;
#line 312 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/gspasswd.c"
unsigned int vcount  =    0U;
#line 32 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/gspasswd.c"
unsigned int vmax  =    0U;
#line 33 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/gspasswd.c"
char **vlist  ;
#line 39
extern char *crypt(char const   * , char const   * ) ;
#line 57 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/gspasswd.c"
void addvec(char *s ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 59
  if (vcount >= vmax) {
#line 60
    if (vmax == 0U) {
      {
#line 61
      tmp = malloc(10UL * sizeof(char *));
#line 61
      vlist = (char **)tmp;
      }
    } else {
      {
#line 63
      tmp___0 = realloc((void *)((char *)vlist), (unsigned long )(vmax + 10U) * sizeof(char *));
#line 63
      vlist = (char **)tmp___0;
      }
    }
#line 64
    if (! vlist) {
      {
#line 65
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Sorry out of memory\n");
#line 66
      exit(255);
      }
    }
#line 68
    vmax += 10U;
  }
#line 70
  *(vlist + vcount) = s;
#line 71
  vcount ++;
#line 72
  return;
}
}
#line 50 "/usr/include/x86_64-linux-gnu/sys/shm.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) shmctl)(int __shmid ,
                                                                             int __cmd ,
                                                                             struct shmid_ds *__buf ) ;
#line 53
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) shmget)(key_t __key ,
                                                                             size_t __size ,
                                                                             int __shmflg ) ;
#line 56
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) shmat)(int __shmid ,
                                                                              void const   *__shmaddr ,
                                                                              int __shmflg ) ;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 580
extern int putchar(int __c ) ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/shmdump.c"
unsigned char lastbuf[8UL * sizeof(unsigned int )]  ;
#line 30 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/shmdump.c"
unsigned int had  =    0U;
#line 30 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/shmdump.c"
unsigned int hadsame  =    0U;
#line 31 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/shmdump.c"
unsigned int blksize  =    4U;
#line 33 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/shmdump.c"
char npchar  =    (char )'.';
#line 35 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/shmdump.c"
void printnext(unsigned int addr , unsigned int len , unsigned char *b ) 
{ 
  unsigned int cnt ;
  int tmp ;
  unsigned int col ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 39
  if (had) {
#line 39
    if (len == blksize) {
      {
#line 39
      tmp = memcmp((void const   *)b, (void const   *)(lastbuf), (size_t )blksize);
      }
#line 39
      if (tmp == 0) {
#line 40
        if (! hadsame) {
          {
#line 41
          hadsame ++;
#line 42
          printf((char const   */* __restrict  */)"%.6x -- same ---\n", addr);
          }
        }
#line 44
        return;
      }
    }
  }
  {
#line 46
  had ++;
#line 47
  hadsame = 0U;
#line 48
  memcpy((void */* __restrict  */)(lastbuf), (void const   */* __restrict  */)b, (size_t )blksize);
#line 49
  printf((char const   */* __restrict  */)"%.6x ", addr);
#line 50
  cnt = 0U;
  }
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    if (! (cnt < len)) {
#line 50
      goto while_break;
    }
    {
#line 51
    printf((char const   */* __restrict  */)"%.2x", (int )*(b + cnt));
    }
#line 52
    if (((unsigned long )cnt & (sizeof(unsigned int ) - 1UL)) == sizeof(unsigned int ) - 1UL) {
      {
#line 53
      putchar(' ');
      }
    }
#line 50
    cnt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  if (len < blksize) {
#line 57
    col = (unsigned int )((unsigned long )(len * 2U) + (unsigned long )len / sizeof(unsigned int ));
    {
#line 57
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 57
      if (! ((unsigned long )col < ((unsigned long )blksize / sizeof(unsigned int )) * (2UL * sizeof(unsigned int ) + 1UL))) {
#line 57
        goto while_break___0;
      }
      {
#line 58
      putchar(' ');
#line 57
      col ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 60
  cnt = 0U;
  {
#line 60
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 60
    if (! (cnt < len)) {
#line 60
      goto while_break___1;
    }
    {
#line 61
    tmp___2 = __ctype_b_loc();
    }
#line 61
    if ((int const   )*(*tmp___2 + (int )*(b + cnt)) & 16384) {
#line 61
      tmp___1 = (int )*(b + cnt);
    } else {
#line 61
      tmp___1 = (int )npchar;
    }
    {
#line 61
    putchar(tmp___1);
    }
#line 62
    if (((unsigned long )cnt & (sizeof(unsigned int ) - 1UL)) == sizeof(unsigned int ) - 1UL) {
#line 62
      if (cnt != len - 1U) {
        {
#line 63
        putchar(' ');
        }
      }
    }
#line 60
    cnt ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 65
  putchar('\n');
  }
#line 66
  return;
}
}
#line 603 "/usr/include/curses.h"
extern int delwin(WINDOW * ) ;
#line 707
extern WINDOW *newwin(int  , int  , int  , int  ) ;
#line 799
extern int wborder(WINDOW * , chtype  , chtype  , chtype  , chtype  , chtype  , chtype  ,
                   chtype  , chtype  ) ;
#line 814
extern chtype winch(WINDOW * ) ;
#line 839
extern int wtouchln(WINDOW * , int  , int  , int  ) ;
#line 1390
extern int COLS ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/pmenu.c"
int nrows  ;
#line 30 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/pmenu.c"
int maxrows  ;
#line 30 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/pmenu.c"
int ncols1  ;
#line 30 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/pmenu.c"
int ncols2  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/pmenu.c"
int Bigcols  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/pmenu.c"
int Bigrows  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/pmenu.c"
int Colsinbigcol  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/pmenu.c"
int Hirow  =    -1;
#line 35 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/pmenu.c"
int Ahrow  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/pmenu.c"
int Actlines  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/pmenu.c"
int multiselect  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/pmenu.c"
int numresult  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/pmenu.c"
int firstresult  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/pmenu.c"
int messnum  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/pmenu.c"
int delim  =    '\t';
#line 48 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/pmenu.c"
char *Header  ;
#line 50 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/pmenu.c"
char **names  ;
#line 50 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/pmenu.c"
char **descrs  ;
#line 50 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/pmenu.c"
char *selected  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/pmenu.c"
void scaninput(void) 
{ 
  int lng ;
  char *tp ;
  char inbuf[120] ;
  int innum ;
  int minus ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  unsigned short const   **tmp___5 ;
  char *nh ;
  size_t tmp___6 ;
  void *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  unsigned short const   **tmp___11 ;
  int l1 ;
  int l2 ;
  char *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  char const   *tmp___17 ;
  char *tmp___18 ;
  void *tmp___19 ;

  {
#line 69
  if (messnum != 0) {
    {
#line 70
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 70
      tmp___3 = fgets((char */* __restrict  */)(inbuf), (int )sizeof(inbuf), (FILE */* __restrict  */)stdin);
      }
#line 70
      if (! tmp___3) {
#line 70
        goto while_break;
      }
      {
#line 73
      tmp = __ctype_b_loc();
      }
#line 73
      if (! ((int const   )*(*tmp + (int )inbuf[0]) & 2048)) {
#line 73
        if ((int )inbuf[0] != 45) {
#line 74
          goto while_continue;
        }
      }
#line 76
      minus = 0;
#line 76
      innum = minus;
#line 76
      lng = innum;
#line 77
      if ((int )inbuf[0] == 45) {
        {
#line 78
        lng ++;
#line 79
        minus = 1;
#line 80
        tmp___0 = __ctype_b_loc();
        }
#line 80
        if (! ((int const   )*(*tmp___0 + (int )inbuf[1]) & 2048)) {
#line 81
          goto while_continue;
        }
      }
      {
#line 83
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 83
        tmp___2 = __ctype_b_loc();
        }
#line 83
        if (! ((int const   )*(*tmp___2 + (int )inbuf[lng]) & 2048)) {
#line 83
          goto while_break___0;
        }
#line 84
        tmp___1 = lng;
#line 84
        lng ++;
#line 84
        innum = (innum * 10 + (int )inbuf[tmp___1]) - 48;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 85
      if ((int )inbuf[lng] != 58) {
#line 86
        goto while_continue;
      }
#line 87
      if (minus) {
#line 88
        innum = - innum;
      }
#line 89
      if (innum == messnum) {
#line 90
        goto found;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 92
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Message %d not found\n",
            messnum);
#line 93
    exit(100);
    }
  }
  found: 
#line 97
  if (Header) {
    {
#line 97
    tmp___9 = strcmp((char const   *)Header, "=");
    }
#line 97
    if (tmp___9 == 0) {
#line 98
      Header = (char *)0;
      {
#line 100
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 100
        tmp___8 = fgets((char */* __restrict  */)(inbuf), (int )sizeof(inbuf), (FILE */* __restrict  */)stdin);
        }
#line 100
        if (! tmp___8) {
#line 100
          goto while_break___1;
        }
        {
#line 102
        tmp___4 = strlen((char const   *)(inbuf));
#line 102
        lng = (int )tmp___4;
        }
        {
#line 103
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 103
          if (lng > 0) {
            {
#line 103
            tmp___5 = __ctype_b_loc();
            }
#line 103
            if (! ((int const   )*(*tmp___5 + (int )inbuf[lng - 1]) & 8192)) {
#line 103
              goto while_break___2;
            }
          } else {
#line 103
            goto while_break___2;
          }
#line 104
          lng --;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 105
        inbuf[lng] = (char )'\000';
#line 106
        if (lng <= 0) {
#line 107
          goto while_break___1;
        }
#line 108
        if (Header) {
          {
#line 109
          tmp___6 = strlen((char const   *)Header);
#line 109
          tmp___7 = malloc((size_t )((unsigned int )((tmp___6 + (size_t )lng) + 2UL)));
#line 109
          nh = (char *)tmp___7;
          }
#line 110
          if (! nh) {
            {
#line 111
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Sorry out of memory\n");
#line 112
            exit(255);
            }
          }
          {
#line 114
          sprintf((char */* __restrict  */)nh, (char const   */* __restrict  */)"%s\n%s",
                  Header, inbuf);
#line 115
          free((void *)Header);
#line 116
          Header = nh;
          }
        } else {
          {
#line 119
          Header = stracpy((char const   *)(inbuf));
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
  {
#line 123
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 123
    tmp___18 = fgets((char */* __restrict  */)(inbuf), (int )sizeof(inbuf), (FILE */* __restrict  */)stdin);
    }
#line 123
    if (! tmp___18) {
#line 123
      goto while_break___3;
    }
    {
#line 125
    tmp___10 = strlen((char const   *)(inbuf));
#line 125
    lng = (int )tmp___10;
    }
    {
#line 126
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 126
      if (lng > 0) {
        {
#line 126
        tmp___11 = __ctype_b_loc();
        }
#line 126
        if (! ((int const   )*(*tmp___11 + (int )inbuf[lng - 1]) & 8192)) {
#line 126
          goto while_break___4;
        }
      } else {
#line 126
        goto while_break___4;
      }
#line 127
      lng --;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 128
    inbuf[lng] = (char )'\000';
#line 129
    if (lng <= 0) {
#line 130
      goto while_break___3;
    }
    {
#line 132
    tp = strchr((char const   *)(inbuf), delim);
    }
#line 132
    if (tp) {
#line 134
      l1 = (int )(tp - inbuf);
#line 134
      l2 = (lng - l1) - 1;
#line 136
      tmp___12 = tp;
#line 136
      tp ++;
#line 136
      *tmp___12 = (char )'\000';
      {
#line 138
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 138
        if (! ((int )*tp == delim)) {
#line 138
          goto while_break___5;
        }
#line 139
        tp ++;
#line 140
        l2 --;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 143
      if (l1 > ncols1) {
#line 144
        ncols1 = l1;
      }
#line 145
      if (l2 > ncols2) {
#line 146
        ncols2 = l2;
      }
    } else
#line 149
    if (lng > ncols1) {
#line 150
      ncols1 = lng;
    }
#line 152
    if (nrows >= maxrows) {
#line 153
      if (maxrows == 0) {
        {
#line 154
        maxrows = 100;
#line 155
        tmp___13 = malloc(100UL * sizeof(char *));
#line 155
        names = (char **)tmp___13;
#line 156
        tmp___14 = malloc(100UL * sizeof(char *));
#line 156
        descrs = (char **)tmp___14;
        }
      } else {
        {
#line 159
        maxrows += 30;
#line 160
        tmp___15 = realloc((void *)((char *)names), (size_t )((unsigned int )((unsigned long )maxrows * sizeof(char *))));
#line 160
        names = (char **)tmp___15;
#line 161
        tmp___16 = realloc((void *)((char *)descrs), (size_t )((unsigned int )((unsigned long )maxrows * sizeof(char *))));
#line 161
        descrs = (char **)tmp___16;
        }
      }
#line 163
      if (! names) {
        {
#line 164
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Sorry, not enough memory\n");
#line 165
        exit(255);
        }
      } else
#line 163
      if (! descrs) {
        {
#line 164
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Sorry, not enough memory\n");
#line 165
        exit(255);
        }
      }
    }
    {
#line 169
    *(names + nrows) = stracpy((char const   *)(inbuf));
    }
#line 170
    if (tp) {
#line 170
      tmp___17 = (char const   *)tp;
    } else {
#line 170
      tmp___17 = "";
    }
    {
#line 170
    *(descrs + nrows) = stracpy(tmp___17);
#line 171
    nrows ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 176
  if (nrows <= 0) {
    {
#line 177
    exit(0);
    }
  }
#line 181
  if (multiselect) {
    {
#line 182
    tmp___19 = malloc((size_t )nrows);
#line 182
    selected = (char *)tmp___19;
    }
#line 182
    if (! selected) {
      {
#line 183
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Sorry, no memory for selections\n");
#line 184
      exit(255);
      }
    }
    {
#line 186
    memset((void *)selected, '\000', (size_t )nrows);
    }
  }
#line 188
  return;
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/pmenu.c"
void dohelp(int const   crow ) 
{ 
  char *fname ;
  char *sp ;
  unsigned int lng ;
  unsigned int cline ;
  unsigned int rcnt ;
  unsigned int widest ;
  int r ;
  FILE *hf ;
  char **lines_buff ;
  char *line ;
  WINDOW *helpwin ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  unsigned int ll ;
  size_t tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  size_t tmp___8 ;

  {
  {
#line 192
  fname = *(names + crow);
#line 193
  widest = 0U;
#line 199
  tmp = strlen((char const   *)fname);
#line 199
  lng = (unsigned int )tmp;
  }
#line 199
  if (lng == 0U) {
#line 200
    goto nohelp;
  }
  {
#line 201
  lng += 10U;
#line 202
  tmp___0 = malloc((size_t )lng);
#line 202
  fname = (char *)tmp___0;
  }
#line 202
  if (! fname) {
#line 203
    goto nohelp;
  }
  {
#line 207
  sp = strchr((char const   *)*(names + crow), ' ');
  }
#line 207
  if (sp) {
#line 208
    *sp = (char )'\000';
  }
  {
#line 209
  sprintf((char */* __restrict  */)fname, (char const   */* __restrict  */)"%s/Menuhelp",
          *(names + crow));
#line 210
  hf = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"r");
  }
#line 210
  if (hf) {
#line 211
    goto found;
  }
  {
#line 212
  sprintf((char */* __restrict  */)fname, (char const   */* __restrict  */)"%s.menuhelp",
          *(names + crow));
#line 213
  hf = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"r");
  }
#line 213
  if (hf) {
#line 214
    goto found;
  }
  {
#line 215
  hf = fopen((char const   */* __restrict  */)"Menu-summary", (char const   */* __restrict  */)"r");
  }
#line 215
  if (! hf) {
#line 216
    if (sp) {
#line 217
      *sp = (char )' ';
    }
    {
#line 218
    free((void *)fname);
    }
#line 219
    goto nohelp;
  }
  found: 
#line 222
  if (sp) {
#line 223
    *sp = (char )' ';
  }
  {
#line 224
  free((void *)fname);
#line 225
  tmp___1 = malloc((unsigned long )((unsigned int )(LINES - 2)) * sizeof(char *));
#line 225
  lines_buff = (char **)tmp___1;
  }
#line 225
  if (! lines_buff) {
    {
#line 226
    fclose(hf);
    }
#line 227
    goto nohelp;
  }
  {
#line 229
  tmp___2 = malloc((size_t )((unsigned int )COLS - 1U));
#line 229
  line = (char *)tmp___2;
  }
#line 229
  if (! line) {
    {
#line 230
    free((void *)lines_buff);
#line 231
    fclose(hf);
    }
#line 232
    goto nohelp;
  }
#line 234
  cline = 0U;
#line 235
  rcnt = (unsigned int )(LINES - 2);
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 237
    tmp___4 = fgets((char */* __restrict  */)line, COLS - 2, (FILE */* __restrict  */)hf);
    }
#line 237
    if (tmp___4) {
#line 237
      if (! (cline < rcnt)) {
#line 237
        goto while_break;
      }
    } else {
#line 237
      goto while_break;
    }
    {
#line 238
    tmp___3 = strlen((char const   *)line);
#line 238
    ll = (unsigned int )tmp___3;
    }
#line 239
    if (ll > 0U) {
#line 239
      if ((int )*(line + (ll - 1U)) == 10) {
#line 240
        ll --;
#line 240
        *(line + ll) = (char )'\000';
      }
    }
#line 241
    if (ll > widest) {
#line 242
      widest = ll;
    }
    {
#line 243
    *(lines_buff + cline) = stracpy((char const   *)line);
#line 244
    cline ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 246
  free((void *)line);
#line 247
  fclose(hf);
  }
#line 249
  if (cline == 0U) {
    {
#line 250
    *(lines_buff + 0) = stracpy("help file empty");
#line 251
    cline = 1U;
#line 252
    tmp___5 = strlen((char const   *)*(lines_buff + 0));
#line 252
    widest = (unsigned int )tmp___5;
    }
  }
  disp: 
  {
#line 256
  helpwin = newwin((int )(cline + 2U), (int )(widest + 2U), (int )((((unsigned int )LINES - cline) - 2U) / 2U),
                   (int )((((unsigned int )COLS - widest) - 2U) / 2U));
  }
#line 256
  if (! helpwin) {
#line 257
    r = 0;
    {
#line 257
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 257
      if (! ((unsigned int )r < cline)) {
#line 257
        goto while_break___0;
      }
      {
#line 258
      free((void *)*(lines_buff + r));
#line 257
      r ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 259
    free((void *)((char *)lines_buff));
    }
#line 260
    return;
  }
  {
#line 263
  wborder(helpwin, (chtype )0, (chtype )0, (chtype )0, (chtype )0, (chtype )0, (chtype )0,
          (chtype )0, (chtype )0);
#line 267
  r = 0;
  }
  {
#line 267
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 267
    if (! ((unsigned int )r < cline)) {
#line 267
      goto while_break___1;
    }
    {
#line 268
    tmp___6 = wmove(helpwin, r + 1, 1);
    }
#line 268
    if (! (tmp___6 == -1)) {
      {
#line 268
      waddnstr(helpwin, (char const   *)*(lines_buff + r), -1);
      }
    }
    {
#line 269
    free((void *)*(lines_buff + r));
#line 267
    r ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 271
  free((void *)((char *)lines_buff));
#line 272
  wmove(helpwin, (int )cline, (int )widest);
#line 273
  wrefresh(helpwin);
#line 274
  wgetch(helpwin);
#line 275
  delwin(helpwin);
  }
#line 276
  return;
  nohelp: 
  {
#line 279
  tmp___7 = malloc(sizeof(char *));
#line 279
  lines_buff = (char **)tmp___7;
  }
#line 280
  if (! lines_buff) {
#line 281
    return;
  }
  {
#line 282
  *(lines_buff + 0) = stracpy("No help for this option");
#line 283
  tmp___8 = strlen((char const   *)*(lines_buff + 0));
#line 283
  widest = (unsigned int )tmp___8;
#line 284
  cline = 1U;
  }
#line 285
  goto disp;
}
}
#line 288 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/pmenu.c"
void fillscreen(int startrow , int hiliterow ) 
{ 
  int cc ;
  int rr ;
  int roff ;
  char *hp ;
  char *cp ;
  int Hlng ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int wcol ;
  int wrow ;
  int tmp___2 ;

  {
  {
#line 290
  roff = 0;
#line 292
  wclear(stdscr);
#line 293
  Hirow = hiliterow;
  }
#line 295
  if (Header) {
#line 296
    hp = Header;
#line 298
    Ahrow = 0;
    {
#line 299
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 299
      cp = strchr((char const   *)hp, '\n');
      }
#line 299
      if (! cp) {
#line 299
        goto while_break;
      }
      {
#line 300
      Hlng = (int )(cp - hp);
#line 301
      *cp = (char )'\000';
#line 302
      tmp = wmove(stdscr, Ahrow, (COLS - Hlng) / 2);
      }
#line 302
      if (! (tmp == -1)) {
        {
#line 302
        waddnstr(stdscr, (char const   *)hp, -1);
        }
      }
#line 303
      *cp = (char )'\n';
#line 304
      Ahrow ++;
#line 305
      hp = cp + 1;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 307
    tmp___0 = strlen((char const   *)hp);
#line 307
    Hlng = (int )tmp___0;
#line 308
    tmp___1 = wmove(stdscr, Ahrow, (COLS - Hlng) / 2);
    }
#line 308
    if (! (tmp___1 == -1)) {
      {
#line 308
      waddnstr(stdscr, (char const   *)hp, -1);
      }
    }
#line 309
    Ahrow += 2;
  }
#line 312
  cc = 0;
  {
#line 312
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 312
    if (! (cc < Bigcols)) {
#line 312
      goto while_break___0;
    }
#line 313
    wcol = cc * Colsinbigcol;
#line 314
    rr = 0;
    {
#line 314
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 314
      if (! (rr < Actlines)) {
#line 314
        goto while_break___1;
      }
#line 315
      wrow = (startrow + rr) + roff;
#line 316
      if (wrow >= nrows) {
#line 317
        return;
      }
#line 318
      if (wrow == hiliterow) {
#line 319
        if (stdscr) {
#line 319
          stdscr->_attrs = 1UL << 16;
        }
      }
#line 320
      if (multiselect) {
#line 320
        if (*(selected + wrow)) {
#line 320
          tmp___2 = '+';
        } else {
#line 320
          tmp___2 = ' ';
        }
      } else {
#line 320
        tmp___2 = ' ';
      }
      {
#line 320
      mvprintw(rr + Ahrow, wcol, "%-*.*s%c%-*.*s", ncols1, ncols1, *(names + wrow),
               tmp___2, ncols2, ncols2, *(descrs + wrow));
      }
#line 323
      if (wrow == hiliterow) {
#line 324
        if (stdscr) {
#line 324
          stdscr->_attrs = 0UL;
        }
      }
#line 314
      rr ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 326
    roff += Actlines;
#line 312
    cc ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 328
  return;
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/pmenu.c"
void rehighlight(int startrow , int hiliterow ) 
{ 
  int cc ;
  int relrow ;
  int bcol ;
  int brow ;
  chtype tmp ;
  chtype tmp___0 ;

  {
#line 338
  if (Hirow == hiliterow) {
#line 339
    return;
  }
#line 341
  if (Hirow >= startrow) {
    {
#line 342
    relrow = Hirow - startrow;
#line 343
    bcol = (relrow / Actlines) * Colsinbigcol;
#line 344
    brow = relrow % Actlines;
#line 345
    wmove(stdscr, brow + Ahrow, bcol);
#line 347
    cc = 0;
    }
    {
#line 347
    while (1) {
      while_continue: /* CIL Label */ ;
#line 347
      if (! (cc < Colsinbigcol)) {
#line 347
        goto while_break;
      }
      {
#line 348
      tmp = winch(stdscr);
#line 348
      waddch(stdscr, (chtype const   )(tmp & ((1UL << 8) - 1UL)));
#line 347
      cc ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 355
  Hirow = hiliterow;
#line 356
  relrow = hiliterow - startrow;
#line 357
  bcol = (relrow / Actlines) * Colsinbigcol;
#line 358
  brow = relrow % Actlines;
#line 359
  wmove(stdscr, brow + Ahrow, bcol);
#line 361
  cc = 0;
  }
  {
#line 361
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 361
    if (! (cc < Colsinbigcol)) {
#line 361
      goto while_break___0;
    }
    {
#line 362
    tmp___0 = winch(stdscr);
#line 362
    waddch(stdscr, (chtype const   )(tmp___0 | (1UL << 16)));
#line 361
    cc ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 369
  return;
}
}
#line 372 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/pmenu.c"
void splurge(int const   crow , FILE *outf ) 
{ 
  size_t tmp ;

  {
#line 374
  if (numresult) {
    {
#line 375
    fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"%d\n",
            crow + 1);
    }
  } else
#line 376
  if (! firstresult) {
    {
#line 376
    tmp = strlen((char const   *)*(descrs + crow));
    }
#line 376
    if (tmp > 0UL) {
      {
#line 377
      fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"%s%c%s\n",
              *(names + crow), delim, *(descrs + crow));
      }
    } else {
      {
#line 379
      fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"%s\n",
              *(names + crow));
      }
    }
  } else {
    {
#line 379
    fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"%s\n",
            *(names + crow));
    }
  }
#line 380
  return;
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/pmenu.c"
void splurgeall(FILE *outf ) 
{ 
  int crow ;

  {
#line 385
  crow = 0;
  {
#line 385
  while (1) {
    while_continue: /* CIL Label */ ;
#line 385
    if (! (crow < nrows)) {
#line 385
      goto while_break;
    }
#line 386
    if (*(selected + crow)) {
      {
#line 387
      splurge((int const   )crow, outf);
      }
    }
#line 385
    crow ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 388
  return;
}
}
#line 390 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/pmenu.c"
int search(int const   strow , int ch ) 
{ 
  int cnt ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 394
  ch = tolower(ch);
#line 396
  cnt = (int )(strow + 1);
  }
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 396
    if (! (cnt < nrows)) {
#line 396
      goto while_break;
    }
    {
#line 397
    tmp = tolower((int )*(*(names + cnt) + 0));
    }
#line 397
    if (tmp == ch) {
#line 398
      return (cnt);
    }
#line 396
    cnt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 400
  cnt = 0;
  {
#line 400
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 400
    if (! (cnt < (int )strow)) {
#line 400
      goto while_break___0;
    }
    {
#line 401
    tmp___0 = tolower((int )*(*(names + cnt) + 0));
    }
#line 401
    if (tmp___0 == ch) {
#line 402
      return (cnt);
    }
#line 400
    cnt ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 404
  return (-1);
}
}
#line 407 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/pmenu.c"
void process(FILE *outf , int crow ) 
{ 
  int toprow ;
  int lastch ;
  char *cp ;
  char *np ;
  int ch ;
  int srow ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 409
  lastch = 9999;
#line 413
  initscr();
#line 414
  raw();
#line 415
  nonl();
#line 416
  noecho();
#line 417
  keypad(stdscr, (_Bool)1);
#line 419
  Actlines = LINES;
  }
#line 421
  if (Header) {
#line 422
    cp = Header;
    {
#line 423
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 423
      np = strchr((char const   *)cp, '\n');
      }
#line 423
      if (! np) {
#line 423
        goto while_break;
      }
#line 424
      cp = np + 1;
#line 425
      Actlines --;
    }
    while_break: /* CIL Label */ ;
    }
#line 427
    Actlines -= 2;
  }
#line 432
  Colsinbigcol = (ncols1 + ncols2) + 2;
#line 433
  Bigcols = COLS / Colsinbigcol;
#line 434
  if (Bigcols <= 0) {
#line 435
    Bigcols = 1;
  }
#line 437
  Bigrows = Actlines * Bigcols;
#line 439
  if (Bigcols == 1) {
#line 440
    if (Colsinbigcol > COLS) {
#line 441
      Colsinbigcol = COLS;
#line 442
      ncols2 = (Colsinbigcol - ncols1) - 2;
    }
  }
#line 446
  if (crow < 0) {
#line 447
    crow = 0;
  } else
#line 448
  if (crow >= nrows) {
#line 449
    crow = nrows - 1;
  }
  {
#line 450
  toprow = (crow / Bigrows) * Bigrows;
#line 452
  fillscreen(toprow, crow);
  }
  {
#line 454
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 457
    wmove(stdscr, LINES - 1, COLS - 1);
#line 458
    wrefresh(stdscr);
#line 460
    ch = wgetch(stdscr);
    }
    {
#line 477
    if (ch == 265) {
#line 477
      goto case_265;
    }
#line 477
    if (ch == 63) {
#line 477
      goto case_265;
    }
#line 488
    if (ch == 113) {
#line 488
      goto case_113;
    }
#line 500
    if (ch == 52) {
#line 500
      goto case_52;
    }
#line 500
    if (ch == 104) {
#line 500
      goto case_52;
    }
#line 500
    if (ch == 260) {
#line 500
      goto case_52;
    }
#line 520
    if (ch == 54) {
#line 520
      goto case_54;
    }
#line 520
    if (ch == 108) {
#line 520
      goto case_54;
    }
#line 520
    if (ch == 261) {
#line 520
      goto case_54;
    }
#line 537
    if (ch == 56) {
#line 537
      goto case_56;
    }
#line 537
    if (ch == 107) {
#line 537
      goto case_56;
    }
#line 537
    if (ch == 259) {
#line 537
      goto case_56;
    }
#line 545
    if (ch == 50) {
#line 545
      goto case_50;
    }
#line 545
    if (ch == 106) {
#line 545
      goto case_50;
    }
#line 545
    if (ch == 258) {
#line 545
      goto case_50;
    }
#line 558
    if (ch == 78) {
#line 558
      goto case_78;
    }
#line 558
    if (ch == 338) {
#line 558
      goto case_78;
    }
#line 558
    if (ch == 402) {
#line 558
      goto case_78;
    }
#line 558
    if (ch == 367) {
#line 558
      goto case_78;
    }
#line 571
    if (ch == 80) {
#line 571
      goto case_80;
    }
#line 571
    if (ch == 339) {
#line 571
      goto case_80;
    }
#line 571
    if (ch == 393) {
#line 571
      goto case_80;
    }
#line 571
    if (ch == 370) {
#line 571
      goto case_80;
    }
#line 575
    if (ch == 32) {
#line 575
      goto case_32;
    }
#line 589
    if (ch == 13) {
#line 589
      goto case_13;
    }
#line 589
    if (ch == 10) {
#line 589
      goto case_13;
    }
#line 589
    if (ch == 343) {
#line 589
      goto case_13;
    }
#line 461
    goto switch_default;
    switch_default: /* CIL Label */ 
    {
#line 462
    srow = search((int const   )crow, ch);
    }
#line 463
    if (srow < 0) {
#line 464
      goto switch_break;
    }
#line 465
    crow = srow;
#line 466
    srow = (crow / Bigrows) * Bigrows;
#line 467
    if (toprow != srow) {
      {
#line 468
      toprow = srow;
#line 469
      fillscreen(toprow, crow);
      }
    } else {
      {
#line 472
      rehighlight(toprow, crow);
      }
    }
#line 473
    goto switch_break;
    case_265: /* CIL Label */ 
    case_63: /* CIL Label */ 
    {
#line 479
    dohelp((int const   )crow);
    }
#line 484
    if (stdscr) {
#line 484
      tmp = (int )stdscr->_maxy + 1;
    } else {
#line 484
      tmp = -1;
    }
    {
#line 484
    wtouchln(stdscr, 0, tmp, 1);
    }
#line 486
    goto __Cont;
    case_113: /* CIL Label */ 
#line 489
    if (multiselect) {
      {
#line 490
      splurgeall(outf);
      }
    }
    {
#line 491
    wclear(stdscr);
#line 492
    wrefresh(stdscr);
#line 493
    endwin();
#line 494
    exit(0);
    }
    case_52: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_260: /* CIL Label */ 
#line 501
    crow -= Actlines;
    decrest: 
#line 503
    if (crow < toprow) {
#line 504
      toprow -= Bigrows;
#line 505
      if (toprow < 0) {
#line 506
        toprow = 0;
      }
#line 507
      if (crow < toprow) {
#line 508
        crow = toprow;
      }
      {
#line 509
      fillscreen(toprow, crow);
      }
    } else {
      {
#line 512
      rehighlight(toprow, crow);
      }
    }
#line 513
    goto switch_break;
    case_54: /* CIL Label */ 
    case_108: /* CIL Label */ 
    case_261: /* CIL Label */ 
#line 521
    crow += Actlines;
    increst: 
#line 523
    if (crow >= nrows) {
#line 524
      crow = nrows - 1;
    }
#line 525
    if (crow >= toprow + Bigrows) {
      {
#line 526
      toprow += Bigrows;
#line 527
      fillscreen(toprow, crow);
      }
    } else {
      {
#line 530
      rehighlight(toprow, crow);
      }
    }
#line 531
    goto switch_break;
    case_56: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_259: /* CIL Label */ 
#line 538
    crow --;
#line 539
    goto decrest;
    case_50: /* CIL Label */ 
    case_106: /* CIL Label */ 
    case_258: /* CIL Label */ 
#line 546
    crow ++;
#line 547
    goto increst;
    case_78: /* CIL Label */ 
    case_338: /* CIL Label */ 
    case_402: /* CIL Label */ 
    case_367: /* CIL Label */ 
#line 559
    crow += Bigrows;
#line 560
    goto increst;
    case_80: /* CIL Label */ 
    case_339: /* CIL Label */ 
    case_393: /* CIL Label */ 
    case_370: /* CIL Label */ 
#line 572
    crow -= Bigrows;
#line 573
    goto decrest;
    case_32: /* CIL Label */ 
#line 576
    if (multiselect) {
      {
#line 577
      *(selected + crow) = (char )(! *(selected + crow));
#line 578
      wmove(stdscr, (crow - toprow) % Actlines + Ahrow, ncols1 + ((crow - toprow) / Actlines) * Colsinbigcol);
      }
#line 579
      if (stdscr) {
#line 579
        stdscr->_attrs = 1UL << 16;
      }
#line 580
      if (*(selected + crow)) {
#line 580
        tmp___0 = '+';
      } else {
#line 580
        tmp___0 = ' ';
      }
      {
#line 580
      waddch(stdscr, (chtype const   )tmp___0);
      }
#line 581
      if (stdscr) {
#line 581
        stdscr->_attrs = 0UL;
      }
    }
#line 583
    goto switch_break;
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_343: /* CIL Label */ 
#line 590
    if (multiselect) {
#line 591
      if (lastch != ch) {
#line 591
        if (lastch != 32) {
          {
#line 592
          *(selected + crow) = (char )(! *(selected + crow));
#line 593
          wmove(stdscr, (crow - toprow) % Actlines + Ahrow, ncols1 + ((crow - toprow) / Actlines) * Colsinbigcol);
          }
#line 594
          if (stdscr) {
#line 594
            stdscr->_attrs = 1UL << 16;
          }
#line 595
          if (*(selected + crow)) {
#line 595
            tmp___1 = '+';
          } else {
#line 595
            tmp___1 = ' ';
          }
          {
#line 595
          waddch(stdscr, (chtype const   )tmp___1);
          }
#line 596
          if (stdscr) {
#line 596
            stdscr->_attrs = 0UL;
          }
#line 597
          goto switch_break;
        }
      }
      {
#line 599
      splurgeall(outf);
      }
    } else {
      {
#line 602
      splurge((int const   )crow, outf);
      }
    }
    {
#line 603
    wclear(stdscr);
#line 604
    wrefresh(stdscr);
#line 605
    endwin();
#line 606
    exit(0);
    }
    switch_break: /* CIL Label */ ;
    }
#line 609
    lastch = ch;
    __Cont: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 613 "/home/june/repo/benchmarks/collector/temp/gnuspool-1.7ubuntu1/util/pmenu.c"
int xdig(int ch ) 
{ 


  {
  {
#line 621
  if (ch == 57) {
#line 621
    goto case_57;
  }
#line 621
  if (ch == 56) {
#line 621
    goto case_57;
  }
#line 621
  if (ch == 55) {
#line 621
    goto case_57;
  }
#line 621
  if (ch == 54) {
#line 621
    goto case_57;
  }
#line 621
  if (ch == 53) {
#line 621
    goto case_57;
  }
#line 621
  if (ch == 52) {
#line 621
    goto case_57;
  }
#line 621
  if (ch == 51) {
#line 621
    goto case_57;
  }
#line 621
  if (ch == 50) {
#line 621
    goto case_57;
  }
#line 621
  if (ch == 49) {
#line 621
    goto case_57;
  }
#line 621
  if (ch == 48) {
#line 621
    goto case_57;
  }
#line 624
  if (ch == 102) {
#line 624
    goto case_102;
  }
#line 624
  if (ch == 101) {
#line 624
    goto case_102;
  }
#line 624
  if (ch == 100) {
#line 624
    goto case_102;
  }
#line 624
  if (ch == 99) {
#line 624
    goto case_102;
  }
#line 624
  if (ch == 98) {
#line 624
    goto case_102;
  }
#line 624
  if (ch == 97) {
#line 624
    goto case_102;
  }
#line 627
  if (ch == 70) {
#line 627
    goto case_70;
  }
#line 627
  if (ch == 69) {
#line 627
    goto case_70;
  }
#line 627
  if (ch == 68) {
#line 627
    goto case_70;
  }
#line 627
  if (ch == 67) {
#line 627
    goto case_70;
  }
#line 627
  if (ch == 66) {
#line 627
    goto case_70;
  }
#line 627
  if (ch == 65) {
#line 627
    goto case_70;
  }
#line 616
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 617
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid hex digit in delimiter\n");
#line 618
  exit(1);
  }
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 622
  return (ch - 48);
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
#line 625
  return ((ch - 97) + 10);
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
#line 628
  return ((ch - 65) + 10);
  switch_break: /* CIL Label */ ;
  }
}
}
