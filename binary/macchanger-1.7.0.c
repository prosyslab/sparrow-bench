/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 30 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/mac.h"
struct __anonstruct_mac_t_28 {
   unsigned char byte[6] ;
};
#line 30 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/mac.h"
typedef struct __anonstruct_mac_t_28 mac_t;
#line 34
enum __anonenum_mac_type_t_29 {
    mac_is_anykind = 0,
    mac_is_wireless = 1,
    mac_is_others = 2
} ;
#line 34 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/mac.h"
typedef enum __anonenum_mac_type_t_29 mac_type_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 111 "/usr/include/net/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifrn_36 {
   char ifrn_name[16] ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifru_37 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   __caddr_t ifru_data ;
};
#line 126 "/usr/include/net/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_36 ifr_ifrn ;
   union __anonunion_ifr_ifru_37 ifr_ifru ;
};
#line 33 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/netinfo.h"
struct __anonstruct_net_info_t_39 {
   int sock ;
   struct ifreq dev ;
};
#line 33 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/netinfo.h"
typedef struct __anonstruct_net_info_t_39 net_info_t;
#line 31 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/maclist.h"
struct __anonstruct_card_mac_list_item_t_27 {
   char *name ;
   unsigned char byte[3] ;
};
#line 31 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/maclist.h"
typedef struct __anonstruct_card_mac_list_item_t_27 card_mac_list_item_t;
#line 116 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 20 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 412 "/usr/include/linux/ethtool.h"
struct ethtool_perm_addr {
   __u32 cmd ;
   __u32 size ;
   __u8 data[0] ;
};
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 173
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 324 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srandom)(unsigned int __seed ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 42 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/mac.h"
int mc_mac_read_string(mac_t *mac , char *string ) ;
#line 43
void mc_mac_into_string(mac_t const   *mac , char *s ) ;
#line 45
int mc_mac_equal(mac_t const   *mac1 , mac_t const   *mac2 ) ;
#line 46
mac_t *mc_mac_dup(mac_t const   *mac ) ;
#line 47
void mc_mac_free(mac_t *mac ) ;
#line 48
void mc_mac_random(mac_t *mac , unsigned char last_n_bytes , char set_bia ) ;
#line 38 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/maclist.h"
int mc_maclist_init(void) ;
#line 39
void mc_maclist_free(void) ;
#line 41
char const   *mc_maclist_get_cardname_with_default(mac_t const   *mac , char const   *def ) ;
#line 42
void mc_maclist_set_random_vendor(mac_t *mac , mac_type_t type ) ;
#line 43
int mc_maclist_is_wireless(mac_t const   *mac ) ;
#line 44
void mc_maclist_print(char const   *keyword ) ;
#line 38 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/netinfo.h"
net_info_t *mc_net_info_new(char const   *device ) ;
#line 39
void mc_net_info_free(net_info_t *net ) ;
#line 41
mac_t *mc_net_info_get_mac(net_info_t const   *net ) ;
#line 42
int mc_net_info_set_mac(net_info_t *net , mac_t const   *mac ) ;
#line 44
mac_t *mc_net_info_get_permanent_mac(net_info_t const   *net ) ;
#line 46 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/main.c"
static void print_help(void) 
{ 


  {
  {
#line 49
  printf((char const   */* __restrict  */)"GNU MAC Changer\nUsage: macchanger [options] device\n\n  -h,  --help                   Print this help\n  -V,  --version                Print version and exit\n  -s,  --show                   Print the MAC address and exit\n  -e,  --ending                 Don\'t change the vendor bytes\n  -a,  --another                Set random vendor MAC of the same kind\n  -A                            Set random vendor MAC of any kind\n  -p,  --permanent              Reset to original, permanent hardware MAC\n  -r,  --random                 Set fully random MAC\n  -l,  --list[=keyword]         Print known vendors\n  -b,  --bia                    Pretend to be a burned-in-address\n  -m,  --mac=XX:XX:XX:XX:XX:XX\n       --mac XX:XX:XX:XX:XX:XX  Set the MAC XX:XX:XX:XX:XX:XX\n\nReport bugs to https://github.com/alobbs/macchanger/issues\n");
  }
#line 64
  return;
}
}
#line 67 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/main.c"
static void print_usage(void) 
{ 


  {
  {
#line 70
  printf((char const   */* __restrict  */)"GNU MAC Changer\nUsage: macchanger [options] device\n\nTry `macchanger --help\' for more options.\n");
  }
#line 73
  return;
}
}
#line 76 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/main.c"
static void print_mac(char const   *s , mac_t const   *mac ) 
{ 
  char string[18] ;
  int is_wireless ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 82
  is_wireless = mc_maclist_is_wireless(mac);
#line 83
  mc_mac_into_string(mac, string);
#line 84
  tmp = mc_maclist_get_cardname_with_default(mac, "unknown");
  }
#line 84
  if (is_wireless) {
#line 84
    tmp___0 = " [wireless]";
  } else {
#line 84
    tmp___0 = "";
  }
  {
#line 84
  printf((char const   */* __restrict  */)"%s%s%s (%s)\n", s, string, tmp___0, tmp);
  }
#line 88
  return;
}
}
#line 91 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/main.c"
static void random_seed(void) 
{ 
  int fd ;
  struct timeval tv ;
  unsigned int seed ;
  __pid_t tmp ;

  {
  {
#line 98
  fd = open("/dev/hwrng", 0);
  }
#line 98
  if (fd >= 0) {
    {
#line 102
    read(fd, (void *)(& seed), sizeof(seed));
#line 103
    close(fd);
    }
  } else {
    {
#line 98
    fd = open("/dev/random", 0);
    }
#line 98
    if (fd >= 0) {
      {
#line 102
      read(fd, (void *)(& seed), sizeof(seed));
#line 103
      close(fd);
      }
    } else {
      {
#line 98
      fd = open("/dev/urandom", 0);
      }
#line 98
      if (fd >= 0) {
        {
#line 102
        read(fd, (void *)(& seed), sizeof(seed));
#line 103
        close(fd);
        }
      } else {
        {
#line 105
        gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 106
        tmp = getpid();
#line 106
        seed = (unsigned int )(((long )(tmp << 16) ^ tv.tv_sec) ^ tv.tv_usec);
        }
      }
    }
  }
  {
#line 109
  srandom(seed);
  }
#line 110
  return;
}
}
#line 113 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/main.c"
int main(int argc , char **argv ) 
{ 
  char random___0 ;
  char ending ;
  char another_any ;
  char another_same ;
  char permanent ;
  char print_list ;
  char show ;
  char set_bia ;
  char *set_mac ;
  char *search_word ;
  struct option long_options[13] ;
  net_info_t *net ;
  mac_t *mac ;
  mac_t *mac_permanent ;
  mac_t *mac_faked ;
  char *device_name ;
  int val ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 116
  random___0 = (char)0;
#line 117
  ending = (char)0;
#line 118
  another_any = (char)0;
#line 119
  another_same = (char)0;
#line 120
  permanent = (char)0;
#line 121
  print_list = (char)0;
#line 122
  show = (char)0;
#line 123
  set_bia = (char)0;
#line 124
  set_mac = (char *)((void *)0);
#line 125
  search_word = (char *)((void *)0);
#line 127
  long_options[0].name = "help";
#line 127
  long_options[0].has_arg = 0;
#line 127
  long_options[0].flag = (int *)((void *)0);
#line 127
  long_options[0].val = 'h';
#line 127
  long_options[1].name = "version";
#line 127
  long_options[1].has_arg = 0;
#line 127
  long_options[1].flag = (int *)((void *)0);
#line 127
  long_options[1].val = 'V';
#line 127
  long_options[2].name = "random";
#line 127
  long_options[2].has_arg = 0;
#line 127
  long_options[2].flag = (int *)((void *)0);
#line 127
  long_options[2].val = 'r';
#line 127
  long_options[3].name = "ending";
#line 127
  long_options[3].has_arg = 0;
#line 127
  long_options[3].flag = (int *)((void *)0);
#line 127
  long_options[3].val = 'e';
#line 127
  long_options[4].name = "endding";
#line 127
  long_options[4].has_arg = 0;
#line 127
  long_options[4].flag = (int *)((void *)0);
#line 127
  long_options[4].val = 'e';
#line 127
  long_options[5].name = "another";
#line 127
  long_options[5].has_arg = 0;
#line 127
  long_options[5].flag = (int *)((void *)0);
#line 127
  long_options[5].val = 'a';
#line 127
  long_options[6].name = "permanent";
#line 127
  long_options[6].has_arg = 0;
#line 127
  long_options[6].flag = (int *)((void *)0);
#line 127
  long_options[6].val = 'p';
#line 127
  long_options[7].name = "show";
#line 127
  long_options[7].has_arg = 0;
#line 127
  long_options[7].flag = (int *)((void *)0);
#line 127
  long_options[7].val = 's';
#line 127
  long_options[8].name = "another_any";
#line 127
  long_options[8].has_arg = 0;
#line 127
  long_options[8].flag = (int *)((void *)0);
#line 127
  long_options[8].val = 'A';
#line 127
  long_options[9].name = "bia";
#line 127
  long_options[9].has_arg = 0;
#line 127
  long_options[9].flag = (int *)((void *)0);
#line 127
  long_options[9].val = 'b';
#line 127
  long_options[10].name = "list";
#line 127
  long_options[10].has_arg = 2;
#line 127
  long_options[10].flag = (int *)((void *)0);
#line 127
  long_options[10].val = 'l';
#line 127
  long_options[11].name = "mac";
#line 127
  long_options[11].has_arg = 1;
#line 127
  long_options[11].flag = (int *)((void *)0);
#line 127
  long_options[11].val = 'm';
#line 127
  long_options[12].name = (char const   *)((void *)0);
#line 127
  long_options[12].has_arg = 0;
#line 127
  long_options[12].flag = (int *)((void *)0);
#line 127
  long_options[12].val = 0;
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 153
    val = getopt_long(argc, (char * const  *)argv, "VasAbrephlm:", (struct option  const  *)(long_options),
                      (int *)((void *)0));
    }
#line 153
    if (! (val != -1)) {
#line 153
      goto while_break;
    }
    {
#line 155
    if (val == 86) {
#line 155
      goto case_86;
    }
#line 164
    if (val == 108) {
#line 164
      goto case_108;
    }
#line 168
    if (val == 114) {
#line 168
      goto case_114;
    }
#line 171
    if (val == 101) {
#line 171
      goto case_101;
    }
#line 174
    if (val == 98) {
#line 174
      goto case_98;
    }
#line 177
    if (val == 97) {
#line 177
      goto case_97;
    }
#line 180
    if (val == 115) {
#line 180
      goto case_115;
    }
#line 183
    if (val == 65) {
#line 183
      goto case_65;
    }
#line 186
    if (val == 112) {
#line 186
      goto case_112;
    }
#line 189
    if (val == 109) {
#line 189
      goto case_109;
    }
#line 194
    goto switch_default;
    case_86: /* CIL Label */ 
    {
#line 156
    printf((char const   */* __restrict  */)"GNU MAC changer %s\nWritten by Alvaro Lopez Ortega <alvaro@gnu.org>\n\nCopyright (C) 2003,2013 Alvaro Lopez Ortega <alvaro@gnu.org>.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n",
           "1.7.0");
#line 162
    exit(0);
    }
#line 163
    goto switch_break;
    case_108: /* CIL Label */ 
#line 165
    print_list = (char)1;
#line 166
    search_word = optarg;
#line 167
    goto switch_break;
    case_114: /* CIL Label */ 
#line 169
    random___0 = (char)1;
#line 170
    goto switch_break;
    case_101: /* CIL Label */ 
#line 172
    ending = (char)1;
#line 173
    goto switch_break;
    case_98: /* CIL Label */ 
#line 175
    set_bia = (char)1;
#line 176
    goto switch_break;
    case_97: /* CIL Label */ 
#line 178
    another_same = (char)1;
#line 179
    goto switch_break;
    case_115: /* CIL Label */ 
#line 181
    show = (char)1;
#line 182
    goto switch_break;
    case_65: /* CIL Label */ 
#line 184
    another_any = (char)1;
#line 185
    goto switch_break;
    case_112: /* CIL Label */ 
#line 187
    permanent = (char)1;
#line 188
    goto switch_break;
    case_109: /* CIL Label */ 
#line 190
    set_mac = optarg;
#line 191
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 195
    print_help();
#line 196
    exit(0);
    }
#line 197
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 202
  tmp = mc_maclist_init();
  }
#line 202
  if (tmp < 0) {
    {
#line 203
    exit(1);
    }
  }
#line 207
  if (print_list) {
    {
#line 208
    mc_maclist_print((char const   *)search_word);
#line 209
    exit(0);
    }
  }
#line 213
  if (optind >= argc) {
    {
#line 214
    print_usage();
#line 215
    exit(0);
    }
  }
  {
#line 217
  device_name = *(argv + optind);
#line 220
  random_seed();
#line 223
  net = mc_net_info_new((char const   *)device_name);
  }
#line 223
  if ((unsigned long )net == (unsigned long )((void *)0)) {
    {
#line 224
    exit(1);
    }
  }
  {
#line 226
  mac = mc_net_info_get_mac((net_info_t const   *)net);
#line 227
  mac_permanent = mc_net_info_get_permanent_mac((net_info_t const   *)net);
  }
#line 230
  if (set_bia) {
#line 230
    if (! random___0) {
      {
#line 231
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[WARNING] Ignoring --bia option that can only be used with --random\n");
      }
    }
  }
  {
#line 235
  print_mac("Current MAC:   ", (mac_t const   *)mac);
#line 236
  print_mac("Permanent MAC: ", (mac_t const   *)mac_permanent);
#line 239
  mac_faked = mc_mac_dup((mac_t const   *)mac);
  }
#line 241
  if (show) {
    {
#line 242
    exit(0);
    }
  } else
#line 243
  if (set_mac) {
    {
#line 244
    tmp___0 = mc_mac_read_string(mac_faked, set_mac);
    }
#line 244
    if (tmp___0 < 0) {
      {
#line 245
      exit(1);
      }
    }
  } else
#line 247
  if (random___0) {
    {
#line 248
    mc_mac_random(mac_faked, (unsigned char)6, set_bia);
    }
  } else
#line 249
  if (ending) {
    {
#line 250
    mc_mac_random(mac_faked, (unsigned char)3, (char)1);
    }
  } else
#line 251
  if (another_same) {
    {
#line 252
    val = mc_maclist_is_wireless((mac_t const   *)mac);
#line 253
    mc_maclist_set_random_vendor(mac_faked, (mac_type_t )val);
#line 254
    mc_mac_random(mac_faked, (unsigned char)3, (char)1);
    }
  } else
#line 255
  if (another_any) {
    {
#line 256
    mc_maclist_set_random_vendor(mac_faked, (mac_type_t )0);
#line 257
    mc_mac_random(mac_faked, (unsigned char)3, (char)1);
    }
  } else
#line 258
  if (permanent) {
    {
#line 259
    mac_faked = mc_mac_dup((mac_t const   *)mac_permanent);
    }
  } else {
    {
#line 261
    exit(0);
    }
  }
  {
#line 265
  ret = mc_net_info_set_mac(net, (mac_t const   *)mac_faked);
  }
#line 266
  if (ret == 0) {
    {
#line 268
    mc_mac_free(mac_faked);
#line 269
    mac_faked = mc_net_info_get_mac((net_info_t const   *)net);
#line 272
    print_mac("New MAC:       ", (mac_t const   *)mac_faked);
#line 275
    tmp___1 = mc_mac_equal((mac_t const   *)mac, (mac_t const   *)mac_faked);
    }
#line 275
    if (tmp___1) {
      {
#line 276
      printf((char const   */* __restrict  */)"It\'s the same MAC!!\n");
#line 277
      exit(1);
      }
    }
  }
  {
#line 282
  mc_mac_free(mac);
#line 283
  mc_mac_free(mac_faked);
#line 284
  mc_mac_free(mac_permanent);
#line 285
  mc_net_info_free(net);
#line 286
  mc_maclist_free();
  }
#line 288
  if (ret == 0) {
#line 288
    tmp___2 = 0;
  } else {
#line 288
    tmp___2 = 1;
  }
#line 288
  return (tmp___2);
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 321
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) random)(void) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 32 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/maclist.c"
card_mac_list_item_t *list_others  =    (card_mac_list_item_t *)((void *)0);
#line 33 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/maclist.c"
card_mac_list_item_t *list_wireless  =    (card_mac_list_item_t *)((void *)0);
#line 35 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/maclist.c"
int list_others_len  =    0;
#line 36 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/maclist.c"
int list_wireless_len  =    0;
#line 39 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/maclist.c"
static char *mc_maclist_get_cardname_from_list(mac_t const   *mac , card_mac_list_item_t *list ) 
{ 
  int i ;

  {
#line 42
  i = 0;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! (list + i)->name) {
#line 44
      goto while_break;
    }
#line 45
    if ((int )mac->byte[0] == (int )(list + i)->byte[0]) {
#line 45
      if ((int )mac->byte[1] == (int )(list + i)->byte[1]) {
#line 45
        if ((int )mac->byte[2] == (int )(list + i)->byte[2]) {
#line 49
          return ((list + i)->name);
        }
      }
    }
#line 51
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  return ((char *)((void *)0));
}
}
#line 58 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/maclist.c"
static char *mc_maclist_get_cardname(mac_t const   *mac ) 
{ 
  char *name ;

  {
  {
#line 63
  name = mc_maclist_get_cardname_from_list(mac, list_wireless);
  }
#line 64
  if (name) {
#line 65
    return (name);
  }
  {
#line 68
  name = mc_maclist_get_cardname_from_list(mac, list_others);
  }
#line 69
  return (name);
}
}
#line 73 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/maclist.c"
char const   *mc_maclist_get_cardname_with_default(mac_t const   *mac , char const   *def ) 
{ 
  char *name ;
  char const   *tmp ;

  {
  {
#line 77
  name = mc_maclist_get_cardname(mac);
  }
#line 78
  if (name) {
#line 78
    tmp = (char const   *)name;
  } else {
#line 78
    tmp = def;
  }
#line 78
  return (tmp);
}
}
#line 81 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/maclist.c"
static void mc_maclist_set_random_vendor_from_list(mac_t *mac , card_mac_list_item_t *list ,
                                                   int list_len ) 
{ 
  int i ;
  int num ;
  long tmp ;

  {
  {
#line 84
  num = list_len;
#line 87
  tmp = random();
#line 87
  num = (int )(tmp % (long )num);
#line 90
  i = 0;
  }
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    if (! (i < 3)) {
#line 90
      goto while_break;
    }
#line 91
    mac->byte[i] = (list + num)->byte[i];
#line 90
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  return;
}
}
#line 96 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/maclist.c"
void mc_maclist_set_random_vendor(mac_t *mac , mac_type_t type ) 
{ 
  int num ;
  long tmp ;

  {
  {
#line 101
  tmp = random();
#line 101
  num = (int )(tmp % (long )(list_others_len + list_wireless_len));
  }
  {
#line 104
  if ((unsigned int )type == 0U) {
#line 104
    goto case_0;
  }
#line 111
  if ((unsigned int )type == 1U) {
#line 111
    goto case_1;
  }
#line 114
  if ((unsigned int )type == 2U) {
#line 114
    goto case_2;
  }
#line 103
  goto switch_break;
  case_0: /* CIL Label */ 
#line 105
  if (num < list_others_len) {
    {
#line 106
    mc_maclist_set_random_vendor_from_list(mac, list_others, list_others_len);
    }
  } else {
    {
#line 108
    mc_maclist_set_random_vendor_from_list(mac, list_wireless, list_wireless_len);
    }
  }
#line 110
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 112
  mc_maclist_set_random_vendor_from_list(mac, list_wireless, list_wireless_len);
  }
#line 113
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 115
  mc_maclist_set_random_vendor_from_list(mac, list_others, list_others_len);
  }
#line 116
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 118
  return;
}
}
#line 121 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/maclist.c"
int mc_maclist_is_wireless(mac_t const   *mac ) 
{ 
  char *tmp ;

  {
  {
#line 124
  tmp = mc_maclist_get_cardname_from_list(mac, list_wireless);
  }
#line 124
  return ((unsigned long )tmp != (unsigned long )((void *)0));
}
}
#line 128 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/maclist.c"
static void mc_maclist_print_from_list(card_mac_list_item_t *list , char const   *keyword ) 
{ 
  int i ;
  char *tmp ;

  {
#line 131
  i = 0;
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    if (! (list + i)->name) {
#line 133
      goto while_break;
    }
#line 134
    if (! keyword) {
      {
#line 135
      printf((char const   */* __restrict  */)"%04i - %02x:%02x:%02x - %s\n", i, (int )(list + i)->byte[0],
             (int )(list + i)->byte[1], (int )(list + i)->byte[2], (list + i)->name);
      }
    } else
#line 134
    if (keyword) {
      {
#line 134
      tmp = strstr((char const   *)(list + i)->name, keyword);
      }
#line 134
      if (tmp) {
        {
#line 135
        printf((char const   */* __restrict  */)"%04i - %02x:%02x:%02x - %s\n", i,
               (int )(list + i)->byte[0], (int )(list + i)->byte[1], (int )(list + i)->byte[2],
               (list + i)->name);
        }
      }
    }
#line 139
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 141
  return;
}
}
#line 144 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/maclist.c"
void mc_maclist_print(char const   *keyword ) 
{ 


  {
  {
#line 147
  printf((char const   */* __restrict  */)"Misc MACs:\nNum    MAC        Vendor\n---    ---        ------\n");
#line 150
  mc_maclist_print_from_list(list_others, keyword);
#line 152
  printf((char const   */* __restrict  */)"\nWireless MACs:\nNum    MAC        Vendor\n---    ---        ------\n");
#line 156
  mc_maclist_print_from_list(list_wireless, keyword);
  }
#line 157
  return;
}
}
#line 160 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/maclist.c"
static card_mac_list_item_t *mc_maclist_read_from_file(char const   *fullpath , int *list_len ) 
{ 
  FILE *f ;
  char *line ;
  char tmp[512] ;
  int num ;
  card_mac_list_item_t *list ;
  void *tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  unsigned char tmp___6 ;
  unsigned char tmp___7 ;

  {
  {
#line 166
  num = 0;
#line 169
  f = fopen((char const   */* __restrict  */)fullpath, (char const   */* __restrict  */)"r");
  }
#line 169
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 170
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[ERROR] Could not read data file: %s\n",
            fullpath);
    }
#line 171
    return ((card_mac_list_item_t *)((void *)0));
  }
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 175
    line = fgets((char */* __restrict  */)(tmp), 511, (FILE */* __restrict  */)f);
    }
#line 175
    if (! ((unsigned long )line != (unsigned long )((void *)0))) {
#line 175
      goto while_break;
    }
#line 175
    num ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 176
  rewind(f);
#line 179
  tmp___0 = malloc(sizeof(card_mac_list_item_t ) * (unsigned long )(num + 1));
#line 179
  list = (card_mac_list_item_t *)tmp___0;
#line 182
  num = 0;
  }
  {
#line 183
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 183
    line = fgets((char */* __restrict  */)(tmp), 511, (FILE */* __restrict  */)f);
    }
#line 183
    if (! ((unsigned long )line != (unsigned long )((void *)0))) {
#line 183
      goto while_break___0;
    }
    {
#line 184
    tmp___1 = strtoul((char const   */* __restrict  */)line, (char **/* __restrict  */)((void *)0),
                      16);
#line 184
    (list + num)->byte[0] = (unsigned char )((char )(tmp___1 & 255UL));
#line 185
    tmp___2 = strtoul((char const   */* __restrict  */)(line + 3), (char **/* __restrict  */)((void *)0),
                      16);
#line 185
    (list + num)->byte[1] = (unsigned char )((char )(tmp___2 & 255UL));
#line 186
    tmp___3 = strtoul((char const   */* __restrict  */)(line + 6), (char **/* __restrict  */)((void *)0),
                      16);
#line 186
    (list + num)->byte[2] = (unsigned char )((char )(tmp___3 & 255UL));
#line 188
    tmp___4 = strlen((char const   *)line);
#line 188
    *(line + (tmp___4 - 1UL)) = (char )'\000';
#line 189
    tmp___5 = strdup((char const   *)(line + 9));
#line 189
    (list + num)->name = tmp___5;
#line 191
    num ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 195
  tmp___7 = (unsigned char)0;
#line 195
  (list + num)->byte[2] = tmp___7;
#line 195
  tmp___6 = tmp___7;
#line 195
  (list + num)->byte[1] = tmp___6;
#line 195
  (list + num)->byte[0] = tmp___6;
#line 196
  (list + num)->name = (char *)((void *)0);
#line 198
  fclose(f);
#line 200
  *list_len = num;
  }
#line 201
  return (list);
}
}
#line 205 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/maclist.c"
int mc_maclist_init(void) 
{ 
  int tmp ;

  {
  {
#line 208
  list_others = mc_maclist_read_from_file("/usr/local/share/macchanger/OUI.list",
                                          & list_others_len);
#line 209
  list_wireless = mc_maclist_read_from_file("/usr/local/share/macchanger/wireless.list",
                                            & list_wireless_len);
  }
#line 211
  if (list_others) {
#line 211
    if (list_wireless) {
#line 211
      tmp = 0;
    } else {
#line 211
      tmp = -1;
    }
  } else {
#line 211
    tmp = -1;
  }
#line 211
  return (tmp);
}
}
#line 215 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/maclist.c"
static void free_list(card_mac_list_item_t *list ) 
{ 
  int i ;

  {
#line 218
  i = 0;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! (list + i)->name) {
#line 219
      goto while_break;
    }
    {
#line 220
    free((void *)(list + i)->name);
#line 221
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 223
  free((void *)list);
  }
#line 224
  return;
}
}
#line 227 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/maclist.c"
void mc_maclist_free(void) 
{ 


  {
  {
#line 230
  free_list(list_others);
#line 231
  free_list(list_wireless);
  }
#line 232
  return;
}
}
#line 846 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 38 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/netinfo.c"
net_info_t *mc_net_info_new(char const   *device ) 
{ 
  net_info_t *new ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 41
  tmp = malloc(sizeof(net_info_t ));
#line 41
  new = (net_info_t *)tmp;
#line 43
  new->sock = socket(2, 2, 0);
  }
#line 44
  if (new->sock < 0) {
    {
#line 45
    perror("[ERROR] Socket");
#line 46
    free((void *)new);
    }
#line 47
    return ((net_info_t *)((void *)0));
  }
  {
#line 50
  strncpy((char */* __restrict  */)(new->dev.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)device,
          sizeof(new->dev.ifr_ifrn.ifrn_name));
#line 51
  new->dev.ifr_ifrn.ifrn_name[sizeof(new->dev.ifr_ifrn.ifrn_name) - 1UL] = (char )'\000';
#line 52
  tmp___0 = ioctl(new->sock, 35111UL, & new->dev);
  }
#line 52
  if (tmp___0 < 0) {
    {
#line 53
    perror("[ERROR] Set device name");
#line 54
    free((void *)new);
    }
#line 55
    return ((net_info_t *)((void *)0));
  }
#line 58
  return (new);
}
}
#line 62 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/netinfo.c"
void mc_net_info_free(net_info_t *net ) 
{ 


  {
  {
#line 65
  close(net->sock);
#line 66
  free((void *)net);
  }
#line 67
  return;
}
}
#line 70 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/netinfo.c"
mac_t *mc_net_info_get_mac(net_info_t const   *net ) 
{ 
  int i ;
  mac_t *new ;
  void *tmp ;

  {
  {
#line 74
  tmp = malloc(sizeof(mac_t ));
#line 74
  new = (mac_t *)tmp;
#line 76
  i = 0;
  }
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! (i < 6)) {
#line 76
      goto while_break;
    }
#line 77
    new->byte[i] = (unsigned char )((int )net->dev.ifr_ifru.ifru_hwaddr.sa_data[i] & 255);
#line 76
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  return (new);
}
}
#line 84 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/netinfo.c"
int mc_net_info_set_mac(net_info_t *net , mac_t const   *mac ) 
{ 
  int i ;
  int tmp ;

  {
#line 89
  i = 0;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! (i < 6)) {
#line 89
      goto while_break;
    }
#line 90
    net->dev.ifr_ifru.ifru_hwaddr.sa_data[i] = (char )mac->byte[i];
#line 89
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 93
  tmp = ioctl(net->sock, 35108UL, & net->dev);
  }
#line 93
  if (tmp < 0) {
    {
#line 94
    perror("[ERROR] Could not change MAC: interface up or insufficient permissions");
    }
#line 95
    return (-1);
  }
#line 98
  return (0);
}
}
#line 101 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/netinfo.c"
mac_t *mc_net_info_get_permanent_mac(net_info_t const   *net ) 
{ 
  int i ;
  struct ifreq req ;
  struct ethtool_perm_addr *epa ;
  mac_t *newmac ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 109
  tmp = calloc((size_t )1, sizeof(mac_t ));
#line 109
  newmac = (mac_t *)tmp;
#line 111
  tmp___0 = malloc(sizeof(struct ethtool_perm_addr ) + 6UL);
#line 111
  epa = (struct ethtool_perm_addr *)tmp___0;
#line 112
  epa->cmd = (__u32 )32;
#line 113
  epa->size = (__u32 )6;
#line 115
  memcpy((void */* __restrict  */)(& req), (void const   */* __restrict  */)(& net->dev),
         sizeof(struct ifreq ));
#line 116
  req.ifr_ifru.ifru_data = (caddr_t )epa;
#line 118
  tmp___1 = ioctl((int )net->sock, 35142UL, & req);
  }
#line 118
  if (tmp___1 < 0) {
    {
#line 119
    perror("[ERROR] Could not read permanent MAC");
    }
  } else {
#line 121
    i = 0;
    {
#line 121
    while (1) {
      while_continue: /* CIL Label */ ;
#line 121
      if (! (i < 6)) {
#line 121
        goto while_break;
      }
#line 122
      newmac->byte[i] = epa->data[i];
#line 121
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 126
  free((void *)epa);
  }
#line 127
  return (newmac);
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 34 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/mac.c"
mac_t *mc_mac_dup(mac_t const   *mac ) 
{ 
  mac_t *new ;
  void *tmp ;

  {
  {
#line 39
  tmp = malloc(sizeof(mac_t ));
#line 39
  new = (mac_t *)tmp;
#line 40
  memcpy((void */* __restrict  */)new, (void const   */* __restrict  */)mac, sizeof(mac_t ));
  }
#line 41
  return (new);
}
}
#line 44 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/mac.c"
void mc_mac_copy(mac_t const   *src_mac , mac_t *dst_mac ) 
{ 
  int i ;

  {
#line 47
  i = 0;
#line 48
  i = 0;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (i < 6)) {
#line 48
      goto while_break;
    }
#line 49
    dst_mac->byte[i] = src_mac->byte[i];
#line 48
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return;
}
}
#line 52 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/mac.c"
void mc_mac_free(mac_t *mac ) 
{ 


  {
  {
#line 55
  free((void *)mac);
  }
#line 56
  return;
}
}
#line 59 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/mac.c"
void mc_mac_into_string(mac_t const   *mac , char *s ) 
{ 
  int i ;
  char const   *tmp ;

  {
#line 64
  i = 0;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! (i < 6)) {
#line 64
      goto while_break;
    }
#line 65
    if (i < 5) {
#line 65
      tmp = ":";
    } else {
#line 65
      tmp = "";
    }
    {
#line 65
    sprintf((char */* __restrict  */)(s + i * 3), (char const   */* __restrict  */)"%02x%s",
            (int )mac->byte[i], tmp);
#line 64
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 67
  return;
}
}
#line 70 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/mac.c"
void mc_mac_random(mac_t *mac , unsigned char last_n_bytes , char set_bia ) 
{ 
  mac_t newmac ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;

  {
  {
#line 79
  mc_mac_copy((mac_t const   *)mac, & newmac);
  }
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 83
    if ((int )last_n_bytes == 6) {
#line 83
      goto case_6;
    }
#line 90
    if ((int )last_n_bytes == 3) {
#line 90
      goto case_3;
    }
#line 82
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 87
    tmp = random();
#line 87
    mac->byte[0] = (unsigned char )(tmp % 255L & 252L);
#line 88
    tmp___0 = random();
#line 88
    mac->byte[1] = (unsigned char )(tmp___0 % 255L);
#line 89
    tmp___1 = random();
#line 89
    mac->byte[2] = (unsigned char )(tmp___1 % 255L);
    }
    case_3: /* CIL Label */ 
    {
#line 91
    tmp___2 = random();
#line 91
    mac->byte[3] = (unsigned char )(tmp___2 % 255L);
#line 92
    tmp___3 = random();
#line 92
    mac->byte[4] = (unsigned char )(tmp___3 % 255L);
#line 93
    tmp___4 = random();
#line 93
    mac->byte[5] = (unsigned char )(tmp___4 % 255L);
    }
    switch_break: /* CIL Label */ ;
    }
#line 98
    if (set_bia) {
#line 99
      mac->byte[0] = (unsigned char )((int )mac->byte[0] & -3);
    } else {
#line 101
      mac->byte[0] = (unsigned char )((int )mac->byte[0] | 2);
    }
    {
#line 81
    tmp___5 = mc_mac_equal((mac_t const   *)(& newmac), (mac_t const   *)mac);
    }
#line 81
    if (! tmp___5) {
#line 81
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 105
  mc_mac_copy((mac_t const   *)(& newmac), mac);
  }
#line 106
  return;
}
}
#line 109 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/mac.c"
int mc_mac_equal(mac_t const   *mac1 , mac_t const   *mac2 ) 
{ 
  int i ;

  {
#line 114
  i = 0;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! (i < 6)) {
#line 114
      goto while_break;
    }
#line 115
    if ((int )mac1->byte[i] != (int )mac2->byte[i]) {
#line 116
      return (0);
    }
#line 114
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  return (1);
}
}
#line 123 "/home/wheatley/newnew/temp/macchanger-1.7.0/src/mac.c"
int mc_mac_read_string(mac_t *mac , char *string ) 
{ 
  int nbyte ;
  size_t tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;

  {
  {
#line 126
  nbyte = 5;
#line 129
  tmp___0 = strlen((char const   *)string);
  }
#line 129
  if (tmp___0 != 17UL) {
    {
#line 130
    tmp = strlen((char const   *)string);
#line 130
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[ERROR] Incorrect format: MAC length should be 17. %s(%lu)\n",
            string, tmp);
    }
#line 131
    return (-1);
  }
#line 134
  nbyte = 2;
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (! (nbyte < 16)) {
#line 134
      goto while_break;
    }
#line 135
    if ((int )*(string + nbyte) != 58) {
      {
#line 136
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[ERROR] Incorrect format: %s\n",
              string);
      }
#line 137
      return (-1);
    }
#line 134
    nbyte += 3;
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  nbyte = 0;
  {
#line 142
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 142
    if (! (nbyte < 6)) {
#line 142
      goto while_break___0;
    }
    {
#line 143
    tmp___1 = strtoul((char const   */* __restrict  */)(string + nbyte * 3), (char **/* __restrict  */)0,
                      16);
#line 143
    mac->byte[nbyte] = (unsigned char )((char )(tmp___1 & 255UL));
#line 142
    nbyte ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 146
  return (0);
}
}
