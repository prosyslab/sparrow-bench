/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 61 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/ipip.h"
struct interface {
   int type ;
   int status ;
   char *id ;
   char *devname ;
   int unit ;
   int fd ;
   char *private ;
   int (*ifopen)() ;
   int (*ifread)() ;
   int (*ifsend)() ;
   long in ;
   long out ;
   long out_overruns ;
   long martians_in ;
   long looped_in ;
   long bogus_in ;
};
#line 110 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/ipip.h"
struct ipip_route {
   unsigned long ipaddr ;
   unsigned long mask ;
   struct interface *destif ;
   unsigned long destaddr ;
   unsigned short destport ;
   long hits ;
};
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_6 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_6 __sigset_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 34 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 48 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 92 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag sigjmp_buf[1];
#line 96 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/ipip.h"
struct message {
   int length ;
   struct interface *from_if ;
   struct interface *to_if ;
   unsigned long fip ;
   unsigned long tip ;
   unsigned short fport ;
   unsigned short tport ;
   unsigned char msg[2048] ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 77 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/slip.c"
struct slippy {
   unsigned char buffer[2048] ;
   int bcount ;
   int bnext ;
   unsigned char ipacket[2048] ;
   int ifcount ;
   int iescaped ;
};
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned char u_int8_t;
#line 201 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short u_int16_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 44 "/usr/include/netinet/ip.h"
struct iphdr {
   unsigned int ihl : 4 ;
   unsigned int version : 4 ;
   u_int8_t tos ;
   u_int16_t tot_len ;
   u_int16_t id ;
   u_int16_t frag_off ;
   u_int8_t ttl ;
   u_int8_t protocol ;
   u_int16_t check ;
   u_int32_t saddr ;
   u_int32_t daddr ;
};
#line 51 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/ipip.h"
int debugd  ;
#line 52 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/ipip.h"
int debugt  ;
#line 53 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/ipip.h"
char progname[32]  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/ipip.h"
int no_timestamp  ;
#line 55 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/ipip.h"
int stat_interval  ;
#line 125 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/ipip.h"
struct ipip_route rts[1024]  ;
#line 129 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/ipip.h"
int rts_top  ;
#line 131 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/ipip.h"
struct interface ifs[8]  ;
#line 132 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/ipip.h"
int ifs_top  ;
#line 195
int read_routes(char *f ) ;
#line 198
int read_config(char *f ) ;
#line 201
void send_stats(int force ) ;
#line 202
int run_it(void) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 59 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int __sigsetjmp(struct __jmp_buf_tag *__env ,
                                                     int __savemask ) ;
#line 63
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
#line 74
extern  __attribute__((__nothrow__, __noreturn__)) void longjmp(struct __jmp_buf_tag *__env ,
                                                                int __val ) ;
#line 102
extern  __attribute__((__nothrow__, __noreturn__)) void siglongjmp(struct __jmp_buf_tag *__env ,
                                                                   int __val ) ;
#line 175 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/main.c"
sigjmp_buf restart_env  ;
#line 32
static void hupper(int sig ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/main.c"
jmp_buf term_env  ;
#line 34
static void terminator(void) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/main.c"
char *configfile  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/main.c"
char *routefile  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/main.c"
int version_only  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/main.c"
void main(int argc , char **argv ) 
{ 
  int n ;
  int i ;
  int oops ;
  int help ;
  time_t now ;
  FILE *pid_file ;
  __pid_t tmp ;
  __pid_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  {
#line 48
  debugd = 0;
#line 49
  debugt = 0;
#line 50
  help = 0;
#line 51
  no_timestamp = 0;
#line 52
  version_only = 0;
#line 53
  routefile = (char *)"/etc/ipip/routes";
#line 54
  configfile = (char *)"/etc/ipip/config";
#line 55
  stat_interval = -1;
#line 58
  openlog("ipip", 17, 16 << 3);
#line 60
  tmp = getpid();
#line 60
  sprintf((char */* __restrict  */)(progname), (char const   */* __restrict  */)"ipip[%d]: ",
          tmp);
#line 63
  pid_file = fopen((char const   */* __restrict  */)"/var/run/ipip.pid", (char const   */* __restrict  */)"w");
  }
#line 63
  if (! pid_file) {
    {
#line 64
    syslog(2, "could not log pid to file %s", "/var/run/ipip.pid");
#line 65
    exit(1);
    }
  }
  {
#line 67
  tmp___0 = getpid();
#line 67
  fprintf((FILE */* __restrict  */)pid_file, (char const   */* __restrict  */)"%d\n",
          tmp___0);
#line 68
  fclose(pid_file);
#line 71
  oops = 0;
#line 72
  i = 1;
  }
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 72
    if (i < argc) {
#line 72
      if (! (oops == 0)) {
#line 72
        goto while_break;
      }
    } else {
#line 72
      goto while_break;
    }
    {
#line 73
    tmp___10 = strcmp((char const   *)*(argv + i), "-c");
    }
#line 73
    if (tmp___10 == 0) {
#line 74
      i ++;
#line 75
      if (i < argc) {
#line 75
        configfile = *(argv + i);
      } else {
#line 76
        oops ++;
      }
    } else {
      {
#line 77
      tmp___9 = strcmp((char const   *)*(argv + i), "-r");
      }
#line 77
      if (tmp___9 == 0) {
#line 78
        i ++;
#line 79
        if (i < argc) {
#line 79
          routefile = *(argv + i);
        } else {
#line 80
          oops ++;
        }
      } else {
        {
#line 81
        tmp___8 = strcmp((char const   *)*(argv + i), "-s");
        }
#line 81
        if (tmp___8 == 0) {
#line 82
          i ++;
#line 83
          if (i < argc) {
            {
#line 83
            tmp___1 = atoi((char const   *)*(argv + i));
#line 83
            stat_interval = tmp___1 * 60;
            }
          } else {
#line 84
            oops ++;
          }
        } else {
          {
#line 85
          tmp___7 = strcmp((char const   *)*(argv + i), "-d");
          }
#line 85
          if (tmp___7 == 0) {
#line 86
            debugd ++;
          } else {
            {
#line 87
            tmp___6 = strcmp((char const   *)*(argv + i), "-t");
            }
#line 87
            if (tmp___6 == 0) {
#line 88
              debugt ++;
            } else {
              {
#line 89
              tmp___5 = strcmp((char const   *)*(argv + i), "-v");
              }
#line 89
              if (tmp___5 == 0) {
#line 90
                version_only ++;
              } else {
                {
#line 91
                tmp___4 = strcmp((char const   *)*(argv + i), "-np");
                }
#line 91
                if (tmp___4 == 0) {
#line 92
                  progname[0] = (char )'\000';
                } else {
                  {
#line 93
                  tmp___3 = strcmp((char const   *)*(argv + i), "-nts");
                  }
#line 93
                  if (tmp___3 == 0) {
#line 94
                    no_timestamp ++;
                  } else {
                    {
#line 95
                    tmp___2 = strcmp((char const   *)*(argv + i), "-help");
                    }
#line 95
                    if (tmp___2 == 0) {
#line 96
                      help ++;
                    } else {
#line 97
                      oops ++;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 72
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 100
  if (oops) {
    {
#line 101
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%sUsage: %s [-help] [-c <configfile>] [-r <routefile>] [-s <minutes>] [-np] [-nts] [-t] [-d] [-v]\n",
            progname, *(argv + 0));
#line 103
    printf((char const   */* __restrict  */)"%sexit (syntax error)\n", progname);
#line 104
    exit(1);
    }
  }
#line 107
  if (help) {
    {
#line 108
    printf((char const   */* __restrict  */)"%s Options are:\n", progname);
#line 109
    printf((char const   */* __restrict  */)"%s  -help      Print this summary of options\n",
           progname);
#line 111
    printf((char const   */* __restrict  */)"%s  -v         Print just the version number and exit\n",
           progname);
#line 113
    printf((char const   */* __restrict  */)"%s  -c file    Use the supplied filename as the config file\n",
           progname);
#line 115
    printf((char const   */* __restrict  */)"%s  -r file    Use the supplied filename as the route file\n",
           progname);
#line 117
    printf((char const   */* __restrict  */)"%s  -s n       Report statistics every n minutes\n",
           progname);
#line 119
    printf((char const   */* __restrict  */)"%s  -np        Don\'t print the ipip[1234]: prefix\n",
           progname);
#line 121
    printf((char const   */* __restrict  */)"%s  -nts       Don\'t include a timestamp in the statistics\n",
           progname);
#line 123
    printf((char const   */* __restrict  */)"%s  -t         Turn on tracing of incoming packets\n",
           progname);
#line 125
    printf((char const   */* __restrict  */)"%s  -d         Print out some debugging information\n",
           progname);
#line 127
    exit(0);
    }
  }
  {
#line 140
  tmp___11 = _setjmp((struct __jmp_buf_tag *)(term_env));
  }
#line 140
  if (tmp___11 != 0) {
    {
#line 141
    send_stats(1);
#line 142
    now = time((time_t *)((void *)0));
#line 143
    syslog(2, "exit (killed)");
#line 144
    exit(0);
    }
  }
  {
#line 147
  signal(15, (void (*)(int  ))(& terminator));
#line 148
  signal(2, (void (*)(int  ))(& terminator));
#line 151
  syslog(7, "version %s Copyright 1991, Michael Westerhof.", "1.1.0");
  }
#line 153
  if (version_only != 0) {
    {
#line 153
    exit(0);
    }
  }
  {
#line 157
  tmp___12 = read_config(configfile);
  }
#line 157
  if (tmp___12 < 0) {
    {
#line 158
    syslog(2, "exit (config file error)");
#line 159
    exit(1);
    }
  }
  {
#line 164
  tmp___13 = __sigsetjmp((struct __jmp_buf_tag *)(restart_env), 1);
  }
#line 164
  if (tmp___13 == 0) {
    {
#line 168
    signal(1, & hupper);
    }
  }
  {
#line 173
  closelog();
#line 174
  openlog("ipip", 17, 16 << 3);
#line 178
  tmp___14 = read_routes(routefile);
  }
#line 178
  if (tmp___14 < 0) {
    {
#line 179
    syslog(2, "exit (routes file error)");
#line 180
    exit(1);
    }
  }
  {
#line 188
  n = run_it();
  }
#line 189
  if (n < 0) {
    {
#line 190
    syslog(2, "exit (I/O error)");
#line 191
    exit(1);
    }
  }
  {
#line 195
  send_stats(1);
#line 196
  syslog(2, "exit (no error code?)");
#line 197
  exit(0);
  }
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/main.c"
static void hupper(int sig ) 
{ 


  {
  {
#line 203
  syslog(7, "SIGHUP received");
#line 205
  siglongjmp((struct __jmp_buf_tag *)(restart_env), 1);
  }
}
}
#line 211 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/main.c"
static void terminator(void) 
{ 


  {
  {
#line 214
  longjmp((struct __jmp_buf_tag *)(term_env), 1);
  }
}
}
#line 180 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/ipip.h"
int slip_open(struct interface *ifp ) ;
#line 181
int slip_send(struct interface *ifp , struct message *m ) ;
#line 182
int slip_read(struct interface *ifp , struct message *m ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 146
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 38 "/usr/include/malloc.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 66 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 76 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/slip.c"
static int assemble_slip(struct slippy *s , unsigned char c ) ;
#line 91 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/slip.c"
int slip_open(struct interface *ifp ) 
{ 
  int baudrate ;
  struct termios nterm ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 105
  if ((unsigned long )ifp == (unsigned long )((void *)0)) {
    {
#line 105
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%sInternal error: NULL interface passed to %s driver\n",
            progname, "slip");
    }
#line 105
    return (-1);
  }
#line 106
  if (ifp->type != 3) {
    {
#line 106
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%sInternal error: incorrect interface type passed to %s driver\n",
            progname, "slip");
    }
#line 106
    return (-1);
  }
#line 108
  if (ifp->status & 1) {
#line 108
    return (1);
  }
  {
#line 115
  ifp->fd = open((char const   *)ifp->devname, 2);
  }
#line 117
  if (ifp->fd < 0) {
    {
#line 118
    syslog(3, (char const   *)ifp->devname);
    }
#line 119
    return (-1);
  }
  {
#line 122
  tmp = fcntl(ifp->fd, 4, 2048);
  }
#line 122
  if (tmp < 0) {
    {
#line 123
    syslog(3, "setting non-blocking I/O on tty device");
    }
#line 124
    return (-1);
  }
  {
#line 129
  tmp___0 = tcgetattr(ifp->fd, & nterm);
  }
#line 129
  if (tmp___0 < 0) {
    {
#line 140
    syslog(3, "fetching tty device parameters");
    }
#line 141
    return (-1);
  }
#line 144
  if (ifp->unit == 50) {
#line 144
    baudrate = 1;
  } else
#line 145
  if (ifp->unit == 50) {
#line 145
    baudrate = 1;
  } else
#line 146
  if (ifp->unit == 75) {
#line 146
    baudrate = 2;
  } else
#line 147
  if (ifp->unit == 110) {
#line 147
    baudrate = 3;
  } else
#line 148
  if (ifp->unit == 134) {
#line 148
    baudrate = 4;
  } else
#line 149
  if (ifp->unit == 150) {
#line 149
    baudrate = 5;
  } else
#line 150
  if (ifp->unit == 200) {
#line 150
    baudrate = 6;
  } else
#line 151
  if (ifp->unit == 300) {
#line 151
    baudrate = 7;
  } else
#line 152
  if (ifp->unit == 600) {
#line 152
    baudrate = 8;
  } else
#line 153
  if (ifp->unit == 1200) {
#line 153
    baudrate = 9;
  } else
#line 154
  if (ifp->unit == 1800) {
#line 154
    baudrate = 10;
  } else
#line 155
  if (ifp->unit == 2400) {
#line 155
    baudrate = 11;
  } else
#line 156
  if (ifp->unit == 4800) {
#line 156
    baudrate = 12;
  } else
#line 157
  if (ifp->unit == 9600) {
#line 157
    baudrate = 13;
  } else
#line 159
  if (ifp->unit == 19200) {
#line 159
    baudrate = 14;
  } else
#line 166
  if (ifp->unit == 38400) {
#line 166
    baudrate = 15;
  } else {
#line 172
    baudrate = 13;
  }
  {
#line 179
  nterm.c_iflag = (tcflag_t )0;
#line 180
  nterm.c_oflag = (tcflag_t )0;
#line 181
  nterm.c_cflag = (tcflag_t )(((baudrate | 48) | 128) | 2048);
#line 182
  nterm.c_lflag = (tcflag_t )0;
#line 183
  nterm.c_cc[6] = (cc_t )0;
#line 184
  nterm.c_cc[5] = (cc_t )0;
#line 189
  tmp___1 = tcsetattr(ifp->fd, 0, (struct termios  const  *)(& nterm));
  }
#line 189
  if (tmp___1 < 0) {
    {
#line 200
    syslog(3, "setting tty device parameters");
    }
#line 201
    return (-1);
  }
#line 204
  if ((unsigned long )ifp->private == (unsigned long )((void *)0)) {
    {
#line 204
    tmp___2 = malloc(sizeof(struct slippy ));
#line 204
    ifp->private = (char *)tmp___2;
    }
  }
#line 205
  if ((unsigned long )ifp->private == (unsigned long )((void *)0)) {
    {
#line 206
    syslog(3, "cannot allocate private data structure (slip)");
    }
#line 207
    return (-1);
  }
  {
#line 210
  memset((void *)ifp->private, 0, sizeof(struct slippy ));
#line 212
  ifp->status = 1;
  }
#line 213
  return (1);
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/slip.c"
int slip_read(struct interface *ifp , struct message *m ) 
{ 
  int n ;
  struct slippy *s ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 229
  if ((unsigned long )ifp == (unsigned long )((void *)0)) {
    {
#line 229
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%sInternal error: NULL interface passed to %s driver\n",
            progname, "slip");
    }
#line 229
    return (-1);
  }
#line 230
  if (ifp->type != 3) {
    {
#line 230
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%sInternal error: incorrect interface type passed to %s driver\n",
            progname, "slip");
    }
#line 230
    return (-1);
  }
#line 231
  if ((ifp->status & 1) == 0) {
    {
#line 231
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%sInternal error: interface has not been opened (%s driver)\n",
            progname, "slip");
    }
#line 231
    return (-1);
  }
#line 232
  if ((unsigned long )m == (unsigned long )((void *)0)) {
    {
#line 232
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%sInternal error: NULL message buffer passed to %s driver\n",
            progname, "slip");
    }
#line 232
    return (-1);
  }
#line 234
  s = (struct slippy *)ifp->private;
#line 235
  ifp->status &= -3;
#line 236
  m->length = 0;
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 239
    if (s->bnext >= s->bcount) {
      {
#line 240
      s->bnext = 0;
#line 241
      s->bcount = 0;
#line 242
      tmp = read(ifp->fd, (void *)((char *)(s->buffer)), (size_t )2048);
#line 242
      n = (int )tmp;
      }
#line 243
      if (n == 0) {
#line 243
        return (0);
      }
#line 244
      if (n < 0) {
        {
#line 245
        tmp___0 = __errno_location();
        }
#line 245
        if (*tmp___0 == 4) {
#line 245
          return (0);
        }
        {
#line 246
        tmp___1 = __errno_location();
        }
#line 246
        if (*tmp___1 == 11) {
#line 246
          return (0);
        }
        {
#line 247
        syslog(3, "read from tty device");
        }
#line 248
        return (-1);
      }
#line 250
      s->bcount = n;
    }
    {
#line 253
    n = assemble_slip(s, (int )s->buffer[s->bnext]);
#line 254
    (s->bnext) ++;
    }
#line 256
    if (n > 0) {
      {
#line 257
      memcpy((void */* __restrict  */)((char *)(m->msg)), (void const   */* __restrict  */)((char *)(s->ipacket)),
             (size_t )n);
#line 258
      m->length = n;
      }
#line 259
      if (s->bnext < s->bcount) {
#line 260
        ifp->status |= 2;
      }
#line 261
      return (n);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/slip.c"
int slip_send(struct interface *ifp , struct message *m ) 
{ 
  int n ;
  int i ;
  int ofcount ;
  unsigned char opacket[4096] ;
  unsigned char *ofptr ;
  unsigned char *mptr ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 282
  if ((unsigned long )ifp == (unsigned long )((void *)0)) {
    {
#line 282
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%sInternal error: NULL interface passed to %s driver\n",
            progname, "slip");
    }
#line 282
    return (-1);
  }
#line 283
  if (ifp->type != 3) {
    {
#line 283
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%sInternal error: incorrect interface type passed to %s driver\n",
            progname, "slip");
    }
#line 283
    return (-1);
  }
#line 284
  if ((ifp->status & 1) == 0) {
    {
#line 284
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%sInternal error: interface has not been opened (%s driver)\n",
            progname, "slip");
    }
#line 284
    return (-1);
  }
#line 285
  if ((unsigned long )m == (unsigned long )((void *)0)) {
    {
#line 285
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%sInternal error: NULL message buffer passed to %s driver\n",
            progname, "slip");
    }
#line 285
    return (-1);
  }
#line 287
  if (m->length <= 0) {
#line 287
    return (0);
  }
#line 289
  ofptr = opacket;
#line 290
  ofcount = 0;
#line 291
  mptr = m->msg;
#line 293
  if (ofcount < 4096) {
#line 293
    *ofptr = (unsigned char)192;
#line 293
    ofptr ++;
#line 293
    ofcount ++;
  }
#line 295
  i = 0;
  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 295
    if (! (i < m->length)) {
#line 295
      goto while_break;
    }
#line 296
    if ((int )*mptr == 192) {
#line 297
      if (ofcount < 4096) {
#line 297
        *ofptr = (unsigned char)219;
#line 297
        ofptr ++;
#line 297
        ofcount ++;
      }
#line 298
      if (ofcount < 4096) {
#line 298
        *ofptr = (unsigned char)220;
#line 298
        ofptr ++;
#line 298
        ofcount ++;
      }
    } else
#line 299
    if ((int )*mptr == 219) {
#line 300
      if (ofcount < 4096) {
#line 300
        *ofptr = (unsigned char)219;
#line 300
        ofptr ++;
#line 300
        ofcount ++;
      }
#line 301
      if (ofcount < 4096) {
#line 301
        *ofptr = (unsigned char)221;
#line 301
        ofptr ++;
#line 301
        ofcount ++;
      }
    } else
#line 303
    if (ofcount < 4096) {
#line 303
      *ofptr = *mptr;
#line 303
      ofptr ++;
#line 303
      ofcount ++;
    }
#line 295
    i ++;
#line 295
    mptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 307
  if (ofcount < 4096) {
#line 307
    *ofptr = (unsigned char)192;
#line 307
    ofptr ++;
#line 307
    ofcount ++;
  }
  {
#line 319
  tmp = write(ifp->fd, (void const   *)((char *)(opacket)), (size_t )ofcount);
#line 319
  n = (int )tmp;
  }
#line 320
  if (n < 0) {
    {
#line 321
    tmp___0 = __errno_location();
#line 321
    tmp___1 = strerror(*tmp___0);
#line 321
    syslog(3, "slip_send(): %s", tmp___1);
#line 322
    tmp___2 = __errno_location();
    }
#line 322
    if (*tmp___2 == 4) {
#line 322
      return (0);
    } else {
      {
#line 322
      tmp___3 = __errno_location();
      }
#line 322
      if (*tmp___3 == 11) {
#line 322
        return (0);
      }
    }
#line 323
    return (-1);
  }
#line 325
  if (n < ofcount) {
#line 325
    (ifp->out_overruns) ++;
  }
#line 326
  return (n);
}
}
#line 336 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/slip.c"
static int assemble_slip(struct slippy *s , unsigned char c ) 
{ 
  int n ;

  {
#line 343
  if ((int )c == 192) {
#line 344
    n = s->ifcount;
#line 345
    s->ifcount = 0;
#line 346
    s->iescaped = 0;
#line 347
    return (n);
  }
#line 350
  if ((int )c == 219) {
#line 351
    s->iescaped = 1;
#line 352
    return (0);
  }
#line 355
  if (s->iescaped) {
#line 356
    if ((int )c == 220) {
#line 356
      c = (unsigned char)192;
    }
#line 357
    if ((int )c == 221) {
#line 357
      c = (unsigned char)219;
    }
#line 358
    s->iescaped = 0;
  }
#line 360
  if (s->ifcount < 2048) {
#line 361
    s->ipacket[s->ifcount] = c;
#line 362
    (s->ifcount) ++;
  }
#line 364
  return (0);
}
}
#line 243 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/run.c"
static int handle(struct interface *ifp ) ;
#line 30
static int find_route(struct message *m ) ;
#line 31
static void tracer(struct message *m ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/run.c"
int martian_count  =    3;
#line 34 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/run.c"
unsigned int martians[3]  = {      2130706433U,      4294967295U,      0U};
#line 36 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/run.c"
time_t last_send  ;
#line 51 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/run.c"
int run_it(void) 
{ 
  int i ;
  int j ;
  int nb ;
  int more_io ;
  int checker ;
  fd_set readfds ;
  struct timeval wait ;
  int __d0 ;
  int __d1 ;
  int *tmp ;
  int tmp___0 ;

  {
#line 58
  i = 0;
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! (i < ifs_top)) {
#line 58
      goto while_break;
    }
#line 59
    if (ifs[i].type == 0) {
#line 59
      goto __Cont;
    }
#line 60
    if (debugd) {
      {
#line 61
      syslog(7, "opening interface %s", ifs[i].id);
      }
    }
    {
#line 62
    j = (*(ifs[i].ifopen))(& ifs[i]);
    }
#line 63
    if (j < 0) {
#line 63
      return (j);
    }
    __Cont: /* CIL Label */ 
#line 58
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 66
  if (debugd) {
    {
#line 67
    syslog(7, "initialization complete");
    }
  }
  {
#line 69
  last_send = time((time_t *)((void *)0));
#line 70
  checker = 0;
  }
  {
#line 72
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 74
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 74
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& readfds.__fds_bits[0]): "memory");
#line 74
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 76
    more_io = 0;
#line 78
    i = 0;
    {
#line 78
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 78
      if (! (i < ifs_top)) {
#line 78
        goto while_break___2;
      }
#line 79
      if (ifs[i].type != 0) {
#line 79
        if (ifs[i].status & 1) {
#line 81
          readfds.__fds_bits[ifs[i].fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ifs[i].fd % (8 * (int )sizeof(__fd_mask ));
#line 82
          if (ifs[i].status & 2) {
#line 82
            more_io ++;
          }
        }
      }
#line 78
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 86
    if (more_io) {
#line 87
      wait.tv_sec = (__time_t )0;
#line 88
      wait.tv_usec = (__suseconds_t )10000;
    } else {
#line 90
      wait.tv_sec = (__time_t )10;
#line 91
      wait.tv_usec = (__suseconds_t )0;
#line 92
      checker = 0;
    }
    {
#line 95
    nb = select(1024, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)((fd_set *)0),
                (fd_set */* __restrict  */)((fd_set *)0), (struct timeval */* __restrict  */)(& wait));
    }
#line 97
    if (nb < 0) {
      {
#line 98
      tmp = __errno_location();
      }
#line 98
      if (*tmp == 4) {
#line 98
        goto __Cont___0;
      }
      {
#line 99
      syslog(3, "select in run_it()");
      }
#line 100
      return (-1);
    }
#line 103
    i = 0;
    {
#line 103
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 103
      if (! (i < ifs_top)) {
#line 103
        goto while_break___3;
      }
#line 104
      if (ifs[i].type != 0) {
#line 104
        if (ifs[i].status & 1) {
#line 106
          if ((readfds.__fds_bits[ifs[i].fd / (8 * (int )sizeof(__fd_mask ))] & (1L << ifs[i].fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 106
            goto _L;
          } else
#line 106
          if (ifs[i].status & 2) {
            _L: /* CIL Label */ 
            {
#line 108
            tmp___0 = handle(& ifs[i]);
            }
#line 108
            if (tmp___0 < 0) {
              {
#line 109
              syslog(3, "handle in run_it()");
              }
#line 110
              return (-1);
            }
          }
        }
      }
#line 103
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 116
    if (checker <= 0) {
      {
#line 117
      send_stats(0);
#line 118
      checker = 100;
      }
    } else {
#line 120
      checker --;
    }
    __Cont___0: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/run.c"
static int handle(struct interface *ifp ) 
{ 
  struct message m ;
  int n ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 141
  m.length = 0;
#line 142
  m.from_if = ifp;
#line 143
  m.to_if = (struct interface *)((void *)0);
#line 144
  m.fip = 0UL;
#line 145
  m.tip = 0UL;
#line 146
  m.fport = (unsigned short)0;
#line 147
  m.tport = (unsigned short)0;
#line 149
  n = (*(ifp->ifread))(ifp, & m);
  }
#line 150
  if (n <= 0) {
#line 150
    return (n);
  }
  {
#line 152
  ((m.from_if)->in) ++;
#line 154
  tmp = find_route(& m);
  }
#line 154
  if (tmp < 0) {
    {
#line 155
    syslog(3, "find_route() failed in handle()");
    }
#line 156
    return (-1);
  }
#line 182
  if ((unsigned long )m.from_if == (unsigned long )m.to_if) {
#line 183
    m.to_if = (struct interface *)((void *)0);
#line 184
    ((m.from_if)->looped_in) ++;
  }
#line 188
  if (debugt) {
    {
#line 188
    tracer(& m);
    }
  }
#line 190
  if ((unsigned long )m.to_if == (unsigned long )((void *)0)) {
    {
#line 191
    syslog(3, "route not found in handle()");
    }
#line 192
    return (0);
  }
  {
#line 195
  tmp___0 = (*((m.to_if)->ifsend))(m.to_if, & m);
  }
#line 195
  if (tmp___0 < 0) {
    {
#line 196
    syslog(3, "ifsend() failed in handle()");
    }
#line 197
    return (-1);
  }
#line 199
  ((m.to_if)->out) ++;
#line 201
  return (1);
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/run.c"
static void tracer(struct message *m ) 
{ 
  char *fromid ;
  char *toid ;
  char fbuf[32] ;
  char tbuf[32] ;
  unsigned char *f ;
  unsigned char *t ;
  unsigned char *iphdr ;
  int ftype ;
  int ttype ;
  uint16_t tmp ;
  uint16_t tmp___0 ;

  {
#line 217
  fromid = (m->from_if)->id;
#line 218
  ftype = (m->from_if)->type;
#line 219
  f = (unsigned char *)(& m->fip);
#line 220
  if (ftype == 2) {
    {
#line 221
    tmp = ntohs(m->fport);
#line 221
    sprintf((char */* __restrict  */)(fbuf), (char const   */* __restrict  */)"(%d.%d.%d.%d:%d)",
            (int )*(f + 0), (int )*(f + 1), (int )*(f + 2), (int )*(f + 3), (int )tmp);
    }
  } else
#line 222
  if (ftype == 1) {
    {
#line 223
    sprintf((char */* __restrict  */)(fbuf), (char const   */* __restrict  */)"(%d.%d.%d.%d)",
            (int )*(f + 0), (int )*(f + 1), (int )*(f + 2), (int )*(f + 3));
    }
  } else {
#line 224
    fbuf[0] = (char )'\000';
  }
#line 226
  if (m->to_if) {
#line 227
    toid = (m->to_if)->id;
#line 228
    ttype = (m->to_if)->type;
#line 229
    t = (unsigned char *)(& m->tip);
  } else {
#line 231
    toid = (char *)"BitBucket";
#line 232
    ttype = 0;
#line 233
    t = (unsigned char *)(& m->tip);
  }
#line 235
  if (ttype == 2) {
    {
#line 236
    tmp___0 = ntohs(m->tport);
#line 236
    sprintf((char */* __restrict  */)(tbuf), (char const   */* __restrict  */)"(%d.%d.%d.%d:%d)",
            (int )*(t + 0), (int )*(t + 1), (int )*(t + 2), (int )*(t + 3), (int )tmp___0);
    }
  } else
#line 237
  if (ttype == 1) {
    {
#line 238
    sprintf((char */* __restrict  */)(tbuf), (char const   */* __restrict  */)"(%d.%d.%d.%d)",
            (int )*(t + 0), (int )*(t + 1), (int )*(t + 2), (int )*(t + 3));
    }
  } else {
#line 239
    tbuf[0] = (char )'\000';
  }
  {
#line 241
  iphdr = m->msg;
#line 243
  syslog(7, "%d.%d.%d.%d->%d.%d.%d.%d len %d [%s%s->%s%s]", (int )*(iphdr + 12), (int )*(iphdr + 13),
         (int )*(iphdr + 14), (int )*(iphdr + 15), (int )*(iphdr + 16), (int )*(iphdr + 17),
         (int )*(iphdr + 18), (int )*(iphdr + 19), m->length, fromid, fbuf, toid,
         tbuf);
  }
#line 247
  return;
}
}
#line 255 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/run.c"
static int find_route(struct message *m ) 
{ 
  int i ;
  unsigned int d ;
  uint32_t tmp ;

  {
#line 262
  if ((unsigned long )m == (unsigned long )((void *)0)) {
#line 262
    return (-1);
  }
#line 264
  if (m->length < 20) {
#line 265
    m->to_if = (struct interface *)((void *)0);
#line 266
    return (0);
  }
  {
#line 269
  memcpy((void */* __restrict  */)((char *)(& d)), (void const   */* __restrict  */)((char *)(m->msg) + 16),
         (size_t )4);
#line 271
  i = 0;
  }
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 271
    if (! (i < martian_count)) {
#line 271
      goto while_break;
    }
    {
#line 272
    tmp = htonl(martians[i]);
    }
#line 272
    if (d == tmp) {
#line 273
      ((m->from_if)->martians_in) ++;
#line 274
      m->to_if = (struct interface *)((void *)0);
#line 275
      return (0);
    }
#line 271
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 279
  i = 0;
  {
#line 279
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 279
    if (! (i < rts_top)) {
#line 279
      goto while_break___0;
    }
#line 280
    if ((rts[i].ipaddr & rts[i].mask) == ((unsigned long )d & rts[i].mask)) {
#line 281
      m->to_if = rts[i].destif;
#line 282
      m->tip = rts[i].destaddr;
#line 283
      m->tport = rts[i].destport;
#line 284
      (rts[i].hits) ++;
#line 285
      return (1);
    }
#line 279
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 288
  m->to_if = (struct interface *)((void *)0);
#line 289
  return (0);
}
}
#line 298 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/run.c"
void send_stats(int force ) 
{ 
  int i ;
  time_t now ;
  struct tm *t ;
  char cnow[32] ;

  {
#line 307
  if (stat_interval == 0) {
#line 307
    return;
  }
  {
#line 309
  now = time((time_t *)((void *)0));
  }
#line 311
  if (force == 0) {
#line 312
    if (stat_interval > 0) {
#line 313
      if (now < last_send + (time_t )stat_interval) {
#line 313
        return;
      }
    }
  }
#line 317
  if (no_timestamp) {
#line 318
    cnow[0] = (char )'\000';
  } else {
    {
#line 320
    t = localtime((time_t const   *)(& now));
#line 321
    sprintf((char */* __restrict  */)(cnow), (char const   */* __restrict  */)"%2d/%2d/%2d %2d:%2d:%2d ",
            t->tm_mon + 1, t->tm_mday, t->tm_year, t->tm_hour, t->tm_min, t->tm_sec);
    }
  }
#line 325
  i = 0;
  {
#line 325
  while (1) {
    while_continue: /* CIL Label */ ;
#line 325
    if (! (i < ifs_top)) {
#line 325
      goto while_break;
    }
#line 326
    if (ifs[i].type == 0) {
#line 326
      goto __Cont;
    }
    {
#line 327
    syslog(7, "%s%-4s in %4ld out %4ld baddr %ld loop %ld bogus %ld ovrn %ld\n", cnow,
           ifs[i].id, ifs[i].in, ifs[i].out, ifs[i].martians_in, ifs[i].looped_in,
           ifs[i].bogus_in, ifs[i].out_overruns);
    }
    __Cont: /* CIL Label */ 
#line 325
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 333
  last_send = now;
#line 334
  return;
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/ipip.h"
int tun_open(struct interface *ifp ) ;
#line 191
int tun_send(struct interface *ifp , struct message *m ) ;
#line 192
int tun_read(struct interface *ifp , struct message *m ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/tun.c"
int tun_open(struct interface *ifp ) 
{ 
  int tmp ;

  {
#line 44
  if ((unsigned long )ifp == (unsigned long )((void *)0)) {
    {
#line 44
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%sInternal error: NULL interface passed to %s driver\n",
            progname, "tun");
    }
#line 44
    return (-1);
  }
#line 45
  if (ifp->type != 4) {
    {
#line 45
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%sInternal error: incorrect interface type passed to %s driver\n",
            progname, "tun");
    }
#line 45
    return (-1);
  }
#line 47
  if (ifp->status & 1) {
#line 47
    return (1);
  }
  {
#line 49
  ifp->fd = open((char const   *)ifp->devname, 2);
  }
#line 50
  if (ifp->fd < 0) {
    {
#line 51
    syslog(3, (char const   *)ifp->devname);
    }
#line 52
    return (-1);
  }
  {
#line 55
  tmp = fcntl(ifp->fd, 4, 2048);
  }
#line 55
  if (tmp < 0) {
    {
#line 56
    syslog(3, "setting non-blocking I/O on tunnel device");
    }
#line 57
    return (-1);
  }
#line 60
  ifp->status = 1;
#line 61
  return (1);
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/tun.c"
int tun_read(struct interface *ifp , struct message *m ) 
{ 
  int n ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 77
  if ((unsigned long )ifp == (unsigned long )((void *)0)) {
    {
#line 77
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%sInternal error: NULL interface passed to %s driver\n",
            progname, "tun");
    }
#line 77
    return (-1);
  }
#line 78
  if (ifp->type != 4) {
    {
#line 78
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%sInternal error: incorrect interface type passed to %s driver\n",
            progname, "tun");
    }
#line 78
    return (-1);
  }
#line 79
  if ((ifp->status & 1) == 0) {
    {
#line 79
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%sInternal error: interface has not been opened (%s driver)\n",
            progname, "tun");
    }
#line 79
    return (-1);
  }
#line 80
  if ((unsigned long )m == (unsigned long )((void *)0)) {
    {
#line 80
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%sInternal error: NULL message buffer passed to %s driver\n",
            progname, "tun");
    }
#line 80
    return (-1);
  }
  {
#line 82
  tmp = read(ifp->fd, (void *)((char *)(m->msg)), (size_t )2048);
#line 82
  n = (int )tmp;
  }
#line 83
  if (n < 0) {
    {
#line 84
    m->length = 0;
#line 85
    tmp___0 = __errno_location();
    }
#line 85
    if (*tmp___0 == 4) {
#line 85
      return (0);
    }
    {
#line 86
    tmp___1 = __errno_location();
    }
#line 86
    if (*tmp___1 == 11) {
#line 86
      return (0);
    }
    {
#line 87
    syslog(3, "read from tunnel device");
    }
#line 88
    return (-1);
  }
#line 90
  m->length = n;
#line 91
  return (n);
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/tun.c"
int tun_send(struct interface *ifp , struct message *m ) 
{ 
  int n ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 107
  if ((unsigned long )ifp == (unsigned long )((void *)0)) {
    {
#line 107
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%sInternal error: NULL interface passed to %s driver\n",
            progname, "tun");
    }
#line 107
    return (-1);
  }
#line 108
  if (ifp->type != 4) {
    {
#line 108
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%sInternal error: incorrect interface type passed to %s driver\n",
            progname, "tun");
    }
#line 108
    return (-1);
  }
#line 109
  if ((ifp->status & 1) == 0) {
    {
#line 109
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%sInternal error: interface has not been opened (%s driver)\n",
            progname, "tun");
    }
#line 109
    return (-1);
  }
#line 110
  if ((unsigned long )m == (unsigned long )((void *)0)) {
    {
#line 110
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%sInternal error: NULL message buffer passed to %s driver\n",
            progname, "tun");
    }
#line 110
    return (-1);
  }
#line 112
  if (m->length <= 0) {
#line 112
    return (0);
  }
  {
#line 114
  tmp = write(ifp->fd, (void const   *)((char *)(m->msg)), (size_t )m->length);
#line 114
  n = (int )tmp;
  }
#line 115
  if (n < 0) {
    {
#line 116
    tmp___0 = __errno_location();
    }
#line 116
    if (*tmp___0 == 4) {
#line 116
      return (0);
    }
    {
#line 117
    tmp___1 = __errno_location();
    }
#line 117
    if (*tmp___1 == 11) {
#line 118
      (ifp->out_overruns) ++;
#line 119
      return (0);
    }
    {
#line 121
    syslog(3, "write to tunnel device");
    }
#line 122
    return (-1);
  }
#line 124
  if (n < m->length) {
#line 124
    (ifp->out_overruns) ++;
  }
#line 125
  return (n);
}
}
#line 622 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 185 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/ipip.h"
int ip_open(struct interface *ifp ) ;
#line 186
int ip_send(struct interface *ifp , struct message *m ) ;
#line 187
int ip_read(struct interface *ifp , struct message *m ) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/config.c"
static void cerr(char *s , char *a ) ;
#line 21
static void init_config(void) ;
#line 22
static void c_interface(void) ;
#line 23
static void print_config(void) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/config.c"
static int clineno  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/config.c"
static int cerrflag  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/config.c"
int read_config(char *f ) 
{ 
  FILE *cf ;
  char buf[256] ;
  char *p ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 40
  init_config();
#line 43
  cf = fopen((char const   */* __restrict  */)f, (char const   */* __restrict  */)"r");
  }
#line 43
  if ((unsigned long )cf == (unsigned long )((void *)0)) {
    {
#line 44
    syslog(3, "Config file %s not found or could not be opened", f);
    }
#line 45
    return (-1);
  }
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 48
    tmp___0 = fgets((char */* __restrict  */)(buf), 255, (FILE */* __restrict  */)cf);
    }
#line 48
    if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 48
      goto while_break;
    }
    {
#line 49
    clineno ++;
#line 50
    p = strtok((char */* __restrict  */)(buf), (char const   */* __restrict  */)" \t\n\r");
    }
#line 50
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 50
      goto while_continue;
    }
#line 51
    if ((int )*p == 35) {
#line 51
      goto while_continue;
    } else
#line 51
    if ((int )*p == 59) {
#line 51
      goto while_continue;
    }
    {
#line 53
    tmp = strcmp((char const   *)p, "interface");
    }
#line 53
    if (tmp == 0) {
      {
#line 53
      c_interface();
      }
    } else {
      {
#line 55
      cerr("Unrecognized command: %s", p);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 58
  if (ifs_top == 0) {
    {
#line 58
    cerr("No interfaces defined", "");
    }
  }
#line 60
  if (debugd) {
    {
#line 60
    print_config();
    }
  }
#line 62
  return (cerrflag);
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/config.c"
static void init_config(void) 
{ 
  int i ;

  {
#line 75
  i = 0;
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (! (i < 8)) {
#line 75
      goto while_break;
    }
#line 76
    ifs[i].type = 0;
#line 77
    ifs[i].status = 0;
#line 78
    ifs[i].id = (char *)((void *)0);
#line 79
    ifs[i].devname = (char *)((void *)0);
#line 80
    ifs[i].unit = 0;
#line 81
    ifs[i].fd = -1;
#line 82
    ifs[i].private = (char *)((void *)0);
#line 83
    ifs[i].ifopen = (int (*)())((void *)0);
#line 84
    ifs[i].ifread = (int (*)())((void *)0);
#line 85
    ifs[i].ifsend = (int (*)())((void *)0);
#line 86
    ifs[i].in = 0L;
#line 87
    ifs[i].out = 0L;
#line 88
    ifs[i].out_overruns = 0L;
#line 89
    ifs[i].martians_in = 0L;
#line 90
    ifs[i].bogus_in = 0L;
#line 91
    ifs[i].looped_in = 0L;
#line 75
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  ifs_top = 0;
#line 95
  clineno = 0;
#line 96
  cerrflag = 0;
#line 97
  return;
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/config.c"
static void print_config(void) 
{ 
  int i ;
  char *id ;
  char *dev ;

  {
#line 110
  if (cerrflag == 0) {
    {
#line 110
    syslog(7, "%d interfaces:\n", ifs_top);
    }
  } else {
    {
#line 111
    syslog(7, "%d interfaces (there are errors):\n", ifs_top);
    }
  }
#line 112
  i = 0;
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if (! (i < ifs_top)) {
#line 112
      goto while_break;
    }
#line 114
    if ((unsigned long )ifs[i].id == (unsigned long )((void *)0)) {
#line 114
      id = (char *)"(none)";
    } else {
#line 115
      id = ifs[i].id;
    }
#line 117
    if ((unsigned long )ifs[i].devname == (unsigned long )((void *)0)) {
#line 117
      dev = (char *)"(none)";
    } else {
#line 118
      dev = ifs[i].devname;
    }
#line 120
    if (ifs[i].type == 0) {
      {
#line 121
      syslog(7, "interface %-4s  type NONE  devicename %s  unit %d\n", id, dev, ifs[i].unit);
      }
    } else
#line 123
    if (ifs[i].type == 3) {
      {
#line 124
      syslog(7, "interface %-4s  type slip  devicename %s  speed %d\n", id, dev, ifs[i].unit);
      }
    } else
#line 126
    if (ifs[i].type == 4) {
      {
#line 127
      syslog(7, "interface %-4s  type tun  devicename %s\n", id, dev);
      }
    } else
#line 129
    if (ifs[i].type == 2) {
      {
#line 130
      syslog(7, "interface %-4s  type udp  port %d\n", id, ifs[i].unit);
      }
    } else
#line 132
    if (ifs[i].type == 1) {
      {
#line 133
      syslog(7, "interface %-4s  type ip  protocol id %d\n", id, ifs[i].unit);
      }
    } else {
      {
#line 136
      syslog(7, "interface %-4s  type UNKNOWN  devicename %s  unit %d\n", id, dev,
             ifs[i].unit);
      }
    }
#line 112
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 140
  return;
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/config.c"
static void cerr(char *s , char *a ) 
{ 


  {
  {
#line 152
  syslog(3, "Config file error at line %d:\n", clineno);
#line 153
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)s, a);
#line 154
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 155
  cerrflag --;
  }
#line 156
  return;
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/config.c"
static void c_interface(void) 
{ 
  int syntax ;
  char *q ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 169
  if (ifs_top >= 8) {
    {
#line 170
    cerr((char *)"Too many interfaces defined", (char *)"");
    }
#line 171
    return;
  }
  {
#line 174
  syntax = 0;
#line 176
  q = strtok((char */* __restrict  */)((char *)((void *)0)), (char const   */* __restrict  */)" \t\n\r");
  }
#line 176
  if (q) {
    {
#line 177
    ifs[ifs_top].id = strdup((char const   *)q);
    }
  } else {
#line 178
    syntax ++;
  }
  {
#line 180
  q = strtok((char */* __restrict  */)((char *)((void *)0)), (char const   */* __restrict  */)" \t\n\r");
  }
#line 180
  if (q) {
    {
#line 181
    tmp___2 = strcmp((char const   *)q, "tunnel");
    }
#line 181
    if (tmp___2 == 0) {
#line 182
      ifs[ifs_top].type = 4;
#line 183
      ifs[ifs_top].ifopen = & tun_open;
#line 184
      ifs[ifs_top].ifread = & tun_read;
#line 185
      ifs[ifs_top].ifsend = & tun_send;
    } else {
      {
#line 186
      tmp___1 = strcmp((char const   *)q, "slip");
      }
#line 186
      if (tmp___1 == 0) {
#line 187
        ifs[ifs_top].type = 3;
#line 188
        ifs[ifs_top].ifopen = & slip_open;
#line 189
        ifs[ifs_top].ifread = & slip_read;
#line 190
        ifs[ifs_top].ifsend = & slip_send;
      } else {
        {
#line 191
        tmp___0 = strcmp((char const   *)q, "ip");
        }
#line 191
        if (tmp___0 == 0) {
#line 192
          ifs[ifs_top].type = 1;
#line 193
          ifs[ifs_top].ifopen = & ip_open;
#line 194
          ifs[ifs_top].ifread = & ip_read;
#line 195
          ifs[ifs_top].ifsend = & ip_send;
        } else {
          {
#line 196
          tmp = strcmp((char const   *)q, "udp");
          }
#line 196
          if (tmp == 0) {
#line 197
            ifs[ifs_top].type = 2;
#line 198
            ifs[ifs_top].ifopen = & ip_open;
#line 199
            ifs[ifs_top].ifread = & ip_read;
#line 200
            ifs[ifs_top].ifsend = & ip_send;
          } else {
            {
#line 201
            cerr((char *)"Bad interface type: %s", q);
            }
          }
        }
      }
    }
  } else {
#line 202
    syntax ++;
  }
  {
#line 204
  q = strtok((char */* __restrict  */)((char *)((void *)0)), (char const   */* __restrict  */)" \t\n\r");
  }
#line 204
  if (q) {
    {
#line 205
    ifs[ifs_top].devname = strdup((char const   *)q);
    }
  } else {
#line 206
    syntax ++;
  }
  {
#line 208
  q = strtok((char */* __restrict  */)((char *)((void *)0)), (char const   */* __restrict  */)" \t\n\r");
  }
#line 208
  if (q) {
    {
#line 209
    ifs[ifs_top].unit = atoi((char const   *)q);
    }
  } else {
#line 210
    syntax ++;
  }
#line 212
  if (syntax) {
    {
#line 212
    cerr((char *)"Syntax error (interface <name> <type> <device> <int>", (char *)"");
    }
  }
#line 214
  ifs_top ++;
#line 215
  return;
}
}
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 144 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 34 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t ( __attribute__((__leaf__)) inet_addr)(char const   *__cp ) ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/route.c"
static void rerr(char *s , char *a ) ;
#line 27
static void init_route(void) ;
#line 28
static void r_route(void) ;
#line 29
static void print_routes(void) ;
#line 30
static void sort_routes(void) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/route.c"
static int rlineno  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/route.c"
static int rerrflag  ;
#line 40 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/route.c"
int read_routes(char *f ) 
{ 
  FILE *cf ;
  char buf[256] ;
  char *p ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 47
  init_route();
#line 50
  cf = fopen((char const   */* __restrict  */)f, (char const   */* __restrict  */)"r");
  }
#line 50
  if ((unsigned long )cf == (unsigned long )((void *)0)) {
    {
#line 51
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%sRoute file %s not found or could not be opened\n",
            progname, f);
    }
#line 52
    return (-1);
  }
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 55
    tmp___0 = fgets((char */* __restrict  */)(buf), 255, (FILE */* __restrict  */)cf);
    }
#line 55
    if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 55
      goto while_break;
    }
    {
#line 56
    rlineno ++;
#line 57
    p = strtok((char */* __restrict  */)(buf), (char const   */* __restrict  */)" \t\n\r");
    }
#line 57
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 57
      goto while_continue;
    }
#line 58
    if ((int )*p == 35) {
#line 58
      goto while_continue;
    } else
#line 58
    if ((int )*p == 59) {
#line 58
      goto while_continue;
    }
    {
#line 60
    tmp = strcmp((char const   *)p, "route");
    }
#line 60
    if (tmp == 0) {
      {
#line 60
      r_route();
      }
    } else {
      {
#line 62
      rerr("Unrecognized command: %s", p);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 65
  if (rts_top == 0) {
    {
#line 65
    rerr("No routes defined", "");
    }
  }
#line 67
  if (debugd) {
    {
#line 67
    print_routes();
    }
  }
  {
#line 69
  sort_routes();
  }
#line 71
  if (debugd) {
    {
#line 71
    print_routes();
    }
  }
#line 73
  return (rerrflag);
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/route.c"
static void init_route(void) 
{ 
  int i ;

  {
#line 85
  i = 0;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! (i < 1024)) {
#line 85
      goto while_break;
    }
#line 86
    rts[i].ipaddr = 0UL;
#line 87
    rts[i].mask = 4294967295UL;
#line 88
    rts[i].destif = (struct interface *)((void *)0);
#line 89
    rts[i].destaddr = 0UL;
#line 90
    rts[i].destport = (unsigned short)0;
#line 91
    rts[i].hits = 0L;
#line 85
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  rts_top = 0;
#line 95
  rlineno = 0;
#line 96
  rerrflag = 0;
#line 97
  return;
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/route.c"
static void print_routes(void) 
{ 
  int i ;
  int port ;
  int type ;
  unsigned char *p ;
  unsigned char *q ;
  char *id ;
  unsigned int m ;
  uint16_t tmp ;

  {
#line 112
  if (rerrflag == 0) {
    {
#line 112
    syslog(7, "%d routes:", rts_top);
    }
  } else {
    {
#line 113
    syslog(7, "%d routes (there are errors):", rts_top);
    }
  }
#line 114
  i = 0;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! (i < rts_top)) {
#line 114
      goto while_break;
    }
#line 115
    p = (unsigned char *)(& rts[i].ipaddr);
#line 116
    q = (unsigned char *)(& rts[i].destaddr);
#line 117
    if ((unsigned long )rts[i].destif != (unsigned long )((void *)0)) {
#line 118
      id = (rts[i].destif)->id;
#line 119
      type = (rts[i].destif)->type;
    } else {
#line 121
      id = (char *)"unknown";
#line 122
      type = 0;
    }
    {
#line 124
    tmp = ntohs(rts[i].destport);
#line 124
    port = (int )tmp;
#line 125
    m = ntohl((uint32_t )rts[i].mask);
    }
#line 127
    if (type == 3) {
      {
#line 129
      syslog(7, "ip %d.%d.%d.%d mask 0x%08x interface %s\n", (int )*(p + 0), (int )*(p + 1),
             (int )*(p + 2), (int )*(p + 3), m, id);
      }
    } else
#line 127
    if (type == 4) {
      {
#line 129
      syslog(7, "ip %d.%d.%d.%d mask 0x%08x interface %s\n", (int )*(p + 0), (int )*(p + 1),
             (int )*(p + 2), (int )*(p + 3), m, id);
      }
    } else
#line 131
    if (type == 1) {
      {
#line 132
      syslog(7, "ip %d.%d.%d.%d mask 0x%08x interface %s ip %d.%d.%d.%d\n", (int )*(p + 0),
             (int )*(p + 1), (int )*(p + 2), (int )*(p + 3), m, id, (int )*(q + 0),
             (int )*(q + 1), (int )*(q + 2), (int )*(q + 3));
      }
    } else {
      {
#line 136
      syslog(7, "ip %d.%d.%d.%d mask 0x%08x interface %s ip %d.%d.%d.%d port %d\n",
             (int )*(p + 0), (int )*(p + 1), (int )*(p + 2), (int )*(p + 3), m, id,
             (int )*(q + 0), (int )*(q + 1), (int )*(q + 2), (int )*(q + 3), port);
      }
    }
#line 114
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 141
  return;
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/route.c"
static void rerr(char *s , char *a ) 
{ 


  {
  {
#line 153
  syslog(3, "Route file error at line %d:\n", rlineno);
#line 154
  syslog(3, (char const   *)s, a);
#line 155
  rerrflag --;
  }
#line 156
  return;
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/route.c"
static void r_route(void) 
{ 
  int i ;
  int syntax ;
  char *q ;
  struct hostent *he ;
  unsigned long tmp ;
  in_addr_t tmp___0 ;
  unsigned long tmp___1 ;
  uint32_t tmp___2 ;
  int tmp___3 ;
  unsigned long tmp___4 ;
  in_addr_t tmp___5 ;
  int tmp___6 ;

  {
#line 170
  if (rts_top >= 1024) {
    {
#line 171
    rerr((char *)"Too many routes defined", (char *)"");
    }
#line 172
    return;
  }
  {
#line 175
  syntax = 0;
#line 177
  q = strtok((char */* __restrict  */)((char *)((void *)0)), (char const   */* __restrict  */)" \t\n\r");
  }
#line 177
  if (q) {
    {
#line 178
    he = gethostbyname((char const   *)q);
    }
#line 178
    if (he) {
      {
#line 179
      memcpy((void */* __restrict  */)((char *)(& rts[rts_top].ipaddr)), (void const   */* __restrict  */)*(he->h_addr_list + 0),
             (size_t )4);
      }
    } else {
      {
#line 182
      tmp___0 = inet_addr((char const   *)q);
#line 182
      tmp = (unsigned long )tmp___0;
#line 182
      rts[rts_top].ipaddr = tmp;
      }
#line 182
      if (tmp == 4294967295UL) {
        {
#line 183
        rerr((char *)"Bad IP address: %s", q);
        }
      }
    }
  } else {
#line 185
    syntax ++;
  }
  {
#line 187
  q = strtok((char */* __restrict  */)((char *)((void *)0)), (char const   */* __restrict  */)" \t\n\r");
  }
#line 187
  if (q) {
    {
#line 188
    tmp___1 = strtoul((char const   */* __restrict  */)q, (char **/* __restrict  */)((void *)0),
                      0);
#line 188
    tmp___2 = htonl((uint32_t )tmp___1);
#line 188
    rts[rts_top].mask = (unsigned long )tmp___2;
    }
  } else {
#line 189
    syntax ++;
  }
  {
#line 191
  q = strtok((char */* __restrict  */)((char *)((void *)0)), (char const   */* __restrict  */)" \t\n\r");
  }
#line 191
  if (q) {
#line 192
    i = 0;
    {
#line 192
    while (1) {
      while_continue: /* CIL Label */ ;
#line 192
      if (! (i < ifs_top)) {
#line 192
        goto while_break;
      }
      {
#line 193
      tmp___3 = strcmp((char const   *)q, (char const   *)ifs[i].id);
      }
#line 193
      if (tmp___3 == 0) {
#line 193
        rts[rts_top].destif = & ifs[i];
      }
#line 192
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 195
    if ((unsigned long )rts[rts_top].destif == (unsigned long )((void *)0)) {
      {
#line 196
      rerr((char *)"Interface %s not defined", q);
      }
    }
  } else {
#line 197
    syntax ++;
  }
  {
#line 199
  q = strtok((char */* __restrict  */)((char *)((void *)0)), (char const   */* __restrict  */)" \t\n\r");
  }
#line 199
  if (q) {
    {
#line 200
    he = gethostbyname((char const   *)q);
    }
#line 200
    if (he) {
      {
#line 201
      memcpy((void */* __restrict  */)((char *)(& rts[rts_top].destaddr)), (void const   */* __restrict  */)*(he->h_addr_list + 0),
             (size_t )4);
      }
    } else {
      {
#line 204
      tmp___5 = inet_addr((char const   *)q);
#line 204
      tmp___4 = (unsigned long )tmp___5;
#line 204
      rts[rts_top].destaddr = tmp___4;
      }
#line 204
      if (tmp___4 == 0xffffffffffffffffUL) {
        {
#line 205
        rerr((char *)"Bad destination IP address: %s", q);
        }
      }
    }
  }
  {
#line 209
  q = strtok((char */* __restrict  */)((char *)((void *)0)), (char const   */* __restrict  */)" \t\n\r");
  }
#line 209
  if (q) {
    {
#line 210
    tmp___6 = atoi((char const   *)q);
#line 210
    rts[rts_top].destport = htons((unsigned short )tmp___6);
    }
  }
#line 213
  if (syntax) {
    {
#line 213
    rerr((char *)"Syntax error (route <ipaddr> <mask> <iface> [<destipaddr> [<destport>]]",
         (char *)"");
    }
  }
#line 215
  rts_top ++;
#line 216
  return;
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/route.c"
static unsigned long mask_entries[33]  = 
#line 222
  {      4294967295UL,      4294967294UL,      4294967292UL,      4294967288UL, 
        4294967280UL,      4294967264UL,      4294967232UL,      4294967168UL, 
        4294967040UL,      4294966784UL,      4294966272UL,      4294965248UL, 
        4294963200UL,      4294959104UL,      4294950912UL,      4294934528UL, 
        4294901760UL,      4294836224UL,      4294705152UL,      4294443008UL, 
        4293918720UL,      4292870144UL,      4290772992UL,      4286578688UL, 
        4278190080UL,      4261412864UL,      4227858432UL,      4160749568UL, 
        4026531840UL,      3758096384UL,      3221225472UL,      2147483648UL, 
        0UL};
#line 218 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/route.c"
static void sort_routes(void) 
{ 
  struct ipip_route *tmptable ;
  int i ;
  int j ;
  int newrows ;
  void *tmp ;
  int tmp___0 ;
  uint32_t tmp___1 ;

  {
  {
#line 234
  tmp = malloc((unsigned long )(rts_top + 1) * sizeof(struct ipip_route ));
#line 234
  tmptable = (struct ipip_route *)tmp;
  }
#line 236
  if ((unsigned long )tmptable == (unsigned long )((void *)0)) {
    {
#line 237
    rerr((char *)"Unable to allocate memory to resort table", (char *)"");
    }
#line 238
    return;
  }
#line 243
  newrows = 0;
#line 244
  i = 0;
  {
#line 244
  while (1) {
    while_continue: /* CIL Label */ ;
#line 244
    if (! (i <= 32)) {
#line 244
      goto while_break;
    }
#line 245
    j = 0;
    {
#line 245
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 245
      if (! (j < rts_top)) {
#line 245
        goto while_break___0;
      }
      {
#line 246
      tmp___1 = htonl((uint32_t )mask_entries[i]);
      }
#line 246
      if (rts[j].mask == (unsigned long )tmp___1) {
#line 247
        tmp___0 = newrows;
#line 247
        newrows ++;
#line 247
        *(tmptable + tmp___0) = rts[j];
      }
#line 245
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 244
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 250
  i = 0;
  {
#line 250
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 250
    if (! (i < rts_top)) {
#line 250
      goto while_break___1;
    }
#line 251
    rts[i] = *(tmptable + i);
#line 250
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 252
  free((void *)tmptable);
  }
#line 253
  return;
}
}
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 163
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  *__addr , socklen_t __addr_len ) ;
#line 174
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/ip.c"
int ip_open(struct interface *ifp ) 
{ 
  struct sockaddr_in ip_udpbind ;
  int tmp ;
  int tmp___0 ;

  {
#line 46
  if ((unsigned long )ifp == (unsigned long )((void *)0)) {
    {
#line 46
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%sInternal error: NULL interface passed to %s driver\n",
            progname, "ip");
    }
#line 46
    return (-1);
  }
#line 47
  if (ifp->type != 1) {
#line 47
    if (ifp->type != 2) {
      {
#line 47
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%sInternal error: incorrect interface type passed to %s driver\n",
              progname, "ip");
      }
#line 47
      return (-1);
    }
  }
#line 49
  if (ifp->status & 1) {
#line 49
    return (1);
  }
#line 51
  if (ifp->type == 2) {
    {
#line 52
    ifp->fd = socket(2, 2, 0);
    }
  } else {
    {
#line 54
    ifp->fd = socket(2, 3, ifp->unit);
    }
  }
#line 56
  if (ifp->fd < 0) {
    {
#line 57
    syslog(3, "opening socket");
    }
#line 58
    return (-1);
  }
  {
#line 61
  tmp = fcntl(ifp->fd, 4, 2048);
  }
#line 61
  if (tmp < 0) {
    {
#line 62
    syslog(3, "setting non-blocking I/O on raw socket");
    }
#line 63
    return (-1);
  }
#line 66
  if (ifp->type == 2) {
    {
#line 67
    memset((void *)((char *)(& ip_udpbind)), 0, sizeof(struct sockaddr ));
#line 68
    ip_udpbind.sin_addr.s_addr = (in_addr_t )0;
#line 69
    ip_udpbind.sin_family = (sa_family_t )2;
#line 70
    ip_udpbind.sin_port = htons((unsigned short )ifp->unit);
#line 71
    tmp___0 = bind(ifp->fd, (struct sockaddr  const  *)((struct sockaddr *)(& ip_udpbind)),
                   (socklen_t )sizeof(ip_udpbind));
    }
#line 71
    if (tmp___0 < 0) {
      {
#line 72
      syslog(3, "binding udp socket");
      }
#line 73
      return (-1);
    }
  }
#line 77
  ifp->status = 1;
#line 78
  return (1);
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/ip.c"
int ip_read(struct interface *ifp , struct message *m ) 
{ 
  unsigned char buf[2048] ;
  unsigned char *p ;
  int n ;
  int hdr_len ;
  int fromlen ;
  struct iphdr *ipptr ;
  struct sockaddr_in ip_from ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 101
  if ((unsigned long )ifp == (unsigned long )((void *)0)) {
    {
#line 101
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%sInternal error: NULL interface passed to %s driver\n",
            progname, "ip");
    }
#line 101
    return (-1);
  }
#line 102
  if (ifp->type != 1) {
#line 102
    if (ifp->type != 2) {
      {
#line 102
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%sInternal error: incorrect interface type passed to %s driver\n",
              progname, "ip");
      }
#line 102
      return (-1);
    }
  }
#line 103
  if ((ifp->status & 1) == 0) {
    {
#line 103
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%sInternal error: interface has not been opened (%s driver)\n",
            progname, "ip");
    }
#line 103
    return (-1);
  }
#line 104
  if ((unsigned long )m == (unsigned long )((void *)0)) {
    {
#line 104
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%sInternal error: NULL message buffer passed to %s driver\n",
            progname, "ip");
    }
#line 104
    return (-1);
  }
  {
#line 106
  memset((void *)((char *)(& ip_from)), 0, sizeof(struct sockaddr ));
#line 107
  ip_from.sin_family = (sa_family_t )2;
#line 108
  fromlen = (int )sizeof(ip_from);
#line 110
  tmp = recvfrom(ifp->fd, (void */* __restrict  */)((char *)(buf)), (size_t )2048,
                 0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& ip_from)),
                 (socklen_t */* __restrict  */)(& fromlen));
#line 110
  n = (int )tmp;
  }
#line 111
  if (n < 0) {
    {
#line 112
    m->length = 0;
#line 113
    tmp___0 = __errno_location();
    }
#line 113
    if (*tmp___0 == 4) {
#line 113
      return (0);
    }
    {
#line 114
    tmp___1 = __errno_location();
    }
#line 114
    if (*tmp___1 == 11) {
#line 114
      return (0);
    }
    {
#line 115
    syslog(3, "recvfrom: on socket");
    }
#line 116
    return (-1);
  }
#line 119
  if (n == 0) {
#line 119
    return (0);
  }
#line 121
  if (ifp->type == 2) {
#line 122
    p = buf;
  } else {
#line 125
    ipptr = (struct iphdr *)(buf);
#line 126
    hdr_len = (int )(4U * ipptr->ihl);
#line 131
    p = buf + hdr_len;
#line 132
    n -= hdr_len;
  }
  {
#line 135
  memcpy((void */* __restrict  */)((char *)(m->msg)), (void const   */* __restrict  */)((char *)p),
         (size_t )n);
#line 136
  m->length = n;
#line 137
  memcpy((void */* __restrict  */)((char *)(& m->fip)), (void const   */* __restrict  */)((char *)(& ip_from.sin_addr)),
         (size_t )4);
#line 138
  m->fport = ip_from.sin_port;
  }
#line 139
  return (n);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/ipip-1.1.9/ip.c"
int ip_send(struct interface *ifp , struct message *m ) 
{ 
  int n ;
  struct sockaddr_in ip_to ;
  ssize_t tmp ;
  char bugger[80] ;
  unsigned char *p ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 155
  if ((unsigned long )ifp == (unsigned long )((void *)0)) {
    {
#line 155
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%sInternal error: NULL interface passed to %s driver\n",
            progname, "ip");
    }
#line 155
    return (-1);
  }
#line 156
  if (ifp->type != 1) {
#line 156
    if (ifp->type != 2) {
      {
#line 156
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%sInternal error: incorrect interface type passed to %s driver\n",
              progname, "ip");
      }
#line 156
      return (-1);
    }
  }
#line 157
  if ((ifp->status & 1) == 0) {
    {
#line 157
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%sInternal error: interface has not been opened (%s driver)\n",
            progname, "ip");
    }
#line 157
    return (-1);
  }
#line 158
  if ((unsigned long )m == (unsigned long )((void *)0)) {
    {
#line 158
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%sInternal error: NULL message buffer passed to %s driver\n",
            progname, "ip");
    }
#line 158
    return (-1);
  }
#line 160
  if (m->length <= 0) {
#line 160
    return (0);
  }
#line 162
  if ((long )m->tip == 0L) {
    {
#line 163
    syslog(4, "attempt to send to IP address 0.0.0.0");
    }
#line 164
    return (0);
  }
#line 167
  if (ifp->type == 2) {
#line 167
    if ((int )m->tport == 0) {
      {
#line 168
      syslog(4, "attempt to send to UDP port 0");
      }
#line 169
      return (0);
    }
  }
  {
#line 172
  memset((void *)((char *)(& ip_to)), 0, sizeof(struct sockaddr ));
#line 173
  ip_to.sin_family = (sa_family_t )2;
#line 174
  ip_to.sin_port = m->tport;
#line 175
  memcpy((void */* __restrict  */)((char *)(& ip_to.sin_addr)), (void const   */* __restrict  */)((char *)(& m->tip)),
         (size_t )4);
#line 177
  tmp = sendto(ifp->fd, (void const   *)((char *)(m->msg)), (size_t )m->length, 0,
               (struct sockaddr  const  *)((struct sockaddr *)(& ip_to)), (socklen_t )sizeof(ip_to));
#line 177
  n = (int )tmp;
  }
#line 179
  if (n < 0) {
    {
#line 182
    p = (unsigned char *)(& m->tip);
#line 183
    tmp___0 = __errno_location();
#line 183
    tmp___1 = strerror(*tmp___0);
#line 183
    sprintf((char */* __restrict  */)(bugger), (char const   */* __restrict  */)"ip_send(dest:%d.%d.%d.%d) sendto(): %s",
            (int )*(p + 0), (int )*(p + 1), (int )*(p + 2), (int )*(p + 3), tmp___1);
#line 186
    syslog(3, (char const   *)(bugger));
    }
#line 187
    return (0);
  }
#line 190
  return (n);
}
}
