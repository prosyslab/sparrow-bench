/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 152 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
struct macel {
   char mac_name[9] ;
   char *mac_start ;
   char *mac_end ;
};
#line 142 "/usr/include/obstack.h"
struct _obstack_chunk {
   char *limit ;
   struct _obstack_chunk *prev ;
   char contents[4] ;
};
#line 149 "/usr/include/obstack.h"
union __anonunion_temp_54 {
   long tempint ;
   void *tempptr ;
};
#line 149 "/usr/include/obstack.h"
struct obstack {
   long chunk_size ;
   struct _obstack_chunk *chunk ;
   char *object_base ;
   char *next_free ;
   char *chunk_limit ;
   union __anonunion_temp_54 temp ;
   int alignment_mask ;
   struct _obstack_chunk *(*chunkfun)(void * , long  ) ;
   void (*freefun)(void * , struct _obstack_chunk * ) ;
   void *extra_arg ;
   unsigned int use_extra_arg : 1 ;
   unsigned int maybe_empty_object : 1 ;
   unsigned int alloc_failed : 1 ;
};
#line 64 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ruserpass.c"
struct toktab {
   char const   *tokstr ;
   int tval ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 257 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 34 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 92 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag sigjmp_buf[1];
#line 139 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
struct cmd {
   char const   *c_name ;
   char const   *c_help ;
   char c_bell ;
   char c_conn ;
   char c_proxy ;
   void (*c_handler_v)(int  , char ** ) ;
   void (*c_handler_0)(void) ;
   void (*c_handler_1)(char const   * ) ;
};
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 86 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_16 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_17 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_18 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_19 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_20 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_21 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_22 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_15 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_16 _kill ;
   struct __anonstruct__timer_17 _timer ;
   struct __anonstruct__rt_18 _rt ;
   struct __anonstruct__sigchld_19 _sigchld ;
   struct __anonstruct__sigfault_20 _sigfault ;
   struct __anonstruct__sigpoll_21 _sigpoll ;
   struct __anonstruct__sigsys_22 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_14 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_15 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_14 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_34 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_34 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 162 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   unsigned long __ss_align ;
   char __ss_padding[128UL - 2UL * sizeof(unsigned long )] ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_44 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_44 __in6_u ;
};
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 1551 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp.c"
struct comvars {
   int connect ;
   char name[64] ;
   struct sockaddr_storage mctl ;
   struct sockaddr_storage hctl ;
   FILE *in ;
   FILE *out ;
   int tpe ;
   int curtpe ;
   int cpnd ;
   int sunqe ;
   int runqe ;
   int mcse ;
   int ntflg ;
   char nti[17] ;
   char nto[17] ;
   int mapflg ;
   char mi[4096] ;
   char mo[4096] ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 60 "/usr/include/x86_64-linux-gnu/sys/wait.h"
union wait;
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_40 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_41 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_40 __wait_terminated ;
   struct __anonstruct___wait_stopped_41 __wait_stopped ;
};
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 82 "/usr/include/glob.h"
struct __anonstruct_glob_t_60 {
   size_t gl_pathc ;
   char **gl_pathv ;
   size_t gl_offs ;
   int gl_flags ;
   void (*gl_closedir)(void * ) ;
   void *(*gl_readdir)(void * ) ;
   void *(*gl_opendir)(char const   * ) ;
   int (*gl_lstat)(char const   * __restrict   , void * __restrict   ) ;
   int (*gl_stat)(char const   * __restrict   , void * __restrict   ) ;
};
#line 82 "/usr/include/glob.h"
typedef struct __anonstruct_glob_t_60 glob_t;
#line 253 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
struct types {
   char const   *t_name ;
   char const   *t_mode ;
   int t_type ;
   char const   *t_arg ;
};
#line 37 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ruserpass.c"
char ruserpass_rcsid[58]  = 
#line 37 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ruserpass.c"
  {      (char )'$',      (char )'I',      (char )'d',      (char )':', 
        (char )' ',      (char )'r',      (char )'u',      (char )'s', 
        (char )'e',      (char )'r',      (char )'p',      (char )'a', 
        (char )'s',      (char )'s',      (char )'.',      (char )'c', 
        (char )',',      (char )'v',      (char )' ',      (char )'1', 
        (char )'.',      (char )'9',      (char )' ',      (char )'1', 
        (char )'9',      (char )'9',      (char )'9',      (char )'/', 
        (char )'1',      (char )'0',      (char )'/',      (char )'0', 
        (char )'2',      (char )' ',      (char )'1',      (char )'9', 
        (char )':',      (char )'1',      (char )'2',      (char )':', 
        (char )'3',      (char )'3',      (char )' ',      (char )'d', 
        (char )'h',      (char )'o',      (char )'l',      (char )'l', 
        (char )'a',      (char )'n',      (char )'d',      (char )' ', 
        (char )'E',      (char )'x',      (char )'p',      (char )' ', 
        (char )'$',      (char )'\000'};
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 489
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) index)(char const   *__s ,
                                                                                              int __c )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 879 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                                                  size_t __len ) ;
#line 89 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
int proxy ;
#line 118
char *hostname ;
#line 158
int macnum ;
#line 159
struct macel macros[16] ;
#line 160
char macbuf[4096] ;
#line 177
int xruserpass(char const   *host , char **aname , char **apass , char **aacct ) ;
#line 180 "/usr/include/obstack.h"
extern void _obstack_newchunk(struct obstack * , int  ) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/main.h"
struct obstack mainobstack ;
#line 51 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ruserpass.c"
static FILE *cfile  ;
#line 52
static int token(void) ;
#line 62 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ruserpass.c"
static char tokval[100]  ;
#line 64 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ruserpass.c"
static struct toktab toktab[8]  = 
#line 64
  {      {"default", 1}, 
        {"login", 2}, 
        {"password", 3}, 
        {"passwd", 3}, 
        {"account", 4}, 
        {"machine", 11}, 
        {"macdef", 5}, 
        {(char const   *)((void *)0), 0}};
#line 78 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ruserpass.c"
int xruserpass(char const   *host , char **aname , char **apass , char **aacct ) 
{ 
  char const   *hdir ;
  char buf___0[8192] ;
  char *tmp ;
  char myname[64] ;
  char const   *mydomain ;
  int t ;
  int i ;
  int c ;
  int usedefault ;
  struct stat stb ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  size_t tmp___11 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  struct obstack *__h___0 ;
  struct obstack *__o___0 ;
  int __len___0 ;
  size_t tmp___19 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  struct obstack *__h___1 ;
  struct obstack *__o___1 ;
  int __len___1 ;
  size_t tmp___25 ;
  struct obstack *__o1___1 ;
  void *__value___1 ;
  char *tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  unsigned short const   **tmp___31 ;
  int tmp___32 ;

  {
  {
#line 85
  usedefault = 0;
#line 88
  tmp___0 = getenv("HOME");
#line 88
  hdir = (char const   *)tmp___0;
  }
#line 89
  if ((unsigned long )hdir == (unsigned long )((void *)0)) {
#line 90
    hdir = ".";
  }
  {
#line 91
  snprintf((char */* __restrict  */)(buf___0), sizeof(buf___0), (char const   */* __restrict  */)"%s/.netrc",
           hdir);
#line 92
  cfile = fopen((char const   */* __restrict  */)(buf___0), (char const   */* __restrict  */)"r");
  }
#line 93
  if ((unsigned long )cfile == (unsigned long )((void *)0)) {
    {
#line 94
    tmp___1 = __errno_location();
    }
#line 94
    if (*tmp___1 != 2) {
      {
#line 95
      perror((char const   *)(buf___0));
      }
    }
#line 96
    return (0);
  }
  {
#line 98
  tmp___2 = gethostname(myname, sizeof(myname));
  }
#line 98
  if (tmp___2 < 0) {
#line 99
    myname[0] = (char )'\000';
  }
  {
#line 100
  tmp___3 = strchr((char const   *)(myname), '.');
#line 100
  mydomain = (char const   *)tmp___3;
  }
#line 100
  if ((unsigned long )mydomain == (unsigned long )((void *)0)) {
#line 101
    mydomain = "";
  }
  next: 
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 103
    t = token();
    }
#line 103
    if (! t) {
#line 103
      goto while_break;
    }
    {
#line 105
    if (t == 1) {
#line 105
      goto case_1;
    }
#line 109
    if (t == 11) {
#line 109
      goto case_11;
    }
#line 103
    goto switch_break;
    case_1: /* CIL Label */ 
#line 106
    usedefault = 1;
    case_11: /* CIL Label */ 
#line 110
    if (! usedefault) {
      {
#line 111
      tmp___4 = token();
      }
#line 111
      if (tmp___4 != 10) {
#line 112
        goto while_continue;
      }
      {
#line 118
      tmp___5 = strcasecmp(host, (char const   *)(tokval));
      }
#line 118
      if (tmp___5 == 0) {
#line 119
        goto match;
      }
      {
#line 120
      tmp___6 = strcasecmp((char const   *)hostname, (char const   *)(tokval));
      }
#line 120
      if (tmp___6 == 0) {
#line 121
        goto match;
      }
      {
#line 122
      tmp = index((char const   *)hostname, '.');
      }
#line 122
      if ((unsigned long )tmp != (unsigned long )((void *)0)) {
        {
#line 122
        tmp___7 = strcasecmp((char const   *)tmp, mydomain);
        }
#line 122
        if (tmp___7 == 0) {
          {
#line 122
          tmp___8 = strncasecmp((char const   *)hostname, (char const   *)(tokval),
                                (size_t )(tmp - hostname));
          }
#line 122
          if (tmp___8 == 0) {
#line 122
            if ((int )tokval[tmp - hostname] == 0) {
#line 126
              goto match;
            }
          }
        }
      }
      {
#line 127
      tmp = index(host, '.');
      }
#line 127
      if ((unsigned long )tmp != (unsigned long )((void *)0)) {
        {
#line 127
        tmp___9 = strcasecmp((char const   *)tmp, mydomain);
        }
#line 127
        if (tmp___9 == 0) {
          {
#line 127
          tmp___10 = strncasecmp(host, (char const   *)(tokval), (size_t )(tmp - (char *)host));
          }
#line 127
          if (tmp___10 == 0) {
#line 127
            if ((int )tokval[tmp - (char *)host] == 0) {
#line 131
              goto match;
            }
          }
        }
      }
#line 132
      goto while_continue;
    }
    match: 
    {
#line 135
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 135
      t = token();
      }
#line 135
      if (t) {
#line 135
        if (t != 11) {
#line 135
          if (! (t != 1)) {
#line 135
            goto while_break___0;
          }
        } else {
#line 135
          goto while_break___0;
        }
      } else {
#line 135
        goto while_break___0;
      }
      {
#line 137
      if (t == 2) {
#line 137
        goto case_2;
      }
#line 147
      if (t == 3) {
#line 147
        goto case_3;
      }
#line 163
      if (t == 4) {
#line 163
        goto case_4;
      }
#line 174
      if (t == 5) {
#line 174
        goto case_5;
      }
#line 233
      goto switch_default;
      case_2: /* CIL Label */ 
      {
#line 138
      tmp___15 = token();
      }
#line 138
      if (tmp___15) {
#line 139
        if ((unsigned long )*aname == (unsigned long )((char *)0)) {
          {
#line 140
          __h = & mainobstack;
#line 140
          __o = __h;
#line 140
          tmp___11 = strlen((char const   *)(tokval));
#line 140
          __len = (int )(tmp___11 + 1UL);
          }
#line 140
          if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
            {
#line 140
            _obstack_newchunk(__o, __len);
            }
          }
          {
#line 140
          memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)(tokval),
                 (size_t )__len);
#line 140
          __o->next_free += __len;
#line 140
          __o1 = __h;
#line 140
          __value = (void *)__o1->object_base;
          }
#line 140
          if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 140
            __o1->maybe_empty_object = 1U;
          }
#line 140
          if (sizeof(long ) < sizeof(void *)) {
#line 140
            tmp___12 = __o1->object_base;
          } else {
#line 140
            tmp___12 = (char *)0;
          }
#line 140
          if (sizeof(long ) < sizeof(void *)) {
#line 140
            tmp___13 = __o1->object_base;
          } else {
#line 140
            tmp___13 = (char *)0;
          }
#line 140
          __o1->next_free = tmp___12 + (((__o1->next_free - tmp___13) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 140
          if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 140
            __o1->next_free = __o1->chunk_limit;
          }
#line 140
          __o1->object_base = __o1->next_free;
#line 140
          *aname = (char *)__value;
        } else {
          {
#line 142
          tmp___14 = strcmp((char const   *)*aname, (char const   *)(tokval));
          }
#line 142
          if (tmp___14) {
#line 143
            goto next;
          }
        }
      }
#line 146
      goto switch_break___0;
      case_3: /* CIL Label */ 
#line 148
      if ((unsigned long )*aname == (unsigned long )((void *)0)) {
        {
#line 149
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: `password\' must follow `login\' in .netrc\n");
        }
#line 150
        goto bad;
      }
      {
#line 152
      tmp___16 = strcmp((char const   *)*aname, "anonymous");
      }
#line 152
      if (tmp___16) {
        {
#line 152
        tmp___17 = fileno(cfile);
#line 152
        tmp___18 = fstat(tmp___17, & stb);
        }
#line 152
        if (tmp___18 >= 0) {
#line 152
          if ((stb.st_mode & 63U) != 0U) {
            {
#line 155
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error - .netrc file not correct permissions.\n");
#line 156
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Remove password or correct mode (should be 600).\n");
            }
#line 157
            goto bad;
          }
        }
      }
      {
#line 159
      tmp___22 = token();
      }
#line 159
      if (tmp___22) {
#line 159
        if ((unsigned long )*apass == (unsigned long )((char *)0)) {
          {
#line 160
          __h___0 = & mainobstack;
#line 160
          __o___0 = __h___0;
#line 160
          tmp___19 = strlen((char const   *)(tokval));
#line 160
          __len___0 = (int )(tmp___19 + 1UL);
          }
#line 160
          if ((unsigned long )(__o___0->next_free + __len___0) > (unsigned long )__o___0->chunk_limit) {
            {
#line 160
            _obstack_newchunk(__o___0, __len___0);
            }
          }
          {
#line 160
          memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)(tokval),
                 (size_t )__len___0);
#line 160
          __o___0->next_free += __len___0;
#line 160
          __o1___0 = __h___0;
#line 160
          __value___0 = (void *)__o1___0->object_base;
          }
#line 160
          if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 160
            __o1___0->maybe_empty_object = 1U;
          }
#line 160
          if (sizeof(long ) < sizeof(void *)) {
#line 160
            tmp___20 = __o1___0->object_base;
          } else {
#line 160
            tmp___20 = (char *)0;
          }
#line 160
          if (sizeof(long ) < sizeof(void *)) {
#line 160
            tmp___21 = __o1___0->object_base;
          } else {
#line 160
            tmp___21 = (char *)0;
          }
#line 160
          __o1___0->next_free = tmp___20 + (((__o1___0->next_free - tmp___21) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 160
          if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 160
            __o1___0->next_free = __o1___0->chunk_limit;
          }
#line 160
          __o1___0->object_base = __o1___0->next_free;
#line 160
          *apass = (char *)__value___0;
        }
      }
#line 162
      goto switch_break___0;
      case_4: /* CIL Label */ 
      {
#line 164
      tmp___23 = fileno(cfile);
#line 164
      tmp___24 = fstat(tmp___23, & stb);
      }
#line 164
      if (tmp___24 >= 0) {
#line 164
        if ((stb.st_mode & 63U) != 0U) {
          {
#line 166
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error - .netrc file not correct permissions.\n");
#line 167
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Remove account or correct mode (should be 600).\n");
          }
#line 168
          goto bad;
        }
      }
      {
#line 170
      tmp___28 = token();
      }
#line 170
      if (tmp___28) {
#line 170
        if ((unsigned long )*aacct == (unsigned long )((char *)0)) {
          {
#line 171
          __h___1 = & mainobstack;
#line 171
          __o___1 = __h___1;
#line 171
          tmp___25 = strlen((char const   *)(tokval));
#line 171
          __len___1 = (int )(tmp___25 + 1UL);
          }
#line 171
          if ((unsigned long )(__o___1->next_free + __len___1) > (unsigned long )__o___1->chunk_limit) {
            {
#line 171
            _obstack_newchunk(__o___1, __len___1);
            }
          }
          {
#line 171
          memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)(tokval),
                 (size_t )__len___1);
#line 171
          __o___1->next_free += __len___1;
#line 171
          __o1___1 = __h___1;
#line 171
          __value___1 = (void *)__o1___1->object_base;
          }
#line 171
          if ((unsigned long )__o1___1->next_free == (unsigned long )__value___1) {
#line 171
            __o1___1->maybe_empty_object = 1U;
          }
#line 171
          if (sizeof(long ) < sizeof(void *)) {
#line 171
            tmp___26 = __o1___1->object_base;
          } else {
#line 171
            tmp___26 = (char *)0;
          }
#line 171
          if (sizeof(long ) < sizeof(void *)) {
#line 171
            tmp___27 = __o1___1->object_base;
          } else {
#line 171
            tmp___27 = (char *)0;
          }
#line 171
          __o1___1->next_free = tmp___26 + (((__o1___1->next_free - tmp___27) + (long )__o1___1->alignment_mask) & (long )(~ __o1___1->alignment_mask));
#line 171
          if (__o1___1->next_free - (char *)__o1___1->chunk > __o1___1->chunk_limit - (char *)__o1___1->chunk) {
#line 171
            __o1___1->next_free = __o1___1->chunk_limit;
          }
#line 171
          __o1___1->object_base = __o1___1->next_free;
#line 171
          *aacct = (char *)__value___1;
        }
      }
#line 173
      goto switch_break___0;
      case_5: /* CIL Label */ 
#line 175
      if (proxy) {
        {
#line 176
        fclose(cfile);
        }
#line 177
        return (0);
      }
      {
#line 179
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 179
        c = _IO_getc(cfile);
        }
#line 179
        if (c != -1) {
#line 179
          if (! (c == 32)) {
#line 179
            if (! (c == 9)) {
#line 179
              goto while_break___1;
            }
          }
        } else {
#line 179
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 180
      if (c == -1) {
        {
#line 181
        printf((char const   */* __restrict  */)"Missing macdef name argument.\n");
        }
#line 182
        goto bad;
      } else
#line 180
      if (c == 10) {
        {
#line 181
        printf((char const   */* __restrict  */)"Missing macdef name argument.\n");
        }
#line 182
        goto bad;
      }
#line 184
      if (macnum == 16) {
        {
#line 185
        printf((char const   */* __restrict  */)"Limit of 16 macros have already been defined\n");
        }
#line 186
        goto bad;
      }
#line 188
      tmp = macros[macnum].mac_name;
#line 189
      tmp___29 = tmp;
#line 189
      tmp ++;
#line 189
      *tmp___29 = (char )c;
#line 190
      i = 0;
      {
#line 190
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 190
        if (i < 8) {
          {
#line 190
          c = _IO_getc(cfile);
          }
#line 190
          if (c != -1) {
            {
#line 190
            tmp___31 = __ctype_b_loc();
            }
#line 190
            if ((int const   )*(*tmp___31 + c) & 8192) {
#line 190
              goto while_break___2;
            }
          } else {
#line 190
            goto while_break___2;
          }
        } else {
#line 190
          goto while_break___2;
        }
#line 192
        tmp___30 = tmp;
#line 192
        tmp ++;
#line 192
        *tmp___30 = (char )c;
#line 190
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 194
      if (c == -1) {
        {
#line 195
        printf((char const   */* __restrict  */)"Macro definition missing null line terminator.\n");
        }
#line 196
        goto bad;
      }
#line 198
      *tmp = (char )'\000';
#line 199
      if (c != 10) {
        {
#line 200
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 200
          c = _IO_getc(cfile);
          }
#line 200
          if (c != -1) {
#line 200
            if (! (c != 10)) {
#line 200
              goto while_break___3;
            }
          } else {
#line 200
            goto while_break___3;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 202
      if (c == -1) {
        {
#line 203
        printf((char const   */* __restrict  */)"Macro definition missing null line terminator.\n");
        }
#line 204
        goto bad;
      }
#line 206
      if (macnum == 0) {
#line 207
        macros[macnum].mac_start = macbuf;
      } else {
#line 210
        macros[macnum].mac_start = macros[macnum - 1].mac_end + 1;
      }
#line 212
      tmp = macros[macnum].mac_start;
      {
#line 213
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 213
        if (! ((unsigned long )tmp != (unsigned long )(macbuf + 4096))) {
#line 213
          goto while_break___4;
        }
        {
#line 214
        c = _IO_getc(cfile);
        }
#line 214
        if (c == -1) {
          {
#line 215
          printf((char const   */* __restrict  */)"Macro definition missing null line terminator.\n");
          }
#line 216
          goto bad;
        }
#line 218
        *tmp = (char )c;
#line 219
        if ((int )*tmp == 10) {
#line 220
          if ((int )*(tmp - 1) == 0) {
#line 221
            tmp___32 = macnum;
#line 221
            macnum ++;
#line 221
            macros[tmp___32].mac_end = tmp - 1;
#line 222
            goto while_break___4;
          }
#line 224
          *tmp = (char )'\000';
        }
#line 226
        tmp ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 228
      if ((unsigned long )tmp == (unsigned long )(macbuf + 4096)) {
        {
#line 229
        printf((char const   */* __restrict  */)"4K macro buffer exceeded\n");
        }
#line 230
        goto bad;
      }
#line 232
      goto switch_break___0;
      switch_default: /* CIL Label */ 
      {
#line 234
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown .netrc keyword %s\n",
              tokval);
      }
#line 235
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 237
    goto done;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  done: 
  {
#line 240
  fclose(cfile);
  }
#line 241
  return (0);
  bad: 
  {
#line 243
  fclose(cfile);
  }
#line 244
  return (-1);
}
}
#line 247 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ruserpass.c"
static int token(void) 
{ 
  char *cp ;
  int c ;
  struct toktab *t ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 255
  tmp = feof(cfile);
  }
#line 255
  if (tmp) {
#line 256
    return (0);
  }
  {
#line 257
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 257
    c = _IO_getc(cfile);
    }
#line 257
    if (c != -1) {
#line 257
      if (! (c == 10)) {
#line 257
        if (! (c == 9)) {
#line 257
          if (! (c == 32)) {
#line 257
            if (! (c == 44)) {
#line 257
              goto while_break;
            }
          }
        }
      }
    } else {
#line 257
      goto while_break;
    }
#line 259
    goto while_continue;
  }
  while_break: /* CIL Label */ ;
  }
#line 260
  if (c == -1) {
#line 261
    return (0);
  }
#line 262
  cp = tokval;
#line 263
  if (c == 34) {
    {
#line 264
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 264
      c = _IO_getc(cfile);
      }
#line 264
      if (c != -1) {
#line 264
        if (! (c != 34)) {
#line 264
          goto while_break___0;
        }
      } else {
#line 264
        goto while_break___0;
      }
#line 265
      if (c == 92) {
        {
#line 266
        c = _IO_getc(cfile);
        }
      }
#line 267
      tmp___0 = cp;
#line 267
      cp ++;
#line 267
      *tmp___0 = (char )c;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 270
    tmp___1 = cp;
#line 270
    cp ++;
#line 270
    *tmp___1 = (char )c;
    {
#line 271
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 271
      c = _IO_getc(cfile);
      }
#line 271
      if (c != -1) {
#line 271
        if (c != 10) {
#line 271
          if (c != 9) {
#line 271
            if (c != 32) {
#line 271
              if (! (c != 44)) {
#line 271
                goto while_break___1;
              }
            } else {
#line 271
              goto while_break___1;
            }
          } else {
#line 271
            goto while_break___1;
          }
        } else {
#line 271
          goto while_break___1;
        }
      } else {
#line 271
        goto while_break___1;
      }
#line 273
      if (c == 92) {
        {
#line 274
        c = _IO_getc(cfile);
        }
      }
#line 275
      tmp___2 = cp;
#line 275
      cp ++;
#line 275
      *tmp___2 = (char )c;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 278
  *cp = (char)0;
#line 279
  if ((int )tokval[0] == 0) {
#line 280
    return (0);
  }
#line 281
  t = toktab;
  {
#line 281
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 281
    if (! t->tokstr) {
#line 281
      goto while_break___2;
    }
    {
#line 282
    tmp___3 = strcmp(t->tokstr, (char const   *)(tokval));
    }
#line 282
    if (! tmp___3) {
#line 283
      return (t->tval);
    }
#line 281
    t ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 284
  return (10);
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/main.c"
char copyright[93]  = 
#line 34 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/main.c"
  {      (char )'@',      (char )'(',      (char )'#',      (char )')', 
        (char )' ',      (char )'C',      (char )'o',      (char )'p', 
        (char )'y',      (char )'r',      (char )'i',      (char )'g', 
        (char )'h',      (char )'t',      (char )' ',      (char )'(', 
        (char )'c',      (char )')',      (char )' ',      (char )'1', 
        (char )'9',      (char )'8',      (char )'5',      (char )',', 
        (char )' ',      (char )'1',      (char )'9',      (char )'8', 
        (char )'9',      (char )' ',      (char )'R',      (char )'e', 
        (char )'g',      (char )'e',      (char )'n',      (char )'t', 
        (char )'s',      (char )' ',      (char )'o',      (char )'f', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'U',      (char )'n',      (char )'i', 
        (char )'v',      (char )'e',      (char )'r',      (char )'s', 
        (char )'i',      (char )'t',      (char )'y',      (char )' ', 
        (char )'o',      (char )'f',      (char )' ',      (char )'C', 
        (char )'a',      (char )'l',      (char )'i',      (char )'f', 
        (char )'o',      (char )'r',      (char )'n',      (char )'i', 
        (char )'a',      (char )'.',      (char )'\n',      (char )'A', 
        (char )'l',      (char )'l',      (char )' ',      (char )'r', 
        (char )'i',      (char )'g',      (char )'h',      (char )'t', 
        (char )'s',      (char )' ',      (char )'r',      (char )'e', 
        (char )'s',      (char )'e',      (char )'r',      (char )'v', 
        (char )'e',      (char )'d',      (char )'.',      (char )'\n', 
        (char )'\000'};
#line 41 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/main.c"
char main_rcsid[52]  = 
#line 41
  {      (char )'$',      (char )'I',      (char )'d',      (char )':', 
        (char )' ',      (char )'m',      (char )'a',      (char )'i', 
        (char )'n',      (char )'.',      (char )'c',      (char )',', 
        (char )'v',      (char )' ',      (char )'1',      (char )'.', 
        (char )'1',      (char )'5',      (char )' ',      (char )'1', 
        (char )'9',      (char )'9',      (char )'9',      (char )'/', 
        (char )'1',      (char )'0',      (char )'/',      (char )'0', 
        (char )'2',      (char )' ',      (char )'1',      (char )'3', 
        (char )':',      (char )'2',      (char )'5',      (char )':', 
        (char )'2',      (char )'3',      (char )' ',      (char )'n', 
        (char )'e',      (char )'t',      (char )'b',      (char )'u', 
        (char )'g',      (char )' ',      (char )'E',      (char )'x', 
        (char )'p',      (char )' ',      (char )'$',      (char )'\000'};
#line 261 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) shutdown)(int __fd ,
                                                                               int __how ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 347
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) siginterrupt)(int __sig ,
                                                                                   int __interrupt ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 779
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 849
extern char *getlogin(void) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 580
extern int putchar(int __c ) ;
#line 678
extern __ssize_t getline(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                         FILE * __restrict  __stream ) ;
#line 290 "/usr/include/netdb.h"
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 116
extern struct passwd *getpwnam(char const   *__name ) ;
#line 181 "/usr/include/obstack.h"
extern int _obstack_begin(struct obstack * , int  , int  , void *(*)(long  ) , void (*)(void * ) ) ;
#line 188
extern void obstack_free(struct obstack *__obstack , void *__glibc_block ) ;
#line 59 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int __sigsetjmp(struct __jmp_buf_tag *__env ,
                                                     int __savemask ) ;
#line 102
extern  __attribute__((__nothrow__, __noreturn__)) void siglongjmp(struct __jmp_buf_tag *__env ,
                                                                   int __val ) ;
#line 75 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
int rl_inhibit  ;
#line 76
int traceflag ;
#line 77 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
int hash  ;
#line 78 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
int tick  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
int sendport  ;
#line 80 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
int verbose  ;
#line 81 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
int connected  ;
#line 82 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
int usefamily  ;
#line 83 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
int fromatty  ;
#line 84 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
int interactive  ;
#line 85 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
int debug  ;
#line 86 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
int bell  ;
#line 87 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
int doglob  ;
#line 88 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
int autologin  ;
#line 89 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
int proxy  ;
#line 90 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
int proxflag  ;
#line 91 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
int sunique  ;
#line 92 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
int runique  ;
#line 93 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
int mcase  ;
#line 94 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
int ntflag  ;
#line 95 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
int mapflag  ;
#line 96 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
int code  ;
#line 97 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
int crflag  ;
#line 98 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
int qcflag  ;
#line 99 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
char pasv[64]  ;
#line 100 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
int passivemode  ;
#line 101 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
char *altarg  ;
#line 102 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
char ntin[17]  ;
#line 103 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
char ntout[17]  ;
#line 104 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
char mapin[4096]  ;
#line 105 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
char mapout[4096]  ;
#line 106 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
char typename[32]  ;
#line 107 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
int type  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
int curtype  ;
#line 109 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
char structname[32]  ;
#line 110 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
int stru  ;
#line 111 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
char formname[32]  ;
#line 112 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
int form  ;
#line 113 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
char modename[32]  ;
#line 114 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
int mode  ;
#line 115 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
char bytename[32]  ;
#line 116 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
int bytesize  ;
#line 118 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
char *hostname  ;
#line 119 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
int unix_server  ;
#line 120 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
int unix_proxy  ;
#line 123 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
int ftp_port  ;
#line 125 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
sigjmp_buf *toplevel  ;
#line 127 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
char *line  ;
#line 128 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
char *stringbase  ;
#line 129 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
char *argbuf  ;
#line 130 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
char *argbase  ;
#line 131 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
int cpend  ;
#line 132 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
int mflag  ;
#line 134 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
int options  ;
#line 158 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
int macnum  ;
#line 159 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
struct macel macros[16]  ;
#line 160 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
char macbuf[4096]  ;
#line 164
struct cmd *getcmd(char const   *name ) ;
#line 165
char **makeargv(int *pargc , char **parg ) ;
#line 173
void fatal(char const   *msg ) ;
#line 176
void pswitch(int flag ) ;
#line 178
void setpeer(int argc , char **argv ) ;
#line 179
void quit(void) ;
#line 4 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/main.h"
int suppressint  ;
#line 5 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/main.h"
int volatile   intpending  ;
#line 6 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/main.h"
int intrnewline  ;
#line 7 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/main.h"
struct obstack mainobstack  ;
#line 8 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/main.h"
struct obstack lineobstack  ;
#line 11
 __attribute__((__noreturn__)) void intr(int ignore ) ;
#line 76 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/main.c"
int traceflag  =    0;
#line 77 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/main.c"
char const   *home  =    "/";
#line 85
FILE *cin ;
#line 86
FILE *cout ;
#line 87
int data ;
#line 88
struct cmd cmdtab[79] ;
#line 89
int NCMDS ;
#line 92
void lostpeer(int ignore ) ;
#line 93
void help(int argc , char **argv ) ;
#line 95
static void inthandler(int sig ) ;
#line 96
static void cmdscanner(int top ) ;
#line 97
static char *slurpstring(void) ;
#line 98
static void resetstack(struct obstack *stack ) ;
#line 100 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/main.c"
static void usage(void) 
{ 


  {
  {
#line 104
  printf((char const   */* __restrict  */)"\n\tUsage: { ftp | pftp } [-46pinegvtd] [hostname]\n");
#line 105
  printf((char const   */* __restrict  */)"\t   -4: use IPv4 addresses only\n");
#line 106
  printf((char const   */* __restrict  */)"\t   -6: use IPv6, nothing else\n");
#line 107
  printf((char const   */* __restrict  */)"\t   -p: enable passive mode (default for pftp)\n");
#line 108
  printf((char const   */* __restrict  */)"\t   -i: turn off prompting during mget\n");
#line 109
  printf((char const   */* __restrict  */)"\t   -n: inhibit auto-login\n");
#line 110
  printf((char const   */* __restrict  */)"\t   -e: disable readline support, if present\n");
#line 111
  printf((char const   */* __restrict  */)"\t   -g: disable filename globbing\n");
#line 112
  printf((char const   */* __restrict  */)"\t   -v: verbose mode\n");
#line 113
  printf((char const   */* __restrict  */)"\t   -t: enable packet tracing [nonfunctional]\n");
#line 114
  printf((char const   */* __restrict  */)"\t   -d: enable debugging\n");
#line 115
  printf((char const   */* __restrict  */)"\n");
  }
#line 116
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/main.c"
int main(int volatile   argc , char ** volatile  argv ) 
{ 
  register char *cp ;
  struct servent *sp ;
  int top ;
  struct passwd *pw ;
  char homedir[4096] ;
  sigjmp_buf jmploc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __uid_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 124
  pw = (struct passwd *)((void *)0);
#line 128
  tick = 0;
#line 130
  sp = getservbyname("ftp", "tcp");
  }
#line 131
  if ((unsigned long )sp == (unsigned long )((struct servent *)0)) {
    {
#line 132
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ftp: ftp/tcp: unknown service\n");
#line 133
    exit(1);
    }
  }
  {
#line 135
  ftp_port = sp->s_port;
#line 136
  doglob = 1;
#line 137
  interactive = 1;
#line 138
  autologin = 1;
#line 139
  passivemode = 0;
#line 140
  usefamily = 0;
#line 142
  cp = strrchr((char const   *)*(argv + 0), '/');
  }
#line 143
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 143
    cp = *(argv + 0);
  } else {
#line 143
    cp ++;
  }
  {
#line 144
  tmp = strcmp((char const   *)cp, "pftp");
  }
#line 144
  if (tmp == 0) {
#line 145
    passivemode = 1;
  }
#line 147
  argc -= (int volatile   )1;
#line 147
  argv ++;
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (argc > (int volatile   )0) {
#line 148
      if (! ((int )*(*argv) == 45)) {
#line 148
        goto while_break;
      }
    } else {
#line 148
      goto while_break;
    }
#line 149
    cp = *argv + 1;
    {
#line 149
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 149
      if (! *cp) {
#line 149
        goto while_break___0;
      }
      {
#line 152
      if ((int )*cp == 52) {
#line 152
        goto case_52;
      }
#line 156
      if ((int )*cp == 54) {
#line 156
        goto case_54;
      }
#line 160
      if ((int )*cp == 100) {
#line 160
        goto case_100;
      }
#line 165
      if ((int )*cp == 118) {
#line 165
        goto case_118;
      }
#line 169
      if ((int )*cp == 116) {
#line 169
        goto case_116;
      }
#line 173
      if ((int )*cp == 105) {
#line 173
        goto case_105;
      }
#line 177
      if ((int )*cp == 110) {
#line 177
        goto case_110;
      }
#line 181
      if ((int )*cp == 112) {
#line 181
        goto case_112;
      }
#line 185
      if ((int )*cp == 103) {
#line 185
        goto case_103;
      }
#line 189
      if ((int )*cp == 101) {
#line 189
        goto case_101;
      }
#line 193
      if ((int )*cp == 104) {
#line 193
        goto case_104;
      }
#line 197
      goto switch_default;
      case_52: /* CIL Label */ 
#line 153
      usefamily = 2;
#line 154
      goto switch_break;
      case_54: /* CIL Label */ 
#line 157
      usefamily = 10;
#line 158
      goto switch_break;
      case_100: /* CIL Label */ 
#line 161
      options |= 1;
#line 162
      debug ++;
#line 163
      goto switch_break;
      case_118: /* CIL Label */ 
#line 166
      verbose ++;
#line 167
      goto switch_break;
      case_116: /* CIL Label */ 
#line 170
      traceflag ++;
#line 171
      goto switch_break;
      case_105: /* CIL Label */ 
#line 174
      interactive = 0;
#line 175
      goto switch_break;
      case_110: /* CIL Label */ 
#line 178
      autologin = 0;
#line 179
      goto switch_break;
      case_112: /* CIL Label */ 
#line 182
      passivemode = 1;
#line 183
      goto switch_break;
      case_103: /* CIL Label */ 
#line 186
      doglob = 0;
#line 187
      goto switch_break;
      case_101: /* CIL Label */ 
#line 190
      rl_inhibit = 1;
#line 191
      goto switch_break;
      case_104: /* CIL Label */ 
      {
#line 194
      usage();
#line 195
      exit(0);
      }
      switch_default: /* CIL Label */ 
      {
#line 198
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"ftp: %c: unknown option\n",
              (int )*cp);
#line 200
      exit(1);
      }
      switch_break: /* CIL Label */ ;
      }
#line 149
      cp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 202
    argc -= (int volatile   )1;
#line 202
    argv ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 204
  tmp___0 = fileno(stdin);
#line 204
  fromatty = isatty(tmp___0);
  }
#line 215
  if (fromatty) {
#line 216
    verbose ++;
  }
  {
#line 217
  cpend = 0;
#line 218
  proxy = 0;
#line 219
  crflag = 1;
#line 220
  sendport = -1;
#line 221
  tmp___1 = fileno(stdout);
#line 221
  qcflag = isatty(tmp___1);
#line 225
  cp = getlogin();
  }
#line 226
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
    {
#line 227
    pw = getpwnam((char const   *)cp);
    }
  }
#line 229
  if ((unsigned long )pw == (unsigned long )((void *)0)) {
    {
#line 230
    tmp___2 = getuid();
#line 230
    pw = getpwuid(tmp___2);
    }
  }
#line 231
  if ((unsigned long )pw != (unsigned long )((void *)0)) {
    {
#line 232
    strncpy((char */* __restrict  */)(homedir), (char const   */* __restrict  */)pw->pw_dir,
            sizeof(homedir));
#line 233
    homedir[sizeof(homedir) - 1UL] = (char)0;
#line 234
    home = (char const   *)(homedir);
    }
  }
  {
#line 240
  siginterrupt(2, 1);
#line 241
  toplevel = & jmploc;
#line 242
  _obstack_begin(& mainobstack, 0, 0, (void *(*)(long  ))(& malloc), (void (*)(void * ))(& free));
#line 243
  _obstack_begin(& lineobstack, 0, 0, (void *(*)(long  ))(& malloc), (void (*)(void * ))(& free));
  }
#line 244
  if (argc > (int volatile   )0) {
    {
#line 245
    tmp___3 = __sigsetjmp((struct __jmp_buf_tag *)(jmploc), 1);
    }
#line 245
    if (tmp___3) {
      {
#line 246
      exit(0);
      }
    }
    {
#line 247
    signal(2, & inthandler);
#line 248
    signal(13, (void (*)(int  ))1);
#line 249
    setpeer((int )(argc + (int volatile   )1), (char **)(argv - 1));
#line 250
    resetstack(& mainobstack);
#line 251
    resetstack(& lineobstack);
    }
  }
  {
#line 253
  tmp___4 = __sigsetjmp((struct __jmp_buf_tag *)(jmploc), 1);
#line 253
  top = tmp___4 == 0;
  }
#line 254
  if (top) {
    {
#line 255
    signal(2, & inthandler);
#line 256
    signal(13, (void (*)(int  ))1);
    }
  } else {
    {
#line 258
    suppressint ++;
#line 259
    resetstack(& mainobstack);
#line 260
    resetstack(& lineobstack);
    }
    {
#line 261
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 261
      suppressint --;
#line 261
      if (suppressint == 0) {
#line 261
        if (intpending) {
          {
#line 261
          intr(2);
          }
        }
      }
#line 261
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 262
    pswitch(0);
    }
  }
  {
#line 264
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 265
    cmdscanner(top);
#line 266
    top = 1;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
}
}
#line 270
 __attribute__((__noreturn__)) void intr(int ignore ) ;
#line 270 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/main.c"
void intr(int ignore ) 
{ 


  {
  {
#line 275
  intpending = (int volatile   )0;
#line 276
  siglongjmp((struct __jmp_buf_tag *)(*toplevel), 1);
  }
}
}
#line 279 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/main.c"
static void inthandler(int sig ) 
{ 


  {
#line 282
  if (intrnewline) {
    {
#line 283
    putchar('\n');
#line 284
    fflush(stdout);
    }
  }
#line 286
  if (suppressint) {
#line 287
    intpending += (int volatile   )1;
#line 288
    return;
  }
  {
#line 290
  intr(sig);
  }
}
}
#line 296 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/main.c"
void lostpeer(int ignore ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 301
  if (connected) {
#line 302
    if ((unsigned long )cout != (unsigned long )((void *)0)) {
      {
#line 303
      tmp = fileno(cout);
#line 303
      shutdown(tmp, 2);
#line 304
      fclose(cout);
#line 305
      cout = (FILE *)((void *)0);
      }
    }
#line 307
    if ((unsigned long )cin != (unsigned long )((void *)0)) {
      {
#line 308
      fclose(cin);
#line 309
      cin = (FILE *)((void *)0);
      }
    }
#line 311
    if (data >= 0) {
      {
#line 312
      shutdown(data, 2);
#line 313
      close(data);
#line 314
      data = -1;
      }
    }
#line 316
    connected = 0;
  }
  {
#line 318
  pswitch(1);
  }
#line 319
  if (connected) {
#line 320
    if ((unsigned long )cout != (unsigned long )((void *)0)) {
      {
#line 321
      tmp___0 = fileno(cout);
#line 321
      shutdown(tmp___0, 2);
#line 322
      fclose(cout);
#line 323
      cout = (FILE *)((void *)0);
      }
    }
#line 325
    if ((unsigned long )cin != (unsigned long )((void *)0)) {
      {
#line 326
      fclose(cin);
#line 327
      cin = (FILE *)((void *)0);
      }
    }
#line 329
    connected = 0;
  }
  {
#line 331
  proxflag = 0;
#line 332
  pswitch(0);
  }
#line 333
  return;
}
}
#line 353 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/main.c"
static char *get_input_line(void) 
{ 
  char *lineread ;
  size_t size ;
  ssize_t len ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 369
  if (fromatty) {
    {
#line 370
    printf((char const   */* __restrict  */)"ftp> ");
#line 371
    fflush(stdout);
    }
  }
  {
#line 373
  size = (size_t )0;
#line 374
  lineread = (char *)0;
#line 375
  suppressint ++;
#line 376
  len = getline((char **/* __restrict  */)(& lineread), (size_t */* __restrict  */)(& size),
                (FILE */* __restrict  */)stdin);
  }
#line 377
  if (len == -1L) {
#line 377
    goto err;
  } else
#line 377
  if (! lineread) {
    err: 
    {
#line 379
    while (1) {
      while_continue: /* CIL Label */ ;
#line 379
      suppressint --;
#line 379
      if (suppressint == 0) {
#line 379
        if (intpending) {
          {
#line 379
          intr(2);
          }
        }
      }
#line 379
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 380
    return ((char *)((void *)0));
  }
#line 383
  __h = & lineobstack;
#line 383
  __o = __h;
#line 383
  __len = (int )(len + 1L);
#line 383
  if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
    {
#line 383
    _obstack_newchunk(__o, __len);
    }
  }
  {
#line 383
  memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)lineread,
         (size_t )__len);
#line 383
  __o->next_free += __len;
#line 383
  __o1 = __h;
#line 383
  __value = (void *)__o1->object_base;
  }
#line 383
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 383
    __o1->maybe_empty_object = 1U;
  }
#line 383
  if (sizeof(long ) < sizeof(void *)) {
#line 383
    tmp = __o1->object_base;
  } else {
#line 383
    tmp = (char *)0;
  }
#line 383
  if (sizeof(long ) < sizeof(void *)) {
#line 383
    tmp___0 = __o1->object_base;
  } else {
#line 383
    tmp___0 = (char *)0;
  }
#line 383
  __o1->next_free = tmp + (((__o1->next_free - tmp___0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 383
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 383
    __o1->next_free = __o1->chunk_limit;
  }
  {
#line 383
  __o1->object_base = __o1->next_free;
#line 383
  line = (char *)__value;
#line 384
  free((void *)lineread);
  }
  {
#line 385
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 385
    suppressint --;
#line 385
    if (suppressint == 0) {
#line 385
      if (intpending) {
        {
#line 385
        intr(2);
        }
      }
    }
#line 385
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 386
  return (line);
}
}
#line 393 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/main.c"
static void cmdscanner(int top ) 
{ 
  int margc ;
  char *marg ;
  char **margv ;
  register struct cmd *c ;
  register int l ;
  int first ;
  struct obstack *__o ;
  void *__obj ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  struct obstack *__o___0 ;
  void *__obj___0 ;
  char *tmp___2 ;

  {
#line 401
  first = 1;
#line 403
  if (! top) {
    {
#line 404
    putchar('\n');
    }
  }
  {
#line 405
  while (1) {
    while_continue: /* CIL Label */ ;
#line 406
    if (! first) {
#line 407
      suppressint ++;
#line 408
      __o = & lineobstack;
#line 408
      __obj = (void *)line;
#line 408
      if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 408
        if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 408
          tmp = (char *)__obj;
#line 408
          __o->object_base = tmp;
#line 408
          __o->next_free = tmp;
        } else {
          {
#line 408
          obstack_free(__o, __obj);
          }
        }
      } else {
        {
#line 408
        obstack_free(__o, __obj);
        }
      }
      {
#line 409
      resetstack(& mainobstack);
      }
      {
#line 410
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 410
        suppressint --;
#line 410
        if (suppressint == 0) {
#line 410
          if (intpending) {
            {
#line 410
            intr(2);
            }
          }
        }
#line 410
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 412
    first = 0;
#line 413
    tmp___0 = get_input_line();
    }
#line 413
    if (! tmp___0) {
      {
#line 414
      quit();
      }
    }
    {
#line 416
    tmp___1 = strlen((char const   *)line);
#line 416
    l = (int )tmp___1;
    }
#line 417
    if (l == 0) {
#line 418
      goto while_break;
    }
#line 419
    l --;
#line 419
    if ((int )*(line + l) == 10) {
#line 420
      if (l == 0) {
#line 421
        goto while_break;
      }
#line 422
      *(line + l) = (char )'\000';
    }
    {
#line 424
    margv = makeargv(& margc, & marg);
    }
#line 425
    if (margc == 0) {
#line 426
      goto __Cont;
    }
    {
#line 428
    c = getcmd((char const   *)*(margv + 0));
    }
#line 429
    if ((unsigned long )c == (unsigned long )((struct cmd *)-1)) {
      {
#line 430
      printf((char const   */* __restrict  */)"?Ambiguous command\n");
      }
#line 431
      goto __Cont;
    }
#line 433
    if ((unsigned long )c == (unsigned long )((void *)0)) {
      {
#line 434
      printf((char const   */* __restrict  */)"?Invalid command\n");
      }
#line 435
      goto __Cont;
    }
#line 437
    if (c->c_conn) {
#line 437
      if (! connected) {
        {
#line 438
        printf((char const   */* __restrict  */)"Not connected.\n");
        }
#line 439
        goto __Cont;
      }
    }
#line 441
    if (c->c_handler_v) {
      {
#line 441
      (*(c->c_handler_v))(margc, margv);
      }
    } else
#line 442
    if (c->c_handler_0) {
      {
#line 442
      (*(c->c_handler_0))();
      }
    } else {
      {
#line 443
      (*(c->c_handler_1))((char const   *)marg);
      }
    }
#line 445
    if (bell) {
#line 445
      if (c->c_bell) {
        {
#line 445
        putchar('\a');
        }
      }
    }
#line 446
    if ((unsigned long )c->c_handler_v != (unsigned long )(& help)) {
#line 447
      goto while_break;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 449
  suppressint ++;
#line 450
  __o___0 = & lineobstack;
#line 450
  __obj___0 = (void *)line;
#line 450
  if ((unsigned long )__obj___0 > (unsigned long )((void *)__o___0->chunk)) {
#line 450
    if ((unsigned long )__obj___0 < (unsigned long )((void *)__o___0->chunk_limit)) {
#line 450
      tmp___2 = (char *)__obj___0;
#line 450
      __o___0->object_base = tmp___2;
#line 450
      __o___0->next_free = tmp___2;
    } else {
      {
#line 450
      obstack_free(__o___0, __obj___0);
      }
    }
  } else {
    {
#line 450
    obstack_free(__o___0, __obj___0);
    }
  }
  {
#line 451
  resetstack(& mainobstack);
  }
  {
#line 452
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 452
    suppressint --;
#line 452
    if (suppressint == 0) {
#line 452
      if (intpending) {
        {
#line 452
        intr(2);
        }
      }
    }
#line 452
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 453
  return;
}
}
#line 455 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/main.c"
struct cmd *getcmd(char const   *name ) 
{ 
  char const   *p ;
  char const   *q ;
  struct cmd *c ;
  struct cmd *found ;
  int nmatches ;
  int longest ;
  char const   *tmp ;

  {
#line 462
  longest = 0;
#line 463
  nmatches = 0;
#line 464
  found = (struct cmd *)0;
#line 465
  c = cmdtab;
  {
#line 465
  while (1) {
    while_continue: /* CIL Label */ ;
#line 465
    p = c->c_name;
#line 465
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 465
      goto while_break;
    }
#line 466
    q = name;
    {
#line 466
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 466
      tmp = p;
#line 466
      p ++;
#line 466
      if (! ((int const   )*q == (int const   )*tmp)) {
#line 466
        goto while_break___0;
      }
#line 467
      if ((int const   )*q == 0) {
#line 468
        return (c);
      }
#line 466
      q ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 469
    if (! *q) {
#line 470
      if (q - name > (long )longest) {
#line 471
        longest = (int )(q - name);
#line 472
        nmatches = 1;
#line 473
        found = c;
      } else
#line 474
      if (q - name == (long )longest) {
#line 475
        nmatches ++;
      }
    }
#line 465
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 478
  if (nmatches > 1) {
#line 479
    return ((struct cmd *)-1);
  }
#line 480
  return (found);
}
}
#line 487 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/main.c"
int slrflag  ;
#line 492 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/main.c"
static char **rargv  =    (char **)((void *)0);
#line 493 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/main.c"
static int arglimit  =    0;
#line 489 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/main.c"
char **makeargv(int *pargc , char **parg ) 
{ 
  int rargc ;
  char **argp ;
  void *tmp ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  size_t tmp___0 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;

  {
#line 494
  rargc = 0;
#line 497
  if (arglimit == 0) {
    {
#line 498
    arglimit = 10;
#line 499
    tmp = malloc((unsigned long )arglimit * sizeof(char *));
#line 499
    rargv = (char **)tmp;
    }
#line 500
    if ((unsigned long )rargv == (unsigned long )((void *)0)) {
      {
#line 500
      fatal("Out of memory");
      }
    }
  }
  {
#line 502
  suppressint ++;
#line 503
  __h = & mainobstack;
#line 503
  __o = __h;
#line 503
  tmp___0 = strlen((char const   *)line);
#line 503
  __len = (int )(tmp___0 + 1UL);
  }
#line 503
  if (__o->chunk_limit - __o->next_free < (long )__len) {
    {
#line 503
    _obstack_newchunk(__o, __len);
    }
  }
#line 503
  __o->next_free += __len;
#line 503
  __o1 = __h;
#line 503
  __value = (void *)__o1->object_base;
#line 503
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 503
    __o1->maybe_empty_object = 1U;
  }
#line 503
  if (sizeof(long ) < sizeof(void *)) {
#line 503
    tmp___1 = __o1->object_base;
  } else {
#line 503
    tmp___1 = (char *)0;
  }
#line 503
  if (sizeof(long ) < sizeof(void *)) {
#line 503
    tmp___2 = __o1->object_base;
  } else {
#line 503
    tmp___2 = (char *)0;
  }
#line 503
  __o1->next_free = tmp___1 + (((__o1->next_free - tmp___2) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 503
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 503
    __o1->next_free = __o1->chunk_limit;
  }
#line 503
  __o1->object_base = __o1->next_free;
#line 503
  argbuf = (char *)__value;
  {
#line 504
  while (1) {
    while_continue: /* CIL Label */ ;
#line 504
    suppressint --;
#line 504
    if (suppressint == 0) {
#line 504
      if (intpending) {
        {
#line 504
        intr(2);
        }
      }
    }
#line 504
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 505
  argp = rargv;
#line 506
  stringbase = line;
#line 507
  argbase = argbuf;
#line 508
  slrflag = 0;
  {
#line 509
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 509
    tmp___4 = argp;
#line 509
    argp ++;
#line 509
    tmp___5 = slurpstring();
#line 509
    *tmp___4 = tmp___5;
    }
#line 509
    if (! ((unsigned long )tmp___5 != (unsigned long )((void *)0))) {
#line 509
      goto while_break___0;
    }
#line 510
    rargc ++;
#line 511
    if (rargc == arglimit) {
      {
#line 512
      tmp___3 = realloc((void *)rargv, (unsigned long )(arglimit + 10) * sizeof(char *));
#line 512
      rargv = (char **)tmp___3;
      }
#line 513
      if ((unsigned long )rargv == (unsigned long )((void *)0)) {
        {
#line 513
        fatal("Out of memory");
        }
      }
#line 514
      argp = rargv + arglimit;
#line 515
      arglimit += 10;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 518
  *pargc = rargc;
#line 519
  if (parg) {
#line 519
    *parg = altarg;
  }
#line 520
  return (rargv);
}
}
#line 532 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/main.c"
static char excl[2]  = {      (char )'!',      (char )'\000'};
#line 532 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/main.c"
static char dols[2]  = {      (char )'$',      (char )'\000'};
#line 528 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/main.c"
static char *slurpstring(void) 
{ 
  int got_one ;
  register char *sb ;
  register char *ap ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 534
  got_one = 0;
#line 535
  sb = stringbase;
#line 536
  ap = argbase;
#line 537
  tmp = argbase;
#line 539
  if ((int )*sb == 33) {
#line 539
    goto _L;
  } else
#line 539
  if ((int )*sb == 36) {
    _L: /* CIL Label */ 
    {
#line 541
    if (slrflag == 0) {
#line 541
      goto case_0;
    }
#line 546
    if (slrflag == 1) {
#line 546
      goto case_1;
    }
#line 550
    goto switch_default;
    case_0: /* CIL Label */ 
#line 542
    slrflag ++;
#line 543
    stringbase ++;
#line 544
    if ((int )*sb == 33) {
#line 544
      tmp___0 = excl;
    } else {
#line 544
      tmp___0 = dols;
    }
#line 544
    return (tmp___0);
    case_1: /* CIL Label */ 
#line 547
    slrflag ++;
#line 548
    altarg = stringbase;
#line 549
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 551
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  S0: 
  {
#line 558
  if ((int )*sb == 0) {
#line 558
    goto case_0___0;
  }
#line 562
  if ((int )*sb == 9) {
#line 562
    goto case_9;
  }
#line 562
  if ((int )*sb == 32) {
#line 562
    goto case_9;
  }
#line 565
  goto switch_default___0;
  case_0___0: /* CIL Label */ 
#line 559
  goto OUT;
  case_9: /* CIL Label */ 
  case_32: /* CIL Label */ 
#line 563
  sb ++;
#line 563
  goto S0;
  switch_default___0: /* CIL Label */ 
  {
#line 567
  if (slrflag == 0) {
#line 567
    goto case_0___1;
  }
#line 570
  if (slrflag == 1) {
#line 570
    goto case_1___0;
  }
#line 574
  goto switch_default___1;
  case_0___1: /* CIL Label */ 
#line 568
  slrflag ++;
#line 569
  goto switch_break___1;
  case_1___0: /* CIL Label */ 
#line 571
  slrflag ++;
#line 572
  altarg = sb;
#line 573
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 575
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 577
  goto S1;
  switch_break___0: /* CIL Label */ ;
  }
  S1: 
  {
#line 585
  if ((int )*sb == 0) {
#line 585
    goto case_0___2;
  }
#line 585
  if ((int )*sb == 9) {
#line 585
    goto case_0___2;
  }
#line 585
  if ((int )*sb == 32) {
#line 585
    goto case_0___2;
  }
#line 588
  if ((int )*sb == 92) {
#line 588
    goto case_92;
  }
#line 591
  if ((int )*sb == 34) {
#line 591
    goto case_34;
  }
#line 594
  goto switch_default___2;
  case_0___2: /* CIL Label */ 
  case_9___0: /* CIL Label */ 
  case_32___0: /* CIL Label */ 
#line 586
  goto OUT;
  case_92: /* CIL Label */ 
#line 589
  sb ++;
#line 589
  goto S2;
  case_34: /* CIL Label */ 
#line 592
  sb ++;
#line 592
  goto S3;
  switch_default___2: /* CIL Label */ 
#line 595
  tmp___1 = ap;
#line 595
  ap ++;
#line 595
  tmp___2 = sb;
#line 595
  sb ++;
#line 595
  *tmp___1 = *tmp___2;
#line 596
  got_one = 1;
#line 597
  goto S1;
  switch_break___2: /* CIL Label */ ;
  }
  S2: 
  {
#line 603
  if ((int )*sb == 0) {
#line 603
    goto case_0___3;
  }
#line 606
  goto switch_default___3;
  case_0___3: /* CIL Label */ 
#line 604
  goto OUT;
  switch_default___3: /* CIL Label */ 
#line 607
  tmp___3 = ap;
#line 607
  ap ++;
#line 607
  tmp___4 = sb;
#line 607
  sb ++;
#line 607
  *tmp___3 = *tmp___4;
#line 608
  got_one = 1;
#line 609
  goto S1;
  switch_break___3: /* CIL Label */ ;
  }
  S3: 
  {
#line 615
  if ((int )*sb == 0) {
#line 615
    goto case_0___4;
  }
#line 618
  if ((int )*sb == 34) {
#line 618
    goto case_34___0;
  }
#line 621
  goto switch_default___4;
  case_0___4: /* CIL Label */ 
#line 616
  goto OUT;
  case_34___0: /* CIL Label */ 
#line 619
  sb ++;
#line 619
  goto S1;
  switch_default___4: /* CIL Label */ 
#line 622
  tmp___5 = ap;
#line 622
  ap ++;
#line 622
  tmp___6 = sb;
#line 622
  sb ++;
#line 622
  *tmp___5 = *tmp___6;
#line 623
  got_one = 1;
#line 624
  goto S3;
  switch_break___4: /* CIL Label */ ;
  }
  OUT: 
#line 628
  if (got_one) {
#line 629
    tmp___7 = ap;
#line 629
    ap ++;
#line 629
    *tmp___7 = (char )'\000';
  }
#line 630
  argbase = ap;
#line 631
  stringbase = sb;
#line 632
  if (got_one) {
#line 633
    return (tmp);
  }
  {
#line 636
  if (slrflag == 0) {
#line 636
    goto case_0___5;
  }
#line 639
  if (slrflag == 1) {
#line 639
    goto case_1___1;
  }
#line 643
  goto switch_default___5;
  case_0___5: /* CIL Label */ 
#line 637
  slrflag ++;
#line 638
  goto switch_break___5;
  case_1___1: /* CIL Label */ 
#line 640
  slrflag ++;
#line 641
  altarg = (char *)((void *)0);
#line 642
  goto switch_break___5;
  switch_default___5: /* CIL Label */ 
#line 644
  goto switch_break___5;
  switch_break___5: /* CIL Label */ ;
  }
#line 646
  return ((char *)((void *)0));
}
}
#line 655 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/main.c"
void help(int argc , char **argv ) 
{ 
  struct cmd *c ;
  int i ;
  int j ;
  int w ;
  unsigned int k ;
  int columns ;
  int width ;
  int lines ;
  int len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  register char *arg ;

  {
#line 660
  if (argc == 1) {
    {
#line 663
    width = 0;
#line 665
    printf((char const   */* __restrict  */)"Commands may be abbreviated.  Commands are:\n\n");
#line 666
    c = cmdtab;
    }
    {
#line 666
    while (1) {
      while_continue: /* CIL Label */ ;
#line 666
      if (! ((unsigned long )c < (unsigned long )(& cmdtab[NCMDS]))) {
#line 666
        goto while_break;
      }
      {
#line 667
      tmp = strlen(c->c_name);
#line 667
      len = (int )tmp;
      }
#line 669
      if (len > width) {
#line 670
        width = len;
      }
#line 666
      c ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 672
    width = (width + 8) & -8;
#line 673
    columns = 80 / width;
#line 674
    if (columns == 0) {
#line 675
      columns = 1;
    }
#line 676
    lines = ((NCMDS + columns) - 1) / columns;
#line 677
    i = 0;
    {
#line 677
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 677
      if (! (i < lines)) {
#line 677
        goto while_break___0;
      }
#line 678
      j = 0;
      {
#line 678
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 678
        if (! (j < columns)) {
#line 678
          goto while_break___1;
        }
#line 679
        c = (cmdtab + j * lines) + i;
#line 680
        if (c->c_name) {
#line 680
          if (! proxy) {
            {
#line 681
            printf((char const   */* __restrict  */)"%s", c->c_name);
            }
          } else
#line 680
          if (c->c_proxy) {
            {
#line 681
            printf((char const   */* __restrict  */)"%s", c->c_name);
            }
          } else {
#line 680
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 683
        if (c->c_name) {
#line 684
          k = 0U;
          {
#line 684
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 684
            tmp___0 = strlen(c->c_name);
            }
#line 684
            if (! ((size_t )k < tmp___0)) {
#line 684
              goto while_break___2;
            }
            {
#line 685
            putchar(' ');
#line 684
            k ++;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
        }
#line 688
        if ((unsigned long )(c + lines) >= (unsigned long )(& cmdtab[NCMDS])) {
          {
#line 689
          printf((char const   */* __restrict  */)"\n");
          }
#line 690
          goto while_break___1;
        }
        {
#line 692
        tmp___1 = strlen(c->c_name);
#line 692
        w = (int )tmp___1;
        }
        {
#line 693
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 693
          if (! (w < width)) {
#line 693
            goto while_break___3;
          }
          {
#line 694
          w = (w + 8) & -8;
#line 695
          putchar('\t');
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 678
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 677
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 699
    return;
  }
  {
#line 701
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 701
    argc --;
#line 701
    if (! (argc > 0)) {
#line 701
      goto while_break___4;
    }
    {
#line 703
    argv ++;
#line 703
    arg = *argv;
#line 704
    c = getcmd((char const   *)arg);
    }
#line 705
    if ((unsigned long )c == (unsigned long )((struct cmd *)-1)) {
      {
#line 706
      printf((char const   */* __restrict  */)"?Ambiguous help command %s\n", arg);
      }
    } else
#line 707
    if ((unsigned long )c == (unsigned long )((void *)0)) {
      {
#line 708
      printf((char const   */* __restrict  */)"?Invalid help command %s\n", arg);
      }
    } else {
      {
#line 710
      printf((char const   */* __restrict  */)"%-*s\t%s\n", (int )sizeof("directory"),
             c->c_name, c->c_help);
      }
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 713
  return;
}
}
#line 715 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/main.c"
static void resetstack(struct obstack *stack ) 
{ 
  struct obstack *__o ;
  void *__obj ;
  char *tmp ;

  {
#line 718
  __o = stack;
#line 718
  __obj = (void *)0;
#line 718
  if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 718
    if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 718
      tmp = (char *)__obj;
#line 718
      __o->object_base = tmp;
#line 718
      __o->next_free = tmp;
    } else {
      {
#line 718
      obstack_free(__o, __obj);
      }
    }
  } else {
    {
#line 718
    obstack_free(__o, __obj);
    }
  }
  {
#line 719
  _obstack_begin(stack, 0, 0, (void *(*)(long  ))(& malloc), (void (*)(void * ))(& free));
  }
#line 720
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 37 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp.c"
char ftp_rcsid[53]  = 
#line 37 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp.c"
  {      (char )'$',      (char )'I',      (char )'d',      (char )':', 
        (char )' ',      (char )'f',      (char )'t',      (char )'p', 
        (char )'.',      (char )'c',      (char )',',      (char )'v', 
        (char )' ',      (char )'1',      (char )'.',      (char )'2', 
        (char )'5',      (char )' ',      (char )'1',      (char )'9', 
        (char )'9',      (char )'9',      (char )'/',      (char )'1', 
        (char )'2',      (char )'/',      (char )'1',      (char )'3', 
        (char )' ',      (char )'2',      (char )'0',      (char )':', 
        (char )'3',      (char )'3',      (char )':',      (char )'2', 
        (char )'0',      (char )' ',      (char )'d',      (char )'h', 
        (char )'o',      (char )'l',      (char )'l',      (char )'a', 
        (char )'n',      (char )'d',      (char )' ',      (char )'E', 
        (char )'x',      (char )'p',      (char )' ',      (char )'$', 
        (char )'\000'};
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 284 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 149
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 64 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) inet_ntop)(int __af ,
                                                                                          void const   * __restrict  __cp ,
                                                                                          char * __restrict  __buf ,
                                                                                          socklen_t __len ) ;
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 306 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 377
extern int vprintf(char const   * __restrict  __format , __gnuc_va_list __arg ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 773
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 873
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 879
extern int pclose(FILE *__stream ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 517
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) rindex)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 334
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 432
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 531
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 948
extern char *( __attribute__((__nonnull__(1))) getpass)(char const   *__prompt ) ;
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 671
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) gai_strerror)(int __ecode ) ;
#line 163 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
char *hookup(char *host , int port ) ;
#line 166
int dologin(char const   *host ) ;
#line 167
int command(char const   *fmt  , ...) ;
#line 168
void sendrequest(char const   *cmd , char *local , char *remote , int printnames ) ;
#line 169
void recvrequest(char const   *cmd , char * volatile  local , char *remote , char const   *lmode ,
                 int printnames ) ;
#line 174
int getreply(int expecteof ) ;
#line 175
void domacro(int argc , char **argv ) ;
#line 180
void changetype(int newtype , int show ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.h"
void reset(void) ;
#line 5 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/../version.h"
char pkg[27]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/../version.h"
  {      (char )'$',      (char )'N',      (char )'e',      (char )'t', 
        (char )'K',      (char )'i',      (char )'t',      (char )':', 
        (char )' ',      (char )'n',      (char )'e',      (char )'t', 
        (char )'k',      (char )'i',      (char )'t',      (char )'-', 
        (char )'f',      (char )'t',      (char )'p',      (char )'-', 
        (char )'0',      (char )'.',      (char )'1',      (char )'7', 
        (char )' ',      (char )'$',      (char )'\000'};
#line 71 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp.c"
int data  =    -1;
#line 72 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp.c"
off_t restart_point  =    (off_t )0;
#line 74 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp.c"
static char ipstring[46]  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp.c"
static struct sockaddr_storage hisctladdr  ;
#line 77 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp.c"
static struct sockaddr_storage data_addr  ;
#line 78 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp.c"
static struct sockaddr_storage myctladdr  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp.c"
static int ptflag  =    0;
#line 80 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp.c"
static int ptabflg  =    0;
#line 85
static char *gunique(char *local ) ;
#line 86
static void proxtrans(char const   *cmd , char *local , char *remote ) ;
#line 87
static int initconn(void) ;
#line 88
static void ptransfer(char const   *direction , off_t bytes , struct timeval  const  *t0 ,
                      struct timeval  const  *t1 ) ;
#line 91
static void tvsub(struct timeval *tdiff , struct timeval  const  *t1 , struct timeval  const  *t0 ) ;
#line 94
static void abort_remote(FILE *din ) ;
#line 96 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp.c"
FILE *cin  ;
#line 96 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp.c"
FILE *cout  ;
#line 97
static FILE *dataconn(char const   *lmode ) ;
#line 98
static void printbytes(off_t bytes ) ;
#line 104 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp.c"
static void trivial_alarm(int sig ) 
{ 


  {
#line 108
  return;
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp.c"
static char hostnamebuf[256]  ;
#line 111 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp.c"
char *hookup(char *host , int port ) 
{ 
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aiptr ;
  struct sigaction sigact ;
  struct sigaction oldsigact ;
  int status___0 ;
  int volatile   s ;
  int tos ;
  int af_in_use ;
  socklen_t len ;
  sigjmp_buf jmploc ;
  sigjmp_buf * volatile  oldtoplevel ;
  int dupfd ;
  struct sockaddr_in *hisctl_sa4 ;
  struct sockaddr_in6 *hisctl_sa6 ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int oerrno ;
  int *tmp___4 ;
  struct in_addr *ctladdr4 ;
  struct in6_addr *ctladdr6 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  int *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  unsigned long tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int on ;
  int tmp___17 ;

  {
  {
#line 114
  ai = (struct addrinfo *)((void *)0);
#line 114
  aiptr = (struct addrinfo *)((void *)0);
#line 117
  s = (int volatile   )-1;
#line 124
  hisctl_sa4 = (struct sockaddr_in *)(& hisctladdr);
#line 125
  hisctl_sa6 = (struct sockaddr_in6 *)(& hisctladdr);
#line 127
  memset((void *)(& hisctladdr), 0, sizeof(hisctladdr));
#line 129
  sigact.__sigaction_handler.sa_handler = & trivial_alarm;
#line 130
  sigemptyset(& sigact.sa_mask);
#line 131
  sigact.sa_flags = 0;
#line 133
  memset((void *)(& hints), 0, sizeof(hints));
#line 134
  hints.ai_flags = 34;
#line 135
  hints.ai_family = usefamily;
#line 136
  hints.ai_socktype = 1;
#line 138
  status___0 = getaddrinfo((char const   */* __restrict  */)host, (char const   */* __restrict  */)((void *)0),
                           (struct addrinfo  const  */* __restrict  */)(& hints),
                           (struct addrinfo **/* __restrict  */)(& ai));
  }
#line 138
  if (status___0) {
    {
#line 139
    tmp = gai_strerror(status___0);
#line 139
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ftp: %s: %s\n",
            host, tmp);
#line 141
    code = -1;
    }
#line 142
    return ((char *)0);
  }
  {
#line 145
  aiptr = ai;
#line 146
  memcpy((void */* __restrict  */)(& hisctladdr), (void const   */* __restrict  */)aiptr->ai_addr,
         (size_t )aiptr->ai_addrlen);
#line 147
  strncpy((char */* __restrict  */)(hostnamebuf), (char const   */* __restrict  */)aiptr->ai_canonname,
          sizeof(hostnamebuf));
#line 149
  hostnamebuf[sizeof(hostnamebuf) - 1UL] = (char)0;
#line 150
  hostname = hostnamebuf;
#line 152
  oldtoplevel = (sigjmp_buf */* volatile  */)toplevel;
#line 153
  tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(jmploc), 0);
  }
#line 153
  if (tmp___0) {
#line 154
    if (s >= (int volatile   )0) {
      {
#line 155
      close((int )s);
      }
    }
    {
#line 156
    toplevel = (sigjmp_buf *)oldtoplevel;
#line 157
    siglongjmp((struct __jmp_buf_tag *)(*toplevel), 1);
    }
  }
  {
#line 159
  toplevel = & jmploc;
#line 161
  suppressint ++;
#line 162
  tmp___1 = socket((int )hisctladdr.ss_family, 1, 0);
#line 162
  s = (int volatile   )tmp___1;
#line 163
  af_in_use = (int )hisctladdr.ss_family;
  }
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    suppressint --;
#line 164
    if (suppressint == 0) {
#line 164
      if (intpending) {
        {
#line 164
        intr(2);
        }
      }
    }
#line 164
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  if (s < (int volatile   )0) {
    {
#line 166
    perror("ftp: socket");
#line 167
    freeaddrinfo(ai);
#line 168
    code = -1;
    }
#line 169
    goto out;
  }
  {
#line 172
  if ((int )hisctladdr.ss_family == 2) {
#line 172
    goto case_2;
  }
#line 175
  if ((int )hisctladdr.ss_family == 10) {
#line 175
    goto case_10;
  }
#line 171
  goto switch_break;
  case_2: /* CIL Label */ 
#line 173
  hisctl_sa4->sin_port = (in_port_t )port;
#line 174
  goto switch_break;
  case_10: /* CIL Label */ 
#line 176
  hisctl_sa6->sin6_port = (in_port_t )port;
  switch_break: /* CIL Label */ ;
  }
  {
#line 179
  sigaction(14, (struct sigaction  const  */* __restrict  */)(& sigact), (struct sigaction */* __restrict  */)(& oldsigact));
#line 180
  alarm(10U);
  }
  {
#line 182
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 182
    if ((int )hisctladdr.ss_family == 2) {
#line 182
      tmp___11 = sizeof(struct sockaddr_in );
    } else {
#line 182
      tmp___11 = sizeof(struct sockaddr_in6 );
    }
    {
#line 182
    tmp___12 = connect((int )s, (struct sockaddr  const  *)((struct sockaddr *)(& hisctladdr)),
                       (socklen_t )tmp___11);
    }
#line 182
    if (! (tmp___12 < 0)) {
#line 182
      goto while_break___0;
    }
    {
#line 188
    alarm(0U);
#line 189
    sigaction(14, (struct sigaction  const  */* __restrict  */)(& oldsigact), (struct sigaction */* __restrict  */)((void *)0));
#line 190
    tmp___3 = __errno_location();
    }
#line 190
    if (*tmp___3 == 4) {
      {
#line 191
      tmp___2 = __errno_location();
#line 191
      *tmp___2 = 110;
      }
    }
#line 193
    if (aiptr) {
#line 193
      if (aiptr->ai_next) {
        {
#line 195
        tmp___4 = __errno_location();
#line 195
        oerrno = *tmp___4;
#line 196
        ctladdr4 = & hisctl_sa4->sin_addr;
#line 197
        ctladdr6 = & hisctl_sa6->sin6_addr;
        }
        {
#line 200
        if (aiptr->ai_family == 2) {
#line 200
          goto case_2___0;
        }
#line 207
        if (aiptr->ai_family == 10) {
#line 207
          goto case_10___0;
        }
#line 199
        goto switch_break___0;
        case_2___0: /* CIL Label */ 
        {
#line 201
        tmp___5 = inet_ntop(aiptr->ai_family, (void const   */* __restrict  */)ctladdr4,
                            (char */* __restrict  */)(ipstring), (socklen_t )sizeof(ipstring));
#line 201
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ftp: connect to address %s: ",
                tmp___5);
        }
#line 206
        goto switch_break___0;
        case_10___0: /* CIL Label */ 
        {
#line 208
        tmp___6 = inet_ntop(aiptr->ai_family, (void const   */* __restrict  */)ctladdr6,
                            (char */* __restrict  */)(ipstring), (socklen_t )sizeof(ipstring));
#line 208
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ftp: connect to address %s: ",
                tmp___6);
        }
        switch_break___0: /* CIL Label */ ;
        }
        {
#line 214
        tmp___7 = __errno_location();
#line 214
        *tmp___7 = oerrno;
#line 215
        perror((char const   *)((char *)0));
#line 217
        aiptr = aiptr->ai_next;
#line 218
        memcpy((void */* __restrict  */)(& hisctladdr), (void const   */* __restrict  */)aiptr->ai_addr,
               (size_t )aiptr->ai_addrlen);
        }
        {
#line 221
        if ((int )hisctladdr.ss_family == 2) {
#line 221
          goto case_2___1;
        }
#line 224
        if ((int )hisctladdr.ss_family == 10) {
#line 224
          goto case_10___1;
        }
#line 220
        goto switch_break___1;
        case_2___1: /* CIL Label */ 
#line 222
        hisctl_sa4->sin_port = (in_port_t )port;
#line 223
        goto switch_break___1;
        case_10___1: /* CIL Label */ 
#line 225
        hisctl_sa6->sin6_port = (in_port_t )port;
        switch_break___1: /* CIL Label */ ;
        }
        {
#line 229
        if (aiptr->ai_family == 2) {
#line 229
          goto case_2___2;
        }
#line 236
        if (aiptr->ai_family == 10) {
#line 236
          goto case_10___2;
        }
#line 228
        goto switch_break___2;
        case_2___2: /* CIL Label */ 
        {
#line 230
        tmp___8 = inet_ntop(aiptr->ai_family, (void const   */* __restrict  */)ctladdr4,
                            (char */* __restrict  */)(ipstring), (socklen_t )sizeof(ipstring));
#line 230
        fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Trying %s...\n",
                tmp___8);
        }
#line 235
        goto switch_break___2;
        case_10___2: /* CIL Label */ 
        {
#line 237
        tmp___9 = inet_ntop(aiptr->ai_family, (void const   */* __restrict  */)ctladdr6,
                            (char */* __restrict  */)(ipstring), (socklen_t )sizeof(ipstring));
#line 237
        fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Trying %s...\n",
                tmp___9);
        }
        switch_break___2: /* CIL Label */ ;
        }
        {
#line 243
        suppressint ++;
#line 244
        close((int )s);
#line 245
        tmp___10 = socket(aiptr->ai_family, 1, 0);
#line 245
        s = (int volatile   )tmp___10;
#line 246
        af_in_use = aiptr->ai_family;
        }
        {
#line 247
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 247
          suppressint --;
#line 247
          if (suppressint == 0) {
#line 247
            if (intpending) {
              {
#line 247
              intr(2);
              }
            }
          }
#line 247
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 248
        if (s < (int volatile   )0) {
          {
#line 249
          perror("ftp: socket");
#line 250
          freeaddrinfo(ai);
#line 251
          code = -1;
          }
#line 252
          goto out;
        }
#line 255
        goto while_continue___0;
      }
    }
    {
#line 258
    perror("ftp: connect");
#line 259
    freeaddrinfo(ai);
#line 260
    code = -1;
    }
#line 261
    goto bad;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 263
  alarm(0U);
#line 264
  sigaction(14, (struct sigaction  const  */* __restrict  */)(& oldsigact), (struct sigaction */* __restrict  */)((void *)0));
#line 266
  len = (socklen_t )sizeof(myctladdr);
#line 267
  tmp___13 = getsockname((int )s, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& myctladdr)),
                         (socklen_t */* __restrict  */)(& len));
  }
#line 267
  if (tmp___13 < 0) {
    {
#line 268
    perror("ftp: getsockname");
    }
#line 269
    if (ai) {
      {
#line 270
      freeaddrinfo(ai);
      }
    }
#line 271
    code = -1;
#line 272
    goto bad;
  }
#line 274
  if (ai) {
    {
#line 275
    freeaddrinfo(ai);
    }
  }
#line 277
  tos = 16;
#line 278
  if (af_in_use == 2) {
    {
#line 278
    tmp___14 = setsockopt((int )s, 0, 1, (void const   *)((char *)(& tos)), (socklen_t )sizeof(tos));
    }
#line 278
    if (tmp___14 < 0) {
      {
#line 281
      perror("ftp: setsockopt TOS (ignored)");
      }
    }
  }
#line 283
  suppressint ++;
#line 284
  if (cin) {
    {
#line 285
    fclose(cin);
    }
  }
#line 286
  if (cout) {
    {
#line 287
    fclose(cout);
    }
  }
  {
#line 288
  cin = fdopen((int )s, "r");
  }
#line 289
  if ((unsigned long )cin == (unsigned long )((void *)0)) {
    {
#line 290
    close((int )s);
    }
  }
  {
#line 291
  dupfd = dup((int )s);
#line 292
  tmp___15 = dup((int )s);
#line 292
  cout = fdopen(tmp___15, "w");
  }
#line 293
  if ((unsigned long )cout == (unsigned long )((void *)0)) {
#line 293
    if (dupfd >= 0) {
      {
#line 294
      close(dupfd);
      }
    }
  }
#line 295
  s = (int volatile   )-1;
#line 296
  toplevel = (sigjmp_buf *)oldtoplevel;
  {
#line 297
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 297
    suppressint --;
#line 297
    if (suppressint == 0) {
#line 297
      if (intpending) {
        {
#line 297
        intr(2);
        }
      }
    }
#line 297
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 298
  if ((unsigned long )cin == (unsigned long )((void *)0)) {
#line 298
    goto _L;
  } else
#line 298
  if ((unsigned long )cout == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
    {
#line 299
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ftp: fdopen failed.\n");
    }
#line 300
    if (cin) {
      {
#line 301
      suppressint ++;
#line 302
      fclose(cin);
#line 303
      cin = (FILE *)((void *)0);
      }
      {
#line 304
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 304
        suppressint --;
#line 304
        if (suppressint == 0) {
#line 304
          if (intpending) {
            {
#line 304
            intr(2);
            }
          }
        }
#line 304
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 306
    if (cout) {
      {
#line 307
      suppressint ++;
#line 308
      fclose(cout);
#line 309
      cout = (FILE *)((void *)0);
      }
      {
#line 310
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 310
        suppressint --;
#line 310
        if (suppressint == 0) {
#line 310
          if (intpending) {
            {
#line 310
            intr(2);
            }
          }
        }
#line 310
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 312
    code = -1;
#line 313
    goto out;
  }
#line 315
  if (verbose) {
    {
#line 316
    printf((char const   */* __restrict  */)"Connected to %s.\n", hostname);
    }
  }
  {
#line 317
  tmp___16 = getreply(0);
  }
#line 317
  if (tmp___16 > 2) {
    {
#line 318
    suppressint ++;
#line 319
    fclose(cin);
#line 320
    fclose(cout);
#line 321
    cin = (FILE *)((void *)0);
#line 322
    cout = (FILE *)((void *)0);
    }
    {
#line 323
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 323
      suppressint --;
#line 323
      if (suppressint == 0) {
#line 323
        if (intpending) {
          {
#line 323
          intr(2);
          }
        }
      }
#line 323
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 324
    code = -1;
#line 325
    goto out;
  }
  {
#line 329
  on = 1;
#line 331
  tmp___17 = setsockopt((int )s, 1, 10, (void const   *)((char *)(& on)), (socklen_t )sizeof(on));
  }
#line 331
  if (tmp___17 < 0) {
#line 331
    if (debug) {
      {
#line 333
      perror("ftp: setsockopt");
      }
    }
  }
#line 338
  return (hostname);
  bad: 
  {
#line 340
  suppressint ++;
#line 341
  close((int )s);
#line 342
  s = (int volatile   )-1;
  }
  {
#line 343
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 343
    suppressint --;
#line 343
    if (suppressint == 0) {
#line 343
      if (intpending) {
        {
#line 343
        intr(2);
        }
      }
    }
#line 343
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  out: 
#line 345
  toplevel = (sigjmp_buf *)oldtoplevel;
#line 346
  return ((char *)0);
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp.c"
int dologin(char const   *host ) 
{ 
  char tmp[80] ;
  char *luser ;
  char *pass ;
  char *zacct ;
  int n ;
  int aflag ;
  int tmp___0 ;
  char *myname ;
  char *tmp___1 ;
  struct passwd *pp ;
  __uid_t tmp___2 ;
  struct passwd *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int margc ;
  char **margv ;
  char *oldline ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___6 ;
  char *tmp___7 ;
  struct obstack *__o___0 ;
  void *__obj ;
  char *tmp___8 ;
  int tmp___9 ;

  {
  {
#line 354
  aflag = 0;
#line 356
  zacct = (char *)0;
#line 356
  pass = zacct;
#line 356
  luser = pass;
#line 357
  suppressint ++;
#line 358
  tmp___0 = xruserpass(host, & luser, & pass, & zacct);
  }
#line 358
  if (tmp___0 < 0) {
    {
#line 359
    while (1) {
      while_continue: /* CIL Label */ ;
#line 359
      suppressint --;
#line 359
      if (suppressint == 0) {
#line 359
        if (intpending) {
          {
#line 359
          intr(2);
          }
        }
      }
#line 359
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 360
    code = -1;
#line 361
    return (0);
  }
  {
#line 363
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 363
    suppressint --;
#line 363
    if (suppressint == 0) {
#line 363
      if (intpending) {
        {
#line 363
        intr(2);
        }
      }
    }
#line 363
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 364
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 364
    if (! ((unsigned long )luser == (unsigned long )((void *)0))) {
#line 364
      goto while_break___1;
    }
    {
#line 365
    tmp___1 = getlogin();
#line 365
    myname = tmp___1;
    }
#line 367
    if ((unsigned long )myname == (unsigned long )((void *)0)) {
      {
#line 368
      tmp___2 = getuid();
#line 368
      tmp___3 = getpwuid(tmp___2);
#line 368
      pp = tmp___3;
      }
#line 370
      if ((unsigned long )pp != (unsigned long )((void *)0)) {
#line 371
        myname = pp->pw_name;
      }
    }
#line 373
    if (myname) {
      {
#line 374
      printf((char const   */* __restrict  */)"Name (%s:%s): ", host, myname);
      }
    } else {
      {
#line 376
      printf((char const   */* __restrict  */)"Name (%s): ", host);
      }
    }
    {
#line 377
    tmp___4 = fgets((char */* __restrict  */)(tmp), (int )sizeof(tmp), (FILE */* __restrict  */)stdin);
    }
#line 377
    if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
      {
#line 378
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nLogin failed.\n");
      }
#line 379
      return (0);
    }
    {
#line 381
    tmp___5 = strlen((char const   *)(tmp));
#line 381
    n = (int )tmp___5;
    }
#line 382
    if ((int )tmp[n - 1] == 10) {
#line 383
      tmp[n - 1] = (char)0;
    }
#line 384
    if ((int )tmp[0] == 0) {
#line 385
      luser = myname;
    } else {
#line 387
      luser = tmp;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 389
  n = command("USER %s", luser);
  }
#line 390
  if (n == 3) {
#line 391
    if ((unsigned long )pass == (unsigned long )((void *)0)) {
      {
#line 393
      pass = getpass("Password:");
      }
    }
    {
#line 395
    n = command("PASS %s", pass);
    }
  }
#line 397
  if (n == 3) {
    {
#line 398
    aflag ++;
#line 400
    zacct = getpass("Account:");
#line 401
    n = command("ACCT %s", zacct);
    }
  }
#line 403
  if (n != 2) {
    {
#line 404
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Login failed.\n");
    }
#line 405
    return (0);
  }
#line 407
  if (! aflag) {
#line 407
    if ((unsigned long )zacct != (unsigned long )((void *)0)) {
      {
#line 408
      command("ACCT %s", zacct);
      }
    }
  }
#line 409
  if (proxy) {
#line 410
    return (1);
  }
#line 411
  n = 0;
  {
#line 411
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 411
    if (! (n < macnum)) {
#line 411
      goto while_break___2;
    }
    {
#line 412
    tmp___9 = strcmp("init", (char const   *)(macros[n].mac_name));
    }
#line 412
    if (! tmp___9) {
#line 415
      oldline = line;
#line 416
      suppressint ++;
#line 417
      __h = & lineobstack;
#line 417
      __o = __h;
#line 417
      __len = 6;
#line 417
      if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
        {
#line 417
        _obstack_newchunk(__o, __len);
        }
      }
      {
#line 417
      memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)"$init",
             (size_t )__len);
#line 417
      __o->next_free += __len;
#line 417
      __o1 = __h;
#line 417
      __value = (void *)__o1->object_base;
      }
#line 417
      if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 417
        __o1->maybe_empty_object = 1U;
      }
#line 417
      if (sizeof(long ) < sizeof(void *)) {
#line 417
        tmp___6 = __o1->object_base;
      } else {
#line 417
        tmp___6 = (char *)0;
      }
#line 417
      if (sizeof(long ) < sizeof(void *)) {
#line 417
        tmp___7 = __o1->object_base;
      } else {
#line 417
        tmp___7 = (char *)0;
      }
#line 417
      __o1->next_free = tmp___6 + (((__o1->next_free - tmp___7) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 417
      if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 417
        __o1->next_free = __o1->chunk_limit;
      }
#line 417
      __o1->object_base = __o1->next_free;
#line 417
      line = (char *)__value;
      {
#line 418
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 418
        suppressint --;
#line 418
        if (suppressint == 0) {
#line 418
          if (intpending) {
            {
#line 418
            intr(2);
            }
          }
        }
#line 418
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 419
      margv = makeargv(& margc, (char **)((void *)0));
#line 420
      domacro(margc, margv);
#line 421
      suppressint ++;
#line 422
      __o___0 = & lineobstack;
#line 422
      __obj = (void *)line;
      }
#line 422
      if ((unsigned long )__obj > (unsigned long )((void *)__o___0->chunk)) {
#line 422
        if ((unsigned long )__obj < (unsigned long )((void *)__o___0->chunk_limit)) {
#line 422
          tmp___8 = (char *)__obj;
#line 422
          __o___0->object_base = tmp___8;
#line 422
          __o___0->next_free = tmp___8;
        } else {
          {
#line 422
          obstack_free(__o___0, __obj);
          }
        }
      } else {
        {
#line 422
        obstack_free(__o___0, __obj);
        }
      }
      {
#line 423
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 423
        suppressint --;
#line 423
        if (suppressint == 0) {
#line 423
          if (intpending) {
            {
#line 423
            intr(2);
            }
          }
        }
#line 423
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 424
      line = oldline;
#line 425
      goto while_break___2;
    }
#line 411
    n ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 428
  return (1);
}
}
#line 431 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp.c"
int command(char const   *fmt  , ...) 
{ 
  va_list ap ;
  int r ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 437
  if (debug) {
    {
#line 438
    printf((char const   */* __restrict  */)"---> ");
#line 439
    __builtin_va_start(ap, fmt);
#line 440
    tmp = strncmp("PASS ", fmt, (size_t )5);
    }
#line 440
    if (tmp == 0) {
      {
#line 441
      printf((char const   */* __restrict  */)"PASS XXXX");
      }
    } else {
      {
#line 443
      vprintf((char const   */* __restrict  */)fmt, ap);
      }
    }
    {
#line 444
    __builtin_va_end(ap);
#line 445
    printf((char const   */* __restrict  */)"\n");
#line 446
    fflush(stdout);
    }
  }
#line 448
  if ((unsigned long )cout == (unsigned long )((void *)0)) {
    {
#line 449
    perror("No control connection for command");
#line 450
    code = -1;
    }
#line 451
    return (0);
  }
  {
#line 453
  suppressint ++;
#line 454
  intrnewline ++;
#line 455
  __builtin_va_start(ap, fmt);
#line 456
  vfprintf((FILE */* __restrict  */)cout, (char const   */* __restrict  */)fmt, ap);
#line 457
  __builtin_va_end(ap);
#line 458
  fputs((char const   */* __restrict  */)"\r\n", (FILE */* __restrict  */)cout);
#line 459
  tmp___0 = fflush(cout);
  }
#line 459
  if (tmp___0 == -1) {
#line 460
    goto outerr;
  }
  {
#line 461
  cpend = 1;
#line 462
  tmp___1 = strcmp(fmt, "QUIT");
  }
#line 462
  if (tmp___1) {
#line 462
    tmp___2 = 0;
  } else {
#line 462
    tmp___2 = 1;
  }
  {
#line 462
  r = getreply(tmp___2);
#line 463
  intrnewline --;
  }
  {
#line 464
  while (1) {
    while_continue: /* CIL Label */ ;
#line 464
    suppressint --;
#line 464
    if (suppressint == 0) {
#line 464
      if (intpending) {
        {
#line 464
        intr(2);
        }
      }
    }
#line 464
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 465
  return (r);
  outerr: 
  {
#line 467
  lostpeer(0);
  }
  {
#line 468
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 468
    suppressint --;
#line 468
    if (suppressint == 0) {
#line 468
      if (intpending) {
        {
#line 468
        intr(2);
        }
      }
    }
#line 468
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 469
  if (verbose) {
    {
#line 470
    printf((char const   */* __restrict  */)"421 Service not available, remote server has closed connection\n");
#line 471
    fflush(stdout);
    }
  }
#line 473
  code = 421;
#line 474
  return (4);
}
}
#line 477 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp.c"
char reply_string[8192]  ;
#line 481 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp.c"
int getreply(int expecteof ) 
{ 
  register int c ;
  register int n ;
  register int dig ;
  register char *cp ;
  int originalcode ;
  int continuation ;
  int pflag ;
  size_t px ;
  size_t psize ;
  int tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;

  {
#line 487
  originalcode = 0;
#line 487
  continuation = 0;
#line 488
  pflag = 0;
#line 489
  px = (size_t )0;
#line 490
  psize = sizeof(pasv);
#line 492
  if (! cin) {
#line 493
    cpend = 0;
#line 494
    return (4);
  } else
#line 492
  if (! cout) {
#line 493
    cpend = 0;
#line 494
    return (4);
  }
#line 496
  suppressint ++;
#line 497
  intrnewline ++;
  {
#line 498
  while (1) {
    while_continue: /* CIL Label */ ;
#line 499
    code = 0;
#line 499
    n = code;
#line 499
    dig = n;
#line 500
    cp = reply_string;
    {
#line 501
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 501
      c = _IO_getc(cin);
      }
#line 501
      if (! (c != 10)) {
#line 501
        goto while_break___0;
      }
#line 502
      if (c == 255) {
        {
#line 503
        c = _IO_getc(cin);
        }
        {
#line 505
        if (c == 252) {
#line 505
          goto case_252;
        }
#line 505
        if (c == 251) {
#line 505
          goto case_252;
        }
#line 513
        if (c == 254) {
#line 513
          goto case_254;
        }
#line 513
        if (c == 253) {
#line 513
          goto case_254;
        }
#line 520
        goto switch_default;
        case_252: /* CIL Label */ 
        case_251: /* CIL Label */ 
        {
#line 506
        c = _IO_getc(cin);
        }
#line 506
        if (c == -1) {
#line 507
          goto goteof;
        }
        {
#line 508
        fprintf((FILE */* __restrict  */)cout, (char const   */* __restrict  */)"%c%c%c",
                255, 254, c);
#line 509
        tmp = fflush(cout);
        }
#line 509
        if (tmp == -1) {
#line 510
          goto goteof;
        }
#line 511
        goto switch_break;
        case_254: /* CIL Label */ 
        case_253: /* CIL Label */ 
        {
#line 514
        c = _IO_getc(cin);
        }
#line 514
        if (c == -1) {
#line 515
          goto goteof;
        }
        {
#line 516
        fprintf((FILE */* __restrict  */)cout, (char const   */* __restrict  */)"%c%c%c",
                255, 252, c);
#line 517
        tmp___0 = fflush(cout);
        }
#line 517
        if (tmp___0 == -1) {
#line 518
          goto goteof;
        }
#line 519
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 521
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 523
        goto while_continue___0;
      }
#line 525
      dig ++;
#line 526
      if (c == -1) {
#line 527
        if (expecteof) {
#line 528
          intrnewline --;
          {
#line 529
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 529
            suppressint --;
#line 529
            if (suppressint == 0) {
#line 529
              if (intpending) {
                {
#line 529
                intr(2);
                }
              }
            }
#line 529
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 530
          code = 221;
#line 531
          return (0);
        }
        goteof: 
        {
#line 534
        lostpeer(0);
#line 535
        intrnewline --;
        }
        {
#line 536
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 536
          suppressint --;
#line 536
          if (suppressint == 0) {
#line 536
            if (intpending) {
              {
#line 536
              intr(2);
              }
            }
          }
#line 536
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 537
        if (verbose) {
          {
#line 538
          printf((char const   */* __restrict  */)"421 Service not available, remote server has closed connection\n");
#line 539
          fflush(stdout);
          }
        }
#line 541
        code = 421;
#line 542
        return (4);
      }
#line 544
      if (c != 13) {
#line 544
        if (verbose > 0) {
#line 544
          goto _L;
        } else
#line 544
        if (verbose > -1) {
#line 544
          if (n == 53) {
#line 544
            if (dig > 4) {
              _L: /* CIL Label */ 
#line 546
              if (proxflag) {
#line 546
                if (dig == 1) {
                  {
#line 548
                  printf((char const   */* __restrict  */)"%s:", hostname);
                  }
                } else
#line 546
                if (dig == 5) {
#line 546
                  if (verbose == 0) {
                    {
#line 548
                    printf((char const   */* __restrict  */)"%s:", hostname);
                    }
                  }
                }
              }
              {
#line 549
              putchar(c);
              }
            }
          }
        }
      }
#line 551
      if (dig < 4) {
        {
#line 551
        tmp___1 = __ctype_b_loc();
        }
#line 551
        if ((int const   )*(*tmp___1 + c) & 2048) {
#line 552
          code = code * 10 + (c - 48);
        }
      }
#line 553
      if (! pflag) {
#line 553
        if (code == 227) {
#line 554
          pflag = 1;
        } else
#line 553
        if (code == 229) {
#line 554
          pflag = 1;
        }
      }
#line 555
      if (dig > 4) {
#line 555
        if (pflag == 1) {
          {
#line 555
          tmp___2 = __ctype_b_loc();
          }
#line 555
          if ((int const   )*(*tmp___2 + c) & 2048) {
#line 556
            pflag = 2;
          }
        }
      }
#line 557
      if (pflag == 2) {
#line 558
        if (c != 13) {
#line 558
          if (c != 41) {
#line 559
            if (px < psize - 1UL) {
#line 559
              tmp___3 = px;
#line 559
              px ++;
#line 559
              pasv[tmp___3] = (char )c;
            }
          } else {
#line 562
            pasv[px] = (char )'\000';
#line 563
            pflag = 3;
          }
        } else {
#line 562
          pasv[px] = (char )'\000';
#line 563
          pflag = 3;
        }
      }
#line 566
      if (dig == 4) {
#line 566
        if (c == 45) {
#line 567
          if (continuation) {
#line 568
            code = 0;
          }
#line 569
          continuation ++;
        }
      }
#line 571
      if (n == 0) {
#line 572
        n = c;
      }
#line 573
      if ((unsigned long )cp < (unsigned long )(& reply_string[sizeof(reply_string) - 1UL])) {
#line 574
        tmp___4 = cp;
#line 574
        cp ++;
#line 574
        *tmp___4 = (char )c;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 576
    if (verbose > 0) {
      {
#line 577
      putchar(c);
#line 578
      fflush(stdout);
      }
    } else
#line 576
    if (verbose > -1) {
#line 576
      if (n == 53) {
        {
#line 577
        putchar(c);
#line 578
        fflush(stdout);
        }
      }
    }
#line 580
    if (continuation) {
#line 580
      if (code != originalcode) {
#line 581
        if (originalcode == 0) {
#line 582
          originalcode = code;
        }
#line 583
        goto __Cont;
      }
    }
#line 585
    *cp = (char )'\000';
#line 586
    if (n != 49) {
#line 587
      cpend = 0;
    }
#line 588
    intrnewline --;
    {
#line 589
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 589
      suppressint --;
#line 589
      if (suppressint == 0) {
#line 589
        if (intpending) {
          {
#line 589
          intr(2);
          }
        }
      }
#line 589
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 590
    if (code == 421) {
#line 590
      goto _L___0;
    } else
#line 590
    if (originalcode == 421) {
      _L___0: /* CIL Label */ 
      {
#line 591
      suppressint ++;
#line 592
      lostpeer(0);
      }
      {
#line 593
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 593
        suppressint --;
#line 593
        if (suppressint == 0) {
#line 593
          if (intpending) {
            {
#line 593
            intr(2);
            }
          }
        }
#line 593
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 595
    return (n - 48);
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 599 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp.c"
static int empty(fd_set *mask , int hifd , int sec ) 
{ 
  struct timeval t ;
  int tmp ;

  {
  {
#line 604
  t.tv_sec = (long )sec;
#line 605
  t.tv_usec = (__suseconds_t )0;
#line 606
  tmp = select(hifd + 1, (fd_set */* __restrict  */)mask, (fd_set */* __restrict  */)((fd_set *)0),
               (fd_set */* __restrict  */)((fd_set *)0), (struct timeval */* __restrict  */)(& t));
  }
#line 606
  return (tmp);
}
}
#line 609 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp.c"
static void abortsend(int ignore ) 
{ 


  {
  {
#line 614
  mflag = 0;
#line 615
  printf((char const   */* __restrict  */)"\nsend aborted\nwaiting for remote to finish abort\n");
#line 616
  fflush(stdout);
  }
#line 617
  return;
}
}
#line 621 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp.c"
void sendrequest(char const   *cmd , char *local , char *remote , int printnames ) 
{ 
  struct stat st ;
  struct timeval start ;
  struct timeval stop ;
  register int c ;
  register int d ;
  FILE * volatile  fin ;
  FILE * volatile  dout ;
  int (* volatile  closefunc)(FILE * ) ;
  off_t volatile   bytes ;
  off_t volatile   hashbytes ;
  char buf___0[8192] ;
  char *bufp ;
  char const   * volatile  lmode ;
  sigjmp_buf jmploc ;
  sigjmp_buf * volatile  oldtoplevel ;
  int tmp ;
  FILE *tmp___0 ;
  FILE *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  FILE *tmp___17 ;
  int *tmp___18 ;
  int tmp___19 ;
  ssize_t tmp___20 ;
  int tmp___21 ;
  ssize_t tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int *tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;

  {
#line 627
  fin = (FILE */* volatile  */)0;
#line 627
  dout = (FILE */* volatile  */)0;
#line 629
  bytes = (off_t volatile   )0;
#line 629
  hashbytes = (off_t volatile   )1024;
#line 635
  if (verbose) {
#line 635
    if (printnames) {
#line 636
      if (local) {
#line 636
        if ((int )*local != 45) {
          {
#line 637
          printf((char const   */* __restrict  */)"local: %s ", local);
          }
        }
      }
#line 638
      if (remote) {
        {
#line 639
        printf((char const   */* __restrict  */)"remote: %s\n", remote);
        }
      }
    }
  }
#line 641
  if (proxy) {
    {
#line 642
    proxtrans(cmd, local, remote);
    }
#line 643
    return;
  }
#line 645
  if (curtype != type) {
    {
#line 646
    changetype(type, 0);
    }
  }
  {
#line 647
  closefunc = (int (*/* volatile  */)(FILE * ))((void *)0);
#line 648
  lmode = (char const   */* volatile  */)"w";
#line 649
  oldtoplevel = (sigjmp_buf */* volatile  */)toplevel;
#line 650
  tmp = __sigsetjmp((struct __jmp_buf_tag *)(jmploc), 1);
  }
#line 650
  if (tmp) {
    {
#line 651
    abortsend(2);
    }
    {
#line 652
    while (1) {
      while_continue: /* CIL Label */ ;
#line 652
      if (! cpend) {
#line 652
        goto while_break;
      }
      {
#line 653
      getreply(0);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 655
    if (data >= 0) {
      {
#line 656
      suppressint ++;
#line 657
      close(data);
#line 658
      data = -1;
      }
      {
#line 659
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 659
        suppressint --;
#line 659
        if (suppressint == 0) {
#line 659
          if (intpending) {
            {
#line 659
            intr(2);
            }
          }
        }
#line 659
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 661
    if ((unsigned long )fin != (unsigned long )((void *)0)) {
#line 661
      if ((unsigned long )closefunc != (unsigned long )((void *)0)) {
        {
#line 662
        (*closefunc)((FILE *)fin);
        }
      }
    }
#line 663
    toplevel = (sigjmp_buf *)oldtoplevel;
#line 664
    code = -1;
#line 665
    return;
  }
  {
#line 667
  toplevel = & jmploc;
#line 668
  tmp___6 = strcmp((char const   *)local, "-");
  }
#line 668
  if (tmp___6 == 0) {
#line 669
    fin = (FILE */* volatile  */)stdin;
  } else
#line 670
  if ((int )*local == 124) {
    {
#line 671
    closefunc = (int (*/* volatile  */)(FILE * ))(& pclose);
#line 672
    suppressint ++;
#line 673
    tmp___0 = popen((char const   *)(local + 1), "r");
#line 673
    fin = (FILE */* volatile  */)tmp___0;
    }
    {
#line 674
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 674
      suppressint --;
#line 674
      if (suppressint == 0) {
#line 674
        if (intpending) {
          {
#line 674
          intr(2);
          }
        }
      }
#line 674
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 675
    if ((unsigned long )fin == (unsigned long )((void *)0)) {
      {
#line 676
      perror((char const   *)(local + 1));
#line 677
      toplevel = (sigjmp_buf *)oldtoplevel;
#line 678
      code = -1;
      }
#line 679
      return;
    }
  } else {
    {
#line 682
    closefunc = (int (*/* volatile  */)(FILE * ))(& fclose);
#line 683
    suppressint ++;
#line 684
    tmp___1 = fopen((char const   */* __restrict  */)local, (char const   */* __restrict  */)"r");
#line 684
    fin = (FILE */* volatile  */)tmp___1;
    }
    {
#line 685
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 685
      suppressint --;
#line 685
      if (suppressint == 0) {
#line 685
        if (intpending) {
          {
#line 685
          intr(2);
          }
        }
      }
#line 685
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 686
    if ((unsigned long )fin == (unsigned long )((void *)0)) {
      {
#line 687
      tmp___2 = __errno_location();
#line 687
      tmp___3 = strerror(*tmp___2);
#line 687
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"local: %s: %s\n",
              local, tmp___3);
#line 689
      toplevel = (sigjmp_buf *)oldtoplevel;
#line 690
      code = -1;
      }
#line 691
      return;
    }
    {
#line 693
    tmp___4 = fileno((FILE *)fin);
#line 693
    tmp___5 = fstat(tmp___4, & st);
    }
#line 693
    if (tmp___5 < 0) {
#line 693
      goto _L;
    } else
#line 693
    if ((st.st_mode & 61440U) != 32768U) {
      _L: /* CIL Label */ 
      {
#line 695
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s: not a plain file.\n",
              local);
#line 696
      suppressint ++;
#line 697
      fclose((FILE *)fin);
#line 698
      fin = (FILE */* volatile  */)((void *)0);
      }
      {
#line 699
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 699
        suppressint --;
#line 699
        if (suppressint == 0) {
#line 699
          if (intpending) {
            {
#line 699
            intr(2);
            }
          }
        }
#line 699
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 700
      toplevel = (sigjmp_buf *)oldtoplevel;
#line 701
      code = -1;
#line 702
      return;
    }
  }
  {
#line 705
  tmp___7 = initconn();
  }
#line 705
  if (tmp___7) {
#line 706
    code = -1;
#line 707
    if ((unsigned long )closefunc != (unsigned long )((void *)0)) {
      {
#line 708
      suppressint ++;
#line 709
      (*closefunc)((FILE *)fin);
#line 710
      fin = (FILE */* volatile  */)((void *)0);
      }
      {
#line 711
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 711
        suppressint --;
#line 711
        if (suppressint == 0) {
#line 711
          if (intpending) {
            {
#line 711
            intr(2);
            }
          }
        }
#line 711
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 713
    toplevel = (sigjmp_buf *)oldtoplevel;
#line 714
    return;
  }
  {
#line 716
  tmp___8 = __sigsetjmp((struct __jmp_buf_tag *)(jmploc), 1);
  }
#line 716
  if (tmp___8) {
    {
#line 717
    abortsend(2);
    }
#line 718
    goto abort;
  }
#line 721
  if (restart_point) {
    {
#line 721
    tmp___13 = strcmp(cmd, "STOR");
    }
#line 721
    if (tmp___13 == 0) {
#line 721
      goto _L___0;
    } else {
      {
#line 721
      tmp___14 = strcmp(cmd, "APPE");
      }
#line 721
      if (tmp___14 == 0) {
        _L___0: /* CIL Label */ 
        {
#line 723
        tmp___11 = fseeko((FILE *)fin, restart_point, 0);
        }
#line 723
        if (tmp___11 < 0) {
          {
#line 724
          tmp___9 = __errno_location();
#line 724
          tmp___10 = strerror(*tmp___9);
#line 724
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"local: %s: %s\n",
                  local, tmp___10);
#line 726
          restart_point = (off_t )0;
          }
#line 727
          if ((unsigned long )closefunc != (unsigned long )((void *)0)) {
            {
#line 728
            suppressint ++;
#line 729
            (*closefunc)((FILE *)fin);
#line 730
            fin = (FILE */* volatile  */)((void *)0);
            }
            {
#line 731
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 731
              suppressint --;
#line 731
              if (suppressint == 0) {
#line 731
                if (intpending) {
                  {
#line 731
                  intr(2);
                  }
                }
              }
#line 731
              goto while_break___5;
            }
            while_break___5: /* CIL Label */ ;
            }
          }
#line 733
          toplevel = (sigjmp_buf *)oldtoplevel;
#line 734
          return;
        }
        {
#line 736
        tmp___12 = command("REST %jd", restart_point);
        }
#line 736
        if (tmp___12 != 3) {
#line 738
          restart_point = (off_t )0;
#line 739
          if ((unsigned long )closefunc != (unsigned long )((void *)0)) {
            {
#line 740
            suppressint ++;
#line 741
            (*closefunc)((FILE *)fin);
#line 742
            fin = (FILE */* volatile  */)((void *)0);
            }
            {
#line 743
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 743
              suppressint --;
#line 743
              if (suppressint == 0) {
#line 743
                if (intpending) {
                  {
#line 743
                  intr(2);
                  }
                }
              }
#line 743
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
          }
#line 745
          toplevel = (sigjmp_buf *)oldtoplevel;
#line 746
          return;
        }
#line 748
        restart_point = (off_t )0;
#line 749
        lmode = (char const   */* volatile  */)"r+w";
      }
    }
  }
#line 751
  if (remote) {
    {
#line 752
    tmp___15 = command("%s %s", cmd, remote);
    }
#line 752
    if (tmp___15 != 1) {
#line 753
      if ((unsigned long )closefunc != (unsigned long )((void *)0)) {
        {
#line 754
        suppressint ++;
#line 755
        (*closefunc)((FILE *)fin);
#line 756
        fin = (FILE */* volatile  */)((void *)0);
        }
        {
#line 757
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 757
          suppressint --;
#line 757
          if (suppressint == 0) {
#line 757
            if (intpending) {
              {
#line 757
              intr(2);
              }
            }
          }
#line 757
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
#line 759
      toplevel = (sigjmp_buf *)oldtoplevel;
#line 760
      return;
    }
  } else {
    {
#line 763
    tmp___16 = command("%s", cmd);
    }
#line 763
    if (tmp___16 != 1) {
#line 764
      if ((unsigned long )closefunc != (unsigned long )((void *)0)) {
        {
#line 765
        suppressint ++;
#line 766
        (*closefunc)((FILE *)fin);
#line 767
        fin = (FILE */* volatile  */)((void *)0);
        }
        {
#line 768
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 768
          suppressint --;
#line 768
          if (suppressint == 0) {
#line 768
            if (intpending) {
              {
#line 768
              intr(2);
              }
            }
          }
#line 768
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
      }
#line 770
      toplevel = (sigjmp_buf *)oldtoplevel;
#line 771
      return;
    }
  }
  {
#line 773
  suppressint ++;
#line 774
  tmp___17 = dataconn((char const   *)lmode);
#line 774
  dout = (FILE */* volatile  */)tmp___17;
  }
  {
#line 775
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 775
    suppressint --;
#line 775
    if (suppressint == 0) {
#line 775
      if (intpending) {
        {
#line 775
        intr(2);
        }
      }
    }
#line 775
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 776
  if ((unsigned long )dout == (unsigned long )((void *)0)) {
#line 777
    goto abort;
  }
  {
#line 778
  gettimeofday((struct timeval */* __restrict  */)(& start), (__timezone_ptr_t )((struct timezone *)0));
  }
  {
#line 782
  if (curtype == 4) {
#line 782
    goto case_4;
  }
#line 782
  if (curtype == 3) {
#line 782
    goto case_4;
  }
#line 822
  if (curtype == 1) {
#line 822
    goto case_1;
  }
#line 779
  goto switch_break;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 783
  tmp___18 = __errno_location();
#line 783
  d = 0;
#line 783
  *tmp___18 = d;
  }
  {
#line 784
  while (1) {
    while_continue___10: /* CIL Label */ ;
    {
#line 784
    tmp___21 = fileno((FILE *)fin);
#line 784
    tmp___22 = read(tmp___21, (void *)(buf___0), sizeof(buf___0));
#line 784
    c = (int )tmp___22;
    }
#line 784
    if (! (c > 0)) {
#line 784
      goto while_break___10;
    }
#line 785
    bytes += (off_t volatile   )c;
#line 786
    bufp = buf___0;
    {
#line 786
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 786
      if (! (c > 0)) {
#line 786
        goto while_break___11;
      }
      {
#line 787
      tmp___19 = fileno((FILE *)dout);
#line 787
      tmp___20 = write(tmp___19, (void const   *)bufp, (size_t )c);
#line 787
      d = (int )tmp___20;
      }
#line 787
      if (d <= 0) {
        {
#line 788
        perror("netout");
        }
#line 789
        goto while_break___11;
      }
#line 786
      c -= d;
#line 786
      bufp += d;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 791
    if (hash) {
      {
#line 792
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 792
        if (! (bytes >= hashbytes)) {
#line 792
          goto while_break___12;
        }
        {
#line 793
        putchar('#');
#line 794
        hashbytes += (off_t volatile   )1024;
        }
      }
      while_break___12: /* CIL Label */ ;
      }
      {
#line 796
      fflush(stdout);
      }
    }
#line 798
    if (tick) {
#line 798
      if (bytes >= hashbytes) {
        {
#line 799
        printbytes((off_t )bytes);
        }
        {
#line 800
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 800
          if (! (bytes >= hashbytes)) {
#line 800
            goto while_break___13;
          }
#line 801
          hashbytes += (off_t volatile   )10240;
        }
        while_break___13: /* CIL Label */ ;
        }
      }
    }
#line 803
    if (d <= 0) {
#line 804
      goto while_break___10;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
#line 806
  if (hash) {
#line 806
    if (bytes > (off_t volatile   )0) {
#line 807
      if (bytes < (off_t volatile   )1024) {
        {
#line 808
        putchar('#');
        }
      }
      {
#line 809
      putchar('\n');
#line 810
      fflush(stdout);
      }
    }
  }
#line 812
  if (tick) {
    {
#line 813
    printbytes((off_t )bytes);
    }
  }
#line 815
  if (c < 0) {
    {
#line 816
    tmp___23 = __errno_location();
#line 816
    tmp___24 = strerror(*tmp___23);
#line 816
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"local: %s: %s\n",
            local, tmp___24);
    }
  }
#line 818
  if (d <= 0) {
#line 819
    bytes = (off_t volatile   )-1;
  }
#line 820
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 823
  while (1) {
    while_continue___14: /* CIL Label */ ;
    {
#line 823
    c = _IO_getc((_IO_FILE *)fin);
    }
#line 823
    if (! (c != -1)) {
#line 823
      goto while_break___14;
    }
#line 824
    if (c == 10) {
      {
#line 825
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 825
        if (hash) {
#line 825
          if (! (bytes >= hashbytes)) {
#line 825
            goto while_break___15;
          }
        } else {
#line 825
          goto while_break___15;
        }
        {
#line 826
        putchar('#');
#line 827
        fflush(stdout);
#line 828
        hashbytes += (off_t volatile   )1024;
        }
      }
      while_break___15: /* CIL Label */ ;
      }
#line 830
      if (tick) {
#line 830
        if (bytes >= hashbytes) {
          {
#line 831
          printbytes((off_t )bytes);
          }
          {
#line 832
          while (1) {
            while_continue___16: /* CIL Label */ ;
#line 832
            if (! (bytes >= hashbytes)) {
#line 832
              goto while_break___16;
            }
#line 833
            hashbytes += (off_t volatile   )10240;
          }
          while_break___16: /* CIL Label */ ;
          }
        }
      }
      {
#line 835
      tmp___25 = _IO_putc('\r', (_IO_FILE *)dout);
      }
#line 835
      if (tmp___25 == -1) {
        {
#line 836
        perror("netout");
        }
#line 837
        goto while_break___14;
      }
#line 839
      bytes += (off_t volatile   )1;
    }
    {
#line 841
    tmp___26 = _IO_putc(c, (_IO_FILE *)dout);
    }
#line 841
    if (tmp___26 == -1) {
      {
#line 842
      perror("netout");
      }
#line 843
      goto while_break___14;
    }
#line 845
    bytes += (off_t volatile   )1;
  }
  while_break___14: /* CIL Label */ ;
  }
#line 851
  if (hash) {
#line 852
    if (bytes < hashbytes) {
      {
#line 853
      putchar('#');
      }
    }
    {
#line 854
    putchar('\n');
#line 855
    fflush(stdout);
    }
  }
#line 857
  if (tick) {
    {
#line 858
    printbytes((off_t )bytes);
    }
  }
  {
#line 860
  tmp___29 = ferror((FILE *)fin);
  }
#line 860
  if (tmp___29) {
    {
#line 861
    tmp___27 = __errno_location();
#line 861
    tmp___28 = strerror(*tmp___27);
#line 861
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"local: %s: %s\n",
            local, tmp___28);
    }
  }
  {
#line 863
  tmp___30 = ferror((FILE *)dout);
  }
#line 863
  if (tmp___30) {
#line 864
    bytes = (off_t volatile   )-1;
  }
#line 865
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 867
  gettimeofday((struct timeval */* __restrict  */)(& stop), (__timezone_ptr_t )((struct timezone *)0));
  }
#line 868
  if ((unsigned long )closefunc != (unsigned long )((void *)0)) {
    {
#line 869
    suppressint ++;
#line 870
    (*closefunc)((FILE *)fin);
#line 871
    fin = (FILE */* volatile  */)((void *)0);
    }
    {
#line 872
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 872
      suppressint --;
#line 872
      if (suppressint == 0) {
#line 872
        if (intpending) {
          {
#line 872
          intr(2);
          }
        }
      }
#line 872
      goto while_break___17;
    }
    while_break___17: /* CIL Label */ ;
    }
  }
  {
#line 874
  suppressint ++;
#line 875
  fclose((FILE *)dout);
#line 876
  dout = (FILE */* volatile  */)((void *)0);
#line 878
  data = -1;
  }
  {
#line 879
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 879
    suppressint --;
#line 879
    if (suppressint == 0) {
#line 879
      if (intpending) {
        {
#line 879
        intr(2);
        }
      }
    }
#line 879
    goto while_break___18;
  }
  while_break___18: /* CIL Label */ ;
  }
  {
#line 880
  getreply(0);
#line 881
  toplevel = (sigjmp_buf *)oldtoplevel;
  }
#line 882
  if (bytes > (off_t volatile   )0) {
    {
#line 883
    ptransfer("sent", (off_t )bytes, (struct timeval  const  *)(& start), (struct timeval  const  *)(& stop));
    }
  }
#line 884
  return;
  abort: 
  {
#line 886
  gettimeofday((struct timeval */* __restrict  */)(& stop), (__timezone_ptr_t )((struct timezone *)0));
  }
#line 887
  if (! cpend) {
#line 888
    code = -1;
#line 889
    toplevel = (sigjmp_buf *)oldtoplevel;
#line 890
    return;
  }
#line 892
  if (dout) {
    {
#line 893
    suppressint ++;
#line 894
    tmp___31 = fileno((FILE *)dout);
    }
#line 894
    if (data == tmp___31) {
#line 895
      data = -1;
    }
    {
#line 896
    fclose((FILE *)dout);
#line 897
    dout = (FILE */* volatile  */)((void *)0);
    }
    {
#line 898
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 898
      suppressint --;
#line 898
      if (suppressint == 0) {
#line 898
        if (intpending) {
          {
#line 898
          intr(2);
          }
        }
      }
#line 898
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
  }
#line 900
  if (data >= 0) {
    {
#line 901
    suppressint ++;
#line 902
    close(data);
#line 903
    data = -1;
    }
    {
#line 904
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 904
      suppressint --;
#line 904
      if (suppressint == 0) {
#line 904
        if (intpending) {
          {
#line 904
          intr(2);
          }
        }
      }
#line 904
      goto while_break___20;
    }
    while_break___20: /* CIL Label */ ;
    }
  }
  {
#line 906
  getreply(0);
#line 907
  code = -1;
  }
#line 908
  if ((unsigned long )closefunc != (unsigned long )((void *)0)) {
#line 908
    if ((unsigned long )fin != (unsigned long )((void *)0)) {
      {
#line 909
      suppressint ++;
#line 910
      (*closefunc)((FILE *)fin);
#line 911
      fin = (FILE */* volatile  */)((void *)0);
      }
      {
#line 912
      while (1) {
        while_continue___21: /* CIL Label */ ;
#line 912
        suppressint --;
#line 912
        if (suppressint == 0) {
#line 912
          if (intpending) {
            {
#line 912
            intr(2);
            }
          }
        }
#line 912
        goto while_break___21;
      }
      while_break___21: /* CIL Label */ ;
      }
    }
  }
#line 914
  toplevel = (sigjmp_buf *)oldtoplevel;
#line 915
  if (bytes > (off_t volatile   )0) {
    {
#line 916
    ptransfer("sent", (off_t )bytes, (struct timeval  const  *)(& start), (struct timeval  const  *)(& stop));
    }
  }
#line 917
  return;
}
}
#line 919 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp.c"
static void abortrecv(int ignore ) 
{ 


  {
  {
#line 924
  mflag = 0;
#line 925
  printf((char const   */* __restrict  */)"\nreceive aborted\nwaiting for remote to finish abort\n");
#line 926
  fflush(stdout);
  }
#line 927
  return;
}
}
#line 929 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp.c"
void recvrequest(char const   *cmd , char * volatile  local , char *remote , char const   *lmode ,
                 int printnames ) 
{ 
  FILE * volatile  fout ;
  FILE * volatile  din ;
  int (* volatile  closefunc)(FILE * ) ;
  int volatile   is_retr ;
  int volatile   tcrflag ;
  int volatile   bare_lfs ;
  int tqcflag ;
  unsigned int bufsize ;
  char *buf___0 ;
  off_t volatile   bytes ;
  off_t volatile   hashbytes ;
  register int c ;
  register int d ;
  struct timeval start ;
  struct timeval stop ;
  struct stat st ;
  sigjmp_buf jmploc ;
  sigjmp_buf * volatile  oldtoplevel ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *dir ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  char const   * volatile  tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  FILE *tmp___25 ;
  FILE *tmp___26 ;
  FILE *tmp___27 ;
  int *tmp___28 ;
  char *tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___33 ;
  char *tmp___34 ;
  int *tmp___35 ;
  char *tmp___36 ;
  int tmp___37 ;
  __off_t tmp___38 ;
  int *tmp___39 ;
  int tmp___40 ;
  ssize_t tmp___41 ;
  int tmp___42 ;
  ssize_t tmp___43 ;
  int *tmp___44 ;
  char *tmp___45 ;
  register off_t i ;
  register off_t n ;
  register int ch ;
  int tmp___46 ;
  off_t tmp___47 ;
  int *tmp___48 ;
  char *tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  unsigned short const   **tmp___52 ;
  unsigned short const   **tmp___53 ;
  int tmp___54 ;
  int *tmp___55 ;
  char *tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;

  {
  {
#line 934
  fout = (FILE */* volatile  */)0;
#line 934
  din = (FILE */* volatile  */)0;
#line 936
  bare_lfs = (int volatile   )0;
#line 937
  tqcflag = 0;
#line 940
  bytes = (off_t volatile   )0;
#line 940
  hashbytes = (off_t volatile   )1024;
#line 947
  tmp = strcmp(cmd, "RETR");
#line 947
  is_retr = (int volatile   )(tmp == 0);
  }
#line 948
  if (is_retr) {
#line 948
    if (verbose) {
#line 948
      if (printnames) {
#line 949
        if (local) {
#line 949
          if ((int )*local != 45) {
            {
#line 950
            printf((char const   */* __restrict  */)"local: %s ", local);
            }
          }
        }
#line 951
        if (remote) {
          {
#line 952
          printf((char const   */* __restrict  */)"remote: %s\n", remote);
          }
        }
      }
    }
  }
#line 954
  if (proxy) {
#line 954
    if (is_retr) {
      {
#line 955
      proxtrans(cmd, (char *)local, remote);
      }
#line 956
      return;
    }
  }
#line 958
  closefunc = (int (*/* volatile  */)(FILE * ))((void *)0);
#line 959
  if (! crflag) {
#line 959
    if (is_retr) {
#line 959
      tmp___0 = 1;
    } else {
#line 959
      tmp___0 = 0;
    }
  } else {
#line 959
    tmp___0 = 0;
  }
  {
#line 959
  tcrflag = (int volatile   )tmp___0;
#line 960
  oldtoplevel = (sigjmp_buf */* volatile  */)toplevel;
#line 961
  tmp___1 = __sigsetjmp((struct __jmp_buf_tag *)(jmploc), 1);
  }
#line 961
  if (tmp___1) {
    {
#line 962
    abortrecv(2);
    }
    {
#line 963
    while (1) {
      while_continue: /* CIL Label */ ;
#line 963
      if (! cpend) {
#line 963
        goto while_break;
      }
      {
#line 964
      getreply(0);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 966
    if (data >= 0) {
      {
#line 967
      suppressint ++;
#line 968
      close(data);
#line 969
      data = -1;
      }
      {
#line 970
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 970
        suppressint --;
#line 970
        if (suppressint == 0) {
#line 970
          if (intpending) {
            {
#line 970
            intr(2);
            }
          }
        }
#line 970
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 972
    toplevel = (sigjmp_buf *)oldtoplevel;
#line 973
    code = -1;
#line 974
    return;
  }
  {
#line 976
  toplevel = & jmploc;
#line 977
  tmp___19 = strcmp((char const   *)local, "-");
  }
#line 977
  if (tmp___19) {
#line 977
    if ((int )*local != 124) {
      {
#line 978
      tmp___18 = access((char const   *)local, 2);
      }
#line 978
      if (tmp___18 < 0) {
        {
#line 979
        tmp___2 = rindex((char const   *)local, '/');
#line 979
        dir = tmp___2;
#line 981
        tmp___5 = __errno_location();
        }
#line 981
        if (*tmp___5 != 2) {
          {
#line 981
          tmp___6 = __errno_location();
          }
#line 981
          if (*tmp___6 != 13) {
            {
#line 982
            tmp___3 = __errno_location();
#line 982
            tmp___4 = strerror(*tmp___3);
#line 982
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"local: %s: %s\n",
                    local, tmp___4);
#line 984
            toplevel = (sigjmp_buf *)oldtoplevel;
#line 985
            code = -1;
            }
#line 986
            return;
          }
        }
#line 988
        if ((unsigned long )dir != (unsigned long )((void *)0)) {
#line 989
          *dir = (char)0;
        }
#line 990
        if (dir) {
#line 990
          tmp___7 = (char const   */* volatile  */)local;
        } else {
#line 990
          tmp___7 = (char const   */* volatile  */)".";
        }
        {
#line 990
        d = access((char const   *)tmp___7, 2);
        }
#line 991
        if ((unsigned long )dir != (unsigned long )((void *)0)) {
#line 992
          *dir = (char )'/';
        }
#line 993
        if (d < 0) {
          {
#line 994
          tmp___8 = __errno_location();
#line 994
          tmp___9 = strerror(*tmp___8);
#line 994
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"local: %s: %s\n",
                  local, tmp___9);
#line 996
          toplevel = (sigjmp_buf *)oldtoplevel;
#line 997
          code = -1;
          }
#line 998
          return;
        }
#line 1000
        if (! runique) {
          {
#line 1000
          tmp___12 = __errno_location();
          }
#line 1000
          if (*tmp___12 == 13) {
            {
#line 1000
            tmp___13 = chmod((char const   *)local, (__mode_t )384);
            }
#line 1000
            if (tmp___13 < 0) {
              {
#line 1002
              tmp___10 = __errno_location();
#line 1002
              tmp___11 = strerror(*tmp___10);
#line 1002
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"local: %s: %s\n",
                      local, tmp___11);
#line 1004
              toplevel = (sigjmp_buf *)oldtoplevel;
#line 1005
              code = -1;
              }
#line 1006
              return;
            }
          }
        }
#line 1008
        if (runique) {
          {
#line 1008
          tmp___14 = __errno_location();
          }
#line 1008
          if (*tmp___14 == 13) {
            {
#line 1008
            tmp___15 = gunique((char *)local);
#line 1008
            local = (char */* volatile  */)tmp___15;
            }
#line 1008
            if ((unsigned long )local == (unsigned long )((void *)0)) {
#line 1010
              toplevel = (sigjmp_buf *)oldtoplevel;
#line 1011
              code = -1;
#line 1012
              return;
            }
          }
        }
      } else
#line 1015
      if (runique) {
        {
#line 1015
        tmp___16 = strcmp(cmd, "NLST");
        }
#line 1015
        if (tmp___16 != 0) {
          {
#line 1015
          tmp___17 = gunique((char *)local);
#line 1015
          local = (char */* volatile  */)tmp___17;
          }
#line 1015
          if ((unsigned long )local == (unsigned long )((void *)0)) {
#line 1017
            toplevel = (sigjmp_buf *)oldtoplevel;
#line 1018
            code = -1;
#line 1019
            return;
          }
        }
      }
    }
  }
#line 1022
  if (! is_retr) {
#line 1023
    if (curtype != 1) {
      {
#line 1024
      changetype(1, 0);
      }
    }
  } else
#line 1026
  if (curtype != type) {
    {
#line 1027
    changetype(type, 0);
    }
  }
  {
#line 1029
  tmp___20 = initconn();
  }
#line 1029
  if (tmp___20) {
#line 1030
    toplevel = (sigjmp_buf *)oldtoplevel;
#line 1031
    code = -1;
#line 1032
    return;
  }
  {
#line 1034
  tmp___21 = __sigsetjmp((struct __jmp_buf_tag *)(jmploc), 1);
  }
#line 1034
  if (tmp___21) {
    {
#line 1035
    abortrecv(2);
    }
#line 1036
    goto abort;
  }
#line 1038
  if (is_retr) {
#line 1038
    if (restart_point) {
      {
#line 1038
      tmp___22 = command("REST %jd", restart_point);
      }
#line 1038
      if (tmp___22 != 3) {
#line 1040
        toplevel = (sigjmp_buf *)oldtoplevel;
#line 1041
        return;
      }
    }
  }
#line 1043
  if (remote) {
    {
#line 1044
    tmp___23 = command("%s %s", cmd, remote);
    }
#line 1044
    if (tmp___23 != 1) {
#line 1045
      toplevel = (sigjmp_buf *)oldtoplevel;
#line 1046
      return;
    }
  } else {
    {
#line 1050
    tmp___24 = command("%s", cmd);
    }
#line 1050
    if (tmp___24 != 1) {
#line 1051
      toplevel = (sigjmp_buf *)oldtoplevel;
#line 1052
      return;
    }
  }
  {
#line 1055
  suppressint ++;
#line 1056
  tmp___25 = dataconn("r");
#line 1056
  din = (FILE */* volatile  */)tmp___25;
  }
  {
#line 1057
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1057
    suppressint --;
#line 1057
    if (suppressint == 0) {
#line 1057
      if (intpending) {
        {
#line 1057
        intr(2);
        }
      }
    }
#line 1057
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1058
  if ((unsigned long )din == (unsigned long )((void *)0)) {
#line 1059
    goto abort;
  }
  {
#line 1060
  tmp___30 = strcmp((char const   *)local, "-");
  }
#line 1060
  if (tmp___30 == 0) {
#line 1061
    fout = (FILE */* volatile  */)stdout;
#line 1062
    tqcflag = qcflag;
  } else
#line 1064
  if ((int )*local == 124) {
    {
#line 1065
    closefunc = (int (*/* volatile  */)(FILE * ))(& pclose);
#line 1066
    suppressint ++;
#line 1067
    tmp___26 = popen((char const   *)(local + 1), "w");
#line 1067
    fout = (FILE */* volatile  */)tmp___26;
    }
    {
#line 1068
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1068
      suppressint --;
#line 1068
      if (suppressint == 0) {
#line 1068
        if (intpending) {
          {
#line 1068
          intr(2);
          }
        }
      }
#line 1068
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1069
    if ((unsigned long )fout == (unsigned long )((void *)0)) {
      {
#line 1070
      perror((char const   *)(local + 1));
      }
#line 1071
      goto abort;
    }
  } else {
    {
#line 1075
    closefunc = (int (*/* volatile  */)(FILE * ))(& fclose);
#line 1076
    suppressint ++;
#line 1077
    tmp___27 = fopen((char const   */* __restrict  */)local, (char const   */* __restrict  */)lmode);
#line 1077
    fout = (FILE */* volatile  */)tmp___27;
    }
    {
#line 1078
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1078
      suppressint --;
#line 1078
      if (suppressint == 0) {
#line 1078
        if (intpending) {
          {
#line 1078
          intr(2);
          }
        }
      }
#line 1078
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1079
    if ((unsigned long )fout == (unsigned long )((void *)0)) {
      {
#line 1080
      tmp___28 = __errno_location();
#line 1080
      tmp___29 = strerror(*tmp___28);
#line 1080
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"local: %s: %s\n",
              local, tmp___29);
      }
#line 1082
      goto abort;
    }
  }
  {
#line 1085
  tmp___31 = fileno((FILE *)fout);
#line 1085
  tmp___32 = fstat(tmp___31, & st);
  }
#line 1085
  if (tmp___32 < 0) {
#line 1086
    bufsize = 8192U;
  } else
#line 1085
  if (st.st_blksize == 0L) {
#line 1086
    bufsize = 8192U;
  } else {
#line 1088
    bufsize = (unsigned int )st.st_blksize;
  }
#line 1089
  suppressint ++;
#line 1090
  __h = & mainobstack;
#line 1090
  __o = __h;
#line 1090
  __len = (int )bufsize;
#line 1090
  if (__o->chunk_limit - __o->next_free < (long )__len) {
    {
#line 1090
    _obstack_newchunk(__o, __len);
    }
  }
#line 1090
  __o->next_free += __len;
#line 1090
  __o1 = __h;
#line 1090
  __value = (void *)__o1->object_base;
#line 1090
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 1090
    __o1->maybe_empty_object = 1U;
  }
#line 1090
  if (sizeof(long ) < sizeof(void *)) {
#line 1090
    tmp___33 = __o1->object_base;
  } else {
#line 1090
    tmp___33 = (char *)0;
  }
#line 1090
  if (sizeof(long ) < sizeof(void *)) {
#line 1090
    tmp___34 = __o1->object_base;
  } else {
#line 1090
    tmp___34 = (char *)0;
  }
#line 1090
  __o1->next_free = tmp___33 + (((__o1->next_free - tmp___34) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 1090
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 1090
    __o1->next_free = __o1->chunk_limit;
  }
#line 1090
  __o1->object_base = __o1->next_free;
#line 1090
  buf___0 = (char *)__value;
  {
#line 1091
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1091
    suppressint --;
#line 1091
    if (suppressint == 0) {
#line 1091
      if (intpending) {
        {
#line 1091
        intr(2);
        }
      }
    }
#line 1091
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 1092
  gettimeofday((struct timeval */* __restrict  */)(& start), (__timezone_ptr_t )((struct timezone *)0));
  }
  {
#line 1096
  if (curtype == 4) {
#line 1096
    goto case_4;
  }
#line 1096
  if (curtype == 3) {
#line 1096
    goto case_4;
  }
#line 1150
  if (curtype == 1) {
#line 1150
    goto case_1;
  }
#line 1093
  goto switch_break;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 1097
  if (restart_point) {
    {
#line 1097
    tmp___37 = fileno((FILE *)fout);
#line 1097
    tmp___38 = lseek(tmp___37, restart_point, 0);
    }
#line 1097
    if (tmp___38 < 0L) {
      {
#line 1099
      tmp___35 = __errno_location();
#line 1099
      tmp___36 = strerror(*tmp___35);
#line 1099
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"local: %s: %s\n",
              local, tmp___36);
      }
#line 1101
      if ((unsigned long )closefunc != (unsigned long )((void *)0)) {
        {
#line 1102
        suppressint ++;
#line 1103
        (*closefunc)((FILE *)fout);
#line 1104
        fout = (FILE */* volatile  */)((void *)0);
        }
        {
#line 1105
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1105
          suppressint --;
#line 1105
          if (suppressint == 0) {
#line 1105
            if (intpending) {
              {
#line 1105
              intr(2);
              }
            }
          }
#line 1105
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
#line 1107
      toplevel = (sigjmp_buf *)oldtoplevel;
#line 1108
      return;
    }
  }
  {
#line 1110
  tmp___39 = __errno_location();
#line 1110
  d = 0;
#line 1110
  *tmp___39 = d;
  }
  {
#line 1111
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 1111
    tmp___42 = fileno((FILE *)din);
#line 1111
    tmp___43 = read(tmp___42, (void *)buf___0, (size_t )bufsize);
#line 1111
    c = (int )tmp___43;
    }
#line 1111
    if (! (c > 0)) {
#line 1111
      goto while_break___6;
    }
    {
#line 1112
    tmp___40 = fileno((FILE *)fout);
#line 1112
    tmp___41 = write(tmp___40, (void const   *)buf___0, (size_t )c);
#line 1112
    d = (int )tmp___41;
    }
#line 1112
    if (d != c) {
#line 1113
      goto while_break___6;
    }
#line 1114
    bytes += (off_t volatile   )c;
#line 1115
    if (hash) {
#line 1115
      if (is_retr) {
        {
#line 1116
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1116
          if (! (bytes >= hashbytes)) {
#line 1116
            goto while_break___7;
          }
          {
#line 1117
          putchar('#');
#line 1118
          hashbytes += (off_t volatile   )1024;
          }
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 1120
        fflush(stdout);
        }
      }
    }
#line 1122
    if (tick) {
#line 1122
      if (bytes >= hashbytes) {
#line 1122
        if (is_retr) {
          {
#line 1123
          printbytes((off_t )bytes);
          }
          {
#line 1124
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 1124
            if (! (bytes >= hashbytes)) {
#line 1124
              goto while_break___8;
            }
#line 1125
            hashbytes += (off_t volatile   )10240;
          }
          while_break___8: /* CIL Label */ ;
          }
        }
      }
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 1128
  if (hash) {
#line 1128
    if (bytes > (off_t volatile   )0) {
#line 1129
      if (bytes < (off_t volatile   )1024) {
        {
#line 1130
        putchar('#');
        }
      }
      {
#line 1131
      putchar('\n');
#line 1132
      fflush(stdout);
      }
    }
  }
#line 1134
  if (tick) {
#line 1134
    if (is_retr) {
      {
#line 1135
      printbytes((off_t )bytes);
      }
    }
  }
#line 1137
  if (c < 0) {
    {
#line 1138
    perror("netin");
#line 1139
    bytes = (off_t volatile   )-1;
    }
  }
#line 1141
  if (d < c) {
#line 1142
    if (d < 0) {
      {
#line 1143
      tmp___44 = __errno_location();
#line 1143
      tmp___45 = strerror(*tmp___44);
#line 1143
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"local: %s: %s\n",
              local, tmp___45);
      }
    } else {
      {
#line 1146
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: short write\n",
              local);
      }
    }
  }
#line 1148
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1151
  if (restart_point) {
    {
#line 1155
    tmp___46 = fseeko((FILE *)fout, 0L, 0);
    }
#line 1155
    if (tmp___46 < 0) {
#line 1156
      goto done;
    }
#line 1157
    n = restart_point;
#line 1158
    i = (off_t )0;
    {
#line 1158
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 1158
      tmp___47 = i;
#line 1158
      i ++;
#line 1158
      if (! (tmp___47 < n)) {
#line 1158
        goto while_break___9;
      }
      {
#line 1159
      ch = _IO_getc((_IO_FILE *)fout);
      }
#line 1159
      if (ch == -1) {
#line 1160
        goto done;
      }
#line 1161
      if (ch == 10) {
#line 1162
        i ++;
      }
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 1164
    tmp___50 = fseeko((FILE *)fout, 0L, 1);
    }
#line 1164
    if (tmp___50 < 0) {
      done: 
      {
#line 1166
      tmp___48 = __errno_location();
#line 1166
      tmp___49 = strerror(*tmp___48);
#line 1166
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"local: %s: %s\n",
              local, tmp___49);
      }
#line 1168
      if ((unsigned long )closefunc != (unsigned long )((void *)0)) {
        {
#line 1169
        suppressint ++;
#line 1170
        (*closefunc)((FILE *)fout);
#line 1171
        fout = (FILE */* volatile  */)((void *)0);
        }
        {
#line 1172
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 1172
          suppressint --;
#line 1172
          if (suppressint == 0) {
#line 1172
            if (intpending) {
              {
#line 1172
              intr(2);
              }
            }
          }
#line 1172
          goto while_break___10;
        }
        while_break___10: /* CIL Label */ ;
        }
      }
#line 1174
      toplevel = (sigjmp_buf *)oldtoplevel;
#line 1175
      return;
    }
  }
  {
#line 1178
  while (1) {
    while_continue___11: /* CIL Label */ ;
    {
#line 1178
    c = _IO_getc((_IO_FILE *)din);
    }
#line 1178
    if (! (c != -1)) {
#line 1178
      goto while_break___11;
    }
#line 1179
    if (c == 10) {
#line 1180
      bare_lfs += (int volatile   )1;
    }
    {
#line 1181
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 1181
      if (! (c == 13)) {
#line 1181
        goto while_break___12;
      }
      {
#line 1182
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 1182
        if (hash) {
#line 1182
          if (bytes >= hashbytes) {
#line 1182
            if (! is_retr) {
#line 1182
              goto while_break___13;
            }
          } else {
#line 1182
            goto while_break___13;
          }
        } else {
#line 1182
          goto while_break___13;
        }
        {
#line 1184
        putchar('#');
#line 1185
        fflush(stdout);
#line 1186
        hashbytes += (off_t volatile   )1024;
        }
      }
      while_break___13: /* CIL Label */ ;
      }
#line 1188
      if (tick) {
#line 1188
        if (bytes >= hashbytes) {
#line 1188
          if (is_retr) {
            {
#line 1189
            printbytes((off_t )bytes);
            }
            {
#line 1190
            while (1) {
              while_continue___14: /* CIL Label */ ;
#line 1190
              if (! (bytes >= hashbytes)) {
#line 1190
                goto while_break___14;
              }
#line 1191
              hashbytes += (off_t volatile   )10240;
            }
            while_break___14: /* CIL Label */ ;
            }
          }
        }
      }
      {
#line 1193
      bytes += (off_t volatile   )1;
#line 1194
      c = _IO_getc((_IO_FILE *)din);
      }
#line 1194
      if (c != 10) {
#line 1194
        goto _L;
      } else
#line 1194
      if (tcrflag) {
        _L: /* CIL Label */ 
        {
#line 1195
        tmp___51 = ferror((FILE *)fout);
        }
#line 1195
        if (tmp___51) {
#line 1196
          goto break2;
        }
        {
#line 1197
        _IO_putc('\r', (_IO_FILE *)fout);
        }
#line 1198
        if (c == 0) {
#line 1199
          bytes += (off_t volatile   )1;
#line 1200
          goto contin2;
        }
#line 1202
        if (c == -1) {
#line 1203
          goto contin2;
        }
      }
    }
    while_break___12: /* CIL Label */ ;
    }
#line 1206
    if (tqcflag) {
      {
#line 1206
      tmp___52 = __ctype_b_loc();
      }
#line 1206
      if (! ((int const   )*(*tmp___52 + c) & 16384)) {
        {
#line 1206
        tmp___53 = __ctype_b_loc();
        }
#line 1206
        if (! ((int const   )*(*tmp___53 + c) & 8192)) {
#line 1207
          c = '?';
        }
      }
    }
    {
#line 1208
    _IO_putc(c, (_IO_FILE *)fout);
#line 1209
    bytes += (off_t volatile   )1;
    }
    contin2: ;
  }
  while_break___11: /* CIL Label */ ;
  }
  break2: 
#line 1213
  if (hash) {
#line 1213
    if (is_retr) {
#line 1214
      if (bytes < hashbytes) {
        {
#line 1215
        putchar('#');
        }
      }
      {
#line 1216
      putchar('\n');
#line 1217
      fflush(stdout);
      }
    }
  }
#line 1219
  if (tick) {
#line 1219
    if (is_retr) {
      {
#line 1220
      printbytes((off_t )bytes);
      }
    }
  }
#line 1222
  if (bare_lfs) {
    {
#line 1223
    printf((char const   */* __restrict  */)"WARNING! %d bare linefeeds received in ASCII mode\n",
           bare_lfs);
#line 1224
    printf((char const   */* __restrict  */)"File may not have transferred correctly.\n");
    }
  }
  {
#line 1226
  tmp___54 = ferror((FILE *)din);
  }
#line 1226
  if (tmp___54) {
    {
#line 1227
    perror("netin");
#line 1228
    bytes = (off_t volatile   )-1;
    }
  }
  {
#line 1230
  tmp___57 = ferror((FILE *)fout);
  }
#line 1230
  if (tmp___57) {
    {
#line 1231
    tmp___55 = __errno_location();
#line 1231
    tmp___56 = strerror(*tmp___55);
#line 1231
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"local: %s: %s\n",
            local, tmp___56);
    }
  }
#line 1233
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1235
  if ((unsigned long )closefunc != (unsigned long )((void *)0)) {
    {
#line 1236
    suppressint ++;
#line 1237
    (*closefunc)((FILE *)fout);
#line 1238
    fout = (FILE */* volatile  */)((void *)0);
    }
    {
#line 1239
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 1239
      suppressint --;
#line 1239
      if (suppressint == 0) {
#line 1239
        if (intpending) {
          {
#line 1239
          intr(2);
          }
        }
      }
#line 1239
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
  }
  {
#line 1241
  suppressint ++;
#line 1242
  fclose((FILE *)din);
#line 1244
  data = -1;
  }
  {
#line 1245
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 1245
    suppressint --;
#line 1245
    if (suppressint == 0) {
#line 1245
      if (intpending) {
        {
#line 1245
        intr(2);
        }
      }
    }
#line 1245
    goto while_break___16;
  }
  while_break___16: /* CIL Label */ ;
  }
  {
#line 1246
  toplevel = (sigjmp_buf *)oldtoplevel;
#line 1247
  gettimeofday((struct timeval */* __restrict  */)(& stop), (__timezone_ptr_t )((struct timezone *)0));
#line 1248
  getreply(0);
  }
#line 1249
  if (bytes > (off_t volatile   )0) {
#line 1249
    if (is_retr) {
      {
#line 1250
      ptransfer("received", (off_t )bytes, (struct timeval  const  *)(& start), (struct timeval  const  *)(& stop));
      }
    }
  }
#line 1251
  return;
  abort: 
  {
#line 1256
  gettimeofday((struct timeval */* __restrict  */)(& stop), (__timezone_ptr_t )((struct timezone *)0));
#line 1257
  suppressint ++;
  }
#line 1258
  if (! cpend) {
#line 1259
    code = -1;
    {
#line 1260
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 1260
      suppressint --;
#line 1260
      if (suppressint == 0) {
#line 1260
        if (intpending) {
          {
#line 1260
          intr(2);
          }
        }
      }
#line 1260
      goto while_break___17;
    }
    while_break___17: /* CIL Label */ ;
    }
#line 1261
    toplevel = (sigjmp_buf *)oldtoplevel;
#line 1262
    return;
  }
  {
#line 1265
  abort_remote((FILE *)din);
#line 1266
  code = -1;
  }
#line 1267
  if ((unsigned long )closefunc != (unsigned long )((void *)0)) {
#line 1267
    if ((unsigned long )fout != (unsigned long )((void *)0)) {
      {
#line 1268
      (*closefunc)((FILE *)fout);
#line 1269
      fout = (FILE */* volatile  */)((void *)0);
      }
    }
  }
#line 1271
  if (din) {
    {
#line 1272
    tmp___58 = fileno((FILE *)din);
    }
#line 1272
    if (data == tmp___58) {
#line 1273
      data = -1;
    }
    {
#line 1274
    fclose((FILE *)din);
#line 1275
    din = (FILE */* volatile  */)((void *)0);
    }
  }
#line 1277
  if (data >= 0) {
    {
#line 1278
    close(data);
#line 1279
    data = -1;
    }
  }
#line 1281
  if (bytes > (off_t volatile   )0) {
    {
#line 1282
    ptransfer("received", (off_t )bytes, (struct timeval  const  *)(& start), (struct timeval  const  *)(& stop));
    }
  }
#line 1283
  toplevel = (sigjmp_buf *)oldtoplevel;
  {
#line 1284
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 1284
    suppressint --;
#line 1284
    if (suppressint == 0) {
#line 1284
      if (intpending) {
        {
#line 1284
        intr(2);
        }
      }
    }
#line 1284
    goto while_break___18;
  }
  while_break___18: /* CIL Label */ ;
  }
#line 1285
  return;
}
}
#line 1291 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp.c"
static int initconn(void) 
{ 
  register char *p ;
  register char *a ;
  int result ;
  int tmpno ;
  socklen_t len ;
  int on ;
  int tos ;
  u_long a1 ;
  u_long a2 ;
  u_long a3 ;
  u_long a4 ;
  u_long p1 ;
  u_long p2 ;
  unsigned short port ;
  struct sockaddr_in *data_addr_sa4 ;
  struct sockaddr_in6 *data_addr_sa6 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  uint16_t tmp___11 ;
  char const   *tmp___12 ;
  int tmp___13 ;

  {
#line 1294
  p = (char *)((void *)0);
#line 1294
  a = (char *)((void *)0);
#line 1295
  tmpno = 0;
#line 1297
  on = 1;
#line 1301
  data_addr_sa4 = (struct sockaddr_in *)(& data_addr);
#line 1302
  data_addr_sa6 = (struct sockaddr_in6 *)(& data_addr);
#line 1304
  if (passivemode) {
#line 1305
    suppressint ++;
#line 1306
    if (data >= 0) {
      {
#line 1307
      close(data);
      }
    }
    {
#line 1308
    data = socket((int )hisctladdr.ss_family, 1, 0);
    }
    {
#line 1309
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1309
      suppressint --;
#line 1309
      if (suppressint == 0) {
#line 1309
        if (intpending) {
          {
#line 1309
          intr(2);
          }
        }
      }
#line 1309
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1310
    if (data < 0) {
      {
#line 1311
      perror("ftp: socket");
      }
#line 1312
      return (1);
    }
#line 1314
    if (options & 1) {
      {
#line 1314
      tmp = setsockopt(data, 1, 1, (void const   *)((char *)(& on)), (socklen_t )sizeof(on));
      }
#line 1314
      if (tmp < 0) {
        {
#line 1317
        perror("ftp: setsockopt (ignored)");
        }
      }
    }
    {
#line 1319
    if ((int )hisctladdr.ss_family == 2) {
#line 1319
      goto case_2;
    }
#line 1325
    if ((int )hisctladdr.ss_family == 10) {
#line 1325
      goto case_10;
    }
#line 1318
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1320
    tmp___0 = command("PASV");
    }
#line 1320
    if (tmp___0 != 2) {
      {
#line 1321
      printf((char const   */* __restrict  */)"Passive mode refused.\n");
      }
#line 1322
      return (1);
    }
#line 1324
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 1326
    tmp___1 = command("EPSV 2");
    }
#line 1326
    if (tmp___1 != 2) {
      {
#line 1327
      printf((char const   */* __restrict  */)"Passive mode refused.\n");
      }
#line 1328
      return (1);
    }
    switch_break: /* CIL Label */ ;
    }
#line 1332
    if ((int )hisctladdr.ss_family == 2) {
      {
#line 1344
      tmp___2 = sscanf((char const   */* __restrict  */)(pasv), (char const   */* __restrict  */)"%ld,%ld,%ld,%ld,%ld,%ld",
                       & a1, & a2, & a3, & a4, & p1, & p2);
      }
#line 1344
      if (tmp___2 != 6) {
        {
#line 1348
        printf((char const   */* __restrict  */)"Passive mode address scan failure.Shouldn\'t happen!\n");
        }
#line 1350
        return (1);
      }
      {
#line 1353
      data_addr.ss_family = (sa_family_t )2;
#line 1354
      data_addr_sa4->sin_addr.s_addr = htonl((uint32_t )((((a1 << 24) | (a2 << 16)) | (a3 << 8)) | a4));
#line 1357
      data_addr_sa4->sin_port = htons((uint16_t )((p1 << 8) | p2));
      }
    } else {
      {
#line 1369
      tmp___3 = sscanf((char const   */* __restrict  */)(pasv), (char const   */* __restrict  */)"%hu",
                       & port);
      }
#line 1369
      if (tmp___3 != 1) {
        {
#line 1370
        printf((char const   */* __restrict  */)"Extended passive mode address scan failure. Unfortunate!\n");
        }
#line 1372
        return (1);
      }
      {
#line 1374
      data_addr = hisctladdr;
#line 1375
      data_addr.ss_family = (sa_family_t )10;
#line 1376
      data_addr_sa6->sin6_port = htons(port);
      }
    }
    {
#line 1379
    tmp___4 = connect(data, (struct sockaddr  const  *)((struct sockaddr *)(& data_addr)),
                      (socklen_t )sizeof(data_addr));
    }
#line 1379
    if (tmp___4 < 0) {
      {
#line 1381
      perror("ftp: connect");
      }
#line 1382
      return (1);
    }
#line 1385
    tos = 8;
#line 1386
    if ((int )hisctladdr.ss_family == 2) {
      {
#line 1386
      tmp___5 = setsockopt(data, 0, 1, (void const   *)((char *)(& tos)), (socklen_t )sizeof(tos));
      }
#line 1386
      if (tmp___5 < 0) {
        {
#line 1389
        perror("ftp: setsockopt TOS (ignored)");
        }
      }
    }
#line 1391
    return (0);
  }
  noport: 
#line 1394
  data_addr = myctladdr;
#line 1395
  if (sendport) {
    {
#line 1398
    if ((int )data_addr.ss_family == 2) {
#line 1398
      goto case_2___0;
    }
#line 1401
    if ((int )data_addr.ss_family == 10) {
#line 1401
      goto case_10___0;
    }
#line 1397
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
#line 1399
    data_addr_sa4->sin_port = (in_port_t )0;
#line 1400
    goto switch_break___0;
    case_10___0: /* CIL Label */ 
#line 1402
    data_addr_sa6->sin6_port = (in_port_t )0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 1404
  suppressint ++;
#line 1405
  if (data != -1) {
    {
#line 1406
    close(data);
    }
  }
  {
#line 1407
  data = socket((int )data_addr.ss_family, 1, 0);
  }
  {
#line 1408
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1408
    suppressint --;
#line 1408
    if (suppressint == 0) {
#line 1408
      if (intpending) {
        {
#line 1408
        intr(2);
        }
      }
    }
#line 1408
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1409
  if (data < 0) {
    {
#line 1410
    perror("ftp: socket");
    }
#line 1411
    if (tmpno) {
#line 1412
      sendport = 1;
    }
#line 1413
    return (1);
  }
#line 1415
  if (! sendport) {
    {
#line 1416
    tmp___6 = setsockopt(data, 1, 2, (void const   *)((char *)(& on)), (socklen_t )sizeof(on));
    }
#line 1416
    if (tmp___6 < 0) {
      {
#line 1417
      perror("ftp: setsockopt (reuse address)");
      }
#line 1418
      goto bad;
    }
  }
  {
#line 1420
  tmp___7 = bind(data, (struct sockaddr  const  *)((struct sockaddr *)(& data_addr)),
                 (socklen_t )sizeof(data_addr));
  }
#line 1420
  if (tmp___7 < 0) {
    {
#line 1421
    perror("ftp: bind");
    }
#line 1422
    goto bad;
  }
#line 1424
  if (options & 1) {
    {
#line 1424
    tmp___8 = setsockopt(data, 1, 1, (void const   *)((char *)(& on)), (socklen_t )sizeof(on));
    }
#line 1424
    if (tmp___8 < 0) {
      {
#line 1426
      perror("ftp: setsockopt (ignored)");
      }
    }
  }
  {
#line 1427
  len = (socklen_t )sizeof(data_addr);
#line 1428
  tmp___9 = getsockname(data, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& data_addr)),
                        (socklen_t */* __restrict  */)(& len));
  }
#line 1428
  if (tmp___9 < 0) {
    {
#line 1429
    perror("ftp: getsockname");
    }
#line 1430
    goto bad;
  }
  {
#line 1432
  tmp___10 = listen(data, 1);
  }
#line 1432
  if (tmp___10 < 0) {
    {
#line 1433
    perror("ftp: listen");
    }
  }
#line 1434
  if (sendport) {
    {
#line 1437
    if ((int )data_addr.ss_family == 2) {
#line 1437
      goto case_2___1;
    }
#line 1444
    if ((int )data_addr.ss_family == 10) {
#line 1444
      goto case_10___1;
    }
#line 1436
    goto switch_break___1;
    case_2___1: /* CIL Label */ 
    {
#line 1438
    a = (char *)(& data_addr_sa4->sin_addr);
#line 1439
    p = (char *)(& data_addr_sa4->sin_port);
#line 1440
    result = command("PORT %d,%d,%d,%d,%d,%d", (int )*(a + 0) & 255, (int )*(a + 1) & 255,
                     (int )*(a + 2) & 255, (int )*(a + 3) & 255, (int )*(p + 0) & 255,
                     (int )*(p + 1) & 255);
    }
#line 1443
    goto switch_break___1;
    case_10___1: /* CIL Label */ 
    {
#line 1445
    tmp___11 = ntohs(data_addr_sa6->sin6_port);
#line 1445
    tmp___12 = inet_ntop((int )data_addr.ss_family, (void const   */* __restrict  */)(& data_addr_sa6->sin6_addr),
                         (char */* __restrict  */)(ipstring), (socklen_t )sizeof(ipstring));
#line 1445
    result = command("EPRT |2|%s|%d|", tmp___12, (int )tmp___11);
    }
    switch_break___1: /* CIL Label */ ;
    }
#line 1452
    if (result == 5) {
#line 1452
      if (sendport == -1) {
#line 1453
        sendport = 0;
#line 1454
        tmpno = 1;
#line 1455
        goto noport;
      }
    }
#line 1457
    return (result != 2);
  }
#line 1459
  if (tmpno) {
#line 1460
    sendport = 1;
  }
#line 1462
  on = 8;
#line 1463
  if ((int )data_addr.ss_family == 2) {
    {
#line 1463
    tmp___13 = setsockopt(data, 0, 1, (void const   *)((char *)(& tos)), (socklen_t )sizeof(tos));
    }
#line 1463
    if (tmp___13 < 0) {
      {
#line 1466
      perror("ftp: setsockopt TOS (ignored)");
      }
    }
  }
#line 1468
  return (0);
  bad: 
  {
#line 1470
  suppressint ++;
#line 1471
  close(data);
#line 1471
  data = -1;
  }
  {
#line 1472
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1472
    suppressint --;
#line 1472
    if (suppressint == 0) {
#line 1472
      if (intpending) {
        {
#line 1472
        intr(2);
        }
      }
    }
#line 1472
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1473
  if (tmpno) {
#line 1474
    sendport = 1;
  }
#line 1475
  return (1);
}
}
#line 1478 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp.c"
static FILE *dataconn(char const   *lmode ) 
{ 
  struct sockaddr_storage from ;
  int s ;
  int tos ;
  socklen_t fromlen ;
  FILE *tmp ;
  int tmp___0 ;
  FILE *tmp___1 ;

  {
#line 1483
  fromlen = (socklen_t )sizeof(from);
#line 1485
  if (passivemode) {
    {
#line 1486
    tmp = fdopen(data, lmode);
    }
#line 1486
    return (tmp);
  }
  {
#line 1488
  s = accept(data, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& from)),
             (socklen_t */* __restrict  */)(& fromlen));
  }
#line 1489
  if (s < 0) {
    {
#line 1490
    perror("ftp: accept");
#line 1491
    close(data);
#line 1491
    data = -1;
    }
#line 1492
    return ((FILE *)((void *)0));
  }
  {
#line 1494
  close(data);
#line 1495
  data = s;
#line 1497
  tos = 8;
  }
#line 1498
  if ((int )from.ss_family == 2) {
    {
#line 1498
    tmp___0 = setsockopt(s, 0, 1, (void const   *)((char *)(& tos)), (socklen_t )sizeof(tos));
    }
#line 1498
    if (tmp___0 < 0) {
      {
#line 1501
      perror("ftp: setsockopt TOS (ignored)");
      }
    }
  }
  {
#line 1503
  tmp___1 = fdopen(data, lmode);
  }
#line 1503
  return (tmp___1);
}
}
#line 1506 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp.c"
static void ptransfer(char const   *direction , off_t bytes , struct timeval  const  *t0 ,
                      struct timeval  const  *t1 ) 
{ 
  struct timeval td ;
  float s ;
  float bs ;
  float tmp ;

  {
#line 1514
  if (verbose) {
    {
#line 1515
    tvsub(& td, t1, t0);
#line 1516
    s = (float )((double )td.tv_sec + (double )td.tv_usec / 1000000.);
    }
#line 1518
    if (s == (float )0) {
#line 1518
      tmp = (float )1;
    } else {
#line 1518
      tmp = s;
    }
    {
#line 1518
    bs = (float )bytes / tmp;
#line 1519
    printf((char const   */* __restrict  */)"%jd bytes %s in %.2f secs (%.1f kB/s)\n",
           bytes, direction, (double )s, (double )bs / 1024.0);
    }
  }
#line 1522
  return;
}
}
#line 1536 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp.c"
static void tvsub(struct timeval *tdiff , struct timeval  const  *t1 , struct timeval  const  *t0 ) 
{ 


  {
#line 1542
  tdiff->tv_sec = (__time_t )(t1->tv_sec - t0->tv_sec);
#line 1543
  tdiff->tv_usec = (__suseconds_t )(t1->tv_usec - t0->tv_usec);
#line 1544
  if (tdiff->tv_usec < 0L) {
#line 1545
    (tdiff->tv_sec) --;
#line 1545
    tdiff->tv_usec += 1000000L;
  }
#line 1546
  return;
}
}
#line 1551 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp.c"
static struct comvars proxstruct  ;
#line 1551 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp.c"
static struct comvars tmpstruct  ;
#line 1548 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp.c"
void pswitch(int flag ) 
{ 
  struct comvars *ip ;
  struct comvars *op ;

  {
#line 1573
  if (flag) {
#line 1574
    if (proxy) {
#line 1575
      return;
    }
#line 1576
    suppressint ++;
#line 1577
    ip = & tmpstruct;
#line 1578
    op = & proxstruct;
#line 1579
    proxy ++;
  } else {
#line 1582
    if (! proxy) {
#line 1583
      return;
    }
#line 1584
    suppressint ++;
#line 1585
    ip = & proxstruct;
#line 1586
    op = & tmpstruct;
#line 1587
    proxy = 0;
  }
#line 1589
  ip->connect = connected;
#line 1590
  connected = op->connect;
#line 1591
  if (hostname) {
    {
#line 1592
    strncpy((char */* __restrict  */)(ip->name), (char const   */* __restrict  */)hostname,
            sizeof(ip->name) - 1UL);
#line 1593
    ip->name[sizeof(ip->name) - 1UL] = (char )'\000';
    }
  } else {
#line 1596
    ip->name[0] = (char)0;
  }
  {
#line 1598
  hostname = op->name;
#line 1599
  ip->hctl = hisctladdr;
#line 1600
  hisctladdr = op->hctl;
#line 1601
  ip->mctl = myctladdr;
#line 1602
  myctladdr = op->mctl;
#line 1603
  ip->in = cin;
#line 1604
  cin = op->in;
#line 1605
  ip->out = cout;
#line 1606
  cout = op->out;
#line 1607
  ip->tpe = type;
#line 1608
  type = op->tpe;
#line 1609
  ip->curtpe = curtype;
#line 1610
  curtype = op->curtpe;
#line 1611
  ip->cpnd = cpend;
#line 1612
  cpend = op->cpnd;
#line 1613
  ip->sunqe = sunique;
#line 1614
  sunique = op->sunqe;
#line 1615
  ip->runqe = runique;
#line 1616
  runique = op->runqe;
#line 1617
  ip->mcse = mcase;
#line 1618
  mcase = op->mcse;
#line 1619
  ip->ntflg = ntflag;
#line 1620
  ntflag = op->ntflg;
#line 1621
  strncpy((char */* __restrict  */)(ip->nti), (char const   */* __restrict  */)(ntin),
          sizeof(ip->nti) - 1UL);
#line 1622
  ip->nti[sizeof(ip->nti) - 1UL] = (char )'\000';
#line 1623
  strcpy((char */* __restrict  */)(ntin), (char const   */* __restrict  */)(op->nti));
#line 1624
  strncpy((char */* __restrict  */)(ip->nto), (char const   */* __restrict  */)(ntout),
          sizeof(ip->nto) - 1UL);
#line 1625
  ip->nto[sizeof(ip->nto) - 1UL] = (char )'\000';
#line 1626
  strcpy((char */* __restrict  */)(ntout), (char const   */* __restrict  */)(op->nto));
#line 1627
  ip->mapflg = mapflag;
#line 1628
  mapflag = op->mapflg;
#line 1629
  strncpy((char */* __restrict  */)(ip->mi), (char const   */* __restrict  */)(mapin),
          sizeof(ip->mi) - 1UL);
#line 1630
  ip->mi[sizeof(ip->mi) - 1UL] = (char )'\000';
#line 1631
  strcpy((char */* __restrict  */)(mapin), (char const   */* __restrict  */)(op->mi));
#line 1632
  strncpy((char */* __restrict  */)(ip->mo), (char const   */* __restrict  */)(mapout),
          sizeof(ip->mo) - 1UL);
#line 1633
  ip->mo[sizeof(ip->mo) - 1UL] = (char )'\000';
#line 1634
  strcpy((char */* __restrict  */)(mapout), (char const   */* __restrict  */)(op->mo));
  }
  {
#line 1635
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1635
    suppressint --;
#line 1635
    if (suppressint == 0) {
#line 1635
      if (intpending) {
        {
#line 1635
        intr(2);
        }
      }
    }
#line 1635
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1636
  return;
}
}
#line 1638 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp.c"
static void abortpt(int ignore ) 
{ 


  {
  {
#line 1643
  printf((char const   */* __restrict  */)"\n");
#line 1644
  fflush(stdout);
#line 1645
  ptabflg ++;
#line 1646
  mflag = 0;
  }
#line 1647
  return;
}
}
#line 1649 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp.c"
static void proxtrans(char const   *cmd , char *local , char *remote ) 
{ 
  int volatile   secndflag ;
  int volatile   prox_type ;
  int volatile   nfnd ;
  char const   * volatile  cmd2 ;
  fd_set mask ;
  sigjmp_buf jmploc ;
  sigjmp_buf * volatile  oldtoplevel ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int __d0 ;
  int __d1 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  {
#line 1652
  secndflag = (int volatile   )0;
#line 1658
  tmp = strcmp(cmd, "RETR");
  }
#line 1658
  if (tmp) {
#line 1659
    cmd2 = (char const   */* volatile  */)"RETR";
  } else
#line 1661
  if (runique) {
#line 1661
    cmd2 = (char const   */* volatile  */)"STOU";
  } else {
#line 1661
    cmd2 = (char const   */* volatile  */)"STOR";
  }
#line 1662
  prox_type = (int volatile   )type;
#line 1662
  if (prox_type == (int volatile   )0) {
#line 1663
    if (unix_server) {
#line 1663
      if (unix_proxy) {
#line 1664
        prox_type = (int volatile   )3;
      } else {
#line 1666
        prox_type = (int volatile   )1;
      }
    } else {
#line 1666
      prox_type = (int volatile   )1;
    }
  }
#line 1668
  if (curtype != (int )prox_type) {
    {
#line 1669
    changetype((int )prox_type, 1);
    }
  }
  {
#line 1670
  tmp___0 = command("PASV");
  }
#line 1670
  if (tmp___0 != 2) {
    {
#line 1671
    printf((char const   */* __restrict  */)"proxy server does not support third party transfers.\n");
    }
#line 1672
    return;
  }
  {
#line 1674
  pswitch(0);
  }
#line 1675
  if (! connected) {
    {
#line 1676
    printf((char const   */* __restrict  */)"No primary connection\n");
#line 1677
    pswitch(1);
#line 1678
    code = -1;
    }
#line 1679
    return;
  }
#line 1681
  if (curtype != (int )prox_type) {
    {
#line 1682
    changetype((int )prox_type, 1);
    }
  }
  {
#line 1683
  tmp___1 = command("PORT %s", pasv);
  }
#line 1683
  if (tmp___1 != 2) {
    {
#line 1684
    pswitch(1);
    }
#line 1685
    return;
  }
  {
#line 1687
  oldtoplevel = (sigjmp_buf */* volatile  */)toplevel;
#line 1688
  tmp___2 = __sigsetjmp((struct __jmp_buf_tag *)(jmploc), 1);
  }
#line 1688
  if (tmp___2) {
    {
#line 1689
    abortpt(2);
    }
#line 1690
    goto abort;
  }
  {
#line 1692
  toplevel = & jmploc;
#line 1693
  tmp___3 = command("%s %s", cmd, remote);
  }
#line 1693
  if (tmp___3 != 1) {
    {
#line 1694
    toplevel = (sigjmp_buf *)oldtoplevel;
#line 1695
    pswitch(1);
    }
#line 1696
    return;
  }
  {
#line 1698
  sleep(2U);
#line 1699
  pswitch(1);
#line 1700
  secndflag += (int volatile   )1;
#line 1701
  tmp___4 = command("%s %s", cmd2, local);
  }
#line 1701
  if (tmp___4 != 1) {
#line 1702
    goto abort;
  }
  {
#line 1703
  ptflag ++;
#line 1704
  getreply(0);
#line 1705
  pswitch(0);
#line 1706
  getreply(0);
#line 1707
  toplevel = (sigjmp_buf *)oldtoplevel;
#line 1708
  pswitch(1);
#line 1709
  ptflag = 0;
#line 1710
  printf((char const   */* __restrict  */)"local: %s remote: %s\n", local, remote);
  }
#line 1711
  return;
  abort: 
  {
#line 1713
  suppressint ++;
#line 1714
  ptflag = 0;
#line 1715
  tmp___6 = strcmp(cmd, "RETR");
  }
#line 1715
  if (tmp___6) {
#line 1715
    if (! proxy) {
      {
#line 1716
      pswitch(1);
      }
    } else {
#line 1715
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 1717
    tmp___5 = strcmp(cmd, "RETR");
    }
#line 1717
    if (! tmp___5) {
#line 1717
      if (proxy) {
        {
#line 1718
        pswitch(0);
        }
      }
    }
  }
#line 1719
  if (! cpend) {
#line 1719
    if (! secndflag) {
      {
#line 1720
      tmp___7 = command("%s %s", cmd2, local);
      }
#line 1720
      if (tmp___7 != 1) {
        {
#line 1721
        pswitch(0);
        }
#line 1722
        if (cpend) {
          {
#line 1723
          abort_remote((FILE *)((void *)0));
          }
        }
      }
      {
#line 1725
      pswitch(1);
      }
#line 1726
      if (ptabflg) {
#line 1727
        code = -1;
      }
#line 1728
      toplevel = (sigjmp_buf *)oldtoplevel;
      {
#line 1729
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1729
        suppressint --;
#line 1729
        if (suppressint == 0) {
#line 1729
          if (intpending) {
            {
#line 1729
            intr(2);
            }
          }
        }
#line 1729
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 1730
      return;
    }
  }
#line 1732
  if (cpend) {
    {
#line 1733
    abort_remote((FILE *)((void *)0));
    }
  }
  {
#line 1734
  pswitch(! proxy);
  }
#line 1735
  if (! cpend) {
#line 1735
    if (! secndflag) {
      {
#line 1736
      tmp___8 = command("%s %s", cmd2, local);
      }
#line 1736
      if (tmp___8 != 1) {
        {
#line 1737
        pswitch(0);
        }
#line 1738
        if (cpend) {
          {
#line 1739
          abort_remote((FILE *)((void *)0));
          }
        }
        {
#line 1740
        pswitch(1);
        }
#line 1741
        if (ptabflg) {
#line 1742
          code = -1;
        }
#line 1743
        toplevel = (sigjmp_buf *)oldtoplevel;
        {
#line 1744
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1744
          suppressint --;
#line 1744
          if (suppressint == 0) {
#line 1744
            if (intpending) {
              {
#line 1744
              intr(2);
              }
            }
          }
#line 1744
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1745
        return;
      }
    }
  }
#line 1748
  if (cpend) {
    {
#line 1749
    abort_remote((FILE *)((void *)0));
    }
  }
  {
#line 1750
  pswitch(! proxy);
  }
#line 1751
  if (cpend) {
    {
#line 1752
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1752
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& mask.__fds_bits[0]): "memory");
#line 1752
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1753
    tmp___9 = fileno(cin);
#line 1753
    tmp___10 = fileno(cin);
#line 1753
    mask.__fds_bits[tmp___9 / (8 * (int )sizeof(__fd_mask ))] |= 1L << tmp___10 % (8 * (int )sizeof(__fd_mask ));
#line 1754
    tmp___11 = fileno(cin);
#line 1754
    tmp___12 = empty(& mask, tmp___11, 10);
#line 1754
    nfnd = (int volatile   )tmp___12;
    }
#line 1754
    if (nfnd <= (int volatile   )0) {
#line 1755
      if (nfnd < (int volatile   )0) {
        {
#line 1756
        perror("abort");
        }
      }
#line 1758
      if (ptabflg) {
#line 1759
        code = -1;
      }
      {
#line 1760
      lostpeer(0);
      }
    }
    {
#line 1762
    getreply(0);
#line 1763
    getreply(0);
    }
  }
#line 1765
  if (proxy) {
    {
#line 1766
    pswitch(0);
    }
  }
  {
#line 1767
  pswitch(1);
  }
#line 1768
  if (ptabflg) {
#line 1769
    code = -1;
  }
#line 1770
  toplevel = (sigjmp_buf *)oldtoplevel;
  {
#line 1771
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1771
    suppressint --;
#line 1771
    if (suppressint == 0) {
#line 1771
      if (intpending) {
        {
#line 1771
        intr(2);
        }
      }
    }
#line 1771
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1772
  return;
}
}
#line 1774 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp.c"
void reset(void) 
{ 
  fd_set mask ;
  int nfnd ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1778
  nfnd = 1;
  {
#line 1780
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1780
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& mask.__fds_bits[0]): "memory");
#line 1780
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1781
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1781
    if (! (nfnd > 0)) {
#line 1781
      goto while_break___0;
    }
    {
#line 1782
    tmp = fileno(cin);
#line 1782
    tmp___0 = fileno(cin);
#line 1782
    mask.__fds_bits[tmp / (8 * (int )sizeof(__fd_mask ))] |= 1L << tmp___0 % (8 * (int )sizeof(__fd_mask ));
#line 1783
    tmp___1 = fileno(cin);
#line 1783
    nfnd = empty(& mask, tmp___1, 0);
    }
#line 1783
    if (nfnd < 0) {
      {
#line 1784
      perror("reset");
#line 1785
      code = -1;
#line 1786
      suppressint ++;
#line 1787
      lostpeer(0);
      }
      {
#line 1788
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1788
        suppressint --;
#line 1788
        if (suppressint == 0) {
#line 1788
          if (intpending) {
            {
#line 1788
            intr(2);
            }
          }
        }
#line 1788
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 1790
    if (nfnd) {
      {
#line 1791
      getreply(0);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1794
  return;
}
}
#line 1799 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp.c"
static char new[4096]  ;
#line 1796 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp.c"
static char *gunique(char *local ) 
{ 
  char *cp ;
  char *tmp ;
  int d ;
  int count ;
  char ext ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 1800
  tmp = rindex((char const   *)local, '/');
#line 1800
  cp = tmp;
#line 1801
  count = 0;
#line 1802
  ext = (char )'1';
  }
#line 1804
  if (cp) {
#line 1805
    *cp = (char )'\000';
  }
#line 1806
  if (cp) {
#line 1806
    tmp___0 = (char const   *)local;
  } else {
#line 1806
    tmp___0 = ".";
  }
  {
#line 1806
  d = access(tmp___0, 2);
  }
#line 1807
  if (cp) {
#line 1808
    *cp = (char )'/';
  }
#line 1809
  if (d < 0) {
    {
#line 1810
    tmp___1 = __errno_location();
#line 1810
    tmp___2 = strerror(*tmp___1);
#line 1810
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"local: %s: %s\n",
            local, tmp___2);
    }
#line 1811
    return ((char *)0);
  }
  {
#line 1813
  strcpy((char */* __restrict  */)(new), (char const   */* __restrict  */)local);
#line 1814
  tmp___3 = strlen((char const   *)(new));
#line 1814
  cp = new + tmp___3;
#line 1815
  tmp___4 = cp;
#line 1815
  cp ++;
#line 1815
  *tmp___4 = (char )'.';
  }
  {
#line 1816
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1816
    if (! (! d)) {
#line 1816
      goto while_break;
    }
#line 1817
    count ++;
#line 1817
    if (count == 100) {
      {
#line 1818
      printf((char const   */* __restrict  */)"runique: can\'t find unique file name.\n");
      }
#line 1819
      return ((char *)0);
    }
#line 1821
    tmp___5 = cp;
#line 1821
    cp ++;
#line 1821
    *tmp___5 = ext;
#line 1822
    *cp = (char )'\000';
#line 1823
    if ((int )ext == 57) {
#line 1824
      ext = (char )'0';
    } else {
#line 1826
      ext = (char )((int )ext + 1);
    }
    {
#line 1827
    d = access((char const   *)(new), 0);
    }
#line 1827
    if (d < 0) {
#line 1828
      goto while_break;
    }
#line 1829
    if ((int )ext != 48) {
#line 1830
      cp --;
    } else
#line 1831
    if ((int )*(cp - 2) == 46) {
#line 1832
      *(cp - 1) = (char )'1';
    } else {
#line 1834
      *(cp - 2) = (char )((int )*(cp - 2) + 1);
#line 1835
      cp --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1838
  return (new);
}
}
#line 1841 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp.c"
static void abort_remote(FILE *din ) 
{ 
  char buf___0[8192] ;
  int nfnd ;
  int hifd ;
  fd_set mask ;
  int tmp ;
  ssize_t tmp___0 ;
  int __d0 ;
  int __d1 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  ssize_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 1845
  hifd = -1;
#line 1852
  if (cout) {
    {
#line 1853
    snprintf((char */* __restrict  */)(buf___0), sizeof(buf___0), (char const   */* __restrict  */)"%c%c%c",
             255, 244, 255);
#line 1854
    tmp = fileno(cout);
#line 1854
    tmp___0 = send(tmp, (void const   *)(buf___0), (size_t )3, 1);
    }
#line 1854
    if (tmp___0 != 3L) {
      {
#line 1855
      perror("abort");
      }
    }
    {
#line 1856
    fprintf((FILE */* __restrict  */)cout, (char const   */* __restrict  */)"%cABOR\r\n",
            242);
#line 1857
    fflush(cout);
    }
  }
  {
#line 1859
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1859
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& mask.__fds_bits[0]): "memory");
#line 1859
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1860
  if (cin) {
    {
#line 1861
    tmp___1 = fileno(cin);
#line 1861
    tmp___2 = fileno(cin);
#line 1861
    mask.__fds_bits[tmp___1 / (8 * (int )sizeof(__fd_mask ))] |= 1L << tmp___2 % (8 * (int )sizeof(__fd_mask ));
#line 1862
    hifd = fileno(cin);
    }
  }
#line 1864
  if (din) {
    {
#line 1865
    tmp___3 = fileno(din);
#line 1865
    tmp___4 = fileno(din);
#line 1865
    mask.__fds_bits[tmp___3 / (8 * (int )sizeof(__fd_mask ))] |= 1L << tmp___4 % (8 * (int )sizeof(__fd_mask ));
#line 1866
    tmp___5 = fileno(din);
    }
#line 1866
    if (hifd < tmp___5) {
      {
#line 1866
      hifd = fileno(din);
      }
    }
  }
#line 1868
  if (hifd >= 0) {
    {
#line 1868
    nfnd = empty(& mask, hifd, 10);
    }
#line 1868
    if (nfnd <= 0) {
#line 1869
      if (nfnd < 0) {
        {
#line 1870
        perror("abort");
        }
      }
#line 1872
      if (ptabflg) {
#line 1873
        code = -1;
      }
      {
#line 1874
      lostpeer(0);
      }
    }
  }
#line 1876
  if (din) {
    {
#line 1876
    tmp___8 = fileno(din);
#line 1876
    tmp___9 = fileno(din);
    }
#line 1876
    if ((mask.__fds_bits[tmp___8 / (8 * (int )sizeof(__fd_mask ))] & (1L << tmp___9 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 1877
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1877
        tmp___6 = fileno(din);
#line 1877
        tmp___7 = read(tmp___6, (void *)(buf___0), (size_t )8192);
        }
#line 1877
        if (! (tmp___7 > 0L)) {
#line 1877
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 1880
  tmp___10 = getreply(0);
  }
#line 1880
  if (tmp___10 == 5) {
#line 1880
    if (code == 552) {
      {
#line 1882
      getreply(0);
      }
    }
  }
  {
#line 1884
  getreply(0);
  }
#line 1885
  return;
}
}
#line 1887 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp.c"
static void printbytes(off_t bytes ) 
{ 


  {
  {
#line 1890
  printf((char const   */* __restrict  */)"\rBytes transferred: %jd", bytes);
#line 1891
  fflush(stdout);
  }
#line 1892
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char cmdtab_rcsid[55]  = 
#line 37 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
  {      (char )'$',      (char )'I',      (char )'d',      (char )':', 
        (char )' ',      (char )'c',      (char )'m',      (char )'d', 
        (char )'t',      (char )'a',      (char )'b',      (char )'.', 
        (char )'c',      (char )',',      (char )'v',      (char )' ', 
        (char )'1',      (char )'.',      (char )'8',      (char )' ', 
        (char )'1',      (char )'9',      (char )'9',      (char )'9', 
        (char )'/',      (char )'0',      (char )'9',      (char )'/', 
        (char )'2',      (char )'8',      (char )' ',      (char )'1', 
        (char )'5',      (char )':',      (char )'3',      (char )'6', 
        (char )':',      (char )'0',      (char )'5',      (char )' ', 
        (char )'d',      (char )'h',      (char )'o',      (char )'l', 
        (char )'l',      (char )'a',      (char )'n',      (char )'d', 
        (char )' ',      (char )'E',      (char )'x',      (char )'p', 
        (char )' ',      (char )'$',      (char )'\000'};
#line 1 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.h"
void settick(void) ;
#line 2
void disconnect(void) ;
#line 4
void setascii(void) ;
#line 5
void setbell(void) ;
#line 6
void setbinary(void) ;
#line 7
void setdebug(int argc , char **argv ) ;
#line 8
void setform(void) ;
#line 9
void setglob(void) ;
#line 10
void sethash(void) ;
#line 11
void setipany(void) ;
#line 12
void setipv4(void) ;
#line 13
void setipv6(void) ;
#line 14
void setmode(void) ;
#line 15
void setport(void) ;
#line 16
void setprompt(void) ;
#line 17
void setstruct(void) ;
#line 18
void settenex(void) ;
#line 19
void settrace(void) ;
#line 20
void settype(int argc , char **argv ) ;
#line 21
void setverbose(void) ;
#line 22
void restart(int argc , char **argv ) ;
#line 23
void reget(int argc , char **argv ) ;
#line 24
void syst(void) ;
#line 25
void cd(int argc , char **argv ) ;
#line 26
void lcd(int argc , char **argv ) ;
#line 27
void delete_cmd(int argc , char **argv ) ;
#line 28
void mdelete(int argc , char **argv ) ;
#line 29
void user(int argc , char **argv ) ;
#line 30
void ls(int argc , char **argv ) ;
#line 31
void mls(int argc , char **argv ) ;
#line 32
void get(int argc , char **argv ) ;
#line 33
void mget(int argc , char **argv ) ;
#line 36
void put(int argc , char **argv ) ;
#line 37
void mput(int argc , char **argv ) ;
#line 38
void renamefile(int argc , char **argv ) ;
#line 39
void status(void) ;
#line 40
void quote(int argc , char **argv ) ;
#line 41
void rmthelp(int argc , char **argv ) ;
#line 42
void shell(char const   *arg ) ;
#line 43
void site(int argc , char **argv ) ;
#line 44
void pwd(void) ;
#line 45
void makedir(int argc , char **argv ) ;
#line 46
void removedir(int argc , char **argv ) ;
#line 47
void setcr(void) ;
#line 48
void setqc(void) ;
#line 49
void account(int argc , char **argv ) ;
#line 50
void doproxy(int argc , char **argv ) ;
#line 52
void setcase(void) ;
#line 53
void setntrans(int argc , char **argv ) ;
#line 54
void setnmap(int argc , char **argv ) ;
#line 55
void setsunique(void) ;
#line 56
void setrunique(void) ;
#line 57
void cdup(void) ;
#line 58
void macdef(int argc , char **argv ) ;
#line 59
void sizecmd(int argc , char **argv ) ;
#line 60
void modtime(int argc , char **argv ) ;
#line 61
void newer(int argc , char **argv ) ;
#line 62
void rmtstatus(int argc , char **argv ) ;
#line 63
void do_chmod(int argc , char **argv ) ;
#line 64
void do_umask(int argc , char **argv ) ;
#line 65
void idle_cmd(int argc , char **argv ) ;
#line 66
void setpassive(void) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   accounthelp[38]  = 
#line 48 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
  {      (char const   )'s',      (char const   )'e',      (char const   )'n',      (char const   )'d', 
        (char const   )' ',      (char const   )'a',      (char const   )'c',      (char const   )'c', 
        (char const   )'o',      (char const   )'u',      (char const   )'n',      (char const   )'t', 
        (char const   )' ',      (char const   )'c',      (char const   )'o',      (char const   )'m', 
        (char const   )'m',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )' ',      (char const   )'t',      (char const   )'o',      (char const   )' ', 
        (char const   )'r',      (char const   )'e',      (char const   )'m',      (char const   )'o', 
        (char const   )'t',      (char const   )'e',      (char const   )' ',      (char const   )'s', 
        (char const   )'e',      (char const   )'r',      (char const   )'v',      (char const   )'e', 
        (char const   )'r',      (char const   )'\000'};
#line 49 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   appendhelp[17]  = 
#line 49
  {      (char const   )'a',      (char const   )'p',      (char const   )'p',      (char const   )'e', 
        (char const   )'n',      (char const   )'d',      (char const   )' ',      (char const   )'t', 
        (char const   )'o',      (char const   )' ',      (char const   )'a',      (char const   )' ', 
        (char const   )'f',      (char const   )'i',      (char const   )'l',      (char const   )'e', 
        (char const   )'\000'};
#line 50 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   asciihelp[24]  = 
#line 50
  {      (char const   )'s',      (char const   )'e',      (char const   )'t',      (char const   )' ', 
        (char const   )'a',      (char const   )'s',      (char const   )'c',      (char const   )'i', 
        (char const   )'i',      (char const   )' ',      (char const   )'t',      (char const   )'r', 
        (char const   )'a',      (char const   )'n',      (char const   )'s',      (char const   )'f', 
        (char const   )'e',      (char const   )'r',      (char const   )' ',      (char const   )'t', 
        (char const   )'y',      (char const   )'p',      (char const   )'e',      (char const   )'\000'};
#line 51 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   beephelp[28]  = 
#line 51
  {      (char const   )'b',      (char const   )'e',      (char const   )'e',      (char const   )'p', 
        (char const   )' ',      (char const   )'w',      (char const   )'h',      (char const   )'e', 
        (char const   )'n',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'m',      (char const   )'m',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'m',      (char const   )'p',      (char const   )'l',      (char const   )'e', 
        (char const   )'t',      (char const   )'e',      (char const   )'d',      (char const   )'\000'};
#line 52 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   binaryhelp[25]  = 
#line 52
  {      (char const   )'s',      (char const   )'e',      (char const   )'t',      (char const   )' ', 
        (char const   )'b',      (char const   )'i',      (char const   )'n',      (char const   )'a', 
        (char const   )'r',      (char const   )'y',      (char const   )' ',      (char const   )'t', 
        (char const   )'r',      (char const   )'a',      (char const   )'n',      (char const   )'s', 
        (char const   )'f',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'\000'};
#line 53 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   casehelp[40]  = 
#line 53
  {      (char const   )'t',      (char const   )'o',      (char const   )'g',      (char const   )'g', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'m', 
        (char const   )'g',      (char const   )'e',      (char const   )'t',      (char const   )' ', 
        (char const   )'u',      (char const   )'p',      (char const   )'p',      (char const   )'e', 
        (char const   )'r',      (char const   )'/',      (char const   )'l',      (char const   )'o', 
        (char const   )'w',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'c',      (char const   )'a',      (char const   )'s',      (char const   )'e', 
        (char const   )' ',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'m',      (char const   )'a',      (char const   )'p',      (char const   )'p', 
        (char const   )'i',      (char const   )'n',      (char const   )'g',      (char const   )'\000'};
#line 54 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   cdhelp[32]  = 
#line 54
  {      (char const   )'c',      (char const   )'h',      (char const   )'a',      (char const   )'n', 
        (char const   )'g',      (char const   )'e',      (char const   )' ',      (char const   )'r', 
        (char const   )'e',      (char const   )'m',      (char const   )'o',      (char const   )'t', 
        (char const   )'e',      (char const   )' ',      (char const   )'w',      (char const   )'o', 
        (char const   )'r',      (char const   )'k',      (char const   )'i',      (char const   )'n', 
        (char const   )'g',      (char const   )' ',      (char const   )'d',      (char const   )'i', 
        (char const   )'r',      (char const   )'e',      (char const   )'c',      (char const   )'t', 
        (char const   )'o',      (char const   )'r',      (char const   )'y',      (char const   )'\000'};
#line 55 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   cduphelp[52]  = 
#line 55
  {      (char const   )'c',      (char const   )'h',      (char const   )'a',      (char const   )'n', 
        (char const   )'g',      (char const   )'e',      (char const   )' ',      (char const   )'r', 
        (char const   )'e',      (char const   )'m',      (char const   )'o',      (char const   )'t', 
        (char const   )'e',      (char const   )' ',      (char const   )'w',      (char const   )'o', 
        (char const   )'r',      (char const   )'k',      (char const   )'i',      (char const   )'n', 
        (char const   )'g',      (char const   )' ',      (char const   )'d',      (char const   )'i', 
        (char const   )'r',      (char const   )'e',      (char const   )'c',      (char const   )'t', 
        (char const   )'o',      (char const   )'r',      (char const   )'y',      (char const   )' ', 
        (char const   )'t',      (char const   )'o',      (char const   )' ',      (char const   )'p', 
        (char const   )'a',      (char const   )'r',      (char const   )'e',      (char const   )'n', 
        (char const   )'t',      (char const   )' ',      (char const   )'d',      (char const   )'i', 
        (char const   )'r',      (char const   )'e',      (char const   )'c',      (char const   )'t', 
        (char const   )'o',      (char const   )'r',      (char const   )'y',      (char const   )'\000'};
#line 56 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   chmodhelp[39]  = 
#line 56
  {      (char const   )'c',      (char const   )'h',      (char const   )'a',      (char const   )'n', 
        (char const   )'g',      (char const   )'e',      (char const   )' ',      (char const   )'f', 
        (char const   )'i',      (char const   )'l',      (char const   )'e',      (char const   )' ', 
        (char const   )'p',      (char const   )'e',      (char const   )'r',      (char const   )'m', 
        (char const   )'i',      (char const   )'s',      (char const   )'s',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )'s',      (char const   )' ', 
        (char const   )'o',      (char const   )'f',      (char const   )' ',      (char const   )'r', 
        (char const   )'e',      (char const   )'m',      (char const   )'o',      (char const   )'t', 
        (char const   )'e',      (char const   )' ',      (char const   )'f',      (char const   )'i', 
        (char const   )'l',      (char const   )'e',      (char const   )'\000'};
#line 57 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   connecthelp[22]  = 
#line 57
  {      (char const   )'c',      (char const   )'o',      (char const   )'n',      (char const   )'n', 
        (char const   )'e',      (char const   )'c',      (char const   )'t',      (char const   )' ', 
        (char const   )'t',      (char const   )'o',      (char const   )' ',      (char const   )'r', 
        (char const   )'e',      (char const   )'m',      (char const   )'o',      (char const   )'t', 
        (char const   )'e',      (char const   )' ',      (char const   )'f',      (char const   )'t', 
        (char const   )'p',      (char const   )'\000'};
#line 58 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   crhelp[47]  = 
#line 58
  {      (char const   )'t',      (char const   )'o',      (char const   )'g',      (char const   )'g', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'c', 
        (char const   )'a',      (char const   )'r',      (char const   )'r',      (char const   )'i', 
        (char const   )'a',      (char const   )'g',      (char const   )'e',      (char const   )' ', 
        (char const   )'r',      (char const   )'e',      (char const   )'t',      (char const   )'u', 
        (char const   )'r',      (char const   )'n',      (char const   )' ',      (char const   )'s', 
        (char const   )'t',      (char const   )'r',      (char const   )'i',      (char const   )'p', 
        (char const   )'p',      (char const   )'i',      (char const   )'n',      (char const   )'g', 
        (char const   )' ',      (char const   )'o',      (char const   )'n',      (char const   )' ', 
        (char const   )'a',      (char const   )'s',      (char const   )'c',      (char const   )'i', 
        (char const   )'i',      (char const   )' ',      (char const   )'g',      (char const   )'e', 
        (char const   )'t',      (char const   )'s',      (char const   )'\000'};
#line 59 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   qchelp[49]  = 
#line 59
  {      (char const   )'p',      (char const   )'r',      (char const   )'i',      (char const   )'n', 
        (char const   )'t',      (char const   )' ',      (char const   )'?',      (char const   )' ', 
        (char const   )'i',      (char const   )'n',      (char const   )' ',      (char const   )'p', 
        (char const   )'l',      (char const   )'a',      (char const   )'c',      (char const   )'e', 
        (char const   )' ',      (char const   )'o',      (char const   )'f',      (char const   )' ', 
        (char const   )'c',      (char const   )'o',      (char const   )'n',      (char const   )'t', 
        (char const   )'r',      (char const   )'o',      (char const   )'l',      (char const   )' ', 
        (char const   )'c',      (char const   )'h',      (char const   )'a',      (char const   )'r', 
        (char const   )'a',      (char const   )'c',      (char const   )'t',      (char const   )'e', 
        (char const   )'r',      (char const   )'s',      (char const   )' ',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'s',      (char const   )'t', 
        (char const   )'d',      (char const   )'o',      (char const   )'u',      (char const   )'t', 
        (char const   )'\000'};
#line 60 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   deletehelp[19]  = 
#line 60
  {      (char const   )'d',      (char const   )'e',      (char const   )'l',      (char const   )'e', 
        (char const   )'t',      (char const   )'e',      (char const   )' ',      (char const   )'r', 
        (char const   )'e',      (char const   )'m',      (char const   )'o',      (char const   )'t', 
        (char const   )'e',      (char const   )' ',      (char const   )'f',      (char const   )'i', 
        (char const   )'l',      (char const   )'e',      (char const   )'\000'};
#line 61 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   debughelp[26]  = 
#line 61
  {      (char const   )'t',      (char const   )'o',      (char const   )'g',      (char const   )'g', 
        (char const   )'l',      (char const   )'e',      (char const   )'/',      (char const   )'s', 
        (char const   )'e',      (char const   )'t',      (char const   )' ',      (char const   )'d', 
        (char const   )'e',      (char const   )'b',      (char const   )'u',      (char const   )'g', 
        (char const   )'g',      (char const   )'i',      (char const   )'n',      (char const   )'g', 
        (char const   )' ',      (char const   )'m',      (char const   )'o',      (char const   )'d', 
        (char const   )'e',      (char const   )'\000'};
#line 62 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   dirhelp[34]  = 
#line 62
  {      (char const   )'l',      (char const   )'i',      (char const   )'s',      (char const   )'t', 
        (char const   )' ',      (char const   )'c',      (char const   )'o',      (char const   )'n', 
        (char const   )'t',      (char const   )'e',      (char const   )'n',      (char const   )'t', 
        (char const   )'s',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'m', 
        (char const   )'o',      (char const   )'t',      (char const   )'e',      (char const   )' ', 
        (char const   )'d',      (char const   )'i',      (char const   )'r',      (char const   )'e', 
        (char const   )'c',      (char const   )'t',      (char const   )'o',      (char const   )'r', 
        (char const   )'y',      (char const   )'\000'};
#line 63 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   disconhelp[22]  = 
#line 63
  {      (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )'m', 
        (char const   )'i',      (char const   )'n',      (char const   )'a',      (char const   )'t', 
        (char const   )'e',      (char const   )' ',      (char const   )'f',      (char const   )'t', 
        (char const   )'p',      (char const   )' ',      (char const   )'s',      (char const   )'e', 
        (char const   )'s',      (char const   )'s',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )'\000'};
#line 64 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   domachelp[14]  = 
#line 64
  {      (char const   )'e',      (char const   )'x',      (char const   )'e',      (char const   )'c', 
        (char const   )'u',      (char const   )'t',      (char const   )'e',      (char const   )' ', 
        (char const   )'m',      (char const   )'a',      (char const   )'c',      (char const   )'r', 
        (char const   )'o',      (char const   )'\000'};
#line 65 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   formhelp[25]  = 
#line 65
  {      (char const   )'s',      (char const   )'e',      (char const   )'t',      (char const   )' ', 
        (char const   )'f',      (char const   )'i',      (char const   )'l',      (char const   )'e', 
        (char const   )' ',      (char const   )'t',      (char const   )'r',      (char const   )'a', 
        (char const   )'n',      (char const   )'s',      (char const   )'f',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'f',      (char const   )'o', 
        (char const   )'r',      (char const   )'m',      (char const   )'a',      (char const   )'t', 
        (char const   )'\000'};
#line 66 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   globhelp[51]  = 
#line 66
  {      (char const   )'t',      (char const   )'o',      (char const   )'g',      (char const   )'g', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'m', 
        (char const   )'e',      (char const   )'t',      (char const   )'a',      (char const   )'c', 
        (char const   )'h',      (char const   )'a',      (char const   )'r',      (char const   )'a', 
        (char const   )'c',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'p', 
        (char const   )'a',      (char const   )'n',      (char const   )'s',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'o', 
        (char const   )'f',      (char const   )' ',      (char const   )'l',      (char const   )'o', 
        (char const   )'c',      (char const   )'a',      (char const   )'l',      (char const   )' ', 
        (char const   )'f',      (char const   )'i',      (char const   )'l',      (char const   )'e', 
        (char const   )' ',      (char const   )'n',      (char const   )'a',      (char const   )'m', 
        (char const   )'e',      (char const   )'s',      (char const   )'\000'};
#line 67 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   hashhelp[48]  = 
#line 67
  {      (char const   )'t',      (char const   )'o',      (char const   )'g',      (char const   )'g', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'p', 
        (char const   )'r',      (char const   )'i',      (char const   )'n',      (char const   )'t', 
        (char const   )'i',      (char const   )'n',      (char const   )'g',      (char const   )' ', 
        (char const   )'`',      (char const   )'#',      (char const   )'\'',      (char const   )' ', 
        (char const   )'f',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'e',      (char const   )'a',      (char const   )'c',      (char const   )'h', 
        (char const   )' ',      (char const   )'b',      (char const   )'u',      (char const   )'f', 
        (char const   )'f',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'t',      (char const   )'r',      (char const   )'a',      (char const   )'n', 
        (char const   )'s',      (char const   )'f',      (char const   )'e',      (char const   )'r', 
        (char const   )'r',      (char const   )'e',      (char const   )'d',      (char const   )'\000'};
#line 68 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   helphelp[29]  = 
#line 68
  {      (char const   )'p',      (char const   )'r',      (char const   )'i',      (char const   )'n', 
        (char const   )'t',      (char const   )' ',      (char const   )'l',      (char const   )'o', 
        (char const   )'c',      (char const   )'a',      (char const   )'l',      (char const   )' ', 
        (char const   )'h',      (char const   )'e',      (char const   )'l',      (char const   )'p', 
        (char const   )' ',      (char const   )'i',      (char const   )'n',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )'m',      (char const   )'a', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )'\000'};
#line 69 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   idlehelp[36]  = 
#line 69
  {      (char const   )'g',      (char const   )'e',      (char const   )'t',      (char const   )' ', 
        (char const   )'(',      (char const   )'s',      (char const   )'e',      (char const   )'t', 
        (char const   )')',      (char const   )' ',      (char const   )'i',      (char const   )'d', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'t', 
        (char const   )'i',      (char const   )'m',      (char const   )'e',      (char const   )'r', 
        (char const   )' ',      (char const   )'o',      (char const   )'n',      (char const   )' ', 
        (char const   )'r',      (char const   )'e',      (char const   )'m',      (char const   )'o', 
        (char const   )'t',      (char const   )'e',      (char const   )' ',      (char const   )'s', 
        (char const   )'i',      (char const   )'d',      (char const   )'e',      (char const   )'\000'};
#line 70 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   ipanyhelp[32]  = 
#line 70
  {      (char const   )'a',      (char const   )'l',      (char const   )'l',      (char const   )'o', 
        (char const   )'w',      (char const   )' ',      (char const   )'u',      (char const   )'s', 
        (char const   )'e',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'a',      (char const   )'n',      (char const   )'y', 
        (char const   )' ',      (char const   )'a',      (char const   )'d',      (char const   )'d', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
        (char const   )' ',      (char const   )'f',      (char const   )'a',      (char const   )'m', 
        (char const   )'i',      (char const   )'l',      (char const   )'y',      (char const   )'\000'};
#line 71 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   ipv4help[31]  = 
#line 71
  {      (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'t', 
        (char const   )'r',      (char const   )'i',      (char const   )'c',      (char const   )'t', 
        (char const   )' ',      (char const   )'a',      (char const   )'d',      (char const   )'d', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
        (char const   )' ',      (char const   )'u',      (char const   )'s',      (char const   )'a', 
        (char const   )'g',      (char const   )'e',      (char const   )' ',      (char const   )'t', 
        (char const   )'o',      (char const   )' ',      (char const   )'I',      (char const   )'P', 
        (char const   )'v',      (char const   )'4',      (char const   )'\000'};
#line 72 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   ipv6help[31]  = 
#line 72
  {      (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'t', 
        (char const   )'r',      (char const   )'i',      (char const   )'c',      (char const   )'t', 
        (char const   )' ',      (char const   )'a',      (char const   )'d',      (char const   )'d', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
        (char const   )' ',      (char const   )'u',      (char const   )'s',      (char const   )'a', 
        (char const   )'g',      (char const   )'e',      (char const   )' ',      (char const   )'t', 
        (char const   )'o',      (char const   )' ',      (char const   )'I',      (char const   )'P', 
        (char const   )'v',      (char const   )'6',      (char const   )'\000'};
#line 73 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   lcdhelp[31]  = 
#line 73
  {      (char const   )'c',      (char const   )'h',      (char const   )'a',      (char const   )'n', 
        (char const   )'g',      (char const   )'e',      (char const   )' ',      (char const   )'l', 
        (char const   )'o',      (char const   )'c',      (char const   )'a',      (char const   )'l', 
        (char const   )' ',      (char const   )'w',      (char const   )'o',      (char const   )'r', 
        (char const   )'k',      (char const   )'i',      (char const   )'n',      (char const   )'g', 
        (char const   )' ',      (char const   )'d',      (char const   )'i',      (char const   )'r', 
        (char const   )'e',      (char const   )'c',      (char const   )'t',      (char const   )'o', 
        (char const   )'r',      (char const   )'y',      (char const   )'\000'};
#line 74 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   lshelp[34]  = 
#line 74
  {      (char const   )'l',      (char const   )'i',      (char const   )'s',      (char const   )'t', 
        (char const   )' ',      (char const   )'c',      (char const   )'o',      (char const   )'n', 
        (char const   )'t',      (char const   )'e',      (char const   )'n',      (char const   )'t', 
        (char const   )'s',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'m', 
        (char const   )'o',      (char const   )'t',      (char const   )'e',      (char const   )' ', 
        (char const   )'d',      (char const   )'i',      (char const   )'r',      (char const   )'e', 
        (char const   )'c',      (char const   )'t',      (char const   )'o',      (char const   )'r', 
        (char const   )'y',      (char const   )'\000'};
#line 75 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   macdefhelp[15]  = 
#line 75
  {      (char const   )'d',      (char const   )'e',      (char const   )'f',      (char const   )'i', 
        (char const   )'n',      (char const   )'e',      (char const   )' ',      (char const   )'a', 
        (char const   )' ',      (char const   )'m',      (char const   )'a',      (char const   )'c', 
        (char const   )'r',      (char const   )'o',      (char const   )'\000'};
#line 76 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   mdeletehelp[22]  = 
#line 76
  {      (char const   )'d',      (char const   )'e',      (char const   )'l',      (char const   )'e', 
        (char const   )'t',      (char const   )'e',      (char const   )' ',      (char const   )'m', 
        (char const   )'u',      (char const   )'l',      (char const   )'t',      (char const   )'i', 
        (char const   )'p',      (char const   )'l',      (char const   )'e',      (char const   )' ', 
        (char const   )'f',      (char const   )'i',      (char const   )'l',      (char const   )'e', 
        (char const   )'s',      (char const   )'\000'};
#line 77 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   mdirhelp[45]  = 
#line 77
  {      (char const   )'l',      (char const   )'i',      (char const   )'s',      (char const   )'t', 
        (char const   )' ',      (char const   )'c',      (char const   )'o',      (char const   )'n', 
        (char const   )'t',      (char const   )'e',      (char const   )'n',      (char const   )'t', 
        (char const   )'s',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'m',      (char const   )'u',      (char const   )'l', 
        (char const   )'t',      (char const   )'i',      (char const   )'p',      (char const   )'l', 
        (char const   )'e',      (char const   )' ',      (char const   )'r',      (char const   )'e', 
        (char const   )'m',      (char const   )'o',      (char const   )'t',      (char const   )'e', 
        (char const   )' ',      (char const   )'d',      (char const   )'i',      (char const   )'r', 
        (char const   )'e',      (char const   )'c',      (char const   )'t',      (char const   )'o', 
        (char const   )'r',      (char const   )'i',      (char const   )'e',      (char const   )'s', 
        (char const   )'\000'};
#line 78 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   mgethelp[19]  = 
#line 78
  {      (char const   )'g',      (char const   )'e',      (char const   )'t',      (char const   )' ', 
        (char const   )'m',      (char const   )'u',      (char const   )'l',      (char const   )'t', 
        (char const   )'i',      (char const   )'p',      (char const   )'l',      (char const   )'e', 
        (char const   )' ',      (char const   )'f',      (char const   )'i',      (char const   )'l', 
        (char const   )'e',      (char const   )'s',      (char const   )'\000'};
#line 79 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   mkdirhelp[37]  = 
#line 79
  {      (char const   )'m',      (char const   )'a',      (char const   )'k',      (char const   )'e', 
        (char const   )' ',      (char const   )'d',      (char const   )'i',      (char const   )'r', 
        (char const   )'e',      (char const   )'c',      (char const   )'t',      (char const   )'o', 
        (char const   )'r',      (char const   )'y',      (char const   )' ',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'t',      (char const   )'h', 
        (char const   )'e',      (char const   )' ',      (char const   )'r',      (char const   )'e', 
        (char const   )'m',      (char const   )'o',      (char const   )'t',      (char const   )'e', 
        (char const   )' ',      (char const   )'m',      (char const   )'a',      (char const   )'c', 
        (char const   )'h',      (char const   )'i',      (char const   )'n',      (char const   )'e', 
        (char const   )'\000'};
#line 80 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   mlshelp[45]  = 
#line 80
  {      (char const   )'l',      (char const   )'i',      (char const   )'s',      (char const   )'t', 
        (char const   )' ',      (char const   )'c',      (char const   )'o',      (char const   )'n', 
        (char const   )'t',      (char const   )'e',      (char const   )'n',      (char const   )'t', 
        (char const   )'s',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'m',      (char const   )'u',      (char const   )'l', 
        (char const   )'t',      (char const   )'i',      (char const   )'p',      (char const   )'l', 
        (char const   )'e',      (char const   )' ',      (char const   )'r',      (char const   )'e', 
        (char const   )'m',      (char const   )'o',      (char const   )'t',      (char const   )'e', 
        (char const   )' ',      (char const   )'d',      (char const   )'i',      (char const   )'r', 
        (char const   )'e',      (char const   )'c',      (char const   )'t',      (char const   )'o', 
        (char const   )'r',      (char const   )'i',      (char const   )'e',      (char const   )'s', 
        (char const   )'\000'};
#line 81 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   modtimehelp[43]  = 
#line 81
  {      (char const   )'s',      (char const   )'h',      (char const   )'o',      (char const   )'w', 
        (char const   )' ',      (char const   )'l',      (char const   )'a',      (char const   )'s', 
        (char const   )'t',      (char const   )' ',      (char const   )'m',      (char const   )'o', 
        (char const   )'d',      (char const   )'i',      (char const   )'f',      (char const   )'i', 
        (char const   )'c',      (char const   )'a',      (char const   )'t',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'t', 
        (char const   )'i',      (char const   )'m',      (char const   )'e',      (char const   )' ', 
        (char const   )'o',      (char const   )'f',      (char const   )' ',      (char const   )'r', 
        (char const   )'e',      (char const   )'m',      (char const   )'o',      (char const   )'t', 
        (char const   )'e',      (char const   )' ',      (char const   )'f',      (char const   )'i', 
        (char const   )'l',      (char const   )'e',      (char const   )'\000'};
#line 82 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   modehelp[23]  = 
#line 82
  {      (char const   )'s',      (char const   )'e',      (char const   )'t',      (char const   )' ', 
        (char const   )'f',      (char const   )'i',      (char const   )'l',      (char const   )'e', 
        (char const   )' ',      (char const   )'t',      (char const   )'r',      (char const   )'a', 
        (char const   )'n',      (char const   )'s',      (char const   )'f',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'m',      (char const   )'o', 
        (char const   )'d',      (char const   )'e',      (char const   )'\000'};
#line 83 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   mputhelp[20]  = 
#line 83
  {      (char const   )'s',      (char const   )'e',      (char const   )'n',      (char const   )'d', 
        (char const   )' ',      (char const   )'m',      (char const   )'u',      (char const   )'l', 
        (char const   )'t',      (char const   )'i',      (char const   )'p',      (char const   )'l', 
        (char const   )'e',      (char const   )' ',      (char const   )'f',      (char const   )'i', 
        (char const   )'l',      (char const   )'e',      (char const   )'s',      (char const   )'\000'};
#line 84 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   newerhelp[50]  = 
#line 84
  {      (char const   )'g',      (char const   )'e',      (char const   )'t',      (char const   )' ', 
        (char const   )'f',      (char const   )'i',      (char const   )'l',      (char const   )'e', 
        (char const   )' ',      (char const   )'i',      (char const   )'f',      (char const   )' ', 
        (char const   )'r',      (char const   )'e',      (char const   )'m',      (char const   )'o', 
        (char const   )'t',      (char const   )'e',      (char const   )' ',      (char const   )'f', 
        (char const   )'i',      (char const   )'l',      (char const   )'e',      (char const   )' ', 
        (char const   )'i',      (char const   )'s',      (char const   )' ',      (char const   )'n', 
        (char const   )'e',      (char const   )'w',      (char const   )'e',      (char const   )'r', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'a', 
        (char const   )'n',      (char const   )' ',      (char const   )'l',      (char const   )'o', 
        (char const   )'c',      (char const   )'a',      (char const   )'l',      (char const   )' ', 
        (char const   )'f',      (char const   )'i',      (char const   )'l',      (char const   )'e', 
        (char const   )' ',      (char const   )'\000'};
#line 85 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   nlisthelp[35]  = 
#line 85
  {      (char const   )'n',      (char const   )'l',      (char const   )'i',      (char const   )'s', 
        (char const   )'t',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'n',      (char const   )'t',      (char const   )'e',      (char const   )'n', 
        (char const   )'t',      (char const   )'s',      (char const   )' ',      (char const   )'o', 
        (char const   )'f',      (char const   )' ',      (char const   )'r',      (char const   )'e', 
        (char const   )'m',      (char const   )'o',      (char const   )'t',      (char const   )'e', 
        (char const   )' ',      (char const   )'d',      (char const   )'i',      (char const   )'r', 
        (char const   )'e',      (char const   )'c',      (char const   )'t',      (char const   )'o', 
        (char const   )'r',      (char const   )'y',      (char const   )'\000'};
#line 86 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   nmaphelp[44]  = 
#line 86
  {      (char const   )'s',      (char const   )'e',      (char const   )'t',      (char const   )' ', 
        (char const   )'t',      (char const   )'e',      (char const   )'m',      (char const   )'p', 
        (char const   )'l',      (char const   )'a',      (char const   )'t',      (char const   )'e', 
        (char const   )'s',      (char const   )' ',      (char const   )'f',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'d',      (char const   )'e', 
        (char const   )'f',      (char const   )'a',      (char const   )'u',      (char const   )'l', 
        (char const   )'t',      (char const   )' ',      (char const   )'f',      (char const   )'i', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'n', 
        (char const   )'a',      (char const   )'m',      (char const   )'e',      (char const   )' ', 
        (char const   )'m',      (char const   )'a',      (char const   )'p',      (char const   )'p', 
        (char const   )'i',      (char const   )'n',      (char const   )'g',      (char const   )'\000'};
#line 87 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   ntranshelp[52]  = 
#line 87
  {      (char const   )'s',      (char const   )'e',      (char const   )'t',      (char const   )' ', 
        (char const   )'t',      (char const   )'r',      (char const   )'a',      (char const   )'n', 
        (char const   )'s',      (char const   )'l',      (char const   )'a',      (char const   )'t', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )' ', 
        (char const   )'t',      (char const   )'a',      (char const   )'b',      (char const   )'l', 
        (char const   )'e',      (char const   )' ',      (char const   )'f',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'d',      (char const   )'e', 
        (char const   )'f',      (char const   )'a',      (char const   )'u',      (char const   )'l', 
        (char const   )'t',      (char const   )' ',      (char const   )'f',      (char const   )'i', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'n', 
        (char const   )'a',      (char const   )'m',      (char const   )'e',      (char const   )' ', 
        (char const   )'m',      (char const   )'a',      (char const   )'p',      (char const   )'p', 
        (char const   )'i',      (char const   )'n',      (char const   )'g',      (char const   )'\000'};
#line 88 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   passivehelp[28]  = 
#line 88
  {      (char const   )'e',      (char const   )'n',      (char const   )'t',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'p',      (char const   )'a', 
        (char const   )'s',      (char const   )'s',      (char const   )'i',      (char const   )'v', 
        (char const   )'e',      (char const   )' ',      (char const   )'t',      (char const   )'r', 
        (char const   )'a',      (char const   )'n',      (char const   )'s',      (char const   )'f', 
        (char const   )'e',      (char const   )'r',      (char const   )' ',      (char const   )'m', 
        (char const   )'o',      (char const   )'d',      (char const   )'e',      (char const   )'\000'};
#line 89 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   porthelp[48]  = 
#line 89
  {      (char const   )'t',      (char const   )'o',      (char const   )'g',      (char const   )'g', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'u', 
        (char const   )'s',      (char const   )'e',      (char const   )' ',      (char const   )'o', 
        (char const   )'f',      (char const   )' ',      (char const   )'P',      (char const   )'O', 
        (char const   )'R',      (char const   )'T',      (char const   )' ',      (char const   )'c', 
        (char const   )'m',      (char const   )'d',      (char const   )' ',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )' ',      (char const   )'e', 
        (char const   )'a',      (char const   )'c',      (char const   )'h',      (char const   )' ', 
        (char const   )'d',      (char const   )'a',      (char const   )'t',      (char const   )'a', 
        (char const   )' ',      (char const   )'c',      (char const   )'o',      (char const   )'n', 
        (char const   )'n',      (char const   )'e',      (char const   )'c',      (char const   )'t', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'\000'};
#line 90 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   prompthelp[49]  = 
#line 90
  {      (char const   )'f',      (char const   )'o',      (char const   )'r',      (char const   )'c', 
        (char const   )'e',      (char const   )' ',      (char const   )'i',      (char const   )'n', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )'a', 
        (char const   )'c',      (char const   )'t',      (char const   )'i',      (char const   )'v', 
        (char const   )'e',      (char const   )' ',      (char const   )'p',      (char const   )'r', 
        (char const   )'o',      (char const   )'m',      (char const   )'p',      (char const   )'t', 
        (char const   )'i',      (char const   )'n',      (char const   )'g',      (char const   )' ', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'m', 
        (char const   )'u',      (char const   )'l',      (char const   )'t',      (char const   )'i', 
        (char const   )'p',      (char const   )'l',      (char const   )'e',      (char const   )' ', 
        (char const   )'c',      (char const   )'o',      (char const   )'m',      (char const   )'m', 
        (char const   )'a',      (char const   )'n',      (char const   )'d',      (char const   )'s', 
        (char const   )'\000'};
#line 91 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   proxyhelp[38]  = 
#line 91
  {      (char const   )'i',      (char const   )'s',      (char const   )'s',      (char const   )'u', 
        (char const   )'e',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'m',      (char const   )'m',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )' ',      (char const   )'o',      (char const   )'n', 
        (char const   )' ',      (char const   )'a',      (char const   )'l',      (char const   )'t', 
        (char const   )'e',      (char const   )'r',      (char const   )'n',      (char const   )'a', 
        (char const   )'t',      (char const   )'e',      (char const   )' ',      (char const   )'c', 
        (char const   )'o',      (char const   )'n',      (char const   )'n',      (char const   )'e', 
        (char const   )'c',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )'\000'};
#line 92 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   pwdhelp[42]  = 
#line 92
  {      (char const   )'p',      (char const   )'r',      (char const   )'i',      (char const   )'n', 
        (char const   )'t',      (char const   )' ',      (char const   )'w',      (char const   )'o', 
        (char const   )'r',      (char const   )'k',      (char const   )'i',      (char const   )'n', 
        (char const   )'g',      (char const   )' ',      (char const   )'d',      (char const   )'i', 
        (char const   )'r',      (char const   )'e',      (char const   )'c',      (char const   )'t', 
        (char const   )'o',      (char const   )'r',      (char const   )'y',      (char const   )' ', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'r', 
        (char const   )'e',      (char const   )'m',      (char const   )'o',      (char const   )'t', 
        (char const   )'e',      (char const   )' ',      (char const   )'m',      (char const   )'a', 
        (char const   )'c',      (char const   )'h',      (char const   )'i',      (char const   )'n', 
        (char const   )'e',      (char const   )'\000'};
#line 93 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   quithelp[31]  = 
#line 93
  {      (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )'m', 
        (char const   )'i',      (char const   )'n',      (char const   )'a',      (char const   )'t', 
        (char const   )'e',      (char const   )' ',      (char const   )'f',      (char const   )'t', 
        (char const   )'p',      (char const   )' ',      (char const   )'s',      (char const   )'e', 
        (char const   )'s',      (char const   )'s',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )' ',      (char const   )'e',      (char const   )'x', 
        (char const   )'i',      (char const   )'t',      (char const   )'\000'};
#line 94 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   quotehelp[27]  = 
#line 94
  {      (char const   )'s',      (char const   )'e',      (char const   )'n',      (char const   )'d', 
        (char const   )' ',      (char const   )'a',      (char const   )'r',      (char const   )'b', 
        (char const   )'i',      (char const   )'t',      (char const   )'r',      (char const   )'a', 
        (char const   )'r',      (char const   )'y',      (char const   )' ',      (char const   )'f', 
        (char const   )'t',      (char const   )'p',      (char const   )' ',      (char const   )'c', 
        (char const   )'o',      (char const   )'m',      (char const   )'m',      (char const   )'a', 
        (char const   )'n',      (char const   )'d',      (char const   )'\000'};
#line 95 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   receivehelp[13]  = 
#line 95
  {      (char const   )'r',      (char const   )'e',      (char const   )'c',      (char const   )'e', 
        (char const   )'i',      (char const   )'v',      (char const   )'e',      (char const   )' ', 
        (char const   )'f',      (char const   )'i',      (char const   )'l',      (char const   )'e', 
        (char const   )'\000'};
#line 96 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   regethelp[41]  = 
#line 96
  {      (char const   )'g',      (char const   )'e',      (char const   )'t',      (char const   )' ', 
        (char const   )'f',      (char const   )'i',      (char const   )'l',      (char const   )'e', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'s', 
        (char const   )'t',      (char const   )'a',      (char const   )'r',      (char const   )'t', 
        (char const   )'i',      (char const   )'n',      (char const   )'g',      (char const   )' ', 
        (char const   )'a',      (char const   )'t',      (char const   )' ',      (char const   )'e', 
        (char const   )'n',      (char const   )'d',      (char const   )' ',      (char const   )'o', 
        (char const   )'f',      (char const   )' ',      (char const   )'l',      (char const   )'o', 
        (char const   )'c',      (char const   )'a',      (char const   )'l',      (char const   )' ', 
        (char const   )'f',      (char const   )'i',      (char const   )'l',      (char const   )'e', 
        (char const   )'\000'};
#line 97 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   remotehelp[28]  = 
#line 97
  {      (char const   )'g',      (char const   )'e',      (char const   )'t',      (char const   )' ', 
        (char const   )'h',      (char const   )'e',      (char const   )'l',      (char const   )'p', 
        (char const   )' ',      (char const   )'f',      (char const   )'r',      (char const   )'o', 
        (char const   )'m',      (char const   )' ',      (char const   )'r',      (char const   )'e', 
        (char const   )'m',      (char const   )'o',      (char const   )'t',      (char const   )'e', 
        (char const   )' ',      (char const   )'s',      (char const   )'e',      (char const   )'r', 
        (char const   )'v',      (char const   )'e',      (char const   )'r',      (char const   )'\000'};
#line 98 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   renamehelp[12]  = 
#line 98
  {      (char const   )'r',      (char const   )'e',      (char const   )'n',      (char const   )'a', 
        (char const   )'m',      (char const   )'e',      (char const   )' ',      (char const   )'f', 
        (char const   )'i',      (char const   )'l',      (char const   )'e',      (char const   )'\000'};
#line 99 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   restarthelp[35]  = 
#line 99
  {      (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'t', 
        (char const   )'a',      (char const   )'r',      (char const   )'t',      (char const   )' ', 
        (char const   )'f',      (char const   )'i',      (char const   )'l',      (char const   )'e', 
        (char const   )' ',      (char const   )'t',      (char const   )'r',      (char const   )'a', 
        (char const   )'n',      (char const   )'s',      (char const   )'f',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'a',      (char const   )'t', 
        (char const   )' ',      (char const   )'b',      (char const   )'y',      (char const   )'t', 
        (char const   )'e',      (char const   )'c',      (char const   )'o',      (char const   )'u', 
        (char const   )'n',      (char const   )'t',      (char const   )'\000'};
#line 100 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   rmdirhelp[39]  = 
#line 100
  {      (char const   )'r',      (char const   )'e',      (char const   )'m',      (char const   )'o', 
        (char const   )'v',      (char const   )'e',      (char const   )' ',      (char const   )'d', 
        (char const   )'i',      (char const   )'r',      (char const   )'e',      (char const   )'c', 
        (char const   )'t',      (char const   )'o',      (char const   )'r',      (char const   )'y', 
        (char const   )' ',      (char const   )'o',      (char const   )'n',      (char const   )' ', 
        (char const   )'t',      (char const   )'h',      (char const   )'e',      (char const   )' ', 
        (char const   )'r',      (char const   )'e',      (char const   )'m',      (char const   )'o', 
        (char const   )'t',      (char const   )'e',      (char const   )' ',      (char const   )'m', 
        (char const   )'a',      (char const   )'c',      (char const   )'h',      (char const   )'i', 
        (char const   )'n',      (char const   )'e',      (char const   )'\000'};
#line 101 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   rmtstatushelp[30]  = 
#line 101
  {      (char const   )'s',      (char const   )'h',      (char const   )'o',      (char const   )'w', 
        (char const   )' ',      (char const   )'s',      (char const   )'t',      (char const   )'a', 
        (char const   )'t',      (char const   )'u',      (char const   )'s',      (char const   )' ', 
        (char const   )'o',      (char const   )'f',      (char const   )' ',      (char const   )'r', 
        (char const   )'e',      (char const   )'m',      (char const   )'o',      (char const   )'t', 
        (char const   )'e',      (char const   )' ',      (char const   )'m',      (char const   )'a', 
        (char const   )'c',      (char const   )'h',      (char const   )'i',      (char const   )'n', 
        (char const   )'e',      (char const   )'\000'};
#line 102 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   runiquehelp[36]  = 
#line 102
  {      (char const   )'t',      (char const   )'o',      (char const   )'g',      (char const   )'g', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'s', 
        (char const   )'t',      (char const   )'o',      (char const   )'r',      (char const   )'e', 
        (char const   )' ',      (char const   )'u',      (char const   )'n',      (char const   )'i', 
        (char const   )'q',      (char const   )'u',      (char const   )'e',      (char const   )' ', 
        (char const   )'f',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'l',      (char const   )'o',      (char const   )'c',      (char const   )'a', 
        (char const   )'l',      (char const   )' ',      (char const   )'f',      (char const   )'i', 
        (char const   )'l',      (char const   )'e',      (char const   )'s',      (char const   )'\000'};
#line 103 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   resethelp[29]  = 
#line 103
  {      (char const   )'c',      (char const   )'l',      (char const   )'e',      (char const   )'a', 
        (char const   )'r',      (char const   )' ',      (char const   )'q',      (char const   )'u', 
        (char const   )'e',      (char const   )'u',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'c',      (char const   )'o',      (char const   )'m', 
        (char const   )'m',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'p', 
        (char const   )'l',      (char const   )'i',      (char const   )'e',      (char const   )'s', 
        (char const   )'\000'};
#line 104 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   sendhelp[14]  = 
#line 104
  {      (char const   )'s',      (char const   )'e',      (char const   )'n',      (char const   )'d', 
        (char const   )' ',      (char const   )'o',      (char const   )'n',      (char const   )'e', 
        (char const   )' ',      (char const   )'f',      (char const   )'i',      (char const   )'l', 
        (char const   )'e',      (char const   )'\000'};
#line 105 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   sitehelp[99]  = 
#line 105
  {      (char const   )'s',      (char const   )'e',      (char const   )'n',      (char const   )'d', 
        (char const   )' ',      (char const   )'s',      (char const   )'i',      (char const   )'t', 
        (char const   )'e',      (char const   )' ',      (char const   )'s',      (char const   )'p', 
        (char const   )'e',      (char const   )'c',      (char const   )'i',      (char const   )'f', 
        (char const   )'i',      (char const   )'c',      (char const   )' ',      (char const   )'c', 
        (char const   )'o',      (char const   )'m',      (char const   )'m',      (char const   )'a', 
        (char const   )'n',      (char const   )'d',      (char const   )' ',      (char const   )'t', 
        (char const   )'o',      (char const   )' ',      (char const   )'r',      (char const   )'e', 
        (char const   )'m',      (char const   )'o',      (char const   )'t',      (char const   )'e', 
        (char const   )' ',      (char const   )'s',      (char const   )'e',      (char const   )'r', 
        (char const   )'v',      (char const   )'e',      (char const   )'r',      (char const   )'\n', 
        (char const   )'\t',      (char const   )'\t',      (char const   )'T',      (char const   )'r', 
        (char const   )'y',      (char const   )' ',      (char const   )'\"',      (char const   )'r', 
        (char const   )'h',      (char const   )'e',      (char const   )'l',      (char const   )'p', 
        (char const   )' ',      (char const   )'s',      (char const   )'i',      (char const   )'t', 
        (char const   )'e',      (char const   )'\"',      (char const   )' ',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'\"',      (char const   )'s', 
        (char const   )'i',      (char const   )'t',      (char const   )'e',      (char const   )' ', 
        (char const   )'h',      (char const   )'e',      (char const   )'l',      (char const   )'p', 
        (char const   )'\"',      (char const   )' ',      (char const   )'f',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'m',      (char const   )'o', 
        (char const   )'r',      (char const   )'e',      (char const   )' ',      (char const   )'i', 
        (char const   )'n',      (char const   )'f',      (char const   )'o',      (char const   )'r', 
        (char const   )'m',      (char const   )'a',      (char const   )'t',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )'\000'};
#line 107 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   shellhelp[20]  = 
#line 107
  {      (char const   )'e',      (char const   )'s',      (char const   )'c',      (char const   )'a', 
        (char const   )'p',      (char const   )'e',      (char const   )' ',      (char const   )'t', 
        (char const   )'o',      (char const   )' ',      (char const   )'t',      (char const   )'h', 
        (char const   )'e',      (char const   )' ',      (char const   )'s',      (char const   )'h', 
        (char const   )'e',      (char const   )'l',      (char const   )'l',      (char const   )'\000'};
#line 108 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   sizecmdhelp[25]  = 
#line 108
  {      (char const   )'s',      (char const   )'h',      (char const   )'o',      (char const   )'w', 
        (char const   )' ',      (char const   )'s',      (char const   )'i',      (char const   )'z', 
        (char const   )'e',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'m', 
        (char const   )'o',      (char const   )'t',      (char const   )'e',      (char const   )' ', 
        (char const   )'f',      (char const   )'i',      (char const   )'l',      (char const   )'e', 
        (char const   )'\000'};
#line 109 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   statushelp[20]  = 
#line 109
  {      (char const   )'s',      (char const   )'h',      (char const   )'o',      (char const   )'w', 
        (char const   )' ',      (char const   )'c',      (char const   )'u',      (char const   )'r', 
        (char const   )'r',      (char const   )'e',      (char const   )'n',      (char const   )'t', 
        (char const   )' ',      (char const   )'s',      (char const   )'t',      (char const   )'a', 
        (char const   )'t',      (char const   )'u',      (char const   )'s',      (char const   )'\000'};
#line 110 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   structhelp[28]  = 
#line 110
  {      (char const   )'s',      (char const   )'e',      (char const   )'t',      (char const   )' ', 
        (char const   )'f',      (char const   )'i',      (char const   )'l',      (char const   )'e', 
        (char const   )' ',      (char const   )'t',      (char const   )'r',      (char const   )'a', 
        (char const   )'n',      (char const   )'s',      (char const   )'f',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'s',      (char const   )'t', 
        (char const   )'r',      (char const   )'u',      (char const   )'c',      (char const   )'t', 
        (char const   )'u',      (char const   )'r',      (char const   )'e',      (char const   )'\000'};
#line 111 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   suniquehelp[38]  = 
#line 111
  {      (char const   )'t',      (char const   )'o',      (char const   )'g',      (char const   )'g', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'s', 
        (char const   )'t',      (char const   )'o',      (char const   )'r',      (char const   )'e', 
        (char const   )' ',      (char const   )'u',      (char const   )'n',      (char const   )'i', 
        (char const   )'q',      (char const   )'u',      (char const   )'e',      (char const   )' ', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'r', 
        (char const   )'e',      (char const   )'m',      (char const   )'o',      (char const   )'t', 
        (char const   )'e',      (char const   )' ',      (char const   )'m',      (char const   )'a', 
        (char const   )'c',      (char const   )'h',      (char const   )'i',      (char const   )'n', 
        (char const   )'e',      (char const   )'\000'};
#line 112 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   systemhelp[24]  = 
#line 112
  {      (char const   )'s',      (char const   )'h',      (char const   )'o',      (char const   )'w', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'m', 
        (char const   )'o',      (char const   )'t',      (char const   )'e',      (char const   )' ', 
        (char const   )'s',      (char const   )'y',      (char const   )'s',      (char const   )'t', 
        (char const   )'e',      (char const   )'m',      (char const   )' ',      (char const   )'t', 
        (char const   )'y',      (char const   )'p',      (char const   )'e',      (char const   )'\000'};
#line 113 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   tenexhelp[29]  = 
#line 113
  {      (char const   )'s',      (char const   )'e',      (char const   )'t',      (char const   )' ', 
        (char const   )'t',      (char const   )'e',      (char const   )'n',      (char const   )'e', 
        (char const   )'x',      (char const   )' ',      (char const   )'f',      (char const   )'i', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'t', 
        (char const   )'r',      (char const   )'a',      (char const   )'n',      (char const   )'s', 
        (char const   )'f',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'\000'};
#line 114 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   tickhelp[46]  = 
#line 114
  {      (char const   )'t',      (char const   )'o',      (char const   )'g',      (char const   )'g', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'p', 
        (char const   )'r',      (char const   )'i',      (char const   )'n',      (char const   )'t', 
        (char const   )'i',      (char const   )'n',      (char const   )'g',      (char const   )' ', 
        (char const   )'b',      (char const   )'y',      (char const   )'t',      (char const   )'e', 
        (char const   )' ',      (char const   )'c',      (char const   )'o',      (char const   )'u', 
        (char const   )'n',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )' ',      (char const   )'d',      (char const   )'u',      (char const   )'r', 
        (char const   )'i',      (char const   )'n',      (char const   )'g',      (char const   )' ', 
        (char const   )'t',      (char const   )'r',      (char const   )'a',      (char const   )'n', 
        (char const   )'s',      (char const   )'f',      (char const   )'e',      (char const   )'r', 
        (char const   )'s',      (char const   )'\000'};
#line 115 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   tracehelp[22]  = 
#line 115
  {      (char const   )'t',      (char const   )'o',      (char const   )'g',      (char const   )'g', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'p', 
        (char const   )'a',      (char const   )'c',      (char const   )'k',      (char const   )'e', 
        (char const   )'t',      (char const   )' ',      (char const   )'t',      (char const   )'r', 
        (char const   )'a',      (char const   )'c',      (char const   )'i',      (char const   )'n', 
        (char const   )'g',      (char const   )'\000'};
#line 116 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   typehelp[23]  = 
#line 116
  {      (char const   )'s',      (char const   )'e',      (char const   )'t',      (char const   )' ', 
        (char const   )'f',      (char const   )'i',      (char const   )'l',      (char const   )'e', 
        (char const   )' ',      (char const   )'t',      (char const   )'r',      (char const   )'a', 
        (char const   )'n',      (char const   )'s',      (char const   )'f',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'t',      (char const   )'y', 
        (char const   )'p',      (char const   )'e',      (char const   )'\000'};
#line 117 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   umaskhelp[31]  = 
#line 117
  {      (char const   )'g',      (char const   )'e',      (char const   )'t',      (char const   )' ', 
        (char const   )'(',      (char const   )'s',      (char const   )'e',      (char const   )'t', 
        (char const   )')',      (char const   )' ',      (char const   )'u',      (char const   )'m', 
        (char const   )'a',      (char const   )'s',      (char const   )'k',      (char const   )' ', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'r', 
        (char const   )'e',      (char const   )'m',      (char const   )'o',      (char const   )'t', 
        (char const   )'e',      (char const   )' ',      (char const   )'s',      (char const   )'i', 
        (char const   )'d',      (char const   )'e',      (char const   )'\000'};
#line 118 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   userhelp[26]  = 
#line 118
  {      (char const   )'s',      (char const   )'e',      (char const   )'n',      (char const   )'d', 
        (char const   )' ',      (char const   )'n',      (char const   )'e',      (char const   )'w', 
        (char const   )' ',      (char const   )'u',      (char const   )'s',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'i',      (char const   )'n', 
        (char const   )'f',      (char const   )'o',      (char const   )'r',      (char const   )'m', 
        (char const   )'a',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )'\000'};
#line 119 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
char const   verbosehelp[20]  = 
#line 119
  {      (char const   )'t',      (char const   )'o',      (char const   )'g',      (char const   )'g', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'v', 
        (char const   )'e',      (char const   )'r',      (char const   )'b',      (char const   )'o', 
        (char const   )'s',      (char const   )'e',      (char const   )' ',      (char const   )'m', 
        (char const   )'o',      (char const   )'d',      (char const   )'e',      (char const   )'\000'};
#line 121 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
struct cmd cmdtab[79]  = 
#line 121
  {      {"!", shellhelp, (char)0, (char)0, (char)0, (void (*)(int  , char ** ))((void *)0),
      (void (*)(void))((void *)0), & shell}, 
        {"$", domachelp, (char)1, (char)0, (char)0, & domacro, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"account", accounthelp, (char)0, (char)1, (char)1, & account, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"append", appendhelp, (char)1, (char)1, (char)1, & put, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"ascii", asciihelp, (char)0, (char)1, (char)1, (void (*)(int  , char ** ))((void *)0),
      & setascii, (void (*)(char const   * ))((void *)0)}, 
        {"bell", beephelp, (char)0, (char)0, (char)0, (void (*)(int  , char ** ))((void *)0),
      & setbell, (void (*)(char const   * ))((void *)0)}, 
        {"binary", binaryhelp, (char)0, (char)1, (char)1, (void (*)(int  , char ** ))((void *)0),
      & setbinary, (void (*)(char const   * ))((void *)0)}, 
        {"bye", quithelp, (char)0, (char)0, (char)0, (void (*)(int  , char ** ))((void *)0),
      & quit, (void (*)(char const   * ))((void *)0)}, 
        {"case", casehelp, (char)0, (char)0, (char)1, (void (*)(int  , char ** ))((void *)0),
      & setcase, (void (*)(char const   * ))((void *)0)}, 
        {"cd", cdhelp, (char)0, (char)1, (char)1, & cd, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"cdup", cduphelp, (char)0, (char)1, (char)1, (void (*)(int  , char ** ))((void *)0),
      & cdup, (void (*)(char const   * ))((void *)0)}, 
        {"chmod", chmodhelp, (char)0, (char)1, (char)1, & do_chmod, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"close", disconhelp, (char)0, (char)1, (char)1, (void (*)(int  , char ** ))((void *)0),
      & disconnect, (void (*)(char const   * ))((void *)0)}, 
        {"cr", crhelp, (char)0, (char)0, (char)0, (void (*)(int  , char ** ))((void *)0),
      & setcr, (void (*)(char const   * ))((void *)0)}, 
        {"delete", deletehelp, (char)0, (char)1, (char)1, & delete_cmd, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"debug", debughelp, (char)0, (char)0, (char)0, & setdebug, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"dir", dirhelp, (char)1, (char)1, (char)1, & ls, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"disconnect", disconhelp, (char)0, (char)1, (char)1, (void (*)(int  , char ** ))((void *)0),
      & disconnect, (void (*)(char const   * ))((void *)0)}, 
        {"exit", quithelp, (char)0, (char)0, (char)0, (void (*)(int  , char ** ))((void *)0),
      & quit, (void (*)(char const   * ))((void *)0)}, 
        {"form", formhelp, (char)0, (char)1, (char)1, (void (*)(int  , char ** ))((void *)0),
      & setform, (void (*)(char const   * ))((void *)0)}, 
        {"get", receivehelp, (char)1, (char)1, (char)1, & get, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"glob", globhelp, (char)0, (char)0, (char)0, (void (*)(int  , char ** ))((void *)0),
      & setglob, (void (*)(char const   * ))((void *)0)}, 
        {"hash", hashhelp, (char)0, (char)0, (char)0, (void (*)(int  , char ** ))((void *)0),
      & sethash, (void (*)(char const   * ))((void *)0)}, 
        {"help", helphelp, (char)0, (char)0, (char)1, & help, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"idle", idlehelp, (char)0, (char)1, (char)1, & idle_cmd, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"image", binaryhelp, (char)0, (char)1, (char)1, (void (*)(int  , char ** ))((void *)0),
      & setbinary, (void (*)(char const   * ))((void *)0)}, 
        {"ipany", ipanyhelp, (char)0, (char)0, (char)0, (void (*)(int  , char ** ))((void *)0),
      & setipany, (void (*)(char const   * ))((void *)0)}, 
        {"ipv4", ipv4help, (char)0, (char)0, (char)0, (void (*)(int  , char ** ))((void *)0),
      & setipv4, (void (*)(char const   * ))((void *)0)}, 
        {"ipv6", ipv6help, (char)0, (char)0, (char)0, (void (*)(int  , char ** ))((void *)0),
      & setipv6, (void (*)(char const   * ))((void *)0)}, 
        {"lcd", lcdhelp, (char)0, (char)0, (char)0, & lcd, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"ls", lshelp, (char)1, (char)1, (char)1, & ls, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"macdef", macdefhelp, (char)0, (char)0, (char)0, & macdef, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"mdelete", mdeletehelp, (char)1, (char)1, (char)1, & mdelete, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"mdir", mdirhelp, (char)1, (char)1, (char)1, & mls, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"mget", mgethelp, (char)1, (char)1, (char)1, & mget, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"mkdir", mkdirhelp, (char)0, (char)1, (char)1, & makedir, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"mls", mlshelp, (char)1, (char)1, (char)1, & mls, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"mode", modehelp, (char)0, (char)1, (char)1, (void (*)(int  , char ** ))((void *)0),
      & setmode, (void (*)(char const   * ))((void *)0)}, 
        {"modtime", modtimehelp, (char)0, (char)1, (char)1, & modtime, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"mput", mputhelp, (char)1, (char)1, (char)1, & mput, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"newer", newerhelp, (char)1, (char)1, (char)1, & newer, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"nmap", nmaphelp, (char)0, (char)0, (char)1, & setnmap, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"nlist", nlisthelp, (char)1, (char)1, (char)1, & ls, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"ntrans", ntranshelp, (char)0, (char)0, (char)1, & setntrans, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"open", connecthelp, (char)0, (char)0, (char)1, & setpeer, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"prompt", prompthelp, (char)0, (char)0, (char)0, (void (*)(int  , char ** ))((void *)0),
      & setprompt, (void (*)(char const   * ))((void *)0)}, 
        {"passive", passivehelp, (char)0, (char)0, (char)0, (void (*)(int  , char ** ))((void *)0),
      & setpassive, (void (*)(char const   * ))((void *)0)}, 
        {"proxy", proxyhelp, (char)0, (char)0, (char)1, & doproxy, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"qc", qchelp, (char)0, (char)0, (char)0, (void (*)(int  , char ** ))((void *)0),
      & setqc, (void (*)(char const   * ))((void *)0)}, 
        {"sendport", porthelp, (char)0, (char)0, (char)0, (void (*)(int  , char ** ))((void *)0),
      & setport, (void (*)(char const   * ))((void *)0)}, 
        {"put", sendhelp, (char)1, (char)1, (char)1, & put, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"pwd", pwdhelp, (char)0, (char)1, (char)1, (void (*)(int  , char ** ))((void *)0),
      & pwd, (void (*)(char const   * ))((void *)0)}, 
        {"quit", quithelp, (char)0, (char)0, (char)0, (void (*)(int  , char ** ))((void *)0),
      & quit, (void (*)(char const   * ))((void *)0)}, 
        {"quote", quotehelp, (char)1, (char)1, (char)1, & quote, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"recv", receivehelp, (char)1, (char)1, (char)1, & get, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"reget", regethelp, (char)1, (char)1, (char)1, & reget, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"rstatus", rmtstatushelp, (char)0, (char)1, (char)1, & rmtstatus, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"rhelp", remotehelp, (char)0, (char)1, (char)1, & rmthelp, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"rename", renamehelp, (char)0, (char)1, (char)1, & renamefile, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"reset", resethelp, (char)0, (char)1, (char)1, (void (*)(int  , char ** ))((void *)0),
      & reset, (void (*)(char const   * ))((void *)0)}, 
        {"restart", restarthelp, (char)1, (char)1, (char)1, & restart, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"rmdir", rmdirhelp, (char)0, (char)1, (char)1, & removedir, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"runique", runiquehelp, (char)0, (char)0, (char)1, (void (*)(int  , char ** ))((void *)0),
      & setrunique, (void (*)(char const   * ))((void *)0)}, 
        {"send", sendhelp, (char)1, (char)1, (char)1, & put, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"site", sitehelp, (char)0, (char)1, (char)1, & site, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"size", sizecmdhelp, (char)1, (char)1, (char)1, & sizecmd, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"status", statushelp, (char)0, (char)0, (char)1, (void (*)(int  , char ** ))((void *)0),
      & status, (void (*)(char const   * ))((void *)0)}, 
        {"struct", structhelp, (char)0, (char)1, (char)1, (void (*)(int  , char ** ))((void *)0),
      & setstruct, (void (*)(char const   * ))((void *)0)}, 
        {"system", systemhelp, (char)0, (char)1, (char)1, (void (*)(int  , char ** ))((void *)0),
      & syst, (void (*)(char const   * ))((void *)0)}, 
        {"sunique", suniquehelp, (char)0, (char)0, (char)1, (void (*)(int  , char ** ))((void *)0),
      & setsunique, (void (*)(char const   * ))((void *)0)}, 
        {"tenex", tenexhelp, (char)0, (char)1, (char)1, (void (*)(int  , char ** ))((void *)0),
      & settenex, (void (*)(char const   * ))((void *)0)}, 
        {"tick", tickhelp, (char)0, (char)0, (char)0, (void (*)(int  , char ** ))((void *)0),
      & settick, (void (*)(char const   * ))((void *)0)}, 
        {"trace", tracehelp, (char)0, (char)0, (char)0, (void (*)(int  , char ** ))((void *)0),
      & settrace, (void (*)(char const   * ))((void *)0)}, 
        {"type", typehelp, (char)0, (char)1, (char)1, & settype, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"user", userhelp, (char)0, (char)1, (char)1, & user, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"umask", umaskhelp, (char)0, (char)1, (char)1, & do_umask, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {"verbose", verbosehelp, (char)0, (char)0, (char)0, (void (*)(int  , char ** ))((void *)0),
      & setverbose, (void (*)(char const   * ))((void *)0)}, 
        {"?", helphelp, (char)0, (char)0, (char)1, & help, (void (*)(void))((void *)0),
      (void (*)(char const   * ))((void *)0)}, 
        {(char const   *)0, (char const   *)0, (char)0, (char)0, (char)0, (void (*)(int  ,
                                                                                 char ** ))0,
      (void (*)(void))0, (void (*)(char const   * ))0}};
#line 203 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmdtab.c"
int NCMDS  =    (int )(sizeof(cmdtab) / sizeof(cmdtab[0]) - 1UL);
#line 37 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
char cmds_rcsid[54]  = 
#line 37 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
  {      (char )'$',      (char )'I',      (char )'d',      (char )':', 
        (char )' ',      (char )'c',      (char )'m',      (char )'d', 
        (char )'s',      (char )'.',      (char )'c',      (char )',', 
        (char )'v',      (char )' ',      (char )'1',      (char )'.', 
        (char )'3',      (char )'3',      (char )' ',      (char )'2', 
        (char )'0',      (char )'0',      (char )'0',      (char )'/', 
        (char )'0',      (char )'7',      (char )'/',      (char )'2', 
        (char )'3',      (char )' ',      (char )'0',      (char )'1', 
        (char )':',      (char )'3',      (char )'6',      (char )':', 
        (char )'5',      (char )'9',      (char )' ',      (char )'d', 
        (char )'h',      (char )'o',      (char )'l',      (char )'l', 
        (char )'a',      (char )'n',      (char )'d',      (char )' ', 
        (char )'E',      (char )'x',      (char )'p',      (char )' ', 
        (char )'$',      (char )'\000'};
#line 102 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 538 "/usr/include/stdio.h"
extern int getchar(void) ;
#line 695
extern int puts(char const   *__s ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 157
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1), __leaf__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 620
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
#line 239 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 511
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 573
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *__path ,
                                                                                              char const   *__arg 
                                                                                              , ...) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 146 "/usr/include/glob.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) glob)(char const   * __restrict  __pattern ,
                                                                           int __flags ,
                                                                           int (*__errfunc)(char const   * ,
                                                                                            int  ) ,
                                                                           glob_t * __restrict  __pglob ) ;
#line 151
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) globfree)(glob_t *__pglob ) ;
#line 171 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/ftp_var.h"
int another(int *pargc , char ***pargv , char const   *prompt ) ;
#line 79 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
static char *mname  ;
#line 81
static char *remglob(char **argv , int doswitch ) ;
#line 82
static int checkglob(FILE *fp , char const   *pattern ) ;
#line 83
static char *dotrans(char *name ) ;
#line 84
static char *domap(char *name ) ;
#line 85
static char *globulize(char *cpp ) ;
#line 86
static int confirm(char const   *cmd , char const   *file ) ;
#line 87
static int getit(int argc , char **argv , int restartit , char const   *modestr ) ;
#line 88
static void quote1(char const   *initial , int argc , char **argv ) ;
#line 89
static void dosyst(void) ;
#line 96 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
static char *pipeprotect(char *name ) 
{ 
  char *nu ;
  int tmp ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  size_t tmp___0 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 99
  tmp = strcmp((char const   *)name, "-");
  }
#line 99
  if (tmp) {
#line 99
    if ((int )*name != 124) {
#line 99
      if ((int )*name != 47) {
#line 100
        return (name);
      }
    }
  }
  {
#line 103
  suppressint ++;
#line 104
  __h = & mainobstack;
#line 104
  __o = __h;
#line 104
  tmp___0 = strlen((char const   *)name);
#line 104
  __len = (int )(tmp___0 + 3UL);
  }
#line 104
  if (__o->chunk_limit - __o->next_free < (long )__len) {
    {
#line 104
    _obstack_newchunk(__o, __len);
    }
  }
#line 104
  __o->next_free += __len;
#line 104
  __o1 = __h;
#line 104
  __value = (void *)__o1->object_base;
#line 104
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 104
    __o1->maybe_empty_object = 1U;
  }
#line 104
  if (sizeof(long ) < sizeof(void *)) {
#line 104
    tmp___1 = __o1->object_base;
  } else {
#line 104
    tmp___1 = (char *)0;
  }
#line 104
  if (sizeof(long ) < sizeof(void *)) {
#line 104
    tmp___2 = __o1->object_base;
  } else {
#line 104
    tmp___2 = (char *)0;
  }
#line 104
  __o1->next_free = tmp___1 + (((__o1->next_free - tmp___2) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 104
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 104
    __o1->next_free = __o1->chunk_limit;
  }
#line 104
  __o1->object_base = __o1->next_free;
#line 104
  nu = (char *)__value;
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    suppressint --;
#line 105
    if (suppressint == 0) {
#line 105
      if (intpending) {
        {
#line 105
        intr(2);
        }
      }
    }
#line 105
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 106
  strcpy((char */* __restrict  */)nu, (char const   */* __restrict  */)".");
  }
#line 107
  if ((int )*name != 47) {
    {
#line 107
    strcat((char */* __restrict  */)nu, (char const   */* __restrict  */)"/");
    }
  }
  {
#line 108
  strcat((char */* __restrict  */)nu, (char const   */* __restrict  */)name);
  }
#line 109
  return (nu);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
static char *pathprotect(char *name ) 
{ 
  int gotdots ;
  int i ;
  int len ;
  size_t tmp ;

  {
  {
#line 118
  gotdots = 0;
#line 121
  tmp = strlen((char const   *)name);
#line 121
  len = (int )(tmp + 1UL);
#line 122
  *(name + (len - 1)) = (char )'/';
#line 129
  i = 0;
  }
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if (! (i < len)) {
#line 129
      goto while_break;
    }
#line 130
    if ((int )*(name + i) == 46) {
#line 130
      if (gotdots >= 0) {
#line 130
        gotdots ++;
      } else {
#line 130
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 131
    if ((int )*(name + i) == 47) {
#line 131
      if (gotdots < 0) {
#line 131
        gotdots = 0;
      } else {
#line 131
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 132
    if ((int )*(name + i) == 47) {
#line 132
      if (gotdots == 2) {
        {
#line 133
        printf((char const   */* __restrict  */)"Warning: embedded .. in %.*s (changing to !!)\n",
               len - 1, name);
#line 135
        *(name + (i - 1)) = (char )'!';
#line 136
        *(name + (i - 2)) = (char )'!';
#line 137
        gotdots = 0;
        }
      } else {
#line 132
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 139
    if ((int )*(name + i) == 47) {
#line 139
      gotdots = 0;
    } else {
#line 140
      gotdots = -1;
    }
#line 129
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  *(name + (len - 1)) = (char)0;
#line 143
  return (name);
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
int another(int *pargc , char ***pargv , char const   *prompt ) 
{ 
  int margc ;
  char **margv ;
  unsigned int len ;
  size_t tmp ;
  int ret ;
  size_t lynesize ;
  ssize_t lynelen ;
  char *lyne ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___0 ;
  char *tmp___1 ;
  struct obstack *__o___0 ;
  void *__obj ;
  char *tmp___2 ;
  struct obstack *__o___1 ;
  int __len___0 ;
  struct obstack *__o___2 ;
  char *tmp___3 ;
  struct obstack *__o___3 ;
  void *__obj___0 ;
  char *tmp___4 ;
  struct obstack *__o___4 ;
  int __len___1 ;
  ssize_t tmp___5 ;
  char *tmp___6 ;
  struct obstack *__o___5 ;
  char *tmp___7 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
  {
#line 159
  tmp = strlen((char const   *)line);
#line 159
  len = (unsigned int )tmp;
#line 166
  suppressint ++;
#line 167
  __h = & mainobstack;
#line 167
  __o = __h;
#line 167
  __len = (int )len;
  }
#line 167
  if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
    {
#line 167
    _obstack_newchunk(__o, __len);
    }
  }
  {
#line 167
  memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)line,
         (size_t )__len);
#line 167
  __o->next_free += __len;
#line 167
  __o1 = __h;
#line 167
  __value = (void *)__o1->object_base;
  }
#line 167
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 167
    __o1->maybe_empty_object = 1U;
  }
#line 167
  if (sizeof(long ) < sizeof(void *)) {
#line 167
    tmp___0 = __o1->object_base;
  } else {
#line 167
    tmp___0 = (char *)0;
  }
#line 167
  if (sizeof(long ) < sizeof(void *)) {
#line 167
    tmp___1 = __o1->object_base;
  } else {
#line 167
    tmp___1 = (char *)0;
  }
#line 167
  __o1->next_free = tmp___0 + (((__o1->next_free - tmp___1) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 167
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 167
    __o1->next_free = __o1->chunk_limit;
  }
#line 167
  __o1->object_base = __o1->next_free;
#line 167
  lyne = (char *)__value;
#line 168
  __o___0 = & lineobstack;
#line 168
  __obj = (void *)line;
#line 168
  if ((unsigned long )__obj > (unsigned long )((void *)__o___0->chunk)) {
#line 168
    if ((unsigned long )__obj < (unsigned long )((void *)__o___0->chunk_limit)) {
#line 168
      tmp___2 = (char *)__obj;
#line 168
      __o___0->object_base = tmp___2;
#line 168
      __o___0->next_free = tmp___2;
    } else {
      {
#line 168
      obstack_free(__o___0, __obj);
      }
    }
  } else {
    {
#line 168
    obstack_free(__o___0, __obj);
    }
  }
#line 169
  __o___1 = & lineobstack;
#line 169
  __len___0 = (int )len;
#line 169
  if ((unsigned long )(__o___1->next_free + __len___0) > (unsigned long )__o___1->chunk_limit) {
    {
#line 169
    _obstack_newchunk(__o___1, __len___0);
    }
  }
  {
#line 169
  memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)lyne,
         (size_t )__len___0);
#line 169
  __o___1->next_free += __len___0;
#line 170
  __o___2 = & lineobstack;
  }
#line 170
  if ((unsigned long )(__o___2->next_free + 1) > (unsigned long )__o___2->chunk_limit) {
    {
#line 170
    _obstack_newchunk(__o___2, 1);
    }
  }
#line 170
  tmp___3 = __o___2->next_free;
#line 170
  (__o___2->next_free) ++;
#line 170
  *tmp___3 = (char )' ';
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 171
    suppressint --;
#line 171
    if (suppressint == 0) {
#line 171
      if (intpending) {
        {
#line 171
        intr(2);
        }
      }
    }
#line 171
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 172
  __o___3 = & mainobstack;
#line 172
  __obj___0 = (void *)lyne;
#line 172
  if ((unsigned long )__obj___0 > (unsigned long )((void *)__o___3->chunk)) {
#line 172
    if ((unsigned long )__obj___0 < (unsigned long )((void *)__o___3->chunk_limit)) {
#line 172
      tmp___4 = (char *)__obj___0;
#line 172
      __o___3->object_base = tmp___4;
#line 172
      __o___3->next_free = tmp___4;
    } else {
      {
#line 172
      obstack_free(__o___3, __obj___0);
      }
    }
  } else {
    {
#line 172
    obstack_free(__o___3, __obj___0);
    }
  }
  {
#line 174
  printf((char const   */* __restrict  */)"(%s) ", prompt);
#line 175
  lyne = (char *)((void *)0);
#line 176
  lynesize = (size_t )0;
#line 177
  suppressint ++;
#line 178
  lynelen = getline((char **/* __restrict  */)(& lyne), (size_t */* __restrict  */)(& lynesize),
                    (FILE */* __restrict  */)stdin);
  }
#line 178
  if (lynelen == -1L) {
#line 179
    if (lyne) {
      {
#line 180
      free((void *)lyne);
      }
    }
    {
#line 181
    suppressint = 0;
#line 182
    intr(0);
    }
  }
#line 184
  if (lynelen > 0L) {
#line 185
    __o___4 = & lineobstack;
#line 185
    if ((int )*(lyne + (lynelen - 1L)) == 10) {
#line 185
      tmp___5 = lynelen - 1L;
    } else {
#line 185
      tmp___5 = lynelen;
    }
#line 185
    __len___1 = (int )tmp___5;
#line 185
    if ((unsigned long )((__o___4->next_free + __len___1) + 1) > (unsigned long )__o___4->chunk_limit) {
      {
#line 185
      _obstack_newchunk(__o___4, __len___1 + 1);
      }
    }
    {
#line 185
    memcpy((void */* __restrict  */)__o___4->next_free, (void const   */* __restrict  */)lyne,
           (size_t )__len___1);
#line 185
    __o___4->next_free += __len___1;
#line 185
    tmp___6 = __o___4->next_free;
#line 185
    (__o___4->next_free) ++;
#line 185
    *tmp___6 = (char)0;
    }
  } else {
#line 188
    __o___5 = & lineobstack;
#line 188
    if ((unsigned long )(__o___5->next_free + 1) > (unsigned long )__o___5->chunk_limit) {
      {
#line 188
      _obstack_newchunk(__o___5, 1);
      }
    }
#line 188
    tmp___7 = __o___5->next_free;
#line 188
    (__o___5->next_free) ++;
#line 188
    *tmp___7 = (char )'\000';
  }
  {
#line 190
  free((void *)lyne);
  }
  {
#line 191
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 191
    suppressint --;
#line 191
    if (suppressint == 0) {
#line 191
      if (intpending) {
        {
#line 191
        intr(2);
        }
      }
    }
#line 191
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 192
  __o1___0 = & lineobstack;
#line 192
  __value___0 = (void *)__o1___0->object_base;
#line 192
  if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 192
    __o1___0->maybe_empty_object = 1U;
  }
#line 192
  if (sizeof(long ) < sizeof(void *)) {
#line 192
    tmp___8 = __o1___0->object_base;
  } else {
#line 192
    tmp___8 = (char *)0;
  }
#line 192
  if (sizeof(long ) < sizeof(void *)) {
#line 192
    tmp___9 = __o1___0->object_base;
  } else {
#line 192
    tmp___9 = (char *)0;
  }
#line 192
  __o1___0->next_free = tmp___8 + (((__o1___0->next_free - tmp___9) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 192
  if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 192
    __o1___0->next_free = __o1___0->chunk_limit;
  }
  {
#line 192
  __o1___0->object_base = __o1___0->next_free;
#line 192
  line = (char *)__value___0;
#line 193
  margv = makeargv(& margc, (char **)((void *)0));
#line 194
  ret = margc > *pargc;
#line 195
  *pargc = margc;
#line 196
  *pargv = margv;
  }
#line 197
  return (ret);
}
}
#line 204 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void setpeer(int argc , char **argv ) 
{ 
  char *host ;
  unsigned short port ;
  int tmp ;

  {
#line 210
  if (connected) {
    {
#line 211
    printf((char const   */* __restrict  */)"Already connected to %s, use close first.\n",
           hostname);
#line 213
    code = -1;
    }
#line 214
    return;
  }
#line 216
  if (argc < 2) {
    {
#line 217
    another(& argc, & argv, "to");
    }
  }
#line 218
  if (argc < 2) {
    {
#line 219
    printf((char const   */* __restrict  */)"usage: %s host-name [port]\n", *(argv + 0));
#line 220
    code = -1;
    }
#line 221
    return;
  } else
#line 218
  if (argc > 3) {
    {
#line 219
    printf((char const   */* __restrict  */)"usage: %s host-name [port]\n", *(argv + 0));
#line 220
    code = -1;
    }
#line 221
    return;
  }
#line 223
  port = (unsigned short )ftp_port;
#line 224
  if (argc > 2) {
    {
#line 225
    tmp = atoi((char const   *)*(argv + 2));
#line 225
    port = (unsigned short )tmp;
    }
#line 226
    if ((int )port < 1) {
      {
#line 227
      printf((char const   */* __restrict  */)"%s: bad port number-- %s\n", *(argv + 1),
             *(argv + 2));
#line 228
      printf((char const   */* __restrict  */)"usage: %s host-name [port]\n", *(argv + 0));
#line 229
      code = -1;
      }
#line 230
      return;
    }
    {
#line 232
    port = htons(port);
    }
  }
  {
#line 234
  host = hookup(*(argv + 1), (int )port);
  }
#line 235
  if (host) {
    {
#line 236
    connected = 1;
#line 240
    strcpy((char */* __restrict  */)(typename), (char const   */* __restrict  */)"ascii");
#line 240
    type = 1;
#line 241
    curtype = 1;
#line 242
    strcpy((char */* __restrict  */)(formname), (char const   */* __restrict  */)"non-print");
#line 242
    form = 1;
#line 243
    strcpy((char */* __restrict  */)(modename), (char const   */* __restrict  */)"stream");
#line 243
    mode = 1;
#line 244
    strcpy((char */* __restrict  */)(structname), (char const   */* __restrict  */)"file");
#line 244
    stru = 1;
#line 245
    strcpy((char */* __restrict  */)(bytename), (char const   */* __restrict  */)"8");
#line 245
    bytesize = 8;
    }
#line 246
    if (autologin) {
      {
#line 247
      dologin((char const   *)*(argv + 1));
#line 248
      dosyst();
      }
    }
  }
#line 251
  return;
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
struct types types[6]  = {      {"ascii", "A", 1, (char const   *)((void *)0)}, 
        {"binary", "I", 3, (char const   *)((void *)0)}, 
        {"image", "I", 3, (char const   *)((void *)0)}, 
        {"ebcdic", "E", 2, (char const   *)((void *)0)}, 
        {"tenex", "L", 4, (char const   *)(bytename)}, 
        {(char const   *)((void *)0), (char const   *)((void *)0), 0, (char const   *)((void *)0)}};
#line 270 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
static void do_settype(char const   *thetype ) 
{ 
  struct types *p ;
  int comret ;
  int tmp ;

  {
#line 277
  p = types;
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 277
    if (! p->t_name) {
#line 277
      goto while_break;
    }
    {
#line 278
    tmp = strcmp(thetype, p->t_name);
    }
#line 278
    if (tmp == 0) {
#line 279
      goto while_break;
    }
#line 277
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  if ((unsigned long )p->t_name == (unsigned long )((char const   *)0)) {
    {
#line 281
    printf((char const   */* __restrict  */)"%s: unknown mode\n", thetype);
#line 282
    code = -1;
    }
#line 283
    return;
  }
#line 285
  if ((unsigned long )p->t_arg != (unsigned long )((void *)0)) {
#line 285
    if ((int const   )*(p->t_arg) != 0) {
      {
#line 286
      comret = command("TYPE %s %s", p->t_mode, p->t_arg);
      }
    } else {
      {
#line 288
      comret = command("TYPE %s", p->t_mode);
      }
    }
  } else {
    {
#line 288
    comret = command("TYPE %s", p->t_mode);
    }
  }
#line 289
  if (comret == 2) {
    {
#line 290
    strcpy((char */* __restrict  */)(typename), (char const   */* __restrict  */)p->t_name);
#line 291
    type = p->t_type;
#line 291
    curtype = type;
    }
  }
#line 293
  return;
}
}
#line 295 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void settype(int argc , char **argv ) 
{ 
  struct types *p ;
  char const   *sep ;

  {
#line 299
  if (argc > 2) {
    {
#line 302
    printf((char const   */* __restrict  */)"usage: %s [", *(argv + 0));
#line 303
    sep = " ";
#line 304
    p = types;
    }
    {
#line 304
    while (1) {
      while_continue: /* CIL Label */ ;
#line 304
      if (! p->t_name) {
#line 304
        goto while_break;
      }
      {
#line 305
      printf((char const   */* __restrict  */)"%s%s", sep, p->t_name);
#line 306
      sep = " | ";
#line 304
      p ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 308
    printf((char const   */* __restrict  */)" ]\n");
#line 309
    code = -1;
    }
#line 310
    return;
  }
#line 312
  if (argc < 2) {
    {
#line 313
    printf((char const   */* __restrict  */)"Using %s mode to transfer files.\n",
           typename);
#line 314
    code = 0;
    }
#line 315
    return;
  }
  {
#line 317
  do_settype((char const   *)*(argv + 1));
  }
#line 318
  return;
}
}
#line 325 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void changetype(int newtype , int show ) 
{ 
  register struct types *p ;
  int comret ;
  int oldverbose ;
  int oldtick ;

  {
#line 329
  oldverbose = verbose;
#line 330
  oldtick = tick;
#line 332
  if (newtype == 0) {
#line 333
    newtype = 3;
  }
#line 334
  if (newtype == curtype) {
#line 335
    return;
  }
#line 336
  if (debug == 0) {
#line 336
    if (show == 0) {
#line 337
      verbose = 0;
    }
  }
#line 338
  tick = 0;
#line 339
  p = types;
  {
#line 339
  while (1) {
    while_continue: /* CIL Label */ ;
#line 339
    if (! p->t_name) {
#line 339
      goto while_break;
    }
#line 340
    if (newtype == p->t_type) {
#line 341
      goto while_break;
    }
#line 339
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  if ((unsigned long )p->t_name == (unsigned long )((char const   *)0)) {
    {
#line 343
    printf((char const   */* __restrict  */)"ftp: internal error: unknown type %d\n",
           newtype);
    }
#line 344
    return;
  }
#line 346
  if (newtype == 4) {
#line 346
    if ((int )bytename[0] != 0) {
      {
#line 347
      comret = command("TYPE %s %s", p->t_mode, bytename);
      }
    } else {
      {
#line 349
      comret = command("TYPE %s", p->t_mode);
      }
    }
  } else {
    {
#line 349
    comret = command("TYPE %s", p->t_mode);
    }
  }
#line 350
  if (comret == 2) {
#line 351
    curtype = newtype;
  }
#line 352
  verbose = oldverbose;
#line 353
  tick = oldtick;
#line 354
  return;
}
}
#line 360 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void setbinary(void) 
{ 


  {
  {
#line 363
  do_settype("binary");
  }
#line 364
  return;
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void setascii(void) 
{ 


  {
  {
#line 373
  do_settype("ascii");
  }
#line 374
  return;
}
}
#line 380 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void settenex(void) 
{ 


  {
  {
#line 383
  do_settype("tenex");
  }
#line 384
  return;
}
}
#line 390 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void setmode(void) 
{ 


  {
  {
#line 393
  printf((char const   */* __restrict  */)"We only support %s mode, sorry.\n", modename);
#line 394
  code = -1;
  }
#line 395
  return;
}
}
#line 401 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void setform(void) 
{ 


  {
  {
#line 404
  printf((char const   */* __restrict  */)"We only support %s format, sorry.\n", formname);
#line 405
  code = -1;
  }
#line 406
  return;
}
}
#line 411 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void setstruct(void) 
{ 


  {
  {
#line 414
  printf((char const   */* __restrict  */)"We only support %s structure, sorry.\n",
         structname);
#line 415
  code = -1;
  }
#line 416
  return;
}
}
#line 421 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void put(int argc , char **argv ) 
{ 
  char const   *cmd ;
  int loc ;
  char *oldargv1 ;
  char *oldargv2 ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
#line 425
  loc = 0;
#line 428
  if (argc == 2) {
#line 429
    argc ++;
#line 430
    *(argv + 2) = *(argv + 1);
#line 431
    loc ++;
  }
#line 433
  if (argc < 2) {
    {
#line 433
    tmp = another(& argc, & argv, "local-file");
    }
#line 433
    if (! tmp) {
#line 434
      goto usage;
    }
  }
#line 435
  if (argc < 3) {
    {
#line 435
    tmp___0 = another(& argc, & argv, "remote-file");
    }
#line 435
    if (! tmp___0) {
      usage: 
      {
#line 437
      printf((char const   */* __restrict  */)"usage: %s local-file remote-file\n",
             *(argv + 0));
#line 438
      code = -1;
      }
#line 439
      return;
    }
  }
  {
#line 441
  oldargv1 = *(argv + 1);
#line 442
  oldargv2 = *(argv + 2);
#line 443
  *(argv + 1) = globulize(*(argv + 1));
  }
#line 444
  if (! *(argv + 1)) {
#line 445
    code = -1;
#line 446
    return;
  }
#line 452
  if ((unsigned long )*(argv + 1) != (unsigned long )oldargv1) {
#line 452
    if ((unsigned long )*(argv + 2) == (unsigned long )oldargv1) {
#line 453
      *(argv + 2) = *(argv + 1);
    }
  }
#line 455
  if ((int )*(*(argv + 0) + 0) == 97) {
#line 455
    cmd = "APPE";
  } else {
#line 455
    if (sunique) {
#line 455
      tmp___1 = "STOU";
    } else {
#line 455
      tmp___1 = "STOR";
    }
#line 455
    cmd = tmp___1;
  }
#line 456
  if (loc) {
#line 456
    if (ntflag) {
      {
#line 457
      *(argv + 2) = dotrans(*(argv + 2));
      }
    }
  }
#line 459
  if (loc) {
#line 459
    if (mapflag) {
      {
#line 460
      *(argv + 2) = domap(*(argv + 2));
      }
    }
  }
#line 462
  if ((unsigned long )*(argv + 1) != (unsigned long )oldargv1) {
#line 462
    tmp___2 = 1;
  } else
#line 462
  if ((unsigned long )*(argv + 2) != (unsigned long )oldargv2) {
#line 462
    tmp___2 = 1;
  } else {
#line 462
    tmp___2 = 0;
  }
  {
#line 462
  sendrequest(cmd, *(argv + 1), *(argv + 2), tmp___2);
  }
#line 464
  return;
}
}
#line 466
void mabort(int ignore ) ;
#line 471 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void mput(int argc , char **argv ) 
{ 
  register int i ;
  int ointer ;
  char *tp ;
  glob_t pglob ;
  int volatile   glob_called ;
  sigjmp_buf jmploc ;
  sigjmp_buf * volatile  oldtoplevel ;
  int globerr ;
  int tmp ;
  int tmp___0 ;
  char *cp ;
  char *tp2 ;
  char tmpbuf[4096] ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  char tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char **cpp ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  char const   *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 478
  glob_called = (int volatile   )0;
#line 483
  if (argc < 2) {
    {
#line 483
    tmp = another(& argc, & argv, "local-files");
    }
#line 483
    if (! tmp) {
      {
#line 484
      printf((char const   */* __restrict  */)"usage: %s local-files\n", *(argv + 0));
#line 485
      code = -1;
      }
#line 486
      return;
    }
  }
  {
#line 488
  mname = *(argv + 0);
#line 489
  mflag = 1;
#line 490
  oldtoplevel = (sigjmp_buf */* volatile  */)toplevel;
#line 491
  tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(jmploc), 1);
  }
#line 491
  if (tmp___0) {
#line 492
    if (glob_called) {
      {
#line 493
      globfree(& pglob);
#line 494
      glob_called = (int volatile   )0;
      }
    }
    {
#line 496
    mabort(2);
    }
  } else {
#line 498
    toplevel = & jmploc;
  }
#line 500
  if (proxy) {
    {
#line 503
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 503
      cp = remglob(argv, 0);
      }
#line 503
      if (! ((unsigned long )cp != (unsigned long )((void *)0))) {
#line 503
        goto while_break;
      }
#line 504
      if ((int )*cp == 0) {
#line 505
        mflag = 0;
#line 506
        goto while_continue;
      }
#line 508
      if (mflag) {
        {
#line 508
        tmp___7 = confirm((char const   *)*(argv + 0), (char const   *)cp);
        }
#line 508
        if (tmp___7) {
#line 509
          tp = cp;
#line 510
          if (mcase) {
            {
#line 511
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 511
              if (*tp) {
                {
#line 511
                tmp___1 = __ctype_b_loc();
                }
#line 511
                if ((int const   )*(*tmp___1 + (int )*tp) & 512) {
#line 511
                  goto while_break___0;
                }
              } else {
#line 511
                goto while_break___0;
              }
#line 512
              tp ++;
            }
            while_break___0: /* CIL Label */ ;
            }
#line 514
            if (! *tp) {
#line 515
              tp = cp;
#line 516
              tp2 = tmpbuf;
              {
#line 517
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 517
                tmp___3 = *tp;
#line 517
                *tp2 = tmp___3;
#line 517
                if (! ((int )tmp___3 != 0)) {
#line 517
                  goto while_break___1;
                }
                {
#line 518
                tmp___2 = __ctype_b_loc();
                }
#line 518
                if ((int const   )*(*tmp___2 + (int )*tp2) & 256) {
#line 519
                  *tp2 = (char )((97 + (int )*tp2) - 65);
                }
#line 521
                tp ++;
#line 522
                tp2 ++;
              }
              while_break___1: /* CIL Label */ ;
              }
            }
#line 525
            tp = tmpbuf;
          }
#line 527
          if (ntflag) {
            {
#line 528
            tp = dotrans(tp);
            }
          }
#line 530
          if (mapflag) {
            {
#line 531
            tp = domap(tp);
            }
          }
#line 533
          if ((unsigned long )cp != (unsigned long )tp) {
#line 533
            tmp___4 = 1;
          } else
#line 533
          if (! interactive) {
#line 533
            tmp___4 = 1;
          } else {
#line 533
            tmp___4 = 0;
          }
#line 533
          if (sunique) {
#line 533
            tmp___5 = "STOU";
          } else {
#line 533
            tmp___5 = "STOR";
          }
          {
#line 533
          sendrequest(tmp___5, cp, tp, tmp___4);
          }
#line 535
          if (! mflag) {
#line 535
            if (fromatty) {
              {
#line 536
              ointer = interactive;
#line 537
              interactive = 1;
#line 538
              tmp___6 = confirm("Continue with", "mput");
              }
#line 538
              if (tmp___6) {
#line 539
                mflag ++;
              }
#line 541
              interactive = ointer;
            }
          }
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 545
    goto out;
  }
#line 547
  i = 1;
  {
#line 547
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 547
    if (! (i < argc)) {
#line 547
      goto while_break___2;
    }
#line 550
    if (! doglob) {
#line 551
      if (mflag) {
        {
#line 551
        tmp___13 = confirm((char const   *)*(argv + 0), (char const   *)*(argv + i));
        }
#line 551
        if (tmp___13) {
#line 552
          if (ntflag) {
            {
#line 552
            tmp___8 = dotrans(*(argv + i));
#line 552
            tp = tmp___8;
            }
          } else {
#line 552
            tp = *(argv + i);
          }
#line 553
          if (mapflag) {
            {
#line 553
            tmp___9 = domap(tp);
#line 553
            tp = tmp___9;
            }
          } else {
#line 553
            tp = tp;
          }
#line 554
          if ((unsigned long )tp != (unsigned long )*(argv + i)) {
#line 554
            tmp___10 = 1;
          } else
#line 554
          if (! interactive) {
#line 554
            tmp___10 = 1;
          } else {
#line 554
            tmp___10 = 0;
          }
#line 554
          if (sunique) {
#line 554
            tmp___11 = "STOU";
          } else {
#line 554
            tmp___11 = "STOR";
          }
          {
#line 554
          sendrequest(tmp___11, *(argv + i), tp, tmp___10);
          }
#line 556
          if (! mflag) {
#line 556
            if (fromatty) {
              {
#line 557
              ointer = interactive;
#line 558
              interactive = 1;
#line 559
              tmp___12 = confirm("Continue with", "mput");
              }
#line 559
              if (tmp___12) {
#line 560
                mflag ++;
              }
#line 562
              interactive = ointer;
            }
          }
        }
      }
#line 565
      goto __Cont;
    }
    {
#line 567
    suppressint ++;
#line 568
    globerr = glob((char const   */* __restrict  */)*(argv + i), ((((1 << 10) | 1) | (1 << 4)) | (1 << 6)) | (1 << 12),
                   (int (*)(char const   * , int  ))0, (glob_t */* __restrict  */)(& pglob));
    }
    {
#line 571
    if (globerr == 1) {
#line 571
      goto case_1;
    }
#line 574
    if (globerr == 2) {
#line 574
      goto case_2;
    }
#line 570
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 572
    tmp___14 = __errno_location();
#line 572
    *tmp___14 = 12;
    }
#line 573
    goto err;
    case_2: /* CIL Label */ 
    {
#line 575
    globfree(& pglob);
    }
    err: 
    {
#line 577
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 577
      suppressint --;
#line 577
      if (suppressint == 0) {
#line 577
        if (intpending) {
          {
#line 577
          intr(2);
          }
        }
      }
#line 577
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 578
    tmp___15 = __errno_location();
#line 578
    tmp___16 = strerror(*tmp___15);
#line 578
    puts((char const   *)tmp___16);
    }
#line 579
    goto __Cont;
    switch_break: /* CIL Label */ ;
    }
#line 581
    glob_called = (int volatile   )1;
    {
#line 582
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 582
      suppressint --;
#line 582
      if (suppressint == 0) {
#line 582
        if (intpending) {
          {
#line 582
          intr(2);
          }
        }
      }
#line 582
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 583
    cpp = pglob.gl_pathv;
    {
#line 583
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 583
      if (! *cpp) {
#line 583
        goto while_break___5;
      }
#line 584
      if (mflag) {
        {
#line 584
        tmp___22 = confirm((char const   *)*(argv + 0), (char const   *)*cpp);
        }
#line 584
        if (tmp___22) {
#line 585
          if (ntflag) {
            {
#line 585
            tmp___17 = dotrans(*cpp);
#line 585
            tp = tmp___17;
            }
          } else {
#line 585
            tp = *cpp;
          }
#line 586
          if (mapflag) {
            {
#line 586
            tmp___18 = domap(tp);
#line 586
            tp = tmp___18;
            }
          } else {
#line 586
            tp = tp;
          }
#line 587
          if ((unsigned long )*cpp != (unsigned long )tp) {
#line 587
            tmp___19 = 1;
          } else
#line 587
          if (! interactive) {
#line 587
            tmp___19 = 1;
          } else {
#line 587
            tmp___19 = 0;
          }
#line 587
          if (sunique) {
#line 587
            tmp___20 = "STOU";
          } else {
#line 587
            tmp___20 = "STOR";
          }
          {
#line 587
          sendrequest(tmp___20, *cpp, tp, tmp___19);
          }
#line 589
          if (! mflag) {
#line 589
            if (fromatty) {
              {
#line 590
              ointer = interactive;
#line 591
              interactive = 1;
#line 592
              tmp___21 = confirm("Continue with", "mput");
              }
#line 592
              if (tmp___21) {
#line 593
                mflag ++;
              }
#line 595
              interactive = ointer;
            }
          }
        }
      }
#line 583
      cpp ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 599
    suppressint ++;
#line 600
    globfree(& pglob);
#line 601
    glob_called = (int volatile   )0;
    }
    {
#line 602
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 602
      suppressint --;
#line 602
      if (suppressint == 0) {
#line 602
        if (intpending) {
          {
#line 602
          intr(2);
          }
        }
      }
#line 602
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 547
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  out: 
#line 605
  toplevel = (sigjmp_buf *)oldtoplevel;
#line 606
  mflag = 0;
#line 607
  return;
}
}
#line 609 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void reget(int argc , char **argv ) 
{ 


  {
  {
#line 612
  getit(argc, argv, 1, "r+w");
  }
#line 613
  return;
}
}
#line 615 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void get(int argc , char **argv ) 
{ 
  char const   *tmp ;

  {
#line 618
  if (restart_point) {
#line 618
    tmp = "r+w";
  } else {
#line 618
    tmp = "w";
  }
  {
#line 618
  getit(argc, argv, 0, tmp);
  }
#line 619
  return;
}
}
#line 624 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
static int getit(int argc , char **argv , int restartit , char const   *modestr ) 
{ 
  int loc ;
  char *oldargv1 ;
  char *oldargv2 ;
  int tmp ;
  int tmp___0 ;
  char *tp ;
  char *tp2 ;
  char tmpbuf[4096] ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  char tmp___3 ;
  struct stat stbuf ;
  int ret ;
  int *tmp___4 ;
  char *tmp___5 ;
  int overbose ;
  int yy ;
  int mo ;
  int day ;
  int hour ;
  int min ;
  int sec ;
  struct tm *tm ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 627
  loc = 0;
#line 630
  if (argc == 2) {
    {
#line 631
    argc ++;
#line 636
    *(argv + 2) = pipeprotect(*(argv + 1));
#line 637
    loc ++;
    }
  }
#line 639
  if (argc < 2) {
    {
#line 639
    tmp = another(& argc, & argv, "remote-file");
    }
#line 639
    if (! tmp) {
#line 640
      goto usage;
    }
  }
#line 641
  if (argc < 3) {
    {
#line 641
    tmp___0 = another(& argc, & argv, "local-file");
    }
#line 641
    if (! tmp___0) {
      usage: 
      {
#line 643
      printf((char const   */* __restrict  */)"usage: %s remote-file [ local-file ]\n",
             *(argv + 0));
#line 644
      code = -1;
      }
#line 645
      return (0);
    }
  }
  {
#line 647
  oldargv1 = *(argv + 1);
#line 648
  oldargv2 = *(argv + 2);
#line 649
  *(argv + 2) = globulize(*(argv + 2));
  }
#line 650
  if (! *(argv + 2)) {
#line 651
    code = -1;
#line 652
    return (0);
  }
#line 654
  if (loc) {
#line 654
    if (mcase) {
#line 655
      tp = *(argv + 1);
      {
#line 657
      while (1) {
        while_continue: /* CIL Label */ ;
#line 657
        if (*tp) {
          {
#line 657
          tmp___1 = __ctype_b_loc();
          }
#line 657
          if ((int const   )*(*tmp___1 + (int )*tp) & 512) {
#line 657
            goto while_break;
          }
        } else {
#line 657
          goto while_break;
        }
#line 658
        tp ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 660
      if (! *tp) {
#line 661
        tp = *(argv + 2);
#line 662
        tp2 = tmpbuf;
        {
#line 663
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 663
          tmp___3 = *tp;
#line 663
          *tp2 = tmp___3;
#line 663
          if (! ((int )tmp___3 != 0)) {
#line 663
            goto while_break___0;
          }
          {
#line 664
          tmp___2 = __ctype_b_loc();
          }
#line 664
          if ((int const   )*(*tmp___2 + (int )*tp2) & 256) {
#line 665
            *tp2 = (char )((97 + (int )*tp2) - 65);
          }
#line 667
          tp ++;
#line 668
          tp2 ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 670
        *(argv + 2) = tmpbuf;
      }
    }
  }
#line 673
  if (loc) {
#line 673
    if (ntflag) {
      {
#line 674
      *(argv + 2) = dotrans(*(argv + 2));
      }
    }
  }
#line 675
  if (loc) {
#line 675
    if (mapflag) {
      {
#line 676
      *(argv + 2) = domap(*(argv + 2));
      }
    }
  }
#line 677
  if (restartit) {
    {
#line 681
    ret = stat((char const   */* __restrict  */)*(argv + 2), (struct stat */* __restrict  */)(& stbuf));
    }
#line 682
    if (restartit == 1) {
#line 683
      if (ret < 0) {
        {
#line 684
        tmp___4 = __errno_location();
#line 684
        tmp___5 = strerror(*tmp___4);
#line 684
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"local: %s: %s\n",
                *(argv + 2), tmp___5);
        }
#line 686
        return (0);
      }
#line 688
      restart_point = stbuf.st_size;
    } else
#line 690
    if (ret == 0) {
#line 693
      overbose = verbose;
#line 694
      if (debug == 0) {
#line 695
        verbose = -1;
      }
      {
#line 696
      tmp___6 = command("MDTM %s", *(argv + 1));
      }
#line 696
      if (tmp___6 == 2) {
        {
#line 699
        verbose = overbose;
#line 700
        sscanf((char const   */* __restrict  */)(reply_string), (char const   */* __restrict  */)"%*s %04d%02d%02d%02d%02d%02d",
               & yy, & mo, & day, & hour, & min, & sec);
#line 703
        tm = gmtime((time_t const   *)(& stbuf.st_mtim.tv_sec));
#line 704
        (tm->tm_mon) ++;
        }
#line 710
        if (tm->tm_year + 1900 > yy) {
#line 711
          return (1);
        }
#line 712
        if (tm->tm_year + 1900 == yy) {
#line 713
          if (tm->tm_mon > mo) {
#line 714
            return (1);
          }
#line 715
          if (tm->tm_mon == mo) {
#line 716
            if (tm->tm_mday > day) {
#line 717
              return (1);
            }
#line 718
            if (tm->tm_mday == day) {
#line 719
              if (tm->tm_hour > hour) {
#line 720
                return (1);
              }
#line 721
              if (tm->tm_hour == hour) {
#line 722
                if (tm->tm_min > min) {
#line 723
                  return (1);
                }
#line 724
                if (tm->tm_min == min) {
#line 725
                  if (tm->tm_sec > sec) {
#line 726
                    return (1);
                  }
                }
              }
            }
          }
        }
      } else {
        {
#line 733
        printf((char const   */* __restrict  */)"%s\n", reply_string);
#line 734
        verbose = overbose;
        }
#line 735
        return (0);
      }
    }
  }
#line 741
  if ((unsigned long )*(argv + 1) != (unsigned long )oldargv1) {
#line 741
    tmp___7 = 1;
  } else
#line 741
  if ((unsigned long )*(argv + 2) != (unsigned long )oldargv2) {
#line 741
    tmp___7 = 1;
  } else {
#line 741
    tmp___7 = 0;
  }
  {
#line 741
  recvrequest("RETR", *(argv + 2), *(argv + 1), modestr, tmp___7);
#line 743
  restart_point = (off_t )0;
  }
#line 744
  return (0);
}
}
#line 747 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void mabort(int ignore ) 
{ 
  int ointer ;
  int tmp ;

  {
  {
#line 754
  printf((char const   */* __restrict  */)"\n");
#line 755
  fflush(stdout);
  }
#line 756
  if (mflag) {
#line 756
    if (fromatty) {
      {
#line 757
      ointer = interactive;
#line 758
      interactive = 1;
#line 759
      tmp = confirm("Continue with", (char const   *)mname);
      }
#line 759
      if (tmp) {
#line 760
        interactive = ointer;
#line 761
        return;
      }
#line 763
      interactive = ointer;
    }
  }
#line 765
  mflag = 0;
#line 766
  return;
}
}
#line 771 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void mget(int argc , char **argv ) 
{ 
  int ointer ;
  char *cp ;
  char *tp ;
  char *tp2 ;
  char tmpbuf[4096] ;
  sigjmp_buf jmploc ;
  sigjmp_buf * volatile  oldtoplevel ;
  int tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  char tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 779
  if (argc < 2) {
    {
#line 779
    tmp = another(& argc, & argv, "remote-files");
    }
#line 779
    if (! tmp) {
      {
#line 780
      printf((char const   */* __restrict  */)"usage: %s remote-files\n", *(argv + 0));
#line 781
      code = -1;
      }
#line 782
      return;
    }
  }
  {
#line 784
  mname = *(argv + 0);
#line 785
  mflag = 1;
#line 786
  oldtoplevel = (sigjmp_buf */* volatile  */)toplevel;
#line 787
  tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(jmploc), 1);
  }
#line 787
  if (tmp___0) {
    {
#line 788
    mabort(2);
    }
  } else {
#line 790
    toplevel = & jmploc;
  }
  {
#line 792
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 792
    cp = remglob(argv, proxy);
    }
#line 792
    if (! ((unsigned long )cp != (unsigned long )((void *)0))) {
#line 792
      goto while_break;
    }
#line 793
    if ((int )*cp == 0) {
#line 794
      mflag = 0;
#line 795
      goto while_continue;
    }
#line 797
    if (mflag) {
      {
#line 797
      tmp___6 = confirm((char const   *)*(argv + 0), (char const   *)cp);
      }
#line 797
      if (tmp___6) {
#line 798
        tp = cp;
#line 799
        if (mcase) {
          {
#line 800
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 800
            if (*tp) {
              {
#line 800
              tmp___1 = __ctype_b_loc();
              }
#line 800
              if ((int const   )*(*tmp___1 + (int )*tp) & 512) {
#line 800
                goto while_break___0;
              }
            } else {
#line 800
              goto while_break___0;
            }
#line 801
            tp ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 803
          if (! *tp) {
#line 804
            tp = cp;
#line 805
            tp2 = tmpbuf;
            {
#line 806
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 806
              tmp___3 = *tp;
#line 806
              *tp2 = tmp___3;
#line 806
              if (! ((int )tmp___3 != 0)) {
#line 806
                goto while_break___1;
              }
              {
#line 807
              tmp___2 = __ctype_b_loc();
              }
#line 807
              if ((int const   )*(*tmp___2 + (int )*tp2) & 256) {
#line 808
                *tp2 = (char )((97 + (int )*tp2) - 65);
              }
#line 810
              tp ++;
#line 811
              tp2 ++;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
#line 814
          tp = tmpbuf;
        }
#line 816
        if (ntflag) {
          {
#line 817
          tp = dotrans(tp);
          }
        }
#line 819
        if (mapflag) {
          {
#line 820
          tp = domap(tp);
          }
        }
        {
#line 823
        tp = pathprotect(tp);
#line 826
        tp = pipeprotect(tp);
        }
#line 827
        if ((unsigned long )tp != (unsigned long )cp) {
#line 827
          tmp___4 = 1;
        } else
#line 827
        if (! interactive) {
#line 827
          tmp___4 = 1;
        } else {
#line 827
          tmp___4 = 0;
        }
        {
#line 827
        recvrequest("RETR", tp, cp, "w", tmp___4);
        }
#line 829
        if (! mflag) {
#line 829
          if (fromatty) {
            {
#line 830
            ointer = interactive;
#line 831
            interactive = 1;
#line 832
            tmp___5 = confirm("Continue with", "mget");
            }
#line 832
            if (tmp___5) {
#line 833
              mflag ++;
            }
#line 835
            interactive = ointer;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 839
  toplevel = (sigjmp_buf *)oldtoplevel;
#line 840
  mflag = 0;
#line 841
  return;
}
}
#line 846 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
static char buf[4096]  ;
#line 847 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
static FILE *ftemp  =    (FILE *)((void *)0);
#line 848 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
static char **args  ;
#line 843 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
static char *remglob(char **argv , int doswitch ) 
{ 
  int oldverbose ;
  int oldhash ;
  int badglob ;
  char *cp ;
  char temp[16] ;
  unsigned int tmp ;
  int volatile   fd ;
  sigjmp_buf jmploc ;
  sigjmp_buf * volatile  oldtoplevel ;
  int tmp___0 ;
  int tmp___1 ;
  int dupfd ;
  int olderrno ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
#line 849
  badglob = 0;
#line 852
  if (! mflag) {
#line 853
    if (! doglob) {
#line 854
      args = (char **)((void *)0);
    } else
#line 857
    if (ftemp) {
      {
#line 858
      suppressint ++;
#line 859
      fclose(ftemp);
#line 860
      ftemp = (FILE *)((void *)0);
      }
      {
#line 861
      while (1) {
        while_continue: /* CIL Label */ ;
#line 861
        suppressint --;
#line 861
        if (suppressint == 0) {
#line 861
          if (intpending) {
            {
#line 861
            intr(2);
            }
          }
        }
#line 861
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 864
    return ((char *)((void *)0));
  }
#line 866
  if (! doglob) {
#line 867
    if ((unsigned long )args == (unsigned long )((void *)0)) {
#line 868
      args = argv;
    }
#line 869
    args ++;
#line 869
    cp = *args;
#line 869
    if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 870
      args = (char **)((void *)0);
    }
#line 871
    return (cp);
  }
#line 873
  if ((unsigned long )ftemp == (unsigned long )((void *)0)) {
#line 874
    temp[0] = (char )'\000';
#line 874
    tmp = 1U;
    {
#line 874
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 874
      if (tmp >= 16U) {
#line 874
        goto while_break___0;
      }
#line 874
      temp[tmp] = (char)0;
#line 874
      tmp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 878
    fd = (int volatile   )-1;
#line 882
    strcpy((char */* __restrict  */)(temp), (char const   */* __restrict  */)"/tmp/ftpXXXXXX");
#line 884
    oldtoplevel = (sigjmp_buf */* volatile  */)toplevel;
#line 885
    tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(jmploc), 0);
    }
#line 885
    if (tmp___0) {
#line 886
      if (fd >= (int volatile   )0) {
        {
#line 887
        unlink((char const   *)(temp));
#line 888
        close((int )fd);
        }
      }
      {
#line 890
      toplevel = (sigjmp_buf *)oldtoplevel;
#line 891
      siglongjmp((struct __jmp_buf_tag *)(*toplevel), 1);
      }
    }
    {
#line 893
    toplevel = & jmploc;
#line 896
    suppressint ++;
#line 900
    tmp___1 = mkstemp(temp);
#line 900
    fd = (int volatile   )tmp___1;
    }
    {
#line 904
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 904
      suppressint --;
#line 904
      if (suppressint == 0) {
#line 904
        if (intpending) {
          {
#line 904
          intr(2);
          }
        }
      }
#line 904
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 906
    if (fd < (int volatile   )0) {
      {
#line 907
      toplevel = (sigjmp_buf *)oldtoplevel;
#line 908
      printf((char const   */* __restrict  */)"Error creating temporary file, oops\n");
      }
#line 909
      return ((char *)((void *)0));
    }
#line 912
    oldverbose = verbose;
#line 912
    verbose = 0;
#line 913
    oldhash = hash;
#line 913
    hash = 0;
#line 914
    if (doswitch) {
      {
#line 915
      pswitch(! proxy);
      }
    }
    {
#line 917
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 917
      argv ++;
#line 917
      if (! ((unsigned long )*argv != (unsigned long )((void *)0))) {
#line 917
        goto while_break___2;
      }
      {
#line 920
      recvrequest("NLST", temp, *argv, "a", 0);
#line 922
      suppressint ++;
#line 923
      dupfd = dup((int )fd);
      }
#line 923
      if (dupfd < 0) {
        {
#line 924
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 924
          suppressint --;
#line 924
          if (suppressint == 0) {
#line 924
            if (intpending) {
              {
#line 924
              intr(2);
              }
            }
          }
#line 924
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 925
        perror("remglob: dup");
        }
        duperr: 
        {
#line 927
        suppressint ++;
#line 928
        unlink((char const   *)(temp));
#line 929
        close((int )fd);
#line 930
        fd = (int volatile   )-1;
        }
        {
#line 931
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 931
          suppressint --;
#line 931
          if (suppressint == 0) {
#line 931
            if (intpending) {
              {
#line 931
              intr(2);
              }
            }
          }
#line 931
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 932
        toplevel = (sigjmp_buf *)oldtoplevel;
#line 933
        return ((char *)((void *)0));
      }
      {
#line 935
      ftemp = fdopen(dupfd, "r");
      }
#line 935
      if ((unsigned long )ftemp == (unsigned long )((void *)0)) {
        {
#line 936
        tmp___2 = __errno_location();
#line 936
        olderrno = *tmp___2;
#line 937
        close(dupfd);
        }
        {
#line 938
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 938
          suppressint --;
#line 938
          if (suppressint == 0) {
#line 938
            if (intpending) {
              {
#line 938
              intr(2);
              }
            }
          }
#line 938
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
        {
#line 939
        tmp___3 = __errno_location();
#line 939
        *tmp___3 = olderrno;
#line 940
        perror("remglob: fdopen");
        }
#line 941
        goto duperr;
      }
      {
#line 943
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 943
        suppressint --;
#line 943
        if (suppressint == 0) {
#line 943
          if (intpending) {
            {
#line 943
            intr(2);
            }
          }
        }
#line 943
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 945
      tmp___4 = checkglob(ftemp, (char const   *)*argv);
      }
#line 945
      if (tmp___4) {
#line 945
        tmp___5 = 0;
      } else {
#line 945
        tmp___5 = 1;
      }
      {
#line 945
      badglob = tmp___5;
#line 947
      suppressint ++;
#line 948
      fclose(ftemp);
#line 949
      ftemp = (FILE *)((void *)0);
      }
      {
#line 950
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 950
        suppressint --;
#line 950
        if (suppressint == 0) {
#line 950
          if (intpending) {
            {
#line 950
            intr(2);
            }
          }
        }
#line 950
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 952
      if (badglob) {
#line 953
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 957
    if (doswitch) {
      {
#line 958
      pswitch(! proxy);
      }
    }
#line 960
    verbose = oldverbose;
#line 960
    hash = oldhash;
#line 961
    if (badglob) {
      {
#line 962
      printf((char const   */* __restrict  */)"Refusing to handle insecure file list\n");
      }
#line 963
      goto duperr;
    }
    {
#line 966
    suppressint ++;
#line 967
    unlink((char const   *)(temp));
#line 968
    ftemp = fdopen((int )fd, "r");
#line 969
    fd = (int volatile   )-1;
    }
    {
#line 970
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 970
      suppressint --;
#line 970
      if (suppressint == 0) {
#line 970
        if (intpending) {
          {
#line 970
          intr(2);
          }
        }
      }
#line 970
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 971
    toplevel = (sigjmp_buf *)oldtoplevel;
#line 973
    if ((unsigned long )ftemp == (unsigned long )((void *)0)) {
      {
#line 974
      printf((char const   */* __restrict  */)"fdopen failed, oops\n");
      }
#line 975
      return ((char *)((void *)0));
    }
    {
#line 978
    rewind(ftemp);
    }
  }
  {
#line 980
  tmp___6 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)ftemp);
  }
#line 980
  if ((unsigned long )tmp___6 == (unsigned long )((void *)0)) {
    {
#line 981
    suppressint ++;
#line 982
    fclose(ftemp);
#line 982
    ftemp = (FILE *)((void *)0);
    }
    {
#line 983
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 983
      suppressint --;
#line 983
      if (suppressint == 0) {
#line 983
        if (intpending) {
          {
#line 983
          intr(2);
          }
        }
      }
#line 983
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 984
    return ((char *)((void *)0));
  }
  {
#line 986
  cp = index((char const   *)(buf), '\n');
  }
#line 986
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 987
    *cp = (char )'\000';
  }
#line 988
  return (buf);
}
}
#line 996 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
static int isdotdotglob(char const   *pattern ) 
{ 
  int havedot ;
  char c ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
#line 999
  havedot = 0;
#line 1002
  tmp = pattern;
#line 1002
  pattern ++;
#line 1002
  if ((int const   )*tmp != 46) {
#line 1003
    return (0);
  }
  {
#line 1004
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1004
    tmp___1 = pattern;
#line 1004
    pattern ++;
#line 1004
    c = (char )*tmp___1;
#line 1004
    if ((int )c != 0) {
#line 1004
      if (! ((int )c != 47)) {
#line 1004
        goto while_break;
      }
    } else {
#line 1004
      goto while_break;
    }
#line 1005
    if ((int )c == 42) {
#line 1006
      goto while_continue;
    } else
#line 1005
    if ((int )c == 63) {
#line 1006
      goto while_continue;
    }
#line 1007
    if ((int )c == 46) {
#line 1007
      tmp___0 = havedot;
#line 1007
      havedot ++;
#line 1007
      if (tmp___0) {
#line 1008
        return (0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1010
  return (1);
}
}
#line 1030 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
static int checkglob(FILE *fp , char const   *pattern ) 
{ 
  char const   *sp ;
  char buffer[4096] ;
  char dotdot[4096] ;
  int okay ;
  int nrslash ;
  int initial ;
  int nr ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *sp___0 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 1035
  okay = 1;
#line 1040
  initial = (int const   )*(pattern + 0) == 47;
#line 1041
  sp = pattern;
#line 1041
  nrslash = 0;
  {
#line 1041
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1041
    if (! ((unsigned long )sp != (unsigned long )((char const   *)0))) {
#line 1041
      goto while_break;
    }
    {
#line 1042
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1042
      if (! ((int const   )*sp == 47)) {
#line 1042
        goto while_break___0;
      }
#line 1043
      sp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1044
    if ((unsigned long )nrslash >= sizeof(dotdot)) {
      {
#line 1045
      printf((char const   */* __restrict  */)"Incredible pattern: %s\n", pattern);
      }
#line 1046
      return (0);
    }
    {
#line 1048
    tmp___0 = nrslash;
#line 1048
    nrslash ++;
#line 1048
    tmp___1 = isdotdotglob(sp);
#line 1048
    dotdot[tmp___0] = (char )tmp___1;
#line 1041
    tmp = strchr(sp, '/');
#line 1041
    sp = (char const   *)tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1051
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1051
    if (okay) {
      {
#line 1051
      tmp___3 = fgets((char */* __restrict  */)(buffer), (int )sizeof(buffer), (FILE */* __restrict  */)fp);
      }
#line 1051
      if (! ((unsigned long )tmp___3 != (unsigned long )((void *)0))) {
#line 1051
        goto while_break___1;
      }
    } else {
#line 1051
      goto while_break___1;
    }
    {
#line 1054
    sp___0 = strchr((char const   *)(buffer), '\n');
    }
#line 1054
    if ((unsigned long )sp___0 != (unsigned long )((char *)0)) {
#line 1055
      *sp___0 = (char )'\000';
    } else {
      {
#line 1057
      printf((char const   */* __restrict  */)"Extremely long filename from server: %s",
             buffer);
#line 1059
      okay = 0;
      }
#line 1060
      goto while_break___1;
    }
#line 1062
    if ((int )buffer[0] == 124) {
#line 1065
      okay = 0;
    } else
#line 1062
    if ((int )buffer[0] != 47) {
#line 1062
      if (initial) {
#line 1065
        okay = 0;
      } else {
#line 1062
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1062
    if ((int )buffer[0] == 47) {
#line 1062
      if (! initial) {
#line 1065
        okay = 0;
      }
    }
#line 1066
    sp___0 = buffer;
#line 1066
    nr = 0;
    {
#line 1066
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1066
      if (! sp___0) {
#line 1066
        goto while_break___2;
      }
      {
#line 1067
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1067
        if (! ((int )*sp___0 == 47)) {
#line 1067
          goto while_break___3;
        }
#line 1068
        sp___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1069
      if ((int )*(sp___0 + 0) == 46) {
        {
#line 1069
        tmp___2 = strncmp((char const   *)sp___0, "../", (size_t )3);
        }
#line 1069
        if (! tmp___2) {
#line 1069
          if (nr >= nrslash) {
#line 1071
            okay = 0;
          } else
#line 1069
          if (! dotdot[nr]) {
#line 1071
            okay = 0;
          }
        }
      }
      {
#line 1066
      sp___0 = strchr((char const   *)sp___0, '/');
#line 1066
      nr ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1075
  if (! okay) {
    {
#line 1076
    printf((char const   */* __restrict  */)"Filename provided by server doesn\'t match pattern `%s\': %s\n",
           pattern, buffer);
    }
  }
#line 1079
  return (okay);
}
}
#line 1082 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
static char const   *onoff(int bool ) 
{ 
  char const   *tmp ;

  {
#line 1085
  if (bool) {
#line 1085
    tmp = "on";
  } else {
#line 1085
    tmp = "off";
  }
#line 1085
  return (tmp);
}
}
#line 1091 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void status(void) 
{ 
  int i ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;

  {
#line 1096
  if (connected) {
    {
#line 1097
    printf((char const   */* __restrict  */)"Connected to %s.\n", hostname);
    }
  } else {
    {
#line 1099
    printf((char const   */* __restrict  */)"Not connected.\n");
    }
  }
#line 1100
  if (! proxy) {
    {
#line 1101
    pswitch(1);
    }
#line 1102
    if (connected) {
      {
#line 1103
      printf((char const   */* __restrict  */)"Connected for proxy commands to %s.\n",
             hostname);
      }
    } else {
      {
#line 1106
      printf((char const   */* __restrict  */)"No proxy connection.\n");
      }
    }
    {
#line 1108
    pswitch(0);
    }
  }
#line 1110
  if (usefamily == 0) {
#line 1110
    tmp___0 = "any";
  } else {
#line 1110
    if (usefamily == 10) {
#line 1110
      tmp = "IPv6";
    } else {
#line 1110
      tmp = "IPv4";
    }
#line 1110
    tmp___0 = tmp;
  }
  {
#line 1110
  printf((char const   */* __restrict  */)"Connecting using address family: %s.\n",
         tmp___0);
#line 1113
  printf((char const   */* __restrict  */)"Mode: %s; Type: %s; Form: %s; Structure: %s\n",
         modename, typename, formname, structname);
#line 1115
  tmp___1 = onoff(doglob);
#line 1115
  tmp___2 = onoff(interactive);
#line 1115
  tmp___3 = onoff(bell);
#line 1115
  tmp___4 = onoff(verbose);
#line 1115
  printf((char const   */* __restrict  */)"Verbose: %s; Bell: %s; Prompting: %s; Globbing: %s\n",
         tmp___4, tmp___3, tmp___2, tmp___1);
#line 1118
  tmp___5 = onoff(runique);
#line 1118
  tmp___6 = onoff(sunique);
#line 1118
  printf((char const   */* __restrict  */)"Store unique: %s; Receive unique: %s\n",
         tmp___6, tmp___5);
#line 1120
  tmp___7 = onoff(crflag);
#line 1120
  tmp___8 = onoff(mcase);
#line 1120
  printf((char const   */* __restrict  */)"Case: %s; CR stripping: %s\n", tmp___8,
         tmp___7);
#line 1121
  tmp___9 = onoff(qcflag);
#line 1121
  printf((char const   */* __restrict  */)"Quote control characters: %s\n", tmp___9);
  }
#line 1122
  if (ntflag) {
    {
#line 1123
    printf((char const   */* __restrict  */)"Ntrans: (in) %s (out) %s\n", ntin, ntout);
    }
  } else {
    {
#line 1126
    printf((char const   */* __restrict  */)"Ntrans: off\n");
    }
  }
#line 1128
  if (mapflag) {
    {
#line 1129
    printf((char const   */* __restrict  */)"Nmap: (in) %s (out) %s\n", mapin, mapout);
    }
  } else {
    {
#line 1132
    printf((char const   */* __restrict  */)"Nmap: off\n");
    }
  }
  {
#line 1134
  tmp___10 = onoff(sendport);
#line 1134
  tmp___11 = onoff(hash);
#line 1134
  printf((char const   */* __restrict  */)"Hash mark printing: %s; Use of PORT cmds: %s\n",
         tmp___11, tmp___10);
#line 1136
  tmp___12 = onoff(tick);
#line 1136
  printf((char const   */* __restrict  */)"Tick counter printing: %s\n", tmp___12);
  }
#line 1137
  if (macnum > 0) {
    {
#line 1138
    printf((char const   */* __restrict  */)"Macros:\n");
#line 1139
    i = 0;
    }
    {
#line 1139
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1139
      if (! (i < macnum)) {
#line 1139
        goto while_break;
      }
      {
#line 1140
      printf((char const   */* __restrict  */)"\t%s\n", macros[i].mac_name);
#line 1139
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1143
  code = 0;
#line 1144
  return;
}
}
#line 1149 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void setbell(void) 
{ 
  char const   *tmp ;

  {
  {
#line 1153
  bell = ! bell;
#line 1154
  tmp = onoff(bell);
#line 1154
  printf((char const   */* __restrict  */)"Bell mode %s.\n", tmp);
#line 1155
  code = bell;
  }
#line 1156
  return;
}
}
#line 1161 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void settrace(void) 
{ 
  char const   *tmp ;

  {
  {
#line 1164
  traceflag = ! traceflag;
#line 1165
  tmp = onoff(traceflag);
#line 1165
  printf((char const   */* __restrict  */)"Packet tracing %s.\n", tmp);
#line 1166
  code = traceflag;
  }
#line 1167
  return;
}
}
#line 1172 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void sethash(void) 
{ 
  char const   *tmp ;

  {
#line 1175
  hash = ! hash;
#line 1176
  if (hash) {
#line 1176
    if (tick) {
      {
#line 1177
      settick();
      }
    }
  }
  {
#line 1179
  tmp = onoff(hash);
#line 1179
  printf((char const   */* __restrict  */)"Hash mark printing %s", tmp);
#line 1180
  code = hash;
  }
#line 1181
  if (hash) {
    {
#line 1182
    printf((char const   */* __restrict  */)" (%d bytes/hash mark)", 1024);
    }
  }
  {
#line 1183
  printf((char const   */* __restrict  */)".\n");
  }
#line 1184
  return;
}
}
#line 1189 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void settick(void) 
{ 
  char const   *tmp ;

  {
#line 1192
  tick = ! tick;
#line 1193
  if (hash) {
#line 1193
    if (tick) {
      {
#line 1194
      sethash();
      }
    }
  }
  {
#line 1195
  tmp = onoff(tick);
#line 1195
  printf((char const   */* __restrict  */)"Tick counter printing %s", tmp);
#line 1196
  code = tick;
  }
#line 1197
  if (tick) {
    {
#line 1198
    printf((char const   */* __restrict  */)" (%d bytes/tick increment)", 10240);
    }
  }
  {
#line 1199
  printf((char const   */* __restrict  */)".\n");
  }
#line 1200
  return;
}
}
#line 1205 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void setverbose(void) 
{ 
  char const   *tmp ;

  {
  {
#line 1208
  verbose = ! verbose;
#line 1209
  tmp = onoff(verbose);
#line 1209
  printf((char const   */* __restrict  */)"Verbose mode %s.\n", tmp);
#line 1210
  code = verbose;
  }
#line 1211
  return;
}
}
#line 1216 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void setport(void) 
{ 
  char const   *tmp ;

  {
  {
#line 1219
  sendport = ! sendport;
#line 1220
  tmp = onoff(sendport);
#line 1220
  printf((char const   */* __restrict  */)"Use of PORT cmds %s.\n", tmp);
#line 1221
  code = sendport;
  }
#line 1222
  return;
}
}
#line 1228 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void setprompt(void) 
{ 
  char const   *tmp ;

  {
  {
#line 1231
  interactive = ! interactive;
#line 1232
  tmp = onoff(interactive);
#line 1232
  printf((char const   */* __restrict  */)"Interactive mode %s.\n", tmp);
#line 1233
  code = interactive;
  }
#line 1234
  return;
}
}
#line 1240 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void setglob(void) 
{ 
  char const   *tmp ;

  {
  {
#line 1243
  doglob = ! doglob;
#line 1244
  tmp = onoff(doglob);
#line 1244
  printf((char const   */* __restrict  */)"Globbing %s.\n", tmp);
#line 1245
  code = doglob;
  }
#line 1246
  return;
}
}
#line 1252 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void setdebug(int argc , char **argv ) 
{ 
  int val ;
  char const   *tmp ;

  {
#line 1257
  if (argc > 1) {
    {
#line 1258
    val = atoi((char const   *)*(argv + 1));
    }
#line 1259
    if (val < 0) {
      {
#line 1260
      printf((char const   */* __restrict  */)"%s: bad debugging value.\n", *(argv + 1));
#line 1261
      code = -1;
      }
#line 1262
      return;
    }
  } else {
#line 1265
    val = ! debug;
  }
#line 1266
  debug = val;
#line 1267
  if (debug) {
#line 1268
    options |= 1;
  } else {
#line 1270
    options &= -2;
  }
  {
#line 1271
  tmp = onoff(debug);
#line 1271
  printf((char const   */* __restrict  */)"Debugging %s (debug=%d).\n", tmp, debug);
#line 1272
  code = debug > 0;
  }
#line 1273
  return;
}
}
#line 1279 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void cd(int argc , char **argv ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1283
  if (argc < 2) {
    {
#line 1283
    tmp = another(& argc, & argv, "remote-directory");
    }
#line 1283
    if (! tmp) {
      {
#line 1284
      printf((char const   */* __restrict  */)"usage: %s remote-directory\n", *(argv + 0));
#line 1285
      code = -1;
      }
#line 1286
      return;
    }
  }
  {
#line 1288
  tmp___0 = command("CWD %s", *(argv + 1));
  }
#line 1288
  if (tmp___0 == 5) {
#line 1288
    if (code == 500) {
#line 1289
      if (verbose) {
        {
#line 1290
        printf((char const   */* __restrict  */)"CWD command not recognized, trying XCWD\n");
        }
      }
      {
#line 1291
      command("XCWD %s", *(argv + 1));
      }
    }
  }
#line 1293
  return;
}
}
#line 1299 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void lcd(int argc , char **argv ) 
{ 
  char buf___0[4096] ;
  char const   *dir ;
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;

  {
#line 1303
  dir = (char const   *)((void *)0);
#line 1305
  if (argc == 1) {
#line 1307
    dir = ".";
  } else
#line 1309
  if (argc != 2) {
    {
#line 1310
    printf((char const   */* __restrict  */)"usage: %s local-directory\n", *(argv + 0));
#line 1311
    code = -1;
    }
#line 1312
    return;
  } else {
    {
#line 1315
    tmp = globulize(*(argv + 1));
#line 1315
    dir = (char const   *)tmp;
    }
  }
#line 1317
  if (! dir) {
#line 1318
    code = -1;
#line 1319
    return;
  }
  {
#line 1321
  tmp___2 = chdir(dir);
  }
#line 1321
  if (tmp___2 < 0) {
    {
#line 1322
    tmp___0 = __errno_location();
#line 1322
    tmp___1 = strerror(*tmp___0);
#line 1322
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"local: %s: %s\n",
            dir, tmp___1);
#line 1323
    code = -1;
    }
#line 1324
    return;
  }
  {
#line 1326
  tmp___4 = getcwd(buf___0, sizeof(buf___0));
  }
#line 1326
  if (! tmp___4) {
    {
#line 1327
    tmp___3 = __errno_location();
    }
#line 1327
    if (*tmp___3 == 34) {
      {
#line 1327
      strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"<too long>");
      }
    } else {
      {
#line 1328
      strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"???");
      }
    }
  }
  {
#line 1330
  printf((char const   */* __restrict  */)"Local directory now %s\n", buf___0);
#line 1331
  code = 0;
  }
#line 1332
  return;
}
}
#line 1337 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void delete_cmd(int argc , char **argv ) 
{ 
  int tmp ;

  {
#line 1341
  if (argc < 2) {
    {
#line 1341
    tmp = another(& argc, & argv, "remote-file");
    }
#line 1341
    if (! tmp) {
      {
#line 1342
      printf((char const   */* __restrict  */)"usage: %s remote-file\n", *(argv + 0));
#line 1343
      code = -1;
      }
#line 1344
      return;
    }
  }
  {
#line 1346
  command("DELE %s", *(argv + 1));
  }
#line 1347
  return;
}
}
#line 1352 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void mdelete(int argc , char **argv ) 
{ 
  int ointer ;
  char *cp ;
  sigjmp_buf jmploc ;
  sigjmp_buf * volatile  oldtoplevel ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1360
  if (argc < 2) {
    {
#line 1360
    tmp = another(& argc, & argv, "remote-files");
    }
#line 1360
    if (! tmp) {
      {
#line 1361
      printf((char const   */* __restrict  */)"usage: %s remote-files\n", *(argv + 0));
#line 1362
      code = -1;
      }
#line 1363
      return;
    }
  }
  {
#line 1365
  mname = *(argv + 0);
#line 1366
  mflag = 1;
#line 1367
  oldtoplevel = (sigjmp_buf */* volatile  */)toplevel;
#line 1368
  tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(jmploc), 1);
  }
#line 1368
  if (tmp___0) {
    {
#line 1369
    mabort(2);
    }
  } else {
#line 1371
    toplevel = & jmploc;
  }
  {
#line 1373
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1373
    cp = remglob(argv, 0);
    }
#line 1373
    if (! ((unsigned long )cp != (unsigned long )((void *)0))) {
#line 1373
      goto while_break;
    }
#line 1374
    if ((int )*cp == 0) {
#line 1375
      mflag = 0;
#line 1376
      goto while_continue;
    }
#line 1378
    if (mflag) {
      {
#line 1378
      tmp___2 = confirm((char const   *)*(argv + 0), (char const   *)cp);
      }
#line 1378
      if (tmp___2) {
        {
#line 1379
        command("DELE %s", cp);
        }
#line 1380
        if (! mflag) {
#line 1380
          if (fromatty) {
            {
#line 1381
            ointer = interactive;
#line 1382
            interactive = 1;
#line 1383
            tmp___1 = confirm("Continue with", "mdelete");
            }
#line 1383
            if (tmp___1) {
#line 1384
              mflag ++;
            }
#line 1386
            interactive = ointer;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1390
  toplevel = (sigjmp_buf *)oldtoplevel;
#line 1391
  mflag = 0;
#line 1392
  return;
}
}
#line 1397 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void renamefile(int argc , char **argv ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1401
  if (argc < 2) {
    {
#line 1401
    tmp = another(& argc, & argv, "from-name");
    }
#line 1401
    if (! tmp) {
#line 1402
      goto usage;
    }
  }
#line 1403
  if (argc < 3) {
    {
#line 1403
    tmp___0 = another(& argc, & argv, "to-name");
    }
#line 1403
    if (! tmp___0) {
      usage: 
      {
#line 1405
      printf((char const   */* __restrict  */)"%s from-name to-name\n", *(argv + 0));
#line 1406
      code = -1;
      }
#line 1407
      return;
    }
  }
  {
#line 1409
  tmp___1 = command("RNFR %s", *(argv + 1));
  }
#line 1409
  if (tmp___1 == 3) {
    {
#line 1410
    command("RNTO %s", *(argv + 2));
    }
  }
#line 1411
  return;
}
}
#line 1420 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
static char foo[2]  = {      (char )'-',      (char )'\000'};
#line 1417 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void ls(int argc , char **argv ) 
{ 
  char const   *cmd ;
  int tmp ;
  int tmp___0 ;

  {
#line 1423
  if (argc < 2) {
#line 1424
    argc ++;
#line 1424
    *(argv + 1) = (char *)((void *)0);
  }
#line 1426
  if (argc < 3) {
#line 1427
    argc ++;
#line 1427
    *(argv + 2) = foo;
  }
#line 1429
  if (argc > 3) {
    {
#line 1430
    printf((char const   */* __restrict  */)"usage: %s remote-directory local-file\n",
           *(argv + 0));
#line 1431
    code = -1;
    }
#line 1432
    return;
  }
#line 1435
  if ((int )*(*(argv + 0) + 0) == 110) {
#line 1435
    cmd = "NLST";
  } else {
#line 1435
    cmd = "LIST";
  }
  {
#line 1436
  tmp___0 = strcmp((char const   *)*(argv + 2), "-");
  }
#line 1436
  if (tmp___0) {
#line 1436
    if ((int )*(*(argv + 2)) != 124) {
      {
#line 1437
      *(argv + 2) = globulize(*(argv + 2));
      }
#line 1438
      if ((unsigned long )*(argv + 2) == (unsigned long )((void *)0)) {
#line 1440
        code = -1;
#line 1441
        return;
      } else {
        {
#line 1438
        tmp = confirm("output to local-file:", (char const   *)*(argv + 2));
        }
#line 1438
        if (! tmp) {
#line 1440
          code = -1;
#line 1441
          return;
        }
      }
    }
  }
  {
#line 1444
  recvrequest(cmd, *(argv + 2), *(argv + 1), "w", 0);
  }
#line 1445
  return;
}
}
#line 1451 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void mls(int argc , char **argv ) 
{ 
  int ointer ;
  int i ;
  char const   * volatile  cmd ;
  char * volatile  dest ;
  char const   *modestr ;
  sigjmp_buf jmploc ;
  sigjmp_buf * volatile  oldtoplevel ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1461
  if (argc < 2) {
    {
#line 1461
    tmp = another(& argc, & argv, "remote-files");
    }
#line 1461
    if (! tmp) {
#line 1462
      goto usage;
    }
  }
#line 1463
  if (argc < 3) {
    {
#line 1463
    tmp___0 = another(& argc, & argv, "local-file");
    }
#line 1463
    if (! tmp___0) {
      usage: 
      {
#line 1465
      printf((char const   */* __restrict  */)"usage: %s remote-files local-file\n",
             *(argv + 0));
#line 1466
      code = -1;
      }
#line 1467
      return;
    }
  }
  {
#line 1470
  dest = (char */* volatile  */)*(argv + (argc - 1));
#line 1471
  *(argv + (argc - 1)) = (char *)((void *)0);
#line 1473
  tmp___3 = strcmp((char const   *)dest, "-");
  }
#line 1473
  if (tmp___3) {
#line 1473
    if ((int )*dest != 124) {
      {
#line 1474
      tmp___1 = globulize((char *)dest);
#line 1474
      dest = (char */* volatile  */)tmp___1;
      }
#line 1475
      if ((unsigned long )dest == (unsigned long )((void *)0)) {
#line 1476
        code = -1;
#line 1477
        return;
      } else {
        {
#line 1475
        tmp___2 = confirm("output to local-file:", (char const   *)dest);
        }
#line 1475
        if (! tmp___2) {
#line 1476
          code = -1;
#line 1477
          return;
        }
      }
    }
  }
#line 1480
  if ((int )*(*(argv + 0) + 1) == 108) {
#line 1480
    cmd = (char const   */* volatile  */)"NLST";
  } else {
#line 1480
    cmd = (char const   */* volatile  */)"LIST";
  }
  {
#line 1481
  mname = *(argv + 0);
#line 1482
  mflag = 1;
#line 1487
  oldtoplevel = (sigjmp_buf */* volatile  */)toplevel;
#line 1488
  tmp___4 = __sigsetjmp((struct __jmp_buf_tag *)(jmploc), 1);
  }
#line 1488
  if (tmp___4) {
    {
#line 1489
    mabort(2);
    }
  } else {
#line 1491
    toplevel = & jmploc;
  }
#line 1494
  i = 1;
  {
#line 1494
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1494
    if (mflag) {
#line 1494
      if (! (i < argc - 1)) {
#line 1494
        goto while_break;
      }
    } else {
#line 1494
      goto while_break;
    }
#line 1495
    if (i == 1) {
#line 1495
      modestr = "w";
    } else {
#line 1495
      modestr = "a";
    }
    {
#line 1496
    recvrequest((char const   *)cmd, (char *)dest, *(argv + i), modestr, 0);
    }
#line 1497
    if (! mflag) {
#line 1497
      if (fromatty) {
        {
#line 1498
        ointer = interactive;
#line 1499
        interactive = 1;
#line 1500
        tmp___5 = confirm("Continue with", (char const   *)*(argv + 0));
        }
#line 1500
        if (tmp___5) {
#line 1501
          mflag ++;
        }
#line 1503
        interactive = ointer;
      }
    }
#line 1494
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1506
  toplevel = (sigjmp_buf *)oldtoplevel;
#line 1507
  mflag = 0;
#line 1508
  return;
}
}
#line 1513 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void shell(char const   *arg ) 
{ 
  int pid ;
  void (*old1)(int  ) ;
  void (*old2)(int  ) ;
  char shellnam[40] ;
  char const   *theshell ;
  char const   *namep ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  __pid_t tmp___2 ;

  {
  {
#line 1522
  old1 = signal(2, (void (*)(int  ))1);
#line 1523
  old2 = signal(3, (void (*)(int  ))1);
#line 1524
  pid = fork();
  }
#line 1524
  if (pid == 0) {
#line 1525
    pid = 3;
    {
#line 1525
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1525
      if (! (pid < 20)) {
#line 1525
        goto while_break;
      }
      {
#line 1526
      close(pid);
#line 1525
      pid ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1527
    signal(2, (void (*)(int  ))0);
#line 1528
    signal(3, (void (*)(int  ))0);
#line 1529
    tmp = getenv("SHELL");
#line 1529
    theshell = (char const   *)tmp;
    }
#line 1530
    if ((unsigned long )theshell == (unsigned long )((void *)0)) {
#line 1531
      theshell = "/bin/sh";
    }
    {
#line 1532
    tmp___0 = strrchr(theshell, '/');
#line 1532
    namep = (char const   *)tmp___0;
    }
#line 1533
    if ((unsigned long )namep == (unsigned long )((void *)0)) {
#line 1534
      namep = theshell;
    } else {
#line 1536
      namep ++;
    }
    {
#line 1537
    strcpy((char */* __restrict  */)(shellnam), (char const   */* __restrict  */)"-");
#line 1538
    strcat((char */* __restrict  */)(shellnam), (char const   */* __restrict  */)namep);
#line 1539
    tmp___1 = strcmp(namep, "sh");
    }
#line 1539
    if (tmp___1 != 0) {
#line 1540
      shellnam[0] = (char )'+';
    }
#line 1541
    if (debug) {
      {
#line 1542
      printf((char const   */* __restrict  */)"%s\n", theshell);
#line 1543
      fflush(stdout);
      }
    }
#line 1545
    if (arg) {
      {
#line 1546
      execl(theshell, (char const   *)(shellnam), "-c", arg, (void *)0);
      }
    } else {
      {
#line 1549
      execl(theshell, (char const   *)(shellnam), (void *)0);
      }
    }
    {
#line 1551
    perror(theshell);
#line 1552
    code = -1;
#line 1553
    exit(1);
    }
  }
#line 1555
  if (pid > 0) {
    {
#line 1555
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1555
      tmp___2 = wait((union wait *)((void *)0));
      }
#line 1555
      if (! (tmp___2 != pid)) {
#line 1555
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 1557
  signal(2, old1);
#line 1558
  signal(3, old2);
  }
#line 1559
  if (pid == -1) {
    {
#line 1560
    perror("Try again later");
#line 1561
    code = -1;
    }
  } else {
#line 1564
    code = 0;
  }
#line 1566
  return;
}
}
#line 1571 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void user(int argc , char **argv ) 
{ 
  char theacct[80] ;
  int n ;
  int aflag ;

  {
#line 1575
  aflag = 0;
#line 1577
  if (argc < 2) {
    {
#line 1578
    another(& argc, & argv, "username");
    }
  }
#line 1579
  if (argc < 2) {
    {
#line 1580
    printf((char const   */* __restrict  */)"usage: %s username [password] [account]\n",
           *(argv + 0));
#line 1581
    code = -1;
    }
#line 1582
    return;
  } else
#line 1579
  if (argc > 4) {
    {
#line 1580
    printf((char const   */* __restrict  */)"usage: %s username [password] [account]\n",
           *(argv + 0));
#line 1581
    code = -1;
    }
#line 1582
    return;
  }
  {
#line 1584
  n = command("USER %s", *(argv + 1));
  }
#line 1585
  if (n == 3) {
#line 1586
    if (argc < 3) {
      {
#line 1587
      *(argv + 2) = getpass("Password: ");
#line 1587
      argc ++;
      }
    }
    {
#line 1588
    n = command("PASS %s", *(argv + 2));
    }
  }
#line 1590
  if (n == 3) {
#line 1591
    if (argc < 4) {
      {
#line 1592
      printf((char const   */* __restrict  */)"Account: ");
#line 1592
      fflush(stdout);
#line 1593
      fgets((char */* __restrict  */)(theacct), (int )sizeof(theacct), (FILE */* __restrict  */)stdin);
#line 1594
      *(argv + 3) = theacct;
#line 1594
      argc ++;
      }
    }
    {
#line 1596
    n = command("ACCT %s", *(argv + 3));
#line 1597
    aflag ++;
    }
  }
#line 1599
  if (n != 2) {
    {
#line 1600
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Login failed.\n");
    }
#line 1601
    return;
  }
#line 1603
  if (! aflag) {
#line 1603
    if (argc == 4) {
      {
#line 1604
      command("ACCT %s", *(argv + 3));
      }
    }
  }
  {
#line 1606
  dosyst();
  }
#line 1607
  return;
}
}
#line 1612 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void pwd(void) 
{ 
  int oldverbose ;
  int tmp ;

  {
  {
#line 1615
  oldverbose = verbose;
#line 1620
  verbose = 1;
#line 1621
  tmp = command("PWD");
  }
#line 1621
  if (tmp == 5) {
#line 1621
    if (code == 500) {
      {
#line 1622
      printf((char const   */* __restrict  */)"PWD command not recognized, trying XPWD\n");
#line 1623
      command("XPWD");
      }
    }
  }
#line 1625
  verbose = oldverbose;
#line 1626
  return;
}
}
#line 1631 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void makedir(int argc , char **argv ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1635
  if (argc < 2) {
    {
#line 1635
    tmp = another(& argc, & argv, "directory-name");
    }
#line 1635
    if (! tmp) {
      {
#line 1636
      printf((char const   */* __restrict  */)"usage: %s directory-name\n", *(argv + 0));
#line 1637
      code = -1;
      }
#line 1638
      return;
    }
  }
  {
#line 1640
  tmp___0 = command("MKD %s", *(argv + 1));
  }
#line 1640
  if (tmp___0 == 5) {
#line 1640
    if (code == 500) {
#line 1641
      if (verbose) {
        {
#line 1642
        printf((char const   */* __restrict  */)"MKD command not recognized, trying XMKD\n");
        }
      }
      {
#line 1643
      command("XMKD %s", *(argv + 1));
      }
    }
  }
#line 1645
  return;
}
}
#line 1650 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void removedir(int argc , char **argv ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1654
  if (argc < 2) {
    {
#line 1654
    tmp = another(& argc, & argv, "directory-name");
    }
#line 1654
    if (! tmp) {
      {
#line 1655
      printf((char const   */* __restrict  */)"usage: %s directory-name\n", *(argv + 0));
#line 1656
      code = -1;
      }
#line 1657
      return;
    }
  }
  {
#line 1659
  tmp___0 = command("RMD %s", *(argv + 1));
  }
#line 1659
  if (tmp___0 == 5) {
#line 1659
    if (code == 500) {
#line 1660
      if (verbose) {
        {
#line 1661
        printf((char const   */* __restrict  */)"RMD command not recognized, trying XRMD\n");
        }
      }
      {
#line 1662
      command("XRMD %s", *(argv + 1));
      }
    }
  }
#line 1664
  return;
}
}
#line 1669 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void quote(int argc , char **argv ) 
{ 
  int tmp ;

  {
#line 1672
  if (argc < 2) {
    {
#line 1672
    tmp = another(& argc, & argv, "command line to send");
    }
#line 1672
    if (! tmp) {
      {
#line 1673
      printf((char const   */* __restrict  */)"usage: %s line-to-send\n", *(argv + 0));
#line 1674
      code = -1;
      }
#line 1675
      return;
    }
  }
  {
#line 1677
  quote1("", argc, argv);
  }
#line 1678
  return;
}
}
#line 1685 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void site(int argc , char **argv ) 
{ 
  int tmp ;

  {
#line 1688
  if (argc < 2) {
    {
#line 1688
    tmp = another(& argc, & argv, "arguments to SITE command");
    }
#line 1688
    if (! tmp) {
      {
#line 1689
      printf((char const   */* __restrict  */)"usage: %s line-to-send\n", *(argv + 0));
#line 1690
      code = -1;
      }
#line 1691
      return;
    }
  }
  {
#line 1693
  quote1("SITE ", argc, argv);
  }
#line 1694
  return;
}
}
#line 1700 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
static void quote1(char const   *initial , int argc , char **argv ) 
{ 
  register int i ;
  char *buf___0 ;
  struct obstack *__o ;
  int __len ;
  size_t tmp ;
  struct obstack *__o___0 ;
  int __len___0 ;
  size_t tmp___0 ;
  struct obstack *__o___1 ;
  char *tmp___1 ;
  struct obstack *__o___2 ;
  int __len___1 ;
  size_t tmp___2 ;
  struct obstack *__o___3 ;
  char *tmp___3 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___4 ;
  char *tmp___5 ;
  struct obstack *__o___4 ;
  void *__obj ;
  char *tmp___6 ;
  int tmp___7 ;

  {
  {
#line 1706
  suppressint ++;
#line 1707
  __o = & mainobstack;
#line 1707
  tmp = strlen(initial);
#line 1707
  __len = (int )tmp;
  }
#line 1707
  if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
    {
#line 1707
    _obstack_newchunk(__o, __len);
    }
  }
  {
#line 1707
  memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)initial,
         (size_t )__len);
#line 1707
  __o->next_free += __len;
  }
#line 1708
  if (argc > 1) {
    {
#line 1709
    __o___0 = & mainobstack;
#line 1709
    tmp___0 = strlen((char const   *)*(argv + 1));
#line 1709
    __len___0 = (int )tmp___0;
    }
#line 1709
    if ((unsigned long )(__o___0->next_free + __len___0) > (unsigned long )__o___0->chunk_limit) {
      {
#line 1709
      _obstack_newchunk(__o___0, __len___0);
      }
    }
    {
#line 1709
    memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)*(argv + 1),
           (size_t )__len___0);
#line 1709
    __o___0->next_free += __len___0;
#line 1710
    i = 2;
    }
    {
#line 1710
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1710
      if (! (i < argc)) {
#line 1710
        goto while_break;
      }
#line 1711
      __o___1 = & mainobstack;
#line 1711
      if ((unsigned long )(__o___1->next_free + 1) > (unsigned long )__o___1->chunk_limit) {
        {
#line 1711
        _obstack_newchunk(__o___1, 1);
        }
      }
      {
#line 1711
      tmp___1 = __o___1->next_free;
#line 1711
      (__o___1->next_free) ++;
#line 1711
      *tmp___1 = (char )' ';
#line 1712
      __o___2 = & mainobstack;
#line 1712
      tmp___2 = strlen((char const   *)*(argv + i));
#line 1712
      __len___1 = (int )tmp___2;
      }
#line 1712
      if ((unsigned long )(__o___2->next_free + __len___1) > (unsigned long )__o___2->chunk_limit) {
        {
#line 1712
        _obstack_newchunk(__o___2, __len___1);
        }
      }
      {
#line 1712
      memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)*(argv + i),
             (size_t )__len___1);
#line 1712
      __o___2->next_free += __len___1;
#line 1710
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1715
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1715
    suppressint --;
#line 1715
    if (suppressint == 0) {
#line 1715
      if (intpending) {
        {
#line 1715
        intr(2);
        }
      }
    }
#line 1715
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1717
  __o___3 = & mainobstack;
#line 1717
  if ((unsigned long )(__o___3->next_free + 1) > (unsigned long )__o___3->chunk_limit) {
    {
#line 1717
    _obstack_newchunk(__o___3, 1);
    }
  }
#line 1717
  tmp___3 = __o___3->next_free;
#line 1717
  (__o___3->next_free) ++;
#line 1717
  *tmp___3 = (char )'\000';
#line 1718
  __o1 = & mainobstack;
#line 1718
  __value = (void *)__o1->object_base;
#line 1718
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 1718
    __o1->maybe_empty_object = 1U;
  }
#line 1718
  if (sizeof(long ) < sizeof(void *)) {
#line 1718
    tmp___4 = __o1->object_base;
  } else {
#line 1718
    tmp___4 = (char *)0;
  }
#line 1718
  if (sizeof(long ) < sizeof(void *)) {
#line 1718
    tmp___5 = __o1->object_base;
  } else {
#line 1718
    tmp___5 = (char *)0;
  }
#line 1718
  __o1->next_free = tmp___4 + (((__o1->next_free - tmp___5) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 1718
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 1718
    __o1->next_free = __o1->chunk_limit;
  }
  {
#line 1718
  __o1->object_base = __o1->next_free;
#line 1718
  buf___0 = (char *)__value;
#line 1719
  i = command("%s", buf___0);
#line 1720
  suppressint ++;
#line 1721
  __o___4 = & mainobstack;
#line 1721
  __obj = (void *)buf___0;
  }
#line 1721
  if ((unsigned long )__obj > (unsigned long )((void *)__o___4->chunk)) {
#line 1721
    if ((unsigned long )__obj < (unsigned long )((void *)__o___4->chunk_limit)) {
#line 1721
      tmp___6 = (char *)__obj;
#line 1721
      __o___4->object_base = tmp___6;
#line 1721
      __o___4->next_free = tmp___6;
    } else {
      {
#line 1721
      obstack_free(__o___4, __obj);
      }
    }
  } else {
    {
#line 1721
    obstack_free(__o___4, __obj);
    }
  }
  {
#line 1722
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1722
    suppressint --;
#line 1722
    if (suppressint == 0) {
#line 1722
      if (intpending) {
        {
#line 1722
        intr(2);
        }
      }
    }
#line 1722
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1724
  if (i == 1) {
    {
#line 1725
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1725
      tmp___7 = getreply(0);
      }
#line 1725
      if (! (tmp___7 == 1)) {
#line 1725
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 1727
  return;
}
}
#line 1729 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void do_chmod(int argc , char **argv ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1733
  if (argc < 2) {
    {
#line 1733
    tmp = another(& argc, & argv, "mode");
    }
#line 1733
    if (! tmp) {
#line 1734
      goto usage;
    }
  }
#line 1735
  if (argc < 3) {
    {
#line 1735
    tmp___0 = another(& argc, & argv, "file-name");
    }
#line 1735
    if (! tmp___0) {
      usage: 
      {
#line 1737
      printf((char const   */* __restrict  */)"usage: %s mode file-name\n", *(argv + 0));
#line 1738
      code = -1;
      }
#line 1739
      return;
    }
  }
  {
#line 1741
  command("SITE CHMOD %s %s", *(argv + 1), *(argv + 2));
  }
#line 1742
  return;
}
}
#line 1744 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void do_umask(int argc , char **argv ) 
{ 
  int oldverbose ;
  char const   *tmp ;

  {
#line 1747
  oldverbose = verbose;
#line 1749
  verbose = 1;
#line 1750
  if (argc == 1) {
#line 1750
    tmp = "SITE UMASK";
  } else {
#line 1750
    tmp = "SITE UMASK %s";
  }
  {
#line 1750
  command(tmp, *(argv + 1));
#line 1751
  verbose = oldverbose;
  }
#line 1752
  return;
}
}
#line 1754 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void idle_cmd(int argc , char **argv ) 
{ 
  int oldverbose ;
  char const   *tmp ;

  {
#line 1757
  oldverbose = verbose;
#line 1759
  verbose = 1;
#line 1760
  if (argc == 1) {
#line 1760
    tmp = "SITE IDLE";
  } else {
#line 1760
    tmp = "SITE IDLE %s";
  }
  {
#line 1760
  command(tmp, *(argv + 1));
#line 1761
  verbose = oldverbose;
  }
#line 1762
  return;
}
}
#line 1767 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void rmthelp(int argc , char **argv ) 
{ 
  int oldverbose ;
  char const   *tmp ;

  {
#line 1770
  oldverbose = verbose;
#line 1772
  verbose = 1;
#line 1773
  if (argc == 1) {
#line 1773
    tmp = "HELP";
  } else {
#line 1773
    tmp = "HELP %s";
  }
  {
#line 1773
  command(tmp, *(argv + 1));
#line 1774
  verbose = oldverbose;
  }
#line 1775
  return;
}
}
#line 1780 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void quit(void) 
{ 


  {
#line 1784
  if (connected) {
    {
#line 1785
    disconnect();
    }
  }
  {
#line 1786
  pswitch(1);
  }
#line 1787
  if (connected) {
    {
#line 1788
    disconnect();
    }
  }
  {
#line 1790
  exit(0);
  }
}
}
#line 1796 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void disconnect(void) 
{ 


  {
#line 1799
  if (! connected) {
#line 1800
    return;
  }
  {
#line 1801
  command("QUIT");
  }
#line 1802
  if (cout) {
    {
#line 1803
    suppressint ++;
#line 1804
    fclose(cout);
#line 1805
    cout = (FILE *)((void *)0);
    }
    {
#line 1806
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1806
      suppressint --;
#line 1806
      if (suppressint == 0) {
#line 1806
        if (intpending) {
          {
#line 1806
          intr(2);
          }
        }
      }
#line 1806
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1808
  if (data >= 0) {
    {
#line 1809
    suppressint ++;
#line 1810
    close(data);
#line 1811
    data = -1;
    }
    {
#line 1812
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1812
      suppressint --;
#line 1812
      if (suppressint == 0) {
#line 1812
        if (intpending) {
          {
#line 1812
          intr(2);
          }
        }
      }
#line 1812
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1814
  connected = 0;
#line 1815
  if (! proxy) {
#line 1816
    macnum = 0;
  }
#line 1818
  return;
}
}
#line 1820 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
static int confirm(char const   *cmd , char const   *file ) 
{ 
  char lyne[8192] ;
  char *tmp ;
  int tmp___0 ;

  {
#line 1825
  if (! interactive) {
#line 1826
    return (1);
  }
  {
#line 1845
  printf((char const   */* __restrict  */)"%s %s? ", cmd, file);
#line 1846
  fflush(stdout);
#line 1847
  tmp = fgets((char */* __restrict  */)(lyne), (int )sizeof(lyne), (FILE */* __restrict  */)stdin);
  }
#line 1847
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 1848
    return (0);
  }
#line 1853
  if ((int )lyne[0] != 110) {
#line 1853
    if ((int )lyne[0] != 78) {
#line 1853
      tmp___0 = 1;
    } else {
#line 1853
      tmp___0 = 0;
    }
  } else {
#line 1853
    tmp___0 = 0;
  }
#line 1853
  return (tmp___0);
}
}
#line 1856 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void fatal(char const   *msg ) 
{ 


  {
  {
#line 1860
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ftp: %s\n",
          msg);
#line 1861
  exit(1);
  }
}
}
#line 1870 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
static char *globulize(char *cpp ) 
{ 
  char *rv ;
  glob_t pglob ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  size_t tmp___3 ;
  char *tmp___4 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
#line 1877
  if (! doglob) {
#line 1877
    return (cpp);
  }
  {
#line 1879
  suppressint ++;
#line 1880
  tmp = glob((char const   */* __restrict  */)cpp, ((((1 << 10) | 1) | (1 << 4)) | (1 << 6)) | (1 << 12),
             (int (*)(char const   * , int  ))0, (glob_t */* __restrict  */)(& pglob));
  }
  {
#line 1882
  if (tmp == 1) {
#line 1882
    goto case_1;
  }
#line 1885
  if (tmp == 2) {
#line 1885
    goto case_2;
  }
#line 1880
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1883
  tmp___0 = __errno_location();
#line 1883
  *tmp___0 = 12;
  }
#line 1884
  goto err;
  case_2: /* CIL Label */ 
  {
#line 1886
  globfree(& pglob);
  }
  err: 
  {
#line 1888
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1888
    suppressint --;
#line 1888
    if (suppressint == 0) {
#line 1888
      if (intpending) {
        {
#line 1888
        intr(2);
        }
      }
    }
#line 1888
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1889
  tmp___1 = __errno_location();
#line 1889
  tmp___2 = strerror(*tmp___1);
#line 1889
  puts((char const   *)tmp___2);
  }
#line 1890
  return ((char *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
  {
#line 1892
  rv = *(pglob.gl_pathv + 0);
#line 1893
  __h = & mainobstack;
#line 1893
  __o = __h;
#line 1893
  tmp___3 = strlen((char const   *)rv);
#line 1893
  __len = (int )tmp___3;
  }
#line 1893
  if ((unsigned long )((__o->next_free + __len) + 1) > (unsigned long )__o->chunk_limit) {
    {
#line 1893
    _obstack_newchunk(__o, __len + 1);
    }
  }
  {
#line 1893
  memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)rv,
         (size_t )__len);
#line 1893
  __o->next_free += __len;
#line 1893
  tmp___4 = __o->next_free;
#line 1893
  (__o->next_free) ++;
#line 1893
  *tmp___4 = (char)0;
#line 1893
  __o1 = __h;
#line 1893
  __value = (void *)__o1->object_base;
  }
#line 1893
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 1893
    __o1->maybe_empty_object = 1U;
  }
#line 1893
  if (sizeof(long ) < sizeof(void *)) {
#line 1893
    tmp___5 = __o1->object_base;
  } else {
#line 1893
    tmp___5 = (char *)0;
  }
#line 1893
  if (sizeof(long ) < sizeof(void *)) {
#line 1893
    tmp___6 = __o1->object_base;
  } else {
#line 1893
    tmp___6 = (char *)0;
  }
#line 1893
  __o1->next_free = tmp___5 + (((__o1->next_free - tmp___6) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 1893
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 1893
    __o1->next_free = __o1->chunk_limit;
  }
  {
#line 1893
  __o1->object_base = __o1->next_free;
#line 1893
  rv = (char *)__value;
#line 1894
  globfree(& pglob);
  }
  {
#line 1895
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1895
    suppressint --;
#line 1895
    if (suppressint == 0) {
#line 1895
      if (intpending) {
        {
#line 1895
        intr(2);
        }
      }
    }
#line 1895
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1896
  return (rv);
}
}
#line 1899 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void account(int argc , char **argv ) 
{ 
  char buf___0[128] ;
  char *ap ;
  size_t tmp ;

  {
#line 1904
  if (argc > 1) {
#line 1905
    buf___0[0] = (char)0;
    {
#line 1906
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1906
      if (! (argc > 1)) {
#line 1906
        goto while_break;
      }
      {
#line 1907
      argc --;
#line 1908
      argv ++;
#line 1909
      tmp = strlen((char const   *)(buf___0));
#line 1909
      strncat((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)*argv,
              sizeof(buf___0) - tmp);
#line 1910
      buf___0[sizeof(buf___0) - 1UL] = (char)0;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1912
    ap = buf___0;
  } else {
    {
#line 1915
    ap = getpass("Account:");
    }
  }
  {
#line 1917
  command("ACCT %s", ap);
  }
#line 1918
  return;
}
}
#line 1920 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
static void proxabort(int ignore ) 
{ 


  {
#line 1926
  if (! proxy) {
    {
#line 1927
    pswitch(1);
    }
  }
#line 1929
  if (connected) {
#line 1930
    proxflag = 1;
  } else {
#line 1933
    proxflag = 0;
  }
  {
#line 1935
  pswitch(0);
  }
#line 1936
  return;
}
}
#line 1938 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void doproxy(int argc , char **argv ) 
{ 
  register struct cmd *c ;
  sigjmp_buf jmploc ;
  sigjmp_buf * volatile  oldtoplevel ;
  int tmp ;
  int tmp___0 ;

  {
#line 1945
  if (argc < 2) {
    {
#line 1945
    tmp = another(& argc, & argv, "command");
    }
#line 1945
    if (! tmp) {
      {
#line 1946
      printf((char const   */* __restrict  */)"usage: %s command\n", *(argv + 0));
#line 1947
      code = -1;
      }
#line 1948
      return;
    }
  }
  {
#line 1950
  c = getcmd((char const   *)*(argv + 1));
  }
#line 1951
  if ((unsigned long )c == (unsigned long )((struct cmd *)-1)) {
    {
#line 1952
    printf((char const   */* __restrict  */)"?Ambiguous command\n");
#line 1953
    fflush(stdout);
#line 1954
    code = -1;
    }
#line 1955
    return;
  }
#line 1957
  if ((unsigned long )c == (unsigned long )((struct cmd *)0)) {
    {
#line 1958
    printf((char const   */* __restrict  */)"?Invalid command\n");
#line 1959
    fflush(stdout);
#line 1960
    code = -1;
    }
#line 1961
    return;
  }
#line 1963
  if (! c->c_proxy) {
    {
#line 1964
    printf((char const   */* __restrict  */)"?Invalid proxy command\n");
#line 1965
    fflush(stdout);
#line 1966
    code = -1;
    }
#line 1967
    return;
  }
  {
#line 1969
  oldtoplevel = (sigjmp_buf */* volatile  */)toplevel;
#line 1970
  tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(jmploc), 1);
  }
#line 1970
  if (tmp___0) {
    {
#line 1971
    proxabort(2);
#line 1972
    toplevel = (sigjmp_buf *)oldtoplevel;
#line 1973
    code = -1;
    }
#line 1974
    return;
  }
  {
#line 1976
  toplevel = & jmploc;
#line 1977
  pswitch(1);
  }
#line 1978
  if (c->c_conn) {
#line 1978
    if (! connected) {
      {
#line 1979
      printf((char const   */* __restrict  */)"Not connected\n");
#line 1980
      fflush(stdout);
#line 1981
      pswitch(0);
#line 1982
      toplevel = (sigjmp_buf *)oldtoplevel;
#line 1983
      code = -1;
      }
#line 1984
      return;
    }
  }
#line 1987
  if (c->c_handler_v) {
    {
#line 1987
    (*(c->c_handler_v))(argc - 1, argv + 1);
    }
  } else
#line 1988
  if (c->c_handler_0) {
    {
#line 1988
    (*(c->c_handler_0))();
    }
  } else {
    {
#line 1989
    (*(c->c_handler_1))((char const   *)((void *)0));
    }
  }
#line 1991
  if (connected) {
#line 1992
    proxflag = 1;
  } else {
#line 1995
    proxflag = 0;
  }
  {
#line 1997
  pswitch(0);
#line 1998
  toplevel = (sigjmp_buf *)oldtoplevel;
  }
#line 1999
  return;
}
}
#line 2001 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void setcase(void) 
{ 
  char const   *tmp ;

  {
  {
#line 2004
  mcase = ! mcase;
#line 2005
  tmp = onoff(mcase);
#line 2005
  printf((char const   */* __restrict  */)"Case mapping %s.\n", tmp);
#line 2006
  code = mcase;
  }
#line 2007
  return;
}
}
#line 2009 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void setcr(void) 
{ 
  char const   *tmp ;

  {
  {
#line 2012
  crflag = ! crflag;
#line 2013
  tmp = onoff(crflag);
#line 2013
  printf((char const   */* __restrict  */)"Carriage Return stripping %s.\n", tmp);
#line 2014
  code = crflag;
  }
#line 2015
  return;
}
}
#line 2017 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void setqc(void) 
{ 
  char const   *tmp ;

  {
  {
#line 2020
  qcflag = ! qcflag;
#line 2021
  tmp = onoff(qcflag);
#line 2021
  printf((char const   */* __restrict  */)"Quote control characters %s.\n", tmp);
#line 2022
  code = qcflag;
  }
#line 2023
  return;
}
}
#line 2025 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void setntrans(int argc , char **argv ) 
{ 


  {
#line 2028
  if (argc == 1) {
    {
#line 2029
    ntflag = 0;
#line 2030
    printf((char const   */* __restrict  */)"Ntrans off.\n");
#line 2031
    code = ntflag;
    }
#line 2032
    return;
  }
  {
#line 2034
  ntflag ++;
#line 2035
  code = ntflag;
#line 2036
  strncpy((char */* __restrict  */)(ntin), (char const   */* __restrict  */)*(argv + 1),
          (size_t )16);
#line 2037
  ntin[16] = (char )'\000';
  }
#line 2038
  if (argc == 2) {
#line 2039
    ntout[0] = (char )'\000';
#line 2040
    return;
  }
  {
#line 2042
  strncpy((char */* __restrict  */)(ntout), (char const   */* __restrict  */)*(argv + 2),
          (size_t )16);
#line 2043
  ntout[16] = (char )'\000';
  }
#line 2044
  return;
}
}
#line 2049 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
static char new___0[4096]  ;
#line 2046 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
static char *dotrans(char *name ) 
{ 
  char *cp1 ;
  char *cp2 ;
  register int i ;
  register int ostop ;
  register int found ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 2050
  cp2 = new___0;
#line 2053
  ostop = 0;
  {
#line 2053
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2053
    if (*(ntout + ostop)) {
#line 2053
      if (! (ostop < 16)) {
#line 2053
        goto while_break;
      }
    } else {
#line 2053
      goto while_break;
    }
#line 2053
    ostop ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2054
  cp1 = name;
  {
#line 2054
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2054
    if (! *cp1) {
#line 2054
      goto while_break___0;
    }
#line 2055
    found = 0;
#line 2056
    i = 0;
    {
#line 2056
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2056
      if (*(ntin + i)) {
#line 2056
        if (! (i < 16)) {
#line 2056
          goto while_break___1;
        }
      } else {
#line 2056
        goto while_break___1;
      }
#line 2057
      if ((int )*cp1 == (int )*(ntin + i)) {
#line 2058
        found ++;
#line 2059
        if (i < ostop) {
#line 2060
          tmp = cp2;
#line 2060
          cp2 ++;
#line 2060
          *tmp = *(ntout + i);
        }
#line 2062
        goto while_break___1;
      }
#line 2056
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2065
    if (! found) {
#line 2066
      tmp___0 = cp2;
#line 2066
      cp2 ++;
#line 2066
      *tmp___0 = *cp1;
    }
#line 2054
    cp1 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2069
  *cp2 = (char )'\000';
#line 2070
  return (new___0);
}
}
#line 2073 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void setnmap(int argc , char **argv ) 
{ 
  char *cp ;
  int tmp ;

  {
#line 2078
  if (argc == 1) {
    {
#line 2079
    mapflag = 0;
#line 2080
    printf((char const   */* __restrict  */)"Nmap off.\n");
#line 2081
    code = mapflag;
    }
#line 2082
    return;
  }
#line 2084
  if (argc < 3) {
    {
#line 2084
    tmp = another(& argc, & argv, "mapout");
    }
#line 2084
    if (! tmp) {
      {
#line 2085
      printf((char const   */* __restrict  */)"Usage: %s [mapin mapout]\n", *(argv + 0));
#line 2086
      code = -1;
      }
#line 2087
      return;
    }
  }
  {
#line 2089
  mapflag = 1;
#line 2090
  code = 1;
#line 2091
  cp = index((char const   *)altarg, ' ');
  }
#line 2092
  if (proxy) {
    {
#line 2093
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2093
      cp ++;
#line 2093
      if (! ((int )*cp == 32)) {
#line 2093
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2094
    altarg = cp;
#line 2095
    cp = index((char const   *)altarg, ' ');
    }
  }
  {
#line 2097
  *cp = (char )'\000';
#line 2098
  strncpy((char */* __restrict  */)(mapin), (char const   */* __restrict  */)altarg,
          sizeof(mapin) - 1UL);
#line 2099
  mapin[sizeof(mapin) - 1UL] = (char)0;
  }
  {
#line 2100
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2100
    cp ++;
#line 2100
    if (! ((int )*cp == 32)) {
#line 2100
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2101
  strncpy((char */* __restrict  */)(mapout), (char const   */* __restrict  */)cp,
          sizeof(mapout) - 1UL);
#line 2102
  mapout[sizeof(mapout) - 1UL] = (char)0;
  }
#line 2103
  return;
}
}
#line 2109 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
static char new___1[4096]  ;
#line 2105 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
static char *domap(char *name ) 
{ 
  register char *cp1 ;
  register char *cp2 ;
  char *tp[9] ;
  char *te[9] ;
  int i ;
  int toks[9] ;
  int toknum ;
  int match ;
  char *tmp ;
  char *cp3 ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *cp3___0 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *cp3___1 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *cp3___2 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  unsigned short const   **tmp___10 ;
  unsigned short const   **tmp___11 ;
  char *cp3___3 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *cp3___4 ;
  char *tmp___14 ;
  char *tmp___15 ;
  unsigned short const   **tmp___16 ;
  char *tmp___17 ;

  {
#line 2110
  cp1 = name;
#line 2110
  cp2 = mapin;
#line 2112
  toknum = 0;
#line 2112
  match = 1;
#line 2114
  i = 0;
  {
#line 2114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2114
    if (! (i < 9)) {
#line 2114
      goto while_break;
    }
#line 2115
    toks[i] = 0;
#line 2114
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2117
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2117
    if (match) {
#line 2117
      if (*cp1) {
#line 2117
        if (! *cp2) {
#line 2117
          goto while_break___0;
        }
      } else {
#line 2117
        goto while_break___0;
      }
    } else {
#line 2117
      goto while_break___0;
    }
    {
#line 2119
    if ((int )*cp2 == 92) {
#line 2119
      goto case_92;
    }
#line 2124
    if ((int )*cp2 == 36) {
#line 2124
      goto case_36;
    }
#line 2138
    goto switch_default;
    case_92: /* CIL Label */ 
#line 2120
    cp2 ++;
#line 2120
    if ((int )*cp2 != (int )*cp1) {
#line 2121
      match = 0;
    }
#line 2123
    goto switch_break;
    case_36: /* CIL Label */ 
#line 2125
    if ((int )*(cp2 + 1) >= 49) {
#line 2125
      if ((int )*(cp2 + 1) <= 57) {
#line 2126
        cp2 ++;
#line 2126
        if ((int )*cp1 != (int )*(cp2 + 1)) {
#line 2127
          toknum = (int )*cp2 - 49;
#line 2128
          (toks[toknum]) ++;
#line 2129
          tp[toknum] = cp1;
          {
#line 2130
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 2130
            cp1 ++;
#line 2130
            if (*cp1) {
#line 2130
              if (! ((int )*(cp2 + 1) != (int )*cp1)) {
#line 2130
                goto while_break___1;
              }
            } else {
#line 2130
              goto while_break___1;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 2132
          te[toknum] = cp1;
        }
#line 2134
        cp2 ++;
#line 2135
        goto switch_break;
      }
    }
    switch_default: /* CIL Label */ 
#line 2139
    if ((int )*cp2 != (int )*cp1) {
#line 2140
      match = 0;
    }
#line 2142
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2144
    if (match) {
#line 2144
      if (*cp1) {
#line 2145
        cp1 ++;
      }
    }
#line 2147
    if (match) {
#line 2147
      if (*cp2) {
#line 2148
        cp2 ++;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2151
  if (! match) {
#line 2151
    if (*cp1) {
#line 2153
      toks[toknum] = 0;
    }
  }
#line 2155
  cp1 = new___1;
#line 2156
  *cp1 = (char )'\000';
#line 2157
  cp2 = mapout;
  {
#line 2158
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2158
    if (! *cp2) {
#line 2158
      goto while_break___2;
    }
#line 2159
    match = 0;
    {
#line 2161
    if ((int )*cp2 == 92) {
#line 2161
      goto case_92___0;
    }
#line 2166
    if ((int )*cp2 == 91) {
#line 2166
      goto LOOP;
    }
#line 2244
    if ((int )*cp2 == 36) {
#line 2244
      goto case_36___0;
    }
#line 2263
    goto switch_default___1;
    case_92___0: /* CIL Label */ 
#line 2162
    if (*(cp2 + 1)) {
#line 2163
      tmp = cp1;
#line 2163
      cp1 ++;
#line 2163
      cp2 ++;
#line 2163
      *tmp = *cp2;
    }
#line 2165
    goto switch_break___0;
    LOOP: 
    case_91: /* CIL Label */ 
#line 2168
    cp2 ++;
#line 2168
    if ((int )*cp2 == 36) {
      {
#line 2168
      tmp___11 = __ctype_b_loc();
      }
#line 2168
      if ((int const   )*(*tmp___11 + (int )*(cp2 + 1)) & 2048) {
#line 2169
        cp2 ++;
#line 2169
        if ((int )*cp2 == 48) {
#line 2170
          cp3 = name;
          {
#line 2172
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 2172
            if (! *cp3) {
#line 2172
              goto while_break___3;
            }
#line 2173
            tmp___0 = cp1;
#line 2173
            cp1 ++;
#line 2173
            tmp___1 = cp3;
#line 2173
            cp3 ++;
#line 2173
            *tmp___0 = *tmp___1;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 2175
          match = 1;
        } else {
#line 2177
          toknum = (int )*cp2 - 49;
#line 2177
          if (toks[toknum]) {
#line 2178
            cp3___0 = tp[toknum];
            {
#line 2180
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 2180
              if (! ((unsigned long )cp3___0 != (unsigned long )te[toknum])) {
#line 2180
                goto while_break___4;
              }
#line 2181
              tmp___2 = cp1;
#line 2181
              cp1 ++;
#line 2181
              tmp___3 = cp3___0;
#line 2181
              cp3___0 ++;
#line 2181
              *tmp___2 = *tmp___3;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 2183
            match = 1;
          }
        }
      } else {
#line 2168
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 2187
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 2187
        if (*cp2) {
#line 2187
          if ((int )*cp2 != 44) {
#line 2187
            if (! ((int )*cp2 != 93)) {
#line 2187
              goto while_break___5;
            }
          } else {
#line 2187
            goto while_break___5;
          }
        } else {
#line 2187
          goto while_break___5;
        }
#line 2189
        if ((int )*cp2 == 92) {
#line 2190
          cp2 ++;
        } else
#line 2192
        if ((int )*cp2 == 36) {
          {
#line 2192
          tmp___10 = __ctype_b_loc();
          }
#line 2192
          if ((int const   )*(*tmp___10 + (int )*(cp2 + 1)) & 2048) {
#line 2194
            cp2 ++;
#line 2194
            if ((int )*cp2 == 48) {
#line 2195
              cp3___1 = name;
              {
#line 2197
              while (1) {
                while_continue___6: /* CIL Label */ ;
#line 2197
                if (! *cp3___1) {
#line 2197
                  goto while_break___6;
                }
#line 2198
                tmp___4 = cp1;
#line 2198
                cp1 ++;
#line 2198
                tmp___5 = cp3___1;
#line 2198
                cp3___1 ++;
#line 2198
                *tmp___4 = *tmp___5;
              }
              while_break___6: /* CIL Label */ ;
              }
            } else {
#line 2201
              toknum = (int )*cp2 - 49;
#line 2201
              if (toks[toknum]) {
#line 2203
                cp3___2 = tp[toknum];
                {
#line 2205
                while (1) {
                  while_continue___7: /* CIL Label */ ;
#line 2205
                  if (! ((unsigned long )cp3___2 != (unsigned long )te[toknum])) {
#line 2205
                    goto while_break___7;
                  }
#line 2207
                  tmp___6 = cp1;
#line 2207
                  cp1 ++;
#line 2207
                  tmp___7 = cp3___2;
#line 2207
                  cp3___2 ++;
#line 2207
                  *tmp___6 = *tmp___7;
                }
                while_break___7: /* CIL Label */ ;
                }
              }
            }
          } else {
#line 2192
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 2211
        if (*cp2) {
#line 2212
          tmp___8 = cp1;
#line 2212
          cp1 ++;
#line 2212
          tmp___9 = cp2;
#line 2212
          cp2 ++;
#line 2212
          *tmp___8 = *tmp___9;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 2215
      if (! *cp2) {
        {
#line 2216
        printf((char const   */* __restrict  */)"nmap: unbalanced brackets\n");
        }
#line 2217
        return (name);
      }
#line 2219
      match = 1;
#line 2220
      cp2 --;
    }
#line 2222
    if (match) {
      {
#line 2223
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 2223
        cp2 ++;
#line 2223
        if (*cp2) {
#line 2223
          if (! ((int )*cp2 != 93)) {
#line 2223
            goto while_break___8;
          }
        } else {
#line 2223
          goto while_break___8;
        }
#line 2224
        if ((int )*cp2 == 92) {
#line 2224
          if (*(cp2 + 1)) {
#line 2225
            cp2 ++;
          }
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 2228
      if (! *cp2) {
        {
#line 2229
        printf((char const   */* __restrict  */)"nmap: unbalanced brackets\n");
        }
#line 2230
        return (name);
      }
#line 2232
      goto switch_break___0;
    }
#line 2234
    cp2 ++;
    {
#line 2235
    if ((int )*cp2 == 44) {
#line 2235
      goto case_44;
    }
#line 2237
    if ((int )*cp2 == 93) {
#line 2237
      goto case_93;
    }
#line 2239
    goto switch_default___0;
    case_44: /* CIL Label */ 
#line 2236
    goto LOOP;
    case_93: /* CIL Label */ 
#line 2238
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
#line 2240
    cp2 --;
#line 2241
    goto LOOP;
    switch_break___1: /* CIL Label */ ;
    }
#line 2243
    goto switch_break___0;
    case_36___0: /* CIL Label */ 
    {
#line 2245
    tmp___16 = __ctype_b_loc();
    }
#line 2245
    if ((int const   )*(*tmp___16 + (int )*(cp2 + 1)) & 2048) {
#line 2246
      cp2 ++;
#line 2246
      if ((int )*cp2 == 48) {
#line 2247
        cp3___3 = name;
        {
#line 2249
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 2249
          if (! *cp3___3) {
#line 2249
            goto while_break___9;
          }
#line 2250
          tmp___12 = cp1;
#line 2250
          cp1 ++;
#line 2250
          tmp___13 = cp3___3;
#line 2250
          cp3___3 ++;
#line 2250
          *tmp___12 = *tmp___13;
        }
        while_break___9: /* CIL Label */ ;
        }
      } else {
#line 2253
        toknum = (int )*cp2 - 49;
#line 2253
        if (toks[toknum]) {
#line 2254
          cp3___4 = tp[toknum];
          {
#line 2256
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 2256
            if (! ((unsigned long )cp3___4 != (unsigned long )te[toknum])) {
#line 2256
              goto while_break___10;
            }
#line 2257
            tmp___14 = cp1;
#line 2257
            cp1 ++;
#line 2257
            tmp___15 = cp3___4;
#line 2257
            cp3___4 ++;
#line 2257
            *tmp___14 = *tmp___15;
          }
          while_break___10: /* CIL Label */ ;
          }
        }
      }
#line 2260
      goto switch_break___0;
    }
    switch_default___1: /* CIL Label */ 
#line 2264
    tmp___17 = cp1;
#line 2264
    cp1 ++;
#line 2264
    *tmp___17 = *cp2;
#line 2265
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 2267
    cp2 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2269
  *cp1 = (char )'\000';
#line 2270
  if (! new___1[0]) {
#line 2271
    return (name);
  }
#line 2273
  return (new___1);
}
}
#line 2276 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void setsunique(void) 
{ 
  char const   *tmp ;

  {
  {
#line 2279
  sunique = ! sunique;
#line 2280
  tmp = onoff(sunique);
#line 2280
  printf((char const   */* __restrict  */)"Store unique %s.\n", tmp);
#line 2281
  code = sunique;
  }
#line 2282
  return;
}
}
#line 2284 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void setrunique(void) 
{ 
  char const   *tmp ;

  {
  {
#line 2287
  runique = ! runique;
#line 2288
  tmp = onoff(runique);
#line 2288
  printf((char const   */* __restrict  */)"Receive unique %s.\n", tmp);
#line 2289
  code = runique;
  }
#line 2290
  return;
}
}
#line 2293 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void cdup(void) 
{ 
  int tmp ;

  {
  {
#line 2296
  tmp = command("CDUP");
  }
#line 2296
  if (tmp == 5) {
#line 2296
    if (code == 500) {
#line 2297
      if (verbose) {
        {
#line 2298
        printf((char const   */* __restrict  */)"CDUP command not recognized, trying XCUP\n");
        }
      }
      {
#line 2299
      command("XCUP");
      }
    }
  }
#line 2301
  return;
}
}
#line 2304 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void restart(int argc , char **argv ) 
{ 
  long long tmp ;

  {
#line 2307
  if (argc != 2) {
    {
#line 2308
    printf((char const   */* __restrict  */)"restart: offset not specified\n");
    }
  } else {
    {
#line 2310
    tmp = atoll((char const   *)*(argv + 1));
#line 2310
    restart_point = (off_t )tmp;
#line 2311
    printf((char const   */* __restrict  */)"restarting at %jd. %s\n", restart_point,
           "execute get, put or append to initiate transfer");
    }
  }
#line 2314
  return;
}
}
#line 2317 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void syst(void) 
{ 


  {
  {
#line 2320
  command("SYST");
  }
#line 2321
  return;
}
}
#line 2323 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void macdef(int argc , char **argv ) 
{ 
  char *tmp ;
  int c ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char tmp___3 ;
  int tmp___4 ;

  {
#line 2329
  if (macnum == 16) {
    {
#line 2330
    printf((char const   */* __restrict  */)"Limit of 16 macros have already been defined\n");
#line 2331
    code = -1;
    }
#line 2332
    return;
  }
#line 2334
  if (argc < 2) {
    {
#line 2334
    tmp___0 = another(& argc, & argv, "macro name");
    }
#line 2334
    if (! tmp___0) {
      {
#line 2335
      printf((char const   */* __restrict  */)"Usage: %s macro_name\n", *(argv + 0));
#line 2336
      code = -1;
      }
#line 2337
      return;
    }
  }
#line 2339
  if (interactive) {
    {
#line 2340
    printf((char const   */* __restrict  */)"Enter macro line by line, terminating it with a null line\n");
    }
  }
  {
#line 2342
  strncpy((char */* __restrict  */)(macros[macnum].mac_name), (char const   */* __restrict  */)*(argv + 1),
          (size_t )8);
#line 2343
  macros[macnum].mac_name[8] = (char)0;
  }
#line 2344
  if (macnum == 0) {
#line 2345
    macros[macnum].mac_start = macbuf;
  } else {
#line 2348
    macros[macnum].mac_start = macros[macnum - 1].mac_end + 1;
  }
#line 2350
  tmp = macros[macnum].mac_start;
  {
#line 2352
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2352
    if (! ((unsigned long )tmp != (unsigned long )(macbuf + 4096))) {
#line 2352
      goto while_break;
    }
    {
#line 2353
    c = getchar();
    }
#line 2353
    if (c == -1) {
      {
#line 2354
      printf((char const   */* __restrict  */)"macdef:end of file encountered\n");
#line 2355
      code = -1;
      }
#line 2356
      return;
    }
#line 2358
    tmp___3 = (char )c;
#line 2358
    *tmp = tmp___3;
#line 2358
    if ((int )tmp___3 == 10) {
#line 2359
      if ((unsigned long )tmp == (unsigned long )macros[macnum].mac_start) {
#line 2360
        tmp___1 = macnum;
#line 2360
        macnum ++;
#line 2360
        macros[tmp___1].mac_end = tmp;
#line 2361
        code = 0;
#line 2362
        return;
      }
#line 2364
      if ((int )*(tmp - 1) == 0) {
#line 2365
        tmp___2 = macnum;
#line 2365
        macnum ++;
#line 2365
        macros[tmp___2].mac_end = tmp - 1;
#line 2366
        code = 0;
#line 2367
        return;
      }
#line 2369
      *tmp = (char )'\000';
    }
#line 2371
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2373
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 2374
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 2374
      c = getchar();
      }
#line 2374
      if (c != 10) {
#line 2374
        if (! (c != -1)) {
#line 2374
          goto while_break___1;
        }
      } else {
#line 2374
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2376
    if (c == -1) {
      {
#line 2377
      printf((char const   */* __restrict  */)"Macro not defined - 4k buffer exceeded\n");
#line 2378
      code = -1;
      }
#line 2379
      return;
    } else {
      {
#line 2376
      tmp___4 = getchar();
      }
#line 2376
      if (tmp___4 == 10) {
        {
#line 2377
        printf((char const   */* __restrict  */)"Macro not defined - 4k buffer exceeded\n");
#line 2378
        code = -1;
        }
#line 2379
        return;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 2387 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void setpassive(void) 
{ 
  char const   *tmp ;

  {
  {
#line 2390
  passivemode = ! passivemode;
#line 2391
  tmp = onoff(passivemode);
#line 2391
  printf((char const   */* __restrict  */)"Passive mode %s.\n", tmp);
#line 2392
  code = passivemode;
  }
#line 2393
  return;
}
}
#line 2398 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void setipany(void) 
{ 


  {
  {
#line 2401
  usefamily = 0;
#line 2402
  printf((char const   */* __restrict  */)"Chosen addressing: %s.\n", "any");
#line 2403
  code = usefamily;
  }
#line 2404
  return;
}
}
#line 2409 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void setipv4(void) 
{ 


  {
  {
#line 2412
  usefamily = 2;
#line 2413
  printf((char const   */* __restrict  */)"Chosen addressing: %s.\n", "IPv4");
#line 2414
  code = usefamily;
  }
#line 2415
  return;
}
}
#line 2420 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void setipv6(void) 
{ 


  {
  {
#line 2423
  usefamily = 10;
#line 2424
  printf((char const   */* __restrict  */)"Chosen addressing: %s.\n", "IPv6");
#line 2425
  code = usefamily;
  }
#line 2426
  return;
}
}
#line 2431 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void sizecmd(int argc , char **argv ) 
{ 
  int tmp ;

  {
#line 2435
  if (argc < 2) {
    {
#line 2435
    tmp = another(& argc, & argv, "filename");
    }
#line 2435
    if (! tmp) {
      {
#line 2436
      printf((char const   */* __restrict  */)"usage: %s filename\n", *(argv + 0));
#line 2437
      code = -1;
      }
#line 2438
      return;
    }
  }
  {
#line 2440
  command("SIZE %s", *(argv + 1));
  }
#line 2441
  return;
}
}
#line 2446 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void modtime(int argc , char **argv ) 
{ 
  int overbose ;
  int tmp ;
  int yy ;
  int mo ;
  int day ;
  int hour ;
  int min ;
  int sec ;
  int tmp___0 ;

  {
#line 2451
  if (argc < 2) {
    {
#line 2451
    tmp = another(& argc, & argv, "filename");
    }
#line 2451
    if (! tmp) {
      {
#line 2452
      printf((char const   */* __restrict  */)"usage: %s filename\n", *(argv + 0));
#line 2453
      code = -1;
      }
#line 2454
      return;
    }
  }
#line 2456
  overbose = verbose;
#line 2457
  if (debug == 0) {
#line 2458
    verbose = -1;
  }
  {
#line 2459
  tmp___0 = command("MDTM %s", *(argv + 1));
  }
#line 2459
  if (tmp___0 == 2) {
    {
#line 2461
    sscanf((char const   */* __restrict  */)(reply_string), (char const   */* __restrict  */)"%*s %04d%02d%02d%02d%02d%02d",
           & yy, & mo, & day, & hour, & min, & sec);
#line 2464
    printf((char const   */* __restrict  */)"%s\t%02d/%02d/%04d %02d:%02d:%02d GMT\n",
           *(argv + 1), mo, day, yy, hour, min, sec);
    }
  } else {
    {
#line 2467
    printf((char const   */* __restrict  */)"%s\n", reply_string);
    }
  }
#line 2468
  verbose = overbose;
#line 2469
  return;
}
}
#line 2474 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void rmtstatus(int argc , char **argv ) 
{ 
  char const   *tmp ;

  {
#line 2477
  if (argc > 1) {
#line 2477
    tmp = "STAT %s";
  } else {
#line 2477
    tmp = "STAT";
  }
  {
#line 2477
  command(tmp, *(argv + 1));
  }
#line 2478
  return;
}
}
#line 2483 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
void newer(int argc , char **argv ) 
{ 
  int tmp ;

  {
  {
#line 2486
  tmp = getit(argc, argv, -1, "w");
  }
#line 2486
  if (tmp) {
    {
#line 2488
    printf((char const   */* __restrict  */)"Local file \"%s\" is newer than remote file \"%s\"\n",
           *(argv + 2), *(argv + 1));
    }
  }
#line 2491
  return;
}
}
#line 2496 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/cmds.c"
static void dosyst(void) 
{ 
  int overbose ;
  register char *cp ;
  register char c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2507
  overbose = verbose;
#line 2508
  if (debug == 0) {
#line 2509
    verbose = -1;
  }
  {
#line 2510
  tmp = command("SYST");
  }
#line 2510
  if (tmp == 2) {
#line 2510
    if (overbose) {
      {
#line 2511
      c = (char)0;
#line 2512
      cp = index((char const   *)(reply_string + 4), ' ');
      }
#line 2513
      if ((unsigned long )cp == (unsigned long )((void *)0)) {
        {
#line 2514
        cp = index((char const   *)(reply_string + 4), '\r');
        }
      }
#line 2515
      if (cp) {
#line 2516
        if ((int )*(cp + -1) == 46) {
#line 2517
          cp --;
        }
#line 2518
        c = *cp;
#line 2519
        *cp = (char )'\000';
      }
      {
#line 2522
      printf((char const   */* __restrict  */)"Remote system type is %s.\n", reply_string + 4);
      }
#line 2524
      if (cp) {
#line 2525
        *cp = c;
      }
    }
  }
  {
#line 2527
  tmp___1 = strncmp((char const   *)(reply_string), "215 UNIX Type: L8", (size_t )17);
  }
#line 2527
  if (tmp___1) {
#line 2544
    if (proxy) {
#line 2545
      unix_proxy = 0;
    } else {
#line 2547
      unix_server = 0;
    }
#line 2548
    if (overbose) {
      {
#line 2548
      tmp___0 = strncmp((char const   *)(reply_string), "215 TOPS20", (size_t )10);
      }
#line 2548
      if (! tmp___0) {
        {
#line 2550
        printf((char const   */* __restrict  */)"Remember to set tenex mode when transferring binary files from this machine.\n");
        }
      }
    }
  } else {
#line 2528
    if (proxy) {
#line 2529
      unix_proxy = 1;
    } else {
#line 2531
      unix_server = 1;
    }
    {
#line 2538
    type = 0;
#line 2539
    strcpy((char */* __restrict  */)(typename), (char const   */* __restrict  */)"binary");
    }
#line 2540
    if (overbose) {
      {
#line 2541
      printf((char const   */* __restrict  */)"Using %s mode to transfer files.\n",
             typename);
      }
    }
  }
#line 2553
  verbose = overbose;
#line 2557
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/domacro.c"
char domacro_rcsid[56]  = 
#line 37 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/domacro.c"
  {      (char )'$',      (char )'I',      (char )'d',      (char )':', 
        (char )' ',      (char )'d',      (char )'o',      (char )'m', 
        (char )'a',      (char )'c',      (char )'r',      (char )'o', 
        (char )'.',      (char )'c',      (char )',',      (char )'v', 
        (char )' ',      (char )'1',      (char )'.',      (char )'4', 
        (char )' ',      (char )'1',      (char )'9',      (char )'9', 
        (char )'6',      (char )'/',      (char )'0',      (char )'8', 
        (char )'/',      (char )'1',      (char )'4',      (char )' ', 
        (char )'2',      (char )'3',      (char )':',      (char )'2', 
        (char )'7',      (char )':',      (char )'2',      (char )'8', 
        (char )' ',      (char )'d',      (char )'h',      (char )'o', 
        (char )'l',      (char )'l',      (char )'a',      (char )'n', 
        (char )'d',      (char )' ',      (char )'E',      (char )'x', 
        (char )'p',      (char )' ',      (char )'$',      (char )'\000'};
#line 49 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/domacro.c"
static char *append(char *p , char const   *s ) 
{ 
  size_t slen ;
  size_t tmp ;
  struct obstack *__o ;
  int __len ;

  {
  {
#line 50
  tmp = strlen(s);
#line 50
  slen = tmp;
#line 52
  suppressint ++;
#line 53
  __o = & lineobstack;
#line 53
  __len = (int )slen;
  }
#line 53
  if (__o->chunk_limit - __o->next_free < (long )__len) {
    {
#line 53
    _obstack_newchunk(__o, __len);
    }
  }
#line 53
  __o->next_free += __len;
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    suppressint --;
#line 54
    if (suppressint == 0) {
#line 54
      if (intpending) {
        {
#line 54
        intr(2);
        }
      }
    }
#line 54
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 55
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)s, slen);
  }
#line 56
  return (p + slen);
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/netkit-ftp-0.17/ftp/domacro.c"
void domacro(int argc , char **argv ) 
{ 
  int margc ;
  char *marg ;
  char **margv ;
  register int i ;
  register int j ;
  register char *cp1 ;
  register char *cp2 ;
  int count ;
  int loopflg ;
  char *line2 ;
  struct cmd *c ;
  size_t len ;
  int tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  size_t tmp___2 ;
  struct obstack *__o ;
  int __len ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  char *tmp___6 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___7 ;
  char *tmp___8 ;
  struct obstack *__o___0 ;
  void *__obj ;
  char *tmp___9 ;
  struct obstack *__o___1 ;
  void *__obj___0 ;
  char *tmp___10 ;

  {
#line 67
  count = 2;
#line 67
  loopflg = 0;
#line 72
  if (argc < 2) {
    {
#line 72
    tmp = another(& argc, & argv, "macro name");
    }
#line 72
    if (! tmp) {
      {
#line 73
      printf((char const   */* __restrict  */)"Usage: %s macro_name.\n", *(argv + 0));
#line 74
      code = -1;
      }
#line 75
      return;
    }
  }
#line 77
  i = 0;
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (i < macnum)) {
#line 77
      goto while_break;
    }
    {
#line 78
    tmp___0 = strncmp((char const   *)*(argv + 1), (char const   *)(macros[i].mac_name),
                      (size_t )9);
    }
#line 78
    if (! tmp___0) {
#line 79
      goto while_break;
    }
#line 77
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  if (i == macnum) {
    {
#line 83
    printf((char const   */* __restrict  */)"\'%s\' macro not found.\n", *(argv + 1));
#line 84
    code = -1;
    }
#line 85
    return;
  }
#line 87
  line2 = line;
  TOP: 
#line 89
  cp1 = macros[i].mac_start;
  {
#line 90
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 90
    if (! ((unsigned long )cp1 != (unsigned long )macros[i].mac_end)) {
#line 90
      goto while_break___0;
    }
    {
#line 91
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 91
      tmp___1 = __ctype_b_loc();
      }
#line 91
      if (! ((int const   )*(*tmp___1 + (int )*cp1) & 8192)) {
#line 91
        goto while_break___1;
      }
#line 92
      cp1 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 94
    tmp___2 = strlen((char const   *)cp1);
#line 94
    len = tmp___2 + 1UL;
#line 95
    suppressint ++;
#line 96
    __o = & lineobstack;
#line 96
    __len = (int )len;
    }
#line 96
    if (__o->chunk_limit - __o->next_free < (long )__len) {
      {
#line 96
      _obstack_newchunk(__o, __len);
      }
    }
#line 96
    __o->next_free += __len;
    {
#line 97
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 97
      suppressint --;
#line 97
      if (suppressint == 0) {
#line 97
        if (intpending) {
          {
#line 97
          intr(2);
          }
        }
      }
#line 97
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 98
    cp2 = (char *)((void *)lineobstack.object_base);
    {
#line 99
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 99
      if (! ((int )*cp1 != 0)) {
#line 99
        goto while_break___3;
      }
      {
#line 101
      if ((int )*cp1 == 92) {
#line 101
        goto case_92;
      }
#line 104
      if ((int )*cp1 == 36) {
#line 104
        goto case_36;
      }
#line 125
      goto switch_default;
      case_92: /* CIL Label */ 
#line 102
      tmp___3 = cp2;
#line 102
      cp2 ++;
#line 102
      cp1 ++;
#line 102
      *tmp___3 = *cp1;
#line 103
      goto switch_break;
      case_36: /* CIL Label */ 
      {
#line 105
      tmp___5 = __ctype_b_loc();
      }
#line 105
      if ((int const   )*(*tmp___5 + (int )*(cp1 + 1)) & 2048) {
#line 106
        j = 0;
        {
#line 107
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 107
          tmp___4 = __ctype_b_loc();
#line 107
          cp1 ++;
          }
#line 107
          if (! ((int const   )*(*tmp___4 + (int )*cp1) & 2048)) {
#line 107
            goto while_break___4;
          }
#line 108
          j = (10 * j + (int )*cp1) - 48;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 110
        cp1 --;
#line 111
        if (argc - 2 >= j) {
          {
#line 112
          cp2 = append(cp2, (char const   *)*(argv + (j + 1)));
          }
        }
#line 114
        goto switch_break;
      }
#line 116
      if ((int )*(cp1 + 1) == 105) {
#line 117
        loopflg = 1;
#line 118
        cp1 ++;
#line 119
        if (count < argc) {
          {
#line 120
          cp2 = append(cp2, (char const   *)*(argv + count));
          }
        }
#line 122
        goto switch_break;
      }
      switch_default: /* CIL Label */ 
#line 126
      tmp___6 = cp2;
#line 126
      cp2 ++;
#line 126
      *tmp___6 = *cp1;
#line 127
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 129
      if ((int )*cp1 != 0) {
#line 130
        cp1 ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 133
    *cp2 = (char )'\000';
#line 134
    __o1 = & lineobstack;
#line 134
    __value = (void *)__o1->object_base;
#line 134
    if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 134
      __o1->maybe_empty_object = 1U;
    }
#line 134
    if (sizeof(long ) < sizeof(void *)) {
#line 134
      tmp___7 = __o1->object_base;
    } else {
#line 134
      tmp___7 = (char *)0;
    }
#line 134
    if (sizeof(long ) < sizeof(void *)) {
#line 134
      tmp___8 = __o1->object_base;
    } else {
#line 134
      tmp___8 = (char *)0;
    }
#line 134
    __o1->next_free = tmp___7 + (((__o1->next_free - tmp___8) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 134
    if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 134
      __o1->next_free = __o1->chunk_limit;
    }
    {
#line 134
    __o1->object_base = __o1->next_free;
#line 134
    line = (char *)__value;
#line 135
    margv = makeargv(& margc, & marg);
#line 136
    c = getcmd((char const   *)*(margv + 0));
    }
#line 137
    if ((unsigned long )c == (unsigned long )((struct cmd *)-1)) {
      {
#line 138
      printf((char const   */* __restrict  */)"?Ambiguous command\n");
#line 139
      code = -1;
      }
    } else
#line 141
    if ((unsigned long )c == (unsigned long )((void *)0)) {
      {
#line 142
      printf((char const   */* __restrict  */)"?Invalid command\n");
#line 143
      code = -1;
      }
    } else
#line 145
    if (c->c_conn) {
#line 145
      if (! connected) {
        {
#line 146
        printf((char const   */* __restrict  */)"Not connected.\n");
#line 147
        code = -1;
        }
      } else {
#line 145
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 150
      if (verbose) {
        {
#line 151
        printf((char const   */* __restrict  */)"%s\n", line);
        }
      }
#line 153
      if (c->c_handler_v) {
        {
#line 153
        (*(c->c_handler_v))(margc, margv);
        }
      } else
#line 154
      if (c->c_handler_0) {
        {
#line 154
        (*(c->c_handler_0))();
        }
      } else {
        {
#line 155
        (*(c->c_handler_1))((char const   *)marg);
        }
      }
#line 157
      if (bell) {
#line 157
        if (c->c_bell) {
          {
#line 158
          putchar('\a');
          }
        }
      }
#line 160
      suppressint ++;
#line 161
      __o___0 = & lineobstack;
#line 161
      __obj = (void *)line;
#line 161
      if ((unsigned long )__obj > (unsigned long )((void *)__o___0->chunk)) {
#line 161
        if ((unsigned long )__obj < (unsigned long )((void *)__o___0->chunk_limit)) {
#line 161
          tmp___9 = (char *)__obj;
#line 161
          __o___0->object_base = tmp___9;
#line 161
          __o___0->next_free = tmp___9;
        } else {
          {
#line 161
          obstack_free(__o___0, __obj);
          }
        }
      } else {
        {
#line 161
        obstack_free(__o___0, __obj);
        }
      }
      {
#line 162
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 162
        suppressint --;
#line 162
        if (suppressint == 0) {
#line 162
          if (intpending) {
            {
#line 162
            intr(2);
            }
          }
        }
#line 162
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 163
      line = line2;
#line 164
      margv = makeargv(& margc, & marg);
#line 165
      argc = margc;
#line 166
      argv = margv;
      }
    }
#line 168
    if ((unsigned long )line != (unsigned long )line2) {
#line 169
      suppressint ++;
#line 170
      __o___1 = & lineobstack;
#line 170
      __obj___0 = (void *)line;
#line 170
      if ((unsigned long )__obj___0 > (unsigned long )((void *)__o___1->chunk)) {
#line 170
        if ((unsigned long )__obj___0 < (unsigned long )((void *)__o___1->chunk_limit)) {
#line 170
          tmp___10 = (char *)__obj___0;
#line 170
          __o___1->object_base = tmp___10;
#line 170
          __o___1->next_free = tmp___10;
        } else {
          {
#line 170
          obstack_free(__o___1, __obj___0);
          }
        }
      } else {
        {
#line 170
        obstack_free(__o___1, __obj___0);
        }
      }
      {
#line 171
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 171
        suppressint --;
#line 171
        if (suppressint == 0) {
#line 171
          if (intpending) {
            {
#line 171
            intr(2);
            }
          }
        }
#line 171
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 173
    if ((unsigned long )cp1 != (unsigned long )macros[i].mac_end) {
#line 174
      cp1 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 177
  if (loopflg) {
#line 177
    count ++;
#line 177
    if (count < argc) {
#line 178
      goto TOP;
    }
  }
#line 180
  line = line2;
#line 181
  return;
}
}
