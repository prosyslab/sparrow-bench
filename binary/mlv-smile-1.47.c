/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 30 "include/struct_tab.h"
typedef unsigned char Bit_Tab;
#line 34 "include/structures.h"
struct _Noeud {
   int debut ;
   int sequence_number ;
   int fin ;
   struct _Noeud *suffixe_link ;
   struct _Noeud **fils ;
   Bit_Tab *sequences ;
   int nb_element_bt ;
};
#line 34 "include/structures.h"
typedef struct _Noeud Noeud;
#line 26 "Spell/include/occ.h"
struct liste_occ {
   Noeud *x ;
   int lon ;
   int xerr ;
   int saut ;
   int blocerr ;
   int codesaut ;
   int num ;
};
#line 26 "Spell/include/occ.h"
typedef struct liste_occ *P_occ;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 27 "include/structures.h"
struct _Liste_Pos {
   int *tab[2] ;
   int last_cell ;
   int tab_size ;
};
#line 27 "include/structures.h"
typedef struct _Liste_Pos ListePositions;
#line 45 "include/structures.h"
struct _Feuille {
   int debut ;
   int sequence_number ;
   int fin_deb ;
   Bit_Tab *sequences ;
};
#line 45 "include/structures.h"
typedef struct _Feuille Feuille;
#line 53 "include/structures.h"
struct _Liste {
   struct _Liste *suiv ;
   Feuille *feuille ;
};
#line 53 "include/structures.h"
typedef struct _Liste Liste;
#line 37 "grep+/Spell/include/global.h"
typedef char Flag;
#line 31 "grep+/Spell/include/criteres.h"
struct struct_fourchette {
   int min ;
   int max ;
};
#line 31 "grep+/Spell/include/criteres.h"
typedef struct struct_fourchette Fourchette;
#line 42 "grep+/Spell/include/criteres.h"
struct struct_criteres {
   Fourchette *longbloc ;
   Fourchette *saut ;
   int *maxerrblocs ;
   int **code2Sauts ;
   char alphaseq[128] ;
   char ficalph[128] ;
   long nbsymb ;
   Fourchette longmod ;
   int maxerr ;
   int nbtotseq ;
   signed char bloc ;
   Flag multiblocs ;
};
#line 42 "grep+/Spell/include/criteres.h"
typedef struct struct_criteres Criteres;
#line 42 "grep+/Spell/include/criteres.h"
typedef struct struct_criteres *P_Criteres;
#line 39 "grep+/Spell/include/alphabet.h"
typedef unsigned char Symbole;
#line 46 "grep+/Spell/include/grep+.h"
struct struct_arbre {
   Noeud *arbre ;
   signed char **text ;
   int nbtxt ;
};
#line 46 "grep+/Spell/include/grep+.h"
typedef struct struct_arbre Arbre;
#line 26 "include/mot.h"
struct struct_mot {
   char *mot ;
   char *codes ;
   float quorum_reel ;
   float khi2 ;
   float moyenne_shuffle ;
   float zscore ;
   float sigma ;
   unsigned int nbseq_vrai ;
   unsigned int nbseq_faux ;
   unsigned int nboccex_vrai ;
   unsigned int nboccex_faux ;
   float moyenne_shuffle_occ ;
   float khi2_occ ;
   float zscore_occ ;
   float sigma_occ ;
   char sign_occ ;
   char sign ;
};
#line 26 "include/mot.h"
typedef struct struct_mot Mot;
#line 26 "Spell/include/occ.h"
typedef struct liste_occ Occ;
#line 79 "include/Gtypes.h"
typedef int Int32;
#line 86 "include/Gtypes.h"
typedef int Bool;
#line 55 "include/libfasta.h"
struct __anonstruct_FastaSequence_11 {
   Bool ok ;
   Int32 length ;
   Int32 offset ;
   Int32 bufsize ;
   char name[64] ;
   char comment[512] ;
   char *seq ;
};
#line 55 "include/libfasta.h"
typedef struct __anonstruct_FastaSequence_11 FastaSequence;
#line 55 "include/libfasta.h"
typedef struct __anonstruct_FastaSequence_11 *FastaSequencePtr;
#line 34 "Spell/include/pile_occ.h"
struct struct_pile_occ {
   Occ *occ ;
   unsigned int *carte ;
   unsigned int pos_carte ;
   unsigned int size_carte ;
   unsigned int size ;
   int pos ;
};
#line 34 "Spell/include/pile_occ.h"
typedef struct struct_pile_occ *P_PileOcc;
#line 28 "Spell/include/model.h"
struct model {
   int *name ;
   int lon ;
   int taille ;
};
#line 28 "Spell/include/model.h"
typedef struct model *P_mod;
#line 34 "Spell/include/pile_occ.h"
typedef struct struct_pile_occ PileOcc;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 37 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/alphabet.c"
enum __anonenum_type_12 {
    DNA = 0,
    PROTEINS = 1,
    UNKNOWN = 2
} ;
#line 28 "Spell/include/model.h"
typedef struct model Mod;
#line 61 "include/allocateurs.h"
struct _cell {
   struct _cell *suivant ;
   unsigned char *data ;
   int current ;
   int max ;
};
#line 61 "include/allocateurs.h"
typedef struct _cell Alloc_Cell;
#line 69 "include/allocateurs.h"
struct _allocateur {
   Alloc_Cell *first ;
   Alloc_Cell *last ;
};
#line 69 "include/allocateurs.h"
typedef struct _allocateur Allocateur;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 59 "/usr/include/time.h"
typedef __clock_t clock_t;
#line 34 "/usr/include/x86_64-linux-gnu/sys/times.h"
struct tms {
   clock_t tms_utime ;
   clock_t tms_stime ;
   clock_t tms_cutime ;
   clock_t tms_cstime ;
};
#line 38 "Spell/include/criteres.h"
struct struct_criteres___0 {
   int **compobloc ;
   int *maxerrblocs ;
   int *compo ;
   Fourchette *longbloc ;
   Fourchette *saut ;
   Flag *flag_compobloc ;
   int *palindrom ;
   long nbsymb ;
   Fourchette longueur ;
   int maxerr ;
   int quorum ;
   char bloc ;
   Flag flag_compo ;
   Flag multiblocs ;
   Flag flag_palindrom ;
};
#line 38 "Spell/include/criteres.h"
typedef struct struct_criteres___0 *P_Criteres___0;
#line 38 "Spell/include/criteres.h"
typedef struct struct_criteres___0 Criteres___0;
#line 38 "Spell/include/criteres.h"
struct struct_criteres___1 {
   int **compobloc ;
   int *maxerrblocs ;
   int *compo ;
   Fourchette *longbloc ;
   Fourchette *saut ;
   int *delta ;
   Flag *flag_compobloc ;
   int *palindrom ;
   long nbsymb ;
   Fourchette longueur ;
   int maxerr ;
   int maxinter ;
   int maxsaut ;
   int quorum ;
   char bloc ;
   Flag flag_compo ;
   Flag flag_palindrom ;
};
#line 38 "Spell/include/criteres.h"
typedef struct struct_criteres___1 *P_Criteres___1;
#line 38 "Spell/include/criteres.h"
typedef struct struct_criteres___1 Criteres___1;
#line 23 "include/define.h"
int ALPHA_CARD  ;
#line 36 "Spell/include/occ.h"
void initOcc(P_occ o ) ;
#line 22 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/occ.c"
void initOcc(P_occ o ) 
{ 


  {
#line 25
  o->x = (Noeud *)((void *)0);
#line 26
  o->num = -1;
#line 27
  o->lon = -1;
#line 28
  o->xerr = -1;
#line 29
  o->blocerr = -1;
#line 30
  o->saut = 0;
#line 31
  o->codesaut = 0;
#line 32
  return;
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 63 "include/structures.h"
unsigned char **Sequence ;
#line 64
ListePositions *Liste_positions_fin ;
#line 66
int global_indice ;
#line 67
int current_sequence ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 29 "include/liste_pos.h"
ListePositions *Alloc_ListePositions(int size ) ;
#line 31
int Ajoute_Position_Liste(ListePositions *lpos , int *deb_liste , int position , int change_seq ) ;
#line 33
void setListeValue(ListePositions *lpos , int i , int value ) ;
#line 30 "include/bit_tab.h"
void addBitTabValue(Bit_Tab **tab , int value ) ;
#line 51 "include/allocateurs.h"
Noeud *Alloc_Noeud(void) ;
#line 52
Feuille *Alloc_Feuille(void) ;
#line 53
Liste *Alloc_Liste(void) ;
#line 54
void Free_Liste(Liste *l ) ;
#line 33 "include/global_fonctions.h"
void Ajoute_Fils_Au_Noeud(Noeud *N , Noeud *F ) ;
#line 34
Noeud *Get_Child_Start_Letter(Noeud *N , int indice ) ;
#line 35
int seg_taille(Noeud *N ) ;
#line 37
Noeud *Add_Fast_String(Noeud *N , int deb , int fin , int *type___0 , Noeud **pere ) ;
#line 57
Noeud *FindString(Noeud *N , int deb , int fin , Noeud **pere , int *restant , int *pos_in_edge ) ;
#line 27 "include/construction.h"
Noeud *Construction_Arbre(unsigned char *S , int taille_fenetre ) ;
#line 29
void Premiere_Phase(Noeud *Racine , int taille_fenetre , Liste **debut_liste , Liste **fin_liste ,
                    Noeud **fin_liste_pere , int *nb_element_liste , int start_indice ) ;
#line 37
int Deuxieme_Phase(Noeud *Racine , int taille_fenetre , Liste **debut_liste , Liste **fin_liste ,
                   Noeud **fin_liste_pere , int *nb_element_liste , int start_indice ,
                   int fict , int ini_res_type ) ;
#line 47
void Troisieme_Phase(Noeud *Racine , int taille_fenetre , Liste **debut_liste , Liste **fin_liste ,
                     Noeud **fin_liste_pere , int *nb_element_liste , int fictive ) ;
#line 55
Noeud *AjouteSequence(Noeud *Arbre , unsigned char *S , int taille_fenetre ) ;
#line 57
void CloseTheFirstPhase(Liste **debut_liste , Liste **fin_liste , Noeud **fin_liste_pere ) ;
#line 62
Noeud *CaseOneAddSequence(Noeud *Arbre , int taille_fenetre ) ;
#line 64
Noeud *CaseTwoAddSequence(Noeud *Arbre , Noeud *resultat , Noeud *pere , int taille_fenetre ) ;
#line 66
Noeud *CaseTreeAddSequence(Noeud *Arbre , Noeud *resultat , int deb , int fin , int taille_fenetre ) ;
#line 68
Noeud *CaseFourAddSequence(Noeud *Arbre , Noeud *resultat , Noeud *pere , int res_type ,
                           int position_arc , int i , int taille_fenetre ) ;
#line 22 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/construction.c"
Noeud *Construction_Arbre(unsigned char *S , int taille_fenetre ) 
{ 
  Liste *Debut_liste ;
  Liste *tmp ;
  Liste *Fin_liste ;
  Noeud *Fin_liste_pere ;
  int nb_element ;
  int fictive ;
  Noeud *Racine ;
  Noeud *tmp___0 ;
  Feuille *feuille ;
  Feuille *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
  {
#line 24
  tmp = Alloc_Liste();
#line 24
  Debut_liste = tmp;
#line 25
  Fin_liste = (Liste *)((void *)0);
#line 31
  tmp___0 = Alloc_Noeud();
#line 31
  Racine = tmp___0;
#line 32
  tmp___1 = Alloc_Feuille();
#line 32
  feuille = tmp___1;
  }
#line 34
  if (! S) {
    {
#line 36
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Construction_Arbre : Invalide String\nProgram Abord\n");
#line 37
    exit(-1);
    }
  }
#line 40
  if (taille_fenetre <= 0) {
    {
#line 42
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Construction_Arbre: taille fenetre = 0!\n");
#line 43
    exit(-1);
    }
  }
  {
#line 46
  *(Sequence + 0) = S;
#line 48
  tmp___2 = strlen((char const   *)S);
#line 48
  Liste_positions_fin = Alloc_ListePositions((int )(tmp___2 * 20UL));
#line 50
  feuille->debut = (-0x7FFFFFFF-1);
#line 51
  Ajoute_Position_Liste(Liste_positions_fin, & feuille->fin_deb, -1, 0);
#line 53
  Fin_liste_pere = Racine;
#line 55
  nb_element = 1;
#line 56
  Debut_liste->feuille = feuille;
#line 57
  Fin_liste = Debut_liste;
#line 59
  Ajoute_Fils_Au_Noeud(Racine, (Noeud *)feuille);
#line 61
  tmp___4 = strlen((char const   *)S);
  }
#line 61
  if ((size_t )taille_fenetre >= tmp___4) {
    {
#line 62
    tmp___3 = strlen((char const   *)S);
#line 62
    taille_fenetre = (int )tmp___3;
    }
  }
  {
#line 64
  Premiere_Phase(Racine, taille_fenetre, & Debut_liste, & Fin_liste, & Fin_liste_pere,
                 & nb_element, 2);
#line 68
  fictive = Deuxieme_Phase(Racine, taille_fenetre, & Debut_liste, & Fin_liste, & Fin_liste_pere,
                           & nb_element, taille_fenetre, 0, 0);
#line 73
  Troisieme_Phase(Racine, taille_fenetre, & Debut_liste, & Fin_liste, & Fin_liste_pere,
                  & nb_element, fictive);
  }
#line 86
  return (Racine);
}
}
#line 89 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/construction.c"
void Premiere_Phase(Noeud *Racine , int taille_fenetre , Liste **debut_liste , Liste **fin_liste ,
                    Noeud **fin_liste_pere , int *nb_element_liste , int start_indice ) 
{ 
  int i ;
  int j ;
  int result_type ;
  Noeud *result ;
  Noeud *result_pere ;
  Noeud *last_created_node ;
  int tmp ;
  int tmp___0 ;

  {
#line 105
  i = start_indice;
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if (! (i < taille_fenetre)) {
#line 105
      goto while_break;
    }
    {
#line 108
    result = *fin_liste_pere;
#line 110
    last_created_node = (Noeud *)((void *)0);
#line 112
    global_indice = i;
#line 115
    tmp = seg_taille((Noeud *)(*fin_liste)->feuille);
#line 115
    result_type = - tmp;
#line 117
    j = *nb_element_liste;
    }
    {
#line 117
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 117
      if (! (j < i)) {
#line 117
        goto while_break___0;
      }
#line 121
      if (! result) {
        {
#line 122
        result = Add_Fast_String(Racine, j, i, & result_type, & result_pere);
        }
      } else
#line 121
      if ((unsigned long )result == (unsigned long )Racine) {
        {
#line 122
        result = Add_Fast_String(Racine, j, i, & result_type, & result_pere);
        }
      } else
#line 121
      if (! result->suffixe_link) {
        {
#line 122
        result = Add_Fast_String(Racine, j, i, & result_type, & result_pere);
        }
      } else {
        {
#line 125
        result = Add_Fast_String(result->suffixe_link, i + result_type, i, & result_type,
                                 & result_pere);
        }
      }
#line 130
      if (result_type == 1) {
#line 130
        goto _L;
      } else
#line 130
      if (result_type == 3) {
        _L: /* CIL Label */ 
        {
#line 133
        setListeValue(Liste_positions_fin, ((Feuille *)result)->fin_deb, -1);
#line 135
        (*fin_liste)->suiv = Alloc_Liste();
#line 136
        *fin_liste = (*fin_liste)->suiv;
#line 137
        (*fin_liste)->feuille = (Feuille *)result;
#line 140
        *fin_liste_pere = result_pere;
#line 142
        (*nb_element_liste) ++;
        }
#line 144
        if (last_created_node) {
#line 145
          last_created_node->suffixe_link = result_pere;
        }
#line 149
        last_created_node = (Noeud *)((void *)0);
#line 151
        if (result_type == 3) {
#line 152
          last_created_node = result_pere;
        }
      } else
#line 156
      if (result_type < 0) {
#line 159
        if (last_created_node) {
#line 161
          last_created_node->suffixe_link = result;
        }
#line 163
        last_created_node = (Noeud *)((void *)0);
#line 165
        goto while_break___0;
      } else {
#line 169
        last_created_node = (Noeud *)((void *)0);
      }
#line 171
      if (result_type > 0) {
#line 176
        if (result_type == 3) {
          {
#line 182
          tmp___0 = seg_taille(result_pere);
#line 182
          result_type = - (tmp___0 + 1);
#line 183
          result = result_pere->suffixe_link;
#line 184
          result_pere->suffixe_link = (struct _Noeud *)((void *)0);
          }
        } else {
#line 190
          result_type = -1;
#line 192
          result = result_pere;
        }
      }
#line 117
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 105
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 197
  return;
}
}
#line 199 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/construction.c"
int Deuxieme_Phase(Noeud *Racine , int taille_fenetre , Liste **debut_liste , Liste **fin_liste ,
                   Noeud **fin_liste_pere , int *nb_element_liste , int start_indice ,
                   int fict , int ini_res_type ) 
{ 
  int i ;
  int j ;
  int result_type ;
  int taille_sequence ;
  int fictive ;
  Liste *tmp_liste ;
  Noeud *result ;
  Noeud *result_pere ;
  Noeud *last_created_node ;
  Feuille *tmp_feuille ;
  Noeud *tmp_noeud ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  Noeud *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 210
  result_type = ini_res_type;
#line 212
  fictive = fict;
#line 223
  tmp = strlen((char const   *)*(Sequence + current_sequence));
#line 223
  taille_sequence = (int )tmp;
#line 226
  i = start_indice;
  }
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 226
    if (! (i < taille_sequence)) {
#line 226
      goto while_break;
    }
#line 229
    result = *fin_liste_pere;
#line 231
    last_created_node = (Noeud *)((void *)0);
#line 233
    global_indice = i;
#line 236
    if (result_type > 0) {
#line 237
      result_type = - result_type;
    } else {
      {
#line 239
      tmp___0 = seg_taille((Noeud *)(*fin_liste)->feuille);
#line 239
      result_type = - tmp___0;
      }
    }
#line 241
    if (fictive) {
      {
#line 247
      tmp_noeud = result;
#line 249
      result = Add_Fast_String(result, i + result_type, i, & result_type, & result_pere);
      }
#line 250
      if (result_type == 1) {
#line 252
        result_type = -1;
#line 253
        result = result_pere;
      } else
#line 257
      if (result_type == 3) {
        {
#line 263
        tmp___1 = seg_taille(result_pere);
#line 263
        result_type = - (tmp___1 + 1);
#line 264
        result = result_pere->suffixe_link;
#line 265
        result_pere->suffixe_link = (struct _Noeud *)((void *)0);
#line 266
        last_created_node = result_pere;
        }
      } else
#line 269
      if (result_type == 2) {
        {
#line 271
        tmp___2 = seg_taille(result);
#line 271
        result_type = - tmp___2;
#line 272
        result = tmp_noeud;
        }
      }
    } else {
      {
#line 283
      setListeValue(Liste_positions_fin, ((*debut_liste)->feuille)->fin_deb, i);
      }
#line 284
      if (result_type > 0) {
#line 285
        result_type = - result_type;
      } else {
        {
#line 287
        tmp___3 = seg_taille((Noeud *)(*fin_liste)->feuille);
#line 287
        result_type = - tmp___3;
        }
      }
    }
#line 290
    fictive = 0;
#line 292
    j = *nb_element_liste;
    {
#line 292
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 292
      if (! (j < i)) {
#line 292
        goto while_break___0;
      }
#line 296
      result_pere = (Noeud *)((void *)0);
#line 298
      if (! result) {
        {
#line 299
        result = Add_Fast_String(Racine, j, i, & result_type, & result_pere);
        }
      } else
#line 298
      if ((unsigned long )result == (unsigned long )Racine) {
        {
#line 299
        result = Add_Fast_String(Racine, j, i, & result_type, & result_pere);
        }
      } else
#line 298
      if (! result->suffixe_link) {
        {
#line 299
        result = Add_Fast_String(Racine, j, i, & result_type, & result_pere);
        }
      } else {
        {
#line 302
        result = Add_Fast_String(result->suffixe_link, i + result_type, i, & result_type,
                                 & result_pere);
        }
      }
#line 306
      if (result_type == 1) {
#line 306
        goto _L;
      } else
#line 306
      if (result_type == 3) {
        _L: /* CIL Label */ 
        {
#line 309
        setListeValue(Liste_positions_fin, ((Feuille *)result)->fin_deb, -1);
#line 311
        (*fin_liste)->suiv = Alloc_Liste();
#line 312
        *fin_liste = (*fin_liste)->suiv;
#line 313
        (*fin_liste)->feuille = (Feuille *)result;
#line 316
        *fin_liste_pere = result_pere;
#line 318
        (*nb_element_liste) ++;
        }
#line 320
        if (last_created_node) {
#line 321
          last_created_node->suffixe_link = result_pere;
        }
#line 325
        last_created_node = (Noeud *)((void *)0);
#line 327
        if (result_type == 3) {
#line 328
          last_created_node = result_pere;
        }
      } else
#line 332
      if (result_type < 0) {
#line 335
        if (last_created_node) {
#line 336
          last_created_node->suffixe_link = result;
        }
#line 337
        last_created_node = (Noeud *)((void *)0);
#line 341
        if (*nb_element_liste == (i - taille_fenetre) + 1) {
          {
#line 351
          tmp___4 = Get_Child_Start_Letter(result, i + result_type);
#line 351
          tmp_feuille = (Feuille *)tmp___4;
#line 353
          tmp___5 = seg_taille((Noeud *)tmp_feuille);
          }
#line 353
          if (- tmp___5 == result_type) {
#line 354
            result_type = 1;
          }
#line 355
          if ((unsigned int )tmp_feuille->debut & 2147483648U) {
            {
#line 357
            *fin_liste_pere = result;
#line 358
            (*fin_liste)->suiv = Alloc_Liste();
#line 359
            *fin_liste = (*fin_liste)->suiv;
#line 360
            (*fin_liste)->feuille = tmp_feuille;
#line 361
            (*nb_element_liste) ++;
            }
          } else {
            {
#line 365
            *fin_liste_pere = (Noeud *)tmp_feuille;
#line 366
            (*fin_liste)->suiv = Alloc_Liste();
#line 367
            *fin_liste = (*fin_liste)->suiv;
#line 368
            (*fin_liste)->feuille = tmp_feuille;
#line 369
            (*nb_element_liste) ++;
            }
          }
#line 371
          fictive = 1;
        }
#line 377
        goto while_break___0;
      } else {
#line 380
        last_created_node = (Noeud *)((void *)0);
      }
#line 382
      if (result_type > 0) {
#line 386
        if (result_type == 3) {
          {
#line 391
          tmp___6 = seg_taille(result_pere);
#line 391
          result_type = - (tmp___6 + 1);
#line 392
          result = result_pere->suffixe_link;
#line 393
          result_pere->suffixe_link = (struct _Noeud *)((void *)0);
          }
        } else
#line 396
        if (result_type == 1) {
#line 398
          result_type = -1;
#line 399
          result = result_pere;
        } else {
          {
#line 403
          tmp___7 = seg_taille(result);
#line 403
          result_type = - tmp___7;
#line 404
          result = result_pere;
          }
        }
      }
#line 292
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 410
    tmp_liste = *debut_liste;
#line 411
    *debut_liste = (*debut_liste)->suiv;
#line 412
    Free_Liste(tmp_liste);
#line 226
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 415
  return (fictive);
}
}
#line 419 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/construction.c"
void Troisieme_Phase(Noeud *Racine , int taille_fenetre , Liste **debut_liste , Liste **fin_liste ,
                     Noeud **fin_liste_pere , int *nb_element_liste , int fictive ) 
{ 
  int i ;
  int j ;
  int result_type ;
  int taille_sequence ;
  Noeud *result ;
  Noeud *result_pere ;
  Noeud *last_created_node ;
  Noeud *tmp_noeud ;
  Noeud *tmp_noeud2 ;
  Liste *tmp_liste ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 432
  result_pere = (Noeud *)((void *)0);
#line 440
  tmp = strlen((char const   *)*(Sequence + current_sequence));
#line 440
  taille_sequence = (int )tmp;
#line 442
  i = taille_sequence;
#line 443
  result = *fin_liste_pere;
#line 444
  last_created_node = (Noeud *)((void *)0);
#line 445
  global_indice = i;
  }
#line 449
  if ((unsigned int )((*fin_liste)->feuille)->debut & 2147483648U) {
    {
#line 450
    tmp___0 = seg_taille((Noeud *)(*fin_liste)->feuille);
#line 450
    result_type = - tmp___0;
    }
  } else {
#line 452
    result_type = -1;
  }
#line 454
  if (fictive) {
    {
#line 456
    result_pere = (Noeud *)((void *)0);
#line 457
    result = Add_Fast_String(result, i + result_type, i, & result_type, & result_pere);
    }
#line 458
    if (result_type == 3) {
      {
#line 460
      last_created_node = result_pere;
#line 461
      tmp___1 = seg_taille(result_pere);
#line 461
      result_type = - (tmp___1 + 1);
#line 462
      result = result_pere->suffixe_link;
#line 463
      result_pere->suffixe_link = (struct _Noeud *)((void *)0);
      }
    }
#line 465
    if (result_type == 1) {
#line 467
      result_type = -1;
#line 468
      result = result_pere;
    }
  } else {
    {
#line 473
    while (1) {
      while_continue: /* CIL Label */ ;
#line 473
      if (! *debut_liste) {
#line 473
        goto while_break;
      }
      {
#line 475
      setListeValue(Liste_positions_fin, ((*debut_liste)->feuille)->fin_deb, i);
      }
#line 476
      if ((unsigned long )*debut_liste == (unsigned long )*fin_liste) {
#line 477
        goto while_break;
      }
      {
#line 478
      tmp_liste = *debut_liste;
#line 479
      *debut_liste = (*debut_liste)->suiv;
#line 480
      Free_Liste(tmp_liste);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 482
    if ((unsigned int )((*fin_liste)->feuille)->debut & 2147483648U) {
      {
#line 483
      tmp___2 = seg_taille((Noeud *)(*fin_liste)->feuille);
#line 483
      result_type = - tmp___2;
      }
    } else {
#line 485
      result_type = -1;
    }
    {
#line 486
    Free_Liste(*fin_liste);
    }
  }
#line 489
  j = *nb_element_liste;
  {
#line 489
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 489
    if (! (j < i)) {
#line 489
      goto while_break___0;
    }
#line 493
    result_pere = (Noeud *)((void *)0);
#line 494
    if (! result) {
      {
#line 495
      result = Add_Fast_String(Racine, j, i, & result_type, & result_pere);
      }
    } else
#line 494
    if ((unsigned long )result == (unsigned long )Racine) {
      {
#line 495
      result = Add_Fast_String(Racine, j, i, & result_type, & result_pere);
      }
    } else
#line 494
    if (! result->suffixe_link) {
      {
#line 495
      result = Add_Fast_String(Racine, j, i, & result_type, & result_pere);
      }
    } else {
      {
#line 498
      result = Add_Fast_String(result->suffixe_link, i + result_type, i, & result_type,
                               & result_pere);
      }
    }
#line 502
    if (result_type == 1) {
#line 502
      goto _L;
    } else
#line 502
    if (result_type == 3) {
      _L: /* CIL Label */ 
#line 513
      *fin_liste_pere = result_pere;
#line 515
      (*nb_element_liste) ++;
#line 517
      if (last_created_node) {
#line 518
        last_created_node->suffixe_link = result_pere;
      }
#line 522
      last_created_node = (Noeud *)((void *)0);
#line 523
      if (result_type == 3) {
#line 524
        last_created_node = result_pere;
      }
    } else
#line 527
    if (result_type < 0) {
      {
#line 531
      tmp_noeud2 = Get_Child_Start_Letter(result, i + result_type);
#line 532
      tmp___3 = seg_taille(tmp_noeud2);
      }
#line 532
      if (tmp___3 > - result_type) {
        {
#line 535
        tmp_noeud = Alloc_Noeud();
        }
#line 536
        if (last_created_node) {
#line 537
          last_created_node->suffixe_link = tmp_noeud;
        }
#line 538
        last_created_node = (Noeud *)((void *)0);
#line 540
        tmp_noeud->debut = i + result_type;
#line 541
        tmp_noeud->fin = i;
#line 542
        if ((unsigned int )tmp_noeud2->debut & 2147483648U) {
#line 543
          tmp_noeud2->debut = (int )((unsigned int )(tmp_noeud2->debut - result_type) | 2147483648U);
        } else {
#line 545
          tmp_noeud2->debut -= result_type;
        }
        {
#line 546
        Ajoute_Fils_Au_Noeud(result, tmp_noeud);
#line 547
        Ajoute_Fils_Au_Noeud(tmp_noeud, tmp_noeud2);
#line 548
        last_created_node = tmp_noeud;
#line 549
        result = result_pere;
        }
      } else {
#line 554
        if (last_created_node) {
#line 555
          last_created_node->suffixe_link = result;
        }
#line 556
        last_created_node = (Noeud *)((void *)0);
      }
    } else {
#line 575
      last_created_node = (Noeud *)((void *)0);
    }
#line 577
    if (result_type > 0) {
#line 581
      if (result_type == 3) {
        {
#line 586
        tmp___4 = seg_taille(result_pere);
#line 586
        result_type = - (tmp___4 + 1);
#line 587
        result = result_pere->suffixe_link;
#line 588
        result_pere->suffixe_link = (struct _Noeud *)((void *)0);
        }
      } else {
#line 592
        result_type = -1;
#line 593
        result = result_pere;
      }
    }
#line 489
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 597
  return;
}
}
#line 599 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/construction.c"
Noeud *AjouteSequence(Noeud *Arbre , unsigned char *S , int taille_fenetre ) 
{ 
  Noeud *pere ;
  Noeud *resultat ;
  int position_arc ;
  int seg_lg ;
  int res_type ;
  int i ;
  int j ;
  int lg_sequence ;
  int decalage ;
  size_t tmp ;
  Noeud *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  Noeud *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 601
  pere = (Noeud *)((void *)0);
#line 607
  i = taille_fenetre;
#line 609
  decalage = taille_fenetre;
#line 611
  current_sequence ++;
#line 613
  *(Sequence + current_sequence) = S;
#line 614
  tmp = strlen((char const   *)S);
#line 614
  lg_sequence = (int )tmp;
  }
#line 615
  if (taille_fenetre >= lg_sequence) {
#line 616
    taille_fenetre = lg_sequence;
  }
#line 618
  i = taille_fenetre;
#line 619
  decalage = taille_fenetre;
#line 624
  resultat = Arbre;
#line 625
  position_arc = 0;
  {
#line 626
  while (1) {
    while_continue: /* CIL Label */ ;
#line 626
    if (! (i <= lg_sequence)) {
#line 626
      goto while_break;
    }
    {
#line 628
    pere = (Noeud *)((void *)0);
#line 629
    resultat = FindString(resultat, i - decalage, i, & pere, & res_type, & position_arc);
    }
#line 630
    if (position_arc == -1) {
      {
#line 633
      tmp___0 = CaseTreeAddSequence(Arbre, resultat, i + res_type, (i + res_type) + 1,
                                    taille_fenetre);
      }
#line 633
      return (tmp___0);
    }
#line 635
    if (res_type == 1) {
      {
#line 637
      seg_lg = seg_taille(resultat);
      }
#line 638
      if ((unsigned int )resultat->debut & 2147483648U) {
#line 640
        resultat->debut = (int )((unsigned int )(i - seg_lg) | 2147483648U);
#line 641
        if (resultat->sequence_number == current_sequence) {
#line 641
          tmp___1 = 0;
        } else {
#line 641
          tmp___1 = 1;
        }
        {
#line 641
        Ajoute_Position_Liste(Liste_positions_fin, & ((Feuille *)resultat)->fin_deb,
                              i, tmp___1);
#line 642
        resultat->sequence_number = current_sequence;
#line 643
        addBitTabValue(& ((Feuille *)resultat)->sequences, current_sequence);
        }
      }
      {
#line 645
      i ++;
#line 646
      tmp___2 = seg_taille(resultat);
#line 646
      decalage = tmp___2 + 1;
      }
#line 647
      if ((unsigned long )pere != (unsigned long )Arbre) {
#line 648
        resultat = pere->suffixe_link;
      } else {
#line 651
        decalage = taille_fenetre;
#line 652
        resultat = Arbre;
      }
    } else
#line 656
    if (res_type == 2) {
      {
#line 659
      printf((char const   */* __restrict  */)"ERREUR    CAS 2 for sequence %d and string %d .. %d \n",
             current_sequence, i - decalage, i);
#line 660
      j = i - decalage;
      }
      {
#line 660
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 660
        if (! (j < i)) {
#line 660
          goto while_break___0;
        }
        {
#line 661
        printf((char const   */* __restrict  */)"%c", (int )*(*(Sequence + current_sequence) + j));
#line 660
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 662
      printf((char const   */* __restrict  */)"\n");
#line 663
      exit(0);
      }
    } else
#line 666
    if (! (res_type == 3)) {
      {
#line 671
      tmp___3 = CaseTreeAddSequence(Arbre, pere, (i + res_type) - position_arc, (i + res_type) + 1,
                                    taille_fenetre);
      }
#line 671
      return (tmp___3);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 674
  i = lg_sequence;
#line 675
  j = lg_sequence - taille_fenetre;
  {
#line 675
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 675
    if (! (j < lg_sequence)) {
#line 675
      goto while_break___1;
    }
    {
#line 677
    resultat = FindString(Arbre, j, i, & pere, & res_type, & position_arc);
    }
#line 678
    if (res_type == 1) {
      {
#line 680
      seg_lg = seg_taille(resultat);
      }
#line 681
      if ((unsigned int )resultat->debut & 2147483648U) {
#line 683
        if (resultat->sequence_number != current_sequence) {
#line 683
          goto _L;
        } else
#line 683
        if (resultat->sequence_number == current_sequence) {
#line 683
          if ((resultat->debut & 2147483647) != i - seg_lg) {
            _L: /* CIL Label */ 
#line 690
            resultat->debut = (int )((unsigned int )(i - seg_lg) | 2147483648U);
#line 691
            if (resultat->sequence_number == current_sequence) {
#line 691
              tmp___4 = 0;
            } else {
#line 691
              tmp___4 = 1;
            }
            {
#line 691
            Ajoute_Position_Liste(Liste_positions_fin, & ((Feuille *)resultat)->fin_deb,
                                  i, tmp___4);
#line 692
            resultat->sequence_number = current_sequence;
#line 693
            addBitTabValue(& ((Feuille *)resultat)->sequences, current_sequence);
            }
          }
        }
      }
    } else {
      {
#line 698
      printf((char const   */* __restrict  */)"YOUPI II I I I %d \n", res_type);
      }
    }
#line 675
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 700
  return (Arbre);
}
}
#line 705 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/construction.c"
Noeud *CaseOneAddSequence(Noeud *Arbre , int taille_fenetre ) 
{ 
  Liste *Debut_liste ;
  Liste *tmp ;
  Liste *Fin_liste ;
  Noeud *Fin_liste_pere ;
  int nb_el_liste ;
  int fictive ;
  Feuille *tmp_f ;

  {
  {
#line 707
  tmp = Alloc_Liste();
#line 707
  Debut_liste = tmp;
#line 710
  nb_el_liste = 0;
#line 711
  fictive = 0;
#line 715
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CASE ONE\n");
#line 717
  tmp_f = Alloc_Feuille();
#line 718
  tmp_f->debut = (-0x7FFFFFFF-1);
#line 719
  Ajoute_Position_Liste(Liste_positions_fin, & tmp_f->fin_deb, -1, 0);
#line 721
  Fin_liste_pere = Arbre;
#line 722
  nb_el_liste = 1;
#line 723
  Debut_liste->feuille = tmp_f;
#line 724
  Fin_liste = Debut_liste;
#line 725
  Ajoute_Fils_Au_Noeud(Arbre, (Noeud *)tmp_f);
#line 727
  Premiere_Phase(Arbre, taille_fenetre, & Debut_liste, & Fin_liste, & Fin_liste_pere,
                 & nb_el_liste, 1);
#line 730
  fictive = Deuxieme_Phase(Arbre, taille_fenetre, & Debut_liste, & Fin_liste, & Fin_liste_pere,
                           & nb_el_liste, taille_fenetre, 0, 0);
#line 734
  Troisieme_Phase(Arbre, taille_fenetre, & Debut_liste, & Fin_liste, & Fin_liste_pere,
                  & nb_el_liste, fictive);
  }
#line 737
  return (Arbre);
}
}
#line 741 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/construction.c"
Noeud *CaseTwoAddSequence(Noeud *Arbre , Noeud *resultat , Noeud *pere , int taille_fenetre ) 
{ 
  Liste *Debut_liste ;
  Liste *tmp ;
  Liste *Fin_liste ;
  Noeud *Fin_liste_pere ;
  int nb_el_liste ;
  int fictive ;

  {
  {
#line 744
  tmp = Alloc_Liste();
#line 744
  Debut_liste = tmp;
#line 747
  nb_el_liste = 0;
#line 748
  fictive = 0;
#line 750
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CASE TWO\n");
#line 752
  Debut_liste->feuille = (Feuille *)pere;
#line 753
  Fin_liste = Debut_liste;
#line 754
  Fin_liste_pere = resultat;
#line 755
  nb_el_liste = 1;
#line 757
  fictive = Deuxieme_Phase(Arbre, taille_fenetre, & Debut_liste, & Fin_liste, & Fin_liste_pere,
                           & nb_el_liste, taille_fenetre, 1, 0);
#line 761
  Troisieme_Phase(Arbre, taille_fenetre, & Debut_liste, & Fin_liste, & Fin_liste_pere,
                  & nb_el_liste, fictive);
  }
#line 765
  return (Arbre);
}
}
#line 769 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/construction.c"
Noeud *CaseTreeAddSequence(Noeud *Arbre , Noeud *resultat , int deb , int fin , int taille_fenetre ) 
{ 
  Liste *Debut_liste ;
  Liste *tmp ;
  Liste *Fin_liste ;
  Noeud *Fin_liste_pere ;
  Noeud *pere ;
  int nb_el_liste ;
  int fictive ;
  int j ;
  int lim ;
  int res_type ;
  int start___3 ;
  Noeud *last_created ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 772
  tmp = Alloc_Liste();
#line 772
  Debut_liste = tmp;
#line 773
  Fin_liste = (Liste *)((void *)0);
#line 775
  pere = (Noeud *)((void *)0);
#line 777
  nb_el_liste = 0;
#line 778
  fictive = 0;
#line 782
  last_created = (Noeud *)((void *)0);
#line 787
  lim = fin;
#line 788
  res_type = deb - fin;
#line 789
  global_indice = lim;
#line 791
  start___3 = lim - taille_fenetre;
  }
#line 792
  if (start___3 < 0) {
#line 793
    start___3 = 0;
  }
#line 794
  j = start___3;
  {
#line 794
  while (1) {
    while_continue: /* CIL Label */ ;
#line 794
    if (! (j < lim)) {
#line 794
      goto while_break;
    }
    {
#line 796
    pere = (Noeud *)((void *)0);
#line 797
    resultat = Add_Fast_String(resultat, lim + res_type, lim, & res_type, & pere);
    }
#line 799
    if (res_type == 1) {
#line 799
      goto _L;
    } else
#line 799
    if (res_type == 3) {
      _L: /* CIL Label */ 
      {
#line 801
      setListeValue(Liste_positions_fin, ((Feuille *)resultat)->fin_deb, -1);
      }
#line 802
      if (Fin_liste) {
        {
#line 804
        Fin_liste->suiv = Alloc_Liste();
#line 805
        Fin_liste = Fin_liste->suiv;
#line 806
        Fin_liste->feuille = (Feuille *)resultat;
        }
      } else {
#line 810
        Fin_liste = Debut_liste;
#line 811
        Debut_liste->feuille = (Feuille *)resultat;
      }
#line 814
      Fin_liste_pere = pere;
#line 815
      nb_el_liste ++;
#line 816
      if (last_created) {
#line 817
        last_created->suffixe_link = pere;
      }
#line 818
      last_created = (Noeud *)((void *)0);
#line 819
      if (res_type == 3) {
#line 820
        last_created = pere;
      }
    } else
#line 823
    if (res_type < 0) {
#line 825
      if (last_created) {
#line 826
        last_created->suffixe_link = resultat;
      }
#line 827
      last_created = (Noeud *)((void *)0);
#line 828
      goto while_break;
    } else {
#line 831
      last_created = (Noeud *)((void *)0);
    }
#line 832
    if (res_type > 0) {
#line 834
      if (res_type == 3) {
        {
#line 836
        tmp___0 = seg_taille(pere);
#line 836
        res_type = - tmp___0 - 1;
#line 837
        resultat = pere->suffixe_link;
        }
#line 838
        if ((unsigned long )resultat != (unsigned long )Arbre) {
#line 839
          resultat = resultat->suffixe_link;
        } else {
#line 841
          res_type ++;
        }
#line 842
        pere->suffixe_link = (struct _Noeud *)((void *)0);
      } else {
#line 846
        res_type = -1;
#line 847
        resultat = pere;
#line 848
        if ((unsigned long )resultat == (unsigned long )((void *)0)) {
#line 850
          resultat = Arbre;
#line 851
          res_type = - (j + 1);
        } else
#line 854
        if ((unsigned long )resultat != (unsigned long )Arbre) {
#line 855
          resultat = resultat->suffixe_link;
        } else {
#line 857
          res_type ++;
        }
      }
    }
#line 794
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 863
  if (fin <= taille_fenetre) {
    {
#line 865
    Premiere_Phase(Arbre, taille_fenetre, & Debut_liste, & Fin_liste, & Fin_liste_pere,
                   & nb_el_liste, lim + 1);
#line 868
    fictive = Deuxieme_Phase(Arbre, taille_fenetre, & Debut_liste, & Fin_liste, & Fin_liste_pere,
                             & nb_el_liste, taille_fenetre, 0, 0);
#line 871
    Troisieme_Phase(Arbre, taille_fenetre, & Debut_liste, & Fin_liste, & Fin_liste_pere,
                    & nb_el_liste, fictive);
    }
  } else {
    {
#line 877
    setListeValue(Liste_positions_fin, (Debut_liste->feuille)->fin_deb, lim);
    }
#line 878
    if (nb_el_liste == 1) {
#line 879
      fictive = 1;
    } else {
#line 882
      res_type = -1;
#line 883
      Debut_liste = Debut_liste->suiv;
#line 884
      nb_el_liste --;
    }
#line 887
    if (fictive) {
#line 887
      tmp___1 = lim;
    } else {
#line 887
      tmp___1 = lim + 1;
    }
#line 887
    nb_el_liste = (tmp___1 - taille_fenetre) + nb_el_liste;
#line 888
    if (fictive) {
#line 888
      tmp___2 = lim;
    } else {
#line 888
      tmp___2 = lim + 1;
    }
    {
#line 888
    fictive = Deuxieme_Phase(Arbre, taille_fenetre, & Debut_liste, & Fin_liste, & Fin_liste_pere,
                             & nb_el_liste, tmp___2, fictive, 0);
#line 892
    Troisieme_Phase(Arbre, taille_fenetre, & Debut_liste, & Fin_liste, & Fin_liste_pere,
                    & nb_el_liste, fictive);
    }
  }
#line 897
  return (Arbre);
}
}
#line 901 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/construction.c"
Noeud *CaseFourAddSequence(Noeud *Arbre , Noeud *resultat , Noeud *pere , int res_type ,
                           int position_arc , int i , int taille_fenetre ) 
{ 
  Liste *Debut_liste ;
  Liste *tmp ;
  Liste *Fin_liste ;
  Noeud *Fin_liste_pere ;
  int nb_el_liste ;
  int fictive ;

  {
  {
#line 904
  tmp = Alloc_Liste();
#line 904
  Debut_liste = tmp;
#line 908
  nb_el_liste = 0;
#line 909
  fictive = 0;
#line 911
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nCASE FOUR------------------------------------------------------------------\n\n");
#line 916
  global_indice = i;
  }
#line 920
  if (res_type != -1) {
#line 922
    Debut_liste->feuille = (Feuille *)resultat;
#line 923
    Fin_liste = Debut_liste;
#line 924
    Fin_liste_pere = pere;
#line 925
    nb_el_liste = (i - taille_fenetre) + 1;
  } else {
#line 929
    Debut_liste->feuille = (Feuille *)resultat;
#line 930
    Fin_liste = Debut_liste;
#line 931
    Fin_liste_pere = resultat;
#line 932
    nb_el_liste = (i - taille_fenetre) + 1;
  }
  {
#line 935
  printf((char const   */* __restrict  */)"Arbre AVANT la Deuxieme phase\n");
#line 936
  printf((char const   */* __restrict  */)"Arbre = %p \n taille_fenetre = %d \nDebut_liste = %p ->feuille %p \nFin_liste = %p ->feuille %p\nFin_liste_pere = %p\nnb_element_liste=%d\ni = %d\nFictive = 0\n",
         Arbre, taille_fenetre, Debut_liste, Debut_liste->feuille, Fin_liste, Fin_liste->feuille,
         Fin_liste_pere, nb_el_liste, i);
#line 945
  fictive = Deuxieme_Phase(Arbre, taille_fenetre, & Debut_liste, & Fin_liste, & Fin_liste_pere,
                           & nb_el_liste, i, 1, 0);
#line 948
  Troisieme_Phase(Arbre, taille_fenetre, & Debut_liste, & Fin_liste, & Fin_liste_pere,
                  & nb_el_liste, fictive);
  }
#line 951
  return (Arbre);
}
}
#line 955 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/construction.c"
void CloseTheFirstPhase(Liste **debut_liste , Liste **fin_liste , Noeud **fin_liste_pere ) 
{ 
  Liste *tmp ;

  {
  {
#line 959
  tmp = *debut_liste;
#line 961
  printf((char const   */* __restrict  */)"CLOSE THE FIRST CASE\n");
  }
  {
#line 962
  while (1) {
    while_continue: /* CIL Label */ ;
#line 962
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 962
      goto while_break;
    }
#line 964
    if (tmp->feuille) {
#line 964
      if ((unsigned int )(tmp->feuille)->debut & 2147483648U) {
        {
#line 965
        setListeValue(Liste_positions_fin, (tmp->feuille)->fin_deb, global_indice);
        }
      }
    }
#line 966
    tmp = tmp->suiv;
  }
  while_break: /* CIL Label */ ;
  }
#line 969
  return;
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 765
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) pow)(double __x ,
                                                                             double __y ) ;
#line 156
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 54 "include/shufflet.h"
int readseq(int k , FILE *infile , int **nver , int ***count , int ***vdeg , int **first ,
            int **last , char ***seqstart , int **seqlen , int *maxsizeseq , int nbseqalloc ,
            char *alphaseq___0 , char ***origseq ) ;
#line 57
void generateseq(int k , int *nver , int **count , int **vdeg , int *first , int *last ,
                 char **seqstart , int nbseq , int *seqlen , int *count1 , int *vdeg1 ,
                 int nklets , int nk1lets , int *lastedge , char **seq ) ;
#line 40 "grep+/Spell/include/barre.h"
void barre(int n ) ;
#line 83 "grep+/Spell/include/global.h"
void fatalError(char *msg ) ;
#line 74 "grep+/Spell/include/criteres.h"
int maxLongMod(Criteres cr ) ;
#line 77
void initCriteres(struct struct_criteres *cr ) ;
#line 78
Flag chargeCriteres(struct struct_criteres *cr , char *line ) ;
#line 51 "grep+/Spell/include/alphabet.h"
void initAlphabet(void) ;
#line 52
Symbole *chargeAlphaSeq(Symbole **seq , int nbseq , char *alphaseq___0 ) ;
#line 53
void chargeAlphaMod(FILE *f___0 ) ;
#line 58 "grep+/Spell/include/grep+.h"
void chercheMot(Arbre a , P_Criteres cr , signed char *mot , unsigned int *nb_occ ,
                unsigned int *nbocc_ex , FILE *f___0 ) ;
#line 64
Flag creeArbreSuffixeFromArray(Arbre *a , char **seq , int nbseq , int maxlongmod___0 ,
                               char *alphaseq___0 ) ;
#line 67
void libereArbreSuffixeFromArray(Arbre a ) ;
#line 70
Flag valideCriteres(P_Criteres cr ) ;
#line 48 "include/io.h"
Mot *lectureFichierRes(FILE *res , int nbseq , int *nbmodeles , int *maxlongmod___0 ) ;
#line 50
FILE *openFile(char *nom , char *mode ) ;
#line 53
void printCpuTime(FILE *f___0 ) ;
#line 29 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/sigstat.c"
char *alphaseq  ;
#line 35
void afficheStats(FILE *outfile , Mot *modeles , int nbmodeles , int nbseq , int maxlongmod___0 ) ;
#line 38
void calculeStats(int nbmodeles , int nbtests , int nbseq , float **resultats , Mot *modeles ,
                  char flag___1 ) ;
#line 45 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/sigstat.c"
int main(int argc , char **argv ) 
{ 
  Mot *modeles ;
  int nbseq ;
  int nbmodeles ;
  int i ;
  int nbtests ;
  int maxsizeseq ;
  int j ;
  int maxlongmod___0 ;
  unsigned int nbocc ;
  unsigned int nboccex ;
  float **resultats ;
  FILE *fasta ;
  FILE *res ;
  FILE *outfile ;
  FILE *f___0 ;
  int *nver ;
  int **count ;
  int **vdeg ;
  int *first ;
  int *last ;
  int *count1 ;
  int *vdeg1 ;
  int nklets ;
  int nk1lets ;
  int *seqlen ;
  int order ;
  int nbseqalloc ;
  int *lastedge ;
  char **seqstart ;
  char **seq ;
  char line[4096] ;
  char *alphaseq___0 ;
  char **origseq ;
  Arbre arbre ;
  Criteres cr ;
  float **resocc ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  Flag tmp___7 ;
  Flag tmp___8 ;
  Symbole *tmp___9 ;
  Mot *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  size_t tmp___15 ;
  double tmp___16 ;
  size_t tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  int tmp___23 ;

  {
  {
#line 48
  maxlongmod___0 = 0;
#line 56
  seqstart = (char **)((void *)0);
#line 69
  initCriteres(& cr);
  }
#line 71
  if (argc != 6) {
    {
#line 73
    printf((char const   */* __restrict  */)"Usage: ~ Fic.Fasta Fic.res Fic.sortie nb_shufflings order\n\n");
    }
#line 74
    return (1);
  }
  {
#line 79
  fasta = openFile(*(argv + 1), (char *)"r");
#line 81
  res = openFile(*(argv + 2), (char *)"r");
#line 83
  outfile = openFile(*(argv + 3), (char *)"w");
#line 85
  nbtests = atoi((char const   *)*(argv + 4));
#line 87
  order = atoi((char const   *)*(argv + 5));
#line 90
  printCpuTime((FILE *)((void *)0));
#line 94
  tmp = malloc(sizeof(int *) * 500UL);
#line 94
  count = (int **)tmp;
#line 95
  tmp___0 = malloc(sizeof(int ) * 500UL);
#line 95
  seqlen = (int *)tmp___0;
#line 96
  tmp___1 = malloc(sizeof(int *) * 500UL);
#line 96
  vdeg = (int **)tmp___1;
#line 97
  tmp___2 = malloc(sizeof(int ) * 500UL);
#line 97
  first = (int *)tmp___2;
#line 98
  tmp___3 = malloc(sizeof(int ) * 500UL);
#line 98
  last = (int *)tmp___3;
#line 99
  tmp___4 = malloc(sizeof(int ) * 500UL);
#line 99
  nver = (int *)tmp___4;
#line 100
  nbseqalloc = 500;
  }
#line 101
  if (! ((unsigned long )count != (unsigned long )((void *)0))) {
    {
#line 101
    __assert_fail("count != ((void *)0)", "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/sigstat.c",
                  101U, "main");
    }
  }
#line 102
  if (! ((unsigned long )vdeg != (unsigned long )((void *)0))) {
    {
#line 102
    __assert_fail("vdeg != ((void *)0)", "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/sigstat.c",
                  102U, "main");
    }
  }
#line 103
  if ((unsigned long )seqlen != (unsigned long )((void *)0)) {
#line 103
    if ((unsigned long )first != (unsigned long )((void *)0)) {
#line 103
      if (! ((unsigned long )last != (unsigned long )((void *)0))) {
        {
#line 103
        __assert_fail("seqlen != ((void *)0) && first != ((void *)0) && last != ((void *)0)",
                      "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/sigstat.c",
                      103U, "main");
        }
      }
    } else {
      {
#line 103
      __assert_fail("seqlen != ((void *)0) && first != ((void *)0) && last != ((void *)0)",
                    "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/sigstat.c",
                    103U, "main");
      }
    }
  } else {
    {
#line 103
    __assert_fail("seqlen != ((void *)0) && first != ((void *)0) && last != ((void *)0)",
                  "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/sigstat.c",
                  103U, "main");
    }
  }
#line 104
  if (! ((unsigned long )nver != (unsigned long )((void *)0))) {
    {
#line 104
    __assert_fail("nver != ((void *)0)", "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/sigstat.c",
                  104U, "main");
    }
  }
#line 106
  if (order == 1) {
    {
#line 108
    tmp___5 = malloc(500UL * sizeof(char *));
#line 108
    origseq = (char **)tmp___5;
    }
#line 109
    if (! ((unsigned long )origseq != (unsigned long )((void *)0))) {
      {
#line 109
      __assert_fail("origseq != ((void *)0)", "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/sigstat.c",
                    109U, "main");
      }
    }
  } else {
    {
#line 113
    tmp___6 = malloc(sizeof(char *) * 500UL);
#line 113
    seqstart = (char **)tmp___6;
    }
#line 114
    if (! ((unsigned long )seqstart != (unsigned long )((void *)0))) {
      {
#line 114
      __assert_fail("seqstart != ((void *)0)", "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/sigstat.c",
                    114U, "main");
      }
    }
  }
  {
#line 121
  fgets((char */* __restrict  */)(line), 4096, (FILE */* __restrict  */)res);
#line 122
  tmp___7 = chargeCriteres(& cr, line);
  }
#line 122
  if (! tmp___7) {
    {
#line 124
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"File \'%s\' is corrupted.\n",
            *(argv + 2));
    }
#line 125
    return (1);
  }
  {
#line 128
  tmp___8 = valideCriteres(& cr);
  }
#line 128
  if ((int )tmp___8 == 0) {
#line 129
    return (1);
  }
  {
#line 133
  initAlphabet();
#line 134
  tmp___9 = chargeAlphaSeq((Symbole **)((void *)0), 0, cr.alphaseq);
#line 134
  alphaseq___0 = (char *)tmp___9;
#line 138
  f___0 = fopen((char const   */* __restrict  */)(cr.ficalph), (char const   */* __restrict  */)"r");
  }
#line 138
  if (! f___0) {
    {
#line 139
    fatalError((char *)"main: cannot open alphabet file\n");
    }
  }
  {
#line 141
  chargeAlphaMod(f___0);
#line 143
  fclose(f___0);
#line 148
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"** Reading composition of the sequences to shuffle **\n");
#line 149
  nbseq = readseq(order, fasta, & nver, & count, & vdeg, & first, & last, & seqstart,
                  & seqlen, & maxsizeseq, nbseqalloc, cr.alphaseq, & origseq);
#line 151
  fclose(fasta);
  }
#line 153
  if (nbseq <= 0) {
    {
#line 154
    fatalError((char *)"no sequences in file\n");
    }
  }
  {
#line 159
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"** Reading extracted models **\n");
#line 160
  tmp___10 = lectureFichierRes(res, nbseq, & nbmodeles, & maxlongmod___0);
#line 160
  modeles = tmp___10;
#line 161
  fclose(res);
  }
#line 163
  if ((unsigned long )modeles == (unsigned long )((void *)0)) {
    {
#line 165
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"STOP: File \'%s\' is empty.\n",
            *(argv + 2));
    }
#line 166
    return (0);
  }
  {
#line 173
  tmp___11 = malloc((unsigned long )nbtests * sizeof(float *));
#line 173
  resultats = (float **)tmp___11;
  }
#line 174
  if (! ((unsigned long )resultats != (unsigned long )((void *)0))) {
    {
#line 174
    __assert_fail("resultats!=((void *)0)", "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/sigstat.c",
                  174U, "main");
    }
  }
  {
#line 176
  tmp___12 = malloc((unsigned long )nbtests * sizeof(float *));
#line 176
  resocc = (float **)tmp___12;
  }
#line 177
  if (! ((unsigned long )resocc != (unsigned long )((void *)0))) {
    {
#line 177
    __assert_fail("resocc!=((void *)0)", "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/sigstat.c",
                  177U, "main");
    }
  }
#line 180
  i = 0;
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    if (! (i < nbtests)) {
#line 180
      goto while_break;
    }
    {
#line 182
    tmp___13 = calloc((size_t )nbmodeles, sizeof(float ));
#line 182
    *(resultats + i) = (float *)tmp___13;
    }
#line 183
    if (! ((unsigned long )*(resultats + i) != (unsigned long )((void *)0))) {
      {
#line 183
      __assert_fail("resultats[i]!=((void *)0)", "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/sigstat.c",
                    183U, "main");
      }
    }
    {
#line 185
    tmp___14 = calloc((size_t )nbmodeles, sizeof(float ));
#line 185
    *(resocc + i) = (float *)tmp___14;
    }
#line 186
    if (! ((unsigned long )*(resocc + i) != (unsigned long )((void *)0))) {
      {
#line 186
      __assert_fail("resocc[i]!=((void *)0)", "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/sigstat.c",
                    186U, "main");
      }
    }
#line 180
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 191
  tmp___15 = strlen((char const   *)alphaseq___0);
#line 191
  tmp___16 = pow((double )(tmp___15 - 1UL), (double )order);
#line 191
  nklets = (int )tmp___16;
#line 192
  tmp___17 = strlen((char const   *)alphaseq___0);
#line 192
  nk1lets = (int )((size_t )nklets / (tmp___17 - 1UL));
#line 193
  tmp___18 = malloc(sizeof(int ) * (unsigned long )nklets);
#line 193
  count1 = (int *)tmp___18;
#line 194
  tmp___19 = malloc((unsigned long )nk1lets * sizeof(int ));
#line 194
  vdeg1 = (int *)tmp___19;
#line 195
  tmp___20 = malloc(sizeof(int ) * (unsigned long )nk1lets);
#line 195
  lastedge = (int *)tmp___20;
#line 197
  tmp___21 = malloc((unsigned long )nbseq * sizeof(char *));
#line 197
  seq = (char **)tmp___21;
  }
#line 198
  if ((unsigned long )count1 != (unsigned long )((void *)0)) {
#line 198
    if ((unsigned long )vdeg1 != (unsigned long )((void *)0)) {
#line 198
      if (! ((unsigned long )lastedge != (unsigned long )((void *)0))) {
        {
#line 198
        __assert_fail("count1!=((void *)0) && vdeg1!=((void *)0) && lastedge!=((void *)0)",
                      "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/sigstat.c",
                      198U, "main");
        }
      }
    } else {
      {
#line 198
      __assert_fail("count1!=((void *)0) && vdeg1!=((void *)0) && lastedge!=((void *)0)",
                    "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/sigstat.c",
                    198U, "main");
      }
    }
  } else {
    {
#line 198
    __assert_fail("count1!=((void *)0) && vdeg1!=((void *)0) && lastedge!=((void *)0)",
                  "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/sigstat.c",
                  198U, "main");
    }
  }
#line 200
  i = 0;
  {
#line 200
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 200
    if (! (i < nbseq)) {
#line 200
      goto while_break___0;
    }
    {
#line 202
    tmp___22 = malloc((unsigned long )((*(seqlen + i) + 2) + order) * sizeof(char ));
#line 202
    *(seq + i) = (char *)tmp___22;
    }
#line 203
    if (! ((unsigned long )*(seq + i) != (unsigned long )((void *)0))) {
      {
#line 203
      __assert_fail("seq[i]!=((void *)0)", "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/sigstat.c",
                    203U, "main");
      }
    }
#line 200
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 210
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n**** Starting processus ****\n");
#line 211
  barre(nbtests);
#line 212
  i = 0;
  }
  {
#line 212
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 212
    if (! (i < nbtests)) {
#line 212
      goto while_break___1;
    }
#line 215
    if (order == 1) {
#line 217
      j = 0;
      {
#line 217
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 217
        if (! (j != nbseq)) {
#line 217
          goto while_break___2;
        }
        {
#line 218
        strncpy((char */* __restrict  */)*(seq + j), (char const   */* __restrict  */)*(origseq + j),
                (size_t )*(seqlen + j));
#line 217
        j ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    {
#line 222
    generateseq(order, nver, count, vdeg, first, last, seqstart, nbseq, seqlen, count1,
                vdeg1, nklets, nk1lets, lastedge, seq);
#line 242
    tmp___23 = maxLongMod(cr);
#line 242
    creeArbreSuffixeFromArray(& arbre, seq, nbseq, tmp___23, alphaseq___0);
#line 259
    j = 0;
    }
    {
#line 259
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 259
      if (! (j != nbmodeles)) {
#line 259
        goto while_break___3;
      }
      {
#line 263
      chercheMot(arbre, & cr, (signed char *)(modeles + j)->codes, & nbocc, & nboccex,
                 (FILE *)((void *)0));
#line 274
      *(*(resultats + i) + j) = (float )nbocc;
#line 275
      (modeles + j)->moyenne_shuffle += (float )nbocc / (float )nbtests;
#line 279
      *(*(resocc + i) + j) = (float )nboccex;
#line 280
      (modeles + j)->moyenne_shuffle_occ += (float )nboccex / (float )nbtests;
#line 259
      j ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 285
    libereArbreSuffixeFromArray(arbre);
#line 287
    barre(0);
#line 212
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 292
  i = 0;
  {
#line 292
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 292
    if (! (i < nbseq)) {
#line 292
      goto while_break___4;
    }
    {
#line 293
    free((void *)*(seq + i));
#line 292
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 294
  free((void *)seq);
#line 296
  free((void *)count);
#line 297
  free((void *)vdeg);
#line 298
  free((void *)first);
#line 299
  free((void *)last);
#line 300
  free((void *)nver);
  }
#line 302
  if (order > 1) {
    {
#line 303
    free((void *)seqstart);
    }
  }
  {
#line 312
  calculeStats(nbmodeles, nbtests, nbseq, resultats, modeles, (char)0);
#line 315
  calculeStats(nbmodeles, nbtests, (int )cr.nbsymb, resocc, modeles, (char)1);
#line 319
  afficheStats(outfile, modeles, nbmodeles, nbseq, maxlongmod___0);
#line 320
  printCpuTime(outfile);
#line 321
  fclose(outfile);
#line 332
  free((void *)seqlen);
#line 333
  i = 0;
  }
  {
#line 333
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 333
    if (! (i < nbtests)) {
#line 333
      goto while_break___5;
    }
    {
#line 335
    free((void *)*(resultats + i));
#line 337
    free((void *)*(resocc + i));
#line 333
    i ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 340
  free((void *)resultats);
#line 343
  free((void *)resocc);
  }
#line 346
  return (0);
}
}
#line 350 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/sigstat.c"
int comparModeles(Mot *a , Mot *b ) 
{ 


  {
#line 352
  if (a->zscore == b->zscore) {
#line 353
    return (0);
  }
#line 354
  if (a->zscore > b->zscore) {
#line 355
    return (-1);
  }
#line 356
  return (1);
}
}
#line 360 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/sigstat.c"
int comparModelesOcc(Mot *a , Mot *b ) 
{ 


  {
#line 362
  if (a->zscore_occ == b->zscore_occ) {
#line 363
    return (0);
  }
#line 364
  if (a->zscore_occ > b->zscore_occ) {
#line 365
    return (-1);
  }
#line 366
  return (1);
}
}
#line 375
void espace(FILE *f___0 , int nb ) ;
#line 375 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/sigstat.c"
static char space[31]  = 
#line 375
  {      (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'\000'};
#line 373 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/sigstat.c"
void espace(FILE *f___0 , int nb ) 
{ 


  {
  {
#line 377
  fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)"%s", (space + 30) - nb);
  }
#line 378
  return;
}
}
#line 384 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/sigstat.c"
void afficheStats(FILE *outfile , Mot *modeles , int nbmodeles , int nbseq , int maxlongmod___0 ) 
{ 
  int i ;
  Mot m ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 390
  fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"STATISTICS ON THE NUMBER OF SEQUENCES HAVING AT LEAST ONE OCCURRENCE\n");
#line 391
  fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"Model");
#line 392
  espace(outfile, maxlongmod___0 - 2);
#line 393
  fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)" %%right\t #right\t %%shfl.\t #shfl.\tSigma\tChi2\tZ-score\n");
#line 394
  fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"=================================================================================\n");
#line 396
  qsort((void *)modeles, (size_t )nbmodeles, sizeof(Mot ), (int (*)(void const   * ,
                                                                    void const   * ))(& comparModeles));
#line 399
  i = 0;
  }
  {
#line 399
  while (1) {
    while_continue: /* CIL Label */ ;
#line 399
    if (! (i < nbmodeles)) {
#line 399
      goto while_break;
    }
    {
#line 401
    m = *(modeles + i);
#line 403
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"%s",
            m.mot);
#line 404
    tmp = strlen((char const   *)m.mot);
#line 404
    espace(outfile, (int )((size_t )(maxlongmod___0 + 4) - tmp));
#line 405
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"%3.2f%%\t%5d\t%3.2f%%\t%5.2f\t%4.2f\t%3.2f\t%3.2f\n",
            (double )m.quorum_reel, m.nbseq_vrai, (double )((m.moyenne_shuffle * (float )100) / (float )nbseq),
            (double )m.moyenne_shuffle, (double )m.sigma, (double )m.khi2, (double )m.zscore);
#line 399
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 411
  fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"\nSTATISTICS ON THE TOTAL NUMBER OF OCCURRENCES\n");
#line 412
  fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"Model");
#line 413
  espace(outfile, maxlongmod___0 - 2);
#line 414
  fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)" #right\t #shfl.\tSigma\tChi2\tZ-score\n");
#line 415
  fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"=================================================================================\n");
#line 417
  qsort((void *)modeles, (size_t )nbmodeles, sizeof(Mot ), (int (*)(void const   * ,
                                                                    void const   * ))(& comparModelesOcc));
#line 420
  i = 0;
  }
  {
#line 420
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 420
    if (! (i < nbmodeles)) {
#line 420
      goto while_break___0;
    }
    {
#line 422
    m = *(modeles + i);
#line 423
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"%s",
            m.mot);
#line 424
    tmp___0 = strlen((char const   *)m.mot);
#line 424
    espace(outfile, (int )((size_t )(maxlongmod___0 + 4) - tmp___0));
#line 425
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"%5d\t%5.2f\t%4.2f\t%3.2f\t%3.2f\n",
            m.nboccex_vrai, (double )m.moyenne_shuffle_occ, (double )m.sigma_occ,
            (double )m.khi2_occ, (double )m.zscore_occ);
#line 420
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 431
  return;
}
}
#line 438 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/sigstat.c"
void calculeStats(int nbmodeles , int nbtests , int nbseq , float **resultats , Mot *modeles ,
                  char flag___1 ) 
{ 
  float Pv ;
  float Pf ;
  float Av ;
  float Af ;
  float nP ;
  float nA ;
  float tmp ;
  float tmp2 ;
  float sigma ;
  int i ;
  int j ;
  double tmp___0 ;

  {
#line 444
  i = 0;
  {
#line 444
  while (1) {
    while_continue: /* CIL Label */ ;
#line 444
    if (! (i < nbmodeles)) {
#line 444
      goto while_break;
    }
#line 450
    if ((int )flag___1 == 1) {
#line 452
      Pv = (float )(modeles + i)->nboccex_vrai;
#line 453
      Pf = (modeles + i)->moyenne_shuffle_occ;
    } else {
#line 458
      Pv = (float )(modeles + i)->nbseq_vrai;
#line 459
      Pf = (modeles + i)->moyenne_shuffle;
    }
#line 462
    Av = (float )nbseq - Pv;
#line 463
    Af = (float )nbseq - Pf;
#line 464
    nP = Pv + Pf;
#line 465
    nA = Av + Af;
#line 470
    if ((int )flag___1 == 1) {
#line 471
      (modeles + i)->khi2_occ = ((float )2 * ((Pv * Af - Pf * Av) * (Pv * Af - Pf * Av))) / ((nP * nA) * (float )nbseq);
    } else {
#line 474
      (modeles + i)->khi2 = ((float )2 * ((Pv * Af - Pf * Av) * (Pv * Af - Pf * Av))) / ((nP * nA) * (float )nbseq);
    }
#line 479
    tmp = (float )0;
#line 480
    j = 0;
    {
#line 480
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 480
      if (! (j < nbtests)) {
#line 480
        goto while_break___0;
      }
#line 482
      tmp2 = ((*(*(resultats + j) + i) - Pf) * (*(*(resultats + j) + i) - Pf)) / (float )(nbtests - 1);
#line 483
      tmp += tmp2;
#line 480
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 485
    tmp___0 = sqrt((double )tmp);
#line 485
    sigma = (float )tmp___0;
    }
#line 487
    if ((double )sigma == 0.000000) {
#line 490
      if ((int )flag___1 == 1) {
#line 492
        (modeles + i)->sigma_occ = sigma;
#line 493
        (modeles + i)->zscore_occ = (float )4294967295U;
      } else {
#line 498
        (modeles + i)->sigma = sigma;
#line 499
        (modeles + i)->zscore = (float )4294967295U;
      }
    } else
#line 504
    if ((int )flag___1 == 1) {
#line 506
      (modeles + i)->sigma_occ = sigma;
#line 507
      (modeles + i)->zscore_occ = (Pv - Pf) / sigma;
    } else {
#line 513
      (modeles + i)->sigma = sigma;
#line 514
      (modeles + i)->zscore = (Pv - Pf) / sigma;
    }
#line 444
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 518
  return;
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 26 "include/struct_tab.h"
int NB_SEQUENCE ;
#line 27
int CHANGE_LIMITE ;
#line 28
int SIZE_STATIC_BIT_TAB ;
#line 27 "include/bit_tab.h"
void initBitTab(int nb_seq ) ;
#line 28
Bit_Tab *AllocBitTab(void) ;
#line 31
void fusionneBitTab(Bit_Tab **tab1 , Bit_Tab *tab2 ) ;
#line 32
int nbSequenceInBitTab(Bit_Tab *tab ) ;
#line 34
void printBitTab(Bit_Tab *tab ) ;
#line 35
void CopyBitTab(Bit_Tab **dest , Bit_Tab *src ) ;
#line 36
void ReinitBitTab(Bit_Tab **bt ) ;
#line 39
void convertBitTab(Bit_Tab **tab ) ;
#line 41
void addBitTabValueStatic(Bit_Tab **tab , int value ) ;
#line 42
void addBitTabValueDynamic(Bit_Tab **tab , int value ) ;
#line 44
int nbSequenceInBitTabStatic(Bit_Tab *tab ) ;
#line 45
int nbSequenceInBitTabDynamic(Bit_Tab *tab ) ;
#line 47
void fusionneBitTabStatic(Bit_Tab **tab1 , Bit_Tab *tab2 ) ;
#line 48
void fusionneBitTabDynamic(Bit_Tab **tab1 , Bit_Tab *tab2 ) ;
#line 49
Bit_Tab *AllocBitTabStatic(void) ;
#line 23 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/bit_tab.c"
int NB_SEQUENCE  =    0;
#line 24 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/bit_tab.c"
int CHANGE_LIMITE  =    0;
#line 25 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/bit_tab.c"
int SIZE_STATIC_BIT_TAB  =    0;
#line 27 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/bit_tab.c"
void initBitTab(int nb_seq ) 
{ 


  {
#line 29
  NB_SEQUENCE = nb_seq;
#line 30
  SIZE_STATIC_BIT_TAB = nb_seq / 8 + 1;
#line 31
  CHANGE_LIMITE = SIZE_STATIC_BIT_TAB / 2 - 1;
#line 32
  if (CHANGE_LIMITE <= 0) {
#line 33
    CHANGE_LIMITE = 1;
  }
#line 34
  return;
}
}
#line 36 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/bit_tab.c"
Bit_Tab *AllocBitTab(void) 
{ 
  Bit_Tab *tmp ;
  void *tmp___0 ;

  {
  {
#line 38
  tmp___0 = malloc((size_t )2);
#line 38
  tmp = (Bit_Tab *)tmp___0;
  }
#line 43
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 45
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No enougth space... \n Program aborded \n");
#line 46
    exit(-2);
    }
  }
  {
#line 48
  memset((void *)tmp, 0, (size_t )2);
#line 49
  *(tmp + 0) = (Bit_Tab )128;
#line 50
  *(tmp + 1) = (Bit_Tab )0;
  }
#line 51
  return (tmp);
}
}
#line 54 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/bit_tab.c"
void ReinitBitTab(Bit_Tab **bt ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 56
  if ((int )*(*bt + 0) & 128) {
    {
#line 58
    tmp = realloc((void *)*bt, (size_t )2);
#line 58
    *bt = (Bit_Tab *)tmp;
#line 59
    *(*bt + 0) = (Bit_Tab )128;
#line 60
    *(*bt + 1) = (Bit_Tab )0;
    }
  } else {
    {
#line 64
    tmp___0 = memset((void *)*bt, 0, (size_t )SIZE_STATIC_BIT_TAB);
#line 64
    *bt = (Bit_Tab *)tmp___0;
    }
  }
#line 66
  return;
}
}
#line 68 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/bit_tab.c"
void CopyBitTab(Bit_Tab **dest , Bit_Tab *src ) 
{ 
  int nb_element ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 71
  if ((int )*(src + 0) & 128) {
    {
#line 73
    nb_element = (((int )*(src + 0) & 127) << 8) | (int )*(src + 1);
#line 74
    tmp = realloc((void *)*dest, 2UL + (unsigned long )nb_element * sizeof(unsigned short ));
#line 74
    *dest = (Bit_Tab *)tmp;
#line 75
    tmp___0 = memcpy((void */* __restrict  */)*dest, (void const   */* __restrict  */)src,
                     2UL + (unsigned long )nb_element * sizeof(unsigned short ));
#line 75
    *dest = (Bit_Tab *)tmp___0;
    }
  } else {
    {
#line 79
    free((void *)*dest);
#line 80
    *dest = AllocBitTabStatic();
#line 82
    tmp___1 = memcpy((void */* __restrict  */)*dest, (void const   */* __restrict  */)src,
                     (size_t )SIZE_STATIC_BIT_TAB);
#line 82
    *dest = (Bit_Tab *)tmp___1;
    }
  }
#line 84
  return;
}
}
#line 86 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/bit_tab.c"
Bit_Tab *AllocBitTabStatic(void) 
{ 
  Bit_Tab *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 88
  tmp___0 = malloc((size_t )SIZE_STATIC_BIT_TAB);
#line 88
  tmp = (Bit_Tab *)tmp___0;
  }
#line 89
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 91
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No enougth space... \n Program aborded \n");
#line 92
    exit(-2);
    }
  }
  {
#line 94
  tmp___1 = memset((void *)tmp, 0, (size_t )SIZE_STATIC_BIT_TAB);
#line 94
  tmp = (Bit_Tab *)tmp___1;
  }
#line 95
  return (tmp);
}
}
#line 98 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/bit_tab.c"
void addBitTabValue(Bit_Tab **tab , int value ) 
{ 


  {
#line 100
  if ((int )*(*tab + 0) & 128) {
    {
#line 101
    addBitTabValueDynamic(tab, value);
    }
  } else {
    {
#line 103
    addBitTabValueStatic(tab, value);
    }
  }
#line 104
  return;
}
}
#line 106 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/bit_tab.c"
void fusionneBitTab(Bit_Tab **tab1 , Bit_Tab *tab2 ) 
{ 


  {
#line 108
  if ((int )*(*tab1 + 0) & 128) {
    {
#line 109
    fusionneBitTabDynamic(tab1, tab2);
    }
  } else {
    {
#line 111
    fusionneBitTabStatic(tab1, tab2);
    }
  }
#line 112
  return;
}
}
#line 114 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/bit_tab.c"
int nbSequenceInBitTab(Bit_Tab *tab ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 116
  if ((int )*(tab + 0) & 128) {
    {
#line 117
    tmp = nbSequenceInBitTabDynamic(tab);
    }
#line 117
    return (tmp);
  }
  {
#line 118
  tmp___0 = nbSequenceInBitTabStatic(tab);
  }
#line 118
  return (tmp___0);
}
}
#line 121 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/bit_tab.c"
void printBitTab(Bit_Tab *tab ) 
{ 
  int i ;
  int value ;
  int nb_element ;
  unsigned char mask ;

  {
#line 125
  mask = (unsigned char)0;
#line 126
  if ((int )*(tab + 0) & 128) {
    {
#line 128
    printf((char const   */* __restrict  */)"d:");
#line 129
    nb_element = nbSequenceInBitTabDynamic(tab);
#line 130
    i = 0;
    }
    {
#line 130
    while (1) {
      while_continue: /* CIL Label */ ;
#line 130
      if (! (i < nb_element)) {
#line 130
        goto while_break;
      }
      {
#line 131
      printf((char const   */* __restrict  */)"%d,", (int )*((unsigned short *)(tab + 2) + i));
#line 130
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 132
    return;
  }
  {
#line 134
  printf((char const   */* __restrict  */)"s:");
#line 135
  value = 0;
#line 136
  mask = (unsigned char)64;
  }
  {
#line 136
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 136
    if (! ((int )mask != 0)) {
#line 136
      goto while_break___0;
    }
#line 137
    if ((int )*(tab + 0) & (int )mask) {
      {
#line 138
      printf((char const   */* __restrict  */)"%d,", value);
      }
    }
#line 136
    mask = (unsigned char )((int )mask >> 1);
#line 136
    value ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 139
  i = 1;
  {
#line 139
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 139
    if (! (i < SIZE_STATIC_BIT_TAB)) {
#line 139
      goto while_break___1;
    }
#line 140
    mask = (unsigned char)128;
    {
#line 140
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 140
      if (! ((int )mask != 0)) {
#line 140
        goto while_break___2;
      }
#line 141
      if ((int )*(tab + i) & (int )mask) {
        {
#line 142
        printf((char const   */* __restrict  */)"%d,", value);
        }
      }
#line 140
      mask = (unsigned char )((int )mask >> 1);
#line 140
      value ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 139
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 143
  return;
}
}
#line 147 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/bit_tab.c"
void convertBitTab(Bit_Tab **tab ) 
{ 
  Bit_Tab *tmp ;
  Bit_Tab *tmp___0 ;
  int nb_elment ;
  int tmp___1 ;
  int i ;

  {
  {
#line 149
  tmp___0 = AllocBitTabStatic();
#line 149
  tmp = tmp___0;
#line 150
  tmp___1 = nbSequenceInBitTabDynamic(*tab);
#line 150
  nb_elment = tmp___1;
#line 153
  i = 0;
  }
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if (! (i < nb_elment)) {
#line 153
      goto while_break;
    }
    {
#line 155
    addBitTabValueStatic(& tmp, (int )*((unsigned short *)(*tab + 2) + i));
#line 153
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 157
  free((void *)*tab);
#line 158
  *tab = tmp;
  }
#line 159
  return;
}
}
#line 161 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/bit_tab.c"
void addBitTabValueStatic(Bit_Tab **tab , int value ) 
{ 
  int position ;
  int offset ;

  {
#line 166
  position = (value + 1) / 8;
#line 167
  offset = (value + 1) % 8;
#line 168
  offset = 128 >> offset;
#line 169
  *(*tab + position) = (Bit_Tab )((int )*(*tab + position) | offset);
#line 170
  return;
}
}
#line 172 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/bit_tab.c"
void addBitTabValueDynamic(Bit_Tab **tab , int value ) 
{ 
  unsigned short nb_element ;
  unsigned short i ;
  void *tmp ;

  {
#line 174
  nb_element = (unsigned short)0;
#line 175
  nb_element = (unsigned short )((((int )*(*tab + 0) & 127) << 8) | (int )*(*tab + 1));
#line 178
  if ((int )nb_element == CHANGE_LIMITE) {
    {
#line 180
    convertBitTab(tab);
#line 181
    addBitTabValueStatic(tab, value);
    }
#line 182
    return;
  }
#line 184
  i = (unsigned short)0;
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if ((int )i < (int )nb_element) {
#line 184
      if (! ((int )*((unsigned short *)(*tab + 2) + i) != value)) {
#line 184
        goto while_break;
      }
    } else {
#line 184
      goto while_break;
    }
#line 184
    i = (unsigned short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 185
  if ((int )i != (int )nb_element) {
#line 185
    if ((int )*((unsigned short *)(*tab + 2) + i) == value) {
#line 186
      return;
    }
  }
  {
#line 187
  nb_element = (unsigned short )((int )nb_element + 1);
#line 188
  tmp = realloc((void *)*tab, 2UL + (unsigned long )nb_element * sizeof(unsigned short ));
#line 188
  *tab = (Bit_Tab *)tmp;
#line 189
  *((unsigned short *)(*tab + 2) + ((int )nb_element - 1)) = (unsigned short )value;
#line 190
  *(*tab + 0) = (Bit_Tab )(128 | ((int )nb_element >> 8));
#line 191
  *(*tab + 1) = (Bit_Tab )nb_element;
  }
#line 192
  return;
}
}
#line 195 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/bit_tab.c"
int nbSequenceInBitTabStatic(Bit_Tab *tab ) 
{ 
  int i ;
  unsigned char k ;
  int nb_element ;

  {
#line 199
  nb_element = 0;
#line 201
  k = (unsigned char)64;
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    if (! ((int )k != 0)) {
#line 201
      goto while_break;
    }
#line 202
    if ((int )*(tab + 0) & (int )k) {
#line 203
      nb_element ++;
    }
#line 201
    k = (unsigned char )((int )k >> 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  i = 1;
  {
#line 205
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 205
    if (! (i < SIZE_STATIC_BIT_TAB)) {
#line 205
      goto while_break___0;
    }
#line 206
    k = (unsigned char)128;
    {
#line 206
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 206
      if (! ((int )k != 0)) {
#line 206
        goto while_break___1;
      }
#line 207
      if ((int )*(tab + i) & (int )k) {
#line 208
        nb_element ++;
      }
#line 206
      k = (unsigned char )((int )k >> 1);
    }
    while_break___1: /* CIL Label */ ;
    }
#line 205
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 209
  return (nb_element);
}
}
#line 212 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/bit_tab.c"
int nbSequenceInBitTabDynamic(Bit_Tab *tab ) 
{ 


  {
#line 214
  return ((((int )*(tab + 0) & 127) << 8) | (int )*(tab + 1));
}
}
#line 217 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/bit_tab.c"
void fusionneBitTabStatic(Bit_Tab **tab1 , Bit_Tab *tab2 ) 
{ 
  int i ;
  int nb_element ;

  {
#line 219
  i = 0;
#line 221
  if ((int )*(tab2 + 0) & 128) {
    {
#line 223
    nb_element = nbSequenceInBitTabDynamic(tab2);
#line 224
    i = 0;
    }
    {
#line 224
    while (1) {
      while_continue: /* CIL Label */ ;
#line 224
      if (! (i < nb_element)) {
#line 224
        goto while_break;
      }
      {
#line 225
      addBitTabValueStatic(tab1, (int )*((unsigned short *)(tab2 + 2) + i));
#line 224
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 226
    return;
  }
#line 229
  i = 0;
  {
#line 229
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 229
    if (! (i < SIZE_STATIC_BIT_TAB)) {
#line 229
      goto while_break___0;
    }
#line 230
    *(*tab1 + i) = (Bit_Tab )((int )*(*tab1 + i) | (int )*(tab2 + i));
#line 229
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 231
  return;
}
}
#line 233 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/bit_tab.c"
void fusionneBitTabDynamic(Bit_Tab **tab1 , Bit_Tab *tab2 ) 
{ 
  int i ;
  int nb_element ;
  int value ;
  unsigned char mask ;

  {
#line 238
  if ((int )*(tab2 + 0) & 128) {
    {
#line 240
    nb_element = nbSequenceInBitTabDynamic(tab2);
#line 241
    i = 0;
    }
    {
#line 241
    while (1) {
      while_continue: /* CIL Label */ ;
#line 241
      if (! (i < nb_element)) {
#line 241
        goto while_break;
      }
      {
#line 242
      addBitTabValue(tab1, (int )*((unsigned short *)(tab2 + 2) + i));
#line 241
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 243
    return;
  }
#line 247
  value = 0;
#line 248
  mask = (unsigned char)64;
  {
#line 248
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 248
    if (! ((int )mask != 0)) {
#line 248
      goto while_break___0;
    }
#line 249
    if ((int )*(tab2 + 0) & (int )mask) {
      {
#line 250
      addBitTabValue(tab1, value);
      }
    }
#line 248
    mask = (unsigned char )((int )mask >> 1);
#line 248
    value ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 251
  i = 1;
  {
#line 251
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 251
    if (! (i < SIZE_STATIC_BIT_TAB)) {
#line 251
      goto while_break___1;
    }
#line 252
    mask = (unsigned char)128;
    {
#line 252
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 252
      if (! ((int )mask != 0)) {
#line 252
        goto while_break___2;
      }
#line 253
      if ((int )*(tab2 + i) & (int )mask) {
        {
#line 254
        addBitTabValue(tab1, value);
        }
      }
#line 252
      mask = (unsigned char )((int )mask >> 1);
#line 252
      value ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 251
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 255
  return;
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 47 "include/shufflet.h"
char wdir[64]  ;
#line 48 "include/shufflet.h"
int debugflag  ;
#line 49 "include/shufflet.h"
FILE *dlog  ;
#line 50 "include/shufflet.h"
char alpha[128]  ;
#line 53
void generatename(char *seqname___0 , int n , int nseq , char *shfseqname ) ;
#line 62
void Error(int code , char *message ) ;
#line 63
void Warning(char *message ) ;
#line 66
void indexseq(signed char *seq , int seqlen , int *letter ) ;
#line 67
void kletcount(signed char *seq , int seqlen , int k , int m , int *count ) ;
#line 68
int kletverify(signed char *seq , int seqlen , int k , int m , int *count0 , int *count1 ) ;
#line 70
int edgecount(int k , int m , int last , int *count , int *vdeg ) ;
#line 71
void kletoutput(FILE *fp , int k , int m , int *count ) ;
#line 73
int ind2hash(char *klet , int k , int m ) ;
#line 74
void shuffle(int m , int k , int nver , int *count , int *vdeg , int first , int last ,
             int *lastedge , char *seq ) ;
#line 76
void monoshuffle(int seqlen , char *seq ) ;
#line 84
int readnextseq(FILE *fp , char *seqname___0 , char **seq , int *maxseqlenalloc ,
                char *errmsg ) ;
#line 86
void seqoutput(char *seq , int seqlen , int linelen ) ;
#line 90
unsigned int readseed(char *filename ) ;
#line 91
int writeseed(char *filename ) ;
#line 41 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/shufflet.c"
int seqno  ;
#line 41 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/shufflet.c"
int sizealpha  ;
#line 42 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/shufflet.c"
char seqname[64]  ;
#line 47 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/shufflet.c"
void usage(void) 
{ 


  {
  {
#line 49
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: shufflet [OPTIONS] NSEQ ORDER <INFILE >OUTFILE\n");
#line 50
  exit(1);
  }
}
}
#line 57 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/shufflet.c"
int readseq(int k , FILE *infile , int **nver , int ***count , int ***vdeg , int **first ,
            int **last , char ***seqstart , int **seqlen , int *maxsizeseq , int nbseqalloc ,
            char *alphaseq___0 , char ***origseq ) 
{ 
  char *seq ;
  char errstr[80] ;
  int nklets ;
  int nk1lets ;
  int j ;
  int maxseqlenalloc ;
  int letter[128] ;
  double tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;

  {
  {
#line 69
  *maxsizeseq = 0;
#line 70
  strcpy((char */* __restrict  */)(alpha), (char const   */* __restrict  */)alphaseq___0);
#line 71
  strcpy((char */* __restrict  */)(wdir), (char const   */* __restrict  */)".");
  }
#line 73
  if (k <= 0) {
    {
#line 74
    usage();
    }
  }
#line 75
  if (k > 10) {
    {
#line 77
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Maximum order: %i\n",
            10);
#line 78
    exit(2);
    }
  }
#line 82
  sizealpha = 0;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! (sizealpha != 128)) {
#line 82
      goto while_break;
    }
#line 83
    letter[sizealpha] = -1;
#line 82
    sizealpha ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  sizealpha = 0;
  {
#line 86
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 86
    if (! ((int )*(alpha + sizealpha) != 36)) {
#line 86
      goto while_break___0;
    }
#line 87
    letter[(int )*(alpha + sizealpha)] = sizealpha;
#line 86
    sizealpha ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 89
  tmp = pow((double )sizealpha, (double )k);
#line 89
  nklets = (int )tmp;
#line 91
  nk1lets = nklets / sizealpha;
  }
#line 92
  if (nklets > 8000) {
    {
#line 93
    Error(2, (char *)"Max size of k-let table exceeded (choose smaller k)\n");
    }
  }
  {
#line 96
  tmp___0 = malloc(2000UL * sizeof(char ));
#line 96
  seq = (char *)tmp___0;
  }
#line 97
  if (! ((unsigned long )seq != (unsigned long )((void *)0))) {
    {
#line 97
    __assert_fail("seq!=((void *)0)", "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/shufflet.c",
                  97U, "readseq");
    }
  }
#line 98
  maxseqlenalloc = 2000;
#line 102
  seqno = 0;
  {
#line 103
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 103
    tmp___13 = readnextseq(infile, (char *)(seqname), & seq, & maxseqlenalloc, (char *)(errstr));
#line 103
    *(*seqlen + seqno) = tmp___13;
    }
#line 103
    if (! (tmp___13 >= 0)) {
#line 103
      goto while_break___1;
    }
#line 107
    if (*(*seqlen + seqno) > *maxsizeseq) {
#line 108
      *maxsizeseq = *(*seqlen + seqno);
    }
#line 110
    if (*(*seqlen + seqno) < k) {
#line 112
      if (*(*seqlen + seqno) == 0) {
        {
#line 113
        Warning((char *)"Empty sequence");
        }
      } else {
        {
#line 115
        Warning((char *)"Too short sequence");
        }
      }
#line 116
      goto while_continue___1;
    }
#line 120
    if (k == 1) {
      {
#line 122
      tmp___1 = malloc((unsigned long )(*(*seqlen + seqno) + 2) * sizeof(char ));
#line 122
      *(*origseq + seqno) = (char *)tmp___1;
      }
#line 123
      if (! ((unsigned long )*(*origseq + seqno) != (unsigned long )((void *)0))) {
        {
#line 123
        __assert_fail("(*origseq)[seqno]!=((void *)0)", "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/shufflet.c",
                      123U, "readseq");
        }
      }
      {
#line 124
      strncpy((char */* __restrict  */)*(*origseq + seqno), (char const   */* __restrict  */)seq,
              (size_t )*(*seqlen + seqno));
      }
    }
    {
#line 128
    indexseq((signed char *)seq, *(*seqlen + seqno), (int *)(letter));
#line 130
    tmp___2 = malloc(sizeof(int ) * (unsigned long )nklets);
#line 130
    *(*count + seqno) = (int *)tmp___2;
#line 131
    tmp___3 = malloc(sizeof(int ) * (unsigned long )nk1lets);
#line 131
    *(*vdeg + seqno) = (int *)tmp___3;
    }
#line 132
    if ((unsigned long )*(*count + seqno) != (unsigned long )((void *)0)) {
#line 132
      if (! ((unsigned long )*(*vdeg + seqno) != (unsigned long )((void *)0))) {
        {
#line 132
        __assert_fail("(*count)[seqno]!=((void *)0) && (*vdeg)[seqno]!=((void *)0)",
                      "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/shufflet.c",
                      132U, "readseq");
        }
      }
    } else {
      {
#line 132
      __assert_fail("(*count)[seqno]!=((void *)0) && (*vdeg)[seqno]!=((void *)0)",
                    "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/shufflet.c",
                    132U, "readseq");
      }
    }
#line 134
    if (k > 1) {
      {
#line 136
      tmp___4 = malloc(sizeof(char ) * (unsigned long )(k - 1));
#line 136
      *(*seqstart + seqno) = (char *)tmp___4;
      }
#line 137
      if (! ((unsigned long )*(*seqstart + seqno) != (unsigned long )((void *)0))) {
        {
#line 137
        __assert_fail("(*seqstart)[seqno] != ((void *)0)", "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/shufflet.c",
                      137U, "readseq");
        }
      }
#line 138
      j = 0;
      {
#line 138
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 138
        if (! (j < k - 1)) {
#line 138
          goto while_break___2;
        }
#line 139
        *(*(*seqstart + seqno) + j) = *(seq + j);
#line 138
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 143
    if (debugflag) {
      {
#line 144
      fprintf((FILE */* __restrict  */)dlog, (char const   */* __restrict  */)"kletcount\n");
      }
    }
    {
#line 145
    kletcount((signed char *)seq, *(*seqlen + seqno), k, sizealpha, *(*count + seqno));
    }
#line 147
    if (debugflag) {
      {
#line 148
      fprintf((FILE */* __restrict  */)dlog, (char const   */* __restrict  */)"edgecount\n");
      }
    }
    {
#line 150
    *(*first + seqno) = ind2hash(seq, k - 1, sizealpha);
#line 152
    *(*last + seqno) = ind2hash(((seq + *(*seqlen + seqno)) - k) + 1, k - 1, sizealpha);
#line 154
    *(*nver + seqno) = edgecount(k, sizealpha, *(*last + seqno), *(*count + seqno),
                                 *(*vdeg + seqno));
    }
#line 157
    if (debugflag) {
      {
#line 159
      kletoutput(dlog, k, sizealpha, *(*count + seqno));
#line 160
      kletoutput(dlog, k - 1, sizealpha, *(*vdeg + seqno));
      }
    }
#line 163
    seqno ++;
#line 166
    if (seqno == nbseqalloc) {
      {
#line 168
      nbseqalloc += 500;
#line 169
      tmp___5 = realloc((void *)*count, sizeof(int *) * (unsigned long )nbseqalloc);
#line 169
      *count = (int **)tmp___5;
#line 170
      tmp___6 = realloc((void *)*seqlen, sizeof(int ) * (unsigned long )nbseqalloc);
#line 170
      *seqlen = (int *)tmp___6;
#line 171
      tmp___7 = realloc((void *)*vdeg, sizeof(int *) * (unsigned long )nbseqalloc);
#line 171
      *vdeg = (int **)tmp___7;
#line 172
      tmp___8 = realloc((void *)*first, sizeof(int ) * (unsigned long )nbseqalloc);
#line 172
      *first = (int *)tmp___8;
#line 173
      tmp___9 = realloc((void *)*last, sizeof(int ) * (unsigned long )nbseqalloc);
#line 173
      *last = (int *)tmp___9;
#line 174
      tmp___10 = realloc((void *)*nver, sizeof(int ) * (unsigned long )nbseqalloc);
#line 174
      *nver = (int *)tmp___10;
      }
#line 175
      if (! ((unsigned long )*count != (unsigned long )((void *)0))) {
        {
#line 175
        __assert_fail("*count != ((void *)0)", "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/shufflet.c",
                      175U, "readseq");
        }
      }
#line 176
      if (! ((unsigned long )*vdeg != (unsigned long )((void *)0))) {
        {
#line 176
        __assert_fail("*vdeg != ((void *)0)", "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/shufflet.c",
                      176U, "readseq");
        }
      }
#line 177
      if (! ((unsigned long )*seqlen != (unsigned long )((void *)0))) {
        {
#line 177
        __assert_fail("*seqlen != ((void *)0)", "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/shufflet.c",
                      177U, "readseq");
        }
      }
#line 178
      if (! ((unsigned long )*first != (unsigned long )((void *)0))) {
        {
#line 178
        __assert_fail("*first != ((void *)0)", "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/shufflet.c",
                      178U, "readseq");
        }
      }
#line 179
      if (! ((unsigned long )*last != (unsigned long )((void *)0))) {
        {
#line 179
        __assert_fail("*last != ((void *)0)", "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/shufflet.c",
                      179U, "readseq");
        }
      }
#line 180
      if (! ((unsigned long )*nver != (unsigned long )((void *)0))) {
        {
#line 180
        __assert_fail("*nver != ((void *)0)", "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/shufflet.c",
                      180U, "readseq");
        }
      }
#line 182
      if (k == 1) {
        {
#line 184
        tmp___11 = realloc((void *)*origseq, sizeof(char *) * (unsigned long )nbseqalloc);
#line 184
        *origseq = (char **)tmp___11;
        }
#line 185
        if (! ((unsigned long )*origseq != (unsigned long )((void *)0))) {
          {
#line 185
          __assert_fail("*origseq != ((void *)0)", "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/shufflet.c",
                        185U, "readseq");
          }
        }
      } else {
        {
#line 189
        tmp___12 = realloc((void *)*seqstart, sizeof(char *) * (unsigned long )nbseqalloc);
#line 189
        *seqstart = (char **)tmp___12;
        }
#line 190
        if (! ((unsigned long )*seqstart != (unsigned long )((void *)0))) {
          {
#line 190
          __assert_fail("*seqstart != ((void *)0)", "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/shufflet.c",
                        190U, "readseq");
          }
        }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 196
  return (seqno);
}
}
#line 203 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/shufflet.c"
void generateseq(int k , int *nver , int **count , int **vdeg , int *first , int *last ,
                 char **seqstart , int nbseq , int *seqlen , int *count1 , int *vdeg1 ,
                 int nklets , int nk1lets , int *lastedge , char **seq ) 
{ 
  char seedfilename[64] ;
  int i ;
  int j ;
  int tmp ;

  {
  {
#line 214
  sprintf((char */* __restrict  */)(seedfilename), (char const   */* __restrict  */)"%s/%s",
          wdir, "seed");
#line 215
  readseed(seedfilename);
  }
#line 228
  if (k == 1) {
#line 230
    i = 0;
    {
#line 230
    while (1) {
      while_continue: /* CIL Label */ ;
#line 230
      if (! (i != nbseq)) {
#line 230
        goto while_break;
      }
      {
#line 233
      monoshuffle(*(seqlen + i), *(seq + i));
#line 235
      *(*(seq + i) + *(seqlen + i)) = (char )'$';
#line 236
      *(*(seq + i) + (*(seqlen + i) + 1)) = (char )'\000';
#line 230
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 248
    i = 0;
    {
#line 248
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 248
      if (! (i != nbseq)) {
#line 248
        goto while_break___0;
      }
      {
#line 250
      memcpy((void */* __restrict  */)*(seq + i), (void const   */* __restrict  */)*(seqstart + i),
             (size_t )(k - 1));
#line 258
      j = 0;
      }
      {
#line 258
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 258
        if (! (j < nklets)) {
#line 258
          goto while_break___1;
        }
#line 259
        *(count1 + j) = *(*(count + i) + j);
#line 258
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 260
      j = 0;
      {
#line 260
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 260
        if (! (j < nk1lets)) {
#line 260
          goto while_break___2;
        }
#line 261
        *(vdeg1 + j) = *(*(vdeg + i) + j);
#line 260
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 265
      shuffle(sizealpha, k, *(nver + i), count1, vdeg1, *(first + i), *(last + i),
              lastedge, *(seq + i));
#line 268
      *(*(seq + i) + *(seqlen + i)) = (char )'$';
#line 269
      *(*(seq + i) + (*(seqlen + i) + 1)) = (char )'\000';
#line 272
      tmp = kletverify((signed char *)*(seq + i), *(seqlen + i), k, sizealpha, *(count + i),
                       count1);
      }
#line 272
      if (! tmp) {
        {
#line 273
        Error(99, (char *)"k-let count mismatch in shuffled seq!!!");
        }
      }
      {
#line 275
      seqoutput(*(seq + i), *(seqlen + i), 60);
#line 248
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 286
  writeseed(seedfilename);
  }
#line 287
  return;
}
}
#line 295 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/shufflet.c"
void Error(int code , char *message ) 
{ 


  {
  {
#line 297
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nError: sequence #%i \"%s\"",
          seqno, seqname);
#line 300
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)":\n");
#line 301
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          message);
  }
#line 303
  return;
}
}
#line 310 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/shufflet.c"
void Warning(char *message ) 
{ 


  {
  {
#line 312
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nWarning: sequence #%i \"%s\"",
          seqno, seqname);
#line 315
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)":\n");
#line 316
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          message);
  }
#line 317
  return;
}
}
#line 325 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/shufflet.c"
void generatename(char *seqname___0 , int n , int nseq , char *shfseqname ) 
{ 
  int tmp ;

  {
#line 327
  if ((int )*(seqname___0 + 0) == 0) {
#line 327
    goto _L;
  } else {
    {
#line 327
    tmp = strcmp((char const   *)seqname___0, "(unnamed)");
    }
#line 327
    if (tmp == 0) {
      _L: /* CIL Label */ 
#line 329
      if (nseq > 1) {
        {
#line 330
        sprintf((char */* __restrict  */)shfseqname, (char const   */* __restrict  */)"SHF%i",
                n);
        }
      } else {
#line 332
        *(shfseqname + 0) = (char )'\000';
      }
    } else {
      {
#line 335
      sprintf((char */* __restrict  */)shfseqname, (char const   */* __restrict  */)"%s_SHF%i",
              seqname___0, n);
      }
    }
  }
#line 336
  return;
}
}
#line 425 "/usr/include/stdio.h"
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 702
extern int ungetc(int __c , FILE *__stream ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 46 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/seqio.c"
int readnextseq(FILE *fp , char *seqname___0 , char **seq , int *maxseqlenalloc ,
                char *errmsg ) 
{ 
  int c ;
  int pos___3 ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  {
#line 49
  pos___3 = 0;
#line 51
  *(*seq + 0) = (char )'\000';
#line 52
  sprintf((char */* __restrict  */)seqname___0, (char const   */* __restrict  */)"(unnamed)");
#line 54
  c = fgetc(fp);
  }
#line 56
  if (c == -1) {
#line 57
    return (-1);
  } else
#line 58
  if (c == 62) {
    {
#line 60
    c = fgetc(fp);
#line 61
    ungetc(c, fp);
    }
#line 62
    if (c != 10) {
#line 62
      if (c != -1) {
        {
#line 63
        fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%20s",
               seqname___0);
        }
      }
    }
    {
#line 65
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 65
      c = fgetc(fp);
      }
#line 65
      if (c != 10) {
#line 65
        if (! (c != -1)) {
#line 65
          goto while_break;
        }
      } else {
#line 65
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 68
    ungetc(c, fp);
    }
  }
  {
#line 71
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 71
    c = fgetc(fp);
    }
#line 71
    if (c != 62) {
#line 71
      if (c != 47) {
#line 71
        if (c != 42) {
#line 71
          if (! (c != -1)) {
#line 71
            goto while_break___0;
          }
        } else {
#line 71
          goto while_break___0;
        }
      } else {
#line 71
        goto while_break___0;
      }
    } else {
#line 71
      goto while_break___0;
    }
    {
#line 72
    tmp___2 = __ctype_b_loc();
    }
#line 72
    if ((int const   )*(*tmp___2 + c) & 1024) {
#line 74
      if (pos___3 == *maxseqlenalloc) {
        {
#line 76
        *maxseqlenalloc += 2000;
#line 77
        tmp = realloc((void *)*seq, sizeof(char ) * (unsigned long )*maxseqlenalloc);
#line 77
        *seq = (char *)tmp;
        }
#line 78
        if (! ((unsigned long )*seq != (unsigned long )((void *)0))) {
          {
#line 78
          __assert_fail("*seq != ((void *)0)", "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/seqio.c",
                        78U, "readnextseq");
          }
        }
      }
      {
#line 81
      tmp___0 = pos___3;
#line 81
      pos___3 ++;
#line 81
      tmp___1 = toupper(c);
#line 81
      *(*seq + tmp___0) = (char )tmp___1;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 84
  if (c == 62) {
    {
#line 85
    ungetc(c, fp);
    }
  }
#line 86
  *(*seq + pos___3) = (char )'\000';
#line 87
  if (pos___3 == 0) {
#line 87
    if (c == -1) {
#line 90
      return (-1);
    } else {
#line 93
      return (pos___3);
    }
  } else {
#line 93
    return (pos___3);
  }
}
}
#line 105 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/seqio.c"
void seqoutput(char *seq , int seqlen , int linelen ) 
{ 
  int i ;

  {
#line 109
  i = 0;
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! (i < seqlen)) {
#line 109
      goto while_break;
    }
#line 110
    *(seq + i) = alpha[(int )*(seq + i)];
#line 109
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 111
  return;
}
}
#line 89 "Spell/include/global.h"
void initEntiers(void) ;
#line 76 "Spell/include/criteres.h"
Flag verifCriteres(Criteres cr ) ;
#line 81
int addSaut2Code(int oldcode , int saut , int curbloc , P_Criteres cr ) ;
#line 83
void initTabSauts(P_Criteres cr ) ;
#line 61 "include/structures.h"
unsigned char Translation_Table[255] ;
#line 77 "include/libfasta.h"
FastaSequencePtr FreeFastaSequence(FastaSequencePtr seq ) ;
#line 78
FastaSequencePtr NewFastaSequence(void) ;
#line 80
Bool ReadFastaSequence(FILE *streamin , FastaSequencePtr seq ) ;
#line 32 "include/liste_pos.h"
int getValue(ListePositions *lpos , int i ) ;
#line 36
void Free_ListePositions(ListePositions *lpos ) ;
#line 50 "Spell/include/pile_occ.h"
P_PileOcc creePileOcc(void) ;
#line 51
void ajouteDummy(P_PileOcc p ) ;
#line 52
int getPrecDummy(P_PileOcc p ) ;
#line 53
void ajouteInitOcc2Pile(P_PileOcc p , Noeud *x ) ;
#line 54
void ajouteOcc2Pile(P_PileOcc p , Noeud *x , int num , int lon , int err , int blocerr ,
                    int saut , int codesaut ) ;
#line 59
void videPile(P_PileOcc p ) ;
#line 63
void afficheLastOcc(FILE *f___0 , P_PileOcc pocc___1 , int l , P_Criteres cr , unsigned int *nboccex ) ;
#line 37 "Spell/include/model.h"
P_mod allocModel(void) ;
#line 43
void changeModel(P_mod mod , int symbol ) ;
#line 55 "include/allocateurs.h"
void Free_All_Liste_Cell(void) ;
#line 59
void Free_Arbre(Noeud *Racine ) ;
#line 31 "include/global_fonctions.h"
void Init_All(unsigned char *Alphabet , int Joker , int nb_sequence ) ;
#line 75
void UpdateBit_TabForAllTree(Noeud *N ) ;
#line 62 "Spell/include/grep+.h"
Flag creeArbreSuffixeFromFile(Arbre *a , char *fic , int maxlongmod___0 , char *alphaseq___0 ) ;
#line 66
void libereArbreSuffixeFromFile(Arbre a ) ;
#line 27 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/grep+.c"
void keepModel(P_PileOcc pocc___1 , int l , P_Criteres cr , unsigned int *nboccex ,
               FILE *f___0 ) ;
#line 31
Flag avanceBranche(P_occ next___1 , P_occ tmp , int symbol , int trans , Flag flag_noeud ,
                   P_Criteres cr , int curbloc , Flag multiblocs ) ;
#line 34
int gestionSaut(P_PileOcc pocc___1 , P_Criteres cr , int curbloc , signed char **text___0 ) ;
#line 38
Flag chargeSequence(Arbre *a , char *fic ) ;
#line 41
Flag creeArbreSuffixe(Arbre *a , int maxlongmod___0 , char *alphaseq___0 ) ;
#line 46
int nbSymbSeq ;
#line 48
int carseq2num[127] ;
#line 49
Flag TabSymb[127][127] ;
#line 51
int numSAUT ;
#line 72 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/grep+.c"
void keepModel(P_PileOcc pocc___1 , int l , P_Criteres cr , unsigned int *nboccex ,
               FILE *f___0 ) 
{ 


  {
  {
#line 76
  afficheLastOcc(f___0, pocc___1, l, cr, nboccex);
  }
#line 78
  return;
}
}
#line 95 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/grep+.c"
Flag avanceBranche(P_occ next___1 , P_occ tmp , int symbol , int trans , Flag flag_noeud ,
                   P_Criteres cr , int curbloc , Flag multiblocs ) 
{ 


  {
#line 104
  if ((int )flag_noeud == 0) {
#line 106
    if (TabSymb[symbol][trans]) {
#line 108
      next___1->xerr = tmp->xerr;
#line 109
      next___1->blocerr = tmp->blocerr;
    } else {
#line 113
      next___1->xerr = tmp->xerr + 1;
#line 115
      if (next___1->xerr == cr->maxerr + 1) {
#line 116
        return ((Flag )0);
      }
#line 118
      if ((int )multiblocs == 1) {
#line 120
        next___1->blocerr = tmp->blocerr + 1;
#line 121
        if (next___1->blocerr == *(cr->maxerrblocs + curbloc) + 1) {
#line 122
          return ((Flag )0);
        }
      }
    }
#line 126
    next___1->x = tmp->x;
#line 127
    next___1->num = tmp->num;
#line 128
    next___1->lon = tmp->lon + 1;
  } else {
#line 133
    next___1->x = *((tmp->x)->fils + tmp->num);
#line 135
    if ((unsigned long )*((next___1->x)->fils + trans) == (unsigned long )((void *)0)) {
#line 136
      return ((Flag )0);
    }
#line 138
    if (TabSymb[symbol][trans]) {
#line 140
      next___1->xerr = tmp->xerr;
#line 141
      next___1->blocerr = tmp->blocerr;
    } else {
#line 145
      next___1->xerr = tmp->xerr + 1;
#line 147
      if (next___1->xerr == cr->maxerr + 1) {
#line 148
        return ((Flag )0);
      }
#line 150
      if ((int )multiblocs == 1) {
#line 152
        next___1->blocerr = tmp->blocerr + 1;
#line 153
        if (next___1->blocerr == *(cr->maxerrblocs + curbloc) + 1) {
#line 154
          return ((Flag )0);
        }
      }
    }
#line 158
    next___1->num = trans;
#line 159
    next___1->lon = 1;
  }
#line 163
  if ((int )multiblocs == 1) {
#line 165
    next___1->saut = tmp->saut;
#line 166
    next___1->codesaut = tmp->codesaut;
  }
#line 169
  return ((Flag )1);
}
}
#line 176 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/grep+.c"
int sauteSymbole(Occ curocc , P_PileOcc pocc___1 , P_Criteres cr , int curbloc , int longsaut ,
                 signed char **text___0 ) 
{ 
  int lmaxbr ;
  Noeud *tmpnoeud ;
  Occ tmpocc ;
  int res ;
  int trans ;
  char carseq ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 182
  res = 0;
#line 187
  tmpnoeud = *((curocc.x)->fils + curocc.num);
#line 189
  if ((unsigned int )tmpnoeud->debut & 2147483648U) {
    {
#line 190
    tmp = getValue(Liste_positions_fin, ((Feuille *)tmpnoeud)->fin_deb);
#line 190
    lmaxbr = tmp - (((Feuille *)tmpnoeud)->debut & 2147483647);
    }
  } else {
#line 193
    lmaxbr = tmpnoeud->fin - tmpnoeud->debut;
  }
  {
#line 200
  tmp___0 = addSaut2Code(curocc.codesaut, longsaut, curbloc, cr);
#line 200
  ajouteOcc2Pile(pocc___1, curocc.x, curocc.num, curocc.lon, curocc.xerr, 0, curocc.saut + longsaut,
                 tmp___0);
#line 203
  res ++;
#line 204
  longsaut ++;
  }
#line 206
  if (curocc.lon != lmaxbr) {
#line 208
    (curocc.lon) ++;
#line 210
    carseq = (char )*(*(text___0 + tmpnoeud->sequence_number) + (((tmpnoeud->debut & 2147483647) + curocc.lon) - 1));
#line 213
    if ((int )carseq == 36) {
#line 214
      return (res);
    }
#line 216
    if (longsaut <= (cr->saut + curbloc)->max) {
      {
#line 217
      tmp___1 = sauteSymbole(curocc, pocc___1, cr, curbloc, longsaut, text___0);
#line 217
      res += tmp___1;
      }
    }
  } else
#line 221
  if (longsaut <= (cr->saut + curbloc)->max) {
#line 223
    tmpocc.x = tmpnoeud;
#line 224
    tmpocc.lon = 1;
#line 225
    tmpocc.xerr = curocc.xerr;
#line 226
    tmpocc.codesaut = curocc.codesaut;
#line 227
    tmpocc.saut = curocc.saut;
#line 229
    if (((unsigned int )tmpnoeud->debut & 2147483648U) == 0U) {
#line 230
      trans = 0;
      {
#line 230
      while (1) {
        while_continue: /* CIL Label */ ;
#line 230
        if (! (trans != nbSymbSeq)) {
#line 230
          goto while_break;
        }
#line 232
        if ((unsigned long )*(tmpnoeud->fils + trans) != (unsigned long )((void *)0)) {
          {
#line 234
          tmpocc.num = trans;
#line 236
          tmp___2 = sauteSymbole(tmpocc, pocc___1, cr, curbloc, longsaut, text___0);
#line 236
          res += tmp___2;
          }
        }
#line 230
        trans ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 245
  return (res);
}
}
#line 251 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/grep+.c"
int sauteBranche(Occ curocc , P_PileOcc pocc___1 , P_Criteres cr , int curbloc , int longsaut ,
                 signed char **text___0 ) 
{ 
  int lmaxbr ;
  Noeud *tmpnoeud ;
  Noeud *newtmpnoeud ;
  Occ tmpocc ;
  int res ;
  int newlongsaut ;
  int trans ;
  char carseq ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 257
  res = 0;
#line 263
  tmpnoeud = *((curocc.x)->fils + curocc.num);
#line 265
  if ((unsigned int )tmpnoeud->debut & 2147483648U) {
    {
#line 266
    tmp = getValue(Liste_positions_fin, ((Feuille *)tmpnoeud)->fin_deb);
#line 266
    lmaxbr = tmp - (((Feuille *)tmpnoeud)->debut & 2147483647);
    }
  } else {
#line 268
    lmaxbr = tmpnoeud->fin - tmpnoeud->debut;
  }
#line 274
  if (curocc.lon != lmaxbr) {
#line 276
    if (lmaxbr - curocc.lon <= (cr->saut + curbloc)->min - longsaut) {
#line 278
      longsaut += lmaxbr - curocc.lon;
#line 279
      curocc.lon = lmaxbr;
#line 285
      carseq = (char )*(*(text___0 + tmpnoeud->sequence_number) + (((tmpnoeud->debut & 2147483647) + lmaxbr) - 1));
#line 288
      if ((int )carseq != 36) {
        {
#line 293
        tmp___0 = sauteBranche(curocc, pocc___1, cr, curbloc, longsaut, text___0);
#line 293
        res += tmp___0;
        }
      }
    } else {
      {
#line 298
      curocc.lon += (cr->saut + curbloc)->min - longsaut;
#line 299
      longsaut = (cr->saut + curbloc)->min;
#line 305
      tmp___1 = sauteSymbole(curocc, pocc___1, cr, curbloc, longsaut, text___0);
#line 305
      res += tmp___1;
      }
    }
  } else {
#line 310
    tmpocc.x = tmpnoeud;
#line 311
    tmpocc.xerr = curocc.xerr;
#line 312
    tmpocc.codesaut = curocc.codesaut;
#line 313
    tmpocc.saut = curocc.saut;
#line 315
    if (((unsigned int )tmpnoeud->debut & 2147483648U) == 0U) {
#line 316
      trans = 0;
      {
#line 316
      while (1) {
        while_continue: /* CIL Label */ ;
#line 316
        if (! (trans != nbSymbSeq)) {
#line 316
          goto while_break;
        }
#line 318
        tmpocc.num = trans;
#line 319
        newlongsaut = longsaut;
#line 321
        if ((unsigned long )*(tmpnoeud->fils + trans) != (unsigned long )((void *)0)) {
#line 323
          newtmpnoeud = *(tmpnoeud->fils + trans);
#line 325
          if ((unsigned int )newtmpnoeud->debut & 2147483648U) {
            {
#line 326
            tmp___2 = getValue(Liste_positions_fin, ((Feuille *)newtmpnoeud)->fin_deb);
#line 326
            lmaxbr = tmp___2 - (newtmpnoeud->debut & 2147483647);
            }
          } else {
#line 330
            lmaxbr = newtmpnoeud->fin - newtmpnoeud->debut;
          }
#line 332
          if (lmaxbr <= (cr->saut + curbloc)->min - longsaut) {
#line 334
            newlongsaut += lmaxbr;
#line 335
            tmpocc.lon = lmaxbr;
#line 341
            carseq = (char )*(*(text___0 + newtmpnoeud->sequence_number) + (((newtmpnoeud->debut & 2147483647) + lmaxbr) - 1));
#line 344
            if ((int )carseq != 36) {
              {
#line 349
              tmp___3 = sauteBranche(tmpocc, pocc___1, cr, curbloc, newlongsaut, text___0);
#line 349
              res += tmp___3;
              }
            }
          } else {
            {
#line 355
            tmpocc.lon = (cr->saut + curbloc)->min - newlongsaut;
#line 356
            newlongsaut = (cr->saut + curbloc)->min;
#line 362
            tmp___4 = sauteSymbole(tmpocc, pocc___1, cr, curbloc, newlongsaut, text___0);
#line 362
            res += tmp___4;
            }
          }
        }
#line 316
        trans ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 371
  return (res);
}
}
#line 377 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/grep+.c"
int gestionSaut(P_PileOcc pocc___1 , P_Criteres cr , int curbloc , signed char **text___0 ) 
{ 
  int pos___3 ;
  int precdummy ;
  Occ curocc ;
  P_occ tmpocc ;
  int res ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 383
  res = 0;
#line 385
  pos___3 = pocc___1->pos - 1;
#line 386
  precdummy = getPrecDummy(pocc___1);
#line 387
  tmpocc = pocc___1->occ + pos___3;
#line 389
  ajouteDummy(pocc___1);
  }
  {
#line 391
  while (1) {
    while_continue: /* CIL Label */ ;
#line 391
    if (pos___3 != precdummy) {
#line 391
      if (! ((unsigned long )tmpocc->x != (unsigned long )((void *)0))) {
#line 391
        goto while_break;
      }
    } else {
#line 391
      goto while_break;
    }
#line 393
    curocc = *tmpocc;
#line 395
    if ((cr->saut + curbloc)->min == 0) {
      {
#line 396
      tmp = sauteSymbole(curocc, pocc___1, cr, curbloc, 0, text___0);
#line 396
      res += tmp;
      }
    } else {
      {
#line 398
      tmp___0 = sauteBranche(curocc, pocc___1, cr, curbloc, 0, text___0);
#line 398
      res += tmp___0;
      }
    }
#line 399
    pos___3 --;
#line 400
    tmpocc = pocc___1->occ + pos___3;
  }
  while_break: /* CIL Label */ ;
  }
#line 406
  return (res);
}
}
#line 415 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/grep+.c"
int sommeBTOcc(P_PileOcc p , Bit_Tab **bt ) 
{ 
  int pos___3 ;
  int precdummy ;
  P_occ po ;
  int tmp ;

  {
  {
#line 420
  ReinitBitTab(bt);
#line 421
  pos___3 = p->pos - 1;
  }
#line 422
  if (pos___3 < 0) {
    {
#line 423
    fatalError((char *)"grep+.c: sommeBTOcc: wrong stack position\n");
    }
  }
  {
#line 424
  po = p->occ + pos___3;
#line 425
  precdummy = getPrecDummy(p);
  }
  {
#line 427
  while (1) {
    while_continue: /* CIL Label */ ;
#line 427
    if (pos___3 != precdummy) {
#line 427
      if (! ((unsigned long )po->x != (unsigned long )((void *)0))) {
#line 427
        goto while_break;
      }
    } else {
#line 427
      goto while_break;
    }
#line 433
    if ((unsigned int )(*((po->x)->fils + po->num))->debut & 2147483648U) {
      {
#line 435
      fusionneBitTab(bt, ((Feuille *)*((po->x)->fils + po->num))->sequences);
      }
    } else {
      {
#line 442
      fusionneBitTab(bt, (*((po->x)->fils + po->num))->sequences);
      }
    }
#line 447
    pos___3 --;
#line 448
    po --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 457
  tmp = nbSequenceInBitTab(*bt);
  }
#line 457
  return (tmp);
}
}
#line 478 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/grep+.c"
static P_mod model  =    (P_mod )((void *)0);
#line 479 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/grep+.c"
static P_PileOcc pocc  =    (P_PileOcc )((void *)0);
#line 480 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/grep+.c"
static P_occ next  =    (P_occ )((void *)0);
#line 481 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/grep+.c"
static Bit_Tab *colors_model  ;
#line 482 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/grep+.c"
static char flag  =    (char)0;
#line 465 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/grep+.c"
void chercheMot(Arbre a , P_Criteres cr , signed char *mot , unsigned int *nb_occ ,
                unsigned int *nbocc_ex , FILE *f___0 ) 
{ 
  int symbol ;
  int trans ;
  int lmaxbr ;
  int pos___3 ;
  int precdummy ;
  int longmod ;
  int curbloc ;
  P_occ tmpocc ;
  int nbocc ;
  char carseq ;
  void *tmp ;
  int tmp___0 ;
  Flag tmp___1 ;
  Flag tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 470
  longmod = 0;
#line 470
  curbloc = 0;
#line 475
  nbocc = 0;
#line 486
  if ((int )flag == 0) {
    {
#line 489
    model = allocModel();
#line 492
    colors_model = AllocBitTab();
#line 493
    ReinitBitTab(& colors_model);
#line 496
    tmp = calloc((size_t )1, sizeof(Occ ));
#line 496
    next = (P_occ )tmp;
    }
#line 497
    if ((unsigned long )next == (unsigned long )((void *)0)) {
      {
#line 498
      fatalError((char *)"doSpell: cannot allocate \'next\'\n");
      }
    }
    {
#line 501
    pocc = creePileOcc();
#line 502
    flag = (char)1;
    }
  } else {
    {
#line 506
    *(model->name + 0) = '\000';
#line 507
    model->lon = 0;
#line 509
    videPile(pocc);
    }
  }
  {
#line 512
  initOcc(next);
#line 515
  ajouteInitOcc2Pile(pocc, a.arbre);
  }
  {
#line 520
  while (1) {
    while_continue: /* CIL Label */ ;
#line 520
    if (! ((int )*mot != -1)) {
#line 520
      goto while_break;
    }
    {
#line 522
    symbol = (int )*mot;
#line 528
    pos___3 = pocc->pos - 1;
#line 529
    tmpocc = pocc->occ + pos___3;
#line 530
    precdummy = getPrecDummy(pocc);
#line 531
    ajouteDummy(pocc);
#line 533
    nbocc = 0;
    }
    {
#line 539
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 539
      if (pos___3 != precdummy) {
#line 539
        if (! ((unsigned long )tmpocc->x != (unsigned long )((void *)0))) {
#line 539
          goto while_break___0;
        }
      } else {
#line 539
        goto while_break___0;
      }
#line 541
      if ((unsigned int )(*((tmpocc->x)->fils + tmpocc->num))->debut & 2147483648U) {
        {
#line 541
        tmp___0 = getValue(Liste_positions_fin, ((Feuille *)*((tmpocc->x)->fils + tmpocc->num))->fin_deb);
#line 541
        lmaxbr = tmp___0 - ((*((tmpocc->x)->fils + tmpocc->num))->debut & 2147483647);
        }
      } else {
#line 541
        lmaxbr = (*((tmpocc->x)->fils + tmpocc->num))->fin - (*((tmpocc->x)->fils + tmpocc->num))->debut;
      }
#line 560
      if (tmpocc->lon != lmaxbr) {
#line 562
        carseq = (char )*(*(a.text + (*((tmpocc->x)->fils + tmpocc->num))->sequence_number) + (((*((tmpocc->x)->fils + tmpocc->num))->debut & 2147483647) + tmpocc->lon));
#line 566
        if ((int )carseq != 36) {
          {
#line 566
          tmp___1 = avanceBranche(next, tmpocc, symbol, carseq2num[(int )carseq],
                                  (Flag )0, cr, curbloc, cr->multiblocs);
          }
#line 566
          if (tmp___1) {
            {
#line 570
            ajouteOcc2Pile(pocc, next->x, next->num, next->lon, next->xerr, next->blocerr,
                           next->saut, next->codesaut);
#line 579
            nbocc ++;
            }
          }
        }
      } else {
#line 585
        trans = 0;
        {
#line 585
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 585
          if (! (trans != nbSymbSeq)) {
#line 585
            goto while_break___1;
          }
          {
#line 587
          tmpocc = pocc->occ + pos___3;
#line 588
          tmp___2 = avanceBranche(next, tmpocc, symbol, trans, (Flag )1, cr, curbloc,
                                  cr->multiblocs);
          }
#line 588
          if (tmp___2) {
            {
#line 591
            ajouteOcc2Pile(pocc, next->x, next->num, next->lon, next->xerr, next->blocerr,
                           next->saut, next->codesaut);
#line 601
            nbocc ++;
            }
          }
#line 585
          trans ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 607
      if (pos___3 == 0) {
#line 612
        goto while_break___0;
      }
#line 615
      pos___3 --;
#line 616
      tmpocc = pocc->occ + pos___3;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 631
    if (nbocc == 0) {
#line 633
      if ((unsigned long )nb_occ != (unsigned long )((void *)0)) {
#line 634
        *nb_occ = 0U;
      }
#line 635
      if ((unsigned long )nbocc_ex != (unsigned long )((void *)0)) {
#line 636
        *nbocc_ex = 0U;
      }
#line 637
      return;
    }
#line 643
    if (cr->multiblocs) {
#line 643
      if ((int )*(mot + 1) == numSAUT) {
        {
#line 645
        tmp___3 = gestionSaut(pocc, cr, curbloc, a.text);
        }
#line 645
        if (tmp___3 == 0) {
#line 647
          if ((unsigned long )nb_occ != (unsigned long )((void *)0)) {
#line 648
            *nb_occ = 0U;
          }
#line 649
          if ((unsigned long )nbocc_ex != (unsigned long )((void *)0)) {
#line 650
            *nbocc_ex = 0U;
          }
#line 651
          return;
        }
        {
#line 654
        changeModel(model, symbol);
#line 655
        changeModel(model, numSAUT);
#line 660
        curbloc ++;
#line 661
        mot ++;
        }
      } else {
        {
#line 669
        changeModel(model, symbol);
        }
      }
    } else {
      {
#line 669
      changeModel(model, symbol);
      }
    }
#line 671
    longmod ++;
#line 520
    mot ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 674
  tmp___4 = sommeBTOcc(pocc, & colors_model);
#line 674
  *nb_occ = (unsigned int )tmp___4;
  }
#line 675
  if ((unsigned long )nbocc_ex == (unsigned long )((void *)0)) {
#line 675
    if ((unsigned long )f___0 == (unsigned long )((void *)0)) {
#line 676
      return;
    }
  }
  {
#line 678
  keepModel(pocc, longmod, cr, nbocc_ex, f___0);
  }
#line 680
  return;
}
}
#line 690 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/grep+.c"
Flag valideCriteres(P_Criteres cr ) 
{ 
  Flag tmp ;

  {
  {
#line 693
  tmp = verifCriteres(*cr);
  }
#line 693
  if (! tmp) {
#line 694
    return ((Flag )0);
  }
  {
#line 696
  initEntiers();
  }
#line 698
  if ((int )cr->bloc > 1) {
    {
#line 700
    initTabSauts(cr);
#line 701
    cr->multiblocs = (Flag )1;
    }
  } else {
#line 704
    cr->multiblocs = (Flag )0;
  }
#line 706
  return ((Flag )1);
}
}
#line 723 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/grep+.c"
Flag chargeSequence(Arbre *a , char *fic ) 
{ 
  FastaSequence **seq ;
  Flag readok ;
  int taille ;
  int siztxt ;
  int i ;
  FILE *fasta ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  Bool tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 731
  tmp = malloc(500UL * sizeof(FastaSequence *));
#line 731
  seq = (FastaSequence **)tmp;
#line 732
  tmp___0 = malloc(500UL * sizeof(signed char *));
#line 732
  a->text = (signed char **)tmp___0;
  }
#line 733
  if (! seq) {
    {
#line 734
    fatalError((char *)"charSequence: cannot allocate \'seq/text\'\n");
    }
  } else
#line 733
  if (! a->text) {
    {
#line 734
    fatalError((char *)"charSequence: cannot allocate \'seq/text\'\n");
    }
  }
  {
#line 735
  siztxt = 500;
#line 738
  fasta = fopen((char const   */* __restrict  */)fic, (char const   */* __restrict  */)"r");
  }
#line 739
  if ((unsigned long )fasta == (unsigned long )((void *)0)) {
    {
#line 741
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"charSequence: cannot open fasta file \'%s\'\n",
            fic);
    }
#line 742
    return ((Flag )0);
  }
#line 745
  readok = (Flag )1;
#line 746
  a->nbtxt = 0;
  {
#line 749
  while (1) {
    while_continue: /* CIL Label */ ;
#line 751
    if (a->nbtxt == siztxt) {
      {
#line 753
      siztxt *= 2;
#line 754
      tmp___1 = realloc((void *)seq, (unsigned long )siztxt * sizeof(FastaSequence *));
#line 754
      seq = (FastaSequence **)tmp___1;
#line 756
      tmp___2 = realloc((void *)a->text, (unsigned long )siztxt * sizeof(signed char *));
#line 756
      a->text = (signed char **)tmp___2;
      }
#line 758
      if (! seq) {
        {
#line 759
        fatalError((char *)"chargeSequence: cannot reallocate \'seq/text\'\n");
        }
      } else
#line 758
      if (! a->text) {
        {
#line 759
        fatalError((char *)"chargeSequence: cannot reallocate \'seq/text\'\n");
        }
      }
    }
    {
#line 762
    *(seq + a->nbtxt) = NewFastaSequence();
#line 763
    tmp___3 = ReadFastaSequence(fasta, *(seq + a->nbtxt));
#line 763
    readok = (Flag )tmp___3;
    }
#line 764
    if (readok) {
      {
#line 766
      taille = (*(seq + a->nbtxt))->length + 1;
#line 767
      tmp___4 = malloc((unsigned long )(taille + 2) * sizeof(signed char ));
#line 767
      *(a->text + a->nbtxt) = (signed char *)tmp___4;
      }
#line 768
      if ((unsigned long )*(a->text + a->nbtxt) == (unsigned long )((void *)0)) {
        {
#line 769
        fatalError((char *)"chargeSequence: cannot allocate \'text\'\n");
        }
      }
      {
#line 771
      strcpy((char */* __restrict  */)((char *)*(a->text + a->nbtxt)), (char const   */* __restrict  */)(*(seq + a->nbtxt))->seq);
#line 772
      *(*(a->text + a->nbtxt) + (taille - 1)) = (signed char )'$';
#line 773
      *(*(a->text + a->nbtxt) + taille) = (signed char )'\000';
#line 774
      (a->nbtxt) ++;
      }
    }
#line 749
    if (! readok) {
#line 749
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 779
  fclose(fasta);
#line 782
  i = 0;
  }
  {
#line 782
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 782
    if (! (i != a->nbtxt)) {
#line 782
      goto while_break___0;
    }
    {
#line 783
    FreeFastaSequence(*(seq + i));
#line 782
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 784
  free((void *)seq);
  }
#line 786
  return ((Flag )1);
}
}
#line 792 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/grep+.c"
Flag creeArbreSuffixe(Arbre *a , int maxlongmod___0 , char *alphaseq___0 ) 
{ 
  int i ;
  Noeud *root_pere ;
  Symbole *tmp ;

  {
#line 798
  if ((unsigned long )alphaseq___0 == (unsigned long )((void *)0)) {
    {
#line 799
    tmp = chargeAlphaSeq((Symbole **)a->text, a->nbtxt, (char *)((void *)0));
#line 799
    alphaseq___0 = (char *)tmp;
    }
  }
  {
#line 805
  Init_All((unsigned char *)alphaseq___0, 0, a->nbtxt);
#line 806
  a->arbre = Construction_Arbre((unsigned char *)*(a->text + 0), maxlongmod___0);
#line 809
  i = 1;
  }
  {
#line 809
  while (1) {
    while_continue: /* CIL Label */ ;
#line 809
    if (! (i != a->nbtxt)) {
#line 809
      goto while_break;
    }
    {
#line 811
    a->arbre = AjouteSequence(a->arbre, (unsigned char *)*(a->text + i), maxlongmod___0);
#line 809
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 816
  UpdateBit_TabForAllTree(a->arbre);
#line 819
  root_pere = Alloc_Noeud();
#line 821
  *(root_pere->fils + Translation_Table['$']) = a->arbre;
#line 822
  root_pere->sequence_number = 0;
#line 823
  (a->arbre)->debut = 0;
#line 824
  (a->arbre)->fin = 1;
#line 825
  (a->arbre)->sequence_number = 0;
#line 827
  a->arbre = root_pere;
  }
#line 829
  return ((Flag )1);
}
}
#line 835 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/grep+.c"
Flag creeArbreSuffixeFromFile(Arbre *a , char *fic , int maxlongmod___0 , char *alphaseq___0 ) 
{ 
  Flag tmp ;

  {
  {
#line 838
  tmp = chargeSequence(a, fic);
  }
#line 838
  if (tmp) {
#line 838
    if (a->nbtxt < 1) {
      {
#line 840
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough sequences (<1)\n");
      }
#line 841
      return ((Flag )0);
    }
  } else {
    {
#line 840
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough sequences (<1)\n");
    }
#line 841
    return ((Flag )0);
  }
  {
#line 844
  creeArbreSuffixe(a, maxlongmod___0, alphaseq___0);
  }
#line 846
  return ((Flag )1);
}
}
#line 852 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/grep+.c"
Flag creeArbreSuffixeFromArray(Arbre *a , char **seq , int nbseq , int maxlongmod___0 ,
                               char *alphaseq___0 ) 
{ 


  {
#line 855
  if (nbseq < 1) {
    {
#line 857
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough sequences (<1)\n");
    }
#line 858
    return ((Flag )0);
  }
  {
#line 860
  a->nbtxt = nbseq;
#line 861
  a->text = (signed char **)seq;
#line 863
  creeArbreSuffixe(a, maxlongmod___0, alphaseq___0);
  }
#line 865
  return ((Flag )1);
}
}
#line 871 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/grep+.c"
void libereArbreSuffixeFromFile(Arbre a ) 
{ 
  int i ;

  {
  {
#line 875
  libereArbreSuffixeFromArray(a);
#line 877
  i = 0;
  }
  {
#line 877
  while (1) {
    while_continue: /* CIL Label */ ;
#line 877
    if (! (i != a.nbtxt)) {
#line 877
      goto while_break;
    }
    {
#line 878
    free((void *)*(a.text + i));
#line 877
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 879
  free((void *)a.text);
  }
#line 880
  return;
}
}
#line 886 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/grep+.c"
void libereArbreSuffixeFromArray(Arbre a ) 
{ 


  {
  {
#line 888
  Free_Arbre(a.arbre);
#line 889
  Free_All_Liste_Cell();
#line 890
  Free_ListePositions(Liste_positions_fin);
  }
#line 891
  return;
}
}
#line 178 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) ceil)(double __x )  __attribute__((__const__)) ;
#line 37 "include/liste_pos.h"
int Print_Positions(FILE *f___0 , Feuille *n , int longway , P_Criteres cr , int code ) ;
#line 56 "Spell/include/pile_occ.h"
void transferePile2Pile(P_PileOcc dest , P_PileOcc source ) ;
#line 57
int copieLastOcc(P_PileOcc dest , P_PileOcc source ) ;
#line 58
void depileRec(P_PileOcc p ) ;
#line 60
void liberePileOcc(P_PileOcc p ) ;
#line 25 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/pile_occ.c"
int recAfficheOcc(FILE *f___0 , Noeud *n , int l , P_Criteres cr , int codesaut ) ;
#line 38 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/pile_occ.c"
P_PileOcc creePileOcc(void) 
{ 
  P_PileOcc p ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 42
  tmp = malloc(sizeof(PileOcc ));
#line 42
  p = (P_PileOcc )tmp;
  }
#line 43
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 44
    fatalError((char *)"creePileOcc: cannot allocate \'p\'\n");
    }
  }
  {
#line 46
  tmp___0 = calloc((size_t )2000, sizeof(Occ ));
#line 46
  p->occ = (P_occ )tmp___0;
  }
#line 47
  if ((unsigned long )p->occ == (unsigned long )((void *)0)) {
    {
#line 48
    fatalError((char *)"creePileOcc: cannot allocate \'p->occ\'\n");
    }
  }
  {
#line 50
  tmp___1 = malloc(1000UL * sizeof(unsigned int ));
#line 50
  p->carte = (unsigned int *)tmp___1;
  }
#line 51
  if ((unsigned long )p->carte == (unsigned long )((void *)0)) {
    {
#line 52
    fatalError((char *)"creePileOcc: cannot allocate \'p->carte\'\n");
    }
  }
  {
#line 54
  p->size = 2000U;
#line 55
  p->size_carte = 1000U;
#line 56
  p->pos = 0;
#line 57
  p->pos_carte = 0U;
#line 59
  ajouteDummy(p);
  }
#line 61
  return (p);
}
}
#line 74 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/pile_occ.c"
void ajouteDummy(P_PileOcc p ) 
{ 
  void *tmp ;

  {
#line 80
  if (p->pos_carte >= p->size_carte) {
    {
#line 82
    p->size_carte += 1000U;
#line 87
    tmp = realloc((void *)p->carte, (unsigned long )p->size_carte * sizeof(unsigned int ));
#line 87
    p->carte = (unsigned int *)tmp;
    }
#line 89
    if ((unsigned long )p->carte == (unsigned long )((void *)0)) {
      {
#line 90
      fatalError((char *)"pile_occ.c: ajouteDummy: cannot reallocate \'p->carte\'");
      }
    }
  }
  {
#line 97
  *(p->carte + p->pos_carte) = (unsigned int )p->pos;
#line 98
  (p->pos_carte) ++;
#line 100
  ajouteOcc2Pile(p, (Noeud *)((void *)0), -1, -1, -1, -1, -1, -1);
  }
#line 101
  return;
}
}
#line 106 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/pile_occ.c"
int getPrecDummy(P_PileOcc p ) 
{ 


  {
#line 108
  return ((int )*(p->carte + (p->pos_carte - 1U)));
}
}
#line 114 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/pile_occ.c"
void ajouteInitOcc2Pile(P_PileOcc p , Noeud *x ) 
{ 
  P_occ ptr ;

  {
#line 118
  ptr = p->occ + p->pos;
#line 119
  ptr->x = x;
#line 120
  ptr->num = carseq2num['$'];
#line 121
  ptr->lon = 1;
#line 122
  ptr->xerr = 0;
#line 123
  ptr->blocerr = 0;
#line 124
  ptr->saut = 0;
#line 125
  ptr->codesaut = 0;
#line 127
  (p->pos) ++;
#line 128
  return;
}
}
#line 133 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/pile_occ.c"
void ajouteOcc2Pile(P_PileOcc p , Noeud *x , int num , int lon , int err , int blocerr ,
                    int saut , int codesaut ) 
{ 
  P_occ ptr ;
  void *tmp ;

  {
#line 142
  if ((unsigned int )p->pos >= p->size) {
    {
#line 147
    p->size += 2000U;
#line 148
    ptr = p->occ;
#line 149
    tmp = realloc((void *)p->occ, (unsigned long )p->size * sizeof(Occ ));
#line 149
    p->occ = (P_occ )tmp;
    }
#line 150
    if ((unsigned long )p->occ == (unsigned long )((void *)0)) {
      {
#line 151
      fatalError((char *)"ajouteOcc2Pile: cannot reallocate \'p->occ\'\n");
      }
    }
  }
#line 157
  ptr = p->occ + p->pos;
#line 158
  ptr->x = x;
#line 159
  ptr->num = num;
#line 160
  ptr->lon = lon;
#line 161
  ptr->xerr = err;
#line 162
  ptr->blocerr = blocerr;
#line 163
  ptr->saut = saut;
#line 164
  ptr->codesaut = codesaut;
#line 166
  (p->pos) ++;
#line 167
  return;
}
}
#line 172 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/pile_occ.c"
int copieLastOcc(P_PileOcc dest , P_PileOcc source ) 
{ 
  int last_dummy ;
  int nbocc ;
  double tmp ;
  void *tmp___0 ;

  {
#line 176
  if (source->pos == 0) {
#line 177
    return (0);
  }
#line 179
  if (source->pos_carte == 0U) {
#line 180
    last_dummy = -1;
  } else {
#line 182
    last_dummy = (int )*(source->carte + (source->pos_carte - 1U));
  }
#line 184
  nbocc = source->pos - last_dummy;
#line 185
  if (nbocc == 1) {
#line 186
    return (1);
  }
#line 188
  if ((unsigned int )(dest->pos + (nbocc - 1)) >= dest->size) {
    {
#line 194
    tmp = ceil((double )((dest->pos + nbocc) - 1) / (double )2000);
#line 194
    dest->size = (unsigned int )((int )tmp * 2000);
#line 198
    tmp___0 = realloc((void *)dest->occ, (unsigned long )dest->size * sizeof(Occ ));
#line 198
    dest->occ = (P_occ )tmp___0;
    }
#line 199
    if ((unsigned long )dest->occ == (unsigned long )((void *)0)) {
      {
#line 200
      fatalError((char *)"ajouteOcc2Pile: cannot reallocate \'dest->occ\'\n");
      }
    }
  }
  {
#line 202
  memcpy((void */* __restrict  */)(dest->occ + dest->pos), (void const   */* __restrict  */)((source->occ + last_dummy) + 1),
         (unsigned long )(nbocc - 1) * sizeof(Occ ));
#line 203
  dest->pos += nbocc - 1;
  }
#line 204
  return (nbocc - 1);
}
}
#line 210 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/pile_occ.c"
void transferePile2Pile(P_PileOcc dest , P_PileOcc source ) 
{ 
  double tmp ;
  void *tmp___0 ;

  {
#line 216
  if (source->pos == 0) {
#line 217
    return;
  }
#line 219
  if ((unsigned int )(dest->pos + source->pos) >= dest->size) {
    {
#line 225
    tmp = ceil((double )(dest->pos + source->pos) / (double )2000);
#line 225
    dest->size = (unsigned int )((int )tmp * 2000);
#line 229
    tmp___0 = realloc((void *)dest->occ, (unsigned long )dest->size * sizeof(Occ ));
#line 229
    dest->occ = (P_occ )tmp___0;
    }
#line 230
    if ((unsigned long )dest->occ == (unsigned long )((void *)0)) {
      {
#line 231
      fatalError((char *)"ajouteOcc2Pile: cannot reallocate \'dest->occ\'\n");
      }
    }
  }
  {
#line 237
  memcpy((void */* __restrict  */)(dest->occ + dest->pos), (void const   */* __restrict  */)source->occ,
         (unsigned long )source->pos * sizeof(Occ ));
#line 238
  dest->pos += source->pos;
#line 240
  source->pos = 0;
  }
#line 241
  return;
}
}
#line 246 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/pile_occ.c"
void depileRec(P_PileOcc p ) 
{ 


  {
#line 248
  if (p->pos_carte == 0U) {
#line 249
    p->pos = 0;
  } else {
#line 252
    (p->pos_carte) --;
#line 253
    p->pos = (int )*(p->carte + p->pos_carte);
  }
#line 255
  return;
}
}
#line 260 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/pile_occ.c"
void videPile(P_PileOcc p ) 
{ 


  {
  {
#line 262
  p->pos = 0;
#line 263
  p->pos_carte = 0U;
#line 264
  ajouteDummy(p);
  }
#line 265
  return;
}
}
#line 270 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/pile_occ.c"
void liberePileOcc(P_PileOcc p ) 
{ 


  {
  {
#line 272
  free((void *)p->occ);
#line 273
  free((void *)p->carte);
#line 274
  free((void *)p);
  }
#line 275
  return;
}
}
#line 303 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/pile_occ.c"
void afficheLastOcc(FILE *f___0 , P_PileOcc pocc___1 , int l , P_Criteres cr , unsigned int *nboccex ) 
{ 
  int i ;
  int nbocc ;
  P_occ ptr ;
  int tmp ;

  {
#line 306
  i = pocc___1->pos - 1;
#line 306
  nbocc = 0;
#line 309
  ptr = pocc___1->occ + i;
  {
#line 310
  while (1) {
    while_continue: /* CIL Label */ ;
#line 310
    if (i > 0) {
#line 310
      if (! ((unsigned long )ptr->x != (unsigned long )((void *)0))) {
#line 310
        goto while_break;
      }
    } else {
#line 310
      goto while_break;
    }
    {
#line 312
    tmp = recAfficheOcc(f___0, *((ptr->x)->fils + ptr->num), (l - ptr->lon) + ptr->saut,
                        cr, ptr->codesaut);
#line 312
    nbocc += tmp;
#line 314
    ptr --;
#line 315
    i --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 317
  if ((unsigned long )f___0 != (unsigned long )((void *)0)) {
    {
#line 318
    fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)"%d\n",
            nbocc);
    }
  }
#line 319
  if ((unsigned long )nboccex != (unsigned long )((void *)0)) {
#line 320
    *nboccex = (unsigned int )nbocc;
  }
#line 321
  return;
}
}
#line 328 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/pile_occ.c"
int recAfficheOcc(FILE *f___0 , Noeud *n , int l , P_Criteres cr , int codesaut ) 
{ 
  int i ;
  int nbocc ;
  int tmp ;
  int tmp___0 ;

  {
#line 330
  nbocc = 0;
#line 337
  if ((unsigned int )n->debut & 2147483648U) {
    {
#line 339
    tmp = Print_Positions(f___0, (Feuille *)n, l, cr, codesaut);
#line 339
    nbocc += tmp;
    }
  } else {
#line 342
    i = 0;
    {
#line 342
    while (1) {
      while_continue: /* CIL Label */ ;
#line 342
      if (! (i != nbSymbSeq)) {
#line 342
        goto while_break;
      }
#line 343
      if (*(n->fils + i)) {
        {
#line 348
        tmp___0 = recAfficheOcc(f___0, *(n->fils + i), (l + n->fin) - n->debut, cr,
                                codesaut);
#line 348
        nbocc += tmp___0;
        }
      }
#line 342
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 351
  return (nbocc);
}
}
#line 357 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/pile_occ.c"
int afficheOcc(FILE *f___0 , P_occ o , int longmod , P_Criteres cr ) 
{ 
  int tmp ;

  {
#line 359
  if ((unsigned long )o->x != (unsigned long )((void *)0)) {
    {
#line 360
    tmp = recAfficheOcc(f___0, *((o->x)->fils + o->num), (longmod - o->lon) + o->saut,
                        cr, o->codesaut);
    }
#line 360
    return (tmp);
  }
#line 362
  return (0);
}
}
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 195
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) difftime)(time_t __time1 ,
                                                                                  time_t __time0 )  __attribute__((__const__)) ;
#line 23 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/barre.c"
void repChar(char c , int nb ) ;
#line 28 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/barre.c"
void repChar(char c , int nb ) 
{ 
  int i ;

  {
#line 32
  i = 0;
  {
#line 32
  while (1) {
    while_continue: /* CIL Label */ ;
#line 32
    if (! (i != nb)) {
#line 32
      goto while_break;
    }
    {
#line 33
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%c",
            (int )c);
#line 32
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 34
  return;
}
}
#line 41 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/barre.c"
static int pos  =    0;
#line 42 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/barre.c"
static int max  =    0;
#line 43 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/barre.c"
static int lastecrit  =    0;
#line 44 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/barre.c"
static time_t start  ;
#line 39 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/barre.c"
void barre(int n ) 
{ 
  int nbpts ;
  int sec ;
  int mn ;
  int hr ;
  time_t tmp ;
  double tmp___0 ;

  {
#line 49
  if (n != 0) {
    {
#line 51
    start = time((time_t *)((void *)0));
#line 52
    max = n;
#line 53
    lastecrit = 0;
#line 54
    pos = 1;
#line 55
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  0%%");
#line 57
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" [");
#line 58
    repChar((char )' ', 60);
#line 59
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"]");
    }
#line 61
    return;
  }
#line 64
  if (pos > max) {
#line 65
    return;
  }
#line 68
  if (pos == max) {
    {
#line 70
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r100%%");
#line 72
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" [");
#line 73
    repChar((char )'.', 60);
#line 74
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"]");
#line 76
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" 00:00:00\n");
#line 77
    pos ++;
    }
#line 78
    return;
  }
  {
#line 81
  tmp = time((time_t *)((void *)0));
#line 81
  tmp___0 = difftime(tmp, start);
#line 81
  sec = (int )tmp___0;
#line 82
  sec = (int )((float )sec * (((float )max - (float )pos) / (float )pos));
#line 83
  hr = sec / 3600;
#line 84
  mn = (sec - hr * 3600) / 60;
#line 85
  sec = (sec - hr * 3600) - mn * 60;
#line 88
  nbpts = (pos * 60) / max;
  }
#line 89
  if (nbpts != lastecrit) {
    {
#line 92
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r%3d%%",
            (pos * 100) / max);
#line 94
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" [");
#line 95
    repChar((char )'.', nbpts);
#line 96
    repChar((char )' ', 60 - nbpts);
#line 97
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"]");
    }
#line 99
    if (pos > 3) {
      {
#line 100
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %02d:%02d:%02d",
              hr, mn, sec);
      }
    }
#line 102
    lastecrit = nbpts;
  }
#line 105
  pos ++;
#line 106
  return;
}
}
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 27 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/alphabet.c"
Flag TabSymb[127][127]  ;
#line 29 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/alphabet.c"
Symbole alphSeq[127]  = {      (Symbole )0};
#line 30 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/alphabet.c"
int carseq2num[127]  ;
#line 31 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/alphabet.c"
char *nummod2str[127]  ;
#line 32 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/alphabet.c"
int nbSymbMod  =    0;
#line 32 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/alphabet.c"
int nbSymbSeq  =    0;
#line 32 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/alphabet.c"
int numSAUT  =    -1;
#line 32 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/alphabet.c"
int numJOKER  =    -1;
#line 37 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/alphabet.c"
enum __anonenum_type_12 type  ;
#line 44 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/alphabet.c"
void initAlphabet(void) 
{ 
  int i ;
  int j ;

  {
#line 48
  i = 0;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (i != 127)) {
#line 48
      goto while_break;
    }
#line 50
    carseq2num[i] = -1;
#line 52
    j = 0;
    {
#line 52
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 52
      if (! (j != 127)) {
#line 52
        goto while_break___0;
      }
#line 53
      TabSymb[i][j] = (Flag )0;
#line 52
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 48
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  alphSeq[0] = (Symbole )'\000';
#line 57
  return;
}
}
#line 64 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/alphabet.c"
Symbole *chargeAlphaSeq(Symbole **seq , int nbseq , char *alphaseq___0 ) 
{ 
  int i ;
  Symbole *j ;
  char tmp[127] ;
  unsigned int tmp___0 ;
  char s ;
  size_t tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
#line 68
  tmp[0] = (char)0;
#line 68
  tmp___0 = 1U;
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (tmp___0 >= 127U) {
#line 68
      goto while_break;
    }
#line 68
    tmp[tmp___0] = (char)0;
#line 68
    tmp___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  if ((unsigned long )alphaseq___0 != (unsigned long )((void *)0)) {
    {
#line 72
    strcpy((char */* __restrict  */)(alphSeq), (char const   */* __restrict  */)alphaseq___0);
#line 73
    tmp___1 = strlen((char const   *)(alphSeq));
#line 73
    nbSymbSeq = (int )(tmp___1 - 1UL);
#line 74
    i = 0;
    }
    {
#line 74
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 74
      if (! (i != nbSymbSeq)) {
#line 74
        goto while_break___0;
      }
#line 75
      carseq2num[(int )*(alphSeq + i)] = i;
#line 74
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 76
    carseq2num['$'] = nbSymbSeq;
#line 78
    return (alphSeq);
  }
#line 83
  i = 0;
  {
#line 83
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 83
    if (! (i != nbseq)) {
#line 83
      goto while_break___1;
    }
#line 85
    j = *(seq + i);
    {
#line 85
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 85
      if (! ((int )*j != 36)) {
#line 85
        goto while_break___2;
      }
#line 87
      s = (char )*j;
#line 88
      if ((int )s < 32) {
        {
#line 90
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> Error: Seq %d Pos %d control character %d (\'%c\') forbidden\n",
                i, (int )(j - *(seq + i)), (int )s, (int )s);
#line 92
        exit(1);
        }
      } else
#line 88
      if ((int )s >= 127) {
        {
#line 90
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> Error: Seq %d Pos %d control character %d (\'%c\') forbidden\n",
                i, (int )(j - *(seq + i)), (int )s, (int )s);
#line 92
        exit(1);
        }
      } else
#line 94
      if ((int )s == 42) {
        {
#line 96
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> Error: Seq %d Pos %d character %d (\'%c\') forbidden in sequences\n",
                i, (int )(j - *(seq + i)), (int )s, (int )s);
#line 98
        exit(1);
        }
      } else
#line 94
      if ((int )s == 95) {
        {
#line 96
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> Error: Seq %d Pos %d character %d (\'%c\') forbidden in sequences\n",
                i, (int )(j - *(seq + i)), (int )s, (int )s);
#line 98
        exit(1);
        }
      } else {
        {
#line 100
        tmp___4 = __ctype_b_loc();
        }
#line 100
        if ((int const   )*(*tmp___4 + (int )s) & 8) {
          {
#line 103
          tmp___3 = __ctype_b_loc();
          }
#line 103
          if ((int const   )*(*tmp___3 + (int )s) & 512) {
            {
#line 105
            tmp___2 = toupper((int )s);
#line 105
            s = (char )((Symbole )tmp___2);
#line 106
            *j = (Symbole )s;
            }
          }
        } else {
          {
#line 101
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"> Warning: Seq %d Pos %d non-alphanumeric character \'%c\'\n",
                  i, (int )(j - *(seq + i)), (int )s);
          }
        }
      }
#line 109
      tmp[(int )s] = (char)1;
#line 85
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 83
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 114
  i = 32;
#line 114
  nbSymbSeq = 0;
  {
#line 114
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 114
    if (! (i != 127)) {
#line 114
      goto while_break___3;
    }
#line 116
    if ((int )tmp[i] == 1) {
#line 118
      alphSeq[nbSymbSeq] = (Symbole )i;
#line 119
      carseq2num[i] = nbSymbSeq;
#line 120
      nbSymbSeq ++;
    }
#line 114
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 123
  carseq2num['$'] = nbSymbSeq;
#line 124
  alphSeq[nbSymbSeq] = (Symbole )'$';
#line 125
  alphSeq[nbSymbSeq + 1] = (Symbole )'\000';
#line 127
  printf((char const   */* __restrict  */)"** Text alphabet: %s (%d symbols + terminator) **\n",
         alphSeq, nbSymbSeq);
  }
#line 130
  return (alphSeq);
}
}
#line 139 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/alphabet.c"
void chargeAlphaMod(FILE *f___0 ) 
{ 
  int i ;
  int k ;
  Symbole *j ;
  char s ;
  char line[512] ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  void *tmp___9 ;

  {
  {
#line 147
  fgets((char */* __restrict  */)(line), 512, (FILE */* __restrict  */)f___0);
#line 150
  tmp___0 = strstr((char const   *)(line), "Nucleotide");
  }
#line 150
  if (tmp___0) {
    {
#line 152
    type = (enum __anonenum_type_12 )0;
#line 153
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"** Models alphabet: Nucleotides **\n");
    }
  } else {
    {
#line 155
    tmp = strstr((char const   *)(line), "Protein");
    }
#line 155
    if (tmp) {
      {
#line 157
      type = (enum __anonenum_type_12 )1;
#line 158
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"** Models alphabet: Amino acids **\n");
      }
    } else {
      {
#line 162
      type = (enum __anonenum_type_12 )2;
#line 163
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"** Models alphabet: Unknown type **\n");
      }
    }
  }
#line 167
  nbSymbMod = 0;
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 168
    tmp___7 = fgets((char */* __restrict  */)(line), 512, (FILE */* __restrict  */)f___0);
    }
#line 168
    if (! tmp___7) {
#line 168
      goto while_break;
    }
#line 170
    j = (Symbole *)(line);
#line 172
    if ((int )*j == 10) {
#line 173
      goto while_continue;
    }
    {
#line 177
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 177
      if ((int )*j != 0) {
#line 177
        if (! ((int )*j != 10)) {
#line 177
          goto while_break___0;
        }
      } else {
#line 177
        goto while_break___0;
      }
#line 179
      s = (char )*j;
#line 180
      if ((int )s <= 32) {
        {
#line 182
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> Error: controle character \'%c\' forbidden in alphabet file\n",
                (int )s);
#line 183
        exit(1);
        }
      } else
#line 180
      if ((int )s >= 127) {
        {
#line 182
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> Error: controle character \'%c\' forbidden in alphabet file\n",
                (int )s);
#line 183
        exit(1);
        }
      } else
#line 185
      if ((int )s == 42) {
#line 187
        if ((unsigned long )j != (unsigned long )((Symbole *)(line))) {
          {
#line 189
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> Error: JOKER character \'%c\' must be alone\n",
                  '*');
#line 191
          exit(1);
          }
        } else
#line 187
        if ((int )*(j + 1) != 0) {
#line 187
          if ((int )*(j + 1) != 10) {
            {
#line 189
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> Error: JOKER character \'%c\' must be alone\n",
                    '*');
#line 191
            exit(1);
            }
          }
        }
#line 194
        if (numJOKER != -1) {
          {
#line 195
          fatalError((char *)"JOKER defined 2 times in alphabet file\n");
          }
        }
#line 197
        numJOKER = nbSymbMod;
#line 198
        k = 0;
        {
#line 198
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 198
          if (! (k != nbSymbSeq)) {
#line 198
            goto while_break___1;
          }
#line 199
          TabSymb[numJOKER][k] = (Flag )1;
#line 198
          k ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else
#line 201
      if ((int )s == 36) {
        {
#line 203
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> Error: character %d (\'%c\') forbidden in alphabet file\n",
                (int )s, (int )s);
#line 205
        exit(1);
        }
      } else
#line 201
      if ((int )s == 95) {
        {
#line 203
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> Error: character %d (\'%c\') forbidden in alphabet file\n",
                (int )s, (int )s);
#line 205
        exit(1);
        }
      } else {
        {
#line 208
        tmp___3 = __ctype_b_loc();
        }
#line 208
        if ((int const   )*(*tmp___3 + (int )s) & 8) {
          {
#line 215
          tmp___2 = __ctype_b_loc();
          }
#line 215
          if ((int const   )*(*tmp___2 + (int )s) & 512) {
            {
#line 216
            tmp___1 = toupper((int )s);
#line 216
            s = (char )((Symbole )tmp___1);
#line 216
            *j = (Symbole )s;
            }
          }
#line 218
          TabSymb[nbSymbMod][carseq2num[(int )s]] = (Flag )1;
        } else {
          {
#line 210
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: non-alphanumeric charactere \'%c\' in alphabet file\n",
                  (int )s);
#line 211
          TabSymb[nbSymbMod][carseq2num[(int )s]] = (Flag )1;
          }
        }
      }
#line 221
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 224
    if ((int )*j == 10) {
#line 225
      *j = (Symbole )'\000';
    }
    {
#line 227
    tmp___5 = strlen((char const   *)(line));
#line 227
    tmp___6 = malloc((tmp___5 + 4UL) * sizeof(char ));
#line 227
    tmp___4 = (char *)tmp___6;
#line 227
    nummod2str[nbSymbMod] = tmp___4;
    }
#line 227
    if (! tmp___4) {
      {
#line 229
      fatalError((char *)"chargeAlphabet: cannot allocate \'nummod2str[i]\'\n");
      }
    }
    {
#line 230
    strcpy((char */* __restrict  */)nummod2str[nbSymbMod], (char const   */* __restrict  */)(line));
#line 234
    nbSymbMod ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 238
  numSAUT = nbSymbMod;
#line 239
  tmp___9 = malloc(2UL * sizeof(char ));
#line 239
  tmp___8 = (char *)tmp___9;
#line 239
  nummod2str[numSAUT] = tmp___8;
  }
#line 239
  if (! tmp___8) {
    {
#line 241
    fatalError((char *)"chargeAlphabet: cannot allocate \'nummod2str[i]\'\n");
    }
  }
#line 242
  *(nummod2str[nbSymbMod] + 0) = (char )'_';
#line 243
  *(nummod2str[nbSymbMod] + 1) = (char )'\000';
#line 253
  i = 0;
  {
#line 253
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 253
    if (! (i != nbSymbSeq)) {
#line 253
      goto while_break___2;
    }
#line 255
    s = (char)0;
#line 256
    k = 0;
    {
#line 256
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 256
      if (! (k != nbSymbMod)) {
#line 256
        goto while_break___3;
      }
#line 257
      s = (char )((int )s | (int )TabSymb[k][i]);
#line 256
      k ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 259
    if (! s) {
      {
#line 260
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"> Warning: text symbol \'%c\' isn\'t recognized by any model\'s symbol in alphabet file.\n",
              (int )alphSeq[i]);
      }
    }
#line 253
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 264
  return;
}
}
#line 272 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/alphabet.c"
Flag strshfl(char *a , char *b ) 
{ 
  char *p ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 276
  tmp = strlen((char const   *)a);
#line 276
  tmp___0 = strlen((char const   *)b);
  }
#line 276
  if (tmp != tmp___0) {
#line 277
    return ((Flag )0);
  }
#line 279
  p = a;
  {
#line 280
  while (1) {
    while_continue: /* CIL Label */ ;
#line 280
    if (! ((int )*p != 0)) {
#line 280
      goto while_break;
    }
    {
#line 282
    tmp___1 = strchr((char const   *)b, (int )*p);
    }
#line 282
    if (! tmp___1) {
#line 283
      return ((Flag )0);
    }
#line 284
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 286
  return ((Flag )1);
}
}
#line 40 "Spell/include/model.h"
void decrModel(P_mod model___1 ) ;
#line 46
void AfficheModel(P_mod m ) ;
#line 25 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/model.c"
void AfficheModel(P_mod m ) 
{ 
  int i ;

  {
#line 29
  i = 0;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if (! (i < m->lon)) {
#line 29
      goto while_break;
    }
    {
#line 30
    printf((char const   */* __restrict  */)"%d", *(m->name + i));
#line 29
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 31
  printf((char const   */* __restrict  */)"\n");
  }
#line 32
  return;
}
}
#line 39 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/model.c"
P_mod allocModel(void) 
{ 
  P_mod model___1 ;
  void *tmp ;
  int *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 43
  tmp = malloc(sizeof(Mod ));
#line 43
  model___1 = (P_mod )tmp;
  }
#line 43
  if (! model___1) {
    {
#line 44
    fatalError((char *)"allocModel: cannot allocate \'model\'\n");
    }
  }
  {
#line 46
  tmp___1 = calloc((size_t )1000, sizeof(int ));
#line 46
  tmp___0 = (int *)tmp___1;
#line 46
  model___1->name = tmp___0;
  }
#line 46
  if (! tmp___0) {
    {
#line 47
    fatalError((char *)"allocModel: cannot allocate \'model->name\'\n");
    }
  }
#line 49
  model___1->taille = 1000;
#line 50
  model___1->lon = 0;
#line 52
  return (model___1);
}
}
#line 61 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/model.c"
void changeModel(P_mod mod , int symbol ) 
{ 
  void *tmp ;

  {
#line 63
  if (mod->lon + 2 >= mod->taille) {
    {
#line 65
    mod->taille += 1000;
#line 69
    tmp = realloc((void *)mod->name, (unsigned long )mod->taille * sizeof(int ));
#line 69
    mod->name = (int *)tmp;
    }
#line 70
    if (! mod->name) {
      {
#line 71
      fatalError((char *)"changeModel: cannot reallocate \'model->name\'\n");
      }
    }
  }
#line 74
  *(mod->name + mod->lon) = symbol;
#line 75
  (mod->lon) ++;
#line 76
  return;
}
}
#line 82 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/model.c"
void decrModel(P_mod model___1 ) 
{ 


  {
#line 84
  if (model___1->lon <= 0) {
#line 85
    return;
  }
#line 87
  (model___1->lon) --;
#line 88
  return;
}
}
#line 580 "/usr/include/stdio.h"
extern int putchar(int __c ) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 34 "include/liste_pos.h"
int getIndiceSuivant(ListePositions *lpos , int i ) ;
#line 56 "include/allocateurs.h"
void Init_Allocateurs(void) ;
#line 53 "include/global_fonctions.h"
int compare_string(int d1 , int f1 , int d2 , int f2 ) ;
#line 55
void Print_Tree(Noeud *N , int affichage , int stat___0 ) ;
#line 56
void Print_Liste(Liste *liste ) ;
#line 76
void Print_BTTree_Debug(Noeud *N , int *nb_noeud ) ;
#line 22 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/global_fonctions.c"
void Init_All(unsigned char *Alphabet , int Joker , int nb_sequence ) 
{ 
  int i ;
  int l ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 27
  initBitTab(nb_sequence);
#line 29
  Init_Allocateurs();
#line 31
  tmp = strlen((char const   *)Alphabet);
#line 31
  l = (int )tmp;
  }
#line 33
  if (Joker) {
#line 35
    i = 0;
    {
#line 35
    while (1) {
      while_continue: /* CIL Label */ ;
#line 35
      if (! (i < 255)) {
#line 35
        goto while_break;
      }
#line 36
      Translation_Table[i] = (unsigned char)0;
#line 35
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 37
    i = 0;
    {
#line 37
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 37
      if (! (i < l)) {
#line 37
        goto while_break___0;
      }
#line 38
      Translation_Table[*(Alphabet + i)] = (unsigned char )(i + 1);
#line 37
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 39
    ALPHA_CARD = l + 1;
  } else {
#line 43
    i = 0;
    {
#line 43
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 43
      if (! (i < 255)) {
#line 43
        goto while_break___1;
      }
#line 44
      Translation_Table[i] = (unsigned char)255;
#line 43
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 45
    i = 0;
    {
#line 45
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 45
      if (! (i < l)) {
#line 45
        goto while_break___2;
      }
#line 46
      Translation_Table[*(Alphabet + i)] = (unsigned char )i;
#line 45
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 47
    ALPHA_CARD = l;
  }
  {
#line 50
  tmp___0 = malloc((unsigned long )nb_sequence * sizeof(unsigned char *));
#line 50
  Sequence = (unsigned char **)tmp___0;
#line 51
  current_sequence = 0;
  }
#line 52
  return;
}
}
#line 54 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/global_fonctions.c"
void Ajoute_Fils_Au_Noeud(Noeud *N , Noeud *F ) 
{ 


  {
#line 56
  if (! N) {
#line 58
    return;
  } else
#line 56
  if (! F) {
#line 58
    return;
  } else
#line 56
  if ((unsigned int )N->debut & 2147483648U) {
#line 58
    return;
  }
#line 59
  *(N->fils + Translation_Table[*(*(Sequence + F->sequence_number) + (F->debut & 2147483647))]) = F;
#line 60
  return;
}
}
#line 63 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/global_fonctions.c"
Noeud *Get_Child_Start_Letter(Noeud *N , int indice ) 
{ 


  {
#line 65
  if ((int )Translation_Table[*(*(Sequence + current_sequence) + indice)] == 255) {
#line 68
    return ((Noeud *)((void *)0));
  } else
#line 65
  if (! N) {
#line 68
    return ((Noeud *)((void *)0));
  } else
#line 65
  if ((unsigned int )N->debut & 2147483648U) {
#line 68
    return ((Noeud *)((void *)0));
  }
#line 69
  return (*(N->fils + Translation_Table[*(*(Sequence + current_sequence) + indice)]));
}
}
#line 72 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/global_fonctions.c"
int seg_taille(Noeud *N ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 75
  if ((unsigned int )N->debut & 2147483648U) {
    {
#line 77
    tmp___0 = getValue(Liste_positions_fin, ((Feuille *)N)->fin_deb);
    }
#line 77
    if (tmp___0 == -1) {
#line 78
      return (global_indice - (((Feuille *)N)->debut & 2147483647));
    } else {
      {
#line 81
      tmp = getValue(Liste_positions_fin, ((Feuille *)N)->fin_deb);
      }
#line 81
      return (tmp - (((Feuille *)N)->debut & 2147483647));
    }
  } else
#line 86
  if (N->fin == -1) {
#line 87
    return (global_indice - N->debut);
  } else {
#line 89
    return (N->fin - N->debut);
  }
}
}
#line 93 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/global_fonctions.c"
Noeud *Add_Fast_String(Noeud *N , int deb , int fin , int *type___0 , Noeud **pere ) 
{ 
  Noeud *res ;
  Noeud *tmp_n ;
  Feuille *tmp_f ;
  int tmp_i ;
  int res_d ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  Noeud *tmp___7 ;

  {
#line 99
  if (! N) {
#line 100
    return ((Noeud *)((void *)0));
  }
#line 102
  if ((unsigned int )N->debut & 2147483648U) {
    {
#line 104
    *type___0 = 2;
#line 105
    tmp___3 = seg_taille(N);
    }
#line 105
    if (tmp___3 < fin - deb) {
      {
#line 107
      tmp = getValue(Liste_positions_fin, N->fin);
#line 107
      N->debut = (int )((unsigned int )(deb - (tmp - (N->debut & 2147483647))) | 2147483648U);
#line 108
      setListeValue(Liste_positions_fin, ((Feuille *)N)->fin_deb, fin);
      }
    } else {
      {
#line 111
      tmp___1 = seg_taille(N);
      }
#line 111
      if (tmp___1 == fin - deb) {
        {
#line 111
        tmp___2 = getValue(Liste_positions_fin, ((Feuille *)N)->fin_deb);
        }
#line 111
        if (tmp___2 != -1) {
#line 113
          if (N->sequence_number != current_sequence) {
#line 113
            goto _L;
          } else {
            {
#line 113
            tmp___0 = getValue(Liste_positions_fin, ((Feuille *)N)->fin_deb);
            }
#line 113
            if (tmp___0 != fin) {
              _L: /* CIL Label */ 
#line 117
              N->debut = (int )((unsigned int )deb | 2147483648U);
#line 118
              if (N->sequence_number == current_sequence) {
                {
#line 120
                Ajoute_Position_Liste(Liste_positions_fin, & ((Feuille *)N)->fin_deb,
                                      fin, 0);
                }
              } else {
                {
#line 124
                Ajoute_Position_Liste(Liste_positions_fin, & ((Feuille *)N)->fin_deb,
                                      fin, 1);
#line 125
                addBitTabValue(& ((Feuille *)N)->sequences, current_sequence);
#line 126
                N->sequence_number = current_sequence;
                }
              }
            }
          }
        }
      }
    }
#line 130
    return (N);
  }
  {
#line 133
  res = Get_Child_Start_Letter(N, deb);
  }
#line 135
  if ((unsigned long )res == (unsigned long )((void *)0)) {
    {
#line 137
    *type___0 = 1;
#line 138
    tmp_f = Alloc_Feuille();
#line 139
    tmp_f->debut = (int )((unsigned int )deb | 2147483648U);
#line 140
    Ajoute_Position_Liste(Liste_positions_fin, & tmp_f->fin_deb, fin, 0);
#line 141
    *pere = N;
#line 142
    Ajoute_Fils_Au_Noeud(N, (Noeud *)tmp_f);
    }
#line 143
    return ((Noeud *)tmp_f);
  }
  {
#line 146
  tmp_i = seg_taille(res);
#line 147
  res_d = res->debut & 2147483647;
  }
#line 149
  if (deb + tmp_i >= fin) {
#line 151
    if ((int )Translation_Table[*(*(Sequence + current_sequence) + (fin - 1))] == (int )Translation_Table[*(*(Sequence + res->sequence_number) + ((res_d + (fin - deb)) - 1))]) {
#line 155
      *type___0 = deb - fin;
#line 156
      if ((unsigned int )res->debut & 2147483648U) {
        {
#line 158
        tmp___5 = getValue(Liste_positions_fin, ((Feuille *)res)->fin_deb);
        }
#line 158
        if (tmp___5 != -1) {
          {
#line 158
          tmp___6 = seg_taille(res);
          }
#line 158
          if (fin - deb == tmp___6) {
#line 161
            if (res->sequence_number != current_sequence) {
#line 161
              goto _L___0;
            } else {
              {
#line 161
              tmp___4 = getValue(Liste_positions_fin, ((Feuille *)res)->fin_deb);
              }
#line 161
              if (tmp___4 != fin) {
                _L___0: /* CIL Label */ 
#line 164
                ((Feuille *)res)->debut = (int )((unsigned int )deb | 2147483648U);
#line 165
                if (res->sequence_number != current_sequence) {
                  {
#line 167
                  Ajoute_Position_Liste(Liste_positions_fin, & ((Feuille *)res)->fin_deb,
                                        fin, 1);
#line 168
                  addBitTabValue(& ((Feuille *)res)->sequences, current_sequence);
#line 169
                  res->sequence_number = current_sequence;
                  }
                } else {
                  {
#line 172
                  Ajoute_Position_Liste(Liste_positions_fin, & ((Feuille *)res)->fin_deb,
                                        fin, 0);
                  }
                }
              }
            }
          }
        }
      }
#line 176
      return (N);
    } else {
      {
#line 180
      tmp_n = Alloc_Noeud();
#line 181
      tmp_n->debut = res_d;
#line 182
      tmp_n->fin = ((res_d + fin) - deb) - 1;
#line 183
      tmp_n->sequence_number = res->sequence_number;
#line 184
      tmp_n->suffixe_link = N;
#line 185
      *(tmp_n->fils + Translation_Table[*(*(Sequence + res->sequence_number) + tmp_n->fin)]) = res;
      }
#line 187
      if ((unsigned int )res->debut & 2147483648U) {
#line 189
        res->debut = (int )((unsigned int )tmp_n->fin | 2147483648U);
      } else {
#line 192
        res->debut = tmp_n->fin;
      }
      {
#line 194
      tmp_f = Alloc_Feuille();
#line 195
      *pere = tmp_n;
#line 196
      tmp_f->debut = (int )((unsigned int )(fin - 1) | 2147483648U);
#line 197
      Ajoute_Position_Liste(Liste_positions_fin, & tmp_f->fin_deb, fin, 0);
#line 198
      *(N->fils + Translation_Table[*(*(Sequence + tmp_n->sequence_number) + tmp_n->debut)]) = tmp_n;
#line 199
      *(tmp_n->fils + Translation_Table[*(*(Sequence + tmp_f->sequence_number) + (tmp_f->debut & 2147483647))]) = (Noeud *)tmp_f;
#line 200
      *type___0 = 3;
      }
#line 201
      return ((Noeud *)tmp_f);
    }
  }
  {
#line 204
  *pere = N;
#line 205
  tmp___7 = Add_Fast_String(res, deb + tmp_i, fin, type___0, pere);
  }
#line 205
  return (tmp___7);
}
}
#line 208 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/global_fonctions.c"
int compare_string(int d1 , int f1 , int d2 , int f2 ) 
{ 
  int i ;
  int j ;

  {
#line 212
  i = d1;
#line 212
  j = d2;
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    if (i < f1) {
#line 212
      if (! (j < f2)) {
#line 212
        goto while_break;
      }
    } else {
#line 212
      goto while_break;
    }
#line 213
    if ((unsigned long )*(Sequence + i) != (unsigned long )*(Sequence + j)) {
#line 214
      goto while_break;
    }
#line 212
    i ++;
#line 212
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  if (i == f1) {
#line 215
    if (j == f2) {
#line 218
      return (-1);
    }
  }
#line 219
  if (i == f1) {
#line 220
    return (-2);
  }
#line 221
  if (j == f2) {
#line 222
    return (-3);
  }
#line 224
  return (i - d1);
}
}
#line 227 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/global_fonctions.c"
void Print_Tree_Indent(Noeud *N , int *nb_noeud , int *nb_feuilles , int *nb_fils ,
                       char *indent , int affichage ) 
{ 
  int i ;
  int tmp ;
  int d ;
  int f___0 ;
  int j ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;

  {
#line 231
  if (! N) {
#line 232
    return;
  }
#line 234
  if ((unsigned int )N->debut & 2147483648U) {
#line 236
    (*nb_feuilles) ++;
#line 237
    if (affichage) {
      {
#line 238
      printf((char const   */* __restrict  */)"Feuille (%p): %d->(", N, N->debut & 2147483647);
#line 240
      tmp = ((Feuille *)N)->fin_deb;
      }
      {
#line 241
      while (1) {
        while_continue: /* CIL Label */ ;
#line 241
        if (! (tmp != 268435455)) {
#line 241
          goto while_break;
        }
        {
#line 243
        tmp___3 = getValue(Liste_positions_fin, tmp);
        }
#line 243
        if (tmp___3 != -1) {
          {
#line 243
          tmp___1 = getValue(Liste_positions_fin, tmp);
#line 243
          tmp___2 = tmp___1;
          }
        } else {
#line 243
          tmp___2 = - global_indice;
        }
        {
#line 243
        printf((char const   */* __restrict  */)"%d,", tmp___2);
#line 244
        tmp = getIndiceSuivant(Liste_positions_fin, tmp);
        }
#line 245
        if ((unsigned int )tmp & 2147483648U) {
          {
#line 246
          printf((char const   */* __restrict  */)"-,");
          }
        }
#line 247
        tmp &= 2147483647;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 249
      printf((char const   */* __restrict  */)") [");
#line 250
      printBitTab(((Feuille *)N)->sequences);
#line 251
      tmp = getValue(Liste_positions_fin, ((Feuille *)N)->fin_deb);
#line 252
      d = N->debut & 2147483647;
      }
#line 253
      if (tmp == -1) {
#line 253
        f___0 = global_indice - 1;
      } else {
#line 253
        f___0 = tmp - 1;
      }
      {
#line 254
      tmp___4 = nbSequenceInBitTab(((Feuille *)N)->sequences);
#line 254
      printf((char const   */* __restrict  */)"] {%d}= (", tmp___4);
#line 255
      j = d;
      }
      {
#line 255
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 255
        if (! (j <= f___0)) {
#line 255
          goto while_break___0;
        }
        {
#line 256
        putchar((int )*(*(Sequence + N->sequence_number) + j));
#line 255
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 257
      printf((char const   */* __restrict  */)")\n");
      }
    }
  } else {
#line 262
    (*nb_noeud) ++;
#line 263
    if (affichage) {
      {
#line 265
      printf((char const   */* __restrict  */)"Noeud (%p): %d->%d (", N, N->debut,
             N->fin);
#line 266
      d = N->debut;
      }
#line 267
      if (N->fin - 1 >= 0) {
#line 267
        f___0 = N->fin - 1;
      } else {
#line 267
        f___0 = 0;
      }
#line 268
      j = d;
      {
#line 268
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 268
        if (! (j <= f___0)) {
#line 268
          goto while_break___1;
        }
        {
#line 269
        putchar((int )*(*(Sequence + N->sequence_number) + j));
#line 268
        j ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 270
      printf((char const   */* __restrict  */)") [");
#line 271
      printBitTab(N->sequences);
#line 272
      tmp___5 = nbSequenceInBitTab(N->sequences);
#line 272
      printf((char const   */* __restrict  */)"]{%d}\n%s       sl : %p\n%s       fils :\n",
             tmp___5, indent, N->suffixe_link, indent);
#line 273
      strcat((char */* __restrict  */)indent, (char const   */* __restrict  */)"\t");
      }
    }
#line 275
    i = 0;
    {
#line 275
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 275
      if (! (i < ALPHA_CARD)) {
#line 275
        goto while_break___2;
      }
#line 277
      if (*(N->fils + i)) {
#line 279
        (*nb_fils) ++;
#line 280
        if (affichage) {
          {
#line 281
          printf((char const   */* __restrict  */)"%s--> %c :", indent, (int )*(*(Sequence + (*(N->fils + i))->sequence_number) + ((*(N->fils + i))->debut & 2147483647)));
          }
        }
        {
#line 282
        Print_Tree_Indent(*(N->fils + i), nb_noeud, nb_feuilles, nb_fils, indent,
                          affichage);
        }
      }
#line 275
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 285
    tmp___6 = strlen((char const   *)indent);
#line 285
    *(indent + (tmp___6 - 1UL)) = (char )'\000';
    }
#line 286
    if (affichage) {
      {
#line 287
      printf((char const   */* __restrict  */)"%s       fin fils\n", indent);
      }
    }
  }
#line 289
  return;
}
}
#line 291 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/global_fonctions.c"
void Print_Tree(Noeud *N , int affichage , int stat___0 ) 
{ 
  char *indent ;
  void *tmp ;
  int nb_noeud ;
  int nb_feuilles ;
  int nb_fils ;

  {
  {
#line 293
  tmp = malloc((size_t )1000);
#line 293
  indent = (char *)tmp;
#line 294
  nb_noeud = 0;
#line 294
  nb_feuilles = 0;
#line 295
  nb_fils = 0;
#line 296
  *(indent + 0) = (char )'\000';
#line 297
  Print_Tree_Indent(N, & nb_noeud, & nb_feuilles, & nb_fils, indent, affichage);
  }
#line 298
  if (stat___0) {
    {
#line 300
    printf((char const   */* __restrict  */)"nombre de Noeud   (%d + %d) : %d \nnombre de Feuille (%d)      : %d \nnombre de fils              : %d \nnombre de fils/Noeud        : %f \ncardinal de l\'alphabet      : %d \n",
           (int )sizeof(Noeud ), (int )sizeof(Noeud *) * ALPHA_CARD, nb_noeud, (int )sizeof(Feuille ),
           nb_feuilles, nb_fils, (double )nb_fils / (double )nb_noeud, ALPHA_CARD);
    }
  }
  {
#line 310
  free((void *)indent);
  }
#line 311
  return;
}
}
#line 313 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/global_fonctions.c"
void Print_Liste(Liste *liste ) 
{ 
  Liste *tmp ;

  {
#line 315
  tmp = liste;
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if (! tmp) {
#line 316
      goto while_break;
    }
    {
#line 318
    printf((char const   */* __restrict  */)"( %p )->", tmp->feuille);
#line 319
    tmp = tmp->suiv;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 321
  printf((char const   */* __restrict  */)"\n");
  }
#line 322
  return;
}
}
#line 325 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/global_fonctions.c"
Noeud *FindString(Noeud *N , int deb , int fin , Noeud **pere , int *restant , int *pos_in_edge ) 
{ 
  Noeud *res ;
  int start___3 ;
  int end ;
  int i ;
  int j ;
  Noeud *tmp ;
  Noeud *tmp___0 ;

  {
#line 332
  if ((unsigned int )N->debut & 2147483648U) {
    {
#line 334
    start___3 = N->debut & 2147483647;
#line 335
    end = getValue(Liste_positions_fin, ((Feuille *)N)->fin_deb);
#line 336
    i = start___3;
#line 336
    j = deb;
    }
    {
#line 336
    while (1) {
      while_continue: /* CIL Label */ ;
#line 336
      if (i < end) {
#line 336
        if (! (j < fin)) {
#line 336
          goto while_break;
        }
      } else {
#line 336
        goto while_break;
      }
#line 337
      if ((int )*(*(Sequence + N->sequence_number) + i) != (int )*(*(Sequence + current_sequence) + j)) {
#line 339
        *restant = j - fin;
#line 340
        *pos_in_edge = i - start___3;
#line 341
        return (N);
      }
#line 336
      i ++;
#line 336
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 343
    if (i == end) {
#line 343
      if (j == fin) {
#line 346
        *restant = 1;
#line 347
        *pos_in_edge = 0;
#line 348
        return (N);
      }
    }
#line 350
    if (i == end) {
#line 352
      *restant = 2;
#line 353
      *pos_in_edge = 0;
#line 354
      return (N);
    }
#line 356
    *restant = 3;
#line 357
    *pos_in_edge = 0;
#line 358
    return (N);
  }
  {
#line 360
  res = Get_Child_Start_Letter(N, deb);
  }
#line 361
  if ((unsigned long )res == (unsigned long )((void *)0)) {
#line 363
    *restant = deb - fin;
#line 364
    *pos_in_edge = -1;
#line 365
    return (N);
  }
#line 368
  if ((unsigned int )res->debut & 2147483648U) {
    {
#line 370
    *pere = N;
#line 371
    tmp = FindString(res, deb, fin, pere, restant, pos_in_edge);
    }
#line 371
    return (tmp);
  }
#line 374
  start___3 = res->debut;
#line 375
  end = res->fin;
#line 376
  *pere = N;
#line 377
  i = start___3;
#line 377
  j = deb;
  {
#line 377
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 377
    if (i < end) {
#line 377
      if (! (j < fin)) {
#line 377
        goto while_break___0;
      }
    } else {
#line 377
      goto while_break___0;
    }
#line 378
    if ((int )*(*(Sequence + res->sequence_number) + i) != (int )*(*(Sequence + current_sequence) + j)) {
#line 380
      *restant = j - fin;
#line 381
      *pos_in_edge = i - start___3;
#line 382
      return (res);
    }
#line 377
    i ++;
#line 377
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 384
  if (i == end) {
#line 384
    if (j == fin) {
#line 386
      *restant = 1;
#line 387
      *pos_in_edge = 0;
#line 388
      return (res);
    }
  }
#line 391
  if (i == end) {
    {
#line 393
    tmp___0 = FindString(res, (deb + end) - start___3, fin, pere, restant, pos_in_edge);
    }
#line 393
    return (tmp___0);
  }
#line 395
  *restant = 3;
#line 396
  *pos_in_edge = 0;
#line 397
  return (res);
}
}
#line 402 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/global_fonctions.c"
void UpdateBit_TabForAllTree(Noeud *N ) 
{ 
  int i ;
  int j ;

  {
#line 405
  if ((unsigned long )N == (unsigned long )((void *)0)) {
#line 406
    return;
  }
#line 407
  if ((unsigned int )N->debut & 2147483648U) {
#line 408
    return;
  }
#line 410
  i = 0;
  {
#line 410
  while (1) {
    while_continue: /* CIL Label */ ;
#line 410
    if (! (i < ALPHA_CARD)) {
#line 410
      goto while_break;
    }
    {
#line 411
    UpdateBit_TabForAllTree(*(N->fils + i));
#line 410
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 413
  j = 0;
  {
#line 415
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 415
    if (! ((unsigned long )*(N->fils + j) == (unsigned long )((void *)0))) {
#line 415
      goto while_break___0;
    }
#line 415
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 416
  if ((unsigned int )(*(N->fils + j))->debut & 2147483648U) {
    {
#line 417
    CopyBitTab(& N->sequences, ((Feuille *)*(N->fils + j))->sequences);
    }
  } else {
    {
#line 419
    CopyBitTab(& N->sequences, (*(N->fils + j))->sequences);
    }
  }
#line 421
  i = j + 1;
  {
#line 421
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 421
    if (! (i < ALPHA_CARD)) {
#line 421
      goto while_break___1;
    }
#line 423
    if (*(N->fils + i)) {
#line 425
      if ((unsigned int )(*(N->fils + i))->debut & 2147483648U) {
        {
#line 426
        fusionneBitTab(& N->sequences, ((Feuille *)*(N->fils + i))->sequences);
        }
      } else {
        {
#line 428
        fusionneBitTab(& N->sequences, (*(N->fils + i))->sequences);
        }
      }
    }
#line 421
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 431
  N->nb_element_bt = nbSequenceInBitTab(N->sequences);
  }
#line 432
  return;
}
}
#line 435 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/global_fonctions.c"
void Print_BTTree_Debug(Noeud *N , int *nb_noeud ) 
{ 
  int i ;
  int j ;
  int max___3 ;
  int tmp ;
  int tmp___0 ;

  {
#line 438
  if ((unsigned long )N == (unsigned long )((void *)0)) {
#line 439
    return;
  }
#line 440
  if ((unsigned int )N->debut & 2147483648U) {
    {
#line 442
    (*nb_noeud) ++;
#line 443
    printf((char const   */* __restrict  */)"%d\t", *nb_noeud);
#line 444
    max___3 = getValue(Liste_positions_fin, ((Feuille *)N)->fin_deb);
#line 445
    j = N->debut & 2147483647;
    }
    {
#line 445
    while (1) {
      while_continue: /* CIL Label */ ;
#line 445
      if (! (j < max___3)) {
#line 445
        goto while_break;
      }
      {
#line 446
      printf((char const   */* __restrict  */)"%c", (int )*(*(Sequence + N->sequence_number) + j));
#line 445
      j ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 447
    printf((char const   */* __restrict  */)"\t");
#line 448
    tmp = nbSequenceInBitTab(((Feuille *)N)->sequences);
#line 448
    printf((char const   */* __restrict  */)"%d", tmp);
#line 449
    printf((char const   */* __restrict  */)"\t");
#line 450
    printBitTab(((Feuille *)N)->sequences);
#line 451
    printf((char const   */* __restrict  */)"\n");
    }
#line 452
    return;
  }
  {
#line 454
  (*nb_noeud) ++;
#line 455
  printf((char const   */* __restrict  */)"%d\t", *nb_noeud);
#line 456
  j = N->debut;
  }
  {
#line 456
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 456
    if (! (j < N->fin)) {
#line 456
      goto while_break___0;
    }
    {
#line 457
    printf((char const   */* __restrict  */)"%c", (int )*(*(Sequence + N->sequence_number) + j));
#line 456
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 458
  printf((char const   */* __restrict  */)"\t");
#line 459
  tmp___0 = nbSequenceInBitTab(N->sequences);
#line 459
  printf((char const   */* __restrict  */)"%d", tmp___0);
#line 460
  printf((char const   */* __restrict  */)"\t");
#line 461
  printBitTab(N->sequences);
#line 462
  printf((char const   */* __restrict  */)"\n");
#line 463
  i = 0;
  }
  {
#line 463
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 463
    if (! (i < ALPHA_CARD)) {
#line 463
      goto while_break___1;
    }
    {
#line 464
    Print_BTTree_Debug(*(N->fils + i), nb_noeud);
#line 463
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 465
  return;
}
}
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 71 "include/libfasta.h"
Int32 CountAlpha(char *buf ) ;
#line 72
char *StrcpyAlpha(char *s1 , char *s2 ) ;
#line 73
char *NextSpace(char *buffer ) ;
#line 74
char *GetFastaName(char *buffer ) ;
#line 75
char *GetFastaComment(char *buffer ) ;
#line 81
Bool GetFastaSequence(FILE *streamin , FastaSequencePtr seq ) ;
#line 82
void WriteFastaSequence(FILE *streamou , FastaSequencePtr seq , Int32 char_per_line ) ;
#line 60 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/libfasta.c"
static char sBuffer[8192]  ;
#line 61
static char *sNextIOBuffer(FILE *streamin , Bool retain , Bool serial ) ;
#line 61 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/libfasta.c"
static Bool sRetained  =    0;
#line 55 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/libfasta.c"
static char *sNextIOBuffer(FILE *streamin , Bool retain , Bool serial ) 
{ 
  char *buf ;
  char *end ;
  char *tmp ;
  size_t tmp___0 ;

  {
#line 63
  if (retain) {
#line 63
    goto _L;
  } else
#line 63
  if (sRetained) {
    _L: /* CIL Label */ 
#line 63
    if (serial) {
#line 63
      buf = sBuffer;
    } else {
      {
#line 63
      tmp = fgets((char */* __restrict  */)(sBuffer), (int )sizeof(sBuffer), (FILE */* __restrict  */)streamin);
#line 63
      buf = tmp;
      }
    }
  } else {
    {
#line 63
    tmp = fgets((char */* __restrict  */)(sBuffer), (int )sizeof(sBuffer), (FILE */* __restrict  */)streamin);
#line 63
    buf = tmp;
    }
  }
#line 67
  if (buf) {
    {
#line 68
    tmp___0 = strlen((char const   *)buf);
#line 68
    end = (buf + tmp___0) - 1;
    }
#line 69
    if ((int )*end == 10) {
#line 69
      *end = (char )'\000';
    }
  }
#line 72
  sRetained = retain;
#line 74
  return (buf);
}
}
#line 81 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/libfasta.c"
Int32 CountAlpha(char *buf ) 
{ 
  Int32 count ;
  unsigned short const   **tmp ;

  {
#line 85
  count = 0;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! *buf) {
#line 85
      goto while_break;
    }
    {
#line 86
    tmp = __ctype_b_loc();
    }
#line 86
    if ((int const   )*(*tmp + (int )*buf) & 1024) {
#line 87
      count ++;
    }
#line 85
    buf ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 89
  return (count);
}
}
#line 96 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/libfasta.c"
char *StrcpyAlpha(char *s1 , char *s2 ) 
{ 
  char *tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! *s2) {
#line 98
      goto while_break;
    }
    {
#line 99
    tmp___0 = __ctype_b_loc();
    }
#line 99
    if ((int const   )*(*tmp___0 + (int )*s2) & 1024) {
#line 100
      tmp = s1;
#line 100
      s1 ++;
#line 100
      *tmp = *s2;
    }
#line 98
    s2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  *s1 = (char )'\000';
#line 104
  return (s1);
}
}
#line 110 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/libfasta.c"
char *NextSpace(char *buffer ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if (! *buffer) {
#line 112
      goto while_break;
    }
    {
#line 113
    tmp = __ctype_b_loc();
    }
#line 113
    if ((int const   )*(*tmp + (int )*buffer) & 8192) {
#line 114
      return (buffer);
    }
#line 112
    buffer ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 116
  return ((char *)((void *)0));
}
}
#line 124 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/libfasta.c"
static char name[64]  ;
#line 122 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/libfasta.c"
char *GetFastaName(char *buffer ) 
{ 
  int tmp ;

  {
  {
#line 126
  *(buffer + 64) = (char )'\000';
#line 128
  tmp = sscanf((char const   */* __restrict  */)(buffer + 1), (char const   */* __restrict  */)"%s",
               name);
  }
#line 128
  if (tmp != 1) {
    {
#line 129
    strcpy((char */* __restrict  */)(name), (char const   */* __restrict  */)"<no Name>");
    }
  }
#line 131
  return (name);
}
}
#line 140 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/libfasta.c"
static char comment[512]  ;
#line 137 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/libfasta.c"
char *GetFastaComment(char *buffer ) 
{ 
  char *space___1 ;
  char const   *tmp ;

  {
  {
#line 142
  *(buffer + 512) = (char )'\000';
#line 144
  space___1 = NextSpace(buffer);
  }
#line 146
  if (space___1) {
#line 146
    tmp = (char const   *)(space___1 + 1);
  } else {
#line 146
    tmp = "<no comment>";
  }
  {
#line 146
  strcpy((char */* __restrict  */)(comment), (char const   */* __restrict  */)tmp);
  }
#line 148
  return (comment);
}
}
#line 154 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/libfasta.c"
FastaSequencePtr FreeFastaSequence(FastaSequencePtr seq ) 
{ 


  {
#line 156
  if (seq) {
#line 157
    if (seq->seq) {
      {
#line 157
      free((void *)seq->seq);
      }
    }
    {
#line 158
    free((void *)seq);
    }
  }
#line 161
  return ((FastaSequencePtr )((void *)0));
}
}
#line 167 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/libfasta.c"
FastaSequencePtr NewFastaSequence(void) 
{ 
  FastaSequencePtr seq ;
  void *tmp ;
  FastaSequencePtr tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 171
  tmp = malloc(sizeof(FastaSequence ));
#line 171
  seq = (FastaSequence *)tmp;
  }
#line 171
  if (! seq) {
#line 172
    return ((FastaSequencePtr )((void *)0));
  }
  {
#line 174
  seq->length = 0;
#line 176
  tmp___2 = malloc(8192UL * sizeof(char ));
#line 176
  tmp___1 = (char *)tmp___2;
#line 176
  seq->seq = tmp___1;
  }
#line 176
  if (! tmp___1) {
    {
#line 177
    tmp___0 = FreeFastaSequence(seq);
    }
#line 177
    return (tmp___0);
  }
#line 179
  seq->bufsize = 8192;
#line 181
  seq->name[0] = (char )'\000';
#line 182
  seq->comment[0] = (char )'\000';
#line 184
  seq->ok = 1;
#line 186
  return (seq);
}
}
#line 196 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/libfasta.c"
Bool ReadFastaSequence(FILE *streamin , FastaSequencePtr seq ) 
{ 
  Int32 readlen ;
  Int32 buflen ;
  char *buffer ;
  char *tbuf ;
  Int32 tmp ;
  long tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  Bool tmp___6 ;

  {
  {
#line 201
  seq->ok = 0;
#line 203
  tmp = 0;
#line 203
  seq->length = tmp;
#line 203
  buflen = tmp;
#line 205
  tmp___0 = ftell(streamin);
#line 205
  seq->offset = (Int32 )tmp___0;
#line 207
  buffer = sNextIOBuffer(streamin, 0, 1);
  }
#line 209
  if (buffer) {
#line 209
    if (! ((int )*buffer == 62)) {
#line 210
      return (0);
    }
  } else {
#line 210
    return (0);
  }
#line 212
  if (seq->offset) {
    {
#line 213
    tmp___1 = strlen((char const   *)buffer);
#line 213
    seq->offset = (Int32 )((size_t )seq->offset - (tmp___1 + 1UL));
    }
  }
  {
#line 215
  tmp___2 = GetFastaName(buffer);
#line 215
  strcpy((char */* __restrict  */)(seq->name), (char const   */* __restrict  */)tmp___2);
#line 217
  tmp___3 = GetFastaComment(buffer);
#line 217
  strcpy((char */* __restrict  */)(seq->comment), (char const   */* __restrict  */)tmp___3);
  }
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 219
    buffer = sNextIOBuffer(streamin, 0, 1);
    }
#line 219
    if (! buffer) {
#line 219
      goto while_break;
    }
#line 221
    if ((int )*buffer == 62) {
      {
#line 222
      sNextIOBuffer(streamin, 1, 1);
      }
#line 223
      goto while_break;
    }
    {
#line 229
    tmp___4 = strlen((char const   *)buffer);
#line 229
    readlen = (Int32 )tmp___4;
#line 232
    buflen += readlen;
    }
#line 234
    if (buflen >= seq->bufsize) {
      {
#line 236
      tmp___5 = realloc((void *)seq->seq, (unsigned long )(2 * buflen + 1) * sizeof(char ));
#line 236
      tbuf = (char *)tmp___5;
      }
#line 236
      if (! tbuf) {
#line 237
        return (1);
      }
#line 239
      seq->seq = tbuf;
#line 241
      seq->bufsize = 2 * buflen + 1;
    }
    {
#line 247
    memcpy((void */* __restrict  */)(seq->seq + seq->length), (void const   */* __restrict  */)buffer,
           (size_t )readlen);
#line 250
    seq->length = buflen;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 254
  *(seq->seq + seq->length) = (char )'\000';
#line 256
  tmp___6 = 1;
#line 256
  seq->ok = tmp___6;
#line 256
  return (tmp___6);
}
}
#line 266 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/libfasta.c"
Bool GetFastaSequence(FILE *streamin , FastaSequencePtr seq ) 
{ 
  Int32 readlen ;
  Int32 buflen ;
  char *buffer ;
  char *tbuf ;
  Int32 tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  Bool tmp___5 ;

  {
  {
#line 271
  seq->ok = 0;
#line 273
  tmp = 0;
#line 273
  seq->length = tmp;
#line 273
  buflen = tmp;
#line 275
  fseek(streamin, (long )seq->offset, 0);
#line 277
  buffer = sNextIOBuffer(streamin, 0, 0);
  }
#line 279
  if (buffer) {
#line 279
    if (! ((int )*buffer == 62)) {
#line 280
      return (0);
    }
  } else {
#line 280
    return (0);
  }
#line 282
  if (seq->offset) {
    {
#line 283
    tmp___0 = strlen((char const   *)buffer);
#line 283
    seq->offset = (Int32 )((size_t )seq->offset - (tmp___0 + 1UL));
    }
  }
  {
#line 285
  tmp___1 = GetFastaName(buffer);
#line 285
  strcpy((char */* __restrict  */)(seq->name), (char const   */* __restrict  */)tmp___1);
#line 287
  tmp___2 = GetFastaComment(buffer);
#line 287
  strcpy((char */* __restrict  */)(seq->comment), (char const   */* __restrict  */)tmp___2);
  }
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 289
    buffer = sNextIOBuffer(streamin, 0, 0);
    }
#line 289
    if (! buffer) {
#line 289
      goto while_break;
    }
#line 291
    if ((int )*buffer == 62) {
#line 292
      goto while_break;
    }
    {
#line 297
    tmp___3 = strlen((char const   *)buffer);
#line 297
    readlen = (Int32 )tmp___3;
#line 300
    buflen += readlen;
    }
#line 302
    if (buflen >= seq->bufsize) {
      {
#line 304
      tmp___4 = realloc((void *)seq->seq, (unsigned long )(2 * buflen + 1) * sizeof(char ));
#line 304
      tbuf = (char *)tmp___4;
      }
#line 304
      if (! tbuf) {
#line 305
        return (1);
      }
#line 307
      seq->seq = tbuf;
#line 309
      seq->bufsize = 2 * buflen + 1;
    }
    {
#line 315
    memcpy((void */* __restrict  */)(seq->seq + seq->length), (void const   */* __restrict  */)buffer,
           (size_t )readlen);
#line 318
    seq->length = buflen;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 322
  *(seq->seq + seq->length) = (char )'\000';
#line 324
  tmp___5 = 1;
#line 324
  seq->ok = tmp___5;
#line 324
  return (tmp___5);
}
}
#line 330 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/libfasta.c"
void WriteFastaSequence(FILE *streamou , FastaSequencePtr seq , Int32 char_per_line ) 
{ 
  Int32 i ;
  Int32 nlines ;
  Int32 rest ;
  char *buf ;
  char *end ;
  char tempo ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 335
  fputc('>', streamou);
  }
#line 336
  if (seq->name[0]) {
#line 336
    tmp = (char const   *)(seq->name);
  } else {
#line 336
    tmp = "<no name>";
  }
  {
#line 336
  fputs((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)streamou);
#line 337
  fputc(' ', streamou);
  }
#line 338
  if (seq->comment[0]) {
#line 338
    tmp___0 = (char const   *)(seq->comment);
  } else {
#line 338
    tmp___0 = "<no comment>";
  }
  {
#line 338
  fputs((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)streamou);
#line 339
  fputc('\n', streamou);
#line 341
  nlines = seq->length / char_per_line;
#line 343
  buf = seq->seq;
#line 345
  i = 0;
  }
  {
#line 345
  while (1) {
    while_continue: /* CIL Label */ ;
#line 345
    if (! (i < nlines)) {
#line 345
      goto while_break;
    }
    {
#line 346
    end = buf + char_per_line;
#line 347
    tempo = *end;
#line 348
    *end = (char )'\000';
#line 349
    fputs((char const   */* __restrict  */)buf, (FILE */* __restrict  */)streamou);
#line 350
    fputc('\n', streamou);
#line 351
    *end = tempo;
#line 352
    buf += char_per_line;
#line 345
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 355
  rest = seq->length % char_per_line;
#line 355
  if (rest) {
    {
#line 356
    end = buf + rest;
#line 357
    tempo = *end;
#line 358
    *end = (char )'\000';
#line 359
    fputs((char const   */* __restrict  */)buf, (FILE */* __restrict  */)streamou);
#line 360
    fputc('\n', streamou);
#line 361
    *end = tempo;
    }
  }
#line 363
  return;
}
}
#line 34 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/random.c"
static unsigned int seed  ;
#line 45 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/random.c"
unsigned int changeseed(unsigned int Iseed ) 
{ 
  unsigned int oldseed ;

  {
#line 49
  oldseed = seed;
#line 50
  seed = Iseed;
#line 52
  return (oldseed);
}
}
#line 65 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/random.c"
double unif01(void) 
{ 
  double random ;

  {
#line 69
  seed = 69069U * seed + 1U;
#line 70
  random = ((double )seed * ((double )1 / ((((double )256 * (double )256) * (double )256) * (double )128))) / (double )2;
#line 72
  return (random);
}
}
#line 85 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/random.c"
unsigned int readseed(char *filename ) 
{ 
  FILE *fp ;

  {
  {
#line 89
  seed = 1000001U;
#line 90
  fp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 91
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 92
    fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%u", & seed);
#line 93
    fclose(fp);
    }
  }
#line 95
  return (seed);
}
}
#line 108 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/random.c"
int writeseed(char *filename ) 
{ 
  FILE *fp ;
  int r ;

  {
  {
#line 113
  fp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"w");
  }
#line 114
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 115
    r = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%u\n",
                seed);
    }
  } else {
#line 117
    r = -1;
  }
  {
#line 118
  fclose(fp);
  }
#line 119
  return (r);
}
}
#line 61 "include/structures.h"
unsigned char Translation_Table[255]  ;
#line 27 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/global_variables.c"
unsigned char **Sequence  =    (unsigned char **)((void *)0);
#line 28 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/global_variables.c"
ListePositions *Liste_positions_fin  =    (ListePositions *)((void *)0);
#line 30 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/global_variables.c"
int global_indice  =    0;
#line 31 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/global_variables.c"
int current_sequence  =    0;
#line 72 "include/shufflet.h"
char *hash2str(int hash , int k , int m , char *klet ) ;
#line 77
void arborescence(int m , int nk1lets , int nver , int *count , int *vdeg , int first ,
                  int root , int *branch ) ;
#line 79
void randomtrail(int m , int k , int *count , int *vdeg , int first , int *lastedge ,
                 char *seq ) ;
#line 36 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/euler.c"
void indexseq(signed char *seq , int seqlen , int *letter ) 
{ 
  int i ;

  {
#line 41
  i = 0;
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
#line 41
    if (! (i < seqlen)) {
#line 41
      goto while_break;
    }
#line 43
    *(seq + i) = (signed char )*(letter + (int )*(seq + i));
#line 44
    if ((int )*(seq + i) == -1) {
      {
#line 46
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unknown character\n");
#line 47
      exit(1);
      }
    }
#line 41
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return;
}
}
#line 61 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/euler.c"
void kletcount(signed char *seq , int seqlen , int k , int m , int *count ) 
{ 
  int i ;
  int hash ;
  int chop ;
  double tmp ;
  int tmp___0 ;

  {
  {
#line 63
  hash = 0;
#line 65
  tmp = pow((double )m, (double )(k - 1));
#line 65
  chop = (int )tmp;
#line 67
  hash = 0;
  }
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! (hash < chop * m)) {
#line 67
      goto while_break;
    }
#line 67
    tmp___0 = hash;
#line 67
    hash ++;
#line 67
    *(count + tmp___0) = 0;
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  i = 0;
  {
#line 70
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 70
    if (! (i < k - 1)) {
#line 70
      goto while_break___0;
    }
#line 72
    if ((int )*(seq + i) >= 0) {
#line 72
      if (! ((int )*(seq + i) < m)) {
        {
#line 72
        __assert_fail("seq[i] >= 0 && seq[i] < m", "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/euler.c",
                      72U, "kletcount");
        }
      }
    } else {
      {
#line 72
      __assert_fail("seq[i] >= 0 && seq[i] < m", "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/euler.c",
                    72U, "kletcount");
      }
    }
#line 73
    hash = hash * m + (int )*(seq + i);
#line 70
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 76
  i = k - 1;
  {
#line 76
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 76
    if (! (i < seqlen)) {
#line 76
      goto while_break___1;
    }
#line 78
    if ((int )*(seq + i) >= 0) {
#line 78
      if (! ((int )*(seq + i) < m)) {
        {
#line 78
        __assert_fail("seq[i] >= 0 && seq[i] < m", "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/euler.c",
                      78U, "kletcount");
        }
      }
    } else {
      {
#line 78
      __assert_fail("seq[i] >= 0 && seq[i] < m", "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/euler.c",
                    78U, "kletcount");
      }
    }
#line 79
    hash = (hash % chop) * m + (int )*(seq + i);
#line 80
    (*(count + hash)) ++;
#line 76
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 82
  return;
}
}
#line 96 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/euler.c"
int kletverify(signed char *seq , int seqlen , int k , int m , int *count0 , int *count1 ) 
{ 
  int hash ;
  int nklets ;
  int errflag ;
  char klet[11] ;
  double tmp ;
  char *tmp___0 ;

  {
  {
#line 99
  errflag = 0;
#line 102
  tmp = pow((double )m, (double )k);
#line 102
  nklets = (int )tmp;
#line 103
  kletcount(seq, seqlen, k, m, count1);
#line 104
  hash = 0;
  }
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (! (hash < nklets)) {
#line 104
      goto while_break;
    }
#line 105
    if (*(count1 + hash) != *(count0 + hash)) {
      {
#line 107
      tmp___0 = hash2str(hash, k, m, klet);
#line 107
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Mismatch: %s: %i in orig, %i in shf\n",
              tmp___0, *(count0 + hash), *(count1 + hash));
#line 109
      errflag = 1;
      }
    }
#line 104
    hash ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 116
  return (! errflag);
}
}
#line 132 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/euler.c"
int edgecount(int k , int m , int last , int *count , int *vdeg ) 
{ 
  int i ;
  int j ;
  int nk1lets ;
  int sum ;
  int nver ;
  double tmp ;

  {
  {
#line 136
  tmp = pow((double )m, (double )(k - 1));
#line 136
  nk1lets = (int )tmp;
#line 137
  i = 0;
#line 137
  nver = 0;
  }
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    if (! (i < nk1lets)) {
#line 137
      goto while_break;
    }
#line 139
    j = m * i;
#line 139
    sum = 0;
    {
#line 139
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 139
      if (! (j < m * (i + 1))) {
#line 139
        goto while_break___0;
      }
#line 140
      sum += *(count + j);
#line 139
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 141
    *(vdeg + i) = sum;
#line 142
    if (sum > 0) {
#line 143
      nver ++;
    }
#line 137
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 145
  if (*(vdeg + last) == 0) {
#line 146
    nver ++;
  }
#line 147
  return (nver);
}
}
#line 157 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/euler.c"
void kletoutput(FILE *fp , int k , int m , int *count ) 
{ 
  int hash ;
  int sum ;
  int nklets ;
  char klet[11] ;
  double tmp ;
  char *tmp___0 ;

  {
  {
#line 159
  sum = 0;
#line 162
  tmp = pow((double )m, (double )k);
#line 162
  nklets = (int )tmp;
#line 163
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
#line 164
  hash = 0;
  }
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! (hash < nklets)) {
#line 164
      goto while_break;
    }
    {
#line 166
    tmp___0 = hash2str(hash, k, m, klet);
#line 166
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s %7i\n",
            tmp___0, *(count + hash));
#line 167
    sum += *(count + hash);
#line 164
    hash ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 169
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\nSum: %i\n",
          sum);
  }
#line 170
  return;
}
}
#line 180 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/euler.c"
char *hash2str(int hash , int k , int m , char *klet ) 
{ 
  int i ;

  {
#line 184
  i = k - 1;
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if (! (i >= 0)) {
#line 184
      goto while_break;
    }
#line 186
    *(klet + i) = alpha[hash % m];
#line 187
    hash /= m;
#line 184
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 189
  *(klet + k) = (char )'\000';
#line 190
  return (klet);
}
}
#line 200 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/euler.c"
int ind2hash(char *klet , int k , int m ) 
{ 
  int i ;
  int hash ;

  {
#line 202
  hash = 0;
#line 204
  i = 0;
  {
#line 204
  while (1) {
    while_continue: /* CIL Label */ ;
#line 204
    if (! (i < k)) {
#line 204
      goto while_break;
    }
#line 205
    hash = hash * m + (int )*(klet + i);
#line 204
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 206
  return (hash);
}
}
#line 232 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/euler.c"
void shuffle(int m , int k , int nver , int *count , int *vdeg , int first , int last ,
             int *lastedge , char *seq ) 
{ 
  int nk1lets ;
  double tmp ;

  {
  {
#line 237
  tmp = pow((double )m, (double )(k - 1));
#line 237
  nk1lets = (int )tmp;
  }
#line 247
  if (debugflag) {
    {
#line 248
    fprintf((FILE */* __restrict  */)dlog, (char const   */* __restrict  */)"constructing arborescence\n");
    }
  }
  {
#line 249
  arborescence(m, nk1lets, nver, count, vdeg, first, last, lastedge);
  }
#line 251
  if (debugflag) {
    {
#line 252
    fprintf((FILE */* __restrict  */)dlog, (char const   */* __restrict  */)"\nmaking random trail\n");
    }
  }
  {
#line 253
  randomtrail(m, k, count, vdeg, first, lastedge, seq);
  }
#line 254
  if (debugflag) {
    {
#line 255
    fprintf((FILE */* __restrict  */)dlog, (char const   */* __restrict  */)"OK!\n");
    }
  }
#line 257
  return;
}
}
#line 264 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/euler.c"
void monoshuffle(int seqlen , char *seq ) 
{ 
  int i ;
  int j ;
  char temp ;
  double tmp ;

  {
#line 269
  i = 0;
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    if (! (i < seqlen)) {
#line 269
      goto while_break;
    }
    {
#line 272
    tmp = unif01();
#line 272
    j = (i + ((int )((double )(seqlen - i) * tmp) + 1)) - 1;
#line 273
    temp = *(seq + i);
#line 274
    *(seq + i) = *(seq + j);
#line 275
    *(seq + j) = temp;
#line 269
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 277
  return;
}
}
#line 305 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/euler.c"
void arborescence(int m , int nk1lets , int nver , int *count , int *vdeg , int first ,
                  int root , int *branch ) 
{ 
  int vertex ;
  int remain ;
  int edgeno ;
  int edge ;
  int i ;
  double tmp ;

  {
#line 310
  if (debugflag) {
    {
#line 311
    fprintf((FILE */* __restrict  */)dlog, (char const   */* __restrict  */)"m=%i, nver=%i, root=%i\n",
            m, nver, root);
    }
  }
#line 313
  if (first != root) {
#line 314
    (*(vdeg + root)) ++;
  }
#line 316
  i = 0;
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if (! (i < nk1lets)) {
#line 316
      goto while_break;
    }
#line 317
    *(branch + i) = -1;
#line 316
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 319
  vertex = root;
#line 320
  *(branch + root) = m;
#line 321
  remain = nver - 1;
#line 322
  if (debugflag) {
    {
#line 323
    fprintf((FILE */* __restrict  */)dlog, (char const   */* __restrict  */)"%i ",
            vertex);
    }
  }
  {
#line 326
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 326
    if (! (remain > 0)) {
#line 326
      goto while_break___0;
    }
    {
#line 329
    tmp = unif01();
#line 329
    edgeno = (int )((double )*(vdeg + vertex) * tmp) + 1;
    }
#line 330
    if (debugflag) {
      {
#line 331
      fprintf((FILE */* __restrict  */)dlog, (char const   */* __restrict  */)"(%i/%i)",
              edgeno, *(vdeg + vertex));
      }
    }
#line 332
    if (vertex == first) {
#line 332
      if (first != root) {
#line 332
        if (edgeno == *(vdeg + vertex)) {
#line 334
          if (debugflag) {
            {
#line 335
            fprintf((FILE */* __restrict  */)dlog, (char const   */* __restrict  */)"xtra");
            }
          }
#line 336
          vertex = root;
#line 337
          goto while_continue___0;
        }
      }
    }
#line 339
    edge = vertex;
#line 340
    edgeno -= *(count + edge);
    {
#line 341
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 341
      if (! (edgeno > 0)) {
#line 341
        goto while_break___1;
      }
#line 343
      edge += nk1lets;
#line 344
      edgeno -= *(count + edge);
    }
    while_break___1: /* CIL Label */ ;
    }
#line 346
    if (! (edge < m * nk1lets)) {
      {
#line 346
      __assert_fail("edge < m*nk1lets", "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/euler.c",
                    346U, "arborescence");
      }
    }
#line 347
    vertex = edge / m;
#line 348
    if (debugflag) {
      {
#line 349
      fprintf((FILE */* __restrict  */)dlog, (char const   */* __restrict  */)"=%i ",
              vertex);
      }
    }
#line 350
    if (*(branch + vertex) == -1) {
#line 352
      *(branch + vertex) = edge % m;
#line 353
      remain --;
#line 354
      if (debugflag) {
        {
#line 355
        fprintf((FILE */* __restrict  */)dlog, (char const   */* __restrict  */)"[%i]",
                remain);
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 360
  if (first != root) {
#line 361
    (*(vdeg + root)) --;
  }
#line 362
  return;
}
}
#line 390 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/euler.c"
void randomtrail(int m , int k , int *count , int *vdeg , int first , int *lastedge ,
                 char *seq ) 
{ 
  int nk1lets ;
  int vertex ;
  int nedges ;
  int letter ;
  int edge ;
  int edgeno ;
  int i ;
  double tmp ;
  double tmp___0 ;

  {
  {
#line 395
  tmp = pow((double )m, (double )(k - 1));
#line 395
  nk1lets = (int )tmp;
  }
#line 397
  if (! (k >= 2)) {
    {
#line 397
    __assert_fail("k >= 2", "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/euler.c",
                  397U, "randomtrail");
    }
  }
#line 399
  i = 0;
  {
#line 399
  while (1) {
    while_continue: /* CIL Label */ ;
#line 399
    if (! (i < nk1lets)) {
#line 399
      goto while_break;
    }
#line 400
    if (*(lastedge + i) >= 0) {
#line 400
      if (*(lastedge + i) < m) {
#line 403
        (*(count + (m * i + *(lastedge + i)))) --;
#line 404
        (*(vdeg + i)) --;
      }
    }
#line 399
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 407
  vertex = first;
#line 408
  if (debugflag) {
    {
#line 409
    fprintf((FILE */* __restrict  */)dlog, (char const   */* __restrict  */)"%i ",
            vertex);
    }
  }
#line 412
  i = k - 1;
  {
#line 412
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 414
    nedges = *(vdeg + vertex);
#line 415
    if (nedges == 0) {
#line 417
      if (debugflag) {
        {
#line 418
        fprintf((FILE */* __restrict  */)dlog, (char const   */* __restrict  */)"(*)");
        }
      }
#line 419
      letter = *(lastedge + vertex);
#line 420
      if (letter == m) {
#line 421
        goto while_break___0;
      }
    } else {
      {
#line 426
      tmp___0 = unif01();
#line 426
      edgeno = (int )((double )nedges * tmp___0) + 1;
      }
#line 427
      if (debugflag) {
        {
#line 428
        fprintf((FILE */* __restrict  */)dlog, (char const   */* __restrict  */)"(%i/%i)",
                edgeno, *(vdeg + vertex));
        }
      }
#line 429
      edge = m * vertex;
#line 430
      edgeno -= *(count + edge);
      {
#line 431
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 431
        if (! (edgeno > 0)) {
#line 431
          goto while_break___1;
        }
#line 433
        if (debugflag) {
          {
#line 434
          fprintf((FILE */* __restrict  */)dlog, (char const   */* __restrict  */)"%i,%i ",
                  edge, *(count + edge));
          }
        }
#line 435
        edge ++;
#line 436
        edgeno -= *(count + edge);
      }
      while_break___1: /* CIL Label */ ;
      }
#line 438
      letter = edge - m * vertex;
#line 439
      if (! (letter < m)) {
        {
#line 439
        __assert_fail("letter < m", "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/euler.c",
                      439U, "randomtrail");
        }
      }
#line 440
      (*(count + edge)) --;
#line 441
      (*(vdeg + vertex)) --;
    }
#line 443
    *(seq + i) = (char )letter;
#line 444
    vertex = (m * vertex) % nk1lets + letter;
#line 445
    if (debugflag) {
      {
#line 446
      fprintf((FILE */* __restrict  */)dlog, (char const   */* __restrict  */)"=%i ",
              vertex);
      }
    }
#line 412
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 448
  return;
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 538
extern int getchar(void) ;
#line 85 "Spell/include/global.h"
int entiers(char c ) ;
#line 87
void entree(void) ;
#line 22 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/global.c"
int symb2int[256]  = {      -1};
#line 29 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/global.c"
void fatalError(char *msg ) 
{ 


  {
  {
#line 31
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: %s\n",
          msg);
#line 32
  exit(1);
  }
}
}
#line 38 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/global.c"
void warning(char *msg ) 
{ 


  {
  {
#line 40
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: %s\n",
          msg);
  }
#line 41
  return;
}
}
#line 46 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/global.c"
void initEntiers(void) 
{ 
  int i ;

  {
#line 50
  i = 0;
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    if (! (i < 256)) {
#line 50
      goto while_break;
    }
#line 51
    symb2int[i] = -1;
#line 50
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  symb2int['A'] = 0;
#line 54
  symb2int['C'] = 1;
#line 55
  symb2int['G'] = 2;
#line 56
  symb2int['T'] = 3;
#line 57
  symb2int['$'] = 4;
#line 58
  return;
}
}
#line 65 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/global.c"
int entiers(char c ) 
{ 
  int ret ;

  {
#line 69
  ret = symb2int[(int )c];
#line 70
  if (ret == -1) {
    {
#line 72
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-- %c --",
            (int )c);
#line 73
    fatalError((char *)"Unknown character, non A,C,G,T or $");
    }
  }
#line 76
  return (ret);
}
}
#line 83 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/global.c"
void entree(void) 
{ 


  {
  {
#line 85
  printf((char const   */* __restrict  */)"\n-- Type ENTER\n");
#line 86
  fflush(stdin);
#line 87
  getchar();
  }
#line 88
  return;
}
}
#line 23 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/allocateurs.c"
Allocateur Noeud_Alloc  ;
#line 24 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/allocateurs.c"
Allocateur Feuille_Alloc  ;
#line 25 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/allocateurs.c"
Liste *FREE_LISTE  =    (Liste *)((void *)0);
#line 26 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/allocateurs.c"
Liste *ALLOC_LISTE  =    (Liste *)((void *)0);
#line 45
extern int ( /* missing proto */  getpagesize)() ;
#line 32 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/allocateurs.c"
Alloc_Cell *Alloc_Alloc_Cell(int obj_size ) 
{ 
  Alloc_Cell *cel ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 38
  tmp = malloc(sizeof(Alloc_Cell ));
#line 38
  cel = (Alloc_Cell *)tmp;
  }
#line 39
  if ((unsigned long )cel == (unsigned long )((void *)0)) {
    {
#line 41
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No Enougth space\nProgram Abord\n");
#line 42
    exit(-1);
    }
  }
  {
#line 44
  cel->suivant = (struct _cell *)((void *)0);
#line 45
  tmp___0 = getpagesize();
#line 45
  tmp___1 = malloc((size_t )tmp___0);
#line 45
  cel->data = (unsigned char *)tmp___1;
  }
#line 46
  if ((unsigned long )cel->data == (unsigned long )((void *)0)) {
    {
#line 48
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No Enougth space\nProgram Abord\n");
#line 49
    exit(-1);
    }
  }
  {
#line 51
  cel->current = 0;
#line 52
  tmp___2 = getpagesize();
#line 52
  cel->max = tmp___2 / obj_size;
  }
#line 53
  return (cel);
}
}
#line 56 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/allocateurs.c"
Noeud *Alloc_Noeud(void) 
{ 
  int i ;
  Noeud *tmp ;
  void *tmp___0 ;

  {
#line 61
  if ((Noeud_Alloc.last)->max == (Noeud_Alloc.last)->current) {
    {
#line 63
    (Noeud_Alloc.last)->suivant = Alloc_Alloc_Cell((int )sizeof(Noeud ));
#line 64
    Noeud_Alloc.last = (Noeud_Alloc.last)->suivant;
#line 65
    tmp = (Noeud *)(Noeud_Alloc.last)->data;
#line 66
    ((Noeud_Alloc.last)->current) ++;
    }
  } else {
#line 70
    tmp = (Noeud *)((Noeud_Alloc.last)->data + sizeof(Noeud ) * (unsigned long )(Noeud_Alloc.last)->current);
#line 71
    ((Noeud_Alloc.last)->current) ++;
  }
  {
#line 74
  tmp->debut = 0;
#line 75
  tmp->fin = 0;
#line 76
  tmp->suffixe_link = (struct _Noeud *)((void *)0);
#line 77
  tmp___0 = malloc(sizeof(Noeud *) * (unsigned long )ALPHA_CARD);
#line 77
  tmp->fils = (Noeud **)tmp___0;
#line 78
  tmp->sequence_number = current_sequence;
  }
#line 79
  if (! tmp->fils) {
    {
#line 81
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No Enougth space\nProgram Abord\n");
#line 82
    exit(-1);
    }
  }
#line 84
  i = 0;
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! (i < ALPHA_CARD)) {
#line 84
      goto while_break;
    }
#line 85
    *(tmp->fils + i) = (struct _Noeud *)((void *)0);
#line 84
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 87
  tmp->sequences = AllocBitTab();
  }
#line 89
  return (tmp);
}
}
#line 92 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/allocateurs.c"
Feuille *Alloc_Feuille(void) 
{ 
  Feuille *tmp ;

  {
#line 96
  if ((Feuille_Alloc.last)->max == (Feuille_Alloc.last)->current) {
    {
#line 98
    (Feuille_Alloc.last)->suivant = Alloc_Alloc_Cell((int )sizeof(Feuille ));
#line 99
    Feuille_Alloc.last = (Feuille_Alloc.last)->suivant;
#line 100
    tmp = (Feuille *)(Feuille_Alloc.last)->data;
#line 101
    ((Feuille_Alloc.last)->current) ++;
    }
  } else {
#line 105
    tmp = (Feuille *)((Feuille_Alloc.last)->data + sizeof(Feuille ) * (unsigned long )(Feuille_Alloc.last)->current);
#line 106
    ((Feuille_Alloc.last)->current) ++;
  }
  {
#line 109
  tmp->debut = (-0x7FFFFFFF-1);
#line 110
  tmp->fin_deb = -1;
#line 111
  tmp->sequence_number = current_sequence;
#line 113
  tmp->sequences = AllocBitTab();
#line 114
  addBitTabValue(& tmp->sequences, current_sequence);
  }
#line 115
  return (tmp);
}
}
#line 119 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/allocateurs.c"
Liste *Alloc_Liste(void) 
{ 
  Liste *l ;
  void *tmp ;

  {
#line 122
  if ((unsigned long )FREE_LISTE == (unsigned long )((void *)0)) {
    {
#line 124
    tmp = malloc(sizeof(Liste ));
#line 124
    l = (Liste *)tmp;
    }
#line 128
    if (! l) {
      {
#line 130
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No Enougth space\nProgram Abord\n");
#line 131
      exit(-1);
      }
    }
#line 133
    l->suiv = (struct _Liste *)((void *)0);
#line 134
    l->feuille = (Feuille *)((void *)0);
  } else {
#line 138
    l = FREE_LISTE;
#line 139
    FREE_LISTE = FREE_LISTE->suiv;
#line 140
    l->suiv = (struct _Liste *)((void *)0);
#line 141
    l->feuille = (Feuille *)((void *)0);
  }
#line 143
  return (l);
}
}
#line 146 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/allocateurs.c"
void Free_Liste(Liste *l ) 
{ 


  {
#line 148
  l->suiv = FREE_LISTE;
#line 149
  FREE_LISTE = l;
#line 150
  return;
}
}
#line 152 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/allocateurs.c"
void Free_All_Liste_Cell(void) 
{ 
  Liste *tmp ;

  {
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! ((unsigned long )FREE_LISTE != (unsigned long )((void *)0))) {
#line 158
      goto while_break;
    }
    {
#line 160
    tmp = FREE_LISTE;
#line 161
    FREE_LISTE = FREE_LISTE->suiv;
#line 162
    free((void *)tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  FREE_LISTE = (Liste *)((void *)0);
#line 171
  return;
}
}
#line 173 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/allocateurs.c"
void Init_Allocateurs(void) 
{ 


  {
  {
#line 178
  Noeud_Alloc.first = Alloc_Alloc_Cell((int )sizeof(Noeud ));
#line 179
  Noeud_Alloc.last = Noeud_Alloc.first;
#line 180
  Feuille_Alloc.first = Alloc_Alloc_Cell((int )sizeof(Feuille ));
#line 181
  Feuille_Alloc.last = Feuille_Alloc.first;
#line 182
  FREE_LISTE = (Liste *)((void *)0);
  }
#line 183
  return;
}
}
#line 185 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/allocateurs.c"
void Free_Arbre(Noeud *Racine ) 
{ 
  Alloc_Cell *tmp ;
  Alloc_Cell *tmp2 ;
  Noeud *n ;
  Feuille *f___0 ;
  int i ;

  {
#line 195
  tmp = Noeud_Alloc.first;
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 196
      goto while_break;
    }
#line 201
    i = 0;
    {
#line 201
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 201
      if (! (i < tmp->current)) {
#line 201
        goto while_break___0;
      }
      {
#line 203
      n = (Noeud *)(tmp->data + (unsigned long )i * sizeof(Noeud ));
#line 204
      free((void *)n->fils);
#line 205
      free((void *)n->sequences);
#line 201
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 208
    tmp2 = tmp->suivant;
#line 209
    free((void *)tmp->data);
#line 210
    free((void *)tmp);
#line 211
    tmp = tmp2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  tmp = Feuille_Alloc.first;
  {
#line 214
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 214
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 214
      goto while_break___1;
    }
#line 219
    i = 0;
    {
#line 219
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 219
      if (! (i < tmp->current)) {
#line 219
        goto while_break___2;
      }
      {
#line 221
      f___0 = (Feuille *)(tmp->data + (unsigned long )i * sizeof(Feuille ));
#line 222
      free((void *)f___0->sequences);
#line 219
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 225
    tmp2 = tmp->suivant;
#line 226
    free((void *)tmp->data);
#line 227
    free((void *)tmp);
#line 228
    tmp = tmp2;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 230
  Feuille_Alloc.last = (Alloc_Cell *)((void *)0);
#line 230
  Feuille_Alloc.first = Feuille_Alloc.last;
#line 230
  Noeud_Alloc.last = Feuille_Alloc.first;
#line 230
  Noeud_Alloc.first = Noeud_Alloc.last;
#line 234
  return;
}
}
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 619 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 48 "/usr/include/x86_64-linux-gnu/sys/times.h"
extern  __attribute__((__nothrow__)) clock_t ( __attribute__((__leaf__)) times)(struct tms *__buffer ) ;
#line 27 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/io.c"
Mot *lectureFichierRes(FILE *res , int nbseq , int *nbmodeles , int *maxlongmod___0 ) 
{ 
  char car ;
  char line[4096] ;
  char ret ;
  char modele[4096] ;
  char codes[4096] ;
  char *ptr ;
  signed char tmp ;
  int i ;
  int nbligneslues ;
  int j ;
  int l ;
  Mot *modeles ;
  void *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 35
  fseek(res, 0L, 2);
#line 37
  i = 0;
  }
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 40
    fseek(res, -2L, 1);
#line 41
    fscanf((FILE */* __restrict  */)res, (char const   */* __restrict  */)"%c", & car);
    }
#line 42
    if ((int )car == 58) {
#line 43
      i ++;
    }
#line 38
    if (! (i != 2)) {
#line 38
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 47
  fscanf((FILE */* __restrict  */)res, (char const   */* __restrict  */)"%d", nbmodeles);
  }
#line 50
  if (*nbmodeles <= 0) {
#line 51
    return ((Mot *)((void *)0));
  }
  {
#line 54
  fseek(res, 320L, 0);
#line 56
  tmp___0 = calloc((size_t )*nbmodeles, sizeof(Mot ));
#line 56
  modeles = (Mot *)tmp___0;
  }
#line 57
  if ((unsigned long )modeles == (unsigned long )((void *)0)) {
    {
#line 58
    fatalError((char *)"lectureFichierRes: cannot allocate \'modeles\'");
    }
  }
  {
#line 62
  i = 0;
#line 63
  fgets((char */* __restrict  */)(line), 4096, (FILE */* __restrict  */)res);
  }
  {
#line 65
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 70
    tmp___1 = sscanf((char const   */* __restrict  */)(line), (char const   */* __restrict  */)"%s %s %d %d\n",
                     modele, codes, & (modeles + i)->nbseq_vrai, & (modeles + i)->nboccex_vrai);
#line 70
    ret = (char )tmp___1;
#line 75
    tmp___2 = strlen((char const   *)(modele));
#line 75
    l = (int )tmp___2;
    }
#line 76
    if (l > *maxlongmod___0) {
#line 77
      *maxlongmod___0 = l;
    }
    {
#line 78
    tmp___4 = malloc((unsigned long )(l + 1) * sizeof(char ));
#line 78
    tmp___3 = (char *)tmp___4;
#line 78
    (modeles + i)->mot = tmp___3;
    }
#line 78
    if (! tmp___3) {
      {
#line 79
      fatalError((char *)"lectureFichierRes: cannot allocate \'modeles[i]\'");
      }
    }
    {
#line 80
    strcpy((char */* __restrict  */)(modeles + i)->mot, (char const   */* __restrict  */)(modele));
#line 83
    tmp___6 = strlen((char const   *)(codes));
#line 83
    tmp___7 = malloc((tmp___6 + 1UL) * sizeof(char ));
#line 83
    tmp___5 = (char *)tmp___7;
#line 83
    (modeles + i)->codes = tmp___5;
    }
#line 83
    if (! tmp___5) {
      {
#line 84
      fatalError((char *)"lectureFichierRes: cannot allocate \'modeles[i].codes\'");
      }
    }
#line 86
    j = 0;
#line 87
    ptr = codes;
    {
#line 89
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 89
      if (! ((int )*ptr != 0)) {
#line 89
        goto while_break___1;
      }
#line 91
      if ((int )*ptr == 42) {
#line 92
        *((modeles + i)->codes + j) = (char )numJOKER;
      } else
#line 93
      if ((int )*ptr == 45) {
#line 94
        *((modeles + i)->codes + j) = (char )numSAUT;
      } else {
#line 97
        tmp = (signed char )((int )*ptr - 48);
#line 98
        if ((int )tmp < 0) {
          {
#line 100
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> Error: Model \'%s\' corrupted (unknown symbol at position %d)\n",
                  modele, j + 1);
#line 102
          exit(1);
          }
        } else
#line 98
        if ((int )tmp >= nbSymbMod) {
          {
#line 100
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> Error: Model \'%s\' corrupted (unknown symbol at position %d)\n",
                  modele, j + 1);
#line 102
          exit(1);
          }
        }
#line 104
        *((modeles + i)->codes + j) = (char )tmp;
      }
#line 107
      j ++;
#line 108
      ptr ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 110
    *((modeles + i)->codes + j) = (char)-1;
#line 113
    (modeles + i)->quorum_reel = (float )(((double )((float )(modeles + i)->nbseq_vrai) * 100.0) / (double )nbseq);
#line 116
    if ((int )ret == 4) {
      {
#line 117
      fgets((char */* __restrict  */)(line), 4096, (FILE */* __restrict  */)res);
      }
    } else {
#line 120
      nbligneslues = 0;
      {
#line 121
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 123
        fgets((char */* __restrict  */)(line), 4096, (FILE */* __restrict  */)res);
#line 124
        nbligneslues ++;
#line 121
        tmp___8 = strncmp((char const   *)(line), "Seq", (size_t )3);
        }
#line 121
        if (tmp___8) {
#line 121
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 130
      if (nbligneslues == 1) {
        {
#line 132
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: output file contains no occurrences number,\n");
#line 134
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    although statistics on total number of occurrences have been requested.\n");
        }
#line 136
        return ((Mot *)((void *)0));
      } else {
        {
#line 139
        sscanf((char const   */* __restrict  */)(line), (char const   */* __restrict  */)"%d\n",
               & (modeles + i)->nboccex_vrai);
        }
      }
#line 141
      if (nbligneslues != 1) {
        {
#line 142
        fgets((char */* __restrict  */)(line), 4096, (FILE */* __restrict  */)res);
        }
      }
    }
    {
#line 147
    i ++;
#line 65
    tmp___9 = strncmp((char const   *)(line), "Nb models", (size_t )9);
    }
#line 65
    if (! tmp___9) {
#line 65
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 151
  return (modeles);
}
}
#line 157 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/io.c"
FILE *openFile(char *nom , char *mode ) 
{ 
  FILE *f___0 ;

  {
  {
#line 161
  f___0 = fopen((char const   */* __restrict  */)nom, (char const   */* __restrict  */)mode);
  }
#line 163
  if ((unsigned long )f___0 == (unsigned long )((void *)0)) {
    {
#line 165
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Impossible to open file \'%s\'.\n",
            nom);
#line 166
    exit(1);
    }
  }
#line 169
  return (f___0);
}
}
#line 179 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/io.c"
static float dust  ;
#line 175 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/io.c"
void printCpuTime(FILE *f___0 ) 
{ 
  float ust ;
  struct tms tms ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 181
  times(& tms);
#line 183
  ust = (float )tms.tms_utime;
  }
#line 185
  if ((unsigned long )f___0 == (unsigned long )((void *)0)) {
#line 187
    dust = ust;
  } else {
    {
#line 191
    ust -= dust;
#line 192
    tmp = sysconf(2);
#line 192
    printf((char const   */* __restrict  */)"User time : %.2f sec.\n", (double )(ust / (float )tmp));
#line 193
    tmp___0 = sysconf(2);
#line 193
    fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)"User time : %.2f sec.\n",
            (double )(ust / (float )tmp___0));
    }
  }
#line 195
  return;
}
}
#line 348 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 63 "Spell/include/criteres.h"
Flag setBloc(P_Criteres cr , signed char bloc ) ;
#line 64
Flag setLongueurBloc(P_Criteres cr , signed char num_bloc , int lon ) ;
#line 65
Flag setErreurBloc(P_Criteres cr , signed char num_bloc , int err ) ;
#line 66
void setErreurGlobal(P_Criteres cr , int err ) ;
#line 67
Flag setSaut(P_Criteres cr , signed char num_bloc , int min , int max___3 ) ;
#line 68
signed char getBloc(Criteres cr ) ;
#line 69
int getLongueurBloc(Criteres cr , signed char num_bloc ) ;
#line 73
Fourchette getSaut(Criteres cr , signed char num_bloc ) ;
#line 75
void afficheCriteres(Criteres cr , FILE *f___0 ) ;
#line 85
Flag allocBloc(P_Criteres cr , signed char bloc ) ;
#line 25 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/criteres.c"
void libereTabSauts(P_Criteres cr ) ;
#line 26
int recFillTab(int bloc , Criteres cr , int *nbcodes , int **code2Sauts___0 ) ;
#line 36 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/criteres.c"
Flag setBloc(P_Criteres cr , signed char bloc ) 
{ 
  Flag tmp ;

  {
  {
#line 38
  tmp = allocBloc(cr, bloc);
  }
#line 38
  if (! tmp) {
#line 39
    return ((Flag )0);
  }
#line 41
  cr->bloc = bloc;
#line 43
  return ((Flag )1);
}
}
#line 47 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/criteres.c"
Flag setLongueurBloc(P_Criteres cr , signed char num_bloc , int lon ) 
{ 


  {
#line 49
  if ((int )num_bloc >= (int )cr->bloc) {
#line 50
    return ((Flag )0);
  } else
#line 49
  if ((int )num_bloc < 0) {
#line 50
    return ((Flag )0);
  }
#line 52
  (cr->longbloc + (int )num_bloc)->max = lon;
#line 54
  return ((Flag )1);
}
}
#line 58 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/criteres.c"
void setErreurGlobal(P_Criteres cr , int err ) 
{ 


  {
#line 60
  cr->maxerr = err;
#line 61
  return;
}
}
#line 64 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/criteres.c"
Flag setErreurBloc(P_Criteres cr , signed char num_bloc , int err ) 
{ 


  {
#line 66
  if ((int )num_bloc >= (int )cr->bloc) {
#line 67
    return ((Flag )0);
  } else
#line 66
  if ((int )num_bloc < 0) {
#line 67
    return ((Flag )0);
  }
#line 69
  *(cr->maxerrblocs + (int )num_bloc) = err;
#line 71
  return ((Flag )1);
}
}
#line 75 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/criteres.c"
Flag setSaut(P_Criteres cr , signed char num_bloc , int min , int max___3 ) 
{ 


  {
#line 77
  if ((int )num_bloc >= (int )cr->bloc - 1) {
#line 78
    return ((Flag )0);
  } else
#line 77
  if ((int )num_bloc < 0) {
#line 78
    return ((Flag )0);
  }
#line 80
  (cr->saut + (int )num_bloc)->min = min;
#line 81
  (cr->saut + (int )num_bloc)->max = max___3;
#line 83
  return ((Flag )1);
}
}
#line 87 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/criteres.c"
signed char getBloc(Criteres cr ) 
{ 


  {
#line 88
  return (cr.bloc);
}
}
#line 91 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/criteres.c"
int getLongueurBloc(Criteres cr , signed char num_bloc ) 
{ 


  {
#line 93
  if ((int )num_bloc >= (int )cr.bloc) {
#line 94
    return (-1);
  } else
#line 93
  if ((int )num_bloc < 0) {
#line 94
    return (-1);
  }
#line 96
  return ((cr.longbloc + (int )num_bloc)->max);
}
}
#line 100 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/criteres.c"
int getErreurGlobal(Criteres cr ) 
{ 


  {
#line 101
  return (cr.maxerr);
}
}
#line 104 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/criteres.c"
int getErreur(Criteres cr , signed char num_bloc ) 
{ 


  {
#line 106
  if ((int )num_bloc >= (int )cr.bloc) {
#line 107
    return (-1);
  } else
#line 106
  if ((int )num_bloc < 0) {
#line 107
    return (-1);
  }
#line 109
  return (*(cr.maxerrblocs + (int )num_bloc));
}
}
#line 113 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/criteres.c"
Fourchette getSaut(Criteres cr , signed char num_bloc ) 
{ 


  {
#line 115
  return (*(cr.saut + (int )num_bloc));
}
}
#line 119 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/criteres.c"
int maxLongMod(Criteres cr ) 
{ 
  int i ;
  int max___3 ;

  {
#line 123
  max___3 = (cr.longbloc + 0)->max;
#line 125
  i = 0;
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 125
    if (! (i < (int )cr.bloc - 1)) {
#line 125
      goto while_break;
    }
#line 127
    max___3 += (cr.saut + i)->max;
#line 128
    max___3 += (cr.longbloc + (i + 1))->max;
#line 125
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  return (max___3);
}
}
#line 137 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/criteres.c"
void afficheCriteres(Criteres cr , FILE *f___0 ) 
{ 
  int i ;

  {
  {
#line 141
  fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)"Blocs               %d\n",
          (int )cr.bloc);
#line 142
  fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)"Longueur min totale %d\n",
          cr.longmod.min);
#line 143
  fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)"Longueur max totale %d\n",
          cr.longmod.max);
#line 144
  fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)"Erreurs globales    %d\n",
          cr.maxerr);
  }
#line 145
  if ((int )cr.bloc <= 1) {
    {
#line 147
    fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)"\n\n");
    }
#line 148
    return;
  }
#line 151
  i = 0;
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    if (! (i < (int )cr.bloc)) {
#line 151
      goto while_break;
    }
    {
#line 153
    fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)"\nBLOC %d\n",
            i);
#line 154
    fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)"Longueur min    %d\n",
            (cr.longbloc + i)->min);
#line 155
    fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)"Longueur max    %d\n",
            (cr.longbloc + i)->max);
#line 156
    fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)"Erreurs         %d\n",
            *(cr.maxerrblocs + i));
    }
#line 158
    if (i != (int )cr.bloc - 1) {
      {
#line 160
      fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)"Saut min        %d\n",
              (cr.saut + i)->min);
#line 161
      fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)"Saut max        %d\n",
              (cr.saut + i)->max);
      }
    }
#line 151
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 164
  fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)"\n\n");
  }
#line 165
  return;
}
}
#line 170 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/criteres.c"
Flag verifCriteres(Criteres cr ) 
{ 
  int i ;

  {
#line 174
  if (cr.maxerr == -1) {
    {
#line 176
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"verifCriteres: global errors number needs to be fixed (setErreurGlobal\n");
    }
#line 178
    return ((Flag )0);
  }
#line 181
  if ((int )cr.bloc <= 0) {
    {
#line 183
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"verifCriteres: boxes number has to be fixed (setBloc)\n");
    }
#line 185
    return ((Flag )0);
  }
#line 188
  if ((cr.longbloc + 0)->max < 0) {
    {
#line 190
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"verifCriteres: first box\'s max length must be fixed (setLongueurBloc)\n");
    }
#line 192
    return ((Flag )0);
  }
#line 195
  if ((int )cr.bloc == 1) {
#line 196
    return ((Flag )1);
  }
#line 198
  i = 0;
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    if (! (i < (int )cr.bloc)) {
#line 198
      goto while_break;
    }
#line 200
    if (*(cr.maxerrblocs + i) == -1) {
      {
#line 202
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"verifCriteres: max errors for box %d has to be fixed (setErreurBloc)\n",
              i + 1);
      }
#line 204
      return ((Flag )0);
    }
#line 207
    if ((cr.longbloc + i)->max < 0) {
      {
#line 209
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"verifCriteres: max length for box %d has to be fixed (setLongueurBloc)\n",
              i + 1);
      }
#line 211
      return ((Flag )0);
    }
#line 214
    if (i != (int )cr.bloc - 1) {
#line 216
      if ((cr.saut + i)->min == -1) {
        {
#line 218
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"verifCriteres: min spacer length after box %d has to be fixed (setSaut)\n",
                i + 1);
        }
#line 220
        return ((Flag )0);
      }
#line 223
      if ((cr.saut + i)->max <= 0) {
        {
#line 225
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"verifCriteres: max spacer length after box %d has to be fixed (setSaut)\n",
                i + 1);
        }
#line 227
        return ((Flag )0);
      }
#line 230
      if ((cr.saut + i)->min > (cr.saut + i)->max) {
        {
#line 232
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"verifCriteres: max spacer length has to be greater than min spacer length!\n");
        }
#line 234
        return ((Flag )0);
      }
    }
#line 198
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 238
  return ((Flag )1);
}
}
#line 246 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/criteres.c"
int addSaut2Code(int oldcode , int saut , int curbloc , P_Criteres cr ) 
{ 


  {
#line 251
  if (curbloc == 0) {
#line 256
    return (saut - (cr->saut + 0)->min);
  }
#line 259
  oldcode *= ((cr->saut + curbloc)->max - (cr->saut + curbloc)->min) + 1;
#line 260
  oldcode += saut - (cr->saut + curbloc)->min;
#line 265
  return (oldcode);
}
}
#line 271 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/criteres.c"
void initTabSauts(P_Criteres cr ) 
{ 
  int bloc ;
  int **i ;
  int j ;
  int nbcodes ;
  int **tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  void *tmp___2 ;

  {
#line 273
  bloc = (int )cr->bloc;
#line 275
  if ((unsigned long )cr->code2Sauts != (unsigned long )((void *)0)) {
    {
#line 276
    libereTabSauts(cr);
    }
  }
#line 278
  nbcodes = 1;
#line 279
  j = 0;
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
#line 279
    if (! (j != bloc - 1)) {
#line 279
      goto while_break;
    }
#line 280
    nbcodes *= ((cr->saut + j)->max - (cr->saut + j)->min) + 1;
#line 279
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 282
  tmp___0 = malloc((unsigned long )nbcodes * sizeof(int *));
#line 282
  tmp = (int **)tmp___0;
#line 282
  cr->code2Sauts = tmp;
  }
#line 282
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 283
    fatalError((char *)"criteres.c: initTabSauts: cannot allocate \'code2Sauts\'\n");
    }
  }
#line 285
  j = 0;
#line 285
  i = cr->code2Sauts;
  {
#line 285
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 285
    if (! (j != nbcodes)) {
#line 285
      goto while_break___0;
    }
    {
#line 286
    tmp___2 = malloc((unsigned long )(bloc - 1) * sizeof(int ));
#line 286
    tmp___1 = (int *)tmp___2;
#line 286
    *i = tmp___1;
    }
#line 286
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      {
#line 287
      fatalError((char *)"criteres.c: initTabSauts: cannot allocate \'code2Sauts[j]\'\n");
      }
    }
#line 285
    j ++;
#line 285
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 289
  recFillTab(0, *cr, & nbcodes, cr->code2Sauts);
  }
#line 290
  return;
}
}
#line 295 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/criteres.c"
void libereTabSauts(P_Criteres cr ) 
{ 
  int bloc ;
  int **i ;
  int j ;
  int nbcodes ;

  {
#line 297
  bloc = (int )cr->bloc;
#line 299
  nbcodes = 1;
#line 300
  j = 0;
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 300
    if (! (j != bloc - 1)) {
#line 300
      goto while_break;
    }
#line 301
    nbcodes *= ((cr->saut + j)->max - (cr->saut + j)->min) + 1;
#line 300
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 304
  j = 0;
#line 304
  i = cr->code2Sauts;
  {
#line 304
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 304
    if (! (j != nbcodes)) {
#line 304
      goto while_break___0;
    }
    {
#line 305
    free((void *)*i);
#line 304
    j ++;
#line 304
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 307
  free((void *)cr->code2Sauts);
#line 309
  cr->code2Sauts = (int **)((void *)0);
  }
#line 310
  return;
}
}
#line 316 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/criteres.c"
int recFillTab(int bloc , Criteres cr , int *nbcodes , int **code2Sauts___0 ) 
{ 
  int i ;
  int j ;
  int k ;
  int pos___3 ;
  int a ;

  {
#line 318
  pos___3 = 0;
#line 320
  if (bloc != (int )cr.bloc - 2) {
    {
#line 321
    a = recFillTab(bloc + 1, cr, nbcodes, code2Sauts___0);
    }
  } else {
#line 323
    a = 1;
  }
#line 325
  *nbcodes /= ((cr.saut + bloc)->max - (cr.saut + bloc)->min) + 1;
#line 326
  i = 0;
  {
#line 326
  while (1) {
    while_continue: /* CIL Label */ ;
#line 326
    if (! (i != *nbcodes)) {
#line 326
      goto while_break;
    }
#line 327
    j = (cr.saut + bloc)->min;
    {
#line 327
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 327
      if (! (j != (cr.saut + bloc)->max + 1)) {
#line 327
        goto while_break___0;
      }
#line 328
      k = 0;
      {
#line 328
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 328
        if (! (k != a)) {
#line 328
          goto while_break___1;
        }
#line 330
        *(*(code2Sauts___0 + pos___3) + bloc) = j;
#line 331
        pos___3 ++;
#line 328
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 327
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 326
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 333
  printf((char const   */* __restrict  */)"\n");
  }
#line 334
  return (a * (((cr.saut + bloc)->max - (cr.saut + bloc)->min) + 1));
}
}
#line 340 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/criteres.c"
Flag allocBloc(P_Criteres cr , signed char bloc ) 
{ 
  int i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  signed char tmp___3 ;
  Flag tmp___4 ;

  {
#line 344
  if ((unsigned long )cr->maxerrblocs != (unsigned long )((void *)0)) {
    {
#line 346
    libereTabSauts(cr);
#line 347
    free((void *)cr->longbloc);
    }
#line 348
    if ((int )cr->bloc > 1) {
      {
#line 350
      free((void *)cr->maxerrblocs);
#line 351
      free((void *)cr->saut);
      }
    }
  }
  {
#line 355
  tmp = malloc((unsigned long )bloc * sizeof(Fourchette ));
#line 355
  cr->longbloc = (Fourchette *)tmp;
  }
#line 356
  if (! cr->longbloc) {
#line 357
    return ((Flag )0);
  }
  {
#line 359
  tmp___0 = malloc((unsigned long )bloc * sizeof(int ));
#line 359
  cr->maxerrblocs = (int *)tmp___0;
  }
#line 360
  if (! cr->maxerrblocs) {
#line 361
    return ((Flag )0);
  }
#line 363
  if ((int )bloc > 1) {
    {
#line 365
    tmp___1 = malloc((unsigned long )((int )bloc - 1) * sizeof(Fourchette ));
#line 365
    cr->saut = (Fourchette *)tmp___1;
    }
#line 367
    if (! cr->saut) {
#line 368
      return ((Flag )0);
    }
  }
#line 372
  i = 0;
  {
#line 372
  while (1) {
    while_continue: /* CIL Label */ ;
#line 372
    if (! (i != (int )bloc)) {
#line 372
      goto while_break;
    }
#line 374
    *(cr->maxerrblocs + i) = -1;
#line 375
    (cr->longbloc + i)->max = -1;
#line 376
    (cr->longbloc + i)->min = -1;
#line 377
    if (i != (int )bloc - 1) {
#line 378
      tmp___2 = -1;
#line 378
      (cr->saut + i)->max = tmp___2;
#line 378
      (cr->saut + i)->min = tmp___2;
    }
#line 372
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 382
  tmp___4 = (Flag )-1;
#line 382
  cr->multiblocs = tmp___4;
#line 382
  tmp___3 = (signed char )tmp___4;
#line 382
  cr->bloc = tmp___3;
#line 382
  cr->maxerr = (int )tmp___3;
#line 383
  cr->code2Sauts = (int **)((void *)0);
#line 384
  cr->nbtotseq = -1;
#line 385
  cr->longmod.max = -1;
#line 386
  cr->longmod.min = -1;
#line 388
  return ((Flag )1);
}
}
#line 394 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/criteres.c"
void initCriteres(struct struct_criteres *cr ) 
{ 


  {
#line 396
  cr->maxerr = -1;
#line 397
  cr->bloc = (signed char)-1;
#line 398
  cr->maxerrblocs = (int *)((void *)0);
#line 399
  cr->longbloc = (Fourchette *)((void *)0);
#line 400
  cr->saut = (Fourchette *)((void *)0);
#line 401
  cr->multiblocs = (Flag )0;
#line 402
  cr->code2Sauts = (int **)((void *)0);
#line 403
  cr->nbtotseq = 0;
#line 404
  cr->longmod.max = 0;
#line 405
  cr->longmod.min = 0;
#line 406
  return;
}
}
#line 411 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/criteres.c"
Flag chargeCriteres(struct struct_criteres *cr , char *line ) 
{ 
  int i ;
  int tmp ;
  int tmp2 ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;

  {
  {
#line 415
  tmp___0 = strtok((char */* __restrict  */)line, (char const   */* __restrict  */)"% ");
#line 415
  tmp = atoi((char const   *)tmp___0);
  }
#line 416
  if (tmp < 1) {
#line 417
    return ((Flag )0);
  }
  {
#line 418
  setBloc(cr, (signed char )tmp);
#line 420
  strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"%/ ");
#line 421
  tmp___1 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" /");
#line 421
  cr->nbtotseq = atoi((char const   *)tmp___1);
#line 422
  tmp___2 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
#line 422
  tmp___3 = atoi((char const   *)tmp___2);
#line 422
  cr->nbsymb = (long )tmp___3;
#line 423
  tmp___4 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
#line 423
  cr->longmod.min = atoi((char const   *)tmp___4);
#line 425
  tmp___5 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
#line 425
  tmp = atoi((char const   *)tmp___5);
#line 426
  cr->longmod.max = tmp;
  }
#line 427
  if ((int )cr->bloc == 1) {
    {
#line 428
    setLongueurBloc(cr, (signed char)0, tmp);
    }
  }
  {
#line 430
  tmp___6 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
#line 430
  tmp___7 = atoi((char const   *)tmp___6);
#line 430
  setErreurGlobal(cr, tmp___7);
  }
#line 432
  if ((int )cr->bloc != 1) {
#line 434
    i = 0;
    {
#line 434
    while (1) {
      while_continue: /* CIL Label */ ;
#line 434
      if (! (i != (int )cr->bloc)) {
#line 434
        goto while_break;
      }
      {
#line 436
      strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
#line 437
      tmp___8 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
#line 437
      tmp = atoi((char const   *)tmp___8);
#line 438
      setLongueurBloc(cr, (signed char )i, tmp);
#line 440
      tmp___9 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
#line 440
      tmp___10 = atoi((char const   *)tmp___9);
#line 440
      setErreurBloc(cr, (signed char )i, tmp___10);
      }
#line 442
      if (i != (int )cr->bloc - 1) {
        {
#line 444
        tmp___11 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
#line 444
        tmp = atoi((char const   *)tmp___11);
#line 445
        tmp___12 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
#line 445
        tmp2 = atoi((char const   *)tmp___12);
#line 447
        setSaut(cr, (signed char )i, tmp, tmp2);
        }
      }
#line 434
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 452
  tmp___13 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
#line 452
  strcpy((char */* __restrict  */)(cr->ficalph), (char const   */* __restrict  */)tmp___13);
#line 453
  tmp___14 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
#line 453
  strcpy((char */* __restrict  */)(cr->alphaseq), (char const   */* __restrict  */)tmp___14);
  }
#line 455
  return ((Flag )1);
}
}
#line 22 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/liste_pos.c"
ListePositions *Alloc_ListePositions(int size ) 
{ 
  ListePositions *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 24
  tmp___0 = malloc(sizeof(ListePositions ));
#line 24
  tmp = (ListePositions *)tmp___0;
  }
#line 25
  if (! tmp) {
    {
#line 27
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No Enough space\nProgram Abort\n");
#line 28
    exit(-1);
    }
  }
  {
#line 30
  tmp___1 = malloc(sizeof(int ) * (unsigned long )size);
#line 30
  tmp->tab[0] = (int *)tmp___1;
#line 31
  tmp___2 = malloc(sizeof(int ) * (unsigned long )size);
#line 31
  tmp->tab[1] = (int *)tmp___2;
  }
#line 37
  if (! tmp->tab[0]) {
    {
#line 39
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No Enough space\nProgram Abort\n");
#line 40
    exit(-1);
    }
  } else
#line 37
  if (! tmp->tab[1]) {
    {
#line 39
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No Enough space\nProgram Abort\n");
#line 40
    exit(-1);
    }
  }
  {
#line 42
  memset((void *)tmp->tab[0], 0, sizeof(int ) * (unsigned long )size);
#line 43
  memset((void *)tmp->tab[1], 0, sizeof(int ) * (unsigned long )size);
#line 44
  tmp->last_cell = 0;
#line 45
  tmp->tab_size = size;
  }
#line 46
  return (tmp);
}
}
#line 49 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/liste_pos.c"
int ChercheDerniereCelluleDansListe(ListePositions *lpos , int deb_liste ) 
{ 


  {
#line 51
  if ((unsigned long )lpos == (unsigned long )((void *)0)) {
#line 52
    return (-1);
  }
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if (! (*(lpos->tab[1] + deb_liste) != 268435455)) {
#line 53
      goto while_break;
    }
#line 54
    deb_liste = *(lpos->tab[1] + deb_liste) & 2147483647;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  return (deb_liste);
}
}
#line 58 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/liste_pos.c"
int Ajoute_Position_Liste(ListePositions *lpos , int *deb_liste , int position , int change_seq ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 60
  if (! lpos) {
#line 61
    return (-2);
  }
#line 63
  if (lpos->last_cell == lpos->tab_size) {
    {
#line 70
    tmp = realloc((void *)lpos->tab[0], sizeof(int ) * (unsigned long )(lpos->tab_size + 50));
#line 70
    lpos->tab[0] = (int *)tmp;
#line 71
    tmp___0 = realloc((void *)lpos->tab[1], sizeof(int ) * (unsigned long )(lpos->tab_size + 50));
#line 71
    lpos->tab[1] = (int *)tmp___0;
#line 72
    lpos->tab_size += 50;
    }
  }
#line 74
  *(lpos->tab[0] + lpos->last_cell) = position;
#line 75
  *(lpos->tab[1] + lpos->last_cell) = 268435455;
#line 77
  if (*deb_liste != -1) {
#line 79
    if (change_seq) {
#line 80
      *(lpos->tab[1] + lpos->last_cell) = (int )((unsigned int )*deb_liste | 2147483648U);
    } else {
#line 82
      *(lpos->tab[1] + lpos->last_cell) = *deb_liste;
    }
  }
#line 84
  *deb_liste = lpos->last_cell;
#line 85
  (lpos->last_cell) ++;
#line 86
  return (1);
}
}
#line 89 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/liste_pos.c"
int getValue(ListePositions *lpos , int i ) 
{ 


  {
#line 91
  if ((unsigned long )lpos == (unsigned long )((void *)0)) {
#line 92
    return (-2);
  }
#line 93
  if (i < 0) {
#line 94
    return (-3);
  } else
#line 93
  if (i > lpos->last_cell) {
#line 94
    return (-3);
  }
#line 95
  return (*(lpos->tab[0] + i));
}
}
#line 98 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/liste_pos.c"
void setListeValue(ListePositions *lpos , int i , int value ) 
{ 


  {
#line 100
  if ((unsigned long )lpos == (unsigned long )((void *)0)) {
#line 101
    return;
  } else
#line 100
  if (i < 0) {
#line 101
    return;
  } else
#line 100
  if (i > lpos->last_cell) {
#line 101
    return;
  }
#line 102
  *(lpos->tab[0] + i) = value;
#line 103
  return;
}
}
#line 105 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/liste_pos.c"
int getIndiceSuivant(ListePositions *lpos , int i ) 
{ 


  {
#line 107
  if ((unsigned long )lpos == (unsigned long )((void *)0)) {
#line 108
    return (-2);
  }
#line 109
  if (i < 0) {
#line 110
    return (-3);
  } else
#line 109
  if (i > lpos->last_cell) {
#line 110
    return (-3);
  }
#line 111
  return (*(lpos->tab[1] + i));
}
}
#line 115 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/liste_pos.c"
void Free_ListePositions(ListePositions *lpos ) 
{ 


  {
#line 117
  if ((unsigned long )lpos == (unsigned long )((void *)0)) {
#line 118
    return;
  }
  {
#line 119
  free((void *)lpos->tab[0]);
#line 120
  free((void *)lpos->tab[1]);
#line 121
  free((void *)lpos);
  }
#line 122
  return;
}
}
#line 124 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/liste_pos.c"
int Print_Positions_Dynamique(FILE *f___0 , Feuille *n , int longway , P_Criteres cr ,
                              int code ) 
{ 
  int indice ;
  int occurrence ;
  int longueur ;
  int *i ;
  int nb_element ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 127
  indice = n->fin_deb;
#line 127
  occurrence = 0;
#line 131
  nb_element = (((int )*(n->sequences + 0) & 127) << 8) | (int )*(n->sequences + 1);
#line 134
  nb_element --;
#line 135
  tmp = getValue(Liste_positions_fin, indice);
#line 135
  longueur = (tmp - (n->debut & 2147483647)) + longway;
  }
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    if (! (indice != 268435455)) {
#line 138
      goto while_break;
    }
#line 141
    if ((unsigned long )f___0 != (unsigned long )((void *)0)) {
      {
#line 143
      tmp___0 = getValue(Liste_positions_fin, indice);
#line 143
      fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)"Seq %5d   Pos %5d",
              (int )*((unsigned short *)(n->sequences + 2) + nb_element), tmp___0 - longueur);
      }
#line 147
      if (cr) {
#line 147
        if ((int )cr->bloc != 1) {
          {
#line 149
          fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)"\tSaut ");
#line 150
          i = *(cr->code2Sauts + code);
          }
          {
#line 150
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 150
            if (! ((unsigned long )i != (unsigned long )((*(cr->code2Sauts + code) + (int )cr->bloc) - 1))) {
#line 150
              goto while_break___0;
            }
            {
#line 151
            fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)"%d ",
                    *i);
#line 150
            i ++;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
      {
#line 154
      fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)"\n");
      }
    }
    {
#line 158
    indice = getIndiceSuivant(Liste_positions_fin, indice);
    }
#line 160
    if ((unsigned int )indice & 2147483648U) {
#line 161
      nb_element --;
    }
#line 163
    indice &= 2147483647;
#line 164
    occurrence ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 166
  return (occurrence);
}
}
#line 172 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/liste_pos.c"
int Print_Positions_Statique(FILE *f___0 , Feuille *n , int longway , P_Criteres cr ,
                             int code ) 
{ 
  unsigned char mask ;
  int compteur ;
  int sequence ;
  int indice ;
  int occurrence ;
  int longueur ;
  int *i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 175
  mask = (unsigned char)1;
#line 176
  compteur = SIZE_STATIC_BIT_TAB - 1;
#line 176
  sequence = 8 * compteur + 6;
#line 176
  indice = n->fin_deb;
#line 176
  occurrence = 0;
#line 184
  tmp = getValue(Liste_positions_fin, indice);
#line 184
  longueur = (tmp - (n->debut & 2147483647)) + longway;
  }
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! (((int )*(n->sequences + compteur) & (int )mask) == 0)) {
#line 187
      goto while_break;
    }
#line 189
    mask = (unsigned char )((int )mask << 1);
#line 190
    sequence --;
#line 192
    if ((int )mask == 0) {
#line 194
      mask = (unsigned char)1;
#line 195
      compteur --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 199
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 199
    if (! (indice != 268435455)) {
#line 199
      goto while_break___0;
    }
#line 202
    if ((unsigned long )f___0 != (unsigned long )((void *)0)) {
      {
#line 204
      tmp___0 = getValue(Liste_positions_fin, indice);
#line 204
      fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)"Seq %5d   Pos %5d",
              sequence, tmp___0 - longueur);
      }
#line 206
      if (cr) {
#line 206
        if ((int )cr->bloc != 1) {
          {
#line 208
          fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)"\tSaut ");
#line 209
          i = *(cr->code2Sauts + code);
          }
          {
#line 209
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 209
            if (! ((unsigned long )i != (unsigned long )((*(cr->code2Sauts + code) + (int )cr->bloc) - 1))) {
#line 209
              goto while_break___1;
            }
            {
#line 210
            fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)"%d ",
                    *i);
#line 209
            i ++;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
        }
      }
      {
#line 213
      fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)"\n");
      }
    }
    {
#line 216
    indice = getIndiceSuivant(Liste_positions_fin, indice);
    }
#line 217
    if ((unsigned int )indice & 2147483648U) {
#line 217
      if (indice != 268435455) {
        {
#line 219
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 221
          mask = (unsigned char )((int )mask << 1);
#line 222
          sequence --;
#line 224
          if ((int )mask == 0) {
#line 226
            mask = (unsigned char)1;
#line 227
            compteur --;
          }
#line 219
          if (! (((int )*(n->sequences + compteur) & (int )mask) == 0)) {
#line 219
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
#line 232
    occurrence ++;
#line 233
    indice &= 2147483647;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 235
  return (occurrence);
}
}
#line 238 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/liste_pos.c"
int Print_Positions(FILE *f___0 , Feuille *n , int longway , P_Criteres cr , int code ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 244
  if ((int )*(n->sequences + 0) & 128) {
    {
#line 245
    tmp = Print_Positions_Dynamique(f___0, n, longway, cr, code);
    }
#line 245
    return (tmp);
  }
  {
#line 247
  tmp___0 = Print_Positions_Statique(f___0, n, longway, cr, code);
  }
#line 247
  return (tmp___0);
}
}
#line 478 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/grep+.c"
static P_mod model___0  =    (P_mod )((void *)0);
#line 479 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/grep+.c"
static P_PileOcc pocc___0  =    (P_PileOcc )((void *)0);
#line 480 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/grep+.c"
static P_occ next___0  =    (P_occ )((void *)0);
#line 481 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/grep+.c"
static Bit_Tab *colors_model___0  ;
#line 482 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/grep+.c"
static char flag___0  =    (char)0;
#line 41 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/barre.c"
static int pos___0  =    0;
#line 42 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/barre.c"
static int max___0  =    0;
#line 43 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/barre.c"
static int lastecrit___0  =    0;
#line 44 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/Spell/src/barre.c"
static time_t start___0  ;
#line 179 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/io.c"
static float dust___0  ;
#line 60 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/libfasta.c"
static char sBuffer___0[8192]  ;
#line 61
static char *sNextIOBuffer___0(FILE *streamin , Bool retain , Bool serial ) ;
#line 61 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/libfasta.c"
static Bool sRetained___0  =    0;
#line 55 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/libfasta.c"
static char *sNextIOBuffer___0(FILE *streamin , Bool retain , Bool serial ) 
{ 
  char *buf ;
  char *end ;
  char *tmp ;
  size_t tmp___0 ;

  {
#line 63
  if (retain) {
#line 63
    goto _L;
  } else
#line 63
  if (sRetained___0) {
    _L: /* CIL Label */ 
#line 63
    if (serial) {
#line 63
      buf = sBuffer___0;
    } else {
      {
#line 63
      tmp = fgets((char */* __restrict  */)(sBuffer___0), (int )sizeof(sBuffer___0),
                  (FILE */* __restrict  */)streamin);
#line 63
      buf = tmp;
      }
    }
  } else {
    {
#line 63
    tmp = fgets((char */* __restrict  */)(sBuffer___0), (int )sizeof(sBuffer___0),
                (FILE */* __restrict  */)streamin);
#line 63
    buf = tmp;
    }
  }
#line 67
  if (buf) {
    {
#line 68
    tmp___0 = strlen((char const   *)buf);
#line 68
    end = (buf + tmp___0) - 1;
    }
#line 69
    if ((int )*end == 10) {
#line 69
      *end = (char )'\000';
    }
  }
#line 72
  sRetained___0 = retain;
#line 74
  return (buf);
}
}
#line 124 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/libfasta.c"
static char name___0[64]  ;
#line 140 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/grep+/src/libfasta.c"
static char comment___0[512]  ;
#line 30 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/faux.c"
void afficheKhi2(Mot *modeles , int nbmodeles , int nbseq_vrai , int nbseq_faux ,
                 long nbsymbV , long nbsymbF , FILE *out , int maxlongmod___0 ) ;
#line 209 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/faux.c"
static char space___0[31]  = 
#line 209
  {      (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'\000'};
#line 217 "/home/wheatley/newnew/temp/mlv-smile-1.47/SigStat/src/faux.c"
void afficheKhi2(Mot *modeles , int nbmodeles , int nbseq_vrai , int nbseq_faux ,
                 long nbsymbV , long nbsymbF , FILE *out , int maxlongmod___0 ) 
{ 
  Mot m ;
  float Pv ;
  float Pf ;
  float Av ;
  float Af ;
  float nP ;
  float nA ;
  float Fv ;
  float Ff ;
  float nbseqtot ;
  int i ;
  float Pv_ex ;
  float Pf_ex ;
  float Av_ex ;
  float Af_ex ;
  float nP_ex ;
  float nA_ex ;
  float Fv_ex ;
  float Ff_ex ;
  long nbsymbtot ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
#line 222
  Fv = (float )0;
#line 222
  Ff = (float )0;
#line 225
  Fv_ex = (float )0;
#line 225
  Ff_ex = (float )0;
#line 229
  i = 0;
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    if (! (i != nbmodeles)) {
#line 229
      goto while_break;
    }
#line 231
    m = *(modeles + i);
#line 232
    Pv = (float )m.nbseq_vrai;
#line 233
    Fv = Pv / (float )nbseq_vrai;
#line 234
    Pf = (float )m.nbseq_faux;
#line 235
    Ff = Pf / (float )nbseq_faux;
#line 236
    Av = (float )nbseq_vrai - Pv;
#line 237
    Af = (float )nbseq_faux - Pf;
#line 238
    nP = Pv + Pf;
#line 239
    nA = Av + Af;
#line 240
    nbseqtot = (float )(nbseq_vrai + nbseq_faux);
#line 249
    (modeles + i)->khi2 = (nbseqtot * ((Pv * Af - Pf * Av) * (Pv * Af - Pf * Av))) / (((nP * nA) * (float )nbseq_vrai) * (float )nbseq_faux);
#line 250
    if (Fv > Ff) {
#line 250
      (modeles + i)->sign = (char )'+';
    } else {
#line 250
      if (Fv == Ff) {
#line 250
        tmp = '=';
      } else {
#line 250
        tmp = '-';
      }
#line 250
      (modeles + i)->sign = (char )tmp;
    }
#line 253
    Pv_ex = (float )m.nboccex_vrai;
#line 254
    Fv_ex = Pv_ex / (float )nbsymbV;
#line 255
    Pf_ex = (float )m.nboccex_faux;
#line 256
    Ff_ex = Pf_ex / (float )nbsymbF;
#line 257
    Av_ex = (float )nbsymbV - Pv_ex;
#line 258
    Af_ex = (float )nbsymbF - Pf_ex;
#line 259
    nP_ex = Pv_ex + Pf_ex;
#line 260
    nA_ex = Av_ex + Af_ex;
#line 261
    nbsymbtot = nbsymbV + nbsymbF;
#line 269
    (modeles + i)->khi2_occ = (((Pv_ex * Af_ex - Pf_ex * Av_ex) * (Pv_ex * Af_ex - Pf_ex * Av_ex)) / (((nP_ex * nA_ex) * (float )nbsymbV) * (float )nbsymbF)) * (float )nbsymbtot;
#line 271
    if (Fv_ex > Ff_ex) {
#line 271
      (modeles + i)->sign_occ = (char )'+';
    } else {
#line 271
      if (Fv_ex == Ff_ex) {
#line 271
        tmp___0 = '=';
      } else {
#line 271
        tmp___0 = '-';
      }
#line 271
      (modeles + i)->sign_occ = (char )tmp___0;
    }
#line 229
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 275
  qsort((void *)modeles, (size_t )nbmodeles, sizeof(Mot ), (int (*)(void const   * ,
                                                                    void const   * ))(& comparModeles));
#line 279
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"Model");
#line 280
  espace(out, maxlongmod___0 - 2);
#line 281
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"#right\t#wrong");
#line 283
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\t#rightT\t#wrongT");
#line 285
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\t\tChi^2");
#line 287
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\t\tChi^2 T");
#line 289
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\n");
#line 290
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"================================================================================\n");
#line 292
  i = 0;
  }
  {
#line 292
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 292
    if (! (i != nbmodeles)) {
#line 292
      goto while_break___0;
    }
    {
#line 294
    m = *(modeles + i);
#line 295
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s", m.mot);
#line 296
    tmp___1 = strlen((char const   *)m.mot);
#line 296
    espace(out, (int )((size_t )(maxlongmod___0 + 4) - tmp___1));
#line 297
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%5d\t%5d",
            m.nbseq_vrai, m.nbseq_faux);
#line 300
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\t%5d\t%5d",
            m.nboccex_vrai, m.nboccex_faux);
#line 303
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\t\t%3.2f %c",
            (double )m.khi2, (int )m.sign);
#line 305
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\t\t%3.2f %c",
            (double )m.khi2_occ, (int )m.sign_occ);
#line 308
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\n");
#line 292
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 310
  return;
}
}
#line 52 "Spell/include/alphabet.h"
Symbole *chargeAlphabet(FILE *f___0 , Symbole **seq , int nbseq ) ;
#line 53
int str2nummod(char *str ) ;
#line 54
void transAlphMod(Flag pal ) ;
#line 22 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS/Spell/src/alphabet.c"
void chercheComp(char *s1 , char *s2 ) ;
#line 29 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS/Spell/src/alphabet.c"
char *alphMod[127]  ;
#line 33 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS/Spell/src/alphabet.c"
int comp[127]  ;
#line 69 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS/Spell/src/alphabet.c"
Symbole *chargeAlphabet(FILE *f___0 , Symbole **seq , int nbseq ) 
{ 
  int i ;
  int k ;
  Symbole *j ;
  char tmp[127] ;
  unsigned int tmp___0 ;
  char s ;
  char line[512] ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  unsigned short const   **tmp___9 ;
  unsigned short const   **tmp___10 ;
  char *tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  void *tmp___16 ;

  {
#line 73
  tmp[0] = (char)0;
#line 73
  tmp___0 = 1U;
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (tmp___0 >= 127U) {
#line 73
      goto while_break;
    }
#line 73
    tmp[tmp___0] = (char)0;
#line 73
    tmp___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  i = 0;
  {
#line 79
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 79
    if (! (i != nbseq)) {
#line 79
      goto while_break___0;
    }
#line 81
    j = *(seq + i);
    {
#line 81
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 81
      if (! ((int )*j != 36)) {
#line 81
        goto while_break___1;
      }
#line 83
      s = (char )*j;
#line 84
      if ((int )s < 32) {
        {
#line 86
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> Error: Seq %d Pos %d Control character %d (\'%c\')\n",
                i, (int )(j - *(seq + i)), (int )s, (int )s);
#line 88
        exit(1);
        }
      } else
#line 84
      if ((int )s >= 127) {
        {
#line 86
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> Error: Seq %d Pos %d Control character %d (\'%c\')\n",
                i, (int )(j - *(seq + i)), (int )s, (int )s);
#line 88
        exit(1);
        }
      } else
#line 90
      if ((int )s == 42) {
        {
#line 92
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> Error: Seq %d Pos %d Forbidden character %d (\'%c\') in the sequences\n",
                i, (int )(j - *(seq + i)), (int )s, (int )s);
#line 94
        exit(1);
        }
      } else
#line 90
      if ((int )s == 95) {
        {
#line 92
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> Error: Seq %d Pos %d Forbidden character %d (\'%c\') in the sequences\n",
                i, (int )(j - *(seq + i)), (int )s, (int )s);
#line 94
        exit(1);
        }
      } else {
        {
#line 96
        tmp___3 = __ctype_b_loc();
        }
#line 96
        if ((int const   )*(*tmp___3 + (int )s) & 8) {
          {
#line 99
          tmp___2 = __ctype_b_loc();
          }
#line 99
          if ((int const   )*(*tmp___2 + (int )s) & 512) {
            {
#line 101
            tmp___1 = toupper((int )s);
#line 101
            s = (char )((Symbole )tmp___1);
#line 102
            *j = (Symbole )s;
            }
          }
        } else {
          {
#line 97
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"> Warning: Seq %d Pos %d Non alphanumeric character \'%c\'\n",
                  i, (int )(j - *(seq + i)), (int )s);
          }
        }
      }
#line 105
      tmp[(int )s] = (char)1;
#line 81
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 79
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 110
  i = 32;
#line 110
  nbSymbSeq = 0;
  {
#line 110
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 110
    if (! (i != 127)) {
#line 110
      goto while_break___2;
    }
#line 112
    if ((int )tmp[i] == 1) {
#line 114
      alphSeq[nbSymbSeq] = (Symbole )i;
#line 115
      carseq2num[i] = nbSymbSeq;
#line 116
      nbSymbSeq ++;
    }
#line 110
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 119
  carseq2num['$'] = nbSymbSeq;
#line 120
  alphSeq[nbSymbSeq] = (Symbole )'$';
#line 121
  alphSeq[nbSymbSeq + 1] = (Symbole )'\000';
#line 123
  printf((char const   */* __restrict  */)"\n** Text alphabet: %s (%d symbols + terminator) **\n",
         alphSeq, nbSymbSeq);
#line 129
  fgets((char */* __restrict  */)(line), 512, (FILE */* __restrict  */)f___0);
#line 132
  tmp___5 = strstr((char const   *)(line), "Nucleotide");
  }
#line 132
  if (tmp___5) {
    {
#line 134
    type = (enum __anonenum_type_12 )0;
#line 135
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"** Models alphabet: Nucleotides **\n");
    }
  } else {
    {
#line 137
    tmp___4 = strstr((char const   *)(line), "Protein");
    }
#line 137
    if (tmp___4) {
      {
#line 139
      type = (enum __anonenum_type_12 )1;
#line 140
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"** Models alphabet: Amino-acids **\n");
      }
    } else {
      {
#line 144
      type = (enum __anonenum_type_12 )2;
#line 145
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"** Models alphabet: unknown **\n");
      }
    }
  }
#line 149
  nbSymbMod = 0;
  {
#line 150
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 150
    tmp___14 = fgets((char */* __restrict  */)(line), 512, (FILE */* __restrict  */)f___0);
    }
#line 150
    if (! tmp___14) {
#line 150
      goto while_break___3;
    }
#line 152
    j = (Symbole *)(line);
#line 154
    if ((int )*j == 10) {
#line 155
      goto while_continue___3;
    }
    {
#line 157
    tmp___6 = strlen((char const   *)(line));
#line 157
    tmp___7 = malloc((tmp___6 + 1UL) * sizeof(char ));
#line 157
    alphMod[nbSymbMod] = (char *)tmp___7;
    }
#line 158
    if ((unsigned long )alphMod[nbSymbMod] == (unsigned long )((void *)0)) {
      {
#line 159
      fatalError((char *)"alphabet.c: chargeAlphabet: cannot allocate \'alphMod[i]\'\n");
      }
    }
    {
#line 160
    strcpy((char */* __restrict  */)alphMod[nbSymbMod], (char const   */* __restrict  */)(line));
    }
    {
#line 161
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 161
      if ((int )*j != 0) {
#line 161
        if (! ((int )*j != 10)) {
#line 161
          goto while_break___4;
        }
      } else {
#line 161
        goto while_break___4;
      }
#line 163
      s = (char )*j;
#line 164
      if ((int )s <= 32) {
        {
#line 166
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> Error: Control character \'%c\' in the alphabet file\n",
                (int )s);
#line 167
        exit(1);
        }
      } else
#line 164
      if ((int )s >= 127) {
        {
#line 166
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> Error: Control character \'%c\' in the alphabet file\n",
                (int )s);
#line 167
        exit(1);
        }
      } else
#line 169
      if ((int )s == 42) {
#line 171
        if ((unsigned long )j != (unsigned long )((Symbole *)(line))) {
          {
#line 173
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> Error: JOKER character \'%c\' not alone\n",
                  '*');
#line 175
          exit(1);
          }
        } else
#line 171
        if ((int )*(j + 1) != 0) {
#line 171
          if ((int )*(j + 1) != 10) {
            {
#line 173
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> Error: JOKER character \'%c\' not alone\n",
                    '*');
#line 175
            exit(1);
            }
          }
        }
#line 178
        if (numJOKER != -1) {
          {
#line 179
          fatalError((char *)"JOKER defined 2 times in the alphabet file\n");
          }
        }
#line 181
        numJOKER = nbSymbMod;
#line 182
        k = 0;
        {
#line 182
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 182
          if (! (k != nbSymbSeq)) {
#line 182
            goto while_break___5;
          }
#line 183
          TabSymb[numJOKER][k] = (Flag )1;
#line 182
          k ++;
        }
        while_break___5: /* CIL Label */ ;
        }
      } else
#line 185
      if ((int )s == 36) {
        {
#line 187
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> Error: Forbidden character %d (\'%c\') in the alphabet file\n",
                (int )s, (int )s);
#line 189
        exit(1);
        }
      } else
#line 185
      if ((int )s == 95) {
        {
#line 187
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> Error: Forbidden character %d (\'%c\') in the alphabet file\n",
                (int )s, (int )s);
#line 189
        exit(1);
        }
      } else {
        {
#line 192
        tmp___10 = __ctype_b_loc();
        }
#line 192
        if ((int const   )*(*tmp___10 + (int )s) & 8) {
          {
#line 199
          tmp___9 = __ctype_b_loc();
          }
#line 199
          if ((int const   )*(*tmp___9 + (int )s) & 512) {
            {
#line 200
            tmp___8 = toupper((int )s);
#line 200
            s = (char )((Symbole )tmp___8);
#line 200
            *j = (Symbole )s;
            }
          }
#line 202
          TabSymb[nbSymbMod][carseq2num[(int )s]] = (Flag )1;
        } else {
          {
#line 194
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Non alphanumeric character \'%c\' in the alphabet file\n",
                  (int )s);
#line 195
          TabSymb[nbSymbMod][carseq2num[(int )s]] = (Flag )1;
          }
        }
      }
#line 206
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 209
    if ((int )*j == 10) {
#line 210
      *j = (Symbole )'\000';
    }
    {
#line 212
    tmp___12 = strlen((char const   *)(line));
#line 212
    tmp___13 = malloc((tmp___12 + 4UL) * sizeof(char ));
#line 212
    tmp___11 = (char *)tmp___13;
#line 212
    nummod2str[nbSymbMod] = tmp___11;
    }
#line 212
    if (! tmp___11) {
      {
#line 214
      fatalError((char *)"chargeAlphabet: cannot allocate \'nummod2str[i]\'\n");
      }
    }
    {
#line 215
    strcpy((char */* __restrict  */)nummod2str[nbSymbMod], (char const   */* __restrict  */)(line));
#line 217
    nbSymbMod ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 219
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Models alphabet\'s size: %d\n",
          nbSymbMod);
#line 222
  numSAUT = nbSymbMod;
#line 223
  tmp___16 = malloc(2UL * sizeof(char ));
#line 223
  tmp___15 = (char *)tmp___16;
#line 223
  nummod2str[numSAUT] = tmp___15;
  }
#line 223
  if (! tmp___15) {
    {
#line 225
    fatalError((char *)"chargeAlphabet: cannot allocate \'nummod2str[i]\'\n");
    }
  }
#line 226
  *(nummod2str[nbSymbMod] + 0) = (char )'_';
#line 227
  *(nummod2str[nbSymbMod] + 1) = (char )'\000';
#line 237
  i = 0;
  {
#line 237
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 237
    if (! (i != nbSymbSeq)) {
#line 237
      goto while_break___6;
    }
#line 239
    s = (char)0;
#line 240
    k = 0;
    {
#line 240
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 240
      if (! (k != nbSymbMod)) {
#line 240
        goto while_break___7;
      }
#line 241
      s = (char )((int )s | (int )TabSymb[k][i]);
#line 240
      k ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 243
    if (! s) {
      {
#line 244
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"> Warning: text symbol \'%c\' is not recognized by any models symbol.\n",
              (int )alphSeq[i]);
      }
    }
#line 237
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 248
  return (alphSeq);
}
}
#line 255 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS/Spell/src/alphabet.c"
int str2nummod(char *str ) 
{ 
  int i ;
  int tmp ;

  {
#line 259
  i = 0;
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
#line 259
    if (! (i != nbSymbMod)) {
#line 259
      goto while_break;
    }
    {
#line 260
    tmp = strcmp((char const   *)nummod2str[i], (char const   *)str);
    }
#line 260
    if (! tmp) {
#line 261
      return (i);
    }
#line 259
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 263
  return (-1);
}
}
#line 290 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS/Spell/src/alphabet.c"
void transAlphMod(Flag pal ) 
{ 
  int i ;
  int j ;
  char tmp[512] ;
  Flag tmp___0 ;
  Flag tmp___1 ;
  Flag tmp___2 ;
  Flag tmp___3 ;
  Flag tmp___4 ;
  Flag tmp___5 ;
  Flag tmp___6 ;
  Flag tmp___7 ;
  Flag tmp___8 ;
  Flag tmp___9 ;
  Flag tmp___10 ;
  Flag tmp___11 ;
  Flag tmp___12 ;
  Flag tmp___13 ;
  Flag tmp___14 ;
  Flag tmp___15 ;
  Flag tmp___16 ;
  Flag tmp___17 ;
  Flag tmp___18 ;
  Flag tmp___19 ;
  int tmp___20 ;

  {
#line 295
  i = 0;
  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 295
    if (! (i != nbSymbMod)) {
#line 295
      goto while_break;
    }
#line 297
    if ((unsigned int )type == 0U) {
      {
#line 299
      tmp___17 = strshfl(nummod2str[i], (char *)"AR");
      }
#line 299
      if (tmp___17) {
        {
#line 301
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Symbol %s ->> A\n",
                nummod2str[i]);
#line 302
        sprintf((char */* __restrict  */)nummod2str[i], (char const   */* __restrict  */)"A");
        }
      } else {
        {
#line 299
        tmp___18 = strshfl(nummod2str[i], (char *)"AN");
        }
#line 299
        if (tmp___18) {
          {
#line 301
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Symbol %s ->> A\n",
                  nummod2str[i]);
#line 302
          sprintf((char */* __restrict  */)nummod2str[i], (char const   */* __restrict  */)"A");
          }
        } else {
          {
#line 299
          tmp___19 = strshfl(nummod2str[i], (char *)"ARN");
          }
#line 299
          if (tmp___19) {
            {
#line 301
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Symbol %s ->> A\n",
                    nummod2str[i]);
#line 302
            sprintf((char */* __restrict  */)nummod2str[i], (char const   */* __restrict  */)"A");
            }
          } else {
            {
#line 304
            tmp___14 = strshfl(nummod2str[i], (char *)"CY");
            }
#line 304
            if (tmp___14) {
              {
#line 306
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Symbol %s ->> C\n",
                      nummod2str[i]);
#line 307
              sprintf((char */* __restrict  */)nummod2str[i], (char const   */* __restrict  */)"C");
              }
            } else {
              {
#line 304
              tmp___15 = strshfl(nummod2str[i], (char *)"CN");
              }
#line 304
              if (tmp___15) {
                {
#line 306
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Symbol %s ->> C\n",
                        nummod2str[i]);
#line 307
                sprintf((char */* __restrict  */)nummod2str[i], (char const   */* __restrict  */)"C");
                }
              } else {
                {
#line 304
                tmp___16 = strshfl(nummod2str[i], (char *)"CYN");
                }
#line 304
                if (tmp___16) {
                  {
#line 306
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Symbol %s ->> C\n",
                          nummod2str[i]);
#line 307
                  sprintf((char */* __restrict  */)nummod2str[i], (char const   */* __restrict  */)"C");
                  }
                } else {
                  {
#line 309
                  tmp___11 = strshfl(nummod2str[i], (char *)"GR");
                  }
#line 309
                  if (tmp___11) {
                    {
#line 311
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Symbol %s ->> G\n",
                            nummod2str[i]);
#line 312
                    sprintf((char */* __restrict  */)nummod2str[i], (char const   */* __restrict  */)"G");
                    }
                  } else {
                    {
#line 309
                    tmp___12 = strshfl(nummod2str[i], (char *)"GN");
                    }
#line 309
                    if (tmp___12) {
                      {
#line 311
                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Symbol %s ->> G\n",
                              nummod2str[i]);
#line 312
                      sprintf((char */* __restrict  */)nummod2str[i], (char const   */* __restrict  */)"G");
                      }
                    } else {
                      {
#line 309
                      tmp___13 = strshfl(nummod2str[i], (char *)"GRN");
                      }
#line 309
                      if (tmp___13) {
                        {
#line 311
                        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Symbol %s ->> G\n",
                                nummod2str[i]);
#line 312
                        sprintf((char */* __restrict  */)nummod2str[i], (char const   */* __restrict  */)"G");
                        }
                      } else {
                        {
#line 314
                        tmp___8 = strshfl(nummod2str[i], (char *)"TY");
                        }
#line 314
                        if (tmp___8) {
                          {
#line 316
                          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Symbol %s ->> T\n",
                                  nummod2str[i]);
#line 317
                          sprintf((char */* __restrict  */)nummod2str[i], (char const   */* __restrict  */)"T");
                          }
                        } else {
                          {
#line 314
                          tmp___9 = strshfl(nummod2str[i], (char *)"TN");
                          }
#line 314
                          if (tmp___9) {
                            {
#line 316
                            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Symbol %s ->> T\n",
                                    nummod2str[i]);
#line 317
                            sprintf((char */* __restrict  */)nummod2str[i], (char const   */* __restrict  */)"T");
                            }
                          } else {
                            {
#line 314
                            tmp___10 = strshfl(nummod2str[i], (char *)"TYN");
                            }
#line 314
                            if (tmp___10) {
                              {
#line 316
                              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Symbol %s ->> T\n",
                                      nummod2str[i]);
#line 317
                              sprintf((char */* __restrict  */)nummod2str[i], (char const   */* __restrict  */)"T");
                              }
                            } else {
                              {
#line 319
                              tmp___4 = strshfl(nummod2str[i], (char *)"AG");
                              }
#line 319
                              if (tmp___4) {
                                {
#line 321
                                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Symbol %s ->> R\n",
                                        nummod2str[i]);
#line 322
                                sprintf((char */* __restrict  */)nummod2str[i], (char const   */* __restrict  */)"R");
                                }
                              } else {
                                {
#line 319
                                tmp___5 = strshfl(nummod2str[i], (char *)"AGR");
                                }
#line 319
                                if (tmp___5) {
                                  {
#line 321
                                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Symbol %s ->> R\n",
                                          nummod2str[i]);
#line 322
                                  sprintf((char */* __restrict  */)nummod2str[i],
                                          (char const   */* __restrict  */)"R");
                                  }
                                } else {
                                  {
#line 319
                                  tmp___6 = strshfl(nummod2str[i], (char *)"AGN");
                                  }
#line 319
                                  if (tmp___6) {
                                    {
#line 321
                                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Symbol %s ->> R\n",
                                            nummod2str[i]);
#line 322
                                    sprintf((char */* __restrict  */)nummod2str[i],
                                            (char const   */* __restrict  */)"R");
                                    }
                                  } else {
                                    {
#line 319
                                    tmp___7 = strshfl(nummod2str[i], (char *)"AGRN");
                                    }
#line 319
                                    if (tmp___7) {
                                      {
#line 321
                                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Symbol %s ->> R\n",
                                              nummod2str[i]);
#line 322
                                      sprintf((char */* __restrict  */)nummod2str[i],
                                              (char const   */* __restrict  */)"R");
                                      }
                                    } else {
                                      {
#line 324
                                      tmp___0 = strshfl(nummod2str[i], (char *)"CT");
                                      }
#line 324
                                      if (tmp___0) {
                                        {
#line 326
                                        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Symbol %s ->> Y\n",
                                                nummod2str[i]);
#line 327
                                        sprintf((char */* __restrict  */)nummod2str[i],
                                                (char const   */* __restrict  */)"Y");
                                        }
                                      } else {
                                        {
#line 324
                                        tmp___1 = strshfl(nummod2str[i], (char *)"CTY");
                                        }
#line 324
                                        if (tmp___1) {
                                          {
#line 326
                                          fprintf((FILE */* __restrict  */)stderr,
                                                  (char const   */* __restrict  */)"Symbol %s ->> Y\n",
                                                  nummod2str[i]);
#line 327
                                          sprintf((char */* __restrict  */)nummod2str[i],
                                                  (char const   */* __restrict  */)"Y");
                                          }
                                        } else {
                                          {
#line 324
                                          tmp___2 = strshfl(nummod2str[i], (char *)"CTN");
                                          }
#line 324
                                          if (tmp___2) {
                                            {
#line 326
                                            fprintf((FILE */* __restrict  */)stderr,
                                                    (char const   */* __restrict  */)"Symbol %s ->> Y\n",
                                                    nummod2str[i]);
#line 327
                                            sprintf((char */* __restrict  */)nummod2str[i],
                                                    (char const   */* __restrict  */)"Y");
                                            }
                                          } else {
                                            {
#line 324
                                            tmp___3 = strshfl(nummod2str[i], (char *)"CTYN");
                                            }
#line 324
                                            if (tmp___3) {
                                              {
#line 326
                                              fprintf((FILE */* __restrict  */)stderr,
                                                      (char const   */* __restrict  */)"Symbol %s ->> Y\n",
                                                      nummod2str[i]);
#line 327
                                              sprintf((char */* __restrict  */)nummod2str[i],
                                                      (char const   */* __restrict  */)"Y");
                                              }
                                            } else
#line 329
                                            if ((int )*(nummod2str[i] + 1) == 0) {
#line 331
                                              if ((int )*(nummod2str[i] + 0) == 42) {
                                                {
#line 333
                                                fprintf((FILE */* __restrict  */)stderr,
                                                        (char const   */* __restrict  */)"Symbol \'%c\' ->> N\n",
                                                        '*');
#line 334
                                                sprintf((char */* __restrict  */)nummod2str[i],
                                                        (char const   */* __restrict  */)"N");
                                                }
                                              }
                                            } else {
                                              {
#line 339
                                              strcpy((char */* __restrict  */)(tmp),
                                                     (char const   */* __restrict  */)nummod2str[i]);
#line 340
                                              sprintf((char */* __restrict  */)nummod2str[i],
                                                      (char const   */* __restrict  */)"[%s]",
                                                      tmp);
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else
#line 343
    if ((unsigned int )type == 1U) {
#line 345
      if ((int )*(nummod2str[i] + 1) == 0) {
#line 347
        if ((int )*(nummod2str[i] + 0) == 42) {
          {
#line 349
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Symbol \'%c\' ->> X\n",
                  '*');
#line 350
          sprintf((char */* __restrict  */)nummod2str[i], (char const   */* __restrict  */)"X");
          }
        }
      } else {
        {
#line 355
        strcpy((char */* __restrict  */)(tmp), (char const   */* __restrict  */)nummod2str[i]);
#line 356
        sprintf((char */* __restrict  */)nummod2str[i], (char const   */* __restrict  */)"[%s]",
                tmp);
        }
      }
    } else
#line 361
    if ((int )*(nummod2str[i] + 1) == 0) {
#line 363
      if ((int )*(nummod2str[i] + 0) == 42) {
        {
#line 365
        strcpy((char */* __restrict  */)(tmp), (char const   */* __restrict  */)nummod2str[i]);
#line 366
        sprintf((char */* __restrict  */)nummod2str[i], (char const   */* __restrict  */)"[%s]",
                tmp);
        }
      }
    }
#line 372
    j = 0;
    {
#line 372
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 372
      if (! (j != i)) {
#line 372
        goto while_break___0;
      }
      {
#line 373
      tmp___20 = strcmp((char const   *)nummod2str[j], (char const   *)nummod2str[i]);
      }
#line 373
      if (! tmp___20) {
        {
#line 375
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> Error: possible confusion between symbols %s and %s of the alphabet.\nModify the alphabet to avoid conflict.\n",
                alphMod[i], alphMod[j]);
#line 377
        exit(1);
        }
      }
#line 372
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 295
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 382
  if (pal) {
#line 384
    if ((unsigned int )type != 0U) {
      {
#line 386
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> Error: palindroms can only be used with a nucleotide alphabet\n");
#line 387
      exit(1);
      }
    }
#line 390
    i = 0;
    {
#line 390
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 390
      if (! (i != nbSymbMod)) {
#line 390
        goto while_break___1;
      }
#line 391
      comp[i] = -1;
#line 390
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 394
    chercheComp((char *)"A", (char *)"T");
#line 395
    chercheComp((char *)"C", (char *)"G");
#line 396
    chercheComp((char *)"R", (char *)"Y");
    }
#line 401
    if (numJOKER != -1) {
#line 402
      comp[numJOKER] = numJOKER;
    }
#line 406
    i = 0;
    {
#line 406
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 406
      if (! (i != nbSymbMod)) {
#line 406
        goto while_break___2;
      }
#line 408
      if (comp[i] == -1) {
        {
#line 410
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> Error: some symbols of the models alphabet misses their complemtentary symbol, cannot use the palindromic option\n");
#line 411
        exit(1);
        }
      }
#line 406
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 415
  return;
}
}
#line 418 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS/Spell/src/alphabet.c"
void chercheComp(char *s1 , char *s2 ) 
{ 
  int i ;
  int j ;
  int tmp ;
  int tmp___0 ;

  {
#line 423
  i = 0;
  {
#line 423
  while (1) {
    while_continue: /* CIL Label */ ;
#line 423
    if (! (i != nbSymbMod)) {
#line 423
      goto while_break;
    }
    {
#line 424
    tmp = strcmp((char const   *)nummod2str[i], (char const   *)s1);
    }
#line 424
    if (! tmp) {
#line 425
      goto while_break;
    }
#line 423
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 427
  j = 0;
  {
#line 427
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 427
    if (! (j != nbSymbMod)) {
#line 427
      goto while_break___0;
    }
    {
#line 428
    tmp___0 = strcmp((char const   *)nummod2str[j], (char const   *)s2);
    }
#line 428
    if (! tmp___0) {
#line 429
      goto while_break___0;
    }
#line 427
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 432
  if (i != nbSymbMod) {
#line 432
    if (j != nbSymbMod) {
#line 434
      comp[i] = j;
#line 435
      comp[j] = i;
    } else {
#line 432
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 438
  if (i == nbSymbMod) {
#line 438
    if (j != nbSymbMod) {
      {
#line 440
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> Error: the models alphabet misses some symbols to be used with the palindromic option (\'%s\' and \'%s\' must appear together)\n",
              s1, s2);
#line 441
      exit(1);
      }
    } else {
#line 438
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 438
  if (i != nbSymbMod) {
#line 438
    if (j == nbSymbMod) {
      {
#line 440
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> Error: the models alphabet misses some symbols to be used with the palindromic option (\'%s\' and \'%s\' must appear together)\n",
              s1, s2);
#line 441
      exit(1);
      }
    }
  }
#line 444
  return;
}
}
#line 63 "Spell/include/criteres.h"
void setCompoPal(P_Criteres___0 cr , char **argv , int argc ) ;
#line 25 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS/Spell/src/criteres.c"
int **code2Sauts  ;
#line 37 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS/Spell/src/criteres.c"
void setCompoPal(P_Criteres___0 cr , char **argv , int argc ) 
{ 
  int i ;
  int j ;
  int bloc ;
  int nbsymb ;
  int *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 41
  tmp___0 = malloc((unsigned long )nbSymbMod * sizeof(int ));
#line 41
  tmp = (int *)tmp___0;
#line 41
  cr->compo = tmp;
  }
#line 41
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 42
    fatalError((char *)"initCriteres: cannot allocate \'cr->compo\'\n");
    }
  }
#line 44
  i = 0;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! (i < (int )cr->bloc)) {
#line 44
      goto while_break;
    }
    {
#line 46
    tmp___1 = malloc((unsigned long )nbSymbMod * sizeof(int ));
#line 46
    *(cr->compobloc + i) = (int *)tmp___1;
    }
#line 47
    if (! *(cr->compobloc + i)) {
      {
#line 48
      fatalError((char *)"setCompoPal: cannot allocate \'cr->compobloc[i]\'\n");
      }
    }
#line 44
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  cr->flag_compo = (Flag )0;
#line 53
  i = 0;
  {
#line 53
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 53
    if (! (i != nbSymbMod)) {
#line 53
      goto while_break___0;
    }
#line 54
    *(cr->compo + i) = -1;
#line 53
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 55
  i = 0;
  {
#line 55
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 55
    if (! (i != (int )cr->bloc)) {
#line 55
      goto while_break___1;
    }
#line 57
    *(cr->flag_compobloc + i) = (Flag )0;
#line 58
    j = 0;
    {
#line 58
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 58
      if (! (j != nbSymbMod)) {
#line 58
        goto while_break___2;
      }
#line 59
      *(*(cr->compobloc + i) + j) = -1;
#line 58
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 55
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 63
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 63
    if (argc > 0) {
#line 63
      if (! ((int )*(*argv) != 112)) {
#line 63
        goto while_break___3;
      }
    } else {
#line 63
      goto while_break___3;
    }
    {
#line 65
    bloc = atoi((char const   *)*argv);
#line 66
    argc --;
#line 66
    argv ++;
#line 67
    nbsymb = atoi((char const   *)*argv);
#line 68
    argc --;
#line 68
    argv ++;
#line 70
    i = 0;
    }
    {
#line 70
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 70
      if (! (i != nbsymb)) {
#line 70
        goto while_break___4;
      }
      {
#line 72
      j = str2nummod(*argv);
#line 73
      argc --;
#line 73
      argv ++;
      }
#line 75
      if (j == -1) {
        {
#line 77
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"> Warning: composition in \'%s\' ignored, symbol is not in the models alphabet.\n",
                *(argv - 1));
#line 80
        argc --;
#line 80
        argv ++;
        }
#line 81
        goto __Cont;
      }
#line 84
      if (bloc == 0) {
        {
#line 86
        cr->flag_compo = (Flag )1;
#line 87
        *(cr->compo + j) = atoi((char const   *)*argv);
        }
      } else {
        {
#line 92
        *(cr->flag_compobloc + (bloc - 1)) = (Flag )1;
#line 93
        *(*(cr->compobloc + (bloc - 1)) + j) = atoi((char const   *)*argv);
        }
      }
#line 97
      argc --;
#line 97
      argv ++;
      __Cont: /* CIL Label */ 
#line 70
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 102
  if (argc == 0) {
#line 103
    return;
  }
#line 105
  cr->flag_palindrom = (Flag )1;
  {
#line 107
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 107
    if (! (argc > 0)) {
#line 107
      goto while_break___5;
    }
    {
#line 109
    sscanf((char const   */* __restrict  */)*argv, (char const   */* __restrict  */)"p%d/%d",
           & i, & j);
#line 110
    *(cr->palindrom + (i - 1)) = j - 1;
#line 111
    argc --;
#line 112
    argv ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 114
  return;
}
}
#line 41 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS/Spell/src/barre.c"
static int pos___1  =    0;
#line 42 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS/Spell/src/barre.c"
static int max___1  =    0;
#line 43 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS/Spell/src/barre.c"
static int lastecrit___1  =    0;
#line 44 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS/Spell/src/barre.c"
static time_t start___1  ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 144 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 50 "Spell/include/spell.h"
void doSpell(P_Criteres___0 cr , int nbseq , Noeud *root ) ;
#line 43 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS/Spell/src/spell.c"
Flag spellModels(P_PileOcc pocc___1 , P_PileOcc poccnew , P_PileOcc poccsaut , int longmod ,
                 int longcurbloc , int curbloc , Flag multiblocs , P_mod model___1 ,
                 P_occ next___1 , Bit_Tab **colors_model___1 , int nbseq , int tmp_quorum ,
                 P_Criteres___0 cr , int *longbloc , int *posdebbloc ) ;
#line 57
static float PrintCpuTime(char flag___1 ) ;
#line 64 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS/Spell/src/spell.c"
int nbmod  =    0;
#line 65 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS/Spell/src/spell.c"
int maxlongmod  =    0;
#line 65 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS/Spell/src/spell.c"
int *maxlongbloc  =    (int *)((void *)0);
#line 66 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS/Spell/src/spell.c"
signed char **text  =    (signed char **)((void *)0);
#line 67 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS/Spell/src/spell.c"
FILE *f  =    (FILE *)((void *)0);
#line 551 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS/Spell/src/spell.c"
Flag spellModels(P_PileOcc pocc___1 , P_PileOcc poccnew , P_PileOcc poccsaut , int longmod ,
                 int longcurbloc , int curbloc , Flag multiblocs , P_mod model___1 ,
                 P_occ next___1 , Bit_Tab **colors_model___1 , int nbseq , int tmp_quorum ,
                 P_Criteres___0 cr , int *longbloc , int *posdebbloc ) 
{ 
  Flag zarb_back ;
  Flag zarb_ext ;
  char carseq ;
  int lmaxbr ;
  int pos___3 ;
  int precdummy ;
  int palbloc ;
  long maxseq ;
  P_occ tmpocc ;
  int tmpint ;
  int nbnewmod ;
  int nbocc ;
  int symbol ;
  int trans ;
  int tmp_quorum2 ;
  int tmp ;
  int tmp___0 ;
  Flag tmp___1 ;
  int tmp___2 ;
  Flag tmp___3 ;
  Flag tmp___4 ;
  int tmp___5 ;
  Flag tmp___6 ;
  int tmp___7 ;

  {
#line 560
  zarb_back = (Flag )0;
#line 560
  zarb_ext = (Flag )0;
#line 569
  nbnewmod = 0;
#line 576
  if (longmod == 3) {
    {
#line 577
    barre(0);
    }
  }
#line 580
  if (cr->longueur.max == 0) {
#line 580
    goto _L___8;
  } else
#line 580
  if (longmod < cr->longueur.max) {
    _L___8: /* CIL Label */ 
#line 580
    if ((int )multiblocs == 0) {
#line 580
      goto _L___7;
    } else
#line 580
    if ((cr->longbloc + curbloc)->max == 0) {
#line 580
      goto _L___7;
    } else
#line 580
    if (longcurbloc < (cr->longbloc + curbloc)->max) {
      _L___7: /* CIL Label */ 
#line 580
      if ((int )cr->flag_palindrom == 0) {
#line 580
        goto _L___4;
      } else
#line 580
      if (*(cr->palindrom + curbloc) == -1) {
#line 580
        goto _L___4;
      } else
#line 580
      if (longcurbloc != *(longbloc + *(cr->palindrom + curbloc))) {
        _L___4: /* CIL Label */ 
#line 599
        symbol = 0;
        {
#line 599
        while (1) {
          while_continue: /* CIL Label */ ;
#line 599
          if (! (symbol != nbSymbMod)) {
#line 599
            goto while_break;
          }
#line 606
          if (longmod == 0) {
#line 606
            if (symbol == numJOKER) {
#line 607
              goto __Cont;
            }
          }
#line 610
          if ((int )cr->flag_compo == 1) {
#line 610
            goto _L;
          } else
#line 610
          if ((int )*(cr->flag_compobloc + curbloc) == 1) {
            _L: /* CIL Label */ 
#line 612
            if (*(*(cr->compobloc + curbloc) + symbol) == 0) {
#line 614
              goto __Cont;
            } else
#line 612
            if (*(cr->compo + symbol) == 0) {
#line 614
              goto __Cont;
            }
          }
#line 618
          if (cr->flag_palindrom) {
#line 620
            if (longcurbloc == 0) {
#line 621
              *(posdebbloc + curbloc) = model___1->lon;
            }
#line 623
            if (*(cr->palindrom + curbloc) != -1) {
#line 625
              palbloc = *(cr->palindrom + curbloc);
#line 627
              if (symbol != comp[*(model___1->name + (((*(posdebbloc + palbloc) + *(longbloc + palbloc)) - 1) - longcurbloc))]) {
#line 629
                goto __Cont;
              }
            }
          }
          {
#line 634
          pos___3 = pocc___1->pos - 1;
#line 635
          tmpocc = pocc___1->occ + pos___3;
#line 636
          precdummy = getPrecDummy(pocc___1);
#line 637
          videPile(poccnew);
#line 638
          maxseq = 0L;
#line 639
          nbocc = 0;
          }
          {
#line 645
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 645
            if (pos___3 != precdummy) {
#line 645
              if (! ((unsigned long )tmpocc->x != (unsigned long )((void *)0))) {
#line 645
                goto while_break___0;
              }
            } else {
#line 645
              goto while_break___0;
            }
#line 647
            if ((unsigned int )(*((tmpocc->x)->fils + tmpocc->num))->debut & 2147483648U) {
              {
#line 647
              tmp = getValue(Liste_positions_fin, ((Feuille *)*((tmpocc->x)->fils + tmpocc->num))->fin_deb);
#line 647
              lmaxbr = tmp - ((*((tmpocc->x)->fils + tmpocc->num))->debut & 2147483647);
              }
            } else {
#line 647
              lmaxbr = (*((tmpocc->x)->fils + tmpocc->num))->fin - (*((tmpocc->x)->fils + tmpocc->num))->debut;
            }
#line 666
            if (tmpocc->lon != lmaxbr) {
#line 668
              carseq = (char )*(*(text + (*((tmpocc->x)->fils + tmpocc->num))->sequence_number) + (((*((tmpocc->x)->fils + tmpocc->num))->debut & 2147483647) + tmpocc->lon));
#line 672
              if ((int )carseq != 36) {
                {
#line 672
                tmp___1 = avanceBranche(next___1, tmpocc, symbol, carseq2num[(int )carseq],
                                        (Flag )0, cr, curbloc, multiblocs);
                }
#line 672
                if (tmp___1) {
                  {
#line 677
                  ajouteOcc2Pile(poccnew, next___1->x, next___1->num, next___1->lon,
                                 next___1->xerr, next___1->blocerr, next___1->saut,
                                 next___1->codesaut);
#line 686
                  nbocc ++;
                  }
#line 688
                  if ((unsigned int )(*((next___1->x)->fils + next___1->num))->debut & 2147483648U) {
                    {
#line 690
                    tmp___0 = nbSequenceInBitTab(((Feuille *)*((next___1->x)->fils + next___1->num))->sequences);
#line 690
                    maxseq += (long )tmp___0;
                    }
                  } else {
#line 700
                    maxseq += (long )(*((next___1->x)->fils + next___1->num))->nb_element_bt;
                  }
                }
              }
            } else {
#line 712
              trans = 0;
              {
#line 712
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 712
                if (! (trans != nbSymbSeq)) {
#line 712
                  goto while_break___1;
                }
                {
#line 714
                tmpocc = pocc___1->occ + pos___3;
#line 715
                tmp___3 = avanceBranche(next___1, tmpocc, symbol, trans, (Flag )1,
                                        cr, curbloc, multiblocs);
                }
#line 715
                if (tmp___3) {
                  {
#line 718
                  ajouteOcc2Pile(poccnew, next___1->x, next___1->num, next___1->lon,
                                 next___1->xerr, next___1->blocerr, next___1->saut,
                                 next___1->codesaut);
#line 728
                  nbocc ++;
                  }
#line 729
                  if ((unsigned int )(*((next___1->x)->fils + next___1->num))->debut & 2147483648U) {
                    {
#line 731
                    tmp___2 = nbSequenceInBitTab(((Feuille *)*((next___1->x)->fils + next___1->num))->sequences);
#line 731
                    maxseq += (long )tmp___2;
                    }
                  } else {
#line 741
                    maxseq += (long )(*((next___1->x)->fils + next___1->num))->nb_element_bt;
                  }
                }
#line 712
                trans ++;
              }
              while_break___1: /* CIL Label */ ;
              }
            }
#line 753
            if (pos___3 == 0) {
#line 758
              goto while_break___0;
            }
#line 761
            pos___3 --;
#line 762
            tmpocc = pocc___1->occ + pos___3;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 781
          if (nbocc == 0) {
#line 782
            goto __Cont;
          }
#line 787
          tmp_quorum2 = -1;
#line 789
          if (multiblocs) {
#line 789
            if (curbloc != (int )cr->bloc - 1) {
#line 789
              if (longcurbloc + 1 >= (cr->longbloc + curbloc)->min) {
#line 789
                if (maxseq >= (long )cr->quorum) {
                  {
#line 789
                  tmp_quorum2 = sommeBTOcc(poccnew, colors_model___1);
                  }
#line 789
                  if (tmp_quorum2 >= cr->quorum) {
                    {
#line 789
                    tmp___5 = gestionSaut(model___1, pocc___1, poccnew, cr, curbloc);
                    }
#line 789
                    if (tmp___5 != 0) {
                      {
#line 797
                      changeModel(model___1, symbol);
#line 798
                      changeModel(model___1, numSAUT);
#line 800
                      ajouteDummy(poccsaut);
#line 802
                      tmpint = copieLastOcc(poccsaut, poccnew);
#line 807
                      videPile(poccnew);
#line 808
                      zarb_ext = (Flag )1;
                      }
#line 810
                      if ((int )cr->flag_compo == 1) {
#line 812
                        (*(cr->compo + symbol)) --;
#line 813
                        (*(*(cr->compobloc + curbloc) + symbol)) --;
                      } else
#line 810
                      if ((int )*(cr->flag_compobloc + curbloc) == 1) {
#line 812
                        (*(cr->compo + symbol)) --;
#line 813
                        (*(*(cr->compobloc + curbloc) + symbol)) --;
                      }
#line 816
                      if (multiblocs) {
#line 817
                        *(longbloc + curbloc) = longcurbloc + 1;
                      }
                      {
#line 819
                      tmp___4 = spellModels(pocc___1, poccnew, poccsaut, longmod + 1,
                                            0, curbloc + 1, multiblocs, model___1,
                                            next___1, colors_model___1, nbseq, tmp_quorum2,
                                            cr, longbloc, posdebbloc);
#line 819
                      zarb_back = (Flag )((int )zarb_back + (int )tmp___4);
                      }
#line 825
                      if ((int )cr->flag_compo == 1) {
#line 827
                        (*(cr->compo + symbol)) ++;
#line 828
                        (*(*(cr->compobloc + curbloc) + symbol)) ++;
                      } else
#line 825
                      if ((int )*(cr->flag_compobloc + curbloc) == 1) {
#line 827
                        (*(cr->compo + symbol)) ++;
#line 828
                        (*(*(cr->compobloc + curbloc) + symbol)) ++;
                      }
                      {
#line 831
                      decrModel(model___1);
#line 832
                      decrModel(model___1);
#line 834
                      videPile(poccnew);
#line 835
                      tmpint = copieLastOcc(poccnew, poccsaut);
#line 840
                      depileRec(poccsaut);
#line 841
                      depileRec(pocc___1);
                      }
                    }
                  }
                }
              }
            }
          }
#line 857
          if (maxseq >= (long )cr->quorum) {
#line 857
            if (tmp_quorum2 != -1) {
#line 857
              tmp___7 = tmp_quorum2 >= cr->quorum;
            } else {
              {
#line 857
              tmp_quorum2 = sommeBTOcc(poccnew, colors_model___1);
#line 857
              tmp___7 = tmp_quorum2 >= cr->quorum;
              }
            }
#line 857
            if (tmp___7) {
#line 864
              if (symbol == numJOKER) {
#line 865
                zarb_ext = (Flag )1;
              } else {
#line 867
                nbnewmod ++;
              }
              {
#line 869
              changeModel(model___1, symbol);
#line 871
              ajouteDummy(pocc___1);
#line 873
              transferePile2Pile(pocc___1, poccnew);
              }
#line 875
              if ((int )cr->flag_compo == 1) {
#line 877
                (*(cr->compo + symbol)) --;
#line 878
                (*(*(cr->compobloc + curbloc) + symbol)) --;
              } else
#line 875
              if ((int )*(cr->flag_compobloc + curbloc) == 1) {
#line 877
                (*(cr->compo + symbol)) --;
#line 878
                (*(*(cr->compobloc + curbloc) + symbol)) --;
              }
              {
#line 881
              tmp___6 = spellModels(pocc___1, poccnew, poccsaut, longmod + 1, longcurbloc + 1,
                                    curbloc, multiblocs, model___1, next___1, colors_model___1,
                                    nbseq, tmp_quorum2, cr, longbloc, posdebbloc);
#line 881
              zarb_back = (Flag )((int )zarb_back + (int )tmp___6);
              }
#line 886
              if ((int )cr->flag_compo == 1) {
#line 888
                (*(cr->compo + symbol)) ++;
#line 889
                (*(*(cr->compobloc + curbloc) + symbol)) ++;
              } else
#line 886
              if ((int )*(cr->flag_compobloc + curbloc) == 1) {
#line 888
                (*(cr->compo + symbol)) ++;
#line 889
                (*(*(cr->compobloc + curbloc) + symbol)) ++;
              }
              {
#line 892
              depileRec(pocc___1);
#line 895
              decrModel(model___1);
              }
            }
          }
          __Cont: /* CIL Label */ 
#line 599
          symbol ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 909
        if (curbloc == (int )cr->bloc - 1) {
#line 909
          if (longmod >= cr->longueur.min) {
#line 909
            if ((int )multiblocs == 0) {
#line 909
              goto _L___2;
            } else
#line 909
            if (longcurbloc >= (cr->longbloc + curbloc)->min) {
              _L___2: /* CIL Label */ 
#line 909
              if ((int )cr->flag_palindrom == 0) {
#line 909
                goto _L___1;
              } else
#line 909
              if (*(cr->palindrom + curbloc) == -1) {
#line 909
                goto _L___1;
              } else
#line 909
              if (longcurbloc == *(longbloc + *(cr->palindrom + curbloc))) {
                _L___1: /* CIL Label */ 
#line 909
                if ((int )zarb_back != 0) {
#line 909
                  goto _L___0;
                } else
#line 909
                if ((int )zarb_ext == 0) {
                  _L___0: /* CIL Label */ 
#line 917
                  if (*(model___1->name + (model___1->lon - 1)) != numJOKER) {
#line 917
                    if (*(model___1->name + (model___1->lon - 1)) != numSAUT) {
#line 920
                      if (multiblocs) {
#line 921
                        *(longbloc + curbloc) = longcurbloc;
                      }
                      {
#line 923
                      keepModel(model___1, pocc___1, nbseq, tmp_quorum, longmod, longbloc,
                                cr);
                      }
#line 924
                      return ((Flag )0);
                    } else {
#line 927
                      return ((Flag )1);
                    }
                  } else {
#line 927
                    return ((Flag )1);
                  }
                }
              }
            }
          }
        }
      } else {
#line 580
        goto _L___5;
      }
    } else {
#line 580
      goto _L___5;
    }
  } else
  _L___5: /* CIL Label */ 
#line 930
  if (curbloc == (int )cr->bloc - 1) {
#line 936
    if (*(model___1->name + (model___1->lon - 1)) != numJOKER) {
#line 936
      if (*(model___1->name + (model___1->lon - 1)) != numSAUT) {
#line 939
        if (multiblocs) {
#line 940
          *(longbloc + curbloc) = longcurbloc;
        }
        {
#line 942
        keepModel(model___1, pocc___1, nbseq, tmp_quorum, longmod, longbloc, cr);
        }
#line 943
        return ((Flag )0);
      } else {
#line 946
        return ((Flag )1);
      }
    } else {
#line 946
      return ((Flag )1);
    }
  }
#line 948
  return ((Flag )0);
}
}
#line 957 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS/Spell/src/spell.c"
void doSpell(P_Criteres___0 cr , int nbseq , Noeud *root ) 
{ 
  P_mod model___1 ;
  P_PileOcc pocc___1 ;
  P_PileOcc poccnew ;
  P_PileOcc poccsaut ;
  P_occ next___1 ;
  Bit_Tab *colors_model___1 ;
  Flag multiblocs ;
  Noeud *root_pere ;
  int *longbloc ;
  int *posdebbloc ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  double tmp___2 ;

  {
  {
#line 961
  poccsaut = (P_PileOcc )((void *)0);
#line 966
  longbloc = (int *)((void *)0);
#line 967
  posdebbloc = (int *)((void *)0);
#line 971
  root_pere = Alloc_Noeud();
#line 972
  *(root_pere->fils + Translation_Table['$']) = root;
#line 973
  root_pere->sequence_number = 0;
#line 974
  root->debut = 0;
#line 975
  root->fin = 1;
#line 976
  root->sequence_number = 0;
  }
#line 978
  if ((int )cr->bloc == 1) {
#line 979
    multiblocs = (Flag )0;
  } else {
#line 981
    multiblocs = (Flag )1;
  }
  {
#line 984
  model___1 = allocModel();
#line 987
  tmp = calloc((size_t )1, sizeof(Occ ));
#line 987
  next___1 = (P_occ )tmp;
  }
#line 988
  if ((unsigned long )next___1 == (unsigned long )((void *)0)) {
    {
#line 989
    fatalError((char *)"doSpell: cannot allocate \'next\'\n");
    }
  }
  {
#line 990
  initOcc(next___1);
#line 993
  colors_model___1 = AllocBitTab();
#line 994
  ReinitBitTab(& colors_model___1);
  }
#line 998
  if ((int )multiblocs == 1) {
    {
#line 1000
    poccsaut = creePileOcc();
#line 1001
    tmp___0 = malloc((unsigned long )cr->bloc * sizeof(int ));
#line 1001
    longbloc = (int *)tmp___0;
    }
#line 1002
    if ((unsigned long )longbloc == (unsigned long )((void *)0)) {
      {
#line 1003
      fatalError((char *)"doSpell: cannot allocate \'longbloc\'\n");
      }
    }
#line 1005
    if (cr->flag_palindrom) {
      {
#line 1007
      tmp___1 = malloc((unsigned long )cr->bloc * sizeof(int ));
#line 1007
      posdebbloc = (int *)tmp___1;
      }
#line 1008
      if ((unsigned long )posdebbloc == (unsigned long )((void *)0)) {
        {
#line 1009
        fatalError((char *)"doSpell: cannot allocate \'posdebbloc\'\n");
        }
      }
    }
  }
  {
#line 1013
  poccnew = creePileOcc();
#line 1014
  pocc___1 = creePileOcc();
#line 1017
  ajouteInitOcc2Pile(pocc___1, root_pere);
#line 1019
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"** Models extraction **\n");
#line 1020
  tmp___2 = pow((double )nbSymbMod, 3.0);
#line 1020
  barre((int )tmp___2);
#line 1023
  spellModels(pocc___1, poccnew, poccsaut, 0, 0, 0, multiblocs, model___1, next___1,
              & colors_model___1, nbseq, 0, cr, longbloc, posdebbloc);
#line 1028
  free((void *)next___1);
#line 1029
  free((void *)model___1->name);
#line 1030
  free((void *)model___1);
#line 1031
  free((void *)colors_model___1);
#line 1032
  liberePileOcc(pocc___1);
#line 1033
  liberePileOcc(poccnew);
  }
#line 1034
  if ((int )multiblocs == 1) {
    {
#line 1035
    liberePileOcc(poccsaut);
    }
  }
#line 1036
  return;
}
}
#line 1413 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS/Spell/src/spell.c"
static float dust___1  ;
#line 1409 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS/Spell/src/spell.c"
static float PrintCpuTime(char flag___1 ) 
{ 
  float ust ;
  struct tms tms ;
  long tmp ;

  {
  {
#line 1415
  times(& tms);
#line 1417
  ust = (float )tms.tms_utime;
  }
#line 1419
  if (flag___1) {
#line 1421
    dust___1 = ust;
#line 1422
    return ((float )0.0);
  } else {
    {
#line 1426
    ust -= dust___1;
#line 1427
    tmp = sysconf(2);
    }
#line 1427
    return (ust / (float )tmp);
  }
}
}
#line 60 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS/src/libfasta.c"
static char sBuffer___1[8192]  ;
#line 61
static char *sNextIOBuffer___1(FILE *streamin , Bool retain , Bool serial ) ;
#line 61 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS/src/libfasta.c"
static Bool sRetained___1  =    0;
#line 55 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS/src/libfasta.c"
static char *sNextIOBuffer___1(FILE *streamin , Bool retain , Bool serial ) 
{ 
  char *buf ;
  char *end ;
  char *tmp ;
  size_t tmp___0 ;

  {
#line 63
  if (retain) {
#line 63
    goto _L;
  } else
#line 63
  if (sRetained___1) {
    _L: /* CIL Label */ 
#line 63
    if (serial) {
#line 63
      buf = sBuffer___1;
    } else {
      {
#line 63
      tmp = fgets((char */* __restrict  */)(sBuffer___1), (int )sizeof(sBuffer___1),
                  (FILE */* __restrict  */)streamin);
#line 63
      buf = tmp;
      }
    }
  } else {
    {
#line 63
    tmp = fgets((char */* __restrict  */)(sBuffer___1), (int )sizeof(sBuffer___1),
                (FILE */* __restrict  */)streamin);
#line 63
    buf = tmp;
    }
  }
#line 67
  if (buf) {
    {
#line 68
    tmp___0 = strlen((char const   *)buf);
#line 68
    end = (buf + tmp___0) - 1;
    }
#line 69
    if ((int )*end == 10) {
#line 69
      *end = (char )'\000';
    }
  }
#line 72
  sRetained___1 = retain;
#line 74
  return (buf);
}
}
#line 124 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS/src/libfasta.c"
static char name___1[64]  ;
#line 140 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS/src/libfasta.c"
static char comment___1[512]  ;
#line 66 "Spell/include/criteres.h"
int initFiles(FILE **f___0 , char *nom , P_Criteres___1 cr ) ;
#line 68
int delta2File(int *deltatab , P_Criteres___1 cr ) ;
#line 70
int file2Delta(int pos___3 , int *deltatab , P_Criteres___1 cr ) ;
#line 30 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS+DELTA/Spell/src/criteres.c"
FILE **recInitFiles(FILE **f___0 , int bloc , P_Criteres___1 cr , char *buf , int *tab ,
                    FILE *namefile ) ;
#line 121 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS+DELTA/Spell/src/criteres.c"
int initFiles(FILE **f___0 , char *nom , P_Criteres___1 cr ) 
{ 
  char buf[500] ;
  int tab[100] ;
  FILE *namefile ;
  FILE **tmp ;

  {
  {
#line 127
  strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)nom);
#line 129
  namefile = fopen((char const   */* __restrict  */)".namefile", (char const   */* __restrict  */)"w");
  }
#line 130
  if ((unsigned long )namefile == (unsigned long )((void *)0)) {
#line 131
    return (0);
  }
  {
#line 133
  tmp = recInitFiles(f___0, 0, cr, buf, tab, namefile);
  }
#line 133
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 135
    fclose(namefile);
    }
#line 136
    return (0);
  }
  {
#line 139
  fclose(namefile);
  }
#line 140
  return (1);
}
}
#line 146 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS+DELTA/Spell/src/criteres.c"
FILE **recInitFiles(FILE **f___0 , int bloc , P_Criteres___1 cr , char *buf , int *tab ,
                    FILE *namefile ) 
{ 
  int i ;
  char tmp[20] ;
  char *posfin ;
  size_t tmp___0 ;

  {
  {
#line 154
  tmp___0 = strlen((char const   *)buf);
#line 154
  posfin = buf + tmp___0;
#line 155
  i = (cr->saut + bloc)->min + *(cr->delta + bloc);
  }
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    if (! (i + *(cr->delta + bloc) <= (cr->saut + bloc)->max)) {
#line 155
      goto while_break;
    }
#line 157
    if (bloc < (int )cr->bloc - 1) {
      {
#line 159
      *(tab + bloc) = i;
#line 160
      sprintf((char */* __restrict  */)(tmp), (char const   */* __restrict  */)"[%d-%d]",
              i - *(cr->delta + bloc), i + *(cr->delta + bloc));
#line 161
      strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)(tmp));
#line 163
      f___0 = recInitFiles(f___0, bloc + 1, cr, buf, tab, namefile);
      }
#line 165
      if ((unsigned long )f___0 == (unsigned long )((void *)0)) {
#line 166
        return ((FILE **)((void *)0));
      }
    } else {
      {
#line 176
      *f___0 = fopen((char const   */* __restrict  */)buf, (char const   */* __restrict  */)"w");
      }
#line 178
      if ((unsigned long )*f___0 == (unsigned long )((void *)0)) {
#line 179
        return ((FILE **)((void *)0));
      }
      {
#line 181
      fprintf((FILE */* __restrict  */)namefile, (char const   */* __restrict  */)"%s\n",
              buf);
#line 186
      i = 0;
      }
      {
#line 186
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 186
        if (! (i != 3)) {
#line 186
          goto while_break___0;
        }
        {
#line 188
        fprintf((FILE */* __restrict  */)*f___0, (char const   */* __restrict  */)"                                        ");
#line 189
        fprintf((FILE */* __restrict  */)*f___0, (char const   */* __restrict  */)"                                       \n");
#line 186
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 191
      fprintf((FILE */* __restrict  */)*f___0, (char const   */* __restrict  */)"========================================");
#line 192
      fprintf((FILE */* __restrict  */)*f___0, (char const   */* __restrict  */)"=======================================\n");
#line 194
      f___0 ++;
      }
#line 194
      return (f___0);
    }
#line 196
    *posfin = (char )'\000';
#line 155
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 198
  return (f___0);
}
}
#line 205 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS+DELTA/Spell/src/criteres.c"
int delta2File(int *deltatab , P_Criteres___1 cr ) 
{ 
  int pos___3 ;
  int i ;

  {
#line 207
  pos___3 = 0;
#line 209
  pos___3 = (*(deltatab + 0) - (cr->saut + 0)->min) - *(cr->delta + 0);
#line 211
  i = 1;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    if (! (i != (int )cr->bloc - 1)) {
#line 211
      goto while_break;
    }
#line 213
    pos___3 *= (((cr->saut + i)->max - (cr->saut + i)->min) + 1) - *(cr->delta + i) * 2;
#line 214
    pos___3 += (*(deltatab + i) - (cr->saut + i)->min) - *(cr->delta + i);
#line 211
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 217
  return (pos___3);
}
}
#line 251 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS+DELTA/Spell/src/criteres.c"
int file2Delta(int pos___3 , int *deltatab , P_Criteres___1 cr ) 
{ 
  int i ;
  int tmp ;

  {
#line 255
  i = 0;
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 255
    if (! (i != (int )cr->bloc - 1)) {
#line 255
      goto while_break;
    }
#line 257
    tmp = (((cr->saut + i)->max - (cr->saut + i)->min) + 1) - *(cr->delta + i) * 2;
#line 258
    *(deltatab + (((int )cr->bloc - 2) - i)) = pos___3 % tmp;
#line 259
    pos___3 /= tmp;
#line 255
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  if (pos___3 != 0) {
    {
#line 264
    warning((char *)"file2Delta: conversion error");
    }
#line 265
    return (0);
  }
#line 267
  return (1);
}
}
#line 41 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS+DELTA/Spell/src/barre.c"
static int pos___2  =    0;
#line 42 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS+DELTA/Spell/src/barre.c"
static int max___2  =    0;
#line 43 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS+DELTA/Spell/src/barre.c"
static int lastecrit___2  =    0;
#line 44 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS+DELTA/Spell/src/barre.c"
static time_t start___2  ;
#line 54 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS+DELTA/Spell/src/spell.c"
static float PrintCpuTime___0(char initIt ) ;
#line 280 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS+DELTA/Spell/src/spell.c"
void sommeBTOccPartielle(P_PileOcc p , Bit_Tab **bt , int nb_tranches , int *nboccsaut ) 
{ 
  int pos___3 ;
  P_occ po ;
  int i ;
  int *ptr_saut ;
  Bit_Tab **curbt ;

  {
#line 283
  pos___3 = p->pos - 1;
#line 284
  po = p->occ + pos___3;
#line 288
  if (pos___3 < 0) {
    {
#line 289
    fatalError((char *)"spell.c: sommeBTOccPartielle: wrong position in stack!\n");
    }
  }
#line 291
  curbt = (bt + nb_tranches) - 1;
#line 292
  ptr_saut = (nboccsaut + nb_tranches) - 1;
  {
#line 293
  while (1) {
    while_continue: /* CIL Label */ ;
#line 293
    if (! (nb_tranches != 0)) {
#line 293
      goto while_break;
    }
    {
#line 295
    ReinitBitTab(curbt);
#line 297
    i = *ptr_saut;
    }
    {
#line 297
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 297
      if (! (i != 0)) {
#line 297
        goto while_break___0;
      }
#line 299
      if ((unsigned int )(*((po->x)->fils + po->num))->debut & 2147483648U) {
        {
#line 300
        fusionneBitTab(curbt, ((Feuille *)*((po->x)->fils + po->num))->sequences);
        }
      } else {
        {
#line 302
        fusionneBitTab(curbt, (*((po->x)->fils + po->num))->sequences);
        }
      }
#line 304
      po --;
#line 297
      i --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 306
    nb_tranches --;
#line 307
    ptr_saut --;
#line 308
    curbt --;
  }
  while_break: /* CIL Label */ ;
  }
#line 316
  return;
}
}
#line 409 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS+DELTA/Spell/src/spell.c"
int saute2MinSaut(Occ curocc , P_mod model___1 , P_PileOcc pocc___1 , Fourchette *range ,
                  P_Criteres___1 cr , int longsaut , int longmod , int curbloc ) 
{ 
  int lmaxbr ;
  Noeud *tmpnoeud ;
  Noeud *newtmpnoeud ;
  int res ;
  int newlongsaut ;
  int trans ;
  char carseq ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 414
  res = 0;
#line 419
  tmpnoeud = *((curocc.x)->fils + curocc.num);
#line 421
  if ((unsigned int )tmpnoeud->debut & 2147483648U) {
    {
#line 422
    tmp = getValue(Liste_positions_fin, ((Feuille *)tmpnoeud)->fin_deb);
#line 422
    lmaxbr = tmp - (((Feuille *)tmpnoeud)->debut & 2147483647);
    }
  } else {
#line 425
    lmaxbr = tmpnoeud->fin - tmpnoeud->debut;
  }
#line 432
  if (curocc.lon != lmaxbr) {
#line 434
    if (lmaxbr - curocc.lon <= range->min - longsaut) {
#line 437
      longsaut += lmaxbr - curocc.lon;
#line 438
      curocc.lon = lmaxbr;
#line 445
      carseq = (char )*(*(text + tmpnoeud->sequence_number) + (((tmpnoeud->debut & 2147483647) + lmaxbr) - 1));
#line 448
      if ((int )carseq != 36) {
        {
#line 450
        tmp___0 = saute2MinSaut(curocc, model___1, pocc___1, range, cr, longsaut,
                                longmod, curbloc);
#line 450
        res += tmp___0;
        }
      }
    } else {
      {
#line 459
      curocc.lon += range->min - longsaut;
#line 460
      longsaut = range->min;
#line 467
      res ++;
#line 468
      tmp___1 = addSaut2Code(curocc.codesaut, longsaut, curbloc, cr);
#line 468
      ajouteOcc2Pile(pocc___1, curocc.x, curocc.num, curocc.lon, curocc.xerr, curocc.codesaut,
                     curocc.saut + longsaut, tmp___1);
      }
    }
  } else {
#line 480
    curocc.x = tmpnoeud;
#line 482
    if (((unsigned int )tmpnoeud->debut & 2147483648U) == 0U) {
#line 484
      trans = 0;
      {
#line 484
      while (1) {
        while_continue: /* CIL Label */ ;
#line 484
        if (! (trans != nbSymbSeq)) {
#line 484
          goto while_break;
        }
#line 486
        curocc.num = trans;
#line 487
        newlongsaut = longsaut;
#line 489
        if ((unsigned long )*(tmpnoeud->fils + trans) != (unsigned long )((void *)0)) {
#line 491
          newtmpnoeud = *(tmpnoeud->fils + trans);
#line 493
          if ((unsigned int )newtmpnoeud->debut & 2147483648U) {
            {
#line 494
            tmp___2 = getValue(Liste_positions_fin, ((Feuille *)newtmpnoeud)->fin_deb);
#line 494
            lmaxbr = tmp___2 - (newtmpnoeud->debut & 2147483647);
            }
          } else {
#line 498
            lmaxbr = newtmpnoeud->fin - newtmpnoeud->debut;
          }
#line 500
          if (lmaxbr <= range->min - longsaut) {
#line 502
            newlongsaut += lmaxbr;
#line 503
            curocc.lon = lmaxbr;
#line 510
            carseq = (char )*(*(text + newtmpnoeud->sequence_number) + (((newtmpnoeud->debut & 2147483647) + lmaxbr) - 1));
#line 512
            if ((int )carseq != 36) {
              {
#line 517
              tmp___3 = saute2MinSaut(curocc, model___1, pocc___1, range, cr, newlongsaut,
                                      longmod, curbloc);
#line 517
              res += tmp___3;
              }
            }
          } else {
            {
#line 523
            curocc.lon = range->min - newlongsaut;
#line 524
            newlongsaut = range->min;
#line 531
            res ++;
#line 532
            tmp___4 = addSaut2Code(curocc.codesaut, newlongsaut, curbloc, cr);
#line 532
            ajouteOcc2Pile(pocc___1, curocc.x, curocc.num, curocc.lon, curocc.xerr,
                           curocc.codesaut, curocc.saut + newlongsaut, tmp___4);
            }
          }
        }
#line 484
        trans ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 546
  return (res);
}
}
#line 555 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS+DELTA/Spell/src/spell.c"
void initBlocerrPile(P_PileOcc p ) 
{ 
  int pos___3 ;
  int precdummy ;
  P_occ tmpocc ;

  {
  {
#line 557
  pos___3 = p->pos - 1;
#line 559
  tmpocc = p->occ + pos___3;
#line 561
  precdummy = getPrecDummy(p);
  }
  {
#line 563
  while (1) {
    while_continue: /* CIL Label */ ;
#line 563
    if (pos___3 != precdummy) {
#line 563
      if (! ((unsigned long )tmpocc->x != (unsigned long )((void *)0))) {
#line 563
        goto while_break;
      }
    } else {
#line 563
      goto while_break;
    }
#line 565
    tmpocc->blocerr = 0;
#line 566
    pos___3 --;
#line 567
    tmpocc --;
  }
  while_break: /* CIL Label */ ;
  }
#line 569
  return;
}
}
#line 1711 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS+DELTA/Spell/src/spell.c"
static float dust___2  ;
#line 1707 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS+DELTA/Spell/src/spell.c"
static float PrintCpuTime___0(char initIt ) 
{ 
  float ust ;
  struct tms tms ;
  long tmp ;

  {
  {
#line 1713
  times(& tms);
#line 1715
  ust = (float )tms.tms_utime;
  }
#line 1717
  if (initIt) {
#line 1719
    dust___2 = ust;
#line 1720
    return ((float )0.0);
  } else {
    {
#line 1724
    ust -= dust___2;
#line 1725
    tmp = sysconf(2);
    }
#line 1725
    return (ust / (float )tmp);
  }
}
}
#line 60 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS+DELTA/src/libfasta.c"
static char sBuffer___2[8192]  ;
#line 61
static char *sNextIOBuffer___2(FILE *streamin , Bool retain , Bool serial ) ;
#line 61 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS+DELTA/src/libfasta.c"
static Bool sRetained___2  =    0;
#line 55 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS+DELTA/src/libfasta.c"
static char *sNextIOBuffer___2(FILE *streamin , Bool retain , Bool serial ) 
{ 
  char *buf ;
  char *end ;
  char *tmp ;
  size_t tmp___0 ;

  {
#line 63
  if (retain) {
#line 63
    goto _L;
  } else
#line 63
  if (sRetained___2) {
    _L: /* CIL Label */ 
#line 63
    if (serial) {
#line 63
      buf = sBuffer___2;
    } else {
      {
#line 63
      tmp = fgets((char */* __restrict  */)(sBuffer___2), (int )sizeof(sBuffer___2),
                  (FILE */* __restrict  */)streamin);
#line 63
      buf = tmp;
      }
    }
  } else {
    {
#line 63
    tmp = fgets((char */* __restrict  */)(sBuffer___2), (int )sizeof(sBuffer___2),
                (FILE */* __restrict  */)streamin);
#line 63
    buf = tmp;
    }
  }
#line 67
  if (buf) {
    {
#line 68
    tmp___0 = strlen((char const   *)buf);
#line 68
    end = (buf + tmp___0) - 1;
    }
#line 69
    if ((int )*end == 10) {
#line 69
      *end = (char )'\000';
    }
  }
#line 72
  sRetained___2 = retain;
#line 74
  return (buf);
}
}
#line 124 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS+DELTA/src/libfasta.c"
static char name___2[64]  ;
#line 140 "/home/wheatley/newnew/temp/mlv-smile-1.47/P_BLOCS+DELTA/src/libfasta.c"
static char comment___2[512]  ;
