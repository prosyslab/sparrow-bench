/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __id_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 220 "/usr/include/unistd.h"
typedef __ssize_t ssize_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_11 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_12 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_11 __wait_terminated ;
   struct __anonstruct___wait_stopped_12 __wait_stopped ;
};
#line 104 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __id_t id_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 292 "/usr/include/x86_64-linux-gnu/bits/resource.h"
enum __priority_which {
    PRIO_PROCESS = 0,
    PRIO_PGRP = 1,
    PRIO_USER = 2
} ;
#line 40 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef enum __priority_which __priority_which_t;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 6 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol.h"
struct string {
   char *start ;
   char *end ;
   char *start_of_file ;
};
#line 13
enum type {
    TYPE_CC = 0,
    TYPE_CPLUSPLUS = 1,
    TYPE_LD = 2,
    TYPE_MAKE = 3,
    TYPE_OTHER = 4,
    LAST_TYPE = 3
} ;
#line 24 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol.h"
struct add {
   struct add *next ;
   char *arg ;
};
#line 30 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol.h"
struct section {
   struct string name ;
   _Bool verbose ;
   int nice ;
   unsigned int cpus ;
   char *no_parallel ;
   char *names[4] ;
   char *ccache ;
   char *distcc ;
   char *distcc_hosts ;
   _Bool distcplusplus_hosts_set ;
   char *distcplusplus_hosts ;
   struct add *make_add ;
   struct add *env_add ;
   int lock_fd ;
   char *lock_file ;
};
#line 78 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol.h"
typedef void (*undofn_t)(void);
#line 213 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol.c"
union __anonunion_68 {
   int __in ;
   int __i ;
};
#line 213 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol.c"
union __anonunion_69 {
   int __in ;
   int __i ;
};
#line 213 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol.c"
union __anonunion_70 {
   int __in ;
   int __i ;
};
#line 144 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __key_t;
#line 177 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __syscall_ulong_t;
#line 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
#line 122 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __key_t key_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/ipc.h"
struct ipc_perm {
   __key_t __key ;
   __uid_t uid ;
   __gid_t gid ;
   __uid_t cuid ;
   __gid_t cgid ;
   unsigned short mode ;
   unsigned short __pad1 ;
   unsigned short __seq ;
   unsigned short __pad2 ;
   __syscall_ulong_t __glibc_reserved1 ;
   __syscall_ulong_t __glibc_reserved2 ;
};
#line 38 "/usr/include/x86_64-linux-gnu/bits/sem.h"
struct semid_ds {
   struct ipc_perm sem_perm ;
   __time_t sem_otime ;
   __syscall_ulong_t __glibc_reserved1 ;
   __time_t sem_ctime ;
   __syscall_ulong_t __glibc_reserved2 ;
   __syscall_ulong_t sem_nsems ;
   __syscall_ulong_t __glibc_reserved3 ;
   __syscall_ulong_t __glibc_reserved4 ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/sem.h"
struct seminfo {
   int semmap ;
   int semmni ;
   int semmns ;
   int semmnu ;
   int semmsl ;
   int semopm ;
   int semume ;
   int semusz ;
   int semvmx ;
   int semaem ;
};
#line 41 "/usr/include/x86_64-linux-gnu/sys/sem.h"
struct sembuf {
   unsigned short sem_num ;
   short sem_op ;
   short sem_flg ;
};
#line 48 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-lock.c"
union semun {
   int val ;
   struct semid_ds *buf ;
   unsigned short *array ;
   struct seminfo *__buf ;
};
#line 12 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-parse.c"
enum token_type {
    CC = 0,
    CPLUSPLUS = 1,
    LD = 2,
    MAKE = 3,
    NONE = 4,
    INDENT = 5,
    NO_PARALLEL = 6,
    CCACHE = 7,
    DISTCC = 8,
    DISTCC_HOSTS = 9,
    DISTCPLUSPLUS_HOSTS = 10,
    LEFT_BRACKET = 11,
    RIGHT_BRACKET = 12,
    EQUALS = 13,
    NUMBER = 14,
    STRING = 15,
    VERBOSE = 16,
    NICE = 17,
    INCLUDE = 18,
    CPUS = 19,
    DISABLE = 20,
    ADD = 21,
    ENV = 22,
    LOCK_FILE = 23,
    END = 24
} ;
#line 3 "keywords.gperf"
struct ccontrol_command;
#line 7 "keywords.gperf"
struct ccontrol_command {
   char const   *name ;
   enum token_type type ;
};
#line 42 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-parse.c"
struct token {
   enum token_type type ;
   struct string string ;
};
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 50
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 511
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 563
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execv)(char const   *__path ,
                                                                                              char * const  *__argv ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 584
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) setenv)(char const   *__name ,
                                                                                             char const   *__value ,
                                                                                             int __replace ) ;
#line 588
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unsetenv)(char const   *__name ) ;
#line 56 "/usr/include/fnmatch.h"
extern int fnmatch(char const   *__pattern , char const   *__name , int __flags ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 102 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 97 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setpriority)(__priority_which_t __which ,
                                                                                  id_t __who ,
                                                                                  int __prio ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 214
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/stdrusty.h"
__inline static _Bool strends(char const   *a , char const   *b ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 16
  tmp = strlen(a);
#line 16
  tmp___0 = strlen(b);
  }
#line 16
  if (tmp < tmp___0) {
#line 17
    return ((_Bool)0);
  }
  {
#line 19
  tmp___1 = strlen(a);
#line 19
  tmp___2 = strlen(b);
#line 19
  tmp___3 = strcmp((a + tmp___1) - tmp___2, b);
  }
#line 19
  return ((_Bool )(tmp___3 == 0));
}
}
#line 44
char const   *int_to_string(int val ) ;
#line 45
 __attribute__((__noreturn__)) void fatal(char const   *msg , int err  , ...) ;
#line 71 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol.h"
void __verbose(char const   *msg  , ...)  __attribute__((__sentinel__)) ;
#line 74
struct section read_config(char const   *configname , char const   *dir , int fd ) ;
#line 75
char *resolve_path(char const   *configured_path , char const   *cmdname ) ;
#line 79
undofn_t grab_lock(int fd , struct section sec , enum type type ) ;
#line 83
enum type what_am_i(char **argv ) ;
#line 84
_Bool can_distcc(char **argv ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol.c"
static void insert_arg(char **argv , unsigned int argc , unsigned int pos , char *arg ) 
{ 


  {
  {
#line 21
  memmove((void *)((argv + pos) + 1), (void const   *)(argv + pos), (unsigned long )(argc + 1U) * sizeof(char *));
#line 22
  *(argv + pos) = arg;
  }
#line 23
  return;
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol.c"
static void write_string(int fd , char const   *str ) 
{ 
  size_t tmp ;

  {
  {
#line 27
  tmp = strlen(str);
#line 27
  write(fd, (void const   *)str, tmp);
  }
#line 28
  return;
}
}
#line 30
void __verbose(char const   *msg  , ...)  __attribute__((__sentinel__)) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol.c"
void __verbose(char const   *msg  , ...) 
{ 
  va_list arglist ;
  char const   *str ;
  __pid_t tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 35
  write_string(2, "   ccontrol(");
#line 36
  tmp = getpid();
#line 36
  tmp___0 = int_to_string(tmp);
#line 36
  write_string(2, tmp___0);
#line 37
  write_string(2, ") ");
#line 38
  write_string(2, msg);
#line 40
  __builtin_va_start(arglist, msg);
  }
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 41
    tmp___1 = __builtin_va_arg(arglist, char *);
#line 41
    str = tmp___1;
    }
#line 41
    if (! ((unsigned long )str != (unsigned long )((void *)0))) {
#line 41
      goto while_break;
    }
    {
#line 42
    write_string(2, str);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 43
  __builtin_va_end(arglist);
#line 45
  write_string(2, "\n");
  }
#line 46
  return;
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol.c"
static _Bool make_target_match(char **argv , char *targets ) 
{ 
  char *p ;
  char *target ;
  unsigned int i ;
  char *tmp ;
  int tmp___0 ;

  {
#line 50
  target = (char *)"";
#line 53
  if (! targets) {
#line 54
    return ((_Bool)0);
  }
#line 56
  if (! *(targets + 0)) {
#line 57
    return ((_Bool)1);
  }
#line 60
  i = 0U;
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! *(argv + i)) {
#line 60
      goto while_break;
    }
#line 61
    if ((int )*(*(argv + i) + 0) == 45) {
#line 62
      goto __Cont;
    }
    {
#line 63
    tmp = strchr((char const   *)*(argv + i), '=');
    }
#line 63
    if (tmp) {
#line 64
      goto __Cont;
    }
#line 65
    target = *(argv + i);
    __Cont: /* CIL Label */ 
#line 60
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 68
  p = strtok((char */* __restrict  */)targets, (char const   */* __restrict  */)" \t");
  }
  {
#line 68
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 68
    if (! p) {
#line 68
      goto while_break___0;
    }
    {
#line 69
    tmp___0 = fnmatch((char const   *)p, (char const   *)target, 0);
    }
#line 69
    if (tmp___0 == 0) {
#line 70
      return ((_Bool)1);
    }
    {
#line 68
    p = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t");
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 71
  return ((_Bool)0);
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol.c"
static _Bool already_has_dash_j(char **argv ) 
{ 
  unsigned int i ;
  char const   *makeflags ;
  size_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 79
  i = 0U;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! *(argv + i)) {
#line 79
      goto while_break;
    }
    {
#line 80
    tmp = strlen("-j");
#line 80
    tmp___0 = strncmp((char const   *)*(argv + i), "-j", tmp);
    }
#line 80
    if (tmp___0 == 0) {
#line 81
      return ((_Bool)1);
    }
#line 79
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 84
  tmp___1 = getenv("MAKEFLAGS");
#line 84
  makeflags = (char const   *)tmp___1;
  }
#line 85
  if (makeflags) {
    {
#line 85
    tmp___2 = strstr(makeflags, "--jobserver-fds");
    }
#line 85
    if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 85
      tmp___3 = 1;
    } else {
#line 85
      tmp___3 = 0;
    }
  } else {
#line 85
    tmp___3 = 0;
  }
#line 85
  return ((_Bool )tmp___3);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol.c"
static void adjust_args_and_environment(struct section sec , enum type type , char **argv ,
                                        unsigned int argc ) 
{ 
  struct add *add ;
  char const   *cpus ;
  char const   *tmp ;
  char *arg ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  unsigned int tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  char *hosts ;
  unsigned int tmp___8 ;
  char *eq ;
  char *tmp___9 ;

  {
#line 95
  if ((unsigned int )type != 4U) {
#line 96
    *(argv + 0) = sec.names[type];
  }
  {
#line 99
  if ((unsigned int )type == 3U) {
#line 99
    goto case_3;
  }
#line 119
  if ((unsigned int )type == 1U) {
#line 119
    goto case_1;
  }
#line 119
  if ((unsigned int )type == 0U) {
#line 119
    goto case_1;
  }
#line 137
  if ((unsigned int )type == 4U) {
#line 137
    goto case_4;
  }
#line 137
  if ((unsigned int )type == 2U) {
#line 137
    goto case_4;
  }
#line 98
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 101
  setenv("MAKE", "make", 1);
#line 104
  tmp___4 = make_target_match(argv, sec.no_parallel);
  }
#line 104
  if (! tmp___4) {
    {
#line 104
    tmp___5 = already_has_dash_j(argv);
    }
#line 104
    if (! tmp___5) {
      {
#line 106
      tmp = int_to_string((int )(sec.cpus * 20U));
#line 106
      cpus = tmp;
#line 107
      tmp___0 = strlen(cpus);
#line 107
      tmp___1 = malloc(tmp___0 + 3UL);
#line 107
      arg = (char *)tmp___1;
#line 109
      strcpy((char */* __restrict  */)arg, (char const   */* __restrict  */)"-j");
#line 110
      tmp___2 = strlen((char const   *)arg);
#line 110
      strcpy((char */* __restrict  */)(arg + tmp___2), (char const   */* __restrict  */)cpus);
#line 111
      tmp___3 = argc;
#line 111
      argc ++;
#line 111
      insert_arg(argv, tmp___3, 1U, arg);
      }
    }
  }
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! sec.make_add) {
#line 113
      goto while_break;
    }
    {
#line 114
    tmp___6 = argc;
#line 114
    argc ++;
#line 114
    insert_arg(argv, tmp___6, 1U, (sec.make_add)->arg);
#line 115
    sec.make_add = (sec.make_add)->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 117
  goto switch_break;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 120
  if (sec.ccache) {
    {
#line 121
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 121
      if (sec.verbose) {
        {
#line 121
        __verbose("Prefixing ccache ", sec.ccache, (void *)0);
        }
      }
#line 121
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 122
    tmp___7 = argc;
#line 122
    argc ++;
#line 122
    insert_arg(argv, tmp___7, 0U, sec.ccache);
    }
  } else
#line 123
  if (sec.distcc) {
#line 126
    if ((unsigned int )type == 0U) {
#line 127
      hosts = sec.distcc_hosts;
    } else {
#line 129
      hosts = sec.distcplusplus_hosts;
    }
    {
#line 130
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 130
      if (sec.verbose) {
        {
#line 130
        __verbose("Setting DISTCC_HOSTS=", hosts, (void *)0);
        }
      }
#line 130
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 131
    setenv("DISTCC_HOSTS", (char const   *)hosts, 1);
    }
    {
#line 132
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 132
      if (sec.verbose) {
        {
#line 132
        __verbose("Prefixing arg ", sec.distcc, (void *)0);
        }
      }
#line 132
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 133
    tmp___8 = argc;
#line 133
    argc ++;
#line 133
    insert_arg(argv, tmp___8, 0U, sec.distcc);
    }
  }
  case_4: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 138
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 141
  add = sec.env_add;
  {
#line 141
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 141
    if (! add) {
#line 141
      goto while_break___3;
    }
    {
#line 142
    tmp___9 = strchr((char const   *)add->arg, '=');
#line 142
    eq = tmp___9;
    }
#line 143
    if (! eq) {
      {
#line 144
      fatal("Environment variable needs \'=\': ", 0, add->arg, (void *)0);
      }
    }
    {
#line 146
    *eq = (char )'\000';
#line 147
    setenv((char const   *)add->arg, (char const   *)(eq + 1), 1);
#line 141
    add = add->next;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 149
  return;
}
}
#line 152
static  __attribute__((__noreturn__)) void run_command(_Bool verbose , char **argv ) ;
#line 152 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol.c"
static void run_command(_Bool verbose , char **argv ) 
{ 
  unsigned int i ;
  __pid_t tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;

  {
#line 154
  if (verbose) {
    {
#line 156
    write_string(2, "  ccontrol(");
#line 157
    tmp = getpid();
#line 157
    tmp___0 = int_to_string(tmp);
#line 157
    write_string(2, tmp___0);
#line 158
    write_string(2, ") execing ");
#line 159
    i = 0U;
    }
    {
#line 159
    while (1) {
      while_continue: /* CIL Label */ ;
#line 159
      if (! *(argv + i)) {
#line 159
        goto while_break;
      }
      {
#line 160
      write_string(2, "\'");
#line 161
      write_string(2, (char const   *)*(argv + i));
#line 162
      write_string(2, "\' ");
#line 159
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 164
    write_string(2, "\n");
    }
  }
  {
#line 166
  execv((char const   *)*(argv + 0), (char * const  *)argv);
#line 167
  tmp___1 = __errno_location();
#line 167
  fatal("failed to exec \'", *tmp___1, *(argv + 0), "\'", (void *)0);
  }
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol.c"
static void fork_command(_Bool verbose , char **argv ) 
{ 
  int pid ;
  __pid_t tmp ;
  int *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 198
  tmp = fork();
#line 198
  pid = tmp;
  }
#line 200
  if (pid < 0) {
    {
#line 201
    tmp___0 = __errno_location();
#line 201
    fatal("failed to fork", *tmp___0, (void *)0);
    }
  }
#line 202
  if (pid == 0) {
    {
#line 203
    run_command(verbose, argv);
    }
  }
  {
#line 204
  while (1) {
    while_continue: /* CIL Label */ ;
#line 204
    if (verbose) {
      {
#line 204
      tmp___1 = int_to_string(pid);
#line 204
      __verbose("Forked ", tmp___1, (void *)0);
      }
    }
#line 204
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  return;
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol.c"
static int wait_for_child(_Bool verbose ) 
{ 
  int status ;
  union __anonunion_69 __constr_expr_1 ;
  union __anonunion_70 __constr_expr_2 ;
  char const   *tmp ;

  {
  {
#line 212
  wait((union wait *)(& status));
#line 213
  __constr_expr_2.__in = status;
  }
#line 213
  if ((__constr_expr_2.__i & 127) == 0) {
#line 213
    __constr_expr_1.__in = status;
#line 213
    status = (__constr_expr_1.__i & 65280) >> 8;
  } else {
#line 213
    status = 255;
  }
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (verbose) {
      {
#line 214
      tmp = int_to_string(status);
#line 214
      __verbose("Child returned ", tmp, (void *)0);
      }
    }
#line 214
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  return (status);
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol.c"
static _Bool file_altered(char const   *configname , struct stat  const  *st ) 
{ 
  struct stat st2 ;
  int tmp ;

  {
  {
#line 222
  stat((char const   */* __restrict  */)configname, (struct stat */* __restrict  */)(& st2));
  }
#line 223
  if (st2.st_ctim.tv_sec != (__time_t )st->st_ctim.tv_sec) {
#line 223
    tmp = 1;
  } else
#line 223
  if (st2.st_mtim.tv_sec != (__time_t )st->st_mtim.tv_sec) {
#line 223
    tmp = 1;
  } else
#line 223
  if (st2.st_ino != (__ino_t )st->st_ino) {
#line 223
    tmp = 1;
  } else {
#line 223
    tmp = 0;
  }
#line 223
  return ((_Bool )tmp);
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol.c"
static void write_item(char const   *a , char const   *b ) 
{ 


  {
#line 229
  if (b) {
    {
#line 230
    write_string(1, "\t");
#line 231
    write_string(1, a);
#line 231
    write_string(1, b);
#line 232
    write_string(1, "\n");
    }
  }
#line 234
  return;
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol.c"
static void print_add(char const   *str , struct add *add ) 
{ 


  {
#line 239
  if (! add) {
#line 240
    return;
  }
  {
#line 241
  print_add(str, add->next);
#line 242
  write_item(str, (char const   *)add->arg);
  }
#line 243
  return;
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol.c"
static void print_section(char const   *dir , struct section sec ) 
{ 
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 247
  write_string(1, "[");
#line 248
  write_string(1, dir);
#line 249
  write_string(1, "]\n");
#line 250
  write_item("cc = ", (char const   *)sec.names[0]);
#line 251
  write_item("c++ = ", (char const   *)sec.names[1]);
#line 252
  write_item("make = ", (char const   *)sec.names[3]);
#line 253
  write_item("ld = ", (char const   *)sec.names[2]);
#line 254
  write_item("ccache = ", (char const   *)sec.ccache);
  }
#line 255
  if (sec.distcc) {
#line 255
    if (sec.distcc_hosts) {
#line 255
      goto _L;
    } else
#line 255
    if (sec.distcplusplus_hosts) {
      _L: /* CIL Label */ 
      {
#line 256
      write_item("distcc = ", (char const   *)sec.distcc);
#line 257
      write_item("distcc-hosts = ", (char const   *)sec.distcc_hosts);
      }
#line 258
      if (sec.distcplusplus_hosts_set) {
        {
#line 259
        write_item("distc++-hosts = ", (char const   *)sec.distcplusplus_hosts);
        }
      }
    }
  }
  {
#line 261
  print_add("add make = ", sec.make_add);
#line 262
  print_add("add env = ", sec.env_add);
  }
#line 263
  if (sec.no_parallel) {
    {
#line 263
    tmp = strcmp((char const   *)sec.no_parallel, "");
    }
#line 263
    if (tmp == 0) {
      {
#line 264
      write_item("no-parallel", "");
      }
    } else {
      {
#line 266
      write_item("no-parallel = ", (char const   *)sec.no_parallel);
      }
    }
  } else {
    {
#line 266
    write_item("no-parallel = ", (char const   *)sec.no_parallel);
    }
  }
#line 267
  if (sec.cpus != 1U) {
    {
#line 268
    tmp___0 = int_to_string((int )sec.cpus);
#line 268
    write_item("cpus = ", tmp___0);
    }
  }
#line 269
  if (sec.verbose) {
    {
#line 270
    write_item("verbose", "");
    }
  }
#line 271
  if (sec.nice != 10) {
    {
#line 272
    tmp___1 = int_to_string(sec.nice);
#line 272
    write_item("nice = ", tmp___1);
    }
  }
  {
#line 273
  write_item("lock-file = ", (char const   *)sec.lock_file);
  }
#line 274
  return;
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol.c"
static _Bool is_preprocess(char **argv ) 
{ 
  char **arg ;
  int tmp ;

  {
#line 279
  arg = argv;
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
#line 279
    if (! *arg) {
#line 279
      goto while_break;
    }
    {
#line 280
    tmp = strcmp((char const   *)*arg, "-E");
    }
#line 280
    if (tmp == 0) {
#line 281
      return ((_Bool)1);
    }
#line 279
    arg ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 283
  return ((_Bool)0);
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol.c"
int main(int orig_argc , char **orig_argv ) 
{ 
  enum type type ;
  struct section sec ;
  int fd ;
  int ret ;
  int argc ;
  _Bool nodistcc ;
  _Bool noccache ;
  _Bool ccache_then_distcc ;
  struct stat st ;
  char configname[4096] ;
  char dirname[4096] ;
  char **new_argv ;
  unsigned long __lengthofnew_argv ;
  void *tmp ;
  char **argv ;
  void (*undo)(void) ;
  _Bool tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  struct section tmp___13 ;
  _Bool tmp___14 ;
  char *cmd ;
  char *tmp___15 ;
  _Bool tmp___16 ;
  _Bool tmp___17 ;
  char c ;
  int fd___0[2] ;
  int *tmp___18 ;
  int tmp___19 ;
  char const   *tmp___20 ;
  ssize_t tmp___21 ;
  int tmp___22 ;

  {
  {
#line 291
  nodistcc = (_Bool)0;
#line 291
  noccache = (_Bool)0;
#line 291
  ccache_then_distcc = (_Bool)0;
#line 295
  __lengthofnew_argv = (unsigned long )(orig_argc + 23);
#line 295
  tmp = __builtin_alloca(sizeof(*new_argv) * __lengthofnew_argv);
#line 295
  new_argv = (char **)tmp;
#line 299
  tmp___5 = getenv("CCONTROL_LOCK_FD");
  }
#line 299
  if (tmp___5) {
    {
#line 301
    tmp___0 = is_preprocess(orig_argv + 1);
    }
#line 301
    if (tmp___0) {
      {
#line 302
      run_command((_Bool)0, orig_argv + 1);
      }
    }
    {
#line 304
    tmp___2 = getenv("CCONTROL_LOCK_FD");
#line 304
    tmp___3 = atoi((char const   *)tmp___2);
#line 304
    tmp___4 = write(tmp___3, (void const   *)"#", (size_t )1);
    }
#line 304
    if (tmp___4 != 1L) {
      {
#line 305
      tmp___1 = __errno_location();
#line 305
      fatal("Could not write to ccontrol lock fd", *tmp___1, (void *)0);
      }
    }
    {
#line 307
    unsetenv("CCACHE_PREFIX");
#line 308
    unsetenv("CCONTROL_LOCK_FD");
#line 309
    noccache = (_Bool)1;
    }
  }
  {
#line 312
  tmp___6 = getenv("HOME");
#line 312
  strcpy((char */* __restrict  */)(configname), (char const   */* __restrict  */)tmp___6);
#line 313
  strcat((char */* __restrict  */)(configname), (char const   */* __restrict  */)"/.ccontrol/config");
  }
  again_restore_args: 
  {
#line 317
  argc = orig_argc;
#line 318
  memcpy((void */* __restrict  */)new_argv, (void const   */* __restrict  */)orig_argv,
         (unsigned long )(argc + 1) * sizeof(*(argv + 0)));
#line 319
  argv = new_argv;
#line 325
  getcwd(dirname, sizeof(dirname));
#line 327
  tmp___14 = strends((char const   *)*(argv + 0), "ccontrol");
  }
#line 327
  if (tmp___14) {
#line 328
    if (*(argv + 1)) {
      {
#line 328
      tmp___8 = strlen("--section=");
#line 328
      tmp___9 = strncmp((char const   *)*(argv + 1), "--section=", tmp___8);
      }
#line 328
      if (tmp___9 == 0) {
        {
#line 329
        tmp___7 = strlen("--section=");
#line 329
        strcpy((char */* __restrict  */)(dirname), (char const   */* __restrict  */)(*(argv + 1) + tmp___7));
#line 330
        argv ++;
#line 331
        argc --;
        }
      }
    }
#line 333
    if (*(argv + 1)) {
      {
#line 333
      tmp___10 = strcmp((char const   *)*(argv + 1), "--version");
      }
#line 333
      if (tmp___10 == 0) {
        {
#line 336
        __verbose("version 1.0 (David Gibson)", (void *)0);
#line 337
        exit(0);
        }
      } else {
        {
#line 333
        tmp___11 = strcmp((char const   *)*(argv + 1), "-V");
        }
#line 333
        if (tmp___11 == 0) {
          {
#line 336
          __verbose("version 1.0 (David Gibson)", (void *)0);
#line 337
          exit(0);
          }
        }
      }
    }
#line 339
    if (! *(argv + 1)) {
      {
#line 340
      tmp___12 = open((char const   *)(configname), 2);
#line 340
      tmp___13 = read_config((char const   *)(configname), (char const   *)(dirname),
                             tmp___12);
#line 340
      print_section((char const   *)(dirname), tmp___13);
#line 343
      exit(0);
      }
    }
#line 345
    argv ++;
#line 346
    argc --;
  }
  {
#line 348
  type = what_am_i(argv);
  }
  again: 
  {
#line 352
  fd = open((char const   *)(configname), 2);
#line 355
  sec = read_config((char const   *)(configname), (char const   *)(dirname), fd);
#line 359
  tmp___15 = resolve_path((char const   *)sec.names[type], (char const   *)*(argv + 0));
#line 359
  cmd = tmp___15;
#line 360
  free((void *)sec.names[type]);
#line 361
  sec.names[type] = cmd;
#line 364
  fstat(fd, & st);
#line 367
  setpriority((__priority_which_t )0, (id_t )0, sec.nice);
  }
#line 369
  if (noccache) {
    {
#line 370
    while (1) {
      while_continue: /* CIL Label */ ;
#line 370
      if (sec.verbose) {
        {
#line 370
        __verbose("ccache suppressed this time", (void *)0);
        }
      }
#line 370
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 371
    sec.ccache = (char *)((void *)0);
  }
#line 375
  if (sec.distcc) {
#line 376
    if (nodistcc) {
#line 377
      sec.distcc = (char *)((void *)0);
    } else
#line 376
    if ((unsigned int )type == 2U) {
#line 377
      sec.distcc = (char *)((void *)0);
    } else
#line 376
    if ((unsigned int )type == 3U) {
#line 377
      sec.distcc = (char *)((void *)0);
    } else
#line 378
    if (sec.ccache) {
#line 380
      sec.distcc = (char *)((void *)0);
#line 381
      ccache_then_distcc = (_Bool)1;
    } else
#line 383
    if ((unsigned int )type == 0U) {
#line 383
      if (! sec.distcc_hosts) {
#line 384
        sec.distcc = (char *)((void *)0);
      } else {
#line 383
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 385
    if ((unsigned int )type == 1U) {
#line 385
      if (! sec.distcplusplus_hosts) {
#line 387
        sec.distcc = (char *)((void *)0);
      } else {
#line 385
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 388
      tmp___16 = can_distcc(argv);
      }
#line 388
      if (! tmp___16) {
        {
#line 389
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 389
          if (sec.verbose) {
            {
#line 389
            __verbose("Cannot distcc this", (void *)0);
            }
          }
#line 389
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 390
        sec.distcc = (char *)((void *)0);
      }
    }
  }
  {
#line 397
  undo = grab_lock(sec.lock_fd, sec, type);
  }
#line 398
  if (undo) {
    {
#line 398
    tmp___17 = file_altered((char const   *)(configname), (struct stat  const  *)(& st));
    }
#line 398
    if (tmp___17) {
      {
#line 400
      nodistcc = (_Bool)0;
#line 401
      close(sec.lock_fd);
#line 402
      (*undo)();
      }
#line 403
      goto again;
    }
  }
  {
#line 406
  adjust_args_and_environment(sec, type, argv, (unsigned int )argc);
  }
#line 408
  if (ccache_then_distcc) {
    {
#line 416
    tmp___19 = pipe((int *)(fd___0));
    }
#line 416
    if (tmp___19 != 0) {
      {
#line 417
      tmp___18 = __errno_location();
#line 417
      fatal("Failed to create pipe", *tmp___18, (void *)0);
      }
    }
    {
#line 418
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 418
      if (sec.verbose) {
        {
#line 418
        __verbose("Setting CCACHE_PREFIX=ccontrol", (void *)0);
        }
      }
#line 418
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 419
    tmp___20 = int_to_string(fd___0[1]);
#line 419
    setenv("CCONTROL_LOCK_FD", tmp___20, 1);
#line 420
    setenv("CCACHE_PREFIX", "ccontrol", 1);
#line 421
    fork_command(sec.verbose, argv);
#line 422
    close(fd___0[1]);
#line 424
    tmp___21 = read(fd___0[0], (void *)(& c), (size_t )1);
    }
#line 424
    if (tmp___21 == 1L) {
      {
#line 425
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 425
        if (sec.verbose) {
          {
#line 425
          __verbose("Grandchild said to drop lock", (void *)0);
          }
        }
#line 425
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
#line 427
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 427
        if (sec.verbose) {
          {
#line 427
          __verbose("I guess ccache exited", (void *)0);
          }
        }
#line 427
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    {
#line 428
    (*undo)();
#line 429
    tmp___22 = wait_for_child(sec.verbose);
#line 429
    exit(tmp___22);
    }
  }
#line 432
  if (! sec.distcc) {
    {
#line 433
    run_command(sec.verbose, argv);
    }
  }
  {
#line 437
  setenv("DISTCC_FALLBACK", "0", 1);
#line 439
  fork_command(sec.verbose, argv);
#line 440
  ret = wait_for_child(sec.verbose);
  }
#line 441
  if (ret == 103) {
#line 441
    goto _L___1;
  } else
#line 441
  if (ret == 116) {
#line 441
    goto _L___1;
  } else
#line 441
  if (ret == 107) {
    _L___1: /* CIL Label */ 
    {
#line 443
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 443
      if (sec.verbose) {
        {
#line 443
        __verbose("distcc failed, retrying without", (void *)0);
        }
      }
#line 443
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 444
    close(sec.lock_fd);
#line 445
    (*undo)();
#line 446
    nodistcc = (_Bool)1;
#line 447
    unsetenv("CCACHE_PREFIX");
    }
    {
#line 451
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 451
      if (! sec.env_add) {
#line 451
        goto while_break___5;
      }
      {
#line 452
      unsetenv((char const   *)(sec.env_add)->arg);
#line 453
      sec.env_add = (sec.env_add)->next;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 455
    goto again_restore_args;
  }
#line 457
  return (ret);
}
}
#line 678 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getegid)(void) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 52 "/usr/include/x86_64-linux-gnu/sys/sem.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) semctl)(int __semid ,
                                                                             int __semnum ,
                                                                             int __cmd 
                                                                             , ...) ;
#line 55
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) semget)(key_t __key ,
                                                                             int __nsems ,
                                                                             int __semflg ) ;
#line 58
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) semop)(int __semid ,
                                                                            struct sembuf *__sops ,
                                                                            size_t __nsops ) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 80 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol.h"
void drop_slow_lock(void) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-lock.c"
static void fcntl_lock(int fd , _Bool lock , unsigned int offset ) 
{ 
  struct flock fl ;
  int *tmp ;
  int tmp___0 ;

  {
#line 25
  if (lock) {
#line 25
    fl.l_type = (short)1;
  } else {
#line 25
    fl.l_type = (short)2;
  }
  {
#line 26
  fl.l_whence = (short)0;
#line 27
  fl.l_start = (__off_t )offset;
#line 28
  fl.l_len = (__off_t )1;
#line 30
  tmp___0 = fcntl(fd, 7, & fl);
  }
#line 30
  if (tmp___0 < 0) {
    {
#line 31
    tmp = __errno_location();
#line 31
    fatal("cannot lock config file", *tmp, (void *)0);
    }
  }
#line 32
  return;
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-lock.c"
static int make_semaphore(int fd , struct section sec , int key ) 
{ 
  int id ;
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;
  union semun semctl_arg ;
  struct semid_ds ds ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 39
  fcntl_lock(fd, (_Bool)1, 0U);
#line 41
  id = semget(key, 1, 1536);
  }
#line 42
  if (id < 0) {
    {
#line 43
    tmp = __errno_location();
#line 43
    saved_errno = *tmp;
#line 45
    id = semget(key, 1, 0);
#line 46
    tmp___0 = __errno_location();
#line 46
    *tmp___0 = saved_errno;
    }
  } else {
    {
#line 56
    while (1) {
      while_continue: /* CIL Label */ ;
#line 56
      if (sec.verbose) {
        {
#line 56
        __verbose("Created slow lock", (void *)0);
        }
      }
#line 56
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 57
    memset((void *)(& ds), 0, sizeof(ds));
#line 58
    ds.sem_perm.uid = geteuid();
#line 59
    ds.sem_perm.gid = getegid();
#line 60
    ds.sem_perm.mode = (unsigned short)384;
#line 61
    semctl_arg.buf = & ds;
#line 63
    tmp___2 = semctl(id, 0, 1, semctl_arg);
    }
#line 63
    if (tmp___2 < 0) {
      {
#line 64
      tmp___1 = __errno_location();
#line 64
      fatal("cannot set semaphore permissions", *tmp___1, (void *)0);
      }
    }
    {
#line 66
    semctl_arg.val = (int )sec.cpus;
#line 67
    tmp___4 = semctl(id, 0, 16, semctl_arg);
    }
#line 67
    if (tmp___4 < 0) {
      {
#line 68
      tmp___3 = __errno_location();
#line 68
      fatal("cannot set semaphore value", *tmp___3, (void *)0);
      }
    }
  }
  {
#line 70
  fcntl_lock(fd, (_Bool)0, 0U);
  }
#line 71
  return (id);
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-lock.c"
static void grab_sem(int fd , struct section sec ) 
{ 
  struct sembuf sop ;
  int id ;
  int key ;
  __uid_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 81
  tmp = geteuid();
#line 81
  key = (int )(13423085U + tmp);
#line 83
  id = semget(key, 1, 0);
  }
#line 84
  if (id < 0) {
    {
#line 84
    tmp___0 = __errno_location();
    }
#line 84
    if (*tmp___0 == 2) {
      {
#line 85
      id = make_semaphore(fd, sec, key);
      }
    }
  }
#line 86
  if (id < 0) {
    {
#line 87
    tmp___1 = __errno_location();
#line 87
    fatal("cannot get semaphore", *tmp___1, (void *)0);
    }
  }
  again: 
  {
#line 90
  sop.sem_num = (unsigned short)0;
#line 91
  sop.sem_op = (short)-1;
#line 92
  sop.sem_flg = (short)4096;
#line 94
  tmp___4 = semop(id, & sop, (size_t )1);
  }
#line 94
  if (tmp___4 != 0) {
    {
#line 95
    tmp___2 = __errno_location();
    }
#line 95
    if (*tmp___2 == 4) {
#line 96
      goto again;
    }
    {
#line 97
    tmp___3 = __errno_location();
#line 97
    fatal("cannot decrement semaphore", *tmp___3, (void *)0);
    }
  }
#line 99
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-lock.c"
static void grab_fcntl_lock(int fd , unsigned int base , unsigned int max ) 
{ 
  __pid_t tmp ;
  int tmp___0 ;

  {
  {
#line 105
  tmp = getpid();
#line 105
  srand((unsigned int )tmp);
#line 107
  tmp___0 = rand();
#line 107
  fcntl_lock(fd, (_Bool)1, base + (unsigned int )tmp___0 % max);
  }
#line 108
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-lock.c"
static void set_lock_envvar(char depth ) 
{ 
  char locktype[2] ;

  {
  {
#line 113
  locktype[0] = depth;
#line 114
  locktype[1] = (char )'\000';
#line 115
  setenv("CCONTROL_LOCK", (char const   *)(locktype), 1);
  }
#line 116
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-lock.c"
static void undo_decrement_envvar(void) 
{ 
  char *depth ;
  char *tmp ;

  {
  {
#line 120
  tmp = getenv("CCONTROL_LOCK");
#line 120
  depth = tmp;
#line 121
  set_lock_envvar((char )((int )*(depth + 0) - 1));
  }
#line 122
  return;
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-lock.c"
void drop_slow_lock(void) 
{ 
  struct sembuf sop ;
  int id ;
  int key ;
  char *tmp ;
  char *tmp___0 ;
  __uid_t tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 129
  tmp = getenv("CCONTROL_LOCK");
  }
#line 129
  if (! tmp) {
    {
#line 129
    __assert_fail("getenv(\"CCONTROL_LOCK\")", "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-lock.c",
                  129U, "drop_slow_lock");
    }
  }
  {
#line 130
  tmp___0 = getenv("CCONTROL_LOCK");
  }
#line 130
  if (! ((int )*(tmp___0 + 0) == 48)) {
    {
#line 130
    __assert_fail("getenv(\"CCONTROL_LOCK\")[0] == \'0\'", "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-lock.c",
                  130U, "drop_slow_lock");
    }
  }
  {
#line 132
  tmp___1 = geteuid();
#line 132
  key = (int )(13423085U + tmp___1);
#line 134
  id = semget(key, 1, 0);
  }
#line 135
  if (id < 0) {
    {
#line 136
    tmp___2 = __errno_location();
#line 136
    fatal("cannot re-get semaphore", *tmp___2, (void *)0);
    }
  }
  {
#line 138
  sop.sem_num = (unsigned short)0;
#line 139
  sop.sem_op = (short)1;
#line 140
  sop.sem_flg = (short)4096;
#line 142
  tmp___4 = semop(id, & sop, (size_t )1);
  }
#line 142
  if (tmp___4 != 0) {
    {
#line 143
    tmp___3 = __errno_location();
#line 143
    fatal("cannot increment semaphore", *tmp___3, (void *)0);
    }
  }
  {
#line 145
  unsetenv("CCONTROL_LOCK");
  }
#line 146
  return;
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-lock.c"
static void undo_unset_envvar(void) 
{ 


  {
  {
#line 150
  unsetenv("CCONTROL_LOCK");
  }
#line 151
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-lock.c"
static void undo_nothing(void) 
{ 


  {
#line 155
  return;
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-lock.c"
undofn_t grab_lock(int fd , struct section sec , enum type type ) 
{ 
  char *lock ;
  char *tmp ;
  unsigned int distcc_lim ;
  unsigned int make_off ;
  unsigned int make_lim ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  unsigned int depth ;

  {
  {
#line 159
  tmp = getenv("CCONTROL_LOCK");
#line 159
  lock = tmp;
  }
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (sec.verbose) {
#line 162
      if ((unsigned int )type == 0U) {
#line 162
        tmp___3 = "CC";
      } else {
#line 162
        if ((unsigned int )type == 1U) {
#line 162
          tmp___2 = "C++";
        } else {
#line 162
          if ((unsigned int )type == 3U) {
#line 162
            tmp___1 = "MAKE";
          } else {
#line 162
            if ((unsigned int )type == 2U) {
#line 162
              tmp___0 = "LD";
            } else {
#line 162
              tmp___0 = "UNKNOWN";
            }
#line 162
            tmp___1 = tmp___0;
          }
#line 162
          tmp___2 = tmp___1;
        }
#line 162
        tmp___3 = tmp___2;
      }
      {
#line 162
      __verbose("Grabbing lock for ", tmp___3, (void *)0);
      }
    }
#line 162
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 169
  if (lock) {
#line 169
    if ((int )*(lock + 0) == 48) {
      {
#line 170
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 170
        if (sec.verbose) {
          {
#line 170
          __verbose("Already got it", (void *)0);
          }
        }
#line 170
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 171
      return (& undo_nothing);
    }
  }
#line 177
  distcc_lim = sec.cpus * 20U;
#line 177
  make_off = distcc_lim;
#line 178
  make_lim = sec.cpus * 3U;
#line 181
  if ((unsigned int )type == 3U) {
#line 182
    depth = 0U;
#line 185
    if (lock) {
#line 186
      depth = (unsigned int )(((int )*(lock + 0) - 65) + 1);
    }
    {
#line 187
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 187
      if (sec.verbose) {
        {
#line 187
        __verbose("Getting fast lock for make", (void *)0);
        }
      }
#line 187
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 190
    if (lock) {
      {
#line 191
      grab_fcntl_lock(fd, (1U + make_off) + depth * make_lim, make_lim);
      }
    }
    {
#line 193
    set_lock_envvar((char )(65U + depth));
    }
#line 194
    return (& undo_decrement_envvar);
  } else
#line 195
  if (! sec.distcc) {
    {
#line 196
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 196
      if (sec.verbose) {
        {
#line 196
        __verbose("Getting slow lock for non-distcc", (void *)0);
        }
      }
#line 196
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 198
    grab_sem(fd, sec);
#line 199
    set_lock_envvar((char )'0');
    }
#line 200
    return (& drop_slow_lock);
  } else {
#line 203
    if (lock) {
#line 203
      if ((int )*(lock + 0) == 49) {
        {
#line 204
        fatal("called myself?", 0, (void *)0);
        }
      }
    }
    {
#line 205
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 205
      if (sec.verbose) {
        {
#line 205
        __verbose("Getting fast lock for compile", (void *)0);
        }
      }
#line 205
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 206
    grab_fcntl_lock(fd, 1U, distcc_lim);
#line 207
    set_lock_envvar((char )'1');
    }
#line 208
    return (& undo_unset_envvar);
  }
}
}
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/stdrusty.h"
void *realloc_nofail(void *ptr , size_t size ) ;
#line 42
void *_realloc_array(void *ptr , size_t size , size_t num ) ;
#line 48
void *suck_file(int fd , unsigned long *size ) ;
#line 49
void release_file(void *data , unsigned long size ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/stdrusty.c"
static char buf[2][12UL]  ;
#line 19 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/stdrusty.c"
static int which  ;
#line 15 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/stdrusty.c"
char const   *int_to_string(int val ) 
{ 
  unsigned int ord ;
  unsigned int i ;
  char *p ;
  char *tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 20
  p = buf[which];
#line 22
  if (val < 0) {
#line 23
    tmp = p;
#line 23
    p ++;
#line 23
    *tmp = (char )'-';
#line 24
    val = - val;
  }
#line 27
  i = 0U;
#line 27
  ord = 1000000U;
  {
#line 27
  while (1) {
    while_continue: /* CIL Label */ ;
#line 27
    if (! ord) {
#line 27
      goto while_break;
    }
#line 28
    if ((unsigned int )val >= ord) {
#line 29
      tmp___0 = i;
#line 29
      i ++;
#line 29
      *(p + tmp___0) = (char )(48U + (unsigned int )val / ord);
#line 30
      val = (int )((unsigned int )val % ord);
    } else
#line 28
    if (i != 0U) {
#line 29
      tmp___0 = i;
#line 29
      i ++;
#line 29
      *(p + tmp___0) = (char )(48U + (unsigned int )val / ord);
#line 30
      val = (int )((unsigned int )val % ord);
    }
#line 27
    ord /= 10U;
  }
  while_break: /* CIL Label */ ;
  }
#line 33
  if (i == 0U) {
#line 34
    tmp___1 = i;
#line 34
    i ++;
#line 34
    *(p + tmp___1) = (char )'0';
  }
#line 35
  *(p + i) = (char )'\000';
#line 36
  which = ! which;
#line 37
  return ((char const   *)(buf[! which]));
}
}
#line 40
 __attribute__((__noreturn__)) void fatal(char const   *msg , int err  , ...) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/stdrusty.c"
void fatal(char const   *msg , int err  , ...) 
{ 
  char const   *str ;
  va_list arglist ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char const   *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
  {
#line 45
  tmp = strlen("ccontrol error: ");
#line 45
  write(2, (void const   *)"ccontrol error: ", tmp);
#line 46
  tmp___0 = strlen(msg);
#line 46
  write(2, (void const   *)msg, tmp___0);
#line 48
  __builtin_va_start(arglist, err);
  }
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 49
    tmp___2 = __builtin_va_arg(arglist, char const   *);
#line 49
    str = tmp___2;
    }
#line 49
    if (! ((unsigned long )str != (unsigned long )((void *)0))) {
#line 49
      goto while_break;
    }
    {
#line 50
    tmp___1 = strlen(str);
#line 50
    write(2, (void const   *)str, tmp___1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 51
  __builtin_va_end(arglist);
  }
#line 52
  if (err) {
    {
#line 53
    str = int_to_string(err);
#line 54
    tmp___3 = strlen(": ");
#line 54
    write(2, (void const   *)": ", tmp___3);
#line 55
    tmp___4 = strlen(str);
#line 55
    write(2, (void const   *)str, tmp___4);
    }
  }
  {
#line 57
  write(2, (void const   *)"\n", (size_t )1);
#line 58
  exit(1);
  }
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/stdrusty.c"
void *_realloc_array(void *ptr , size_t size , size_t num ) 
{ 
  void *tmp ;

  {
#line 67
  if (num >= 0xffffffffffffffffUL / size) {
#line 68
    return ((void *)0);
  }
  {
#line 69
  tmp = realloc_nofail(ptr, size * num);
  }
#line 69
  return (tmp);
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/stdrusty.c"
void *realloc_nofail(void *ptr , size_t size ) 
{ 
  int *tmp ;

  {
  {
#line 74
  ptr = realloc(ptr, size);
  }
#line 75
  if (ptr) {
#line 76
    return (ptr);
  }
  {
#line 77
  tmp = __errno_location();
#line 77
  fatal("realloc failed", *tmp, (void *)0);
  }
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/stdrusty.c"
void *suck_file(int fd , unsigned long *size ) 
{ 
  unsigned int max ;
  int ret ;
  int savederr ;
  void *buffer ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 83
  max = 16384U;
#line 84
  savederr = 0;
#line 87
  if (fd < 0) {
#line 88
    return ((void *)0);
  }
  {
#line 90
  buffer = malloc((size_t )(max + 1U));
#line 91
  *size = 0UL;
  }
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 92
    tmp = read(fd, buffer + *size, (unsigned long )max - *size);
#line 92
    ret = (int )tmp;
    }
#line 92
    if (! (ret > 0)) {
#line 92
      goto while_break;
    }
#line 93
    *size += (unsigned long )ret;
#line 94
    if (*size == (unsigned long )max) {
      {
#line 95
      max *= 3U;
#line 95
      buffer = realloc(buffer, (size_t )max);
      }
    } else {
#line 98
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 100
  if (ret < 0) {
    {
#line 101
    tmp___0 = __errno_location();
#line 101
    savederr = *tmp___0;
#line 102
    free(buffer);
#line 103
    buffer = (void *)0;
    }
  } else {
#line 105
    *((char *)buffer + *size) = (char )'\000';
  }
  {
#line 106
  tmp___1 = __errno_location();
#line 106
  *tmp___1 = savederr;
  }
#line 107
  return (buffer);
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/stdrusty.c"
void release_file(void *data , unsigned long size ) 
{ 


  {
  {
#line 112
  free(data);
  }
#line 113
  return;
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 96 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 3 "keywords.gperf"
__inline struct ccontrol_command  const  *find_keyword(char const   *str , unsigned int len ) ;
#line 23
__inline static unsigned int hash_keyword(char const   *str , unsigned int len ) ;
#line 23 "keywords.gperf"
static unsigned char const   asso_values[256]  = 
#line 23
  {      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )10,      (unsigned char const   )28,      (unsigned char const   )0, 
        (unsigned char const   )5,      (unsigned char const   )5,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )20,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )5,      (unsigned char const   )15,      (unsigned char const   )5,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )15,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28, 
        (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28,      (unsigned char const   )28};
#line 14 "keywords.gperf"
__inline static unsigned int hash_keyword(char const   *str , unsigned int len ) 
{ 


  {
#line 52
  return (len + (unsigned int )asso_values[(unsigned char )*(str + 0)]);
}
}
#line 70 "keywords.gperf"
static struct ccontrol_command  const  wordlist[28]  = 
#line 70
  {      {"", 0U}, 
        {"", 0U}, 
        {"cc", (enum token_type )0}, 
        {"c++", (enum token_type )1}, 
        {"cpus", (enum token_type )19}, 
        {"", 0U}, 
        {"ccache", (enum token_type )7}, 
        {"ld", (enum token_type )2}, 
        {"env", (enum token_type )22}, 
        {"nice", (enum token_type )17}, 
        {"", 0U}, 
        {"distcc", (enum token_type )8}, 
        {"disable", (enum token_type )20}, 
        {"add", (enum token_type )21}, 
        {"lock-file", (enum token_type )23}, 
        {"", 0U}, 
        {"no-parallel", (enum token_type )6}, 
        {"distcc-hosts", (enum token_type )9}, 
        {"distc++-hosts", (enum token_type )10}, 
        {"make", (enum token_type )3}, 
        {"", 0U}, 
        {"", 0U}, 
        {"verbose", (enum token_type )16}, 
        {"", 0U}, 
        {"", 0U}, 
        {"", 0U}, 
        {"", 0U}, 
        {"include", (enum token_type )18}};
#line 56 "keywords.gperf"
__inline struct ccontrol_command  const  *find_keyword(char const   *str , unsigned int len ) 
{ 
  register int key ;
  unsigned int tmp ;
  register char const   *s ;
  int tmp___0 ;

  {
#line 32
  if (len <= 13U) {
#line 32
    if (len >= 2U) {
      {
#line 34
      tmp = hash_keyword(str, len);
#line 34
      key = (int )tmp;
      }
#line 36
      if (key <= 27) {
#line 36
        if (key >= 0) {
#line 38
          s = (char const   *)wordlist[key].name;
#line 40
          if ((int const   )*str == (int const   )*s) {
            {
#line 40
            tmp___0 = strncmp(str + 1, s + 1, (size_t )(len - 1U));
            }
#line 40
            if (! tmp___0) {
#line 40
              if ((int const   )*(s + len) == 0) {
#line 41
                return (& wordlist[key]);
              }
            }
          }
        }
      }
    }
  }
#line 44
  return ((struct ccontrol_command  const  *)0);
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-parse.c"
static unsigned int slen(struct string string ) 
{ 


  {
#line 50
  return ((unsigned int )(string.end - string.start));
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-parse.c"
static unsigned int upto(struct string data , char c ) 
{ 
  char *end ;
  unsigned int tmp ;
  void *tmp___0 ;

  {
  {
#line 58
  tmp = slen(data);
#line 58
  tmp___0 = memchr((void const   *)data.start, (int )c, (size_t )tmp);
#line 58
  end = (char *)tmp___0;
  }
#line 59
  if (end) {
#line 60
    return ((unsigned int )((end - data.start) + 1L));
  }
#line 61
  return (0U);
}
}
#line 64
static  __attribute__((__noreturn__)) void parse_error(struct token tok , char const   *str ) ;
#line 64 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-parse.c"
static void parse_error(struct token tok , char const   *str ) 
{ 
  unsigned int line ;
  char *input_head ;
  char const   *tmp ;

  {
#line 67
  line = 1U;
#line 68
  input_head = tok.string.start_of_file;
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! ((unsigned long )input_head < (unsigned long )tok.string.start)) {
#line 71
      goto while_break;
    }
#line 72
    if ((int )*input_head == 10) {
#line 73
      line ++;
    }
#line 74
    input_head ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 76
  tmp = int_to_string((int )line);
#line 76
  fatal("parse error on line ", 0, tmp, ": expected ", str, (void *)0);
  }
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-parse.c"
static _Bool swallow_whitspace(struct string *data ) 
{ 
  _Bool ret ;

  {
#line 82
  ret = (_Bool)0;
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! ((int )*(data->start + 0) == 32)) {
#line 84
      if (! ((int )*(data->start + 0) == 9)) {
#line 84
        goto while_break;
      }
    }
#line 85
    ret = (_Bool)1;
#line 86
    (data->start) ++;
#line 87
    if ((unsigned long )data->start == (unsigned long )data->end) {
#line 88
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  return (ret);
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-parse.c"
static struct string get_string(struct string *data ) 
{ 
  struct string str ;

  {
#line 96
  str.start_of_file = data->start_of_file;
#line 97
  str.start = data->start;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if ((unsigned long )data->start != (unsigned long )data->end) {
#line 98
      if ((int )*(data->start) != 61) {
#line 98
        if ((int )*(data->start) != 91) {
#line 98
          if ((int )*(data->start) != 93) {
#line 98
            if ((int )*(data->start) != 32) {
#line 98
              if ((int )*(data->start) != 10) {
#line 98
                if (! ((int )*(data->start) != 9)) {
#line 98
                  goto while_break;
                }
              } else {
#line 98
                goto while_break;
              }
            } else {
#line 98
              goto while_break;
            }
          } else {
#line 98
            goto while_break;
          }
        } else {
#line 98
          goto while_break;
        }
      } else {
#line 98
        goto while_break;
      }
    } else {
#line 98
      goto while_break;
    }
#line 105
    (data->start) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  str.end = data->start;
#line 107
  return (str);
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-parse.c"
static struct token single_digit_token(struct string data , enum token_type type ) 
{ 
  struct token __constr_expr_3 ;

  {
#line 113
  __constr_expr_3.type = type;
#line 113
  __constr_expr_3.string.start = data.start;
#line 113
  __constr_expr_3.string.end = data.start + 1;
#line 113
  __constr_expr_3.string.start_of_file = data.start_of_file;
#line 113
  return (__constr_expr_3);
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-parse.c"
static struct token peek_token(struct string data ) 
{ 
  struct token tok ;
  unsigned int num ;
  _Bool new_line ;
  struct ccontrol_command  const  *cmd ;
  char *start ;
  unsigned int tmp ;
  _Bool tmp___0 ;
  struct token tmp___1 ;
  struct token tmp___2 ;
  struct token tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int i ;
  unsigned short const   **tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;

  {
#line 121
  new_line = (_Bool )((unsigned long )data.start == (unsigned long )data.start_of_file);
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! ((unsigned long )data.start != (unsigned long )data.end)) {
#line 124
      goto while_break;
    }
#line 128
    if ((int )*(data.start + 0) == 10) {
#line 129
      new_line = (_Bool)1;
#line 130
      (data.start) ++;
#line 131
      goto while_continue;
    }
    {
#line 135
    start = data.start;
#line 136
    tmp___0 = swallow_whitspace(& data);
    }
#line 136
    if (tmp___0) {
#line 136
      if (new_line) {
        {
#line 137
        tmp = slen(data);
        }
#line 137
        if (tmp) {
#line 138
          if ((int )*(data.start + 0) == 10) {
#line 139
            goto while_continue;
          } else
#line 138
          if ((int )*(data.start + 0) == 35) {
#line 139
            goto while_continue;
          }
#line 141
          tok.type = (enum token_type )5;
#line 142
          tok.string.start_of_file = data.start_of_file;
#line 143
          tok.string.start = start;
#line 144
          tok.string.end = data.start;
#line 145
          return (tok);
        }
      }
    }
#line 150
    if ((int )*(data.start + 0) == 35) {
      {
#line 151
      num = upto(data, (char )'\n');
      }
#line 152
      if (! num) {
#line 153
        goto while_break;
      }
#line 154
      data.start += num;
#line 155
      new_line = (_Bool)1;
#line 156
      goto while_continue;
    }
#line 159
    if ((int )*(data.start + 0) == 91) {
      {
#line 160
      tmp___1 = single_digit_token(data, (enum token_type )11);
      }
#line 160
      return (tmp___1);
    }
#line 162
    if ((int )*(data.start + 0) == 93) {
      {
#line 163
      tmp___2 = single_digit_token(data, (enum token_type )12);
      }
#line 163
      return (tmp___2);
    }
#line 165
    if ((int )*(data.start + 0) == 61) {
      {
#line 166
      tmp___3 = single_digit_token(data, (enum token_type )13);
      }
#line 166
      return (tmp___3);
    }
    {
#line 168
    tok.string = get_string(& data);
#line 169
    tmp___4 = slen(tok.string);
#line 169
    cmd = find_keyword((char const   *)tok.string.start, tmp___4);
    }
#line 170
    if (cmd) {
#line 171
      tok.type = (enum token_type )cmd->type;
    } else {
#line 176
      i = 0U;
      {
#line 176
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 176
        tmp___6 = slen(tok.string);
        }
#line 176
        if (! (i < tmp___6)) {
#line 176
          goto while_break___0;
        }
        {
#line 177
        tmp___5 = __ctype_b_loc();
        }
#line 177
        if (! ((int const   )*(*tmp___5 + (int )*(tok.string.start + i)) & 2048)) {
#line 177
          if (! ((int )*(tok.string.start + i) == 45)) {
#line 179
            goto while_break___0;
          }
        }
#line 176
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 180
      if (i > 0U) {
        {
#line 180
        tmp___7 = slen(tok.string);
        }
#line 180
        if (i == tmp___7) {
#line 181
          tok.type = (enum token_type )14;
        } else {
#line 183
          tok.type = (enum token_type )15;
        }
      } else {
#line 183
        tok.type = (enum token_type )15;
      }
    }
#line 185
    return (tok);
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  tok.type = (enum token_type )24;
#line 189
  tok.string = data;
#line 190
  return (tok);
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-parse.c"
static void swallow_token(struct string *data , struct token tok ) 
{ 


  {
#line 195
  data->start = tok.string.end;
#line 196
  return;
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-parse.c"
static struct token get_token(struct string *data ) 
{ 
  struct token tok ;
  struct token tmp ;

  {
  {
#line 200
  tmp = peek_token(*data);
#line 200
  tok = tmp;
#line 201
  swallow_token(data, tok);
  }
#line 202
  return (tok);
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-parse.c"
static struct token get_value(struct string *data ) 
{ 
  struct token tok ;
  struct token tmp ;

  {
  {
#line 210
  tok = peek_token(*data);
  }
#line 211
  if ((unsigned int )tok.type == 13U) {
    {
#line 212
    swallow_token(data, tok);
#line 213
    tmp = get_token(data);
    }
#line 213
    return (tmp);
  }
#line 215
  tok.type = (enum token_type )4;
#line 216
  tok.string.start = data->start;
#line 217
  tok.string.end = data->start;
#line 218
  return (tok);
}
}
#line 221 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-parse.c"
static int to_int(struct token tok , int min , int max ) 
{ 
  int num ;

  {
#line 224
  if ((unsigned int )tok.type != 14U) {
    {
#line 225
    parse_error(tok, "\'= some-number\'");
    }
  }
  {
#line 227
  num = atoi((char const   *)tok.string.start);
  }
#line 228
  if (num < min) {
    {
#line 229
    parse_error(tok, "\'= number in valid range\'");
    }
  } else
#line 228
  if (num > max) {
    {
#line 229
    parse_error(tok, "\'= number in valid range\'");
    }
  }
#line 230
  return (num);
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-parse.c"
char *resolve_path(char const   *configured_path , char const   *cmdname ) 
{ 
  struct stat st ;
  char const   *basename ;
  char *execcmd ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  size_t tmp___6 ;

  {
#line 248
  if ((int const   )*(configured_path + 0) != 47) {
    {
#line 251
    tmp = strdup(configured_path);
    }
#line 251
    return (tmp);
  } else {
    {
#line 248
    tmp___0 = stat((char const   */* __restrict  */)configured_path, (struct stat */* __restrict  */)(& st));
    }
#line 248
    if (tmp___0 == -1) {
      {
#line 251
      tmp = strdup(configured_path);
      }
#line 251
      return (tmp);
    } else
#line 248
    if (! ((st.st_mode & 61440U) == 16384U)) {
      {
#line 251
      tmp = strdup(configured_path);
      }
#line 251
      return (tmp);
    }
  }
  {
#line 253
  tmp___1 = strrchr(cmdname, '/');
#line 253
  basename = (char const   *)tmp___1;
  }
#line 254
  if (basename) {
#line 255
    basename ++;
  } else {
#line 257
    basename = cmdname;
  }
  {
#line 259
  tmp___2 = strlen(configured_path);
#line 259
  tmp___3 = strlen(basename);
#line 259
  tmp___4 = malloc((tmp___2 + tmp___3) + 2UL);
#line 259
  execcmd = (char *)tmp___4;
  }
#line 260
  if (! execcmd) {
    {
#line 261
    tmp___5 = __errno_location();
#line 261
    fatal("Cannot allocate memory for command", *tmp___5);
    }
  }
  {
#line 264
  tmp___6 = strlen(configured_path);
#line 264
  memcpy((void */* __restrict  */)execcmd, (void const   */* __restrict  */)configured_path,
         tmp___6 + 1UL);
#line 265
  strcat((char */* __restrict  */)execcmd, (char const   */* __restrict  */)"/");
#line 266
  strcat((char */* __restrict  */)execcmd, (char const   */* __restrict  */)basename);
  }
#line 268
  return (execcmd);
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-parse.c"
static char *get_path(struct string *data ) 
{ 
  char *p ;
  char const   *prefix ;
  struct token tok ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  unsigned int tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  unsigned int tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  unsigned int tmp___9 ;

  {
  {
#line 275
  prefix = "";
#line 278
  tok = get_value(data);
  }
#line 279
  if ((unsigned int )tok.type != 15U) {
    {
#line 280
    parse_error(tok, "\'= some-path\'");
    }
  }
#line 282
  if ((int )*(tok.string.start + 0) == 126) {
    {
#line 283
    tmp___1 = getenv("HOME");
#line 283
    tmp___0 = (char const   *)tmp___1;
    }
#line 283
    if (! tmp___0) {
#line 283
      tmp___0 = "";
    }
#line 283
    prefix = tmp___0;
#line 284
    (tok.string.start) ++;
  }
  {
#line 287
  tmp___2 = strlen(prefix);
#line 287
  tmp___3 = slen(tok.string);
#line 287
  tmp___4 = _realloc_array((void *)((char *)0), sizeof(*((char *)0)), (tmp___2 + (size_t )tmp___3) + 1UL);
#line 287
  p = (char *)tmp___4;
#line 288
  tmp___5 = strlen(prefix);
#line 288
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)prefix, tmp___5);
#line 289
  tmp___6 = slen(tok.string);
#line 289
  tmp___7 = strlen(prefix);
#line 289
  memcpy((void */* __restrict  */)(p + tmp___7), (void const   */* __restrict  */)tok.string.start,
         (size_t )tmp___6);
#line 290
  tmp___8 = strlen(prefix);
#line 290
  tmp___9 = slen(tok.string);
#line 290
  *(p + (tmp___8 + (size_t )tmp___9)) = (char )'\000';
  }
#line 292
  return (p);
}
}
#line 295 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-parse.c"
static char *get_optional_path(struct string *data ) 
{ 
  struct token tok ;
  char *tmp ;

  {
  {
#line 299
  tok = peek_token(*data);
  }
#line 300
  if ((unsigned int )tok.type == 20U) {
    {
#line 301
    swallow_token(data, tok);
    }
#line 302
    return ((char *)((void *)0));
  }
  {
#line 305
  tmp = get_path(data);
  }
#line 305
  return (tmp);
}
}
#line 309 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-parse.c"
static char *get_to_eol(struct string *data , char const   *expect ) 
{ 
  char *p ;
  unsigned int len ;
  struct token tok ;
  struct token tok___0 ;
  void *tmp ;

  {
  {
#line 315
  tok = get_token(data);
  }
#line 316
  if ((unsigned int )tok.type == 20U) {
#line 317
    return ((char *)((void *)0));
  }
#line 318
  if ((unsigned int )tok.type != 13U) {
    {
#line 319
    parse_error(tok, expect);
    }
  }
  {
#line 321
  swallow_whitspace(data);
#line 322
  len = upto(*data, (char )'\n');
  }
#line 323
  if (! len) {
    {
#line 326
    tok___0.type = (enum token_type )24;
#line 327
    tok___0.string = *data;
#line 328
    parse_error(tok___0, "something");
    }
  }
  {
#line 332
  tmp = malloc((size_t )len);
#line 332
  p = (char *)tmp;
#line 333
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)data->start,
         (size_t )len);
#line 334
  *(p + (len - 1U)) = (char )'\000';
#line 337
  data->start += len - 1U;
  }
#line 339
  return (p);
}
}
#line 342 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-parse.c"
static struct add *new_add(char *arg , struct add *next ) 
{ 
  struct add *add ;
  void *tmp ;

  {
  {
#line 344
  tmp = malloc(sizeof(struct add ));
#line 344
  add = (struct add *)tmp;
#line 345
  add->arg = arg;
#line 346
  add->next = next;
  }
#line 347
  return (add);
}
}
#line 350
static void read_section_file(char const   *configname , struct section *sec ) ;
#line 353 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-parse.c"
static void read_section_section(struct string *data , struct section *sec ) 
{ 
  struct token tok ;
  struct add **add ;
  char *p ;
  struct token tmp ;
  int tmp___0 ;
  struct token tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 359
    tok = peek_token(*data);
    }
#line 359
    if (! ((unsigned int )tok.type == 5U)) {
#line 359
      goto while_break;
    }
    {
#line 360
    swallow_token(data, tok);
#line 361
    tok = get_token(data);
    }
    {
#line 364
    if ((unsigned int )tok.type == 6U) {
#line 364
      goto case_6;
    }
#line 370
    if ((unsigned int )tok.type == 19U) {
#line 370
      goto case_19;
    }
#line 373
    if ((unsigned int )tok.type == 7U) {
#line 373
      goto case_7;
    }
#line 376
    if ((unsigned int )tok.type == 8U) {
#line 376
      goto case_8;
    }
#line 379
    if ((unsigned int )tok.type == 9U) {
#line 379
      goto case_9;
    }
#line 384
    if ((unsigned int )tok.type == 10U) {
#line 384
      goto case_10;
    }
#line 389
    if ((unsigned int )tok.type == 16U) {
#line 389
      goto case_16;
    }
#line 392
    if ((unsigned int )tok.type == 17U) {
#line 392
      goto case_17;
    }
#line 398
    if ((unsigned int )tok.type == 3U) {
#line 398
      goto case_3;
    }
#line 398
    if ((unsigned int )tok.type == 2U) {
#line 398
      goto case_3;
    }
#line 398
    if ((unsigned int )tok.type == 1U) {
#line 398
      goto case_3;
    }
#line 398
    if ((unsigned int )tok.type == 0U) {
#line 398
      goto case_3;
    }
#line 401
    if ((unsigned int )tok.type == 18U) {
#line 401
      goto case_18;
    }
#line 404
    if ((unsigned int )tok.type == 21U) {
#line 404
      goto case_21;
    }
#line 422
    if ((unsigned int )tok.type == 23U) {
#line 422
      goto case_23;
    }
#line 430
    goto switch_default___0;
    case_6: /* CIL Label */ 
    {
#line 365
    sec->no_parallel = get_to_eol(data, "= targets");
    }
#line 367
    if (! sec->no_parallel) {
      {
#line 368
      unsetenv("CCONTROL_NO_PARALLEL");
      }
    }
#line 369
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 371
    tmp = get_value(data);
#line 371
    tmp___0 = to_int(tmp, 1, 1000000);
#line 371
    sec->cpus = (unsigned int )tmp___0;
    }
#line 372
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 374
    sec->ccache = get_optional_path(data);
    }
#line 375
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 377
    sec->distcc = get_optional_path(data);
    }
#line 378
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 380
    sec->distcc_hosts = get_to_eol(data, "= some-hosts");
    }
#line 381
    if (! sec->distcplusplus_hosts_set) {
#line 382
      sec->distcplusplus_hosts = sec->distcc_hosts;
    }
#line 383
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 385
    sec->distcplusplus_hosts = get_to_eol(data, "= some-hosts");
#line 387
    sec->distcplusplus_hosts_set = (_Bool)1;
    }
#line 388
    goto switch_break;
    case_16: /* CIL Label */ 
#line 390
    sec->verbose = (_Bool)1;
#line 391
    goto switch_break;
    case_17: /* CIL Label */ 
    {
#line 393
    tmp___1 = get_value(data);
#line 393
    sec->nice = to_int(tmp___1, -19, 20);
    }
#line 394
    goto switch_break;
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
#line 399
    sec->names[tok.type] = get_path(data);
    }
#line 400
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 402
    tmp___2 = get_path(data);
#line 402
    read_section_file((char const   *)tmp___2, sec);
    }
#line 403
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 405
    tok = get_token(data);
    }
    {
#line 407
    if ((unsigned int )tok.type == 3U) {
#line 407
      goto case_3___0;
    }
#line 410
    if ((unsigned int )tok.type == 22U) {
#line 410
      goto case_22;
    }
#line 413
    goto switch_default;
    case_3___0: /* CIL Label */ 
#line 408
    add = & sec->make_add;
#line 409
    goto switch_break___0;
    case_22: /* CIL Label */ 
#line 411
    add = & sec->env_add;
#line 412
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 414
    parse_error(tok, "make or env");
    }
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 416
    p = get_to_eol(data, "= argument");
    }
#line 417
    if (! p) {
#line 418
      *add = (struct add *)((void *)0);
    } else {
      {
#line 420
      *add = new_add(p, *add);
      }
    }
#line 421
    goto switch_break;
    case_23: /* CIL Label */ 
    {
#line 423
    sec->lock_file = get_path(data);
#line 424
    sec->lock_fd = open((char const   *)sec->lock_file, 66, 384);
    }
#line 426
    if (sec->lock_fd < 0) {
      {
#line 427
      tmp___3 = __errno_location();
#line 427
      fatal("could not open lock file: ", *tmp___3, sec->lock_file, (void *)0);
      }
    }
#line 429
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 431
    parse_error(tok, "some instruction");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 434
  return;
}
}
#line 436 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-parse.c"
static void read_section_file(char const   *configname , struct section *sec ) 
{ 
  unsigned long len ;
  struct string data ;
  int tmp ;
  void *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 441
  tmp = open(configname, 0);
#line 441
  tmp___0 = suck_file(tmp, & len);
#line 441
  data.start_of_file = (char *)tmp___0;
  }
#line 442
  if (! data.start_of_file) {
    {
#line 443
    tmp___1 = __errno_location();
#line 443
    fatal("reading included file ", *tmp___1, configname, (void *)0);
    }
  }
  {
#line 444
  data.start = data.start_of_file;
#line 445
  data.end = data.start_of_file + len;
#line 447
  read_section_section(& data, sec);
  }
#line 448
  return;
}
}
#line 450 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-parse.c"
static _Bool read_section(struct string *data , struct section *sec ) 
{ 
  struct token tok ;
  struct token tmp ;

  {
  {
#line 452
  tmp = get_token(data);
#line 452
  tok = tmp;
  }
#line 454
  if ((unsigned int )tok.type == 24U) {
#line 455
    return ((_Bool)0);
  }
#line 457
  if ((unsigned int )tok.type != 11U) {
    {
#line 458
    parse_error(tok, "\'[\' to start new section");
    }
  }
  {
#line 460
  tok = get_token(data);
  }
#line 461
  if ((unsigned int )tok.type != 15U) {
    {
#line 462
    parse_error(tok, "path after \'[\' in section start");
    }
  }
  {
#line 463
  sec->name = tok.string;
#line 465
  tok = get_token(data);
  }
#line 466
  if ((unsigned int )tok.type != 12U) {
    {
#line 467
    parse_error(tok, "\']\' after name in section start");
    }
  }
  {
#line 469
  read_section_section(data, sec);
  }
#line 471
  return ((_Bool)1);
}
}
#line 478 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-parse.c"
static _Bool section_matches(char const   *dirname , struct section sec ) 
{ 
  unsigned int len ;
  unsigned int tmp ;
  char *pattern ;
  unsigned long __lengthofpattern ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 480
  tmp = slen(sec.name);
#line 480
  len = tmp;
#line 481
  __lengthofpattern = (unsigned long )(len + 2U);
#line 481
  tmp___0 = __builtin_alloca(sizeof(*pattern) * __lengthofpattern);
#line 481
  pattern = (char *)tmp___0;
  }
#line 484
  if (len == 0U) {
#line 485
    return ((_Bool)1);
  }
  {
#line 487
  memcpy((void */* __restrict  */)pattern, (void const   */* __restrict  */)sec.name.start,
         (size_t )len);
  }
#line 489
  if ((int )*(pattern + (len - 1U)) == 42) {
#line 490
    *(pattern + len) = (char )'\000';
  } else {
#line 492
    *(pattern + len) = (char )'*';
#line 493
    *(pattern + (len + 1U)) = (char )'\000';
  }
  {
#line 495
  tmp___1 = fnmatch((char const   *)pattern, dirname, 0);
  }
#line 495
  return ((_Bool )(tmp___1 == 0));
}
}
#line 498 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-parse.c"
static struct section get_default(int fd ) 
{ 
  struct section def ;

  {
#line 500
  def.name.start = (char *)0;
#line 500
  def.name.end = (char *)0;
#line 500
  def.name.start_of_file = (char *)0;
#line 500
  def.verbose = (_Bool)0;
#line 500
  def.nice = 10;
#line 500
  def.cpus = 1U;
#line 500
  def.no_parallel = (char *)0;
#line 500
  def.names[0] = (char *)0;
#line 500
  def.names[1] = (char *)0;
#line 500
  def.names[2] = (char *)0;
#line 500
  def.names[3] = (char *)0;
#line 500
  def.ccache = (char *)0;
#line 500
  def.distcc = (char *)0;
#line 500
  def.distcc_hosts = (char *)0;
#line 500
  def.distcplusplus_hosts_set = (_Bool)0;
#line 500
  def.distcplusplus_hosts = (char *)0;
#line 500
  def.make_add = (struct add *)0;
#line 500
  def.env_add = (struct add *)0;
#line 500
  def.lock_fd = 0;
#line 500
  def.lock_file = (char *)0;
#line 503
  def.lock_fd = fd;
#line 504
  return (def);
}
}
#line 507 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-parse.c"
static void read_config_file(char const   *configname , int fd , char const   *dirname ,
                             struct section *result ) 
{ 
  unsigned long len ;
  struct string data ;
  void *tmp ;
  int *tmp___0 ;
  struct section sec ;
  struct token tok ;
  char *included ;
  int incfd ;
  _Bool tmp___1 ;
  unsigned int len___0 ;
  unsigned int tmp___2 ;
  char *str ;
  unsigned long __lengthofstr ;
  void *tmp___3 ;
  _Bool tmp___4 ;
  char *rawccache ;
  char *rawdistcc ;

  {
  {
#line 514
  tmp = suck_file(fd, & len);
#line 514
  data.start_of_file = (char *)tmp;
  }
#line 515
  if (! data.start_of_file) {
    {
#line 516
    tmp___0 = __errno_location();
#line 516
    fatal("reading ", *tmp___0, configname, (void *)0);
    }
  }
#line 517
  data.start = data.start_of_file;
#line 518
  data.end = data.start_of_file + len;
  {
#line 521
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 522
    sec = *result;
#line 525
    tok = peek_token(data);
    }
#line 526
    if ((unsigned int )tok.type == 18U) {
      {
#line 529
      swallow_token(& data, tok);
#line 531
      included = get_path(& data);
#line 532
      incfd = open((char const   *)included, 0);
#line 533
      read_config_file((char const   *)included, incfd, dirname, result);
#line 534
      close(incfd);
      }
#line 535
      goto __Cont;
    }
    {
#line 538
    tmp___1 = read_section(& data, & sec);
    }
#line 538
    if (! tmp___1) {
#line 539
      goto while_break;
    }
    {
#line 541
    tmp___4 = section_matches(dirname, sec);
    }
#line 541
    if (tmp___4) {
#line 542
      if (sec.verbose) {
        {
#line 543
        tmp___2 = slen(sec.name);
#line 543
        len___0 = tmp___2;
#line 544
        __lengthofstr = (unsigned long )(len___0 + 1U);
#line 544
        tmp___3 = __builtin_alloca(sizeof(*str) * __lengthofstr);
#line 544
        str = (char *)tmp___3;
#line 545
        memcpy((void */* __restrict  */)str, (void const   */* __restrict  */)sec.name.start,
               (size_t )len___0);
#line 546
        *(str + len___0) = (char )'\000';
        }
        {
#line 547
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 547
          if (sec.verbose) {
            {
#line 547
            __verbose("Using section ", str, (void *)0);
            }
          }
#line 547
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 549
      *result = sec;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 554
  if (result->ccache) {
    {
#line 555
    rawccache = result->ccache;
#line 556
    result->ccache = resolve_path((char const   *)result->ccache, "ccache");
#line 557
    free((void *)rawccache);
    }
  }
#line 561
  if (result->distcc) {
    {
#line 562
    rawdistcc = result->distcc;
#line 563
    result->distcc = resolve_path((char const   *)result->distcc, "distcc");
#line 564
    free((void *)rawdistcc);
    }
  }
  {
#line 567
  free((void *)data.start_of_file);
  }
#line 568
  return;
}
}
#line 570 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-parse.c"
struct section read_config(char const   *configname , char const   *dir , int fd ) 
{ 
  struct section result ;

  {
  {
#line 574
  result = get_default(fd);
#line 575
  read_config_file(configname, fd, dir, & result);
  }
#line 576
  return (result);
}
}
#line 5 "extensions.gperf"
__inline char const   *find_extension(char const   *str , unsigned int len ) ;
#line 19
__inline static unsigned int hash_extension(char const   *str , unsigned int len ) ;
#line 19 "extensions.gperf"
static unsigned char const   asso_values___0[256]  = 
#line 19
  {      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )10, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )30, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )25,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )20, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )10, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )5,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )5,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )15, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )0,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )32};
#line 10 "extensions.gperf"
__inline static unsigned int hash_extension(char const   *str , unsigned int len ) 
{ 
  register int hval ;

  {
#line 48
  hval = (int )len;
  {
#line 55
  if (hval == 1) {
#line 55
    goto case_1;
  }
#line 52
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 53
  hval += (int )asso_values___0[(unsigned char )*(str + 1)];
  case_1: /* CIL Label */ 
#line 56
  hval += (int )asso_values___0[(unsigned char )*(str + 0)];
#line 57
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 59
  return ((unsigned int )hval);
}
}
#line 77 "extensions.gperf"
static char const   * const  wordlist___0[32]  = 
#line 77
  {      (char const   */* const  */)"",      (char const   */* const  */)"m",      (char const   */* const  */)"mm",      (char const   */* const  */)"", 
        (char const   */* const  */)"",      (char const   */* const  */)"",      (char const   */* const  */)"i",      (char const   */* const  */)"mi", 
        (char const   */* const  */)"mii",      (char const   */* const  */)"",      (char const   */* const  */)"",      (char const   */* const  */)"c", 
        (char const   */* const  */)"ii",      (char const   */* const  */)"cxx",      (char const   */* const  */)"",      (char const   */* const  */)"", 
        (char const   */* const  */)"s",      (char const   */* const  */)"cp",      (char const   */* const  */)"cpp",      (char const   */* const  */)"", 
        (char const   */* const  */)"",      (char const   */* const  */)"S",      (char const   */* const  */)"cc",      (char const   */* const  */)"c++", 
        (char const   */* const  */)"",      (char const   */* const  */)"",      (char const   */* const  */)"M",      (char const   */* const  */)"", 
        (char const   */* const  */)"",      (char const   */* const  */)"",      (char const   */* const  */)"",      (char const   */* const  */)"C"};
#line 63 "extensions.gperf"
__inline char const   *find_extension(char const   *str , unsigned int len ) 
{ 
  register int key ;
  unsigned int tmp ;
  register char const   *s ;
  int tmp___0 ;

  {
#line 104
  if (len <= 3U) {
#line 104
    if (len >= 1U) {
      {
#line 106
      tmp = hash_extension(str, len);
#line 106
      key = (int )tmp;
      }
#line 108
      if (key <= 31) {
#line 108
        if (key >= 0) {
#line 110
          s = (char const   *)wordlist___0[key];
#line 112
          if ((int const   )*str == (int const   )*s) {
            {
#line 112
            tmp___0 = strcmp(str + 1, s + 1);
            }
#line 112
            if (! tmp___0) {
#line 113
              return (s);
            }
          }
        }
      }
    }
  }
#line 116
  return ((char const   *)0);
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-identify.c"
static _Bool is_source(char const   *sfile ) 
{ 
  char const   *dot ;
  char *tmp ;
  size_t tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 11
  tmp = strrchr(sfile, '.');
#line 11
  dot = (char const   *)tmp;
  }
#line 12
  if (! dot) {
#line 13
    return ((_Bool)0);
  }
  {
#line 15
  tmp___0 = strlen(dot + 1);
#line 15
  tmp___1 = find_extension(dot + 1, (unsigned int )tmp___0);
  }
#line 15
  return ((_Bool )((unsigned long )tmp___1 != (unsigned long )((void *)0)));
}
}
#line 19 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-identify.c"
_Bool can_distcc(char **argv ) 
{ 
  unsigned int i ;
  char *a ;
  char *input_file ;
  char *output_file ;
  _Bool seen_opt_s ;
  _Bool seen_opt_c ;
  _Bool tmp ;
  _Bool tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;

  {
#line 22
  input_file = (char *)((void *)0);
#line 22
  output_file = (char *)((void *)0);
#line 23
  seen_opt_s = (_Bool)0;
#line 23
  seen_opt_c = (_Bool)0;
#line 27
  i = 1U;
  {
#line 27
  while (1) {
    while_continue: /* CIL Label */ ;
#line 27
    a = *(argv + i);
#line 27
    if (! a) {
#line 27
      goto while_break;
    }
#line 28
    if ((int )*(a + 0) != 45) {
      {
#line 29
      tmp___0 = is_source((char const   *)a);
      }
#line 29
      if (tmp___0) {
#line 30
        if (input_file) {
#line 31
          return ((_Bool)0);
        }
#line 32
        input_file = a;
      } else {
        {
#line 33
        tmp = strends((char const   *)a, ".o");
        }
#line 33
        if (tmp) {
          got_output: 
#line 35
          if (output_file) {
#line 36
            return ((_Bool)0);
          }
#line 37
          output_file = a;
        }
      }
    } else {
      {
#line 40
      tmp___23 = strcmp((char const   *)a, "-E");
      }
#line 40
      if (tmp___23 == 0) {
#line 41
        return ((_Bool)0);
      } else {
        {
#line 42
        tmp___19 = strcmp((char const   *)a, "-MD");
        }
#line 42
        if (! (tmp___19 == 0)) {
          {
#line 42
          tmp___20 = strcmp((char const   *)a, "-MMD");
          }
#line 42
          if (! (tmp___20 == 0)) {
            {
#line 42
            tmp___21 = strcmp((char const   *)a, "-MG");
            }
#line 42
            if (! (tmp___21 == 0)) {
              {
#line 42
              tmp___22 = strcmp((char const   *)a, "-MP");
              }
#line 42
              if (! (tmp___22 == 0)) {
                {
#line 45
                tmp___16 = strcmp((char const   *)a, "-MF");
                }
#line 45
                if (tmp___16 == 0) {
#line 47
                  i ++;
                } else {
                  {
#line 45
                  tmp___17 = strcmp((char const   *)a, "-MT");
                  }
#line 45
                  if (tmp___17 == 0) {
#line 47
                    i ++;
                  } else {
                    {
#line 45
                    tmp___18 = strcmp((char const   *)a, "-MQ");
                    }
#line 45
                    if (tmp___18 == 0) {
#line 47
                      i ++;
                    } else
#line 48
                    if ((int )*(a + 1) == 77) {
#line 49
                      return ((_Bool)0);
                    } else {
                      {
#line 50
                      tmp___15 = strstr((char const   *)a, "-Wa,");
                      }
#line 50
                      if (tmp___15) {
                        {
#line 51
                        tmp___1 = strstr((char const   *)a, ",-a");
                        }
#line 51
                        if (tmp___1) {
#line 52
                          return ((_Bool)0);
                        } else {
                          {
#line 51
                          tmp___2 = strstr((char const   *)a, "--MD");
                          }
#line 51
                          if (tmp___2) {
#line 52
                            return ((_Bool)0);
                          }
                        }
                      } else {
                        {
#line 53
                        tmp___13 = strlen("-specs=");
#line 53
                        tmp___14 = strncmp((char const   *)a, "-specs=", tmp___13);
                        }
#line 53
                        if (tmp___14 == 0) {
#line 54
                          return ((_Bool)0);
                        } else {
                          {
#line 55
                          tmp___12 = strcmp((char const   *)a, "-S");
                          }
#line 55
                          if (tmp___12 == 0) {
#line 56
                            seen_opt_s = (_Bool)1;
                          } else {
                            {
#line 57
                            tmp___9 = strcmp((char const   *)a, "-fprofile-arcs");
                            }
#line 57
                            if (tmp___9 == 0) {
#line 60
                              return ((_Bool)0);
                            } else {
                              {
#line 57
                              tmp___10 = strcmp((char const   *)a, "-ftest-coverage");
                              }
#line 57
                              if (tmp___10 == 0) {
#line 60
                                return ((_Bool)0);
                              } else {
                                {
#line 57
                                tmp___11 = strcmp((char const   *)a, "-frepo");
                                }
#line 57
                                if (tmp___11 == 0) {
#line 60
                                  return ((_Bool)0);
                                } else {
                                  {
#line 61
                                  tmp___7 = strlen("-x");
#line 61
                                  tmp___8 = strncmp((char const   *)a, "-x", tmp___7);
                                  }
#line 61
                                  if (tmp___8 == 0) {
#line 62
                                    return ((_Bool)0);
                                  } else {
                                    {
#line 63
                                    tmp___6 = strcmp((char const   *)a, "-c");
                                    }
#line 63
                                    if (tmp___6 == 0) {
#line 64
                                      seen_opt_c = (_Bool)1;
                                    } else {
                                      {
#line 65
                                      tmp___5 = strcmp((char const   *)a, "-o");
                                      }
#line 65
                                      if (tmp___5 == 0) {
#line 66
                                        i ++;
#line 66
                                        a = *(argv + i);
#line 67
                                        goto got_output;
                                      } else {
                                        {
#line 68
                                        tmp___3 = strlen("-o");
#line 68
                                        tmp___4 = strncmp((char const   *)a, "-o",
                                                          tmp___3);
                                        }
#line 68
                                        if (tmp___4 == 0) {
#line 69
                                          a += 2;
#line 70
                                          goto got_output;
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 27
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  if (! seen_opt_c) {
#line 75
    if (! seen_opt_s) {
#line 76
      return ((_Bool)0);
    }
  }
#line 78
  if (! input_file) {
#line 79
    return ((_Bool)0);
  }
#line 80
  return ((_Bool)1);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/ccontrol-1.0/ccontrol-identify.c"
enum type what_am_i(char **argv ) 
{ 
  char const   *basename ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 86
  tmp = strrchr((char const   *)*(argv + 0), '/');
#line 86
  basename = (char const   *)tmp;
  }
#line 87
  if (! basename) {
#line 88
    basename = (char const   *)*(argv + 0);
  }
  {
#line 90
  tmp___3 = strstr(basename, "cc");
  }
#line 90
  if (tmp___3) {
#line 91
    return ((enum type )0);
  } else {
    {
#line 92
    tmp___2 = strstr(basename, "++");
    }
#line 92
    if (tmp___2) {
#line 93
      return ((enum type )1);
    } else {
      {
#line 94
      tmp___1 = strstr(basename, "ld");
      }
#line 94
      if (tmp___1) {
#line 95
        return ((enum type )2);
      } else {
        {
#line 96
        tmp___0 = strstr(basename, "make");
        }
#line 96
        if (tmp___0) {
#line 97
          return ((enum type )3);
        } else {
#line 99
          return ((enum type )4);
        }
      }
    }
  }
}
}
