/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 23 "./bitstring.h"
typedef unsigned char bitstr_t;
#line 172 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.h"
struct _entry {
   struct _entry *next ;
   uid_t uid ;
   gid_t gid ;
   char **envp ;
   char *cmd ;
   bitstr_t minute[(59 >> 3) + 1] ;
   bitstr_t hour[(23 >> 3) + 1] ;
   bitstr_t dom[(30 >> 3) + 1] ;
   bitstr_t month[(11 >> 3) + 1] ;
   bitstr_t dow[(7 >> 3) + 1] ;
   int flags ;
};
#line 172 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.h"
typedef struct _entry entry;
#line 203 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/popen.c"
union __anonunion_55 {
   int __in ;
   int __i ;
};
#line 205 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/popen.c"
union __anonunion_56 {
   int __in ;
   int __i ;
};
#line 132 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/env.c"
enum env_state {
    NAMEI = 0,
    NAME = 1,
    EQ1 = 2,
    EQ2 = 3,
    VALUEI = 4,
    VALUE = 5,
    FINI = 6,
    ERROR = 7
} ;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 198 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.h"
struct _user {
   struct _user *next ;
   struct _user *prev ;
   char *name ;
   time_t mtime ;
   entry *crontab ;
};
#line 198 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.h"
typedef struct _user user;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 208 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.h"
struct _cron_db {
   user *head ;
   user *tail ;
   time_t user_mtime ;
   time_t sys_mtime ;
   time_t sysd_mtime ;
};
#line 208 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.h"
typedef struct _cron_db cron_db;
#line 217 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.h"
struct _orphan {
   struct _orphan *next ;
   char *uname ;
   char *fname ;
   char *tabname ;
};
#line 217 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.h"
typedef struct _orphan orphan;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *__buffer ;
   unsigned long __allocated ;
   unsigned long __used ;
   reg_syntax_t __syntax ;
   char *__fastmap ;
   unsigned char *__translate ;
   size_t re_nsub ;
   unsigned int __can_be_null : 1 ;
   unsigned int __regs_allocated : 2 ;
   unsigned int __fastmap_accurate : 1 ;
   unsigned int __no_sub : 1 ;
   unsigned int __not_bol : 1 ;
   unsigned int __not_eol : 1 ;
   unsigned int __newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_56 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_56 regmatch_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 36 "/usr/include/nl_types.h"
typedef int nl_item;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 135 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.h"
typedef int time_min;
#line 32 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/entry.c"
enum ecode {
    e_none = 0,
    e_minute = 1,
    e_hour = 2,
    e_dom = 3,
    e_month = 4,
    e_dow = 5,
    e_cmd = 6,
    e_timespec = 7,
    e_username = 8
} ;
#line 32 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/entry.c"
typedef enum ecode ecode_e;
#line 30 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 60 "/usr/include/x86_64-linux-gnu/sys/wait.h"
union wait;
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_45 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_46 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_45 __wait_terminated ;
   struct __anonstruct___wait_stopped_46 __wait_stopped ;
};
#line 496 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/do_command.c"
union __anonunion_55___0 {
   int __in ;
   int __i ;
};
#line 501 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/do_command.c"
union __anonunion_56___0 {
   int __in ;
   int __i ;
};
#line 501 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/do_command.c"
union __anonunion_57 {
   int __in ;
   int __i ;
};
#line 501 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/do_command.c"
union __anonunion_58 {
   int __in ;
   int __i ;
};
#line 499 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/do_command.c"
union __anonunion_59 {
   int __in ;
   int __i ;
};
#line 494 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/do_command.c"
union __anonunion_60 {
   int __in ;
   int __i ;
};
#line 494 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/do_command.c"
union __anonunion_61 {
   int __in ;
   int __i ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/job.c"
struct _job {
   struct _job *next ;
   entry *e ;
   user *u ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/job.c"
typedef struct _job job;
#line 42 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 37 "/usr/include/utime.h"
struct utimbuf {
   __time_t actime ;
   __time_t modtime ;
};
#line 50 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/crontab.c"
enum opt_t {
    opt_unknown = 0,
    opt_list = 1,
    opt_delete = 2,
    opt_edit = 3,
    opt_replace = 4
} ;
#line 724 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/crontab.c"
union __anonunion_55___1 {
   int __in ;
   int __i ;
};
#line 728 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/crontab.c"
union __anonunion_56___1 {
   int __in ;
   int __i ;
};
#line 728 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/crontab.c"
union __anonunion_57___0 {
   int __in ;
   int __i ;
};
#line 728 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/crontab.c"
union __anonunion_58___0 {
   int __in ;
   int __i ;
};
#line 727 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/crontab.c"
union __anonunion_59___0 {
   int __in ;
   int __i ;
};
#line 723 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/crontab.c"
union __anonunion_60___0 {
   int __in ;
   int __i ;
};
#line 723 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/crontab.c"
union __anonunion_61___0 {
   int __in ;
   int __i ;
};
#line 721 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/crontab.c"
union __anonunion_62 {
   int __in ;
   int __i ;
};
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 221
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 248
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 603
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 700
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 717
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 983
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getdtablesize)(void) ;
#line 348 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 459
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) bzero)(void *__s ,
                                                                                             size_t __n ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 224 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.h"
void log_it(char *username , int xpid , char *event , char *detail ) ;
#line 243
int cron_pclose(FILE *iop ) ;
#line 257
char *env_get(char *name , char **envp ) ;
#line 271
FILE *cron_popen(char *program , char *type , entry *e ) ;
#line 201 "/usr/include/grp.h"
extern int initgroups(char const   *__user , __gid_t __group ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/popen.c"
static pid_t *pids  ;
#line 48 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/popen.c"
static int fds  ;
#line 50 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/popen.c"
FILE *cron_popen(char *program , char *type , entry *e ) 
{ 
  register char *cp ;
  FILE *iop ;
  int argc ;
  int pdes[2] ;
  pid_t pid ;
  char *argv[101] ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char msg[256] ;
  int *tmp___3 ;
  char *tmp___4 ;
  __pid_t tmp___5 ;
  int tmp___6 ;
  char msg___0[256] ;
  int *tmp___7 ;
  char *tmp___8 ;
  __pid_t tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char msg___1[256] ;
  int *tmp___12 ;
  char *tmp___13 ;
  __pid_t tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;

  {
#line 67
  if ((int )*type != 114) {
#line 67
    if ((int )*type != 119) {
#line 68
      return ((FILE *)((void *)0));
    } else {
#line 67
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 67
  if (*(type + 1)) {
#line 68
    return ((FILE *)((void *)0));
  }
#line 70
  if (! pids) {
    {
#line 71
    fds = getdtablesize();
    }
#line 71
    if (fds <= 0) {
#line 72
      return ((FILE *)((void *)0));
    }
    {
#line 73
    tmp = malloc((size_t )((u_int )((unsigned long )fds * sizeof(pid_t ))));
#line 73
    pids = (pid_t *)tmp;
    }
#line 73
    if (! pids) {
#line 74
      return ((FILE *)((void *)0));
    }
    {
#line 75
    bzero((void *)((char *)pids), (unsigned long )fds * sizeof(pid_t ));
    }
  }
  {
#line 77
  tmp___0 = pipe((int *)(pdes));
  }
#line 77
  if (tmp___0 < 0) {
#line 78
    return ((FILE *)((void *)0));
  }
#line 81
  argc = 0;
#line 81
  cp = program;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! (argc < 100)) {
#line 81
      goto while_break;
    }
    {
#line 82
    tmp___1 = argc;
#line 82
    argc ++;
#line 82
    tmp___2 = strtok((char */* __restrict  */)cp, (char const   */* __restrict  */)" \t\n");
#line 82
    argv[tmp___1] = tmp___2;
    }
#line 82
    if (! tmp___2) {
#line 83
      goto while_break;
    }
#line 81
    cp = (char *)((void *)0);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 84
  argv[100] = (char *)((void *)0);
#line 102
  iop = (FILE *)((void *)0);
#line 103
  pid = fork();
  }
  {
#line 104
  if (pid == -1) {
#line 104
    goto case_neg_1;
  }
#line 109
  if (pid == 0) {
#line 109
    goto case_0;
  }
#line 103
  goto switch_break;
  case_neg_1: /* CIL Label */ 
  {
#line 105
  close(pdes[0]);
#line 106
  close(pdes[1]);
  }
#line 107
  goto pfree;
  case_0: /* CIL Label */ 
#line 110
  if ((int )*type == 114) {
#line 111
    if (pdes[1] != 1) {
      {
#line 112
      dup2(pdes[1], 1);
#line 113
      dup2(pdes[1], 2);
#line 114
      close(pdes[1]);
      }
    }
    {
#line 116
    close(pdes[0]);
    }
  } else {
#line 118
    if (pdes[0] != 0) {
      {
#line 119
      dup2(pdes[0], 0);
#line 120
      close(pdes[0]);
      }
    }
    {
#line 122
    close(pdes[1]);
    }
  }
  {
#line 127
  tmp___6 = setgid(e->gid);
  }
#line 127
  if (tmp___6 != 0) {
    {
#line 129
    tmp___3 = __errno_location();
#line 129
    tmp___4 = strerror(*tmp___3);
#line 129
    snprintf((char */* __restrict  */)(msg), (size_t )256, (char const   */* __restrict  */)"popen:setgid(%lu) failed: %s",
             (unsigned long )e->gid, tmp___4);
#line 131
    tmp___5 = getpid();
#line 131
    log_it((char *)"CRON", tmp___5, (char *)"error", msg);
#line 132
    exit(1);
    }
  }
  {
#line 135
  tmp___10 = env_get((char *)"LOGNAME", e->envp);
#line 135
  tmp___11 = initgroups((char const   *)tmp___10, e->gid);
  }
#line 135
  if (tmp___11 != 0) {
    {
#line 137
    tmp___7 = __errno_location();
#line 137
    tmp___8 = strerror(*tmp___7);
#line 137
    snprintf((char */* __restrict  */)(msg___0), (size_t )256, (char const   */* __restrict  */)"popen:initgroups(%lu) failed: %s",
             (unsigned long )e->gid, tmp___8);
#line 139
    tmp___9 = getpid();
#line 139
    log_it((char *)"CRON", tmp___9, (char *)"error", msg___0);
#line 140
    exit(1);
    }
  }
  {
#line 143
  tmp___15 = setuid(e->uid);
  }
#line 143
  if (tmp___15 != 0) {
    {
#line 145
    tmp___12 = __errno_location();
#line 145
    tmp___13 = strerror(*tmp___12);
#line 145
    snprintf((char */* __restrict  */)(msg___1), (size_t )256, (char const   */* __restrict  */)"popen: setuid(%lu) failed: %s",
             (unsigned long )e->uid, tmp___13);
#line 147
    tmp___14 = getpid();
#line 147
    log_it((char *)"CRON", tmp___14, (char *)"error", msg___1);
#line 148
    exit(1);
    }
  }
  {
#line 150
  tmp___16 = env_get((char *)"HOME", e->envp);
#line 150
  chdir((char const   *)tmp___16);
#line 155
  execvp((char const   *)argv[0], (char * const  *)(argv));
#line 157
  _exit(1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 160
  if ((int )*type == 114) {
    {
#line 161
    iop = fdopen(pdes[0], (char const   *)type);
#line 162
    close(pdes[1]);
    }
  } else {
    {
#line 164
    iop = fdopen(pdes[1], (char const   *)type);
#line 165
    close(pdes[0]);
    }
  }
  {
#line 167
  tmp___17 = fileno(iop);
#line 167
  *(pids + tmp___17) = pid;
  }
  pfree: 
#line 176
  return (iop);
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/popen.c"
int cron_pclose(FILE *iop ) 
{ 
  register int fdes ;
  sigset_t omask ;
  sigset_t mask ;
  int stat_loc ;
  pid_t pid ;
  union __anonunion_55 __constr_expr_0 ;
  union __anonunion_56 __constr_expr_1 ;

  {
#line 192
  if ((unsigned long )pids == (unsigned long )((pid_t *)0)) {
#line 193
    return (-1);
  } else {
    {
#line 192
    fdes = fileno(iop);
    }
#line 192
    if (*(pids + fdes) == 0) {
#line 193
      return (-1);
    }
  }
  {
#line 194
  fclose(iop);
#line 195
  sigemptyset(& mask);
#line 196
  sigaddset(& mask, 3);
#line 197
  sigaddset(& mask, 2);
#line 198
  sigaddset(& mask, 1);
#line 199
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& mask), (sigset_t */* __restrict  */)(& omask));
#line 200
  pid = waitpid(*(pids + fdes), & stat_loc, 0);
#line 201
  sigprocmask(2, (sigset_t const   */* __restrict  */)(& omask), (sigset_t */* __restrict  */)((void *)0));
#line 202
  *(pids + fdes) = 0;
  }
#line 203
  if (pid == -1) {
#line 204
    return (-1);
  } else {
#line 203
    __constr_expr_0.__in = stat_loc;
#line 203
    if (! ((__constr_expr_0.__i & 127) == 0)) {
#line 204
      return (-1);
    }
  }
#line 205
  __constr_expr_1.__in = stat_loc;
#line 205
  return ((__constr_expr_1.__i & 65280) >> 8);
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 515
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 224 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.h"
void env_free(char **envp ) ;
#line 224
void skip_comments(FILE *file ) ;
#line 243
int get_string(char *string , int size , FILE *file , char *terms ) ;
#line 243
int load_env(char *envstr , FILE *f ) ;
#line 243
int strcmp_until(char *left , char *right , int until ) ;
#line 243
int strdtb(char *s ) ;
#line 257
char **env_init(void) ;
#line 257
char **env_copy(char **envp ) ;
#line 257
char **env_set(char **envp , char *envstr ) ;
#line 325
int LineNumber ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/env.c"
char **env_init(void) 
{ 
  register char **p ;
  void *tmp ;

  {
  {
#line 29
  tmp = malloc(sizeof(char **));
#line 29
  p = (char **)tmp;
  }
#line 31
  if (p) {
#line 32
    *(p + 0) = (char *)((void *)0);
  }
#line 33
  return (p);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/env.c"
void env_free(char **envp ) 
{ 
  char **p ;

  {
#line 43
  if (! envp) {
#line 44
    return;
  }
#line 46
  p = envp;
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    if (! *p) {
#line 46
      goto while_break;
    }
    {
#line 47
    free((void *)*p);
#line 46
    p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 48
  free((void *)envp);
  }
#line 49
  return;
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/env.c"
char **env_copy(char **envp ) 
{ 
  register int count ;
  register int i ;
  register char **p ;
  void *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
#line 59
  count = 0;
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    if (! ((unsigned long )*(envp + count) != (unsigned long )((void *)0))) {
#line 59
      goto while_break;
    }
#line 59
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 61
  tmp = malloc((unsigned long )(count + 1) * sizeof(char *));
#line 61
  p = (char **)tmp;
  }
#line 62
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 63
    tmp___0 = __errno_location();
#line 63
    *tmp___0 = 12;
    }
#line 64
    return ((char **)((void *)0));
  }
#line 66
  i = 0;
  {
#line 66
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 66
    if (! (i < count)) {
#line 66
      goto while_break___0;
    }
    {
#line 67
    tmp___2 = strdup((char const   *)*(envp + i));
#line 67
    *(p + i) = tmp___2;
    }
#line 67
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
      {
#line 68
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 68
        i --;
#line 68
        if (! (i >= 0)) {
#line 68
          goto while_break___1;
        }
        {
#line 69
        free((void *)*(p + i));
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 70
      free((void *)p);
#line 71
      tmp___1 = __errno_location();
#line 71
      *tmp___1 = 12;
      }
#line 72
      return ((char **)((void *)0));
    }
#line 66
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 74
  *(p + count) = (char *)((void *)0);
#line 75
  return (p);
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/env.c"
char **env_set(char **envp , char *envstr ) 
{ 
  register int count ;
  register int found ;
  register char **p ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
#line 91
  found = -1;
#line 92
  count = 0;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! ((unsigned long )*(envp + count) != (unsigned long )((void *)0))) {
#line 92
      goto while_break;
    }
    {
#line 93
    tmp = strcmp_until(*(envp + count), envstr, '=');
    }
#line 93
    if (! tmp) {
#line 94
      found = count;
    }
#line 92
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  count ++;
#line 98
  if (found != -1) {
    {
#line 103
    free((void *)*(envp + found));
#line 104
    tmp___1 = strdup((char const   *)envstr);
#line 104
    *(envp + found) = tmp___1;
    }
#line 104
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      {
#line 105
      *(envp + found) = (char *)"";
#line 106
      tmp___0 = __errno_location();
#line 106
      *tmp___0 = 12;
      }
#line 107
      return ((char **)((void *)0));
    }
#line 109
    return (envp);
  }
  {
#line 117
  tmp___2 = realloc((void *)envp, (size_t )((unsigned int )((unsigned long )(count + 1) * sizeof(char **))));
#line 117
  p = (char **)tmp___2;
  }
#line 119
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 120
    tmp___3 = __errno_location();
#line 120
    *tmp___3 = 12;
    }
#line 121
    return ((char **)((void *)0));
  }
  {
#line 123
  *(p + count) = *(p + (count - 1));
#line 124
  tmp___5 = strdup((char const   *)envstr);
#line 124
  *(p + (count - 1)) = tmp___5;
  }
#line 124
  if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
    {
#line 125
    tmp___4 = __errno_location();
#line 125
    *tmp___4 = 12;
    }
#line 126
    return ((char **)((void *)0));
  }
#line 128
  return (p);
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/env.c"
int load_env(char *envstr , FILE *f ) 
{ 
  long filepos ;
  int fileline ;
  enum env_state state ;
  char name[1000] ;
  char val[1000] ;
  char quotechar ;
  char *c ;
  char *str ;
  int tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  size_t tmp___6 ;
  unsigned short const   **tmp___7 ;
  int len ;
  int tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;

  {
  {
#line 158
  filepos = ftell(f);
#line 159
  fileline = LineNumber;
#line 160
  skip_comments(f);
#line 161
  tmp = get_string(envstr, 999, f, (char *)"\n");
  }
#line 161
  if (-1 == tmp) {
#line 162
    return (-1);
  }
  {
#line 164
  *(envstr + 999) = (char )'\000';
#line 168
  bzero((void *)(name), sizeof(name));
#line 169
  bzero((void *)(val), sizeof(val));
#line 170
  str = name;
#line 171
  state = (enum env_state )0;
#line 172
  quotechar = (char )'\000';
#line 173
  c = envstr;
  }
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if ((unsigned int )state != 7U) {
#line 174
      if (! *c) {
#line 174
        goto while_break;
      }
    } else {
#line 174
      goto while_break;
    }
    {
#line 177
    if ((unsigned int )state == 4U) {
#line 177
      goto case_4;
    }
#line 177
    if ((unsigned int )state == 0U) {
#line 177
      goto case_4;
    }
#line 183
    if ((unsigned int )state == 5U) {
#line 183
      goto case_5;
    }
#line 183
    if ((unsigned int )state == 1U) {
#line 183
      goto case_5;
    }
#line 210
    if ((unsigned int )state == 2U) {
#line 210
      goto case_2;
    }
#line 223
    if ((unsigned int )state == 6U) {
#line 223
      goto case_6;
    }
#line 223
    if ((unsigned int )state == 3U) {
#line 223
      goto case_6;
    }
#line 230
    goto switch_default;
    case_4: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 178
    if ((int )*c == 39) {
#line 179
      tmp___0 = c;
#line 179
      c ++;
#line 179
      quotechar = *tmp___0;
    } else
#line 178
    if ((int )*c == 34) {
#line 179
      tmp___0 = c;
#line 179
      c ++;
#line 179
      quotechar = *tmp___0;
    }
#line 180
    state = (enum env_state )((unsigned int )state + 1U);
    case_5: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 184
    if (quotechar) {
#line 185
      if ((int )*c == (int )quotechar) {
#line 186
        state = (enum env_state )((unsigned int )state + 1U);
#line 187
        c ++;
#line 188
        goto switch_break;
      }
#line 190
      if ((unsigned int )state == 1U) {
#line 190
        if ((int )*c == 61) {
#line 191
          state = (enum env_state )7;
#line 192
          goto switch_break;
        }
      }
    } else
#line 195
    if ((unsigned int )state == 1U) {
      {
#line 196
      tmp___1 = __ctype_b_loc();
      }
#line 196
      if ((int const   )*(*tmp___1 + (int )((unsigned char )*c)) & 8192) {
#line 197
        c ++;
#line 198
        state = (enum env_state )((unsigned int )state + 1U);
#line 199
        goto switch_break;
      }
#line 201
      if ((int )*c == 61) {
#line 202
        state = (enum env_state )((unsigned int )state + 1U);
#line 203
        goto switch_break;
      }
    }
#line 207
    tmp___2 = str;
#line 207
    str ++;
#line 207
    tmp___3 = c;
#line 207
    c ++;
#line 207
    *tmp___2 = *tmp___3;
#line 208
    goto switch_break;
    case_2: /* CIL Label */ 
#line 211
    if ((int )*c == 61) {
#line 212
      state = (enum env_state )((unsigned int )state + 1U);
#line 213
      str = val;
#line 214
      quotechar = (char )'\000';
    } else {
      {
#line 216
      tmp___4 = __ctype_b_loc();
      }
#line 216
      if (! ((int const   )*(*tmp___4 + (int )((unsigned char )*c)) & 8192)) {
#line 217
        state = (enum env_state )7;
      }
    }
#line 219
    c ++;
#line 220
    goto switch_break;
    case_6: /* CIL Label */ 
    case_3: /* CIL Label */ 
    {
#line 224
    tmp___5 = __ctype_b_loc();
    }
#line 224
    if ((int const   )*(*tmp___5 + (int )((unsigned char )*c)) & 8192) {
#line 225
      c ++;
    } else {
#line 227
      state = (enum env_state )((unsigned int )state + 1U);
    }
#line 228
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 231
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  if ((unsigned int )state != 6U) {
#line 234
    if ((unsigned int )state == 5U) {
#line 234
      if (! (! quotechar)) {
        {
#line 236
        fseek(f, filepos, 0);
#line 237
        LineNumber = fileline;
        }
#line 238
        return (0);
      }
    } else {
      {
#line 236
      fseek(f, filepos, 0);
#line 237
      LineNumber = fileline;
      }
#line 238
      return (0);
    }
  }
#line 240
  if ((unsigned int )state == 5U) {
    {
#line 242
    tmp___6 = strlen((char const   *)(val));
#line 242
    c = val + tmp___6;
    }
    {
#line 243
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 243
      if ((unsigned long )c > (unsigned long )(val)) {
        {
#line 243
        tmp___7 = __ctype_b_loc();
        }
#line 243
        if (! ((int const   )*(*tmp___7 + (int )((unsigned char )*(c + -1))) & 8192)) {
#line 243
          goto while_break___0;
        }
      } else {
#line 243
        goto while_break___0;
      }
#line 244
      c --;
#line 244
      *c = (char )'\000';
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 254
  tmp___8 = strdtb(val);
#line 254
  len = tmp___8;
  }
#line 256
  if (len >= 2) {
#line 257
    if ((int )val[0] == 39) {
#line 257
      goto _L;
    } else
#line 257
    if ((int )val[0] == 34) {
      _L: /* CIL Label */ 
#line 258
      if ((int )val[len - 1] == (int )val[0]) {
        {
#line 259
        val[len - 1] = (char )'\000';
#line 260
        strcpy((char */* __restrict  */)(val), (char const   */* __restrict  */)(val + 1));
        }
      }
    }
  }
  {
#line 266
  tmp___9 = strlen((char const   *)(name));
#line 266
  tmp___10 = strlen((char const   *)(val));
  }
#line 266
  if ((tmp___9 + 1UL) + tmp___10 >= 999UL) {
#line 267
    return (0);
  }
  {
#line 268
  sprintf((char */* __restrict  */)envstr, (char const   */* __restrict  */)"%s=%s",
          name, val);
  }
#line 270
  return (1);
}
}
#line 273 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/env.c"
char *env_get(char *name , char **envp ) 
{ 
  register int len ;
  size_t tmp ;
  register char *p ;
  register char *q ;
  int tmp___0 ;
  char **tmp___1 ;

  {
  {
#line 278
  tmp = strlen((char const   *)name);
#line 278
  len = (int )tmp;
  }
  {
#line 281
  while (1) {
    while_continue: /* CIL Label */ ;
#line 281
    tmp___1 = envp;
#line 281
    envp ++;
#line 281
    p = *tmp___1;
#line 281
    if (! p) {
#line 281
      goto while_break;
    }
    {
#line 282
    q = strchr((char const   *)p, '=');
    }
#line 282
    if (! q) {
#line 283
      goto while_continue;
    }
#line 284
    if (q - p == (long )len) {
      {
#line 284
      tmp___0 = strncmp((char const   *)p, (char const   *)name, (size_t )len);
      }
#line 284
      if (! tmp___0) {
#line 285
        return (q + 1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 287
  return ((char *)((void *)0));
}
}
#line 190 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 846 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 224 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.h"
void free_user(user *u ) ;
#line 224
void free_entry(entry *e ) ;
#line 265
user *load_user(int crontab_fd , struct passwd *pw___0 , char *uname , char *fname ,
                char *tabname ) ;
#line 268
entry *load_entry(FILE *file , void (*error_func)() , struct passwd *pw___0 , char **envp ) ;
#line 137 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/user.c"
static char *err_user  =    (char *)((void *)0);
#line 139 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/user.c"
void crontab_error(char *msg ) 
{ 
  char const   *fn ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 145
  tmp___0 = strcmp((char const   *)err_user, "*system*");
  }
#line 145
  if (0 == tmp___0) {
    {
#line 146
    syslog(3 | (9 << 3), "Error: %s; while reading %s", msg, "/etc/crontab");
    }
  } else {
    {
#line 147
    tmp = strncmp((char const   *)err_user, "*system*", (size_t )8);
    }
#line 147
    if (0 == tmp) {
      {
#line 148
      fn = (char const   *)(err_user + 8);
#line 149
      syslog(3 | (9 << 3), "Error: %s; while reading %s/%s", msg, "/etc/cron.d", fn);
      }
    } else {
      {
#line 152
      syslog(3 | (9 << 3), "Error: %s; while reading crontab for user %s", msg, err_user);
      }
    }
  }
#line 155
  return;
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/user.c"
void free_user(user *u ) 
{ 
  entry *e ;
  entry *ne ;

  {
  {
#line 165
  free((void *)u->name);
#line 166
  e = u->crontab;
  }
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 166
      goto while_break;
    }
    {
#line 167
    ne = e->next;
#line 168
    free_entry(e);
#line 166
    e = ne;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 174
  free((void *)u);
  }
#line 175
  return;
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/user.c"
user *load_user(int crontab_fd , struct passwd *pw___0 , char *uname , char *fname ,
                char *tabname ) 
{ 
  char envstr[1000] ;
  FILE *file ;
  user *u ;
  entry *e ;
  int status ;
  char **envp ;
  char **tenvp ;
  int *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  __pid_t tmp___3 ;
  __pid_t tmp___4 ;

  {
  {
#line 191
  envp = (char **)((void *)0);
#line 193
  file = fdopen(crontab_fd, "r");
  }
#line 193
  if (! file) {
    {
#line 194
    perror("fdopen on crontab_fd in load_user");
    }
#line 195
    return ((user *)((void *)0));
  }
  {
#line 202
  tmp___0 = malloc(sizeof(user ));
#line 202
  u = (user *)tmp___0;
  }
#line 202
  if ((unsigned long )u == (unsigned long )((void *)0)) {
    {
#line 203
    tmp = __errno_location();
#line 203
    *tmp = 12;
    }
#line 204
    return ((user *)((void *)0));
  }
  {
#line 206
  tmp___2 = strdup((char const   *)fname);
#line 206
  u->name = tmp___2;
  }
#line 206
  if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
    {
#line 207
    free((void *)u);
#line 208
    tmp___1 = __errno_location();
#line 208
    *tmp___1 = 12;
    }
#line 209
    return ((user *)((void *)0));
  }
  {
#line 211
  u->crontab = (entry *)((void *)0);
#line 234
  envp = env_init();
  }
#line 234
  if ((unsigned long )envp == (unsigned long )((void *)0)) {
    {
#line 235
    free((void *)u->name);
#line 236
    free((void *)u);
    }
#line 237
    return ((user *)((void *)0));
  }
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 244
    status = load_env(envstr, file);
    }
    {
#line 246
    if (status == -1) {
#line 246
      goto case_neg_1;
    }
#line 261
    if (status == 0) {
#line 261
      goto case_0;
    }
#line 282
    if (status == 1) {
#line 282
      goto case_1;
    }
#line 245
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 253
    if ((int )envstr[0] != 0) {
      {
#line 254
      tmp___3 = getpid();
#line 254
      log_it(u->name, tmp___3, (char *)"ERROR", (char *)"Missing newline before EOF, this crontab file will be ignored");
#line 257
      free_user(u);
#line 258
      u = (user *)((void *)0);
      }
    }
#line 260
    goto done;
    case_0: /* CIL Label */ 
    {
#line 263
    err_user = fname;
#line 264
    e = load_entry(file, (void (*)())(& crontab_error), pw___0, envp);
#line 265
    err_user = (char *)((void *)0);
    }
#line 269
    if (e) {
#line 270
      e->next = u->crontab;
#line 271
      u->crontab = e;
    } else {
      {
#line 274
      tmp___4 = getpid();
#line 274
      log_it(u->name, tmp___4, (char *)"ERROR", (char *)"Syntax error, this crontab file will be ignored");
#line 277
      free_user(u);
#line 278
      u = (user *)((void *)0);
      }
#line 279
      goto done;
    }
#line 281
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 283
    tenvp = env_set(envp, envstr);
    }
#line 283
    if (tenvp) {
#line 284
      envp = tenvp;
    } else {
      {
#line 286
      free_user(u);
#line 287
      u = (user *)((void *)0);
      }
#line 288
      goto done;
    }
#line 290
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 243
    if (! (status >= 0)) {
#line 243
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  done: 
  {
#line 295
  env_free(envp);
#line 296
  fclose(file);
  }
#line 298
  return (u);
}
}
#line 78 "/usr/include/pwd.h"
extern void endpwent(void) ;
#line 116
extern struct passwd *getpwnam(char const   *__name ) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 224 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.h"
void load_database(cron_db *old_db ) ;
#line 224
void link_user(cron_db *db , user *u ) ;
#line 224
void unlink_user(cron_db *db , user *u ) ;
#line 224
void check_orphans(cron_db *db ) ;
#line 265
user *find_user(cron_db *db , char *name ) ;
#line 323
int lsbsysinit_mode ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 214
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 263
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/database.c"
static void process_crontab(char *uname , char *fname , char *tabname , struct stat *statbuf ,
                            cron_db *new_db , cron_db *old_db ) ;
#line 53
static int valid_name(char *filename ) ;
#line 54
static user *get_next_system_crontab(user *curtab ) ;
#line 57
void force_rescan_user(cron_db *old_db , cron_db *new_db , char const   *fname , time_t old_mtime ) ;
#line 59
static void add_orphan(char const   *uname , char const   *fname , char const   *tabname ) ;
#line 60
static void free_orphan(orphan *o ) ;
#line 62 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/database.c"
void load_database(cron_db *old_db ) 
{ 
  DIR *dir ;
  struct stat statbuf ;
  struct stat syscron_stat ;
  struct dirent *dp ;
  cron_db new_db ;
  user *u ;
  user *nu ;
  struct stat syscrond_stat ;
  struct stat syscrond_file_stat ;
  char syscrond_fname[4097] ;
  int syscrond_change ;
  __pid_t tmp ;
  int tmp___0 ;
  __pid_t tmp___1 ;
  int tmp___2 ;
  __pid_t tmp___3 ;
  int tmp___4 ;
  user *systab ;
  int tmp___5 ;
  __pid_t tmp___6 ;
  char fname[256] ;
  char tabname[4097] ;
  int tmp___7 ;
  __pid_t tmp___8 ;
  char fname___0[256] ;
  char tabname___0[4097] ;

  {
  {
#line 77
  syscrond_change = 0;
#line 86
  tmp___0 = stat((char const   */* __restrict  */)"crontabs", (struct stat */* __restrict  */)(& statbuf));
  }
#line 86
  if (tmp___0 < 0) {
    {
#line 87
    tmp = getpid();
#line 87
    log_it((char *)"CRON", tmp, (char *)"STAT FAILED", (char *)"crontabs");
#line 88
    statbuf.st_mtim.tv_sec = (__time_t )0;
    }
  }
  {
#line 93
  tmp___2 = stat((char const   */* __restrict  */)"/etc/crontab", (struct stat */* __restrict  */)(& syscron_stat));
  }
#line 93
  if (tmp___2 < 0) {
    {
#line 94
    tmp___1 = getpid();
#line 94
    log_it((char *)"CRON", tmp___1, (char *)"STAT FAILED", (char *)"/etc/crontab");
#line 95
    syscron_stat.st_mtim.tv_sec = (__time_t )0;
    }
  }
  {
#line 103
  tmp___4 = stat((char const   */* __restrict  */)"/etc/cron.d", (struct stat */* __restrict  */)(& syscrond_stat));
  }
#line 103
  if (tmp___4 < 0) {
    {
#line 104
    tmp___3 = getpid();
#line 104
    log_it((char *)"CRON", tmp___3, (char *)"STAT FAILED", (char *)"/etc/cron.d");
#line 105
    syscrond_stat.st_mtim.tv_sec = (__time_t )0;
    }
  }
#line 115
  if (old_db->sysd_mtime != syscrond_stat.st_mtim.tv_sec) {
#line 116
    syscrond_change = 1;
  } else {
#line 124
    systab = old_db->head;
    {
#line 124
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 124
      systab = get_next_system_crontab(systab);
      }
#line 124
      if (! ((unsigned long )systab != (unsigned long )((void *)0))) {
#line 124
        goto while_break;
      }
      {
#line 128
      sprintf((char */* __restrict  */)(syscrond_fname), (char const   */* __restrict  */)"%s/%s",
              "/etc/cron.d", systab->name + 8);
#line 133
      tmp___5 = stat((char const   */* __restrict  */)(syscrond_fname), (struct stat */* __restrict  */)(& syscrond_file_stat));
      }
#line 133
      if (tmp___5 < 0) {
#line 134
        syscrond_file_stat.st_mtim.tv_sec = (__time_t )0;
      }
#line 136
      if (syscrond_file_stat.st_mtim.tv_sec != systab->mtime) {
#line 138
        syscrond_change = 1;
      } else
#line 136
      if (systab->mtime == 0L) {
#line 138
        syscrond_change = 1;
      }
#line 124
      systab = systab->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 154
  if (old_db->user_mtime == statbuf.st_mtim.tv_sec) {
#line 154
    if (old_db->sys_mtime == syscron_stat.st_mtim.tv_sec) {
#line 154
      if (! syscrond_change) {
#line 163
        return;
      }
    }
  }
#line 171
  new_db.user_mtime = statbuf.st_mtim.tv_sec;
#line 172
  new_db.sys_mtime = syscron_stat.st_mtim.tv_sec;
#line 174
  new_db.sysd_mtime = syscrond_stat.st_mtim.tv_sec;
#line 176
  new_db.tail = (user *)((void *)0);
#line 176
  new_db.head = new_db.tail;
#line 178
  if (syscron_stat.st_mtim.tv_sec) {
    {
#line 179
    process_crontab((char *)"root", (char *)"*system*", (char *)"/etc/crontab", & syscron_stat,
                    & new_db, old_db);
    }
  }
  {
#line 186
  dir = opendir("/etc/cron.d");
  }
#line 186
  if (! dir) {
    {
#line 187
    tmp___6 = getpid();
#line 187
    log_it((char *)"CRON", tmp___6, (char *)"OPENDIR FAILED", (char *)"/etc/cron.d");
    }
  }
  {
#line 190
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 190
    if ((unsigned long )dir != (unsigned long )((void *)0)) {
      {
#line 190
      dp = readdir(dir);
      }
#line 190
      if (! ((unsigned long )((void *)0) != (unsigned long )dp)) {
#line 190
        goto while_break___0;
      }
    } else {
#line 190
      goto while_break___0;
    }
#line 200
    if ((int )dp->d_name[0] == 46) {
#line 201
      goto while_continue___0;
    }
    {
#line 206
    tmp___7 = valid_name(dp->d_name);
    }
#line 206
    if (! tmp___7) {
#line 207
      goto while_continue___0;
    }
    {
#line 210
    strcpy((char */* __restrict  */)(fname), (char const   */* __restrict  */)"*system*");
#line 211
    strcat((char */* __restrict  */)(fname), (char const   */* __restrict  */)(dp->d_name));
#line 212
    sprintf((char */* __restrict  */)(tabname), (char const   */* __restrict  */)"%s/%s",
            "/etc/cron.d", dp->d_name);
#line 216
    process_crontab((char *)"root", fname, tabname, & statbuf, & new_db, old_db);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 220
  if (dir) {
    {
#line 221
    closedir(dir);
    }
  }
  {
#line 228
  dir = opendir("crontabs");
  }
#line 228
  if (! dir) {
    {
#line 229
    tmp___8 = getpid();
#line 229
    log_it((char *)"CRON", tmp___8, (char *)"OPENDIR FAILED", (char *)"crontabs");
    }
  }
  {
#line 232
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 232
    if ((unsigned long )dir != (unsigned long )((void *)0)) {
      {
#line 232
      dp = readdir(dir);
      }
#line 232
      if (! ((unsigned long )((void *)0) != (unsigned long )dp)) {
#line 232
        goto while_break___1;
      }
    } else {
#line 232
      goto while_break___1;
    }
#line 241
    if ((int )dp->d_name[0] == 46) {
#line 242
      goto while_continue___1;
    }
    {
#line 244
    strcpy((char */* __restrict  */)(fname___0), (char const   */* __restrict  */)(dp->d_name));
#line 245
    snprintf((char */* __restrict  */)(tabname___0), (size_t )4097, (char const   */* __restrict  */)"%s/%s",
             "crontabs", fname___0);
#line 247
    process_crontab(fname___0, fname___0, tabname___0, & statbuf, & new_db, old_db);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 250
  if (dir) {
    {
#line 251
    closedir(dir);
    }
  }
  {
#line 257
  endpwent();
#line 262
  u = old_db->head;
  }
  {
#line 262
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 262
    if (! ((unsigned long )u != (unsigned long )((void *)0))) {
#line 262
      goto while_break___2;
    }
    {
#line 264
    nu = u->next;
#line 265
    unlink_user(old_db, u);
#line 266
    free_user(u);
#line 262
    u = nu;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 271
  *old_db = new_db;
#line 273
  return;
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/database.c"
void link_user(cron_db *db , user *u ) 
{ 


  {
#line 281
  if ((unsigned long )db->head == (unsigned long )((void *)0)) {
#line 282
    db->head = u;
  }
#line 283
  if (db->tail) {
#line 284
    (db->tail)->next = u;
  }
#line 285
  u->prev = db->tail;
#line 286
  u->next = (struct _user *)((void *)0);
#line 287
  db->tail = u;
#line 288
  return;
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/database.c"
void unlink_user(cron_db *db , user *u ) 
{ 


  {
#line 296
  if ((unsigned long )u->prev == (unsigned long )((void *)0)) {
#line 297
    db->head = u->next;
  } else {
#line 299
    (u->prev)->next = u->next;
  }
#line 301
  if ((unsigned long )u->next == (unsigned long )((void *)0)) {
#line 302
    db->tail = u->prev;
  } else {
#line 304
    (u->next)->prev = u->prev;
  }
#line 305
  return;
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/database.c"
user *find_user(cron_db *db , char *name ) 
{ 
  user *u ;
  int tmp ;

  {
#line 316
  u = db->head;
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if (! ((unsigned long )u != (unsigned long )((void *)0))) {
#line 316
      goto while_break;
    }
    {
#line 317
    tmp = strcmp((char const   *)u->name, (char const   *)name);
    }
#line 317
    if (! tmp) {
#line 318
      goto while_break;
    }
#line 316
    u = u->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 319
  return (u);
}
}
#line 323 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/database.c"
static void process_crontab(char *uname , char *fname , char *tabname , struct stat *statbuf ,
                            cron_db *new_db , cron_db *old_db ) 
{ 
  struct passwd *pw___0 ;
  int crontab_fd ;
  user *u ;
  __pid_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __pid_t tmp___2 ;
  __pid_t tmp___3 ;
  int tmp___4 ;
  __pid_t tmp___5 ;
  __pid_t tmp___6 ;
  __pid_t tmp___7 ;
  __pid_t tmp___8 ;
  __pid_t tmp___9 ;
  int tmp___10 ;
  __pid_t tmp___11 ;
  __pid_t tmp___12 ;
  __pid_t tmp___13 ;
  __pid_t tmp___14 ;
  int tmp___15 ;
  __pid_t tmp___16 ;
  __pid_t tmp___17 ;
  __pid_t tmp___18 ;
  __pid_t tmp___19 ;
  __pid_t tmp___20 ;

  {
  {
#line 332
  pw___0 = (struct passwd *)((void *)0);
#line 333
  crontab_fd = -1;
#line 334
  u = (user *)((void *)0);
#line 339
  tmp___1 = strncmp((char const   *)fname, "*system*", (size_t )8);
  }
#line 339
  if (tmp___1) {
    {
#line 339
    pw___0 = getpwnam((char const   *)uname);
    }
#line 339
    if (! pw___0) {
      {
#line 345
      tmp___0 = strncmp((char const   *)fname, "tmp.", (size_t )4);
      }
#line 345
      if (tmp___0) {
        {
#line 347
        tmp = getpid();
#line 347
        log_it(fname, tmp, (char *)"ORPHAN", (char *)"no passwd entry");
#line 348
        add_orphan((char const   *)uname, (char const   *)fname, (char const   *)tabname);
        }
      }
#line 350
      goto next_crontab;
    }
  }
#line 353
  if (pw___0) {
    {
#line 355
    crontab_fd = open((char const   *)tabname, 131072, 0);
    }
#line 355
    if (crontab_fd < 0) {
      {
#line 358
      tmp___2 = getpid();
#line 358
      log_it(fname, tmp___2, (char *)"CAN\'T OPEN", tabname);
      }
#line 359
      goto next_crontab;
    }
    {
#line 362
    tmp___4 = fstat(crontab_fd, statbuf);
    }
#line 362
    if (tmp___4 < 0) {
      {
#line 363
      tmp___3 = getpid();
#line 363
      log_it(fname, tmp___3, (char *)"FSTAT FAILED", tabname);
      }
#line 364
      goto next_crontab;
    }
#line 368
    if (statbuf->st_uid != pw___0->pw_uid) {
#line 368
      if (statbuf->st_uid != 0U) {
        {
#line 369
        tmp___5 = getpid();
#line 369
        log_it(fname, tmp___5, (char *)"WRONG FILE OWNER", tabname);
#line 370
        force_rescan_user(old_db, new_db, (char const   *)fname, (time_t )0);
        }
#line 371
        goto next_crontab;
      }
    }
#line 375
    if (! ((statbuf->st_mode & 61440U) == 32768U)) {
      {
#line 376
      tmp___6 = getpid();
#line 376
      log_it(fname, tmp___6, (char *)"NOT A REGULAR FILE", tabname);
      }
#line 377
      goto next_crontab;
    }
#line 381
    if ((statbuf->st_mode & 4095U) != 384U) {
      {
#line 382
      tmp___7 = getpid();
#line 382
      log_it(fname, tmp___7, (char *)"INSECURE MODE (mode 0600 expected)", tabname);
#line 383
      force_rescan_user(old_db, new_db, (char const   *)fname, (time_t )0);
      }
#line 384
      goto next_crontab;
    }
#line 388
    if (statbuf->st_nlink != 1UL) {
      {
#line 389
      tmp___8 = getpid();
#line 389
      log_it(fname, tmp___8, (char *)"NUMBER OF HARD LINKS > 1", tabname);
#line 390
      force_rescan_user(old_db, new_db, (char const   *)fname, (time_t )0);
      }
#line 391
      goto next_crontab;
    }
  } else {
    {
#line 396
    tmp___10 = lstat((char const   */* __restrict  */)tabname, (struct stat */* __restrict  */)statbuf);
    }
#line 396
    if (tmp___10 < 0) {
      {
#line 397
      tmp___9 = getpid();
#line 397
      log_it(fname, tmp___9, (char *)"LSTAT FAILED", tabname);
      }
#line 398
      goto next_crontab;
    }
#line 400
    if ((statbuf->st_mode & 61440U) == 40960U) {
#line 400
      if (statbuf->st_uid != 0U) {
        {
#line 401
        tmp___11 = getpid();
#line 401
        log_it(fname, tmp___11, (char *)"WRONG SYMLINK OWNER", tabname);
#line 402
        force_rescan_user(old_db, new_db, (char const   *)fname, (time_t )0);
        }
#line 403
        goto next_crontab;
      }
    }
    {
#line 405
    crontab_fd = open((char const   *)tabname, 0, 0);
    }
#line 405
    if (crontab_fd < 0) {
#line 413
      if ((statbuf->st_mode & 61440U) == 40960U) {
        {
#line 414
        tmp___12 = getpid();
#line 414
        log_it(fname, tmp___12, (char *)"CAN\'T OPEN SYMLINK", tabname);
#line 415
        force_rescan_user(old_db, new_db, (char const   *)fname, (time_t )0);
        }
#line 416
        goto next_crontab;
      } else {
        {
#line 418
        tmp___13 = getpid();
#line 418
        log_it(fname, tmp___13, (char *)"CAN\'T OPEN", tabname);
        }
#line 419
        goto next_crontab;
      }
    }
    {
#line 423
    tmp___15 = fstat(crontab_fd, statbuf);
    }
#line 423
    if (tmp___15 < 0) {
      {
#line 424
      tmp___14 = getpid();
#line 424
      log_it(fname, tmp___14, (char *)"FSTAT FAILED", tabname);
      }
#line 425
      goto next_crontab;
    }
#line 429
    if (statbuf->st_uid != 0U) {
      {
#line 430
      tmp___16 = getpid();
#line 430
      log_it(fname, tmp___16, (char *)"WRONG FILE OWNER", tabname);
#line 431
      force_rescan_user(old_db, new_db, (char const   *)fname, (time_t )0);
      }
#line 432
      goto next_crontab;
    }
#line 436
    if (! ((statbuf->st_mode & 61440U) == 32768U)) {
      {
#line 437
      tmp___17 = getpid();
#line 437
      log_it(fname, tmp___17, (char *)"NOT A REGULAR FILE", tabname);
      }
#line 438
      goto next_crontab;
    }
#line 445
    if (statbuf->st_mode & (unsigned int )(128 >> 3)) {
      {
#line 446
      tmp___18 = getpid();
#line 446
      log_it(fname, tmp___18, (char *)"INSECURE MODE (group/other writable)", tabname);
#line 447
      force_rescan_user(old_db, new_db, (char const   *)fname, (time_t )0);
      }
#line 448
      goto next_crontab;
    } else
#line 445
    if (statbuf->st_mode & (unsigned int )((128 >> 3) >> 3)) {
      {
#line 446
      tmp___18 = getpid();
#line 446
      log_it(fname, tmp___18, (char *)"INSECURE MODE (group/other writable)", tabname);
#line 447
      force_rescan_user(old_db, new_db, (char const   *)fname, (time_t )0);
      }
#line 448
      goto next_crontab;
    }
#line 458
    if (statbuf->st_nlink != 1UL) {
      {
#line 459
      tmp___19 = getpid();
#line 459
      log_it(fname, tmp___19, (char *)"NUMBER OF HARD LINKS > 1", tabname);
#line 460
      force_rescan_user(old_db, new_db, (char const   *)fname, (time_t )0);
      }
#line 461
      goto next_crontab;
    }
  }
#line 471
  if ((unsigned long )old_db != (unsigned long )((void *)0)) {
    {
#line 472
    u = find_user(old_db, fname);
    }
  }
#line 474
  if ((unsigned long )u != (unsigned long )((void *)0)) {
#line 478
    if (u->mtime == statbuf->st_mtim.tv_sec) {
      {
#line 480
      unlink_user(old_db, u);
#line 481
      link_user(new_db, u);
      }
#line 482
      goto next_crontab;
    }
    {
#line 493
    unlink_user(old_db, u);
#line 494
    free_user(u);
#line 495
    tmp___20 = getpid();
#line 495
    log_it(fname, tmp___20, (char *)"RELOAD", tabname);
    }
  }
  {
#line 498
  u = load_user(crontab_fd, pw___0, uname, fname, tabname);
  }
#line 499
  if ((unsigned long )u != (unsigned long )((void *)0)) {
    {
#line 500
    u->mtime = statbuf->st_mtim.tv_sec;
#line 501
    link_user(new_db, u);
    }
  } else {
    {
#line 509
    force_rescan_user(old_db, new_db, (char const   *)fname, statbuf->st_mtim.tv_sec);
    }
  }
  next_crontab: 
#line 514
  if (crontab_fd >= 0) {
    {
#line 516
    close(crontab_fd);
    }
  }
#line 518
  return;
}
}
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 577
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 533 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/database.c"
static regex_t hierre  ;
#line 533 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/database.c"
static regex_t tradre  ;
#line 533 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/database.c"
static regex_t excsre  ;
#line 533 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/database.c"
static regex_t classicalre  ;
#line 534 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/database.c"
static int donere  =    0;
#line 530 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/database.c"
static int valid_name(char *filename ) 
{ 
  __pid_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 536
  if (! donere) {
    {
#line 537
    donere = 1;
#line 538
    tmp___0 = regcomp((regex_t */* __restrict  */)(& hierre), (char const   */* __restrict  */)"^_?([a-z0-9_.]+-)+[a-z0-9]+$",
                      1 | (((1 << 1) << 1) << 1));
    }
#line 538
    if (tmp___0) {
      {
#line 545
      tmp = getpid();
#line 545
      log_it((char *)"CRON", tmp, (char *)"REGEX FAILED", (char *)"valid_name");
#line 546
      exit(1);
      }
    } else {
      {
#line 538
      tmp___1 = regcomp((regex_t */* __restrict  */)(& excsre), (char const   */* __restrict  */)"^[a-z0-9-].*dpkg-(old|dist)$",
                        1 | (((1 << 1) << 1) << 1));
      }
#line 538
      if (tmp___1) {
        {
#line 545
        tmp = getpid();
#line 545
        log_it((char *)"CRON", tmp, (char *)"REGEX FAILED", (char *)"valid_name");
#line 546
        exit(1);
        }
      } else {
        {
#line 538
        tmp___2 = regcomp((regex_t */* __restrict  */)(& tradre), (char const   */* __restrict  */)"^[a-z0-9][a-z0-9-]*$",
                          ((1 << 1) << 1) << 1);
        }
#line 538
        if (tmp___2) {
          {
#line 545
          tmp = getpid();
#line 545
          log_it((char *)"CRON", tmp, (char *)"REGEX FAILED", (char *)"valid_name");
#line 546
          exit(1);
          }
        } else {
          {
#line 538
          tmp___3 = regcomp((regex_t */* __restrict  */)(& classicalre), (char const   */* __restrict  */)"^[a-zA-Z0-9_-]+$",
                            1 | (((1 << 1) << 1) << 1));
          }
#line 538
          if (tmp___3) {
            {
#line 545
            tmp = getpid();
#line 545
            log_it((char *)"CRON", tmp, (char *)"REGEX FAILED", (char *)"valid_name");
#line 546
            exit(1);
            }
          }
        }
      }
    }
  }
#line 549
  if (lsbsysinit_mode) {
    {
#line 550
    tmp___7 = regexec((regex_t const   */* __restrict  */)(& hierre), (char const   */* __restrict  */)filename,
                      (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
    }
#line 550
    if (tmp___7) {
      {
#line 553
      tmp___5 = regexec((regex_t const   */* __restrict  */)(& tradre), (char const   */* __restrict  */)filename,
                        (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
      }
#line 553
      if (tmp___5) {
#line 553
        tmp___6 = 0;
      } else {
#line 553
        tmp___6 = 1;
      }
#line 553
      return (tmp___6);
    } else {
      {
#line 551
      tmp___4 = regexec((regex_t const   */* __restrict  */)(& excsre), (char const   */* __restrict  */)filename,
                        (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
      }
#line 551
      return (tmp___4);
    }
  }
  {
#line 557
  tmp___8 = regexec((regex_t const   */* __restrict  */)(& classicalre), (char const   */* __restrict  */)filename,
                    (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
  }
#line 557
  if (tmp___8) {
#line 557
    tmp___9 = 0;
  } else {
#line 557
    tmp___9 = 1;
  }
#line 557
  return (tmp___9);
}
}
#line 561 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/database.c"
static user *get_next_system_crontab(user *curtab ) 
{ 
  int tmp ;

  {
  {
#line 565
  while (1) {
    while_continue: /* CIL Label */ ;
#line 565
    if (! ((unsigned long )curtab != (unsigned long )((void *)0))) {
#line 565
      goto while_break;
    }
    {
#line 566
    tmp = strncmp((char const   *)curtab->name, "*system*", (size_t )8);
    }
#line 566
    if (! tmp) {
#line 566
      if (*(curtab->name + 8)) {
#line 567
        goto while_break;
      }
    }
#line 565
    curtab = curtab->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 568
  return (curtab);
}
}
#line 582 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/database.c"
void force_rescan_user(cron_db *old_db , cron_db *new_db , char const   *fname , time_t old_mtime ) 
{ 
  user *u ;
  int *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 588
  u = find_user(old_db, (char *)fname);
  }
#line 589
  if ((unsigned long )u != (unsigned long )((void *)0)) {
    {
#line 591
    unlink_user(old_db, u);
#line 592
    free_user(u);
    }
  }
  {
#line 596
  tmp___0 = malloc(sizeof(user ));
#line 596
  u = (user *)tmp___0;
  }
#line 596
  if ((unsigned long )u == (unsigned long )((void *)0)) {
    {
#line 597
    tmp = __errno_location();
#line 597
    *tmp = 12;
    }
  }
  {
#line 599
  tmp___2 = strdup(fname);
#line 599
  u->name = tmp___2;
  }
#line 599
  if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
    {
#line 600
    free((void *)u);
#line 601
    tmp___1 = __errno_location();
#line 601
    *tmp___1 = 12;
    }
  }
  {
#line 603
  u->mtime = old_mtime;
#line 604
  u->crontab = (entry *)((void *)0);
#line 609
  link_user(new_db, u);
  }
#line 610
  return;
}
}
#line 613 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/database.c"
static orphan *orphans  ;
#line 615 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/database.c"
static void free_orphan(orphan *o ) 
{ 


  {
  {
#line 617
  free((void *)o->tabname);
#line 618
  free((void *)o->fname);
#line 619
  free((void *)o->uname);
#line 620
  free((void *)o);
  }
#line 621
  return;
}
}
#line 623 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/database.c"
void check_orphans(cron_db *db ) 
{ 
  orphan *prev_orphan ;
  orphan *o ;
  struct stat statbuf ;
  orphan *next ;
  struct passwd *tmp ;

  {
#line 625
  prev_orphan = (orphan *)((void *)0);
#line 626
  o = orphans;
  {
#line 629
  while (1) {
    while_continue: /* CIL Label */ ;
#line 629
    if (! ((unsigned long )o != (unsigned long )((void *)0))) {
#line 629
      goto while_break;
    }
    {
#line 630
    tmp = getpwnam((char const   *)o->uname);
    }
#line 630
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 631
      next = o->next;
#line 633
      if ((unsigned long )prev_orphan == (unsigned long )((void *)0)) {
#line 634
        orphans = next;
      } else {
#line 636
        prev_orphan->next = next;
      }
      {
#line 639
      process_crontab(o->uname, o->fname, o->tabname, & statbuf, db, (cron_db *)((void *)0));
      }
#line 643
      if ((unsigned long )prev_orphan == (unsigned long )((void *)0)) {
#line 643
        if ((unsigned long )orphans != (unsigned long )next) {
#line 644
          prev_orphan = orphans;
        }
      }
      {
#line 646
      free_orphan(o);
#line 647
      o = next;
      }
    } else {
#line 649
      prev_orphan = o;
#line 650
      o = o->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 653
  return;
}
}
#line 655 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/database.c"
static void add_orphan(char const   *uname , char const   *fname , char const   *tabname ) 
{ 
  orphan *o ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 659
  tmp = calloc((size_t )1, sizeof(*o));
#line 659
  o = (orphan *)tmp;
  }
#line 660
  if ((unsigned long )o == (unsigned long )((void *)0)) {
#line 661
    return;
  }
#line 663
  if (uname) {
    {
#line 664
    tmp___0 = strdup(uname);
#line 664
    o->uname = tmp___0;
    }
#line 664
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 665
      goto cleanup;
    }
  }
#line 667
  if (fname) {
    {
#line 668
    tmp___1 = strdup(fname);
#line 668
    o->fname = tmp___1;
    }
#line 668
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 669
      goto cleanup;
    }
  }
#line 671
  if (tabname) {
    {
#line 672
    tmp___2 = strdup(tabname);
#line 672
    o->tabname = tmp___2;
    }
#line 672
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 673
      goto cleanup;
    }
  }
#line 675
  o->next = orphans;
#line 676
  orphans = o;
#line 677
  return;
  cleanup: 
  {
#line 680
  free_orphan(o);
  }
#line 681
  return;
}
}
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 278
extern FILE *freopen(char const   * __restrict  __filename , char const   * __restrict  __modes ,
                     FILE * __restrict  __stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 584
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) setenv)(char const   *__name ,
                                                                                             char const   *__value ,
                                                                                             int __replace ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 583 "/usr/include/langinfo.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) nl_langinfo)(nl_item __item ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 239
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 224 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.h"
void set_cron_uid(void) ;
#line 224
void set_cron_cwd(void) ;
#line 224
void job_add(entry *e , user *u ) ;
#line 224
void acquire_daemonlock(int closeflag ) ;
#line 224
void log_close(void) ;
#line 243
int job_runqueue(void) ;
#line 243
int set_debug_flags(char *flags ) ;
#line 255
long get_gmtoff(time_t *clock___0 , struct tm *local ) ;
#line 281 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.h"
char *copyright[2]  = {      (char *)"@(#) Copyright 1988,1989,1990,1993,1994 by Paul Vixie",      (char *)"@(#) All rights reserved"};
#line 287 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.h"
char *MonthNames[13]  = 
#line 287
  {      (char *)"Jan",      (char *)"Feb",      (char *)"Mar",      (char *)"Apr", 
        (char *)"May",      (char *)"Jun",      (char *)"Jul",      (char *)"Aug", 
        (char *)"Sep",      (char *)"Oct",      (char *)"Nov",      (char *)"Dec", 
        (char *)((void *)0)};
#line 293 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.h"
char *DowNames[9]  = 
#line 293
  {      (char *)"Sun",      (char *)"Mon",      (char *)"Tue",      (char *)"Wed", 
        (char *)"Thu",      (char *)"Fri",      (char *)"Sat",      (char *)"Sun", 
        (char *)((void *)0)};
#line 298 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.h"
char *ProgramName  ;
#line 299 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.h"
int LineNumber  ;
#line 300 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.h"
time_t StartTime  ;
#line 301 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.h"
time_min timeRunning  ;
#line 302 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.h"
time_min virtualTime  ;
#line 303 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.h"
time_min clockTime  ;
#line 304 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.h"
static long GMToff  ;
#line 306 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.h"
int stay_foreground  ;
#line 307 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.h"
int lsbsysinit_mode  ;
#line 308 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.h"
int log_level  =    1;
#line 309 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.h"
char cron_default_mail_charset[1000]  = {      (char )'\000'};
#line 192 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) creat)(char const   *__file , mode_t __mode ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.c"
static void usage(void) ;
#line 32
static void run_reboot_jobs(cron_db *db ) ;
#line 32
static void find_jobs(time_min vtime , cron_db *db , int doWild , int doNonWild ) ;
#line 32
static void set_time(int initialize ) ;
#line 32
static void cron_sleep(time_min target ) ;
#line 32
static void sigchld_handler(int x ) ;
#line 32
static void sighup_handler(int x ) ;
#line 32
static void parse_args(int argc , char **argv ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.c"
static void usage(void) 
{ 


  {
  {
#line 54
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: %s\n",
          ProgramName);
#line 56
  exit(1);
  }
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.c"
int main(int argc , char **argv ) 
{ 
  cron_db database ;
  char *cs ;
  FILE *tmp ;
  int tmp___0 ;
  __pid_t tmp___2 ;
  __pid_t tmp___3 ;
  __pid_t tmp___4 ;
  time_min timeDiff ;
  int wakeupKind ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 68
  ProgramName = *(argv + 0);
#line 75
  parse_args(argc, argv);
#line 78
  signal(17, & sigchld_handler);
#line 82
  signal(1, & sighup_handler);
#line 87
  tmp = fdopen(0, "r");
  }
#line 87
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 88
    open("dev/null", 0);
    }
  }
  {
#line 91
  acquire_daemonlock(0);
#line 92
  set_cron_uid();
#line 93
  set_cron_cwd();
#line 96
  setenv("PATH", "/usr/bin:/bin", 1);
#line 102
  setlocale(6, "");
#line 104
  setlocale(3, "C");
#line 107
  cs = nl_langinfo(14);
  }
#line 107
  if ((unsigned long )cs != (unsigned long )((char *)0)) {
    {
#line 107
    tmp___0 = strcmp((char const   *)cs, "ANSI_x3.4-1968");
    }
#line 107
    if (tmp___0 != 0) {
      {
#line 109
      strncpy((char */* __restrict  */)(cron_default_mail_charset), (char const   */* __restrict  */)cs,
              (size_t )1000);
      }
    } else {
      {
#line 111
      strcpy((char */* __restrict  */)(cron_default_mail_charset), (char const   */* __restrict  */)"US-ASCII");
      }
    }
  } else {
    {
#line 111
    strcpy((char */* __restrict  */)(cron_default_mail_charset), (char const   */* __restrict  */)"US-ASCII");
    }
  }
#line 121
  if (! stay_foreground) {
    {
#line 122
    tmp___2 = fork();
    }
    {
#line 123
    if (tmp___2 == -1) {
#line 123
      goto case_neg_1;
    }
#line 127
    if (tmp___2 == 0) {
#line 127
      goto case_0;
    }
#line 135
    goto switch_default;
    case_neg_1: /* CIL Label */ 
    {
#line 124
    tmp___3 = getpid();
#line 124
    log_it((char *)"CRON", tmp___3, (char *)"DEATH", (char *)"can\'t fork");
#line 125
    exit(0);
    }
#line 126
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 129
    tmp___4 = getpid();
#line 129
    log_it((char *)"CRON", tmp___4, (char *)"STARTUP", (char *)"fork ok");
#line 130
    setsid();
#line 131
    freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"r",
            (FILE */* __restrict  */)stdin);
#line 132
    freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"w",
            (FILE */* __restrict  */)stdout);
#line 133
    freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"w",
            (FILE */* __restrict  */)stderr);
    }
#line 134
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 137
    _exit(0);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 141
  acquire_daemonlock(0);
#line 142
  database.head = (user *)((void *)0);
#line 143
  database.tail = (user *)((void *)0);
#line 144
  database.sys_mtime = (time_t )0;
#line 145
  database.user_mtime = (time_t )0;
#line 147
  database.sysd_mtime = (time_t )0;
#line 149
  load_database(& database);
#line 151
  set_time(1);
#line 152
  run_reboot_jobs(& database);
#line 153
  virtualTime = clockTime;
#line 153
  timeRunning = virtualTime;
  }
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 170
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 171
      cron_sleep(timeRunning + 1);
#line 172
      set_time(0);
      }
#line 170
      if (! (clockTime == timeRunning)) {
#line 170
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 174
    timeRunning = clockTime;
#line 176
    check_orphans(& database);
#line 177
    load_database(& database);
#line 184
    timeDiff = timeRunning - virtualTime;
    }
#line 190
    if (timeDiff == 1) {
      {
#line 191
      virtualTime = timeRunning;
#line 192
      find_jobs(virtualTime, & database, 1, 1);
      }
    } else {
#line 194
      wakeupKind = -1;
#line 195
      if (timeDiff > -180) {
#line 196
        wakeupKind = 0;
      }
#line 197
      if (timeDiff > 0) {
#line 198
        wakeupKind = 1;
      }
#line 199
      if (timeDiff > 5) {
#line 200
        wakeupKind = 2;
      }
#line 201
      if (timeDiff > 180) {
#line 202
        wakeupKind = 3;
      }
      {
#line 205
      if (wakeupKind == 1) {
#line 205
        goto case_1;
      }
#line 221
      if (wakeupKind == 2) {
#line 221
        goto case_2;
      }
#line 247
      if (wakeupKind == 0) {
#line 247
        goto case_0___0;
      }
#line 259
      goto switch_default___0;
      case_1: /* CIL Label */ ;
      {
#line 213
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 214
        tmp___5 = job_runqueue();
        }
#line 214
        if (tmp___5) {
          {
#line 215
          sleep(10U);
          }
        }
        {
#line 216
        virtualTime ++;
#line 217
        find_jobs(virtualTime, & database, 1, 1);
        }
#line 213
        if (! (virtualTime < timeRunning)) {
#line 213
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 219
      goto switch_break___0;
      case_2: /* CIL Label */ 
      {
#line 234
      find_jobs(timeRunning, & database, 1, 0);
      }
      {
#line 237
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 238
        tmp___6 = job_runqueue();
        }
#line 238
        if (tmp___6) {
          {
#line 239
          sleep(10U);
          }
        }
        {
#line 240
        virtualTime ++;
#line 241
        find_jobs(virtualTime, & database, 0, 1);
#line 242
        set_time(0);
        }
#line 237
        if (virtualTime < timeRunning) {
#line 237
          if (! (clockTime == timeRunning)) {
#line 237
            goto while_break___2;
          }
        } else {
#line 237
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 245
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
      {
#line 257
      find_jobs(timeRunning, & database, 1, 0);
      }
#line 258
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
      {
#line 265
      virtualTime = timeRunning;
#line 266
      find_jobs(timeRunning, & database, 1, 1);
      }
      switch_break___0: /* CIL Label */ ;
      }
    }
    {
#line 270
    job_runqueue();
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 279 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.c"
static void run_reboot_jobs(cron_db *db ) 
{ 
  register user *u ;
  register entry *e ;
  int rbfd ;
  __pid_t tmp ;
  int tmp___0 ;
  __pid_t tmp___1 ;
  __pid_t tmp___2 ;

  {
  {
#line 289
  tmp___0 = access("/var/run/crond.reboot", 0);
  }
#line 289
  if (tmp___0 == 0) {
    {
#line 291
    tmp = getpid();
#line 291
    log_it((char *)"CRON", tmp, (char *)"INFO", (char *)"Skipping @reboot jobs -- not system startup");
    }
#line 293
    return;
  }
  {
#line 296
  rbfd = creat("/var/run/crond.reboot", (mode_t )0);
  }
#line 296
  if (rbfd < 0) {
    {
#line 298
    tmp___1 = getpid();
#line 298
    log_it((char *)"CRON", tmp___1, (char *)"DEATH", (char *)"Can\'t create reboot check file");
#line 299
    exit(0);
    }
  } else {
    {
#line 301
    close(rbfd);
#line 302
    tmp___2 = getpid();
#line 302
    log_it((char *)"CRON", tmp___2, (char *)"INFO", (char *)"Running @reboot jobs");
    }
  }
#line 310
  u = db->head;
  {
#line 310
  while (1) {
    while_continue: /* CIL Label */ ;
#line 310
    if (! ((unsigned long )u != (unsigned long )((void *)0))) {
#line 310
      goto while_break;
    }
#line 311
    e = u->crontab;
    {
#line 311
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 311
      if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 311
        goto while_break___0;
      }
#line 312
      if (e->flags & 4) {
        {
#line 313
        job_add(e, u);
        }
      }
#line 311
      e = e->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 310
    u = u->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 317
  job_runqueue();
  }
#line 318
  return;
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.c"
static void find_jobs(time_min vtime , cron_db *db , int doWild , int doNonWild ) 
{ 
  time_t virtualSecond ;
  register struct tm *tm ;
  struct tm *tmp ;
  register int minute ;
  register int hour ;
  register int dom ;
  register int month ;
  register int dow ;
  register user *u ;
  register entry *e ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 328
  virtualSecond = (time_t )(vtime * 60);
#line 329
  tmp = gmtime((time_t const   *)(& virtualSecond));
#line 329
  tm = tmp;
#line 336
  minute = tm->tm_min;
#line 337
  hour = tm->tm_hour;
#line 338
  dom = tm->tm_mday - 1;
#line 339
  month = (tm->tm_mon + 1) - 1;
#line 340
  dow = tm->tm_wday;
#line 352
  u = db->head;
  }
  {
#line 352
  while (1) {
    while_continue: /* CIL Label */ ;
#line 352
    if (! ((unsigned long )u != (unsigned long )((void *)0))) {
#line 352
      goto while_break;
    }
#line 353
    e = u->crontab;
    {
#line 353
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 353
      if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 353
        goto while_break___0;
      }
#line 357
      if ((int )e->minute[minute >> 3] & (1 << (minute & 7))) {
#line 357
        if ((int )e->hour[hour >> 3] & (1 << (hour & 7))) {
#line 357
          if ((int )e->month[month >> 3] & (1 << (month & 7))) {
#line 357
            if (e->flags & 1) {
#line 357
              goto _L___0;
            } else
#line 357
            if (e->flags & 2) {
              _L___0: /* CIL Label */ 
#line 357
              if ((int )e->dow[dow >> 3] & (1 << (dow & 7))) {
#line 357
                if ((int )e->dom[dom >> 3] & (1 << (dom & 7))) {
#line 357
                  tmp___0 = 1;
                } else {
#line 357
                  tmp___0 = 0;
                }
              } else {
#line 357
                tmp___0 = 0;
              }
#line 357
              tmp___2 = tmp___0;
            } else {
#line 357
              if ((int )e->dow[dow >> 3] & (1 << (dow & 7))) {
#line 357
                tmp___1 = 1;
              } else
#line 357
              if ((int )e->dom[dom >> 3] & (1 << (dom & 7))) {
#line 357
                tmp___1 = 1;
              } else {
#line 357
                tmp___1 = 0;
              }
#line 357
              tmp___2 = tmp___1;
            }
#line 357
            if (tmp___2) {
#line 363
              if (doNonWild) {
#line 363
                if (! (e->flags & 24)) {
                  {
#line 365
                  job_add(e, u);
                  }
                } else {
#line 363
                  goto _L;
                }
              } else
              _L: /* CIL Label */ 
#line 363
              if (doWild) {
#line 363
                if (e->flags & 24) {
                  {
#line 365
                  job_add(e, u);
                  }
                }
              }
            }
          }
        }
      }
#line 353
      e = e->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 352
    u = u->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 369
  return;
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.c"
static int isdst  ;
#line 377 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.c"
static void set_time(int initialize ) 
{ 
  struct tm tm ;
  struct tm *tmp ;

  {
  {
#line 383
  StartTime = time((time_t *)((void *)0));
#line 386
  tmp = localtime((time_t const   *)(& StartTime));
#line 386
  tm = *tmp;
  }
#line 387
  if (initialize) {
    {
#line 388
    isdst = tm.tm_isdst;
#line 389
    GMToff = get_gmtoff(& StartTime, & tm);
    }
  } else
#line 387
  if (tm.tm_isdst != isdst) {
    {
#line 388
    isdst = tm.tm_isdst;
#line 389
    GMToff = get_gmtoff(& StartTime, & tm);
    }
  }
#line 393
  clockTime = (time_min )((StartTime + GMToff) / 60L);
#line 394
  return;
}
}
#line 399 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.c"
static void cron_sleep(time_min target ) 
{ 
  time_t t ;
  int seconds_to_wait ;
  time_t tmp ;

  {
  {
#line 406
  tmp = time((time_t *)((void *)0));
#line 406
  t = tmp + GMToff;
#line 408
  seconds_to_wait = (int )((time_t )(target * 60) - t) + 1;
  }
#line 412
  if (seconds_to_wait > 0) {
#line 412
    if (seconds_to_wait < 65) {
      {
#line 413
      sleep((unsigned int )seconds_to_wait);
      }
    }
  }
#line 414
  return;
}
}
#line 418 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.c"
static void sigchld_handler(int x ) 
{ 
  int save_errno ;
  int *tmp ;
  int waiter ;
  pid_t pid ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 420
  tmp = __errno_location();
#line 420
  save_errno = *tmp;
  }
  {
#line 424
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 426
    pid = waitpid(-1, & waiter, 1);
    }
    {
#line 431
    if (pid == -1) {
#line 431
      goto case_neg_1;
    }
#line 436
    if (pid == 0) {
#line 436
      goto case_0;
    }
#line 441
    goto switch_default;
    case_neg_1: /* CIL Label */ 
    {
#line 434
    tmp___0 = __errno_location();
#line 434
    *tmp___0 = save_errno;
    }
#line 435
    return;
    case_0: /* CIL Label */ 
    {
#line 439
    tmp___1 = __errno_location();
#line 439
    *tmp___1 = save_errno;
    }
#line 440
    return;
    switch_default: /* CIL Label */ ;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 447
  tmp___2 = __errno_location();
#line 447
  *tmp___2 = save_errno;
  }
}
}
#line 452 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.c"
static void sighup_handler(int x ) 
{ 


  {
  {
#line 454
  log_close();
#line 458
  signal(1, & sighup_handler);
  }
#line 459
  return;
}
}
#line 462 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.c"
static void parse_args(int argc , char **argv ) 
{ 
  int argch ;
  int tmp ;

  {
#line 469
  log_level = 1;
#line 470
  stay_foreground = 0;
#line 471
  lsbsysinit_mode = 0;
  {
#line 473
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 473
    argch = getopt(argc, (char * const  *)argv, "lfx:L:");
    }
#line 473
    if (! (-1 != argch)) {
#line 473
      goto while_break;
    }
    {
#line 477
    if (argch == 102) {
#line 477
      goto case_102;
    }
#line 480
    if (argch == 120) {
#line 480
      goto case_120;
    }
#line 484
    if (argch == 108) {
#line 484
      goto case_108;
    }
#line 487
    if (argch == 76) {
#line 487
      goto case_76;
    }
#line 475
    goto switch_default;
    switch_default: /* CIL Label */ 
    {
#line 476
    usage();
    }
    case_102: /* CIL Label */ 
#line 478
    stay_foreground = 1;
#line 479
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 481
    tmp = set_debug_flags(optarg);
    }
#line 481
    if (! tmp) {
      {
#line 482
      usage();
      }
    }
#line 483
    goto switch_break;
    case_108: /* CIL Label */ 
#line 485
    lsbsysinit_mode = 1;
#line 486
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 488
    log_level = atoi((char const   *)optarg);
    }
#line 489
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 492
  return;
}
}
#line 534 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 224 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.h"
void unget_char(int ch , FILE *file ) ;
#line 243
int get_char(FILE *file ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/entry.c"
static char get_list(bitstr_t *bits , int low , int high , char **names , int ch ,
                     FILE *file ) ;
#line 37
static char get_range(bitstr_t *bits , int low , int high , char **names , int ch ,
                      FILE *file ) ;
#line 37
static char get_number(int *numptr , int low , char **names , int ch , FILE *file ) ;
#line 40
static int set_element(bitstr_t *bits , int low , int high , int number ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/entry.c"
static char *ecodes[9]  = 
#line 42
  {      (char *)"no error",      (char *)"bad minute",      (char *)"bad hour",      (char *)"bad day-of-month", 
        (char *)"bad month",      (char *)"bad day-of-week",      (char *)"bad command",      (char *)"bad time specifier", 
        (char *)"bad username"};
#line 56 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/entry.c"
void free_entry(entry *e ) 
{ 


  {
  {
#line 60
  free((void *)e->cmd);
#line 61
  env_free(e->envp);
#line 62
  free((void *)e);
  }
#line 63
  return;
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/entry.c"
entry *load_entry(FILE *file , void (*error_func)() , struct passwd *pw___0 , char **envp ) 
{ 
  ecode_e ecode ;
  entry *e ;
  int ch ;
  char cmd[1000] ;
  char envstr[1000] ;
  char **tenvp ;
  void *tmp ;
  register bitstr_t *_name ;
  register int _start ;
  register int _stop ;
  register int _startbyte ;
  register int _stopbyte ;
  register bitstr_t *_name___0 ;
  register int _start___0 ;
  register int _stop___0 ;
  register int _startbyte___0 ;
  register int _stopbyte___0 ;
  register bitstr_t *_name___1 ;
  register int _start___1 ;
  register int _stop___1 ;
  register int _startbyte___1 ;
  register int _stopbyte___1 ;
  register bitstr_t *_name___2 ;
  register int _start___2 ;
  register int _stop___2 ;
  register int _startbyte___2 ;
  register int _stopbyte___2 ;
  register bitstr_t *_name___3 ;
  register int _start___3 ;
  register int _stop___3 ;
  register int _startbyte___3 ;
  register int _stopbyte___3 ;
  register bitstr_t *_name___4 ;
  register int _start___4 ;
  register int _stop___4 ;
  register int _startbyte___4 ;
  register int _stopbyte___4 ;
  register bitstr_t *_name___5 ;
  register int _start___5 ;
  register int _stop___5 ;
  register int _startbyte___5 ;
  register int _stopbyte___5 ;
  register bitstr_t *_name___6 ;
  register int _start___6 ;
  register int _stop___6 ;
  register int _startbyte___6 ;
  register int _stopbyte___6 ;
  register bitstr_t *_name___7 ;
  register int _start___7 ;
  register int _stop___7 ;
  register int _startbyte___7 ;
  register int _stopbyte___7 ;
  register bitstr_t *_name___8 ;
  register int _start___8 ;
  register int _stop___8 ;
  register int _startbyte___8 ;
  register int _stopbyte___8 ;
  register bitstr_t *_name___9 ;
  register int _start___9 ;
  register int _stop___9 ;
  register int _startbyte___9 ;
  register int _stopbyte___9 ;
  register bitstr_t *_name___10 ;
  register int _start___10 ;
  register int _stop___10 ;
  register int _startbyte___10 ;
  register int _stopbyte___10 ;
  register bitstr_t *_name___11 ;
  register int _start___11 ;
  register int _stop___11 ;
  register int _startbyte___11 ;
  register int _stopbyte___11 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char tmp___8 ;
  char tmp___9 ;
  char tmp___10 ;
  char tmp___11 ;
  char tmp___12 ;
  char *username ;
  char **tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;

  {
  {
#line 89
  ecode = (ecode_e )0;
#line 98
  skip_comments(file);
#line 100
  ch = get_char(file);
  }
#line 101
  if (ch == -1) {
#line 102
    return ((entry *)((void *)0));
  }
  {
#line 109
  tmp = calloc(sizeof(entry ), sizeof(char ));
#line 109
  e = (entry *)tmp;
  }
#line 111
  if (ch == 64) {
    {
#line 124
    ch = get_string(cmd, 1000, file, (char *)" \t\n");
#line 125
    tmp___7 = strcmp("reboot", (char const   *)(cmd));
    }
#line 125
    if (tmp___7) {
      {
#line 127
      tmp___5 = strcmp("yearly", (char const   *)(cmd));
      }
#line 127
      if (tmp___5) {
        {
#line 127
        tmp___6 = strcmp("annually", (char const   *)(cmd));
        }
#line 127
        if (tmp___6) {
          {
#line 134
          tmp___4 = strcmp("monthly", (char const   *)(cmd));
          }
#line 134
          if (tmp___4) {
            {
#line 141
            tmp___3 = strcmp("weekly", (char const   *)(cmd));
            }
#line 141
            if (tmp___3) {
              {
#line 148
              tmp___1 = strcmp("daily", (char const   *)(cmd));
              }
#line 148
              if (tmp___1) {
                {
#line 148
                tmp___2 = strcmp("midnight", (char const   *)(cmd));
                }
#line 148
                if (tmp___2) {
                  {
#line 154
                  tmp___0 = strcmp("hourly", (char const   *)(cmd));
                  }
#line 154
                  if (tmp___0) {
#line 162
                    ecode = (ecode_e )7;
#line 163
                    goto eof;
                  } else {
#line 155
                    e->minute[0] = (bitstr_t )((int )e->minute[0] | 1);
#line 156
                    _name___8 = e->hour;
#line 156
                    _start___8 = 0;
#line 156
                    _stop___8 = 24;
#line 156
                    _startbyte___8 = _start___8 >> 3;
#line 156
                    _stopbyte___8 = _stop___8 >> 3;
#line 156
                    if (_startbyte___8 == _stopbyte___8) {
#line 156
                      *(_name___8 + _startbyte___8) = (bitstr_t )((int )*(_name___8 + _startbyte___8) | ((255 << (_start___8 & 7)) & (255 >> (7 - (_stop___8 & 7)))));
                    } else {
#line 156
                      *(_name___8 + _startbyte___8) = (bitstr_t )((int )*(_name___8 + _startbyte___8) | (255 << (_start___8 & 7)));
                      {
#line 156
                      while (1) {
                        while_continue: /* CIL Label */ ;
#line 156
                        _startbyte___8 ++;
#line 156
                        if (! (_startbyte___8 < _stopbyte___8)) {
#line 156
                          goto while_break;
                        }
#line 156
                        *(_name___8 + _startbyte___8) = (bitstr_t )255;
                      }
                      while_break: /* CIL Label */ ;
                      }
#line 156
                      *(_name___8 + _stopbyte___8) = (bitstr_t )((int )*(_name___8 + _stopbyte___8) | (255 >> (7 - (_stop___8 & 7))));
                    }
#line 157
                    _name___9 = e->dom;
#line 157
                    _start___9 = 0;
#line 157
                    _stop___9 = 31;
#line 157
                    _startbyte___9 = _start___9 >> 3;
#line 157
                    _stopbyte___9 = _stop___9 >> 3;
#line 157
                    if (_startbyte___9 == _stopbyte___9) {
#line 157
                      *(_name___9 + _startbyte___9) = (bitstr_t )((int )*(_name___9 + _startbyte___9) | ((255 << (_start___9 & 7)) & (255 >> (7 - (_stop___9 & 7)))));
                    } else {
#line 157
                      *(_name___9 + _startbyte___9) = (bitstr_t )((int )*(_name___9 + _startbyte___9) | (255 << (_start___9 & 7)));
                      {
#line 157
                      while (1) {
                        while_continue___0: /* CIL Label */ ;
#line 157
                        _startbyte___9 ++;
#line 157
                        if (! (_startbyte___9 < _stopbyte___9)) {
#line 157
                          goto while_break___0;
                        }
#line 157
                        *(_name___9 + _startbyte___9) = (bitstr_t )255;
                      }
                      while_break___0: /* CIL Label */ ;
                      }
#line 157
                      *(_name___9 + _stopbyte___9) = (bitstr_t )((int )*(_name___9 + _stopbyte___9) | (255 >> (7 - (_stop___9 & 7))));
                    }
#line 158
                    _name___10 = e->month;
#line 158
                    _start___10 = 0;
#line 158
                    _stop___10 = 12;
#line 158
                    _startbyte___10 = _start___10 >> 3;
#line 158
                    _stopbyte___10 = _stop___10 >> 3;
#line 158
                    if (_startbyte___10 == _stopbyte___10) {
#line 158
                      *(_name___10 + _startbyte___10) = (bitstr_t )((int )*(_name___10 + _startbyte___10) | ((255 << (_start___10 & 7)) & (255 >> (7 - (_stop___10 & 7)))));
                    } else {
#line 158
                      *(_name___10 + _startbyte___10) = (bitstr_t )((int )*(_name___10 + _startbyte___10) | (255 << (_start___10 & 7)));
                      {
#line 158
                      while (1) {
                        while_continue___1: /* CIL Label */ ;
#line 158
                        _startbyte___10 ++;
#line 158
                        if (! (_startbyte___10 < _stopbyte___10)) {
#line 158
                          goto while_break___1;
                        }
#line 158
                        *(_name___10 + _startbyte___10) = (bitstr_t )255;
                      }
                      while_break___1: /* CIL Label */ ;
                      }
#line 158
                      *(_name___10 + _stopbyte___10) = (bitstr_t )((int )*(_name___10 + _stopbyte___10) | (255 >> (7 - (_stop___10 & 7))));
                    }
#line 159
                    _name___11 = e->dow;
#line 159
                    _start___11 = 0;
#line 159
                    _stop___11 = 8;
#line 159
                    _startbyte___11 = _start___11 >> 3;
#line 159
                    _stopbyte___11 = _stop___11 >> 3;
#line 159
                    if (_startbyte___11 == _stopbyte___11) {
#line 159
                      *(_name___11 + _startbyte___11) = (bitstr_t )((int )*(_name___11 + _startbyte___11) | ((255 << (_start___11 & 7)) & (255 >> (7 - (_stop___11 & 7)))));
                    } else {
#line 159
                      *(_name___11 + _startbyte___11) = (bitstr_t )((int )*(_name___11 + _startbyte___11) | (255 << (_start___11 & 7)));
                      {
#line 159
                      while (1) {
                        while_continue___2: /* CIL Label */ ;
#line 159
                        _startbyte___11 ++;
#line 159
                        if (! (_startbyte___11 < _stopbyte___11)) {
#line 159
                          goto while_break___2;
                        }
#line 159
                        *(_name___11 + _startbyte___11) = (bitstr_t )255;
                      }
                      while_break___2: /* CIL Label */ ;
                      }
#line 159
                      *(_name___11 + _stopbyte___11) = (bitstr_t )((int )*(_name___11 + _stopbyte___11) | (255 >> (7 - (_stop___11 & 7))));
                    }
#line 160
                    e->flags |= 16;
                  }
                } else {
                  _L: /* CIL Label */ 
#line 149
                  e->minute[0] = (bitstr_t )((int )e->minute[0] | 1);
#line 150
                  e->hour[0] = (bitstr_t )((int )e->hour[0] | 1);
#line 151
                  _name___5 = e->dom;
#line 151
                  _start___5 = 0;
#line 151
                  _stop___5 = 31;
#line 151
                  _startbyte___5 = _start___5 >> 3;
#line 151
                  _stopbyte___5 = _stop___5 >> 3;
#line 151
                  if (_startbyte___5 == _stopbyte___5) {
#line 151
                    *(_name___5 + _startbyte___5) = (bitstr_t )((int )*(_name___5 + _startbyte___5) | ((255 << (_start___5 & 7)) & (255 >> (7 - (_stop___5 & 7)))));
                  } else {
#line 151
                    *(_name___5 + _startbyte___5) = (bitstr_t )((int )*(_name___5 + _startbyte___5) | (255 << (_start___5 & 7)));
                    {
#line 151
                    while (1) {
                      while_continue___3: /* CIL Label */ ;
#line 151
                      _startbyte___5 ++;
#line 151
                      if (! (_startbyte___5 < _stopbyte___5)) {
#line 151
                        goto while_break___3;
                      }
#line 151
                      *(_name___5 + _startbyte___5) = (bitstr_t )255;
                    }
                    while_break___3: /* CIL Label */ ;
                    }
#line 151
                    *(_name___5 + _stopbyte___5) = (bitstr_t )((int )*(_name___5 + _stopbyte___5) | (255 >> (7 - (_stop___5 & 7))));
                  }
#line 152
                  _name___6 = e->month;
#line 152
                  _start___6 = 0;
#line 152
                  _stop___6 = 12;
#line 152
                  _startbyte___6 = _start___6 >> 3;
#line 152
                  _stopbyte___6 = _stop___6 >> 3;
#line 152
                  if (_startbyte___6 == _stopbyte___6) {
#line 152
                    *(_name___6 + _startbyte___6) = (bitstr_t )((int )*(_name___6 + _startbyte___6) | ((255 << (_start___6 & 7)) & (255 >> (7 - (_stop___6 & 7)))));
                  } else {
#line 152
                    *(_name___6 + _startbyte___6) = (bitstr_t )((int )*(_name___6 + _startbyte___6) | (255 << (_start___6 & 7)));
                    {
#line 152
                    while (1) {
                      while_continue___4: /* CIL Label */ ;
#line 152
                      _startbyte___6 ++;
#line 152
                      if (! (_startbyte___6 < _stopbyte___6)) {
#line 152
                        goto while_break___4;
                      }
#line 152
                      *(_name___6 + _startbyte___6) = (bitstr_t )255;
                    }
                    while_break___4: /* CIL Label */ ;
                    }
#line 152
                    *(_name___6 + _stopbyte___6) = (bitstr_t )((int )*(_name___6 + _stopbyte___6) | (255 >> (7 - (_stop___6 & 7))));
                  }
#line 153
                  _name___7 = e->dow;
#line 153
                  _start___7 = 0;
#line 153
                  _stop___7 = 8;
#line 153
                  _startbyte___7 = _start___7 >> 3;
#line 153
                  _stopbyte___7 = _stop___7 >> 3;
#line 153
                  if (_startbyte___7 == _stopbyte___7) {
#line 153
                    *(_name___7 + _startbyte___7) = (bitstr_t )((int )*(_name___7 + _startbyte___7) | ((255 << (_start___7 & 7)) & (255 >> (7 - (_stop___7 & 7)))));
                  } else {
#line 153
                    *(_name___7 + _startbyte___7) = (bitstr_t )((int )*(_name___7 + _startbyte___7) | (255 << (_start___7 & 7)));
                    {
#line 153
                    while (1) {
                      while_continue___5: /* CIL Label */ ;
#line 153
                      _startbyte___7 ++;
#line 153
                      if (! (_startbyte___7 < _stopbyte___7)) {
#line 153
                        goto while_break___5;
                      }
#line 153
                      *(_name___7 + _startbyte___7) = (bitstr_t )255;
                    }
                    while_break___5: /* CIL Label */ ;
                    }
#line 153
                    *(_name___7 + _stopbyte___7) = (bitstr_t )((int )*(_name___7 + _stopbyte___7) | (255 >> (7 - (_stop___7 & 7))));
                  }
                }
              } else {
#line 148
                goto _L;
              }
            } else {
#line 142
              e->minute[0] = (bitstr_t )((int )e->minute[0] | 1);
#line 143
              e->hour[0] = (bitstr_t )((int )e->hour[0] | 1);
#line 144
              _name___2 = e->dom;
#line 144
              _start___2 = 0;
#line 144
              _stop___2 = 31;
#line 144
              _startbyte___2 = _start___2 >> 3;
#line 144
              _stopbyte___2 = _stop___2 >> 3;
#line 144
              if (_startbyte___2 == _stopbyte___2) {
#line 144
                *(_name___2 + _startbyte___2) = (bitstr_t )((int )*(_name___2 + _startbyte___2) | ((255 << (_start___2 & 7)) & (255 >> (7 - (_stop___2 & 7)))));
              } else {
#line 144
                *(_name___2 + _startbyte___2) = (bitstr_t )((int )*(_name___2 + _startbyte___2) | (255 << (_start___2 & 7)));
                {
#line 144
                while (1) {
                  while_continue___6: /* CIL Label */ ;
#line 144
                  _startbyte___2 ++;
#line 144
                  if (! (_startbyte___2 < _stopbyte___2)) {
#line 144
                    goto while_break___6;
                  }
#line 144
                  *(_name___2 + _startbyte___2) = (bitstr_t )255;
                }
                while_break___6: /* CIL Label */ ;
                }
#line 144
                *(_name___2 + _stopbyte___2) = (bitstr_t )((int )*(_name___2 + _stopbyte___2) | (255 >> (7 - (_stop___2 & 7))));
              }
#line 145
              e->flags |= 1;
#line 146
              _name___3 = e->month;
#line 146
              _start___3 = 0;
#line 146
              _stop___3 = 12;
#line 146
              _startbyte___3 = _start___3 >> 3;
#line 146
              _stopbyte___3 = _stop___3 >> 3;
#line 146
              if (_startbyte___3 == _stopbyte___3) {
#line 146
                *(_name___3 + _startbyte___3) = (bitstr_t )((int )*(_name___3 + _startbyte___3) | ((255 << (_start___3 & 7)) & (255 >> (7 - (_stop___3 & 7)))));
              } else {
#line 146
                *(_name___3 + _startbyte___3) = (bitstr_t )((int )*(_name___3 + _startbyte___3) | (255 << (_start___3 & 7)));
                {
#line 146
                while (1) {
                  while_continue___7: /* CIL Label */ ;
#line 146
                  _startbyte___3 ++;
#line 146
                  if (! (_startbyte___3 < _stopbyte___3)) {
#line 146
                    goto while_break___7;
                  }
#line 146
                  *(_name___3 + _startbyte___3) = (bitstr_t )255;
                }
                while_break___7: /* CIL Label */ ;
                }
#line 146
                *(_name___3 + _stopbyte___3) = (bitstr_t )((int )*(_name___3 + _stopbyte___3) | (255 >> (7 - (_stop___3 & 7))));
              }
#line 147
              _name___4 = e->dow;
#line 147
              _start___4 = 0;
#line 147
              _stop___4 = 0;
#line 147
              _startbyte___4 = _start___4 >> 3;
#line 147
              _stopbyte___4 = _stop___4 >> 3;
#line 147
              if (_startbyte___4 == _stopbyte___4) {
#line 147
                *(_name___4 + _startbyte___4) = (bitstr_t )((int )*(_name___4 + _startbyte___4) | ((255 << (_start___4 & 7)) & (255 >> (7 - (_stop___4 & 7)))));
              } else {
#line 147
                *(_name___4 + _startbyte___4) = (bitstr_t )((int )*(_name___4 + _startbyte___4) | (255 << (_start___4 & 7)));
                {
#line 147
                while (1) {
                  while_continue___8: /* CIL Label */ ;
#line 147
                  _startbyte___4 ++;
#line 147
                  if (! (_startbyte___4 < _stopbyte___4)) {
#line 147
                    goto while_break___8;
                  }
#line 147
                  *(_name___4 + _startbyte___4) = (bitstr_t )255;
                }
                while_break___8: /* CIL Label */ ;
                }
#line 147
                *(_name___4 + _stopbyte___4) = (bitstr_t )((int )*(_name___4 + _stopbyte___4) | (255 >> (7 - (_stop___4 & 7))));
              }
            }
          } else {
#line 135
            e->minute[0] = (bitstr_t )((int )e->minute[0] | 1);
#line 136
            e->hour[0] = (bitstr_t )((int )e->hour[0] | 1);
#line 137
            e->dom[0] = (bitstr_t )((int )e->dom[0] | 1);
#line 138
            _name___0 = e->month;
#line 138
            _start___0 = 0;
#line 138
            _stop___0 = 12;
#line 138
            _startbyte___0 = _start___0 >> 3;
#line 138
            _stopbyte___0 = _stop___0 >> 3;
#line 138
            if (_startbyte___0 == _stopbyte___0) {
#line 138
              *(_name___0 + _startbyte___0) = (bitstr_t )((int )*(_name___0 + _startbyte___0) | ((255 << (_start___0 & 7)) & (255 >> (7 - (_stop___0 & 7)))));
            } else {
#line 138
              *(_name___0 + _startbyte___0) = (bitstr_t )((int )*(_name___0 + _startbyte___0) | (255 << (_start___0 & 7)));
              {
#line 138
              while (1) {
                while_continue___9: /* CIL Label */ ;
#line 138
                _startbyte___0 ++;
#line 138
                if (! (_startbyte___0 < _stopbyte___0)) {
#line 138
                  goto while_break___9;
                }
#line 138
                *(_name___0 + _startbyte___0) = (bitstr_t )255;
              }
              while_break___9: /* CIL Label */ ;
              }
#line 138
              *(_name___0 + _stopbyte___0) = (bitstr_t )((int )*(_name___0 + _stopbyte___0) | (255 >> (7 - (_stop___0 & 7))));
            }
#line 139
            _name___1 = e->dow;
#line 139
            _start___1 = 0;
#line 139
            _stop___1 = 8;
#line 139
            _startbyte___1 = _start___1 >> 3;
#line 139
            _stopbyte___1 = _stop___1 >> 3;
#line 139
            if (_startbyte___1 == _stopbyte___1) {
#line 139
              *(_name___1 + _startbyte___1) = (bitstr_t )((int )*(_name___1 + _startbyte___1) | ((255 << (_start___1 & 7)) & (255 >> (7 - (_stop___1 & 7)))));
            } else {
#line 139
              *(_name___1 + _startbyte___1) = (bitstr_t )((int )*(_name___1 + _startbyte___1) | (255 << (_start___1 & 7)));
              {
#line 139
              while (1) {
                while_continue___10: /* CIL Label */ ;
#line 139
                _startbyte___1 ++;
#line 139
                if (! (_startbyte___1 < _stopbyte___1)) {
#line 139
                  goto while_break___10;
                }
#line 139
                *(_name___1 + _startbyte___1) = (bitstr_t )255;
              }
              while_break___10: /* CIL Label */ ;
              }
#line 139
              *(_name___1 + _stopbyte___1) = (bitstr_t )((int )*(_name___1 + _stopbyte___1) | (255 >> (7 - (_stop___1 & 7))));
            }
#line 140
            e->flags |= 2;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 128
          e->minute[0] = (bitstr_t )((int )e->minute[0] | 1);
#line 129
          e->hour[0] = (bitstr_t )((int )e->hour[0] | 1);
#line 130
          e->dom[0] = (bitstr_t )((int )e->dom[0] | 1);
#line 131
          e->month[0] = (bitstr_t )((int )e->month[0] | 1);
#line 132
          _name = e->dow;
#line 132
          _start = 0;
#line 132
          _stop = 8;
#line 132
          _startbyte = _start >> 3;
#line 132
          _stopbyte = _stop >> 3;
#line 132
          if (_startbyte == _stopbyte) {
#line 132
            *(_name + _startbyte) = (bitstr_t )((int )*(_name + _startbyte) | ((255 << (_start & 7)) & (255 >> (7 - (_stop & 7)))));
          } else {
#line 132
            *(_name + _startbyte) = (bitstr_t )((int )*(_name + _startbyte) | (255 << (_start & 7)));
            {
#line 132
            while (1) {
              while_continue___11: /* CIL Label */ ;
#line 132
              _startbyte ++;
#line 132
              if (! (_startbyte < _stopbyte)) {
#line 132
                goto while_break___11;
              }
#line 132
              *(_name + _startbyte) = (bitstr_t )255;
            }
            while_break___11: /* CIL Label */ ;
            }
#line 132
            *(_name + _stopbyte) = (bitstr_t )((int )*(_name + _stopbyte) | (255 >> (7 - (_stop & 7))));
          }
#line 133
          e->flags |= 2;
        }
      } else {
#line 127
        goto _L___0;
      }
    } else {
#line 126
      e->flags |= 4;
    }
  } else {
#line 168
    if (ch == 42) {
#line 169
      e->flags |= 8;
    }
    {
#line 170
    tmp___8 = get_list(e->minute, 0, 59, (char **)((void *)0), ch, file);
#line 170
    ch = (int )tmp___8;
    }
#line 172
    if (ch == -1) {
#line 173
      ecode = (ecode_e )1;
#line 174
      goto eof;
    }
#line 180
    if (ch == 42) {
#line 181
      e->flags |= 16;
    }
    {
#line 182
    tmp___9 = get_list(e->hour, 0, 23, (char **)((void *)0), ch, file);
#line 182
    ch = (int )tmp___9;
    }
#line 184
    if (ch == -1) {
#line 185
      ecode = (ecode_e )2;
#line 186
      goto eof;
    }
#line 192
    if (ch == 42) {
#line 193
      e->flags |= 1;
    }
    {
#line 194
    tmp___10 = get_list(e->dom, 1, 31, (char **)((void *)0), ch, file);
#line 194
    ch = (int )tmp___10;
    }
#line 196
    if (ch == -1) {
#line 197
      ecode = (ecode_e )3;
#line 198
      goto eof;
    }
    {
#line 204
    tmp___11 = get_list(e->month, 1, 12, MonthNames, ch, file);
#line 204
    ch = (int )tmp___11;
    }
#line 206
    if (ch == -1) {
#line 207
      ecode = (ecode_e )4;
#line 208
      goto eof;
    }
#line 214
    if (ch == 42) {
#line 215
      e->flags |= 2;
    }
    {
#line 216
    tmp___12 = get_list(e->dow, 0, 7, DowNames, ch, file);
#line 216
    ch = (int )tmp___12;
    }
#line 218
    if (ch == -1) {
#line 219
      ecode = (ecode_e )5;
#line 220
      goto eof;
    }
  }
#line 225
  if ((int )e->dow[0] & 1) {
#line 226
    e->dow[0] = (bitstr_t )((int )e->dow[0] | 1);
#line 227
    e->dow[7 >> 3] = (bitstr_t )((int )e->dow[7 >> 3] | (1 << 7));
  } else
#line 225
  if ((int )e->dow[7 >> 3] & (1 << 7)) {
#line 226
    e->dow[0] = (bitstr_t )((int )e->dow[0] | 1);
#line 227
    e->dow[7 >> 3] = (bitstr_t )((int )e->dow[7 >> 3] | (1 << 7));
  }
  {
#line 232
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 232
    if (! (ch == 9)) {
#line 232
      if (! (ch == 32)) {
#line 232
        goto while_break___12;
      }
    }
    {
#line 232
    ch = get_char(file);
    }
  }
  while_break___12: /* CIL Label */ ;
  }
  {
#line 234
  unget_char(ch, file);
  }
#line 236
  if (! pw___0) {
    {
#line 237
    username = cmd;
#line 240
    ch = get_string(username, 1000, file, (char *)" \t");
    }
#line 243
    if (ch == -1) {
#line 244
      ecode = (ecode_e )6;
#line 245
      goto eof;
    }
    {
#line 248
    pw___0 = getpwnam((char const   *)username);
    }
#line 249
    if ((unsigned long )pw___0 == (unsigned long )((void *)0)) {
#line 250
      ecode = (ecode_e )8;
#line 251
      goto eof;
    }
  } else
#line 254
  if (ch == 42) {
#line 255
    ecode = (ecode_e )6;
#line 256
    goto eof;
  }
  {
#line 259
  e->uid = pw___0->pw_uid;
#line 260
  e->gid = pw___0->pw_gid;
#line 265
  tmp___13 = env_copy(envp);
#line 265
  e->envp = tmp___13;
  }
#line 265
  if ((unsigned long )tmp___13 == (unsigned long )((void *)0)) {
#line 266
    ecode = (ecode_e )0;
#line 267
    goto eof;
  }
  {
#line 269
  tmp___14 = env_get((char *)"SHELL", e->envp);
  }
#line 269
  if (! tmp___14) {
    {
#line 270
    snprintf((char */* __restrict  */)(envstr), (size_t )1000, (char const   */* __restrict  */)"SHELL=%s",
             "/bin/sh");
#line 271
    tenvp = env_set(e->envp, envstr);
    }
#line 271
    if (tenvp) {
#line 272
      e->envp = tenvp;
    } else {
#line 274
      ecode = (ecode_e )0;
#line 275
      goto eof;
    }
  }
  {
#line 278
  tmp___15 = env_get((char *)"HOME", e->envp);
  }
#line 278
  if (! tmp___15) {
    {
#line 279
    snprintf((char */* __restrict  */)(envstr), (size_t )1000, (char const   */* __restrict  */)"HOME=%s",
             pw___0->pw_dir);
#line 280
    tenvp = env_set(e->envp, envstr);
    }
#line 280
    if (tenvp) {
#line 281
      e->envp = tenvp;
    } else {
#line 283
      ecode = (ecode_e )0;
#line 284
      goto eof;
    }
  }
  {
#line 287
  tmp___16 = env_get((char *)"PATH", e->envp);
  }
#line 287
  if (! tmp___16) {
    {
#line 288
    snprintf((char */* __restrict  */)(envstr), (size_t )1000, (char const   */* __restrict  */)"PATH=%s",
             "/usr/bin:/bin");
#line 289
    tenvp = env_set(e->envp, envstr);
    }
#line 289
    if (tenvp) {
#line 290
      e->envp = tenvp;
    } else {
#line 292
      ecode = (ecode_e )0;
#line 293
      goto eof;
    }
  }
  {
#line 296
  snprintf((char */* __restrict  */)(envstr), (size_t )1000, (char const   */* __restrict  */)"%s=%s",
           "LOGNAME", pw___0->pw_name);
#line 297
  tenvp = env_set(e->envp, envstr);
  }
#line 297
  if (tenvp) {
#line 298
    e->envp = tenvp;
  } else {
#line 300
    ecode = (ecode_e )0;
#line 301
    goto eof;
  }
  {
#line 320
  ch = get_string(cmd, 1000, file, (char *)"\n");
  }
#line 328
  if (ch == -1) {
#line 329
    ecode = (ecode_e )6;
#line 330
    goto eof;
  }
  {
#line 335
  tmp___17 = strdup((char const   *)(cmd));
#line 335
  e->cmd = tmp___17;
  }
#line 335
  if ((unsigned long )tmp___17 == (unsigned long )((void *)0)) {
#line 336
    ecode = (ecode_e )0;
#line 337
    goto eof;
  }
#line 344
  return (e);
  eof: 
#line 347
  if (e->envp) {
    {
#line 348
    env_free(e->envp);
    }
  }
#line 349
  if (e->cmd) {
    {
#line 350
    free((void *)e->cmd);
    }
  }
  {
#line 351
  free((void *)e);
  }
#line 352
  if ((unsigned int )ecode != 0U) {
#line 352
    if (error_func) {
      {
#line 353
      (*error_func)(ecodes[(int )ecode]);
      }
    }
  }
  {
#line 354
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 354
    if (ch != -1) {
#line 354
      if (! (ch != 10)) {
#line 354
        goto while_break___13;
      }
    } else {
#line 354
      goto while_break___13;
    }
    {
#line 355
    ch = get_char(file);
    }
  }
  while_break___13: /* CIL Label */ ;
  }
#line 356
  return ((entry *)((void *)0));
}
}
#line 360 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/entry.c"
static char get_list(bitstr_t *bits , int low , int high , char **names , int ch ,
                     FILE *file ) 
{ 
  register int done ;
  register bitstr_t *_name ;
  register int _start ;
  register int _stop ;
  register int _startbyte ;
  register int _stopbyte ;
  char tmp ;

  {
#line 383
  _name = bits;
#line 383
  _start = 0;
#line 383
  _stop = (high - low) + 1;
#line 383
  _startbyte = _start >> 3;
#line 383
  _stopbyte = _stop >> 3;
#line 383
  if (_startbyte == _stopbyte) {
#line 383
    *(_name + _startbyte) = (bitstr_t )((int )*(_name + _startbyte) & ((255 >> (8 - (_start & 7))) | (255 << ((_stop & 7) + 1))));
  } else {
#line 383
    *(_name + _startbyte) = (bitstr_t )((int )*(_name + _startbyte) & (255 >> (8 - (_start & 7))));
    {
#line 383
    while (1) {
      while_continue: /* CIL Label */ ;
#line 383
      _startbyte ++;
#line 383
      if (! (_startbyte < _stopbyte)) {
#line 383
        goto while_break;
      }
#line 383
      *(_name + _startbyte) = (bitstr_t )0;
    }
    while_break: /* CIL Label */ ;
    }
#line 383
    *(_name + _stopbyte) = (bitstr_t )((int )*(_name + _stopbyte) & (255 << ((_stop & 7) + 1)));
  }
#line 387
  done = 0;
  {
#line 388
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 388
    if (! (! done)) {
#line 388
      goto while_break___0;
    }
    {
#line 389
    tmp = get_range(bits, low, high, names, ch, file);
#line 389
    ch = (int )tmp;
    }
#line 390
    if (ch == 44) {
      {
#line 391
      ch = get_char(file);
      }
    } else {
#line 393
      done = 1;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 398
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 398
    if (ch != 9) {
#line 398
      if (ch != 32) {
#line 398
        if (ch != 10) {
#line 398
          if (! (ch != -1)) {
#line 398
            goto while_break___1;
          }
        } else {
#line 398
          goto while_break___1;
        }
      } else {
#line 398
        goto while_break___1;
      }
    } else {
#line 398
      goto while_break___1;
    }
    {
#line 398
    ch = get_char(file);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 399
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 399
    if (! (ch == 9)) {
#line 399
      if (! (ch == 32)) {
#line 399
        goto while_break___2;
      }
    }
    {
#line 399
    ch = get_char(file);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 403
  return ((char )ch);
}
}
#line 407 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/entry.c"
static char get_range(bitstr_t *bits , int low , int high , char **names , int ch ,
                      FILE *file ) 
{ 
  register int i ;
  int num1 ;
  int num2 ;
  int num3 ;
  char tmp ;
  int tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;

  {
#line 423
  if (ch == 42) {
    {
#line 426
    num1 = low;
#line 427
    num2 = high;
#line 428
    ch = get_char(file);
    }
#line 429
    if (ch == -1) {
#line 430
      return ((char)-1);
    }
  } else {
    {
#line 432
    tmp = get_number(& num1, low, names, ch, file);
#line 432
    ch = (int )tmp;
    }
#line 432
    if (-1 == ch) {
#line 433
      return ((char)-1);
    }
#line 435
    if (ch != 45) {
      {
#line 438
      tmp___0 = set_element(bits, low, high, num1);
      }
#line 438
      if (-1 == tmp___0) {
#line 439
        return ((char)-1);
      }
#line 440
      return ((char )ch);
    } else {
      {
#line 444
      ch = get_char(file);
      }
#line 445
      if (ch == -1) {
#line 446
        return ((char)-1);
      }
      {
#line 450
      tmp___1 = get_number(& num2, low, names, ch, file);
#line 450
      ch = (int )tmp___1;
      }
#line 451
      if (ch == -1) {
#line 452
        return ((char)-1);
      }
    }
  }
#line 458
  if (ch == 47) {
    {
#line 461
    ch = get_char(file);
    }
#line 462
    if (ch == -1) {
#line 463
      return ((char)-1);
    }
    {
#line 470
    tmp___2 = get_number(& num3, 0, (char **)((void *)0), ch, file);
#line 470
    ch = (int )tmp___2;
    }
#line 471
    if (ch == -1) {
#line 472
      return ((char)-1);
    } else
#line 471
    if (num3 <= 0) {
#line 472
      return ((char)-1);
    }
  } else {
#line 476
    num3 = 1;
  }
#line 487
  if (num1 < low) {
#line 488
    return ((char)-1);
  } else
#line 487
  if (num1 > high) {
#line 488
    return ((char)-1);
  } else
#line 487
  if (num2 < low) {
#line 488
    return ((char)-1);
  } else
#line 487
  if (num2 > high) {
#line 488
    return ((char)-1);
  }
#line 495
  i = num1;
  {
#line 495
  while (1) {
    while_continue: /* CIL Label */ ;
#line 495
    if (! (i <= num2)) {
#line 495
      goto while_break;
    }
    {
#line 496
    tmp___3 = set_element(bits, low, high, i);
    }
#line 496
    if (-1 == tmp___3) {
#line 497
      return ((char)-1);
    }
#line 495
    i += num3;
  }
  while_break: /* CIL Label */ ;
  }
#line 499
  return ((char )ch);
}
}
#line 503 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/entry.c"
static char get_number(int *numptr , int low , char **names , int ch , FILE *file ) 
{ 
  char temp[1000] ;
  char *pc ;
  int len ;
  int i ;
  int all_digits ;
  char *tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;

  {
#line 516
  pc = temp;
#line 517
  len = 0;
#line 518
  all_digits = 1;
  {
#line 519
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 519
    tmp___1 = __ctype_b_loc();
    }
#line 519
    if (! ((int const   )*(*tmp___1 + ch) & 8)) {
#line 519
      goto while_break;
    }
#line 520
    len ++;
#line 520
    if (len >= 1000) {
#line 521
      return ((char)-1);
    }
    {
#line 523
    tmp = pc;
#line 523
    pc ++;
#line 523
    *tmp = (char )ch;
#line 525
    tmp___0 = __ctype_b_loc();
    }
#line 525
    if (! ((int const   )*(*tmp___0 + ch) & 2048)) {
#line 526
      all_digits = 0;
    }
    {
#line 528
    ch = get_char(file);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 530
  *pc = (char )'\000';
#line 532
  if (len == 0) {
#line 533
    return ((char)-1);
  }
#line 538
  if (names) {
#line 539
    i = 0;
    {
#line 539
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 539
      if (! ((unsigned long )*(names + i) != (unsigned long )((void *)0))) {
#line 539
        goto while_break___0;
      }
      {
#line 542
      tmp___2 = strcasecmp((char const   *)*(names + i), (char const   *)(temp));
      }
#line 542
      if (! tmp___2) {
#line 543
        *numptr = i + low;
#line 544
        return ((char )ch);
      }
#line 539
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 553
  if (all_digits) {
    {
#line 554
    *numptr = atoi((char const   *)(temp));
    }
#line 555
    return ((char )ch);
  }
#line 558
  return ((char)-1);
}
}
#line 562 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/entry.c"
static int set_element(bitstr_t *bits , int low , int high , int number ) 
{ 


  {
#line 571
  if (number < low) {
#line 572
    return (-1);
  } else
#line 571
  if (number > high) {
#line 572
    return (-1);
  }
#line 574
  *(bits + ((number - low) >> 3)) = (bitstr_t )((int )*(bits + ((number - low) >> 3)) | (1 << ((number - low) & 7)));
#line 575
  return (0);
}
}
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 195 "/usr/include/stdio.h"
extern FILE *tmpfile(void) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 102 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 568 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execle)(char const   *__path ,
                                                                                               char const   *__arg 
                                                                                               , ...) ;
#line 879
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                                                  size_t __len ) ;
#line 285 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 289
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 224 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.h"
void do_command(entry *e , user *u ) ;
#line 257
char *mkprints(unsigned char *src , unsigned int len ) ;
#line 257
char *first_word(char *s , char *t ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/do_command.c"
static void child_process(entry *e , user *u ) ;
#line 53
static void do_univ(user *u ) ;
#line 58 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/do_command.c"
static char **build_env(char **cronenv ) 
{ 
  char **jobenv ;

  {
#line 60
  jobenv = cronenv;
#line 79
  return (jobenv);
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/do_command.c"
void do_command(entry *e , user *u ) 
{ 
  __pid_t tmp ;
  __pid_t tmp___0 ;

  {
  {
#line 97
  tmp = fork();
  }
  {
#line 98
  if (tmp == -1) {
#line 98
    goto case_neg_1;
  }
#line 101
  if (tmp == 0) {
#line 101
    goto case_0;
  }
#line 108
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 99
  tmp___0 = getpid();
#line 99
  log_it((char *)"CRON", tmp___0, (char *)"error", (char *)"can\'t fork");
  }
#line 100
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 103
  acquire_daemonlock(1);
#line 104
  child_process(e, u);
#line 106
  _exit(0);
  }
#line 107
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 110
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 113
  return;
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/do_command.c"
static void child_process(entry *e , user *u ) 
{ 
  int stdin_pipe[2] ;
  FILE *tmpout ;
  register char *input_data ;
  char *usernm ;
  char *mailto ;
  int children ;
  pid_t job_pid ;
  register char *pch ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  char const   *end ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  __pid_t tmp___4 ;
  __pid_t tmp___5 ;
  register int escaped ;
  register int ch ;
  register char *p ;
  char *tmp___6 ;
  __pid_t tmp___7 ;
  char *x ;
  size_t tmp___8 ;
  char *tmp___9 ;
  __pid_t tmp___10 ;
  int tmp___11 ;
  char msg[256] ;
  int *tmp___12 ;
  char *tmp___13 ;
  __pid_t tmp___14 ;
  int tmp___15 ;
  char msg___0[256] ;
  int *tmp___16 ;
  char *tmp___17 ;
  __pid_t tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  char msg___1[256] ;
  int *tmp___21 ;
  char *tmp___22 ;
  __pid_t tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  char **jobenv ;
  char **tmp___26 ;
  char *shell ;
  char *tmp___27 ;
  int *tmp___28 ;
  char *tmp___29 ;
  char logcmd[1008] ;
  char *x___0 ;
  size_t tmp___30 ;
  char *tmp___31 ;
  __pid_t tmp___32 ;
  register FILE *out ;
  FILE *tmp___33 ;
  register int need_newline ;
  register int escaped___0 ;
  register int ch___0 ;
  char *tmp___34 ;
  __pid_t tmp___35 ;
  int status ;
  char msg___2[256] ;
  int waiter ;
  pid_t pid ;
  union __anonunion_55___0 __constr_expr_2 ;
  __pid_t tmp___36 ;
  char const   *tmp___37 ;
  union __anonunion_57 __constr_expr_4 ;
  union __anonunion_58 __constr_expr_5 ;
  __pid_t tmp___38 ;
  union __anonunion_59 __constr_expr_6 ;
  union __anonunion_60 __constr_expr_7 ;
  union __anonunion_61 __constr_expr_8 ;
  long pos ;
  struct stat mcsb ;
  int statret ;
  __pid_t tmp___39 ;
  register FILE *mail ;
  register int bytes ;
  register char **env ;
  char **jobenv___0 ;
  char **tmp___40 ;
  char mailcmd[1000] ;
  char hostname[64] ;
  char *content_type ;
  char *tmp___41 ;
  char *content_transfer_encoding ;
  char *tmp___42 ;
  char const   *tmp___43 ;
  char *tmp___44 ;
  char *nl ;
  size_t ctlen ;
  size_t tmp___45 ;
  char *nl___0 ;
  size_t ctlen___0 ;
  size_t tmp___46 ;
  char buf[4096] ;
  int ret ;
  int remain ;
  size_t tmp___47 ;
  size_t tmp___48 ;
  char buf___0[1000] ;
  char const   *tmp___49 ;
  __pid_t tmp___50 ;
  __pid_t tmp___51 ;
  int tmp___52 ;
  char *x___1 ;
  char logcmd___0[1008] ;
  size_t tmp___53 ;
  size_t tmp___54 ;

  {
#line 133
  children = 0;
#line 148
  pch = ProgramName;
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (! *pch) {
#line 148
      goto while_break;
    }
    {
#line 149
    tmp___1 = __ctype_b_loc();
    }
#line 149
    if ((int const   )*(*tmp___1 + (int )*pch) & 512) {
      {
#line 149
      tmp___0 = toupper((int )*pch);
#line 149
      *pch = (char )tmp___0;
      }
    } else {
#line 149
      *pch = *pch;
    }
#line 148
    pch ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 154
  usernm = env_get((char *)"LOGNAME", e->envp);
#line 155
  mailto = env_get((char *)"MAILTO", e->envp);
  }
#line 158
  if (mailto) {
    {
#line 163
    tmp___2 = strspn((char const   *)mailto, " \t\n");
#line 163
    mailto += tmp___2;
#line 164
    tmp___3 = strcspn((char const   *)mailto, " \t\n");
#line 164
    end = (char const   *)(mailto + tmp___3);
    }
#line 165
    if ((int )*mailto == 45) {
      {
#line 166
      printf((char const   */* __restrict  */)"Bad Mailto karma.\n");
#line 167
      tmp___4 = getpid();
#line 167
      log_it((char *)"CRON", tmp___4, (char *)"error", (char *)"bad mailto");
#line 168
      mailto = (char *)((void *)0);
      }
    } else
#line 165
    if ((int const   )*end != 0) {
      {
#line 166
      printf((char const   */* __restrict  */)"Bad Mailto karma.\n");
#line 167
      tmp___4 = getpid();
#line 167
      log_it((char *)"CRON", tmp___4, (char *)"error", (char *)"bad mailto");
#line 168
      mailto = (char *)((void *)0);
      }
    }
  }
  {
#line 179
  signal(17, (void (*)(int  ))0);
#line 193
  pipe((int *)(stdin_pipe));
#line 195
  tmpout = tmpfile();
  }
#line 195
  if ((unsigned long )tmpout == (unsigned long )((void *)0)) {
    {
#line 196
    tmp___5 = getpid();
#line 196
    log_it((char *)"CRON", tmp___5, (char *)"error", (char *)"create tmpfile");
#line 197
    exit(1);
    }
  }
#line 211
  escaped = 0;
#line 215
  p = e->cmd;
#line 215
  input_data = p;
  {
#line 215
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 215
    ch = (int )*input_data;
#line 215
    if (! ch) {
#line 215
      goto while_break___0;
    }
#line 217
    if ((unsigned long )p != (unsigned long )input_data) {
#line 218
      *p = (char )ch;
    }
#line 219
    if (escaped) {
#line 220
      if (ch == 37) {
#line 221
        p --;
#line 221
        *p = (char )ch;
      } else
#line 220
      if (ch == 92) {
#line 221
        p --;
#line 221
        *p = (char )ch;
      }
#line 222
      escaped = 0;
#line 223
      goto __Cont;
    }
#line 225
    if (ch == 92) {
#line 226
      escaped = 1;
#line 227
      goto __Cont;
    }
#line 229
    if (ch == 37) {
#line 230
      tmp___6 = input_data;
#line 230
      input_data ++;
#line 230
      *tmp___6 = (char )'\000';
#line 231
      goto while_break___0;
    }
    __Cont: /* CIL Label */ 
#line 215
    input_data ++;
#line 215
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 234
  *p = (char )'\000';
#line 253
  job_pid = fork();
  }
  {
#line 254
  if (job_pid == -1) {
#line 254
    goto case_neg_1;
  }
#line 258
  if (job_pid == 0) {
#line 258
    goto case_0;
  }
#line 380
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 255
  tmp___7 = getpid();
#line 255
  log_it((char *)"CRON", tmp___7, (char *)"error", (char *)"can\'t fork");
#line 256
  exit(1);
  }
  case_0: /* CIL Label */ ;
#line 267
  if (log_level & 1) {
#line 267
    if (! (log_level & 8)) {
      {
#line 268
      tmp___8 = strlen((char const   *)e->cmd);
#line 268
      tmp___9 = mkprints((u_char *)e->cmd, (unsigned int )tmp___8);
#line 268
      x = tmp___9;
#line 269
      tmp___10 = getpid();
#line 269
      log_it(usernm, tmp___10, (char *)"CMD", x);
#line 270
      free((void *)x);
      }
    }
  }
  {
#line 274
  log_close();
#line 278
  setsid();
#line 286
  close(stdin_pipe[1]);
#line 293
  dup2(stdin_pipe[0], 0);
#line 294
  tmp___11 = fileno(tmpout);
#line 294
  dup2(tmp___11, 1);
#line 295
  dup2(1, 2);
#line 300
  close(stdin_pipe[0]);
#line 301
  fclose(tmpout);
#line 307
  do_univ(u);
#line 312
  tmp___15 = setgid(e->gid);
  }
#line 312
  if (tmp___15 != 0) {
    {
#line 314
    tmp___12 = __errno_location();
#line 314
    tmp___13 = strerror(*tmp___12);
#line 314
    snprintf((char */* __restrict  */)(msg), (size_t )256, (char const   */* __restrict  */)"do_command:setgid(%lu) failed: %s",
             (unsigned long )e->gid, tmp___13);
#line 316
    tmp___14 = getpid();
#line 316
    log_it((char *)"CRON", tmp___14, (char *)"error", msg);
#line 317
    exit(1);
    }
  }
  {
#line 320
  tmp___19 = env_get((char *)"LOGNAME", e->envp);
#line 320
  tmp___20 = initgroups((char const   *)tmp___19, e->gid);
  }
#line 320
  if (tmp___20 != 0) {
    {
#line 322
    tmp___16 = __errno_location();
#line 322
    tmp___17 = strerror(*tmp___16);
#line 322
    snprintf((char */* __restrict  */)(msg___0), (size_t )256, (char const   */* __restrict  */)"do_command:initgroups(%lu) failed: %s",
             (unsigned long )e->gid, tmp___17);
#line 324
    tmp___18 = getpid();
#line 324
    log_it((char *)"CRON", tmp___18, (char *)"error", msg___0);
#line 325
    exit(1);
    }
  }
  {
#line 328
  tmp___24 = setuid(e->uid);
  }
#line 328
  if (tmp___24 != 0) {
    {
#line 330
    tmp___21 = __errno_location();
#line 330
    tmp___22 = strerror(*tmp___21);
#line 330
    snprintf((char */* __restrict  */)(msg___1), (size_t )256, (char const   */* __restrict  */)"do_command:setuid(%lu) failed: %s",
             (unsigned long )e->uid, tmp___22);
#line 332
    tmp___23 = getpid();
#line 332
    log_it((char *)"CRON", tmp___23, (char *)"error", msg___1);
#line 333
    exit(1);
    }
  }
  {
#line 335
  tmp___25 = env_get((char *)"HOME", e->envp);
#line 335
  chdir((char const   *)tmp___25);
#line 340
  tmp___26 = build_env(e->envp);
#line 340
  jobenv = tmp___26;
#line 341
  tmp___27 = env_get((char *)"SHELL", jobenv);
#line 341
  shell = tmp___27;
#line 375
  execle((char const   *)shell, (char const   *)shell, "-c", e->cmd, (char *)0, jobenv);
#line 376
  tmp___28 = __errno_location();
#line 376
  tmp___29 = strerror(*tmp___28);
#line 376
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: execle: %s\n",
          shell, tmp___29);
#line 377
  _exit(1);
  }
#line 379
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 385
  if (log_level & 1) {
#line 385
    if (log_level & 8) {
      {
#line 387
      snprintf((char */* __restrict  */)(logcmd), sizeof(logcmd), (char const   */* __restrict  */)"[%d] %s",
               job_pid, e->cmd);
#line 388
      tmp___30 = strlen((char const   *)(logcmd));
#line 388
      tmp___31 = mkprints((u_char *)(logcmd), (unsigned int )tmp___30);
#line 388
      x___0 = tmp___31;
#line 389
      tmp___32 = getpid();
#line 389
      log_it(usernm, tmp___32, (char *)"CMD", x___0);
#line 390
      free((void *)x___0);
      }
    }
  }
#line 392
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 395
  children ++;
#line 406
  close(stdin_pipe[0]);
  }
#line 419
  if (*input_data) {
    {
#line 419
    tmp___35 = fork();
    }
#line 419
    if (tmp___35 == 0) {
      {
#line 420
      tmp___33 = fdopen(stdin_pipe[1], "w");
#line 420
      out = tmp___33;
#line 421
      need_newline = 0;
#line 422
      escaped___0 = 0;
      }
      {
#line 432
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 432
        tmp___34 = input_data;
#line 432
        input_data ++;
#line 432
        ch___0 = (int )*tmp___34;
#line 432
        if (! (ch___0 != 0)) {
#line 432
          goto while_break___1;
        }
#line 433
        if (escaped___0) {
#line 434
          if (ch___0 != 37) {
            {
#line 435
            _IO_putc('\\', out);
            }
          }
        } else
#line 437
        if (ch___0 == 37) {
#line 438
          ch___0 = '\n';
        }
#line 441
        escaped___0 = ch___0 == 92;
#line 441
        if (! escaped___0) {
          {
#line 442
          _IO_putc(ch___0, out);
#line 443
          need_newline = ch___0 != 10;
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 446
      if (escaped___0) {
        {
#line 447
        _IO_putc('\\', out);
        }
      }
#line 448
      if (need_newline) {
        {
#line 449
        _IO_putc('\n', out);
        }
      }
      {
#line 454
      fclose(out);
#line 457
      exit(0);
      }
    }
  }
  {
#line 463
  close(stdin_pipe[1]);
#line 465
  children ++;
#line 476
  status = 0;
  }
  {
#line 477
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 477
    if (! (children > 0)) {
#line 477
      goto while_break___2;
    }
    {
#line 485
    pid = wait((union wait *)(& waiter));
    }
#line 486
    if (pid < 0) {
#line 488
      goto while_break___2;
    }
#line 493
    if (log_level & 4) {
#line 494
      __constr_expr_7.__in = waiter;
#line 494
      if ((__constr_expr_7.__i & 127) == 0) {
#line 494
        __constr_expr_8.__in = waiter;
#line 494
        if ((__constr_expr_8.__i & 65280) >> 8) {
          {
#line 495
          status = waiter;
#line 496
          __constr_expr_2.__in = waiter;
#line 496
          snprintf((char */* __restrict  */)(msg___2), (size_t )256, (char const   */* __restrict  */)"grandchild #%d failed with exit status %d",
                   pid, (__constr_expr_2.__i & 65280) >> 8);
#line 498
          tmp___36 = getpid();
#line 498
          log_it((char *)"CRON", tmp___36, (char *)"error", msg___2);
          }
        } else {
#line 494
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 499
        __constr_expr_6.__in = waiter;
#line 499
        if ((int )((signed char )((__constr_expr_6.__i & 127) + 1)) >> 1 > 0) {
#line 500
          status = waiter;
#line 501
          __constr_expr_4.__in = waiter;
#line 501
          if (__constr_expr_4.__i & 128) {
#line 501
            tmp___37 = ", dumped core";
          } else {
#line 501
            tmp___37 = "";
          }
          {
#line 501
          __constr_expr_5.__in = waiter;
#line 501
          snprintf((char */* __restrict  */)(msg___2), (size_t )256, (char const   */* __restrict  */)"grandchild #%d terminated by signal %d%s",
                   pid, __constr_expr_5.__i & 127, tmp___37);
#line 504
          tmp___38 = getpid();
#line 504
          log_it((char *)"CRON", tmp___38, (char *)"error", msg___2);
          }
        }
      }
    }
#line 477
    children --;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 518
  fseek(tmpout, 0L, 2);
#line 519
  pos = ftell(tmpout);
#line 520
  fseek(tmpout, 0L, 0);
  }
#line 524
  if (pos == 0L) {
#line 525
    goto mail_finished;
  }
#line 528
  if ((unsigned long )mailto == (unsigned long )((void *)0)) {
#line 529
    mailto = usernm;
  } else
#line 530
  if (! *mailto) {
#line 531
    goto mail_finished;
  }
  {
#line 534
  statret = stat((char const   */* __restrict  */)"/usr/sbin/sendmail", (struct stat */* __restrict  */)(& mcsb));
  }
#line 534
  if (statret != 0) {
#line 536
    if (pos > 0L) {
      {
#line 537
      tmp___39 = getpid();
#line 537
      log_it((char *)"CRON", tmp___39, (char *)"info", (char *)"No MTA installed, discarding output");
      }
    }
#line 539
    goto mail_finished;
  }
  {
#line 544
  mail = (FILE *)((void *)0);
#line 545
  bytes = 1;
#line 548
  tmp___40 = build_env(e->envp);
#line 548
  jobenv___0 = tmp___40;
#line 551
  tmp___41 = env_get((char *)"CONTENT_TYPE", jobenv___0);
#line 551
  content_type = tmp___41;
#line 551
  tmp___42 = env_get((char *)"CONTENT_TRANSFER_ENCODING", jobenv___0);
#line 551
  content_transfer_encoding = tmp___42;
#line 554
  gethostname(hostname, (size_t )64);
#line 555
  snprintf((char */* __restrict  */)(mailcmd), sizeof(mailcmd), (char const   */* __restrict  */)"%s -i -FCronDaemon -oem  %s",
           "/usr/sbin/sendmail", mailto);
#line 557
  mail = cron_popen(mailcmd, (char *)"w", e);
  }
#line 557
  if (! mail) {
    {
#line 558
    perror("/usr/sbin/sendmail");
#line 559
    _exit(1);
    }
  }
  {
#line 561
  fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"From: root (Cron Daemon)\n");
#line 562
  fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"To: %s\n",
          mailto);
  }
#line 563
  if (status) {
#line 563
    tmp___43 = " (failed)";
  } else {
#line 563
    tmp___43 = "";
  }
  {
#line 563
  tmp___44 = first_word(hostname, (char *)".");
#line 563
  fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"Subject: Cron <%s@%s> %s%s\n",
          usernm, tmp___44, e->cmd, tmp___43);
  }
#line 570
  if ((unsigned long )content_type == (unsigned long )((char *)0)) {
    {
#line 571
    fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"Content-Type: text/plain; charset=%s\n",
            cron_default_mail_charset);
    }
  } else {
    {
#line 579
    nl = content_type;
#line 580
    tmp___45 = strlen((char const   *)content_type);
#line 580
    ctlen = tmp___45;
    }
    {
#line 582
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 582
      if ((int )*nl != 0) {
        {
#line 582
        nl = strchr((char const   *)nl, '\n');
        }
#line 582
        if ((unsigned long )nl != (unsigned long )((char *)0)) {
#line 582
          if (! ((unsigned long )nl < (unsigned long )(content_type + ctlen))) {
#line 582
            goto while_break___3;
          }
        } else {
#line 582
          goto while_break___3;
        }
      } else {
#line 582
        goto while_break___3;
      }
#line 585
      *nl = (char )' ';
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 586
    fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"Content-Type: %s\n",
            content_type);
    }
  }
#line 588
  if ((unsigned long )content_transfer_encoding != (unsigned long )((char *)0)) {
    {
#line 589
    nl___0 = content_transfer_encoding;
#line 590
    tmp___46 = strlen((char const   *)content_transfer_encoding);
#line 590
    ctlen___0 = tmp___46;
    }
    {
#line 591
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 591
      if ((int )*nl___0 != 0) {
        {
#line 591
        nl___0 = strchr((char const   *)nl___0, '\n');
        }
#line 591
        if ((unsigned long )nl___0 != (unsigned long )((char *)0)) {
#line 591
          if (! ((unsigned long )nl___0 < (unsigned long )(content_transfer_encoding + ctlen___0))) {
#line 591
            goto while_break___4;
          }
        } else {
#line 591
          goto while_break___4;
        }
      } else {
#line 591
        goto while_break___4;
      }
#line 594
      *nl___0 = (char )' ';
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 596
    fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"Content-Transfer-Encoding: %s\n",
            content_transfer_encoding);
    }
  }
#line 599
  env = e->envp;
  {
#line 599
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 599
    if (! *env) {
#line 599
      goto while_break___5;
    }
    {
#line 600
    fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"X-Cron-Env: <%s>\n",
            *env);
#line 599
    env ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 602
  fputc('\n', mail);
  }
  {
#line 609
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 610
    tmp___47 = fread((void */* __restrict  */)(buf), (size_t )1, sizeof(buf), (FILE */* __restrict  */)tmpout);
#line 610
    ret = (int )tmp___47;
    }
#line 610
    if (ret == 0) {
#line 611
      goto while_break___6;
    }
#line 612
    remain = ret;
    {
#line 612
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 612
      if (! (remain != 0)) {
#line 612
        goto while_break___7;
      }
      {
#line 613
      tmp___48 = fwrite((void const   */* __restrict  */)(buf), (size_t )1, (size_t )remain,
                        (FILE */* __restrict  */)mail);
#line 613
      ret = (int )tmp___48;
      }
#line 614
      if (ret > 0) {
#line 615
        remain -= ret;
#line 616
        goto __Cont___0;
      }
#line 619
      goto while_break___7;
      __Cont___0: /* CIL Label */ ;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 624
  status = cron_pclose(mail);
  }
#line 630
  if (status) {
#line 632
    if (bytes == 1) {
#line 632
      tmp___49 = "";
    } else {
#line 632
      tmp___49 = "s";
    }
    {
#line 632
    snprintf((char */* __restrict  */)(buf___0), (size_t )1000, (char const   */* __restrict  */)"mailed %d byte%s of output; but got status 0x%04x, \n",
             bytes, tmp___49, status);
#line 637
    tmp___50 = getpid();
#line 637
    log_it(usernm, tmp___50, (char *)"MAIL", buf___0);
    }
  }
  {
#line 640
  tmp___52 = ferror(tmpout);
  }
#line 640
  if (tmp___52) {
    {
#line 641
    tmp___51 = getpid();
#line 641
    log_it(usernm, tmp___51, (char *)"MAIL", (char *)"stream error reading output");
    }
  }
  mail_finished: 
  {
#line 645
  fclose(tmpout);
  }
#line 647
  if (log_level & 2) {
#line 649
    if (log_level & 8) {
      {
#line 651
      snprintf((char */* __restrict  */)(logcmd___0), sizeof(logcmd___0), (char const   */* __restrict  */)"[%d] %s",
               job_pid, e->cmd);
#line 652
      tmp___53 = strlen((char const   *)(logcmd___0));
#line 652
      x___1 = mkprints((u_char *)(logcmd___0), (unsigned int )tmp___53);
      }
    } else {
      {
#line 654
      tmp___54 = strlen((char const   *)e->cmd);
#line 654
      x___1 = mkprints((u_char *)e->cmd, (unsigned int )tmp___54);
      }
    }
    {
#line 656
    log_it(usernm, job_pid, (char *)"END", x___1);
#line 657
    free((void *)x___1);
    }
  }
#line 665
  return;
}
}
#line 668 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/do_command.c"
static void do_univ(user *u ) 
{ 


  {
#line 703
  return;
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/job.c"
static job *jhead  =    (job *)((void *)0);
#line 33 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/job.c"
static job *jtail  =    (job *)((void *)0);
#line 36 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/job.c"
void job_add(entry *e , user *u ) 
{ 
  register job *j ;
  void *tmp ;

  {
#line 44
  j = jhead;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! j) {
#line 44
      goto while_break;
    }
#line 45
    if ((unsigned long )j->e == (unsigned long )e) {
#line 45
      if ((unsigned long )j->u == (unsigned long )u) {
#line 45
        return;
      }
    }
#line 44
    j = j->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 48
  tmp = malloc(sizeof(job ));
#line 48
  j = (job *)tmp;
  }
#line 48
  if ((unsigned long )j == (unsigned long )((void *)0)) {
#line 49
    return;
  }
#line 50
  j->next = (job *)((void *)0);
#line 51
  j->e = e;
#line 52
  j->u = u;
#line 55
  if (! jhead) {
#line 55
    jhead = j;
  } else {
#line 56
    jtail->next = j;
  }
#line 57
  jtail = j;
#line 58
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/job.c"
int job_runqueue(void) 
{ 
  register job *j ;
  register job *jn ;
  register int run ;

  {
#line 65
  run = 0;
#line 67
  j = jhead;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! j) {
#line 67
      goto while_break;
    }
    {
#line 68
    do_command(j->e, j->u);
#line 69
    jn = j->next;
#line 70
    free((void *)j);
#line 71
    run ++;
#line 67
    j = jn;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  jtail = (job *)((void *)0);
#line 73
  jhead = jtail;
#line 74
  return (run);
}
}
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 702
extern int ungetc(int __c , FILE *__stream ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 473 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chown)(char const   *__file ,
                                                                                            __uid_t __owner ,
                                                                                            __gid_t __group ) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 681
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getegid)(void) ;
#line 710
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) seteuid)(__uid_t __uid ) ;
#line 727
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setegid)(__gid_t __gid ) ;
#line 1016
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ftruncate)(int __fd ,
                                                                                __off_t __length ) ;
#line 243 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/cron.h"
int swap_uids(void) ;
#line 243
int swap_uids_back(void) ;
#line 243
int allowed(char *username ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/file.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) flock)(int __fd ,
                                                                            int __operation ) ;
#line 312 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 321
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 111 "/usr/include/grp.h"
extern struct group *getgrnam(char const   *__name ) ;
#line 175 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 55 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/misc.c"
int strcmp_until(char *left , char *right , int until ) 
{ 
  register int diff ;

  {
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (*left) {
#line 63
      if ((int )*left != until) {
#line 63
        if (! ((int )*left == (int )*right)) {
#line 63
          goto while_break;
        }
      } else {
#line 63
        goto while_break;
      }
    } else {
#line 63
      goto while_break;
    }
#line 64
    left ++;
#line 65
    right ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 68
  if ((int )*left == 0) {
#line 68
    goto _L;
  } else
#line 68
  if ((int )*left == until) {
    _L: /* CIL Label */ 
#line 68
    if ((int )*right == 0) {
#line 70
      diff = 0;
    } else
#line 68
    if ((int )*right == until) {
#line 70
      diff = 0;
    } else {
#line 72
      diff = (int )*left - (int )*right;
    }
  } else {
#line 72
    diff = (int )*left - (int )*right;
  }
#line 75
  return (diff);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/misc.c"
int strdtb(char *s ) 
{ 
  char *x ;
  unsigned short const   **tmp ;

  {
#line 85
  x = s;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! *x) {
#line 89
      goto while_break;
    }
#line 90
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 95
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 95
    x --;
#line 95
    if ((unsigned long )x >= (unsigned long )s) {
      {
#line 95
      tmp = __ctype_b_loc();
      }
#line 95
      if (! ((int const   )*(*tmp + (int )*x) & 8192)) {
#line 95
        goto while_break___0;
      }
    } else {
#line 95
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 101
  x ++;
#line 101
  *x = (char )'\000';
#line 106
  return ((int )(x - s));
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/misc.c"
int set_debug_flags(char *flags ) 
{ 


  {
  {
#line 122
  printf((char const   */* __restrict  */)"this program was compiled without debugging enabled\n");
  }
#line 123
  return (0);
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/misc.c"
void set_cron_uid(void) 
{ 
  int tmp ;

  {
  {
#line 181
  tmp = seteuid((__uid_t )0);
  }
#line 181
  if (tmp < 0) {
    {
#line 182
    perror("seteuid");
#line 183
    exit(1);
    }
  }
#line 191
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/misc.c"
void set_cron_cwd(void) 
{ 
  struct stat sb ;
  mode_t um ;
  struct group *gr ;
  __uid_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  __uid_t tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int *tmp___18 ;

  {
  {
#line 203
  tmp___3 = stat((char const   */* __restrict  */)"/var/spool/cron", (struct stat */* __restrict  */)(& sb));
  }
#line 203
  if (tmp___3 < 0) {
    {
#line 203
    tmp___4 = __errno_location();
    }
#line 203
    if (*tmp___4 == 2) {
      {
#line 204
      perror("/var/spool/cron");
#line 208
      tmp = getuid();
      }
#line 208
      if (tmp != 0U) {
        {
#line 209
        exit(1);
        }
      }
      {
#line 211
      um = umask((__mode_t )0);
#line 212
      tmp___2 = mkdir("/var/spool/cron", (__mode_t )493);
      }
#line 212
      if (0 == tmp___2) {
        {
#line 213
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: created\n",
                "/var/spool/cron");
#line 214
        stat((char const   */* __restrict  */)"/var/spool/cron", (struct stat */* __restrict  */)(& sb));
        }
      } else {
        {
#line 216
        tmp___0 = __errno_location();
#line 216
        tmp___1 = strerror(*tmp___0);
#line 216
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: mkdir: %s\n",
                "/var/spool/cron", tmp___1);
#line 218
        exit(1);
        }
      }
      {
#line 220
      umask(um);
      }
    }
  }
#line 222
  if (! (sb.st_mode & 16384U)) {
    {
#line 223
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\'%s\' is not a directory, bailing out.\n",
            "/var/spool/cron");
#line 225
    exit(1);
    }
  }
  {
#line 227
  tmp___7 = chdir("/var/spool/cron");
  }
#line 227
  if (tmp___7 < 0) {
    {
#line 228
    tmp___5 = __errno_location();
#line 228
    tmp___6 = strerror(*tmp___5);
#line 228
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: chdir: %s\n",
            "/var/spool/cron", tmp___6);
#line 229
    exit(1);
    }
  }
  {
#line 234
  tmp___17 = stat((char const   */* __restrict  */)"crontabs", (struct stat */* __restrict  */)(& sb));
  }
#line 234
  if (tmp___17 < 0) {
    {
#line 234
    tmp___18 = __errno_location();
    }
#line 234
    if (*tmp___18 == 2) {
      {
#line 235
      perror("crontabs");
#line 239
      tmp___8 = getuid();
      }
#line 239
      if (tmp___8 != 0U) {
        {
#line 240
        exit(1);
        }
      }
      {
#line 242
      um = umask((__mode_t )0);
#line 243
      tmp___11 = mkdir("crontabs", (__mode_t )984);
      }
#line 243
      if (0 == tmp___11) {
        {
#line 244
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: created\n",
                "crontabs");
        }
      } else {
        {
#line 246
        tmp___9 = __errno_location();
#line 246
        tmp___10 = strerror(*tmp___9);
#line 246
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: mkdir: %s\n",
                "crontabs", tmp___10);
#line 248
        exit(1);
        }
      }
      {
#line 250
      umask(um);
#line 252
      gr = getgrnam("crontab");
      }
#line 252
      if (! gr) {
        {
#line 253
        tmp___12 = __errno_location();
#line 253
        tmp___13 = strerror(*tmp___12);
#line 253
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: getgrnam: %s\n",
                "crontabs", tmp___13);
#line 255
        exit(1);
        }
      }
      {
#line 257
      tmp___16 = chown("crontabs", (__uid_t )-1, gr->gr_gid);
      }
#line 257
      if (0 == tmp___16) {
        {
#line 258
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: chowned\n",
                "crontabs");
#line 259
        stat((char const   */* __restrict  */)"crontabs", (struct stat */* __restrict  */)(& sb));
        }
      } else {
        {
#line 261
        tmp___14 = __errno_location();
#line 261
        tmp___15 = strerror(*tmp___14);
#line 261
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: chown: %s\n",
                "crontabs", tmp___15);
#line 263
        exit(1);
        }
      }
    }
  }
#line 266
  if (! (sb.st_mode & 16384U)) {
    {
#line 267
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\'%s\' is not a directory, bailing out.\n",
            "crontabs");
#line 269
    exit(1);
    }
  }
#line 271
  return;
}
}
#line 287 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/misc.c"
static FILE *fp  =    (FILE *)((void *)0);
#line 283 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/misc.c"
void acquire_daemonlock(int closeflag ) 
{ 
  char pidfile[100] ;
  char buf[1000] ;
  int fd ;
  int otherpid ;
  int *tmp ;
  char *tmp___0 ;
  __pid_t tmp___1 ;
  int save_errno ;
  int *tmp___2 ;
  char *tmp___3 ;
  __pid_t tmp___4 ;
  int tmp___5 ;
  __pid_t tmp___6 ;
  __pid_t tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;

  {
#line 289
  if (closeflag) {
#line 289
    if (fp) {
      {
#line 290
      fclose(fp);
#line 291
      fp = (FILE *)((void *)0);
      }
#line 292
      return;
    }
  }
#line 295
  if (! fp) {
    {
#line 300
    snprintf((char */* __restrict  */)(pidfile), (size_t )100, (char const   */* __restrict  */)"%scrond.pid",
             "/var/run/");
#line 301
    fd = open((char const   *)(pidfile), 66, 420);
    }
#line 301
    if (-1 == fd) {
#line 301
      goto _L;
    } else {
      {
#line 301
      fp = fdopen(fd, "r+");
      }
#line 301
      if ((unsigned long )((void *)0) == (unsigned long )fp) {
        _L: /* CIL Label */ 
        {
#line 304
        tmp = __errno_location();
#line 304
        tmp___0 = strerror(*tmp);
#line 304
        snprintf((char */* __restrict  */)(buf), (size_t )1000, (char const   */* __restrict  */)"can\'t open or create %s: %s",
                 pidfile, tmp___0);
#line 306
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
                ProgramName, buf);
#line 307
        tmp___1 = getpid();
#line 307
        log_it((char *)"CRON", tmp___1, (char *)"DEATH", buf);
#line 308
        exit(1);
        }
      }
    }
    {
#line 311
    tmp___5 = flock(fd, 6);
    }
#line 311
    if (tmp___5 < 0) {
      {
#line 312
      tmp___2 = __errno_location();
#line 312
      save_errno = *tmp___2;
#line 314
      fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d", & otherpid);
#line 315
      tmp___3 = strerror(save_errno);
#line 315
      snprintf((char */* __restrict  */)(buf), (size_t )1000, (char const   */* __restrict  */)"can\'t lock %s, otherpid may be %d: %s",
               pidfile, otherpid, tmp___3);
#line 317
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
              ProgramName, buf);
#line 318
      tmp___4 = getpid();
#line 318
      log_it((char *)"CRON", tmp___4, (char *)"DEATH", buf);
#line 319
      exit(1);
      }
    }
    {
#line 321
    snprintf((char */* __restrict  */)(buf), (size_t )1000, (char const   */* __restrict  */)"pidfile fd = %d",
             fd);
#line 322
    tmp___6 = getpid();
#line 322
    log_it((char *)"CRON", tmp___6, (char *)"INFO", buf);
#line 323
    fcntl(fd, 2, 1);
    }
  }
  {
#line 326
  rewind(fp);
#line 327
  tmp___7 = getpid();
#line 327
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d\n", tmp___7);
#line 328
  fflush(fp);
#line 329
  tmp___8 = ftell(fp);
#line 329
  tmp___9 = fileno(fp);
#line 329
  ftruncate(tmp___9, tmp___8);
  }
#line 335
  return;
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/misc.c"
int get_char(FILE *file ) 
{ 
  int ch ;

  {
  {
#line 345
  ch = _IO_getc(file);
  }
#line 346
  if (ch == 10) {
#line 347
    LineNumber ++;
  }
#line 348
  return (ch);
}
}
#line 354 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/misc.c"
void unget_char(int ch , FILE *file ) 
{ 


  {
  {
#line 359
  ungetc(ch, file);
  }
#line 360
  if (ch == 10) {
#line 361
    LineNumber --;
  }
#line 362
  return;
}
}
#line 371 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/misc.c"
int get_string(char *string , int size , FILE *file , char *terms ) 
{ 
  int ch ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 380
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 380
    ch = get_char(file);
    }
#line 380
    if (-1 != ch) {
      {
#line 380
      tmp___0 = strchr((char const   *)terms, ch);
      }
#line 380
      if (tmp___0) {
#line 380
        goto while_break;
      }
    } else {
#line 380
      goto while_break;
    }
#line 381
    if (size > 1) {
#line 382
      tmp = string;
#line 382
      string ++;
#line 382
      *tmp = (char )ch;
#line 383
      size --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 387
  if (size > 0) {
#line 388
    *string = (char )'\000';
  }
#line 390
  return (ch);
}
}
#line 396 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/misc.c"
void skip_comments(FILE *file ) 
{ 
  int ch ;

  {
  {
#line 402
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 402
    ch = get_char(file);
    }
#line 402
    if (! (-1 != ch)) {
#line 402
      goto while_break;
    }
    {
#line 406
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 406
      if (! (ch == 32)) {
#line 406
        if (! (ch == 9)) {
#line 406
          goto while_break___0;
        }
      }
      {
#line 407
      ch = get_char(file);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 409
    if (ch == -1) {
#line 410
      goto while_break;
    }
#line 415
    if (ch != 10) {
#line 415
      if (ch != 35) {
#line 416
        goto while_break;
      }
    }
    {
#line 422
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 422
      if (ch != 10) {
#line 422
        if (! (ch != -1)) {
#line 422
          goto while_break___1;
        }
      } else {
#line 422
        goto while_break___1;
      }
      {
#line 423
      ch = get_char(file);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 429
  if (ch != -1) {
    {
#line 430
    unget_char(ch, file);
    }
  }
#line 431
  return;
}
}
#line 438 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/misc.c"
static int in_file(char *string , FILE *file ) 
{ 
  char line[1000] ;
  size_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 445
  rewind(file);
  }
  {
#line 446
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 446
    tmp___1 = fgets((char */* __restrict  */)(line), 1000, (FILE */* __restrict  */)file);
    }
#line 446
    if (! tmp___1) {
#line 446
      goto while_break;
    }
#line 447
    if ((int )line[0] != 0) {
      {
#line 448
      tmp = strlen((char const   *)(line));
#line 448
      line[tmp - 1UL] = (char )'\000';
      }
    }
    {
#line 449
    tmp___0 = strcmp((char const   *)(line), (char const   *)string);
    }
#line 449
    if (0 == tmp___0) {
#line 450
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 452
  return (0);
}
}
#line 465 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/misc.c"
static int init  =    0;
#line 466 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/misc.c"
static FILE *allow  ;
#line 466 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/misc.c"
static FILE *deny  ;
#line 461 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/misc.c"
int allowed(char *username ) 
{ 
  int isallowed ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 471
  tmp = strcmp((char const   *)username, "root");
  }
#line 471
  if (tmp == 0) {
#line 472
    return (1);
  }
#line 474
  isallowed = 0;
#line 478
  if (! init) {
    {
#line 479
    init = 1;
#line 481
    allow = fopen((char const   */* __restrict  */)"/etc/cron.allow", (char const   */* __restrict  */)"r");
#line 482
    deny = fopen((char const   */* __restrict  */)"/etc/cron.deny", (char const   */* __restrict  */)"r");
    }
  }
#line 490
  if (allow) {
    {
#line 491
    isallowed = in_file(username, allow);
    }
  } else {
#line 493
    isallowed = 1;
  }
#line 494
  if (deny) {
#line 494
    if (! allow) {
      {
#line 495
      tmp___0 = in_file(username, deny);
      }
#line 495
      if (tmp___0) {
#line 495
        tmp___1 = 0;
      } else {
#line 495
        tmp___1 = 1;
      }
#line 495
      isallowed = tmp___1;
    }
  }
#line 507
  return (isallowed);
}
}
#line 511 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/misc.c"
void log_it(char *username , int xpid , char *event , char *detail ) 
{ 


  {
  {
#line 580
  openlog((char const   *)ProgramName, 1, 9 << 3);
#line 585
  syslog(6, "(%s) %s (%s)", username, event, detail);
#line 587
  closelog();
  }
#line 596
  return;
}
}
#line 599 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/misc.c"
void log_close(void) 
{ 


  {
  {
#line 608
  closelog();
  }
#line 610
  return;
}
}
#line 622 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/misc.c"
static char retbuf[2][1001]  ;
#line 623 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/misc.c"
static int retsel  =    0;
#line 617 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/misc.c"
char *first_word(char *s , char *t ) 
{ 
  register char *rb ;
  register char *rp ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 627
  retsel = 1 - retsel;
#line 628
  rb = & retbuf[retsel][0];
#line 629
  rp = rb;
  {
#line 632
  while (1) {
    while_continue: /* CIL Label */ ;
#line 632
    if (*s) {
      {
#line 632
      tmp = strchr((char const   *)t, (int )*s);
      }
#line 632
      if (! ((unsigned long )((void *)0) != (unsigned long )tmp)) {
#line 632
        goto while_break;
      }
    } else {
#line 632
      goto while_break;
    }
#line 633
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 637
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 637
    if (*s) {
      {
#line 637
      tmp___2 = strchr((char const   *)t, (int )*s);
      }
#line 637
      if ((unsigned long )((void *)0) == (unsigned long )tmp___2) {
#line 637
        if (! ((unsigned long )rp < (unsigned long )(rb + 1000))) {
#line 637
          goto while_break___0;
        }
      } else {
#line 637
        goto while_break___0;
      }
    } else {
#line 637
      goto while_break___0;
    }
#line 638
    tmp___0 = rp;
#line 638
    rp ++;
#line 638
    tmp___1 = s;
#line 638
    s ++;
#line 638
    *tmp___0 = *tmp___1;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 642
  *rp = (char )'\000';
#line 643
  return (rb);
}
}
#line 650 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/misc.c"
void mkprint(char *dst , unsigned char *src , int len ) 
{ 
  register unsigned char ch ;
  unsigned char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 656
  while (1) {
    while_continue: /* CIL Label */ ;
#line 656
    tmp___5 = len;
#line 656
    len --;
#line 656
    if (! (tmp___5 > 0)) {
#line 656
      goto while_break;
    }
#line 658
    tmp = src;
#line 658
    src ++;
#line 658
    ch = *tmp;
#line 660
    if ((int )ch < 32) {
#line 661
      tmp___0 = dst;
#line 661
      dst ++;
#line 661
      *tmp___0 = (char )'^';
#line 662
      tmp___1 = dst;
#line 662
      dst ++;
#line 662
      *tmp___1 = (char )((int )ch + 64);
    } else
#line 663
    if ((int )ch < 127) {
#line 664
      tmp___2 = dst;
#line 664
      dst ++;
#line 664
      *tmp___2 = (char )ch;
    } else
#line 665
    if ((int )ch == 127) {
#line 666
      tmp___3 = dst;
#line 666
      dst ++;
#line 666
      *tmp___3 = (char )'^';
#line 667
      tmp___4 = dst;
#line 667
      dst ++;
#line 667
      *tmp___4 = (char )'?';
    } else {
      {
#line 671
      snprintf((char */* __restrict  */)dst, (size_t )5, (char const   */* __restrict  */)"\\%03o",
               (int )ch);
#line 672
      dst += 4;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 675
  *dst = (char )'\000';
#line 676
  return;
}
}
#line 682 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/misc.c"
char *mkprints(unsigned char *src , unsigned int len ) 
{ 
  register char *dst ;
  void *tmp ;

  {
  {
#line 687
  tmp = malloc((size_t )(len * 4U + 1U));
#line 687
  dst = (char *)tmp;
  }
#line 689
  if (dst) {
    {
#line 690
    mkprint(dst, src, (int )len);
    }
  }
#line 692
  return (dst);
}
}
#line 734 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/misc.c"
static uid_t save_euid  ;
#line 734 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/misc.c"
static uid_t save_egid  ;
#line 735 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/misc.c"
int swap_uids(void) 
{ 
  int tmp___3 ;
  __gid_t tmp___4 ;
  int tmp___5 ;
  __uid_t tmp___6 ;
  int tmp___7 ;

  {
  {
#line 737
  save_euid = geteuid();
#line 737
  save_egid = getegid();
#line 738
  tmp___4 = getgid();
#line 738
  tmp___5 = setegid(tmp___4);
  }
#line 738
  if (tmp___5) {
#line 738
    tmp___3 = -1;
  } else {
    {
#line 738
    tmp___6 = getuid();
#line 738
    tmp___7 = seteuid(tmp___6);
    }
#line 738
    if (tmp___7) {
#line 738
      tmp___3 = -1;
    } else {
#line 738
      tmp___3 = 0;
    }
  }
#line 738
  return (tmp___3);
}
}
#line 740 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/misc.c"
int swap_uids_back(void) 
{ 
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 742
  tmp___2 = setegid(save_egid);
  }
#line 742
  if (tmp___2) {
#line 742
    tmp___1 = -1;
  } else {
    {
#line 742
    tmp___3 = seteuid(save_euid);
    }
#line 742
    if (tmp___3) {
#line 742
      tmp___1 = -1;
    } else {
#line 742
      tmp___1 = 0;
    }
  }
#line 742
  return (tmp___1);
}
}
#line 761 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/misc.c"
long get_gmtoff(time_t *clock___0 , struct tm *local ) 
{ 
  struct tm gmt ;
  long offset ;
  struct tm *tmp ;

  {
  {
#line 766
  tmp = gmtime((time_t const   *)clock___0);
#line 766
  gmt = *tmp;
  }
#line 767
  if ((unsigned long )local == (unsigned long )((void *)0)) {
    {
#line 768
    local = localtime((time_t const   *)clock___0);
    }
  }
#line 770
  offset = (long )(((local->tm_sec - gmt.tm_sec) + (local->tm_min - gmt.tm_min) * 60) + (local->tm_hour - gmt.tm_hour) * 3600);
#line 775
  if (local->tm_year < gmt.tm_year) {
#line 776
    offset -= 86400L;
  } else
#line 777
  if (local->tm_year > gmt.tm_year) {
#line 778
    offset += 86400L;
  } else
#line 779
  if (local->tm_yday < gmt.tm_yday) {
#line 780
    offset -= 86400L;
  } else
#line 781
  if (local->tm_yday > gmt.tm_yday) {
#line 782
    offset += 86400L;
  }
#line 784
  return (offset);
}
}
#line 287 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/misc.c"
static FILE *fp___0  =    (FILE *)((void *)0);
#line 438 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/misc.c"
static int in_file___0(char *string , FILE *file ) 
{ 
  char line[1000] ;
  size_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 445
  rewind(file);
  }
  {
#line 446
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 446
    tmp___1 = fgets((char */* __restrict  */)(line), 1000, (FILE */* __restrict  */)file);
    }
#line 446
    if (! tmp___1) {
#line 446
      goto while_break;
    }
#line 447
    if ((int )line[0] != 0) {
      {
#line 448
      tmp = strlen((char const   *)(line));
#line 448
      line[tmp - 1UL] = (char )'\000';
      }
    }
    {
#line 449
    tmp___0 = strcmp((char const   *)(line), (char const   *)string);
    }
#line 449
    if (0 == tmp___0) {
#line 450
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 452
  return (0);
}
}
#line 465 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/misc.c"
static int init___0  =    0;
#line 466 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/misc.c"
static FILE *allow___0  ;
#line 466 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/misc.c"
static FILE *deny___0  ;
#line 622 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/misc.c"
static char retbuf___0[2][1001]  ;
#line 623 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/misc.c"
static int retsel___0  =    0;
#line 734 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/misc.c"
static uid_t save_euid___0  ;
#line 734 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/misc.c"
static uid_t save_egid___0  ;
#line 19 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/crontab.c"
static char rcsid[54]  = 
#line 19 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/crontab.c"
  {      (char )'$',      (char )'I',      (char )'d',      (char )':', 
        (char )' ',      (char )'c',      (char )'r',      (char )'o', 
        (char )'n',      (char )'t',      (char )'a',      (char )'b', 
        (char )'.',      (char )'c',      (char )',',      (char )'v', 
        (char )' ',      (char )'2',      (char )'.',      (char )'1', 
        (char )'3',      (char )' ',      (char )'1',      (char )'9', 
        (char )'9',      (char )'4',      (char )'/',      (char )'0', 
        (char )'1',      (char )'/',      (char )'1',      (char )'7', 
        (char )' ',      (char )'0',      (char )'3',      (char )':', 
        (char )'2',      (char )'0',      (char )':',      (char )'3', 
        (char )'7',      (char )' ',      (char )'v',      (char )'i', 
        (char )'x',      (char )'i',      (char )'e',      (char )' ', 
        (char )'E',      (char )'x',      (char )'p',      (char )' ', 
        (char )'$',      (char )'\000'};
#line 180 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 580
extern int putchar(int __c ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 620
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
#line 663
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) mkdtemp)(char *__template ) ;
#line 584 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execlp)(char const   *__file ,
                                                                                               char const   *__arg 
                                                                                               , ...) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 835
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) rmdir)(char const   *__path ) ;
#line 71 "/usr/include/getopt.h"
extern int optind ;
#line 956 "/usr/include/unistd.h"
extern int fsync(int __fd ) ;
#line 264 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 297 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchmod)(int __fd ,
                                                                             __mode_t __mode ) ;
#line 45 "/usr/include/utime.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) utime)(char const   *__file ,
                                                                                            struct utimbuf  const  *__file_times ) ;
#line 57 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/crontab.c"
static pid_t Pid  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/crontab.c"
static char *User  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/crontab.c"
static char *RealUser  ;
#line 59 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/crontab.c"
static char Filename[100]  ;
#line 60 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/crontab.c"
static char Directory[100]  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/crontab.c"
static FILE *NewCrontab  =    (FILE *)((void *)0);
#line 62 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/crontab.c"
static int CheckErrorCount  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/crontab.c"
static int PromptOnDelete  ;
#line 64 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/crontab.c"
static enum opt_t Option  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/crontab.c"
static struct passwd *pw  ;
#line 66
static void list_cmd(void) ;
#line 66
static void delete_cmd(void) ;
#line 66
static void edit_cmd(void) ;
#line 66
static void poke_daemon(void) ;
#line 66
static void check_error(char *msg ) ;
#line 66
static void parse_args___0(int argc , char **argv ) ;
#line 72
static int replace_cmd(void) ;
#line 75
static int create_tmp_crontab(void) ;
#line 76
static int open_tmp_crontab(struct stat *fsbuf ) ;
#line 77
static void cleanup_tmp_crontab(void) ;
#line 79 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/crontab.c"
static void usage___0(char *msg ) 
{ 


  {
  {
#line 83
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: usage error: %s\n",
          ProgramName, msg);
#line 84
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage:\t%s [-u user] file\n",
          ProgramName);
#line 85
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t%s [ -u user ] [ -i ] { -e | -l | -r }\n",
          ProgramName);
#line 86
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t(default operation is replace, per 1003.2)\n");
#line 87
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-e\t(edit user\'s crontab)\n");
#line 88
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-l\t(list user\'s crontab)\n");
#line 89
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-r\t(delete user\'s crontab)\n");
#line 90
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-i\t(prompt before deleting user\'s crontab)\n");
#line 91
  exit(1);
  }
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/crontab.c"
char *getoptarg  =    (char *)"u:leri";
#line 162 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/crontab.c"
static void parse_args___0(int argc , char **argv ) 
{ 
  int argch ;
  struct stat statbuf ;
  __uid_t tmp ;
  __uid_t tmp___0 ;
  __uid_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 170
  tmp = getuid();
#line 170
  pw = getpwuid(tmp);
  }
#line 170
  if (! pw) {
    {
#line 171
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: your UID isn\'t in the passwd file.\n",
            ProgramName);
#line 173
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bailing out.\n");
#line 174
    exit(1);
    }
  }
  {
#line 176
  User = strdup((char const   *)pw->pw_name);
  }
#line 176
  if ((unsigned long )User == (unsigned long )((void *)0)) {
    {
#line 178
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Memory allocation error\n");
#line 179
    exit(1);
    }
  } else {
    {
#line 176
    RealUser = strdup((char const   *)pw->pw_name);
    }
#line 176
    if ((unsigned long )RealUser == (unsigned long )((void *)0)) {
      {
#line 178
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Memory allocation error\n");
#line 179
      exit(1);
      }
    }
  }
#line 181
  Filename[0] = (char )'\000';
#line 182
  Option = (enum opt_t )0;
#line 183
  PromptOnDelete = 0;
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 185
    argch = getopt(argc, (char * const  *)argv, (char const   *)getoptarg);
    }
#line 185
    if (! (-1 != argch)) {
#line 185
      goto while_break;
    }
    {
#line 194
    if (argch == 117) {
#line 194
      goto case_117;
    }
#line 214
    if (argch == 108) {
#line 214
      goto case_108;
    }
#line 219
    if (argch == 114) {
#line 219
      goto case_114;
    }
#line 224
    if (argch == 101) {
#line 224
      goto case_101;
    }
#line 229
    if (argch == 105) {
#line 229
      goto case_105;
    }
#line 232
    goto switch_default;
    case_117: /* CIL Label */ 
    {
#line 195
    pw = getpwnam((char const   *)optarg);
    }
#line 195
    if (! pw) {
      {
#line 197
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:  user `%s\' unknown\n",
              ProgramName, optarg);
#line 199
      exit(1);
      }
    }
    {
#line 201
    tmp___0 = getuid();
    }
#line 201
    if (tmp___0 != 0U) {
      {
#line 201
      tmp___1 = getuid();
      }
#line 201
      if (tmp___1 != pw->pw_uid) {
        {
#line 204
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"must be privileged to use -u\n");
#line 206
        exit(1);
        }
      }
    }
    {
#line 208
    free((void *)User);
#line 209
    User = strdup((char const   *)pw->pw_name);
    }
#line 209
    if ((unsigned long )User == (unsigned long )((void *)0)) {
      {
#line 210
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Memory allocation error\n");
#line 211
      exit(1);
      }
    }
#line 213
    goto switch_break;
    case_108: /* CIL Label */ 
#line 215
    if ((unsigned int )Option != 0U) {
      {
#line 216
      usage___0((char *)"only one operation permitted");
      }
    }
#line 217
    Option = (enum opt_t )1;
#line 218
    goto switch_break;
    case_114: /* CIL Label */ 
#line 220
    if ((unsigned int )Option != 0U) {
      {
#line 221
      usage___0((char *)"only one operation permitted");
      }
    }
#line 222
    Option = (enum opt_t )2;
#line 223
    goto switch_break;
    case_101: /* CIL Label */ 
#line 225
    if ((unsigned int )Option != 0U) {
      {
#line 226
      usage___0((char *)"only one operation permitted");
      }
    }
#line 227
    Option = (enum opt_t )3;
#line 228
    goto switch_break;
    case_105: /* CIL Label */ 
#line 230
    PromptOnDelete = 1;
#line 231
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 233
    usage___0((char *)"unrecognized option");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 237
  endpwent();
  }
#line 239
  if ((unsigned int )Option != 0U) {
#line 240
    if ((unsigned long )*(argv + optind) != (unsigned long )((void *)0)) {
      {
#line 241
      usage___0((char *)"no arguments permitted after this option");
      }
    }
  } else
#line 244
  if ((unsigned long )*(argv + optind) != (unsigned long )((void *)0)) {
    {
#line 245
    Option = (enum opt_t )4;
#line 246
    strncpy((char */* __restrict  */)(Filename), (char const   */* __restrict  */)*(argv + optind),
            sizeof(Filename) - 1UL);
#line 247
    Filename[sizeof(Filename) - 1UL] = (char )'\000';
    }
  } else {
    {
#line 250
    usage___0((char *)"file name must be specified for replace");
    }
  }
#line 254
  if ((unsigned int )Option == 4U) {
    {
#line 259
    tmp___6 = strcmp((char const   *)(Filename), "-");
    }
#line 259
    if (tmp___6) {
      {
#line 270
      tmp___2 = swap_uids();
      }
#line 270
      if (tmp___2 < 0) {
        {
#line 271
        perror("swapping uids");
#line 272
        exit(1);
        }
      }
      {
#line 274
      NewCrontab = fopen((char const   */* __restrict  */)(Filename), (char const   */* __restrict  */)"r");
      }
#line 274
      if (! NewCrontab) {
        {
#line 275
        perror((char const   *)(Filename));
#line 276
        exit(1);
        }
      }
      {
#line 279
      tmp___3 = fileno(NewCrontab);
#line 279
      tmp___4 = fstat(tmp___3, & statbuf);
      }
#line 279
      if (tmp___4 < 0) {
        {
#line 280
        perror("fstat");
#line 281
        exit(1);
        }
      }
#line 283
      if (! ((statbuf.st_mode & 61440U) == 32768U)) {
        {
#line 284
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Not a regular file.\n",
                Filename);
#line 285
        exit(1);
        }
      }
      {
#line 287
      tmp___5 = swap_uids_back();
      }
#line 287
      if (tmp___5 < 0) {
        {
#line 288
        perror("swapping uids back");
#line 289
        exit(1);
        }
      }
    } else {
#line 260
      NewCrontab = stdin;
    }
  }
#line 296
  return;
}
}
#line 299 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/crontab.c"
static void list_cmd(void) 
{ 
  char n[100] ;
  FILE *f ;
  int ch ;
  int x ;
  char *ctnh ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 309
  log_it(RealUser, Pid, (char *)"LIST", User);
#line 310
  snprintf((char */* __restrict  */)(n), (size_t )100, (char const   */* __restrict  */)"%s/%s",
           "crontabs", User);
#line 311
  f = fopen((char const   */* __restrict  */)(n), (char const   */* __restrict  */)"r");
  }
#line 311
  if (! f) {
    {
#line 312
    tmp___1 = __errno_location();
    }
#line 312
    if (*tmp___1 == 2) {
      {
#line 313
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"no crontab for %s\n",
              User);
      }
    } else {
      {
#line 315
      tmp = __errno_location();
#line 315
      tmp___0 = strerror(*tmp);
#line 315
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s/: fopen: %s\n",
              n, tmp___0);
      }
    }
    {
#line 317
    exit(1);
    }
  }
  {
#line 322
  LineNumber = 1;
#line 328
  ctnh = getenv("CRONTAB_NOHEADER");
  }
#line 328
  if (ctnh) {
    {
#line 328
    tmp___2 = toupper((int )*ctnh);
    }
#line 328
    if (tmp___2 != 78) {
      _L: /* CIL Label */ 
#line 331
      x = 0;
      {
#line 331
      while (1) {
        while_continue: /* CIL Label */ ;
#line 331
        if (! (x < 3)) {
#line 331
          goto while_break;
        }
        {
#line 332
        ch = get_char(f);
        }
#line 333
        if (-1 == ch) {
#line 334
          goto while_break;
        }
#line 335
        if (35 != ch) {
          {
#line 336
          putchar(ch);
          }
#line 337
          goto while_break;
        }
        {
#line 339
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 339
          ch = get_char(f);
          }
#line 339
          if (! (-1 != ch)) {
#line 339
            goto while_break___0;
          }
#line 340
          if (ch == 10) {
#line 341
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 342
        if (-1 == ch) {
#line 343
          goto while_break;
        }
#line 331
        x ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else {
#line 328
    goto _L;
  }
  {
#line 347
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 347
    ch = get_char(f);
    }
#line 347
    if (! (-1 != ch)) {
#line 347
      goto while_break___1;
    }
    {
#line 348
    putchar(ch);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 349
  fclose(f);
  }
#line 350
  return;
}
}
#line 353 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/crontab.c"
static void delete_cmd(void) 
{ 
  char n[100] ;
  char q[1000] ;
  int ans ;
  struct stat fsbuf ;
  int tmp ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;

  {
  {
#line 361
  snprintf((char */* __restrict  */)(n), (size_t )100, (char const   */* __restrict  */)"%s/%s",
           "crontabs", User);
#line 362
  tmp = stat((char const   */* __restrict  */)(n), (struct stat */* __restrict  */)(& fsbuf));
  }
#line 362
  if (tmp < 0) {
    {
#line 363
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"no crontab for %s\n",
            User);
#line 364
    exit(1);
    }
  }
#line 367
  if (PromptOnDelete == 1) {
    {
#line 369
    printf((char const   */* __restrict  */)"crontab: really delete %s\'s crontab? (y/n) ",
           User);
#line 370
    fflush(stdout);
#line 371
    ans = 0;
#line 372
    q[0] = (char )'\000';
    }
    {
#line 373
    while (1) {
      while_continue: /* CIL Label */ ;
#line 373
      if (! (ans == 0)) {
#line 373
        goto while_break;
      }
      {
#line 374
      fgets((char */* __restrict  */)(q), (int )sizeof(q), (FILE */* __restrict  */)stdin);
#line 375
      tmp___3 = __ctype_b_loc();
      }
#line 375
      if ((int const   )*(*tmp___3 + (int )q[0]) & 512) {
#line 375
        tmp___2 = (int )q[0];
      } else {
        {
#line 375
        tmp___1 = tolower((int )q[0]);
#line 375
        tmp___2 = tmp___1;
        }
      }
      {
#line 377
      if (tmp___2 == 110) {
#line 377
        goto case_110;
      }
#line 377
      if (tmp___2 == 121) {
#line 377
        goto case_110;
      }
#line 380
      goto switch_default;
      case_110: /* CIL Label */ 
      case_121: /* CIL Label */ 
#line 378
      ans = 1;
#line 379
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 381
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Please enter Y or N: ");
      }
      switch_break: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 384
    if ((int )q[0] == 78) {
      {
#line 385
      exit(0);
      }
    } else
#line 384
    if ((int )q[0] == 110) {
      {
#line 385
      exit(0);
      }
    }
  }
  {
#line 388
  log_it(RealUser, Pid, (char *)"DELETE", User);
#line 389
  tmp___7 = unlink((char const   *)(n));
  }
#line 389
  if (tmp___7) {
    {
#line 390
    tmp___6 = __errno_location();
    }
#line 390
    if (*tmp___6 == 2) {
      {
#line 391
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"no crontab for %s\n",
              User);
      }
    } else {
      {
#line 393
      tmp___4 = __errno_location();
#line 393
      tmp___5 = strerror(*tmp___4);
#line 393
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s/: unlink: %s\n",
              "/var/spool/cron", tmp___5);
      }
    }
    {
#line 395
    exit(1);
    }
  }
  {
#line 397
  poke_daemon();
  }
#line 398
  return;
}
}
#line 401 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/crontab.c"
static void check_error(char *msg ) 
{ 


  {
  {
#line 405
  CheckErrorCount ++;
#line 406
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\"%s\":%d: %s\n",
          Filename, LineNumber - 1, msg);
  }
#line 407
  return;
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/crontab.c"
static int create_tmp_crontab(void) 
{ 
  char const   *template ;
  int nfd ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 416
  template = "/crontab.XXXXXX";
#line 422
  tmp = getenv("TMPDIR");
  }
#line 422
  if (tmp) {
    {
#line 422
    tmp___0 = strlen((char const   *)tmp);
    }
#line 422
    if (tmp___0 < 100UL) {
      {
#line 423
      strcpy((char */* __restrict  */)(Directory), (char const   */* __restrict  */)tmp);
      }
    } else {
      {
#line 425
      strcpy((char */* __restrict  */)(Directory), (char const   */* __restrict  */)"/tmp");
      }
    }
  } else {
    {
#line 425
    strcpy((char */* __restrict  */)(Directory), (char const   */* __restrict  */)"/tmp");
    }
  }
  {
#line 428
  tmp___1 = strlen((char const   *)(Directory));
#line 428
  tmp___2 = strlen(template);
  }
#line 428
  if (tmp___1 + tmp___2 < 100UL) {
    {
#line 429
    strcat((char */* __restrict  */)(Directory), (char const   */* __restrict  */)template);
    }
  } else {
    {
#line 431
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"TMPDIR value is to long -- exiting\n");
#line 432
    Directory[0] = (char )'\000';
    }
#line 433
    return (-1);
  }
  {
#line 436
  tmp___3 = mkdtemp(Directory);
  }
#line 436
  if (! tmp___3) {
    {
#line 437
    perror((char const   *)(Directory));
#line 438
    Directory[0] = (char )'\000';
    }
#line 439
    return (-1);
  }
  {
#line 443
  tmp___4 = snprintf((char */* __restrict  */)(Filename), (size_t )100, (char const   */* __restrict  */)"%s/crontab",
                     Directory);
  }
#line 443
  if (tmp___4 >= 100) {
    {
#line 445
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Temporary filename too long - aborting\n");
#line 446
    Filename[0] = (char )'\000';
    }
#line 447
    return (-1);
  }
  {
#line 449
  nfd = open((char const   *)(Filename), 193, 384);
  }
#line 449
  if (nfd == -1) {
    {
#line 450
    perror((char const   *)(Filename));
#line 451
    Filename[0] = (char )'\000';
    }
#line 452
    return (-1);
  }
#line 454
  return (nfd);
}
}
#line 461 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/crontab.c"
static int open_tmp_crontab(struct stat *fsbuf ) 
{ 
  int t ;
  struct stat statbuf ;
  int tmp ;
  __uid_t tmp___0 ;

  {
  {
#line 468
  t = open((char const   *)(Filename), 0);
  }
#line 468
  if (t < 0) {
    {
#line 469
    perror("Can\'t open tempfile after edit");
    }
#line 470
    return (-1);
  }
  {
#line 473
  tmp = fstat(t, & statbuf);
  }
#line 473
  if (tmp < 0) {
    {
#line 474
    perror("fstat");
    }
#line 475
    return (-1);
  }
  {
#line 477
  tmp___0 = getuid();
  }
#line 477
  if (statbuf.st_uid != tmp___0) {
    {
#line 478
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Temporary crontab no longer owned by you.\n");
    }
#line 479
    return (-1);
  }
#line 482
  if (! ((statbuf.st_mode & 61440U) == 32768U)) {
    {
#line 483
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The temporary crontab must remain a regular file");
    }
#line 484
    return (-1);
  }
#line 487
  if (statbuf.st_mtim.tv_sec == fsbuf->st_mtim.tv_sec) {
#line 488
    return (1);
  }
  {
#line 491
  NewCrontab = fdopen(t, "r");
  }
#line 492
  if (! NewCrontab) {
    {
#line 493
    perror("fdopen(): after edit");
    }
#line 494
    return (-1);
  }
#line 496
  return (0);
}
}
#line 503 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/crontab.c"
static void cleanup_tmp_crontab(void) 
{ 
  DIR *dp ;
  struct dirent *ep ;
  char fname[100] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 510
  if ((int )Directory[0] == 0) {
#line 511
    return;
  }
  {
#line 515
  dp = opendir((char const   *)(Directory));
  }
#line 516
  if ((unsigned long )dp == (unsigned long )((void *)0)) {
    {
#line 517
    perror((char const   *)(Directory));
    }
#line 518
    return;
  }
  {
#line 521
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 521
    ep = readdir(dp);
    }
#line 521
    if (! ep) {
#line 521
      goto while_break;
    }
    {
#line 522
    tmp = strcmp((char const   *)(ep->d_name), ".");
    }
#line 522
    if (tmp) {
      {
#line 522
      tmp___0 = strcmp((char const   *)(ep->d_name), "..");
      }
#line 522
      if (! tmp___0) {
#line 524
        goto while_continue;
      }
    } else {
#line 524
      goto while_continue;
    }
    {
#line 526
    tmp___1 = snprintf((char */* __restrict  */)(fname), (size_t )100, (char const   */* __restrict  */)"%s/%s",
                       Directory, ep->d_name);
    }
#line 526
    if (tmp___1 >= 100) {
      {
#line 528
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"filename too long to delete: %s/%s",
              Directory, ep->d_name);
      }
#line 530
      return;
    }
    {
#line 532
    tmp___2 = unlink((char const   *)(fname));
    }
#line 532
    if (tmp___2) {
      {
#line 533
      perror((char const   *)(ep->d_name));
      }
#line 534
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 537
  closedir(dp);
#line 539
  tmp___3 = rmdir((char const   *)(Directory));
  }
#line 539
  if (tmp___3) {
    {
#line 540
    perror((char const   *)(Directory));
    }
#line 541
    return;
  }
#line 543
  return;
}
}
#line 546 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/crontab.c"
static void edit_cmd(void) 
{ 
  char n[100] ;
  char q[1000] ;
  char *editor ;
  FILE *f ;
  int ch ;
  int t ;
  int x ;
  struct stat fsbuf ;
  int waiter ;
  pid_t pid ;
  pid_t xpid ;
  mode_t um ;
  int add_help_text ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  __gid_t tmp___7 ;
  int tmp___8 ;
  __uid_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  union __anonunion_55___1 __constr_expr_9 ;
  char const   *tmp___16 ;
  union __anonunion_57___0 __constr_expr_11 ;
  union __anonunion_58___0 __constr_expr_12 ;
  union __anonunion_59___0 __constr_expr_13 ;
  union __anonunion_60___0 __constr_expr_14 ;
  union __anonunion_61___0 __constr_expr_15 ;
  union __anonunion_62 __constr_expr_16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___20 ;
  int tmp___21 ;
  unsigned short const   **tmp___22 ;
  int tmp___23 ;

  {
  {
#line 555
  add_help_text = 0;
#line 557
  log_it(RealUser, Pid, (char *)"BEGIN EDIT", User);
#line 558
  snprintf((char */* __restrict  */)(n), (size_t )100, (char const   */* __restrict  */)"%s/%s",
           "crontabs", User);
#line 559
  f = fopen((char const   */* __restrict  */)(n), (char const   */* __restrict  */)"r");
  }
#line 559
  if (! f) {
    {
#line 560
    tmp___1 = __errno_location();
    }
#line 560
    if (*tmp___1 != 2) {
      {
#line 561
      tmp = __errno_location();
#line 561
      tmp___0 = strerror(*tmp);
#line 561
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s/: fdopen: %s",
              n, tmp___0);
#line 562
      exit(1);
      }
    }
    {
#line 564
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"no crontab for %s - using an empty one\n",
            User);
#line 566
    f = fopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"r");
    }
#line 566
    if (! f) {
      {
#line 567
      perror("/dev/null");
#line 568
      exit(1);
      }
    }
#line 570
    add_help_text = 1;
  }
  {
#line 573
  um = umask((__mode_t )63);
#line 575
  t = create_tmp_crontab();
  }
#line 575
  if (t < 0) {
    {
#line 576
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Creation of temporary crontab file failed - aborting\n");
#line 577
    umask(um);
    }
#line 578
    goto fatal;
  }
  {
#line 581
  umask(um);
#line 582
  NewCrontab = fdopen(t, "w");
  }
#line 582
  if (! NewCrontab) {
    {
#line 583
    perror("fdopen");
    }
#line 584
    goto fatal;
  }
#line 587
  LineNumber = 1;
#line 589
  if (add_help_text) {
    {
#line 590
    fprintf((FILE */* __restrict  */)NewCrontab, (char const   */* __restrict  */)"# Edit this file to introduce tasks to be run by cron.\n# \n# Each task to run has to be defined through a single line\n# indicating with different fields when the task will be run\n# and what command to run for the task\n# \n# To define the time you can provide concrete values for\n# minute (m), hour (h), day of month (dom), month (mon),\n# and day of week (dow) or use \'*\' in these fields (for \'any\').# \n# Notice that tasks will be started based on the cron\'s system\n# daemon\'s notion of time and timezones.\n# \n# Output of the crontab jobs (including errors) is sent through\n# email to the user the crontab file belongs to (unless redirected).\n# \n# For example, you can run a backup of all your user accounts\n# at 5 a.m every week with:\n# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/\n# \n# For more information see the manual pages of crontab(5) and cron(8)\n# \n# m h  dom mon dow   command\n");
    }
  }
#line 618
  x = 0;
  {
#line 618
  while (1) {
    while_continue: /* CIL Label */ ;
#line 618
    if (! (x < 3)) {
#line 618
      goto while_break;
    }
    {
#line 619
    ch = get_char(f);
    }
#line 620
    if (-1 == ch) {
#line 621
      goto while_break;
    }
#line 622
    if (35 != ch) {
      {
#line 623
      _IO_putc(ch, NewCrontab);
      }
#line 624
      goto while_break;
    }
    {
#line 626
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 626
      ch = get_char(f);
      }
#line 626
      if (! (-1 != ch)) {
#line 626
        goto while_break___0;
      }
#line 627
      if (ch == 10) {
#line 628
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 629
    if (-1 == ch) {
#line 630
      goto while_break;
    }
#line 618
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 635
  if (-1 != ch) {
    {
#line 636
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 636
      ch = get_char(f);
      }
#line 636
      if (! (-1 != ch)) {
#line 636
        goto while_break___1;
      }
      {
#line 637
      _IO_putc(ch, NewCrontab);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 638
  fclose(f);
#line 640
  tmp___2 = ferror(NewCrontab);
  }
#line 640
  if (tmp___2) {
    {
#line 641
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error while writing new crontab to %s\n",
            ProgramName, Filename);
    }
  }
  {
#line 645
  tmp___3 = fstat(t, & fsbuf);
  }
#line 645
  if (tmp___3 < 0) {
    {
#line 646
    perror("unable to stat temp file");
    }
#line 647
    goto fatal;
  }
  {
#line 654
  editor = getenv("VISUAL");
  }
#line 654
  if (editor) {
    {
#line 654
    tmp___4 = strlen((char const   *)editor);
    }
#line 654
    if (! tmp___4) {
#line 654
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 654
    editor = getenv("EDITOR");
    }
#line 654
    if (editor) {
      {
#line 654
      tmp___5 = strlen((char const   *)editor);
      }
#line 654
      if (! tmp___5) {
#line 657
        editor = (char *)"/usr/bin/sensible-editor";
      }
    } else {
#line 657
      editor = (char *)"/usr/bin/sensible-editor";
    }
  }
  {
#line 663
  tmp___6 = fclose(NewCrontab);
  }
#line 663
  if (tmp___6 != 0) {
    {
#line 664
    perror((char const   *)(Filename));
    }
#line 665
    goto fatal;
  }
  again: 
  {
#line 671
  signal(1, (void (*)(int  ))1);
#line 672
  signal(2, (void (*)(int  ))1);
#line 673
  signal(3, (void (*)(int  ))1);
#line 676
  swap_uids();
#line 678
  pid = fork();
  }
  {
#line 679
  if (pid == -1) {
#line 679
    goto case_neg_1;
  }
#line 682
  if (pid == 0) {
#line 682
    goto case_0;
  }
#line 706
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 680
  perror("fork");
  }
#line 681
  goto fatal;
  case_0: /* CIL Label */ 
  {
#line 684
  tmp___7 = getgid();
#line 684
  tmp___8 = setgid(tmp___7);
  }
#line 684
  if (tmp___8 < 0) {
    {
#line 685
    perror("setgid(getgid())");
#line 686
    exit(1);
    }
  }
  {
#line 688
  tmp___9 = getuid();
#line 688
  tmp___10 = setuid(tmp___9);
  }
#line 688
  if (tmp___10 < 0) {
    {
#line 689
    perror("setuid(getuid())");
#line 690
    exit(1);
    }
  }
  {
#line 692
  tmp___11 = chdir("/tmp");
  }
#line 692
  if (tmp___11 < 0) {
    {
#line 693
    perror("chdir(/tmp)");
#line 694
    exit(1);
    }
  }
  {
#line 696
  tmp___12 = strlen((char const   *)editor);
#line 696
  tmp___13 = strlen((char const   *)(Filename));
  }
#line 696
  if ((tmp___12 + tmp___13) + 2UL >= 1000UL) {
    {
#line 697
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: editor or filename too long\n",
            ProgramName);
#line 699
    exit(1);
    }
  }
  {
#line 701
  snprintf((char */* __restrict  */)(q), (size_t )1000, (char const   */* __restrict  */)"%s %s",
           editor, Filename);
#line 702
  execlp("/bin/sh", "/bin/sh", "-c", q, (void *)0);
#line 703
  perror((char const   *)editor);
#line 704
  exit(1);
  }
  switch_default: /* CIL Label */ 
#line 708
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 712
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 713
    xpid = waitpid(pid, & waiter, 2);
    }
#line 714
    if (xpid == -1) {
      {
#line 715
      tmp___14 = __errno_location();
#line 715
      tmp___15 = strerror(*tmp___14);
#line 715
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: waitpid() failed waiting for PID %d from \"%s\": %s\n",
              ProgramName, pid, editor, tmp___15);
      }
    } else
#line 717
    if (xpid != pid) {
      {
#line 718
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: wrong PID (%d != %d) from \"%s\"\n",
              ProgramName, xpid, pid, editor);
      }
#line 720
      goto fatal;
    } else {
#line 721
      __constr_expr_16.__in = waiter;
#line 721
      if (! ((__constr_expr_16.__i & 255) == 127)) {
#line 723
        __constr_expr_14.__in = waiter;
#line 723
        if ((__constr_expr_14.__i & 127) == 0) {
#line 723
          __constr_expr_15.__in = waiter;
#line 723
          if ((__constr_expr_15.__i & 65280) >> 8) {
            {
#line 724
            __constr_expr_9.__in = waiter;
#line 724
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: \"%s\" exited with status %d\n",
                    ProgramName, editor, (__constr_expr_9.__i & 65280) >> 8);
            }
#line 726
            goto fatal;
          } else {
#line 723
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 727
          __constr_expr_13.__in = waiter;
#line 727
          if ((int )((signed char )((__constr_expr_13.__i & 127) + 1)) >> 1 > 0) {
#line 728
            __constr_expr_11.__in = waiter;
#line 728
            if (__constr_expr_11.__i & 128) {
#line 728
              tmp___16 = "";
            } else {
#line 728
              tmp___16 = "no ";
            }
            {
#line 728
            __constr_expr_12.__in = waiter;
#line 728
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: \"%s\" killed; signal %d (%score dumped)\n",
                    ProgramName, editor, __constr_expr_12.__i & 127, tmp___16);
            }
#line 732
            goto fatal;
          } else {
#line 734
            goto while_break___2;
          }
        }
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 736
  signal(1, (void (*)(int  ))0);
#line 737
  signal(2, (void (*)(int  ))0);
#line 738
  signal(3, (void (*)(int  ))0);
#line 739
  signal(20, (void (*)(int  ))0);
#line 742
  swap_uids_back();
#line 744
  tmp___17 = open_tmp_crontab(& fsbuf);
  }
  {
#line 745
  if (tmp___17 == -1) {
#line 745
    goto case_neg_1___0;
  }
#line 748
  if (tmp___17 == 1) {
#line 748
    goto case_1;
  }
#line 751
  if (tmp___17 == 0) {
#line 751
    goto case_0___0;
  }
#line 753
  goto switch_default___0;
  case_neg_1___0: /* CIL Label */ 
  {
#line 746
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error while editing crontab\n");
  }
#line 747
  goto fatal;
  case_1: /* CIL Label */ 
  {
#line 749
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No modification made\n");
  }
#line 750
  goto remove;
  case_0___0: /* CIL Label */ 
#line 752
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 754
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cron@packages.debian.org fscked up. Send him a nasty note\n");
  }
#line 756
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 759
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: installing new crontab\n",
          ProgramName);
#line 760
  tmp___18 = replace_cmd();
  }
  {
#line 761
  if (tmp___18 == 0) {
#line 761
    goto case_0___1;
  }
#line 763
  if (tmp___18 == -1) {
#line 763
    goto case_neg_1___1;
  }
#line 779
  if (tmp___18 == -2) {
#line 779
    goto abandon;
  }
#line 784
  goto switch_default___2;
  case_0___1: /* CIL Label */ 
#line 762
  goto switch_break___1;
  case_neg_1___1: /* CIL Label */ 
  {
#line 764
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 765
    printf((char const   */* __restrict  */)"Do you want to retry the same edit? (y/n) ");
#line 766
    fflush(stdout);
#line 767
    q[0] = (char )'\000';
#line 768
    fgets((char */* __restrict  */)(q), (int )sizeof(q), (FILE */* __restrict  */)stdin);
#line 769
    tmp___22 = __ctype_b_loc();
    }
#line 769
    if ((int const   )*(*tmp___22 + (int )q[0]) & 512) {
#line 769
      tmp___21 = (int )q[0];
    } else {
      {
#line 769
      tmp___20 = tolower((int )q[0]);
#line 769
      tmp___21 = tmp___20;
      }
    }
    {
#line 770
    if (tmp___21 == 121) {
#line 770
      goto case_121;
    }
#line 772
    if (tmp___21 == 110) {
#line 772
      goto case_110;
    }
#line 774
    goto switch_default___1;
    case_121: /* CIL Label */ 
#line 771
    goto again;
    case_110: /* CIL Label */ 
#line 773
    goto abandon;
    switch_default___1: /* CIL Label */ 
    {
#line 775
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Enter Y or N\n");
    }
    switch_break___2: /* CIL Label */ ;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  abandon: 
  case_neg_2: /* CIL Label */ 
  {
#line 781
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: edits left in %s\n",
          ProgramName, Filename);
  }
#line 783
  goto done;
  switch_default___2: /* CIL Label */ 
  {
#line 785
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: panic: bad switch() in replace_cmd()\n",
          ProgramName);
  }
#line 787
  goto fatal;
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 790
  tmp___23 = fclose(NewCrontab);
  }
#line 790
  if (tmp___23 != 0) {
    {
#line 791
    perror((char const   *)(Filename));
    }
  }
  remove: 
  {
#line 795
  cleanup_tmp_crontab();
  }
  done: 
  {
#line 797
  log_it(RealUser, Pid, (char *)"END EDIT", User);
  }
#line 798
  return;
  fatal: 
  {
#line 800
  cleanup_tmp_crontab();
#line 801
  unlink((char const   *)(Filename));
#line 802
  exit(1);
  }
}
}
#line 805 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/crontab.c"
static char tn[100]  ;
#line 807 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/crontab.c"
static void sig_handler(int x ) 
{ 


  {
  {
#line 809
  unlink((char const   *)(tn));
#line 810
  exit(1);
  }
}
}
#line 817 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/crontab.c"
static int replace_cmd(void) 
{ 
  char n[100] ;
  char envstr[1000] ;
  FILE *tmp ;
  int ch ;
  int eof ;
  int fd ;
  int nl ;
  entry *e ;
  time_t now ;
  time_t tmp___0 ;
  char **envp ;
  char **tmp___1 ;
  mode_t um ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  __uid_t tmp___17 ;
  int tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;

  {
  {
#line 822
  nl = 0;
#line 824
  tmp___0 = time((time_t *)((void *)0));
#line 824
  now = tmp___0;
#line 825
  tmp___1 = env_init();
#line 825
  envp = tmp___1;
  }
#line 828
  if ((unsigned long )envp == (unsigned long )((void *)0)) {
    {
#line 829
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Cannot allocate memory.\n",
            ProgramName);
    }
#line 830
    return (-2);
  }
  {
#line 838
  signal(1, & sig_handler);
#line 839
  signal(2, & sig_handler);
#line 840
  signal(3, & sig_handler);
#line 841
  signal(20, (void (*)(int  ))1);
#line 843
  snprintf((char */* __restrict  */)(tn), (size_t )100, (char const   */* __restrict  */)"%s/%s",
           "crontabs", "tmp.XXXXXX");
#line 844
  um = umask((__mode_t )63);
#line 845
  fd = mkstemp(tn);
  }
#line 846
  if (fd < 0) {
    {
#line 847
    tmp___2 = __errno_location();
#line 847
    tmp___3 = strerror(*tmp___2);
#line 847
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s/: mkstemp: %s\n",
            "/var/spool/cron", tmp___3);
    }
#line 848
    return (-2);
  }
  {
#line 850
  tmp = fdopen(fd, "w+");
  }
#line 851
  if (! tmp) {
    {
#line 852
    tmp___4 = __errno_location();
#line 852
    tmp___5 = strerror(*tmp___4);
#line 852
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s/: fdopen: %s\n",
            "/var/spool/cron", tmp___5);
    }
#line 853
    return (-2);
  }
  {
#line 855
  umask(um);
#line 861
  fprintf((FILE */* __restrict  */)tmp, (char const   */* __restrict  */)"# DO NOT EDIT THIS FILE - edit the master and reinstall.\n");
#line 862
  tmp___6 = ctime((time_t const   *)(& now));
#line 862
  fprintf((FILE */* __restrict  */)tmp, (char const   */* __restrict  */)"# (%s installed on %-24.24s)\n",
          Filename, tmp___6);
#line 863
  fprintf((FILE */* __restrict  */)tmp, (char const   */* __restrict  */)"# (Cron version -- %s)\n",
          rcsid);
#line 867
  rewind(NewCrontab);
#line 868
  LineNumber = 1;
  }
  {
#line 869
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 869
    ch = get_char(NewCrontab);
    }
#line 869
    if (! (-1 != ch)) {
#line 869
      goto while_break;
    }
    {
#line 870
    _IO_putc(ch, tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 872
  tmp___9 = ferror(tmp);
  }
#line 872
  if (tmp___9) {
#line 872
    goto _L;
  } else {
    {
#line 872
    tmp___10 = fflush(tmp);
    }
#line 872
    if (tmp___10) {
#line 872
      goto _L;
    } else {
      {
#line 872
      tmp___11 = fsync(fd);
      }
#line 872
      if (tmp___11) {
        _L: /* CIL Label */ 
        {
#line 873
        tmp___7 = __errno_location();
#line 873
        tmp___8 = strerror(*tmp___7);
#line 873
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
                ProgramName, tn, tmp___8);
#line 875
        fclose(tmp);
#line 875
        unlink((char const   *)(tn));
        }
#line 876
        return (-2);
      }
    }
  }
  {
#line 881
  rewind(tmp);
#line 886
  LineNumber = -2;
#line 887
  CheckErrorCount = 0;
#line 887
  eof = 0;
  }
  {
#line 888
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 888
    if (! CheckErrorCount) {
#line 888
      if (! (! eof)) {
#line 888
        goto while_break___0;
      }
    } else {
#line 888
      goto while_break___0;
    }
    {
#line 889
    tmp___12 = load_env(envstr, tmp);
    }
    {
#line 890
    if (tmp___12 == -1) {
#line 890
      goto case_neg_1;
    }
#line 895
    if (tmp___12 == 0) {
#line 895
      goto case_0;
    }
#line 900
    if (tmp___12 == 1) {
#line 900
      goto case_1;
    }
#line 889
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 891
    eof = 1;
#line 892
    if ((int )envstr[0] == 0) {
#line 893
      nl = 1;
    }
#line 894
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 896
    e = load_entry(tmp, (void (*)())(& check_error), pw, envp);
    }
#line 897
    if (e) {
      {
#line 898
      free((void *)e);
      }
    }
#line 899
    goto switch_break;
    case_1: /* CIL Label */ 
#line 901
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 905
  if (CheckErrorCount != 0) {
    {
#line 906
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"errors in crontab file, can\'t install.\n");
#line 907
    fclose(tmp);
#line 907
    unlink((char const   *)(tn));
    }
#line 908
    return (-1);
  }
#line 911
  if (nl == 0) {
    {
#line 912
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"new crontab file is missing newline before EOF, can\'t install.\n");
#line 914
    fclose(tmp);
#line 914
    unlink((char const   *)(tn));
    }
#line 915
    return (-1);
  }
  {
#line 920
  tmp___13 = fileno(tmp);
#line 920
  tmp___14 = fchmod(tmp___13, (__mode_t )384);
  }
#line 920
  if (tmp___14 < 0) {
    {
#line 925
    perror("chmod");
#line 926
    fclose(tmp);
#line 926
    unlink((char const   *)(tn));
    }
#line 927
    return (-2);
  }
  {
#line 931
  tmp___15 = fclose(tmp);
  }
#line 931
  if (tmp___15 == -1) {
    {
#line 932
    perror("fclose");
#line 933
    unlink((char const   *)(tn));
    }
#line 934
    return (-2);
  }
  {
#line 938
  tmp___17 = getuid();
  }
#line 938
  if (tmp___17 == 0U) {
    {
#line 938
    tmp___18 = strcmp((char const   *)User, (char const   *)RealUser);
    }
#line 938
    if (tmp___18 != 0) {
      {
#line 939
      tmp___16 = chown((char const   *)(tn), pw->pw_uid, (__gid_t )-1);
      }
#line 939
      if (tmp___16 != 0) {
        {
#line 940
        perror("chown");
#line 941
        unlink((char const   *)(tn));
        }
#line 942
        return (-2);
      }
    }
  }
  {
#line 946
  snprintf((char */* __restrict  */)(n), sizeof(n), (char const   */* __restrict  */)"%s/%s",
           "crontabs", User);
#line 947
  tmp___21 = rename((char const   *)(tn), (char const   *)(n));
  }
#line 947
  if (tmp___21) {
    {
#line 948
    tmp___19 = __errno_location();
#line 948
    tmp___20 = strerror(*tmp___19);
#line 948
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: rename: %s\n",
            ProgramName, n, tmp___20);
#line 950
    unlink((char const   *)(tn));
    }
#line 951
    return (-2);
  }
  {
#line 955
  log_it(RealUser, Pid, (char *)"REPLACE", User);
#line 957
  poke_daemon();
  }
#line 959
  return (0);
}
}
#line 963 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/crontab.c"
static void poke_daemon(void) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 977
  tmp___1 = utime("crontabs", (struct utimbuf  const  *)((void *)0));
  }
#line 977
  if (tmp___1 < 0) {
    {
#line 978
    tmp = __errno_location();
#line 978
    tmp___0 = strerror(*tmp);
#line 978
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: utime: %s\n",
            "/var/spool/cron", tmp___0);
#line 979
    fputs((char const   */* __restrict  */)"crontab: can\'t update mtime on spooldir\n",
          (FILE */* __restrict  */)stderr);
    }
#line 980
    return;
  }
#line 983
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/entry.c"
static char get_list___0(bitstr_t *bits , int low , int high , char **names , int ch ,
                         FILE *file ) ;
#line 37
static char get_range___0(bitstr_t *bits , int low , int high , char **names , int ch ,
                          FILE *file ) ;
#line 37
static char get_number___0(int *numptr , int low , char **names , int ch , FILE *file ) ;
#line 40
static int set_element___0(bitstr_t *bits , int low , int high , int number ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/entry.c"
static char *ecodes___0[9]  = 
#line 42
  {      (char *)"no error",      (char *)"bad minute",      (char *)"bad hour",      (char *)"bad day-of-month", 
        (char *)"bad month",      (char *)"bad day-of-week",      (char *)"bad command",      (char *)"bad time specifier", 
        (char *)"bad username"};
#line 360 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/entry.c"
static char get_list___0(bitstr_t *bits , int low , int high , char **names , int ch ,
                         FILE *file ) 
{ 
  register int done ;
  register bitstr_t *_name ;
  register int _start ;
  register int _stop ;
  register int _startbyte ;
  register int _stopbyte ;
  char tmp ;

  {
#line 383
  _name = bits;
#line 383
  _start = 0;
#line 383
  _stop = (high - low) + 1;
#line 383
  _startbyte = _start >> 3;
#line 383
  _stopbyte = _stop >> 3;
#line 383
  if (_startbyte == _stopbyte) {
#line 383
    *(_name + _startbyte) = (bitstr_t )((int )*(_name + _startbyte) & ((255 >> (8 - (_start & 7))) | (255 << ((_stop & 7) + 1))));
  } else {
#line 383
    *(_name + _startbyte) = (bitstr_t )((int )*(_name + _startbyte) & (255 >> (8 - (_start & 7))));
    {
#line 383
    while (1) {
      while_continue: /* CIL Label */ ;
#line 383
      _startbyte ++;
#line 383
      if (! (_startbyte < _stopbyte)) {
#line 383
        goto while_break;
      }
#line 383
      *(_name + _startbyte) = (bitstr_t )0;
    }
    while_break: /* CIL Label */ ;
    }
#line 383
    *(_name + _stopbyte) = (bitstr_t )((int )*(_name + _stopbyte) & (255 << ((_stop & 7) + 1)));
  }
#line 387
  done = 0;
  {
#line 388
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 388
    if (! (! done)) {
#line 388
      goto while_break___0;
    }
    {
#line 389
    tmp = get_range___0(bits, low, high, names, ch, file);
#line 389
    ch = (int )tmp;
    }
#line 390
    if (ch == 44) {
      {
#line 391
      ch = get_char(file);
      }
    } else {
#line 393
      done = 1;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 398
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 398
    if (ch != 9) {
#line 398
      if (ch != 32) {
#line 398
        if (ch != 10) {
#line 398
          if (! (ch != -1)) {
#line 398
            goto while_break___1;
          }
        } else {
#line 398
          goto while_break___1;
        }
      } else {
#line 398
        goto while_break___1;
      }
    } else {
#line 398
      goto while_break___1;
    }
    {
#line 398
    ch = get_char(file);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 399
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 399
    if (! (ch == 9)) {
#line 399
      if (! (ch == 32)) {
#line 399
        goto while_break___2;
      }
    }
    {
#line 399
    ch = get_char(file);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 403
  return ((char )ch);
}
}
#line 407 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/entry.c"
static char get_range___0(bitstr_t *bits , int low , int high , char **names , int ch ,
                          FILE *file ) 
{ 
  register int i ;
  int num1 ;
  int num2 ;
  int num3 ;
  char tmp ;
  int tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;

  {
#line 423
  if (ch == 42) {
    {
#line 426
    num1 = low;
#line 427
    num2 = high;
#line 428
    ch = get_char(file);
    }
#line 429
    if (ch == -1) {
#line 430
      return ((char)-1);
    }
  } else {
    {
#line 432
    tmp = get_number___0(& num1, low, names, ch, file);
#line 432
    ch = (int )tmp;
    }
#line 432
    if (-1 == ch) {
#line 433
      return ((char)-1);
    }
#line 435
    if (ch != 45) {
      {
#line 438
      tmp___0 = set_element___0(bits, low, high, num1);
      }
#line 438
      if (-1 == tmp___0) {
#line 439
        return ((char)-1);
      }
#line 440
      return ((char )ch);
    } else {
      {
#line 444
      ch = get_char(file);
      }
#line 445
      if (ch == -1) {
#line 446
        return ((char)-1);
      }
      {
#line 450
      tmp___1 = get_number___0(& num2, low, names, ch, file);
#line 450
      ch = (int )tmp___1;
      }
#line 451
      if (ch == -1) {
#line 452
        return ((char)-1);
      }
    }
  }
#line 458
  if (ch == 47) {
    {
#line 461
    ch = get_char(file);
    }
#line 462
    if (ch == -1) {
#line 463
      return ((char)-1);
    }
    {
#line 470
    tmp___2 = get_number___0(& num3, 0, (char **)((void *)0), ch, file);
#line 470
    ch = (int )tmp___2;
    }
#line 471
    if (ch == -1) {
#line 472
      return ((char)-1);
    } else
#line 471
    if (num3 <= 0) {
#line 472
      return ((char)-1);
    }
  } else {
#line 476
    num3 = 1;
  }
#line 487
  if (num1 < low) {
#line 488
    return ((char)-1);
  } else
#line 487
  if (num1 > high) {
#line 488
    return ((char)-1);
  } else
#line 487
  if (num2 < low) {
#line 488
    return ((char)-1);
  } else
#line 487
  if (num2 > high) {
#line 488
    return ((char)-1);
  }
#line 495
  i = num1;
  {
#line 495
  while (1) {
    while_continue: /* CIL Label */ ;
#line 495
    if (! (i <= num2)) {
#line 495
      goto while_break;
    }
    {
#line 496
    tmp___3 = set_element___0(bits, low, high, i);
    }
#line 496
    if (-1 == tmp___3) {
#line 497
      return ((char)-1);
    }
#line 495
    i += num3;
  }
  while_break: /* CIL Label */ ;
  }
#line 499
  return ((char )ch);
}
}
#line 503 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/entry.c"
static char get_number___0(int *numptr , int low , char **names , int ch , FILE *file ) 
{ 
  char temp[1000] ;
  char *pc ;
  int len ;
  int i ;
  int all_digits ;
  char *tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;

  {
#line 516
  pc = temp;
#line 517
  len = 0;
#line 518
  all_digits = 1;
  {
#line 519
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 519
    tmp___1 = __ctype_b_loc();
    }
#line 519
    if (! ((int const   )*(*tmp___1 + ch) & 8)) {
#line 519
      goto while_break;
    }
#line 520
    len ++;
#line 520
    if (len >= 1000) {
#line 521
      return ((char)-1);
    }
    {
#line 523
    tmp = pc;
#line 523
    pc ++;
#line 523
    *tmp = (char )ch;
#line 525
    tmp___0 = __ctype_b_loc();
    }
#line 525
    if (! ((int const   )*(*tmp___0 + ch) & 2048)) {
#line 526
      all_digits = 0;
    }
    {
#line 528
    ch = get_char(file);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 530
  *pc = (char )'\000';
#line 532
  if (len == 0) {
#line 533
    return ((char)-1);
  }
#line 538
  if (names) {
#line 539
    i = 0;
    {
#line 539
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 539
      if (! ((unsigned long )*(names + i) != (unsigned long )((void *)0))) {
#line 539
        goto while_break___0;
      }
      {
#line 542
      tmp___2 = strcasecmp((char const   *)*(names + i), (char const   *)(temp));
      }
#line 542
      if (! tmp___2) {
#line 543
        *numptr = i + low;
#line 544
        return ((char )ch);
      }
#line 539
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 553
  if (all_digits) {
    {
#line 554
    *numptr = atoi((char const   *)(temp));
    }
#line 555
    return ((char )ch);
  }
#line 558
  return ((char)-1);
}
}
#line 562 "/home/june/repo/benchmarks/collector/temp/cron-3.0pl1/entry.c"
static int set_element___0(bitstr_t *bits , int low , int high , int number ) 
{ 


  {
#line 571
  if (number < low) {
#line 572
    return (-1);
  } else
#line 571
  if (number > high) {
#line 572
    return (-1);
  }
#line 574
  *(bits + ((number - low) >> 3)) = (bitstr_t )((int )*(bits + ((number - low) >> 3)) | (1 << ((number - low) & 7)));
#line 575
  return (0);
}
}
