/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 66 "/usr/include/X11/X.h"
typedef unsigned long XID;
#line 74 "/usr/include/X11/X.h"
typedef unsigned long Atom;
#line 76 "/usr/include/X11/X.h"
typedef unsigned long VisualID;
#line 77 "/usr/include/X11/X.h"
typedef unsigned long Time;
#line 96 "/usr/include/X11/X.h"
typedef XID Window;
#line 97 "/usr/include/X11/X.h"
typedef XID Drawable;
#line 100 "/usr/include/X11/X.h"
typedef XID Font;
#line 102 "/usr/include/X11/X.h"
typedef XID Pixmap;
#line 103 "/usr/include/X11/X.h"
typedef XID Cursor;
#line 104 "/usr/include/X11/X.h"
typedef XID Colormap;
#line 92 "/usr/include/X11/Xlib.h"
typedef char *XPointer;
#line 160 "/usr/include/X11/Xlib.h"
struct _XExtData {
   int number ;
   struct _XExtData *next ;
   int (*free_private)(struct _XExtData *extension ) ;
   XPointer private_data ;
};
#line 160 "/usr/include/X11/Xlib.h"
typedef struct _XExtData XExtData;
#line 193 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGCValues_29 {
   int function ;
   unsigned long plane_mask ;
   unsigned long foreground ;
   unsigned long background ;
   int line_width ;
   int line_style ;
   int cap_style ;
   int join_style ;
   int fill_style ;
   int fill_rule ;
   int arc_mode ;
   Pixmap tile ;
   Pixmap stipple ;
   int ts_x_origin ;
   int ts_y_origin ;
   Font font ;
   int subwindow_mode ;
   int graphics_exposures ;
   int clip_x_origin ;
   int clip_y_origin ;
   Pixmap clip_mask ;
   int dash_offset ;
   char dashes ;
};
#line 193 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGCValues_29 XGCValues;
#line 226
struct _XGC;
#line 226 "/usr/include/X11/Xlib.h"
typedef struct _XGC *GC;
#line 239 "/usr/include/X11/Xlib.h"
struct __anonstruct_Visual_30 {
   XExtData *ext_data ;
   VisualID visualid ;
   int class ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   int bits_per_rgb ;
   int map_entries ;
};
#line 239 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Visual_30 Visual;
#line 255 "/usr/include/X11/Xlib.h"
struct __anonstruct_Depth_31 {
   int depth ;
   int nvisuals ;
   Visual *visuals ;
};
#line 255 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Depth_31 Depth;
#line 267
struct _XDisplay;
#line 269 "/usr/include/X11/Xlib.h"
struct __anonstruct_Screen_32 {
   XExtData *ext_data ;
   struct _XDisplay *display ;
   Window root ;
   int width ;
   int height ;
   int mwidth ;
   int mheight ;
   int ndepths ;
   Depth *depths ;
   int root_depth ;
   Visual *root_visual ;
   GC default_gc ;
   Colormap cmap ;
   unsigned long white_pixel ;
   unsigned long black_pixel ;
   int max_maps ;
   int min_maps ;
   int backing_store ;
   int save_unders ;
   long root_input_mask ;
};
#line 269 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Screen_32 Screen;
#line 292 "/usr/include/X11/Xlib.h"
struct __anonstruct_ScreenFormat_33 {
   XExtData *ext_data ;
   int depth ;
   int bits_per_pixel ;
   int scanline_pad ;
};
#line 292 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_ScreenFormat_33 ScreenFormat;
#line 422 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColor_39 {
   unsigned long pixel ;
   unsigned short red ;
   unsigned short green ;
   unsigned short blue ;
   char flags ;
   char pad ;
};
#line 422 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColor_39 XColor;
#line 499 "/usr/include/X11/Xlib.h"
typedef struct _XDisplay Display;
#line 502
struct _XPrivate;
#line 503
struct _XrmHashBucketRec;
#line 505 "/usr/include/X11/Xlib.h"
struct __anonstruct__XPrivDisplay_48 {
   XExtData *ext_data ;
   struct _XPrivate *private1 ;
   int fd ;
   int private2 ;
   int proto_major_version ;
   int proto_minor_version ;
   char *vendor ;
   XID private3 ;
   XID private4 ;
   XID private5 ;
   int private6 ;
   XID (*resource_alloc)(struct _XDisplay * ) ;
   int byte_order ;
   int bitmap_unit ;
   int bitmap_pad ;
   int bitmap_bit_order ;
   int nformats ;
   ScreenFormat *pixmap_format ;
   int private8 ;
   int release ;
   struct _XPrivate *private9 ;
   struct _XPrivate *private10 ;
   int qlen ;
   unsigned long last_request_read ;
   unsigned long request ;
   XPointer private11 ;
   XPointer private12 ;
   XPointer private13 ;
   XPointer private14 ;
   unsigned int max_request_size ;
   struct _XrmHashBucketRec *db ;
   int (*private15)(struct _XDisplay * ) ;
   char *display_name ;
   int default_screen ;
   int nscreens ;
   Screen *screens ;
   unsigned long motion_buffer ;
   unsigned long private16 ;
   int min_keycode ;
   int max_keycode ;
   XPointer private17 ;
   XPointer private18 ;
   int private19 ;
   char *xdefaults ;
};
#line 505 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct__XPrivDisplay_48 *_XPrivDisplay;
#line 569 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeyEvent_49 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int keycode ;
   int same_screen ;
};
#line 569 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeyEvent_49 XKeyEvent;
#line 587 "/usr/include/X11/Xlib.h"
struct __anonstruct_XButtonEvent_50 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int button ;
   int same_screen ;
};
#line 587 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XButtonEvent_50 XButtonEvent;
#line 605 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMotionEvent_51 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   char is_hint ;
   int same_screen ;
};
#line 605 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMotionEvent_51 XMotionEvent;
#line 622 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCrossingEvent_52 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   int mode ;
   int detail ;
   int same_screen ;
   int focus ;
   unsigned int state ;
};
#line 622 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCrossingEvent_52 XCrossingEvent;
#line 646 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFocusChangeEvent_53 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int mode ;
   int detail ;
};
#line 646 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFocusChangeEvent_53 XFocusChangeEvent;
#line 665 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeymapEvent_54 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   char key_vector[32] ;
};
#line 665 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeymapEvent_54 XKeymapEvent;
#line 674 "/usr/include/X11/Xlib.h"
struct __anonstruct_XExposeEvent_55 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
};
#line 674 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XExposeEvent_55 XExposeEvent;
#line 685 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGraphicsExposeEvent_56 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
   int major_code ;
   int minor_code ;
};
#line 685 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGraphicsExposeEvent_56 XGraphicsExposeEvent;
#line 698 "/usr/include/X11/Xlib.h"
struct __anonstruct_XNoExposeEvent_57 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int major_code ;
   int minor_code ;
};
#line 698 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XNoExposeEvent_57 XNoExposeEvent;
#line 708 "/usr/include/X11/Xlib.h"
struct __anonstruct_XVisibilityEvent_58 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int state ;
};
#line 708 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XVisibilityEvent_58 XVisibilityEvent;
#line 717 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCreateWindowEvent_59 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   int override_redirect ;
};
#line 717 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCreateWindowEvent_59 XCreateWindowEvent;
#line 730 "/usr/include/X11/Xlib.h"
struct __anonstruct_XDestroyWindowEvent_60 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
};
#line 730 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XDestroyWindowEvent_60 XDestroyWindowEvent;
#line 739 "/usr/include/X11/Xlib.h"
struct __anonstruct_XUnmapEvent_61 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int from_configure ;
};
#line 739 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XUnmapEvent_61 XUnmapEvent;
#line 749 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapEvent_62 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int override_redirect ;
};
#line 749 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapEvent_62 XMapEvent;
#line 759 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapRequestEvent_63 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
};
#line 759 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapRequestEvent_63 XMapRequestEvent;
#line 768 "/usr/include/X11/Xlib.h"
struct __anonstruct_XReparentEvent_64 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   Window parent ;
   int x ;
   int y ;
   int override_redirect ;
};
#line 768 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XReparentEvent_64 XReparentEvent;
#line 780 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureEvent_65 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int override_redirect ;
};
#line 780 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureEvent_65 XConfigureEvent;
#line 794 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGravityEvent_66 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
};
#line 794 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGravityEvent_66 XGravityEvent;
#line 804 "/usr/include/X11/Xlib.h"
struct __anonstruct_XResizeRequestEvent_67 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int width ;
   int height ;
};
#line 804 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XResizeRequestEvent_67 XResizeRequestEvent;
#line 813 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureRequestEvent_68 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int detail ;
   unsigned long value_mask ;
};
#line 813 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureRequestEvent_68 XConfigureRequestEvent;
#line 828 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateEvent_69 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int place ;
};
#line 828 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateEvent_69 XCirculateEvent;
#line 838 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateRequestEvent_70 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int place ;
};
#line 838 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateRequestEvent_70 XCirculateRequestEvent;
#line 848 "/usr/include/X11/Xlib.h"
struct __anonstruct_XPropertyEvent_71 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom atom ;
   Time time ;
   int state ;
};
#line 848 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XPropertyEvent_71 XPropertyEvent;
#line 859 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionClearEvent_72 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom selection ;
   Time time ;
};
#line 859 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionClearEvent_72 XSelectionClearEvent;
#line 869 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionRequestEvent_73 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window owner ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 869 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionRequestEvent_73 XSelectionRequestEvent;
#line 882 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionEvent_74 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 882 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionEvent_74 XSelectionEvent;
#line 894 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColormapEvent_75 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Colormap colormap ;
   int new ;
   int state ;
};
#line 894 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColormapEvent_75 XColormapEvent;
#line 909 "/usr/include/X11/Xlib.h"
union __anonunion_data_77 {
   char b[20] ;
   short s[10] ;
   long l[5] ;
};
#line 909 "/usr/include/X11/Xlib.h"
struct __anonstruct_XClientMessageEvent_76 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom message_type ;
   int format ;
   union __anonunion_data_77 data ;
};
#line 909 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XClientMessageEvent_76 XClientMessageEvent;
#line 924 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMappingEvent_78 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int request ;
   int first_keycode ;
   int count ;
};
#line 924 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMappingEvent_78 XMappingEvent;
#line 936 "/usr/include/X11/Xlib.h"
struct __anonstruct_XErrorEvent_79 {
   int type ;
   Display *display ;
   XID resourceid ;
   unsigned long serial ;
   unsigned char error_code ;
   unsigned char request_code ;
   unsigned char minor_code ;
};
#line 936 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XErrorEvent_79 XErrorEvent;
#line 946 "/usr/include/X11/Xlib.h"
struct __anonstruct_XAnyEvent_80 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
};
#line 946 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XAnyEvent_80 XAnyEvent;
#line 960 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEvent_81 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
};
#line 960 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEvent_81 XGenericEvent;
#line 970 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEventCookie_82 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
   unsigned int cookie ;
   void *data ;
};
#line 970 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEventCookie_82 XGenericEventCookie;
#line 985 "/usr/include/X11/Xlib.h"
union _XEvent {
   int type ;
   XAnyEvent xany ;
   XKeyEvent xkey ;
   XButtonEvent xbutton ;
   XMotionEvent xmotion ;
   XCrossingEvent xcrossing ;
   XFocusChangeEvent xfocus ;
   XExposeEvent xexpose ;
   XGraphicsExposeEvent xgraphicsexpose ;
   XNoExposeEvent xnoexpose ;
   XVisibilityEvent xvisibility ;
   XCreateWindowEvent xcreatewindow ;
   XDestroyWindowEvent xdestroywindow ;
   XUnmapEvent xunmap ;
   XMapEvent xmap ;
   XMapRequestEvent xmaprequest ;
   XReparentEvent xreparent ;
   XConfigureEvent xconfigure ;
   XGravityEvent xgravity ;
   XResizeRequestEvent xresizerequest ;
   XConfigureRequestEvent xconfigurerequest ;
   XCirculateEvent xcirculate ;
   XCirculateRequestEvent xcirculaterequest ;
   XPropertyEvent xproperty ;
   XSelectionClearEvent xselectionclear ;
   XSelectionRequestEvent xselectionrequest ;
   XSelectionEvent xselection ;
   XColormapEvent xcolormap ;
   XClientMessageEvent xclient ;
   XMappingEvent xmapping ;
   XErrorEvent xerror ;
   XKeymapEvent xkeymap ;
   XGenericEvent xgeneric ;
   XGenericEventCookie xcookie ;
   long pad[24] ;
};
#line 985 "/usr/include/X11/Xlib.h"
typedef union _XEvent XEvent;
#line 1029 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCharStruct_83 {
   short lbearing ;
   short rbearing ;
   short width ;
   short ascent ;
   short descent ;
   unsigned short attributes ;
};
#line 1029 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCharStruct_83 XCharStruct;
#line 1042 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFontProp_84 {
   Atom name ;
   unsigned long card32 ;
};
#line 1042 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFontProp_84 XFontProp;
#line 1047 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFontStruct_85 {
   XExtData *ext_data ;
   Font fid ;
   unsigned int direction ;
   unsigned int min_char_or_byte2 ;
   unsigned int max_char_or_byte2 ;
   unsigned int min_byte1 ;
   unsigned int max_byte1 ;
   int all_chars_exist ;
   unsigned int default_char ;
   int n_properties ;
   XFontProp *properties ;
   XCharStruct min_bounds ;
   XCharStruct max_bounds ;
   XCharStruct *per_char ;
   int ascent ;
   int descent ;
};
#line 1047 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFontStruct_85 XFontStruct;
#line 1855 "/usr/include/X11/Xlib.h"
typedef int (*XErrorHandler)(Display * , XErrorEvent * );
#line 53 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.h"
struct __anonstruct_TermWin_t_107 {
   short width ;
   short height ;
   short fwidth ;
   short fheight ;
   short ncol ;
   short nrow ;
   short focus ;
   short saveLines ;
   short nscrolled ;
   short view_start ;
   Window parent ;
   Window vt ;
   GC gc ;
   XFontStruct *font ;
   XFontStruct *boldFont ;
};
#line 53 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.h"
typedef struct __anonstruct_TermWin_t_107 TermWin_t;
#line 206 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.h"
typedef unsigned long Pixel;
#line 81 "/usr/include/X11/Xutil.h"
struct __anonstruct_min_aspect_112 {
   int x ;
   int y ;
};
#line 81 "/usr/include/X11/Xutil.h"
struct __anonstruct_XSizeHints_111 {
   long flags ;
   int x ;
   int y ;
   int width ;
   int height ;
   int min_width ;
   int min_height ;
   int max_width ;
   int max_height ;
   int width_inc ;
   int height_inc ;
   struct __anonstruct_min_aspect_112 min_aspect ;
   struct __anonstruct_min_aspect_112 max_aspect ;
   int base_width ;
   int base_height ;
   int win_gravity ;
};
#line 81 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XSizeHints_111 XSizeHints;
#line 119 "/usr/include/X11/Xutil.h"
struct __anonstruct_XWMHints_113 {
   long flags ;
   int input ;
   int initial_state ;
   Pixmap icon_pixmap ;
   Window icon_window ;
   int icon_x ;
   int icon_y ;
   Pixmap icon_mask ;
   XID window_group ;
};
#line 119 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XWMHints_113 XWMHints;
#line 163 "/usr/include/X11/Xutil.h"
struct __anonstruct_XTextProperty_114 {
   unsigned char *value ;
   Atom encoding ;
   int format ;
   unsigned long nitems ;
};
#line 163 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XTextProperty_114 XTextProperty;
#line 189 "/usr/include/X11/Xutil.h"
struct __anonstruct_XClassHint_117 {
   char *res_name ;
   char *res_class ;
};
#line 189 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XClassHint_117 XClassHint;
#line 17 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/scrollbar.h"
struct __anonstruct_scrollBar_t_120 {
   short beg ;
   short end ;
   short top ;
   short bot ;
   short state ;
   Window win ;
};
#line 17 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/scrollbar.h"
typedef struct __anonstruct_scrollBar_t_120 scrollBar_t;
#line 438 "/usr/include/X11/Xlib.h"
struct __anonstruct_XPoint_41 {
   short x ;
   short y ;
};
#line 438 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XPoint_41 XPoint;
#line 108 "/usr/include/X11/Xmd.h"
typedef unsigned int CARD32;
#line 8 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/thai.h"
typedef unsigned char text_t;
#line 9 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/thai.h"
typedef unsigned int rend_t;
#line 144 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
struct __anonstruct_screen_t_111 {
   text_t *text ;
   rend_t *rend ;
   short row ;
   short col ;
   short tscroll ;
   short bscroll ;
   short charset ;
   unsigned int flags ;
};
#line 144 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
typedef struct __anonstruct_screen_t_111 screen_t;
#line 185 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
struct __anonstruct_save_112 {
   short row ;
   short col ;
   short charset ;
   char charset_char ;
   rend_t rstyle ;
};
#line 207 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
struct __anonstruct_beg_114 {
   short row ;
   short col ;
};
#line 207 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
struct __anonstruct_selection_113 {
   unsigned char *text ;
   int len ;
   short op ;
   short screen ;
   struct __anonstruct_beg_114 beg ;
   struct __anonstruct_beg_114 end ;
   struct __anonstruct_beg_114 mark ;
};
#line 1848 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
typedef CARD32 Atom32;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 324 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef int wchar_t;
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_16 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_16 fd_set;
#line 106 "/usr/include/X11/X.h"
typedef XID KeySym;
#line 584 "/usr/include/X11/Xlib.h"
typedef XKeyEvent XKeyPressedEvent;
#line 1157
struct _XIM;
#line 1157 "/usr/include/X11/Xlib.h"
typedef struct _XIM *XIM;
#line 1158
struct _XIC;
#line 1158 "/usr/include/X11/Xlib.h"
typedef struct _XIC *XIC;
#line 1178 "/usr/include/X11/Xlib.h"
typedef unsigned long XIMStyle;
#line 1180 "/usr/include/X11/Xlib.h"
struct __anonstruct_XIMStyles_97 {
   unsigned short count_styles ;
   XIMStyle *supported_styles ;
};
#line 1180 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XIMStyles_97 XIMStyles;
#line 1252 "/usr/include/X11/Xlib.h"
struct __anonstruct_XICCallback_99 {
   XPointer client_data ;
   int (*callback)(XIC  , XPointer  , XPointer  ) ;
};
#line 1252 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XICCallback_99 XICCallback;
#line 1294 "/usr/include/X11/Xlib.h"
typedef unsigned long XIMStringConversionFeedback;
#line 1303 "/usr/include/X11/Xlib.h"
union __anonunion_string_101 {
   char *mbs ;
   wchar_t *wcs ;
};
#line 1303 "/usr/include/X11/Xlib.h"
struct _XIMStringConversionText {
   unsigned short length ;
   XIMStringConversionFeedback *feedback ;
   int encoding_is_wchar ;
   union __anonunion_string_101 string ;
};
#line 1303 "/usr/include/X11/Xlib.h"
typedef struct _XIMStringConversionText XIMStringConversionText;
#line 1313 "/usr/include/X11/Xlib.h"
typedef unsigned short XIMStringConversionPosition;
#line 1322 "/usr/include/X11/Xlib.h"
typedef unsigned short XIMStringConversionOperation;
#line 1327
enum __anonenum_XIMCaretDirection_102 {
    XIMForwardChar = 0,
    XIMBackwardChar = 1,
    XIMForwardWord = 2,
    XIMBackwardWord = 3,
    XIMCaretUp = 4,
    XIMCaretDown = 5,
    XIMNextLine = 6,
    XIMPreviousLine = 7,
    XIMLineStart = 8,
    XIMLineEnd = 9,
    XIMAbsolutePosition = 10,
    XIMDontChange = 11
} ;
#line 1327 "/usr/include/X11/Xlib.h"
typedef enum __anonenum_XIMCaretDirection_102 XIMCaretDirection;
#line 1337 "/usr/include/X11/Xlib.h"
struct _XIMStringConversionCallbackStruct {
   XIMStringConversionPosition position ;
   XIMCaretDirection direction ;
   XIMStringConversionOperation operation ;
   unsigned short factor ;
   XIMStringConversionText *text ;
};
#line 1337 "/usr/include/X11/Xlib.h"
typedef struct _XIMStringConversionCallbackStruct XIMStringConversionCallbackStruct;
#line 1393 "/usr/include/X11/Xlib.h"
struct __anonstruct_XIMValuesList_106 {
   unsigned short count_values ;
   char **supported_values ;
};
#line 1393 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XIMValuesList_106 XIMValuesList;
#line 231 "/usr/include/X11/Xutil.h"
struct _XComposeStatus {
   XPointer compose_ptr ;
   int chars_matched ;
};
#line 231 "/usr/include/X11/Xutil.h"
typedef struct _XComposeStatus XComposeStatus;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 107 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 738 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
typedef struct termios ttymode_t;
#line 98 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/xdefaults.c"
struct __anonstruct_optList_108 {
   unsigned long flag ;
   char const   **dp ;
   char const   * const  kw ;
   char const   * const  opt ;
   char const   * const  arg ;
   char const   * const  desc ;
};
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int int32_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/utmpx.h"
struct __exit_status {
   short e_termination ;
   short e_exit ;
};
#line 55 "/usr/include/x86_64-linux-gnu/bits/utmpx.h"
struct __anonstruct_ut_tv_99 {
   __int32_t tv_sec ;
   __int32_t tv_usec ;
};
#line 55 "/usr/include/x86_64-linux-gnu/bits/utmpx.h"
struct utmpx {
   short ut_type ;
   __pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct __exit_status ut_exit ;
   __int32_t ut_session ;
   struct __anonstruct_ut_tv_99 ut_tv ;
   __int32_t ut_addr_v6[4] ;
   char __glibc_reserved[20] ;
};
#line 43 "/usr/include/utmpx.h"
struct utmp;
#line 50 "/usr/include/x86_64-linux-gnu/bits/utmp.h"
struct exit_status {
   short e_termination ;
   short e_exit ;
};
#line 58 "/usr/include/x86_64-linux-gnu/bits/utmp.h"
struct __anonstruct_ut_tv_100 {
   int32_t tv_sec ;
   int32_t tv_usec ;
};
#line 58 "/usr/include/x86_64-linux-gnu/bits/utmp.h"
struct utmp {
   short ut_type ;
   pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct exit_status ut_exit ;
   int32_t ut_session ;
   struct __anonstruct_ut_tv_100 ut_tv ;
   int32_t ut_addr_v6[4] ;
   char __glibc_reserved[20] ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) putenv)(char *__string ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 1406 "/usr/include/X11/Xlib.h"
extern XFontStruct *XLoadQueryFont(Display * , char const   * ) ;
#line 1495
extern Display *XOpenDisplay(char const   * ) ;
#line 1588
extern Cursor XCreateFontCursor(Display * , unsigned int  ) ;
#line 1596
extern GC XCreateGC(Display * , Drawable  , unsigned long  , XGCValues * ) ;
#line 1633
extern Window XCreateSimpleWindow(Display * , Window  , int  , int  , unsigned int  ,
                                  unsigned int  , unsigned int  , unsigned long  ,
                                  unsigned long  ) ;
#line 1827
extern char *XDisplayString(Display * ) ;
#line 1860
extern XErrorHandler XSetErrorHandler(int (*)(Display * , XErrorEvent * ) ) ;
#line 1970
extern int XAllocColor(Display * , Colormap  , XColor * ) ;
#line 2127
extern int XCheckTypedWindowEvent(Display * , Window  , int  , XEvent * ) ;
#line 2167
extern int XClearWindow(Display * , Window  ) ;
#line 2243
extern int XDefineCursor(Display * , Window  , Cursor  ) ;
#line 2465
extern int XFetchName(Display * , Window  , char ** ) ;
#line 2528
extern int XFree(void * ) ;
#line 2554
extern int XFreeFont(Display * , XFontStruct * ) ;
#line 2632
extern int XGetGeometry(Display * , Drawable  , Window * , int * , int * , unsigned int * ,
                        unsigned int * , unsigned int * , unsigned int * ) ;
#line 2644
extern int XGetIconName(Display * , Window  , char ** ) ;
#line 2818
extern int XMapWindow(Display * , Window  ) ;
#line 2837
extern int XMoveResizeWindow(Display * , Window  , int  , int  , unsigned int  , unsigned int  ) ;
#line 2862
extern int XParseColor(Display * , Colormap  , char const   * , XColor * ) ;
#line 2869
extern int XParseGeometry(char const   * , int * , int * , unsigned int * , unsigned int * ) ;
#line 2969
extern int XQueryColor(Display * , Colormap  , XColor * ) ;
#line 3072
extern int XRecolorCursor(Display * , Cursor  , XColor * , XColor * ) ;
#line 3111
extern int XResizeWindow(Display * , Window  , unsigned int  , unsigned int  ) ;
#line 3141
extern int XSelectInput(Display * , Window  , long  ) ;
#line 3227
extern int XSetFont(Display * , GC  , Font  ) ;
#line 3257
extern int XSetIconName(Display * , Window  , char const   * ) ;
#line 3345
extern int XSetWindowBackground(Display * , Window  , unsigned long  ) ;
#line 3407
extern int XStoreName(Display * , Window  , char const   * ) ;
#line 3421
extern int XSync(Display * , int  ) ;
#line 3446
extern int XTextWidth(XFontStruct * , char const   * , int  ) ;
#line 23 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/misc.h"
char const   *my_basename(char const   *str ) ;
#line 26
void print_error(char const   *fmt  , ...) ;
#line 80 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.h"
TermWin_t TermWin  ;
#line 104 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.h"
Display *Xdisplay  ;
#line 127
unsigned long Options ;
#line 129
char const   *display_name ;
#line 130
char const   *rs_name ;
#line 205 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.h"
char const   *rs_color[24]  ;
#line 207 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.h"
Pixel PixColors[27]  ;
#line 210 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.h"
char const   *rs_font[5]  ;
#line 215
char const   *rs_boldFont ;
#line 222
char const   *rs_cutchars ;
#line 227
void map_scrollBar(int map ) ;
#line 230
void xterm_seq(int op , char *str ) ;
#line 239
void change_font(int init , char const   *fontname ) ;
#line 243
void set_width(unsigned short width ) ;
#line 246
void resize_window(void) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 659 "/usr/include/X11/Xutil.h"
extern void XSetWMNormalHints(Display * , Window  , XSizeHints * ) ;
#line 665
extern void XSetWMProperties(Display * , Window  , XTextProperty * , XTextProperty * ,
                             char ** , int  , XSizeHints * , XWMHints * , XClassHint * ) ;
#line 29 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.h"
void init_command(char **argv ) ;
#line 46
void main_loop(void) ;
#line 49 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/debug.h"
void *my_malloc(size_t size ) ;
#line 60
void my_free(void *mem ) ;
#line 25 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/scrollbar.h"
scrollBar_t scrollBar ;
#line 30
int scrollbar_mapping(int map ) ;
#line 82 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.h"
unsigned int colorfgbg ;
#line 88
void scr_reset(void) ;
#line 91
void scr_poweron(void) ;
#line 164
void scr_touch(void) ;
#line 195
int scr_change_screen(int scrn ) ;
#line 245
void selection_clear(void) ;
#line 13 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/xdefaults.h"
char const   *rs_title ;
#line 14
char const   *rs_iconName ;
#line 15
char const   *rs_geometry ;
#line 16
char const   *rs_saveLines ;
#line 36
void extract_resources(Display *display , char const   *name ) ;
#line 40
void get_options(int argc , char **argv ) ;
#line 60 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.c"
unsigned long Options  =    1UL << 7;
#line 62 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.c"
char const   *display_name  =    (char const   *)((void *)0);
#line 63 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.c"
char const   *rs_name  =    (char const   *)((void *)0);
#line 66 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.c"
char const   *rs_boldFont  =    (char const   *)((void *)0);
#line 77 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.c"
char const   *rs_cutchars  =    (char const   *)((void *)0);
#line 81 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.c"
static Cursor TermWin_cursor  ;
#line 83 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.c"
static XSizeHints szHint  = 
#line 83
     {(((1L << 4) | (1L << 6)) | (1L << 8)) | (1L << 9), 0, 0, 80, 24, 1, 1, 0, 0, 1,
    1, {1, 1}, {0, 0}, 0, 0, 1};
#line 96 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.c"
static char const   *def_colorName[24]  = 
#line 96
  {      "White",      "Black",      "Black",      "Red3", 
        "Green3",      "Yellow3",      "Blue3",      "Magenta3", 
        "Cyan3",      "AntiqueWhite",      "Grey25",      "Red", 
        "Green",      "Yellow",      "Blue",      "Magenta", 
        "Cyan",      "White",      (char const   *)((void *)0),      (char const   *)((void *)0), 
        (char const   *)((void *)0),      (char const   *)((void *)0),      (char const   *)((void *)0),      "#B2B2B2"};
#line 138 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.c"
static char const   *def_fontName[5]  = {      "7x14",      "6x10",      "6x13",      "8x13", 
        "9x15"};
#line 159
static void resize(void) ;
#line 163 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.c"
static XErrorHandler xerror_handler(Display *display , XErrorEvent *event ) 
{ 


  {
  {
#line 166
  exit(1);
  }
#line 167
  return ((XErrorHandler )0);
}
}
#line 171 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.c"
__inline static void color_aliases(int idx ) 
{ 
  int i ;
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 174
  if (rs_color[idx]) {
    {
#line 174
    tmp___0 = __ctype_b_loc();
    }
#line 174
    if ((int const   )*(*tmp___0 + (int )*(rs_color[idx])) & 2048) {
      {
#line 176
      tmp = atoi(rs_color[idx]);
#line 176
      i = tmp;
      }
#line 177
      if (i >= 8) {
#line 177
        if (i <= 15) {
#line 179
          i -= 8;
#line 181
          rs_color[idx] = rs_color[10 + i];
#line 182
          return;
        }
      }
#line 185
      if (i >= 0) {
#line 185
        if (i <= 7) {
#line 186
          rs_color[idx] = rs_color[2 + i];
        }
      }
    }
  }
#line 188
  return;
}
}
#line 198
__inline static void set_colorfgbg(void) ;
#line 198 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.c"
static char colorfgbg_env[29]  = 
#line 198
  {      (char )'C',      (char )'O',      (char )'L',      (char )'O', 
        (char )'R',      (char )'F',      (char )'G',      (char )'B', 
        (char )'G',      (char )'=',      (char )'d',      (char )'e', 
        (char )'f',      (char )'a',      (char )'u',      (char )'l', 
        (char )'t',      (char )';',      (char )'d',      (char )'e', 
        (char )'f',      (char )'a',      (char )'u',      (char )'l', 
        (char )'t',      (char )';',      (char )'b',      (char )'g', 
        (char )'\000'};
#line 194 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.c"
__inline static void set_colorfgbg(void) 
{ 
  unsigned int i ;
  char *p ;
  int fg ;
  int bg ;

  {
#line 200
  fg = -1;
#line 200
  bg = -1;
#line 202
  i = 2U;
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
#line 202
    if (! (i <= 17U)) {
#line 202
      goto while_break;
    }
#line 204
    if (PixColors[0] == PixColors[i]) {
#line 206
      fg = (int )(i - 2U);
#line 207
      goto while_break;
    }
#line 202
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 210
  i = 2U;
  {
#line 210
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 210
    if (! (i <= 17U)) {
#line 210
      goto while_break___0;
    }
#line 212
    if (PixColors[1] == PixColors[i]) {
#line 214
      bg = (int )(i - 2U);
#line 215
      goto while_break___0;
    }
#line 210
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 219
  p = strchr((char const   *)(colorfgbg_env), '=');
#line 220
  p ++;
  }
#line 221
  if (fg >= 0) {
    {
#line 222
    sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%d;", fg);
    }
  } else {
    {
#line 224
    strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)"default;");
    }
  }
  {
#line 225
  p = strchr((char const   *)p, '\000');
  }
#line 226
  if (bg >= 0) {
    {
#line 227
    sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%d", bg);
    }
  } else {
    {
#line 233
    strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)"default");
    }
  }
  {
#line 234
  putenv(colorfgbg_env);
#line 236
  colorfgbg = (unsigned int )(1 << 16);
#line 237
  i = 2U;
  }
  {
#line 237
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 237
    if (! (i <= 9U)) {
#line 237
      goto while_break___1;
    }
#line 239
    if (PixColors[0] == PixColors[i]) {
#line 239
      if (PixColors[0] == PixColors[21]) {
#line 248
        colorfgbg = (colorfgbg & 4294959359U) | (i << 8);
      }
    }
#line 249
    if (PixColors[1] == PixColors[i]) {
#line 250
      colorfgbg = (colorfgbg & 4292935679U) | (i << 16);
    }
#line 237
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 252
  return;
}
}
#line 644 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.c"
static void Create_Windows(int argc , char **argv ) 
{ 
  Cursor cursor ;
  XClassHint classHint ;
  XWMHints wmHint ;
  int i ;
  int x ;
  int y ;
  int flags ;
  unsigned int width ;
  unsigned int height ;
  char const   *msg ;
  XColor xcol ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  XColor xcol___0 ;
  XColor white ;
  int tmp___4 ;
  XColor xscroll ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  XColor fg ;
  XColor bg ;
  XGCValues gcvalue ;

  {
#line 656
  i = 0;
  {
#line 656
  while (1) {
    while_continue: /* CIL Label */ ;
#line 656
    if ((((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root_depth <= 2) {
#line 656
      tmp___3 = 2;
    } else {
#line 656
      tmp___3 = 24;
    }
#line 656
    if (! (i < tmp___3)) {
#line 656
      goto while_break;
    }
#line 660
    msg = "can\'t load color \"%s\"";
#line 663
    if (! rs_color[i]) {
#line 664
      goto __Cont;
    }
    {
#line 666
    tmp___1 = XParseColor(Xdisplay, (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->cmap,
                          rs_color[i], & xcol);
    }
#line 666
    if (tmp___1) {
      {
#line 666
      tmp___2 = XAllocColor(Xdisplay, (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->cmap,
                            & xcol);
      }
#line 666
      if (! tmp___2) {
        _L___0: /* CIL Label */ 
        {
#line 669
        print_error(msg, rs_color[i]);
#line 670
        rs_color[i] = def_colorName[i];
        }
#line 671
        if (! rs_color[i]) {
#line 672
          goto __Cont;
        }
        {
#line 673
        tmp = XParseColor(Xdisplay, (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->cmap,
                          rs_color[i], & xcol);
        }
#line 673
        if (tmp) {
          {
#line 673
          tmp___0 = XAllocColor(Xdisplay, (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->cmap,
                                & xcol);
          }
#line 673
          if (! tmp___0) {
            _L: /* CIL Label */ 
            {
#line 676
            print_error(msg, rs_color[i]);
            }
            {
#line 680
            if (i == 1) {
#line 680
              goto case_1;
            }
#line 680
            if (i == 0) {
#line 680
              goto case_1;
            }
#line 686
            if (i == 18) {
#line 686
              goto case_18;
            }
#line 689
            if (i == 19) {
#line 689
              goto case_19;
            }
#line 693
            if (i == 20) {
#line 693
              goto case_20;
            }
#line 698
            goto switch_default;
            case_1: /* CIL Label */ 
            case_0: /* CIL Label */ 
            {
#line 682
            print_error("aborting");
#line 683
            exit(1);
            }
#line 684
            goto switch_break;
            case_18: /* CIL Label */ 
#line 687
            xcol.pixel = PixColors[1];
#line 688
            goto switch_break;
            case_19: /* CIL Label */ 
#line 690
            xcol.pixel = PixColors[0];
#line 691
            goto switch_break;
            case_20: /* CIL Label */ 
#line 694
            xcol.pixel = PixColors[1];
#line 695
            goto switch_break;
            switch_default: /* CIL Label */ 
#line 699
            xcol.pixel = PixColors[1];
#line 700
            goto switch_break;
            switch_break: /* CIL Label */ ;
            }
          }
        } else {
#line 673
          goto _L;
        }
      }
    } else {
#line 666
      goto _L___0;
    }
#line 704
    PixColors[i] = xcol.pixel;
    __Cont: /* CIL Label */ 
#line 656
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 708
  if ((((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root_depth <= 2) {
#line 709
    PixColors[18] = PixColors[1];
  } else
#line 708
  if (! rs_color[18]) {
#line 709
    PixColors[18] = PixColors[1];
  }
#line 710
  if ((((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root_depth <= 2) {
#line 711
    PixColors[19] = PixColors[0];
  } else
#line 710
  if (! rs_color[19]) {
#line 711
    PixColors[19] = PixColors[0];
  }
#line 713
  if ((((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root_depth <= 2) {
#line 714
    PixColors[20] = PixColors[1];
  } else
#line 713
  if (! rs_color[20]) {
#line 714
    PixColors[20] = PixColors[1];
  }
#line 719
  if ((((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root_depth <= 2) {
#line 720
    PixColors[21] = PixColors[0];
  } else
#line 719
  if (! rs_color[21]) {
#line 720
    PixColors[21] = PixColors[0];
  }
#line 721
  if ((((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root_depth <= 2) {
#line 722
    PixColors[22] = PixColors[0];
  } else
#line 721
  if (! rs_color[22]) {
#line 722
    PixColors[22] = PixColors[0];
  }
#line 732
  if ((((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root_depth <= 2) {
#line 734
    PixColors[23] = PixColors[1];
#line 735
    PixColors[24] = PixColors[0];
#line 736
    PixColors[25] = PixColors[0];
  } else {
    {
#line 743
    xcol___0.pixel = PixColors[23];
#line 744
    XQueryColor(Xdisplay, (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->cmap,
                & xcol___0);
#line 746
    xcol___0.red = (unsigned short )((int )xcol___0.red / 2);
#line 747
    xcol___0.green = (unsigned short )((int )xcol___0.green / 2);
#line 748
    xcol___0.blue = (unsigned short )((int )xcol___0.blue / 2);
#line 750
    tmp___4 = XAllocColor(Xdisplay, (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->cmap,
                          & xcol___0);
    }
#line 750
    if (! tmp___4) {
      {
#line 752
      print_error("can\'t allocate %s", "bottomShadowColor");
#line 753
      xcol___0.pixel = PixColors[2];
      }
    }
    {
#line 755
    PixColors[25] = xcol___0.pixel;
#line 760
    xscroll.pixel = PixColors[23];
#line 761
    XQueryColor(Xdisplay, (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->cmap,
                & xscroll);
#line 764
    xcol___0.red = (unsigned short )(((int )xcol___0.red + (int )xscroll.red) / 2);
#line 765
    xcol___0.green = (unsigned short )(((int )xcol___0.green + (int )xscroll.green) / 2);
#line 766
    xcol___0.blue = (unsigned short )(((int )xcol___0.blue + (int )xscroll.blue) / 2);
#line 768
    tmp___5 = XAllocColor(Xdisplay, (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->cmap,
                          & xcol___0);
    }
#line 768
    if (! tmp___5) {
      {
#line 770
      print_error("can\'t allocate %s", "scrollBGColor");
#line 771
      xcol___0.pixel = PixColors[2];
      }
    }
    {
#line 773
    PixColors[26] = xcol___0.pixel;
#line 777
    white.pixel = (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->white_pixel;
#line 778
    XQueryColor(Xdisplay, (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->cmap,
                & white);
#line 780
    xcol___0.pixel = PixColors[23];
#line 781
    XQueryColor(Xdisplay, (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->cmap,
                & xcol___0);
    }
#line 787
    if ((int )white.red / 5 > (int )xcol___0.red) {
#line 787
      xcol___0.red = (unsigned short )((int )white.red / 5);
    } else {
#line 787
      xcol___0.red = xcol___0.red;
    }
#line 788
    if ((int )white.green / 5 > (int )xcol___0.green) {
#line 788
      xcol___0.green = (unsigned short )((int )white.green / 5);
    } else {
#line 788
      xcol___0.green = xcol___0.green;
    }
#line 789
    if ((int )white.blue / 5 > (int )xcol___0.blue) {
#line 789
      xcol___0.blue = (unsigned short )((int )white.blue / 5);
    } else {
#line 789
      xcol___0.blue = xcol___0.blue;
    }
#line 791
    if ((int )white.red < ((int )xcol___0.red * 7) / 5) {
#line 791
      xcol___0.red = white.red;
    } else {
#line 791
      xcol___0.red = (unsigned short )(((int )xcol___0.red * 7) / 5);
    }
#line 792
    if ((int )white.green < ((int )xcol___0.green * 7) / 5) {
#line 792
      xcol___0.green = white.green;
    } else {
#line 792
      xcol___0.green = (unsigned short )(((int )xcol___0.green * 7) / 5);
    }
#line 793
    if ((int )white.blue < ((int )xcol___0.blue * 7) / 5) {
#line 793
      xcol___0.blue = white.blue;
    } else {
#line 793
      xcol___0.blue = (unsigned short )(((int )xcol___0.blue * 7) / 5);
    }
    {
#line 795
    tmp___6 = XAllocColor(Xdisplay, (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->cmap,
                          & xcol___0);
    }
#line 795
    if (! tmp___6) {
      {
#line 797
      print_error("can\'t allocate %s", "topShadowColor");
#line 798
      xcol___0.pixel = PixColors[17];
      }
    }
#line 800
    PixColors[24] = xcol___0.pixel;
  }
#line 804
  if (Options & (1UL << 7)) {
#line 804
    tmp___7 = 10;
  } else {
#line 804
    tmp___7 = 0;
  }
#line 804
  szHint.base_width = 4 + tmp___7;
#line 806
  szHint.base_height = 4;
#line 808
  if (rs_geometry) {
    {
#line 808
    tmp___8 = XParseGeometry(rs_geometry, & x, & y, & width, & height);
#line 808
    flags = tmp___8;
    }
  } else {
#line 808
    flags = 0;
  }
#line 811
  if (flags & 4) {
#line 813
    szHint.width = (int )width;
#line 814
    szHint.flags |= 1L << 1;
  }
#line 816
  if (flags & 8) {
#line 818
    szHint.height = (int )height;
#line 819
    szHint.flags |= 1L << 1;
  }
  {
#line 822
  TermWin.ncol = (short )szHint.width;
#line 823
  TermWin.nrow = (short )szHint.height;
#line 825
  change_font(1, (char const   *)((void *)0));
  }
#line 827
  if (flags & 1) {
#line 829
    if (flags & 16) {
#line 831
      x += (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->width - (szHint.width + 2);
#line 833
      szHint.win_gravity = 3;
    }
#line 835
    szHint.x = x;
#line 836
    szHint.flags |= 1L;
  }
#line 838
  if (flags & 2) {
#line 840
    if (flags & 32) {
#line 842
      y += (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->height - (szHint.height + 2);
#line 844
      if (szHint.win_gravity == 3) {
#line 844
        szHint.win_gravity = 9;
      } else {
#line 844
        szHint.win_gravity = 7;
      }
    }
#line 847
    szHint.y = y;
#line 848
    szHint.flags |= 1L;
  }
  {
#line 855
  TermWin.parent = XCreateSimpleWindow(Xdisplay, (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root,
                                       szHint.x, szHint.y, (unsigned int )szHint.width,
                                       (unsigned int )szHint.height, 1U, PixColors[1],
                                       PixColors[0]);
#line 862
  xterm_seq(2, (char *)rs_title);
#line 863
  xterm_seq(1, (char *)rs_iconName);
#line 865
  classHint.res_name = (char *)rs_name;
#line 866
  classHint.res_class = (char *)"XTerm";
#line 867
  wmHint.input = 1;
  }
#line 868
  if (Options & (1UL << 2)) {
#line 868
    wmHint.initial_state = 3;
  } else {
#line 868
    wmHint.initial_state = 1;
  }
  {
#line 869
  wmHint.flags = 1L | (1L << 1);
#line 871
  XSetWMProperties(Xdisplay, TermWin.parent, (XTextProperty *)((void *)0), (XTextProperty *)((void *)0),
                   argv, argc, & szHint, & wmHint, & classHint);
#line 874
  XSelectInput(Xdisplay, TermWin.parent, ((1L | (1L << 21)) | (1L << 17)) | (1L << 16));
#line 880
  TermWin_cursor = XCreateFontCursor(Xdisplay, 152U);
#line 883
  fg.pixel = PixColors[0];
#line 884
  XQueryColor(Xdisplay, (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->cmap,
              & fg);
#line 885
  bg.pixel = PixColors[1];
#line 886
  XQueryColor(Xdisplay, (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->cmap,
              & bg);
#line 887
  XRecolorCursor(Xdisplay, TermWin_cursor, & fg, & bg);
#line 891
  cursor = XCreateFontCursor(Xdisplay, 68U);
#line 894
  TermWin.vt = XCreateSimpleWindow(Xdisplay, TermWin.parent, 0, 0, (unsigned int )szHint.width,
                                   (unsigned int )szHint.height, 0U, PixColors[0],
                                   PixColors[1]);
#line 901
  XDefineCursor(Xdisplay, TermWin.vt, TermWin_cursor);
#line 902
  XSelectInput(Xdisplay, TermWin.vt, ((((1L << 15) | (1L << 2)) | (1L << 3)) | (1L << 8)) | (1L << 10));
#line 906
  XMapWindow(Xdisplay, TermWin.vt);
#line 907
  XMapWindow(Xdisplay, TermWin.parent);
#line 910
  scrollBar.win = XCreateSimpleWindow(Xdisplay, TermWin.parent, 0, 0, 1U, 1U, 0U,
                                      PixColors[0], PixColors[26]);
#line 924
  XDefineCursor(Xdisplay, scrollBar.win, cursor);
#line 925
  XSelectInput(Xdisplay, scrollBar.win, (((((1L << 15) | (1L << 2)) | (1L << 3)) | (1L << 8)) | (1L << 9)) | (1L << 10));
#line 947
  gcvalue.font = (TermWin.font)->fid;
#line 948
  gcvalue.foreground = PixColors[0];
#line 949
  gcvalue.background = PixColors[1];
#line 950
  TermWin.gc = XCreateGC(Xdisplay, TermWin.vt, (unsigned long )(((1L << 2) | (1L << 3)) | (1L << 14)),
                         & gcvalue);
  }
#line 954
  return;
}
}
#line 957 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.c"
static void resize_subwindows(int width , int height ) 
{ 
  int x ;
  int y ;
  int old_width ;
  int old_height  __attribute__((__unused__)) ;

  {
#line 960
  x = 0;
#line 960
  y = 0;
#line 961
  old_width = (int )TermWin.width;
#line 966
  old_height = (int )TermWin.height;
#line 971
  TermWin.width = (short )((int )TermWin.ncol * (int )TermWin.fwidth);
#line 972
  TermWin.height = (short )((int )TermWin.nrow * (int )TermWin.fheight);
#line 975
  if (scrollBar.state) {
    {
#line 977
    scrollBar.beg = (short)0;
#line 978
    scrollBar.end = (short )height;
#line 981
    scrollBar.beg = (short )((int )scrollBar.beg + 11);
#line 982
    scrollBar.end = (short )((int )scrollBar.end - 11);
#line 985
    width -= 10;
#line 986
    XMoveResizeWindow(Xdisplay, scrollBar.win, width, 0, 10U, (unsigned int )height);
    }
  }
  {
#line 999
  XMoveResizeWindow(Xdisplay, TermWin.vt, x, y, (unsigned int )width, (unsigned int )(height + 1));
#line 1005
  XClearWindow(Xdisplay, TermWin.vt);
#line 1007
  XSync(Xdisplay, 0);
  }
#line 1008
  return;
}
}
#line 1010 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.c"
static void resize(void) 
{ 
  int tmp ;

  {
#line 1013
  szHint.base_width = 4;
#line 1014
  szHint.base_height = 4;
#line 1016
  if (scrollBar.state) {
#line 1016
    tmp = 10;
  } else {
#line 1016
    tmp = 0;
  }
  {
#line 1016
  szHint.base_width += tmp;
#line 1018
  szHint.min_width = szHint.base_width + szHint.width_inc;
#line 1019
  szHint.min_height = szHint.base_height + szHint.height_inc;
#line 1021
  szHint.width = szHint.base_width + (int )TermWin.width;
#line 1022
  szHint.height = szHint.base_height + (int )TermWin.height;
#line 1024
  szHint.flags = (((1L << 4) | (1L << 6)) | (1L << 8)) | (1L << 9);
#line 1026
  XSetWMNormalHints(Xdisplay, TermWin.parent, & szHint);
#line 1027
  XResizeWindow(Xdisplay, TermWin.parent, (unsigned int )szHint.width, (unsigned int )szHint.height);
#line 1029
  resize_subwindows(szHint.width, szHint.height);
  }
#line 1030
  return;
}
}
#line 1032 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.c"
void map_scrollBar(int map ) 
{ 
  int tmp ;

  {
  {
#line 1035
  tmp = scrollbar_mapping(map);
  }
#line 1035
  if (tmp) {
    {
#line 1037
    scr_touch();
#line 1038
    resize();
    }
  }
#line 1040
  return;
}
}
#line 1048
static void resize_window1(unsigned int width , unsigned int height ) ;
#line 1048 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.c"
static short first_time  =    (short)1;
#line 1045 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.c"
static void resize_window1(unsigned int width , unsigned int height ) 
{ 
  int new_ncol ;
  int new_nrow ;
  int curr_screen ;

  {
#line 1049
  new_ncol = (int )((width - (unsigned int )szHint.base_width) / (unsigned int )TermWin.fwidth);
#line 1050
  new_nrow = (int )((height - (unsigned int )szHint.base_height) / (unsigned int )TermWin.fheight);
#line 1052
  if (first_time) {
#line 1052
    goto _L;
  } else
#line 1052
  if (new_ncol != (int )TermWin.ncol) {
#line 1052
    goto _L;
  } else
#line 1052
  if (new_nrow != (int )TermWin.nrow) {
    _L: /* CIL Label */ 
#line 1056
    curr_screen = -1;
#line 1059
    if (! first_time) {
      {
#line 1061
      selection_clear();
#line 1062
      curr_screen = scr_change_screen(0);
      }
    }
    {
#line 1065
    TermWin.ncol = (short )new_ncol;
#line 1066
    TermWin.nrow = (short )new_nrow;
#line 1068
    resize_subwindows((int )width, (int )height);
#line 1069
    scr_reset();
    }
#line 1071
    if (curr_screen >= 0) {
      {
#line 1072
      scr_change_screen(curr_screen);
      }
    }
#line 1073
    first_time = (short)0;
  }
#line 1075
  return;
}
}
#line 1080 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.c"
void set_width(unsigned short width ) 
{ 
  unsigned short height ;

  {
#line 1083
  height = (unsigned short )TermWin.nrow;
#line 1085
  if ((int )width != (int )TermWin.ncol) {
    {
#line 1087
    width = (unsigned short )(szHint.base_width + (int )width * (int )TermWin.fwidth);
#line 1088
    height = (unsigned short )(szHint.base_height + (int )height * (int )TermWin.fheight);
#line 1090
    XResizeWindow(Xdisplay, TermWin.parent, (unsigned int )width, (unsigned int )height);
#line 1091
    resize_window1((unsigned int )width, (unsigned int )height);
    }
  }
#line 1093
  return;
}
}
#line 1098 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.c"
void resize_window(void) 
{ 
  Window root ;
  XEvent dummy ;
  int x ;
  int y ;
  unsigned int border ;
  unsigned int depth ;
  unsigned int width ;
  unsigned int height ;
  int tmp ;

  {
  {
#line 1106
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1106
    tmp = XCheckTypedWindowEvent(Xdisplay, TermWin.parent, 22, & dummy);
    }
#line 1106
    if (! tmp) {
#line 1106
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1108
  XGetGeometry(Xdisplay, TermWin.parent, & root, & x, & y, & width, & height, & border,
               & depth);
#line 1112
  resize_window1(width, height);
  }
#line 1113
  return;
}
}
#line 1117 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.c"
static void set_title(char const   *str ) 
{ 
  char *name ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1121
  tmp = XFetchName(Xdisplay, TermWin.parent, & name);
  }
#line 1121
  if (tmp) {
#line 1122
    name = (char *)((void *)0);
  }
#line 1123
  if ((unsigned long )name == (unsigned long )((void *)0)) {
    {
#line 1124
    XStoreName(Xdisplay, TermWin.parent, str);
    }
  } else {
    {
#line 1123
    tmp___0 = strcmp((char const   *)name, str);
    }
#line 1123
    if (tmp___0) {
      {
#line 1124
      XStoreName(Xdisplay, TermWin.parent, str);
      }
    }
  }
#line 1125
  if (name) {
    {
#line 1126
    XFree((void *)name);
    }
  }
#line 1127
  return;
}
}
#line 1133 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.c"
static void set_iconName(char const   *str ) 
{ 
  char *name ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1137
  tmp = XGetIconName(Xdisplay, TermWin.parent, & name);
  }
#line 1137
  if (tmp) {
#line 1138
    name = (char *)((void *)0);
  }
#line 1139
  if ((unsigned long )name == (unsigned long )((void *)0)) {
    {
#line 1140
    XSetIconName(Xdisplay, TermWin.parent, str);
    }
  } else {
    {
#line 1139
    tmp___0 = strcmp((char const   *)name, str);
    }
#line 1139
    if (tmp___0) {
      {
#line 1140
      XSetIconName(Xdisplay, TermWin.parent, str);
      }
    }
  }
#line 1141
  if (name) {
    {
#line 1142
    XFree((void *)name);
    }
  }
#line 1143
  return;
}
}
#line 1149 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.c"
static void set_window_color(int idx , char const   *color ) 
{ 
  char const   *msg ;
  XColor xcol ;
  int i ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  XColor fg ;
  XColor bg ;

  {
#line 1152
  msg = "can\'t load color \"%s\"";
#line 1156
  if ((unsigned long )color == (unsigned long )((void *)0)) {
#line 1157
    return;
  } else
#line 1156
  if ((int const   )*color == 0) {
#line 1157
    return;
  }
  {
#line 1160
  tmp = __ctype_b_loc();
  }
#line 1160
  if ((int const   )*(*tmp + (int )*color) & 2048) {
    {
#line 1162
    i = atoi(color);
    }
#line 1163
    if (i >= 8) {
#line 1163
      if (i <= 15) {
#line 1165
        i -= 8;
#line 1167
        PixColors[idx] = PixColors[10 + i];
#line 1168
        goto Done;
      }
    }
#line 1171
    if (i >= 0) {
#line 1171
      if (i <= 7) {
#line 1173
        PixColors[idx] = PixColors[2 + i];
#line 1174
        goto Done;
      }
    }
  }
  {
#line 1178
  tmp___0 = XParseColor(Xdisplay, (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->cmap,
                        color, & xcol);
  }
#line 1178
  if (tmp___0) {
    {
#line 1178
    tmp___1 = XAllocColor(Xdisplay, (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->cmap,
                          & xcol);
    }
#line 1178
    if (! tmp___1) {
      {
#line 1181
      print_error(msg, color);
      }
#line 1182
      return;
    }
  } else {
    {
#line 1181
    print_error(msg, color);
    }
#line 1182
    return;
  }
#line 1203
  PixColors[idx] = xcol.pixel;
  Done: 
#line 1208
  if (idx == 1) {
    {
#line 1209
    XSetWindowBackground(Xdisplay, TermWin.vt, PixColors[1]);
    }
  }
  {
#line 1213
  set_colorfgbg();
#line 1216
  fg.pixel = PixColors[0];
#line 1217
  XQueryColor(Xdisplay, (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->cmap,
              & fg);
#line 1218
  bg.pixel = PixColors[1];
#line 1219
  XQueryColor(Xdisplay, (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->cmap,
              & bg);
#line 1220
  XRecolorCursor(Xdisplay, TermWin_cursor, & fg, & bg);
#line 1223
  scr_poweron();
  }
#line 1224
  return;
}
}
#line 1368 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.c"
void xterm_seq(int op , char *str ) 
{ 
  int changed ;

  {
#line 1371
  changed = 0;
#line 1373
  if (! ((unsigned long )str != (unsigned long )((void *)0))) {
    {
#line 1373
    __assert_fail("str != ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.c",
                  1373U, "xterm_seq");
    }
  }
  {
#line 1376
  if (op == 0) {
#line 1376
    goto case_0;
  }
#line 1378
  if (op == 1) {
#line 1378
    goto case_1;
  }
#line 1381
  if (op == 2) {
#line 1381
    goto case_2;
  }
#line 1392
  if (op == 20) {
#line 1392
    goto case_20;
  }
#line 1410
  if (op == 39) {
#line 1410
    goto case_39;
  }
#line 1413
  if (op == 49) {
#line 1413
    goto case_49;
  }
#line 1416
  if (op == 46) {
#line 1416
    goto case_46;
  }
#line 1418
  if (op == 50) {
#line 1418
    goto case_50;
  }
#line 1374
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1377
  set_title((char const   *)str);
  }
  case_1: /* CIL Label */ 
  {
#line 1379
  set_iconName((char const   *)str);
  }
#line 1380
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1384
  set_title("X Terminal International (THAI) 1.10");
  }
#line 1391
  goto switch_break;
  case_20: /* CIL Label */ 
#line 1408
  goto switch_break;
  case_39: /* CIL Label */ 
  {
#line 1411
  set_window_color(0, (char const   *)str);
  }
#line 1412
  goto switch_break;
  case_49: /* CIL Label */ 
  {
#line 1414
  set_window_color(1, (char const   *)str);
  }
#line 1415
  goto switch_break;
  case_46: /* CIL Label */ 
#line 1417
  goto switch_break;
  case_50: /* CIL Label */ 
  {
#line 1419
  change_font(0, (char const   *)str);
  }
#line 1420
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1422
  return;
}
}
#line 1437 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.c"
static char *newfont[5]  ;
#line 1439 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.c"
static XFontStruct *boldFont  =    (XFontStruct *)((void *)0);
#line 1441 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.c"
static int fnum  =    2;
#line 1432 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.c"
void change_font(int init , char const   *fontname ) 
{ 
  char const   *msg ;
  XFontStruct *xfont ;
  int idx ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *name ;
  size_t tmp___8 ;
  void *tmp___9 ;
  int fw ;
  int tmp___10 ;
  int fh ;
  int tmp___11 ;

  {
#line 1435
  msg = "can\'t load font \"%s\"";
#line 1442
  idx = 0;
#line 1453
  if (! init) {
    {
#line 1457
    if ((int const   )*(fontname + 0) == 0) {
#line 1457
      goto case_0;
    }
#line 1463
    if ((int const   )*(fontname + 0) == 35) {
#line 1463
      goto case_35;
    }
#line 1488
    goto switch_default___0;
    case_0: /* CIL Label */ 
#line 1458
    fnum = 2;
#line 1459
    fontname = (char const   *)((void *)0);
#line 1460
    goto switch_break;
    case_35: /* CIL Label */ 
    {
#line 1464
    idx = atoi(fontname + 1);
    }
    {
#line 1467
    if ((int const   )*(fontname + 1) == 43) {
#line 1467
      goto case_43;
    }
#line 1472
    if ((int const   )*(fontname + 1) == 45) {
#line 1472
      goto case_45;
    }
#line 1477
    goto switch_default;
    case_43: /* CIL Label */ 
#line 1468
    if (idx) {
#line 1468
      tmp = idx;
    } else {
#line 1468
      tmp = 1;
    }
#line 1468
    fnum += tmp;
#line 1469
    if (fnum <= 0) {
#line 1469
      fnum = 0;
    } else {
#line 1469
      if (fnum >= 5) {
#line 1469
        tmp___0 = 4;
      } else {
#line 1469
        tmp___0 = fnum;
      }
#line 1469
      fnum = tmp___0;
    }
#line 1470
    goto switch_break___0;
    case_45: /* CIL Label */ 
#line 1473
    if (idx) {
#line 1473
      tmp___1 = idx;
    } else {
#line 1473
      tmp___1 = -1;
    }
#line 1473
    fnum += tmp___1;
#line 1474
    if (fnum <= 0) {
#line 1474
      fnum = 0;
    } else {
#line 1474
      if (fnum >= 5) {
#line 1474
        tmp___2 = 4;
      } else {
#line 1474
        tmp___2 = fnum;
      }
#line 1474
      fnum = tmp___2;
    }
#line 1475
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 1478
    if ((int const   )*(fontname + 1) != 0) {
      {
#line 1478
      tmp___3 = __ctype_b_loc();
      }
#line 1478
      if (! ((int const   )*(*tmp___3 + (int )*(fontname + 1)) & 2048)) {
#line 1479
        return;
      }
    }
#line 1480
    if (idx < 0) {
#line 1481
      return;
    } else
#line 1480
    if (idx >= 5) {
#line 1481
      return;
    }
#line 1482
    if (idx == 0) {
#line 1482
      fnum = 2;
    } else {
#line 1482
      if (idx <= 2) {
#line 1482
        tmp___4 = idx - 1;
      } else {
#line 1482
        tmp___4 = idx;
      }
#line 1482
      fnum = tmp___4;
    }
#line 1483
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 1485
    fontname = (char const   *)((void *)0);
#line 1486
    goto switch_break;
    switch_default___0: /* CIL Label */ 
#line 1489
    if ((unsigned long )fontname != (unsigned long )((void *)0)) {
#line 1492
      idx = 0;
      {
#line 1492
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1492
        if (! (idx < 5)) {
#line 1492
          goto while_break;
        }
        {
#line 1494
        tmp___6 = strcmp(rs_font[idx], fontname);
        }
#line 1494
        if (! tmp___6) {
#line 1496
          if (idx == 0) {
#line 1496
            fnum = 2;
          } else {
#line 1496
            if (idx <= 2) {
#line 1496
              tmp___5 = idx - 1;
            } else {
#line 1496
              tmp___5 = idx;
            }
#line 1496
            fnum = tmp___5;
          }
#line 1497
          fontname = (char const   *)((void *)0);
#line 1498
          goto while_break;
        }
#line 1492
        idx ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 1503
      return;
    }
#line 1504
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1507
    if (fnum == 2) {
#line 1507
      idx = 0;
    } else {
#line 1507
      if (fnum < 2) {
#line 1507
        tmp___7 = fnum + 1;
      } else {
#line 1507
        tmp___7 = fnum;
      }
#line 1507
      idx = tmp___7;
    }
#line 1509
    if ((unsigned long )fontname != (unsigned long )((void *)0)) {
      {
#line 1512
      xfont = XLoadQueryFont(Xdisplay, fontname);
      }
#line 1513
      if (! xfont) {
#line 1514
        return;
      }
      {
#line 1516
      tmp___8 = strlen(fontname + 1);
#line 1516
      tmp___9 = my_malloc(tmp___8 * sizeof(char ));
#line 1516
      name = (char *)tmp___9;
      }
#line 1518
      if ((unsigned long )name == (unsigned long )((void *)0)) {
        {
#line 1520
        XFreeFont(Xdisplay, xfont);
        }
#line 1521
        return;
      }
      {
#line 1524
      strcpy((char */* __restrict  */)name, (char const   */* __restrict  */)fontname);
      }
#line 1525
      if ((unsigned long )newfont[idx] != (unsigned long )((void *)0)) {
        {
#line 1526
        my_free((void *)newfont[idx]);
        }
      }
#line 1527
      newfont[idx] = name;
#line 1528
      rs_font[idx] = (char const   *)newfont[idx];
    }
  }
#line 1532
  if (TermWin.font) {
    {
#line 1533
    XFreeFont(Xdisplay, TermWin.font);
    }
  }
  {
#line 1536
  xfont = XLoadQueryFont(Xdisplay, rs_font[idx]);
  }
#line 1537
  if (! xfont) {
    {
#line 1539
    print_error(msg, rs_font[idx]);
#line 1540
    rs_font[idx] = "fixed";
#line 1541
    xfont = XLoadQueryFont(Xdisplay, rs_font[idx]);
    }
#line 1542
    if (! xfont) {
      {
#line 1544
      print_error(msg, rs_font[idx]);
      }
#line 1545
      goto Abort;
    }
  }
#line 1548
  TermWin.font = xfont;
#line 1552
  if (init) {
#line 1552
    if ((unsigned long )rs_boldFont != (unsigned long )((void *)0)) {
      {
#line 1553
      boldFont = XLoadQueryFont(Xdisplay, rs_boldFont);
      }
    }
  }
#line 1577
  if (! init) {
    {
#line 1579
    XSetFont(Xdisplay, TermWin.gc, (TermWin.font)->fid);
    }
  }
  {
#line 1584
  tmp___10 = XTextWidth(TermWin.font, "MMMMMMMMMM", 10);
#line 1584
  fw = tmp___10 / 10;
#line 1585
  fh = (TermWin.font)->ascent + (TermWin.font)->descent;
  }
#line 1588
  if (fw == (int )TermWin.fwidth) {
#line 1588
    if (fh == (int )TermWin.fheight) {
#line 1589
      return;
    }
  }
#line 1591
  TermWin.fwidth = (short )fw;
#line 1592
  TermWin.fheight = (short )fh;
#line 1597
  if ((unsigned long )boldFont != (unsigned long )((void *)0)) {
    {
#line 1597
    tmp___11 = XTextWidth(boldFont, "MMMMMMMMMM", 10);
    }
#line 1597
    if ((int )TermWin.fwidth == tmp___11 / 10) {
#line 1597
      if ((int )TermWin.fheight == boldFont->ascent + boldFont->descent) {
#line 1600
        TermWin.boldFont = boldFont;
      } else {
#line 1602
        TermWin.boldFont = (XFontStruct *)((void *)0);
      }
    } else {
#line 1602
      TermWin.boldFont = (XFontStruct *)((void *)0);
    }
  } else {
#line 1602
    TermWin.boldFont = (XFontStruct *)((void *)0);
  }
  {
#line 1605
  set_colorfgbg();
#line 1607
  TermWin.width = (short )((int )TermWin.ncol * (int )TermWin.fwidth);
#line 1608
  TermWin.height = (short )((int )TermWin.nrow * (int )TermWin.fheight);
#line 1610
  szHint.width_inc = (int )TermWin.fwidth;
#line 1611
  szHint.height_inc = (int )TermWin.fheight;
#line 1613
  szHint.min_width = szHint.base_width + szHint.width_inc;
#line 1614
  szHint.min_height = szHint.base_height + szHint.height_inc;
#line 1616
  szHint.width = szHint.base_width + (int )TermWin.width;
#line 1617
  szHint.height = szHint.base_height + (int )TermWin.height;
#line 1619
  szHint.flags = (((1L << 4) | (1L << 6)) | (1L << 8)) | (1L << 9);
  }
#line 1621
  if (! init) {
    {
#line 1622
    resize();
    }
  }
#line 1624
  return;
  Abort: 
  {
#line 1626
  print_error("aborting");
#line 1627
  exit(1);
  }
}
}
#line 1641 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.c"
static char windowid_string[20]  ;
#line 1641 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.c"
static char *display_string  ;
#line 1635 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/main.c"
int main(int argc , char **argv ) 
{ 
  int i ;
  char *val ;
  char **cmd_argv ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *name ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;

  {
#line 1639
  cmd_argv = (char **)((void *)0);
#line 1643
  i = 0;
  {
#line 1643
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1643
    if (! (i < argc)) {
#line 1643
      goto while_break;
    }
    {
#line 1645
    tmp = strcmp((char const   *)*(argv + i), "-e");
    }
#line 1645
    if (! tmp) {
#line 1647
      argc = i;
#line 1648
      *(argv + argc) = (char *)((void *)0);
#line 1649
      if ((unsigned long )*(argv + (argc + 1)) != (unsigned long )((void *)0)) {
#line 1651
        cmd_argv = (argv + argc) + 1;
#line 1652
        if ((unsigned long )*(cmd_argv + 0) != (unsigned long )((void *)0)) {
          {
#line 1653
          rs_title = my_basename((char const   *)*(cmd_argv + 0));
#line 1653
          rs_iconName = rs_title;
          }
        }
      }
#line 1655
      goto while_break;
    }
#line 1643
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1659
  rs_name = my_basename((char const   *)*(argv + 0));
#line 1664
  get_options(argc, argv);
  }
#line 1666
  if (! display_name) {
    {
#line 1666
    tmp___0 = getenv("DISPLAY");
#line 1666
    display_name = (char const   *)tmp___0;
    }
#line 1666
    if ((unsigned long )display_name == (unsigned long )((void *)0)) {
      {
#line 1668
      print_error("can\'t open display, DISPLAY is not set?\n");
#line 1669
      exit(1);
      }
    }
  }
  {
#line 1672
  Xdisplay = XOpenDisplay(display_name);
  }
#line 1673
  if (! Xdisplay) {
    {
#line 1675
    print_error("can\'t open display %s", display_name);
#line 1676
    exit(1);
    }
  }
  {
#line 1678
  extract_resources(Xdisplay, rs_name);
  }
#line 1683
  if (! rs_title) {
#line 1684
    rs_title = rs_name;
  }
#line 1685
  if (! rs_iconName) {
#line 1686
    rs_iconName = rs_name;
  }
#line 1687
  if (! rs_saveLines) {
#line 1688
    TermWin.saveLines = (short)64;
  } else {
    {
#line 1687
    tmp___1 = atoi(rs_saveLines);
#line 1687
    TermWin.saveLines = (short )tmp___1;
    }
#line 1687
    if ((int )TermWin.saveLines < 0) {
#line 1688
      TermWin.saveLines = (short)64;
    }
  }
#line 1691
  if (! TermWin.saveLines) {
#line 1692
    Options &= ~ (1UL << 7);
  }
#line 1698
  if (! rs_cutchars) {
#line 1699
    rs_cutchars = "\t \"&\'()*,;<=>?@[\\]^`{|}~";
  }
#line 1702
  if ((unsigned long )rs_font[0] == (unsigned long )((void *)0)) {
#line 1702
    if ((unsigned long )rs_boldFont != (unsigned long )((void *)0)) {
#line 1704
      rs_font[0] = rs_boldFont;
#line 1705
      rs_boldFont = (char const   *)((void *)0);
    }
  }
#line 1708
  i = 0;
  {
#line 1708
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1708
    if (! (i < 5)) {
#line 1708
      goto while_break___0;
    }
#line 1710
    if (! rs_font[i]) {
#line 1711
      rs_font[i] = def_fontName[i];
    }
#line 1708
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1729
  i = 0;
  {
#line 1729
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1729
    if (! (i < 24)) {
#line 1729
      goto while_break___1;
    }
#line 1730
    if (! rs_color[i]) {
#line 1731
      rs_color[i] = def_colorName[i];
    }
#line 1729
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1735
  if (Options & (1UL << 5)) {
#line 1740
    name = rs_color[0];
#line 1741
    rs_color[0] = rs_color[1];
#line 1742
    rs_color[1] = name;
#line 1744
    name = def_colorName[0];
#line 1745
    def_colorName[0] = def_colorName[1];
#line 1746
    def_colorName[1] = name;
  }
  {
#line 1751
  color_aliases(0);
#line 1752
  color_aliases(1);
#line 1754
  color_aliases(18);
#line 1755
  color_aliases(19);
#line 1758
  color_aliases(21);
#line 1759
  color_aliases(22);
#line 1762
  Create_Windows(argc, argv);
#line 1763
  scr_reset();
#line 1767
  scrollbar_mapping((int )(Options & (1UL << 7)));
#line 1773
  XSetErrorHandler((int (*)(Display * , XErrorEvent * ))(& xerror_handler));
#line 1790
  val = XDisplayString(Xdisplay);
  }
#line 1791
  if ((unsigned long )display_name == (unsigned long )((void *)0)) {
#line 1792
    display_name = (char const   *)val;
  }
  {
#line 1794
  tmp___2 = strlen((char const   *)val);
#line 1794
  i = (int )tmp___2;
#line 1795
  tmp___3 = my_malloc((unsigned long )(i + 9) * sizeof(char ));
#line 1795
  display_string = (char *)tmp___3;
#line 1797
  sprintf((char */* __restrict  */)display_string, (char const   */* __restrict  */)"DISPLAY=%s",
          val);
#line 1798
  sprintf((char */* __restrict  */)(windowid_string), (char const   */* __restrict  */)"WINDOWID=%u",
          (unsigned int )TermWin.parent);
#line 1806
  putenv(display_string);
#line 1807
  putenv(windowid_string);
  }
#line 1808
  if ((((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root_depth <= 2) {
    {
#line 1810
    putenv((char *)"COLORTERM=xiterm-mono");
#line 1811
    putenv((char *)"TERM=xterm");
    }
  } else {
    {
#line 1818
    putenv((char *)"COLORTERM=xiterm");
#line 1821
    putenv((char *)"TERM=xterm-color");
    }
  }
  {
#line 1827
  tmp___4 = setlocale(0, "");
  }
#line 1827
  if (! tmp___4) {
    {
#line 1827
    print_error("Cannot set locale");
    }
  }
  {
#line 1829
  init_command(cmd_argv);
#line 1830
  main_loop();
  }
#line 1831
  return (0);
}
}
#line 17 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/thaikb.h"
void thai_set_keyboard(int thai_kbmode ) ;
#line 18
char thai_map_qwerty(unsigned char c ) ;
#line 10 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/thaikb.c"
static char const   tis_qwerty_map[128]  = 
#line 10 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/thaikb.c"
  {      (char const   )0,      (char const   )1,      (char const   )2,      (char const   )3, 
        (char const   )4,      (char const   )5,      (char const   )6,      (char const   )7, 
        (char const   )8,      (char const   )9,      (char const   )10,      (char const   )11, 
        (char const   )12,      (char const   )13,      (char const   )14,      (char const   )15, 
        (char const   )16,      (char const   )17,      (char const   )18,      (char const   )19, 
        (char const   )20,      (char const   )21,      (char const   )22,      (char const   )23, 
        (char const   )24,      (char const   )25,      (char const   )26,      (char const   )27, 
        (char const   )28,      (char const   )29,      (char const   )30,      (char const   )31, 
        (char const   )32,      (char const   )229,      (char const   )46,      (char const   )242, 
        (char const   )243,      (char const   )244,      (char const   )238,      (char const   )167, 
        (char const   )246,      (char const   )247,      (char const   )245,      (char const   )249, 
        (char const   )193,      (char const   )162,      (char const   )227,      (char const   )189, 
        (char const   )168,      (char const   )223,      (char const   )47,      (char const   )45, 
        (char const   )192,      (char const   )182,      (char const   )216,      (char const   )214, 
        (char const   )164,      (char const   )181,      (char const   )171,      (char const   )199, 
        (char const   )178,      (char const   )170,      (char const   )204,      (char const   )198, 
        (char const   )241,      (char const   )196,      (char const   )218,      (char const   )169, 
        (char const   )175,      (char const   )174,      (char const   )226,      (char const   )172, 
        (char const   )231,      (char const   )179,      (char const   )235,      (char const   )201, 
        (char const   )200,      (char const   )63,      (char const   )236,      (char const   )207, 
        (char const   )173,      (char const   )240,      (char const   )177,      (char const   )166, 
        (char const   )184,      (char const   )234,      (char const   )206,      (char const   )34, 
        (char const   )41,      (char const   )237,      (char const   )40,      (char const   )186, 
        (char const   )163,      (char const   )197,      (char const   )217,      (char const   )248, 
        (char const   )239,      (char const   )191,      (char const   )212,      (char const   )225, 
        (char const   )161,      (char const   )211,      (char const   )180,      (char const   )224, 
        (char const   )233,      (char const   )195,      (char const   )232,      (char const   )210, 
        (char const   )202,      (char const   )183,      (char const   )215,      (char const   )185, 
        (char const   )194,      (char const   )230,      (char const   )190,      (char const   )203, 
        (char const   )208,      (char const   )213,      (char const   )205,      (char const   )228, 
        (char const   )187,      (char const   )209,      (char const   )188,      (char const   )176, 
        (char const   )165,      (char const   )44,      (char const   )251,      (char const   )127};
#line 30 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/thaikb.c"
static char const   ketmanee_qwerty_map[128]  = 
#line 30
  {      (char const   )0,      (char const   )1,      (char const   )2,      (char const   )3, 
        (char const   )4,      (char const   )5,      (char const   )6,      (char const   )7, 
        (char const   )8,      (char const   )9,      (char const   )10,      (char const   )11, 
        (char const   )12,      (char const   )13,      (char const   )14,      (char const   )15, 
        (char const   )16,      (char const   )17,      (char const   )18,      (char const   )19, 
        (char const   )20,      (char const   )21,      (char const   )22,      (char const   )23, 
        (char const   )24,      (char const   )25,      (char const   )26,      (char const   )27, 
        (char const   )28,      (char const   )29,      (char const   )30,      (char const   )31, 
        (char const   )32,      (char const   )43,      (char const   )46,      (char const   )242, 
        (char const   )243,      (char const   )244,      (char const   )223,      (char const   )167, 
        (char const   )246,      (char const   )247,      (char const   )245,      (char const   )249, 
        (char const   )193,      (char const   )162,      (char const   )227,      (char const   )189, 
        (char const   )168,      (char const   )229,      (char const   )47,      (char const   )45, 
        (char const   )192,      (char const   )182,      (char const   )216,      (char const   )214, 
        (char const   )164,      (char const   )181,      (char const   )171,      (char const   )199, 
        (char const   )178,      (char const   )170,      (char const   )204,      (char const   )198, 
        (char const   )241,      (char const   )196,      (char const   )218,      (char const   )169, 
        (char const   )175,      (char const   )174,      (char const   )226,      (char const   )172, 
        (char const   )231,      (char const   )179,      (char const   )235,      (char const   )201, 
        (char const   )200,      (char const   )63,      (char const   )236,      (char const   )207, 
        (char const   )173,      (char const   )240,      (char const   )177,      (char const   )166, 
        (char const   )184,      (char const   )234,      (char const   )206,      (char const   )34, 
        (char const   )41,      (char const   )237,      (char const   )40,      (char const   )186, 
        (char const   )163,      (char const   )197,      (char const   )217,      (char const   )248, 
        (char const   )95,      (char const   )191,      (char const   )212,      (char const   )225, 
        (char const   )161,      (char const   )211,      (char const   )180,      (char const   )224, 
        (char const   )233,      (char const   )195,      (char const   )232,      (char const   )210, 
        (char const   )202,      (char const   )183,      (char const   )215,      (char const   )185, 
        (char const   )194,      (char const   )230,      (char const   )190,      (char const   )203, 
        (char const   )208,      (char const   )213,      (char const   )205,      (char const   )228, 
        (char const   )187,      (char const   )209,      (char const   )188,      (char const   )176, 
        (char const   )165,      (char const   )44,      (char const   )37,      (char const   )127};
#line 49 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/thaikb.c"
static char const   *thai_qwerty_map  =    ketmanee_qwerty_map;
#line 51 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/thaikb.c"
void thai_set_keyboard(int thai_kbmode ) 
{ 


  {
  {
#line 54
  if (thai_kbmode == 1) {
#line 54
    goto case_1;
  }
#line 57
  goto switch_default;
  case_1: /* CIL Label */ 
#line 55
  thai_qwerty_map = tis_qwerty_map;
#line 55
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 58
  thai_qwerty_map = ketmanee_qwerty_map;
#line 58
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 60
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/thaikb.c"
char thai_map_qwerty(unsigned char c ) 
{ 


  {
#line 64
  return ((char )*(thai_qwerty_map + c));
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 515
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 52 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/debug.h"
void *my_calloc(size_t count , size_t size ) ;
#line 56
void *my_realloc(void *mem , size_t size ) ;
#line 27 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/debug.c"
void *my_malloc(size_t size ) 
{ 
  void *ptr ;

  {
  {
#line 31
  ptr = malloc(size);
  }
#line 31
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
#line 33
    printf((char const   */* __restrict  */)"malloc error: size 0x%X\n", (int )size);
#line 35
    abort();
    }
  }
#line 37
  return (ptr);
}
}
#line 43 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/debug.c"
void *my_calloc(size_t count , size_t size ) 
{ 
  void *ptr ;

  {
  {
#line 48
  ptr = calloc(count, size);
  }
#line 48
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
#line 50
    printf((char const   */* __restrict  */)"calloc error: count * size 0x%X\n", (int )(count * size));
#line 52
    abort();
    }
  }
#line 54
  return (ptr);
}
}
#line 60 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/debug.c"
void *my_realloc(void *mem , size_t size ) 
{ 
  void *ptr ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 68
  if (mem) {
    {
#line 68
    tmp = realloc(mem, size);
#line 68
    ptr = tmp;
    }
  } else {
    {
#line 68
    tmp___0 = malloc(size);
#line 68
    ptr = tmp___0;
    }
  }
#line 68
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
#line 70
    printf((char const   */* __restrict  */)"realloc error: size 0x%X\n", (int )size);
#line 71
    abort();
    }
  }
#line 73
  return (ptr);
}
}
#line 76 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/debug.c"
void my_free(void *mem ) 
{ 


  {
#line 79
  if ((unsigned long )mem != (unsigned long )((void *)0)) {
    {
#line 80
    free(mem);
    }
  }
#line 81
  return;
}
}
#line 2157 "/usr/include/X11/Xlib.h"
extern int XClearArea(Display * , Window  , int  , int  , unsigned int  , unsigned int  ,
                      int  ) ;
#line 2354
extern int XDrawLine(Display * , Drawable  , GC  , int  , int  , int  , int  ) ;
#line 2491
extern int XFillPolygon(Display * , Drawable  , GC  , XPoint * , int  , int  , int  ) ;
#line 2501
extern int XFillRectangle(Display * , Drawable  , GC  , int  , int  , unsigned int  ,
                          unsigned int  ) ;
#line 3517
extern int XUnmapWindow(Display * , Window  ) ;
#line 32 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/misc.h"
void Draw_Shadow(Window win , GC topShadow , GC botShadow , int x , int y , int w ,
                 int h ) ;
#line 25 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/scrollbar.h"
scrollBar_t scrollBar  ;
#line 33
int scrollbar_show(int update ) ;
#line 27 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/scrollbar.c"
static GC scrollbarGC  ;
#line 40 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/scrollbar.c"
static GC topShadowGC  ;
#line 40 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/scrollbar.c"
static GC botShadowGC  ;
#line 43 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/scrollbar.c"
static void Draw_up_button(int x , int y , int state ) 
{ 
  unsigned int sz ;
  unsigned int sz2 ;
  XPoint pt[3] ;
  GC top ;
  GC bot ;

  {
#line 46
  sz = 10U;
#line 46
  sz2 = 5U;
  {
#line 51
  if (state == 1) {
#line 51
    goto case_1;
  }
#line 52
  if (state == -1) {
#line 52
    goto case_neg_1;
  }
#line 53
  if (state == 0) {
#line 53
    goto case_0;
  }
#line 50
  goto switch_break;
  case_1: /* CIL Label */ 
#line 51
  top = topShadowGC;
#line 51
  bot = botShadowGC;
#line 51
  goto switch_break;
  case_neg_1: /* CIL Label */ 
#line 52
  top = botShadowGC;
#line 52
  bot = topShadowGC;
#line 52
  goto switch_break;
  case_0: /* CIL Label */ 
#line 53
  bot = scrollbarGC;
#line 53
  top = bot;
#line 53
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 57
  pt[0].x = (short )x;
#line 57
  pt[0].y = (short )(((unsigned int )y + sz) - 1U);
#line 58
  pt[1].x = (short )(((unsigned int )x + sz) - 1U);
#line 58
  pt[1].y = (short )(((unsigned int )y + sz) - 1U);
#line 59
  pt[2].x = (short )((unsigned int )x + sz2);
#line 59
  pt[2].y = (short )y;
#line 60
  XFillPolygon(Xdisplay, scrollBar.win, scrollbarGC, pt, 3, 2, 0);
#line 64
  XDrawLine(Xdisplay, scrollBar.win, bot, (int )pt[0].x, (int )pt[0].y, (int )pt[1].x,
            (int )pt[1].y);
#line 68
  pt[1].x = (short )(((unsigned int )x + sz2) - 1U);
#line 68
  pt[1].y = (short )y;
#line 69
  XDrawLine(Xdisplay, scrollBar.win, top, (int )pt[0].x, (int )pt[0].y, (int )pt[1].x,
            (int )pt[1].y);
#line 73
  pt[0].x = (short )((int )pt[0].x + 1);
#line 73
  pt[0].y = (short )((int )pt[0].y - 1);
#line 73
  pt[1].y = (short )((int )pt[1].y + 1);
#line 74
  XDrawLine(Xdisplay, scrollBar.win, top, (int )pt[0].x, (int )pt[0].y, (int )pt[1].x,
            (int )pt[1].y);
#line 78
  pt[0].x = (short )((unsigned int )x + sz2);
#line 78
  pt[0].y = (short )y;
#line 79
  pt[1].x = (short )(((unsigned int )x + sz) - 1U);
#line 79
  pt[1].y = (short )(((unsigned int )y + sz) - 1U);
#line 80
  XDrawLine(Xdisplay, scrollBar.win, bot, (int )pt[0].x, (int )pt[0].y, (int )pt[1].x,
            (int )pt[1].y);
#line 84
  pt[0].y = (short )((int )pt[0].y + 1);
#line 84
  pt[1].x = (short )((int )pt[1].x - 1);
#line 84
  pt[1].y = (short )((int )pt[1].y - 1);
#line 85
  XDrawLine(Xdisplay, scrollBar.win, bot, (int )pt[0].x, (int )pt[0].y, (int )pt[1].x,
            (int )pt[1].y);
  }
#line 88
  return;
}
}
#line 91 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/scrollbar.c"
static void Draw_dn_button(int x , int y , int state ) 
{ 
  unsigned int sz ;
  unsigned int sz2 ;
  XPoint pt[3] ;
  GC top ;
  GC bot ;

  {
#line 94
  sz = 10U;
#line 94
  sz2 = 5U;
  {
#line 99
  if (state == 1) {
#line 99
    goto case_1;
  }
#line 100
  if (state == -1) {
#line 100
    goto case_neg_1;
  }
#line 101
  if (state == 0) {
#line 101
    goto case_0;
  }
#line 98
  goto switch_break;
  case_1: /* CIL Label */ 
#line 99
  top = topShadowGC;
#line 99
  bot = botShadowGC;
#line 99
  goto switch_break;
  case_neg_1: /* CIL Label */ 
#line 100
  top = botShadowGC;
#line 100
  bot = topShadowGC;
#line 100
  goto switch_break;
  case_0: /* CIL Label */ 
#line 101
  bot = scrollbarGC;
#line 101
  top = bot;
#line 101
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 105
  pt[0].x = (short )x;
#line 105
  pt[0].y = (short )y;
#line 106
  pt[1].x = (short )(((unsigned int )x + sz) - 1U);
#line 106
  pt[1].y = (short )y;
#line 107
  pt[2].x = (short )((unsigned int )x + sz2);
#line 107
  pt[2].y = (short )((unsigned int )y + sz);
#line 108
  XFillPolygon(Xdisplay, scrollBar.win, scrollbarGC, pt, 3, 2, 0);
#line 112
  XDrawLine(Xdisplay, scrollBar.win, top, (int )pt[0].x, (int )pt[0].y, (int )pt[1].x,
            (int )pt[1].y);
#line 116
  pt[1].x = (short )(((unsigned int )x + sz2) - 1U);
#line 116
  pt[1].y = (short )(((unsigned int )y + sz) - 1U);
#line 117
  XDrawLine(Xdisplay, scrollBar.win, top, (int )pt[0].x, (int )pt[0].y, (int )pt[1].x,
            (int )pt[1].y);
#line 121
  pt[0].x = (short )((int )pt[0].x + 1);
#line 121
  pt[0].y = (short )((int )pt[0].y + 1);
#line 121
  pt[1].y = (short )((int )pt[1].y - 1);
#line 122
  XDrawLine(Xdisplay, scrollBar.win, top, (int )pt[0].x, (int )pt[0].y, (int )pt[1].x,
            (int )pt[1].y);
#line 126
  pt[0].x = (short )((unsigned int )x + sz2);
#line 126
  pt[0].y = (short )(((unsigned int )y + sz) - 1U);
#line 127
  pt[1].x = (short )(((unsigned int )x + sz) - 1U);
#line 127
  pt[1].y = (short )y;
#line 128
  XDrawLine(Xdisplay, scrollBar.win, bot, (int )pt[0].x, (int )pt[0].y, (int )pt[1].x,
            (int )pt[1].y);
#line 132
  pt[0].y = (short )((int )pt[0].y - 1);
#line 132
  pt[1].x = (short )((int )pt[1].x - 1);
#line 132
  pt[1].y = (short )((int )pt[1].y + 1);
#line 133
  XDrawLine(Xdisplay, scrollBar.win, bot, (int )pt[0].x, (int )pt[0].y, (int )pt[1].x,
            (int )pt[1].y);
  }
#line 136
  return;
}
}
#line 139 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/scrollbar.c"
int scrollbar_mapping(int map ) 
{ 
  int change ;

  {
#line 142
  change = 0;
#line 143
  if (map) {
#line 143
    if (! scrollBar.state) {
      {
#line 145
      scrollBar.state = (short)1;
#line 146
      XMapWindow(Xdisplay, scrollBar.win);
#line 147
      change = 1;
      }
    } else {
#line 143
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 149
  if (! map) {
#line 149
    if (scrollBar.state) {
      {
#line 151
      scrollBar.state = (short)0;
#line 152
      XUnmapWindow(Xdisplay, scrollBar.win);
#line 153
      change = 1;
      }
    }
  }
#line 156
  return (change);
}
}
#line 162 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/scrollbar.c"
static short last_top  ;
#line 162 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/scrollbar.c"
static short last_bot  ;
#line 159 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/scrollbar.c"
int scrollbar_show(int update ) 
{ 
  XGCValues gcvalue ;
  int top ;
  int bot ;
  int len ;
  int tmp ;
  int tmp___0 ;

  {
#line 164
  if (! scrollBar.state) {
#line 164
    return (0);
  }
#line 166
  if ((unsigned long )scrollbarGC == (unsigned long )((GC )0)) {
#line 189
    if ((((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root_depth <= 2) {
#line 189
      gcvalue.foreground = PixColors[0];
    } else {
#line 189
      gcvalue.foreground = PixColors[23];
    }
    {
#line 192
    scrollbarGC = XCreateGC(Xdisplay, scrollBar.win, (unsigned long )(1L << 2), & gcvalue);
#line 196
    gcvalue.foreground = PixColors[24];
#line 197
    topShadowGC = XCreateGC(Xdisplay, scrollBar.win, (unsigned long )(1L << 2), & gcvalue);
#line 201
    gcvalue.foreground = PixColors[25];
#line 202
    botShadowGC = XCreateGC(Xdisplay, scrollBar.win, (unsigned long )(1L << 2), & gcvalue);
    }
  }
#line 208
  if (update) {
#line 210
    top = (int )TermWin.nscrolled - (int )TermWin.view_start;
#line 211
    bot = top + ((int )TermWin.nrow - 1);
#line 212
    len = (int )TermWin.nscrolled + ((int )TermWin.nrow - 1);
#line 214
    scrollBar.top = (short )((int )scrollBar.beg + (top * ((int )scrollBar.end - (int )scrollBar.beg)) / len);
#line 216
    scrollBar.bot = (short )((int )scrollBar.beg + (bot * ((int )scrollBar.end - (int )scrollBar.beg)) / len);
#line 219
    if ((int )scrollBar.top == (int )last_top) {
#line 219
      if ((int )scrollBar.bot == (int )last_bot) {
#line 220
        return (0);
      }
    }
  }
#line 224
  if ((int )last_top < (int )scrollBar.top) {
    {
#line 225
    XClearArea(Xdisplay, scrollBar.win, 0, (int )last_top, 10U, (unsigned int )((int )scrollBar.top - (int )last_top),
               0);
    }
  }
#line 229
  if ((int )scrollBar.bot < (int )last_bot) {
    {
#line 230
    XClearArea(Xdisplay, scrollBar.win, 0, (int )scrollBar.bot, 10U, (unsigned int )((int )last_bot - (int )scrollBar.bot),
               0);
    }
  }
  {
#line 234
  last_top = scrollBar.top;
#line 235
  last_bot = scrollBar.bot;
#line 238
  XFillRectangle(Xdisplay, scrollBar.win, scrollbarGC, 0, (int )scrollBar.top, 10U,
                 (unsigned int )((int )scrollBar.bot - (int )scrollBar.top));
#line 244
  Draw_Shadow(scrollBar.win, topShadowGC, botShadowGC, 0, (int )scrollBar.top, 10,
              (int )scrollBar.bot - (int )scrollBar.top);
  }
#line 252
  if ((int )scrollBar.state == 85) {
#line 252
    tmp = -1;
  } else {
#line 252
    tmp = 1;
  }
  {
#line 252
  Draw_up_button(0, 0, tmp);
  }
#line 253
  if ((int )scrollBar.state == 68) {
#line 253
    tmp___0 = -1;
  } else {
#line 253
    tmp___0 = 1;
  }
  {
#line 253
  Draw_dn_button(0, (int )scrollBar.end + 1, tmp___0);
  }
#line 256
  return (1);
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 1548 "/usr/include/X11/Xlib.h"
extern Atom XInternAtom(Display * , char const   * , int  ) ;
#line 1644
extern Window XGetSelectionOwner(Display * , Atom  ) ;
#line 2022
extern int XBell(Display * , int  ) ;
#line 2050
extern int XChangeGC(Display * , GC  , unsigned long  , XGCValues * ) ;
#line 2080
extern int XChangeProperty(Display * , Window  , Atom  , Atom  , int  , int  , unsigned char const   * ,
                           int  ) ;
#line 2187
extern int XConvertSelection(Display * , Atom  , Atom  , Atom  , Window  , Time  ) ;
#line 2334
extern int XDrawImageString(Display * , Drawable  , GC  , int  , int  , char const   * ,
                            int  ) ;
#line 2390
extern int XDrawRectangle(Display * , Drawable  , GC  , int  , int  , unsigned int  ,
                          unsigned int  ) ;
#line 2688
extern int XGetWindowProperty(Display * , Window  , Atom  , long  , long  , int  ,
                              Atom  , Atom * , int * , unsigned long * , unsigned long * ,
                              unsigned char ** ) ;
#line 3147
extern int XSendEvent(Display * , Window  , int  , long  , XEvent * ) ;
#line 3304
extern int XSetSelectionOwner(Display * , Atom  , Window  , Time  ) ;
#line 32 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.h"
void tt_resize(void) ;
#line 35
void tt_write(unsigned char const   *buf___0 , unsigned int count ) ;
#line 39
void tt_printf(char const   *fmt  , ...) ;
#line 94 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.h"
void scr_backspace(void) ;
#line 97
void scr_bell(void) ;
#line 100
void scr_rendition(int set , int style ) ;
#line 104
void scr_add_lines(unsigned char const   *str , int nlines , int cnt ) ;
#line 109
void scr_tab(int count ) ;
#line 112
void scr_gotorc(int row , int col , int relative ) ;
#line 117
void scr_index(int dirn ) ;
#line 120
void scr_cursor(int mode ) ;
#line 123
void scr_cursor_visible(int mode ) ;
#line 126
void scr_erase_line(int mode ) ;
#line 129
void scr_erase_screen(int mode ) ;
#line 132
void scr_insdel_lines(int count , int insdel ) ;
#line 136
void scr_insdel_chars(int count , int insdel ) ;
#line 140
void scr_scroll_region(int top , int bot ) ;
#line 144
void scr_report_position(void) ;
#line 148
void scr_get_position(int *prow , int *pcol ) ;
#line 152
unsigned char scr_get_char_rc(int row , int col ) ;
#line 158
void scr_expose(int x , int y , int width , int height ) ;
#line 167
void scr_charset_choose(int set ) ;
#line 170
void scr_charset_set(int set , unsigned int ch ) ;
#line 174
void scr_refresh(int type ) ;
#line 177
void scr_set_tab(int mode ) ;
#line 180
void scr_E(void) ;
#line 183
void scr_color(unsigned int color , unsigned int Intensity ) ;
#line 187
int scr_move_to(int y , int len ) ;
#line 191
int scr_page(int dirn , int nlines ) ;
#line 204
void mouse_report(XButtonEvent *ev ) ;
#line 209
void scr_autowrap(int mode ) ;
#line 212
void scr_relative_origin(int mode ) ;
#line 215
void scr_insert_mode(int mode ) ;
#line 218
void scr_rvideo_mode(int mode ) ;
#line 226
void selection_make(Time tm ) ;
#line 229
void selection_send(XSelectionRequestEvent *rq ) ;
#line 232
void selection_paste(Window win , unsigned int prop , int Delete ) ;
#line 237
void selection_request(Time tm , int x , int y ) ;
#line 242
void selection_reset(void) ;
#line 248
void selection_extend(int x , int y ) ;
#line 252
void selection_start(int x , int y ) ;
#line 256
void selection_click(int clicks___0 , int x , int y ) ;
#line 11 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/thai.h"
int thai_compare(text_t *d , text_t *s , rend_t *dr , rend_t *sr , int *result , int *mcol ,
                 int *mcolcount ) ;
#line 15
int thai_isupper(unsigned char c ) ;
#line 16
int thai_level(unsigned char c ) ;
#line 18
int ThaiCol2Pixel(int c , unsigned char *start ) ;
#line 20
int ThaiPixel2Col(int x , int y ) ;
#line 21
int ThaiPixel2Col2(int x , int y ) ;
#line 57 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
unsigned int colorfgbg  =    (unsigned int )(1 << 16);
#line 68
int thai_keyboard ;
#line 69
int thai_spcount ;
#line 70
void thai_clearline(int from , int to , int ypixel ) ;
#line 71
void thai_complexclear(int *list , int ypixel ) ;
#line 76 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
static rend_t rstyle  =    (rend_t )(1 << 16);
#line 162 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
static screen_t screen  = 
#line 162
     {(text_t *)((void *)0), (rend_t *)((void *)0), (short)0, (short)0, (short)0, (short)0,
    (short)0, (unsigned int )((1 << 1) | (1 << 2))};
#line 169 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
static screen_t swap_screen  = 
#line 169
     {(text_t *)((void *)0), (rend_t *)((void *)0), (short)0, (short)0, (short)0, (short)0,
    (short)0, (unsigned int )((1 << 1) | (1 << 2))};
#line 174 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
static short current_screen  =    (short)0;
#line 175 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
static short rvideo  =    (short)0;
#line 177 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
static char *tabs  =    (char *)((void *)0);
#line 178 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
static text_t *linebuf  =    (text_t *)((void *)0);
#line 185 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
static struct __anonstruct_save_112 save  =    {(short)0, (short)0, (short)0, (char )'B', (rend_t )(1 << 16)};
#line 198 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
text_t *drawn_text  =    (text_t *)((void *)0);
#line 199 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
static rend_t *drawn_rend  =    (rend_t *)((void *)0);
#line 201 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
static char charsets[4]  = {      (char )'B',      (char )'B',      (char )'B',      (char )'B'};
#line 207 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
static struct __anonstruct_selection_113 selection  =    {(unsigned char *)((void *)0), 0, (short)0, (short)0, {(short)0, (short)0}, {(short)0,
                                                                                (short)0},
    {(short)0, (short)0}};
#line 247
static int scroll_text(int row1 , int row2 , int count ) ;
#line 248
__inline static void selection_check(void) ;
#line 332 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
__inline static void blank_lines(text_t *text , rend_t *rend , int count ) 
{ 
  int r ;
  int n ;
  rend_t *p ;
  rend_t *tmp ;
  int tmp___0 ;

  {
#line 337
  if (count <= 0) {
#line 338
    return;
  }
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    n = count * ((int )TermWin.ncol + 1);
#line 341
    if (n > 0) {
      {
#line 341
      p = rend;
#line 341
      memset((void *)text, ' ', (unsigned long )n * sizeof(text_t ));
      }
      {
#line 341
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 341
        tmp___0 = n;
#line 341
        n --;
#line 341
        if (! (tmp___0 > 0)) {
#line 341
          goto while_break___0;
        }
#line 341
        tmp = p;
#line 341
        p ++;
#line 341
        *tmp = rstyle;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 341
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 344
  text += (int )TermWin.ncol;
#line 345
  r = 0;
  {
#line 345
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 345
    if (! (r < count)) {
#line 345
      goto while_break___1;
    }
#line 346
    *text = (text_t )'\000';
#line 345
    r ++;
#line 345
    text += (int )TermWin.ncol + 1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 347
  return;
}
}
#line 357 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
static short prev_nrow  =    (short)-1;
#line 357 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
static short prev_ncol  =    (short)-1;
#line 354 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void scr_reset(void) 
{ 
  int i ;
  int ncol ;
  text_t *old_text ;
  rend_t *old_rend ;
  int r ;
  int oldr ;
  int oldr_max ;
  int histsize ;
  screen_t *scr ;
  int n ;
  void *tmp ;
  void *tmp___0 ;
  int roffset ;
  int oroffset ;
  void *tmp___1 ;
  void *tmp___2 ;
  int n___0 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 358
  ncol = 0;
#line 360
  TermWin.view_start = (short)0;
#line 362
  if ((int )prev_ncol == (int )TermWin.ncol) {
#line 362
    if ((int )prev_nrow == (int )TermWin.nrow) {
#line 363
      return;
    }
  }
#line 368
  if ((int )TermWin.ncol <= 0) {
#line 369
    TermWin.ncol = (short)80;
  }
#line 370
  if ((int )TermWin.nrow <= 0) {
#line 371
    TermWin.nrow = (short)24;
  }
#line 377
  if ((int )prev_ncol < (int )TermWin.ncol) {
#line 377
    ncol = (int )prev_ncol;
  } else {
#line 377
    ncol = (int )TermWin.ncol;
  }
#line 379
  if ((int )prev_nrow < 0) {
#line 380
    TermWin.nscrolled = (short)0;
  }
#line 382
  i = 0;
  {
#line 382
  while (1) {
    while_continue: /* CIL Label */ ;
#line 382
    if (! (i <= 1)) {
#line 382
      goto while_break;
    }
#line 387
    histsize = (int )TermWin.saveLines;
#line 388
    scr = & screen;
#line 392
    if (i) {
#line 394
      histsize = 0;
#line 395
      scr = & swap_screen;
    }
#line 400
    oldr_max = (int )prev_nrow;
#line 400
    oldr = oldr_max;
#line 401
    if ((int )prev_nrow > 0) {
#line 403
      n = (int )TermWin.nrow - (int )prev_nrow;
#line 404
      if (n > 0) {
#line 406
        oldr = (int )TermWin.nrow;
#line 407
        if (histsize) {
#line 409
          if (n <= (int )TermWin.nscrolled) {
#line 411
            scr->row = (short )((int )scr->row + n);
#line 412
            oldr = oldr_max;
          } else {
#line 416
            scr->row = (short )((int )scr->row + (int )TermWin.nscrolled);
#line 417
            oldr -= (int )TermWin.nscrolled;
          }
#line 419
          TermWin.nscrolled = (short )((int )TermWin.nscrolled - n);
        }
      } else
#line 422
      if (n < 0) {
#line 424
        if ((int )scr->row < (int )TermWin.nrow) {
#line 426
          oldr_max = (int )TermWin.nrow;
        } else {
#line 431
          oldr_max = (int )scr->row + 1;
#line 432
          if (histsize) {
#line 433
            TermWin.nscrolled = (short )((int )TermWin.nscrolled + (oldr_max - (int )TermWin.nrow));
          }
        }
#line 435
        oldr = oldr_max;
      }
#line 437
      oldr_max += histsize;
#line 438
      oldr += histsize;
#line 439
      oldr --;
    }
#line 442
    if ((int )scr->row < 0) {
#line 443
      scr->row = (short)0;
    } else
#line 444
    if ((int )scr->row >= (int )TermWin.nrow) {
#line 445
      scr->row = (short )((int )TermWin.nrow - 1);
    }
#line 447
    if ((int )scr->col < 0) {
#line 448
      scr->col = (short)0;
    } else
#line 449
    if ((int )scr->col >= (int )TermWin.ncol) {
#line 450
      scr->col = (short )((int )TermWin.ncol - 1);
    }
    {
#line 453
    scr->tscroll = (short)0;
#line 454
    scr->bscroll = (short )((int )TermWin.nrow - 1);
#line 456
    old_text = scr->text;
#line 457
    old_rend = scr->rend;
#line 459
    tmp = my_malloc((unsigned long )((histsize + (int )TermWin.nrow) * ((int )TermWin.ncol + 1)) * sizeof(text_t ));
#line 459
    scr->text = (text_t *)tmp;
#line 461
    tmp___0 = my_malloc((unsigned long )((histsize + (int )TermWin.nrow) * ((int )TermWin.ncol + 1)) * sizeof(rend_t ));
#line 461
    scr->rend = (rend_t *)tmp___0;
#line 464
    blank_lines(scr->text, scr->rend, histsize + (int )TermWin.nrow);
    }
#line 465
    if (ncol > 0) {
#line 467
      r = ((int )TermWin.nrow + histsize) - 1;
      {
#line 467
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 467
        if (r >= 0) {
#line 467
          if (! (oldr >= 0)) {
#line 467
            goto while_break___0;
          }
        } else {
#line 467
          goto while_break___0;
        }
#line 471
        if (oldr < oldr_max) {
          {
#line 473
          roffset = r * ((int )TermWin.ncol + 1);
#line 474
          oroffset = oldr * ((int )prev_ncol + 1);
#line 475
          memcpy((void */* __restrict  */)(scr->text + roffset), (void const   */* __restrict  */)(old_text + oroffset),
                 (unsigned long )ncol * sizeof(text_t ));
#line 477
          memcpy((void */* __restrict  */)(scr->rend + roffset), (void const   */* __restrict  */)(old_rend + oroffset),
                 (unsigned long )ncol * sizeof(rend_t ));
          }
        }
#line 467
        r --;
#line 467
        oldr --;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 483
    my_free((void *)old_text);
#line 484
    my_free((void *)old_rend);
#line 382
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 488
  if ((int )TermWin.nscrolled < 0) {
#line 489
    TermWin.nscrolled = (short)0;
  } else
#line 490
  if ((int )TermWin.nscrolled > (int )TermWin.saveLines) {
#line 491
    TermWin.nscrolled = TermWin.saveLines;
  }
  {
#line 493
  prev_ncol = TermWin.ncol;
#line 494
  prev_nrow = TermWin.nrow;
#line 496
  tmp___1 = my_realloc((void *)drawn_text, (unsigned long )((int )TermWin.nrow * ((int )TermWin.ncol + 1)) * sizeof(text_t ));
#line 496
  drawn_text = (text_t *)tmp___1;
#line 499
  tmp___2 = my_realloc((void *)drawn_rend, (unsigned long )((int )TermWin.nrow * ((int )TermWin.ncol + 1)) * sizeof(rend_t ));
#line 499
  drawn_rend = (rend_t *)tmp___2;
  }
  {
#line 503
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 503
    n___0 = (int )TermWin.nrow * ((int )TermWin.ncol + 1);
#line 503
    if (n___0 > 0) {
      {
#line 503
      memset((void *)drawn_text, 0, (unsigned long )n___0 * sizeof(text_t ));
#line 503
      memset((void *)drawn_rend, 0, (unsigned long )n___0 * sizeof(rend_t ));
      }
    }
#line 503
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 506
  if ((int )save.row >= (int )TermWin.nrow) {
#line 507
    save.row = (short )((int )TermWin.nrow - 1);
  }
#line 508
  if ((int )save.col >= (int )TermWin.ncol) {
#line 509
    save.col = (short )((int )TermWin.ncol - 1);
  }
  {
#line 511
  tmp___3 = my_realloc((void *)tabs, (unsigned long )TermWin.ncol * sizeof(char ));
#line 511
  tabs = (char *)tmp___3;
#line 512
  tmp___4 = my_realloc((void *)linebuf, (unsigned long )((int )TermWin.ncol + 1) * sizeof(text_t ));
#line 512
  linebuf = (text_t *)tmp___4;
#line 514
  memset((void *)tabs, 0, (unsigned long )TermWin.ncol * sizeof(char ));
#line 516
  i = 0;
  }
  {
#line 516
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 516
    if (! (i < (int )TermWin.ncol)) {
#line 516
      goto while_break___2;
    }
#line 517
    *(tabs + i) = (char)1;
#line 516
    i += 8;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 519
  tt_resize();
  }
#line 520
  return;
}
}
#line 528 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void scr_poweron(void) 
{ 
  screen_t *scr ;
  int i ;
  short tmp ;
  int n ;

  {
  {
#line 531
  scr = & screen;
#line 534
  TermWin.view_start = (short)0;
#line 535
  TermWin.nscrolled = (short)0;
#line 537
  memset((void *)(charsets), 'B', sizeof(charsets));
#line 538
  rvideo = (short)0;
#line 539
  scr_rendition(0, ~ 0);
#line 542
  scr_change_screen(1);
#line 543
  scr_erase_screen(2);
#line 545
  scr_change_screen(0);
#line 546
  scr_erase_screen(2);
#line 548
  i = 0;
  }
  {
#line 548
  while (1) {
    while_continue: /* CIL Label */ ;
#line 548
    if (! (i <= 1)) {
#line 548
      goto while_break;
    }
#line 550
    scr->tscroll = (short)0;
#line 551
    scr->bscroll = (short )((int )TermWin.nrow - 1);
#line 552
    tmp = (short)0;
#line 552
    scr->col = tmp;
#line 552
    scr->row = tmp;
#line 553
    scr->charset = (short)0;
#line 554
    scr->flags = (unsigned int )((1 << 1) | (1 << 2));
#line 556
    scr = & swap_screen;
#line 548
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 559
  scr_cursor('s');
  }
  {
#line 560
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 560
    n = (int )TermWin.nrow * ((int )TermWin.ncol + 1);
#line 560
    if (n > 0) {
      {
#line 560
      memset((void *)drawn_text, 0, (unsigned long )n * sizeof(text_t ));
#line 560
      memset((void *)drawn_rend, 0, (unsigned long )n * sizeof(rend_t ));
      }
    }
#line 560
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 562
  scr_reset();
#line 563
  XClearWindow(Xdisplay, TermWin.vt);
#line 564
  scr_refresh(1);
  }
#line 566
  return;
}
}
#line 570 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
__inline static void set_font_style(void) 
{ 


  {
#line 573
  rstyle &= 3489660927U;
  {
#line 577
  if ((int )charsets[screen.charset] == 48) {
#line 577
    goto case_48;
  }
#line 581
  if ((int )charsets[screen.charset] == 65) {
#line 581
    goto case_65;
  }
#line 574
  goto switch_break;
  case_48: /* CIL Label */ 
#line 578
  rstyle |= 268435456U;
#line 579
  goto switch_break;
  case_65: /* CIL Label */ 
#line 582
  rstyle |= 536870912U;
#line 583
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 592
  return;
}
}
#line 595 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void scr_cursor(int mode ) 
{ 


  {
  {
#line 603
  if (mode == 115) {
#line 603
    goto case_115;
  }
#line 610
  if (mode == 114) {
#line 610
    goto case_114;
  }
#line 601
  goto switch_break;
  case_115: /* CIL Label */ 
#line 604
  save.row = screen.row;
#line 605
  save.col = screen.col;
#line 606
  save.rstyle = rstyle;
#line 607
  save.charset = screen.charset;
#line 608
  save.charset_char = charsets[save.charset];
#line 609
  goto switch_break;
  case_114: /* CIL Label */ 
  {
#line 611
  screen.row = save.row;
#line 612
  screen.col = save.col;
#line 613
  rstyle = save.rstyle;
#line 614
  screen.charset = save.charset;
#line 615
  charsets[screen.charset] = save.charset_char;
#line 616
  set_font_style();
  }
#line 617
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 622
  return;
}
}
#line 626 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
int scr_change_screen(int scrn ) 
{ 
  register int x ;
  int tmp ;
  int count ;
  int roffset ;
  text_t *text ;
  rend_t *rend ;
  register text_t t ;
  register rend_t r ;

  {
#line 630
  TermWin.view_start = (short)0;
#line 632
  if ((int )current_screen == scrn) {
#line 633
    return ((int )current_screen);
  } else {
#line 637
    tmp = (int )current_screen;
#line 638
    current_screen = (short )scrn;
#line 639
    scrn = tmp;
  }
#line 647
  count = (int )TermWin.nrow * ((int )TermWin.ncol + 1);
#line 648
  roffset = (int )TermWin.saveLines * ((int )TermWin.ncol + 1);
#line 650
  text = screen.text + roffset;
#line 651
  rend = screen.rend + roffset;
#line 653
  x = 0;
  {
#line 653
  while (1) {
    while_continue: /* CIL Label */ ;
#line 653
    if (! (x < count)) {
#line 653
      goto while_break;
    }
#line 658
    t = *(text + x);
#line 659
    *(text + x) = *(swap_screen.text + x);
#line 660
    *(swap_screen.text + x) = t;
#line 662
    r = *(rend + x);
#line 663
    *(rend + x) = *(swap_screen.rend + x);
#line 664
    *(swap_screen.rend + x) = r;
#line 653
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 668
  x = (int )screen.row;
#line 669
  screen.row = swap_screen.row;
#line 670
  swap_screen.row = (short )x;
#line 672
  x = (int )screen.col;
#line 673
  screen.col = swap_screen.col;
#line 674
  swap_screen.col = (short )x;
#line 676
  x = (int )screen.charset;
#line 677
  screen.charset = swap_screen.charset;
#line 678
  swap_screen.charset = (short )x;
#line 680
  x = (int )screen.flags;
#line 681
  screen.flags = swap_screen.flags;
#line 682
  swap_screen.flags = (unsigned int )x;
#line 684
  screen.flags |= (unsigned int )(1 << 1);
#line 685
  swap_screen.flags |= (unsigned int )(1 << 1);
#line 699
  return (scrn);
}
}
#line 755 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void scr_color(unsigned int color , unsigned int Intensity ) 
{ 


  {
  {
#line 760
  if (color == 39U) {
#line 760
    goto case_39;
  }
#line 764
  if (color == 49U) {
#line 764
    goto case_49;
  }
#line 769
  goto switch_default;
  case_39: /* CIL Label */ 
#line 761
  color = 0U;
#line 762
  if (! (Intensity == 32768U)) {
    {
#line 762
    __assert_fail("Intensity == 0x00008000u", "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c",
                  762U, "scr_color");
    }
  }
#line 763
  goto switch_break;
  case_49: /* CIL Label */ 
#line 765
  color = 1U;
#line 766
  if (! (Intensity == 8388608U)) {
    {
#line 766
    __assert_fail("Intensity == 0x00800000u", "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c",
                  766U, "scr_color");
    }
  }
#line 767
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 770
  if ((((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root_depth <= 2) {
    {
#line 774
    if (Intensity == 32768U) {
#line 774
      goto case_32768;
    }
#line 777
    if (Intensity == 8388608U) {
#line 777
      goto case_8388608;
    }
#line 772
    goto switch_break___0;
    case_32768: /* CIL Label */ 
#line 775
    color = 0U;
#line 776
    goto switch_break___0;
    case_8388608: /* CIL Label */ 
#line 778
    color = 1U;
#line 779
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  } else
#line 785
  if (rstyle & Intensity) {
#line 785
    if (color >= 2U) {
#line 785
      if (color <= 9U) {
#line 786
        color += 8U;
      } else {
#line 785
        goto _L___0;
      }
    } else {
#line 785
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 787
  if (color >= 10U) {
#line 787
    if (color <= 17U) {
#line 789
      if (rstyle & Intensity) {
#line 790
        return;
      }
#line 791
      color -= 8U;
    }
  }
#line 795
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 800
  if (Intensity == 32768U) {
#line 800
    goto case_32768___0;
  }
#line 803
  if (Intensity == 8388608U) {
#line 803
    goto case_8388608___0;
  }
#line 798
  goto switch_break___1;
  case_32768___0: /* CIL Label */ 
#line 801
  rstyle = (rstyle & 4294959359U) | (color << 8);
#line 802
  goto switch_break___1;
  case_8388608___0: /* CIL Label */ 
#line 804
  rstyle = (rstyle & 4292935679U) | (color << 16);
#line 805
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 808
  return;
}
}
#line 811 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void scr_rendition(int set , int style ) 
{ 
  unsigned int color ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 817
  if (set) {
#line 819
    rstyle |= (unsigned int )style;
    {
#line 823
    if (style == 32768) {
#line 823
      goto case_32768;
    }
#line 829
    if (style == 8388608) {
#line 829
      goto case_8388608;
    }
#line 836
    if (style == 67108864) {
#line 836
      goto case_67108864;
    }
#line 820
    goto switch_break;
    case_32768: /* CIL Label */ 
#line 824
    color = (rstyle & 7936U) >> 8;
#line 825
    if (color == 0U) {
#line 825
      tmp = (colorfgbg & 7936U) >> 8;
    } else {
#line 825
      tmp = color;
    }
    {
#line 825
    scr_color(tmp, 32768U);
    }
#line 827
    goto switch_break;
    case_8388608: /* CIL Label */ 
#line 830
    color = (rstyle & 2031616U) >> 16;
#line 831
    if (color == 1U) {
#line 831
      tmp___0 = (colorfgbg & 2031616U) >> 16;
    } else {
#line 831
      tmp___0 = color;
    }
    {
#line 831
    scr_color(tmp___0, 8388608U);
    }
#line 833
    goto switch_break;
    case_67108864: /* CIL Label */ 
#line 837
    if (rvideo) {
#line 838
      rstyle &= 4227858431U;
    }
#line 839
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
#line 844
    rstyle &= (unsigned int )(~ style);
    {
#line 848
    if (style == -1) {
#line 848
      goto case_neg_1;
    }
#line 855
    if (style == 32768) {
#line 855
      goto case_32768___0;
    }
#line 866
    if (style == 8388608) {
#line 866
      goto case_8388608___0;
    }
#line 878
    if (style == 67108864) {
#line 878
      goto case_67108864___0;
    }
#line 846
    goto switch_break___0;
    case_neg_1: /* CIL Label */ 
#line 849
    rstyle = (rend_t )(1 << 16);
#line 850
    if (rvideo) {
#line 851
      rstyle |= 67108864U;
    }
#line 852
    goto switch_break___0;
    case_32768___0: /* CIL Label */ 
#line 856
    color = (rstyle & 7936U) >> 8;
#line 857
    if (color >= 10U) {
#line 857
      if (color <= 17U) {
        {
#line 859
        scr_color(color, 32768U);
        }
#line 861
        if ((rstyle & 7936U) == (colorfgbg & 7936U)) {
          {
#line 862
          scr_color(39U, 32768U);
          }
        }
      }
    }
#line 864
    goto switch_break___0;
    case_8388608___0: /* CIL Label */ 
#line 867
    color = (rstyle & 2031616U) >> 16;
#line 868
    if (color >= 10U) {
#line 868
      if (color <= 17U) {
        {
#line 870
        scr_color(color, 8388608U);
        }
#line 872
        if ((rstyle & 2031616U) == (colorfgbg & 2031616U)) {
          {
#line 873
          scr_color(49U, 8388608U);
          }
        }
      }
    }
#line 875
    goto switch_break___0;
    case_67108864___0: /* CIL Label */ 
#line 879
    if (rvideo) {
#line 880
      rstyle |= 67108864U;
    }
#line 881
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 885
  return;
}
}
#line 889 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void scr_add_lines(unsigned char const   *str , int nlines , int cnt ) 
{ 
  int i ;
  int roffset ;

  {
#line 901
  TermWin.view_start = (short)0;
#line 904
  if (selection.op) {
    {
#line 905
    selection_check();
    }
  }
#line 908
  if (nlines > 0) {
#line 910
    nlines += (int )screen.row - (int )screen.bscroll;
#line 912
    if (nlines > 0) {
#line 912
      if ((int )screen.tscroll == 0) {
#line 912
        if ((int )screen.bscroll == (int )TermWin.nrow - 1) {
          {
#line 916
          scroll_text((int )screen.tscroll, (int )screen.bscroll, nlines);
#line 919
          screen.row = (short )((int )screen.row - nlines);
          }
#line 920
          if ((int )screen.row < - ((int )TermWin.saveLines)) {
#line 921
            screen.row = (short )(- ((int )TermWin.saveLines));
          }
        }
      }
    }
  }
#line 925
  if ((int )screen.col >= (int )TermWin.ncol) {
#line 926
    screen.col = (short )((int )TermWin.ncol - 1);
  }
#line 928
  roffset = ((int )screen.row + (int )TermWin.saveLines) * ((int )TermWin.ncol + 1);
#line 929
  i = 0;
  {
#line 929
  while (1) {
    while_continue: /* CIL Label */ ;
#line 929
    if (! (i < cnt)) {
#line 929
      goto while_break;
    }
    {
#line 962
    if ((int const   )*(str + i) == 127) {
#line 962
      goto case_127;
    }
#line 965
    if ((int const   )*(str + i) == 9) {
#line 965
      goto case_9;
    }
#line 969
    if ((int const   )*(str + i) == 10) {
#line 969
      goto case_10;
    }
#line 983
    if ((int const   )*(str + i) == 13) {
#line 983
      goto case_13;
    }
#line 990
    goto switch_default;
    case_127: /* CIL Label */ 
#line 963
    goto __Cont;
#line 964
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 966
    scr_tab(1);
    }
#line 967
    goto __Cont;
#line 968
    goto switch_break;
    case_10: /* CIL Label */ 
#line 970
    screen.flags &= (unsigned int )(~ (1 << 4));
#line 971
    *(screen.text + (roffset + (int )TermWin.ncol)) = (text_t )'\000';
#line 972
    if ((int )screen.row == (int )screen.bscroll) {
      {
#line 973
      scroll_text((int )screen.tscroll, (int )screen.bscroll, 1);
      }
    } else
#line 974
    if ((int )screen.row < (int )TermWin.nrow - 1) {
#line 976
      screen.row = (short )((int )screen.row + 1);
#line 977
      roffset = ((int )screen.row + (int )TermWin.saveLines) * ((int )TermWin.ncol + 1);
    }
#line 980
    goto __Cont;
#line 981
    goto switch_break;
    case_13: /* CIL Label */ 
#line 984
    screen.col = (short)0;
#line 985
    screen.flags &= (unsigned int )(~ (1 << 4));
#line 986
    *(screen.text + (roffset + (int )TermWin.ncol)) = (text_t )'\000';
#line 987
    goto __Cont;
#line 988
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 994
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 998
    if (screen.flags & (unsigned int )(1 << 4)) {
#line 1000
      *(screen.text + (roffset + (int )TermWin.ncol)) = (text_t )'\n';
#line 1001
      if ((int )screen.row == (int )screen.bscroll) {
        {
#line 1002
        scroll_text((int )screen.tscroll, (int )screen.bscroll, 1);
        }
      } else
#line 1003
      if ((int )screen.row < (int )TermWin.nrow - 1) {
#line 1005
        screen.row = (short )((int )screen.row + 1);
#line 1006
        roffset = ((int )screen.row + (int )TermWin.saveLines) * ((int )TermWin.ncol + 1);
      }
#line 1009
      screen.col = (short)0;
#line 1010
      screen.flags &= (unsigned int )(~ (1 << 4));
    }
#line 1012
    if (screen.flags & (unsigned int )(1 << 3)) {
      {
#line 1013
      scr_insdel_chars(1, -1);
      }
    }
#line 1014
    *(screen.text + (roffset + (int )screen.col)) = (text_t )*(str + i);
#line 1015
    *(screen.rend + (roffset + (int )screen.col)) = rstyle;
#line 1017
    screen.col = (short )((int )screen.col + 1);
#line 1018
    if ((int )screen.col == (int )TermWin.ncol) {
#line 1020
      screen.col = (short )((int )screen.col - 1);
#line 1021
      if (screen.flags & (unsigned int )(1 << 2)) {
#line 1022
        screen.flags |= (unsigned int )(1 << 4);
      } else {
#line 1024
        screen.flags &= (unsigned int )(~ (1 << 4));
      }
    }
    __Cont: /* CIL Label */ 
#line 929
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1027
  return;
}
}
#line 1035 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
static int scroll_text(int row1 , int row2 , int count ) 
{ 
  int r ;
  text_t *t_dst ;
  text_t *t_src ;
  rend_t *r_dst ;
  rend_t *r_src ;
  int n ;
  int x ;
  int x___0 ;
  int n___0 ;
  rend_t *p ;
  rend_t *tmp ;
  int tmp___0 ;

  {
#line 1042
  if (selection.op) {
#line 1044
    selection.beg.row = (short )((int )selection.beg.row - count);
#line 1045
    selection.end.row = (short )((int )selection.end.row - count);
#line 1046
    selection.mark.row = (short )((int )selection.mark.row - count);
  }
#line 1054
  if (count > 0) {
#line 1059
    if (row1 == 0) {
#line 1059
      if ((int )current_screen == 0) {
#line 1061
        row1 = - ((int )TermWin.saveLines);
#line 1062
        TermWin.nscrolled = (short )((int )TermWin.nscrolled + count);
#line 1063
        if ((int )TermWin.nscrolled > (int )TermWin.saveLines) {
#line 1064
          TermWin.nscrolled = TermWin.saveLines;
        }
      }
    }
#line 1067
    x = (row1 + (int )TermWin.saveLines) * ((int )TermWin.ncol + 1);
#line 1068
    t_dst = screen.text + x;
#line 1069
    r_dst = screen.rend + x;
#line 1071
    n = (row2 - row1) + 1;
#line 1072
    if (count > n) {
#line 1074
      count = n;
#line 1075
      n = 0;
    } else {
#line 1079
      n -= count;
    }
#line 1082
    x += count * ((int )TermWin.ncol + 1);
#line 1083
    t_src = screen.text + x;
#line 1084
    r_src = screen.rend + x;
#line 1087
    if (n > 0) {
      {
#line 1089
      n *= (int )TermWin.ncol + 1;
#line 1090
      memcpy((void */* __restrict  */)t_dst, (void const   */* __restrict  */)t_src,
             (unsigned long )n * sizeof(text_t ));
#line 1091
      memcpy((void */* __restrict  */)r_dst, (void const   */* __restrict  */)r_src,
             (unsigned long )n * sizeof(rend_t ));
#line 1092
      t_dst += n;
#line 1093
      r_dst += n;
      }
    }
    {
#line 1099
    blank_lines(t_dst, r_dst, count);
    }
  } else
#line 1101
  if (count < 0) {
#line 1106
    x___0 = (row2 + (int )TermWin.saveLines) * ((int )TermWin.ncol + 1);
#line 1107
    t_dst = screen.text + x___0;
#line 1108
    r_dst = screen.rend + x___0;
#line 1110
    x___0 += count * ((int )TermWin.ncol + 1);
#line 1111
    t_src = screen.text + x___0;
#line 1112
    r_src = screen.rend + x___0;
#line 1113
    r = row2;
    {
#line 1113
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1113
      if (! (r >= row1 - count)) {
#line 1113
        goto while_break;
      }
      {
#line 1115
      memcpy((void */* __restrict  */)t_dst, (void const   */* __restrict  */)t_src,
             (unsigned long )((int )TermWin.ncol + 1) * sizeof(text_t ));
#line 1116
      t_dst -= (int )TermWin.ncol + 1;
#line 1117
      t_src -= (int )TermWin.ncol + 1;
#line 1119
      memcpy((void */* __restrict  */)r_dst, (void const   */* __restrict  */)r_src,
             (unsigned long )((int )TermWin.ncol + 1) * sizeof(rend_t ));
#line 1120
      r_dst -= (int )TermWin.ncol + 1;
#line 1121
      r_src -= (int )TermWin.ncol + 1;
#line 1113
      r --;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1125
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1125
      if (! (r >= row1)) {
#line 1125
        goto while_break___0;
      }
      {
#line 1127
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1127
        n___0 = (int )TermWin.ncol;
#line 1127
        if (n___0 > 0) {
          {
#line 1127
          p = r_dst;
#line 1127
          memset((void *)t_dst, ' ', (unsigned long )n___0 * sizeof(text_t ));
          }
          {
#line 1127
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1127
            tmp___0 = n___0;
#line 1127
            n___0 --;
#line 1127
            if (! (tmp___0 > 0)) {
#line 1127
              goto while_break___2;
            }
#line 1127
            tmp = p;
#line 1127
            p ++;
#line 1127
            *tmp = rstyle;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
#line 1127
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1128
      *(t_dst + TermWin.ncol) = (text_t )'\000';
#line 1129
      t_dst -= (int )TermWin.ncol + 1;
#line 1130
      r_dst -= (int )TermWin.ncol + 1;
#line 1125
      r --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1135
  return (count);
}
}
#line 1140 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void scr_backspace(void) 
{ 
  int roffset ;

  {
#line 1145
  if (selection.op) {
    {
#line 1146
    selection_check();
    }
  }
#line 1147
  if ((int )screen.col == 0) {
#line 1147
    if ((int )screen.row > 0) {
#line 1149
      screen.row = (short )((int )screen.row - 1);
#line 1150
      screen.col = (short )((int )TermWin.ncol - 1);
    } else {
#line 1147
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1152
  if (screen.flags & (unsigned int )(1 << 4)) {
#line 1154
    roffset = ((int )screen.row + (int )TermWin.saveLines) * ((int )TermWin.ncol + 1);
#line 1155
    *(screen.text + (roffset + (int )TermWin.ncol)) = (text_t )'\000';
#line 1156
    screen.flags &= (unsigned int )(~ (1 << 4));
  } else {
    {
#line 1159
    scr_gotorc(0, -1, 3);
    }
  }
#line 1160
  return;
}
}
#line 1167 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void scr_tab(int count ) 
{ 
  int x ;
  int i ;
  int i___0 ;

  {
#line 1170
  x = (int )screen.col;
#line 1172
  if (count > 0) {
#line 1175
    i = x + 1;
    {
#line 1175
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1175
      if (! (i < (int )TermWin.ncol)) {
#line 1175
        goto while_break;
      }
#line 1177
      if (*(tabs + i)) {
#line 1179
        x = i;
#line 1180
        count --;
#line 1181
        if (! count) {
#line 1182
          goto while_break;
        }
      }
#line 1175
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 1186
  if (count < 0) {
#line 1189
    count = - count;
#line 1190
    i___0 = x - 1;
    {
#line 1190
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1190
      if (! (i___0 >= 0)) {
#line 1190
        goto while_break___0;
      }
#line 1192
      if (*(tabs + i___0)) {
#line 1194
        x = i___0;
#line 1195
        count --;
#line 1196
        if (! count) {
#line 1197
          goto while_break___0;
        }
      }
#line 1190
      i___0 --;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 1202
    return;
  }
#line 1204
  if (x != (int )screen.col) {
    {
#line 1205
    scr_gotorc(0, x, 2);
    }
  }
#line 1206
  return;
}
}
#line 1214 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void scr_gotorc(int row , int col , int relative ) 
{ 
  int roffset ;

  {
#line 1217
  TermWin.view_start = (short)0;
#line 1221
  if (relative & 1) {
#line 1221
    screen.col = (short )((int )screen.col + col);
  } else {
#line 1221
    screen.col = (short )col;
  }
#line 1223
  if ((int )screen.col < 0) {
#line 1224
    screen.col = (short)0;
  } else
#line 1225
  if ((int )screen.col >= (int )TermWin.ncol) {
#line 1226
    screen.col = (short )((int )TermWin.ncol - 1);
  }
#line 1228
  if (screen.flags & (unsigned int )(1 << 4)) {
#line 1230
    roffset = ((int )screen.row + (int )TermWin.saveLines) * ((int )TermWin.ncol + 1);
#line 1231
    *(screen.text + (roffset + (int )TermWin.ncol)) = (text_t )'\000';
#line 1232
    screen.flags &= (unsigned int )(~ (1 << 4));
  }
#line 1235
  if (relative & 2) {
#line 1237
    if (row > 0) {
#line 1239
      if ((int )screen.row <= (int )screen.bscroll) {
#line 1239
        if ((int )screen.row + row > (int )screen.bscroll) {
#line 1241
          screen.row = screen.bscroll;
        } else {
#line 1243
          screen.row = (short )((int )screen.row + row);
        }
      } else {
#line 1243
        screen.row = (short )((int )screen.row + row);
      }
    } else
#line 1245
    if (row < 0) {
#line 1247
      if ((int )screen.row >= (int )screen.tscroll) {
#line 1247
        if ((int )screen.row + row < (int )screen.tscroll) {
#line 1249
          screen.row = screen.tscroll;
        } else {
#line 1251
          screen.row = (short )((int )screen.row + row);
        }
      } else {
#line 1251
        screen.row = (short )((int )screen.row + row);
      }
    }
  } else
#line 1256
  if (screen.flags & 1U) {
#line 1258
    screen.row = (short )(row + (int )screen.tscroll);
#line 1259
    if ((int )screen.row > (int )screen.bscroll) {
#line 1260
      screen.row = screen.bscroll;
    }
  } else {
#line 1263
    screen.row = (short )row;
  }
#line 1265
  if ((int )screen.row < 0) {
#line 1266
    screen.row = (short)0;
  } else
#line 1267
  if ((int )screen.row >= (int )TermWin.nrow) {
#line 1268
    screen.row = (short )((int )TermWin.nrow - 1);
  }
#line 1269
  return;
}
}
#line 1273 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void scr_index(int dirn ) 
{ 
  int roffset ;

  {
#line 1276
  TermWin.view_start = (short)0;
#line 1282
  if (screen.flags & (unsigned int )(1 << 4)) {
#line 1284
    roffset = ((int )screen.row + (int )TermWin.saveLines) * ((int )TermWin.ncol + 1);
#line 1285
    *(screen.text + (roffset + (int )TermWin.ncol)) = (text_t )'\000';
#line 1286
    screen.flags &= (unsigned int )(~ (1 << 4));
  }
#line 1289
  if ((int )screen.row == (int )screen.bscroll) {
#line 1289
    if (dirn == 1) {
      {
#line 1291
      scroll_text((int )screen.tscroll, (int )screen.bscroll, dirn);
      }
    } else {
#line 1289
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1289
  if ((int )screen.row == (int )screen.tscroll) {
#line 1289
    if (dirn == -1) {
      {
#line 1291
      scroll_text((int )screen.tscroll, (int )screen.bscroll, dirn);
      }
    } else {
#line 1293
      screen.row = (short )((int )screen.row + dirn);
    }
  } else {
#line 1293
    screen.row = (short )((int )screen.row + dirn);
  }
#line 1294
  if (selection.op) {
    {
#line 1295
    selection_check();
    }
  }
#line 1296
  return;
}
}
#line 1300 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void scr_erase_line(int mode ) 
{ 
  int count ;
  int roffset ;
  int n ;
  rend_t *p ;
  rend_t *tmp ;
  int tmp___0 ;

  {
#line 1303
  roffset = ((int )screen.row + (int )TermWin.saveLines) * ((int )TermWin.ncol + 1);
#line 1304
  TermWin.view_start = (short)0;
#line 1308
  if (screen.flags & (unsigned int )(1 << 4)) {
#line 1310
    *(screen.text + (roffset + (int )TermWin.ncol)) = (text_t )'\000';
#line 1311
    screen.flags &= (unsigned int )(~ (1 << 4));
  }
  {
#line 1315
  if (mode == 0) {
#line 1315
    goto case_0;
  }
#line 1321
  if (mode == 1) {
#line 1321
    goto case_1;
  }
#line 1326
  if (mode == 2) {
#line 1326
    goto case_2;
  }
#line 1331
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1317
  roffset += (int )screen.col;
#line 1318
  count = (int )TermWin.ncol - (int )screen.col;
#line 1319
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1323
  count = (int )screen.col + 1;
#line 1324
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1328
  count = (int )TermWin.ncol;
#line 1329
  goto switch_break;
  switch_default: /* CIL Label */ ;
#line 1333
  return;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1336
    n = count;
#line 1336
    if (n > 0) {
      {
#line 1336
      p = screen.rend + roffset;
#line 1336
      memset((void *)(screen.text + roffset), ' ', (unsigned long )n * sizeof(text_t ));
      }
      {
#line 1336
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1336
        tmp___0 = n;
#line 1336
        n --;
#line 1336
        if (! (tmp___0 > 0)) {
#line 1336
          goto while_break___0;
        }
#line 1336
        tmp = p;
#line 1336
        p ++;
#line 1336
        *tmp = rstyle;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1336
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1339
  if (selection.op) {
    {
#line 1340
    selection_check();
    }
  }
#line 1341
  return;
}
}
#line 1345 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void scr_erase_screen(int mode ) 
{ 
  int count ;
  int roffset ;

  {
#line 1348
  roffset = (int )TermWin.saveLines * ((int )TermWin.ncol + 1);
#line 1349
  TermWin.view_start = (short)0;
  {
#line 1353
  if (mode == 0) {
#line 1353
    goto case_0;
  }
#line 1360
  if (mode == 1) {
#line 1360
    goto case_1;
  }
#line 1366
  if (mode == 2) {
#line 1366
    goto case_2;
  }
#line 1372
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1355
  scr_erase_line(0);
#line 1356
  count = (int )TermWin.nrow - ((int )screen.row + 1);
#line 1357
  roffset += ((int )screen.row + 1) * ((int )TermWin.ncol + 1);
  }
#line 1358
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1362
  scr_erase_line(1);
#line 1363
  count = (int )screen.row;
  }
#line 1364
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1369
  count = (int )TermWin.nrow;
#line 1370
  goto switch_break;
  switch_default: /* CIL Label */ ;
#line 1374
  return;
#line 1375
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1378
  blank_lines(screen.text + roffset, screen.rend + roffset, count);
  }
#line 1380
  return;
}
}
#line 1384 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void scr_E(void) 
{ 
  int r ;
  int roffset ;

  {
  {
#line 1387
  roffset = (int )TermWin.saveLines * ((int )TermWin.ncol + 1);
#line 1390
  TermWin.view_start = (short)0;
#line 1391
  memset((void *)(screen.text + roffset), 'E', (unsigned long )((int )TermWin.nrow * ((int )TermWin.ncol + 1)) * sizeof(text_t ));
#line 1393
  r = 0;
  }
  {
#line 1393
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1393
    if (! (r < (int )TermWin.nrow)) {
#line 1393
      goto while_break;
    }
#line 1394
    *(screen.text + (roffset + (int )TermWin.ncol)) = (text_t )'\000';
#line 1393
    r ++;
#line 1393
    roffset += (int )TermWin.ncol + 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 1395
  return;
}
}
#line 1406 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void scr_insdel_lines(int count , int insdel ) 
{ 
  int roffset ;

  {
#line 1411
  if ((int )screen.row > (int )screen.bscroll) {
#line 1412
    return;
  }
#line 1414
  if (count > ((int )screen.bscroll - (int )screen.row) + 1) {
#line 1416
    if (insdel == 1) {
#line 1417
      return;
    } else
#line 1418
    if (insdel == -1) {
#line 1419
      count = ((int )screen.bscroll - (int )screen.row) + 1;
    }
  }
#line 1422
  TermWin.view_start = (short)0;
#line 1426
  if (screen.flags & (unsigned int )(1 << 4)) {
#line 1428
    roffset = ((int )screen.row + (int )TermWin.saveLines) * ((int )TermWin.ncol + 1);
#line 1429
    *(screen.text + (roffset + (int )TermWin.ncol)) = (text_t )'\000';
#line 1430
    screen.flags &= (unsigned int )(~ (1 << 4));
  }
  {
#line 1433
  scroll_text((int )screen.row, (int )screen.bscroll, insdel * count);
  }
#line 1434
  return;
}
}
#line 1443 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void scr_insdel_chars(int count , int insdel ) 
{ 
  int roffset ;
  text_t *text ;
  text_t *textend ;
  rend_t *rend ;
  rend_t *rendend ;

  {
#line 1446
  roffset = ((int )screen.row + (int )TermWin.saveLines) * ((int )TermWin.ncol + 1);
#line 1452
  if (insdel == 2) {
#line 1454
    if (count > (int )screen.col) {
#line 1455
      count = (int )screen.col;
    }
#line 1456
    if (count <= 0) {
#line 1457
      return;
    }
#line 1458
    screen.col = (short )((int )screen.col - count);
#line 1459
    insdel = 1;
  } else
#line 1461
  if (count > (int )TermWin.ncol - (int )screen.col) {
#line 1463
    count = (int )TermWin.ncol - (int )screen.col;
  }
#line 1465
  if (count <= 0) {
#line 1466
    return;
  }
#line 1468
  TermWin.view_start = (short)0;
#line 1471
  if (selection.op) {
    {
#line 1472
    selection_check();
    }
  }
#line 1474
  *(screen.text + (roffset + (int )TermWin.ncol)) = (text_t )'\000';
#line 1475
  screen.flags &= (unsigned int )(~ (1 << 4));
#line 1477
  text = screen.text + (roffset + (int )screen.col);
#line 1478
  rend = screen.rend + (roffset + (int )screen.col);
#line 1479
  if (insdel == 1) {
    {
#line 1482
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1482
      if (*text) {
#line 1482
        if (! *(text + count)) {
#line 1482
          goto while_break;
        }
      } else {
#line 1482
        goto while_break;
      }
#line 1484
      *text = *(text + count);
#line 1485
      *rend = *(rend + count);
#line 1482
      text ++;
#line 1482
      rend ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1489
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1489
      if (! *text) {
#line 1489
        goto while_break___0;
      }
#line 1491
      *text = (text_t )' ';
#line 1492
      *rend = rstyle;
#line 1489
      text ++;
#line 1489
      rend ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 1498
    textend = screen.text + (roffset + ((int )TermWin.ncol - 1));
#line 1499
    rendend = screen.rend + (roffset + ((int )TermWin.ncol - 1));
    {
#line 1501
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1501
      if (! ((unsigned long )(textend - count) >= (unsigned long )text)) {
#line 1501
        goto while_break___1;
      }
#line 1503
      *textend = *(textend - count);
#line 1504
      *rendend = *(rendend - count);
#line 1501
      textend --;
#line 1501
      rendend --;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1508
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1508
      if (! ((unsigned long )textend >= (unsigned long )text)) {
#line 1508
        goto while_break___2;
      }
#line 1510
      *textend = (text_t )' ';
#line 1511
      *rendend = rstyle;
#line 1508
      textend --;
#line 1508
      rendend --;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 1514
  return;
}
}
#line 1518 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void scr_scroll_region(int top , int bot ) 
{ 


  {
#line 1521
  if (top < 0) {
#line 1522
    top = 0;
  }
#line 1523
  if (bot >= (int )TermWin.nrow) {
#line 1524
    bot = (int )TermWin.nrow - 1;
  }
#line 1525
  if (top > bot) {
#line 1526
    return;
  }
  {
#line 1528
  screen.tscroll = (short )top;
#line 1529
  screen.bscroll = (short )bot;
#line 1530
  scr_gotorc(0, 0, 0);
  }
#line 1531
  return;
}
}
#line 1535 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void scr_cursor_visible(int mode ) 
{ 


  {
#line 1538
  if (mode) {
#line 1539
    screen.flags |= (unsigned int )(1 << 1);
  } else {
#line 1541
    screen.flags &= (unsigned int )(~ (1 << 1));
  }
#line 1542
  return;
}
}
#line 1545 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void scr_autowrap(int mode ) 
{ 


  {
#line 1548
  if (mode) {
#line 1549
    screen.flags |= (unsigned int )(1 << 2);
  } else {
#line 1551
    screen.flags &= (unsigned int )(~ (1 << 2));
  }
#line 1552
  return;
}
}
#line 1562 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void scr_relative_origin(int mode ) 
{ 


  {
#line 1565
  if (mode) {
#line 1566
    screen.flags |= 1U;
  } else {
#line 1568
    screen.flags &= 4294967294U;
  }
  {
#line 1569
  scr_gotorc(0, 0, 0);
  }
#line 1570
  return;
}
}
#line 1574 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void scr_insert_mode(int mode ) 
{ 


  {
#line 1577
  if (mode) {
#line 1578
    screen.flags |= (unsigned int )(1 << 3);
  } else {
#line 1580
    screen.flags &= (unsigned int )(~ (1 << 3));
  }
#line 1581
  return;
}
}
#line 1589 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
int scr_move_to(int y , int len ) 
{ 
  int start ;

  {
#line 1592
  start = (int )TermWin.view_start;
#line 1594
  TermWin.view_start = (short )(((len - y) * (((int )TermWin.nrow - 1) + (int )TermWin.nscrolled)) / len - ((int )TermWin.nrow - 1));
#line 1597
  if ((int )TermWin.view_start < 0) {
#line 1598
    TermWin.view_start = (short)0;
  } else
#line 1599
  if ((int )TermWin.view_start > (int )TermWin.nscrolled) {
#line 1600
    TermWin.view_start = TermWin.nscrolled;
  }
#line 1605
  return ((int )TermWin.view_start - start);
}
}
#line 1610 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
int scr_page(int dirn , int nlines ) 
{ 
  int start ;

  {
#line 1613
  start = (int )TermWin.view_start;
#line 1615
  if (! dirn) {
#line 1616
    return (0);
  } else
#line 1615
  if (! nlines) {
#line 1616
    return (0);
  }
#line 1618
  if (nlines <= 0) {
#line 1619
    nlines = 1;
  } else
#line 1620
  if (nlines > (int )TermWin.nrow) {
#line 1621
    nlines = (int )TermWin.nrow;
  }
#line 1622
  TermWin.view_start = (short )((int )TermWin.view_start + nlines * dirn);
#line 1624
  if ((int )TermWin.view_start < 0) {
#line 1625
    TermWin.view_start = (short)0;
  } else
#line 1626
  if ((int )TermWin.view_start > (int )TermWin.nscrolled) {
#line 1627
    TermWin.view_start = TermWin.nscrolled;
  }
#line 1632
  return ((int )TermWin.view_start - start);
}
}
#line 1640 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
__inline static void selection_check(void) 
{ 
  int c1 ;
  int c2 ;
  int r1 ;
  int r2 ;

  {
#line 1646
  if ((int )current_screen != (int )selection.screen) {
#line 1647
    return;
  }
#line 1649
  if ((int )selection.mark.row < - ((int )TermWin.nscrolled)) {
    {
#line 1656
    selection_reset();
    }
#line 1657
    return;
  } else
#line 1649
  if ((int )selection.mark.row >= (int )TermWin.nrow) {
    {
#line 1656
    selection_reset();
    }
#line 1657
    return;
  } else
#line 1649
  if ((int )selection.beg.row < - ((int )TermWin.nscrolled)) {
    {
#line 1656
    selection_reset();
    }
#line 1657
    return;
  } else
#line 1649
  if ((int )selection.beg.row >= (int )TermWin.nrow) {
    {
#line 1656
    selection_reset();
    }
#line 1657
    return;
  } else
#line 1649
  if ((int )selection.end.row < - ((int )TermWin.nscrolled)) {
    {
#line 1656
    selection_reset();
    }
#line 1657
    return;
  } else
#line 1649
  if ((int )selection.end.row >= (int )TermWin.nrow) {
    {
#line 1656
    selection_reset();
    }
#line 1657
    return;
  }
#line 1660
  r1 = (int )screen.row - (int )TermWin.view_start;
#line 1661
  c1 = (r1 - (int )selection.mark.row) * (r1 - (int )selection.end.row);
#line 1667
  if (c1 < 0) {
    {
#line 1668
    selection_reset();
    }
  } else
#line 1670
  if (c1 == 0) {
#line 1673
    if ((int )selection.mark.row < (int )selection.end.row) {
#line 1677
      r1 = (int )selection.mark.row;
#line 1678
      c1 = (int )selection.mark.col;
#line 1679
      r2 = (int )selection.end.row;
#line 1680
      c2 = (int )selection.end.col;
    } else
#line 1673
    if ((int )selection.mark.row == (int )selection.end.row) {
#line 1673
      if ((int )selection.mark.col < (int )selection.end.col) {
#line 1677
        r1 = (int )selection.mark.row;
#line 1678
        c1 = (int )selection.mark.col;
#line 1679
        r2 = (int )selection.end.row;
#line 1680
        c2 = (int )selection.end.col;
      } else {
#line 1684
        r1 = (int )selection.end.row;
#line 1685
        c1 = (int )selection.end.col;
#line 1686
        r2 = (int )selection.mark.row;
#line 1687
        c2 = (int )selection.mark.col;
      }
    } else {
#line 1684
      r1 = (int )selection.end.row;
#line 1685
      c1 = (int )selection.end.col;
#line 1686
      r2 = (int )selection.mark.row;
#line 1687
      c2 = (int )selection.mark.col;
    }
#line 1689
    if ((int )screen.row == r1) {
#line 1689
      if ((int )screen.row == r2) {
#line 1691
        if ((int )screen.col >= c1) {
#line 1691
          if ((int )screen.col <= c2) {
            {
#line 1692
            selection_reset();
            }
          }
        }
      } else {
#line 1689
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1694
    if ((int )screen.row == r1) {
#line 1694
      if ((int )screen.col >= c1) {
        {
#line 1696
        selection_reset();
        }
      } else {
#line 1694
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1694
    if ((int )screen.row == r2) {
#line 1694
      if ((int )screen.col <= c2) {
        {
#line 1696
        selection_reset();
        }
      }
    }
  }
#line 1698
  return;
}
}
#line 1718 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void selection_make(Time tm ) 
{ 
  unsigned char *str ;
  int r ;
  int startr ;
  int startc ;
  int endr ;
  int endc ;
  int roffset ;
  void *tmp ;
  int c ;
  int c1 ;
  int tmp___0 ;
  int c2 ;
  int tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned char *tmp___4 ;
  size_t tmp___5 ;
  Window tmp___6 ;

  {
  {
#line 1727
  if ((int )selection.op == 3) {
#line 1727
    goto case_3;
  }
#line 1730
  if ((int )selection.op == 2) {
#line 1730
    goto case_2;
  }
#line 1735
  if ((int )selection.op == 1) {
#line 1735
    goto case_1;
  }
#line 1738
  goto switch_default;
  case_3: /* CIL Label */ 
#line 1728
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1731
  selection_reset();
#line 1732
  selection.mark.row = selection.beg.row;
#line 1732
  selection.end.row = selection.mark.row;
#line 1733
  selection.mark.col = selection.beg.col;
#line 1733
  selection.end.col = selection.mark.col;
  }
  case_1: /* CIL Label */ 
#line 1736
  selection.op = (short)4;
  switch_default: /* CIL Label */ 
#line 1739
  return;
#line 1740
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1742
  selection.op = (short)4;
#line 1744
  my_free((void *)selection.text);
#line 1745
  selection.text = (unsigned char *)((void *)0);
#line 1746
  selection.len = 0;
#line 1748
  selection.screen = current_screen;
  }
#line 1750
  if ((int )selection.end.row < (int )selection.mark.row) {
#line 1754
    startr = (int )selection.end.row;
#line 1755
    endr = (int )selection.mark.row;
#line 1756
    startc = (int )selection.end.col;
#line 1757
    endc = (int )selection.mark.col;
  } else
#line 1750
  if ((int )selection.end.row == (int )selection.mark.row) {
#line 1750
    if ((int )selection.end.col <= (int )selection.mark.col) {
#line 1754
      startr = (int )selection.end.row;
#line 1755
      endr = (int )selection.mark.row;
#line 1756
      startc = (int )selection.end.col;
#line 1757
      endc = (int )selection.mark.col;
    } else {
#line 1761
      startr = (int )selection.mark.row;
#line 1762
      endr = (int )selection.end.row;
#line 1763
      startc = (int )selection.mark.col;
#line 1764
      endc = (int )selection.end.col;
    }
  } else {
#line 1761
    startr = (int )selection.mark.row;
#line 1762
    endr = (int )selection.end.row;
#line 1763
    startc = (int )selection.mark.col;
#line 1764
    endc = (int )selection.end.col;
  }
#line 1767
  if (startr < - ((int )TermWin.nscrolled)) {
    {
#line 1769
    selection_reset();
    }
#line 1770
    return;
  } else
#line 1767
  if (endr >= (int )TermWin.nrow) {
    {
#line 1769
    selection_reset();
    }
#line 1770
    return;
  }
  {
#line 1773
  tmp = my_malloc((unsigned long )(((endr - startr) + 1) * ((int )TermWin.ncol + 1) + 1) * sizeof(char ));
#line 1773
  str = (unsigned char *)tmp;
#line 1775
  selection.text = str;
#line 1776
  *str = (unsigned char )'\000';
#line 1779
  roffset = (startr + (int )TermWin.saveLines) * ((int )TermWin.ncol + 1);
#line 1780
  r = startr;
  }
  {
#line 1780
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1780
    if (! (r <= endr)) {
#line 1780
      goto while_break;
    }
#line 1783
    if (r == startr) {
#line 1783
      tmp___0 = startc;
    } else {
#line 1783
      tmp___0 = 0;
    }
#line 1783
    c1 = tmp___0;
#line 1784
    if (r == endr) {
#line 1784
      tmp___1 = endc;
    } else {
#line 1784
      tmp___1 = (int )TermWin.ncol - 1;
    }
#line 1784
    c2 = tmp___1;
#line 1792
    c = c1;
    {
#line 1792
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1792
      if (! (c <= c2)) {
#line 1792
        goto while_break___0;
      }
#line 1793
      tmp___2 = str;
#line 1793
      str ++;
#line 1793
      *tmp___2 = *(screen.text + (roffset + c));
#line 1792
      c ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1799
    if (c2 == (int )TermWin.ncol - 1) {
#line 1799
      if (! *(screen.text + (roffset + (int )TermWin.ncol))) {
#line 1801
        str --;
#line 1802
        c = c2;
        {
#line 1802
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1802
          if (c >= c1) {
            {
#line 1802
            tmp___3 = __ctype_b_loc();
            }
#line 1802
            if (! ((int const   )*(*tmp___3 + (int )*str) & 8192)) {
#line 1802
              goto while_break___1;
            }
          } else {
#line 1802
            goto while_break___1;
          }
#line 1803
          str --;
#line 1802
          c --;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1804
        str ++;
#line 1805
        tmp___4 = str;
#line 1805
        str ++;
#line 1805
        *tmp___4 = (unsigned char )'\n';
      }
    }
#line 1780
    r ++;
#line 1780
    roffset += (int )TermWin.ncol + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1808
  *str = (unsigned char )'\000';
#line 1810
  tmp___5 = strlen((char const   *)((char *)selection.text));
#line 1810
  selection.len = (int )tmp___5;
  }
#line 1811
  if (selection.len <= 0) {
#line 1812
    return;
  }
  {
#line 1813
  XSetSelectionOwner(Xdisplay, (Atom )1, TermWin.vt, tm);
#line 1814
  tmp___6 = XGetSelectionOwner(Xdisplay, (Atom )1);
  }
#line 1814
  if (tmp___6 != TermWin.vt) {
    {
#line 1815
    print_error("can\'t get primary selection");
    }
  }
  {
#line 1818
  XChangeProperty(Xdisplay, (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root,
                  (Atom )9, (Atom )31, 8, 0, (unsigned char const   *)selection.text,
                  selection.len);
  }
#line 1821
  return;
}
}
#line 1829 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
static Atom xa_targets  =    (Atom )0L;
#line 1825 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void selection_send(XSelectionRequestEvent *rq ) 
{ 
  XEvent ev ;
  Atom32 target_list[2] ;

  {
#line 1830
  if (xa_targets == 0UL) {
    {
#line 1831
    xa_targets = XInternAtom(Xdisplay, "TARGETS", 0);
    }
  }
#line 1833
  ev.xselection.type = 31;
#line 1834
  ev.xselection.property = (Atom )0L;
#line 1835
  ev.xselection.display = rq->display;
#line 1836
  ev.xselection.requestor = rq->requestor;
#line 1837
  ev.xselection.selection = rq->selection;
#line 1838
  ev.xselection.target = rq->target;
#line 1839
  ev.xselection.time = rq->time;
#line 1841
  if (rq->target == xa_targets) {
    {
#line 1852
    target_list[0] = (Atom32 )xa_targets;
#line 1853
    target_list[1] = (Atom32 )((Atom )31);
#line 1855
    XChangeProperty(Xdisplay, rq->requestor, rq->property, xa_targets, (int )(8UL * sizeof(target_list[0])),
                    0, (unsigned char const   *)((unsigned char *)(target_list)),
                    (int )(sizeof(target_list) / sizeof(target_list[0])));
#line 1859
    ev.xselection.property = rq->property;
    }
  } else
#line 1861
  if (rq->target == 31UL) {
    {
#line 1863
    XChangeProperty(Xdisplay, rq->requestor, rq->property, (Atom )31, 8, 0, (unsigned char const   *)selection.text,
                    selection.len);
#line 1866
    ev.xselection.property = rq->property;
    }
  }
  {
#line 1868
  XSendEvent(Xdisplay, rq->requestor, 0, 0L, & ev);
  }
#line 1869
  return;
}
}
#line 1873 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
static void PasteIt(unsigned char const   *data , unsigned int nitems ) 
{ 
  unsigned char const   *p ;
  unsigned char const   *pmax ;
  unsigned char cr ;

  {
#line 1876
  p = data;
#line 1876
  pmax = data + nitems;
#line 1878
  nitems = 0U;
  {
#line 1878
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1878
    if (! ((unsigned long )p < (unsigned long )pmax)) {
#line 1878
      goto while_break;
    }
#line 1881
    if ((int const   )*p == 10) {
      {
#line 1883
      cr = (unsigned char )'\r';
#line 1884
      tt_write(data, nitems);
#line 1885
      tt_write((unsigned char const   *)(& cr), 1U);
#line 1886
      data += nitems + 1U;
#line 1887
      nitems = 0U;
      }
    } else {
#line 1890
      nitems ++;
    }
#line 1878
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1892
  if (nitems) {
    {
#line 1893
    tt_write(data, nitems);
    }
  }
#line 1894
  return;
}
}
#line 1899 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void selection_paste(Window win , unsigned int prop , int Delete ) 
{ 
  unsigned long nread ;
  unsigned long bytes_after ;
  unsigned char *data ;
  Atom actual_type ;
  int actual_fmt ;
  unsigned long nitems ;
  int tmp ;

  {
#line 1904
  if ((long )prop == 0L) {
#line 1905
    return;
  }
#line 1907
  nread = 0UL;
  {
#line 1908
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1915
    tmp = XGetWindowProperty(Xdisplay, win, (Atom )prop, (long )(nread / 4UL), 4096L,
                             Delete, (Atom )0L, & actual_type, & actual_fmt, & nitems,
                             & bytes_after, & data);
    }
#line 1915
    if (tmp != 0) {
      {
#line 1922
      XFree((void *)data);
      }
#line 1923
      return;
    } else
#line 1915
    if (actual_type != 31UL) {
      {
#line 1922
      XFree((void *)data);
      }
#line 1923
      return;
    }
    {
#line 1926
    nread += nitems;
#line 1927
    PasteIt((unsigned char const   *)data, (unsigned int )nitems);
#line 1929
    XFree((void *)data);
    }
#line 1908
    if (! (bytes_after > 0UL)) {
#line 1908
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1932
  return;
}
}
#line 1936 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void selection_request(Time tm , int x , int y ) 
{ 
  Atom prop ;
  Atom tmp ;
  Window tmp___0 ;

  {
#line 1940
  if (x < 0) {
#line 1941
    return;
  } else
#line 1940
  if (y < 0) {
#line 1941
    return;
  } else
#line 1940
  if (x >= (int )TermWin.width) {
#line 1941
    return;
  } else
#line 1940
  if (y >= (int )TermWin.height) {
#line 1941
    return;
  }
#line 1943
  if ((unsigned long )selection.text != (unsigned long )((void *)0)) {
    {
#line 1946
    PasteIt((unsigned char const   *)selection.text, (unsigned int )selection.len);
    }
  } else {
    {
#line 1948
    tmp___0 = XGetSelectionOwner(Xdisplay, (Atom )1);
    }
#line 1948
    if (tmp___0 == 0UL) {
      {
#line 1951
      selection_paste((((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root,
                      (unsigned int )((Atom )9), 0);
      }
    } else {
      {
#line 1955
      tmp = XInternAtom(Xdisplay, "VT_SELECTION", 0);
#line 1955
      prop = tmp;
#line 1956
      XConvertSelection(Xdisplay, (Atom )1, (Atom )31, prop, TermWin.vt, tm);
      }
    }
  }
#line 1959
  return;
}
}
#line 1963 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void selection_reset(void) 
{ 
  int x ;
  int nrow ;

  {
#line 1966
  nrow = (int )TermWin.nrow;
#line 1968
  selection.op = (short)0;
#line 1969
  selection.mark.row = (short)0;
#line 1969
  selection.end.row = selection.mark.row;
#line 1970
  selection.mark.col = (short)0;
#line 1970
  selection.end.col = selection.mark.col;
#line 1972
  if ((int )current_screen == 0) {
#line 1973
    nrow += (int )TermWin.saveLines;
  }
#line 1975
  x = 0;
  {
#line 1975
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1975
    if (! (x < nrow * ((int )TermWin.ncol + 1))) {
#line 1975
      goto while_break;
    }
#line 1976
    *(screen.rend + x) &= 4261412863U;
#line 1975
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1977
  return;
}
}
#line 1979 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void selection_clear(void) 
{ 


  {
  {
#line 1982
  my_free((void *)selection.text);
#line 1983
  selection.text = (unsigned char *)((void *)0);
#line 1984
  selection.len = 0;
#line 1986
  selection.op = (short)0;
#line 1987
  selection_reset();
  }
#line 1988
  return;
}
}
#line 1992 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
static void selection_setclr(int set , int startr , int startc , int endr , int endc ) 
{ 
  int r ;
  int roffset ;
  int c1 ;
  int tmp ;
  int c2 ;
  int tmp___0 ;

  {
#line 1995
  roffset = (startr + (int )TermWin.saveLines) * ((int )TermWin.ncol + 1);
#line 1998
  if (startr < - ((int )TermWin.nscrolled)) {
    {
#line 2000
    selection_reset();
    }
#line 2001
    return;
  } else
#line 1998
  if (endr >= (int )TermWin.nrow) {
    {
#line 2000
    selection_reset();
    }
#line 2001
    return;
  }
#line 2004
  r = startr;
  {
#line 2004
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2004
    if (! (r <= endr)) {
#line 2004
      goto while_break;
    }
#line 2006
    if (r == startr) {
#line 2006
      tmp = startc;
    } else {
#line 2006
      tmp = 0;
    }
#line 2006
    c1 = tmp;
#line 2007
    if (r == endr) {
#line 2007
      tmp___0 = endc;
    } else {
#line 2007
      tmp___0 = (int )TermWin.ncol - 1;
    }
#line 2007
    c2 = tmp___0;
    {
#line 2015
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2015
      if (! (c1 <= c2)) {
#line 2015
        goto while_break___0;
      }
#line 2017
      if (set) {
#line 2018
        *(screen.rend + (roffset + c1)) |= 33554432U;
      } else {
#line 2020
        *(screen.rend + (roffset + c1)) &= 4261412863U;
      }
#line 2015
      c1 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2022
    roffset += (int )TermWin.ncol + 1;
#line 2004
    r ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2024
  return;
}
}
#line 2028 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
static void selection_start_colrow(int col , int row ) 
{ 


  {
#line 2031
  if (selection.op) {
#line 2034
    if ((int )selection.end.row < - ((int )TermWin.nscrolled)) {
      {
#line 2037
      selection_reset();
      }
    } else
#line 2034
    if ((int )selection.mark.row < - ((int )TermWin.nscrolled)) {
      {
#line 2037
      selection_reset();
      }
    } else
#line 2042
    if ((int )selection.end.row < (int )selection.mark.row) {
      {
#line 2045
      selection_setclr(0, (int )selection.end.row, (int )selection.end.col, (int )selection.mark.row,
                       (int )selection.mark.col);
      }
    } else
#line 2042
    if ((int )selection.end.row == (int )selection.mark.row) {
#line 2042
      if ((int )selection.end.col <= (int )selection.mark.col) {
        {
#line 2045
        selection_setclr(0, (int )selection.end.row, (int )selection.end.col, (int )selection.mark.row,
                         (int )selection.mark.col);
        }
      } else {
        {
#line 2049
        selection_setclr(0, (int )selection.mark.row, (int )selection.mark.col, (int )selection.end.row,
                         (int )selection.end.col);
        }
      }
    } else {
      {
#line 2049
      selection_setclr(0, (int )selection.mark.row, (int )selection.mark.col, (int )selection.end.row,
                       (int )selection.end.col);
      }
    }
  }
#line 2054
  selection.op = (short)2;
#line 2056
  selection.beg.col = (short )col;
#line 2057
  selection.beg.row = (short )row;
#line 2058
  selection.beg.row = (short )((int )selection.beg.row - (int )TermWin.view_start);
#line 2059
  return;
}
}
#line 2064 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void selection_start(int x , int y ) 
{ 
  int tmp ;

  {
  {
#line 2068
  tmp = ThaiPixel2Col(x, y);
#line 2068
  selection_start_colrow(tmp, (y - 2) / (int )TermWin.fheight);
  }
#line 2072
  return;
}
}
#line 2076 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
static void selection_extend_colrow(int col , int row ) 
{ 
  int old_row ;
  int old_col ;
  int old_dirn ;
  int dirn ;

  {
  {
#line 2083
  if ((int )selection.op == 2) {
#line 2083
    goto case_2;
  }
#line 2088
  if ((int )selection.op == 1) {
#line 2088
    goto case_1;
  }
#line 2093
  if ((int )selection.op == 3) {
#line 2093
    goto case_3;
  }
#line 2093
  if ((int )selection.op == 4) {
#line 2093
    goto case_3;
  }
#line 2097
  if ((int )selection.op == 0) {
#line 2097
    goto case_0;
  }
#line 2100
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 2084
  selection_reset();
#line 2085
  selection.mark.col = selection.beg.col;
#line 2085
  selection.end.col = selection.mark.col;
#line 2086
  selection.mark.row = selection.beg.row;
#line 2086
  selection.end.row = selection.mark.row;
  }
  case_1: /* CIL Label */ 
#line 2089
  selection.op = (short)1;
#line 2090
  goto switch_break;
  case_3: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 2094
  selection.op = (short)3;
#line 2095
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 2098
  selection_start_colrow(col, row);
  }
  switch_default: /* CIL Label */ 
#line 2101
  return;
#line 2102
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2106
  old_row = (int )selection.end.row;
#line 2107
  old_col = (int )selection.end.col;
#line 2109
  if (old_row < - ((int )TermWin.nscrolled)) {
    {
#line 2112
    selection_reset();
    }
#line 2113
    return;
  } else
#line 2109
  if ((int )selection.mark.row < - ((int )TermWin.nscrolled)) {
    {
#line 2112
    selection_reset();
    }
#line 2113
    return;
  }
#line 2117
  selection.end.col = (short )col;
#line 2118
  selection.end.row = (short )row;
#line 2120
  if ((int )selection.end.col < 0) {
#line 2121
    selection.end.col = (short)0;
  } else
#line 2122
  if ((int )selection.end.col >= (int )TermWin.ncol) {
#line 2123
    selection.end.col = (short )((int )TermWin.ncol - 1);
  }
#line 2125
  selection.end.row = (short )((int )selection.end.row - (int )TermWin.view_start);
#line 2126
  if ((int )selection.end.row < - ((int )TermWin.nscrolled)) {
    {
#line 2128
    selection_reset();
    }
#line 2129
    return;
  } else
#line 2131
  if ((int )selection.end.row >= (int )TermWin.nrow) {
#line 2132
    selection.end.row = (short )((int )TermWin.nrow - 1);
  }
#line 2134
  if ((int )selection.op == 1) {
#line 2134
    if ((int )selection.end.col != (int )selection.mark.col) {
#line 2137
      selection.op = (short)3;
    } else
#line 2134
    if ((int )selection.end.row != (int )selection.mark.row) {
#line 2137
      selection.op = (short)3;
    }
  }
#line 2142
  if ((int )selection.end.row == old_row) {
#line 2142
    if ((int )selection.end.col == old_col) {
#line 2143
      return;
    }
  }
#line 2148
  if (old_row < (int )selection.mark.row) {
#line 2148
    old_dirn = 1;
  } else
#line 2148
  if (old_row == (int )selection.mark.row) {
#line 2148
    if (old_col <= (int )selection.mark.col) {
#line 2148
      old_dirn = 1;
    } else {
#line 2148
      old_dirn = -1;
    }
  } else {
#line 2148
    old_dirn = -1;
  }
#line 2153
  if ((int )selection.end.row < (int )selection.mark.row) {
#line 2153
    dirn = 1;
  } else
#line 2153
  if ((int )selection.end.row == (int )selection.mark.row) {
#line 2153
    if ((int )selection.end.col <= (int )selection.mark.col) {
#line 2153
      dirn = 1;
    } else {
#line 2153
      dirn = -1;
    }
  } else {
#line 2153
    dirn = -1;
  }
#line 2158
  if (dirn != old_dirn) {
#line 2160
    if (old_dirn == 1) {
      {
#line 2162
      selection_setclr(0, old_row, old_col, (int )selection.mark.row, (int )selection.mark.col);
#line 2165
      selection_setclr(1, (int )selection.mark.row, (int )selection.mark.col, (int )selection.end.row,
                       (int )selection.end.col);
      }
    } else {
      {
#line 2171
      selection_setclr(0, (int )selection.mark.row, (int )selection.mark.col, old_row,
                       old_col);
#line 2174
      selection_setclr(1, (int )selection.end.row, (int )selection.end.col, (int )selection.mark.row,
                       (int )selection.mark.col);
      }
    }
  } else
#line 2181
  if (old_dirn == 1) {
#line 2183
    if (old_row < (int )selection.end.row) {
      {
#line 2187
      selection_setclr(0, old_row, old_col, (int )selection.end.row, (int )selection.end.col);
#line 2190
      selection_setclr(1, (int )selection.end.row, (int )selection.end.col, (int )selection.end.row,
                       (int )selection.end.col);
      }
    } else
#line 2183
    if (old_row == (int )selection.end.row) {
#line 2183
      if (old_col < (int )selection.end.col) {
        {
#line 2187
        selection_setclr(0, old_row, old_col, (int )selection.end.row, (int )selection.end.col);
#line 2190
        selection_setclr(1, (int )selection.end.row, (int )selection.end.col, (int )selection.end.row,
                         (int )selection.end.col);
        }
      } else {
        {
#line 2196
        selection_setclr(1, (int )selection.end.row, (int )selection.end.col, old_row,
                         old_col);
        }
      }
    } else {
      {
#line 2196
      selection_setclr(1, (int )selection.end.row, (int )selection.end.col, old_row,
                       old_col);
      }
    }
  } else
#line 2203
  if ((int )selection.end.row < old_row) {
    {
#line 2207
    selection_setclr(0, (int )selection.end.row, (int )selection.end.col, old_row,
                     old_col);
#line 2210
    selection_setclr(1, (int )selection.end.row, (int )selection.end.col, (int )selection.end.row,
                     (int )selection.end.col);
    }
  } else
#line 2203
  if ((int )selection.end.row == old_row) {
#line 2203
    if ((int )selection.end.col < old_col) {
      {
#line 2207
      selection_setclr(0, (int )selection.end.row, (int )selection.end.col, old_row,
                       old_col);
#line 2210
      selection_setclr(1, (int )selection.end.row, (int )selection.end.col, (int )selection.end.row,
                       (int )selection.end.col);
      }
    } else {
      {
#line 2216
      selection_setclr(1, old_row, old_col, (int )selection.end.row, (int )selection.end.col);
      }
    }
  } else {
    {
#line 2216
    selection_setclr(1, old_row, old_col, (int )selection.end.row, (int )selection.end.col);
    }
  }
#line 2222
  return;
}
}
#line 2227 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void selection_extend(int x , int y ) 
{ 
  int tmp ;

  {
  {
#line 2231
  tmp = ThaiPixel2Col2(x, y);
#line 2231
  selection_extend_colrow(tmp, (y - 2) / (int )TermWin.fheight);
  }
#line 2235
  return;
}
}
#line 2243 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void selection_click(int clicks___0 , int x , int y ) 
{ 
  int beg_c ;
  int end_c ;
  int beg_r ;
  int end_r ;
  text_t *text ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 2246
  if (clicks___0 <= 1) {
    {
#line 2248
    selection_start(x, y);
    }
  } else {
    {
#line 2257
    x = ThaiPixel2Col(x, y);
    }
#line 2261
    if (x <= 0) {
#line 2261
      x = 0;
    } else {
#line 2261
      if (x >= (int )TermWin.ncol) {
#line 2261
        tmp = (int )TermWin.ncol - 1;
      } else {
#line 2261
        tmp = x;
      }
#line 2261
      x = tmp;
    }
#line 2262
    end_c = x;
#line 2262
    beg_c = end_c;
#line 2264
    y = (y - 2) / (int )TermWin.fheight;
#line 2265
    if (y <= 0) {
#line 2265
      y = 0;
    } else {
#line 2265
      if (y >= (int )TermWin.nrow) {
#line 2265
        tmp___0 = (int )TermWin.nrow - 1;
      } else {
#line 2265
        tmp___0 = y;
      }
#line 2265
      y = tmp___0;
    }
#line 2266
    end_r = y;
#line 2266
    beg_r = end_r;
    {
#line 2270
    if (clicks___0 == 3) {
#line 2270
      goto case_3;
    }
#line 2278
    if (clicks___0 == 2) {
#line 2278
      goto case_2;
    }
#line 2321
    goto switch_default;
    case_3: /* CIL Label */ 
#line 2274
    beg_c = 0;
#line 2275
    end_c = (int )TermWin.ncol - 1;
#line 2276
    goto switch_break;
    case_2: /* CIL Label */ 
#line 2282
    text = screen.text + ((beg_r + (int )TermWin.saveLines) - (int )TermWin.view_start) * ((int )TermWin.ncol + 1);
    {
#line 2282
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 2288
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2288
        if (beg_c > 0) {
          {
#line 2288
          tmp___1 = strchr(rs_cutchars, (int )*(text + (beg_c - 1)));
          }
#line 2288
          if (tmp___1) {
#line 2288
            goto while_break___0;
          }
        } else {
#line 2288
          goto while_break___0;
        }
#line 2290
        beg_c --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2292
      if (beg_c == 0) {
#line 2292
        if (beg_r > (int )TermWin.view_start - (int )TermWin.nscrolled) {
#line 2292
          if ((int )*(text - 1) == 10) {
            {
#line 2292
            tmp___2 = strchr(rs_cutchars, (int )*(text - 2));
            }
#line 2292
            if (tmp___2) {
#line 2298
              goto while_break;
            } else {
#line 2296
              beg_c = (int )TermWin.ncol - 1;
            }
          } else {
#line 2298
            goto while_break;
          }
        } else {
#line 2298
          goto while_break;
        }
      } else {
#line 2298
        goto while_break;
      }
#line 2282
      beg_r --;
#line 2282
      text -= (int )TermWin.ncol + 1;
    }
    while_break: /* CIL Label */ ;
    }
#line 2301
    text = screen.text + ((end_r + (int )TermWin.saveLines) - (int )TermWin.view_start) * ((int )TermWin.ncol + 1);
    {
#line 2301
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 2307
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2307
        if (end_c < (int )TermWin.ncol - 1) {
          {
#line 2307
          tmp___3 = strchr(rs_cutchars, (int )*(text + (end_c + 1)));
          }
#line 2307
          if (tmp___3) {
#line 2307
            goto while_break___2;
          }
        } else {
#line 2307
          goto while_break___2;
        }
#line 2309
        end_c ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 2311
      if (end_c == (int )TermWin.ncol - 1) {
#line 2311
        if (end_r < ((int )TermWin.view_start + (int )TermWin.nrow) - 1) {
#line 2311
          if ((int )*(text + TermWin.ncol) == 10) {
            {
#line 2311
            tmp___4 = strchr(rs_cutchars, (int )*(text + ((int )TermWin.ncol + 1)));
            }
#line 2311
            if (tmp___4) {
#line 2317
              goto while_break___1;
            } else {
#line 2315
              end_c = 0;
            }
          } else {
#line 2317
            goto while_break___1;
          }
        } else {
#line 2317
          goto while_break___1;
        }
      } else {
#line 2317
        goto while_break___1;
      }
#line 2301
      end_r ++;
#line 2301
      text += (int )TermWin.ncol + 1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2319
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2322
    return;
#line 2323
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 2325
    selection_start_colrow(beg_c, beg_r);
#line 2326
    selection_extend_colrow(end_c, end_r);
    }
  }
#line 2328
  return;
}
}
#line 2332 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void scr_report_position(void) 
{ 


  {
  {
#line 2335
  tt_printf("\033[%d;%dR", (int )screen.row + 1, (int )screen.col + 1);
  }
#line 2336
  return;
}
}
#line 2340 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void scr_get_position(int *prow , int *pcol ) 
{ 


  {
#line 2342
  *prow = (int )screen.row;
#line 2343
  *pcol = (int )screen.col;
#line 2344
  return;
}
}
#line 2345 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
unsigned char scr_get_char_rc(int row , int col ) 
{ 
  int tmp ;

  {
#line 2347
  if (0 <= row) {
#line 2347
    if (row < (int )TermWin.nrow) {
#line 2347
      if (0 <= col) {
#line 2347
        if (col < (int )TermWin.ncol) {
#line 2347
          tmp = (int )*(screen.text + ((row + (int )TermWin.saveLines) * ((int )TermWin.ncol + 1) + col));
        } else {
#line 2347
          tmp = '\000';
        }
      } else {
#line 2347
        tmp = '\000';
      }
    } else {
#line 2347
      tmp = '\000';
    }
  } else {
#line 2347
    tmp = '\000';
  }
#line 2347
  return ((unsigned char )tmp);
}
}
#line 2357 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void scr_charset_choose(int set ) 
{ 


  {
  {
#line 2360
  screen.charset = (short )set;
#line 2361
  set_font_style();
  }
#line 2362
  return;
}
}
#line 2367 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void scr_charset_set(int set , unsigned int ch ) 
{ 


  {
  {
#line 2374
  charsets[set] = (char )((unsigned char )ch);
#line 2375
  set_font_style();
  }
#line 2376
  return;
}
}
#line 2430 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void scr_expose(int x , int y , int width , int height ) 
{ 
  int row ;
  int end_row ;
  int row_y ;
  int col ;
  int end_col ;
  int roffset ;
  int rwidth ;

  {
#line 2435
  if ((unsigned long )drawn_text == (unsigned long )((void *)0)) {
#line 2436
    return;
  }
#line 2440
  row = (y - 2) / (int )TermWin.fheight;
#line 2441
  if (row < 0) {
#line 2441
    row = 0;
  } else
#line 2442
  if (row >= (int )TermWin.nrow) {
#line 2442
    row = (int )TermWin.nrow - 1;
  }
#line 2444
  end_row = (row + 1) + height / (int )TermWin.fheight;
#line 2445
  if (end_row >= (int )TermWin.nrow) {
#line 2445
    end_row = (int )TermWin.nrow - 1;
  }
  {
#line 2447
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2447
    if (! (row <= end_row)) {
#line 2447
      goto while_break;
    }
    {
#line 2451
    row_y = row * (int )TermWin.fheight + 2;
#line 2453
    col = ThaiPixel2Col(x, row_y);
    }
#line 2454
    if (col < 0) {
#line 2454
      col = 0;
    } else
#line 2455
    if (col >= (int )TermWin.ncol) {
#line 2455
      col = (int )TermWin.ncol - 1;
    }
    {
#line 2457
    end_col = ThaiPixel2Col(x + width, row_y);
    }
#line 2458
    if (end_col < 0) {
#line 2458
      col = 0;
    } else
#line 2459
    if (end_col >= (int )TermWin.ncol) {
#line 2459
      end_col = (int )TermWin.ncol - 1;
    }
    {
#line 2461
    rwidth = (end_col - col) + 1;
#line 2462
    roffset = col + row * ((int )TermWin.ncol + 1);
#line 2463
    memset((void *)(drawn_text + roffset), 0, (unsigned long )rwidth * sizeof(text_t ));
#line 2464
    memset((void *)(drawn_rend + roffset), 0, (unsigned long )rwidth * sizeof(rend_t ));
#line 2447
    row ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2466
  return;
}
}
#line 2471 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void scr_touch(void) 
{ 


  {
  {
#line 2474
  scr_expose(0, 0, (int )TermWin.width, (int )TermWin.height);
  }
#line 2475
  return;
}
}
#line 2508 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
static int last_xcursor  =    0;
#line 2490 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void scr_refresh(int type ) 
{ 
  int r ;
  int roffset ;
  int doffset ;
  int xcursor ;
  int c ;
  int ypixel ;
  int *thai_check ;
  unsigned long __lengthofthai_check ;
  void *tmp ;
  int *thai_mcol ;
  unsigned long __lengthofthai_mcol ;
  void *tmp___0 ;
  int thai_mcolcount ;
  int thai_len ;
  int tmp___1 ;
  int tmp___2 ;
  int count ;
  int x ;
  int x1 ;
  int fore ;
  int back ;
  int rend ;
  XGCValues gcvalue ;
  unsigned long gcmask ;
  int outlineCursor ;
  int xpixel ;
  int tmp___3 ;
  unsigned char *start_text ;
  int rvid ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int height ;
  int top ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 2514
  if (type == 2) {
#line 2515
    return;
  }
#line 2519
  if (last_xcursor < (int )TermWin.nrow * ((int )TermWin.ncol + 1)) {
#line 2522
    *(drawn_rend + last_xcursor) = 4286611456U;
  }
#line 2525
  xcursor = ((int )screen.row + (int )TermWin.saveLines) * ((int )TermWin.ncol + 1) + (int )screen.col;
#line 2527
  last_xcursor = (int )screen.row + (int )TermWin.view_start;
#line 2528
  if (last_xcursor >= (int )TermWin.nrow) {
#line 2530
    last_xcursor = 0;
  } else {
#line 2534
    last_xcursor *= (int )TermWin.ncol + 1;
#line 2535
    if (screen.flags & (unsigned int )(1 << 1)) {
#line 2537
      *(screen.rend + xcursor) |= 16777216U;
    }
  }
#line 2544
  last_xcursor += (int )screen.col;
#line 2646
  doffset = 0;
#line 2647
  roffset = doffset + ((int )TermWin.saveLines - (int )TermWin.view_start) * ((int )TermWin.ncol + 1);
#line 2650
  r = 0;
  {
#line 2650
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2650
    if (! (r < (int )TermWin.nrow)) {
#line 2650
      goto while_break;
    }
    {
#line 2657
    ypixel = (TermWin.font)->ascent + (r * (int )TermWin.fheight + 2);
#line 2659
    __lengthofthai_check = (unsigned long )((int )TermWin.ncol + 1);
#line 2659
    tmp = __builtin_alloca(sizeof(*thai_check) * __lengthofthai_check);
#line 2659
    thai_check = (int *)tmp;
#line 2660
    __lengthofthai_mcol = (unsigned long )((int )TermWin.ncol + 1);
#line 2660
    tmp___0 = __builtin_alloca(sizeof(*thai_mcol) * __lengthofthai_mcol);
#line 2660
    thai_mcol = (int *)tmp___0;
#line 2667
    tmp___1 = memcmp((void const   *)(drawn_text + doffset), (void const   *)(screen.text + roffset),
                     (unsigned long )TermWin.ncol * sizeof(text_t ));
    }
#line 2667
    if (! tmp___1) {
      {
#line 2667
      tmp___2 = memcmp((void const   *)(drawn_rend + doffset), (void const   *)(screen.rend + roffset),
                       (unsigned long )TermWin.ncol * sizeof(rend_t ));
      }
#line 2667
      if (! tmp___2) {
#line 2673
        goto __Cont;
      }
    }
    {
#line 2678
    thai_len = thai_compare(drawn_text + doffset, screen.text + roffset, drawn_rend + doffset,
                            screen.rend + roffset, thai_check, thai_mcol, & thai_mcolcount);
    }
#line 2681
    if (thai_mcolcount) {
      {
#line 2683
      thai_complexclear(thai_mcol, ypixel);
      }
    } else
#line 2686
    if (thai_len < (int )TermWin.ncol) {
      {
#line 2687
      thai_clearline(thai_len, (int )TermWin.ncol, ypixel);
      }
    }
#line 2691
    c = 0;
    {
#line 2691
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2691
      if (! (c < (int )TermWin.ncol)) {
#line 2691
        goto while_break___0;
      }
#line 2694
      x = roffset + c;
#line 2695
      x1 = doffset + c;
#line 2706
      if (*(thai_check + c)) {
#line 2706
        goto _L;
      } else
#line 2706
      if (*(drawn_rend + x1) != *(screen.rend + x)) {
        _L: /* CIL Label */ 
        {
#line 2713
        gcmask = 0UL;
#line 2714
        outlineCursor = 0;
#line 2716
        tmp___3 = ThaiCol2Pixel(c, screen.text + roffset);
#line 2716
        xpixel = tmp___3;
#line 2717
        start_text = screen.text + (roffset + c);
#line 2722
        *(drawn_text + x1) = *(screen.text + x);
#line 2723
        *(drawn_rend + x1) = *(screen.rend + x);
#line 2724
        *(linebuf + 0) = *(screen.text + x);
#line 2725
        rend = (int )*(screen.rend + x);
#line 2727
        x ++;
#line 2728
        c ++;
#line 2729
        count = 1;
        }
        {
#line 2729
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2729
          if (c < (int )TermWin.ncol) {
#line 2729
            if ((rend_t )rend == *(screen.rend + x)) {
#line 2729
              if (! ((int )*(drawn_text + (doffset + c)) != (int )*(screen.text + x))) {
#line 2729
                if (! (*(drawn_rend + (doffset + c)) != *(screen.rend + x))) {
#line 2729
                  if (c + 1 < (int )TermWin.ncol) {
#line 2729
                    if (! ((int )*(drawn_text + ((doffset + c) + 1)) != (int )*(screen.text + (x + 1)))) {
#line 2729
                      goto while_break___1;
                    }
                  } else {
#line 2729
                    goto while_break___1;
                  }
                }
              }
            } else {
#line 2729
              goto while_break___1;
            }
          } else {
#line 2729
            goto while_break___1;
          }
#line 2746
          *(drawn_text + (doffset + c)) = *(screen.text + x);
#line 2747
          *(drawn_rend + (doffset + c)) = *(screen.rend + x);
#line 2748
          *(linebuf + count) = *(screen.text + x);
#line 2750
          if (thai_spcount) {
#line 2750
            if ((int )*(linebuf + count) != 32) {
#line 2750
              if ((int )*(linebuf + (count - 1)) == 32) {
#line 2752
                goto while_break___1;
              }
            }
          }
#line 2729
          count ++;
#line 2729
          x ++;
#line 2729
          c ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 2756
        c --;
#line 2757
        *(linebuf + count) = (text_t )'\000';
#line 2781
        fore = (int )(((unsigned int )rend & 7936U) >> 8);
#line 2782
        back = (int )(((unsigned int )rend & 2031616U) >> 16);
#line 2783
        rend = (int )((unsigned int )rend & 4286611456U);
#line 2784
        if (rend) {
#line 2786
          rvid = 0;
#line 2788
          if (((unsigned int )rend & 100663296U) == 100663296U) {
#line 2789
            rend = (int )((unsigned int )rend & 4194303999U);
          } else
#line 2790
          if ((unsigned int )rend & 100663296U) {
#line 2791
            rvid = 1;
          }
#line 2793
          if ((unsigned int )rend & 16777216U) {
#line 2796
            if (! TermWin.focus) {
#line 2801
              outlineCursor = 1;
#line 2802
              rend = (int )((unsigned int )rend & 4278190079U);
            } else {
              {
#line 2796
              tmp___5 = thai_isupper(*(linebuf + 0));
              }
#line 2796
              if (tmp___5) {
#line 2801
                outlineCursor = 1;
#line 2802
                rend = (int )((unsigned int )rend & 4278190079U);
              } else {
#line 2805
                if (! rvid) {
#line 2805
                  tmp___4 = 1;
                } else
#line 2805
                if (PixColors[18] != PixColors[1]) {
#line 2805
                  tmp___4 = 1;
                } else {
#line 2805
                  tmp___4 = 0;
                }
#line 2805
                rvid = tmp___4;
              }
            }
          }
#line 2813
          if (rvid) {
#line 2815
            tmp___6 = back;
#line 2816
            back = fore;
#line 2817
            fore = tmp___6;
          }
          {
#line 2825
          if (((unsigned int )rend & 805306368U) == 268435456U) {
#line 2825
            goto case_268435456;
          }
#line 2831
          if (((unsigned int )rend & 805306368U) == 536870912U) {
#line 2831
            goto case_536870912;
          }
#line 2823
          goto switch_break;
          case_268435456: /* CIL Label */ 
#line 2826
          x = 0;
          {
#line 2826
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 2826
            if (! (x < count)) {
#line 2826
              goto while_break___2;
            }
#line 2827
            if ((int )*(linebuf + x) >= 95) {
#line 2827
              if ((int )*(linebuf + x) < 127) {
#line 2828
                if ((int )*(linebuf + x) == 95) {
#line 2828
                  *(linebuf + x) = (text_t )127;
                } else {
#line 2828
                  *(linebuf + x) = (text_t )((int )*(linebuf + x) - 95);
                }
              }
            }
#line 2826
            x ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 2830
          goto switch_break;
          case_536870912: /* CIL Label */ 
#line 2832
          x = 0;
          {
#line 2832
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 2832
            if (! (x < count)) {
#line 2832
              goto while_break___3;
            }
#line 2833
            if ((int )*(linebuf + x) == 35) {
#line 2834
              *(linebuf + x) = (text_t )'\036';
            }
#line 2832
            x ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 2835
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        }
#line 2857
        if (fore != 0) {
#line 2859
          gcvalue.foreground = PixColors[fore];
#line 2860
          gcmask |= (unsigned long )(1L << 2);
        } else
#line 2865
        if ((unsigned int )rend & 32768U) {
#line 2867
          gcvalue.foreground = PixColors[21];
#line 2868
          if (gcvalue.foreground != PixColors[0]) {
#line 2870
            gcmask |= (unsigned long )(1L << 2);
#line 2871
            rend = (int )((unsigned int )rend & 4294934527U);
          }
        } else
#line 2874
        if ((unsigned int )rend & 134217728U) {
#line 2876
          gcvalue.foreground = PixColors[22];
#line 2877
          if (gcvalue.foreground != PixColors[0]) {
#line 2879
            gcmask |= (unsigned long )(1L << 2);
#line 2880
            rend = (int )((unsigned int )rend & 4160749567U);
          }
        }
#line 2886
        if (back != 1) {
#line 2888
          gcvalue.background = PixColors[back];
#line 2889
          gcmask |= (unsigned long )(1L << 3);
        }
#line 2893
        if ((unsigned int )rend & 16777216U) {
#line 2893
          if (PixColors[18] != PixColors[1]) {
#line 2897
            if (thai_keyboard) {
#line 2897
              gcvalue.background = PixColors[20];
            } else {
#line 2897
              gcvalue.background = PixColors[18];
            }
#line 2902
            gcmask |= (unsigned long )(1L << 3);
#line 2903
            if (PixColors[19] != PixColors[0]) {
#line 2905
              gcvalue.foreground = PixColors[19];
#line 2906
              gcmask |= (unsigned long )(1L << 2);
            }
          }
        }
#line 2911
        if (gcmask) {
          {
#line 2912
          XChangeGC(Xdisplay, TermWin.gc, gcmask, & gcvalue);
          }
        }
#line 2990
        if ((unsigned int )rend & 32768U) {
#line 2990
          if (fore == 0) {
#line 2990
            if ((unsigned long )TermWin.boldFont != (unsigned long )((void *)0)) {
              {
#line 2992
              XSetFont(Xdisplay, TermWin.gc, (TermWin.boldFont)->fid);
#line 3002
              XDrawImageString(Xdisplay, TermWin.vt, TermWin.gc, xpixel, ypixel, (char const   *)((char *)linebuf),
                               count);
#line 3003
              XSetFont(Xdisplay, TermWin.gc, (TermWin.font)->fid);
              }
            } else {
              {
#line 3016
              XDrawImageString(Xdisplay, TermWin.vt, TermWin.gc, xpixel, ypixel, (char const   *)((char *)linebuf),
                               count);
              }
            }
          } else {
            {
#line 3016
            XDrawImageString(Xdisplay, TermWin.vt, TermWin.gc, xpixel, ypixel, (char const   *)((char *)linebuf),
                             count);
            }
          }
        } else {
          {
#line 3016
          XDrawImageString(Xdisplay, TermWin.vt, TermWin.gc, xpixel, ypixel, (char const   *)((char *)linebuf),
                           count);
          }
        }
#line 3032
        if ((unsigned int )rend & 134217728U) {
#line 3032
          if ((TermWin.font)->descent > 1) {
            {
#line 3034
            XDrawLine(Xdisplay, TermWin.vt, TermWin.gc, xpixel, ypixel + 1, (xpixel + count * (int )TermWin.fwidth) - 1,
                      ypixel + 1);
            }
          }
        }
#line 3043
        if (outlineCursor) {
#line 3046
          if (PixColors[18] != PixColors[1]) {
#line 3049
            if (thai_keyboard) {
#line 3049
              gcvalue.foreground = PixColors[20];
            } else {
#line 3049
              gcvalue.foreground = PixColors[18];
            }
            {
#line 3054
            gcmask |= (unsigned long )(1L << 2);
#line 3055
            XChangeGC(Xdisplay, TermWin.gc, gcmask, & gcvalue);
            }
          }
          {
#line 3062
          tmp___8 = thai_isupper(*(linebuf + 0));
          }
#line 3062
          if (tmp___8) {
            {
#line 3063
            height = ((int )TermWin.fheight - 1) / 4;
#line 3064
            tmp___7 = thai_level(*(linebuf + 0));
            }
            {
#line 3065
            if (tmp___7 == 1) {
#line 3065
              goto case_1;
            }
#line 3068
            if (tmp___7 == 2) {
#line 3068
              goto case_2;
            }
#line 3071
            goto switch_default;
            case_1: /* CIL Label */ 
#line 3065
            top = ((ypixel - (TermWin.font)->ascent) + ((int )TermWin.fheight - 1)) - height;
#line 3067
            goto switch_break___0;
            case_2: /* CIL Label */ 
#line 3068
            top = (ypixel - (TermWin.font)->ascent) + height;
#line 3069
            goto switch_break___0;
            switch_default: /* CIL Label */ 
#line 3072
            top = ypixel - (TermWin.font)->ascent;
#line 3073
            goto switch_break___0;
            switch_break___0: /* CIL Label */ ;
            }
            {
#line 3075
            XDrawRectangle(Xdisplay, TermWin.vt, TermWin.gc, xpixel - (int )TermWin.fwidth,
                           top, (unsigned int )((int )TermWin.fwidth - 1), (unsigned int )height);
            }
          } else {
            {
#line 3084
            XDrawRectangle(Xdisplay, TermWin.vt, TermWin.gc, xpixel, ypixel - (TermWin.font)->ascent,
                           (unsigned int )((int )TermWin.fwidth - 1), (unsigned int )((int )TermWin.fheight - 1));
            }
          }
        }
#line 3102
        if (gcmask) {
          {
#line 3105
          gcvalue.foreground = PixColors[0];
#line 3106
          gcvalue.background = PixColors[1];
#line 3107
          XChangeGC(Xdisplay, TermWin.gc, gcmask, & gcvalue);
          }
        }
      }
#line 2691
      c ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 2650
    roffset += (int )TermWin.ncol + 1;
#line 2650
    doffset += (int )TermWin.ncol + 1;
#line 2650
    r ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3112
  if (screen.flags & (unsigned int )(1 << 1)) {
#line 3114
    *(screen.rend + xcursor) &= 4278190079U;
  }
#line 3138
  return;
}
}
#line 3147 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void scr_set_tab(int mode ) 
{ 


  {
#line 3150
  if (mode < 0) {
    {
#line 3151
    memset((void *)tabs, 0, (unsigned long )TermWin.ncol * sizeof(char ));
    }
  } else
#line 3152
  if ((int )screen.col < (int )TermWin.ncol) {
#line 3153
    *(tabs + screen.col) = (char )(mode != 0);
  }
#line 3154
  return;
}
}
#line 3158 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void scr_rvideo_mode(int mode ) 
{ 
  register int x ;
  register int count ;

  {
#line 3161
  if ((int )rvideo != mode) {
#line 3165
    rvideo = (short )mode;
#line 3166
    rstyle ^= 67108864U;
#line 3168
    count = ((int )TermWin.nrow + (int )TermWin.saveLines) * ((int )TermWin.ncol + 1);
#line 3169
    x = 0;
    {
#line 3169
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3169
      if (! (x < count)) {
#line 3169
        goto while_break;
      }
#line 3170
      *(screen.rend + x) ^= 67108864U;
#line 3169
      x ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3171
    scr_refresh(1);
    }
  }
#line 3177
  return;
}
}
#line 3181 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void scr_bell(void) 
{ 


  {
  {
#line 3188
  XMapWindow(Xdisplay, TermWin.parent);
  }
#line 3191
  if (Options & (1UL << 3)) {
    {
#line 3193
    scr_rvideo_mode(! rvideo);
#line 3194
    scr_rvideo_mode(! rvideo);
    }
  } else {
    {
#line 3197
    XBell(Xdisplay, 0);
    }
  }
#line 3198
  return;
}
}
#line 3326 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void mouse_report(XButtonEvent *ev ) 
{ 
  int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 3329
  tmp = ThaiPixel2Col(ev->x, ev->y);
  }
#line 3329
  if ((long )ev->button == 0L) {
#line 3329
    tmp___0 = 3U;
  } else {
#line 3329
    tmp___0 = ev->button - 1U;
  }
#line 3329
  if (ev->state & (unsigned int )(1 << 3)) {
#line 3329
    tmp___1 = 2;
  } else {
#line 3329
    tmp___1 = 0;
  }
  {
#line 3329
  tt_printf("\033[M%c%c%c", (32U + tmp___0) + (((ev->state & (unsigned int )(1 | (1 << 2))) + (unsigned int )tmp___1) << 2),
            33 + tmp, 33 + (ev->y - 2) / (int )TermWin.fheight);
  }
#line 3337
  return;
}
}
#line 3386 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void thai_complexclear(int *list , int ypixel ) 
{ 
  int from ;
  int to ;
  int in ;
  int i ;

  {
#line 3388
  from = 0;
#line 3390
  in = 0;
#line 3391
  i = 1;
  {
#line 3391
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3391
    if (! (i <= (int )TermWin.ncol)) {
#line 3391
      goto while_break;
    }
#line 3392
    if (*(list + i)) {
#line 3392
      if (in == 0) {
#line 3393
        in = 1;
#line 3394
        from = i - 1;
      }
    }
#line 3396
    if (in == 1) {
#line 3396
      if (! *(list + i)) {
        {
#line 3397
        to = i - 1;
#line 3398
        thai_clearline(from, to, ypixel);
#line 3399
        in = 0;
        }
      }
    }
#line 3391
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3402
  if (in) {
    {
#line 3403
    thai_clearline(from, i - 1, ypixel);
    }
  }
#line 3405
  return;
}
}
#line 3407 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/screen.c"
void thai_clearline(int from , int to , int ypixel ) 
{ 


  {
  {
#line 3423
  XClearArea(Xdisplay, TermWin.vt, from * (int )TermWin.fwidth + 2, ypixel - (TermWin.font)->ascent,
             (unsigned int )((to - from) * (int )TermWin.fwidth), (unsigned int )((int )TermWin.fheight),
             0);
  }
#line 3428
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 379
extern  __attribute__((__nothrow__)) int vsprintf(char * __restrict  __s , char const   * __restrict  __format ,
                                                  __gnuc_va_list __arg ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 519 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 588
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unsetenv)(char const   *__name ) ;
#line 924
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) grantpt)(int __fd ) ;
#line 928
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) unlockpt)(int __fd ) ;
#line 933
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ptsname)(int __fd ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 1900 "/usr/include/X11/Xlib.h"
extern int XSetWMProtocols(Display * , Window  , Atom * , int  ) ;
#line 2183
extern int XConnectionNumber(Display * ) ;
#line 2853
extern int XNextEvent(Display * , XEvent * ) ;
#line 2893
extern int XPending(Display * ) ;
#line 2995
extern int XQueryPointer(Display * , Window  , Window * , Window * , int * , int * ,
                         int * , int * , unsigned int * ) ;
#line 3079
extern int XRefreshKeyboardMapping(XMappingEvent * ) ;
#line 3565
extern char *XSetLocaleModifiers(char const   * ) ;
#line 3838
extern XIM XOpenIM(Display * , struct _XrmHashBucketRec * , char * , char * ) ;
#line 3845
extern int XCloseIM(XIM  ) ;
#line 3849
extern char *XGetIMValues(XIM   , ...)  __attribute__((__sentinel__(0))) ;
#line 3865
extern XIC XCreateIC(XIM   , ...)  __attribute__((__sentinel__(0))) ;
#line 3873
extern void XSetICFocus(XIC  ) ;
#line 3877
extern void XUnsetICFocus(XIC  ) ;
#line 3893
extern char *XSetICValues(XIC   , ...)  __attribute__((__sentinel__(0))) ;
#line 3905
extern int XFilterEvent(XEvent * , Window  ) ;
#line 3910
extern int XmbLookupString(XIC  , XKeyPressedEvent * , char * , int  , KeySym * ,
                           int * ) ;
#line 534 "/usr/include/X11/Xutil.h"
extern int XLookupString(XKeyEvent * , char * , int  , KeySym * , XComposeStatus * ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 473
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chown)(char const   *__file ,
                                                                                            __uid_t __owner ,
                                                                                            __gid_t __group ) ;
#line 478
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchown)(int __fd ,
                                                                             __uid_t __owner ,
                                                                             __gid_t __group ) ;
#line 531
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 584
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execlp)(char const   *__file ,
                                                                                               char const   *__arg 
                                                                                               , ...) ;
#line 619
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 681
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getegid)(void) ;
#line 710
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) seteuid)(__uid_t __uid ) ;
#line 727
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setegid)(__gid_t __gid ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 842
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetpgrp)(int __fd ,
                                                                                __pid_t __pgrp_id ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 146
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 54 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) cfsetospeed)(struct termios *__termios_p ,
                                                                                  speed_t __speed ) ;
#line 57
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) cfsetispeed)(struct termios *__termios_p ,
                                                                                  speed_t __speed ) ;
#line 66
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 263 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 284
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 297
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchmod)(int __fd ,
                                                                             __mode_t __mode ) ;
#line 42 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.h"
unsigned int cmd_write(unsigned char const   *str , unsigned int count ) ;
#line 262 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
void cleanutent(void) ;
#line 263
void makeutent(char const   *pty , char const   *hostname ) ;
#line 269 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
int thai_keyboard  =    0;
#line 295 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static char *ptydev  =    (char *)((void *)0);
#line 295 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static char *ttydev  =    (char *)((void *)0);
#line 296 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static int cmd_fd  =    -1;
#line 297 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static pid_t cmd_pid  =    -1;
#line 298 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static int Xfd  =    -1;
#line 299 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static unsigned int num_fds  =    0U;
#line 300 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static struct stat ttyfd_stat  ;
#line 331 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static unsigned long PrivateModes  =    (((1UL << 5) | (1UL << 7)) | (1UL << 9)) | (1UL << 10);
#line 332 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static unsigned long SavedModes  =    (((1UL << 5) | (1UL << 7)) | (1UL << 9)) | (1UL << 10);
#line 336 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static int refresh_count  =    0;
#line 336 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static int refresh_limit  =    1;
#line 336 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static int refresh_type  =    1;
#line 338 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static Atom wmDeleteWindow  ;
#line 345 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
char const   *rs_inputMethod  =    (char const   *)((void *)0);
#line 346 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
char const   *rs_preeditType  =    (char const   *)((void *)0);
#line 347 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static XIC Input_Context  ;
#line 348
static void stringConversionCallback(XIC ic , XPointer client_data , XPointer call_data ) ;
#line 351 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static XICCallback String_Conv_Cb  =    {(XPointer )0, (int (*)(XIC  , XPointer  , XPointer  ))(& stringConversionCallback)};
#line 358 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static unsigned char cmdbuf_base[8192]  ;
#line 358 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static unsigned char *cmdbuf_ptr  ;
#line 358 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static unsigned char *cmdbuf_endp  ;
#line 361
static void privileges(int mode ) ;
#line 363
static void Child_signal(int unused ) ;
#line 364
static void Exit_signal(int sig ) ;
#line 365
static int get_pty(void) ;
#line 366
static int get_tty(void) ;
#line 367
static int run_command(char **argv ) ;
#line 368
static unsigned char cmd_getc(void) ;
#line 369
static void lookup_key(XEvent *ev ) ;
#line 370
static void process_x_event(XEvent *ev ) ;
#line 375
static void process_escape_seq(void) ;
#line 376
static void process_csi_seq(void) ;
#line 377
static void process_xterm_seq(void) ;
#line 378
static void process_terminal_mode(int mode , int priv , unsigned int nargs , int *arg ) ;
#line 382
static void process_sgr_mode(unsigned int nargs , int *arg ) ;
#line 384
static void tt_winsize(int fd ) ;
#line 387
static void init_xlocale(void) ;
#line 393 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
__inline static int nowarn_chown(char const   *file , uid_t uid , gid_t gid ) 
{ 
  int tmp ;

  {
  {
#line 396
  tmp = chown(file, uid, gid);
  }
#line 396
  return (tmp);
}
}
#line 400 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
__inline static int nowarn_fchown(int fd , uid_t uid , gid_t gid ) 
{ 
  int tmp ;

  {
  {
#line 403
  tmp = fchown(fd, uid, gid);
  }
#line 403
  return (tmp);
}
}
#line 429 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static uid_t euid  ;
#line 430 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static gid_t egid  ;
#line 425 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static void privileges(int mode ) 
{ 
  __uid_t tmp ;
  __gid_t tmp___0 ;

  {
  {
#line 434
  if (mode == 0) {
#line 434
    goto case_0;
  }
#line 443
  if (mode == 115) {
#line 443
    goto case_115;
  }
#line 448
  if (mode == 114) {
#line 448
    goto case_114;
  }
#line 432
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 439
  tmp = getuid();
#line 439
  seteuid(tmp);
#line 440
  tmp___0 = getgid();
#line 440
  setegid(tmp___0);
  }
#line 441
  goto switch_break;
  case_115: /* CIL Label */ 
  {
#line 444
  euid = geteuid();
#line 445
  egid = getegid();
  }
#line 446
  goto switch_break;
  case_114: /* CIL Label */ 
  {
#line 449
  seteuid(euid);
#line 450
  setegid(egid);
  }
#line 451
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 467
  return;
}
}
#line 474 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static void Child_signal(int unused ) 
{ 
  int pid ;
  int save_errno ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 477
  tmp = __errno_location();
#line 477
  save_errno = *tmp;
  }
  {
#line 479
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 481
    tmp___0 = __errno_location();
#line 481
    *tmp___0 = 0;
#line 479
    pid = waitpid(cmd_pid, (int *)((void *)0), 1);
    }
#line 479
    if (-1 == pid) {
      {
#line 479
      tmp___1 = __errno_location();
      }
#line 479
      if (! (*tmp___1 == 4)) {
#line 479
        goto while_break;
      }
    } else {
#line 479
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 486
  if (pid == cmd_pid) {
    {
#line 487
    exit(0);
    }
  }
  {
#line 488
  tmp___2 = __errno_location();
#line 488
  *tmp___2 = save_errno;
#line 490
  signal(17, & Child_signal);
  }
#line 491
  return;
}
}
#line 496 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static void Exit_signal(int sig ) 
{ 
  __pid_t tmp ;

  {
  {
#line 502
  signal(sig, (void (*)(int  ))0);
#line 504
  privileges('r');
#line 505
  cleanutent();
#line 506
  privileges(0);
#line 508
  tmp = getpid();
#line 508
  kill(tmp, sig);
  }
#line 509
  return;
}
}
#line 514 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static void clean_exit(void) 
{ 


  {
  {
#line 521
  privileges('r');
#line 522
  chmod((char const   *)ttydev, ttyfd_stat.st_mode);
#line 524
  nowarn_chown((char const   *)ttydev, ttyfd_stat.st_uid, ttyfd_stat.st_gid);
#line 525
  cleanutent();
#line 526
  privileges(0);
  }
#line 527
  return;
}
}
#line 538 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static int get_pty(void) 
{ 
  int fd ;

  {
  {
#line 541
  fd = -1;
#line 551
  fd = open("/dev/ptmx", 2);
  }
#line 551
  if (fd < 0) {
#line 553
    goto Failed;
  } else {
    {
#line 557
    grantpt(fd);
#line 558
    unlockpt(fd);
#line 559
    ttydev = ptsname(fd);
#line 559
    ptydev = ttydev;
    }
  }
  {
#line 597
  fcntl(fd, 4, 2048);
  }
#line 598
  return (fd);
  Failed: 
  {
#line 601
  print_error("can\'t open pseudo-tty");
  }
#line 602
  return (-1);
}
}
#line 611 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static int get_tty(void) 
{ 
  int fd ;
  pid_t pid ;
  unsigned int mode ;
  gid_t gid ;
  __gid_t tmp ;
  __uid_t tmp___0 ;
  int i ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 625
  pid = setsid();
  }
#line 627
  if (pid < 0) {
    {
#line 628
    perror(rs_name);
    }
  }
  {
#line 634
  fd = open((char const   *)ttydev, 2);
  }
#line 634
  if (fd < 0) {
    {
#line 636
    print_error("can\'t open slave tty %s", ttydev);
#line 637
    exit(1);
    }
  }
  {
#line 652
  mode = 402U;
#line 653
  tmp = getgid();
#line 653
  gid = tmp;
#line 666
  privileges('r');
#line 667
  tmp___0 = getuid();
#line 667
  nowarn_fchown(fd, tmp___0, gid);
#line 668
  fchmod(fd, mode);
#line 669
  privileges(0);
#line 679
  i = 0;
  }
  {
#line 679
  while (1) {
    while_continue: /* CIL Label */ ;
#line 679
    if (! ((unsigned int )i < num_fds)) {
#line 679
      goto while_break;
    }
#line 680
    if (i != fd) {
      {
#line 681
      close(i);
      }
    }
#line 679
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 684
  i = 0;
  {
#line 684
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 684
    if (! (i < 3)) {
#line 684
      goto while_break___0;
    }
    {
#line 685
    tmp___3 = dup(fd);
    }
#line 685
    if (tmp___3 < 0) {
      {
#line 687
      tmp___1 = __errno_location();
#line 687
      tmp___2 = strerror(*tmp___1);
#line 687
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Fail to dup tty for fd %d: %s\n",
              i, tmp___2);
#line 689
      exit(1);
      }
    }
#line 684
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 693
  if (fd > 2) {
    {
#line 694
    close(fd);
    }
  }
  {
#line 713
  ioctl(0, 21518UL, 0);
#line 718
  tcsetpgrp(0, pid);
#line 726
  tmp___4 = open((char const   *)ttydev, 2, 0);
#line 726
  close(tmp___4);
#line 730
  privileges(0);
  }
#line 732
  return (fd);
}
}
#line 867 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static void get_ttymode(ttymode_t *tio ) 
{ 
  int tmp ;

  {
  {
#line 874
  tmp = tcgetattr(0, tio);
  }
#line 874
  if (tmp < 0) {
#line 877
    tio->c_cc[0] = (cc_t )3;
#line 878
    tio->c_cc[1] = (cc_t )28;
#line 879
    tio->c_cc[2] = (cc_t )127;
#line 880
    tio->c_cc[3] = (cc_t )21;
#line 881
    tio->c_cc[8] = (cc_t )17;
#line 882
    tio->c_cc[9] = (cc_t )19;
#line 883
    tio->c_cc[10] = (cc_t )26;
#line 888
    tio->c_cc[12] = (cc_t )18;
#line 891
    tio->c_cc[13] = (cc_t )15;
#line 894
    tio->c_cc[14] = (cc_t )23;
#line 897
    tio->c_cc[15] = (cc_t )22;
  }
#line 901
  tio->c_cc[4] = (cc_t )4;
#line 902
  tio->c_cc[11] = (cc_t )'\000';
#line 904
  tio->c_cc[16] = (cc_t )'\000';
#line 907
  tio->c_cc[7] = (cc_t )'\000';
#line 913
  tio->c_cc[6] = (cc_t )1;
#line 916
  tio->c_cc[5] = (cc_t )0;
#line 920
  tio->c_iflag = (tcflag_t )9478;
#line 927
  tio->c_oflag = (tcflag_t )5;
#line 930
  tio->c_cflag = (tcflag_t )176;
#line 933
  tio->c_lflag = (tcflag_t )35387;
  {
#line 945
  while (1) {
    while_continue: /* CIL Label */ ;
#line 945
    if ((int )tio->c_cc[2] == 8) {
#line 945
      PrivateModes |= 1UL << 8;
    } else {
#line 945
      PrivateModes &= ~ (1UL << 8);
    }
#line 945
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1001
  return;
}
}
#line 1010 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static int run_command(char **argv ) 
{ 
  ttymode_t tio ;
  int ptyfd ;
  unsigned int on ;
  char const   *argv0 ;
  char const   *shell ;
  char *tmp ;
  char *p ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 1017
  privileges('s');
#line 1018
  privileges(0);
#line 1020
  ptyfd = get_pty();
  }
#line 1021
  if (ptyfd < 0) {
#line 1022
    return (-1);
  }
  {
#line 1025
  lstat((char const   */* __restrict  */)ttydev, (struct stat */* __restrict  */)(& ttyfd_stat));
#line 1033
  atexit(& clean_exit);
#line 1046
  get_ttymode(& tio);
#line 1048
  SavedModes |= PrivateModes & (1UL << 8);
  }
#line 1051
  if (scrollBar.state) {
#line 1053
    PrivateModes |= 1UL << 14;
#line 1054
    SavedModes |= 1UL << 14;
  }
  {
#line 1062
  signal(1, & Exit_signal);
#line 1064
  signal(2, & Exit_signal);
#line 1066
  signal(3, & Exit_signal);
#line 1067
  signal(15, & Exit_signal);
#line 1068
  signal(17, & Child_signal);
#line 1073
  cmd_pid = fork();
  }
#line 1074
  if (cmd_pid < 0) {
    {
#line 1076
    print_error("can\'t fork");
    }
#line 1077
    return (-1);
  }
#line 1079
  if (cmd_pid == 0) {
    {
#line 1085
    unsetenv("LINES");
#line 1086
    unsetenv("COLUMNS");
#line 1088
    unsetenv("TERMCAP");
#line 1091
    get_tty();
    }
    {
#line 1094
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1094
      cfsetospeed(& tio, (speed_t )15);
#line 1094
      cfsetispeed(& tio, (speed_t )15);
#line 1094
      tcsetattr(0, 0, (struct termios  const  *)(& tio));
      }
#line 1094
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1097
    if (Options & 1UL) {
      {
#line 1100
      on = 1U;
#line 1101
      ioctl(0, 21533UL, & on);
      }
    }
    {
#line 1111
    tt_winsize(0);
#line 1114
    signal(2, (void (*)(int  ))0);
#line 1115
    signal(3, (void (*)(int  ))0);
#line 1116
    signal(17, (void (*)(int  ))0);
#line 1122
    signal(20, (void (*)(int  ))1);
#line 1123
    signal(21, (void (*)(int  ))1);
#line 1124
    signal(22, (void (*)(int  ))1);
    }
#line 1128
    if ((unsigned long )argv != (unsigned long )((void *)0)) {
      {
#line 1135
      execvp((char const   *)*(argv + 0), (char * const  *)argv);
#line 1136
      print_error("can\'t execute \"%s\"", *(argv + 0));
      }
    } else {
      {
#line 1142
      tmp = getenv("SHELL");
#line 1142
      shell = (char const   *)tmp;
      }
#line 1142
      if ((unsigned long )shell == (unsigned long )((void *)0)) {
#line 1143
        shell = "/bin/sh";
      } else
#line 1142
      if ((int const   )*shell == 0) {
#line 1143
        shell = "/bin/sh";
      }
      {
#line 1145
      argv0 = my_basename(shell);
      }
#line 1146
      if (Options & (1UL << 1)) {
        {
#line 1148
        tmp___0 = strlen(argv0);
#line 1148
        tmp___1 = my_malloc((tmp___0 + 2UL) * sizeof(char ));
#line 1148
        p = (char *)tmp___1;
#line 1149
        *(p + 0) = (char )'-';
#line 1150
        strcpy((char */* __restrict  */)(p + 1), (char const   */* __restrict  */)argv0);
#line 1151
        argv0 = (char const   *)p;
        }
      }
      {
#line 1153
      execlp(shell, argv0, (void *)0);
#line 1154
      print_error("can\'t execute \"%s\"", shell);
      }
    }
    {
#line 1156
    exit(1);
    }
  }
  {
#line 1159
  privileges('r');
  }
#line 1160
  if (! (Options & (1UL << 6))) {
    {
#line 1161
    makeutent((char const   *)ttydev, display_name);
    }
  }
  {
#line 1162
  privileges(0);
  }
#line 1164
  return (ptyfd);
}
}
#line 1169 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
void init_command(char **argv ) 
{ 
  long tmp ;

  {
  {
#line 1178
  wmDeleteWindow = XInternAtom(Xdisplay, "WM_DELETE_WINDOW", 0);
#line 1179
  XSetWMProtocols(Xdisplay, TermWin.parent, & wmDeleteWindow, 1);
#line 1187
  init_xlocale();
#line 1191
  tmp = sysconf(4);
#line 1191
  num_fds = (unsigned int )tmp;
#line 1204
  Xfd = XConnectionNumber(Xdisplay);
#line 1205
  cmdbuf_endp = cmdbuf_base;
#line 1205
  cmdbuf_ptr = cmdbuf_endp;
#line 1207
  cmd_fd = run_command(argv);
  }
#line 1207
  if (cmd_fd < 0) {
    {
#line 1209
    print_error("aborting");
#line 1210
    exit(1);
    }
  }
#line 1212
  return;
}
}
#line 1221 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static void init_xlocale(void) 
{ 
  char *p ;
  char *s ;
  char buf___0[32] ;
  char tmp[1024] ;
  XIM xim ;
  XIMStyle input_style ;
  XIMStyles *xim_styles ;
  int found ;
  XIMValuesList *ic_values ;
  char *end ;
  char *next_s ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  unsigned short i ;
  char *end___0 ;
  char *next_s___0 ;
  unsigned short const   **tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  unsigned short const   **tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int i___0 ;
  int tmp___12 ;
  char *tmp___13 ;

  {
#line 1225
  xim = (XIM )((void *)0);
#line 1226
  input_style = (XIMStyle )0;
#line 1227
  xim_styles = (XIMStyles *)((void *)0);
#line 1229
  ic_values = (XIMValuesList *)((void *)0);
#line 1231
  Input_Context = (XIC )((void *)0);
#line 1237
  if ((unsigned long )rs_inputMethod == (unsigned long )((void *)0)) {
#line 1237
    goto _L;
  } else
#line 1237
  if (! *rs_inputMethod) {
    _L: /* CIL Label */ 
    {
#line 1243
    p = XSetLocaleModifiers("");
    }
#line 1243
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 1243
      if (*p) {
        {
#line 1244
        xim = XOpenIM(Xdisplay, (struct _XrmHashBucketRec *)((void *)0), (char *)((void *)0),
                      (char *)((void *)0));
        }
      }
    }
  } else {
    {
#line 1248
    strcpy((char */* __restrict  */)(tmp), (char const   */* __restrict  */)rs_inputMethod);
#line 1249
    s = tmp;
    }
    {
#line 1249
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1249
      if (! *s) {
#line 1249
        goto while_break;
      }
      {
#line 1252
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1252
        if (*s) {
          {
#line 1252
          tmp___0 = __ctype_b_loc();
          }
#line 1252
          if (! ((int const   )*(*tmp___0 + (int )*s) & 8192)) {
#line 1252
            goto while_break___0;
          }
        } else {
#line 1252
          goto while_break___0;
        }
#line 1253
        s ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1254
      if (! *s) {
#line 1255
        goto while_break;
      }
#line 1256
      end = s;
      {
#line 1257
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1257
        if (*end) {
#line 1257
          if (! ((int )*end != 44)) {
#line 1257
            goto while_break___1;
          }
        } else {
#line 1257
          goto while_break___1;
        }
#line 1258
        end ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1259
      tmp___1 = end;
#line 1259
      end --;
#line 1259
      next_s = tmp___1;
      {
#line 1260
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1260
        if ((unsigned long )end >= (unsigned long )s) {
          {
#line 1260
          tmp___2 = __ctype_b_loc();
          }
#line 1260
          if (! ((int const   )*(*tmp___2 + (int )*end) & 8192)) {
#line 1260
            goto while_break___2;
          }
        } else {
#line 1260
          goto while_break___2;
        }
#line 1261
        end --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1262
      *(end + 1) = (char )'\000';
#line 1264
      if (*s) {
        {
#line 1266
        strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"@im=");
#line 1267
        strcat((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)s);
#line 1268
        p = XSetLocaleModifiers((char const   *)(buf___0));
        }
#line 1268
        if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 1268
          if (*p) {
            {
#line 1268
            xim = XOpenIM(Xdisplay, (struct _XrmHashBucketRec *)((void *)0), (char *)((void *)0),
                          (char *)((void *)0));
            }
#line 1268
            if ((unsigned long )xim != (unsigned long )((void *)0)) {
#line 1270
              goto while_break;
            }
          }
        }
      }
#line 1272
      if (! *next_s) {
#line 1273
        goto while_break;
      }
#line 1274
      s = next_s + 1;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1278
  if ((unsigned long )xim == (unsigned long )((void *)0)) {
    {
#line 1279
    xim = XOpenIM(Xdisplay, (struct _XrmHashBucketRec *)((void *)0), (char *)((void *)0),
                  (char *)((void *)0));
    }
  }
#line 1281
  if ((unsigned long )xim == (unsigned long )((void *)0)) {
    {
#line 1281
    p = XSetLocaleModifiers("@im=none");
    }
#line 1281
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 1281
      if (*p) {
        {
#line 1282
        xim = XOpenIM(Xdisplay, (struct _XrmHashBucketRec *)((void *)0), (char *)((void *)0),
                      (char *)((void *)0));
        }
      }
    }
  }
#line 1284
  if ((unsigned long )xim == (unsigned long )((void *)0)) {
    {
#line 1286
    print_error("Failed to open input method");
    }
#line 1287
    return;
  }
  {
#line 1290
  tmp___3 = XGetIMValues(xim, "queryInputStyle", & xim_styles, (void *)0);
  }
#line 1290
  if (tmp___3) {
    {
#line 1292
    print_error("input method doesn\'t support any style");
#line 1293
    XCloseIM(xim);
    }
#line 1294
    return;
  } else
#line 1290
  if (! xim_styles) {
    {
#line 1292
    print_error("input method doesn\'t support any style");
#line 1293
    XCloseIM(xim);
    }
#line 1294
    return;
  }
#line 1297
  if (rs_preeditType) {
#line 1297
    tmp___4 = rs_preeditType;
  } else {
#line 1297
    tmp___4 = "Root";
  }
  {
#line 1297
  strcpy((char */* __restrict  */)(tmp), (char const   */* __restrict  */)tmp___4);
#line 1298
  found = 0;
#line 1298
  s = tmp;
  }
  {
#line 1298
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1298
    if (*s) {
#line 1298
      if (! (! found)) {
#line 1298
        goto while_break___3;
      }
    } else {
#line 1298
      goto while_break___3;
    }
    {
#line 1303
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1303
      if (*s) {
        {
#line 1303
        tmp___5 = __ctype_b_loc();
        }
#line 1303
        if (! ((int const   )*(*tmp___5 + (int )*s) & 8192)) {
#line 1303
          goto while_break___4;
        }
      } else {
#line 1303
        goto while_break___4;
      }
#line 1304
      s ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1305
    if (! *s) {
#line 1306
      goto while_break___3;
    }
#line 1307
    end___0 = s;
    {
#line 1308
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1308
      if (*end___0) {
#line 1308
        if (! ((int )*end___0 != 44)) {
#line 1308
          goto while_break___5;
        }
      } else {
#line 1308
        goto while_break___5;
      }
#line 1309
      end___0 ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1310
    tmp___6 = end___0;
#line 1310
    end___0 --;
#line 1310
    next_s___0 = tmp___6;
    {
#line 1311
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1311
      if ((unsigned long )end___0 >= (unsigned long )s) {
        {
#line 1311
        tmp___8 = __ctype_b_loc();
        }
#line 1311
        if (! ((int const   )*(*tmp___8 + (int )*end___0) & 8192)) {
#line 1311
          goto while_break___6;
        }
      } else {
#line 1311
        goto while_break___6;
      }
#line 1312
      tmp___7 = end___0;
#line 1312
      end___0 --;
#line 1312
      *tmp___7 = (char)0;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 1314
    tmp___11 = strcmp((char const   *)s, "OverTheSpot");
    }
#line 1314
    if (tmp___11) {
      {
#line 1316
      tmp___10 = strcmp((char const   *)s, "OffTheSpot");
      }
#line 1316
      if (tmp___10) {
        {
#line 1318
        tmp___9 = strcmp((char const   *)s, "Root");
        }
#line 1318
        if (! tmp___9) {
#line 1319
          input_style = (XIMStyle )1032L;
        }
      } else {
#line 1317
        input_style = (XIMStyle )257L;
      }
    } else {
#line 1315
      input_style = (XIMStyle )260L;
    }
#line 1321
    i = (unsigned short)0;
    {
#line 1321
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1321
      if (! ((int )i < (int )xim_styles->count_styles)) {
#line 1321
        goto while_break___7;
      }
#line 1323
      if (input_style == *(xim_styles->supported_styles + i)) {
#line 1325
        found = 1;
#line 1326
        goto while_break___7;
      }
#line 1321
      i = (unsigned short )((int )i + 1);
    }
    while_break___7: /* CIL Label */ ;
    }
#line 1329
    s = next_s___0;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1331
  XFree((void *)xim_styles);
  }
#line 1333
  if (found == 0) {
    {
#line 1335
    print_error("input method doesn\'t support my preedit type");
#line 1336
    XCloseIM(xim);
    }
#line 1337
    return;
  }
#line 1346
  if (input_style != 1032UL) {
    {
#line 1348
    print_error("This program only supports the \"Root\" preedit type");
#line 1349
    XCloseIM(xim);
    }
#line 1350
    return;
  }
  {
#line 1353
  Input_Context = XCreateIC(xim, "inputStyle", input_style, "clientWindow", TermWin.parent,
                            "focusWindow", TermWin.parent, (void *)0);
  }
#line 1358
  if ((unsigned long )Input_Context == (unsigned long )((void *)0)) {
    {
#line 1360
    print_error("Failed to create input context");
#line 1361
    XCloseIM(xim);
    }
  }
  {
#line 1363
  tmp___13 = XGetIMValues(xim, "queryICValuesList", & ic_values, (void *)0);
  }
#line 1363
  if (! tmp___13) {
#line 1366
    i___0 = 0;
    {
#line 1366
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1366
      if (! (i___0 < (int )ic_values->count_values)) {
#line 1366
        goto while_break___8;
      }
      {
#line 1368
      tmp___12 = strcmp((char const   *)*(ic_values->supported_values + i___0), "stringConversionCallback");
      }
#line 1368
      if (tmp___12 == 0) {
        {
#line 1371
        XSetICValues(Input_Context, "stringConversionCallback", (XPointer )(& String_Conv_Cb),
                     (void *)0);
#line 1373
        print_error("SCCB registered");
        }
#line 1374
        goto while_break___8;
      }
#line 1366
      i___0 ++;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 1378
  return;
}
}
#line 1380 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static void stringConversionCallback(XIC ic , XPointer client_data , XPointer call_data ) 
{ 
  XIMStringConversionCallbackStruct *conv_data ;
  char buff[255] ;
  char *p ;
  int row ;
  int col ;
  int begcol ;
  int endcol ;
  char *tmp ;
  int tmp___0 ;
  unsigned char tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 1389
  conv_data = (XIMStringConversionCallbackStruct *)call_data;
#line 1391
  if ((int )conv_data->operation != 2) {
#line 1393
    conv_data->text = (XIMStringConversionText *)((void *)0);
#line 1394
    return;
  }
  {
#line 1397
  scr_get_position(& row, & col);
#line 1399
  p = buff;
#line 1400
  begcol = col + (int )conv_data->position;
#line 1401
  endcol = -1;
  }
  {
#line 1403
  if ((unsigned int )conv_data->direction == 0U) {
#line 1403
    goto case_0;
  }
#line 1406
  if ((unsigned int )conv_data->direction == 1U) {
#line 1406
    goto case_1;
  }
#line 1420
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1404
  endcol = begcol + (int )conv_data->factor;
#line 1405
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1407
  endcol = begcol;
#line 1408
  begcol -= (int )conv_data->factor;
#line 1409
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1421
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1424
  if (0 <= begcol) {
#line 1424
    if (begcol < endcol) {
#line 1424
      if (endcol <= (int )TermWin.ncol) {
        {
#line 1425
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1425
          if (! (begcol < endcol)) {
#line 1425
            goto while_break;
          }
          {
#line 1426
          tmp = p;
#line 1426
          p ++;
#line 1426
          tmp___0 = begcol;
#line 1426
          begcol ++;
#line 1426
          tmp___1 = scr_get_char_rc(row, tmp___0);
#line 1426
          *tmp = (char )tmp___1;
          }
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 1429
        tmp___2 = malloc(sizeof(XIMStringConversionText ));
#line 1429
        conv_data->text = (XIMStringConversionText *)tmp___2;
#line 1431
        (conv_data->text)->length = (unsigned short )(p - buff);
#line 1432
        (conv_data->text)->feedback = (XIMStringConversionFeedback *)0;
#line 1433
        (conv_data->text)->encoding_is_wchar = 0;
#line 1434
        tmp___3 = malloc((size_t )(p - buff));
#line 1434
        (conv_data->text)->string.mbs = (char *)tmp___3;
#line 1435
        memcpy((void */* __restrict  */)(conv_data->text)->string.mbs, (void const   */* __restrict  */)(buff),
               (size_t )(p - buff));
        }
      }
    }
  }
#line 1437
  return;
}
}
#line 1446 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static void tt_winsize(int fd ) 
{ 
  struct winsize ws ;

  {
#line 1451
  if (fd < 0) {
#line 1452
    return;
  }
  {
#line 1454
  ws.ws_col = (unsigned short )TermWin.ncol;
#line 1455
  ws.ws_row = (unsigned short )TermWin.nrow;
#line 1456
  ws.ws_ypixel = (unsigned short)0;
#line 1456
  ws.ws_xpixel = ws.ws_ypixel;
#line 1457
  ioctl(fd, 21524UL, & ws);
  }
#line 1458
  return;
}
}
#line 1460 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
void tt_resize(void) 
{ 


  {
  {
#line 1463
  tt_winsize(cmd_fd);
  }
#line 1464
  return;
}
}
#line 1471 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static int numlock_state  =    0;
#line 1478 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static XComposeStatus compose  =    {(XPointer )((void *)0), 0};
#line 1480 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static unsigned char kbuf[8]  ;
#line 1468 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static void lookup_key(XEvent *ev ) 
{ 
  int ctrl ;
  int meta ;
  int shft ;
  int len ;
  KeySym keysym ;
  int status_return ;
  int tmp ;
  int tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  char *tmp___11 ;
  size_t tmp___12 ;
  char *tmp___13 ;
  size_t tmp___14 ;
  int i ;
  char tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  unsigned char ch ;

  {
#line 1482
  keysym = (KeySym )0;
#line 1490
  shft = (int )(ev->xkey.state & 1U);
#line 1491
  ctrl = (int )(ev->xkey.state & (unsigned int )(1 << 2));
#line 1492
  meta = (int )(ev->xkey.state & (unsigned int )(1 << 3));
#line 1494
  if (numlock_state) {
#line 1494
    goto _L;
  } else
#line 1494
  if (ev->xkey.state & (unsigned int )(1 << 7)) {
    _L: /* CIL Label */ 
#line 1496
    numlock_state = (int )(ev->xkey.state & (unsigned int )(1 << 7));
    {
#line 1497
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1497
      if (! numlock_state) {
#line 1497
        PrivateModes |= 1UL << 7;
      } else {
#line 1497
        PrivateModes &= ~ (1UL << 7);
      }
#line 1497
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1501
  tmp = XFilterEvent(ev, ev->xkey.window);
  }
#line 1501
  if (tmp) {
#line 1518
    len = 0;
  } else
#line 1503
  if ((unsigned long )Input_Context != (unsigned long )((void *)0)) {
    {
#line 1506
    len = XmbLookupString(Input_Context, & ev->xkey, (char *)(kbuf), (int )sizeof(kbuf),
                          & keysym, & status_return);
    }
  } else {
    {
#line 1512
    len = XLookupString(& ev->xkey, (char *)(kbuf), (int )sizeof(kbuf), & keysym,
                        & compose);
    }
  }
#line 1536
  if (ctrl) {
#line 1536
    if (keysym == 32UL) {
#line 1537
      thai_keyboard = ! thai_keyboard;
#line 1538
      return;
    }
  }
#line 1567
  if (shft) {
#line 1570
    if (keysym >= 65470UL) {
#line 1570
      if (keysym <= 65479UL) {
#line 1572
        keysym += 10UL;
#line 1573
        shft = 0;
      } else {
#line 1570
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1575
    if (! ctrl) {
#line 1575
      if (! meta) {
#line 1575
        if (PrivateModes & (1UL << 9)) {
          {
#line 1580
          if (keysym == 65365UL) {
#line 1580
            goto case_65365;
          }
#line 1588
          if (keysym == 65366UL) {
#line 1588
            goto case_65366;
          }
#line 1596
          if (keysym == 65379UL) {
#line 1596
            goto case_65379;
          }
#line 1602
          if (keysym == 65451UL) {
#line 1602
            goto case_65451;
          }
#line 1607
          if (keysym == 65453UL) {
#line 1607
            goto case_65453;
          }
#line 1577
          goto switch_break;
          case_65365: /* CIL Label */ 
#line 1581
          if (TermWin.saveLines) {
            {
#line 1583
            scr_page(1, ((int )TermWin.nrow * 4) / 5);
            }
#line 1584
            return;
          }
#line 1586
          goto switch_break;
          case_65366: /* CIL Label */ 
#line 1589
          if (TermWin.saveLines) {
            {
#line 1591
            scr_page(-1, ((int )TermWin.nrow * 4) / 5);
            }
#line 1592
            return;
          }
#line 1594
          goto switch_break;
          case_65379: /* CIL Label */ 
          {
#line 1597
          selection_request(ev->xkey.time, ev->xkey.x, ev->xkey.y);
          }
#line 1598
          return;
#line 1599
          goto switch_break;
          case_65451: /* CIL Label */ 
          {
#line 1603
          change_font(0, "#+");
          }
#line 1604
          return;
#line 1605
          goto switch_break;
          case_65453: /* CIL Label */ 
          {
#line 1608
          change_font(0, "#-");
          }
#line 1609
          return;
#line 1610
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
  {
#line 1617
  if (keysym == 65377UL) {
#line 1617
    goto case_65377;
  }
#line 1629
  if (keysym == 65406UL) {
#line 1629
    goto case_65406;
  }
#line 1615
  goto switch_break___0;
  case_65377: /* CIL Label */ 
#line 1627
  goto switch_break___0;
  case_65406: /* CIL Label */ 
#line 1642
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1645
  if (keysym >= 65280UL) {
#line 1645
    if (keysym <= 65535UL) {
      {
#line 1673
      if (keysym == 65288UL) {
#line 1673
        goto case_65288;
      }
#line 1679
      if (keysym == 65289UL) {
#line 1679
        goto case_65289;
      }
#line 1687
      if (keysym == 65360UL) {
#line 1687
        goto case_65360;
      }
#line 1693
      if (keysym == 65364UL) {
#line 1693
        goto case_65364;
      }
#line 1693
      if (keysym == 65363UL) {
#line 1693
        goto case_65364;
      }
#line 1693
      if (keysym == 65362UL) {
#line 1693
        goto case_65364;
      }
#line 1693
      if (keysym == 65361UL) {
#line 1693
        goto case_65364;
      }
#line 1712
      if (keysym == 65365UL) {
#line 1712
        goto case_65365___0;
      }
#line 1716
      if (keysym == 65366UL) {
#line 1716
        goto case_65366___0;
      }
#line 1720
      if (keysym == 65367UL) {
#line 1720
        goto case_65367;
      }
#line 1724
      if (keysym == 65376UL) {
#line 1724
        goto case_65376;
      }
#line 1728
      if (keysym == 65378UL) {
#line 1728
        goto case_65378;
      }
#line 1732
      if (keysym == 65379UL) {
#line 1732
        goto case_65379___0;
      }
#line 1737
      if (keysym == 65383UL) {
#line 1737
        goto case_65383;
      }
#line 1741
      if (keysym == 65384UL) {
#line 1741
        goto case_65384;
      }
#line 1745
      if (keysym == 65386UL) {
#line 1745
        goto case_65386;
      }
#line 1750
      if (keysym == 65421UL) {
#line 1750
        goto case_65421;
      }
#line 1767
      if (keysym == 65428UL) {
#line 1767
        goto case_65428;
      }
#line 1767
      if (keysym == 65427UL) {
#line 1767
        goto case_65428;
      }
#line 1767
      if (keysym == 65426UL) {
#line 1767
        goto case_65428;
      }
#line 1767
      if (keysym == 65425UL) {
#line 1767
        goto case_65428;
      }
#line 1788
      if (keysym == 65465UL) {
#line 1788
        goto case_65465;
      }
#line 1788
      if (keysym == 65464UL) {
#line 1788
        goto case_65465;
      }
#line 1788
      if (keysym == 65463UL) {
#line 1788
        goto case_65465;
      }
#line 1788
      if (keysym == 65462UL) {
#line 1788
        goto case_65465;
      }
#line 1788
      if (keysym == 65461UL) {
#line 1788
        goto case_65465;
      }
#line 1788
      if (keysym == 65460UL) {
#line 1788
        goto case_65465;
      }
#line 1788
      if (keysym == 65459UL) {
#line 1788
        goto case_65465;
      }
#line 1788
      if (keysym == 65458UL) {
#line 1788
        goto case_65465;
      }
#line 1788
      if (keysym == 65457UL) {
#line 1788
        goto case_65465;
      }
#line 1788
      if (keysym == 65456UL) {
#line 1788
        goto case_65465;
      }
#line 1788
      if (keysym == 65455UL) {
#line 1788
        goto case_65465;
      }
#line 1788
      if (keysym == 65454UL) {
#line 1788
        goto case_65465;
      }
#line 1788
      if (keysym == 65453UL) {
#line 1788
        goto case_65465;
      }
#line 1788
      if (keysym == 65452UL) {
#line 1788
        goto case_65465;
      }
#line 1788
      if (keysym == 65451UL) {
#line 1788
        goto case_65465;
      }
#line 1788
      if (keysym == 65450UL) {
#line 1788
        goto case_65465;
      }
#line 1801
      if (keysym == 65433UL) {
#line 1801
        goto case_65433;
      }
#line 1801
      if (keysym == 65432UL) {
#line 1801
        goto case_65433;
      }
#line 1801
      if (keysym == 65431UL) {
#line 1801
        goto case_65433;
      }
#line 1801
      if (keysym == 65430UL) {
#line 1801
        goto case_65433;
      }
#line 1815
      if (keysym == 65434UL) {
#line 1815
        goto case_65434;
      }
#line 1819
      if (keysym == 65435UL) {
#line 1819
        goto case_65435;
      }
#line 1823
      if (keysym == 65436UL) {
#line 1823
        goto case_65436;
      }
#line 1826
      if (keysym == 65438UL) {
#line 1826
        goto case_65438;
      }
#line 1830
      if (keysym == 65429UL) {
#line 1830
        goto case_65429;
      }
#line 1833
      if (keysym == 65439UL) {
#line 1833
        goto case_65439;
      }
#line 1843
      if (keysym == 65470UL) {
#line 1843
        goto case_65470;
      }
#line 1851
      if (keysym == 65474UL) {
#line 1851
        goto case_65474;
      }
#line 1851
      if (keysym == 65473UL) {
#line 1851
        goto case_65474;
      }
#line 1851
      if (keysym == 65472UL) {
#line 1851
        goto case_65474;
      }
#line 1851
      if (keysym == 65471UL) {
#line 1851
        goto case_65474;
      }
#line 1859
      if (keysym == 65479UL) {
#line 1859
        goto case_65479;
      }
#line 1859
      if (keysym == 65478UL) {
#line 1859
        goto case_65479;
      }
#line 1859
      if (keysym == 65477UL) {
#line 1859
        goto case_65479;
      }
#line 1859
      if (keysym == 65476UL) {
#line 1859
        goto case_65479;
      }
#line 1859
      if (keysym == 65475UL) {
#line 1859
        goto case_65479;
      }
#line 1866
      if (keysym == 65483UL) {
#line 1866
        goto case_65483;
      }
#line 1866
      if (keysym == 65482UL) {
#line 1866
        goto case_65483;
      }
#line 1866
      if (keysym == 65481UL) {
#line 1866
        goto case_65483;
      }
#line 1866
      if (keysym == 65480UL) {
#line 1866
        goto case_65483;
      }
#line 1871
      if (keysym == 65485UL) {
#line 1871
        goto case_65485;
      }
#line 1871
      if (keysym == 65484UL) {
#line 1871
        goto case_65485;
      }
#line 1893
      if (keysym == 65504UL) {
#line 1893
        goto case_65504;
      }
#line 1893
      if (keysym == 65503UL) {
#line 1893
        goto case_65504;
      }
#line 1893
      if (keysym == 65502UL) {
#line 1893
        goto case_65504;
      }
#line 1893
      if (keysym == 65501UL) {
#line 1893
        goto case_65504;
      }
#line 1893
      if (keysym == 65500UL) {
#line 1893
        goto case_65504;
      }
#line 1893
      if (keysym == 65499UL) {
#line 1893
        goto case_65504;
      }
#line 1893
      if (keysym == 65498UL) {
#line 1893
        goto case_65504;
      }
#line 1893
      if (keysym == 65497UL) {
#line 1893
        goto case_65504;
      }
#line 1893
      if (keysym == 65496UL) {
#line 1893
        goto case_65504;
      }
#line 1893
      if (keysym == 65495UL) {
#line 1893
        goto case_65504;
      }
#line 1893
      if (keysym == 65494UL) {
#line 1893
        goto case_65504;
      }
#line 1893
      if (keysym == 65493UL) {
#line 1893
        goto case_65504;
      }
#line 1893
      if (keysym == 65492UL) {
#line 1893
        goto case_65504;
      }
#line 1893
      if (keysym == 65491UL) {
#line 1893
        goto case_65504;
      }
#line 1893
      if (keysym == 65490UL) {
#line 1893
        goto case_65504;
      }
#line 1893
      if (keysym == 65489UL) {
#line 1893
        goto case_65504;
      }
#line 1893
      if (keysym == 65488UL) {
#line 1893
        goto case_65504;
      }
#line 1893
      if (keysym == 65487UL) {
#line 1893
        goto case_65504;
      }
#line 1893
      if (keysym == 65486UL) {
#line 1893
        goto case_65504;
      }
#line 1898
      if (keysym == 65535UL) {
#line 1898
        goto case_65535;
      }
#line 1671
      goto switch_break___1;
      case_65288: /* CIL Label */ 
#line 1674
      len = 1;
#line 1675
      if (PrivateModes & (1UL << 8)) {
#line 1675
        tmp___1 = ! (shft | ctrl);
      } else {
#line 1675
        tmp___1 = shft | ctrl;
      }
#line 1675
      if (tmp___1) {
#line 1675
        kbuf[0] = (unsigned char )'\b';
      } else {
#line 1675
        kbuf[0] = (unsigned char )'\177';
      }
#line 1677
      goto switch_break___1;
      case_65289: /* CIL Label */ 
#line 1680
      if (shft) {
        {
#line 1682
        len = 3;
#line 1683
        strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)"\033[Z");
        }
      }
#line 1685
      goto switch_break___1;
      case_65360: /* CIL Label */ 
      {
#line 1688
      tmp___2 = strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)"\033[1~");
#line 1688
      tmp___3 = strlen((char const   *)tmp___2);
#line 1688
      len = (int )tmp___3;
      }
#line 1689
      goto switch_break___1;
      case_65364: /* CIL Label */ 
      case_65363: /* CIL Label */ 
      case_65362: /* CIL Label */ 
      case_65361: /* CIL Label */ 
      {
#line 1694
      len = 3;
#line 1695
      strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)"\033[@");
#line 1696
      kbuf[2] = (unsigned char )*("DACB" + (keysym - 65361UL));
      }
#line 1697
      if (PrivateModes & (1UL << 6)) {
#line 1699
        kbuf[1] = (unsigned char )'O';
      } else
#line 1702
      if (shft) {
#line 1704
        kbuf[2] = (unsigned char )*("dacb" + (keysym - 65361UL));
      } else
#line 1706
      if (ctrl) {
#line 1708
        kbuf[1] = (unsigned char )'O';
#line 1709
        kbuf[2] = (unsigned char )*("dacb" + (keysym - 65361UL));
      }
#line 1711
      goto switch_break___1;
      case_65365___0: /* CIL Label */ 
      {
#line 1713
      len = 4;
#line 1714
      strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)"\033[5~");
      }
#line 1715
      goto switch_break___1;
      case_65366___0: /* CIL Label */ 
      {
#line 1717
      len = 4;
#line 1718
      strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)"\033[6~");
      }
#line 1719
      goto switch_break___1;
      case_65367: /* CIL Label */ 
      {
#line 1721
      tmp___4 = strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)"\033[4~");
#line 1721
      tmp___5 = strlen((char const   *)tmp___4);
#line 1721
      len = (int )tmp___5;
      }
#line 1722
      goto switch_break___1;
      case_65376: /* CIL Label */ 
      {
#line 1725
      len = 4;
#line 1726
      strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)"\033[4~");
      }
#line 1727
      goto switch_break___1;
      case_65378: /* CIL Label */ 
      {
#line 1729
      len = 4;
#line 1730
      strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)"\033[3~");
      }
#line 1731
      goto switch_break___1;
      case_65379___0: /* CIL Label */ 
      {
#line 1733
      len = 4;
#line 1734
      strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)"\033[2~");
      }
#line 1735
      goto switch_break___1;
      case_65383: /* CIL Label */ 
      {
#line 1738
      len = 5;
#line 1739
      strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)"\033[29~");
      }
#line 1740
      goto switch_break___1;
      case_65384: /* CIL Label */ 
      {
#line 1742
      len = 4;
#line 1743
      strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)"\033[1~");
      }
#line 1744
      goto switch_break___1;
      case_65386: /* CIL Label */ 
      {
#line 1746
      len = 5;
#line 1747
      strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)"\033[28~");
      }
#line 1748
      goto switch_break___1;
      case_65421: /* CIL Label */ 
#line 1752
      if (PrivateModes & (1UL << 7)) {
#line 1752
        tmp___6 = ! shft;
      } else {
#line 1752
        tmp___6 = shft;
      }
#line 1752
      if (tmp___6) {
#line 1754
        len = 1;
#line 1755
        kbuf[0] = (unsigned char )'\r';
      } else {
        {
#line 1759
        len = 3;
#line 1760
        strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)"\033OM");
        }
      }
#line 1762
      goto switch_break___1;
      case_65428: /* CIL Label */ 
      case_65427: /* CIL Label */ 
      case_65426: /* CIL Label */ 
      case_65425: /* CIL Label */ 
      {
#line 1768
      len = 3;
#line 1769
      strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)"\033OP");
#line 1770
      kbuf[2] = (unsigned char )((KeySym )kbuf[2] + (keysym - 65425UL));
      }
#line 1771
      goto switch_break___1;
      case_65465: /* CIL Label */ 
      case_65464: /* CIL Label */ 
      case_65463: /* CIL Label */ 
      case_65462: /* CIL Label */ 
      case_65461: /* CIL Label */ 
      case_65460: /* CIL Label */ 
      case_65459: /* CIL Label */ 
      case_65458: /* CIL Label */ 
      case_65457: /* CIL Label */ 
      case_65456: /* CIL Label */ 
      case_65455: /* CIL Label */ 
      case_65454: /* CIL Label */ 
      case_65453___0: /* CIL Label */ 
      case_65452: /* CIL Label */ 
      case_65451___0: /* CIL Label */ 
      case_65450: /* CIL Label */ 
#line 1790
      if ((PrivateModes & (1UL << 7)) == 0UL) {
#line 1793
        len = 1;
#line 1794
        kbuf[0] = (unsigned char )(42UL + (keysym - 65450UL));
      }
#line 1796
      goto switch_break___1;
      case_65433: /* CIL Label */ 
      case_65432: /* CIL Label */ 
      case_65431: /* CIL Label */ 
      case_65430: /* CIL Label */ 
      {
#line 1802
      len = 3;
#line 1803
      strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)"\033[@");
#line 1804
      kbuf[2] = (unsigned char )*("DACB" + (keysym - 65430UL));
      }
#line 1805
      if (PrivateModes & (1UL << 6)) {
#line 1807
        kbuf[1] = (unsigned char )'O';
      } else
#line 1809
      if (ctrl) {
#line 1811
        kbuf[1] = (unsigned char )'O';
#line 1812
        kbuf[2] = (unsigned char )*("dacb" + (keysym - 65430UL));
      }
#line 1814
      goto switch_break___1;
      case_65434: /* CIL Label */ 
      {
#line 1816
      len = 4;
#line 1817
      strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)"\033[5~");
      }
#line 1818
      goto switch_break___1;
      case_65435: /* CIL Label */ 
      {
#line 1820
      len = 4;
#line 1821
      strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)"\033[6~");
      }
#line 1822
      goto switch_break___1;
      case_65436: /* CIL Label */ 
      {
#line 1824
      tmp___7 = strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)"\033[4~");
#line 1824
      tmp___8 = strlen((char const   *)tmp___7);
#line 1824
      len = (int )tmp___8;
      }
#line 1825
      goto switch_break___1;
      case_65438: /* CIL Label */ 
      {
#line 1827
      len = 4;
#line 1828
      strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)"\033[2~");
      }
#line 1829
      goto switch_break___1;
      case_65429: /* CIL Label */ 
      {
#line 1831
      tmp___9 = strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)"\033[1~");
#line 1831
      tmp___10 = strlen((char const   *)tmp___9);
#line 1831
      len = (int )tmp___10;
      }
#line 1832
      goto switch_break___1;
      case_65439: /* CIL Label */ 
      {
#line 1834
      tmp___11 = strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)"\033[3~");
#line 1834
      tmp___12 = strlen((char const   *)tmp___11);
#line 1834
      len = (int )tmp___12;
      }
#line 1835
      goto switch_break___1;
      case_65470: /* CIL Label */ 
#line 1845
      thai_keyboard = ! thai_keyboard;
#line 1846
      goto switch_break___1;
      case_65474: /* CIL Label */ 
      case_65473: /* CIL Label */ 
      case_65472: /* CIL Label */ 
      case_65471: /* CIL Label */ 
      {
#line 1852
      len = 5;
#line 1852
      sprintf((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)"\033[%02d~",
              (int )(11UL + (keysym - 65470UL)));
      }
#line 1853
      goto switch_break___1;
      case_65479: /* CIL Label */ 
      case_65478: /* CIL Label */ 
      case_65477: /* CIL Label */ 
      case_65476: /* CIL Label */ 
      case_65475: /* CIL Label */ 
      {
#line 1860
      len = 5;
#line 1860
      sprintf((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)"\033[%02d~",
              (int )(17UL + (keysym - 65475UL)));
      }
#line 1861
      goto switch_break___1;
      case_65483: /* CIL Label */ 
      case_65482: /* CIL Label */ 
      case_65481: /* CIL Label */ 
      case_65480: /* CIL Label */ 
      {
#line 1867
      len = 5;
#line 1867
      sprintf((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)"\033[%02d~",
              (int )(23UL + (keysym - 65480UL)));
      }
#line 1868
      goto switch_break___1;
      case_65485: /* CIL Label */ 
      case_65484: /* CIL Label */ 
      {
#line 1872
      len = 5;
#line 1872
      sprintf((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)"\033[%02d~",
              (int )(28UL + (keysym - 65484UL)));
      }
#line 1873
      goto switch_break___1;
      case_65504: /* CIL Label */ 
      case_65503: /* CIL Label */ 
      case_65502: /* CIL Label */ 
      case_65501: /* CIL Label */ 
      case_65500: /* CIL Label */ 
      case_65499: /* CIL Label */ 
      case_65498: /* CIL Label */ 
      case_65497: /* CIL Label */ 
      case_65496: /* CIL Label */ 
      case_65495: /* CIL Label */ 
      case_65494: /* CIL Label */ 
      case_65493: /* CIL Label */ 
      case_65492: /* CIL Label */ 
      case_65491: /* CIL Label */ 
      case_65490: /* CIL Label */ 
      case_65489: /* CIL Label */ 
      case_65488: /* CIL Label */ 
      case_65487: /* CIL Label */ 
      case_65486: /* CIL Label */ 
      {
#line 1894
      len = 5;
#line 1894
      sprintf((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)"\033[%02d~",
              (int )(31UL + (keysym - 65486UL)));
      }
#line 1895
      goto switch_break___1;
      case_65535: /* CIL Label */ 
      {
#line 1899
      tmp___13 = strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)"\033[3~");
#line 1899
      tmp___14 = strlen((char const   *)tmp___13);
#line 1899
      len = (int )tmp___14;
      }
#line 1900
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
    } else {
#line 1645
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 1904
  if (ctrl) {
#line 1904
    if (keysym == 45UL) {
#line 1906
      len = 1;
#line 1907
      kbuf[0] = (unsigned char )'\037';
    } else {
#line 1904
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1926
  if (thai_keyboard) {
#line 1928
    i = 0;
    {
#line 1928
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1928
      if (! (i < len)) {
#line 1928
        goto while_break___0;
      }
      {
#line 1929
      tmp___15 = thai_map_qwerty(kbuf[i]);
#line 1929
      kbuf[i] = (unsigned char )tmp___15;
#line 1928
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1939
  if (len <= 0) {
#line 1940
    return;
  }
#line 1952
  if ((int )kbuf[0] == 27) {
#line 1952
    if ((int )kbuf[1] == 91) {
#line 1952
      if ((int )kbuf[len - 1] == 126) {
#line 1953
        if (shft) {
#line 1953
          if (ctrl) {
#line 1953
            tmp___16 = '@';
          } else {
#line 1953
            tmp___16 = '$';
          }
#line 1953
          kbuf[len - 1] = (unsigned char )tmp___16;
        } else {
#line 1953
          if (ctrl) {
#line 1953
            tmp___17 = '^';
          } else {
#line 1953
            tmp___17 = '~';
          }
#line 1953
          kbuf[len - 1] = (unsigned char )tmp___17;
        }
      }
    }
  }
#line 1956
  if (meta) {
    {
#line 1962
    ch = (unsigned char )'\033';
#line 1963
    tt_write((unsigned char const   *)(& ch), 1U);
    }
  }
  {
#line 1992
  tt_write((unsigned char const   *)(kbuf), (unsigned int )len);
  }
#line 1993
  return;
}
}
#line 1997 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static void cmd_ungetc(unsigned char ch ) 
{ 
  int n ;

  {
#line 2000
  if ((unsigned long )cmdbuf_ptr > (unsigned long )(cmdbuf_base)) {
#line 2003
    cmdbuf_ptr --;
#line 2004
    *cmdbuf_ptr = ch;
  } else {
#line 2008
    n = (int )(cmdbuf_endp - cmdbuf_base);
#line 2009
    if (n > 0) {
#line 2011
      if ((unsigned long )n == sizeof(cmdbuf_base)) {
#line 2014
        n --;
#line 2015
        cmdbuf_endp --;
      }
      {
#line 2017
      memmove((void *)(cmdbuf_base + 1), (void const   *)(cmdbuf_base), (size_t )n);
      }
    }
#line 2019
    *cmdbuf_ptr = ch;
#line 2020
    cmdbuf_endp ++;
  }
#line 2022
  return;
}
}
#line 2025 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
unsigned int cmd_write(unsigned char const   *str , unsigned int count ) 
{ 
  unsigned int tmp ;

  {
  {
#line 2028
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2028
    tmp = count;
#line 2028
    count --;
#line 2028
    if (! tmp) {
#line 2028
      goto while_break;
    }
    {
#line 2029
    cmd_ungetc((unsigned char )*(str + count));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2031
  return (0U);
}
}
#line 2042 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static short refreshed  =    (short)0;
#line 2038 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static unsigned char cmd_getc(void) 
{ 
  fd_set readfds ;
  int retval ;
  struct itimerval value ;
  XEvent ev ;
  int tmp ;
  int __d0 ;
  int __d1 ;
  struct timeval *tmp___0 ;
  unsigned int count ;
  int n ;
  ssize_t tmp___1 ;
  unsigned char *tmp___2 ;

  {
#line 2054
  if (refresh_count > refresh_limit * (int )TermWin.nrow) {
#line 2056
    if (refresh_limit < 1) {
#line 2057
      refresh_limit ++;
    }
    {
#line 2058
    refresh_count = 0;
#line 2059
    refreshed = (short)1;
#line 2060
    scr_refresh(refresh_type);
    }
  }
#line 2064
  if ((unsigned long )cmdbuf_ptr < (unsigned long )cmdbuf_endp) {
#line 2065
    goto Return_Char;
  }
  {
#line 2067
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2069
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2069
      tmp = XPending(Xdisplay);
      }
#line 2069
      if (! tmp) {
#line 2069
        goto while_break___0;
      }
      {
#line 2072
      refreshed = (short)0;
#line 2073
      XNextEvent(Xdisplay, & ev);
#line 2074
      process_x_event(& ev);
      }
#line 2077
      if ((unsigned long )cmdbuf_ptr < (unsigned long )cmdbuf_endp) {
#line 2078
        goto Return_Char;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2081
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2081
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& readfds.fds_bits[0]): "memory");
#line 2081
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2082
    readfds.fds_bits[cmd_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << cmd_fd % (8 * (int )sizeof(__fd_mask ));
#line 2083
    readfds.fds_bits[Xfd / (8 * (int )sizeof(__fd_mask ))] |= 1L << Xfd % (8 * (int )sizeof(__fd_mask ));
#line 2084
    value.it_value.tv_usec = (__suseconds_t )5000;
#line 2085
    value.it_value.tv_sec = (__time_t )0;
#line 2087
    if (refreshed) {
#line 2087
      tmp___0 = (struct timeval *)((void *)0);
    } else {
#line 2087
      tmp___0 = & value.it_value;
    }
    {
#line 2087
    retval = select((int )num_fds, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)((void *)0),
                    (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)tmp___0);
    }
#line 2091
    if ((readfds.fds_bits[cmd_fd / (8 * (int )sizeof(__fd_mask ))] & (1L << cmd_fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 2093
      count = (unsigned int )(sizeof(cmdbuf_base) - 1UL);
#line 2094
      cmdbuf_endp = cmdbuf_base;
#line 2094
      cmdbuf_ptr = cmdbuf_endp;
      {
#line 2097
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2097
        if (! count) {
#line 2097
          goto while_break___2;
        }
        {
#line 2099
        tmp___1 = read(cmd_fd, (void *)cmdbuf_endp, (size_t )count);
#line 2099
        n = (int )tmp___1;
        }
#line 2100
        if (n <= 0) {
#line 2101
          goto while_break___2;
        }
#line 2102
        cmdbuf_endp += n;
#line 2103
        count -= (unsigned int )n;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 2106
      if ((unsigned long )cmdbuf_ptr < (unsigned long )cmdbuf_endp) {
#line 2107
        goto Return_Char;
      }
    }
#line 2110
    if (retval == 0) {
#line 2112
      refresh_count = 0;
#line 2113
      refresh_limit = 1;
#line 2114
      if (! refreshed) {
        {
#line 2116
        refreshed = (short)1;
#line 2117
        scr_refresh(refresh_type);
#line 2118
        scrollbar_show(1);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2122
  return ((unsigned char)0);
  Return_Char: 
#line 2125
  refreshed = (short)0;
#line 2126
  tmp___2 = cmdbuf_ptr;
#line 2126
  cmdbuf_ptr ++;
#line 2126
  return (*tmp___2);
}
}
#line 2134 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static Time buttonpress_time  ;
#line 2135 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static int clicks  =    0;
#line 2137 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static int bypass_keystate  =    0;
#line 2131 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static void process_x_event(XEvent *ev ) 
{ 
  int reportmode ;
  XEvent unused_xevent ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  Window unused_root ;
  Window unused_child ;
  int unused_root_x ;
  int unused_root_y ;
  unsigned int unused_mask ;
  int tmp___4 ;
  Window unused_root___0 ;
  Window unused_child___0 ;
  int unused_root_x___0 ;
  int unused_root_y___0 ;
  unsigned int unused_mask___0 ;
  int tmp___5 ;

  {
  {
#line 2142
  if (ev->type == 2) {
#line 2142
    goto case_2;
  }
#line 2146
  if (ev->type == 33) {
#line 2146
    goto case_33;
  }
#line 2178
  if (ev->type == 34) {
#line 2178
    goto case_34;
  }
#line 2190
  if (ev->type == 15) {
#line 2190
    goto case_15;
  }
#line 2207
  if (ev->type == 9) {
#line 2207
    goto case_9;
  }
#line 2218
  if (ev->type == 10) {
#line 2218
    goto case_10;
  }
#line 2229
  if (ev->type == 22) {
#line 2229
    goto case_22;
  }
#line 2233
  if (ev->type == 29) {
#line 2233
    goto case_29;
  }
#line 2237
  if (ev->type == 31) {
#line 2237
    goto case_31;
  }
#line 2241
  if (ev->type == 30) {
#line 2241
    goto case_30;
  }
#line 2246
  if (ev->type == 12) {
#line 2246
    goto case_12;
  }
#line 2246
  if (ev->type == 13) {
#line 2246
    goto case_12;
  }
#line 2271
  if (ev->type == 4) {
#line 2271
    goto case_4;
  }
#line 2429
  if (ev->type == 5) {
#line 2429
    goto case_5___0;
  }
#line 2487
  if (ev->type == 6) {
#line 2487
    goto case_6;
  }
#line 2140
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 2143
  lookup_key(ev);
  }
#line 2144
  goto switch_break;
  case_33: /* CIL Label */ 
#line 2147
  if (ev->xclient.format == 32) {
#line 2147
    if ((Atom )ev->xclient.data.l[0] == wmDeleteWindow) {
      {
#line 2148
      exit(0);
      }
    }
  }
#line 2176
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 2179
  XRefreshKeyboardMapping(& ev->xmapping);
  }
#line 2180
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 2193
  if (ev->xvisibility.state == 0) {
#line 2193
    goto case_0;
  }
#line 2197
  if (ev->xvisibility.state == 1) {
#line 2197
    goto case_1;
  }
#line 2201
  goto switch_default;
  case_0: /* CIL Label */ 
#line 2194
  refresh_type = 0;
#line 2195
  goto switch_break___0;
  case_1: /* CIL Label */ 
#line 2198
  refresh_type = 1;
#line 2199
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 2202
  refresh_type = 2;
#line 2203
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 2205
  goto switch_break;
  case_9: /* CIL Label */ 
#line 2208
  if (! TermWin.focus) {
#line 2210
    TermWin.focus = (short)1;
#line 2212
    if ((unsigned long )Input_Context != (unsigned long )((void *)0)) {
      {
#line 2213
      XSetICFocus(Input_Context);
      }
    }
  }
#line 2216
  goto switch_break;
  case_10: /* CIL Label */ 
#line 2219
  if (TermWin.focus) {
#line 2221
    TermWin.focus = (short)0;
#line 2223
    if ((unsigned long )Input_Context != (unsigned long )((void *)0)) {
      {
#line 2224
      XUnsetICFocus(Input_Context);
      }
    }
  }
#line 2227
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 2230
  resize_window();
  }
#line 2231
  goto switch_break;
  case_29: /* CIL Label */ 
  {
#line 2234
  selection_clear();
  }
#line 2235
  goto switch_break;
  case_31: /* CIL Label */ 
  {
#line 2238
  selection_paste(ev->xselection.requestor, (unsigned int )ev->xselection.property,
                  1);
  }
#line 2239
  goto switch_break;
  case_30: /* CIL Label */ 
  {
#line 2242
  selection_send(& ev->xselectionrequest);
  }
#line 2243
  goto switch_break;
  case_12: /* CIL Label */ 
  case_13: /* CIL Label */ 
#line 2247
  if (ev->xany.window == TermWin.vt) {
    {
#line 2249
    scr_expose(ev->xexpose.x, ev->xexpose.y, ev->xexpose.width, ev->xexpose.height);
    }
  } else {
    {
#line 2256
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 2256
      tmp = XCheckTypedWindowEvent(Xdisplay, ev->xany.window, 12, & unused_xevent);
      }
#line 2256
      if (! tmp) {
#line 2256
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2259
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2259
      tmp___0 = XCheckTypedWindowEvent(Xdisplay, ev->xany.window, 13, & unused_xevent);
      }
#line 2259
      if (! tmp___0) {
#line 2259
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2262
    if (scrollBar.state) {
#line 2262
      if (ev->xany.window == scrollBar.win) {
        {
#line 2264
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2264
          scrollBar.state = (short)1;
#line 2264
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 2265
        scrollbar_show(0);
        }
      }
    }
  }
#line 2269
  goto switch_break;
  case_4: /* CIL Label */ 
#line 2272
  bypass_keystate = (int )(ev->xbutton.state & (unsigned int )((1 << 3) | 1));
#line 2273
  if (bypass_keystate) {
#line 2273
    reportmode = 0;
  } else {
#line 2273
    reportmode = (int )(PrivateModes & ((1UL << 11) | (1UL << 12)));
  }
#line 2276
  if (ev->xany.window == TermWin.vt) {
#line 2278
    if (! (ev->xbutton.subwindow != 0UL)) {
#line 2282
      if (reportmode) {
#line 2284
        if ((unsigned long )reportmode & (1UL << 11)) {
#line 2287
          ev->xbutton.state = 0U;
        }
        {
#line 2298
        clicks = 1;
#line 2300
        mouse_report(& ev->xbutton);
        }
      } else {
        {
#line 2305
        if (ev->xbutton.button == 1U) {
#line 2305
          goto case_1___0;
        }
#line 2313
        if (ev->xbutton.button == 3U) {
#line 2313
          goto case_3;
        }
#line 2317
        if (ev->xbutton.button == 4U) {
#line 2317
          goto case_4___0;
        }
#line 2321
        if (ev->xbutton.button == 5U) {
#line 2321
          goto case_5;
        }
#line 2303
        goto switch_break___1;
        case_1___0: /* CIL Label */ 
#line 2306
        if (ev->xbutton.time - buttonpress_time < 500UL) {
#line 2307
          clicks ++;
        } else {
#line 2309
          clicks = 1;
        }
        {
#line 2310
        selection_click(clicks, ev->xbutton.x, ev->xbutton.y);
        }
#line 2311
        goto switch_break___1;
        case_3: /* CIL Label */ 
        {
#line 2314
        selection_extend(ev->xbutton.x, ev->xbutton.y);
        }
#line 2315
        goto switch_break___1;
        case_4___0: /* CIL Label */ 
        {
#line 2318
        scr_page(1, (int )TermWin.nrow / 4);
        }
#line 2319
        goto switch_break___1;
        case_5: /* CIL Label */ 
        {
#line 2322
        scr_page(-1, (int )TermWin.nrow / 4);
        }
#line 2323
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
      }
#line 2325
      buttonpress_time = ev->xbutton.time;
#line 2326
      return;
    }
  }
#line 2330
  if (scrollBar.state) {
#line 2330
    if (ev->xany.window == scrollBar.win) {
      {
#line 2332
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2332
        scrollBar.state = (short)1;
#line 2332
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 2344
      if (reportmode) {
#line 2351
        if (ev->xbutton.y < (int )scrollBar.beg) {
          {
#line 2352
          tt_printf("\033[A");
          }
        } else
#line 2353
        if (ev->xbutton.y > (int )scrollBar.end) {
          {
#line 2354
          tt_printf("\033[B");
          }
        } else {
          {
#line 2358
          if (ev->xbutton.button == 2U) {
#line 2358
            goto case_2___0;
          }
#line 2361
          if (ev->xbutton.button == 1U) {
#line 2361
            goto case_1___1;
          }
#line 2364
          if (ev->xbutton.button == 3U) {
#line 2364
            goto case_3___0;
          }
#line 2356
          goto switch_break___2;
          case_2___0: /* CIL Label */ 
          {
#line 2359
          tt_printf("\f");
          }
#line 2360
          goto switch_break___2;
          case_1___1: /* CIL Label */ 
          {
#line 2362
          tt_printf("\033[6~");
          }
#line 2363
          goto switch_break___2;
          case_3___0: /* CIL Label */ 
          {
#line 2365
          tt_printf("\033[5~");
          }
#line 2366
          goto switch_break___2;
          switch_break___2: /* CIL Label */ ;
          }
        }
      } else
#line 2372
      if (ev->xbutton.button == 4U) {
        {
#line 2374
        scr_page(1, (int )TermWin.nrow / 4);
        }
      } else
#line 2376
      if (ev->xbutton.button == 5U) {
        {
#line 2378
        scr_page(-1, (int )TermWin.nrow / 4);
        }
      } else
#line 2380
      if (ev->xbutton.y < (int )scrollBar.beg) {
#line 2383
        if (ev->xbutton.button == 1U) {
          {
#line 2383
          tmp___1 = scr_page(1, 1);
          }
#line 2383
          if (tmp___1) {
            {
#line 2384
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 2384
              scrollBar.state = (short )'U';
#line 2384
              goto while_break___3;
            }
            while_break___3: /* CIL Label */ ;
            }
          }
        }
      } else
#line 2386
      if (ev->xbutton.y > (int )scrollBar.end) {
#line 2388
        if (ev->xbutton.button == 1U) {
          {
#line 2388
          tmp___2 = scr_page(-1, 1);
          }
#line 2388
          if (tmp___2) {
            {
#line 2389
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 2389
              scrollBar.state = (short )'D';
#line 2389
              goto while_break___4;
            }
            while_break___4: /* CIL Label */ ;
            }
          }
        }
      } else {
        {
#line 2394
        if (ev->xbutton.button == 2U) {
#line 2394
          goto case_2___1;
        }
#line 2407
        if (ev->xbutton.button == 3U) {
#line 2407
          goto case_3___1;
        }
#line 2407
        if (ev->xbutton.button == 1U) {
#line 2407
          goto case_3___1;
        }
#line 2392
        goto switch_break___3;
        case_2___1: /* CIL Label */ 
#line 2396
        if (ev->xbutton.y < (int )scrollBar.top) {
          {
#line 2399
          scr_move_to(ev->xbutton.y - (int )scrollBar.beg, (int )scrollBar.end - (int )scrollBar.beg);
          }
        } else
#line 2396
        if (ev->xbutton.y > (int )scrollBar.bot) {
          {
#line 2399
          scr_move_to(ev->xbutton.y - (int )scrollBar.beg, (int )scrollBar.end - (int )scrollBar.beg);
          }
        }
        {
#line 2401
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 2401
          scrollBar.state = (short )'m';
#line 2401
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 2402
        goto switch_break___3;
        case_3___1: /* CIL Label */ 
        case_1___2: /* CIL Label */ 
#line 2409
        if (ev->xbutton.y < (int )scrollBar.top) {
          {
#line 2410
          scr_page(1, (int )TermWin.nrow / 4);
          }
        } else
#line 2411
        if (ev->xbutton.y > (int )scrollBar.bot) {
          {
#line 2412
          scr_page(-1, (int )TermWin.nrow / 4);
          }
        } else {
          {
#line 2414
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 2414
            scrollBar.state = (short )'m';
#line 2414
            goto while_break___6;
          }
          while_break___6: /* CIL Label */ ;
          }
        }
#line 2422
        goto switch_break___3;
        switch_break___3: /* CIL Label */ ;
        }
      }
#line 2425
      return;
    }
  }
#line 2427
  goto switch_break;
  case_5___0: /* CIL Label */ 
#line 2430
  if (bypass_keystate) {
#line 2430
    reportmode = 0;
  } else {
#line 2430
    reportmode = (int )(PrivateModes & ((1UL << 11) | (1UL << 12)));
  }
  {
#line 2433
  tmp___3 = __ctype_b_loc();
  }
#line 2433
  if ((int const   )*(*tmp___3 + (int )scrollBar.state) & 256) {
    {
#line 2435
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 2435
      scrollBar.state = (short)1;
#line 2435
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 2436
    scrollbar_show(0);
    }
  }
#line 2439
  if (ev->xany.window == TermWin.vt) {
#line 2441
    if (! (ev->xbutton.subwindow != 0UL)) {
#line 2445
      if (reportmode) {
        {
#line 2449
        if (((unsigned long )reportmode & ((1UL << 11) | (1UL << 12))) == 1UL << 11) {
#line 2449
          goto case_exp;
        }
#line 2452
        if (((unsigned long )reportmode & ((1UL << 11) | (1UL << 12))) == 1UL << 12) {
#line 2452
          goto case_exp___0;
        }
#line 2447
        goto switch_break___4;
        case_exp: /* CIL Label */ 
#line 2450
        goto switch_break___4;
        case_exp___0: /* CIL Label */ 
        {
#line 2453
        ev->xbutton.state = (unsigned int )bypass_keystate;
#line 2454
        ev->xbutton.button = 0U;
#line 2455
        mouse_report(& ev->xbutton);
        }
#line 2456
        goto switch_break___4;
        switch_break___4: /* CIL Label */ ;
        }
#line 2458
        return;
      }
#line 2465
      if (PrivateModes & ((1UL << 11) | (1UL << 12))) {
#line 2465
        if (bypass_keystate) {
#line 2465
          if (ev->xbutton.button == 1U) {
#line 2465
            if (clicks <= 1) {
              {
#line 2469
              selection_extend(ev->xbutton.x, ev->xbutton.y);
              }
            }
          }
        }
      }
      {
#line 2474
      if (ev->xbutton.button == 3U) {
#line 2474
        goto case_3___2;
      }
#line 2474
      if (ev->xbutton.button == 1U) {
#line 2474
        goto case_3___2;
      }
#line 2478
      if (ev->xbutton.button == 2U) {
#line 2478
        goto case_2___2;
      }
#line 2471
      goto switch_break___5;
      case_3___2: /* CIL Label */ 
      case_1___3: /* CIL Label */ 
      {
#line 2475
      selection_make(ev->xbutton.time);
      }
#line 2476
      goto switch_break___5;
      case_2___2: /* CIL Label */ 
      {
#line 2479
      selection_request(ev->xbutton.time, ev->xbutton.x, ev->xbutton.y);
      }
#line 2481
      goto switch_break___5;
      switch_break___5: /* CIL Label */ ;
      }
    }
  }
#line 2485
  goto switch_break;
  case_6: /* CIL Label */ 
#line 2488
  if (PrivateModes & ((1UL << 11) | (1UL << 12))) {
#line 2488
    if (! bypass_keystate) {
#line 2489
      goto switch_break;
    }
  }
#line 2491
  if (ev->xany.window == TermWin.vt) {
#line 2493
    if (ev->xbutton.state & (unsigned int )((1 << 8) | (1 << 10))) {
#line 2493
      if (clicks <= 1) {
        {
#line 2500
        while (1) {
          while_continue___8: /* CIL Label */ ;
          {
#line 2500
          tmp___4 = XCheckTypedWindowEvent(Xdisplay, TermWin.vt, 6, ev);
          }
#line 2500
          if (! tmp___4) {
#line 2500
            goto while_break___8;
          }
        }
        while_break___8: /* CIL Label */ ;
        }
        {
#line 2502
        XQueryPointer(Xdisplay, TermWin.vt, & unused_root, & unused_child, & unused_root_x,
                      & unused_root_y, & ev->xbutton.x, & ev->xbutton.y, & unused_mask);
        }
#line 2509
        if (ev->xmotion.time - buttonpress_time > 50UL) {
          {
#line 2511
          selection_extend(ev->xbutton.x, ev->xbutton.y);
          }
        }
      }
    }
  } else
#line 2514
  if (ev->xany.window == scrollBar.win) {
#line 2514
    if ((int )scrollBar.state == 109) {
      {
#line 2520
      while (1) {
        while_continue___9: /* CIL Label */ ;
        {
#line 2520
        tmp___5 = XCheckTypedWindowEvent(Xdisplay, scrollBar.win, 6, ev);
        }
#line 2520
        if (! tmp___5) {
#line 2520
          goto while_break___9;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 2522
      XQueryPointer(Xdisplay, scrollBar.win, & unused_root___0, & unused_child___0,
                    & unused_root_x___0, & unused_root_y___0, & ev->xbutton.x, & ev->xbutton.y,
                    & unused_mask___0);
#line 2527
      scr_move_to(ev->xbutton.y - (int )scrollBar.beg, (int )scrollBar.end - (int )scrollBar.beg);
#line 2529
      scr_refresh(refresh_type);
#line 2530
      refresh_limit = 0;
#line 2530
      refresh_count = refresh_limit;
#line 2531
      scrollbar_show(1);
      }
    }
  }
#line 2533
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2535
  return;
}
}
#line 2542 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
void tt_write(unsigned char const   *buf___0 , unsigned int count ) 
{ 
  int n ;
  ssize_t tmp ;

  {
  {
#line 2545
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2545
    if (! (count > 0U)) {
#line 2545
      goto while_break;
    }
    {
#line 2547
    tmp = write(cmd_fd, (void const   *)buf___0, (size_t )count);
#line 2547
    n = (int )tmp;
    }
#line 2548
    if (n > 0) {
#line 2550
      count -= (unsigned int )n;
#line 2551
      buf___0 += n;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2554
  return;
}
}
#line 2563 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static char buf[256]  ;
#line 2560 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
void tt_printf(char const   *fmt  , ...) 
{ 
  va_list arg_ptr ;
  size_t tmp ;

  {
  {
#line 2566
  __builtin_va_start(arg_ptr, fmt);
#line 2567
  vsprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)fmt, arg_ptr);
#line 2568
  __builtin_va_end(arg_ptr);
#line 2569
  tmp = strlen((char const   *)(buf));
#line 2569
  tt_write((unsigned char const   *)((unsigned char *)(buf)), (unsigned int )tmp);
  }
#line 2570
  return;
}
}
#line 2631 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static void process_escape_seq(void) 
{ 
  unsigned char ch ;
  unsigned char tmp ;
  unsigned char tmp___0 ;
  unsigned char tmp___1 ;
  unsigned char tmp___2 ;
  unsigned char tmp___3 ;
  unsigned char tmp___4 ;

  {
  {
#line 2634
  tmp = cmd_getc();
#line 2634
  ch = tmp;
  }
  {
#line 2639
  if ((int )ch == 35) {
#line 2639
    goto case_35;
  }
#line 2643
  if ((int )ch == 40) {
#line 2643
    goto case_40;
  }
#line 2646
  if ((int )ch == 41) {
#line 2646
    goto case_41;
  }
#line 2649
  if ((int )ch == 42) {
#line 2649
    goto case_42;
  }
#line 2652
  if ((int )ch == 43) {
#line 2652
    goto case_43;
  }
#line 2660
  if ((int )ch == 55) {
#line 2660
    goto case_55;
  }
#line 2663
  if ((int )ch == 56) {
#line 2663
    goto case_56;
  }
#line 2667
  if ((int )ch == 62) {
#line 2667
    goto case_62;
  }
#line 2667
  if ((int )ch == 61) {
#line 2667
    goto case_62;
  }
#line 2670
  if ((int )ch == 64) {
#line 2670
    goto case_64;
  }
#line 2673
  if ((int )ch == 68) {
#line 2673
    goto case_68;
  }
#line 2676
  if ((int )ch == 69) {
#line 2676
    goto case_69;
  }
#line 2679
  if ((int )ch == 72) {
#line 2679
    goto case_72;
  }
#line 2682
  if ((int )ch == 77) {
#line 2682
    goto case_77;
  }
#line 2687
  if ((int )ch == 90) {
#line 2687
    goto case_90;
  }
#line 2690
  if ((int )ch == 91) {
#line 2690
    goto case_91;
  }
#line 2693
  if ((int )ch == 93) {
#line 2693
    goto case_93;
  }
#line 2696
  if ((int )ch == 99) {
#line 2696
    goto case_99;
  }
#line 2699
  if ((int )ch == 110) {
#line 2699
    goto case_110;
  }
#line 2702
  if ((int )ch == 111) {
#line 2702
    goto case_111;
  }
#line 2636
  goto switch_break;
  case_35: /* CIL Label */ 
  {
#line 2640
  tmp___0 = cmd_getc();
  }
#line 2640
  if ((int )tmp___0 == 56) {
    {
#line 2641
    scr_E();
    }
  }
#line 2642
  goto switch_break;
  case_40: /* CIL Label */ 
  {
#line 2644
  tmp___1 = cmd_getc();
#line 2644
  scr_charset_set(0, (unsigned int )tmp___1);
  }
#line 2645
  goto switch_break;
  case_41: /* CIL Label */ 
  {
#line 2647
  tmp___2 = cmd_getc();
#line 2647
  scr_charset_set(1, (unsigned int )tmp___2);
  }
#line 2648
  goto switch_break;
  case_42: /* CIL Label */ 
  {
#line 2650
  tmp___3 = cmd_getc();
#line 2650
  scr_charset_set(2, (unsigned int )tmp___3);
  }
#line 2651
  goto switch_break;
  case_43: /* CIL Label */ 
  {
#line 2653
  tmp___4 = cmd_getc();
#line 2653
  scr_charset_set(3, (unsigned int )tmp___4);
  }
#line 2654
  goto switch_break;
  case_55: /* CIL Label */ 
  {
#line 2661
  scr_cursor('s');
  }
#line 2662
  goto switch_break;
  case_56: /* CIL Label */ 
  {
#line 2664
  scr_cursor('r');
  }
#line 2665
  goto switch_break;
  case_62: /* CIL Label */ 
  case_61: /* CIL Label */ 
  {
#line 2668
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2668
    if ((int )ch == 61) {
#line 2668
      PrivateModes |= 1UL << 7;
    } else {
#line 2668
      PrivateModes &= ~ (1UL << 7);
    }
#line 2668
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2669
  goto switch_break;
  case_64: /* CIL Label */ 
  {
#line 2671
  cmd_getc();
  }
#line 2672
  goto switch_break;
  case_68: /* CIL Label */ 
  {
#line 2674
  scr_index(1);
  }
#line 2675
  goto switch_break;
  case_69: /* CIL Label */ 
  {
#line 2677
  scr_add_lines((unsigned char const   *)"\n\r", 1, 2);
  }
#line 2678
  goto switch_break;
  case_72: /* CIL Label */ 
  {
#line 2680
  scr_set_tab(1);
  }
#line 2681
  goto switch_break;
  case_77: /* CIL Label */ 
  {
#line 2683
  scr_index(-1);
  }
#line 2684
  goto switch_break;
  case_90: /* CIL Label */ 
  {
#line 2688
  tt_printf("\033[?1;2c");
  }
#line 2689
  goto switch_break;
  case_91: /* CIL Label */ 
  {
#line 2691
  process_csi_seq();
  }
#line 2692
  goto switch_break;
  case_93: /* CIL Label */ 
  {
#line 2694
  process_xterm_seq();
  }
#line 2695
  goto switch_break;
  case_99: /* CIL Label */ 
  {
#line 2697
  scr_poweron();
  }
#line 2698
  goto switch_break;
  case_110: /* CIL Label */ 
  {
#line 2700
  scr_charset_choose(2);
  }
#line 2701
  goto switch_break;
  case_111: /* CIL Label */ 
  {
#line 2703
  scr_charset_choose(3);
  }
#line 2704
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2706
  return;
}
}
#line 2710 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static void process_csi_seq(void) 
{ 
  unsigned char ch ;
  unsigned char priv ;
  unsigned int nargs ;
  int arg[32] ;
  int n ;
  unsigned short const   **tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
  {
#line 2717
  nargs = 0U;
#line 2718
  arg[0] = 0;
#line 2719
  arg[1] = 0;
#line 2721
  priv = (unsigned char)0;
#line 2722
  ch = cmd_getc();
  }
#line 2723
  if ((int )ch >= 60) {
#line 2723
    if ((int )ch <= 63) {
      {
#line 2725
      priv = ch;
#line 2726
      ch = cmd_getc();
      }
    }
  }
  {
#line 2730
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2733
    n = 0;
    {
#line 2733
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2733
      tmp = __ctype_b_loc();
      }
#line 2733
      if (! ((int const   )*(*tmp + (int )ch) & 2048)) {
#line 2733
        goto while_break___0;
      }
      {
#line 2734
      n = n * 10 + ((int )ch - 48);
#line 2733
      ch = cmd_getc();
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2736
    if (nargs < 32U) {
#line 2737
      tmp___0 = nargs;
#line 2737
      nargs ++;
#line 2737
      arg[tmp___0] = n;
    }
#line 2738
    if ((int )ch == 8) {
      {
#line 2740
      scr_backspace();
      }
    } else
#line 2742
    if ((int )ch == 27) {
      {
#line 2744
      process_escape_seq();
      }
#line 2745
      return;
    } else
#line 2747
    if ((int )ch < 32) {
      {
#line 2749
      scr_add_lines((unsigned char const   *)(& ch), 0, 1);
      }
#line 2750
      return;
    }
#line 2752
    if ((int )ch < 64) {
      {
#line 2753
      ch = cmd_getc();
      }
    }
#line 2730
    if ((int )ch >= 32) {
#line 2730
      if (! ((int )ch < 64)) {
#line 2730
        goto while_break;
      }
    } else {
#line 2730
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2756
  if ((int )ch == 27) {
    {
#line 2758
    process_escape_seq();
    }
#line 2759
    return;
  } else
#line 2761
  if ((int )ch < 32) {
#line 2762
    return;
  }
  {
#line 2780
  if ((int )ch == 101) {
#line 2780
    goto case_101;
  }
#line 2780
  if ((int )ch == 65) {
#line 2780
    goto case_101;
  }
#line 2783
  if ((int )ch == 66) {
#line 2783
    goto case_66;
  }
#line 2787
  if ((int )ch == 97) {
#line 2787
    goto case_97;
  }
#line 2787
  if ((int )ch == 67) {
#line 2787
    goto case_97;
  }
#line 2790
  if ((int )ch == 68) {
#line 2790
    goto case_68;
  }
#line 2793
  if ((int )ch == 69) {
#line 2793
    goto case_69;
  }
#line 2796
  if ((int )ch == 70) {
#line 2796
    goto case_70;
  }
#line 2800
  if ((int )ch == 96) {
#line 2800
    goto case_96;
  }
#line 2800
  if ((int )ch == 71) {
#line 2800
    goto case_96;
  }
#line 2803
  if ((int )ch == 100) {
#line 2803
    goto case_100;
  }
#line 2807
  if ((int )ch == 102) {
#line 2807
    goto case_102;
  }
#line 2807
  if ((int )ch == 72) {
#line 2807
    goto case_102;
  }
#line 2821
  if ((int )ch == 73) {
#line 2821
    goto case_73;
  }
#line 2824
  if ((int )ch == 90) {
#line 2824
    goto case_90;
  }
#line 2827
  if ((int )ch == 74) {
#line 2827
    goto case_74;
  }
#line 2830
  if ((int )ch == 75) {
#line 2830
    goto case_75;
  }
#line 2833
  if ((int )ch == 64) {
#line 2833
    goto case_64;
  }
#line 2836
  if ((int )ch == 76) {
#line 2836
    goto case_76;
  }
#line 2839
  if ((int )ch == 77) {
#line 2839
    goto case_77;
  }
#line 2842
  if ((int )ch == 88) {
#line 2842
    goto case_88;
  }
#line 2845
  if ((int )ch == 80) {
#line 2845
    goto case_80;
  }
#line 2849
  if ((int )ch == 99) {
#line 2849
    goto case_99;
  }
#line 2852
  if ((int )ch == 109) {
#line 2852
    goto case_109;
  }
#line 2855
  if ((int )ch == 110) {
#line 2855
    goto case_110;
  }
#line 2874
  if ((int )ch == 114) {
#line 2874
    goto case_114;
  }
#line 2887
  if ((int )ch == 108) {
#line 2887
    goto case_108;
  }
#line 2887
  if ((int )ch == 104) {
#line 2887
    goto case_108;
  }
#line 2887
  if ((int )ch == 116) {
#line 2887
    goto case_108;
  }
#line 2887
  if ((int )ch == 115) {
#line 2887
    goto case_108;
  }
#line 2890
  if ((int )ch == 103) {
#line 2890
    goto case_103;
  }
#line 2901
  if ((int )ch == 87) {
#line 2901
    goto case_87;
  }
#line 2764
  goto switch_break;
  case_101: /* CIL Label */ 
  case_65: /* CIL Label */ 
#line 2781
  if (arg[0]) {
#line 2781
    tmp___1 = - arg[0];
  } else {
#line 2781
    tmp___1 = -1;
  }
  {
#line 2781
  scr_gotorc(tmp___1, 0, 3);
  }
#line 2782
  goto switch_break;
  case_66: /* CIL Label */ 
#line 2784
  if (arg[0]) {
#line 2784
    tmp___2 = arg[0];
  } else {
#line 2784
    tmp___2 = 1;
  }
  {
#line 2784
  scr_gotorc(tmp___2, 0, 3);
  }
#line 2785
  goto switch_break;
  case_97: /* CIL Label */ 
  case_67: /* CIL Label */ 
#line 2788
  if (arg[0]) {
#line 2788
    tmp___3 = arg[0];
  } else {
#line 2788
    tmp___3 = 1;
  }
  {
#line 2788
  scr_gotorc(0, tmp___3, 3);
  }
#line 2789
  goto switch_break;
  case_68: /* CIL Label */ 
#line 2791
  if (arg[0]) {
#line 2791
    tmp___4 = - arg[0];
  } else {
#line 2791
    tmp___4 = -1;
  }
  {
#line 2791
  scr_gotorc(0, tmp___4, 3);
  }
#line 2792
  goto switch_break;
  case_69: /* CIL Label */ 
#line 2794
  if (arg[0]) {
#line 2794
    tmp___5 = arg[0];
  } else {
#line 2794
    tmp___5 = 1;
  }
  {
#line 2794
  scr_gotorc(tmp___5, 0, 2);
  }
#line 2795
  goto switch_break;
  case_70: /* CIL Label */ 
#line 2797
  if (arg[0]) {
#line 2797
    tmp___6 = - arg[0];
  } else {
#line 2797
    tmp___6 = -1;
  }
  {
#line 2797
  scr_gotorc(tmp___6, 0, 2);
  }
#line 2798
  goto switch_break;
  case_96: /* CIL Label */ 
  case_71: /* CIL Label */ 
#line 2801
  if (arg[0]) {
#line 2801
    tmp___7 = arg[0];
  } else {
#line 2801
    tmp___7 = 1;
  }
  {
#line 2801
  scr_gotorc(0, tmp___7, 2);
  }
#line 2802
  goto switch_break;
  case_100: /* CIL Label */ 
#line 2804
  if (arg[0]) {
#line 2804
    tmp___8 = arg[0];
  } else {
#line 2804
    tmp___8 = 1;
  }
  {
#line 2804
  scr_gotorc(tmp___8, 0, 1);
  }
#line 2805
  goto switch_break;
  case_102: /* CIL Label */ 
  case_72: /* CIL Label */ 
  {
#line 2810
  if (nargs == 0U) {
#line 2810
    goto case_0;
  }
#line 2813
  if (nargs == 1U) {
#line 2813
    goto case_1;
  }
#line 2816
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 2811
  scr_gotorc(0, 0, 0);
  }
#line 2812
  goto switch_break___0;
  case_1: /* CIL Label */ 
#line 2814
  if (arg[0]) {
#line 2814
    tmp___9 = arg[0] - 1;
  } else {
#line 2814
    tmp___9 = 0;
  }
  {
#line 2814
  scr_gotorc(tmp___9, 0, 0);
  }
#line 2815
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 2817
  scr_gotorc(arg[0] - 1, arg[1] - 1, 0);
  }
#line 2818
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 2820
  goto switch_break;
  case_73: /* CIL Label */ 
#line 2822
  if (arg[0]) {
#line 2822
    tmp___10 = arg[0];
  } else {
#line 2822
    tmp___10 = 1;
  }
  {
#line 2822
  scr_tab(tmp___10);
  }
#line 2823
  goto switch_break;
  case_90: /* CIL Label */ 
#line 2825
  if (arg[0]) {
#line 2825
    tmp___11 = - arg[0];
  } else {
#line 2825
    tmp___11 = -1;
  }
  {
#line 2825
  scr_tab(tmp___11);
  }
#line 2826
  goto switch_break;
  case_74: /* CIL Label */ 
  {
#line 2828
  scr_erase_screen(arg[0]);
  }
#line 2829
  goto switch_break;
  case_75: /* CIL Label */ 
  {
#line 2831
  scr_erase_line(arg[0]);
  }
#line 2832
  goto switch_break;
  case_64: /* CIL Label */ 
#line 2834
  if (arg[0]) {
#line 2834
    tmp___12 = arg[0];
  } else {
#line 2834
    tmp___12 = 1;
  }
  {
#line 2834
  scr_insdel_chars(tmp___12, -1);
  }
#line 2835
  goto switch_break;
  case_76: /* CIL Label */ 
#line 2837
  if (arg[0]) {
#line 2837
    tmp___13 = arg[0];
  } else {
#line 2837
    tmp___13 = 1;
  }
  {
#line 2837
  scr_insdel_lines(tmp___13, -1);
  }
#line 2838
  goto switch_break;
  case_77: /* CIL Label */ 
#line 2840
  if (arg[0]) {
#line 2840
    tmp___14 = arg[0];
  } else {
#line 2840
    tmp___14 = 1;
  }
  {
#line 2840
  scr_insdel_lines(tmp___14, 1);
  }
#line 2841
  goto switch_break;
  case_88: /* CIL Label */ 
#line 2843
  if (arg[0]) {
#line 2843
    tmp___15 = arg[0];
  } else {
#line 2843
    tmp___15 = 1;
  }
  {
#line 2843
  scr_insdel_chars(tmp___15, 2);
  }
#line 2844
  goto switch_break;
  case_80: /* CIL Label */ 
#line 2846
  if (arg[0]) {
#line 2846
    tmp___16 = arg[0];
  } else {
#line 2846
    tmp___16 = 1;
  }
  {
#line 2846
  scr_insdel_chars(tmp___16, 1);
  }
#line 2847
  goto switch_break;
  case_99: /* CIL Label */ 
  {
#line 2850
  tt_printf("\033[?1;2c");
  }
#line 2851
  goto switch_break;
  case_109: /* CIL Label */ 
  {
#line 2853
  process_sgr_mode(nargs, arg);
  }
#line 2854
  goto switch_break;
  case_110: /* CIL Label */ 
  {
#line 2858
  if (arg[0] == 5) {
#line 2858
    goto case_5;
  }
#line 2861
  if (arg[0] == 6) {
#line 2861
    goto case_6;
  }
#line 2869
  if (arg[0] == 8) {
#line 2869
    goto case_8;
  }
#line 2856
  goto switch_break___1;
  case_5: /* CIL Label */ 
  {
#line 2859
  tt_printf("\033[0n");
  }
#line 2860
  goto switch_break___1;
  case_6: /* CIL Label */ 
  {
#line 2862
  scr_report_position();
  }
#line 2863
  goto switch_break___1;
  case_8: /* CIL Label */ 
  {
#line 2870
  xterm_seq(2, (char *)"xiterm+thai-1.10");
  }
#line 2871
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 2873
  goto switch_break;
  case_114: /* CIL Label */ 
#line 2875
  if ((int )priv != 63) {
#line 2877
    if (nargs < 2U) {
      {
#line 2878
      scr_scroll_region(0, 10000);
      }
    } else
#line 2877
    if (arg[0] >= arg[1]) {
      {
#line 2878
      scr_scroll_region(0, 10000);
      }
    } else {
      {
#line 2880
      scr_scroll_region(arg[0] - 1, arg[1] - 1);
      }
    }
#line 2881
    goto switch_break;
  }
  case_108: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
  {
#line 2888
  process_terminal_mode((int )ch, (int )priv, nargs, arg);
  }
#line 2889
  goto switch_break;
  case_103: /* CIL Label */ 
  {
#line 2893
  if (arg[0] == 0) {
#line 2893
    goto case_0___0;
  }
#line 2896
  if (arg[0] == 3) {
#line 2896
    goto case_3;
  }
#line 2891
  goto switch_break___2;
  case_0___0: /* CIL Label */ 
  {
#line 2894
  scr_set_tab(0);
  }
#line 2895
  goto switch_break___2;
  case_3: /* CIL Label */ 
  {
#line 2897
  scr_set_tab(-1);
  }
#line 2898
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 2900
  goto switch_break;
  case_87: /* CIL Label */ 
  {
#line 2904
  if (arg[0] == 0) {
#line 2904
    goto case_0___1;
  }
#line 2907
  if (arg[0] == 2) {
#line 2907
    goto case_2;
  }
#line 2910
  if (arg[0] == 5) {
#line 2910
    goto case_5___0;
  }
#line 2902
  goto switch_break___3;
  case_0___1: /* CIL Label */ 
  {
#line 2905
  scr_set_tab(1);
  }
#line 2906
  goto switch_break___3;
  case_2: /* CIL Label */ 
  {
#line 2908
  scr_set_tab(0);
  }
#line 2909
  goto switch_break___3;
  case_5___0: /* CIL Label */ 
  {
#line 2911
  scr_set_tab(-1);
  }
#line 2912
  goto switch_break___3;
  switch_break___3: /* CIL Label */ ;
  }
#line 2914
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2916
  return;
}
}
#line 2920 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static void process_xterm_seq(void) 
{ 
  unsigned char ch ;
  unsigned char string[512] ;
  int arg ;
  unsigned short const   **tmp ;
  int n ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;

  {
  {
#line 2926
  ch = cmd_getc();
#line 2927
  arg = 0;
  }
  {
#line 2927
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2927
    tmp = __ctype_b_loc();
    }
#line 2927
    if (! ((int const   )*(*tmp + (int )ch) & 2048)) {
#line 2927
      goto while_break;
    }
    {
#line 2928
    arg = arg * 10 + ((int )ch - 48);
#line 2927
    ch = cmd_getc();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2930
  if ((int )ch == 59) {
#line 2932
    n = 0;
    {
#line 2933
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2933
      ch = cmd_getc();
      }
#line 2933
      if (! ((int )ch != 7)) {
#line 2933
        goto while_break___0;
      }
#line 2935
      if ((unsigned long )n < sizeof(string) - 1UL) {
        {
#line 2938
        tmp___0 = __ctype_b_loc();
        }
#line 2938
        if ((int const   )*(*tmp___0 + (int )ch) & 8192) {
#line 2939
          ch = (unsigned char )' ';
        }
#line 2940
        if ((int )ch >= 32) {
#line 2941
          tmp___1 = n;
#line 2941
          n ++;
#line 2941
          string[tmp___1] = ch;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2944
    string[n] = (unsigned char )'\000';
#line 2945
    xterm_seq(arg, (char *)(string));
    }
  }
#line 2947
  return;
}
}
#line 2960 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static void process_terminal_mode(int mode , int priv , unsigned int nargs , int *arg ) 
{ 
  unsigned int i ;
  int state ;
  int tmp ;

  {
#line 2967
  if (nargs == 0U) {
#line 2968
    return;
  }
  {
#line 2973
  if (mode == 108) {
#line 2973
    goto case_108;
  }
#line 2976
  if (mode == 104) {
#line 2976
    goto case_104;
  }
#line 2971
  goto switch_break;
  case_108: /* CIL Label */ 
#line 2974
  mode = 0;
#line 2975
  goto switch_break;
  case_104: /* CIL Label */ 
#line 2977
  mode = 1;
#line 2978
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 2983
  if (priv == 0) {
#line 2983
    goto case_0;
  }
#line 3007
  if (priv == 63) {
#line 3007
    goto case_63;
  }
#line 2981
  goto switch_break___0;
  case_0: /* CIL Label */ 
#line 2984
  if (mode) {
#line 2984
    if (mode != 1) {
#line 2985
      return;
    }
  }
#line 2986
  i = 0U;
  {
#line 2986
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2986
    if (! (i < nargs)) {
#line 2986
      goto while_break;
    }
    {
#line 2989
    if (*(arg + i) == 4) {
#line 2989
      goto case_4;
    }
#line 2993
    if (*(arg + i) == 36) {
#line 2993
      goto case_36;
    }
#line 2987
    goto switch_break___1;
    case_4: /* CIL Label */ 
    {
#line 2990
    scr_insert_mode(mode);
    }
#line 2991
    goto switch_break___1;
    case_36: /* CIL Label */ 
    {
#line 2994
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2994
      if (mode) {
#line 2994
        PrivateModes |= 1UL << 8;
      } else {
#line 2994
        PrivateModes &= ~ (1UL << 8);
      }
#line 2994
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2995
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 2986
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2998
  goto switch_break___0;
  case_63: /* CIL Label */ 
#line 3008
  i = 0U;
  {
#line 3008
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3008
    if (! (i < nargs)) {
#line 3008
      goto while_break___1;
    }
    {
#line 3011
    if (*(arg + i) == 1) {
#line 3011
      goto case_1;
    }
#line 3017
    if (*(arg + i) == 3) {
#line 3017
      goto case_3;
    }
#line 3025
    if (*(arg + i) == 5) {
#line 3025
      goto case_5;
    }
#line 3030
    if (*(arg + i) == 6) {
#line 3030
      goto case_6;
    }
#line 3035
    if (*(arg + i) == 7) {
#line 3035
      goto case_7;
    }
#line 3042
    if (*(arg + i) == 9) {
#line 3042
      goto case_9;
    }
#line 3050
    if (*(arg + i) == 30) {
#line 3050
      goto case_30;
    }
#line 3056
    if (*(arg + i) == 25) {
#line 3056
      goto case_25;
    }
#line 3061
    if (*(arg + i) == 35) {
#line 3061
      goto case_35;
    }
#line 3065
    if (*(arg + i) == 36) {
#line 3065
      goto case_36___0;
    }
#line 3069
    if (*(arg + i) == 40) {
#line 3069
      goto case_40;
    }
#line 3073
    if (*(arg + i) == 47) {
#line 3073
      goto case_47;
    }
#line 3078
    if (*(arg + i) == 66) {
#line 3078
      goto case_66;
    }
#line 3082
    if (*(arg + i) == 1000) {
#line 3082
      goto case_1000;
    }
#line 3009
    goto switch_break___2;
    case_1: /* CIL Label */ 
#line 3012
    if (mode == 116) {
#line 3012
      state = ! (PrivateModes & (1UL << 6));
    } else {
#line 3012
      state = mode;
    }
    {
#line 3012
    if (state == 115) {
#line 3012
      goto case_115;
    }
#line 3012
    if (state == 114) {
#line 3012
      goto case_114;
    }
#line 3012
    goto switch_default;
    case_115: /* CIL Label */ 
#line 3012
    SavedModes |= PrivateModes & (1UL << 6);
#line 3012
    goto __Cont;
#line 3012
    goto switch_break___3;
    case_114: /* CIL Label */ 
#line 3012
    if (SavedModes & (1UL << 6)) {
#line 3012
      state = 1;
    } else {
#line 3012
      state = 0;
    }
    switch_default: /* CIL Label */ 
    {
#line 3012
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3012
      if (state) {
#line 3012
        PrivateModes |= 1UL << 6;
      } else {
#line 3012
        PrivateModes &= ~ (1UL << 6);
      }
#line 3012
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    switch_break___3: /* CIL Label */ ;
    }
#line 3013
    goto switch_break___2;
    case_3: /* CIL Label */ 
#line 3018
    if (mode == 116) {
#line 3018
      state = ! (PrivateModes & 1UL);
    } else {
#line 3018
      state = mode;
    }
    {
#line 3018
    if (state == 115) {
#line 3018
      goto case_115___0;
    }
#line 3018
    if (state == 114) {
#line 3018
      goto case_114___0;
    }
#line 3018
    goto switch_default___0;
    case_115___0: /* CIL Label */ 
#line 3018
    SavedModes |= PrivateModes & 1UL;
#line 3018
    goto __Cont;
#line 3018
    goto switch_break___4;
    case_114___0: /* CIL Label */ 
#line 3018
    if (SavedModes & 1UL) {
#line 3018
      state = 1;
    } else {
#line 3018
      state = 0;
    }
    switch_default___0: /* CIL Label */ 
    {
#line 3018
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 3018
      if (state) {
#line 3018
        PrivateModes |= 1UL;
      } else {
#line 3018
        PrivateModes &= 0xfffffffffffffffeUL;
      }
#line 3018
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    switch_break___4: /* CIL Label */ ;
    }
#line 3019
    if (PrivateModes & (1UL << 1)) {
#line 3020
      if (state) {
#line 3020
        tmp = 132;
      } else {
#line 3020
        tmp = 80;
      }
      {
#line 3020
      set_width((unsigned short )tmp);
      }
    }
#line 3021
    goto switch_break___2;
    case_5: /* CIL Label */ 
#line 3026
    if (mode == 116) {
#line 3026
      state = ! (PrivateModes & (1UL << 2));
    } else {
#line 3026
      state = mode;
    }
    {
#line 3026
    if (state == 115) {
#line 3026
      goto case_115___1;
    }
#line 3026
    if (state == 114) {
#line 3026
      goto case_114___1;
    }
#line 3026
    goto switch_default___1;
    case_115___1: /* CIL Label */ 
#line 3026
    SavedModes |= PrivateModes & (1UL << 2);
#line 3026
    goto __Cont;
#line 3026
    goto switch_break___5;
    case_114___1: /* CIL Label */ 
#line 3026
    if (SavedModes & (1UL << 2)) {
#line 3026
      state = 1;
    } else {
#line 3026
      state = 0;
    }
    switch_default___1: /* CIL Label */ 
    {
#line 3026
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 3026
      if (state) {
#line 3026
        PrivateModes |= 1UL << 2;
      } else {
#line 3026
        PrivateModes &= ~ (1UL << 2);
      }
#line 3026
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    switch_break___5: /* CIL Label */ ;
    }
    {
#line 3027
    scr_rvideo_mode(state);
    }
#line 3028
    goto switch_break___2;
    case_6: /* CIL Label */ 
#line 3031
    if (mode == 116) {
#line 3031
      state = ! (PrivateModes & (1UL << 3));
    } else {
#line 3031
      state = mode;
    }
    {
#line 3031
    if (state == 115) {
#line 3031
      goto case_115___2;
    }
#line 3031
    if (state == 114) {
#line 3031
      goto case_114___2;
    }
#line 3031
    goto switch_default___2;
    case_115___2: /* CIL Label */ 
#line 3031
    SavedModes |= PrivateModes & (1UL << 3);
#line 3031
    goto __Cont;
#line 3031
    goto switch_break___6;
    case_114___2: /* CIL Label */ 
#line 3031
    if (SavedModes & (1UL << 3)) {
#line 3031
      state = 1;
    } else {
#line 3031
      state = 0;
    }
    switch_default___2: /* CIL Label */ 
    {
#line 3031
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 3031
      if (state) {
#line 3031
        PrivateModes |= 1UL << 3;
      } else {
#line 3031
        PrivateModes &= ~ (1UL << 3);
      }
#line 3031
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    switch_break___6: /* CIL Label */ ;
    }
    {
#line 3032
    scr_relative_origin(state);
    }
#line 3033
    goto switch_break___2;
    case_7: /* CIL Label */ 
#line 3036
    if (mode == 116) {
#line 3036
      state = ! (PrivateModes & (1UL << 5));
    } else {
#line 3036
      state = mode;
    }
    {
#line 3036
    if (state == 115) {
#line 3036
      goto case_115___3;
    }
#line 3036
    if (state == 114) {
#line 3036
      goto case_114___3;
    }
#line 3036
    goto switch_default___3;
    case_115___3: /* CIL Label */ 
#line 3036
    SavedModes |= PrivateModes & (1UL << 5);
#line 3036
    goto __Cont;
#line 3036
    goto switch_break___7;
    case_114___3: /* CIL Label */ 
#line 3036
    if (SavedModes & (1UL << 5)) {
#line 3036
      state = 1;
    } else {
#line 3036
      state = 0;
    }
    switch_default___3: /* CIL Label */ 
    {
#line 3036
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 3036
      if (state) {
#line 3036
        PrivateModes |= 1UL << 5;
      } else {
#line 3036
        PrivateModes &= ~ (1UL << 5);
      }
#line 3036
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    switch_break___7: /* CIL Label */ ;
    }
    {
#line 3037
    scr_autowrap(state);
    }
#line 3038
    goto switch_break___2;
    case_9: /* CIL Label */ 
#line 3043
    if (mode == 116) {
#line 3043
      state = ! (PrivateModes & (1UL << 11));
    } else {
#line 3043
      state = mode;
    }
    {
#line 3043
    if (state == 115) {
#line 3043
      goto case_115___4;
    }
#line 3043
    if (state == 114) {
#line 3043
      goto case_114___4;
    }
#line 3043
    goto switch_default___4;
    case_115___4: /* CIL Label */ 
#line 3043
    SavedModes |= PrivateModes & (1UL << 11);
#line 3043
    goto __Cont;
#line 3043
    goto switch_break___8;
    case_114___4: /* CIL Label */ 
#line 3043
    if (SavedModes & (1UL << 11)) {
#line 3043
      state = 1;
    } else {
#line 3043
      state = 0;
    }
    switch_default___4: /* CIL Label */ 
    {
#line 3043
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 3043
      if (state) {
#line 3043
        PrivateModes |= 1UL << 11;
      } else {
#line 3043
        PrivateModes &= ~ (1UL << 11);
      }
#line 3043
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    switch_break___8: /* CIL Label */ ;
    }
#line 3045
    if (PrivateModes & (1UL << 11)) {
#line 3046
      PrivateModes &= ~ (1UL << 12);
    }
#line 3047
    goto switch_break___2;
    case_30: /* CIL Label */ 
#line 3051
    if (mode == 116) {
#line 3051
      state = ! (PrivateModes & (1UL << 14));
    } else {
#line 3051
      state = mode;
    }
    {
#line 3051
    if (state == 115) {
#line 3051
      goto case_115___5;
    }
#line 3051
    if (state == 114) {
#line 3051
      goto case_114___5;
    }
#line 3051
    goto switch_default___5;
    case_115___5: /* CIL Label */ 
#line 3051
    SavedModes |= PrivateModes & (1UL << 14);
#line 3051
    goto __Cont;
#line 3051
    goto switch_break___9;
    case_114___5: /* CIL Label */ 
#line 3051
    if (SavedModes & (1UL << 14)) {
#line 3051
      state = 1;
    } else {
#line 3051
      state = 0;
    }
    switch_default___5: /* CIL Label */ 
    {
#line 3051
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 3051
      if (state) {
#line 3051
        PrivateModes |= 1UL << 14;
      } else {
#line 3051
        PrivateModes &= ~ (1UL << 14);
      }
#line 3051
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    switch_break___9: /* CIL Label */ ;
    }
    {
#line 3052
    map_scrollBar(state);
    }
#line 3053
    goto switch_break___2;
    case_25: /* CIL Label */ 
#line 3057
    if (mode == 116) {
#line 3057
      state = ! (PrivateModes & (1UL << 10));
    } else {
#line 3057
      state = mode;
    }
    {
#line 3057
    if (state == 115) {
#line 3057
      goto case_115___6;
    }
#line 3057
    if (state == 114) {
#line 3057
      goto case_114___6;
    }
#line 3057
    goto switch_default___6;
    case_115___6: /* CIL Label */ 
#line 3057
    SavedModes |= PrivateModes & (1UL << 10);
#line 3057
    goto __Cont;
#line 3057
    goto switch_break___10;
    case_114___6: /* CIL Label */ 
#line 3057
    if (SavedModes & (1UL << 10)) {
#line 3057
      state = 1;
    } else {
#line 3057
      state = 0;
    }
    switch_default___6: /* CIL Label */ 
    {
#line 3057
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 3057
      if (state) {
#line 3057
        PrivateModes |= 1UL << 10;
      } else {
#line 3057
        PrivateModes &= ~ (1UL << 10);
      }
#line 3057
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
    switch_break___10: /* CIL Label */ ;
    }
    {
#line 3058
    scr_cursor_visible(state);
    }
#line 3059
    goto switch_break___2;
    case_35: /* CIL Label */ 
#line 3062
    if (mode == 116) {
#line 3062
      state = ! (PrivateModes & (1UL << 9));
    } else {
#line 3062
      state = mode;
    }
    {
#line 3062
    if (state == 115) {
#line 3062
      goto case_115___7;
    }
#line 3062
    if (state == 114) {
#line 3062
      goto case_114___7;
    }
#line 3062
    goto switch_default___7;
    case_115___7: /* CIL Label */ 
#line 3062
    SavedModes |= PrivateModes & (1UL << 9);
#line 3062
    goto __Cont;
#line 3062
    goto switch_break___11;
    case_114___7: /* CIL Label */ 
#line 3062
    if (SavedModes & (1UL << 9)) {
#line 3062
      state = 1;
    } else {
#line 3062
      state = 0;
    }
    switch_default___7: /* CIL Label */ 
    {
#line 3062
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 3062
      if (state) {
#line 3062
        PrivateModes |= 1UL << 9;
      } else {
#line 3062
        PrivateModes &= ~ (1UL << 9);
      }
#line 3062
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
    switch_break___11: /* CIL Label */ ;
    }
#line 3063
    goto switch_break___2;
    case_36___0: /* CIL Label */ 
#line 3066
    if (mode == 116) {
#line 3066
      state = ! (PrivateModes & (1UL << 8));
    } else {
#line 3066
      state = mode;
    }
    {
#line 3066
    if (state == 115) {
#line 3066
      goto case_115___8;
    }
#line 3066
    if (state == 114) {
#line 3066
      goto case_114___8;
    }
#line 3066
    goto switch_default___8;
    case_115___8: /* CIL Label */ 
#line 3066
    SavedModes |= PrivateModes & (1UL << 8);
#line 3066
    goto __Cont;
#line 3066
    goto switch_break___12;
    case_114___8: /* CIL Label */ 
#line 3066
    if (SavedModes & (1UL << 8)) {
#line 3066
      state = 1;
    } else {
#line 3066
      state = 0;
    }
    switch_default___8: /* CIL Label */ 
    {
#line 3066
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 3066
      if (state) {
#line 3066
        PrivateModes |= 1UL << 8;
      } else {
#line 3066
        PrivateModes &= ~ (1UL << 8);
      }
#line 3066
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
    switch_break___12: /* CIL Label */ ;
    }
#line 3067
    goto switch_break___2;
    case_40: /* CIL Label */ 
#line 3070
    if (mode == 116) {
#line 3070
      state = ! (PrivateModes & (1UL << 1));
    } else {
#line 3070
      state = mode;
    }
    {
#line 3070
    if (state == 115) {
#line 3070
      goto case_115___9;
    }
#line 3070
    if (state == 114) {
#line 3070
      goto case_114___9;
    }
#line 3070
    goto switch_default___9;
    case_115___9: /* CIL Label */ 
#line 3070
    SavedModes |= PrivateModes & (1UL << 1);
#line 3070
    goto __Cont;
#line 3070
    goto switch_break___13;
    case_114___9: /* CIL Label */ 
#line 3070
    if (SavedModes & (1UL << 1)) {
#line 3070
      state = 1;
    } else {
#line 3070
      state = 0;
    }
    switch_default___9: /* CIL Label */ 
    {
#line 3070
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 3070
      if (state) {
#line 3070
        PrivateModes |= 1UL << 1;
      } else {
#line 3070
        PrivateModes &= ~ (1UL << 1);
      }
#line 3070
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
    switch_break___13: /* CIL Label */ ;
    }
#line 3071
    goto switch_break___2;
    case_47: /* CIL Label */ 
#line 3074
    if (mode == 116) {
#line 3074
      state = ! (PrivateModes & (1UL << 4));
    } else {
#line 3074
      state = mode;
    }
    {
#line 3074
    if (state == 115) {
#line 3074
      goto case_115___10;
    }
#line 3074
    if (state == 114) {
#line 3074
      goto case_114___10;
    }
#line 3074
    goto switch_default___10;
    case_115___10: /* CIL Label */ 
#line 3074
    SavedModes |= PrivateModes & (1UL << 4);
#line 3074
    goto __Cont;
#line 3074
    goto switch_break___14;
    case_114___10: /* CIL Label */ 
#line 3074
    if (SavedModes & (1UL << 4)) {
#line 3074
      state = 1;
    } else {
#line 3074
      state = 0;
    }
    switch_default___10: /* CIL Label */ 
    {
#line 3074
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 3074
      if (state) {
#line 3074
        PrivateModes |= 1UL << 4;
      } else {
#line 3074
        PrivateModes &= ~ (1UL << 4);
      }
#line 3074
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
    switch_break___14: /* CIL Label */ ;
    }
    {
#line 3075
    scr_change_screen(state);
    }
#line 3076
    goto switch_break___2;
    case_66: /* CIL Label */ 
#line 3079
    if (mode == 116) {
#line 3079
      state = ! (PrivateModes & (1UL << 7));
    } else {
#line 3079
      state = mode;
    }
    {
#line 3079
    if (state == 115) {
#line 3079
      goto case_115___11;
    }
#line 3079
    if (state == 114) {
#line 3079
      goto case_114___11;
    }
#line 3079
    goto switch_default___11;
    case_115___11: /* CIL Label */ 
#line 3079
    SavedModes |= PrivateModes & (1UL << 7);
#line 3079
    goto __Cont;
#line 3079
    goto switch_break___15;
    case_114___11: /* CIL Label */ 
#line 3079
    if (SavedModes & (1UL << 7)) {
#line 3079
      state = 1;
    } else {
#line 3079
      state = 0;
    }
    switch_default___11: /* CIL Label */ 
    {
#line 3079
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 3079
      if (state) {
#line 3079
        PrivateModes |= 1UL << 7;
      } else {
#line 3079
        PrivateModes &= ~ (1UL << 7);
      }
#line 3079
      goto while_break___14;
    }
    while_break___14: /* CIL Label */ ;
    }
    switch_break___15: /* CIL Label */ ;
    }
#line 3080
    goto switch_break___2;
    case_1000: /* CIL Label */ 
#line 3083
    if (mode == 116) {
#line 3083
      state = ! (PrivateModes & (1UL << 12));
    } else {
#line 3083
      state = mode;
    }
    {
#line 3083
    if (state == 115) {
#line 3083
      goto case_115___12;
    }
#line 3083
    if (state == 114) {
#line 3083
      goto case_114___12;
    }
#line 3083
    goto switch_default___12;
    case_115___12: /* CIL Label */ 
#line 3083
    SavedModes |= PrivateModes & (1UL << 12);
#line 3083
    goto __Cont;
#line 3083
    goto switch_break___16;
    case_114___12: /* CIL Label */ 
#line 3083
    if (SavedModes & (1UL << 12)) {
#line 3083
      state = 1;
    } else {
#line 3083
      state = 0;
    }
    switch_default___12: /* CIL Label */ 
    {
#line 3083
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 3083
      if (state) {
#line 3083
        PrivateModes |= 1UL << 12;
      } else {
#line 3083
        PrivateModes &= ~ (1UL << 12);
      }
#line 3083
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
    switch_break___16: /* CIL Label */ ;
    }
#line 3085
    if (PrivateModes & (1UL << 12)) {
#line 3086
      PrivateModes &= ~ (1UL << 11);
    }
#line 3087
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 3008
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3095
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 3097
  return;
}
}
#line 3101 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
static void process_sgr_mode(unsigned int nargs , int *arg ) 
{ 
  unsigned int i ;

  {
#line 3106
  if (nargs == 0U) {
    {
#line 3108
    scr_rendition(0, ~ 0);
    }
#line 3109
    return;
  }
#line 3111
  i = 0U;
  {
#line 3111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3111
    if (! (i < nargs)) {
#line 3111
      goto while_break;
    }
    {
#line 3114
    if (*(arg + i) == 0) {
#line 3114
      goto case_0;
    }
#line 3117
    if (*(arg + i) == 1) {
#line 3117
      goto case_1;
    }
#line 3120
    if (*(arg + i) == 4) {
#line 3120
      goto case_4;
    }
#line 3123
    if (*(arg + i) == 5) {
#line 3123
      goto case_5;
    }
#line 3126
    if (*(arg + i) == 7) {
#line 3126
      goto case_7;
    }
#line 3129
    if (*(arg + i) == 22) {
#line 3129
      goto case_22;
    }
#line 3132
    if (*(arg + i) == 24) {
#line 3132
      goto case_24;
    }
#line 3135
    if (*(arg + i) == 25) {
#line 3135
      goto case_25;
    }
#line 3138
    if (*(arg + i) == 27) {
#line 3138
      goto case_27;
    }
#line 3149
    if (*(arg + i) == 37) {
#line 3149
      goto case_37;
    }
#line 3149
    if (*(arg + i) == 36) {
#line 3149
      goto case_37;
    }
#line 3149
    if (*(arg + i) == 35) {
#line 3149
      goto case_37;
    }
#line 3149
    if (*(arg + i) == 34) {
#line 3149
      goto case_37;
    }
#line 3149
    if (*(arg + i) == 33) {
#line 3149
      goto case_37;
    }
#line 3149
    if (*(arg + i) == 32) {
#line 3149
      goto case_37;
    }
#line 3149
    if (*(arg + i) == 31) {
#line 3149
      goto case_37;
    }
#line 3149
    if (*(arg + i) == 30) {
#line 3149
      goto case_37;
    }
#line 3152
    if (*(arg + i) == 39) {
#line 3152
      goto case_39;
    }
#line 3163
    if (*(arg + i) == 47) {
#line 3163
      goto case_47;
    }
#line 3163
    if (*(arg + i) == 46) {
#line 3163
      goto case_47;
    }
#line 3163
    if (*(arg + i) == 45) {
#line 3163
      goto case_47;
    }
#line 3163
    if (*(arg + i) == 44) {
#line 3163
      goto case_47;
    }
#line 3163
    if (*(arg + i) == 43) {
#line 3163
      goto case_47;
    }
#line 3163
    if (*(arg + i) == 42) {
#line 3163
      goto case_47;
    }
#line 3163
    if (*(arg + i) == 41) {
#line 3163
      goto case_47;
    }
#line 3163
    if (*(arg + i) == 40) {
#line 3163
      goto case_47;
    }
#line 3166
    if (*(arg + i) == 49) {
#line 3166
      goto case_49;
    }
#line 3112
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 3115
    scr_rendition(0, ~ 0);
    }
#line 3116
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 3118
    scr_rendition(1, 32768);
    }
#line 3119
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 3121
    scr_rendition(1, 134217728);
    }
#line 3122
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 3124
    scr_rendition(1, 8388608);
    }
#line 3125
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 3127
    scr_rendition(1, 67108864);
    }
#line 3128
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 3130
    scr_rendition(0, 32768);
    }
#line 3131
    goto switch_break;
    case_24: /* CIL Label */ 
    {
#line 3133
    scr_rendition(0, 134217728);
    }
#line 3134
    goto switch_break;
    case_25: /* CIL Label */ 
    {
#line 3136
    scr_rendition(0, 8388608);
    }
#line 3137
    goto switch_break;
    case_27: /* CIL Label */ 
    {
#line 3139
    scr_rendition(0, 67108864);
    }
#line 3140
    goto switch_break;
    case_37: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_35: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_33: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_31: /* CIL Label */ 
    case_30: /* CIL Label */ 
    {
#line 3150
    scr_color((unsigned int )(2 + (*(arg + i) - 30)), 32768U);
    }
#line 3151
    goto switch_break;
    case_39: /* CIL Label */ 
    {
#line 3153
    scr_color(39U, 32768U);
    }
#line 3154
    goto switch_break;
    case_47: /* CIL Label */ 
    case_46: /* CIL Label */ 
    case_45: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_41: /* CIL Label */ 
    case_40: /* CIL Label */ 
    {
#line 3164
    scr_color((unsigned int )(2 + (*(arg + i) - 40)), 8388608U);
    }
#line 3165
    goto switch_break;
    case_49: /* CIL Label */ 
    {
#line 3167
    scr_color(49U, 8388608U);
    }
#line 3168
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 3111
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3170
  return;
}
}
#line 3174 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/command.c"
void main_loop(void) 
{ 
  int ch ;
  unsigned char tmp ;
  int nlines ;
  unsigned char *str ;

  {
  {
#line 3179
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3181
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 3181
      tmp = cmd_getc();
#line 3181
      ch = (int )tmp;
      }
#line 3181
      if (! (ch == 0)) {
#line 3181
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3182
    if (ch >= 32) {
#line 3182
      goto _L___0;
    } else
#line 3182
    if (ch == 9) {
#line 3182
      goto _L___0;
    } else
#line 3182
    if (ch == 10) {
#line 3182
      goto _L___0;
    } else
#line 3182
    if (ch == 13) {
      _L___0: /* CIL Label */ 
#line 3185
      nlines = 0;
#line 3192
      cmdbuf_ptr --;
#line 3192
      str = cmdbuf_ptr;
      {
#line 3193
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3193
        if (! ((unsigned long )cmdbuf_ptr < (unsigned long )cmdbuf_endp)) {
#line 3193
          goto while_break___1;
        }
#line 3195
        ch = (int )*cmdbuf_ptr;
#line 3196
        if (ch >= 32) {
#line 3196
          goto _L;
        } else
#line 3196
        if (ch == 9) {
#line 3196
          goto _L;
        } else
#line 3196
        if (ch == 10) {
#line 3196
          goto _L;
        } else
#line 3196
        if (ch == 13) {
          _L: /* CIL Label */ 
#line 3198
          cmdbuf_ptr ++;
#line 3199
          if (ch == 10) {
#line 3201
            nlines ++;
#line 3202
            refresh_count ++;
#line 3204
            if (refresh_count > refresh_limit * (int )TermWin.nrow) {
#line 3205
              goto while_break___1;
            }
          }
        } else {
#line 3211
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 3214
      scr_add_lines((unsigned char const   *)str, nlines, (int )(cmdbuf_ptr - str));
      }
    } else {
      {
#line 3220
      if (ch == 5) {
#line 3220
        goto case_5;
      }
#line 3223
      if (ch == 7) {
#line 3223
        goto case_7;
      }
#line 3226
      if (ch == 8) {
#line 3226
        goto case_8;
      }
#line 3230
      if (ch == 12) {
#line 3230
        goto case_12;
      }
#line 3230
      if (ch == 11) {
#line 3230
        goto case_12;
      }
#line 3233
      if (ch == 14) {
#line 3233
        goto case_14;
      }
#line 3236
      if (ch == 15) {
#line 3236
        goto case_15;
      }
#line 3239
      if (ch == 27) {
#line 3239
        goto case_27;
      }
#line 3218
      goto switch_break;
      case_5: /* CIL Label */ 
      {
#line 3221
      tt_printf("\033[?1;2c");
      }
#line 3222
      goto switch_break;
      case_7: /* CIL Label */ 
      {
#line 3224
      scr_bell();
      }
#line 3225
      goto switch_break;
      case_8: /* CIL Label */ 
      {
#line 3227
      scr_backspace();
      }
#line 3228
      goto switch_break;
      case_12: /* CIL Label */ 
      case_11: /* CIL Label */ 
      {
#line 3231
      scr_index(1);
      }
#line 3232
      goto switch_break;
      case_14: /* CIL Label */ 
      {
#line 3234
      scr_charset_choose(1);
      }
#line 3235
      goto switch_break;
      case_15: /* CIL Label */ 
      {
#line 3237
      scr_charset_choose(0);
      }
#line 3238
      goto switch_break;
      case_27: /* CIL Label */ 
      {
#line 3240
      process_escape_seq();
      }
#line 3241
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 3179
    if (! (ch != -1)) {
#line 3179
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3246
  return;
}
}
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 371 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 29 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/misc.h"
int escaped_string(char *str ) ;
#line 36
void Draw_Triangle(Window win , GC topShadow , GC botShadow , int x , int y , int w ,
                   int type ) ;
#line 25 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/misc.c"
char const   *my_basename(char const   *str ) 
{ 
  char const   *base ;
  char *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 28
  tmp = strrchr(str, '/');
#line 28
  base = (char const   *)tmp;
  }
#line 29
  if (base) {
#line 29
    tmp___0 = base + 1;
  } else {
#line 29
    tmp___0 = str;
  }
#line 29
  return (tmp___0);
}
}
#line 35 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/misc.c"
void print_error(char const   *fmt  , ...) 
{ 
  va_list arg_ptr ;

  {
  {
#line 40
  __builtin_va_start(arg_ptr, fmt);
#line 41
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"xiterm+thai: ");
#line 42
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           arg_ptr);
#line 43
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 44
  __builtin_va_end(arg_ptr);
  }
#line 45
  return;
}
}
#line 54 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/misc.c"
int escaped_string(char *str ) 
{ 
  register char *p ;
  int i ;
  int len ;
  int meta_x ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  register char ch ;
  char *tmp___5 ;
  int j ;
  int num ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 57
  p = str;
#line 58
  i = 0;
#line 58
  meta_x = 0;
#line 61
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 62
    return (0);
  } else {
    {
#line 61
    tmp = strlen((char const   *)str);
#line 61
    len = (int )tmp;
    }
#line 61
    if (len == 0) {
#line 62
      return (0);
    }
  }
  {
#line 65
  tmp___4 = strncmp((char const   *)p, "M-", (size_t )2);
  }
#line 65
  if (! tmp___4) {
    {
#line 67
    tmp___0 = i;
#line 67
    i ++;
#line 67
    *(str + tmp___0) = (char )'\033';
#line 68
    p += 2;
#line 69
    len --;
#line 70
    tmp___3 = toupper((int )*p);
    }
#line 70
    if (tmp___3 == 88) {
#line 72
      meta_x = 1;
#line 73
      tmp___1 = i;
#line 73
      i ++;
#line 73
      *(str + tmp___1) = (char )'x';
#line 74
      p ++;
      {
#line 75
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 75
        tmp___2 = __ctype_b_loc();
        }
#line 75
        if (! ((int const   )*(*tmp___2 + (int )*p) & 8192)) {
#line 75
          goto while_break;
        }
#line 77
        p ++;
#line 78
        len --;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 83
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 83
    if (! (i < len)) {
#line 83
      goto while_break___0;
    }
#line 85
    tmp___5 = p;
#line 85
    p ++;
#line 85
    ch = *tmp___5;
#line 86
    if ((int )ch == 92) {
#line 88
      ch = *p;
#line 89
      if ((int )ch >= 48) {
#line 89
        if ((int )ch <= 55) {
#line 91
          num = 0;
#line 92
          j = 0;
          {
#line 92
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 92
            if (j < 3) {
#line 92
              if ((int )ch >= 48) {
#line 92
                if (! ((int )ch <= 55)) {
#line 92
                  goto while_break___1;
                }
              } else {
#line 92
                goto while_break___1;
              }
            } else {
#line 92
              goto while_break___1;
            }
#line 94
            num = num * 8 + ((int )ch - 48);
#line 95
            p ++;
#line 96
            len --;
#line 97
            ch = *p;
#line 92
            j ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 99
          ch = (char )((unsigned char )num);
        } else {
#line 89
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 103
        p ++;
#line 104
        len --;
        {
#line 107
        if ((int )ch == 97) {
#line 107
          goto case_97;
        }
#line 110
        if ((int )ch == 98) {
#line 110
          goto case_98;
        }
#line 114
        if ((int )ch == 101) {
#line 114
          goto case_101;
        }
#line 114
        if ((int )ch == 69) {
#line 114
          goto case_101;
        }
#line 117
        if ((int )ch == 110) {
#line 117
          goto case_110;
        }
#line 120
        if ((int )ch == 114) {
#line 120
          goto case_114;
        }
#line 123
        if ((int )ch == 116) {
#line 123
          goto case_116;
        }
#line 105
        goto switch_break;
        case_97: /* CIL Label */ 
#line 108
        ch = (char)7;
#line 109
        goto switch_break;
        case_98: /* CIL Label */ 
#line 111
        ch = (char )'\b';
#line 112
        goto switch_break;
        case_101: /* CIL Label */ 
        case_69: /* CIL Label */ 
#line 115
        ch = (char)27;
#line 116
        goto switch_break;
        case_110: /* CIL Label */ 
#line 118
        ch = (char )'\n';
#line 119
        goto switch_break;
        case_114: /* CIL Label */ 
#line 121
        ch = (char )'\r';
#line 122
        goto switch_break;
        case_116: /* CIL Label */ 
#line 124
        ch = (char )'\t';
#line 125
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    } else
#line 129
    if ((int )ch == 94) {
      {
#line 131
      ch = *p;
#line 132
      p ++;
#line 133
      len --;
#line 134
      tmp___6 = toupper((int )ch);
#line 134
      ch = (char )tmp___6;
      }
#line 135
      if ((int )ch == 63) {
#line 135
        ch = (char)127;
      } else {
#line 135
        ch = (char )((int )ch - 64);
      }
    }
#line 138
    *(str + i) = ch;
#line 83
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 142
  if (meta_x) {
#line 142
    if ((int )*(str + (len - 1)) != 13) {
#line 143
      tmp___7 = len;
#line 143
      len ++;
#line 143
      *(str + tmp___7) = (char )'\r';
    }
  }
#line 145
  *(str + len) = (char )'\000';
#line 147
  return (len);
}
}
#line 157 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/misc.c"
static void Draw_tl(Window win , GC gc , int x , int y , int w , int h ) 
{ 
  int shadow ;

  {
#line 160
  shadow = 2;
#line 161
  if (w == 0) {
#line 162
    shadow = 1;
  } else
#line 161
  if (h == 0) {
#line 162
    shadow = 1;
  }
#line 164
  w += x - 1;
#line 165
  h += y - 1;
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! (shadow > 0)) {
#line 167
      goto while_break;
    }
    {
#line 169
    XDrawLine(Xdisplay, win, gc, x, y, w, y);
#line 170
    XDrawLine(Xdisplay, win, gc, x, y, x, h);
#line 167
    shadow --;
#line 167
    x ++;
#line 167
    y ++;
#line 167
    w --;
#line 167
    h --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 172
  return;
}
}
#line 177 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/misc.c"
static void Draw_br(Window win , GC gc , int x , int y , int w , int h ) 
{ 
  int shadow ;

  {
#line 180
  shadow = 2;
#line 181
  if (w == 0) {
#line 182
    shadow = 1;
  } else
#line 181
  if (h == 0) {
#line 182
    shadow = 1;
  }
#line 184
  w += x - 1;
#line 185
  h += y - 1;
#line 187
  x ++;
#line 188
  y ++;
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 189
    if (! (shadow > 0)) {
#line 189
      goto while_break;
    }
    {
#line 191
    XDrawLine(Xdisplay, win, gc, w, h, w, y);
#line 192
    XDrawLine(Xdisplay, win, gc, w, h, x, h);
#line 189
    shadow --;
#line 189
    x ++;
#line 189
    y ++;
#line 189
    w --;
#line 189
    h --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 194
  return;
}
}
#line 196 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/misc.c"
void Draw_Shadow(Window win , GC topShadow , GC botShadow , int x , int y , int w ,
                 int h ) 
{ 


  {
  {
#line 200
  Draw_tl(win, topShadow, x, y, w, h);
#line 201
  Draw_br(win, botShadow, x, y, w, h);
  }
#line 202
  return;
}
}
#line 205 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/misc.c"
void Draw_Triangle(Window win , GC topShadow , GC botShadow , int x , int y , int w ,
                   int type ) 
{ 


  {
  {
#line 211
  if (type == 114) {
#line 211
    goto case_114;
  }
#line 217
  if (type == 108) {
#line 217
    goto case_108;
  }
#line 223
  if (type == 100) {
#line 223
    goto case_100;
  }
#line 229
  if (type == 117) {
#line 229
    goto case_117;
  }
#line 209
  goto switch_break;
  case_114: /* CIL Label */ 
  {
#line 212
  XDrawLine(Xdisplay, win, topShadow, x, y, x, y + w);
#line 213
  XDrawLine(Xdisplay, win, topShadow, x, y, x + w, y + w / 2);
#line 214
  XDrawLine(Xdisplay, win, botShadow, x, y + w, x + w, y + w / 2);
  }
#line 215
  goto switch_break;
  case_108: /* CIL Label */ 
  {
#line 218
  XDrawLine(Xdisplay, win, botShadow, x + w, y + w, x + w, y);
#line 219
  XDrawLine(Xdisplay, win, botShadow, x + w, y + w, x, y + w / 2);
#line 220
  XDrawLine(Xdisplay, win, topShadow, x, y + w / 2, x + w, y);
  }
#line 221
  goto switch_break;
  case_100: /* CIL Label */ 
  {
#line 224
  XDrawLine(Xdisplay, win, topShadow, x, y, x + w / 2, y + w);
#line 225
  XDrawLine(Xdisplay, win, topShadow, x, y, x + w, y);
#line 226
  XDrawLine(Xdisplay, win, botShadow, x + w, y, x + w / 2, y + w);
  }
#line 227
  goto switch_break;
  case_117: /* CIL Label */ 
  {
#line 230
  XDrawLine(Xdisplay, win, botShadow, x + w, y + w, x + w / 2, y);
#line 231
  XDrawLine(Xdisplay, win, botShadow, x + w, y + w, x, y + w);
#line 232
  XDrawLine(Xdisplay, win, topShadow, x, y + w, x + w / 2, y);
  }
#line 233
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 243
  return;
}
}
#line 19 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/thai.h"
int ThaiWidth2Pixel(int c , unsigned char *start ) ;
#line 4 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/thai.c"
static unsigned char const   movetab[256]  = 
#line 4 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/thai.c"
  {      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0};
#line 24 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/thai.c"
int thai_spcount  =    2;
#line 26 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/thai.c"
static int thai_colinc(unsigned char c , int *udcount , int *spcount ) 
{ 
  int ret ;
  int tmp ;

  {
#line 28
  ret = 0;
#line 30
  if ((int )c == 0) {
#line 31
    tmp = 0;
#line 31
    *spcount = tmp;
#line 31
    *udcount = tmp;
  } else
#line 33
  if (! movetab[c]) {
#line 34
    ret = 1;
#line 35
    if ((int )c == 32) {
#line 36
      (*spcount) ++;
#line 37
      if (*spcount == thai_spcount) {
#line 38
        *spcount = 0;
#line 39
        ret += *udcount;
#line 40
        *udcount = 0;
      }
    } else {
#line 44
      *spcount = 0;
    }
  } else {
#line 48
    (*udcount) ++;
#line 49
    *spcount = 0;
#line 50
    ret = 0;
  }
#line 53
  return (ret);
}
}
#line 58 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/thai.c"
static int ud1  ;
#line 58 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/thai.c"
static int sp1  ;
#line 56 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/thai.c"
static int thai_colinc1(unsigned char c ) 
{ 
  int tmp ;

  {
  {
#line 59
  tmp = thai_colinc(c, & ud1, & sp1);
  }
#line 59
  return (tmp);
}
}
#line 64 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/thai.c"
static int ud2  ;
#line 64 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/thai.c"
static int sp2  ;
#line 62 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/thai.c"
static int thai_colinc2(unsigned char c ) 
{ 
  int tmp ;

  {
  {
#line 65
  tmp = thai_colinc(c, & ud2, & sp2);
  }
#line 65
  return (tmp);
}
}
#line 68 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/thai.c"
static int thaistrlen(unsigned char *from , unsigned char *to ) 
{ 
  int j ;
  int tmp ;

  {
#line 72
  j = 0;
#line 73
  if (thai_spcount) {
    {
#line 74
    thai_colinc1((unsigned char)0);
    }
    {
#line 75
    while (1) {
      while_continue: /* CIL Label */ ;
#line 75
      if (! ((unsigned long )from != (unsigned long )to)) {
#line 75
        goto while_break;
      }
      {
#line 76
      tmp = thai_colinc1(*from);
#line 76
      j += tmp;
#line 77
      from ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 81
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 81
      if (! ((unsigned long )from != (unsigned long )to)) {
#line 81
        goto while_break___0;
      }
#line 82
      if (! movetab[*from]) {
#line 82
        j ++;
      }
#line 83
      from ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 86
  return (j);
}
}
#line 89 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/thai.c"
int thai_compare(text_t *d , text_t *s , rend_t *dr , rend_t *sr , int *result , int *mcol ,
                 int *mcolcount ) 
{ 
  int i ;
  int j ;
  int len ;
  int *col ;
  unsigned long __lengthofcol ;
  void *tmp ;
  unsigned int *col_d ;
  unsigned long __lengthofcol_d ;
  void *tmp___0 ;
  unsigned int *col_s ;
  unsigned long __lengthofcol_s ;
  void *tmp___1 ;
  int ptr_d ;
  int ptr_s ;
  int ptr ;
  int s1 ;
  int s2 ;
  unsigned int tmp___2 ;

  {
  {
#line 94
  __lengthofcol = (unsigned long )((int )TermWin.ncol + 1);
#line 94
  tmp = __builtin_alloca(sizeof(*col) * __lengthofcol);
#line 94
  col = (int *)tmp;
#line 95
  __lengthofcol_d = (unsigned long )(2 * (int )TermWin.ncol + 4);
#line 95
  tmp___0 = __builtin_alloca(sizeof(*col_d) * __lengthofcol_d);
#line 95
  col_d = (unsigned int *)tmp___0;
#line 96
  __lengthofcol_s = (unsigned long )(2 * (int )TermWin.ncol + 4);
#line 96
  tmp___1 = __builtin_alloca(sizeof(*col_s) * __lengthofcol_s);
#line 96
  col_s = (unsigned int *)tmp___1;
#line 102
  *mcolcount = 0;
#line 104
  i = 2 * (int )TermWin.ncol + 4;
  }
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if (! (i > 0)) {
#line 105
      goto while_break;
    }
#line 106
    i --;
#line 107
    tmp___2 = 0U;
#line 107
    *(col_s + i) = tmp___2;
#line 107
    *(col_d + i) = tmp___2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 111
  ptr_s = 0;
#line 111
  ptr_d = ptr_s;
#line 111
  len = ptr_d;
#line 112
  thai_colinc1((unsigned char)0);
#line 113
  thai_colinc2((unsigned char)0);
#line 115
  *(mcol + TermWin.ncol) = 0;
#line 116
  i = 0;
  }
  {
#line 116
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 116
    if (! (i < (int )TermWin.ncol)) {
#line 116
      goto while_break___0;
    }
    {
#line 117
    *(result + i) = 0;
#line 118
    *(mcol + i) = 0;
#line 119
    s1 = thai_colinc1(*(s + i));
#line 120
    len += s1;
#line 121
    ptr_s += s1 * 2;
    }
#line 122
    if (! movetab[*(s + i)]) {
#line 123
      *(col_s + ptr_s) = (rend_t )*(s + i) + *(sr + i);
    } else {
#line 126
      *(col_s + (ptr_s + 1)) += (rend_t )*(s + i) + *(sr + i);
    }
    {
#line 128
    *(col + i) = len;
#line 130
    s2 = thai_colinc2(*(d + i));
#line 131
    ptr_d += s2 * 2;
    }
#line 132
    if (! movetab[*(d + i)]) {
#line 133
      *(col_d + ptr_d) = (rend_t )*(d + i) + *(dr + i);
    } else {
#line 136
      *(col_d + (ptr_d + 1)) += (rend_t )*(d + i) + *(dr + i);
    }
#line 116
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 140
  i = 1;
#line 140
  ptr = 2;
  {
#line 140
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 140
    if (! (i <= (int )TermWin.ncol)) {
#line 140
      goto while_break___1;
    }
#line 141
    if (*(col_d + ptr) != *(col_s + ptr)) {
#line 143
      *(mcol + i) = 1;
#line 144
      (*mcolcount) ++;
    } else
#line 141
    if (*(col_d + (ptr + 1)) != *(col_s + (ptr + 1))) {
#line 143
      *(mcol + i) = 1;
#line 144
      (*mcolcount) ++;
    } else
#line 146
    if (! *(col_s + ptr)) {
#line 147
      *(mcol + i) = 1;
#line 148
      (*mcolcount) ++;
    }
#line 140
    i ++;
#line 140
    ptr += 2;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 152
  i = 0;
  {
#line 152
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 152
    if (! (i < (int )TermWin.ncol)) {
#line 152
      goto while_break___2;
    }
#line 153
    j = *(mcol + *(col + i));
#line 153
    if (j != 0) {
#line 154
      *(result + i) = 1;
#line 155
      if (j == 1) {
#line 156
        (*mcolcount) --;
#line 157
        *(mcol + *(col + i)) = 2;
      }
    }
#line 152
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 161
  return (len);
}
}
#line 164 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/thai.c"
int thai_isupper(unsigned char c ) 
{ 


  {
#line 166
  return ((int )movetab[c]);
}
}
#line 169 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/thai.c"
static short const   levtable[48]  = 
#line 169
  {      (short const   )0,      (short const   )2,      (short const   )0,      (short const   )0, 
        (short const   )2,      (short const   )2,      (short const   )2,      (short const   )2, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )2, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )3, 
        (short const   )3,      (short const   )3,      (short const   )3,      (short const   )3, 
        (short const   )3,      (short const   )3,      (short const   )3,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0};
#line 175 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/thai.c"
int thai_level(unsigned char c ) 
{ 
  int tmp ;

  {
#line 177
  if ((int )c > 208) {
#line 177
    tmp = (int const   )levtable[(int )c - 208];
  } else {
#line 177
    tmp = (int const   )0;
  }
#line 177
  return ((int )tmp);
}
}
#line 182 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/thai.c"
int ThaiCol2Pixel(int c , unsigned char *start ) 
{ 
  int tmp ;

  {
  {
#line 184
  tmp = thaistrlen(start, start + c);
  }
#line 184
  return (tmp * (int )TermWin.fwidth + 2);
}
}
#line 188 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/thai.c"
int ThaiWidth2Pixel(int c , unsigned char *start ) 
{ 
  int tmp ;

  {
  {
#line 190
  tmp = thaistrlen(start, start + c);
  }
#line 190
  return (tmp * (int )TermWin.fwidth);
}
}
#line 193 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/thai.c"
int ThaiPixel2Col(int x , int y ) 
{ 
  int doffset ;
  unsigned char *start ;
  int col ;
  int cx ;
  int tmp ;

  {
#line 195
  doffset = ((y - 2) / (int )TermWin.fheight) * ((int )TermWin.ncol + 1);
#line 196
  start = drawn_text + doffset;
#line 197
  col = 0;
#line 197
  cx = 0;
#line 198
  x -= 2;
#line 199
  if (thai_spcount) {
    {
#line 200
    thai_colinc1((unsigned char)0);
    }
    {
#line 201
    while (1) {
      while_continue: /* CIL Label */ ;
#line 201
      if (! (cx <= x)) {
#line 201
        goto while_break;
      }
      {
#line 202
      tmp = thai_colinc1(*(start + col));
#line 202
      cx += (int )TermWin.fwidth * tmp;
#line 203
      col ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 207
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 207
      if (! (cx <= x)) {
#line 207
        goto while_break___0;
      }
#line 208
      if (! movetab[*(start + col)]) {
#line 209
        cx += (int )TermWin.fwidth;
      }
#line 210
      col ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 213
  return (col - 1);
}
}
#line 216 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/thai.c"
int ThaiPixel2Col2(int x , int y ) 
{ 
  int doffset ;
  unsigned char *start ;
  int col ;
  int cx ;
  int tmp ;

  {
#line 218
  doffset = ((y - 2) / (int )TermWin.fheight) * ((int )TermWin.ncol + 1);
#line 219
  start = drawn_text + doffset;
#line 220
  col = 0;
#line 220
  cx = 0;
#line 221
  x -= 2;
#line 222
  if (thai_spcount) {
    {
#line 223
    thai_colinc1((unsigned char)0);
    }
    {
#line 224
    while (1) {
      while_continue: /* CIL Label */ ;
#line 224
      if (! (cx <= x)) {
#line 224
        goto while_break;
      }
      {
#line 225
      tmp = thai_colinc1(*(start + col));
#line 225
      cx += (int )TermWin.fwidth * tmp;
#line 226
      col ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 230
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 230
      if (! (cx <= x)) {
#line 230
        goto while_break___0;
      }
#line 231
      if (! movetab[*(start + col)]) {
#line 232
        cx += (int )TermWin.fwidth;
      }
#line 233
      col ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 237
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 237
    if (movetab[*(start + col)]) {
#line 237
      if (! (col < (int )TermWin.ncol)) {
#line 237
        goto while_break___1;
      }
    } else {
#line 237
      goto while_break___1;
    }
#line 238
    col ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 239
  return (col - 1);
}
}
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 1522 "/usr/include/X11/Xlib.h"
extern char *XGetDefault(Display * , char const   * , char const   * ) ;
#line 37 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/xdefaults.c"
char const   *rs_title  =    (char const   *)((void *)0);
#line 38 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/xdefaults.c"
char const   *rs_iconName  =    (char const   *)((void *)0);
#line 39 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/xdefaults.c"
char const   *rs_geometry  =    (char const   *)((void *)0);
#line 40 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/xdefaults.c"
char const   *rs_saveLines  =    (char const   *)((void *)0);
#line 57 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/xdefaults.c"
static char const   *rs_loginShell  =    (char const   *)((void *)0);
#line 58 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/xdefaults.c"
static char const   *rs_utmpInhibit  =    (char const   *)((void *)0);
#line 59 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/xdefaults.c"
static char const   *rs_scrollBar  =    (char const   *)((void *)0);
#line 70 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/xdefaults.c"
static char const   *rs_visualBell  =    (char const   *)((void *)0);
#line 71 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/xdefaults.c"
static char const   *rs_reverseVideo  =    (char const   *)((void *)0);
#line 82 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/xdefaults.c"
static char const   *rs_thai_space  =    (char const   *)((void *)0);
#line 83 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/xdefaults.c"
static char const   *rs_thai_keyboard  =    (char const   *)((void *)0);
#line 98 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/xdefaults.c"
static struct __anonstruct_optList_108  const  optList[51]  = 
#line 98
  {      {0UL, & display_name, (char const   */* const  */)((void *)0), (char const   */* const  */)"display",
      (char const   */* const  */)"displayname", (char const   */* const  */)"X server to contact"}, 
        {0UL,
      & rs_geometry, (char const   */* const  */)"geometry", (char const   */* const  */)"geometry",
      (char const   */* const  */)"geom", (char const   */* const  */)"size (in characters) and position"}, 
        {0UL,
      & display_name, (char const   */* const  */)((void *)0), (char const   */* const  */)"d",
      (char const   */* const  */)((void *)0), (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_geometry, (char const   */* const  */)((void *)0), (char const   */* const  */)"g",
      (char const   */* const  */)((void *)0), (char const   */* const  */)((void *)0)}, 
        {(1UL << 31) | (1UL << 5),
      & rs_reverseVideo, (char const   */* const  */)"reverseVideo", (char const   */* const  */)"rv",
      (char const   */* const  */)((void *)0), (char const   */* const  */)"reverse video"}, 
        {0UL,
      & rs_color[1], (char const   */* const  */)"background", (char const   */* const  */)"bg",
      (char const   */* const  */)"color", (char const   */* const  */)"background color"}, 
        {0UL,
      & rs_color[0], (char const   */* const  */)"foreground", (char const   */* const  */)"fg",
      (char const   */* const  */)"color", (char const   */* const  */)"foreground color"}, 
        {0UL,
      & rs_color[2], (char const   */* const  */)"color0", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_color[3], (char const   */* const  */)"color1", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_color[4], (char const   */* const  */)"color2", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_color[5], (char const   */* const  */)"color3", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_color[6], (char const   */* const  */)"color4", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_color[7], (char const   */* const  */)"color5", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_color[8], (char const   */* const  */)"color6", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_color[9], (char const   */* const  */)"color7", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_color[10], (char const   */* const  */)"color8", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_color[11], (char const   */* const  */)"color9", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_color[12], (char const   */* const  */)"color10", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_color[13], (char const   */* const  */)"color11", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_color[14], (char const   */* const  */)"color12", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_color[15], (char const   */* const  */)"color13", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_color[16], (char const   */* const  */)"color14", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_color[17], (char const   */* const  */)"color15", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_color[21], (char const   */* const  */)"colorBD", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_color[22], (char const   */* const  */)"colorUL", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_color[23], (char const   */* const  */)"scrollColor", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_boldFont, (char const   */* const  */)"boldFont", (char const   */* const  */)"fb",
      (char const   */* const  */)"fontname", (char const   */* const  */)"bold text font"}, 
        {0UL,
      & rs_font[0], (char const   */* const  */)"font", (char const   */* const  */)"fn",
      (char const   */* const  */)"fontname", (char const   */* const  */)"normal text font"}, 
        {0UL,
      & rs_font[1], (char const   */* const  */)"font1", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"fontname", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_font[2], (char const   */* const  */)"font2", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"fontname", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_font[3], (char const   */* const  */)"font3", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"fontname", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_font[4], (char const   */* const  */)"font4", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"fontname", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_thai_space, (char const   */* const  */)"thai_space", (char const   */* const  */)"tspace",
      (char const   */* const  */)"int", (char const   */* const  */)"Space count to trigger compensation"}, 
        {0UL,
      & rs_thai_keyboard, (char const   */* const  */)"thai_keyboard", (char const   */* const  */)"tkb",
      (char const   */* const  */)"mode", (char const   */* const  */)"Thai keyboard mapping; mode = tis | ket"}, 
        {0UL,
      & rs_inputMethod, (char const   */* const  */)"thai_im", (char const   */* const  */)"tim",
      (char const   */* const  */)"mode", (char const   */* const  */)"Thai input method; mode = BasicCheck | Strict | Passthrough"}, 
        {1UL << 2,
      (char const   **)((void *)0), (char const   */* const  */)((void *)0), (char const   */* const  */)"iconic",
      (char const   */* const  */)((void *)0), (char const   */* const  */)"start iconic"}, 
        {1UL << 2,
      (char const   **)((void *)0), (char const   */* const  */)((void *)0), (char const   */* const  */)"ic",
      (char const   */* const  */)((void *)0), (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_name, (char const   */* const  */)((void *)0), (char const   */* const  */)"name",
      (char const   */* const  */)"string", (char const   */* const  */)"client instance, icon, and title strings"}, 
        {0UL,
      & rs_title, (char const   */* const  */)"title", (char const   */* const  */)"title",
      (char const   */* const  */)"string", (char const   */* const  */)"title name for window"}, 
        {0UL,
      & rs_title, (char const   */* const  */)((void *)0), (char const   */* const  */)"T",
      (char const   */* const  */)((void *)0), (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_iconName, (char const   */* const  */)"iconName", (char const   */* const  */)"n",
      (char const   */* const  */)"string", (char const   */* const  */)"icon name for window"}, 
        {0UL,
      & rs_color[18], (char const   */* const  */)"cursorColor", (char const   */* const  */)"cr",
      (char const   */* const  */)"color", (char const   */* const  */)"cursor color"}, 
        {0UL,
      & rs_color[19], (char const   */* const  */)"cursorColor2", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_color[20], (char const   */* const  */)"cursorColorThai", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {(1UL << 31) | (1UL << 1),
      & rs_loginShell, (char const   */* const  */)"loginShell", (char const   */* const  */)"ls",
      (char const   */* const  */)((void *)0), (char const   */* const  */)"login shell"}, 
        {(1UL << 31) | (1UL << 7),
      & rs_scrollBar, (char const   */* const  */)"scrollBar", (char const   */* const  */)"sb",
      (char const   */* const  */)((void *)0), (char const   */* const  */)"scrollbar"}, 
        {0UL,
      & rs_saveLines, (char const   */* const  */)"saveLines", (char const   */* const  */)"sl",
      (char const   */* const  */)"number", (char const   */* const  */)"number of scrolled lines to save"}, 
        {(1UL << 31) | (1UL << 6),
      & rs_utmpInhibit, (char const   */* const  */)"utmpInhibit", (char const   */* const  */)"ut",
      (char const   */* const  */)((void *)0), (char const   */* const  */)"utmp inhibit"}, 
        {(1UL << 31) | (1UL << 3),
      & rs_visualBell, (char const   */* const  */)"visualBell", (char const   */* const  */)"vb",
      (char const   */* const  */)((void *)0), (char const   */* const  */)"visual bell"}, 
        {1UL,
      (char const   **)((void *)0), (char const   */* const  */)((void *)0), (char const   */* const  */)"C",
      (char const   */* const  */)((void *)0), (char const   */* const  */)"intercept console messages"}, 
        {0UL,
      (char const   **)((void *)0), (char const   */* const  */)((void *)0), (char const   */* const  */)"e",
      (char const   */* const  */)"command arg ...", (char const   */* const  */)"command to execute"}};
#line 315 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/xdefaults.c"
static void usage(int type ) 
{ 
  int i ;
  int col ;
  int len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  size_t tmp___11 ;

  {
  {
#line 321
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nUsage v1.10:\n  xiterm+thai");
  }
  {
#line 323
  if (type == 0) {
#line 323
    goto case_0;
  }
#line 358
  if (type == 1) {
#line 358
    goto case_1;
  }
#line 376
  if (type == 2) {
#line 376
    goto case_2;
  }
#line 322
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 324
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" [-help]\n   ");
#line 325
  col = 3;
#line 326
  i = 0;
  }
  {
#line 326
  while (1) {
    while_continue: /* CIL Label */ ;
#line 326
    if (! ((unsigned long )i < sizeof(optList) / sizeof(optList[0]))) {
#line 326
      goto while_break;
    }
#line 328
    if ((unsigned long )optList[i].desc != (unsigned long )((void *)0)) {
#line 330
      len = 2;
#line 331
      if (! (optList[i].flag & (unsigned long const   )(1UL << 31))) {
#line 333
        if (optList[i].flag) {
#line 333
          len = 0;
        } else {
#line 333
          if (optList[i].arg) {
            {
#line 333
            tmp = strlen((char const   *)optList[i].arg);
#line 333
            tmp___0 = tmp;
            }
          } else {
#line 333
            tmp___0 = (size_t )1;
          }
#line 333
          len = (int )tmp___0;
        }
#line 334
        if (len > 0) {
#line 335
          len ++;
        }
      }
      {
#line 337
      tmp___1 = strlen((char const   *)optList[i].opt);
#line 337
      len = (int )((size_t )len + (4UL + tmp___1));
#line 339
      col += len;
      }
#line 340
      if (col > 79) {
        {
#line 342
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n   ");
#line 343
        col = 3 + len;
        }
      }
      {
#line 345
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" [-");
      }
#line 346
      if (optList[i].flag & (unsigned long const   )(1UL << 31)) {
        {
#line 347
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"/+");
        }
      }
      {
#line 348
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
              optList[i].opt);
      }
#line 349
      if (optList[i].flag) {
#line 349
        tmp___4 = (size_t )0;
      } else {
#line 349
        if (optList[i].arg) {
          {
#line 349
          tmp___2 = strlen((char const   *)optList[i].arg);
#line 349
          tmp___3 = tmp___2;
          }
        } else {
#line 349
          tmp___3 = (size_t )1;
        }
#line 349
        tmp___4 = tmp___3;
      }
#line 349
      if (tmp___4) {
        {
#line 350
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %s]",
                optList[i].arg);
        }
      } else {
        {
#line 352
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"]");
        }
      }
    }
#line 326
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 355
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n\n");
  }
#line 356
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 359
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" [options] [-e command args]\n\nwhere options include:\n");
#line 363
  i = 0;
  }
  {
#line 363
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 363
    if (! ((unsigned long )i < sizeof(optList) / sizeof(optList[0]))) {
#line 363
      goto while_break___0;
    }
#line 364
    if ((unsigned long )optList[i].desc != (unsigned long )((void *)0)) {
#line 365
      if (optList[i].flag & (unsigned long const   )(1UL << 31)) {
#line 365
        tmp___5 = "turn on/off ";
      } else {
#line 365
        tmp___5 = "";
      }
#line 365
      if (optList[i].arg) {
#line 365
        tmp___6 = optList[i].arg;
      } else {
#line 365
        tmp___6 = (char const   */* const  */)"";
      }
      {
#line 365
      tmp___7 = strlen((char const   *)optList[i].opt);
      }
#line 365
      if (optList[i].flag & (unsigned long const   )(1UL << 31)) {
#line 365
        tmp___8 = 0;
      } else {
#line 365
        tmp___8 = 2;
      }
#line 365
      if (optList[i].flag & (unsigned long const   )(1UL << 31)) {
#line 365
        tmp___9 = "-/+";
      } else {
#line 365
        tmp___9 = "-";
      }
      {
#line 365
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    %s%s %-*s%s%s\n",
              tmp___9, optList[i].opt, (int )((30UL - tmp___7) + (size_t )tmp___8),
              tmp___6, tmp___5, optList[i].desc);
      }
    }
#line 363
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 373
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n    --help to list long-options\n\n");
  }
#line 374
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 377
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" [options] [-e command args]\n\nwhere resources (long-options) include:\n");
#line 381
  i = 0;
  }
  {
#line 381
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 381
    if (! ((unsigned long )i < sizeof(optList) / sizeof(optList[0]))) {
#line 381
      goto while_break___1;
    }
#line 382
    if ((unsigned long )optList[i].kw != (unsigned long )((void *)0)) {
#line 383
      if (optList[i].flag & (unsigned long const   )(1UL << 31)) {
#line 383
        tmp___10 = (char const   */* const  */)"boolean";
      } else {
#line 383
        tmp___10 = optList[i].arg;
      }
      {
#line 383
      tmp___11 = strlen((char const   *)optList[i].kw);
#line 383
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    %s: %*s\n",
              optList[i].kw, (int )(30UL - tmp___11), tmp___10);
      }
    }
#line 381
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 392
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n    -help to list options\n\n");
  }
#line 393
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 395
  exit(1);
  }
}
}
#line 404 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/xdefaults.c"
static char const   * const  On  =    (char const   */* const  */)"ON";
#line 405 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/xdefaults.c"
static char const   * const  Off  =    (char const   */* const  */)"OFF";
#line 400 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/xdefaults.c"
void get_options(int argc , char **argv ) 
{ 
  int i ;
  int bad_option ;
  int entry ;
  int longopt ;
  char const   *flag ;
  char *opt ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *str ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  char const   *msg ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 403
  bad_option = 0;
#line 407
  i = 1;
  {
#line 407
  while (1) {
    while_continue: /* CIL Label */ ;
#line 407
    if (! (i < argc)) {
#line 407
      goto while_break;
    }
#line 409
    longopt = 0;
#line 411
    opt = *(argv + i);
#line 416
    if ((int )*opt == 45) {
#line 418
      flag = (char const   *)On;
#line 419
      opt ++;
#line 419
      if ((int )*opt == 45) {
#line 419
        tmp = opt;
#line 419
        opt ++;
#line 419
        longopt = (int )*tmp;
      }
    } else
#line 421
    if ((int )*opt == 43) {
#line 423
      flag = (char const   *)Off;
#line 424
      opt ++;
#line 424
      if ((int )*opt == 43) {
#line 424
        tmp___0 = opt;
#line 424
        opt ++;
#line 424
        longopt = (int )*tmp___0;
      }
    } else {
      {
#line 428
      bad_option = 1;
#line 429
      print_error("bad option \"%s\"", opt);
      }
#line 430
      goto __Cont;
    }
    {
#line 433
    tmp___2 = strcmp((char const   *)opt, "help");
    }
#line 433
    if (! tmp___2) {
#line 433
      if (longopt) {
#line 433
        tmp___1 = 2;
      } else {
#line 433
        tmp___1 = 1;
      }
      {
#line 433
      usage(tmp___1);
      }
    }
#line 436
    entry = 0;
    {
#line 436
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 436
      if (! ((unsigned long )entry < sizeof(optList) / sizeof(optList[0]))) {
#line 436
        goto while_break___0;
      }
#line 437
      if (optList[entry].kw) {
        {
#line 437
        tmp___3 = strcmp((char const   *)opt, (char const   *)optList[entry].kw);
        }
#line 437
        if (tmp___3) {
#line 437
          goto _L;
        } else {
#line 440
          goto while_break___0;
        }
      } else
      _L: /* CIL Label */ 
#line 437
      if (! longopt) {
#line 437
        if (optList[entry].opt) {
          {
#line 437
          tmp___4 = strcmp((char const   *)opt, (char const   *)optList[entry].opt);
          }
#line 437
          if (! tmp___4) {
#line 440
            goto while_break___0;
          }
        }
      }
#line 436
      entry ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 442
    if ((unsigned long )entry < sizeof(optList) / sizeof(optList[0])) {
#line 444
      if (optList[entry].flag) {
#line 444
        tmp___9 = (size_t )0;
      } else {
#line 444
        if (optList[entry].arg) {
          {
#line 444
          tmp___7 = strlen((char const   *)optList[entry].arg);
#line 444
          tmp___8 = tmp___7;
          }
        } else {
#line 444
          tmp___8 = (size_t )1;
        }
#line 444
        tmp___9 = tmp___8;
      }
#line 444
      if (tmp___9) {
#line 446
        i ++;
#line 446
        str = *(argv + i);
#line 452
        if ((unsigned long )flag == (unsigned long )On) {
#line 452
          if (str) {
#line 452
            if (optList[entry].dp) {
              {
#line 456
              *(optList[entry].dp) = (char const   *)str;
#line 459
              tmp___6 = strcmp((char const   *)opt, "n");
              }
#line 459
              if (tmp___6) {
                {
#line 461
                tmp___5 = strcmp((char const   *)opt, "name");
                }
#line 461
                if (! tmp___5) {
#line 462
                  if (! rs_title) {
#line 462
                    rs_title = (char const   *)str;
                  }
#line 463
                  if (! rs_iconName) {
#line 463
                    rs_iconName = (char const   *)str;
                  }
                }
              } else
#line 460
              if (! rs_title) {
#line 460
                rs_title = (char const   *)str;
              }
            }
          }
        }
      } else {
#line 476
        if ((unsigned long )flag == (unsigned long )On) {
#line 477
          Options |= (unsigned long )optList[entry].flag;
        } else {
#line 479
          Options &= (unsigned long )(~ optList[entry].flag);
        }
#line 481
        if (optList[entry].dp) {
#line 482
          *(optList[entry].dp) = flag;
        }
      }
    } else {
#line 491
      msg = "bad";
#line 492
      if (longopt) {
#line 494
        opt --;
#line 495
        bad_option = 1;
      } else {
        {
#line 497
        tmp___10 = strcmp((char const   *)opt, "7");
        }
#line 497
        if (tmp___10) {
          {
#line 497
          tmp___11 = strcmp((char const   *)opt, "8");
          }
#line 497
          if (tmp___11) {
            {
#line 497
            tmp___12 = strcmp((char const   *)opt, "fat");
            }
#line 497
            if (tmp___12) {
              {
#line 497
              tmp___13 = strcmp((char const   *)opt, "thin");
              }
#line 497
              if (tmp___13) {
#line 506
                bad_option = 1;
              } else {
#line 504
                msg = "obsolete";
              }
            } else {
#line 504
              msg = "obsolete";
            }
          } else {
#line 504
            msg = "obsolete";
          }
        } else {
#line 504
          msg = "obsolete";
        }
      }
      {
#line 508
      opt --;
#line 508
      print_error("%s option \"%s\"", msg, opt);
      }
    }
    __Cont: /* CIL Label */ 
#line 407
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 512
  if (bad_option) {
    {
#line 513
    usage(0);
    }
  }
#line 514
  return;
}
}
#line 523 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/xdefaults.c"
static int my_strcasecmp(char const   *s1 , char const   *s2 ) 
{ 
  register int c1 ;
  int tmp ;
  register int c2 ;
  int tmp___0 ;

  {
  {
#line 526
  while (1) {
    while_continue: /* CIL Label */ ;
#line 526
    if (*s1) {
#line 526
      if (! *s2) {
#line 526
        goto while_break;
      }
    } else {
#line 526
      goto while_break;
    }
    {
#line 528
    tmp = toupper((int )*s1);
#line 528
    c1 = tmp;
#line 529
    tmp___0 = toupper((int )*s2);
#line 529
    c2 = tmp___0;
    }
#line 530
    if (c1 != c2) {
#line 531
      return (c1 - c2);
    }
#line 526
    s1 ++;
#line 526
    s2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 533
  return ((int )((int const   )*s1 - (int const   )*s2));
}
}
#line 664 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/xdefaults.c"
void extract_resources(Display *display , char const   *name ) 
{ 
  int entry ;
  char *p ;
  char const   *kw ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 673
  entry = 0;
  {
#line 673
  while (1) {
    while_continue: /* CIL Label */ ;
#line 673
    if (! ((unsigned long )entry < sizeof(optList) / sizeof(optList[0]))) {
#line 673
      goto while_break;
    }
#line 676
    kw = (char const   *)optList[entry].kw;
#line 677
    if ((unsigned long )kw == (unsigned long )((void *)0)) {
#line 678
      goto __Cont;
    } else
#line 677
    if ((unsigned long )*(optList[entry].dp) != (unsigned long )((void *)0)) {
#line 678
      goto __Cont;
    }
    {
#line 679
    p = XGetDefault(display, name, kw);
    }
#line 679
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 679
      goto _L;
    } else {
      {
#line 679
      p = XGetDefault(display, "XiTerm", kw);
      }
#line 679
      if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 679
        goto _L;
      } else {
        {
#line 679
        p = XGetDefault(display, "XTerm", kw);
        }
#line 679
        if ((unsigned long )p != (unsigned long )((void *)0)) {
          _L: /* CIL Label */ 
#line 683
          *(optList[entry].dp) = (char const   *)p;
#line 685
          if (optList[entry].flag & (unsigned long const   )(1UL << 31)) {
            {
#line 687
            tmp = my_strcasecmp((char const   *)p, "TRUE");
            }
#line 687
            if (tmp) {
#line 690
              Options &= (unsigned long )(~ optList[entry].flag);
            } else {
#line 688
              Options |= (unsigned long )optList[entry].flag;
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 673
    entry ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 778
  if ((unsigned long )rs_thai_space != (unsigned long )((void *)0)) {
    {
#line 779
    sscanf((char const   */* __restrict  */)rs_thai_space, (char const   */* __restrict  */)"%d",
           & thai_spcount);
    }
  }
#line 781
  if ((unsigned long )rs_thai_keyboard != (unsigned long )((void *)0)) {
    {
#line 782
    tmp___1 = strcmp(rs_thai_keyboard, "tis");
    }
#line 782
    if (tmp___1 == 0) {
      {
#line 783
      thai_set_keyboard(1);
      }
    } else {
      {
#line 784
      tmp___0 = strcmp(rs_thai_keyboard, "ket");
      }
#line 784
      if (tmp___0 == 0) {
        {
#line 785
        thai_set_keyboard(0);
        }
      }
    }
  }
#line 798
  return;
}
}
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 83 "/usr/include/utmpx.h"
extern struct utmpx *pututxline(struct utmpx  const  *__utmpx ) ;
#line 101
extern void updwtmpx(char const   *__wtmpx_file , struct utmpx  const  *__utmpx ) ;
#line 111
extern void getutmp(struct utmpx  const  *__utmpx , struct utmp *__utmp ) ;
#line 120
extern void getutmpx(struct utmp  const  *__utmp , struct utmpx *__utmpx ) ;
#line 59 "/usr/include/utmp.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) utmpname)(char const   *__file ) ;
#line 65
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) setutent)(void) ;
#line 68
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) endutent)(void) ;
#line 72
extern  __attribute__((__nothrow__)) struct utmp *( __attribute__((__leaf__)) getutid)(struct utmp  const  *__id ) ;
#line 79
extern  __attribute__((__nothrow__)) struct utmp *( __attribute__((__leaf__)) pututline)(struct utmp  const  *__utmp_ptr ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 671 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getsid)(__pid_t __pid ) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 188 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/utmp.c"
static char ut_id[5]  = {      (char )'\000'};
#line 257 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/utmp.c"
void makeutent(char const   *pty , char const   *hostname ) 
{ 
  struct passwd *pwent ;
  __uid_t tmp ;
  struct passwd *tmp___0 ;
  struct utmpx utmp ;
  struct utmp utmp2 ;
  int tmp___1 ;
  int n ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  time_t tmp___5 ;

  {
  {
#line 260
  tmp = getuid();
#line 260
  tmp___0 = getpwuid(tmp);
#line 260
  pwent = tmp___0;
#line 264
  memset((void *)(& utmp), 0, sizeof(struct utmpx ));
#line 270
  tmp___1 = strncmp(pty, "/dev/", (size_t )5);
  }
#line 270
  if (! tmp___1) {
#line 270
    pty += 5;
  }
  {
#line 271
  tmp___3 = strncmp(pty, "pty", (size_t )3);
  }
#line 271
  if (tmp___3) {
    {
#line 271
    tmp___4 = strncmp(pty, "tty", (size_t )3);
    }
#line 271
    if (tmp___4) {
      {
#line 276
      tmp___2 = sscanf((char const   */* __restrict  */)pty, (char const   */* __restrict  */)"pts/%d",
                       & n);
      }
#line 276
      if (tmp___2 == 1) {
        {
#line 277
        sprintf((char */* __restrict  */)(ut_id), (char const   */* __restrict  */)"vt%02x",
                n);
        }
      } else {
        {
#line 280
        print_error("can\'t parse tty name \"%s\"", pty);
#line 281
        ut_id[0] = (char )'\000';
        }
#line 282
        return;
      }
    } else {
      {
#line 272
      strncpy((char */* __restrict  */)(ut_id), (char const   */* __restrict  */)(pty + 3),
              sizeof(ut_id));
      }
    }
  } else {
    {
#line 272
    strncpy((char */* __restrict  */)(ut_id), (char const   */* __restrict  */)(pty + 3),
            sizeof(ut_id));
    }
  }
  {
#line 285
  strncpy((char */* __restrict  */)(utmp.ut_id), (char const   */* __restrict  */)(ut_id),
          sizeof(utmp.ut_id));
#line 286
  utmp.ut_type = (short)8;
#line 289
  getutmp((struct utmpx  const  *)(& utmp), & utmp2);
#line 290
  getutid((struct utmp  const  *)(& utmp2));
#line 296
  strncpy((char */* __restrict  */)(utmp.ut_id), (char const   */* __restrict  */)(ut_id),
          sizeof(utmp.ut_id));
#line 297
  strncpy((char */* __restrict  */)(utmp.ut_line), (char const   */* __restrict  */)pty,
          sizeof(utmp.ut_line));
#line 298
  strncpy((char */* __restrict  */)(utmp.ut_user), (char const   */* __restrict  */)pwent->pw_name,
          sizeof(utmp.ut_user));
#line 299
  strncpy((char */* __restrict  */)(utmp.ut_user), (char const   */* __restrict  */)pwent->pw_name,
          sizeof(utmp.ut_user));
#line 300
  strncpy((char */* __restrict  */)(utmp.ut_host), (char const   */* __restrict  */)hostname,
          sizeof(utmp.ut_host));
#line 308
  utmp.ut_type = (short)7;
#line 309
  utmp.ut_pid = getpid();
#line 312
  utmp.ut_session = getsid(0);
#line 313
  tmp___5 = time((time_t *)((void *)0));
#line 313
  utmp.ut_tv.tv_sec = (__int32_t )tmp___5;
#line 314
  utmp.ut_tv.tv_usec = 0;
#line 322
  utmpname("/var/run/utmp");
#line 324
  getutmp((struct utmpx  const  *)(& utmp), & utmp2);
#line 325
  pututline((struct utmp  const  *)(& utmp2));
#line 326
  pututxline((struct utmpx  const  *)(& utmp));
#line 331
  updwtmpx("/var/log/wtmp", (struct utmpx  const  *)(& utmp));
#line 332
  endutent();
  }
#line 333
  return;
}
}
#line 348 "/home/june/repo/benchmarks/collector2/temp/xiterm+thai-1.10/src/utmp.c"
void cleanutent(void) 
{ 
  struct utmp utmp ;
  struct utmpx utmpx ;
  struct utmp *tmp ;
  time_t tmp___0 ;

  {
#line 355
  if (! ut_id[0]) {
#line 355
    return;
  }
  {
#line 357
  utmpname("/var/run/utmp");
#line 358
  setutent();
#line 359
  tmp = getutid((struct utmp  const  *)(& utmp));
  }
#line 359
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 359
    return;
  }
  {
#line 360
  utmp.ut_type = (short)8;
#line 361
  tmp___0 = time((time_t *)((void *)0));
#line 361
  utmp.ut_tv.tv_sec = (int32_t )tmp___0;
#line 362
  pututline((struct utmp  const  *)(& utmp));
#line 363
  getutmpx((struct utmp  const  *)(& utmp), & utmpx);
#line 364
  updwtmpx("/var/log/wtmp", (struct utmpx  const  *)(& utmpx));
#line 365
  endutent();
  }
#line 394
  return;
}
}
