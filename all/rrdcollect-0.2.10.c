/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 130 "../include/rrdcollect.h"
struct counter_t {
   char const   *name ;
   char *value ;
};
#line 142 "../include/rrdcollect.h"
struct uri_t {
   char const   *domain ;
   char const   *host ;
   char const   *path ;
};
#line 155
enum match_type_t {
    MATCH_PATTERN = 0,
    MATCH_PATSUBST = 1
} ;
#line 163 "../include/rrdcollect.h"
union __anonunion____missing_field_name_31 {
   char const   *pattern ;
};
#line 163 "../include/rrdcollect.h"
struct match_t {
   int line ;
   int done ;
   int count ;
   struct counter_t **counter ;
   enum match_type_t type ;
   union __anonunion____missing_field_name_31 __annonCompField1 ;
};
#line 189 "../include/rrdcollect.h"
struct test_t {
   struct uri_t *uri ;
   int count ;
   struct match_t **match ;
};
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_7 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_7 __sigset_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 91 "/usr/include/x86_64-linux-gnu/sys/time.h"
enum __itimer_which {
    ITIMER_REAL = 0,
    ITIMER_VIRTUAL = 1,
    ITIMER_PROF = 2
} ;
#line 107 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
#line 118 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef enum __itimer_which __itimer_which_t;
#line 94 "./getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_34 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_35 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_36 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_37 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_38 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_39 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_40 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_33 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_34 _kill ;
   struct __anonstruct__timer_35 _timer ;
   struct __anonstruct__rt_36 _rt ;
   struct __anonstruct__sigchld_37 _sigchld ;
   struct __anonstruct__sigfault_38 _sigfault ;
   struct __anonstruct__sigpoll_39 _sigpoll ;
   struct __anonstruct__sigsys_40 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_32 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_33 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_32 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_52 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_52 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 37 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/rrdcollect.c"
enum working_mode {
    PIPE_MODE = 0,
    FILE_MODE = 1
} ;
#line 138 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/rrdcollect.c"
struct __anonstruct_lls_57 {
   char *f ;
   int v ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 135 "../include/rrdcollect.h"
struct rrd_t {
   char const   *rrdfile ;
   int count ;
   char *rrdtemplate ;
   struct counter_t **counter ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 170
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 175 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 200
extern void ( /* format attribute */  vsyslog)(int __pri , char const   *__fmt , __gnuc_va_list __ap ) ;
#line 212 "../include/rrdcollect.h"
void start_log(void) ;
#line 213
void stop_log(void) ;
#line 214
void send_log(int prio , char *fmt  , ...) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/log.c"
int debugoutput ;
#line 27
int debuglevel ;
#line 29 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/log.c"
int logger_subsystem_initialized  =    1;
#line 31 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/log.c"
void start_log(void) 
{ 


  {
  {
#line 33
  if (debugoutput == 1) {
#line 33
    goto case_1;
  }
#line 36
  if (debugoutput == 0) {
#line 36
    goto case_0;
  }
#line 38
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 34
  openlog("rrdcollect", 3, 3 << 3);
  }
#line 35
  goto switch_break;
  case_0: /* CIL Label */ 
#line 37
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 39
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"start_log: Fatal error in /home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/log.c:%i. Please send a bugreport.\n",
          39);
#line 40
  exit(1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 42
  logger_subsystem_initialized = 1;
#line 43
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/log.c"
void stop_log(void) 
{ 


  {
  {
#line 47
  if (debugoutput == 1) {
#line 47
    goto case_1;
  }
#line 50
  if (debugoutput == 0) {
#line 50
    goto case_0;
  }
#line 52
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 48
  closelog();
  }
#line 49
  goto switch_break;
  case_0: /* CIL Label */ 
#line 51
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 53
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"stop_log: Fatal error in /home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/log.c:%i. Please send a bugreport.\n",
          53);
#line 54
  exit(1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 56
  logger_subsystem_initialized = 0;
#line 57
  return;
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/log.c"
void send_log(int prio , char *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 61
  __builtin_va_start(ap, fmt);
  }
#line 62
  if (! logger_subsystem_initialized) {
    {
#line 63
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
             ap);
#line 64
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"send_log: Fatal error. Logger subsystem uninitialized. Please send a bugreport.\n");
#line 65
    exit(1);
    }
  }
  {
#line 68
  if (debugoutput == 1) {
#line 68
    goto case_1;
  }
#line 72
  if (debugoutput == 0) {
#line 72
    goto case_0;
  }
#line 76
  goto switch_default;
  case_1: /* CIL Label */ 
#line 69
  if (prio <= debuglevel) {
    {
#line 70
    vsyslog(prio, (char const   *)fmt, ap);
    }
  }
#line 71
  goto switch_break;
  case_0: /* CIL Label */ 
#line 73
  if (prio <= debuglevel) {
    {
#line 74
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
             ap);
    }
  }
#line 75
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 77
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Fatal error in /home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/log.c:%i. Please end a bugreport.\n",
          77);
#line 78
  exit(1);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 80
  __builtin_va_end(ap);
  }
#line 81
  return;
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 201 "../include/rrdcollect.h"
int scan_count(char const   *fmt ) ;
#line 205
struct counter_t *add_rrd_counter(char const   *rrdfile , char const   *name ) ;
#line 206
struct test_t *add_test_uri(struct uri_t  const  *uri ) ;
#line 222 "../include/rrdcollect.h"
char buf[8192]  ;
#line 224
int parse_conf(char const   *conf_file ) ;
#line 228
int set_config_variable(char const   *name , char const   *value ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/parse.c"
static int cut_comments(char *line ) 
{ 
  int closing ;
  char *space ;

  {
#line 31
  space = (char *)((void *)0);
  {
#line 33
  while (1) {
    while_continue: /* CIL Label */ ;
#line 33
    if (! *line) {
#line 33
      goto while_break;
    }
    {
#line 37
    if ((int )*line == 92) {
#line 37
      goto case_92;
    }
#line 44
    if ((int )*line == 34) {
#line 44
      goto case_34;
    }
#line 44
    if ((int )*line == 47) {
#line 44
      goto case_34;
    }
#line 59
    if ((int )*line == 11) {
#line 59
      goto case_11;
    }
#line 59
    if ((int )*line == 9) {
#line 59
      goto case_11;
    }
#line 59
    if ((int )*line == 12) {
#line 59
      goto case_11;
    }
#line 59
    if ((int )*line == 32) {
#line 59
      goto case_11;
    }
#line 67
    if ((int )*line == 13) {
#line 67
      goto case_13;
    }
#line 67
    if ((int )*line == 10) {
#line 67
      goto case_13;
    }
#line 67
    if ((int )*line == 0) {
#line 67
      goto case_13;
    }
#line 67
    if ((int )*line == 35) {
#line 67
      goto case_13;
    }
#line 74
    goto switch_default;
    case_92: /* CIL Label */ 
#line 38
    line ++;
#line 38
    if (! *line) {
#line 39
      return (0);
    }
#line 40
    goto switch_break;
    case_34: /* CIL Label */ 
    case_47: /* CIL Label */ 
#line 45
    closing = (int )*line;
    {
#line 46
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 46
      if (*line) {
#line 46
        if (! ((int )*line != closing)) {
#line 46
          goto while_break___0;
        }
      } else {
#line 46
        goto while_break___0;
      }
#line 46
      line ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 47
    if (! *line) {
      {
#line 48
      send_log(3, (char *)"Error, umatched `%c\'\n", closing);
#line 49
      exit(1);
      }
#line 50
      return (1);
    }
#line 53
    goto switch_break;
    case_11: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 60
    if (! space) {
#line 61
      space = line;
    }
#line 62
    goto switch_break;
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_0: /* CIL Label */ 
    case_35: /* CIL Label */ 
#line 68
    if (space) {
#line 69
      *space = (char )'\000';
    }
#line 70
    *line = (char )'\000';
#line 71
    return (0);
    switch_default: /* CIL Label */ 
#line 75
    space = (char *)((void *)0);
#line 76
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 33
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  return (0);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/parse.c"
static char *skip_config_name(char *line ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 91
    tmp = __ctype_b_loc();
    }
#line 91
    if (! ((int const   )*(*tmp + (int )*line) & 8)) {
#line 91
      if (! ((int )*line == 95)) {
#line 91
        goto while_break;
      }
    }
#line 92
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  if (! *line) {
#line 94
    return ((char *)((void *)0));
  }
#line 95
  return (line);
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/parse.c"
static char const   *skip_equal_sign(char const   *line ) 
{ 
  unsigned short const   **tmp ;
  char const   *tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 101
    tmp = __ctype_b_loc();
    }
#line 101
    if (! ((int const   )*(*tmp + (int )*line) & 8192)) {
#line 101
      goto while_break;
    }
#line 102
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  tmp___0 = line;
#line 105
  line ++;
#line 105
  if ((int const   )*tmp___0 != 61) {
#line 106
    return ((char const   *)((void *)0));
  }
  {
#line 109
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 109
    tmp___1 = __ctype_b_loc();
    }
#line 109
    if (! ((int const   )*(*tmp___1 + (int )*line) & 8192)) {
#line 109
      goto while_break___0;
    }
#line 110
    line ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 112
  if (! *line) {
#line 113
    return ((char const   *)((void *)0));
  }
#line 114
  return (line);
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/parse.c"
static int get_config_var(char *name ) 
{ 
  char const   *value ;
  char *div___0 ;

  {
  {
#line 122
  div___0 = skip_config_name(name);
  }
#line 122
  if (! div___0) {
#line 123
    return (1);
  }
  {
#line 125
  value = skip_equal_sign((char const   *)div___0);
  }
#line 125
  if (! value) {
#line 126
    return (2);
  }
  {
#line 129
  *div___0 = (char )'\000';
#line 132
  set_config_variable((char const   *)name, value);
  }
#line 134
  return (0);
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/parse.c"
static char *find_domain_end(char *line ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 146
    tmp = __ctype_b_loc();
    }
#line 146
    if (! ((int const   )*(*tmp + (int )*line) & 1024)) {
#line 146
      goto while_break;
    }
#line 147
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  if ((int )*(line + 0) == 58) {
#line 149
    if ((int )*(line + 1) == 47) {
#line 149
      if ((int )*(line + 2) == 47) {
#line 150
        return (line);
      }
    }
  }
#line 152
  return ((char *)((void *)0));
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/parse.c"
static char *find_host_end(char *line ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (! ((int )*line != 47)) {
#line 157
      goto while_break;
    }
    {
#line 158
    tmp = __ctype_b_loc();
    }
#line 158
    if (! ((int const   )*(*tmp + (int )*line) & 32768)) {
#line 159
      return ((char *)((void *)0));
    }
#line 157
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  return (line);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/parse.c"
static int get_uri(char *domain , struct uri_t *uri ) 
{ 
  char *dend ;
  char *host ;
  char *path ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 168
  dend = find_domain_end(domain);
  }
#line 168
  if (! dend) {
#line 169
    return (1);
  }
  {
#line 171
  host = dend + 2;
#line 173
  path = find_host_end(host);
  }
#line 173
  if (! path) {
#line 174
    return (2);
  }
  {
#line 177
  tmp = strncmp((char const   *)domain, "file", (size_t )(dend - domain));
  }
#line 177
  if (tmp) {
#line 182
    return (3);
  }
  {
#line 186
  tmp___0 = path;
#line 186
  path ++;
#line 186
  *tmp___0 = (char )'\000';
#line 187
  *dend = (char )'\000';
#line 200
  tmp___1 = strdup((char const   *)domain);
#line 200
  uri->domain = (char const   *)tmp___1;
#line 201
  tmp___2 = strdup((char const   *)host);
#line 201
  uri->host = (char const   *)tmp___2;
#line 202
  tmp___3 = strdup((char const   *)path);
#line 202
  uri->path = (char const   *)tmp___3;
  }
#line 204
  return (0);
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/parse.c"
static char *find_end_of_pattern(char *line , int c ) 
{ 


  {
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! *line) {
#line 214
      goto while_break;
    }
#line 215
    if ((int )*line == 92) {
#line 216
      line ++;
#line 216
      if (! *line) {
#line 217
        return ((char *)((void *)0));
      }
    }
#line 220
    if ((int )*line == c) {
#line 221
      return (line);
    }
#line 214
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  return ((char *)((void *)0));
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/parse.c"
static int get_pattern(char *pat , struct test_t *test___0 ) 
{ 
  struct match_t match ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  int type ;
  char *eol ;
  char *tmp___3 ;
  char *store ;
  char *rrdfile ;
  int i ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;
  void *tmp___6 ;
  char *start ;
  unsigned short const   **tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;

  {
  {
#line 247
  match.line = 0;
#line 250
  tmp___2 = __ctype_b_loc();
  }
#line 250
  if ((int const   )*(*tmp___2 + (int )*pat) & 2048) {
    {
#line 251
    match.line = atoi((char const   *)pat);
    }
    {
#line 252
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 252
      tmp = __ctype_b_loc();
#line 252
      pat ++;
      }
#line 252
      if (! ((int const   )*(*tmp + (int )*pat) & 2048)) {
#line 252
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 254
    tmp___0 = pat;
#line 254
    pat ++;
#line 254
    if ((int )*tmp___0 != 58) {
#line 255
      return (1);
    }
    {
#line 258
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 258
      tmp___1 = __ctype_b_loc();
      }
#line 258
      if (! ((int const   )*(*tmp___1 + (int )*pat) & 8192)) {
#line 258
        goto while_break___0;
      }
#line 259
      pat ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 262
  if ((int )*pat == 34) {
#line 262
    goto _L;
  } else
#line 262
  if ((int )*pat == 47) {
    _L: /* CIL Label */ 
    {
#line 263
    type = (int )*pat;
#line 264
    pat ++;
#line 264
    tmp___3 = find_end_of_pattern(pat, type);
#line 264
    eol = tmp___3;
#line 266
    rrdfile = (char *)((void *)0);
    }
#line 269
    if (! eol) {
#line 270
      return (2);
    }
#line 272
    store = eol + 1;
    {
#line 272
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 272
      tmp___4 = __ctype_b_loc();
      }
#line 272
      if (! ((int const   )*(*tmp___4 + (int )*store) & 8192)) {
#line 272
        goto while_break___1;
      }
#line 272
      store ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 275
    *eol = (char )'\000';
#line 285
    if (type == 34) {
      {
#line 286
      match.type = (enum match_type_t )0;
#line 287
      tmp___5 = strdup((char const   *)pat);
#line 287
      match.__annonCompField1.pattern = (char const   *)tmp___5;
#line 288
      match.count = scan_count((char const   *)pat);
      }
    } else {
      {
#line 316
      send_log(3, (char *)"This version is not compiled with libpcre support.\n");
#line 317
      send_log(3, (char *)"Please make sure libpcre is installed and recompile.\n");
#line 318
      exit(1);
      }
    }
    {
#line 321
    tmp___6 = malloc((unsigned long )match.count * sizeof(struct counter_t *));
#line 321
    match.counter = (struct counter_t **)tmp___6;
#line 323
    i = 0;
    }
    {
#line 323
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 323
      if (! (i < match.count)) {
#line 323
        goto while_break___2;
      }
#line 324
      start = store;
      {
#line 326
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 326
        if ((int )*store != 58) {
#line 326
          if ((int )*store != 44) {
            {
#line 326
            tmp___7 = __ctype_b_loc();
            }
#line 326
            if (! ((int const   )*(*tmp___7 + (int )*store) & 32768)) {
#line 326
              goto while_break___3;
            }
          } else {
#line 326
            goto while_break___3;
          }
        } else {
#line 326
          goto while_break___3;
        }
#line 327
        store ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 328
      if ((int )*store == 58) {
#line 329
        tmp___8 = store;
#line 329
        store ++;
#line 329
        *tmp___8 = (char )'\000';
#line 330
        rrdfile = start;
#line 331
        goto __Cont;
      }
#line 334
      if (! rrdfile) {
        {
#line 335
        send_log(3, (char *)"RRD file name must be given first; in pattern \"%s\".\n",
                 pat);
#line 336
        exit(1);
        }
      }
#line 339
      if (*store) {
#line 340
        tmp___9 = store;
#line 340
        store ++;
#line 340
        *tmp___9 = (char )'\000';
      }
      {
#line 342
      tmp___10 = i;
#line 342
      i ++;
#line 342
      *(match.counter + tmp___10) = add_rrd_counter((char const   *)rrdfile, (char const   *)start);
      }
#line 344
      if (! *store) {
#line 344
        if (i < match.count) {
          {
#line 345
          send_log(3, (char *)"Not enough targets in pattern \"%s\"!!!\n", pat);
#line 346
          exit(1);
          }
        }
      }
      __Cont: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 349
    if (*store) {
      {
#line 350
      send_log(3, (char *)"Too many targets in pattern \"%s\"!!!\n", pat);
#line 351
      exit(1);
      }
    }
    {
#line 354
    tmp___11 = test___0->count;
#line 354
    (test___0->count) ++;
#line 354
    i = tmp___11;
#line 355
    tmp___12 = realloc((void *)test___0->match, (unsigned long )test___0->count * sizeof(struct match_t *));
#line 355
    test___0->match = (struct match_t **)tmp___12;
#line 356
    tmp___13 = malloc(sizeof(struct match_t ));
#line 356
    *(test___0->match + i) = (struct match_t *)tmp___13;
#line 357
    memcpy((void */* __restrict  */)*(test___0->match + i), (void const   */* __restrict  */)(& match),
           sizeof(struct match_t ));
    }
#line 359
    return (0);
  }
#line 361
  return (3);
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/parse.c"
int parse_conf(char const   *conf_file ) 
{ 
  FILE *conf ;
  FILE *tmp ;
  struct uri_t uri ;
  struct test_t *test___0 ;
  char *bp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 372
  tmp = fopen((char const   */* __restrict  */)conf_file, (char const   */* __restrict  */)"r");
#line 372
  conf = tmp;
#line 375
  test___0 = (struct test_t *)((void *)0);
  }
#line 377
  if (! conf) {
#line 378
    return (1);
  }
  {
#line 380
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 380
    tmp___4 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)conf);
    }
#line 380
    if (! tmp___4) {
#line 380
      goto while_break;
    }
#line 381
    bp = buf;
    {
#line 383
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 383
      tmp___0 = __ctype_b_loc();
      }
#line 383
      if (! ((int const   )*(*tmp___0 + (int )*bp) & 8192)) {
#line 383
        goto while_break___0;
      }
#line 384
      bp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 385
    cut_comments(buf);
    }
#line 387
    if ((int )*bp == 0) {
#line 388
      goto while_continue;
    }
    {
#line 390
    tmp___1 = get_config_var(bp);
    }
#line 390
    if (! tmp___1) {
#line 391
      goto while_continue;
    }
    {
#line 393
    tmp___2 = get_uri(bp, & uri);
    }
#line 393
    if (! tmp___2) {
      {
#line 394
      test___0 = add_test_uri((struct uri_t  const  *)(& uri));
      }
#line 395
      goto while_continue;
    }
    {
#line 399
    tmp___3 = get_pattern(bp, test___0);
    }
#line 399
    if (! tmp___3) {
#line 400
      goto while_continue;
    }
    {
#line 404
    send_log(3, (char *)"Unrecognized config line:\n%s\n", buf);
#line 405
    fclose(conf);
#line 406
    exit(1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 409
  fclose(conf);
  }
#line 410
  return (0);
}
}
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 347
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) setlinebuf)(FILE *__stream ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 873
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 515 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 584
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) setenv)(char const   *__name ,
                                                                                             char const   *__value ,
                                                                                             int __replace ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 469
extern int pause(void) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 47 "./getopt.h"
extern char *optarg ;
#line 61
extern int optind ;
#line 131 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setitimer)(__itimer_which_t __which ,
                                                                                struct itimerval  const  * __restrict  __new ,
                                                                                struct itimerval * __restrict  __old ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 151 "./getopt.h"
extern int getopt_long(int ___argc , char * const  *___argv , char const   *__shortopts ,
                       struct option  const  *__longopts , int *__longind ) ;
#line 207 "../include/rrdcollect.h"
void clear_counters(void) ;
#line 208
void perform_tests(void) ;
#line 209
void print_results(void) ;
#line 217
int is_another_copy(void) ;
#line 218
void write_pidfile(void) ;
#line 219
void release_pidfile(void) ;
#line 227 "../include/rrdcollect.h"
int (*make_update)(int argc , char **argv )  ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 259 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/rrdcollect.c"
char const   *config_file  =    "/usr/local/etc/rrdcollect.conf";
#line 37 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/rrdcollect.c"
enum working_mode mode  ;
#line 44 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/rrdcollect.c"
char const   *output_pipe  =    "rrdtool - >/dev/null";
#line 45 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/rrdcollect.c"
char const   *output_file  =    (char const   *)((void *)0);
#line 46 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/rrdcollect.c"
FILE *rrdtool  =    (FILE *)((void *)0);
#line 48 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/rrdcollect.c"
int verbose  =    0;
#line 49 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/rrdcollect.c"
int no_fork  =    0;
#line 52 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/rrdcollect.c"
char const   *workdir  =    (char const   *)((void *)0);
#line 53 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/rrdcollect.c"
int step  =    60;
#line 54 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/rrdcollect.c"
int debugoutput  =    1;
#line 55 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/rrdcollect.c"
int debuglevel  =    5;
#line 58 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/rrdcollect.c"
int volatile   action_request  =    (int volatile   )0;
#line 60 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/rrdcollect.c"
void do_nothing(int signum  __attribute__((__unused__)) ) 
{ 


  {
#line 60
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/rrdcollect.c"
void do_action(int signum ) 
{ 


  {
#line 61
  action_request = (int volatile   )signum;
#line 61
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/rrdcollect.c"
void do_abort(int signum  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 63
  send_log(3, (char *)"Segmentation fault (core dumped), but The Memory Remains.\n\n");
#line 64
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nSegmentation fault (core dumped), but The Memory Remains.\n\n");
#line 65
  fflush(stderr);
#line 66
  abort();
  }
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/rrdcollect.c"
int print_update(int argc , char **argv ) 
{ 
  int i ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 73
  i = 0;
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (i < argc) {
#line 73
      if (! *(argv + i)) {
#line 73
        goto while_break;
      }
    } else {
#line 73
      goto while_break;
    }
#line 74
    if (i) {
#line 74
      tmp = " %s";
    } else {
#line 74
      tmp = "%s";
    }
    {
#line 74
    fprintf((FILE */* __restrict  */)rrdtool, (char const   */* __restrict  */)tmp,
            *(argv + i));
    }
#line 75
    if (verbose) {
#line 76
      if (i) {
#line 76
        tmp___0 = " %s";
      } else {
#line 76
        tmp___0 = "%s";
      }
      {
#line 76
      send_log(7, (char *)tmp___0, *(argv + i));
      }
    }
#line 73
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 78
  _IO_putc('\n', rrdtool);
  }
#line 80
  return (0);
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/rrdcollect.c"
int set_config_variable(char const   *name , char const   *value ) 
{ 
  struct __anonstruct_lls_57 lls[9] ;
  char *tmp ;
  int tmp___0 ;
  int i ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 138
  lls[0].f = (char *)"LOG_EMERG";
#line 138
  lls[0].v = 0;
#line 138
  lls[1].f = (char *)"LOG_ALERT";
#line 138
  lls[1].v = 1;
#line 138
  lls[2].f = (char *)"LOG_CRIT";
#line 138
  lls[2].v = 2;
#line 138
  lls[3].f = (char *)"LOG_ERR";
#line 138
  lls[3].v = 3;
#line 138
  lls[4].f = (char *)"LOG_WARNING";
#line 138
  lls[4].v = 4;
#line 138
  lls[5].f = (char *)"LOG_NOTICE";
#line 138
  lls[5].v = 5;
#line 138
  lls[6].f = (char *)"LOG_INFO";
#line 138
  lls[6].v = 6;
#line 138
  lls[7].f = (char *)"LOG_DEBUG";
#line 138
  lls[7].v = 7;
#line 138
  lls[8].f = (char *)((void *)0);
#line 138
  lls[8].v = -1;
  {
#line 151
  if ((int const   )*name == 100) {
#line 151
    goto case_100;
  }
#line 157
  if ((int const   )*name == 108) {
#line 157
    goto case_108;
  }
#line 171
  if ((int const   )*name == 115) {
#line 171
    goto case_115;
  }
#line 181
  goto switch_default;
  case_100: /* CIL Label */ 
  {
#line 152
  tmp___0 = strcmp(name, "directory");
  }
#line 152
  if (! tmp___0) {
    {
#line 153
    tmp = strdup(value);
#line 153
    workdir = (char const   *)tmp;
    }
#line 154
    return (0);
  }
#line 156
  goto switch_break;
  case_108: /* CIL Label */ 
  {
#line 158
  tmp___2 = strcmp(name, "loglevel");
  }
#line 158
  if (! tmp___2) {
#line 159
    i = 0;
#line 160
    debuglevel = 4;
    {
#line 161
    while (1) {
      while_continue: /* CIL Label */ ;
#line 161
      if (! (lls[i].v != -1)) {
#line 161
        goto while_break;
      }
      {
#line 162
      tmp___1 = strcmp(value, (char const   *)lls[i].f);
      }
#line 162
      if (! tmp___1) {
#line 163
        debuglevel = lls[i].v;
#line 164
        goto while_break;
      }
#line 166
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 168
    send_log(5, (char *)"Log level: %s\n", lls[i].f);
    }
#line 169
    return (0);
  }
  case_115: /* CIL Label */ 
  {
#line 172
  tmp___3 = strcmp(name, "step");
  }
#line 172
  if (! tmp___3) {
    {
#line 173
    step = atoi(value);
    }
#line 174
    if (! step) {
      {
#line 175
      send_log(3, (char *)"Invalid step value: %s (%d)\n", value, step);
#line 176
      exit(1);
      }
    }
#line 178
    return (0);
  }
#line 180
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 182
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 184
  return (2);
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/rrdcollect.c"
void usage(int mode___0 ) 
{ 


  {
#line 191
  if (mode___0 == -2) {
    {
#line 192
    printf((char const   */* __restrict  */)"Usage: rrdcollect [-v] [--config=PATH] [--help] [--usage]\n");
#line 193
    exit(0);
    }
  }
#line 196
  if (mode___0 == -1) {
    {
#line 197
    printf((char const   */* __restrict  */)"RRDcollect 0.2.10\n");
#line 218
    printf((char const   */* __restrict  */)"Copyright (C) 2002  Dawid Kuroczko <qnex@knm.org.pl>\n\n");
#line 220
    printf((char const   */* __restrict  */)"This program is distributed in the hope that it will be useful,\n");
#line 221
    printf((char const   */* __restrict  */)"but WITHOUT ANY WARRANTY; without even the implied warranty of\n");
#line 222
    printf((char const   */* __restrict  */)"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n");
#line 223
    printf((char const   */* __restrict  */)"GNU General Public License for more details.\n\n");
#line 224
    exit(0);
    }
  }
  {
#line 227
  printf((char const   */* __restrict  */)"RRDcollect 0.2.10  --  Round-Robin Database Collecting Daemon.\n");
#line 228
  printf((char const   */* __restrict  */)"Usage: rrdcollect [OPTION]...\n");
  }
#line 231
  if (mode___0 > 0) {
    {
#line 232
    printf((char const   */* __restrict  */)"\nTry `rrdcollect --help\' for more options.\n");
#line 233
    exit(1);
    }
  }
  {
#line 235
  printf((char const   */* __restrict  */)"\nGeneral options:\n");
#line 236
  printf((char const   */* __restrict  */)"  -c,  --config=FILE       specify alternative config file.\n");
#line 237
  printf((char const   */* __restrict  */)"  -n,  --no-fork           do not even think about forking.\n");
#line 238
  printf((char const   */* __restrict  */)"  -v,  --verbose           increase verbosity, implies -n.\n");
#line 240
  printf((char const   */* __restrict  */)"\nRRD update options:\n");
#line 241
  printf((char const   */* __restrict  */)"  -o,  --output=FILE       writes update commands to FILE.\n");
#line 242
  printf((char const   */* __restrict  */)"  -p,  --pipe[=RRDTOOL]    opens pipe to RRDTOOL and sends it commands.\n");
#line 243
  printf((char const   */* __restrict  */)"\nIf no RRD update option is given, RRDcollect opens pipe to rrdtool - >/dev/null program.\n");
#line 251
  printf((char const   */* __restrict  */)"\nHelp options:\n");
#line 252
  printf((char const   */* __restrict  */)"  -V,  --version           display the version of RRDcollect and exit.\n");
#line 253
  printf((char const   */* __restrict  */)"  -h,  --help              print this help.\n");
#line 254
  printf((char const   */* __restrict  */)"       --usage             terse usage information.\n");
#line 256
  printf((char const   */* __restrict  */)"\nMail bug reports and suggestions to <rrdcollect-bugs@snafu.pl>\n");
#line 257
  exit(0);
  }
#line 257
  return;
}
}
#line 284
int main(int argc , char **argv ) ;
#line 284 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/rrdcollect.c"
static struct option long_options[9]  = 
#line 284
  {      {"verbose", 0, (int *)0, 'v'}, 
        {"no-fork", 0, (int *)0, 'n'}, 
        {"config", 1, (int *)0, 'c'}, 
        {"output", 1, (int *)0, 'o'}, 
        {"pipe", 2, (int *)0, 'p'}, 
        {"version", 0, (int *)0, 'V'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"usage", 0, (int *)0, 'U'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 260 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/rrdcollect.c"
int main(int argc , char **argv ) 
{ 
  int c ;
  struct sigaction action ;
  struct itimerval period ;
  int loop ;
  int option_index ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  __pid_t tmp___10 ;

  {
  {
#line 269
  setenv("IFS", " \t\n", 1);
#line 276
  mode = (enum working_mode )0;
#line 279
  start_log();
  }
  {
#line 281
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 282
    option_index = 0;
#line 298
    c = getopt_long(argc, (char * const  *)argv, "vnc:o:pVh", (struct option  const  *)(long_options),
                    & option_index);
    }
#line 300
    if (c == -1) {
#line 301
      goto while_break;
    }
    {
#line 304
    if (c == 99) {
#line 304
      goto case_99;
    }
#line 307
    if (c == 118) {
#line 307
      goto case_118;
    }
#line 309
    if (c == 110) {
#line 309
      goto case_110;
    }
#line 313
    if (c == 111) {
#line 313
      goto case_111;
    }
#line 317
    if (c == 112) {
#line 317
      goto case_112;
    }
#line 324
    if (c == 104) {
#line 324
      goto case_104;
    }
#line 327
    if (c == 86) {
#line 327
      goto case_86;
    }
#line 330
    if (c == 85) {
#line 330
      goto case_85;
    }
#line 303
    goto switch_break;
    case_99: /* CIL Label */ 
#line 305
    config_file = (char const   *)optarg;
#line 306
    goto switch_break;
    case_118: /* CIL Label */ 
#line 308
    verbose ++;
    case_110: /* CIL Label */ 
#line 310
    no_fork = 1;
#line 311
    goto switch_break;
    case_111: /* CIL Label */ 
#line 314
    mode = (enum working_mode )1;
#line 315
    output_file = (char const   *)optarg;
#line 316
    goto switch_break;
    case_112: /* CIL Label */ 
#line 318
    mode = (enum working_mode )0;
#line 319
    if (optarg) {
#line 320
      output_pipe = (char const   *)optarg;
    }
#line 322
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 325
    usage(0);
    }
#line 326
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 328
    usage(-1);
    }
#line 329
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 331
    usage(-2);
    }
#line 332
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 336
  if (optind < argc) {
    {
#line 337
    usage(1);
    }
#line 338
    return (1);
  }
  {
#line 341
  tmp___1 = parse_conf(config_file);
  }
#line 341
  if (tmp___1) {
    {
#line 342
    tmp = __errno_location();
#line 342
    tmp___0 = strerror(*tmp);
#line 342
    send_log(3, (char *)"Cannot parse config file %s: %s\n", config_file, tmp___0);
    }
#line 343
    return (2);
  }
#line 346
  if (! workdir) {
    {
#line 347
    send_log(3, (char *)"You have to give working directory in config file\n");
#line 348
    send_log(3, (char *)"If you\'re desperate, you can use something like this:\n");
#line 349
    send_log(3, (char *)"    # current directory:\n");
#line 350
    send_log(3, (char *)"    directory = .\n");
    }
#line 351
    return (2);
  }
  {
#line 354
  send_log(5, (char *)"%s started", *(argv + 0));
#line 356
  tmp___2 = is_another_copy();
  }
#line 356
  if (tmp___2) {
    {
#line 357
    send_log(3, (char *)"Another copy of program is running, exiting\n");
#line 358
    exit(1);
    }
  }
  {
#line 369
  make_update = & print_update;
#line 370
  send_log(6, (char *)"Update method: print");
  }
#line 371
  if ((unsigned int )mode == 1U) {
#line 372
    if ((int const   )*(output_file + 0) == 45) {
#line 372
      if ((int const   )*(output_file + 1) == 0) {
        {
#line 373
        no_fork = 1;
#line 374
        rrdtool = stdout;
#line 375
        send_log(6, (char *)"Output: stdout");
        }
      } else {
        {
#line 377
        rrdtool = fopen((char const   */* __restrict  */)output_file, (char const   */* __restrict  */)"a");
#line 378
        send_log(6, (char *)"Output: file");
        }
      }
    } else {
      {
#line 377
      rrdtool = fopen((char const   */* __restrict  */)output_file, (char const   */* __restrict  */)"a");
#line 378
      send_log(6, (char *)"Output: file");
      }
    }
#line 380
    if (! rrdtool) {
      {
#line 381
      tmp___3 = __errno_location();
#line 381
      tmp___4 = strerror(*tmp___3);
#line 381
      send_log(3, (char *)"Failed opening %s: %s\n", output_file, tmp___4);
      }
#line 382
      return (3);
    }
  } else
#line 384
  if ((unsigned int )mode == 0U) {
    {
#line 385
    chdir(workdir);
#line 386
    rrdtool = popen(output_pipe, "w");
#line 387
    send_log(6, (char *)"Update method: pipe");
    }
#line 388
    if (! rrdtool) {
      {
#line 389
      tmp___5 = __errno_location();
#line 389
      tmp___6 = strerror(*tmp___5);
#line 389
      send_log(3, (char *)"Failed opening pipe %s: %s\n", output_pipe, tmp___6);
      }
#line 390
      return (3);
    }
#line 392
    make_update = & print_update;
  }
  {
#line 396
  setlinebuf(rrdtool);
#line 399
  tmp___9 = chdir(workdir);
  }
#line 399
  if (tmp___9) {
    {
#line 400
    tmp___7 = __errno_location();
#line 400
    tmp___8 = strerror(*tmp___7);
#line 400
    send_log(3, (char *)"Cannot chdir to %s: %s\n", workdir, tmp___8);
    }
#line 401
    return (2);
  }
#line 405
  if (! no_fork) {
    {
#line 405
    tmp___10 = fork();
    }
#line 405
    if (tmp___10) {
#line 406
      return (0);
    }
  }
#line 408
  if (! no_fork) {
    {
#line 414
    close(0);
#line 415
    close(1);
    }
#line 416
    if (debugoutput != 0) {
      {
#line 417
      close(2);
      }
    }
    {
#line 419
    open("/dev/null", 2);
#line 420
    dup2(0, 1);
    }
#line 421
    if (debugoutput != 0) {
      {
#line 422
      dup2(0, 2);
      }
    }
  }
  {
#line 429
  write_pidfile();
#line 432
  action.__sigaction_handler.sa_handler = & do_nothing;
#line 433
  action.sa_flags = 0;
#line 434
  sigaction(14, (struct sigaction  const  */* __restrict  */)(& action), (struct sigaction */* __restrict  */)((void *)0));
#line 437
  action.__sigaction_handler.sa_handler = & do_action;
#line 438
  action.sa_flags = 0;
#line 439
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& action), (struct sigaction */* __restrict  */)((void *)0));
#line 440
  sigaction(3, (struct sigaction  const  */* __restrict  */)(& action), (struct sigaction */* __restrict  */)((void *)0));
#line 441
  sigaction(15, (struct sigaction  const  */* __restrict  */)(& action), (struct sigaction */* __restrict  */)((void *)0));
#line 442
  sigaction(1, (struct sigaction  const  */* __restrict  */)(& action), (struct sigaction */* __restrict  */)((void *)0));
#line 443
  sigaction(10, (struct sigaction  const  */* __restrict  */)(& action), (struct sigaction */* __restrict  */)((void *)0));
#line 444
  sigaction(12, (struct sigaction  const  */* __restrict  */)(& action), (struct sigaction */* __restrict  */)((void *)0));
#line 447
  action.__sigaction_handler.sa_handler = & do_abort;
#line 448
  action.sa_flags = 0;
#line 449
  sigaction(11, (struct sigaction  const  */* __restrict  */)(& action), (struct sigaction */* __restrict  */)((void *)0));
#line 450
  sigaction(8, (struct sigaction  const  */* __restrict  */)(& action), (struct sigaction */* __restrict  */)((void *)0));
#line 451
  sigaction(7, (struct sigaction  const  */* __restrict  */)(& action), (struct sigaction */* __restrict  */)((void *)0));
#line 453
  period.it_value.tv_sec = (__time_t )step;
#line 453
  period.it_interval.tv_sec = period.it_value.tv_sec;
#line 454
  period.it_value.tv_usec = (__suseconds_t )0;
#line 454
  period.it_interval.tv_usec = period.it_value.tv_usec;
#line 455
  setitimer((__itimer_which_t )0, (struct itimerval  const  */* __restrict  */)(& period),
            (struct itimerval */* __restrict  */)((void *)0));
#line 457
  loop = 1;
  }
  {
#line 458
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 458
    if (! loop) {
#line 458
      goto while_break___0;
    }
#line 459
    if (action_request) {
      {
#line 463
      if (action_request == (int volatile   )15) {
#line 463
        goto case_15;
      }
#line 463
      if (action_request == (int volatile   )3) {
#line 463
        goto case_15;
      }
#line 463
      if (action_request == (int volatile   )2) {
#line 463
        goto case_15;
      }
#line 471
      goto switch_default;
      case_15: /* CIL Label */ 
      case_3: /* CIL Label */ 
      case_2: /* CIL Label */ 
      {
#line 464
      send_log(5, (char *)"Signal received. Preparing to exit...");
#line 465
      loop = 0;
      }
#line 466
      goto switch_break___0;
      switch_default: /* CIL Label */ 
      {
#line 472
      fflush(stdout);
      }
#line 473
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 476
      action_request = (int volatile   )0;
    } else {
      {
#line 479
      perform_tests();
#line 480
      print_results();
#line 481
      clear_counters();
      }
    }
#line 484
    if (loop) {
      {
#line 484
      pause();
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 487
  release_pidfile();
#line 488
  send_log(5, (char *)"Exitting.");
  }
#line 489
  return (0);
}
}
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 184 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strndup)(char const   *__string ,
                                                                                                size_t __n )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 200 "../include/rrdcollect.h"
int scan(char const   *buf___0 , char const   *fmt , struct counter_t **counter ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/scan.c"
static char *valuedup(long const   value ) 
{ 
  char dec[21] ;
  char *tmp ;

  {
  {
#line 45
  snprintf((char */* __restrict  */)(dec), sizeof(dec), (char const   */* __restrict  */)"%ld",
           value);
#line 46
  tmp = strdup((char const   *)(dec));
  }
#line 46
  return (tmp);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/scan.c"
int scan(char const   *buf___0 , char const   *fmt , struct counter_t **counter ) 
{ 
  int i ;
  int ignore ;
  int length ;
  long value ;
  char const   *start ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  unsigned short const   **tmp___10 ;
  int tmp___11 ;
  unsigned short const   **tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  unsigned short const   **tmp___15 ;
  unsigned short const   **tmp___16 ;

  {
#line 53
  i = 0;
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if (! ((int const   )*fmt != 0)) {
#line 54
      goto while_break;
    }
    {
#line 56
    if ((int const   )*fmt == 37) {
#line 56
      goto case_37;
    }
#line 193
    if ((int const   )*fmt == 11) {
#line 193
      goto case_11;
    }
#line 193
    if ((int const   )*fmt == 12) {
#line 193
      goto case_11;
    }
#line 193
    if ((int const   )*fmt == 13) {
#line 193
      goto case_11;
    }
#line 193
    if ((int const   )*fmt == 10) {
#line 193
      goto case_11;
    }
#line 193
    if ((int const   )*fmt == 9) {
#line 193
      goto case_11;
    }
#line 193
    if ((int const   )*fmt == 32) {
#line 193
      goto case_11;
    }
#line 217
    goto switch_default___1;
    case_37: /* CIL Label */ 
#line 57
    fmt ++;
#line 57
    if ((int const   )*fmt == 37) {
#line 58
      if ((int const   )*buf___0 != 37) {
#line 59
        return (1);
      }
#line 60
      buf___0 ++;
    } else {
#line 62
      ignore = 0;
#line 63
      length = -1;
#line 64
      value = 0L;
#line 67
      if ((int const   )*fmt == 42) {
#line 68
        ignore = 1;
#line 68
        fmt ++;
      }
      {
#line 70
      tmp___0 = __ctype_b_loc();
      }
#line 70
      if ((int const   )*(*tmp___0 + (int )*fmt) & 2048) {
        {
#line 71
        length = atoi(fmt);
        }
        {
#line 72
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 73
          fmt ++;
#line 72
          tmp = __ctype_b_loc();
          }
#line 72
          if (! ((int const   )*(*tmp + (int )*fmt) & 2048)) {
#line 72
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 78
      tmp___2 = strchr("difuoxX", (int )*fmt);
      }
#line 78
      if (tmp___2) {
        {
#line 79
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 79
          tmp___1 = __ctype_b_loc();
          }
#line 79
          if (! ((int const   )*(*tmp___1 + (int )*buf___0) & 8192)) {
#line 79
            goto while_break___1;
          }
#line 80
          buf___0 ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 86
      start = buf___0;
      {
#line 93
      if ((int const   )*fmt == 102) {
#line 93
        goto case_102;
      }
#line 93
      if ((int const   )*fmt == 105) {
#line 93
        goto case_102;
      }
#line 93
      if ((int const   )*fmt == 100) {
#line 93
        goto case_102;
      }
#line 96
      if ((int const   )*fmt == 117) {
#line 96
        goto case_117;
      }
#line 116
      if ((int const   )*fmt == 111) {
#line 116
        goto case_111;
      }
#line 132
      if ((int const   )*fmt == 88) {
#line 132
        goto case_88;
      }
#line 132
      if ((int const   )*fmt == 120) {
#line 132
        goto case_88;
      }
#line 153
      if ((int const   )*fmt == 115) {
#line 153
        goto case_115;
      }
#line 162
      if ((int const   )*fmt == 99) {
#line 162
        goto case_99;
      }
#line 177
      goto switch_default;
      case_102: /* CIL Label */ 
      case_105: /* CIL Label */ 
      case_100: /* CIL Label */ 
#line 94
      if ((int const   )*buf___0 == 45) {
#line 94
        if (length) {
#line 95
          buf___0 ++;
#line 95
          length --;
        }
      }
      case_117: /* CIL Label */ 
      {
#line 97
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 97
        tmp___3 = __ctype_b_loc();
        }
#line 97
        if ((int const   )*(*tmp___3 + (int )*buf___0) & 2048) {
#line 97
          if (! length) {
#line 97
            goto while_break___2;
          }
        } else {
#line 97
          goto while_break___2;
        }
#line 98
        buf___0 ++;
#line 98
        length --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 101
      if ((int const   )*fmt == 102) {
#line 101
        if ((int const   )*buf___0 == 46) {
#line 101
          if (length) {
#line 102
            buf___0 ++;
#line 102
            length --;
            {
#line 103
            while (1) {
              while_continue___3: /* CIL Label */ ;
              {
#line 103
              tmp___4 = __ctype_b_loc();
              }
#line 103
              if ((int const   )*(*tmp___4 + (int )*buf___0) & 2048) {
#line 103
                if (! length) {
#line 103
                  goto while_break___3;
                }
              } else {
#line 103
                goto while_break___3;
              }
#line 104
              buf___0 ++;
#line 104
              length --;
            }
            while_break___3: /* CIL Label */ ;
            }
          }
        }
      }
#line 109
      if ((unsigned long )start == (unsigned long )buf___0) {
#line 110
        goto switch_break___0;
      } else {
        {
#line 109
        tmp___5 = atoi(start);
        }
#line 109
        if (tmp___5 == 45) {
#line 109
          if (buf___0 - start == 1L) {
#line 110
            goto switch_break___0;
          }
        }
      }
#line 112
      if (! ignore) {
        {
#line 113
        tmp___6 = i;
#line 113
        i ++;
#line 113
        (*(counter + tmp___6))->value = strndup(start, (size_t )(buf___0 - start));
        }
      }
#line 114
      goto switch_break___0;
      case_111: /* CIL Label */ 
      {
#line 117
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 117
        if ((int const   )*buf___0 >= 48) {
#line 117
          if ((int const   )*buf___0 <= 55) {
#line 117
            if (! length) {
#line 117
              goto while_break___4;
            }
          } else {
#line 117
            goto while_break___4;
          }
        } else {
#line 117
          goto while_break___4;
        }
#line 118
        value <<= 3;
#line 119
        value += (long )((int const   )*buf___0 - 48);
#line 120
        buf___0 ++;
#line 120
        length --;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 124
      if ((unsigned long )start == (unsigned long )buf___0) {
#line 125
        goto switch_break___0;
      }
#line 127
      if (! ignore) {
        {
#line 128
        tmp___7 = i;
#line 128
        i ++;
#line 128
        (*(counter + tmp___7))->value = valuedup((long const   )value);
        }
      }
#line 129
      goto switch_break___0;
      case_88: /* CIL Label */ 
      case_120: /* CIL Label */ 
      {
#line 133
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 133
        tmp___10 = __ctype_b_loc();
        }
#line 133
        if ((int const   )*(*tmp___10 + (int )*buf___0) & 4096) {
#line 133
          if (! length) {
#line 133
            goto while_break___5;
          }
        } else {
#line 133
          goto while_break___5;
        }
        {
#line 134
        value <<= 4;
#line 135
        tmp___9 = __ctype_b_loc();
        }
#line 135
        if ((int const   )*(*tmp___9 + (int )*buf___0) & 2048) {
#line 136
          value += (long )((int const   )*buf___0 - 48);
        } else {
          {
#line 137
          tmp___8 = __ctype_b_loc();
          }
#line 137
          if ((int const   )*(*tmp___8 + (int )*buf___0) & 512) {
#line 138
            value += (long )(((int const   )*buf___0 - 97) + 10);
          } else {
#line 140
            value += (long )(((int const   )*buf___0 - 65) + 10);
          }
        }
#line 142
        buf___0 ++;
#line 142
        length --;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 146
      if ((unsigned long )start == (unsigned long )buf___0) {
#line 147
        goto switch_break___0;
      }
#line 149
      if (! ignore) {
        {
#line 150
        tmp___11 = i;
#line 150
        i ++;
#line 150
        (*(counter + tmp___11))->value = valuedup((long const   )value);
        }
      }
#line 151
      goto switch_break___0;
      case_115: /* CIL Label */ 
      {
#line 154
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 154
        tmp___12 = __ctype_b_loc();
        }
#line 154
        if ((int const   )*(*tmp___12 + (int )*buf___0) & 8192) {
#line 154
          goto while_break___6;
        } else
#line 154
        if (! length) {
#line 154
          goto while_break___6;
        }
#line 155
        buf___0 ++;
#line 155
        length --;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 158
      if (! ignore) {
        {
#line 159
        tmp___13 = i;
#line 159
        i ++;
#line 159
        (*(counter + tmp___13))->value = strndup(start, (size_t )(buf___0 - start));
        }
      }
#line 160
      goto switch_break___0;
      case_99: /* CIL Label */ 
#line 163
      if (length < 0) {
#line 164
        length = 1;
      }
      {
#line 166
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 166
        if (*buf___0) {
#line 166
          if (! (length > 0)) {
#line 166
            goto while_break___7;
          }
        } else {
#line 166
          goto while_break___7;
        }
#line 167
        buf___0 ++;
#line 167
        length --;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 169
      if (length > 0) {
#line 170
        return (2);
      }
#line 172
      if (! ignore) {
        {
#line 173
        tmp___14 = i;
#line 173
        i ++;
#line 173
        (*(counter + tmp___14))->value = strndup(start, (size_t )(buf___0 - start));
        }
      }
#line 174
      goto switch_break___0;
      switch_default: /* CIL Label */ 
      {
#line 178
      send_log(7, (char *)"Error: unrecognized pattern type: `%%%c\'\n", (int const   )*fmt);
#line 179
      exit(1);
      }
      switch_break___0: /* CIL Label */ ;
      }
#line 182
      if (buf___0 - start <= 0L) {
#line 183
        return (3);
      }
    }
#line 185
    fmt ++;
#line 186
    goto switch_break;
    case_11: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
    {
#line 195
    tmp___15 = __ctype_b_loc();
    }
#line 195
    if ((int const   )*(*tmp___15 + (int )*buf___0) & 8192) {
#line 198
      buf___0 ++;
    } else {
#line 196
      return (0);
    }
    {
#line 208
    if ((int const   )*(fmt + 1) == 11) {
#line 208
      goto case_11___0;
    }
#line 208
    if ((int const   )*(fmt + 1) == 12) {
#line 208
      goto case_11___0;
    }
#line 208
    if ((int const   )*(fmt + 1) == 13) {
#line 208
      goto case_11___0;
    }
#line 208
    if ((int const   )*(fmt + 1) == 10) {
#line 208
      goto case_11___0;
    }
#line 208
    if ((int const   )*(fmt + 1) == 9) {
#line 208
      goto case_11___0;
    }
#line 208
    if ((int const   )*(fmt + 1) == 32) {
#line 208
      goto case_11___0;
    }
#line 210
    goto switch_default___0;
    case_11___0: /* CIL Label */ 
    case_12___0: /* CIL Label */ 
    case_13___0: /* CIL Label */ 
    case_10___0: /* CIL Label */ 
    case_9___0: /* CIL Label */ 
    case_32___0: /* CIL Label */ 
#line 209
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
    {
#line 211
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 211
      tmp___16 = __ctype_b_loc();
      }
#line 211
      if (! ((int const   )*(*tmp___16 + (int )*buf___0) & 8192)) {
#line 211
        goto while_break___8;
      }
#line 212
      buf___0 ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    switch_break___1: /* CIL Label */ ;
    }
#line 214
    fmt ++;
#line 215
    goto switch_break;
    switch_default___1: /* CIL Label */ 
#line 218
    if ((int const   )*fmt != (int const   )*buf___0) {
#line 219
      return (1);
    }
#line 220
    fmt ++;
#line 220
    buf___0 ++;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  return (0);
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/scan.c"
int scan_count(char const   *fmt ) 
{ 
  int count ;
  unsigned short const   **tmp ;

  {
#line 230
  count = 0;
  {
#line 231
  while (1) {
    while_continue: /* CIL Label */ ;
#line 231
    if (! *fmt) {
#line 231
      goto while_break;
    }
#line 232
    if ((int const   )*fmt == 37) {
#line 233
      fmt ++;
#line 233
      if ((int const   )*fmt == 42) {
#line 234
        goto while_continue;
      }
      {
#line 236
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 236
        tmp = __ctype_b_loc();
        }
#line 236
        if (! ((int const   )*(*tmp + (int )*fmt) & 2048)) {
#line 236
          goto while_break___0;
        }
#line 237
        fmt ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 239
      if ((int const   )*fmt == 100) {
#line 243
        count ++;
      } else
#line 239
      if ((int const   )*fmt == 105) {
#line 243
        count ++;
      } else
#line 239
      if ((int const   )*fmt == 117) {
#line 243
        count ++;
      } else
#line 239
      if ((int const   )*fmt == 102) {
#line 243
        count ++;
      } else
#line 239
      if ((int const   )*fmt == 111) {
#line 243
        count ++;
      } else
#line 239
      if ((int const   )*fmt == 120) {
#line 243
        count ++;
      } else
#line 239
      if ((int const   )*fmt == 88) {
#line 243
        count ++;
      } else
#line 239
      if ((int const   )*fmt == 99) {
#line 243
        count ++;
      } else
#line 239
      if ((int const   )*fmt == 115) {
#line 243
        count ++;
      } else {
        {
#line 245
        send_log(7, (char *)"Error: unrecognized pattern type: `%%%c\'\n", (int const   )*fmt);
#line 246
        exit(1);
        }
      }
    }
#line 250
    fmt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 252
  return (count);
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/counters.c"
struct rrd_t **rrd  =    (struct rrd_t **)((void *)0);
#line 24 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/counters.c"
int rrd_count  =    0;
#line 26 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/counters.c"
struct test_t **test  =    (struct test_t **)((void *)0);
#line 27 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/counters.c"
int test_count  =    0;
#line 29 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/counters.c"
struct counter_t *add_rrd_counter(char const   *rrdfile , char const   *name ) 
{ 
  int i ;
  int n ;
  size_t len ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  char *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  char *tmp___13 ;

  {
#line 33
  i = 0;
  {
#line 33
  while (1) {
    while_continue: /* CIL Label */ ;
#line 33
    if (! (i < rrd_count)) {
#line 33
      goto while_break;
    }
    {
#line 34
    tmp___6 = strcmp((*(rrd + i))->rrdfile, rrdfile);
    }
#line 34
    if (! tmp___6) {
#line 37
      n = 0;
      {
#line 37
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 37
        if (! (n < (*(rrd + i))->count)) {
#line 37
          goto while_break___0;
        }
        {
#line 38
        tmp = strcmp((*((*(rrd + i))->counter + n))->name, name);
        }
#line 38
        if (! tmp) {
          {
#line 39
          send_log(3, (char *)"duplicate target: `%s:%s\'\n", rrdfile, name);
#line 41
          exit(1);
          }
        }
#line 37
        n ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 44
      tmp___0 = (*(rrd + i))->count;
#line 44
      ((*(rrd + i))->count) ++;
#line 44
      n = tmp___0;
#line 46
      tmp___1 = realloc((void *)(*(rrd + i))->counter, (unsigned long )(*(rrd + i))->count * sizeof(struct counter_t *));
#line 46
      (*(rrd + i))->counter = (struct counter_t **)tmp___1;
#line 49
      tmp___2 = malloc(sizeof(struct counter_t ));
#line 49
      *((*(rrd + i))->counter + n) = (struct counter_t *)tmp___2;
#line 50
      tmp___3 = strdup(name);
#line 50
      (*((*(rrd + i))->counter + n))->name = (char const   *)tmp___3;
#line 51
      (*((*(rrd + i))->counter + n))->value = (char *)((void *)0);
#line 53
      len = strlen((char const   *)(*(rrd + i))->rrdtemplate);
#line 54
      tmp___4 = strlen(name);
#line 54
      len += tmp___4 + 2UL;
#line 55
      tmp___5 = realloc((void *)(*(rrd + i))->rrdtemplate, len);
#line 55
      (*(rrd + i))->rrdtemplate = (char *)tmp___5;
#line 56
      strcat((char */* __restrict  */)(*(rrd + i))->rrdtemplate, (char const   */* __restrict  */)":");
#line 57
      strcat((char */* __restrict  */)(*(rrd + i))->rrdtemplate, (char const   */* __restrict  */)name);
      }
#line 59
      return (*((*(rrd + i))->counter + n));
    }
#line 33
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 63
  tmp___7 = rrd_count;
#line 63
  rrd_count ++;
#line 63
  i = tmp___7;
#line 64
  tmp___8 = realloc((void *)rrd, (unsigned long )rrd_count * sizeof(struct rrd_t *));
#line 64
  rrd = (struct rrd_t **)tmp___8;
#line 65
  tmp___9 = malloc(sizeof(struct rrd_t ));
#line 65
  *(rrd + i) = (struct rrd_t *)tmp___9;
#line 67
  tmp___10 = strdup(rrdfile);
#line 67
  (*(rrd + i))->rrdfile = (char const   *)tmp___10;
#line 68
  (*(rrd + i))->count = 1;
#line 70
  tmp___11 = malloc(sizeof(struct counter_t *));
#line 70
  (*(rrd + i))->counter = (struct counter_t **)tmp___11;
#line 71
  tmp___12 = malloc(sizeof(struct counter_t ));
#line 71
  *((*(rrd + i))->counter + 0) = (struct counter_t *)tmp___12;
#line 72
  tmp___13 = strdup(name);
#line 72
  (*((*(rrd + i))->counter + 0))->name = (char const   *)tmp___13;
#line 73
  (*((*(rrd + i))->counter + 0))->value = (char *)((void *)0);
#line 75
  (*(rrd + i))->rrdtemplate = strdup(name);
  }
#line 77
  return (*((*(rrd + i))->counter + 0));
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/counters.c"
struct test_t *add_test_uri(struct uri_t  const  *uri ) 
{ 
  int i ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 82
  tmp = test_count;
#line 82
  test_count ++;
#line 82
  i = tmp;
#line 83
  tmp___0 = realloc((void *)test, (unsigned long )test_count * sizeof(struct test_t *));
#line 83
  test = (struct test_t **)tmp___0;
#line 84
  tmp___1 = malloc(sizeof(struct test_t ));
#line 84
  *(test + i) = (struct test_t *)tmp___1;
#line 86
  tmp___2 = malloc(sizeof(struct uri_t ));
#line 86
  (*(test + i))->uri = (struct uri_t *)tmp___2;
#line 87
  memcpy((void */* __restrict  */)(*(test + i))->uri, (void const   */* __restrict  */)uri,
         sizeof(struct uri_t ));
#line 89
  (*(test + i))->count = 0;
#line 90
  (*(test + i))->match = (struct match_t **)((void *)0);
  }
#line 92
  return (*(test + i));
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/counters.c"
void clear_counters(void) 
{ 
  int i ;
  int n ;

  {
#line 98
  i = 0;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (i < rrd_count)) {
#line 98
      goto while_break;
    }
#line 101
    n = 0;
    {
#line 101
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 101
      if (! (n < (*(rrd + i))->count)) {
#line 101
        goto while_break___0;
      }
#line 102
      if ((*((*(rrd + i))->counter + n))->value) {
        {
#line 103
        free((void *)(*((*(rrd + i))->counter + n))->value);
#line 104
        (*((*(rrd + i))->counter + n))->value = (char *)((void *)0);
        }
      }
#line 101
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 98
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/counters.c"
void perform_tests(void) 
{ 
  int i ;
  FILE *input ;
  int n ;
  int line ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  struct match_t  const  *match ;
  struct counter_t **tmpcnt ;
  int j ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;

  {
#line 113
  i = 0;
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! (i < test_count)) {
#line 113
      goto while_break;
    }
    {
#line 116
    line = 0;
#line 124
    input = fopen((char const   */* __restrict  */)((*(test + i))->uri)->path, (char const   */* __restrict  */)"r");
    }
#line 129
    if (! input) {
      {
#line 130
      tmp = __errno_location();
#line 130
      tmp___0 = strerror(*tmp);
#line 130
      send_log(3, (char *)"Cannot open file %s: %s\n", ((*(test + i))->uri)->path,
               tmp___0);
#line 131
      tmp___1 = __errno_location();
#line 131
      *tmp___1 = 0;
      }
#line 132
      goto __Cont;
    }
    {
#line 135
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 135
      tmp___5 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)input);
      }
#line 135
      if (! tmp___5) {
#line 135
        goto while_break___0;
      }
#line 136
      line ++;
#line 138
      n = 0;
      {
#line 138
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 138
        if (! (n < (*(test + i))->count)) {
#line 138
          goto while_break___1;
        }
#line 139
        match = (struct match_t  const  *)*((*(test + i))->match + n);
#line 143
        if (match->line) {
#line 143
          if (match->line != (int const   )line) {
#line 144
            goto __Cont___0;
          }
        }
        {
#line 146
        tmp___2 = malloc((unsigned long )match->count * sizeof(struct counter_t *));
#line 146
        tmpcnt = (struct counter_t **)tmp___2;
#line 147
        j = 0;
        }
        {
#line 147
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 147
          if (! (j < (int )match->count)) {
#line 147
            goto while_break___2;
          }
          {
#line 148
          tmp___3 = malloc(sizeof(struct counter_t ));
#line 148
          *(tmpcnt + j) = (struct counter_t *)tmp___3;
#line 149
          (*(tmpcnt + j))->name = (*(match->counter + j))->name;
#line 150
          (*(tmpcnt + j))->value = (char *)((void *)0);
#line 147
          j ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 156
        if ((unsigned int const   )match->type == 1U) {
#line 156
          goto case_1;
        }
#line 156
        if ((unsigned int const   )match->type == 0U) {
#line 156
          goto case_1;
        }
#line 154
        goto switch_break;
        case_1: /* CIL Label */ 
        case_0: /* CIL Label */ 
        {
#line 157
        tmp___4 = scan((char const   *)(buf), (char const   *)match->__annonCompField1.pattern,
                       tmpcnt);
        }
#line 157
        if (tmp___4 == 0) {
#line 158
          j = 0;
          {
#line 158
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 158
            if (! (j < (int )match->count)) {
#line 158
              goto while_break___3;
            }
#line 159
            if ((*(tmpcnt + j))->value) {
#line 160
              if ((*(match->counter + j))->value) {
                {
#line 160
                free((void *)(*(match->counter + j))->value);
                }
              }
              {
#line 161
              (*(match->counter + j))->value = strdup((char const   *)(*(tmpcnt + j))->value);
              }
            }
#line 158
            j ++;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 165
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 173
        j = 0;
        {
#line 173
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 173
          if (! (j < (int )match->count)) {
#line 173
            goto while_break___4;
          }
#line 174
          if ((*(tmpcnt + j))->value) {
            {
#line 174
            free((void *)(*(tmpcnt + j))->value);
            }
          }
          {
#line 175
          free((void *)*(tmpcnt + j));
#line 173
          j ++;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 177
        free((void *)tmpcnt);
        }
        __Cont___0: /* CIL Label */ 
#line 138
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 186
    fclose(input);
    }
    __Cont: /* CIL Label */ 
#line 113
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  return;
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/counters.c"
void print_results(void) 
{ 
  char const   *embed[6] ;
  int i ;
  int n ;
  char *bp ;
  time_t tmp ;
  int tmp___0 ;
  struct counter_t  const  *counter ;
  char *p ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 195
  embed[0] = "update";
#line 195
  embed[1] = "-t";
#line 195
  embed[2] = (char const   *)((void *)0);
#line 195
  embed[3] = (char const   *)((void *)0);
#line 195
  embed[4] = (char const   *)((void *)0);
#line 195
  embed[5] = (char const   *)((void *)0);
#line 197
  i = 0;
  {
#line 197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 197
    if (! (i < rrd_count)) {
#line 197
      goto while_break;
    }
    {
#line 199
    bp = buf;
#line 201
    tmp = time((time_t *)((void *)0));
#line 201
    tmp___0 = sprintf((char */* __restrict  */)bp, (char const   */* __restrict  */)"%ld",
                      tmp);
#line 201
    bp += tmp___0;
#line 203
    n = 0;
    }
    {
#line 203
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 203
      if (! (n < (*(rrd + i))->count)) {
#line 203
        goto while_break___0;
      }
#line 204
      counter = (struct counter_t  const  *)*((*(rrd + i))->counter + n);
#line 208
      tmp___1 = bp;
#line 208
      bp ++;
#line 208
      *tmp___1 = (char )':';
#line 209
      p = (char *)counter->value;
#line 209
      if (p) {
        {
#line 210
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 210
          if (! *p) {
#line 210
            goto while_break___1;
          }
#line 211
          tmp___2 = bp;
#line 211
          bp ++;
#line 211
          tmp___3 = p;
#line 211
          p ++;
#line 211
          *tmp___2 = *tmp___3;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
#line 214
        tmp___4 = bp;
#line 214
        bp ++;
#line 214
        *tmp___4 = (char )'U';
      }
#line 203
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 217
    *bp = (char )'\000';
#line 219
    embed[2] = (char const   *)(*(rrd + i))->rrdtemplate;
#line 220
    embed[3] = (*(rrd + i))->rrdfile;
#line 221
    embed[4] = (char const   *)(buf);
#line 223
    (*make_update)(5, (char **)(embed));
#line 197
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  return;
}
}
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/file.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) flock)(int __fd ,
                                                                            int __operation ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/checkpid.c"
char const   *pid_file  =    "/usr/local/var/run/rrdcollect.pid";
#line 30 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/checkpid.c"
static int pidfd  =    -1;
#line 43 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/checkpid.c"
int is_another_copy(void) 
{ 
  int res ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;

  {
  {
#line 47
  pidfd = open(pid_file, 1577026, (384 | (256 >> 3)) | ((256 >> 3) >> 3));
  }
#line 55
  if (pidfd == -1) {
    {
#line 56
    tmp = __errno_location();
#line 56
    tmp___0 = strerror(*tmp);
#line 56
    tmp___1 = __errno_location();
#line 56
    send_log(3, (char *)"Cannot open PID file %s. Error [%d] %s\n", pid_file, *tmp___1,
             tmp___0);
#line 58
    exit(1);
    }
  }
  {
#line 70
  send_log(7, (char *)"Opened PID file, fd=%d\n", pidfd);
#line 72
  res = flock(pidfd, 6);
#line 73
  send_log(7, (char *)"Trying to lock the pidfile with result %d\n", res);
  }
#line 74
  if (res == -1) {
    {
#line 75
    tmp___2 = __errno_location();
#line 75
    tmp___3 = strerror(*tmp___2);
#line 75
    tmp___4 = __errno_location();
#line 75
    send_log(7, (char *)"Extended result is [%d] %s\n", *tmp___4, tmp___3);
#line 77
    tmp___5 = __errno_location();
    }
#line 77
    if (*tmp___5 == 11) {
      {
#line 78
      send_log(7, (char *)"EWOULDBLOCK - other copy is running");
      }
#line 79
      return (1);
    }
    {
#line 81
    tmp___6 = __errno_location();
#line 81
    tmp___7 = strerror(*tmp___6);
#line 81
    tmp___8 = __errno_location();
#line 81
    send_log(3, (char *)"Cannot lock PID file %s. Error [%d] %s\n", pid_file, *tmp___8,
             tmp___7);
#line 83
    exit(1);
    }
  }
  {
#line 85
  send_log(7, (char *)"We can run!\n");
  }
#line 89
  return (0);
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/checkpid.c"
void write_pidfile(void) 
{ 
  char pid_string[7] ;
  int res ;
  __pid_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  ssize_t tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;

  {
#line 95
  if (pidfd == -1) {
    {
#line 96
    send_log(3, (char *)"PID file is unavailable for some reason. Please see syslog for hints. If still in doubt please send us a bugreport.\n");
#line 97
    exit(1);
    }
  }
  {
#line 99
  tmp = getpid();
#line 99
  tmp___0 = snprintf((char */* __restrict  */)(pid_string), (size_t )7, (char const   */* __restrict  */)"%i\n",
                     tmp);
  }
#line 99
  if (tmp___0 == -1) {
    {
#line 100
    send_log(3, (char *)"PID_LENGTH should be increased, please, send us a bugreport.\n");
#line 101
    exit(1);
    }
  }
  {
#line 103
  tmp___1 = strlen((char const   *)(pid_string));
#line 103
  send_log(7, (char *)"Write PID %s(%d) to file fd=%d\n", pid_string, tmp___1, pidfd);
#line 104
  tmp___2 = strlen((char const   *)(pid_string));
#line 104
  tmp___3 = write(pidfd, (void const   *)((void *)(pid_string)), tmp___2);
#line 104
  res = (int )tmp___3;
  }
#line 105
  if (res == -1) {
    {
#line 106
    tmp___4 = __errno_location();
#line 106
    tmp___5 = strerror(*tmp___4);
#line 106
    tmp___6 = __errno_location();
#line 106
    send_log(3, (char *)"Cannot write to PID file [%d] %s\n", *tmp___6, tmp___5);
#line 108
    exit(1);
    }
  }
#line 110
  return;
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/rrdcollect-0.2.10/src/checkpid.c"
void release_pidfile(void) 
{ 


  {
  {
#line 113
  close(pidfd);
#line 114
  unlink("/usr/local/var/run/rrdcollect.pid");
  }
#line 115
  return;
}
}
