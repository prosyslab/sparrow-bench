/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 57 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.h"
enum __anonenum_int_type_1 {
    INT_UNDEF = 0,
    INT_CHAR = 65793,
    INT_UCHAR = 65792,
    INT_SHORT = 131585,
    INT_USHORT = 131584,
    INT_INT = 197633,
    INT_UINT = 197632,
    INT_LONG = 264193,
    INT_ULONG = 264192,
    INT_LLONG = 329729,
    INT_ULLONG = 329728,
    INT_TOO_BIG = 393216,
    INT_INSOLUBLE = 393216
} ;
#line 57 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.h"
typedef enum __anonenum_int_type_1 int_type;
#line 89 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.h"
union __anonunion_val_2 {
   long long ll ;
   unsigned long long ull ;
   long l ;
   unsigned long ul ;
   int i ;
   unsigned int ui ;
};
#line 89 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.h"
struct int_spec {
   union __anonunion_val_2 val ;
   int_type type ;
};
#line 89 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.h"
typedef struct int_spec int_spec_t;
#line 52 "/home/wslee/tests/SOURCES/coan-4.2.2/src/memory.h"
typedef char *heap_str;
#line 66 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.h"
enum __anonenum_reason_code_t_25 {
    MSGCLASS_SHIFT = 11,
    ISSUE_MASK = 2047,
    MSGCLASS_NONE = 0,
    MSGCLASS_PROGRESS = 2048,
    MSGCLASS_INFO = 4096,
    MSGCLASS_WARNING = 8192,
    MSGCLASS_ERROR = 16384,
    MSGCLASS_ABEND = 32768,
    MSGCLASS_SUMMARY = 65536,
    MSGCLASS_MASK = 522240,
    MSGSEVERITY_MASK = 456704,
    MSGEVENT_MASK = 454656,
    EVENT_SUMMARY_MIN = 1,
    EVENT_SUMMARY_DROPPED_LINES = 69633,
    EVENT_SUMMARY_CHANGED_LINES = 69634,
    EVENT_SUMMARY_ERRORED_LINES = 73732,
    EVENT_SUMMARY_ERROR_OUTPUT = 73736,
    EVENT_SUMMARY_MAX = 16,
    EVENT_SUMMARY_MASK = 15,
    PROGRESS_SHIFT = 4,
    PROGRESS_PROCESSING_FILE = 2768,
    PROGRESS_ENTERING_DIR = 2784,
    PROGRESS_LEAVING_DIR = 2800,
    PROGRESS_BUILDING_TREE = 2832,
    PROGRESS_SEARCHING_DIR = 2848,
    PROGRESS_ADDED_FILE = 2864,
    PROGRESS_ADDED_DIR = 2880,
    PROGRESS_FILE_TALLY = 2896,
    PROGRESS_GOT_OPTIONS = 2912,
    PROGRESS_SUMMARY_SHIFT = 4,
    PROGRESS_SUMMARY_FILES_REACHED = 70512,
    PROGRESS_SUMMARY_FILES_DROPPED = 70528,
    PROGRESS_SUMMARY_ALL_DONE = 68496,
    GRIPE_SHIFT = 4,
    GRIPE_DUPLICATE_MASK = 4528,
    GRIPE_SYMLINK = 4864,
    GRIPE_STRAIGHTENED_LINE = 4288,
    GRIPE_REDUNDANT_OPTION = 8976,
    GRIPE_DUPLICATE_ARGS = 8208,
    GRIPE_DELETED_CONTRADICTION = 8224,
    GRIPE_COMMENTED_CONTRADICTION = 8240,
    GRIPE_ERRORED_CONTRADICTION = 8256,
    GRIPE_DIFFERING_REDEF = 9408,
    GRIPE_UNDEFING_DEFINED = 9424,
    GRIPE_UNCONDITIONAL_ERROR_INPUT = 8272,
    GRIPE_UNCONDITIONAL_ERROR_OUTPUT = 8288,
    GRIPE_GARBAGE_AFTER_DIRECTIVE = 8304,
    GRIPE_MISSING_EOF_NEWLINE = 8480,
    GRIPE_CIRCULAR_SYM_DEF = 8640,
    GRIPE_VERBOSE_ONLY = 8656,
    GRIPE_ZERO_DIVIDE = 8800,
    GRIPE_DIR_IGNORED = 8848,
    GRIPE_EMPTY_SYMBOL = 9120,
    GRIPE_UNKNOWN_DIRECTIVE = 9152,
    GRIPE_INVALID_INCLUDE = 9168,
    GRIPE_STRAY_ESCAPE = 9184,
    GRIPE_FUNCTION_LIKE_MACRO_EXPANSION = 9200,
    GRIPE_INT_OVERFLOW = 9216,
    GRIPE_UNCLOSED_QUOTE = 9232,
    GRIPE_NEGATIVE_SHIFT = 9248,
    GRIPE_FORCED_UNSIGNED = 9264,
    GRIPE_SIGN_CHANGED = 9280,
    GRIPE_SHIFT_OVERFLOW = 9296,
    GRIPE_CHAR_CONSTANT_TOO_LONG = 9312,
    GRIPE_MULITBYTE_CHAR_CONSTANT = 9328,
    GRIPE_TRANSIENT_SYMBOL_ADDED = 9360,
    GRIPE_INSOURCE_FUNCTION_LIKE_MACRO_DEFINITION = 9376,
    GRIPE_NO_SYMS = 9392,
    GRIPE_ORPHAN_ELIF = 16512,
    GRIPE_ORPHAN_ELSE = 16528,
    GRIPE_ORPHAN_ENDIF = 16544,
    GRIPE_EOF_TOO_SOON = 16560,
    GRIPE_EOF_IN_COMMENT = 16592,
    GRIPE_EOF_IN_QUOTE = 16608,
    GRIPE_NOTHING_TO_DO = 16624,
    GRIPE_ONE_FILE_ONLY = 16640,
    GRIPE_NEWLINE_IN_QUOTE = 16656,
    GRIPE_INVALID_ARGS = 16688,
    GRIPE_USAGE_ERROR = 16704,
    GRIPE_TOO_DEEP = 16720,
    GRIPE_MULTIPLE_ARGFILES = 16880,
    GRIPE_GARBAGE_ARG = 16896,
    GRIPE_NOT_IDENTIFIER = 16912,
    GRIPE_UNBALANCED_PAREN = 17328,
    GRIPE_GLOBAL_FUNCTION_LIKE_MACRO_DEFINITION = 17536,
    GRIPE_IF_WITHOUT_COND = 17632,
    GRIPE_CANT_OPEN_INPUT = 33120,
    GRIPE_OUT_OF_MEMORY = 33136,
    GRIPE_FILENAME_TOO_LONG = 33152,
    GRIPE_EOF_IN_FILENAME = 33168,
    GRIPE_CONFUSED = 33184,
    GRIPE_CANT_READ_INPUT = 33248,
    GRIPE_CANT_WRITE_FILE = 33392,
    GRIPE_NO_FILE = 33408,
    GRIPE_ILLEGAL_FILENAME = 33312,
    GRIPE_CANT_DELETE_FILE = 33328,
    GRIPE_CANT_RENAME_FILE = 33344,
    GRIPE_NO_TEMPFILE = 33360,
    GRIPE_CANT_OPEN_DIR = 33440,
    GRIPE_CANT_READ_DIR = 33456
} ;
#line 66 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.h"
typedef enum __anonenum_reason_code_t_25 reason_code_t;
#line 211 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned long size_t;
#line 323 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stddef.h"
typedef int wchar_t;
#line 149 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stddef.h"
typedef long ptrdiff_t;
#line 54 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.h"
typedef ptrdiff_t locator_t;
#line 48 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_set.h"
struct ptr_set;
#line 48 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_set.h"
typedef struct ptr_set *ptr_set_h;
#line 51 "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.h"
struct canonical_string_impl;
#line 51 "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.h"
typedef struct canonical_string_impl *canonical_string_h;
#line 118 "/home/wslee/tests/SOURCES/coan-4.2.2/src/eval_result.h"
struct eval_result {
   char *sym_name ;
   canonical_string_h sym_def ;
   canonical_string_h most_resolved ;
   int_spec_t value ;
   int flags ;
   int line ;
};
#line 55 "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.h"
typedef struct eval_result *symbol_h;
#line 58 "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.h"
typedef struct eval_result  const  *symbol_const_h;
#line 63 "/home/wslee/tests/SOURCES/coan-4.2.2/src/unconfigured_symbols.h"
struct unconfigured_symbols_public_state_s {
   ptr_set_h sym_tab ;
};
#line 63 "/home/wslee/tests/SOURCES/coan-4.2.2/src/unconfigured_symbols.h"
typedef struct unconfigured_symbols_public_state_s unconfigured_symbols_public_state_t;
#line 48 "/home/wslee/tests/SOURCES/coan-4.2.2/src/unconfigured_symbols.c"
typedef unconfigured_symbols_public_state_t unconfigured_symbols_state_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef long __off64_t;
#line 54 "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.h"
typedef struct canonical_string_impl  const  *canonical_string_const_h;
#line 85 "/home/wslee/tests/SOURCES/coan-4.2.2/src/eval_result.h"
enum __anonenum_line_type_t_20 {
    LT_IF = 0,
    LT_TRUE = 1,
    LT_FALSE = 2,
    LT_ELIF = 3,
    LT_ELTRUE = 4,
    LT_ELFALSE = 5,
    LT_ELSE = 6,
    LT_ENDIF = 7,
    LT_PLAIN = 8,
    LT_EOF = 9,
    LT_DIRECTIVE_DROP = 10,
    LT_DIRECTIVE_KEEP = 11,
    LT_SENTINEL = 12
} ;
#line 85 "/home/wslee/tests/SOURCES/coan-4.2.2/src/eval_result.h"
typedef enum __anonenum_line_type_t_20 line_type_t;
#line 118 "/home/wslee/tests/SOURCES/coan-4.2.2/src/eval_result.h"
typedef struct eval_result eval_result_t;
#line 57 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.h"
struct ptr_vector;
#line 57 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.h"
typedef struct ptr_vector *ptr_vector_h;
#line 60 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.h"
typedef struct ptr_vector  const  *ptr_vector_const_h;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 188 "/home/wslee/tests/SOURCES/coan-4.2.2/src/io.h"
struct io_public_state_s {
   int line_num ;
   char const   *filename ;
   char *line_start ;
   char *pristine_line ;
   size_t line_len ;
   FILE *output ;
   size_t extension_lines ;
};
#line 188 "/home/wslee/tests/SOURCES/coan-4.2.2/src/io.h"
typedef struct io_public_state_s io_public_state_t;
#line 158 "/home/wslee/tests/SOURCES/coan-4.2.2/src/contradiction.h"
struct contradiction_public_state_s {
   symbol_const_h last_contradictory_undef ;
};
#line 158 "/home/wslee/tests/SOURCES/coan-4.2.2/src/contradiction.h"
typedef struct contradiction_public_state_s contradiction_public_state_t;
#line 29 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_5 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 29 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_5 __sigset_t;
#line 57 "/home/wslee/tests/SOURCES/coan-4.2.2/src/hash_include.h"
typedef symbol_const_h hash_include_const_h;
#line 50 "/home/wslee/tests/SOURCES/coan-4.2.2/src/directives_tally.h"
enum __anonenum_directive_type_t_24 {
    HASH_UNKNOWN = 0,
    HASH_IF = 1,
    HASH_IFDEF = 2,
    HASH_IFNDEF = 3,
    HASH_ELSE = 4,
    HASH_ELIF = 5,
    HASH_ENDIF = 6,
    HASH_DEFINE = 7,
    HASH_UNDEF = 8,
    HASH_INCLUDE = 9,
    HASH_PRAGMA = 10,
    HASH_ERROR = 11,
    HASH_COUNT = 12
} ;
#line 50 "/home/wslee/tests/SOURCES/coan-4.2.2/src/directives_tally.h"
typedef enum __anonenum_directive_type_t_24 directive_type_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 102 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 321 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.h"
enum __anonenum_dbg_code_t_26 {
    DBG_1 = 1,
    DBG_2 = 2,
    DBG_3 = 3,
    DBG_4 = 4,
    DBG_5 = 5,
    DBG_6 = 6,
    DBG_8 = 7,
    DBG_7 = 8,
    DBG_9 = 9,
    DBG_10 = 10,
    DBG_11 = 11,
    DBG_12 = 12,
    DBG_13 = 13,
    DBG_14 = 14,
    DBG_15 = 15,
    DBG_16 = 16,
    DBG_17 = 17,
    DBG_18 = 18,
    DBG_19 = 19,
    DBG_20 = 20,
    DBG_21 = 21,
    DBG_22 = 22
} ;
#line 321 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.h"
typedef enum __anonenum_dbg_code_t_26 dbg_code_t;
#line 90 "/home/wslee/tests/SOURCES/coan-4.2.2/src/get_options.h"
struct cmd_option {
   char const   *name ;
   int cmd_code ;
   int cmd_mask ;
};
#line 90 "/home/wslee/tests/SOURCES/coan-4.2.2/src/get_options.h"
typedef struct cmd_option cmd_option_t;
#line 54 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.h"
enum __anonenum_discard_policy_t_32 {
    DISCARD_DROP = 0,
    DISCARD_BLANK = 1,
    DISCARD_COMMENT = 2
} ;
#line 54 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.h"
typedef enum __anonenum_discard_policy_t_32 discard_policy_t;
#line 122 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.h"
struct args_public_state_s {
   cmd_option_t *command ;
   char *exec_path ;
   char *prog_name ;
   char *backup_suffix ;
   _Bool got_opts ;
   _Bool replace ;
   _Bool list_locate ;
   _Bool list_only_once ;
   _Bool list_only_active ;
   _Bool list_only_inactive ;
   _Bool list_symbols_in_ifs ;
   _Bool list_symbols_in_defs ;
   _Bool list_symbols_in_undefs ;
   _Bool list_symbols_in_includes ;
   _Bool list_system_includes ;
   _Bool list_local_includes ;
   _Bool complement ;
   _Bool eval_consts ;
   _Bool resolve_symbols ;
   discard_policy_t discard_policy ;
   _Bool line_directives ;
   _Bool plaintext ;
   _Bool recurse ;
   _Bool keepgoing ;
   _Bool implicit ;
   int diagnostic_filter ;
};
#line 122 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.h"
typedef struct args_public_state_s args_public_state_t;
#line 58 "/home/wslee/tests/SOURCES/coan-4.2.2/src/chew.h"
enum comment_state {
    NO_COMMENT = 0,
    C_COMMENT = 1,
    CXX_COMMENT = 2,
    STARTING_COMMENT = 3,
    FINISHING_COMMENT = 4,
    PSEUDO_COMMENT = 5
} ;
#line 74
enum __anonenum_line_state_t_33 {
    LS_NEUTER = 0,
    LS_DIRECTIVE = 1,
    LS_CODE = 2
} ;
#line 74 "/home/wslee/tests/SOURCES/coan-4.2.2/src/chew.h"
typedef enum __anonenum_line_state_t_33 line_state_t;
#line 189 "/home/wslee/tests/SOURCES/coan-4.2.2/src/chew.h"
struct chew_public_state_s {
   enum comment_state comment_state ;
   _Bool stop_at_quote ;
   _Bool must_balance_quotes ;
   _Bool in_double_quote ;
   _Bool in_source ;
   line_state_t line_state ;
   size_t last_quote_start_line ;
   size_t last_comment_start_line ;
};
#line 189 "/home/wslee/tests/SOURCES/coan-4.2.2/src/chew.h"
typedef struct chew_public_state_s chew_public_state_t;
#line 57 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.h"
enum __anonenum_if_state_t_34 {
    IF_STATE_OUTSIDE = 0,
    IF_STATE_FALSE_PREFIX = 1,
    IF_STATE_TRUE_PREFIX = 2,
    IF_STATE_PASS_MIDDLE = 3,
    IF_STATE_FALSE_MIDDLE = 4,
    IF_STATE_TRUE_MIDDLE = 5,
    IF_STATE_PASS_ELSE = 6,
    IF_STATE_FALSE_ELSE = 7,
    IF_STATE_TRUE_ELSE = 8,
    IF_STATE_FALSE_TRAILER = 9,
    IF_STATE_COUNT = 10
} ;
#line 57 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.h"
typedef enum __anonenum_if_state_t_34 if_state_t;
#line 91 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_despatch.h"
struct line_despatch_public_state_s {
   int lines_inactive ;
   int lines_changed ;
};
#line 91 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_despatch.h"
typedef struct line_despatch_public_state_s line_despatch_public_state_t;
#line 32 "/usr/include/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 35 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 49 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 77 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.h"
struct file_tree;
#line 77 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.h"
typedef struct file_tree *file_tree_h;
#line 80 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.h"
typedef struct file_tree  const  *file_tree_const_h;
#line 84 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.h"
struct __anonstruct_file_tree_count_t_36 {
   size_t files ;
   size_t dirs ;
   size_t children ;
};
#line 84 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.h"
typedef struct __anonstruct_file_tree_count_t_36 file_tree_count_t;
#line 82 "/home/wslee/tests/SOURCES/coan-4.2.2/src/dataset.h"
struct dataset_public_state_s {
   file_tree_h file_tree ;
   unsigned int donefiles ;
   unsigned int errorfiles ;
};
#line 82 "/home/wslee/tests/SOURCES/coan-4.2.2/src/dataset.h"
typedef struct dataset_public_state_s dataset_public_state_t;
#line 189 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
struct report_state_s {
   _Bool dbg ;
   unsigned int exitstat ;
   char const   *hash_keywords[12] ;
};
#line 189 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
typedef struct report_state_s report_state_t;
#line 201 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
typedef report_state_t report_public_state_t;
#line 63 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.h"
typedef void (*dtor_t)(void * );
#line 66 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.h"
typedef void *(*cloner_t)(void const   * );
#line 49 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.c"
struct ptr_vector {
   size_t tranch ;
   size_t count ;
   size_t cap ;
   void (*dtor)(void * ) ;
   void *(*cloner)(void const   * ) ;
   void **ptrs ;
};
#line 78 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.h"
typedef int (*comparator_t)(void const   *obj , void const   *key , locator_t keylen );
#line 51 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_set.h"
typedef struct ptr_set  const  *ptr_set_const_h;
#line 62 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_set.c"
struct ptr_set {
   ptr_vector_h pv ;
   int (*compare)(void const   *obj , void const   *key , locator_t keylen ) ;
   locator_t cached_pos ;
};
#line 58 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.h"
enum __anonenum_file_tree_traverse_state_t_35 {
    FT_ENTERING_TREE = -2,
    FT_ENTERING_DIR = -1,
    FT_AT_FILE = 0,
    FT_LEAVING_DIR = 1,
    FT_LEAVING_TREE = 2
} ;
#line 58 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.h"
typedef enum __anonenum_file_tree_traverse_state_t_35 file_tree_traverse_state_t;
#line 73 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_select.h"
struct line_select_public_state_s {
   _Bool dropping_line ;
};
#line 73 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_select.h"
typedef struct line_select_public_state_s line_select_public_state_t;
#line 49 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_select.c"
typedef line_select_public_state_t line_select_state_t;
#line 161 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_edit.h"
struct line_edit_public_state_s {
   char *keyword ;
   _Bool ops_cut ;
   size_t parens_deleted ;
};
#line 161 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_edit.h"
typedef struct line_edit_public_state_s line_edit_public_state_t;
#line 163 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_edit.c"
typedef line_edit_public_state_t line_edit_state_t;
#line 341 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 254 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_despatch.c"
struct line_despatch_state_s {
   line_despatch_public_state_t line_despatch_public_state ;
   void (*flushline)(_Bool  , char const   * ) ;
   size_t drop_run ;
};
#line 254 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_despatch.c"
typedef struct line_despatch_state_s line_despatch_state_t;
#line 123 "/home/wslee/tests/SOURCES/coan-4.2.2/src/io.c"
struct io_state_s {
   io_public_state_t io_public_state ;
   FILE *input ;
   size_t bufsz ;
   size_t infile ;
   char *in_name_buf ;
   char *out_name_buf ;
   char *bak_name_buf ;
   size_t saved_read_pos ;
};
#line 123 "/home/wslee/tests/SOURCES/coan-4.2.2/src/io.c"
typedef struct io_state_s io_state_t;
#line 84 "/home/wslee/tests/SOURCES/coan-4.2.2/src/includes_tally.h"
struct includes_tally_public_state_s {
   ptr_set_h includes_tab ;
};
#line 84 "/home/wslee/tests/SOURCES/coan-4.2.2/src/includes_tally.h"
typedef struct includes_tally_public_state_s includes_tally_public_state_t;
#line 54 "/home/wslee/tests/SOURCES/coan-4.2.2/src/hash_include.h"
typedef symbol_h hash_include_h;
#line 47 "/home/wslee/tests/SOURCES/coan-4.2.2/src/includes_tally.c"
typedef includes_tally_public_state_t includes_tally_state_t;
#line 67 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
typedef void transition_t(void);
#line 332 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
struct if_control_state_s {
   if_state_t ifstate[64] ;
   size_t depth ;
   size_t if_start_lines[64] ;
};
#line 332 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
typedef struct if_control_state_s if_control_state_t;
#line 348 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
typedef if_control_state_t if_control_public_state_t;
#line 59 "/home/wslee/tests/SOURCES/coan-4.2.2/src/get_options.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 102 "/home/wslee/tests/SOURCES/coan-4.2.2/src/get_options.h"
struct exclusion_list {
   int excluder ;
   int const   *excluded ;
};
#line 134 "/usr/include/bits/types.h"
typedef unsigned long __dev_t;
#line 135 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 136 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned long __nlink_t;
#line 149 "/usr/include/bits/types.h"
typedef long __time_t;
#line 164 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 169 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 43 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   __time_t st_atime ;
   unsigned long st_atimensec ;
   __time_t st_mtime ;
   unsigned long st_mtimensec ;
   __time_t st_ctime ;
   unsigned long st_ctimensec ;
   long __unused[3] ;
};
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 55 "/home/wslee/tests/SOURCES/coan-4.2.2/src/filesys.h"
typedef void *fs_dir_t;
#line 59
enum __anonenum_fs_obj_type_t_20 {
    FS_OBJ_NONE = 0,
    FS_OBJ_SLINK = 1,
    FS_OBJ_FILE = 2,
    FS_OBJ_DIR = 4
} ;
#line 59 "/home/wslee/tests/SOURCES/coan-4.2.2/src/filesys.h"
typedef enum __anonenum_fs_obj_type_t_20 fs_obj_type_t;
#line 57 "/home/wslee/tests/SOURCES/coan-4.2.2/src/fs_nix.c"
struct fs_dir_nix {
   struct fs_dir_nix *parent ;
   heap_str dirname ;
   char *dirname_end ;
   DIR *dir ;
   struct dirent entry ;
};
#line 57 "/home/wslee/tests/SOURCES/coan-4.2.2/src/fs_nix.c"
typedef struct fs_dir_nix fs_dir_nix_t;
#line 67 "/home/wslee/tests/SOURCES/coan-4.2.2/src/filesys.h"
enum __anonenum_fs_path_type_t_19 {
    FS_ABS_PATH = 1,
    FS_UNIX_PATH = 2,
    FS_WIN_PATH = 6,
    FS_DANGLING_PATH = 8,
    FS_ROOT_PATH = 16
} ;
#line 67 "/home/wslee/tests/SOURCES/coan-4.2.2/src/filesys.h"
typedef enum __anonenum_fs_path_type_t_19 fs_path_type_t;
#line 111 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.c"
union __anonunion_var_35 {
   heap_str leafname ;
   _Bool (*filter)(char const   *leafname ) ;
};
#line 111 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.c"
struct file_tree {
   union __anonunion_var_35 var ;
   struct file_tree *parent ;
   ptr_vector_h children ;
   unsigned int files ;
};
#line 108 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.h"
typedef int_spec_t integer_bin_op_t(int_spec_t const   * , int_spec_t const   * );
#line 58 "/home/wslee/tests/SOURCES/coan-4.2.2/src/chew.h"
typedef enum comment_state comment_state_t;
#line 68 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
struct evaluator_state_s {
   char const   *ifpos ;
   line_type_t line_type ;
   int parsing_sym_def_depth ;
};
#line 68 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
typedef struct evaluator_state_s evaluator_state_t;
#line 86 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
typedef evaluator_state_t evaluator_public_state_t;
#line 95
struct co_precedent_ops;
#line 325 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
struct operation {
   char const   *str ;
   eval_result_t (*fn)(eval_result_t * , eval_result_t * ) ;
};
#line 349 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
typedef eval_result_t evaluator_t(struct co_precedent_ops  const  *ops , char const   ** ,
                                  struct operation  const  **pbin_op );
#line 412 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
struct co_precedent_ops {
   evaluator_t *inner ;
   struct operation op[5] ;
};
#line 51 "/home/wslee/tests/SOURCES/coan-4.2.2/src/directives_tally.c"
struct directives_tally_state_s {
   ptr_vector_h directives_tab ;
};
#line 51 "/home/wslee/tests/SOURCES/coan-4.2.2/src/directives_tally.c"
typedef struct directives_tally_state_s directives_tally_state_t;
#line 62 "/home/wslee/tests/SOURCES/coan-4.2.2/src/directives_tally.c"
typedef directives_tally_state_t directives_tally_public_state_t;
#line 84 "/home/wslee/tests/SOURCES/coan-4.2.2/src/directives_tally.c"
struct directive {
   directive_type_t type ;
   char const   *keyword ;
};
#line 84 "/home/wslee/tests/SOURCES/coan-4.2.2/src/directives_tally.c"
typedef struct directive directive_t;
#line 51 "/home/wslee/tests/SOURCES/coan-4.2.2/src/dataset.c"
struct dataset_state_s {
   dataset_public_state_t dataset_public_state ;
   heap_str filter_types ;
};
#line 51 "/home/wslee/tests/SOURCES/coan-4.2.2/src/dataset.c"
typedef struct dataset_state_s dataset_state_t;
#line 121 "/home/wslee/tests/SOURCES/coan-4.2.2/src/configured_symbols.h"
struct configured_symbols_public_state_s {
   ptr_set_h global_sym_tab ;
   ptr_set_h sym_tab ;
};
#line 121 "/home/wslee/tests/SOURCES/coan-4.2.2/src/configured_symbols.h"
typedef struct configured_symbols_public_state_s configured_symbols_public_state_t;
#line 47 "/home/wslee/tests/SOURCES/coan-4.2.2/src/configured_symbols.c"
typedef configured_symbols_public_state_t configured_symbols_state_t;
#line 58 "/home/wslee/tests/SOURCES/coan-4.2.2/src/chew.c"
struct chew_state_s {
   chew_public_state_t chew_public_state ;
   size_t single_quote_length ;
   _Bool escape ;
};
#line 58 "/home/wslee/tests/SOURCES/coan-4.2.2/src/chew.c"
typedef struct chew_state_s chew_state_t;
#line 56 "/home/wslee/tests/SOURCES/coan-4.2.2/src/contradiction.h"
enum contradiction_policy {
    CONTRADICTION_DELETE = 0,
    CONTRADICTION_COMMENT = 1,
    CONTRADICTION_ERROR = 2
} ;
#line 56 "/home/wslee/tests/SOURCES/coan-4.2.2/src/contradiction.h"
typedef enum contradiction_policy contradiction_policy_t;
#line 56 "/home/wslee/tests/SOURCES/coan-4.2.2/src/contradiction.c"
struct contradiction_state_s {
   contradiction_public_state_t contradiction_public_state ;
   char *contradiction_insert_prefix ;
   int contradiction_insert_reason ;
   _Bool had_warnings ;
   heap_str err_msg_buf[2] ;
};
#line 56 "/home/wslee/tests/SOURCES/coan-4.2.2/src/contradiction.c"
typedef struct contradiction_state_s contradiction_state_t;
#line 52 "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c"
struct canonical_string_impl {
   heap_str text ;
};
#line 59 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c"
struct args_state_s {
   args_public_state_t args_public_state ;
   ptr_vector_h argfile_argv ;
   char *memfile ;
   int arg_dirs_ignored ;
};
#line 59 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c"
typedef struct args_state_s args_state_t;
#line 115 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.h"
int_spec_t lt(int_spec_t const   *l , int_spec_t const   *r ) ;
#line 123
int_spec_t gt(int_spec_t const   *l , int_spec_t const   *r ) ;
#line 131
int_spec_t le(int_spec_t const   *l , int_spec_t const   *r ) ;
#line 139
int_spec_t ge(int_spec_t const   *l , int_spec_t const   *r ) ;
#line 147
int_spec_t eq(int_spec_t const   *l , int_spec_t const   *r ) ;
#line 155
int_spec_t ne(int_spec_t const   *l , int_spec_t const   *r ) ;
#line 163
int_spec_t bit_and(int_spec_t const   *l , int_spec_t const   *r ) ;
#line 171
int_spec_t bit_or(int_spec_t const   *l , int_spec_t const   *r ) ;
#line 179
int_spec_t bit_xor(int_spec_t const   *l , int_spec_t const   *r ) ;
#line 186
int_spec_t complement(int_spec_t const   *int_spec ) ;
#line 193
int_spec_t minus(int_spec_t const   *int_spec ) ;
#line 201
int_spec_t lshift(int_spec_t const   *l , int_spec_t const   *r ) ;
#line 209
int_spec_t rshift(int_spec_t const   *l , int_spec_t const   *r ) ;
#line 217
int_spec_t add(int_spec_t const   *l , int_spec_t const   *r ) ;
#line 225
int_spec_t subtract(int_spec_t const   *l , int_spec_t const   *r ) ;
#line 233
int_spec_t multiply(int_spec_t const   *l , int_spec_t const   *r ) ;
#line 241
int_spec_t divide(int_spec_t const   *l , int_spec_t const   *r ) ;
#line 249
int_spec_t modulus(int_spec_t const   *l , int_spec_t const   *r ) ;
#line 257
int_spec_t boolean_and(int_spec_t const   *l , int_spec_t const   *r ) ;
#line 266
int_spec_t boolean_or(int_spec_t const   *l , int_spec_t const   *r ) ;
#line 274
int_spec_t negate(int_spec_t const   *int_spec ) ;
#line 488 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 71 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
#line 459 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.h"
void report(reason_code_t reason , heap_str *buf , char const   *format  , ...) ;
#line 681
char *format_int(int_spec_t const   *int_spec ) ;
#line 57 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.c"
static int sign(int_spec_t const   *int_spec ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 61
  if ((unsigned int const   )int_spec->type == 197633U) {
#line 61
    goto case_197633;
  }
#line 63
  if ((unsigned int const   )int_spec->type == 197632U) {
#line 63
    goto case_197632;
  }
#line 65
  if ((unsigned int const   )int_spec->type == 264193U) {
#line 65
    goto case_264193;
  }
#line 67
  if ((unsigned int const   )int_spec->type == 264192U) {
#line 67
    goto case_264192;
  }
#line 69
  if ((unsigned int const   )int_spec->type == 329729U) {
#line 69
    goto case_329729;
  }
#line 71
  if ((unsigned int const   )int_spec->type == 329728U) {
#line 71
    goto case_329728;
  }
#line 73
  goto switch_default;
  case_197633: /* CIL Label */ 
#line 62
  if (int_spec->val.i < 0) {
#line 62
    tmp = -1;
  } else {
#line 62
    tmp = 1;
  }
#line 62
  return (tmp);
  case_197632: /* CIL Label */ 
#line 64
  return (1);
  case_264193: /* CIL Label */ 
#line 66
  if (int_spec->val.l < 0L) {
#line 66
    tmp___0 = -1;
  } else {
#line 66
    tmp___0 = 1;
  }
#line 66
  return (tmp___0);
  case_264192: /* CIL Label */ 
#line 68
  return (1);
  case_329729: /* CIL Label */ 
#line 70
  if (int_spec->val.ll < 0LL) {
#line 70
    tmp___1 = -1;
  } else {
#line 70
    tmp___1 = 1;
  }
#line 70
  return (tmp___1);
  case_329728: /* CIL Label */ 
#line 72
  return (1);
  switch_default: /* CIL Label */ 
#line 74
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 92 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.c"
static void sign_extend(int_spec_t *converted , int_spec_t const   *unconverted ) 
{ 
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 95
  if ((unsigned int const   )unconverted->type & 1U) {
    {
    {
#line 95
    tmp = sign(unconverted);
    }
    }
#line 95
    if (tmp == -1) {
#line 95
      if ((unsigned int )converted->type >> 16 > (unsigned int )((unsigned int const   )unconverted->type >> 16)) {
        {
#line 99
        if ((unsigned int )converted->type == 264192U) {
#line 99
          goto case_264192;
        }
#line 99
        if ((unsigned int )converted->type == 264193U) {
#line 99
          goto case_264192;
        }
#line 109
        if ((unsigned int )converted->type == 329728U) {
#line 109
          goto case_329728;
        }
#line 109
        if ((unsigned int )converted->type == 329729U) {
#line 109
          goto case_329728;
        }
#line 121
        goto switch_default___1;
        case_264192: /* CIL Label */ 
        case_264193: /* CIL Label */ 
        {
#line 101
        if ((unsigned int const   )unconverted->type == 197633U) {
#line 101
          goto case_197633;
        }
#line 104
        goto switch_default;
        case_197633: /* CIL Label */ 
#line 102
        converted->val.ul = (unsigned long )unconverted->val.i;
#line 103
        goto switch_break___0;
        switch_default: /* CIL Label */ 
        {
        {
#line 105
        __assert_fail("0", "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.c",
                      105U, "sign_extend");
        }
        }
        switch_break___0: /* CIL Label */ ;
        }
#line 107
        goto switch_break;
        case_329728: /* CIL Label */ 
        case_329729: /* CIL Label */ 
        {
#line 111
        if ((unsigned int const   )unconverted->type == 197633U) {
#line 111
          goto case_197633___0;
        }
#line 114
        if ((unsigned int const   )unconverted->type == 264193U) {
#line 114
          goto case_264193___0;
        }
#line 117
        goto switch_default___0;
        case_197633___0: /* CIL Label */ 
#line 112
        converted->val.ull = (unsigned long long )unconverted->val.i;
#line 113
        goto switch_break___1;
        case_264193___0: /* CIL Label */ 
#line 115
        converted->val.ull = (unsigned long long )unconverted->val.l;
#line 116
        goto switch_break___1;
        switch_default___0: /* CIL Label */ 
        {
        {
#line 118
        __assert_fail("0", "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.c",
                      118U, "sign_extend");
        }
        }
        switch_break___1: /* CIL Label */ ;
        }
#line 120
        goto switch_break;
        switch_default___1: /* CIL Label */ 
        {
        {
#line 122
        __assert_fail("0", "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.c",
                      122U, "sign_extend");
        }
        }
        switch_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 125
  return;
}
}
#line 140 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.c"
static void do_usual_conversions(int_spec_t const   *l , int_spec_t const   *r , int_spec_t *cl ,
                                 int_spec_t *cr ) 
{ 
  int_type lhs ;
  int_type rhs ;
  int_spec_t *post_sign_changed ;
  int_spec_t const   *pre_sign_changed ;
  int_type tmp ;
  int_type tmp___0 ;
  int_type tmp___1 ;
  char *orig ;
  char *tmp___2 ;
  char *converted ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp18 ;

  {
#line 143
  lhs = (int_type )l->type;
#line 144
  rhs = (int_type )r->type;
#line 145
  post_sign_changed = (int_spec_t *)((void *)0);
#line 146
  pre_sign_changed = (int_spec_t const   *)((void *)0);
#line 149
  *cl = (int_spec_t )*l;
#line 150
  *cr = (int_spec_t )*r;
#line 153
  if ((unsigned int )lhs == (unsigned int )rhs) {
#line 154
    return;
  }
#line 159
  if (((unsigned int )lhs & 1U) == ((unsigned int )rhs & 1U)) {
#line 160
    if ((unsigned int )lhs >> 16 > (unsigned int )rhs >> 16) {
#line 160
      tmp = lhs;
    } else {
#line 160
      tmp = rhs;
    }
#line 160
    cr->type = tmp;
#line 160
    cl->type = tmp;
#line 161
    return;
  }
#line 168
  if (! ((unsigned int )lhs & 1U)) {
#line 168
    if ((unsigned int )lhs >> 16 >= (unsigned int )rhs >> 16) {
#line 169
      post_sign_changed = cr;
#line 170
      pre_sign_changed = r;
#line 171
      cr->type = cl->type;
    } else {
#line 168
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 173
  if (! ((unsigned int )rhs & 1U)) {
#line 173
    if ((unsigned int )rhs >> 16 >= (unsigned int )lhs >> 16) {
#line 174
      post_sign_changed = cl;
#line 175
      pre_sign_changed = l;
#line 176
      cl->type = cr->type;
    } else {
#line 173
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 182
  if ((unsigned int )lhs & 1U) {
#line 182
    if ((((unsigned int )lhs >> 8) & 4294902015U) > (((unsigned int )rhs >> 8) & 4294902015U)) {
#line 183
      post_sign_changed = cr;
#line 184
      pre_sign_changed = r;
#line 185
      cr->type = cl->type;
    } else {
#line 182
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 187
  if ((unsigned int )rhs & 1U) {
#line 187
    if ((((unsigned int )rhs >> 8) & 4294902015U) > (((unsigned int )lhs >> 8) & 4294902015U)) {
#line 188
      post_sign_changed = cl;
#line 189
      pre_sign_changed = l;
#line 190
      cl->type = cr->type;
    } else {
#line 187
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 194
  if ((unsigned int )lhs & 1U) {
#line 195
    post_sign_changed = cl;
#line 196
    pre_sign_changed = l;
#line 197
    tmp___0 = (int_type )((unsigned int )lhs & 4294967294U);
#line 197
    cr->type = tmp___0;
#line 197
    cl->type = tmp___0;
  } else
#line 200
  if ((unsigned int )rhs & 1U) {
#line 201
    post_sign_changed = cr;
#line 202
    pre_sign_changed = r;
#line 203
    tmp___1 = (int_type )((unsigned int )rhs & 4294967294U);
#line 203
    cr->type = tmp___1;
#line 203
    cl->type = tmp___1;
  }
#line 205
  if (post_sign_changed) {
    {
    {
#line 206
    sign_extend(post_sign_changed, pre_sign_changed);
    }
    {
#line 207
    tmp___4 = sign((int_spec_t const   *)post_sign_changed);
    }
    {
#line 207
    tmp___5 = sign(pre_sign_changed);
    }
    }
#line 207
    if (tmp___4 != tmp___5) {
      {
      {
#line 208
      tmp___2 = format_int(pre_sign_changed);
      }
#line 208
      orig = tmp___2;
      {
#line 209
      tmp___3 = format_int((int_spec_t const   *)post_sign_changed);
      }
#line 209
      converted = tmp___3;
      {
#line 210
      report((reason_code_t )9280, (heap_str *)((void *)0), "Integer %s changed to %s by the usual arithmetic conversions",
             orig, converted);
      }
      {
#line 212
      free((void *)orig);
      }
      {
#line 213
      free((void *)converted);
      }
      }
    }
  }
#line 216
  return;
}
}
#line 226 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.c"
static _Bool check_shift_validity(char const   *direction , int_type type , int_spec_t const   *shiftval ) 
{ 
  _Bool ok ;
  unsigned int type_bits ;
  unsigned long long val ;
  unsigned long long neg_bit ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 229
  ok = (_Bool)1;
#line 230
  type_bits = (((unsigned int )type >> 8) & 4294902015U) * 8U;
#line 231
  val = (unsigned long long )shiftval->val.ull;
#line 232
  if ((unsigned int const   )shiftval->type & 1U) {
#line 233
    neg_bit = (unsigned long long )(1 << (type_bits - 1U));
#line 234
    if (val & neg_bit) {
      {
      {
#line 235
      report((reason_code_t )9248, (heap_str *)((void *)0), "Negative %s-shift has undefined behavior. The expression will not be resolved",
             direction);
      }
#line 237
      ok = (_Bool)0;
      }
    }
  }
#line 240
  if (ok) {
#line 240
    if (val >= (unsigned long long )type_bits) {
      {
      {
#line 241
      report((reason_code_t )9296, (heap_str *)((void *)0), "Shifting a quantity passed its width has undefined behavior. The expression will not be resolved");
      }
#line 242
      ok = (_Bool)0;
      }
    }
  }
#line 244
  return (ok);
}
}
#line 251 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.c"
int_spec_t lt(int_spec_t const   *l , int_spec_t const   *r ) 
{ 
  int_spec_t result ;
  int_spec_t cl ;
  int_spec_t cr ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 254
  result.val.ll = 0LL;
#line 254
  result.type = (int_type )197633;
  {
#line 256
  do_usual_conversions(l, r, & cl, & cr);
  }
#line 257
  result.type = cl.type;
  }
  {
#line 259
  if ((unsigned int )result.type == 197633U) {
#line 259
    goto case_197633;
  }
#line 262
  if ((unsigned int )result.type == 197632U) {
#line 262
    goto case_197632;
  }
#line 265
  if ((unsigned int )result.type == 264193U) {
#line 265
    goto case_264193;
  }
#line 268
  if ((unsigned int )result.type == 264192U) {
#line 268
    goto case_264192;
  }
#line 271
  if ((unsigned int )result.type == 329729U) {
#line 271
    goto case_329729;
  }
#line 274
  if ((unsigned int )result.type == 329728U) {
#line 274
    goto case_329728;
  }
#line 277
  goto switch_default;
  case_197633: /* CIL Label */ 
#line 260
  result.val.i = cl.val.i < cr.val.i;
#line 261
  goto switch_break;
  case_197632: /* CIL Label */ 
#line 263
  result.val.i = cl.val.ui < cr.val.ui;
#line 264
  goto switch_break;
  case_264193: /* CIL Label */ 
#line 266
  result.val.i = cl.val.l < cr.val.l;
#line 267
  goto switch_break;
  case_264192: /* CIL Label */ 
#line 269
  result.val.i = cl.val.ul < cr.val.ul;
#line 270
  goto switch_break;
  case_329729: /* CIL Label */ 
#line 272
  result.val.i = cl.val.ll < cr.val.ll;
#line 273
  goto switch_break;
  case_329728: /* CIL Label */ 
#line 275
  result.val.i = cl.val.ull < cr.val.ull;
#line 276
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 278
  __assert_fail("0", "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.c", 278U,
                "lt");
  }
  }
  switch_break: /* CIL Label */ ;
  }
#line 280
  return (result);
}
}
#line 283 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.c"
int_spec_t gt(int_spec_t const   *l , int_spec_t const   *r ) 
{ 
  int_spec_t tmp ;

  {
  {
  {
#line 286
  tmp = lt(r, l);
  }
  }
#line 286
  return (tmp);
}
}
#line 289 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.c"
int_spec_t le(int_spec_t const   *l , int_spec_t const   *r ) 
{ 
  int_spec_t result ;
  int_spec_t cl ;
  int_spec_t cr ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 292
  result.val.ll = 0LL;
#line 292
  result.type = (int_type )0;
  {
#line 294
  do_usual_conversions(l, r, & cl, & cr);
  }
#line 295
  result.type = cl.type;
  }
  {
#line 297
  if ((unsigned int )result.type == 197633U) {
#line 297
    goto case_197633;
  }
#line 300
  if ((unsigned int )result.type == 197632U) {
#line 300
    goto case_197632;
  }
#line 303
  if ((unsigned int )result.type == 264193U) {
#line 303
    goto case_264193;
  }
#line 306
  if ((unsigned int )result.type == 264192U) {
#line 306
    goto case_264192;
  }
#line 309
  if ((unsigned int )result.type == 329729U) {
#line 309
    goto case_329729;
  }
#line 312
  if ((unsigned int )result.type == 329728U) {
#line 312
    goto case_329728;
  }
#line 315
  goto switch_default;
  case_197633: /* CIL Label */ 
#line 298
  result.val.i = cl.val.i <= cr.val.i;
#line 299
  goto switch_break;
  case_197632: /* CIL Label */ 
#line 301
  result.val.i = cl.val.ui <= cr.val.ui;
#line 302
  goto switch_break;
  case_264193: /* CIL Label */ 
#line 304
  result.val.i = cl.val.l <= cr.val.l;
#line 305
  goto switch_break;
  case_264192: /* CIL Label */ 
#line 307
  result.val.i = cl.val.ul <= cr.val.ul;
#line 308
  goto switch_break;
  case_329729: /* CIL Label */ 
#line 310
  result.val.i = cl.val.ll <= cr.val.ll;
#line 311
  goto switch_break;
  case_329728: /* CIL Label */ 
#line 313
  result.val.i = cl.val.ull <= cr.val.ull;
#line 314
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 316
  __assert_fail("0", "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.c", 316U,
                "le");
  }
  }
  switch_break: /* CIL Label */ ;
  }
#line 318
  return (result);
}
}
#line 321 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.c"
int_spec_t ge(int_spec_t const   *l , int_spec_t const   *r ) 
{ 
  int_spec_t tmp ;

  {
  {
  {
#line 324
  tmp = le(r, l);
  }
  }
#line 324
  return (tmp);
}
}
#line 327 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.c"
int_spec_t eq(int_spec_t const   *l , int_spec_t const   *r ) 
{ 
  int_spec_t result ;

  {
#line 330
  result.val.ll = 0LL;
#line 330
  result.type = (int_type )197633;
#line 331
  result.val.i = l->val.ll == r->val.ll;
#line 332
  return (result);
}
}
#line 335 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.c"
int_spec_t ne(int_spec_t const   *l , int_spec_t const   *r ) 
{ 
  int_spec_t result ;

  {
#line 338
  result.val.ll = 0LL;
#line 338
  result.type = (int_type )197633;
#line 339
  result.val.i = l->val.ll != r->val.ll;
#line 340
  return (result);
}
}
#line 344 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.c"
int_spec_t bit_and(int_spec_t const   *l , int_spec_t const   *r ) 
{ 
  int_spec_t result ;
  int_spec_t cl ;
  int_spec_t cr ;

  {
  {
#line 347
  result.val.ll = 0LL;
#line 347
  result.type = (int_type )0;
  {
#line 349
  do_usual_conversions(l, r, & cl, & cr);
  }
#line 350
  result.type = cl.type;
#line 351
  result.val.ll = cl.val.ll & cr.val.ll;
  }
#line 352
  return (result);
}
}
#line 355 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.c"
int_spec_t bit_or(int_spec_t const   *l , int_spec_t const   *r ) 
{ 
  int_spec_t result ;
  int_spec_t cl ;
  int_spec_t cr ;

  {
  {
#line 358
  result.val.ll = 0LL;
#line 358
  result.type = (int_type )0;
  {
#line 360
  do_usual_conversions(l, r, & cl, & cr);
  }
#line 361
  result.type = cl.type;
#line 362
  result.val.ll = cl.val.ll | cr.val.ll;
  }
#line 363
  return (result);
}
}
#line 366 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.c"
int_spec_t bit_xor(int_spec_t const   *l , int_spec_t const   *r ) 
{ 
  int_spec_t result ;
  int_spec_t cl ;
  int_spec_t cr ;

  {
  {
#line 369
  result.val.ll = 0LL;
#line 369
  result.type = (int_type )0;
  {
#line 371
  do_usual_conversions(l, r, & cl, & cr);
  }
#line 372
  result.type = cl.type;
#line 373
  result.val.ll = cl.val.ll ^ cr.val.ll;
  }
#line 374
  return (result);
}
}
#line 377 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.c"
int_spec_t complement(int_spec_t const   *int_spec ) 
{ 
  int_spec_t result ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 380
  result.val.ll = 0LL;
#line 380
  result.type = (int_type )0;
#line 381
  result.type = (int_type )int_spec->type;
  {
#line 384
  if ((unsigned int )result.type == 197632U) {
#line 384
    goto case_197632;
  }
#line 384
  if ((unsigned int )result.type == 197633U) {
#line 384
    goto case_197632;
  }
#line 388
  if ((unsigned int )result.type == 264192U) {
#line 388
    goto case_264192;
  }
#line 388
  if ((unsigned int )result.type == 264193U) {
#line 388
    goto case_264192;
  }
#line 392
  if ((unsigned int )result.type == 329728U) {
#line 392
    goto case_329728;
  }
#line 392
  if ((unsigned int )result.type == 329729U) {
#line 392
    goto case_329728;
  }
#line 394
  goto switch_default;
  case_197632: /* CIL Label */ 
  case_197633: /* CIL Label */ 
#line 385
  result.val.ui = (unsigned int )(~ int_spec->val.ui);
#line 386
  goto switch_break;
  case_264192: /* CIL Label */ 
  case_264193: /* CIL Label */ 
#line 389
  result.val.ul = (unsigned long )(~ int_spec->val.ul);
#line 390
  goto switch_break;
  case_329728: /* CIL Label */ 
  case_329729: /* CIL Label */ 
#line 393
  result.val.ull = (unsigned long long )(~ int_spec->val.ull);
  switch_default: /* CIL Label */ 
  {
  {
#line 395
  __assert_fail("0", "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.c", 395U,
                "complement");
  }
  }
  switch_break: /* CIL Label */ ;
  }
#line 397
  return (result);
}
}
#line 400 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.c"
int_spec_t minus(int_spec_t const   *int_spec ) 
{ 
  int_spec_t result ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 403
  result.val.ll = 0LL;
#line 403
  result.type = (int_type )0;
#line 404
  result.type = (int_type )int_spec->type;
  {
#line 406
  if ((unsigned int )result.type == 197633U) {
#line 406
    goto case_197633;
  }
#line 409
  if ((unsigned int )result.type == 197632U) {
#line 409
    goto case_197632;
  }
#line 412
  if ((unsigned int )result.type == 264193U) {
#line 412
    goto case_264193;
  }
#line 415
  if ((unsigned int )result.type == 264192U) {
#line 415
    goto case_264192;
  }
#line 418
  if ((unsigned int )result.type == 329729U) {
#line 418
    goto case_329729;
  }
#line 421
  if ((unsigned int )result.type == 329728U) {
#line 421
    goto case_329728;
  }
#line 424
  goto switch_default;
  case_197633: /* CIL Label */ 
#line 407
  result.val.i = (int )(- int_spec->val.i);
#line 408
  goto switch_break;
  case_197632: /* CIL Label */ 
#line 410
  result.val.ui = (unsigned int )(- int_spec->val.ui);
#line 411
  goto switch_break;
  case_264193: /* CIL Label */ 
#line 413
  result.val.l = (long )(- int_spec->val.l);
#line 414
  goto switch_break;
  case_264192: /* CIL Label */ 
#line 416
  result.val.ul = (unsigned long )(- int_spec->val.ul);
#line 417
  goto switch_break;
  case_329729: /* CIL Label */ 
#line 419
  result.val.ll = (long long )(- int_spec->val.ll);
#line 420
  goto switch_break;
  case_329728: /* CIL Label */ 
#line 422
  result.val.ull = (unsigned long long )(- int_spec->val.ull);
#line 423
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 425
  __assert_fail("0", "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.c", 425U,
                "minus");
  }
  }
  switch_break: /* CIL Label */ ;
  }
#line 427
  return (result);
}
}
#line 430 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.c"
int_spec_t lshift(int_spec_t const   *l , int_spec_t const   *r ) 
{ 
  int_spec_t result ;
  int_type type ;
  _Bool valid_shift ;
  _Bool tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 433
  result.val.ll = 0LL;
#line 433
  result.type = (int_type )0;
#line 434
  type = (int_type )l->type;
  {
#line 435
  tmp = check_shift_validity("left", type, r);
  }
#line 435
  valid_shift = tmp;
  }
#line 436
  if (valid_shift) {
#line 437
    result.type = type;
    {
#line 439
    if ((unsigned int )type == 197633U) {
#line 439
      goto case_197633;
    }
#line 442
    if ((unsigned int )type == 197632U) {
#line 442
      goto case_197632;
    }
#line 445
    if ((unsigned int )type == 264193U) {
#line 445
      goto case_264193;
    }
#line 448
    if ((unsigned int )type == 264192U) {
#line 448
      goto case_264192;
    }
#line 451
    if ((unsigned int )type == 329729U) {
#line 451
      goto case_329729;
    }
#line 454
    if ((unsigned int )type == 329728U) {
#line 454
      goto case_329728;
    }
#line 457
    goto switch_default;
    case_197633: /* CIL Label */ 
#line 440
    result.val.i = (int )(l->val.i << r->val.i);
#line 441
    goto switch_break;
    case_197632: /* CIL Label */ 
#line 443
    result.val.ui = (unsigned int )(l->val.ui << r->val.i);
#line 444
    goto switch_break;
    case_264193: /* CIL Label */ 
#line 446
    result.val.l = (long )(l->val.l << r->val.i);
#line 447
    goto switch_break;
    case_264192: /* CIL Label */ 
#line 449
    result.val.ul = (unsigned long )(l->val.ul << r->val.i);
#line 450
    goto switch_break;
    case_329729: /* CIL Label */ 
#line 452
    result.val.ll = (long long )(l->val.ll << r->val.i);
#line 453
    goto switch_break;
    case_329728: /* CIL Label */ 
#line 455
    result.val.ull = (unsigned long long )(l->val.ull << r->val.i);
#line 456
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    {
#line 458
    __assert_fail("0", "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.c", 458U,
                  "lshift");
    }
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 461
  return (result);
}
}
#line 464 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.c"
int_spec_t rshift(int_spec_t const   *l , int_spec_t const   *r ) 
{ 
  int_spec_t result ;
  int_type type ;
  _Bool valid_shift ;
  _Bool tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 467
  result.val.ll = 0LL;
#line 467
  result.type = (int_type )0;
#line 468
  type = (int_type )l->type;
  {
#line 469
  tmp = check_shift_validity("left", type, r);
  }
#line 469
  valid_shift = tmp;
  }
#line 470
  if (valid_shift) {
#line 471
    result.type = type;
    {
#line 473
    if ((unsigned int )type == 197633U) {
#line 473
      goto case_197633;
    }
#line 476
    if ((unsigned int )type == 197632U) {
#line 476
      goto case_197632;
    }
#line 479
    if ((unsigned int )type == 264193U) {
#line 479
      goto case_264193;
    }
#line 482
    if ((unsigned int )type == 264192U) {
#line 482
      goto case_264192;
    }
#line 485
    if ((unsigned int )type == 329729U) {
#line 485
      goto case_329729;
    }
#line 488
    if ((unsigned int )type == 329728U) {
#line 488
      goto case_329728;
    }
#line 491
    goto switch_default;
    case_197633: /* CIL Label */ 
#line 474
    result.val.i = (int )(l->val.i >> r->val.i);
#line 475
    goto switch_break;
    case_197632: /* CIL Label */ 
#line 477
    result.val.ui = (unsigned int )(l->val.ui >> r->val.i);
#line 478
    goto switch_break;
    case_264193: /* CIL Label */ 
#line 480
    result.val.l = (long )(l->val.l >> r->val.i);
#line 481
    goto switch_break;
    case_264192: /* CIL Label */ 
#line 483
    result.val.ul = (unsigned long )(l->val.ul >> r->val.i);
#line 484
    goto switch_break;
    case_329729: /* CIL Label */ 
#line 486
    result.val.ll = (long long )(l->val.ll >> r->val.i);
#line 487
    goto switch_break;
    case_329728: /* CIL Label */ 
#line 489
    result.val.ull = (unsigned long long )(l->val.ull >> r->val.i);
#line 490
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    {
#line 492
    __assert_fail("0", "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.c", 492U,
                  "rshift");
    }
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 495
  return (result);
}
}
#line 498 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.c"
int_spec_t add(int_spec_t const   *l , int_spec_t const   *r ) 
{ 
  int_spec_t result ;
  int_spec_t cl ;
  int_spec_t cr ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 501
  result.val.ll = 0LL;
#line 501
  result.type = (int_type )0;
  {
#line 503
  do_usual_conversions(l, r, & cl, & cr);
  }
#line 504
  result.type = cl.type;
  }
  {
#line 506
  if ((unsigned int )result.type == 197633U) {
#line 506
    goto case_197633;
  }
#line 509
  if ((unsigned int )result.type == 197632U) {
#line 509
    goto case_197632;
  }
#line 512
  if ((unsigned int )result.type == 264193U) {
#line 512
    goto case_264193;
  }
#line 515
  if ((unsigned int )result.type == 264192U) {
#line 515
    goto case_264192;
  }
#line 518
  if ((unsigned int )result.type == 329729U) {
#line 518
    goto case_329729;
  }
#line 521
  if ((unsigned int )result.type == 329728U) {
#line 521
    goto case_329728;
  }
#line 524
  goto switch_default;
  case_197633: /* CIL Label */ 
#line 507
  result.val.i = cl.val.i + cr.val.i;
#line 508
  goto switch_break;
  case_197632: /* CIL Label */ 
#line 510
  result.val.ui = cl.val.ui + cr.val.ui;
#line 511
  goto switch_break;
  case_264193: /* CIL Label */ 
#line 513
  result.val.l = cl.val.l + cr.val.l;
#line 514
  goto switch_break;
  case_264192: /* CIL Label */ 
#line 516
  result.val.ul = cl.val.ul + cr.val.ul;
#line 517
  goto switch_break;
  case_329729: /* CIL Label */ 
#line 519
  result.val.ll = cl.val.ll + cr.val.ll;
#line 520
  goto switch_break;
  case_329728: /* CIL Label */ 
#line 522
  result.val.ull = cl.val.ull + cr.val.ull;
#line 523
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 525
  __assert_fail("0", "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.c", 525U,
                "add");
  }
  }
  switch_break: /* CIL Label */ ;
  }
#line 527
  return (result);
}
}
#line 530 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.c"
int_spec_t subtract(int_spec_t const   *l , int_spec_t const   *r ) 
{ 
  int_spec_t result ;
  int_spec_t cl ;
  int_spec_t cr ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 533
  result.val.ll = 0LL;
#line 533
  result.type = (int_type )0;
  {
#line 535
  do_usual_conversions(l, r, & cl, & cr);
  }
#line 536
  result.type = cl.type;
  }
  {
#line 538
  if ((unsigned int )result.type == 197633U) {
#line 538
    goto case_197633;
  }
#line 541
  if ((unsigned int )result.type == 197632U) {
#line 541
    goto case_197632;
  }
#line 544
  if ((unsigned int )result.type == 264193U) {
#line 544
    goto case_264193;
  }
#line 547
  if ((unsigned int )result.type == 264192U) {
#line 547
    goto case_264192;
  }
#line 550
  if ((unsigned int )result.type == 329729U) {
#line 550
    goto case_329729;
  }
#line 553
  if ((unsigned int )result.type == 329728U) {
#line 553
    goto case_329728;
  }
#line 556
  goto switch_default;
  case_197633: /* CIL Label */ 
#line 539
  result.val.i = cl.val.i - cr.val.i;
#line 540
  goto switch_break;
  case_197632: /* CIL Label */ 
#line 542
  result.val.ui = cl.val.ui - cr.val.ui;
#line 543
  goto switch_break;
  case_264193: /* CIL Label */ 
#line 545
  result.val.l = cl.val.l - cr.val.l;
#line 546
  goto switch_break;
  case_264192: /* CIL Label */ 
#line 548
  result.val.ul = cl.val.ul - cr.val.ul;
#line 549
  goto switch_break;
  case_329729: /* CIL Label */ 
#line 551
  result.val.ll = cl.val.ll - cr.val.ll;
#line 552
  goto switch_break;
  case_329728: /* CIL Label */ 
#line 554
  result.val.ull = cl.val.ull - cr.val.ull;
#line 555
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 557
  __assert_fail("0", "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.c", 557U,
                "subtract");
  }
  }
  switch_break: /* CIL Label */ ;
  }
#line 559
  return (result);
}
}
#line 562 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.c"
int_spec_t multiply(int_spec_t const   *l , int_spec_t const   *r ) 
{ 
  int_spec_t result ;
  int_spec_t cl ;
  int_spec_t cr ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 565
  result.val.ll = 0LL;
#line 565
  result.type = (int_type )0;
  {
#line 567
  do_usual_conversions(l, r, & cl, & cr);
  }
#line 568
  result.type = cl.type;
  }
  {
#line 570
  if ((unsigned int )result.type == 197633U) {
#line 570
    goto case_197633;
  }
#line 573
  if ((unsigned int )result.type == 197632U) {
#line 573
    goto case_197632;
  }
#line 576
  if ((unsigned int )result.type == 264193U) {
#line 576
    goto case_264193;
  }
#line 579
  if ((unsigned int )result.type == 264192U) {
#line 579
    goto case_264192;
  }
#line 582
  if ((unsigned int )result.type == 329729U) {
#line 582
    goto case_329729;
  }
#line 585
  if ((unsigned int )result.type == 329728U) {
#line 585
    goto case_329728;
  }
#line 588
  goto switch_default;
  case_197633: /* CIL Label */ 
#line 571
  result.val.i = cl.val.i * cr.val.i;
#line 572
  goto switch_break;
  case_197632: /* CIL Label */ 
#line 574
  result.val.ui = cl.val.ui * cr.val.ui;
#line 575
  goto switch_break;
  case_264193: /* CIL Label */ 
#line 577
  result.val.l = cl.val.l * cr.val.l;
#line 578
  goto switch_break;
  case_264192: /* CIL Label */ 
#line 580
  result.val.ul = cl.val.ul * cr.val.ul;
#line 581
  goto switch_break;
  case_329729: /* CIL Label */ 
#line 583
  result.val.ll = cl.val.ll * cr.val.ll;
#line 584
  goto switch_break;
  case_329728: /* CIL Label */ 
#line 586
  result.val.ull = cl.val.ull * cr.val.ull;
#line 587
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 589
  __assert_fail("0", "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.c", 589U,
                "multiply");
  }
  }
  switch_break: /* CIL Label */ ;
  }
#line 591
  return (result);
}
}
#line 594 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.c"
int_spec_t divide(int_spec_t const   *l , int_spec_t const   *r ) 
{ 
  int_spec_t result ;
  int_spec_t cl ;
  int_spec_t cr ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 597
  result.val.ll = 0LL;
#line 597
  result.type = (int_type )0;
  {
#line 599
  do_usual_conversions(l, r, & cl, & cr);
  }
#line 600
  result.type = cl.type;
  }
  {
#line 602
  if ((unsigned int )result.type == 197633U) {
#line 602
    goto case_197633;
  }
#line 605
  if ((unsigned int )result.type == 197632U) {
#line 605
    goto case_197632;
  }
#line 608
  if ((unsigned int )result.type == 264193U) {
#line 608
    goto case_264193;
  }
#line 611
  if ((unsigned int )result.type == 264192U) {
#line 611
    goto case_264192;
  }
#line 614
  if ((unsigned int )result.type == 329729U) {
#line 614
    goto case_329729;
  }
#line 617
  if ((unsigned int )result.type == 329728U) {
#line 617
    goto case_329728;
  }
#line 620
  goto switch_default;
  case_197633: /* CIL Label */ 
#line 603
  result.val.i = cl.val.i / cr.val.i;
#line 604
  goto switch_break;
  case_197632: /* CIL Label */ 
#line 606
  result.val.ui = cl.val.ui / cr.val.ui;
#line 607
  goto switch_break;
  case_264193: /* CIL Label */ 
#line 609
  result.val.l = cl.val.l / cr.val.l;
#line 610
  goto switch_break;
  case_264192: /* CIL Label */ 
#line 612
  result.val.ul = cl.val.ul / cr.val.ul;
#line 613
  goto switch_break;
  case_329729: /* CIL Label */ 
#line 615
  result.val.ll = cl.val.ll / cr.val.ll;
#line 616
  goto switch_break;
  case_329728: /* CIL Label */ 
#line 618
  result.val.ull = cl.val.ull / cr.val.ull;
#line 619
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 621
  __assert_fail("0", "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.c", 621U,
                "divide");
  }
  }
  switch_break: /* CIL Label */ ;
  }
#line 623
  return (result);
}
}
#line 626 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.c"
int_spec_t modulus(int_spec_t const   *l , int_spec_t const   *r ) 
{ 
  int_spec_t result ;
  int_spec_t cl ;
  int_spec_t cr ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 629
  result.val.ll = 0LL;
#line 629
  result.type = (int_type )0;
  {
#line 631
  do_usual_conversions(l, r, & cl, & cr);
  }
#line 632
  result.type = cl.type;
  }
  {
#line 634
  if ((unsigned int )result.type == 197633U) {
#line 634
    goto case_197633;
  }
#line 637
  if ((unsigned int )result.type == 197632U) {
#line 637
    goto case_197632;
  }
#line 640
  if ((unsigned int )result.type == 264193U) {
#line 640
    goto case_264193;
  }
#line 643
  if ((unsigned int )result.type == 264192U) {
#line 643
    goto case_264192;
  }
#line 646
  if ((unsigned int )result.type == 329729U) {
#line 646
    goto case_329729;
  }
#line 649
  if ((unsigned int )result.type == 329728U) {
#line 649
    goto case_329728;
  }
#line 652
  goto switch_default;
  case_197633: /* CIL Label */ 
#line 635
  result.val.i = cl.val.i % cr.val.i;
#line 636
  goto switch_break;
  case_197632: /* CIL Label */ 
#line 638
  result.val.ui = cl.val.ui % cr.val.ui;
#line 639
  goto switch_break;
  case_264193: /* CIL Label */ 
#line 641
  result.val.l = cl.val.l % cr.val.l;
#line 642
  goto switch_break;
  case_264192: /* CIL Label */ 
#line 644
  result.val.ul = cl.val.ul % cr.val.ul;
#line 645
  goto switch_break;
  case_329729: /* CIL Label */ 
#line 647
  result.val.ll = cl.val.ll % cr.val.ll;
#line 648
  goto switch_break;
  case_329728: /* CIL Label */ 
#line 650
  result.val.ull = cl.val.ull % cr.val.ull;
#line 651
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 653
  __assert_fail("0", "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.c", 653U,
                "modulus");
  }
  }
  switch_break: /* CIL Label */ ;
  }
#line 655
  return (result);
}
}
#line 663 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.c"
int_spec_t boolean_and(int_spec_t const   *l , int_spec_t const   *r ) 
{ 
  int_spec_t result ;
  int tmp ;

  {
#line 666
  result.val.ll = 0LL;
#line 666
  result.type = (int_type )197633;
#line 667
  if (l->val.ull) {
#line 667
    if (r->val.ull) {
#line 667
      tmp = 1;
    } else {
#line 667
      tmp = 0;
    }
  } else {
#line 667
    tmp = 0;
  }
#line 667
  result.val.i = tmp;
#line 668
  return (result);
}
}
#line 676 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.c"
int_spec_t boolean_or(int_spec_t const   *l , int_spec_t const   *r ) 
{ 
  int_spec_t result ;
  int tmp ;

  {
#line 679
  result.val.ll = 0LL;
#line 679
  result.type = (int_type )197633;
#line 680
  if (l->val.ull) {
#line 680
    tmp = 1;
  } else
#line 680
  if (r->val.ull) {
#line 680
    tmp = 1;
  } else {
#line 680
    tmp = 0;
  }
#line 680
  result.val.i = tmp;
#line 681
  return (result);
}
}
#line 689 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_ops.c"
int_spec_t negate(int_spec_t const   *int_spec ) 
{ 
  int_spec_t result ;

  {
#line 692
  result.val.ll = 0LL;
#line 692
  result.type = (int_type )197633;
#line 693
  result.val.i = ! int_spec->val.ull;
#line 694
  return (result);
}
}
#line 77 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_constant.h"
int_spec_t eval_numeral(char const   *num , char const   **numend ) ;
#line 89
int_spec_t eval_character_constant(char const   **cpp ) ;
#line 79 "/home/wslee/tests/SOURCES/coan-4.2.2/src/memory.h"
void release(void **pp ) ;
#line 128 "/home/wslee/tests/SOURCES/coan-4.2.2/src/chew.h"
char const   *chew_continuation(char const   *cp ) ;
#line 70 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_constant.c"
static int char_escape_val(char const   **cpp ) 
{ 
  int val ;
  char const   *cp ;

  {
#line 73
  val = -1;
#line 74
  cp = *cpp;
#line 75
  if ((int const   )*cp == 92) {
    {
#line 76
    cp ++;
    {
#line 76
    cp = chew_continuation(cp);
    }
    }
    {
#line 78
    if ((int const   )*cp == 0) {
#line 78
      goto case_0;
    }
#line 80
    if ((int const   )*cp == 97) {
#line 80
      goto case_97;
    }
#line 83
    if ((int const   )*cp == 98) {
#line 83
      goto case_98;
    }
#line 86
    if ((int const   )*cp == 102) {
#line 86
      goto case_102;
    }
#line 89
    if ((int const   )*cp == 110) {
#line 89
      goto case_110;
    }
#line 92
    if ((int const   )*cp == 114) {
#line 92
      goto case_114;
    }
#line 95
    if ((int const   )*cp == 116) {
#line 95
      goto case_116;
    }
#line 98
    if ((int const   )*cp == 118) {
#line 98
      goto case_118;
    }
#line 101
    goto switch_default;
    case_0: /* CIL Label */ 
#line 79
    goto switch_break;
    case_97: /* CIL Label */ 
#line 81
    val = '\a';
#line 82
    goto switch_break;
    case_98: /* CIL Label */ 
#line 84
    val = '\b';
#line 85
    goto switch_break;
    case_102: /* CIL Label */ 
#line 87
    val = '\f';
#line 88
    goto switch_break;
    case_110: /* CIL Label */ 
#line 90
    val = '\n';
#line 91
    goto switch_break;
    case_114: /* CIL Label */ 
#line 93
    val = '\r';
#line 94
    goto switch_break;
    case_116: /* CIL Label */ 
#line 96
    val = '\t';
#line 97
    goto switch_break;
    case_118: /* CIL Label */ 
#line 99
    val = '\v';
#line 100
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 102
    val = (int )*cp;
    switch_break: /* CIL Label */ ;
    }
    {
#line 104
    cp ++;
    {
#line 104
    cp = chew_continuation(cp);
    }
    }
  } else
#line 105
  if (*cp) {
    {
#line 106
    val = (int )*cp;
#line 107
    cp ++;
    {
#line 107
    cp = chew_continuation(cp);
    }
    }
  }
#line 109
  *cpp = cp;
#line 110
  return (val);
}
}
#line 122 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_constant.c"
static unsigned long long decode_utf8(char const   **cpp ) 
{ 
  unsigned long long val ;
  char const   *cp ;
  size_t bytes ;
  unsigned int byte1 ;
  unsigned int byte2 ;
  unsigned int byte3 ;
  unsigned int byte4 ;

  {
#line 125
  val = 0xffffffffffffffffULL;
#line 126
  cp = *cpp;
#line 127
  bytes = (size_t )0;
#line 128
  byte1 = (unsigned int )((int const   )*cp & 255);
#line 130
  if (byte1 == 4294967295U) {
#line 131
    bytes = (size_t )0;
  } else
#line 132
  if (byte1 >> 7 == 0U) {
#line 134
    bytes = (size_t )1;
  } else
#line 135
  if (byte1 >> 5 == 6U) {
#line 137
    bytes = (size_t )2;
  } else
#line 138
  if (byte1 >> 4 == 14U) {
#line 140
    bytes = (size_t )3;
  } else
#line 141
  if (bytes >> 3 == 30UL) {
#line 143
    bytes = (size_t )4;
  }
  {
#line 146
  if (bytes == 1UL) {
#line 146
    goto case_1;
  }
#line 150
  if (bytes == 2UL) {
#line 150
    goto case_2;
  }
#line 161
  if (bytes == 3UL) {
#line 161
    goto case_3;
  }
#line 176
  if (bytes == 4UL) {
#line 176
    goto case_4;
  }
#line 196
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 147
  val = (unsigned long long )byte1;
#line 148
  cp ++;
  {
#line 148
  *cpp = chew_continuation(cp);
  }
  }
#line 149
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 151
  byte1 &= 31U;
#line 152
  cp ++;
  {
#line 152
  cp = chew_continuation(cp);
  }
#line 152
  byte2 = (unsigned int )(255 & (int )*cp);
  }
#line 153
  if (byte2 == 4294967295U) {
#line 154
    goto switch_break;
  } else
#line 153
  if (byte2 >> 6 != 2U) {
#line 154
    goto switch_break;
  }
  {
#line 156
  byte2 &= 63U;
#line 158
  val = (unsigned long long )((byte1 << 6) | byte2);
#line 159
  cp ++;
  {
#line 159
  *cpp = chew_continuation(cp);
  }
  }
#line 160
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 162
  byte1 &= 31U;
#line 163
  cp ++;
  {
#line 163
  cp = chew_continuation(cp);
  }
#line 163
  byte2 = (unsigned int )(255 & (int )*cp);
  }
#line 164
  if (byte2 == 4294967295U) {
#line 165
    goto switch_break;
  } else
#line 164
  if (byte2 >> 6 != 2U) {
#line 165
    goto switch_break;
  }
  {
#line 167
  byte2 &= 63U;
#line 168
  cp ++;
  {
#line 168
  cp = chew_continuation(cp);
  }
#line 168
  byte3 = (unsigned int )(255 & (int )*cp);
  }
#line 169
  if (byte3 == 4294967295U) {
#line 170
    goto switch_break;
  } else
#line 169
  if (byte3 >> 6 != 2U) {
#line 170
    goto switch_break;
  }
  {
#line 172
  byte3 &= 63U;
#line 173
  val = (unsigned long long )(((byte1 << 12) | (byte2 << 6)) | byte3);
#line 174
  cp ++;
  {
#line 174
  *cpp = chew_continuation(cp);
  }
  }
#line 175
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 177
  byte1 &= 31U;
#line 178
  cp ++;
  {
#line 178
  cp = chew_continuation(cp);
  }
#line 178
  byte2 = (unsigned int )(255 & (int )*cp);
  }
#line 179
  if (byte2 == 4294967295U) {
#line 180
    goto switch_break;
  } else
#line 179
  if (byte2 >> 6 != 2U) {
#line 180
    goto switch_break;
  }
  {
#line 182
  byte2 &= 63U;
#line 183
  cp ++;
  {
#line 183
  cp = chew_continuation(cp);
  }
#line 183
  byte3 = (unsigned int )(255 & (int )*cp);
  }
#line 184
  if (byte3 == 4294967295U) {
#line 185
    goto switch_break;
  } else
#line 184
  if (byte3 >> 6 != 2U) {
#line 185
    goto switch_break;
  }
  {
#line 187
  byte3 &= 63U;
#line 188
  cp ++;
  {
#line 188
  cp = chew_continuation(cp);
  }
#line 188
  byte4 = (unsigned int )(255 & (int )*cp);
  }
#line 189
  if (byte4 == 4294967295U) {
#line 190
    goto switch_break;
  } else
#line 189
  if (byte4 >> 6 != 2U) {
#line 190
    goto switch_break;
  }
  {
#line 192
  byte4 &= 63U;
#line 193
  val = (unsigned long long )((((byte1 << 18) | (byte2 << 12)) | (byte3 << 6)) | byte4);
#line 194
  cp ++;
  {
#line 194
  *cpp = chew_continuation(cp);
  }
  }
#line 195
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 197
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 199
  return (val);
}
}
#line 215 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_constant.c"
static unsigned long long eval_numeral_helper(char const   **pnum , unsigned int base ,
                                              _Bool *overflow ) 
{ 
  char const   *num ;
  int dval ;
  unsigned long long val ;
  unsigned long long tmp ;

  {
#line 218
  num = *pnum;
#line 219
  dval = 0;
#line 220
  val = 0ULL;
#line 222
  *overflow = (_Bool)0;
  {
  {
#line 223
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
#line 225
    if ((int const   )*num == 48) {
#line 225
      goto case_48;
    }
#line 228
    if ((int const   )*num == 49) {
#line 228
      goto case_49;
    }
#line 231
    if ((int const   )*num == 50) {
#line 231
      goto case_50;
    }
#line 234
    if ((int const   )*num == 51) {
#line 234
      goto case_51;
    }
#line 237
    if ((int const   )*num == 52) {
#line 237
      goto case_52;
    }
#line 240
    if ((int const   )*num == 53) {
#line 240
      goto case_53;
    }
#line 243
    if ((int const   )*num == 54) {
#line 243
      goto case_54;
    }
#line 246
    if ((int const   )*num == 55) {
#line 246
      goto case_55;
    }
#line 249
    if ((int const   )*num == 56) {
#line 249
      goto case_56;
    }
#line 252
    if ((int const   )*num == 57) {
#line 252
      goto case_57;
    }
#line 256
    if ((int const   )*num == 65) {
#line 256
      goto case_65;
    }
#line 256
    if ((int const   )*num == 97) {
#line 256
      goto case_65;
    }
#line 260
    if ((int const   )*num == 66) {
#line 260
      goto case_66;
    }
#line 260
    if ((int const   )*num == 98) {
#line 260
      goto case_66;
    }
#line 264
    if ((int const   )*num == 67) {
#line 264
      goto case_67;
    }
#line 264
    if ((int const   )*num == 99) {
#line 264
      goto case_67;
    }
#line 268
    if ((int const   )*num == 68) {
#line 268
      goto case_68;
    }
#line 268
    if ((int const   )*num == 100) {
#line 268
      goto case_68;
    }
#line 272
    if ((int const   )*num == 69) {
#line 272
      goto case_69;
    }
#line 272
    if ((int const   )*num == 101) {
#line 272
      goto case_69;
    }
#line 276
    if ((int const   )*num == 70) {
#line 276
      goto case_70;
    }
#line 276
    if ((int const   )*num == 102) {
#line 276
      goto case_70;
    }
#line 279
    goto switch_default;
    case_48: /* CIL Label */ 
#line 226
    dval = 0;
#line 227
    goto switch_break;
    case_49: /* CIL Label */ 
#line 229
    dval = 1;
#line 230
    goto switch_break;
    case_50: /* CIL Label */ 
#line 232
    dval = 2;
#line 233
    goto switch_break;
    case_51: /* CIL Label */ 
#line 235
    dval = 3;
#line 236
    goto switch_break;
    case_52: /* CIL Label */ 
#line 238
    dval = 4;
#line 239
    goto switch_break;
    case_53: /* CIL Label */ 
#line 241
    dval = 5;
#line 242
    goto switch_break;
    case_54: /* CIL Label */ 
#line 244
    dval = 6;
#line 245
    goto switch_break;
    case_55: /* CIL Label */ 
#line 247
    dval = 7;
#line 248
    goto switch_break;
    case_56: /* CIL Label */ 
#line 250
    dval = 8;
#line 251
    goto switch_break;
    case_57: /* CIL Label */ 
#line 253
    dval = 9;
#line 254
    goto switch_break;
    case_65: /* CIL Label */ 
    case_97: /* CIL Label */ 
#line 257
    dval = 10;
#line 258
    goto switch_break;
    case_66: /* CIL Label */ 
    case_98: /* CIL Label */ 
#line 261
    dval = 11;
#line 262
    goto switch_break;
    case_67: /* CIL Label */ 
    case_99: /* CIL Label */ 
#line 265
    dval = 12;
#line 266
    goto switch_break;
    case_68: /* CIL Label */ 
    case_100: /* CIL Label */ 
#line 269
    dval = 13;
#line 270
    goto switch_break;
    case_69: /* CIL Label */ 
    case_101: /* CIL Label */ 
#line 273
    dval = 14;
#line 274
    goto switch_break;
    case_70: /* CIL Label */ 
    case_102: /* CIL Label */ 
#line 277
    dval = 15;
#line 278
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 280
    dval = 16;
    switch_break: /* CIL Label */ ;
    }
#line 282
    if ((unsigned int )dval < base) {
#line 283
      tmp = val;
#line 284
      val *= (unsigned long long )base;
#line 285
      if (val / (unsigned long long )base != tmp) {
#line 286
        *overflow = (_Bool)1;
      } else
#line 287
      if (dval) {
#line 288
        tmp = val;
#line 289
        val += (unsigned long long )dval;
#line 290
        if (val <= tmp) {
#line 291
          *overflow = (_Bool)1;
        }
      }
    } else {
#line 295
      goto while_break;
    }
    {
#line 223
    num ++;
    {
#line 223
    num = chew_continuation(num);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 298
  *pnum = num;
#line 299
  return (val);
}
}
#line 316 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_constant.c"
static unsigned long long eval_numerical_character_constant(char const   **cpp , int base ) 
{ 
  unsigned long long val ;
  char const   *cp ;
  char prefix ;
  _Bool overflow ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 319
  val = 0xffffffffffffffffULL;
#line 320
  cp = *cpp;
#line 321
  prefix = (char)0;
#line 322
  if (! (base == 8)) {
#line 322
    if (! (base == 16)) {
      {
      {
#line 322
      __assert_fail("base == 8 || base == 16", "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_constant.c",
                    322U, "eval_numerical_character_constant");
      }
      }
    }
  }
#line 323
  if (base == 8) {
#line 324
    prefix = (char )'0';
  } else
#line 325
  if (base == 16) {
#line 326
    prefix = (char )'x';
  } else {
    {
    {
#line 328
    __assert_fail("0", "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_constant.c",
                  328U, "eval_numerical_character_constant");
    }
    }
  }
#line 330
  if ((int const   )*cp == 39) {
    {
#line 331
    cp ++;
    {
#line 331
    cp = chew_continuation(cp);
    }
    }
#line 332
    if ((int const   )*cp == 92) {
      {
#line 332
      cp ++;
      {
#line 332
      cp = chew_continuation(cp);
      }
      }
#line 332
      if ((int const   )*cp == (int const   )prefix) {
        {
#line 334
        cp ++;
        {
#line 334
        cp = chew_continuation(cp);
        }
        {
#line 335
        val = eval_numeral_helper(& cp, (unsigned int )base, & overflow);
        }
        }
#line 336
        if (overflow) {
#line 337
          val = 0xffffffffffffffffULL;
        } else
#line 336
        if (val > 2147483647ULL) {
#line 337
          val = 0xffffffffffffffffULL;
        } else
#line 336
        if ((int const   )*cp != 39) {
#line 337
          val = 0xffffffffffffffffULL;
        } else {
          {
#line 339
          cp ++;
          {
#line 339
          *cpp = chew_continuation(cp);
          }
          }
        }
      }
    }
  }
#line 343
  return (val);
}
}
#line 358 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_constant.c"
static unsigned long long eval_octal_character_constant(char const   **cpp ) 
{ 
  unsigned long long tmp ;

  {
  {
  {
#line 361
  tmp = eval_numerical_character_constant(cpp, 8);
  }
  }
#line 361
  return (tmp);
}
}
#line 376 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_constant.c"
static unsigned long long eval_hex_character_constant(char const   **cpp ) 
{ 
  unsigned long long tmp ;

  {
  {
  {
#line 379
  tmp = eval_numerical_character_constant(cpp, 16);
  }
  }
#line 379
  return (tmp);
}
}
#line 386 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_constant.c"
int_spec_t eval_numeral(char const   *num , char const   **numend ) 
{ 
  int_spec_t result ;
  unsigned int base ;
  unsigned long long val ;
  unsigned long long max_val ;
  _Bool overflow ;
  int_type type ;
  size_t num_len ;
  char const   *start ;
  char const   *int_type___0 ;
  heap_str gripe ;
  _Bool has_suffix ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 389
  result.val.ll = 0LL;
#line 389
  result.type = (int_type )393216;
#line 390
  base = 10U;
#line 391
  max_val = 0xffffffffffffffffULL;
#line 392
  overflow = (_Bool)0;
#line 393
  type = (int_type )329729;
#line 398
  num_len = (size_t )0;
#line 399
  start = num;
#line 400
  int_type___0 = (char const   *)((void *)0);
#line 401
  gripe = (heap_str )((void *)0);
#line 402
  has_suffix = (_Bool)0;
#line 403
  if ((int const   )*num == 0) {
#line 404
    return (result);
  }
#line 406
  if ((int const   )*num == 48) {
    {
#line 407
    num ++;
    {
#line 407
    num = chew_continuation(num);
    }
    }
#line 408
    if ((int const   )*num == 120) {
      {
#line 409
      num ++;
      {
#line 409
      num = chew_continuation(num);
      }
#line 410
      base = 16U;
      }
    } else
#line 408
    if ((int const   )*num == 88) {
      {
#line 409
      num ++;
      {
#line 409
      num = chew_continuation(num);
      }
#line 410
      base = 16U;
      }
    } else {
#line 412
      base = 8U;
    }
  }
  {
  {
#line 415
  val = eval_numeral_helper(& num, base, & overflow);
  }
  }
#line 416
  if (overflow) {
#line 417
    type = (int_type )329728;
#line 418
    int_type___0 = "unsigned long long";
#line 419
    max_val = 0xffffffffffffffffULL;
  }
#line 421
  num_len = (size_t )(num - start);
#line 422
  if (num_len == 1UL) {
#line 422
    if ((int const   )*num == 120) {
#line 423
      num = start;
    } else
#line 422
    if ((int const   )*num == 88) {
#line 423
      num = start;
    } else {
#line 422
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 424
  if (num_len > 0UL) {
#line 425
    if ((int const   )*num == 117) {
      {
#line 426
      has_suffix = (_Bool)1;
#line 427
      type = (int_type )197632;
#line 428
      num ++;
      {
#line 428
      num = chew_continuation(num);
      }
      }
    } else
#line 425
    if ((int const   )*num == 85) {
      {
#line 426
      has_suffix = (_Bool)1;
#line 427
      type = (int_type )197632;
#line 428
      num ++;
      {
#line 428
      num = chew_continuation(num);
      }
      }
    }
#line 430
    if ((int const   )*num == 108) {
#line 430
      goto _L;
    } else
#line 430
    if ((int const   )*num == 76) {
      _L: /* CIL Label */ 
      {
#line 431
      has_suffix = (_Bool)1;
#line 432
      num ++;
      {
#line 432
      num = chew_continuation(num);
      }
      }
#line 433
      if ((unsigned int )type & 1U) {
#line 433
        type = (int_type )264193;
      } else {
#line 433
        type = (int_type )264192;
      }
    }
#line 435
    if ((int const   )*num == 108) {
#line 435
      goto _L___0;
    } else
#line 435
    if ((int const   )*num == 76) {
      _L___0: /* CIL Label */ 
      {
#line 436
      has_suffix = (_Bool)1;
#line 437
      num ++;
      {
#line 437
      num = chew_continuation(num);
      }
      }
#line 438
      if ((unsigned int )type & 1U) {
#line 438
        type = (int_type )329729;
      } else {
#line 438
        type = (int_type )329728;
      }
    }
#line 440
    if ((unsigned int )type & 1U) {
#line 440
      if ((int const   )*num == 117) {
#line 440
        goto _L___1;
      } else
#line 440
      if ((int const   )*num == 85) {
        _L___1: /* CIL Label */ 
#line 441
        if (! has_suffix) {
#line 442
          has_suffix = (_Bool)1;
#line 443
          type = (int_type )197632;
        } else {
#line 445
          type = (int_type )((unsigned int )type & 4294967294U);
        }
        {
#line 447
        num ++;
        {
#line 447
        num = chew_continuation(num);
        }
        }
      }
    }
  }
#line 451
  *numend = num;
#line 452
  if (num_len == 0UL) {
#line 453
    return (result);
  }
#line 455
  if ((unsigned int )type & 1U) {
#line 455
    if (val > 9223372036854775807ULL) {
#line 455
      if (! has_suffix) {
        {
        {
#line 460
        report((reason_code_t )9264, & gripe, "Integer constant \"%.*s\" is so large it is treated as unsigned",
               num - start, start);
        }
#line 464
        type = (int_type )329728;
        }
      }
    }
  }
#line 466
  if ((unsigned int )type == 264192U) {
#line 466
    if (val > 0xffffffffffffffffULL) {
#line 467
      overflow = (_Bool)1;
#line 468
      int_type___0 = "unsigned long";
#line 469
      max_val = 0xffffffffffffffffULL;
    } else {
#line 466
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 470
  if ((unsigned int )type == 264193U) {
#line 470
    if (val > 9223372036854775807ULL) {
#line 471
      overflow = (_Bool)1;
#line 472
      int_type___0 = "long";
#line 473
      max_val = 9223372036854775807ULL;
    } else {
#line 470
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 474
  if ((unsigned int )type == 329729U) {
#line 474
    if (val > 9223372036854775807ULL) {
#line 475
      overflow = (_Bool)1;
#line 476
      int_type___0 = "long long";
#line 477
      max_val = 9223372036854775807ULL;
    }
  }
#line 479
  if (overflow) {
    {
    {
#line 480
    release((void **)(& gripe));
    }
    {
#line 481
    report((reason_code_t )9216, (heap_str *)((void *)0), "Integer constant \"%.*s\" is too large for type %s (max %llu): expression will not be resolved",
           num - start, start, int_type___0, max_val);
    }
#line 485
    result.type = (int_type )393216;
    }
  } else {
#line 487
    if (gripe) {
      {
      {
#line 488
      report((reason_code_t )9264, & gripe, (char const   *)((void *)0));
      }
      }
    }
#line 490
    if (! has_suffix) {
#line 492
      if ((unsigned int )type & 1U) {
#line 493
        if (val <= 2147483647ULL) {
#line 494
          type = (int_type )197633;
        }
      } else
#line 496
      if (val <= 4294967295ULL) {
#line 497
        type = (int_type )197632;
      }
    }
#line 500
    result.val.ull = val;
#line 501
    result.type = type;
  }
#line 503
  return (result);
}
}
#line 515 "/home/wslee/tests/SOURCES/coan-4.2.2/src/integer_constant.c"
int_spec_t eval_character_constant(char const   **cpp ) 
{ 
  int_spec_t result ;
  char const   *cp ;
  char const   *int_type___0 ;
  unsigned long long val ;
  _Bool wide ;
  int max_len ;
  int chval ;
  int nbytes ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 518
  result.val.ll = 0LL;
#line 518
  result.type = (int_type )0;
#line 519
  cp = *cpp;
#line 520
  int_type___0 = "int";
#line 521
  val = 0xffffffffffffffffULL;
#line 522
  wide = (_Bool)0;
#line 523
  max_len = (int )sizeof(int );
#line 524
  if ((int const   )*cp == 76) {
    {
#line 525
    cp ++;
    {
#line 525
    cp = chew_continuation(cp);
    }
#line 526
    max_len = (int )sizeof(wchar_t );
#line 527
    int_type___0 = "wchar_t";
#line 528
    wide = (_Bool)1;
    }
  }
#line 530
  if ((int const   )*cp == 39) {
#line 531
    if (val == 0xffffffffffffffffULL) {
      {
      {
#line 532
      val = eval_hex_character_constant(& cp);
      }
      }
    }
#line 534
    if (val == 0xffffffffffffffffULL) {
      {
      {
#line 535
      val = eval_octal_character_constant(& cp);
      }
      }
    }
#line 537
    if (val == 0xffffffffffffffffULL) {
      {
#line 539
      chval = 0;
#line 540
      nbytes = 0;
#line 541
      val = 0ULL;
#line 542
      cp ++;
      {
#line 542
      cp = chew_continuation(cp);
      }
      }
#line 546
      if (! wide) {
#line 546
        goto _L;
      } else
#line 546
      if ((int const   )*(cp + 0) == 92) {
#line 546
        if ((int const   )*(cp + 1) != 10) {
          _L: /* CIL Label */ 
          {
          {
#line 547
          while (1) {
            while_continue___1: /* CIL Label */ ;
            while_continue: /* CIL Label */ ;
#line 547
            if (nbytes < max_len) {
#line 547
              if (*cp) {
#line 547
                if ((int const   )*cp != 39) {
                  {
                  {
#line 547
                  chval = char_escape_val(& cp);
                  }
                  }
#line 547
                  if (! (chval != -1)) {
#line 547
                    goto while_break;
                  }
                } else {
#line 547
                  goto while_break;
                }
              } else {
#line 547
                goto while_break;
              }
            } else {
#line 547
              goto while_break;
            }
#line 547
            val = (val << 8) | (unsigned long long )chval;
#line 547
            nbytes ++;
          }
          while_break___1: /* CIL Label */ ;
          }
          while_break: /* CIL Label */ ;
          }
        } else {
          {
          {
#line 550
          val = decode_utf8(& cp);
          }
          }
        }
      } else {
        {
        {
#line 550
        val = decode_utf8(& cp);
        }
        }
      }
#line 553
      if ((int const   )*cp != 39) {
#line 554
        val = 0xffffffffffffffffULL;
        {
        {
#line 556
        while (1) {
          while_continue___2: /* CIL Label */ ;
          while_continue___0: /* CIL Label */ ;
          {
#line 556
          cp ++;
          {
#line 556
          cp = chew_continuation(cp);
          }
          }
#line 556
          if ((int const   )*cp != 0) {
#line 556
            if ((int const   )*cp != 10) {
#line 556
              if (! ((int const   )*cp != 39)) {
#line 556
                goto while_break___0;
              }
            } else {
#line 556
              goto while_break___0;
            }
          } else {
#line 556
            goto while_break___0;
          }
          {
#line 556
          cp ++;
          {
#line 556
          cp = chew_continuation(cp);
          }
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 558
        if (! *cp) {
          {
          {
#line 559
          report((reason_code_t )9232, (heap_str *)((void *)0), "Unclosed quotation after \"%.*s\"",
                 cp - *cpp, *cpp);
          }
          }
        } else
#line 558
        if ((int const   )*cp == 10) {
          {
          {
#line 559
          report((reason_code_t )9232, (heap_str *)((void *)0), "Unclosed quotation after \"%.*s\"",
                 cp - *cpp, *cpp);
          }
          }
        } else {
          {
          {
#line 562
          report((reason_code_t )9312, (heap_str *)((void *)0), "Character constant %.*s is too long for type %s (max %d bytes). Will not be resolved",
                 (cp - *cpp) + 1L, *cpp, int_type___0, max_len);
          }
          }
        }
      } else
#line 566
      if (! wide) {
#line 566
        if (nbytes > 1) {
          {
          {
#line 567
          report((reason_code_t )9328, (heap_str *)((void *)0), "Multi-byte character constant %.*s",
                 (cp - *cpp) + 1L, *cpp);
          }
          }
        }
      }
      {
#line 570
      cp ++;
      {
#line 570
      cp = chew_continuation(cp);
      }
      }
    }
  }
#line 573
  if (val != 0xffffffffffffffffULL) {
#line 574
    result.val.i = (int )val;
#line 575
    result.type = (int_type )197633;
  } else {
#line 577
    result.type = (int_type )393216;
  }
#line 579
  *cpp = cp;
#line 580
  return (result);
}
}
#line 95 "/home/wslee/tests/SOURCES/coan-4.2.2/src/lexicon.h"
_Bool match_keyword(char const   **ptxt , char const   *keyword ) ;
#line 105
_Bool match_op(char const   **ptxt , char const   *op ) ;
#line 397 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 182 "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.h"
_Bool is_symbol_start_char(char cp ) ;
#line 64 "/home/wslee/tests/SOURCES/coan-4.2.2/src/lexicon.c"
static int text_match(char const   **ptxt , char const   *match , size_t nbytes ) 
{ 
  int cmp ;
  char const   *txt ;

  {
#line 68
  txt = *ptxt;
#line 69
  if (! nbytes) {
    {
    {
#line 70
    nbytes = strlen(match);
    }
    }
  }
  {
  {
#line 72
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 72
    nbytes --;
#line 72
    if (nbytes) {
#line 72
      if (*txt) {
#line 72
        if (*match) {
#line 72
          if (! ((int const   )*txt == (int const   )*match)) {
#line 72
            goto while_break;
          }
        } else {
#line 72
          goto while_break;
        }
      } else {
#line 72
        goto while_break;
      }
    } else {
#line 72
      goto while_break;
    }
    {
#line 72
    txt ++;
    {
#line 72
    txt = chew_continuation(txt);
    }
#line 72
    match ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  if ((int const   )*txt < (int const   )*match) {
#line 74
    cmp = -1;
  } else
#line 75
  if ((int const   )*txt > (int const   )*match) {
#line 76
    cmp = 1;
  } else {
    {
#line 78
    cmp = 0;
#line 79
    txt ++;
    {
#line 79
    *ptxt = chew_continuation(txt);
    }
    }
  }
#line 81
  return (cmp);
}
}
#line 96 "/home/wslee/tests/SOURCES/coan-4.2.2/src/lexicon.c"
_Bool match_keyword(char const   **ptxt , char const   *keyword ) 
{ 
  char const   *saved_txt ;
  int tmp ;
  _Bool tmp___0 ;

  {
  {
#line 99
  saved_txt = *ptxt;
  {
#line 100
  tmp = text_match(ptxt, keyword, (size_t )0);
  }
  }
#line 100
  if (0 == tmp) {
    {
    {
#line 100
    tmp___0 = is_symbol_start_char((char )*(*ptxt));
    }
    }
#line 100
    if (tmp___0) {
#line 103
      *ptxt = saved_txt;
#line 104
      return ((_Bool)0);
    } else {
#line 101
      return ((_Bool)1);
    }
  } else {
#line 103
    *ptxt = saved_txt;
#line 104
    return ((_Bool)0);
  }
}
}
#line 108 "/home/wslee/tests/SOURCES/coan-4.2.2/src/lexicon.c"
_Bool match_op(char const   **ptxt , char const   *op ) 
{ 
  char const   *txt ;
  _Bool verdict ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 111
  txt = *ptxt;
#line 112
  verdict = (_Bool)1;
#line 113
  if (! ((int const   )*(op + 1) == 0)) {
#line 113
    if (! ((int const   )*(op + 2) == 0)) {
      {
      {
#line 113
      __assert_fail("op[1] == \'\\0\' || op[2] ==\'\\0\'", "/home/wslee/tests/SOURCES/coan-4.2.2/src/lexicon.c",
                    113U, "match_op");
      }
      }
    }
  }
#line 114
  if ((int const   )*(txt + 0) != (int const   )*(op + 0)) {
#line 115
    verdict = (_Bool)0;
  } else
#line 117
  if (*(op + 1)) {
    {
#line 118
    txt ++;
    {
#line 118
    txt = chew_continuation(txt);
    }
    }
#line 119
    if ((int const   )*(txt + 0) != (int const   )*(op + 1)) {
#line 120
      verdict = (_Bool)0;
    }
  } else
#line 122
  if ((int const   )*(txt + 1) == (int const   )*(op + 0)) {
#line 123
    verdict = (_Bool)0;
  }
#line 126
  if (verdict) {
#line 127
    *ptxt = txt + 1;
  }
#line 129
  return (verdict);
}
}
#line 235 "/home/wslee/tests/SOURCES/coan-4.2.2/src/state_utils.h"
void component_initor(_Bool is_static , _Bool is_zero_initable , void **state , void **public_state ,
                      void const   *initialiser , size_t size , void (*user_init)() ) ;
#line 264
void component_finitor(_Bool is_static , void **state , void **public_state , void (*user_finis)() ) ;
#line 65 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_set.h"
ptr_set_h ptr_set_new(int (*compare)(void const   *obj , void const   *key , locator_t keylen ) ,
                      void (*dtor)(void * ) , void *(*cloner)(void const   * ) ) ;
#line 77
void ptr_set_dispose(ptr_set_h ps ) ;
#line 147
void *ptr_set_search(ptr_set_h ps , char const   *key , locator_t keylen ) ;
#line 165
_Bool ptr_set_insert(ptr_set_h ps , void const   *obj ) ;
#line 66 "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.h"
symbol_h symbol_new(char const   *name , size_t namelen ) ;
#line 72
void symbol_dispose(symbol_h sym ) ;
#line 79
symbol_h symbol_copy(symbol_const_h src ) ;
#line 152
int symbol_compare(symbol_const_h lhs , void const   *rhs , size_t len ) ;
#line 56 "/home/wslee/tests/SOURCES/coan-4.2.2/src/unconfigured_symbols.h"
void unconfigured_symbol_tally(char const   *name , size_t namelen ) ;
#line 73
unconfigured_symbols_public_state_t *unconfigured_symbols_public_h ;
#line 73
void unconfigured_symbols_initor(void) ;
#line 73
void unconfigured_symbols_finitor(void) ;
#line 629 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.h"
void report_symbol(symbol_h sym ) ;
#line 53 "/home/wslee/tests/SOURCES/coan-4.2.2/src/unconfigured_symbols.c"
static unconfigured_symbols_state_t unconfigured_symbols_state  ;
#line 53 "/home/wslee/tests/SOURCES/coan-4.2.2/src/unconfigured_symbols.c"
unconfigured_symbols_state_t *unconfigured_symbols_h  =    & unconfigured_symbols_state;
#line 53 "/home/wslee/tests/SOURCES/coan-4.2.2/src/unconfigured_symbols.c"
unconfigured_symbols_public_state_t *unconfigured_symbols_public_h  =    & unconfigured_symbols_state;
#line 53 "/home/wslee/tests/SOURCES/coan-4.2.2/src/unconfigured_symbols.c"
static unconfigured_symbols_state_t const   * const  unconfigured_symbols_static_initialiser_h  ;
#line 53
void (*unconfigured_symbols_init_h)(unconfigured_symbols_state_t * ) ;
#line 53
void (*unconfigured_symbols_finis_h)(unconfigured_symbols_state_t * ) ;
#line 53 "/home/wslee/tests/SOURCES/coan-4.2.2/src/unconfigured_symbols.c"
void unconfigured_symbols_initor(void) 
{ 


  {
  {
  {
#line 53
  component_initor((_Bool)1, (_Bool)0, (void **)((char *)(& unconfigured_symbols_h)),
                   (void **)((char *)(& unconfigured_symbols_public_h)), (void const   *)unconfigured_symbols_static_initialiser_h,
                   sizeof(unconfigured_symbols_state_t ), (void (*)())unconfigured_symbols_init_h);
  }
  }
#line 53
  return;
}
}
#line 53 "/home/wslee/tests/SOURCES/coan-4.2.2/src/unconfigured_symbols.c"
void unconfigured_symbols_finitor(void) 
{ 


  {
  {
  {
#line 53
  component_finitor((_Bool)1, (void **)((char *)(& unconfigured_symbols_h)), (void **)((char *)(& unconfigured_symbols_public_h)),
                    (void (*)())unconfigured_symbols_init_h);
  }
  }
#line 53
  return;
}
}
#line 55
void unconfigured_symbols_init(unconfigured_symbols_state_t *st_state ) ;
#line 55 "/home/wslee/tests/SOURCES/coan-4.2.2/src/unconfigured_symbols.c"
void (*unconfigured_symbols_init_h)(unconfigured_symbols_state_t * )  =    & unconfigured_symbols_init;
#line 55 "/home/wslee/tests/SOURCES/coan-4.2.2/src/unconfigured_symbols.c"
void unconfigured_symbols_init(unconfigured_symbols_state_t *st_state ) 
{ 


  {
  {
  {
#line 57
  st_state->sym_tab = ptr_set_new((int (*)(void const   *obj , void const   *key ,
                                           locator_t keylen ))(& symbol_compare),
                                  (void (*)(void * ))(& symbol_dispose), (void *(*)(void const   * ))(& symbol_copy));
  }
  }
#line 60
  return;
}
}
#line 62
void unconfigured_symbols_finis(unconfigured_symbols_state_t *st_state ) ;
#line 62 "/home/wslee/tests/SOURCES/coan-4.2.2/src/unconfigured_symbols.c"
void (*unconfigured_symbols_finis_h)(unconfigured_symbols_state_t * )  =    & unconfigured_symbols_finis;
#line 62 "/home/wslee/tests/SOURCES/coan-4.2.2/src/unconfigured_symbols.c"
void unconfigured_symbols_finis(unconfigured_symbols_state_t *st_state ) 
{ 


  {
  {
  {
#line 65
  ptr_set_dispose(st_state->sym_tab);
  }
  }
#line 66
  return;
}
}
#line 71 "/home/wslee/tests/SOURCES/coan-4.2.2/src/unconfigured_symbols.c"
void unconfigured_symbol_tally(char const   *name , size_t namelen ) 
{ 
  symbol_h sym ;
  void *tmp ;

  {
  {
  {
#line 74
  tmp = ptr_set_search(unconfigured_symbols_public_h->sym_tab, name, (locator_t )namelen);
  }
#line 74
  sym = (symbol_h )tmp;
  }
#line 76
  if (! sym) {
    {
    {
#line 77
    sym = symbol_new(name, namelen);
    }
    {
#line 78
    ptr_set_insert(unconfigured_symbols_public_h->sym_tab, (void const   *)sym);
    }
    }
  }
  {
  {
#line 80
  report_symbol(sym);
  }
  }
#line 81
  return;
}
}
#line 142 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 145
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 69 "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.h"
canonical_string_h canonical_string_new(char const   *start , size_t nbytes , char const   **pend ) ;
#line 82
canonical_string_h canonical_numeral(struct int_spec  const  *int_spec ) ;
#line 96
canonical_string_h canonical_string_copy(canonical_string_const_h src ) ;
#line 100
void canonical_string_dispose(canonical_string_h cs ) ;
#line 104
void canonical_string_swap(canonical_string_h lhs , canonical_string_h rhs ) ;
#line 112
_Bool canonical_string_equal(canonical_string_const_h lhs , canonical_string_const_h rhs ) ;
#line 119
char const   *canonical_string_text(canonical_string_const_h cs ) ;
#line 177
void canonical_string_replace(canonical_string_h cs , size_t start , size_t len ,
                              canonical_string_const_h subst ) ;
#line 282 "/home/wslee/tests/SOURCES/coan-4.2.2/src/eval_result.h"
struct int_spec  const  int_spec_false ;
#line 291
void eval_result_set_value(eval_result_t *result , int_spec_t const   *int_spec ) ;
#line 300
void eval_result_clear(eval_result_t *result ) ;
#line 89 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.h"
ptr_vector_h ptr_vector_new(void (*dtor)(void * ) , void *(*cloner)(void const   * ) ) ;
#line 117
void ptr_vector_drop(ptr_vector_h pv ) ;
#line 173
void ptr_vector_append(ptr_vector_h pv , void *ptr ) ;
#line 220
void const   **ptr_vector_begin_const(ptr_vector_const_h pv ) ;
#line 236
void const   **ptr_vector_end_const(ptr_vector_const_h pv ) ;
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 83 "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.h"
void symbol_swap(symbol_h lhs , symbol_h rhs ) ;
#line 90
void symbol_assign(symbol_h dest , symbol_const_h src ) ;
#line 99
_Bool symbol_equal(symbol_const_h lhs , symbol_const_h rhs ) ;
#line 111
line_type_t symbol_define(symbol_h sym , char const   *tail , char const   **pend ) ;
#line 123
line_type_t symbol_undefine(symbol_h sym , char const   *tail , char const   **pend ) ;
#line 131
char const   *symbol_name(symbol_const_h sym ) ;
#line 139
canonical_string_const_h symbol_definition(symbol_const_h sym ) ;
#line 160
_Bool symbol_is_legal(char const   *tok , size_t toklen ) ;
#line 167
_Bool symbol_is_configured(symbol_const_h sym ) ;
#line 176
_Bool symbol_is_global(symbol_const_h sym ) ;
#line 188
_Bool is_symbol_inner_char(char cp ) ;
#line 220
canonical_string_const_h symbol_resolve(symbol_h sym , ptr_vector_h history ) ;
#line 224
_Bool symbol_reported(symbol_const_h sym ) ;
#line 261
line_type_t symbol_evaluate_status(_Bool define , char const   *symstart , char const   *tail ,
                                   char const   **pend ) ;
#line 62 "/home/wslee/tests/SOURCES/coan-4.2.2/src/memory.h"
void *zallocate(size_t bytes ) ;
#line 92
void *clone(void const   *src , size_t len ) ;
#line 497 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.h"
void bail(int reason , char const   *format  , ...) ;
#line 114 "/home/wslee/tests/SOURCES/coan-4.2.2/src/chew.h"
char const   *chew_symbol(char const   *cp ) ;
#line 75 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.h"
eval_result_t eval_definition_text(char const   **pdef ) ;
#line 79 "/home/wslee/tests/SOURCES/coan-4.2.2/src/configured_symbols.h"
symbol_h configured_symbol_match(char const   *symname , size_t namelen ) ;
#line 100
symbol_h configured_symbol_find(canonical_string_const_h cs , size_t *start ) ;
#line 113
line_type_t configured_symbol_add(_Bool define , symbol_h sym , char const   *tail ,
                                  char const   **pend ) ;
#line 207 "/home/wslee/tests/SOURCES/coan-4.2.2/src/io.h"
io_public_state_t *io_public_h ;
#line 87 "/home/wslee/tests/SOURCES/coan-4.2.2/src/contradiction.h"
void insert_contradiction(char const   *sub_format ) ;
#line 124
void forget_contradiction(void) ;
#line 136
void flush_contradiction(void) ;
#line 149
void save_contradiction(char const   *sub_format ) ;
#line 165
contradiction_public_state_t *contradiction_public_h ;
#line 54 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_select.h"
_Bool eligible_line(int cmd_code , int directive ) ;
#line 63
_Bool dropping_line(void) ;
#line 60 "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c"
static void symbol_init(symbol_h sym , char const   *name , size_t namelen ) 
{ 
  void *tmp ;

  {
  {
  {
#line 63
  eval_result_clear(sym);
  }
  {
#line 64
  tmp = clone((void const   *)name, namelen);
  }
#line 64
  sym->sym_name = (char *)tmp;
  }
#line 65
  return;
}
}
#line 74 "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c"
static void symbol_copy_init(symbol_h dest , symbol_const_h src ) 
{ 
  void *tmp ;

  {
  {
  {
#line 77
  tmp = clone((void const   *)src->sym_name, (size_t )0);
  }
#line 77
  dest->sym_name = (char *)tmp;
  }
#line 78
  if (src->sym_def) {
    {
    {
#line 79
    dest->sym_def = canonical_string_copy((canonical_string_const_h )src->sym_def);
    }
    }
  } else {
#line 81
    dest->sym_def = (canonical_string_h )src->sym_def;
  }
#line 83
  if (src->most_resolved) {
    {
    {
#line 84
    dest->most_resolved = canonical_string_copy((canonical_string_const_h )src->most_resolved);
    }
    }
  } else {
#line 86
    dest->most_resolved = (canonical_string_h )src->most_resolved;
  }
#line 88
  dest->flags = (int )src->flags;
#line 89
  dest->value = (int_spec_t )src->value;
#line 90
  return;
}
}
#line 99 "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c"
static int symbol_name_compare(symbol_const_h sym , char const   *name , size_t namelen ) 
{ 
  char const   *sym_name ;
  int comp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 104
  if (! sym) {
    {
    {
#line 104
    __assert_fail("sym", "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c", 104U,
                  "symbol_name_compare");
    }
    }
  }
#line 105
  if (! name) {
    {
    {
#line 105
    __assert_fail("name", "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c", 105U,
                  "symbol_name_compare");
    }
    }
  }
  {
  {
#line 106
  sym_name = symbol_name(sym);
  }
  {
#line 107
  comp = strncmp(sym_name, name, namelen);
  }
  }
#line 108
  if (comp <= 0) {
#line 109
    if (comp == 0) {
#line 110
      if ((int const   )*(sym_name + namelen) != 0) {
#line 112
        comp = 1;
      }
    }
  }
#line 117
  return (comp);
}
}
#line 121 "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c"
static void report_symbol_configuration(_Bool define , int gripe , symbol_const_h sym ,
                                        canonical_string_const_h old_def , canonical_string_const_h new_def ,
                                        char const   *tail ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  char const   *tmp___22 ;
  char const   *tmp___23 ;
  char const   *tmp___24 ;
  char const   *tmp___25 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;

  {
#line 127
  if (! gripe) {
#line 128
    return;
  }
#line 130
  if (define) {
    {
#line 132
    if (gripe == 9376) {
#line 132
      goto case_9376;
    }
#line 137
    if (gripe == 17536) {
#line 137
      goto case_17536;
    }
#line 142
    if (gripe == 16896) {
#line 142
      goto case_16896;
    }
#line 146
    if (gripe == 9408) {
#line 146
      goto case_9408;
    }
#line 155
    if (gripe == 8208) {
#line 155
      goto case_8208;
    }
#line 161
    if (gripe == 9360) {
#line 161
      goto case_9360;
    }
#line 167
    if (gripe == 16688) {
#line 167
      goto case_16688;
    }
#line 184
    goto switch_default;
    case_9376: /* CIL Label */ 
    {
    {
#line 133
    tmp = symbol_name(sym);
    }
    {
#line 133
    report((reason_code_t )9376, (heap_str *)((void *)0), "Sorry. Function-like macro definition is not supported, ignored: \"#define %s%s\"",
           tmp, tail);
    }
    }
#line 136
    goto switch_break;
    case_17536: /* CIL Label */ 
    {
    {
#line 138
    tmp___0 = symbol_name(sym);
    }
    {
#line 138
    bail(17536, "Sorry. Function-like macro definition is not supported: \"-D%s%s\"",
         tmp___0, tail);
    }
    }
#line 141
    goto switch_break;
    case_16896: /* CIL Label */ 
    {
    {
#line 143
    tmp___1 = symbol_name(sym);
    }
    {
#line 143
    bail(16896, "Garbage in \"-D%s%s\"", tmp___1, tail);
    }
    }
#line 145
    goto switch_break;
    case_9408: /* CIL Label */ 
    {
    {
#line 147
    tmp___2 = canonical_string_text(old_def);
    }
    {
#line 147
    tmp___3 = symbol_name(sym);
    }
    {
#line 147
    tmp___4 = canonical_string_text(new_def);
    }
    {
#line 147
    tmp___5 = symbol_name(sym);
    }
    {
#line 147
    report((reason_code_t )9408, (heap_str *)((void *)0), "Differently redefining \"%s=%s\", after \"%s=%s\" at line %d",
           tmp___5, tmp___4, tmp___3, tmp___2, sym->line);
    }
    }
#line 154
    goto switch_break;
    case_8208: /* CIL Label */ 
    {
    {
#line 156
    tmp___6 = canonical_string_text(new_def);
    }
    {
#line 156
    tmp___7 = symbol_name(sym);
    }
    {
#line 156
    report((reason_code_t )8208, (heap_str *)((void *)0), "Duplicated \"-D%s=%s\" ignored",
           tmp___7, tmp___6);
    }
    }
#line 160
    goto switch_break;
    case_9360: /* CIL Label */ 
    {
    {
#line 162
    tmp___8 = canonical_string_text(new_def);
    }
    {
#line 162
    tmp___9 = symbol_name(sym);
    }
    {
#line 162
    report((reason_code_t )9360, (heap_str *)((void *)0), "\"-D%s=%s\" has been assumed for the current file",
           tmp___9, tmp___8);
    }
    }
#line 166
    goto switch_break;
    case_16688: /* CIL Label */ 
#line 168
    if (old_def) {
      {
      {
#line 169
      tmp___10 = canonical_string_text(old_def);
      }
      {
#line 169
      tmp___11 = symbol_name(sym);
      }
      {
#line 169
      tmp___12 = canonical_string_text(new_def);
      }
      {
#line 169
      tmp___13 = symbol_name(sym);
      }
      {
#line 169
      bail(16688, "\"-D%s=%s\" contradicts prior \"-D%s=%s\"", tmp___13, tmp___12,
           tmp___11, tmp___10);
      }
      }
    } else {
      {
      {
#line 177
      tmp___14 = symbol_name(sym);
      }
      {
#line 177
      tmp___15 = canonical_string_text(old_def);
      }
      {
#line 177
      tmp___16 = symbol_name(sym);
      }
      {
#line 177
      bail(16688, "\"-D%s=%s\" contradicts prior \"-U%s\"", tmp___16, tmp___15, tmp___14);
      }
      }
    }
#line 183
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    {
#line 185
    __assert_fail("0", "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c", 185U,
                  "report_symbol_configuration");
    }
    }
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 190
    if (gripe == 16896) {
#line 190
      goto case_16896___0;
    }
#line 194
    if (gripe == 9424) {
#line 194
      goto case_9424;
    }
#line 202
    if (gripe == 16688) {
#line 202
      goto case_16688___0;
    }
#line 209
    if (gripe == 8208) {
#line 209
      goto case_8208___0;
    }
#line 214
    if (gripe == 9360) {
#line 214
      goto case_9360___0;
    }
#line 219
    goto switch_default___0;
    case_16896___0: /* CIL Label */ 
    {
    {
#line 191
    tmp___17 = symbol_name(sym);
    }
    {
#line 191
    bail(16896, "Garbage in \"-U%s%s\"", tmp___17, tail);
    }
    }
#line 193
    goto switch_break___0;
    case_9424: /* CIL Label */ 
    {
    {
#line 195
    tmp___18 = canonical_string_text(old_def);
    }
    {
#line 195
    tmp___19 = symbol_name(sym);
    }
    {
#line 195
    tmp___20 = symbol_name(sym);
    }
    {
#line 195
    report((reason_code_t )9424, (heap_str *)((void *)0), "undefining %s, after defining %s=%s at line %d",
           tmp___20, tmp___19, tmp___18, sym->line);
    }
    }
#line 201
    goto switch_break___0;
    case_16688___0: /* CIL Label */ 
    {
    {
#line 203
    tmp___21 = canonical_string_text(old_def);
    }
    {
#line 203
    tmp___22 = symbol_name(sym);
    }
    {
#line 203
    tmp___23 = symbol_name(sym);
    }
    {
#line 203
    bail(16688, "\"-U%s\" contradicts prior \"-D%s=%s\"", tmp___23, tmp___22, tmp___21);
    }
    }
#line 208
    goto switch_break___0;
    case_8208___0: /* CIL Label */ 
    {
    {
#line 210
    tmp___24 = symbol_name(sym);
    }
    {
#line 210
    report((reason_code_t )8208, (heap_str *)((void *)0), "Duplicated \"-U%s\" ignored",
           tmp___24);
    }
    }
#line 213
    goto switch_break___0;
    case_9360___0: /* CIL Label */ 
    {
    {
#line 215
    tmp___25 = symbol_name(sym);
    }
    {
#line 215
    report((reason_code_t )9360, (heap_str *)((void *)0), "\"-U%s\" has been assumed for the current file",
           tmp___25);
    }
    }
#line 218
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
    {
#line 220
    __assert_fail("0", "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c", 220U,
                  "report_symbol_configuration");
    }
    }
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 223
  return;
}
}
#line 237 "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c"
static canonical_string_h symbol_definition_resolve(symbol_const_h sym , ptr_vector_h history ) 
{ 
  canonical_string_h resolved ;
  canonical_string_const_h tmp ;
  canonical_string_h tmp___0 ;
  size_t offset ;
  symbol_h sy ;
  char const   *symname ;
  char const   *tmp___1 ;
  char const   *text ;
  char const   *tmp___2 ;
  char const   *cut_start ;
  char const   *cut_end ;
  size_t tmp___3 ;
  size_t cut_len ;
  canonical_string_const_h val ;
  canonical_string_const_h tmp___4 ;

  {
  {
  {
#line 240
  tmp = symbol_definition(sym);
  }
  {
#line 240
  tmp___0 = canonical_string_copy(tmp);
  }
#line 240
  resolved = tmp___0;
#line 241
  offset = (size_t )0;
  }
  {
  {
#line 243
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 243
    sy = configured_symbol_find((canonical_string_const_h )resolved, & offset);
    }
    }
#line 243
    if (! ((unsigned long )sy != (unsigned long )((void *)0))) {
#line 243
      goto while_break;
    }
    {
    {
#line 244
    tmp___1 = symbol_name((symbol_const_h )sy);
    }
#line 244
    symname = tmp___1;
    {
#line 245
    tmp___2 = canonical_string_text((canonical_string_const_h )resolved);
    }
#line 245
    text = tmp___2;
#line 246
    cut_start = text + offset;
    {
#line 247
    tmp___3 = strlen(symname);
    }
#line 247
    cut_end = cut_start + tmp___3;
    {
#line 249
    tmp___4 = symbol_resolve(sy, history);
    }
#line 249
    val = tmp___4;
#line 250
    cut_len = (size_t )(cut_end - cut_start);
    }
#line 251
    if (! val) {
      {
      {
#line 253
      canonical_string_dispose(resolved);
      }
#line 254
      resolved = (canonical_string_h )((void *)0);
      }
#line 255
      goto while_break;
    }
    {
    {
#line 257
    canonical_string_replace(resolved, offset, cut_len, val);
    }
#line 243
    offset = (size_t )0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 259
  return (resolved);
}
}
#line 266 "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c"
symbol_h symbol_new(char const   *name , size_t namelen ) 
{ 
  symbol_h sym ;
  void *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 270
  if (! name) {
    {
    {
#line 270
    __assert_fail("name", "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c", 270U,
                  "symbol_new");
    }
    }
  }
#line 271
  if (! namelen) {
    {
    {
#line 271
    __assert_fail("namelen", "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c",
                  271U, "symbol_new");
    }
    }
  }
  {
  {
#line 272
  tmp = zallocate(sizeof(eval_result_t ));
  }
#line 272
  sym = (symbol_h )tmp;
  {
#line 273
  symbol_init(sym, name, namelen);
  }
  }
#line 274
  return (sym);
}
}
#line 277 "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c"
void symbol_dispose(symbol_h sym ) 
{ 


  {
#line 280
  if (sym) {
    {
    {
#line 281
    eval_result_clear(sym);
    }
    {
#line 282
    free((void *)sym);
    }
    }
  }
#line 284
  return;
}
}
#line 286 "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c"
symbol_h symbol_copy(symbol_const_h src ) 
{ 
  symbol_h dest ;
  void *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 290
  if (! src) {
    {
    {
#line 290
    __assert_fail("src", "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c", 290U,
                  "symbol_copy");
    }
    }
  }
  {
  {
#line 291
  tmp = zallocate(sizeof(eval_result_t ));
  }
#line 291
  dest = (symbol_h )tmp;
  {
#line 292
  symbol_copy_init(dest, src);
  }
  }
#line 293
  return (dest);
}
}
#line 296 "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c"
void symbol_swap(symbol_h lhs , symbol_h rhs ) 
{ 
  char *tmp ;
  int_spec_t tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 299
  if (! lhs) {
    {
    {
#line 299
    __assert_fail("lhs", "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c", 299U,
                  "symbol_swap");
    }
    }
  }
#line 300
  if (! rhs) {
    {
    {
#line 300
    __assert_fail("rhs", "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c", 300U,
                  "symbol_swap");
    }
    }
  }
  {
  {
#line 301
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 301
    tmp = lhs->sym_name;
#line 301
    lhs->sym_name = rhs->sym_name;
#line 301
    rhs->sym_name = tmp;
#line 301
    goto while_break;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 302
  canonical_string_swap(lhs->sym_def, rhs->sym_def);
  }
  {
#line 303
  canonical_string_swap(lhs->most_resolved, rhs->most_resolved);
  }
  }
  {
  {
#line 304
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 304
    tmp___0 = lhs->value;
#line 304
    lhs->value = lhs->value;
#line 304
    lhs->value = tmp___0;
#line 304
    goto while_break___0;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 305
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 305
    tmp___1 = lhs->flags;
#line 305
    lhs->flags = lhs->flags;
#line 305
    lhs->flags = tmp___1;
#line 305
    goto while_break___1;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 306
  return;
}
}
#line 308 "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c"
void symbol_assign(symbol_h dest , symbol_const_h src ) 
{ 
  symbol_h tmp ;
  symbol_h tmp___0 ;

  {
#line 311
  if ((unsigned long )dest != (unsigned long )src) {
    {
    {
#line 312
    tmp___0 = symbol_copy(src);
    }
#line 312
    tmp = tmp___0;
    {
#line 313
    symbol_swap(dest, tmp);
    }
    {
#line 314
    symbol_dispose(tmp);
    }
    }
  }
#line 316
  return;
}
}
#line 318 "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c"
_Bool symbol_equal(symbol_const_h lhs , symbol_const_h rhs ) 
{ 
  _Bool eq___0 ;
  int tmp ;
  canonical_string_const_h tmp___0 ;
  canonical_string_const_h tmp___1 ;

  {
#line 321
  eq___0 = (_Bool )((unsigned long )lhs == (unsigned long )rhs);
#line 322
  if (! eq___0) {
    {
    {
#line 323
    tmp = symbol_compare(lhs, (void const   *)rhs, (size_t )0);
    }
#line 323
    eq___0 = (_Bool )tmp;
    }
#line 324
    if (eq___0) {
      {
      {
#line 325
      tmp___0 = symbol_definition(rhs);
      }
      {
#line 325
      tmp___1 = symbol_definition(lhs);
      }
      {
#line 325
      eq___0 = canonical_string_equal(tmp___1, tmp___0);
      }
      }
    }
  }
#line 329
  return (eq___0);
}
}
#line 332 "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c"
line_type_t symbol_define(symbol_h sym , char const   *tail , char const   **pend ) 
{ 
  canonical_string_h new_def ;
  canonical_string_const_h old_def ;
  line_type_t retval ;
  _Bool update ;
  int gripe ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 335
  new_def = (canonical_string_h )((void *)0);
#line 336
  old_def = (canonical_string_const_h )((void *)0);
#line 337
  retval = (line_type_t )11;
#line 338
  update = (_Bool)1;
#line 339
  gripe = 0;
#line 340
  if (! sym) {
    {
    {
#line 340
    __assert_fail("sym", "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c", 340U,
                  "symbol_define");
    }
    }
  }
#line 341
  if ((int const   )*tail == 40) {
#line 342
    if (io_public_h->line_num != 0) {
#line 343
      gripe = 9376;
    } else {
#line 346
      gripe = 17536;
    }
#line 348
    update = (_Bool)0;
#line 349
    goto conclusion;
  }
#line 351
  if (! (io_public_h->line_num != 0)) {
#line 352
    if ((int const   )*tail == 61) {
#line 353
      tail ++;
    } else
#line 355
    if (*tail) {
#line 356
      gripe = 16896;
#line 357
      goto conclusion;
    }
  }
#line 360
  if (*tail) {
    {
    {
#line 361
    new_def = canonical_string_new(tail, (size_t )0, & tail);
    }
    }
  } else {
    {
    {
#line 364
    new_def = canonical_string_new((char const   *)((void *)0), (size_t )0, (char const   **)((void *)0));
    }
    }
  }
  {
  {
#line 366
  old_def = symbol_definition((symbol_const_h )sym);
  }
  {
#line 367
  tmp___3 = symbol_is_configured((symbol_const_h )sym);
  }
  }
#line 367
  if (tmp___3) {
#line 369
    if (old_def) {
      {
      {
#line 370
      tmp___1 = canonical_string_equal(old_def, (canonical_string_const_h )new_def);
      }
      }
#line 370
      if (tmp___1) {
        {
        {
#line 387
        tmp___0 = symbol_is_global((symbol_const_h )sym);
        }
        }
#line 387
        if (tmp___0) {
#line 390
          if (io_public_h->line_num != 0) {
#line 391
            retval = (line_type_t )10;
#line 392
            update = (_Bool)0;
#line 393
            if ((unsigned long )sym == (unsigned long )contradiction_public_h->last_contradictory_undef) {
              {
              {
#line 394
              forget_contradiction();
              }
              }
            }
          } else {
#line 399
            gripe = 8208;
#line 400
            update = (_Bool)0;
          }
        } else {
#line 388
          update = (_Bool)0;
        }
      } else {
        {
        {
#line 371
        tmp = symbol_is_global((symbol_const_h )sym);
        }
        }
#line 371
        if (tmp) {
#line 374
          if (io_public_h->line_num != 0) {
            {
#line 375
            retval = (line_type_t )10;
#line 376
            update = (_Bool)0;
            {
#line 377
            flush_contradiction();
            }
            {
#line 378
            insert_contradiction("\"%.*s\" differently redefines -D symbol");
            }
            }
          } else {
#line 383
            gripe = 16688;
          }
        } else {
#line 372
          gripe = 9408;
        }
      }
    } else {
      {
      {
#line 404
      tmp___2 = symbol_is_global((symbol_const_h )sym);
      }
      }
#line 404
      if (tmp___2) {
#line 405
        update = (_Bool)0;
#line 406
        if (io_public_h->line_num != 0) {
          {
#line 407
          retval = (line_type_t )10;
          {
#line 408
          insert_contradiction("\"%.*s\" contradicts -U or --implicit");
          }
          }
        } else {
#line 412
          gripe = 16688;
        }
      }
    }
  } else
#line 418
  if (io_public_h->line_num != 0) {
#line 419
    gripe = 9360;
  }
  conclusion: 
  {
  {
#line 422
  report_symbol_configuration((_Bool)1, gripe, (symbol_const_h )sym, old_def, (canonical_string_const_h )new_def,
                              tail);
  }
  }
#line 423
  if (pend) {
#line 424
    *pend = tail;
  }
#line 426
  if (update) {
    {
    {
#line 427
    canonical_string_dispose(sym->sym_def);
    }
#line 428
    sym->sym_def = new_def;
    {
#line 429
    canonical_string_dispose(sym->most_resolved);
    }
#line 430
    sym->most_resolved = (canonical_string_h )((void *)0);
#line 431
    sym->line = io_public_h->line_num;
    }
#line 432
    if (! (io_public_h->line_num != 0)) {
#line 433
      sym->flags |= 128;
    } else {
#line 436
      sym->flags |= 64;
    }
  } else {
    {
    {
#line 440
    canonical_string_dispose(new_def);
    }
    }
  }
#line 442
  return (retval);
}
}
#line 445 "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c"
line_type_t symbol_undefine(symbol_h sym , char const   *tail , char const   **pend ) 
{ 
  line_type_t retval ;
  _Bool update ;
  int gripe ;
  canonical_string_const_h old_def ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 448
  retval = (line_type_t )11;
#line 449
  update = (_Bool)1;
#line 450
  gripe = 0;
#line 451
  old_def = (canonical_string_const_h )((void *)0);
#line 452
  if (! sym) {
    {
    {
#line 452
    __assert_fail("sym", "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c", 452U,
                  "symbol_undefine");
    }
    }
  }
#line 453
  if (! (io_public_h->line_num != 0)) {
#line 454
    if (*tail) {
#line 455
      gripe = 16896;
#line 456
      update = (_Bool)0;
#line 457
      goto conclusion;
    }
  }
  {
  {
#line 460
  old_def = symbol_definition((symbol_const_h )sym);
  }
  {
#line 461
  tmp___1 = symbol_is_configured((symbol_const_h )sym);
  }
  }
#line 461
  if (tmp___1) {
#line 463
    if (old_def) {
      {
      {
#line 464
      tmp = symbol_is_global((symbol_const_h )sym);
      }
      }
#line 464
      if (tmp) {
#line 467
        if (io_public_h->line_num != 0) {
#line 468
          retval = (line_type_t )10;
#line 469
          update = (_Bool)0;
#line 470
          if ((unsigned long )contradiction_public_h->last_contradictory_undef != (unsigned long )sym) {
            {
            {
#line 471
            flush_contradiction();
            }
#line 472
            contradiction_public_h->last_contradictory_undef = (symbol_const_h )sym;
            {
#line 473
            save_contradiction("\"%.*s\" contradicts -D symbol");
            }
            }
          }
        }
      } else {
#line 465
        gripe = 9424;
      }
    } else {
      {
      {
#line 478
      tmp___0 = symbol_is_global((symbol_const_h )sym);
      }
      }
#line 478
      if (tmp___0) {
#line 479
        update = (_Bool)0;
#line 480
        if (io_public_h->line_num != 0) {
#line 481
          retval = (line_type_t )10;
        } else {
#line 484
          gripe = 8208;
        }
      } else {
#line 488
        update = (_Bool)0;
      }
    }
  } else
#line 491
  if (io_public_h->line_num != 0) {
#line 492
    gripe = 9360;
  }
  conclusion: 
#line 495
  if (pend) {
#line 496
    *pend = tail;
  }
  {
  {
#line 498
  report_symbol_configuration((_Bool)0, gripe, (symbol_const_h )sym, old_def, (canonical_string_const_h )((void *)0),
                              tail);
  }
  }
#line 499
  if (update) {
    {
    {
#line 500
    canonical_string_dispose(sym->sym_def);
    }
#line 501
    sym->sym_def = (canonical_string_h )((void *)0);
    {
#line 502
    canonical_string_dispose(sym->most_resolved);
    }
#line 503
    sym->most_resolved = (canonical_string_h )((void *)0);
    {
#line 504
    eval_result_set_value(sym, & int_spec_false);
    }
#line 505
    sym->line = io_public_h->line_num;
    }
#line 506
    if (! (io_public_h->line_num != 0)) {
#line 507
      sym->flags |= 128;
    } else {
#line 510
      sym->flags |= 64;
    }
  }
#line 513
  return (retval);
}
}
#line 516 "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c"
char const   *symbol_name(symbol_const_h sym ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 519
  if (! sym) {
    {
    {
#line 519
    __assert_fail("sym", "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c", 519U,
                  "symbol_name");
    }
    }
  }
#line 520
  return ((char const   *)sym->sym_name);
}
}
#line 523 "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c"
canonical_string_const_h symbol_definition(symbol_const_h sym ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 526
  if (! sym) {
    {
    {
#line 526
    __assert_fail("sym", "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c", 526U,
                  "symbol_definition");
    }
    }
  }
#line 527
  return ((canonical_string_const_h )sym->sym_def);
}
}
#line 530 "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c"
int symbol_compare(symbol_const_h lhs , void const   *rhs , size_t len ) 
{ 
  int tmp ;
  symbol_const_h other ;
  int tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 533
  if (! lhs) {
    {
    {
#line 533
    __assert_fail("lhs", "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c", 533U,
                  "symbol_compare");
    }
    }
  }
#line 534
  if (! rhs) {
    {
    {
#line 534
    __assert_fail("rhs", "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c", 534U,
                  "symbol_compare");
    }
    }
  }
#line 535
  if (len) {
    {
    {
#line 536
    tmp = symbol_name_compare(lhs, (char const   *)rhs, len);
    }
    }
#line 536
    return (tmp);
  } else {
    {
#line 538
    other = (symbol_const_h )rhs;
    {
#line 539
    tmp___0 = strcmp((char const   *)lhs->sym_name, (char const   *)other->sym_name);
    }
    }
#line 539
    return (tmp___0);
  }
}
}
#line 543 "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c"
_Bool symbol_is_legal(char const   *tok , size_t toklen ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;

  {
  {
  {
#line 546
  tmp = is_symbol_start_char((char )*tok);
  }
  }
#line 546
  if (tmp) {
#line 546
    if (toklen < 1UL) {
#line 547
      return ((_Bool)0);
    }
  } else {
#line 547
    return ((_Bool)0);
  }
#line 549
  toklen --;
  {
  {
#line 549
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 549
    if (! toklen) {
#line 549
      goto while_break;
    }
    {
    {
#line 550
    tmp___0 = is_symbol_inner_char((char )*tok);
    }
    }
#line 550
    if (! tmp___0) {
#line 551
      return ((_Bool)0);
    }
#line 549
    toklen --;
#line 549
    tok ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 554
  return ((_Bool)1);
}
}
#line 557 "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c"
_Bool symbol_is_configured(symbol_const_h sym ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 560
  if (! sym) {
    {
    {
#line 560
    __assert_fail("sym", "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c", 560U,
                  "symbol_is_configured");
    }
    }
  }
#line 561
  if ((sym->flags & 128) == 128) {
#line 561
    tmp = 1;
  } else
#line 561
  if ((sym->flags & 64) == 64) {
#line 561
    tmp = 1;
  } else {
#line 561
    tmp = 0;
  }
#line 561
  return ((_Bool )tmp);
}
}
#line 564 "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c"
_Bool symbol_is_global(symbol_const_h sym ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 567
  if (! sym) {
    {
    {
#line 567
    __assert_fail("sym", "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c", 567U,
                  "symbol_is_global");
    }
    }
  }
#line 568
  return ((_Bool )((sym->flags & 128) == 128));
}
}
#line 571 "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c"
_Bool is_symbol_start_char(char cp ) 
{ 
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
  {
  {
#line 574
  tmp = __ctype_b_loc();
  }
  }
#line 574
  if ((int const   )*(*tmp + (int )cp) & 1024) {
#line 574
    tmp___0 = 1;
  } else
#line 574
  if ((int )cp == 95) {
#line 574
    tmp___0 = 1;
  } else {
#line 574
    tmp___0 = 0;
  }
#line 574
  return ((_Bool )tmp___0);
}
}
#line 577 "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c"
_Bool is_symbol_inner_char(char cp ) 
{ 
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
  {
  {
#line 580
  tmp = __ctype_b_loc();
  }
  }
#line 580
  if ((int const   )*(*tmp + (int )cp) & 8) {
#line 580
    tmp___0 = 1;
  } else
#line 580
  if ((int )cp == 95) {
#line 580
    tmp___0 = 1;
  } else {
#line 580
    tmp___0 = 0;
  }
#line 580
  return ((_Bool )tmp___0);
}
}
#line 583 "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c"
_Bool symbol_reported(symbol_const_h sym ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 586
  if (! sym) {
    {
    {
#line 586
    __assert_fail("sym", "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c", 586U,
                  "symbol_reported");
    }
    }
  }
#line 587
  return ((_Bool )((sym->flags & 256) == 256));
}
}
#line 590 "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c"
canonical_string_const_h symbol_resolve(symbol_h sym , ptr_vector_h history ) 
{ 
  canonical_string_h resolved ;
  _Bool outermost ;
  symbol_const_h *begin ;
  void const   **tmp ;
  symbol_const_h *end ;
  void const   **tmp___0 ;
  char const   *tmp___1 ;
  canonical_string_const_h tmp___2 ;
  char const   *tmp___3 ;
  _Bool tmp___4 ;
  char const   *tmp___5 ;
  char const   *pc ;
  char const   *tmp___6 ;
  void *tmp___7 ;
  char const   *def_text ;
  eval_result_t er ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 593
  resolved = (canonical_string_h )((void *)0);
#line 594
  outermost = (_Bool)1;
#line 595
  if (history) {
    {
    {
#line 596
    tmp = ptr_vector_begin_const((ptr_vector_const_h )history);
    }
#line 596
    begin = (symbol_const_h *)tmp;
    {
#line 597
    tmp___0 = ptr_vector_end_const((ptr_vector_const_h )history);
    }
#line 597
    end = (symbol_const_h *)tmp___0;
#line 598
    outermost = (_Bool)0;
    }
    {
    {
#line 599
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 599
      if (! ((unsigned long )begin != (unsigned long )end)) {
#line 599
        goto while_break;
      }
#line 600
      if ((unsigned long )*begin == (unsigned long )sym) {
        {
        {
#line 601
        tmp___1 = symbol_name((symbol_const_h )sym);
        }
        {
#line 601
        report((reason_code_t )8640, (heap_str *)((void *)0), "Symbol \"%s\" has a circular definition",
               tmp___1);
        }
        {
#line 604
        canonical_string_dispose(sym->most_resolved);
        }
#line 605
        sym->most_resolved = (canonical_string_h )((void *)0);
        }
#line 606
        return ((canonical_string_const_h )sym->most_resolved);
      }
#line 599
      begin ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
    {
#line 611
    history = ptr_vector_new((void (*)(void * ))((void *)0), (void *(*)(void const   * ))((void *)0));
    }
    {
#line 612
    ptr_vector_append(history, (void *)sym);
    }
    }
  }
  {
  {
#line 614
  tmp___4 = symbol_is_configured((symbol_const_h )sym);
  }
  }
#line 614
  if (tmp___4) {
    {
    {
#line 615
    tmp___2 = symbol_definition((symbol_const_h )sym);
    }
    }
#line 615
    if (tmp___2) {
      {
      {
#line 616
      resolved = symbol_definition_resolve((symbol_const_h )sym, history);
      }
      }
    } else {
      {
      {
#line 619
      resolved = canonical_string_new("0", (size_t )0, (char const   **)((void *)0));
      }
      }
    }
  } else {
    {
    {
#line 623
    tmp___3 = symbol_name((symbol_const_h )sym);
    }
    {
#line 623
    resolved = canonical_string_new(tmp___3, (size_t )0, (char const   **)((void *)0));
    }
    }
  }
  {
  {
#line 625
  canonical_string_dispose(sym->most_resolved);
  }
  }
#line 626
  if (! resolved) {
#line 628
    if (outermost) {
      {
#line 629
      sym->flags |= 2;
      {
#line 630
      tmp___5 = symbol_name((symbol_const_h )sym);
      }
      {
#line 630
      sym->most_resolved = canonical_string_new(tmp___5, (size_t )0, (char const   **)((void *)0));
      }
      }
    } else {
#line 633
      sym->most_resolved = resolved;
    }
  } else {
    {
    {
#line 637
    tmp___6 = canonical_string_text((canonical_string_const_h )resolved);
    }
    {
#line 637
    tmp___7 = clone((void const   *)tmp___6, (size_t )0);
    }
#line 637
    pc = (char const   *)tmp___7;
#line 638
    def_text = pc;
    {
#line 640
    er = eval_definition_text(& pc);
    }
    }
#line 641
    if ((int const   )*pc == 0) {
#line 641
      if (! ((er.flags & 24) == 0)) {
        {
        {
#line 642
        eval_result_set_value(sym, (int_spec_t const   *)(& er.value));
        }
        {
#line 643
        sym->most_resolved = canonical_numeral((struct int_spec  const  *)(& er.value));
        }
        }
      } else {
#line 646
        sym->most_resolved = resolved;
      }
    } else {
#line 646
      sym->most_resolved = resolved;
    }
    {
    {
#line 648
    eval_result_clear(& er);
    }
    {
#line 649
    free((void *)((char *)def_text));
    }
    }
  }
#line 651
  if (outermost) {
    {
    {
#line 652
    ptr_vector_drop(history);
    }
    }
  }
#line 654
  return ((canonical_string_const_h )sym->most_resolved);
}
}
#line 657 "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c"
line_type_t symbol_evaluate_status(_Bool define , char const   *symstart , char const   *tail ,
                                   char const   **pend ) 
{ 
  line_type_t retval ;
  symbol_h sym ;
  size_t namelen ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 660
  retval = (line_type_t )11;
#line 663
  if (! symstart) {
    {
    {
#line 663
    __assert_fail("symstart", "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c",
                  663U, "symbol_evaluate_status");
    }
    }
  }
#line 664
  if (! tail) {
#line 665
    if (! (! (io_public_h->line_num != 0))) {
      {
      {
#line 665
      __assert_fail("!((((1) ? (void) (0) : __assert_fail (\"1\", \"/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c\", 665, __PRETTY_FUNCTION__)),(io_public_h->line_num)) != 0)",
                    "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c", 665U, "symbol_evaluate_status");
      }
      }
    }
    {
    {
#line 666
    tail = chew_symbol(symstart);
    }
#line 667
    namelen = (size_t )(tail - symstart);
    }
  } else {
#line 670
    if (! (io_public_h->line_num != 0)) {
      {
      {
#line 670
      __assert_fail("((((1) ? (void) (0) : __assert_fail (\"1\", \"/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c\", 670, __PRETTY_FUNCTION__)),(io_public_h->line_num)) != 0)",
                    "/home/wslee/tests/SOURCES/coan-4.2.2/src/symbol.c", 670U, "symbol_evaluate_status");
      }
      }
    }
    {
    {
#line 671
    namelen = strlen(symstart);
    }
    }
  }
  {
  {
#line 673
  sym = configured_symbol_match(symstart, namelen);
  }
  }
#line 674
  if (! sym) {
    {
    {
#line 675
    sym = symbol_new(symstart, namelen);
    }
    }
  }
#line 677
  if (io_public_h->line_num != 0) {
#line 677
    if (define) {
      {
      {
#line 677
      tmp = eligible_line(4, 7);
      }
      }
#line 677
      if (tmp) {
        {
        {
#line 679
        report_symbol(sym);
        }
        }
      } else {
#line 677
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 677
    if (! define) {
      {
      {
#line 677
      tmp___0 = eligible_line(4, 8);
      }
      }
#line 677
      if (tmp___0) {
        {
        {
#line 679
        report_symbol(sym);
        }
        }
      }
    }
  }
  {
  {
#line 681
  tmp___1 = dropping_line();
  }
  }
#line 681
  if (! tmp___1) {
    {
    {
#line 682
    retval = configured_symbol_add(define, sym, tail, pend);
    }
    }
  }
  {
  {
#line 684
  tmp___2 = symbol_is_configured((symbol_const_h )sym);
  }
  }
#line 684
  if (! tmp___2) {
    {
    {
#line 685
    symbol_dispose(sym);
    }
    }
  }
#line 687
  return (retval);
}
}
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 64
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 57 "/home/wslee/tests/SOURCES/coan-4.2.2/src/state_utils.c"
void component_initor(_Bool is_static , _Bool is_zero_initable , void **state , void **public_state ,
                      void const   *initialiser , size_t size , void (*user_init)() ) 
{ 
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 67
  if (! is_static) {
#line 68
    if (! ((unsigned long )*state == (unsigned long )((void *)0))) {
      {
      {
#line 68
      __assert_fail("*state == ((void *)0)", "/home/wslee/tests/SOURCES/coan-4.2.2/src/state_utils.c",
                    68U, "component_initor");
      }
      }
    }
    {
    {
#line 69
    *state = zallocate(size);
    }
#line 70
    *public_state = *state;
    }
  }
#line 72
  if (is_zero_initable) {
    {
    {
#line 73
    memset(*state, 0, size);
    }
    }
  } else
#line 74
  if (initialiser) {
    {
    {
#line 75
    memcpy((void */* __restrict  */)*state, (void const   */* __restrict  */)initialiser,
           size);
    }
    }
  } else {
#line 77
    if (! user_init) {
      {
      {
#line 77
      __assert_fail("user_init", "/home/wslee/tests/SOURCES/coan-4.2.2/src/state_utils.c",
                    77U, "component_initor");
      }
      }
    }
    {
    {
#line 78
    (*user_init)(*state);
    }
    }
  }
#line 80
  return;
}
}
#line 82 "/home/wslee/tests/SOURCES/coan-4.2.2/src/state_utils.c"
void component_finitor(_Bool is_static , void **state , void **public_state , void (*user_finis)() ) 
{ 
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 89
  if (user_finis) {
#line 90
    if (! *state) {
      {
      {
#line 90
      __assert_fail("*state", "/home/wslee/tests/SOURCES/coan-4.2.2/src/state_utils.c",
                    90U, "component_finitor");
      }
      }
    }
    {
    {
#line 91
    (*user_finis)(*state);
    }
    }
  }
#line 93
  if (! is_static) {
#line 94
    if (! *state) {
      {
      {
#line 94
      __assert_fail("*state", "/home/wslee/tests/SOURCES/coan-4.2.2/src/state_utils.c",
                    94U, "component_finitor");
      }
      }
    }
    {
    {
#line 95
    release(state);
    }
#line 96
    *public_state = (void *)0;
    }
  }
#line 98
  return;
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 127 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 104 "/home/wslee/tests/SOURCES/coan-4.2.2/src/directives_tally.h"
char const   *get_directive_keyword(directive_type_t directive_type ) ;
#line 66 "/home/wslee/tests/SOURCES/coan-4.2.2/src/memory.h"
void *reallocate(void *ptr , size_t bytes ) ;
#line 70
void *callocate(size_t items , size_t size ) ;
#line 351 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.h"
void set_exit_flags(int bits , _Bool set ) ;
#line 359
int get_exit_flags(int bits ) ;
#line 389
int exitcode(void) ;
#line 395
size_t line_len(char const   *str ) ;
#line 402
void flatten_line(char *line ) ;
#line 467
void parse_error(int reason , char const   *format  , ...) ;
#line 475
void give_up_confused(void) ;
#line 487
void vbail(int reason , char const   *msg , va_list argp ) ;
#line 503
void debugging(_Bool on ) ;
#line 510
void debug(dbg_code_t how  , ...) ;
#line 517
void exit_diagnostics(void) ;
#line 521
void orphan_elif(void) ;
#line 525
void orphan_else(void) ;
#line 529
void orphan_endif(void) ;
#line 533
void early_eof(void) ;
#line 537
void processing_file(char const   *filename ) ;
#line 541
void entering_dir(char const   *dirname ) ;
#line 545
void leaving_dir(char const   *dirname ) ;
#line 582
size_t format_output(void *dest , int *buflen , int *startoff , char const   *format 
                     , ...) ;
#line 596
heap_str concatenate(size_t count , char **strs , int punctch ) ;
#line 655
void report_include(hash_include_const_h inc_arg ) ;
#line 672
void report_directive(canonical_string_const_h cl , directive_type_t directive_type ) ;
#line 689
void report_initor(void) ;
#line 690
void report_finitor(void) ;
#line 146 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 147
extern struct _IO_FILE *stderr ;
#line 339
extern int printf(char const   * __restrict  __format  , ...) ;
#line 341
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 348
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 367
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 562
extern int putchar(int __c ) ;
#line 662
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 170 "/home/wslee/tests/SOURCES/coan-4.2.2/src/io.h"
void io_toplevel(void) ;
#line 180 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.h"
args_public_state_t *args_public_h ;
#line 91 "/home/wslee/tests/SOURCES/coan-4.2.2/src/chew.h"
size_t eol(char const   *cp ) ;
#line 212
chew_public_state_t *chew_public_h ;
#line 110 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.h"
size_t if_start_line(void) ;
#line 114
size_t if_depth(void) ;
#line 118
if_state_t if_state(void) ;
#line 122
void if_control_toplevel(void) ;
#line 101 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_despatch.h"
line_despatch_public_state_t *line_despatch_public_h ;
#line 82 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__, __noreturn__)) void longjmp(struct __jmp_buf_tag *__env ,
                                                                int __val ) ;
#line 54 "/home/wslee/tests/SOURCES/coan-4.2.2/src/exception.h"
jmp_buf exception_context ;
#line 57
_Bool exceptions_enabled ;
#line 248 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.h"
size_t file_tree_count(file_tree_const_h ft , unsigned int flags , file_tree_count_t *counter ) ;
#line 94 "/home/wslee/tests/SOURCES/coan-4.2.2/src/dataset.h"
dataset_public_state_t *dataset_public_h ;
#line 57 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
static char const   * const  comment_name[6]  = {      (char const   */* const  */)"NO",      (char const   */* const  */)"C",      (char const   */* const  */)"CXX",      (char const   */* const  */)"STARTING", 
        (char const   */* const  */)"FINISHING",      (char const   */* const  */)"PSEUDO"};
#line 62 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
static char const   * const  linestate_name[3]  = {      (char const   */* const  */)"VACANT",      (char const   */* const  */)"DIRECTIVE",      (char const   */* const  */)"CODE"};
#line 67 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
static char const   * const  ifstate_name[10]  = 
#line 67
  {      (char const   */* const  */)"OUTSIDE",      (char const   */* const  */)"FALSE_PREFIX",      (char const   */* const  */)"TRUE_PREFIX",      (char const   */* const  */)"PASS_MIDDLE", 
        (char const   */* const  */)"FALSE_MIDDLE",      (char const   */* const  */)"TRUE_MIDDLE",      (char const   */* const  */)"PASS_ELSE",      (char const   */* const  */)"FALSE_ELSE", 
        (char const   */* const  */)"TRUE_ELSE",      (char const   */* const  */)"FALSE_TRAILER"};
#line 75 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
static char const   * const  linetype_name[29]  = 
#line 75
  {      (char const   */* const  */)"TRUEI",      (char const   */* const  */)"FALSEI",      (char const   */* const  */)"IF",      (char const   */* const  */)"TRUE", 
        (char const   */* const  */)"FALSE",      (char const   */* const  */)"ELIF",      (char const   */* const  */)"ELTRUE",      (char const   */* const  */)"ELFALSE", 
        (char const   */* const  */)"ELSE",      (char const   */* const  */)"ENDIF",      (char const   */* const  */)"DODGY TRUEI",      (char const   */* const  */)"DODGY FALSEI", 
        (char const   */* const  */)"DODGY IF",      (char const   */* const  */)"DODGY TRUE",      (char const   */* const  */)"DODGY FALSE",      (char const   */* const  */)"DODGY ELIF", 
        (char const   */* const  */)"DODGY ELTRUE",      (char const   */* const  */)"DODGY ELFALSE",      (char const   */* const  */)"DODGY ELSE",      (char const   */* const  */)"DODGY ENDIF", 
        (char const   */* const  */)"PLAIN",      (char const   */* const  */)"EOF",      (char const   */* const  */)"CONSISTENT DEFINE KEEP",      (char const   */* const  */)"CONSISTENT DEFINE DROP", 
        (char const   */* const  */)"CONTRADICTORY DEFINE",      (char const   */* const  */)"DIFFERING DEFINE",      (char const   */* const  */)"CONSISTENT UNDEF KEEP",      (char const   */* const  */)"CONSISTENT UNDEF DROP", 
        (char const   */* const  */)"CONTRADICTORY UNDEF"};
#line 93 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
static char const   *get_comment_type_name(void) 
{ 


  {
#line 96
  return ((char const   *)comment_name[chew_public_h->comment_state]);
}
}
#line 102 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
static char const   *get_linestate_name(void) 
{ 


  {
#line 105
  return ((char const   *)linestate_name[chew_public_h->line_state]);
}
}
#line 111 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
static char const   *if_state_name(void) 
{ 
  if_state_t tmp ;

  {
  {
  {
#line 114
  tmp = if_state();
  }
  }
#line 114
  return ((char const   *)ifstate_name[tmp]);
}
}
#line 122 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
static char const   *get_linetype_name(line_type_t type ) 
{ 


  {
#line 125
  return ((char const   *)linetype_name[type]);
}
}
#line 137 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
static size_t vformat_output(void *dest , int *buflen , int *startoff , char const   *format ,
                             va_list argp ) 
{ 
  size_t written ;
  char *buf ;
  size_t spare ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  FILE *out ;
  int tmp___4 ;

  {
#line 145
  if (*buflen >= 0) {
#line 146
    buf = *((heap_str *)dest);
#line 148
    if (*buflen == 0) {
      {
#line 149
      *buflen = 1024;
#line 150
      *startoff = 0;
      {
#line 151
      release((void **)dest);
      }
      {
#line 152
      tmp = zallocate((size_t )*buflen);
      }
#line 152
      buf = (char *)tmp;
      }
    }
    {
#line 154
    spare = (size_t )(*buflen - *startoff);
    {
#line 155
    tmp___0 = vsnprintf((char */* __restrict  */)(buf + *startoff), spare, (char const   */* __restrict  */)format,
                        argp);
    }
#line 155
    written = (size_t )tmp___0;
    }
    {
    {
#line 156
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 156
      if (! (written >= spare)) {
#line 156
        goto while_break;
      }
      {
#line 157
      spare += (size_t )*buflen;
#line 158
      tmp___1 = *buflen >> 1;
#line 158
      *buflen = tmp___1;
      {
#line 158
      tmp___2 = reallocate((void *)buf, (size_t )tmp___1);
      }
#line 158
      buf = (char *)tmp___2;
      {
#line 159
      tmp___3 = vsnprintf((char */* __restrict  */)(buf + *startoff), spare, (char const   */* __restrict  */)format,
                          argp);
      }
#line 159
      written = (size_t )tmp___3;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 161
    *((heap_str *)dest) = buf;
#line 162
    *startoff += (int )written;
  } else {
    {
#line 164
    out = (FILE *)dest;
    {
#line 165
    tmp___4 = vfprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)format,
                       argp);
    }
#line 165
    written = (size_t )tmp___4;
    }
  }
#line 167
  return (written);
}
}
#line 179
static void vreport(reason_code_t reason , heap_str *bufp , char const   *format ,
                    va_list argp ) ;
#line 203 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
static report_state_t report_state  ;
#line 203 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
report_state_t *report_h  =    & report_state;
#line 203 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
report_public_state_t *report_public_h  =    & report_state;
#line 203 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
static report_state_t const   * const  report_static_initialiser_h  ;
#line 203 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
void (*report_init_h)(report_state_t * )  ;
#line 203 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
void (*report_finis_h)(report_state_t * )  ;
#line 203 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
void report_initor(void) 
{ 


  {
  {
  {
#line 203
  component_initor((_Bool)1, (_Bool)1, (void **)((char *)(& report_h)), (void **)((char *)(& report_public_h)),
                   (void const   *)report_static_initialiser_h, sizeof(report_state_t ),
                   (void (*)())report_init_h);
  }
  }
#line 203
  return;
}
}
#line 203 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
void report_finitor(void) 
{ 


  {
  {
  {
#line 203
  component_finitor((_Bool)1, (void **)((char *)(& report_h)), (void **)((char *)(& report_public_h)),
                    (void (*)())report_init_h);
  }
  }
#line 203
  return;
}
}
#line 207 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
static void vreport(reason_code_t reason , heap_str *bufp , char const   *format ,
                    va_list argp ) 
{ 
  int mask ;
  char *mess ;
  void *dest ;
  int buflen ;
  int startoff ;
  size_t depth ;
  size_t tmp ;
  char *category ;
  size_t tmp___0 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 210
  if (args_public_h->got_opts) {
#line 210
    if ((unsigned int )reason != 0U) {
#line 211
      mask = args_public_h->diagnostic_filter;
#line 212
      if (mask) {
#line 212
        if (((unsigned int )reason & (unsigned int )mask) != 0U) {
#line 214
          report_state.exitstat |= (unsigned int )reason & 454656U;
#line 215
          if (bufp) {
#line 216
            *bufp = (heap_str )((void *)0);
          }
#line 218
          return;
        }
      }
    }
  }
#line 221
  if (! format) {
#line 222
    if (! bufp) {
      {
      {
#line 222
      __assert_fail("bufp", "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c", 222U,
                    "vreport");
      }
      }
    }
#line 223
    if (*bufp) {
      {
#line 224
      mess = *bufp;
      {
#line 225
      fputs((char const   */* __restrict  */)mess, (FILE */* __restrict  */)stderr);
      }
      {
#line 226
      release((void **)bufp);
      }
      }
    }
  } else {
    {
#line 231
    startoff = 0;
    {
#line 232
    tmp = if_depth();
    }
#line 232
    depth = tmp;
    }
#line 233
    if (! bufp) {
#line 234
      dest = (void *)stderr;
#line 235
      buflen = -1;
    } else {
#line 237
      dest = (void *)bufp;
#line 238
      buflen = 0;
    }
    {
    {
#line 240
    format_output(dest, & buflen, & startoff, "%s: ", args_public_h->prog_name);
    }
    }
#line 241
    if (! args_public_h->got_opts) {
      {
      {
#line 242
      format_output(dest, & buflen, & startoff, "while parsing options: ");
      }
      }
    }
#line 244
    if (io_public_h->filename) {
      {
      {
#line 245
      format_output(dest, & buflen, & startoff, "%s: ", io_public_h->filename);
      }
      }
    }
#line 248
    if (io_public_h->line_num) {
      {
      {
#line 249
      format_output(dest, & buflen, & startoff, "line %d: ", io_public_h->line_num);
      }
      }
    }
#line 252
    if ((unsigned int )reason & 2047U) {
#line 253
      category = (char *)((void *)0);
      {
#line 255
      if (((unsigned int )reason & 456704U) == 2048U) {
#line 255
        goto case_2048;
      }
#line 258
      if (((unsigned int )reason & 456704U) == 4096U) {
#line 258
        goto case_4096;
      }
#line 261
      if (((unsigned int )reason & 456704U) == 8192U) {
#line 261
        goto case_8192;
      }
#line 264
      if (((unsigned int )reason & 456704U) == 16384U) {
#line 264
        goto case_16384;
      }
#line 267
      if (((unsigned int )reason & 456704U) == 32768U) {
#line 267
        goto case_32768;
      }
#line 270
      goto switch_default;
      case_2048: /* CIL Label */ 
#line 256
      category = (char *)"progress";
#line 257
      goto switch_break;
      case_4096: /* CIL Label */ 
#line 259
      category = (char *)"info";
#line 260
      goto switch_break;
      case_8192: /* CIL Label */ 
#line 262
      category = (char *)"warning";
#line 263
      goto switch_break;
      case_16384: /* CIL Label */ 
#line 265
      category = (char *)"error";
#line 266
      goto switch_break;
      case_32768: /* CIL Label */ 
#line 268
      category = (char *)"abend";
#line 269
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
      {
#line 271
      __assert_fail("0", "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c", 271U,
                    "vreport");
      }
      }
      switch_break: /* CIL Label */ ;
      }
      {
      {
#line 273
      format_output(dest, & buflen, & startoff, "%s 0x%05x: ", category, (unsigned int )reason);
      }
#line 274
      report_state.exitstat |= (unsigned int )reason & 454656U;
      }
    }
    {
    {
#line 276
    vformat_output(dest, & buflen, & startoff, format, argp);
    }
    }
#line 277
    if (depth > 0UL) {
      {
      {
#line 278
      tmp___0 = if_start_line();
      }
      {
#line 278
      format_output(dest, & buflen, & startoff, " (#if line %d depth %d)", (int )tmp___0,
                    (int )depth);
      }
      }
    }
    {
    {
#line 281
    format_output(dest, & buflen, & startoff, "\n");
    }
    }
  }
#line 283
  return;
}
}
#line 288 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
void flatten_line(char *line ) 
{ 
  size_t len ;
  size_t tmp ;
  char tmp___0 ;

  {
  {
  {
#line 291
  tmp = line_len((char const   *)line);
  }
#line 291
  len = tmp;
  }
  {
  {
#line 292
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 292
    if (len) {
#line 292
      if (! *line) {
#line 292
        goto while_break;
      }
    } else {
#line 292
      goto while_break;
    }
#line 293
    if ((int )*line == 92) {
#line 293
      if ((int )*(line + 1) == 10) {
#line 294
        tmp___0 = (char )' ';
#line 294
        *(line + 1) = tmp___0;
#line 294
        *line = tmp___0;
      } else {
#line 293
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 296
    if ((int )*line == 10) {
#line 297
      *line = (char )' ';
    } else
#line 296
    if ((int )*line == 13) {
#line 297
      *line = (char )' ';
    } else
#line 296
    if ((int )*line == 9) {
#line 297
      *line = (char )' ';
    }
#line 292
    line ++;
#line 292
    len --;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 300
  return;
}
}
#line 303 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
size_t line_len(char const   *str ) 
{ 
  size_t len ;
  size_t tmp ;
  char const   *last_ch ;
  char const   *last_but_1_ch ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
  {
#line 307
  tmp = strlen(str);
  }
#line 307
  len = tmp;
#line 308
  last_ch = (str + len) - 1;
#line 309
  last_but_1_ch = last_ch - 1;
  {
#line 310
  tmp___1 = eol(last_but_1_ch);
  }
  }
#line 310
  if (tmp___1) {
#line 313
    len -= 2UL;
  } else {
    {
    {
#line 314
    tmp___0 = eol(last_ch);
    }
    }
#line 314
    if (tmp___0) {
#line 316
      len --;
    }
  }
#line 318
  return (len);
}
}
#line 321 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
int exitcode(void) 
{ 
  unsigned int severities ;
  unsigned int summaries ;
  unsigned int ret ;

  {
#line 326
  ret = report_state.exitstat;
#line 327
  if (line_despatch_public_h->lines_inactive) {
#line 328
    ret |= 4097U;
  }
#line 330
  if (line_despatch_public_h->lines_changed) {
#line 331
    ret |= 4098U;
  }
#line 333
  report_state.exitstat = ret;
#line 335
  severities = ret >> 12;
#line 336
  summaries = (ret & 15U) << 4;
#line 337
  return ((int )(severities | summaries));
}
}
#line 340 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
int get_exit_flags(int bits ) 
{ 


  {
#line 343
  return ((int )((unsigned int )(bits & 456719) & report_state.exitstat));
}
}
#line 347 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
void set_exit_flags(int bits , _Bool set ) 
{ 


  {
#line 350
  bits &= 456719;
#line 351
  if (set) {
#line 352
    report_state.exitstat |= (unsigned int )bits;
  } else {
#line 354
    report_state.exitstat &= (unsigned int )(~ bits);
  }
#line 356
  return;
}
}
#line 358 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
size_t format_output(void *dest , int *buflen , int *startoff , char const   *format 
                     , ...) 
{ 
  size_t written ;
  va_list argp ;

  {
  {
  {
#line 363
  __builtin_va_start(argp, format);
  }
  {
#line 364
  written = vformat_output(dest, buflen, startoff, format, argp);
  }
  {
#line 365
  __builtin_va_end(argp);
  }
  }
#line 366
  return (written);
}
}
#line 370 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
void report(reason_code_t reason , heap_str *buf , char const   *format  , ...) 
{ 
  va_list argp ;

  {
  {
  {
#line 374
  __builtin_va_start(argp, format);
  }
  {
#line 375
  vreport(reason, buf, format, argp);
  }
  {
#line 376
  __builtin_va_end(argp);
  }
  }
#line 377
  return;
}
}
#line 379 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
void parse_error(int reason , char const   *format  , ...) 
{ 
  va_list argp ;

  {
  {
  {
#line 383
  __builtin_va_start(argp, format);
  }
  {
#line 384
  vbail(reason, format, argp);
  }
  {
#line 385
  __builtin_va_end(argp);
  }
  }
#line 386
  return;
}
}
#line 388 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
void give_up_confused(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 391
  bail(33184, "Bailing out in confusion");
  }
  }
#line 392
  return;
}
}
#line 394 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
void vbail(int reason , char const   *msg , va_list argp ) 
{ 
  int tmp ;

  {
#line 397
  if (msg) {
    {
    {
#line 398
    vreport((reason_code_t )reason, (heap_str *)((void *)0), msg, argp);
    }
    }
  } else {
#line 400
    report_state.exitstat |= (unsigned int )(reason & 454656);
  }
#line 402
  if (exceptions_enabled) {
#line 402
    if ((reason & 454656) != 32768) {
      {
      {
#line 404
      longjmp((struct __jmp_buf_tag *)(exception_context), reason);
      }
      }
    }
  }
  {
  {
#line 406
  tmp = exitcode();
  }
  {
#line 406
  exit(tmp);
  }
  }
}
}
#line 410 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
void bail(int reason , char const   *format  , ...) 
{ 
  va_list argp ;

  {
  {
  {
#line 414
  __builtin_va_start(argp, format);
  }
  {
#line 415
  vbail(reason, format, argp);
  }
  {
#line 416
  __builtin_va_end(argp);
  }
  }
#line 417
  return;
}
}
#line 419 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
void debugging(_Bool on ) 
{ 


  {
#line 422
  report_state.dbg = on;
#line 423
  return;
}
}
#line 425 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
void debug(dbg_code_t how  , ...) 
{ 
  va_list ap ;
  size_t safelen ;
  size_t tmp___0 ;
  char const   *define ;
  char const   *tmp___2 ;
  int linetype ;
  int tmp___4 ;
  char const   *linetype_name___0 ;
  char const   *tmp___5 ;
  size_t safelen___0 ;
  size_t tmp___7 ;
  char const   *define___0 ;
  char const   *tmp___9 ;
  int linetype___0 ;
  int tmp___11 ;
  char const   *linetype_name___1 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  int linetype___1 ;
  int tmp___16 ;
  size_t tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;

  {
#line 428
  if (report_state.dbg) {
    {
    {
#line 430
    __builtin_va_start(ap, how);
    }
    }
    {
#line 432
    if ((unsigned int )how == 1U) {
#line 432
      goto case_1;
    }
#line 435
    if ((unsigned int )how == 2U) {
#line 435
      goto case_2;
    }
#line 438
    if ((unsigned int )how == 3U) {
#line 438
      goto case_3;
    }
#line 441
    if ((unsigned int )how == 4U) {
#line 441
      goto case_4;
    }
#line 444
    if ((unsigned int )how == 5U) {
#line 444
      goto case_5;
    }
#line 447
    if ((unsigned int )how == 6U) {
#line 447
      goto case_6;
    }
#line 450
    if ((unsigned int )how == 8U) {
#line 450
      goto case_8;
    }
#line 453
    if ((unsigned int )how == 7U) {
#line 453
      goto case_7;
    }
#line 456
    if ((unsigned int )how == 9U) {
#line 456
      goto case_9;
    }
#line 459
    if ((unsigned int )how == 10U) {
#line 459
      goto case_10;
    }
#line 462
    if ((unsigned int )how == 11U) {
#line 462
      goto case_11;
    }
#line 465
    if ((unsigned int )how == 12U) {
#line 465
      goto case_12;
    }
#line 468
    if ((unsigned int )how == 13U) {
#line 468
      goto case_13;
    }
#line 471
    if ((unsigned int )how == 14U) {
#line 471
      goto case_14;
    }
#line 480
    if ((unsigned int )how == 15U) {
#line 480
      goto case_15;
    }
#line 483
    if ((unsigned int )how == 16U) {
#line 483
      goto case_16;
    }
#line 492
    if ((unsigned int )how == 17U) {
#line 492
      goto case_17;
    }
#line 496
    if ((unsigned int )how == 18U) {
#line 496
      goto case_18;
    }
#line 499
    if ((unsigned int )how == 19U) {
#line 499
      goto case_19;
    }
#line 507
    if ((unsigned int )how == 20U) {
#line 507
      goto case_20;
    }
#line 510
    if ((unsigned int )how == 21U) {
#line 510
      goto case_21;
    }
#line 513
    if ((unsigned int )how == 22U) {
#line 513
      goto case_22;
    }
#line 516
    goto switch_default;
    case_1: /* CIL Label */ 
    {
    {
#line 433
    vreport((reason_code_t )0, (heap_str *)((void *)0), "eval%d !", ap);
    }
    }
#line 434
    goto switch_break;
    case_2: /* CIL Label */ 
    {
    {
#line 436
    vreport((reason_code_t )0, (heap_str *)((void *)0), "eval%d (", ap);
    }
    }
#line 437
    goto switch_break;
    case_3: /* CIL Label */ 
    {
    {
#line 439
    vreport((reason_code_t )0, (heap_str *)((void *)0), "eval%d number", ap);
    }
    }
#line 440
    goto switch_break;
    case_4: /* CIL Label */ 
    {
    {
#line 442
    vreport((reason_code_t )0, (heap_str *)((void *)0), "eval%d defined", ap);
    }
    }
#line 443
    goto switch_break;
    case_5: /* CIL Label */ 
    {
    {
#line 445
    vreport((reason_code_t )0, (heap_str *)((void *)0), "eval%d symbol", ap);
    }
    }
#line 446
    goto switch_break;
    case_6: /* CIL Label */ 
    {
    {
#line 448
    vreport((reason_code_t )0, (heap_str *)((void *)0), "eval%d bad expr", ap);
    }
    }
#line 449
    goto switch_break;
    case_8: /* CIL Label */ 
    {
    {
#line 451
    vreport((reason_code_t )0, (heap_str *)((void *)0), "eval%d = %d", ap);
    }
    }
#line 452
    goto switch_break;
    case_7: /* CIL Label */ 
    {
    {
#line 454
    vreport((reason_code_t )0, (heap_str *)((void *)0), "eval%d", ap);
    }
    }
#line 455
    goto switch_break;
    case_9: /* CIL Label */ 
    {
    {
#line 457
    vreport((reason_code_t )0, (heap_str *)((void *)0), "eval%d %s", ap);
    }
    }
#line 458
    goto switch_break;
    case_10: /* CIL Label */ 
    {
    {
#line 460
    vreport((reason_code_t )0, (heap_str *)((void *)0), "eval%d = %d", ap);
    }
    }
#line 461
    goto switch_break;
    case_11: /* CIL Label */ 
    {
    {
#line 463
    vreport((reason_code_t )0, (heap_str *)((void *)0), "eval %s", ap);
    }
    }
#line 464
    goto switch_break;
    case_12: /* CIL Label */ 
    {
    {
#line 466
    vreport((reason_code_t )0, (heap_str *)((void *)0), "eval = %d", ap);
    }
    }
#line 467
    goto switch_break;
    case_13: /* CIL Label */ 
    {
    {
#line 469
    vreport((reason_code_t )0, (heap_str *)((void *)0), "eval #define %.*s", ap);
    }
    }
#line 470
    goto switch_break;
    case_14: /* CIL Label */ 
    {
    {
#line 472
    tmp___0 = __builtin_va_arg(ap, size_t );
    }
#line 472
    safelen = tmp___0;
    {
#line 473
    tmp___2 = __builtin_va_arg(ap, char const   *);
    }
#line 473
    define = tmp___2;
    {
#line 474
    tmp___4 = __builtin_va_arg(ap, int );
    }
#line 474
    linetype = tmp___4;
    {
#line 475
    tmp___5 = get_linetype_name((line_type_t )linetype);
    }
#line 475
    linetype_name___0 = tmp___5;
    {
#line 476
    report((reason_code_t )0, (heap_str *)((void *)0), "eval #define %.*s = %s", safelen,
           define, linetype_name___0);
    }
    }
#line 478
    goto switch_break;
    case_15: /* CIL Label */ 
    {
    {
#line 481
    vreport((reason_code_t )0, (heap_str *)((void *)0), "eval #undef %.*s", ap);
    }
    }
#line 482
    goto switch_break;
    case_16: /* CIL Label */ 
    {
    {
#line 484
    tmp___7 = __builtin_va_arg(ap, size_t );
    }
#line 484
    safelen___0 = tmp___7;
    {
#line 485
    tmp___9 = __builtin_va_arg(ap, char const   *);
    }
#line 485
    define___0 = tmp___9;
    {
#line 486
    tmp___11 = __builtin_va_arg(ap, int );
    }
#line 486
    linetype___0 = tmp___11;
    {
#line 487
    tmp___12 = get_linetype_name((line_type_t )linetype___0);
    }
#line 487
    linetype_name___1 = tmp___12;
    {
#line 488
    report((reason_code_t )0, (heap_str *)((void *)0), "eval #undef %.*s = %s", safelen___0,
           define___0, linetype_name___1);
    }
    }
#line 490
    goto switch_break;
    case_17: /* CIL Label */ 
    {
    {
#line 493
    tmp___13 = get_linestate_name();
    }
    {
#line 493
    tmp___14 = get_comment_type_name();
    }
    {
#line 493
    report((reason_code_t )0, (heap_str *)((void *)0), "parser %s comment %s line",
           tmp___14, tmp___13);
    }
    }
#line 495
    goto switch_break;
    case_18: /* CIL Label */ 
    {
    {
#line 497
    vreport((reason_code_t )0, (heap_str *)((void *)0), "symbol_table_seek %s %s",
            ap);
    }
    }
#line 498
    goto switch_break;
    case_19: /* CIL Label */ 
    {
    {
#line 500
    tmp___16 = __builtin_va_arg(ap, int );
    }
#line 500
    linetype___1 = tmp___16;
    {
#line 501
    tmp___17 = if_depth();
    }
    {
#line 501
    tmp___18 = if_state_name();
    }
    {
#line 501
    tmp___19 = get_linetype_name((line_type_t )linetype___1);
    }
    {
#line 501
    report((reason_code_t )0, (heap_str *)((void *)0), "process %s -> %s depth %d",
           tmp___19, tmp___18, tmp___17);
    }
    }
#line 505
    goto switch_break;
    case_20: /* CIL Label */ 
    {
    {
#line 508
    vreport((reason_code_t )0, (heap_str *)((void *)0), "eval%d +", ap);
    }
    }
#line 509
    goto switch_break;
    case_21: /* CIL Label */ 
    {
    {
#line 511
    vreport((reason_code_t )0, (heap_str *)((void *)0), "eval%d -", ap);
    }
    }
#line 512
    goto switch_break;
    case_22: /* CIL Label */ 
    {
    {
#line 514
    vreport((reason_code_t )0, (heap_str *)((void *)0), "eval%d ~", ap);
    }
    }
#line 515
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    {
#line 517
    __assert_fail("0", "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c", 517U,
                  "debug");
    }
    }
    switch_break: /* CIL Label */ ;
    }
    {
    {
#line 519
    __builtin_va_end(ap);
    }
    }
  }
#line 521
  return;
}
}
#line 523 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
void exit_diagnostics(void) 
{ 
  size_t infiles ;
  size_t tmp ;
  unsigned int donefiles ;
  unsigned int errorfiles ;
  char *diagnostic_status ;
  int ret ;
  int tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
  {
#line 526
  tmp = file_tree_count((file_tree_const_h )dataset_public_h->file_tree, 1U, (file_tree_count_t *)((void *)0));
  }
#line 526
  infiles = tmp;
#line 528
  donefiles = dataset_public_h->donefiles;
#line 529
  errorfiles = dataset_public_h->errorfiles;
#line 530
  diagnostic_status = (char *)"";
  {
#line 532
  tmp___0 = exitcode();
  }
#line 532
  ret = tmp___0;
  {
#line 533
  if_control_toplevel();
  }
  {
#line 534
  io_toplevel();
  }
  }
#line 536
  if (report_state.exitstat & 32768U) {
#line 537
    diagnostic_status = (char *)" ABNORMALLY";
  } else
#line 538
  if (report_state.exitstat & 16384U) {
#line 539
    diagnostic_status = (char *)" with errors";
  } else
#line 540
  if (report_state.exitstat & 8192U) {
#line 541
    diagnostic_status = (char *)" with warnings";
  } else
#line 542
  if (report_state.exitstat & 4096U) {
#line 543
    diagnostic_status = (char *)" with remarks";
  }
  {
  {
#line 545
  report((reason_code_t )68496, (heap_str *)((void *)0), "Completed%s, exit code 0x%02x",
         diagnostic_status, ret);
  }
  }
#line 547
  if (infiles) {
    {
    {
#line 548
    report((reason_code_t )70512, (heap_str *)((void *)0), "%d out of %d input files were reached; %d files were not reached",
           donefiles, infiles, infiles - (size_t )donefiles);
    }
    {
#line 551
    report((reason_code_t )70528, (heap_str *)((void *)0), "%d out %d files reached were valid; %d were abandoned due to parse errors",
           donefiles - errorfiles, donefiles, errorfiles);
    }
    }
#line 555
    if (infiles == (size_t )donefiles) {
#line 555
      if (errorfiles == 0U) {
#line 556
        if ((report_state.exitstat & 69633U) & 2047U) {
          {
          {
#line 558
          report((reason_code_t )69633, (heap_str *)((void *)0), "Input lines were dropped");
          }
          }
        }
#line 561
        if ((report_state.exitstat & 69634U) & 2047U) {
          {
          {
#line 563
          report((reason_code_t )69634, (heap_str *)((void *)0), "Input lines were changed");
          }
          }
        }
#line 566
        if ((report_state.exitstat & 73732U) & 2047U) {
          {
          {
#line 568
          report((reason_code_t )73732, (heap_str *)((void *)0), "Input lines were changed to #error directives");
          }
          }
        }
#line 572
        if ((report_state.exitstat & 73736U) & 2047U) {
          {
          {
#line 574
          report((reason_code_t )73732, (heap_str *)((void *)0), "Unconditional #error directives are operative");
          }
          }
        }
      }
    }
  }
#line 580
  return;
}
}
#line 582 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
void orphan_elif(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 585
  parse_error(16512, "Orphan #elif");
  }
  }
#line 586
  return;
}
}
#line 588 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
void orphan_else(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 591
  parse_error(16528, "Orphan #else");
  }
  }
#line 592
  return;
}
}
#line 594 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
void orphan_endif(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 597
  parse_error(16544, "Orphan #endif");
  }
  }
#line 598
  return;
}
}
#line 600 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
void early_eof(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 603
  parse_error(16560, "Unexpected EOF");
  }
  }
#line 604
  return;
}
}
#line 606 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
void processing_file(char const   *filename ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 609
  report((reason_code_t )2768, (heap_str *)((void *)0), "Processing file \"%s\"",
         filename);
  }
  }
#line 610
  return;
}
}
#line 612 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
void entering_dir(char const   *dirname ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 615
  report((reason_code_t )2784, (heap_str *)((void *)0), "Entering directory \"%s\"",
         dirname);
  }
  }
#line 616
  return;
}
}
#line 618 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
void leaving_dir(char const   *dirname ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 621
  report((reason_code_t )2800, (heap_str *)((void *)0), "Leaving directory \"%s\"",
         dirname);
  }
  }
#line 622
  return;
}
}
#line 624 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
heap_str concatenate(size_t count , char **strs , int punctch ) 
{ 
  heap_str concat ;
  char *posn ;
  size_t *lengths ;
  void *tmp ;
  size_t buflen ;
  size_t punctsz ;
  size_t tmp___0 ;
  size_t i ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
  {
  {
#line 629
  tmp = callocate(count, sizeof(size_t ));
  }
#line 629
  lengths = (size_t *)tmp;
#line 630
  buflen = (size_t )0;
  }
#line 631
  if (punctch == -1) {
#line 631
    tmp___0 = (size_t )0;
  } else {
#line 631
    tmp___0 = count - 1UL;
  }
#line 631
  punctsz = tmp___0;
#line 632
  i = (size_t )0;
  {
  {
#line 633
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 633
    if (! (i < count)) {
#line 633
      goto while_break;
    }
    {
    {
#line 634
    tmp___1 = strlen((char const   *)*(strs + i));
    }
#line 634
    *(lengths + i) = tmp___1;
#line 634
    buflen += tmp___1;
#line 633
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 636
  buflen += punctsz + 2UL;
  {
#line 637
  tmp___2 = zallocate(buflen);
  }
#line 637
  concat = (heap_str )tmp___2;
#line 638
  posn = concat;
#line 639
  i = (size_t )0;
  }
  {
  {
#line 639
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 639
    if (! (i < count)) {
#line 639
      goto while_break___0;
    }
    {
    {
#line 640
    strcpy((char */* __restrict  */)posn, (char const   */* __restrict  */)*(strs + i));
    }
#line 641
    posn += *(lengths + i);
    }
#line 642
    if (punctch != -1) {
#line 643
      tmp___3 = posn;
#line 643
      posn ++;
#line 643
      *tmp___3 = (char )punctch;
    }
#line 639
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 646
  if (punctch != -1) {
#line 647
    *(posn + -1) = (char )'\000';
  }
  {
  {
#line 649
  free((void *)lengths);
  }
  }
#line 650
  return (concat);
}
}
#line 653 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
void report_symbol(symbol_h sym ) 
{ 
  char const   *tmp ;
  canonical_string_const_h resolved ;
  canonical_string_const_h tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
  {
#line 656
  tmp___5 = symbol_reported((symbol_const_h )sym);
  }
  }
#line 656
  if (tmp___5) {
#line 656
    if (! args_public_h->list_only_once) {
      _L: /* CIL Label */ 
      {
      {
#line 657
      tmp = symbol_name((symbol_const_h )sym);
      }
      {
#line 657
      printf((char const   */* __restrict  */)"%s", tmp);
      }
      }
#line 658
      if (args_public_h->resolve_symbols) {
        {
        {
#line 659
        tmp___0 = symbol_resolve(sym, (ptr_vector_h )((void *)0));
        }
#line 659
        resolved = tmp___0;
        {
#line 660
        tmp___2 = canonical_string_text(resolved);
        }
        {
#line 660
        tmp___3 = symbol_name((symbol_const_h )sym);
        }
        {
#line 660
        tmp___4 = strcmp(tmp___3, tmp___2);
        }
        }
#line 660
        if (tmp___4) {
          {
          {
#line 661
          tmp___1 = canonical_string_text(resolved);
          }
          {
#line 661
          printf((char const   */* __restrict  */)": resolves as <|%s|>", tmp___1);
          }
          }
        } else {
          {
          {
#line 664
          fputs((char const   */* __restrict  */)": insoluble", (FILE */* __restrict  */)stdout);
          }
          }
        }
      }
#line 667
      if (args_public_h->list_locate) {
        {
        {
#line 668
        printf((char const   */* __restrict  */)": %s(%d)", io_public_h->filename,
               io_public_h->line_num);
        }
        }
      }
      {
      {
#line 670
      putchar('\n');
      }
#line 671
      sym->flags |= 256;
      }
    }
  } else {
#line 656
    goto _L;
  }
#line 673
  return;
}
}
#line 676 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
void report_include(hash_include_const_h inc_arg ) 
{ 
  canonical_string_const_h sym_def ;
  canonical_string_const_h tmp ;
  char const   *tmp___0 ;
  char const   *def_text ;
  char const   *tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 679
  tmp = symbol_definition(inc_arg);
  }
#line 679
  sym_def = tmp;
  {
#line 680
  tmp___0 = symbol_name(inc_arg);
  }
  {
#line 680
  printf((char const   */* __restrict  */)"#include %s", tmp___0);
  }
  }
#line 681
  if (sym_def) {
    {
    {
#line 682
    tmp___1 = canonical_string_text(sym_def);
    }
#line 682
    def_text = tmp___1;
    {
#line 683
    printf((char const   */* __restrict  */)": defined symbol, resolves as \"%s\"",
           def_text);
    }
    }
  }
#line 685
  if (args_public_h->list_locate) {
    {
    {
#line 686
    printf((char const   */* __restrict  */)": %s(%d)", io_public_h->filename, io_public_h->line_num);
    }
    }
  }
  {
  {
#line 688
  putchar('\n');
  }
  }
#line 689
  return;
}
}
#line 691 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
void report_directive(canonical_string_const_h cl , directive_type_t directive_type ) 
{ 
  char const   **hash_keywords ;
  int ind ;
  char const   *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 694
  hash_keywords = report_state.hash_keywords;
#line 695
  if (! *(hash_keywords + 1)) {
#line 696
    ind = 0;
#line 697
    ind ++;
    {
    {
#line 697
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 697
      if (! (ind < 12)) {
#line 697
        goto while_break;
      }
      {
      {
#line 698
      *(hash_keywords + ind) = get_directive_keyword((directive_type_t )ind);
      }
#line 697
      ind ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
  {
#line 701
  tmp = canonical_string_text(cl);
  }
  {
#line 701
  printf((char const   */* __restrict  */)"#%s %s", *(hash_keywords + directive_type),
         tmp);
  }
  }
#line 702
  if (args_public_h->list_locate) {
    {
    {
#line 703
    printf((char const   */* __restrict  */)": %s(%d)", io_public_h->filename, io_public_h->line_num);
    }
    }
  }
  {
  {
#line 705
  putchar('\n');
  }
  }
#line 706
  return;
}
}
#line 711 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
static char numeral[48]  ;
#line 708 "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c"
char *format_int(int_spec_t const   *int_spec ) 
{ 
  void *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 714
  if ((unsigned int const   )int_spec->type == 65792U) {
#line 714
    goto case_65792;
  }
#line 714
  if ((unsigned int const   )int_spec->type == 65793U) {
#line 714
    goto case_65792;
  }
#line 717
  if ((unsigned int const   )int_spec->type == 131585U) {
#line 717
    goto case_131585;
  }
#line 720
  if ((unsigned int const   )int_spec->type == 131584U) {
#line 720
    goto case_131584;
  }
#line 723
  if ((unsigned int const   )int_spec->type == 197633U) {
#line 723
    goto case_197633;
  }
#line 726
  if ((unsigned int const   )int_spec->type == 197632U) {
#line 726
    goto case_197632;
  }
#line 729
  if ((unsigned int const   )int_spec->type == 264193U) {
#line 729
    goto case_264193;
  }
#line 732
  if ((unsigned int const   )int_spec->type == 264192U) {
#line 732
    goto case_264192;
  }
#line 735
  if ((unsigned int const   )int_spec->type == 329729U) {
#line 735
    goto case_329729;
  }
#line 738
  if ((unsigned int const   )int_spec->type == 329728U) {
#line 738
    goto case_329728;
  }
#line 741
  goto switch_default;
  case_65792: /* CIL Label */ 
  case_65793: /* CIL Label */ 
  {
  {
#line 715
  sprintf((char */* __restrict  */)(numeral), (char const   */* __restrict  */)"%d (\'%c\')",
          int_spec->val.i, (int )((char )int_spec->val.i));
  }
  }
#line 716
  goto switch_break;
  case_131585: /* CIL Label */ 
  {
  {
#line 718
  sprintf((char */* __restrict  */)(numeral), (char const   */* __restrict  */)"%hd",
          (int )((short )int_spec->val.i));
  }
  }
#line 719
  goto switch_break;
  case_131584: /* CIL Label */ 
  {
  {
#line 721
  sprintf((char */* __restrict  */)(numeral), (char const   */* __restrict  */)"%hu",
          (int )((unsigned short )int_spec->val.i));
  }
  }
#line 722
  goto switch_break;
  case_197633: /* CIL Label */ 
  {
  {
#line 724
  sprintf((char */* __restrict  */)(numeral), (char const   */* __restrict  */)"%d",
          int_spec->val.i);
  }
  }
#line 725
  goto switch_break;
  case_197632: /* CIL Label */ 
  {
  {
#line 727
  sprintf((char */* __restrict  */)(numeral), (char const   */* __restrict  */)"%u",
          int_spec->val.ui);
  }
  }
#line 728
  goto switch_break;
  case_264193: /* CIL Label */ 
  {
  {
#line 730
  sprintf((char */* __restrict  */)(numeral), (char const   */* __restrict  */)"%ld",
          int_spec->val.l);
  }
  }
#line 731
  goto switch_break;
  case_264192: /* CIL Label */ 
  {
  {
#line 733
  sprintf((char */* __restrict  */)(numeral), (char const   */* __restrict  */)"%lu",
          int_spec->val.ul);
  }
  }
#line 734
  goto switch_break;
  case_329729: /* CIL Label */ 
  {
  {
#line 736
  sprintf((char */* __restrict  */)(numeral), (char const   */* __restrict  */)"%lld",
          int_spec->val.ll);
  }
  }
#line 737
  goto switch_break;
  case_329728: /* CIL Label */ 
  {
  {
#line 739
  sprintf((char */* __restrict  */)(numeral), (char const   */* __restrict  */)"%llu",
          int_spec->val.ull);
  }
  }
#line 740
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 742
  __assert_fail("0", "/home/wslee/tests/SOURCES/coan-4.2.2/src/report.c", 742U, "format_int");
  }
  }
#line 743
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 745
  tmp = clone((void const   *)(numeral), (size_t )0);
  }
  }
#line 745
  return ((char *)tmp);
}
}
#line 101 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.h"
void ptr_vector_dispose(ptr_vector_h pv ) ;
#line 125
ptr_vector_h ptr_vector_copy(ptr_vector_const_h src ) ;
#line 129
void ptr_vector_swap(ptr_vector_h lhs , ptr_vector_h rhs ) ;
#line 136
void ptr_vector_assign(ptr_vector_h dest , ptr_vector_const_h src ) ;
#line 151
void ptr_vector_insert(ptr_vector_h pv , size_t pos , void const   *ptr ) ;
#line 163
_Bool ptr_vector_delete(ptr_vector_h pv , size_t pos ) ;
#line 178
dtor_t ptr_vector_dtor(ptr_vector_const_h pv ) ;
#line 183
cloner_t ptr_vector_cloner(ptr_vector_const_h pv ) ;
#line 190
size_t ptr_vector_count(ptr_vector_const_h pv ) ;
#line 202
_Bool ptr_vector_equal(ptr_vector_const_h lhs , ptr_vector_const_h rhs , int (*compare)(void const   *obj ,
                                                                                        void const   *key ,
                                                                                        locator_t keylen ) ) ;
#line 212
void **ptr_vector_begin(ptr_vector_h pv ) ;
#line 228
void **ptr_vector_end(ptr_vector_h pv ) ;
#line 246
void *ptr_vector_at(ptr_vector_h pv , size_t pos ) ;
#line 255
void const   *ptr_vector_at_const(ptr_vector_const_h pv , size_t pos ) ;
#line 271
locator_t ptr_vector_search(ptr_vector_const_h pv , void const   *key , locator_t keylen ,
                            int (*compare)(void const   *obj , void const   *key ,
                                           locator_t keylen ) , _Bool ordered ) ;
#line 48 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
#line 71 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.c"
static void *default_cloner(void const   *src ) 
{ 
  void *tmp ;

  {
  {
  {
#line 74
  tmp = clone(src, (size_t )0);
  }
  }
#line 74
  return (tmp);
}
}
#line 86 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.c"
static void ptr_vector_init(ptr_vector_h pv , void (*dtor)(void * ) , void *(*cloner)(void const   * ) ) 
{ 
  size_t tmp ;

  {
#line 89
  tmp = (size_t )0;
#line 89
  pv->count = tmp;
#line 89
  pv->cap = tmp;
#line 90
  pv->tranch = 16UL * sizeof(void *);
#line 91
  if (dtor) {
#line 91
    pv->dtor = dtor;
  } else {
#line 91
    pv->dtor = & free;
  }
#line 92
  if (cloner) {
#line 92
    pv->cloner = cloner;
  } else {
#line 92
    pv->cloner = & default_cloner;
  }
#line 93
  pv->ptrs = (void **)((void *)0);
#line 94
  return;
}
}
#line 103 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.c"
static void ptr_vector_copy_init(ptr_vector_h dest , ptr_vector_const_h src ) 
{ 
  void const   **begin ;
  void const   **tmp ;
  void const   **end ;
  void const   **tmp___0 ;
  void *(*cloner)(void const   * ) ;
  void *tmp___1 ;

  {
  {
  {
#line 106
  tmp = ptr_vector_begin_const(src);
  }
#line 106
  begin = tmp;
  {
#line 107
  tmp___0 = ptr_vector_end_const(src);
  }
#line 107
  end = tmp___0;
#line 108
  cloner = (void *(*)(void const   * ))src->cloner;
  {
#line 109
  ptr_vector_init(dest, (void (*)(void * ))src->dtor, (void *(*)(void const   * ))src->cloner);
  }
  {
#line 110
  begin = ptr_vector_begin_const(src);
  }
  {
#line 111
  end = ptr_vector_end_const(src);
  }
  }
  {
  {
#line 112
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 112
    if (! ((unsigned long )begin != (unsigned long )end)) {
#line 112
      goto while_break;
    }
    {
    {
#line 113
    tmp___1 = (*cloner)(*begin);
    }
    {
#line 113
    ptr_vector_append(dest, tmp___1);
    }
#line 112
    begin ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  return;
}
}
#line 120 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.c"
static void ptr_vector_finis(ptr_vector_h pv ) 
{ 
  void **begin ;
  void **end ;

  {
#line 123
  if (pv->ptrs) {
#line 124
    begin = pv->ptrs;
#line 125
    end = pv->ptrs + pv->count;
    {
    {
#line 126
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 126
      if (! ((unsigned long )begin != (unsigned long )end)) {
#line 126
        goto while_break;
      }
      {
      {
#line 127
      (*(pv->dtor))(*begin);
      }
#line 126
      begin ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 129
    free((void *)pv->ptrs);
    }
#line 130
    pv->ptrs = (void **)((void *)0);
    }
  }
#line 132
  return;
}
}
#line 141 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.c"
ptr_vector_h ptr_vector_new(void (*dtor)(void * ) , void *(*cloner)(void const   * ) ) 
{ 
  ptr_vector_h pv ;
  void *tmp ;

  {
  {
  {
#line 144
  tmp = zallocate(sizeof(struct ptr_vector ));
  }
#line 144
  pv = (ptr_vector_h )tmp;
  {
#line 145
  ptr_vector_init(pv, dtor, cloner);
  }
  }
#line 146
  return (pv);
}
}
#line 149 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.c"
void ptr_vector_dispose(ptr_vector_h pv ) 
{ 


  {
#line 152
  if (pv) {
    {
    {
#line 153
    ptr_vector_finis(pv);
    }
    {
#line 154
    free((void *)pv);
    }
    }
  }
#line 156
  return;
}
}
#line 158 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.c"
void ptr_vector_drop(ptr_vector_h pv ) 
{ 


  {
#line 161
  if (pv) {
    {
    {
#line 162
    free((void *)pv);
    }
    }
  }
#line 164
  return;
}
}
#line 166 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.c"
ptr_vector_h ptr_vector_copy(ptr_vector_const_h src ) 
{ 
  ptr_vector_h pv ;
  void *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 170
  if (! src) {
    {
    {
#line 170
    __assert_fail("src", "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.c",
                  170U, "ptr_vector_copy");
    }
    }
  }
  {
  {
#line 171
  tmp = zallocate(sizeof(struct ptr_vector ));
  }
#line 171
  pv = (ptr_vector_h )tmp;
  {
#line 172
  ptr_vector_copy_init(pv, src);
  }
  }
#line 173
  return (pv);
}
}
#line 176 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.c"
void ptr_vector_swap(ptr_vector_h lhs , ptr_vector_h rhs ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void (*tmp___2)(void * ) ;
  void *(*tmp___3)(void const   * ) ;
  void **tmp___4 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 179
  if (! lhs) {
    {
    {
#line 179
    __assert_fail("lhs", "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.c",
                  179U, "ptr_vector_swap");
    }
    }
  }
#line 180
  if (! rhs) {
    {
    {
#line 180
    __assert_fail("rhs", "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.c",
                  180U, "ptr_vector_swap");
    }
    }
  }
  {
  {
#line 181
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 181
    tmp = lhs->tranch;
#line 181
    lhs->tranch = rhs->tranch;
#line 181
    rhs->tranch = tmp;
#line 181
    goto while_break;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 182
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 182
    tmp___0 = lhs->count;
#line 182
    lhs->count = rhs->count;
#line 182
    rhs->count = tmp___0;
#line 182
    goto while_break___0;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 183
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 183
    tmp___1 = lhs->cap;
#line 183
    lhs->cap = rhs->cap;
#line 183
    rhs->cap = tmp___1;
#line 183
    goto while_break___1;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  {
#line 184
  while (1) {
    while_continue___8: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 184
    tmp___2 = lhs->dtor;
#line 184
    lhs->dtor = rhs->dtor;
#line 184
    rhs->dtor = tmp___2;
#line 184
    goto while_break___2;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
  {
#line 185
  while (1) {
    while_continue___9: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 185
    tmp___3 = lhs->cloner;
#line 185
    lhs->cloner = rhs->cloner;
#line 185
    rhs->cloner = tmp___3;
#line 185
    goto while_break___3;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
  {
#line 186
  while (1) {
    while_continue___10: /* CIL Label */ ;
    while_continue___4: /* CIL Label */ ;
#line 186
    tmp___4 = lhs->ptrs;
#line 186
    lhs->ptrs = rhs->ptrs;
#line 186
    rhs->ptrs = tmp___4;
#line 186
    goto while_break___4;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 187
  return;
}
}
#line 189 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.c"
void ptr_vector_assign(ptr_vector_h dest , ptr_vector_const_h src ) 
{ 
  ptr_vector_h tmp ;
  ptr_vector_h tmp___0 ;

  {
#line 192
  if ((unsigned long )dest != (unsigned long )src) {
    {
    {
#line 193
    tmp___0 = ptr_vector_copy(src);
    }
#line 193
    tmp = tmp___0;
    {
#line 194
    ptr_vector_swap(dest, tmp);
    }
    {
#line 195
    ptr_vector_dispose(tmp);
    }
    }
  }
#line 197
  return;
}
}
#line 199 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.c"
void ptr_vector_insert(ptr_vector_h pv , size_t pos , void const   *ptr ) 
{ 
  void *tmp ;
  size_t tmp___0 ;

  {
#line 202
  if (pv->count == pv->cap) {
    {
#line 203
    pv->cap += pv->tranch;
    {
#line 204
    tmp = reallocate((void *)pv->ptrs, pv->cap * sizeof(void *));
    }
#line 204
    pv->ptrs = (void **)tmp;
#line 205
    pv->tranch <<= 1;
    }
  }
#line 207
  if (pos >= pv->count) {
#line 208
    tmp___0 = pv->count;
#line 208
    (pv->count) ++;
#line 208
    *(pv->ptrs + tmp___0) = (void *)ptr;
  } else {
    {
    {
#line 210
    memmove((void *)((pv->ptrs + pos) + 1), (void const   *)(pv->ptrs + pos), (pv->count - pos) * sizeof(void *));
    }
#line 213
    *(pv->ptrs + pos) = (void *)ptr;
#line 214
    (pv->count) ++;
    }
  }
#line 216
  return;
}
}
#line 218 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.c"
_Bool ptr_vector_delete(ptr_vector_h pv , size_t pos ) 
{ 


  {
#line 221
  if (pos < pv->count) {
    {
    {
#line 222
    memmove((void *)(pv->ptrs + pos), (void const   *)((pv->ptrs + pos) + 1), ((pv->count - 1UL) + pos) * sizeof(void *));
    }
#line 225
    (pv->count) --;
    }
#line 226
    return ((_Bool)1);
  }
#line 228
  return ((_Bool)0);
}
}
#line 231 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.c"
_Bool ptr_vector_equal(ptr_vector_const_h lhs , ptr_vector_const_h rhs , int (*compare)(void const   *obj ,
                                                                                        void const   *key ,
                                                                                        locator_t keylen ) ) 
{ 
  void const   **lh_iter ;
  void const   **tmp ;
  void const   **rh_iter ;
  void const   **tmp___0 ;
  void const   **lh_end ;
  void const   **tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 236
  if ((unsigned long )lhs != (unsigned long )rhs) {
#line 237
    if (! lhs) {
      {
      {
#line 237
      __assert_fail("lhs", "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.c",
                    237U, "ptr_vector_equal");
      }
      }
    }
#line 238
    if (! rhs) {
      {
      {
#line 238
      __assert_fail("rhs", "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.c",
                    238U, "ptr_vector_equal");
      }
      }
    }
#line 239
    if ((unsigned long )lhs->dtor == (unsigned long )rhs->dtor) {
#line 239
      if ((unsigned long )lhs->cloner == (unsigned long )rhs->cloner) {
        {
        {
#line 240
        tmp___3 = ptr_vector_count(lhs);
        }
        {
#line 240
        tmp___4 = ptr_vector_count(rhs);
        }
        }
#line 240
        if (tmp___3 == tmp___4) {
          {
          {
#line 241
          tmp = ptr_vector_begin_const(lhs);
          }
#line 241
          lh_iter = tmp;
          {
#line 242
          tmp___0 = ptr_vector_begin_const(rhs);
          }
#line 242
          rh_iter = tmp___0;
          {
#line 243
          tmp___1 = ptr_vector_end_const(lhs);
          }
#line 243
          lh_end = tmp___1;
          }
          {
          {
#line 244
          while (1) {
            while_continue___0: /* CIL Label */ ;
            while_continue: /* CIL Label */ ;
#line 244
            if (! ((unsigned long )lh_iter != (unsigned long )lh_end)) {
#line 244
              goto while_break;
            }
            {
            {
#line 245
            tmp___2 = (*compare)(*lh_iter, *rh_iter, (locator_t )0);
            }
            }
#line 245
            if (tmp___2) {
#line 246
              return ((_Bool)0);
            }
#line 244
            lh_iter ++;
#line 244
            rh_iter ++;
          }
          while_break___0: /* CIL Label */ ;
          }
          while_break: /* CIL Label */ ;
          }
#line 249
          return ((_Bool)1);
        }
      }
    }
#line 252
    return ((_Bool)0);
  }
#line 254
  return ((_Bool)1);
}
}
#line 257 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.c"
dtor_t ptr_vector_dtor(ptr_vector_const_h pv ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 260
  if (! pv) {
    {
    {
#line 260
    __assert_fail("pv", "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.c", 260U,
                  "ptr_vector_dtor");
    }
    }
  }
#line 261
  return ((dtor_t )pv->dtor);
}
}
#line 264 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.c"
cloner_t ptr_vector_cloner(ptr_vector_const_h pv ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 267
  if (! pv) {
    {
    {
#line 267
    __assert_fail("pv", "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.c", 267U,
                  "ptr_vector_cloner");
    }
    }
  }
#line 268
  return ((cloner_t )pv->cloner);
}
}
#line 272 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.c"
void ptr_vector_append(ptr_vector_h pv , void *ptr ) 
{ 


  {
  {
  {
#line 275
  ptr_vector_insert(pv, (size_t )-1, (void const   *)ptr);
  }
  }
#line 276
  return;
}
}
#line 278 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.c"
size_t ptr_vector_count(ptr_vector_const_h pv ) 
{ 


  {
#line 281
  return ((size_t )pv->count);
}
}
#line 284 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.c"
void **ptr_vector_begin(ptr_vector_h pv ) 
{ 


  {
#line 287
  return (pv->ptrs);
}
}
#line 290 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.c"
void const   **ptr_vector_begin_const(ptr_vector_const_h pv ) 
{ 
  void **tmp ;

  {
  {
  {
#line 293
  tmp = ptr_vector_begin((ptr_vector_h )pv);
  }
  }
#line 293
  return ((void const   **)tmp);
}
}
#line 296 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.c"
void **ptr_vector_end(ptr_vector_h pv ) 
{ 


  {
#line 299
  return (pv->ptrs + pv->count);
}
}
#line 302 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.c"
void const   **ptr_vector_end_const(ptr_vector_const_h pv ) 
{ 
  void **tmp ;

  {
  {
  {
#line 305
  tmp = ptr_vector_end((ptr_vector_h )pv);
  }
  }
#line 305
  return ((void const   **)tmp);
}
}
#line 308 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.c"
void *ptr_vector_at(ptr_vector_h pv , size_t pos ) 
{ 
  void *tmp ;

  {
#line 311
  if (pos < pv->count) {
#line 311
    tmp = *(pv->ptrs + pos);
  } else {
#line 311
    tmp = (void *)0;
  }
#line 311
  return (tmp);
}
}
#line 314 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.c"
void const   *ptr_vector_at_const(ptr_vector_const_h pv , size_t pos ) 
{ 
  void *tmp ;

  {
  {
  {
#line 317
  tmp = ptr_vector_at((ptr_vector_h )pv, pos);
  }
  }
#line 317
  return ((void const   *)tmp);
}
}
#line 320 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_vector.c"
locator_t ptr_vector_search(ptr_vector_const_h pv , void const   *key , locator_t keylen ,
                            int (*compare)(void const   *obj , void const   *key ,
                                           locator_t keylen ) , _Bool ordered ) 
{ 
  locator_t comp ;
  void const   **begin ;
  void const   **tmp ;
  void const   **end ;
  void const   **tmp___0 ;
  void const   **iter ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 327
  comp = (locator_t )1;
  {
#line 328
  tmp = ptr_vector_begin_const(pv);
  }
#line 328
  begin = tmp;
  {
#line 329
  tmp___0 = ptr_vector_end_const(pv);
  }
#line 329
  end = tmp___0;
#line 330
  iter = begin;
  }
#line 331
  if (! ordered) {
#line 332
    iter = begin;
    {
    {
#line 332
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 332
      if (! ((unsigned long )iter != (unsigned long )end)) {
#line 332
        goto while_break;
      }
      {
      {
#line 333
      tmp___1 = (*compare)(*iter, key, keylen);
      }
#line 333
      comp = (locator_t )tmp___1;
      }
#line 334
      if (! comp) {
#line 335
        goto while_break;
      }
#line 332
      iter ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 339
    iter = begin;
    {
    {
#line 339
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 339
      if (! ((unsigned long )iter != (unsigned long )end)) {
#line 339
        goto while_break___0;
      }
      {
      {
#line 340
      tmp___2 = (*compare)(*iter, key, keylen);
      }
#line 340
      comp = (locator_t )tmp___2;
      }
#line 341
      if (comp >= 0L) {
#line 342
        goto while_break___0;
      }
#line 339
      iter ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 346
  if (comp) {
#line 346
    comp = ~ (iter - begin);
  } else {
#line 346
    comp = iter - begin;
  }
#line 347
  return (comp);
}
}
#line 84 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_set.h"
ptr_set_h ptr_set_copy(ptr_set_const_h src ) ;
#line 88
void ptr_set_swap(ptr_set_h lhs , ptr_set_h rhs ) ;
#line 95
void ptr_set_assign(ptr_set_h dest , ptr_set_const_h src ) ;
#line 105
_Bool ptr_set_equal(ptr_set_const_h lhs , ptr_set_const_h rhs ) ;
#line 109
comparator_t ptr_set_comparator(ptr_set_const_h ps ) ;
#line 113
dtor_t ptr_set_dtor(ptr_set_const_h ps ) ;
#line 117
cloner_t ptr_set_cloner(ptr_set_const_h ps ) ;
#line 121
size_t ptr_set_count(ptr_set_const_h ps ) ;
#line 152
void const   *ptr_set_search_const(ptr_set_const_h ps , char const   *key , locator_t keylen ) ;
#line 176
_Bool ptr_set_delete(ptr_set_h ps , locator_t pos ) ;
#line 182
void **ptr_set_begin(ptr_set_const_h ps ) ;
#line 189
void **ptr_set_end(ptr_set_const_h ps ) ;
#line 193
void const   **ptr_set_begin_const(ptr_set_const_h ps ) ;
#line 197
void const   **ptr_set_end_const(ptr_set_const_h ps ) ;
#line 58 "/home/wslee/tests/SOURCES/coan-4.2.2/src/memory.h"
void *allocate(size_t bytes ) ;
#line 81 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_set.c"
static int default_comparator(void const   *obj , void const   *key , locator_t ignore ) 
{ 
  int tmp ;

  {
  {
  {
#line 85
  tmp = strcmp((char const   *)obj, (char const   *)key);
  }
  }
#line 85
  return (tmp);
}
}
#line 96 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_set.c"
static void ptr_set_init(ptr_set_h ps , int (*compare)(void const   *obj , void const   *key ,
                                                       locator_t keylen ) , void (*dtor)(void * ) ,
                         void *(*cloner)(void const   * ) ) 
{ 


  {
  {
  {
#line 102
  ps->pv = ptr_vector_new(dtor, cloner);
  }
  }
#line 103
  if (compare) {
#line 103
    ps->compare = compare;
  } else {
#line 103
    ps->compare = & default_comparator;
  }
#line 104
  ps->cached_pos = (locator_t )-1;
#line 105
  return;
}
}
#line 114 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_set.c"
static void ptr_set_copy_init(ptr_set_h dest , ptr_set_const_h src ) 
{ 


  {
  {
  {
#line 117
  dest->pv = ptr_vector_copy((ptr_vector_const_h )src->pv);
  }
#line 118
  dest->compare = (int (*)(void const   *obj , void const   *key , locator_t keylen ))src->compare;
#line 119
  dest->cached_pos = (locator_t )src->cached_pos;
  }
#line 120
  return;
}
}
#line 126 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_set.c"
ptr_set_h ptr_set_new(int (*compare)(void const   *obj , void const   *key , locator_t keylen ) ,
                      void (*dtor)(void * ) , void *(*cloner)(void const   * ) ) 
{ 
  ptr_set_h ps ;
  void *tmp ;

  {
  {
  {
#line 129
  tmp = allocate(sizeof(struct ptr_set ));
  }
#line 129
  ps = (ptr_set_h )tmp;
  {
#line 130
  ptr_set_init(ps, compare, dtor, cloner);
  }
  }
#line 131
  return (ps);
}
}
#line 134 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_set.c"
void ptr_set_dispose(ptr_set_h ps ) 
{ 


  {
#line 137
  if (ps) {
    {
    {
#line 138
    ptr_vector_dispose(ps->pv);
    }
    {
#line 139
    free((void *)ps);
    }
    }
  }
#line 141
  return;
}
}
#line 143 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_set.c"
ptr_set_h ptr_set_copy(ptr_set_const_h src ) 
{ 
  ptr_set_h ps ;
  void *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 147
  if (! src) {
    {
    {
#line 147
    __assert_fail("src", "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_set.c", 147U,
                  "ptr_set_copy");
    }
    }
  }
  {
  {
#line 148
  tmp = allocate(sizeof(struct ptr_set ));
  }
#line 148
  ps = (ptr_set_h )tmp;
  {
#line 149
  ptr_set_copy_init(ps, src);
  }
  }
#line 150
  return (ps);
}
}
#line 153 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_set.c"
void ptr_set_swap(ptr_set_h lhs , ptr_set_h rhs ) 
{ 
  int (*tmp)(void const   *obj , void const   *key , locator_t keylen ) ;
  locator_t tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 156
  if (! lhs) {
    {
    {
#line 156
    __assert_fail("lhs", "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_set.c", 156U,
                  "ptr_set_swap");
    }
    }
  }
#line 157
  if (! rhs) {
    {
    {
#line 157
    __assert_fail("rhs", "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_set.c", 157U,
                  "ptr_set_swap");
    }
    }
  }
  {
  {
#line 158
  ptr_vector_swap(lhs->pv, rhs->pv);
  }
  }
  {
  {
#line 159
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 159
    tmp = lhs->compare;
#line 159
    lhs->compare = rhs->compare;
#line 159
    rhs->compare = tmp;
#line 159
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 160
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 160
    tmp___0 = lhs->cached_pos;
#line 160
    lhs->cached_pos = rhs->cached_pos;
#line 160
    rhs->cached_pos = tmp___0;
#line 160
    goto while_break___0;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 161
  return;
}
}
#line 163 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_set.c"
void ptr_set_assign(ptr_set_h dest , ptr_set_const_h src ) 
{ 
  ptr_set_h tmp ;
  ptr_set_h tmp___0 ;

  {
#line 166
  if ((unsigned long )dest != (unsigned long )src) {
    {
    {
#line 167
    tmp___0 = ptr_set_copy(src);
    }
#line 167
    tmp = tmp___0;
    {
#line 168
    ptr_set_swap(dest, tmp);
    }
    {
#line 169
    ptr_set_dispose(tmp);
    }
    }
  }
#line 171
  return;
}
}
#line 173 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_set.c"
_Bool ptr_set_equal(ptr_set_const_h lhs , ptr_set_const_h rhs ) 
{ 
  _Bool eq___0 ;

  {
#line 177
  eq___0 = (_Bool )((unsigned long )lhs == (unsigned long )rhs);
#line 178
  if (! eq___0) {
#line 179
    eq___0 = (_Bool )((unsigned long )lhs->compare == (unsigned long )rhs->compare);
#line 180
    if (eq___0) {
      {
      {
#line 181
      eq___0 = ptr_vector_equal((ptr_vector_const_h )lhs->pv, (ptr_vector_const_h )rhs->pv,
                                (int (*)(void const   *obj , void const   *key , locator_t keylen ))lhs->compare);
      }
      }
    }
  }
#line 184
  return (eq___0);
}
}
#line 188 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_set.c"
comparator_t ptr_set_comparator(ptr_set_const_h ps ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 191
  if (! ps) {
    {
    {
#line 191
    __assert_fail("ps", "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_set.c", 191U,
                  "ptr_set_comparator");
    }
    }
  }
#line 192
  return ((comparator_t )ps->compare);
}
}
#line 195 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_set.c"
dtor_t ptr_set_dtor(ptr_set_const_h ps ) 
{ 
  dtor_t tmp ;

  {
  {
  {
#line 198
  tmp = ptr_vector_dtor((ptr_vector_const_h )ps->pv);
  }
  }
#line 198
  return (tmp);
}
}
#line 201 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_set.c"
cloner_t ptr_set_cloner(ptr_set_const_h ps ) 
{ 
  cloner_t tmp ;

  {
  {
  {
#line 204
  tmp = ptr_vector_cloner((ptr_vector_const_h )ps->pv);
  }
  }
#line 204
  return (tmp);
}
}
#line 207 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_set.c"
size_t ptr_set_count(ptr_set_const_h ps ) 
{ 
  size_t tmp ;

  {
  {
  {
#line 210
  tmp = ptr_vector_count((ptr_vector_const_h )ps->pv);
  }
  }
#line 210
  return (tmp);
}
}
#line 213 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_set.c"
void *ptr_set_search(ptr_set_h ps , char const   *key , locator_t keylen ) 
{ 
  locator_t loc ;
  void *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 217
  if (! ps) {
    {
    {
#line 217
    __assert_fail("ps", "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_set.c", 217U,
                  "ptr_set_search");
    }
    }
  }
  {
  {
#line 218
  loc = ptr_vector_search((ptr_vector_const_h )ps->pv, (void const   *)key, keylen,
                          ps->compare, (_Bool)1);
  }
  }
#line 219
  if (loc < 0L) {
#line 220
    ps->cached_pos = ~ loc;
#line 221
    return ((void *)0);
  }
  {
#line 223
  ps->cached_pos = (locator_t )-1;
  {
#line 224
  tmp = ptr_vector_at(ps->pv, (size_t )loc);
  }
  }
#line 224
  return (tmp);
}
}
#line 227 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_set.c"
void const   *ptr_set_search_const(ptr_set_const_h ps , char const   *key , locator_t keylen ) 
{ 
  void *tmp ;

  {
  {
  {
#line 230
  tmp = ptr_set_search((ptr_set_h )ps, key, keylen);
  }
  }
#line 230
  return ((void const   *)tmp);
}
}
#line 234 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_set.c"
_Bool ptr_set_insert(ptr_set_h ps , void const   *obj ) 
{ 
  size_t nelems ;
  size_t tmp ;
  locator_t loc ;
  int prev_comp ;
  int next_comp ;
  void const   *other ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 237
  if (! ps) {
    {
    {
#line 237
    __assert_fail("ps", "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_set.c", 237U,
                  "ptr_set_insert");
    }
    }
  }
#line 238
  if (! obj) {
    {
    {
#line 238
    __assert_fail("obj", "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_set.c", 238U,
                  "ptr_set_insert");
    }
    }
  }
  {
  {
#line 239
  tmp = ptr_vector_count((ptr_vector_const_h )ps->pv);
  }
#line 239
  nelems = tmp;
#line 240
  loc = ps->cached_pos;
#line 241
  ps->cached_pos = (locator_t )-1;
  }
#line 242
  if (! nelems) {
    {
    {
#line 243
    ptr_vector_append(ps->pv, (void *)obj);
    }
    }
#line 244
    return ((_Bool)1);
  } else {
#line 246
    if (loc >= 0L) {
#line 247
      prev_comp = -1;
#line 247
      next_comp = 1;
#line 249
      if (loc > 0L) {
        {
        {
#line 250
        tmp___0 = ptr_vector_at(ps->pv, (size_t )(loc - 1L));
        }
#line 250
        other = (void const   *)tmp___0;
        {
#line 251
        prev_comp = (*(ps->compare))(other, obj, (locator_t )0);
        }
        }
#line 252
        if (! prev_comp) {
#line 253
          return ((_Bool)0);
        }
      }
#line 256
      if ((size_t )(loc + 1L) < nelems) {
        {
        {
#line 257
        tmp___1 = ptr_vector_at(ps->pv, (size_t )(loc + 1L));
        }
#line 257
        other = (void const   *)tmp___1;
        {
#line 258
        next_comp = (*(ps->compare))(other, obj, (locator_t )0);
        }
        }
#line 259
        if (! next_comp) {
#line 260
          return ((_Bool)0);
        }
      }
#line 263
      if (prev_comp > 0) {
#line 264
        loc = (locator_t )-1;
      } else
#line 263
      if (next_comp < 0) {
#line 264
        loc = (locator_t )-1;
      }
    }
#line 267
    if (loc < 0L) {
      {
      {
#line 268
      loc = ptr_vector_search((ptr_vector_const_h )ps->pv, obj, (locator_t )0, ps->compare,
                              (_Bool)1);
      }
      }
#line 269
      if (loc >= 0L) {
#line 270
        return ((_Bool)0);
      }
#line 272
      loc = ~ loc;
    }
    {
    {
#line 274
    ptr_vector_insert(ps->pv, (size_t )loc, obj);
    }
    }
#line 275
    return ((_Bool)1);
  }
}
}
#line 279 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_set.c"
_Bool ptr_set_delete(ptr_set_h ps , locator_t pos ) 
{ 
  _Bool tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 282
  if (! ps) {
    {
    {
#line 282
    __assert_fail("ps", "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_set.c", 282U,
                  "ptr_set_delete");
    }
    }
  }
  {
  {
#line 283
  tmp = ptr_vector_delete(ps->pv, (size_t )pos);
  }
  }
#line 283
  return (tmp);
}
}
#line 286 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_set.c"
void **ptr_set_begin(ptr_set_const_h ps ) 
{ 
  void **tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 289
  if (! ps) {
    {
    {
#line 289
    __assert_fail("ps", "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_set.c", 289U,
                  "ptr_set_begin");
    }
    }
  }
  {
  {
#line 290
  tmp = ptr_vector_begin((ptr_vector_h )ps->pv);
  }
  }
#line 290
  return (tmp);
}
}
#line 293 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_set.c"
void **ptr_set_end(ptr_set_const_h ps ) 
{ 
  void **tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 296
  if (! ps) {
    {
    {
#line 296
    __assert_fail("ps", "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_set.c", 296U,
                  "ptr_set_end");
    }
    }
  }
  {
  {
#line 297
  tmp = ptr_vector_end((ptr_vector_h )ps->pv);
  }
  }
#line 297
  return (tmp);
}
}
#line 300 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_set.c"
void const   **ptr_set_begin_const(ptr_set_const_h ps ) 
{ 
  void **tmp ;

  {
  {
  {
#line 303
  tmp = ptr_set_begin(ps);
  }
  }
#line 303
  return ((void const   **)tmp);
}
}
#line 306 "/home/wslee/tests/SOURCES/coan-4.2.2/src/ptr_set.c"
void const   **ptr_set_end_const(ptr_set_const_h ps ) 
{ 
  void **tmp ;

  {
  {
  {
#line 309
  tmp = ptr_set_end(ps);
  }
  }
#line 309
  return ((void const   **)tmp);
}
}
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 473
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 485
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 55 "/home/wslee/tests/SOURCES/coan-4.2.2/src/memory.c"
static void *no_alloc_fail(void *ptr ) 
{ 
  char *__cil_tmp2 ;

  {
#line 58
  if (! ptr) {
    {
    {
#line 59
    bail(33136, "Out of memory");
    }
    }
  }
#line 61
  return (ptr);
}
}
#line 67 "/home/wslee/tests/SOURCES/coan-4.2.2/src/memory.c"
void *allocate(size_t bytes ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
  {
#line 70
  tmp = malloc(bytes);
  }
  {
#line 70
  tmp___0 = no_alloc_fail(tmp);
  }
  }
#line 70
  return (tmp___0);
}
}
#line 74 "/home/wslee/tests/SOURCES/coan-4.2.2/src/memory.c"
void *zallocate(size_t bytes ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
  {
#line 77
  tmp = calloc(bytes, (size_t )1);
  }
  {
#line 77
  tmp___0 = no_alloc_fail(tmp);
  }
  }
#line 77
  return (tmp___0);
}
}
#line 80 "/home/wslee/tests/SOURCES/coan-4.2.2/src/memory.c"
void *reallocate(void *ptr , size_t bytes ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
  {
#line 83
  tmp = realloc(ptr, bytes);
  }
  {
#line 83
  tmp___0 = no_alloc_fail(tmp);
  }
  }
#line 83
  return (tmp___0);
}
}
#line 86 "/home/wslee/tests/SOURCES/coan-4.2.2/src/memory.c"
void *callocate(size_t items , size_t size ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
  {
#line 89
  tmp = calloc(items, size);
  }
  {
#line 89
  tmp___0 = no_alloc_fail(tmp);
  }
  }
#line 89
  return (tmp___0);
}
}
#line 92 "/home/wslee/tests/SOURCES/coan-4.2.2/src/memory.c"
void release(void **pp ) 
{ 


  {
#line 94
  if (*pp) {
    {
    {
#line 95
    free(*pp);
    }
#line 96
    *pp = (void *)0;
    }
  }
#line 98
  return;
}
}
#line 100 "/home/wslee/tests/SOURCES/coan-4.2.2/src/memory.c"
void *clone(void const   *src , size_t len ) 
{ 
  char *dest ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 103
  dest = (char *)((void *)0);
#line 104
  if (src) {
#line 105
    if (! len) {
      {
      {
#line 106
      len = strlen((char const   *)src);
      }
      }
    }
    {
    {
#line 108
    tmp = allocate(len + 1UL);
    }
#line 108
    dest = (char *)tmp;
    {
#line 109
    tmp___0 = memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src,
                     len);
    }
#line 109
    *((char *)tmp___0 + len) = (char)0;
    }
  }
#line 111
  return ((void *)dest);
}
}
#line 517 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atexit)(void (*__func)(void) ) ;
#line 111 "/home/wslee/tests/SOURCES/coan-4.2.2/src/directives_tally.h"
void directives_tally_initor(void) ;
#line 165 "/home/wslee/tests/SOURCES/coan-4.2.2/src/contradiction.h"
void contradiction_initor(void) ;
#line 62 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_despatch.h"
void drop(void) ;
#line 101
void line_despatch_initor(void) ;
#line 59 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.h"
line_type_t eval_line(void) ;
#line 82
void evaluator_initor(void) ;
#line 90 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.h"
void transition(line_type_t linetype ) ;
#line 130
void if_control_initor(void) ;
#line 97 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.h"
void parse_executable(char **argv ) ;
#line 106
void parse_args(int argc , char **argv ) ;
#line 112
void finish_args(void) ;
#line 180
void args_initor(void) ;
#line 89 "/home/wslee/tests/SOURCES/coan-4.2.2/src/io.h"
void open_io(char const   *filename ) ;
#line 105
void close_io(int error___0 ) ;
#line 207
void io_initor(void) ;
#line 180 "/home/wslee/tests/SOURCES/coan-4.2.2/src/chew.h"
void chew_toplevel(void) ;
#line 212
void chew_initor(void) ;
#line 174 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_edit.h"
void line_edit_initor(void) ;
#line 65 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
#line 226 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.h"
void file_tree_traverse(file_tree_h ft , void (*callback)(file_tree_h ft , char const   *name ,
                                                          file_tree_traverse_state_t context ) ) ;
#line 233
_Bool file_tree_is_empty(file_tree_const_h ft ) ;
#line 94 "/home/wslee/tests/SOURCES/coan-4.2.2/src/dataset.h"
void dataset_initor(void) ;
#line 134 "/home/wslee/tests/SOURCES/coan-4.2.2/src/configured_symbols.h"
void configured_symbols_initor(void) ;
#line 94 "/home/wslee/tests/SOURCES/coan-4.2.2/src/includes_tally.h"
void includes_tally_initor(void) ;
#line 79 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_select.h"
void line_select_initor(void) ;
#line 61 "/home/wslee/tests/SOURCES/coan-4.2.2/src/main.c"
static void ready(void) ;
#line 64
static void process(void) ;
#line 67 "/home/wslee/tests/SOURCES/coan-4.2.2/src/main.c"
int main(int argc , char **argv ) 
{ 


  {
  {
  {
#line 70
  ready();
  }
  {
#line 71
  atexit(& exit_diagnostics);
  }
  {
#line 72
  parse_executable(argv);
  }
  {
#line 73
  parse_args(argc, argv);
  }
  {
#line 74
  finish_args();
  }
  {
#line 75
  process();
  }
  {
#line 76
  give_up_confused();
  }
  }
#line 77
  return (0);
}
}
#line 82 "/home/wslee/tests/SOURCES/coan-4.2.2/src/main.c"
static void line_debug(int line ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
#line 85
  if (line < 0) {
    {
    {
#line 87
    printf((char const   */* __restrict  */)"%d\n", io_public_h->line_num);
    }
    }
  } else
#line 88
  if (line > 0) {
#line 88
    if (line == io_public_h->line_num) {
      {
      {
#line 90
      fputs((char const   */* __restrict  */)"Here\n", (FILE */* __restrict  */)stderr);
      }
      }
    }
  }
#line 92
  return;
}
}
#line 94 "/home/wslee/tests/SOURCES/coan-4.2.2/src/main.c"
static void ready(void) 
{ 


  {
  {
  {
#line 97
  chew_initor();
  }
  {
#line 98
  report_initor();
  }
  {
#line 99
  evaluator_initor();
  }
  {
#line 100
  if_control_initor();
  }
  {
#line 101
  io_initor();
  }
  {
#line 102
  dataset_initor();
  }
  {
#line 103
  line_edit_initor();
  }
  {
#line 104
  args_initor();
  }
  {
#line 105
  configured_symbols_initor();
  }
  {
#line 106
  unconfigured_symbols_initor();
  }
  {
#line 107
  line_despatch_initor();
  }
  {
#line 108
  contradiction_initor();
  }
  {
#line 109
  includes_tally_initor();
  }
  {
#line 110
  directives_tally_initor();
  }
  {
#line 111
  line_select_initor();
  }
  }
#line 112
  return;
}
}
#line 133 "/home/wslee/tests/SOURCES/coan-4.2.2/src/main.c"
static int error  ;
#line 128 "/home/wslee/tests/SOURCES/coan-4.2.2/src/main.c"
static void node_proc(file_tree_h ft , char const   *name , file_tree_traverse_state_t context ) 
{ 
  line_type_t lineval ;
  file_tree_count_t count ;
  file_tree_count_t count___0 ;
  _Bool tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 135
  if ((int )context == 0) {
#line 135
    goto case_0;
  }
#line 157
  if ((int )context == -1) {
#line 157
    goto case_neg_1;
  }
#line 168
  if ((int )context == 1) {
#line 168
    goto case_1;
  }
#line 179
  if ((int )context == -2) {
#line 179
    goto case_neg_2;
  }
#line 184
  if ((int )context == 2) {
#line 184
    goto case_2;
  }
#line 187
  goto switch_default;
  case_0: /* CIL Label */ 
  {
  {
#line 137
  if_control_toplevel();
  }
  {
#line 138
  processing_file(name);
  }
  {
#line 139
  open_io(name);
  }
  {
#line 140
  chew_toplevel();
  }
#line 141
  exceptions_enabled = (_Bool)1;
  {
#line 142
  error = _setjmp((struct __jmp_buf_tag *)(exception_context));
  }
  }
  {
  {
#line 143
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 143
    if (! error) {
      {
      {
#line 143
      lineval = eval_line();
      }
      }
#line 143
      if (! ((unsigned int )lineval != 9U)) {
#line 143
        goto while_break;
      }
    } else {
#line 143
      goto while_break;
    }
    {
    {
#line 144
    line_debug(0);
    }
    }
#line 145
    if ((unsigned int )lineval != 10U) {
      {
      {
#line 146
      transition(lineval);
      }
      }
    } else {
      {
      {
#line 149
      drop();
      }
      }
    }
    {
    {
#line 151
    debug((dbg_code_t )19, (unsigned int )lineval);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 153
  exceptions_enabled = (_Bool)0;
  {
#line 154
  close_io(error);
  }
  }
#line 156
  goto switch_break;
  case_neg_1: /* CIL Label */ 
  {
  {
#line 159
  file_tree_count((file_tree_const_h )ft, 7U, & count);
  }
  {
#line 160
  if_control_toplevel();
  }
  }
#line 163
  if (count.dirs != 1UL) {
    {
    {
#line 164
    entering_dir(name);
    }
    }
  } else
#line 163
  if (count.files != 0UL) {
    {
    {
#line 164
    entering_dir(name);
    }
    }
  }
#line 167
  goto switch_break;
  case_1: /* CIL Label */ 
  {
  {
#line 170
  file_tree_count((file_tree_const_h )ft, 7U, & count___0);
  }
  {
#line 173
  if_control_toplevel();
  }
  }
#line 174
  if (count___0.dirs != 1UL) {
    {
    {
#line 175
    leaving_dir(name);
    }
    }
  } else
#line 174
  if (count___0.files != 0UL) {
    {
    {
#line 175
    leaving_dir(name);
    }
    }
  }
#line 178
  goto switch_break;
  case_neg_2: /* CIL Label */ 
  {
  {
#line 180
  tmp = file_tree_is_empty((file_tree_const_h )ft);
  }
  }
#line 180
  if (tmp) {
    {
    {
#line 181
    node_proc(ft, "[stdin]", (file_tree_traverse_state_t )0);
    }
    }
  }
#line 183
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  {
#line 185
  io_toplevel();
  }
  }
#line 186
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 188
  __assert_fail("0", "/home/wslee/tests/SOURCES/coan-4.2.2/src/main.c", 188U, "node_proc");
  }
  }
  switch_break: /* CIL Label */ ;
  }
#line 190
  return;
}
}
#line 192 "/home/wslee/tests/SOURCES/coan-4.2.2/src/main.c"
static void process(void) 
{ 
  file_tree_h ft ;
  int tmp ;

  {
  {
#line 195
  ft = dataset_public_h->file_tree;
  {
#line 196
  file_tree_traverse(ft, & node_proc);
  }
  {
#line 197
  tmp = exitcode();
  }
  {
#line 197
  exit(tmp);
  }
  }
}
}
#line 79 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_select.h"
line_select_public_state_t *line_select_public_h ;
#line 79
void line_select_finitor(void) ;
#line 94 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.h"
_Bool dead_line(void) ;
#line 50 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_select.c"
static line_select_state_t line_select_state  ;
#line 50 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_select.c"
line_select_state_t *line_select_h  =    & line_select_state;
#line 50 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_select.c"
line_select_public_state_t *line_select_public_h  =    & line_select_state;
#line 50 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_select.c"
static line_select_state_t const   * const  line_select_static_initialiser_h  ;
#line 50 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_select.c"
void (*line_select_init_h)(line_select_state_t * )  ;
#line 50 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_select.c"
void (*line_select_finis_h)(line_select_state_t * )  ;
#line 50 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_select.c"
void line_select_initor(void) 
{ 


  {
  {
  {
#line 50
  component_initor((_Bool)1, (_Bool)1, (void **)((char *)(& line_select_h)), (void **)((char *)(& line_select_public_h)),
                   (void const   *)line_select_static_initialiser_h, sizeof(line_select_state_t ),
                   (void (*)())line_select_init_h);
  }
  }
#line 50
  return;
}
}
#line 50 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_select.c"
void line_select_finitor(void) 
{ 


  {
  {
  {
#line 50
  component_finitor((_Bool)1, (void **)((char *)(& line_select_h)), (void **)((char *)(& line_select_public_h)),
                    (void (*)())line_select_init_h);
  }
  }
#line 50
  return;
}
}
#line 56 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_select.c"
_Bool dropping_line(void) 
{ 
  _Bool tmp ;
  int tmp___0 ;

  {
#line 59
  if (io_public_h->line_num != 0) {
    {
    {
#line 59
    tmp = dead_line();
    }
    }
#line 59
    if ((int )tmp ^ (int )args_public_h->complement) {
#line 59
      tmp___0 = 1;
    } else {
#line 59
      tmp___0 = 0;
    }
  } else {
#line 59
    tmp___0 = 0;
  }
#line 59
  return ((_Bool )tmp___0);
}
}
#line 62 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_select.c"
_Bool eligible_line(int cmd_code , int directive ) 
{ 
  _Bool verdict ;

  {
#line 65
  verdict = (_Bool)0;
#line 66
  if (((1 << (cmd_code - 1)) & (args_public_h->command)->cmd_mask) != 0) {
#line 67
    if (args_public_h->list_only_inactive) {
#line 68
      verdict = line_select_public_h->dropping_line;
    } else
#line 69
    if (args_public_h->list_only_active) {
#line 70
      verdict = (_Bool )(! line_select_public_h->dropping_line);
    } else {
#line 72
      verdict = (_Bool)1;
    }
#line 74
    if (verdict) {
#line 74
      if (cmd_code == 4) {
        {
#line 78
        if (directive == 1) {
#line 78
          goto case_1;
        }
#line 78
        if (directive == 3) {
#line 78
          goto case_1;
        }
#line 78
        if (directive == 2) {
#line 78
          goto case_1;
        }
#line 81
        if (directive == 7) {
#line 81
          goto case_7;
        }
#line 84
        if (directive == 8) {
#line 84
          goto case_8;
        }
#line 87
        if (directive == 9) {
#line 87
          goto case_9;
        }
#line 90
        goto switch_default;
        case_1: /* CIL Label */ 
        case_3: /* CIL Label */ 
        case_2: /* CIL Label */ 
#line 79
        verdict = args_public_h->list_symbols_in_ifs;
#line 80
        goto switch_break;
        case_7: /* CIL Label */ 
#line 82
        verdict = args_public_h->list_symbols_in_defs;
#line 83
        goto switch_break;
        case_8: /* CIL Label */ 
#line 85
        verdict = args_public_h->list_symbols_in_undefs;
#line 86
        goto switch_break;
        case_9: /* CIL Label */ 
#line 88
        verdict = args_public_h->list_symbols_in_includes;
#line 89
        goto switch_break;
        switch_default: /* CIL Label */ ;
        switch_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 95
  return (verdict);
}
}
#line 80 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_edit.h"
void keywordedit(char const   *replacement ) ;
#line 103
void delete_paren(size_t lparen_off , size_t rparen_off ) ;
#line 115
extern void restore_paren(size_t lparen_off , size_t rparen_off ) ;
#line 127
void restore_all_paren(void) ;
#line 145
void cut_text(char const   *start , char const   *end ) ;
#line 152
void truncate_line(size_t off ) ;
#line 174
line_edit_public_state_t *line_edit_public_h ;
#line 174
void line_edit_finitor(void) ;
#line 144 "/home/wslee/tests/SOURCES/coan-4.2.2/src/io.h"
void ensure_buf(size_t extra ) ;
#line 58 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_despatch.h"
void print(void) ;
#line 70 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_edit.c"
static void tail_edit(char *where , char const   *what ) 
{ 
  size_t tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 73
  if ((unsigned long )io_public_h->line_start <= (unsigned long )where) {
#line 73
    if (! ((unsigned long )where < (unsigned long )(io_public_h->line_start + io_public_h->line_len))) {
      {
      {
#line 73
      __assert_fail("(((1) ? (void) (0) : __assert_fail (\"1\", \"/home/wslee/tests/SOURCES/coan-4.2.2/src/line_edit.c\", 74, __PRETTY_FUNCTION__)),(io_public_h->line_start)) <= where && where < ((((1) ? (void) (0) : __assert_fail (\"1\", \"/home/wslee/tests/SOURCES/coan-4.2.2/src/line_edit.c\", 74, __PRETTY_FUNCTION__)),(io_public_h->line_start)) + (((1) ? (void) (0) : __assert_fail (\"1\", \"/home/wslee/tests/SOURCES/coan-4.2.2/src/line_edit.c\", 74, __PRETTY_FUNCTION__)),(io_public_h->line_len)))",
                    "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_edit.c", 74U, "tail_edit");
      }
      }
    }
  } else {
    {
    {
#line 73
    __assert_fail("(((1) ? (void) (0) : __assert_fail (\"1\", \"/home/wslee/tests/SOURCES/coan-4.2.2/src/line_edit.c\", 74, __PRETTY_FUNCTION__)),(io_public_h->line_start)) <= where && where < ((((1) ? (void) (0) : __assert_fail (\"1\", \"/home/wslee/tests/SOURCES/coan-4.2.2/src/line_edit.c\", 74, __PRETTY_FUNCTION__)),(io_public_h->line_start)) + (((1) ? (void) (0) : __assert_fail (\"1\", \"/home/wslee/tests/SOURCES/coan-4.2.2/src/line_edit.c\", 74, __PRETTY_FUNCTION__)),(io_public_h->line_len)))",
                  "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_edit.c", 74U, "tail_edit");
    }
    }
  }
  {
  {
#line 75
  tmp = strlen(what);
  }
  {
#line 75
  ensure_buf(tmp);
  }
  {
#line 76
  strcpy((char */* __restrict  */)where, (char const   */* __restrict  */)what);
  }
  }
#line 77
  return;
}
}
#line 83 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_edit.c"
void keywordedit(char const   *replacement ) 
{ 


  {
  {
  {
#line 86
  tail_edit(line_edit_public_h->keyword, replacement);
  }
#line 87
  (line_despatch_public_h->lines_changed) ++;
  {
#line 88
  print();
  }
  }
#line 89
  return;
}
}
#line 92 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_edit.c"
void delete_paren(size_t lparen_off , size_t rparen_off ) 
{ 
  char *lparen ;
  char *rparen ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;

  {
#line 95
  lparen = io_public_h->line_start + lparen_off;
#line 96
  rparen = io_public_h->line_start + rparen_off;
  {
  {
#line 97
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 97
    if ((int )*lparen != 40) {
#line 97
      if (! ((unsigned long )lparen < (unsigned long )rparen)) {
#line 97
        goto while_break;
      }
    } else {
#line 97
      goto while_break;
    }
#line 97
    lparen ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 98
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 98
    if ((int )*rparen != 41) {
#line 98
      if (! ((unsigned long )rparen > (unsigned long )lparen)) {
#line 98
        goto while_break___0;
      }
    } else {
#line 98
      goto while_break___0;
    }
#line 98
    rparen --;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 99
  if ((int )*lparen == 40) {
#line 99
    if ((int )*rparen == 41) {
      {
      {
#line 100
      tmp = is_symbol_inner_char(*(lparen + -1));
      }
      }
#line 100
      if (tmp) {
        {
        {
#line 100
        tmp___0 = is_symbol_inner_char(*(lparen + 1));
        }
        }
#line 100
        if (! tmp___0) {
          _L: /* CIL Label */ 
          {
          {
#line 100
          tmp___1 = is_symbol_inner_char(*(rparen + -1));
          }
          }
#line 100
          if (tmp___1) {
            {
            {
#line 100
            tmp___2 = is_symbol_inner_char(*(rparen + 1));
            }
            }
#line 100
            if (! tmp___2) {
#line 105
              *lparen = (char)2;
#line 106
              *rparen = (char)3;
#line 107
              (line_edit_public_h->parens_deleted) ++;
            }
          } else {
#line 105
            *lparen = (char)2;
#line 106
            *rparen = (char)3;
#line 107
            (line_edit_public_h->parens_deleted) ++;
          }
        }
      } else {
#line 100
        goto _L;
      }
    }
  }
#line 110
  return;
}
}
#line 112 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_edit.c"
extern void restore_paren(size_t lparen_off , size_t rparen_off ) 
{ 
  char *lparen ;
  char *rparen ;

  {
#line 115
  lparen = io_public_h->line_start + lparen_off;
#line 116
  rparen = io_public_h->line_start + rparen_off;
  {
  {
#line 117
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 117
    if ((int )*lparen != 2) {
#line 117
      if (! ((unsigned long )lparen < (unsigned long )rparen)) {
#line 117
        goto while_break;
      }
    } else {
#line 117
      goto while_break;
    }
#line 117
    lparen ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 118
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 118
    if ((int )*rparen != 3) {
#line 118
      if (! ((unsigned long )rparen > (unsigned long )lparen)) {
#line 118
        goto while_break___0;
      }
    } else {
#line 118
      goto while_break___0;
    }
#line 118
    rparen --;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 119
  if ((int )*lparen == 2) {
#line 119
    if ((int )*rparen == 3) {
#line 120
      *lparen = (char )'(';
#line 121
      *rparen = (char )')';
#line 122
      (line_edit_public_h->parens_deleted) --;
    }
  }
#line 124
  return;
}
}
#line 125 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_edit.c"
void restore_all_paren(void) 
{ 
  char *buf ;

  {
#line 128
  buf = io_public_h->line_start;
  {
  {
#line 129
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 129
    if (! *buf) {
#line 129
      goto while_break;
    }
#line 130
    if ((int )*buf == 2) {
#line 131
      *buf = (char )'(';
    } else
#line 132
    if ((int )*buf == 3) {
#line 133
      *buf = (char )')';
    }
#line 129
    buf ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  return;
}
}
#line 138 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_edit.c"
void cut_text(char const   *start , char const   *end ) 
{ 
  char *s ;
  char *e ;

  {
  {
#line 141
  s = (char *)start;
#line 142
  e = (char *)end;
#line 143
  line_edit_public_h->ops_cut = (_Bool)1;
  {
#line 144
  memset((void *)s, 1, (size_t )(e - s));
  }
  }
#line 146
  if (! *e) {
#line 147
    *(e + -1) = (char )'\n';
  }
#line 149
  return;
}
}
#line 151 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_edit.c"
void truncate_line(size_t off ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 154
  if (! (off < io_public_h->line_len)) {
    {
    {
#line 154
    __assert_fail("off < (((1) ? (void) (0) : __assert_fail (\"1\", \"/home/wslee/tests/SOURCES/coan-4.2.2/src/line_edit.c\", 154, __PRETTY_FUNCTION__)),(io_public_h->line_len))",
                  "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_edit.c", 154U, "truncate_line");
    }
    }
  }
#line 155
  *(io_public_h->line_start + off) = (char )'\000';
#line 156
  io_public_h->line_len = off;
#line 157
  return;
}
}
#line 168 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_edit.c"
static line_edit_state_t line_edit_state  ;
#line 168 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_edit.c"
line_edit_state_t *line_edit_h  =    & line_edit_state;
#line 168 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_edit.c"
line_edit_public_state_t *line_edit_public_h  =    & line_edit_state;
#line 168 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_edit.c"
static line_edit_state_t const   * const  line_edit_static_initialiser_h  ;
#line 168 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_edit.c"
void (*line_edit_init_h)(line_edit_state_t * )  ;
#line 168 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_edit.c"
void (*line_edit_finis_h)(line_edit_state_t * )  ;
#line 168 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_edit.c"
void line_edit_initor(void) 
{ 


  {
  {
  {
#line 168
  component_initor((_Bool)1, (_Bool)1, (void **)((char *)(& line_edit_h)), (void **)((char *)(& line_edit_public_h)),
                   (void const   *)line_edit_static_initialiser_h, sizeof(line_edit_state_t ),
                   (void (*)())line_edit_init_h);
  }
  }
#line 168
  return;
}
}
#line 168 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_edit.c"
void line_edit_finitor(void) 
{ 


  {
  {
  {
#line 168
  component_finitor((_Bool)1, (void **)((char *)(& line_edit_h)), (void **)((char *)(& line_edit_public_h)),
                    (void (*)())line_edit_init_h);
  }
  }
#line 168
  return;
}
}
#line 233 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 75 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_despatch.h"
void substitute(char const   *replacement ) ;
#line 82
void line_despatch_no_op(void) ;
#line 101
void line_despatch_finitor(void) ;
#line 461 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 555 "/usr/include/stdio.h"
extern int fputc(int __c , FILE *__stream ) ;
#line 688
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 64 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_despatch.c"
static void printline_fast(void) 
{ 


  {
  {
  {
#line 67
  fputs((char const   */* __restrict  */)io_public_h->line_start, (FILE */* __restrict  */)io_public_h->output);
  }
  }
#line 68
  return;
}
}
#line 73 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_despatch.c"
static void printline_cut(void) 
{ 
  discard_policy_t discard_policy ;
  size_t extension_lines ;
  char *cp ;
  char last_written ;
  char tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 76
  discard_policy = args_public_h->discard_policy;
#line 77
  extension_lines = io_public_h->extension_lines;
#line 78
  cp = io_public_h->line_start;
#line 79
  line_despatch_public_h->lines_changed = (int )((size_t )line_despatch_public_h->lines_changed + (extension_lines + 1UL));
#line 80
  last_written = (char )' ';
  {
  {
#line 81
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 81
    if (! ((int )*cp != 10)) {
#line 81
      goto while_break;
    }
#line 82
    if (! *cp) {
      {
      {
#line 82
      __assert_fail("*cp", "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_despatch.c",
                    82U, "printline_cut");
      }
      }
    }
#line 83
    if (! ((int )*cp < 4)) {
#line 84
      if (! ((int )*cp == 32)) {
#line 85
        if ((int )*cp == 92) {
#line 85
          if ((int )*(cp + 1) == 10) {
#line 86
            tmp = (char )' ';
#line 86
            *(cp + 1) = tmp;
#line 86
            *cp = tmp;
#line 87
            cp ++;
          } else {
#line 85
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
          {
#line 89
          tmp___1 = __ctype_b_loc();
          }
          }
#line 89
          if ((int const   )*(*tmp___1 + (int )*cp) & 8192) {
#line 90
            *cp = (char )' ';
          } else {
            {
            {
#line 92
            tmp___0 = __ctype_b_loc();
            }
            }
#line 92
            if (! ((int const   )*(*tmp___0 + (int )last_written) & 8192)) {
              {
              {
#line 93
              fputc(' ', io_public_h->output);
              }
#line 94
              last_written = (char )' ';
              }
            }
          }
        }
      }
      {
      {
#line 96
      fputc((int )*cp, io_public_h->output);
      }
      }
    } else
#line 98
    if (! ((int )last_written < 4)) {
#line 99
      last_written = *cp;
    }
#line 81
    cp ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 102
  fputc('\n', io_public_h->output);
  }
  }
#line 103
  if ((unsigned int )discard_policy == 1U) {
    {
    {
#line 104
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 104
      if (! extension_lines) {
#line 104
        goto while_break___0;
      }
      {
      {
#line 105
      _IO_putc('\n', io_public_h->output);
      }
#line 104
      extension_lines --;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 108
  if ((unsigned int )discard_policy == 2U) {
    {
    {
#line 109
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 109
      if (! extension_lines) {
#line 109
        goto while_break___1;
      }
      {
      {
#line 110
      fputs((char const   */* __restrict  */)"//coan <\n", (FILE */* __restrict  */)io_public_h->output);
      }
#line 109
      extension_lines --;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 113
  return;
}
}
#line 122 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_despatch.c"
static void printline_restore_all_paren(void) 
{ 


  {
  {
  {
#line 125
  restore_all_paren();
  }
  {
#line 126
  printline_fast();
  }
  }
#line 127
  return;
}
}
#line 137 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_despatch.c"
static void printline_slow(void) 
{ 


  {
#line 140
  if (line_edit_public_h->ops_cut) {
    {
    {
#line 141
    printline_cut();
    }
    }
  } else {
    {
    {
#line 143
    printline_restore_all_paren();
    }
    }
  }
#line 145
  return;
}
}
#line 152 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_despatch.c"
static void printline(void) 
{ 


  {
#line 155
  if ((int )line_edit_public_h->ops_cut == 0) {
#line 155
    if (line_edit_public_h->parens_deleted == 0UL) {
      {
      {
#line 156
      printline_fast();
      }
      }
    } else {
      {
      {
#line 158
      printline_slow();
      }
      }
    }
  } else {
    {
    {
#line 158
    printline_slow();
    }
    }
  }
#line 160
  return;
}
}
#line 164 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_despatch.c"
static void printline_commented_out(void) 
{ 
  size_t extension_lines ;
  char const   *linestart ;
  char const   *newline ;
  size_t written ;
  char *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 167
  if ((int )line_edit_public_h->ops_cut == 0) {
#line 167
    if (line_edit_public_h->parens_deleted == 0UL) {
#line 168
      (line_despatch_public_h->lines_changed) ++;
#line 169
      extension_lines = io_public_h->extension_lines;
#line 170
      if (! extension_lines) {
        {
        {
#line 171
        fputs((char const   */* __restrict  */)"//coan < ", (FILE */* __restrict  */)io_public_h->output);
        }
        {
#line 172
        printline_fast();
        }
        }
      } else {
#line 175
        line_despatch_public_h->lines_changed = (int )((size_t )line_despatch_public_h->lines_changed + extension_lines);
#line 176
        linestart = (char const   *)io_public_h->line_start;
        {
        {
#line 178
        while (1) {
          while_continue___0: /* CIL Label */ ;
          while_continue: /* CIL Label */ ;
          {
          {
#line 178
          tmp = strchr(linestart, '\n');
          }
#line 178
          newline = (char const   *)tmp;
          }
#line 178
          if (! ((unsigned long )newline != (unsigned long )((void *)0))) {
#line 178
            goto while_break;
          }
          {
          {
#line 180
          fputs((char const   */* __restrict  */)"//coan < ", (FILE */* __restrict  */)io_public_h->output);
          }
          {
#line 181
          written = fwrite((void const   */* __restrict  */)linestart, (size_t )1,
                           (size_t )(newline - linestart), (FILE */* __restrict  */)io_public_h->output);
          }
          }
#line 182
          if (! (written == (size_t )(newline - linestart))) {
            {
            {
#line 182
            __assert_fail("written == newline - linestart", "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_despatch.c",
                          182U, "printline_commented_out");
            }
            }
          }
          {
          {
#line 183
          fputc('\n', io_public_h->output);
          }
#line 184
          linestart = newline + 1;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        while_break: /* CIL Label */ ;
        }
      }
    } else {
      {
      {
#line 188
      fputs((char const   */* __restrict  */)"//coan < ", (FILE */* __restrict  */)io_public_h->output);
      }
      {
#line 189
      printline_slow();
      }
      }
    }
  } else {
    {
    {
#line 188
    fputs((char const   */* __restrict  */)"//coan < ", (FILE */* __restrict  */)io_public_h->output);
    }
    {
#line 189
    printline_slow();
    }
    }
  }
#line 191
  return;
}
}
#line 196 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_despatch.c"
static void flushline_dummy(_Bool keep , char const   *insert_text ) 
{ 


  {
#line 197
  return;
}
}
#line 218 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_despatch.c"
static void flushline_live(_Bool keep , char const   *insert_text ) 
{ 
  size_t extension_lines ;
  discard_policy_t discard_policy ;

  {
#line 221
  if (insert_text) {
    {
    {
#line 224
    fputs((char const   */* __restrict  */)insert_text, (FILE */* __restrict  */)io_public_h->output);
    }
#line 225
    (line_despatch_public_h->lines_inactive) --;
#line 226
    (line_despatch_public_h->lines_changed) ++;
    }
#line 227
    return;
  }
#line 229
  if ((int )keep ^ (int )args_public_h->complement) {
    {
    {
#line 230
    printline();
    }
    }
  } else {
#line 232
    extension_lines = io_public_h->extension_lines;
#line 233
    discard_policy = args_public_h->discard_policy;
#line 234
    if ((unsigned int )discard_policy == 1U) {
      {
#line 235
      line_despatch_public_h->lines_changed = (int )((size_t )line_despatch_public_h->lines_changed + (extension_lines + 1UL));
      {
#line 236
      _IO_putc('\n', io_public_h->output);
      }
      }
      {
      {
#line 237
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 237
        if (! extension_lines) {
#line 237
          goto while_break;
        }
        {
        {
#line 238
        _IO_putc('\n', io_public_h->output);
        }
#line 237
        extension_lines --;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
    } else
#line 240
    if ((unsigned int )discard_policy == 0U) {
#line 241
      line_despatch_public_h->lines_inactive = (int )((size_t )line_despatch_public_h->lines_inactive + (extension_lines + 1UL));
    } else {
      {
      {
#line 243
      printline_commented_out();
      }
      }
    }
  }
#line 246
  return;
}
}
#line 274 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_despatch.c"
static line_despatch_state_t line_despatch_state  ;
#line 274 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_despatch.c"
line_despatch_state_t *line_despatch_h  =    & line_despatch_state;
#line 274 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_despatch.c"
line_despatch_public_state_t *line_despatch_public_h  =    (line_despatch_public_state_t *)(& line_despatch_state);
#line 274
static line_despatch_state_t const   * const  line_despatch_static_initialiser_h ;
#line 274 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_despatch.c"
void (*line_despatch_init_h)(line_despatch_state_t * )  ;
#line 274 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_despatch.c"
void (*line_despatch_finis_h)(line_despatch_state_t * )  ;
#line 274 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_despatch.c"
void line_despatch_initor(void) 
{ 


  {
  {
  {
#line 274
  component_initor((_Bool)1, (_Bool)0, (void **)((char *)(& line_despatch_h)), (void **)((char *)(& line_despatch_public_h)),
                   (void const   *)line_despatch_static_initialiser_h, sizeof(line_despatch_state_t ),
                   (void (*)())line_despatch_init_h);
  }
  }
#line 274
  return;
}
}
#line 274 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_despatch.c"
void line_despatch_finitor(void) 
{ 


  {
  {
  {
#line 274
  component_finitor((_Bool)1, (void **)((char *)(& line_despatch_h)), (void **)((char *)(& line_despatch_public_h)),
                    (void (*)())line_despatch_init_h);
  }
  }
#line 274
  return;
}
}
#line 276
static struct line_despatch_state_s  const  line_despatch_static_initialiser ;
#line 276 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_despatch.c"
static line_despatch_state_t const   * const  line_despatch_static_initialiser_h  =    (line_despatch_state_t const   */* const  */)(& line_despatch_static_initialiser);
#line 276 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_despatch.c"
static struct line_despatch_state_s  const  line_despatch_static_initialiser  =    {{0, 0}, & flushline_live, (size_t )0};
#line 281 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_despatch.c"
void line_despatch_no_op(void) 
{ 


  {
#line 284
  line_despatch_state.flushline = & flushline_dummy;
#line 285
  return;
}
}
#line 287 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_despatch.c"
void print(void) 
{ 
  int line_num ;
  size_t extension_lines ;
  char *__cil_tmp3 ;

  {
#line 290
  if (args_public_h->line_directives) {
#line 291
    if (line_despatch_state.drop_run) {
#line 292
      line_num = io_public_h->line_num;
#line 293
      extension_lines = io_public_h->extension_lines;
#line 294
      if (extension_lines) {
#line 295
        line_num --;
      }
      {
      {
#line 297
      printf((char const   */* __restrict  */)"#line %d\n", line_num);
      }
#line 298
      (line_despatch_public_h->lines_inactive) --;
#line 299
      (line_despatch_public_h->lines_changed) ++;
      }
    }
#line 301
    line_despatch_state.drop_run = (size_t )0;
  }
  {
  {
#line 303
  (*(line_despatch_state.flushline))((_Bool)1, (char const   *)((void *)0));
  }
  }
#line 305
  return;
}
}
#line 307 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_despatch.c"
void drop(void) 
{ 


  {
  {
  {
#line 310
  (*(line_despatch_state.flushline))((_Bool)0, (char const   *)((void *)0));
  }
  }
#line 311
  if (args_public_h->line_directives) {
#line 312
    (line_despatch_state.drop_run) ++;
  }
#line 314
  return;
}
}
#line 316 "/home/wslee/tests/SOURCES/coan-4.2.2/src/line_despatch.c"
void substitute(char const   *replacement ) 
{ 


  {
  {
  {
#line 319
  (*(line_despatch_state.flushline))((_Bool)0, replacement);
  }
  }
#line 320
  return;
}
}
#line 130 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 135
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 260
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
#line 279 "/home/wslee/tests/SOURCES/coan-4.2.2/src/filesys.h"
char *fs_tempname(char *template ) ;
#line 145 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 155
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 157
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 214
extern int fclose(FILE *__stream ) ;
#line 249
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 520
extern int getchar(void) ;
#line 604
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 803
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 71 "/home/wslee/tests/SOURCES/coan-4.2.2/src/io.h"
char *read_filename(void) ;
#line 80
FILE *open_file(char const   *file , char const   *mode ) ;
#line 115
_Bool get_line(void) ;
#line 131
char *read_more(char const   *readpos ) ;
#line 136
_Bool input_opened(void) ;
#line 155
void save_read_pos(char const   *cp ) ;
#line 166
char *saved_read_pos(void) ;
#line 174
size_t read_offset(char const   *readpos ) ;
#line 178
char *read_pos(size_t readoff ) ;
#line 207
void io_finitor(void) ;
#line 89 "/home/wslee/tests/SOURCES/coan-4.2.2/src/configured_symbols.h"
void configured_symbols_rewind(void) ;
#line 56 "/home/wslee/tests/SOURCES/coan-4.2.2/src/io.c"
static _Bool readon(void) ;
#line 66
static void make_tempfile(void) ;
#line 76
static void replace_infile(void) ;
#line 86
static void make_backup_name(char const   *filename ) ;
#line 93
static void backup_infile(void) ;
#line 99 "/home/wslee/tests/SOURCES/coan-4.2.2/src/io.c"
static void delete_infile(void) 
{ 
  int tmp ;
  char *__cil_tmp2 ;

  {
  {
  {
#line 102
  tmp = remove(io_public_h->filename);
  }
  }
#line 102
  if (tmp) {
    {
    {
#line 103
    bail(33328, "Cannot remove file \"%s\"", io_public_h->filename);
    }
    }
  }
#line 106
  return;
}
}
#line 114
static void open_output(void) ;
#line 141 "/home/wslee/tests/SOURCES/coan-4.2.2/src/io.c"
static io_state_t io_state  ;
#line 141 "/home/wslee/tests/SOURCES/coan-4.2.2/src/io.c"
io_state_t *io_h  =    & io_state;
#line 141 "/home/wslee/tests/SOURCES/coan-4.2.2/src/io.c"
io_public_state_t *io_public_h  =    (io_public_state_t *)(& io_state);
#line 141 "/home/wslee/tests/SOURCES/coan-4.2.2/src/io.c"
static io_state_t const   * const  io_static_initialiser_h  ;
#line 141 "/home/wslee/tests/SOURCES/coan-4.2.2/src/io.c"
void (*io_init_h)(io_state_t * )  ;
#line 141 "/home/wslee/tests/SOURCES/coan-4.2.2/src/io.c"
void (*io_finis_h)(io_state_t * )  ;
#line 141 "/home/wslee/tests/SOURCES/coan-4.2.2/src/io.c"
void io_initor(void) 
{ 


  {
  {
  {
#line 141
  component_initor((_Bool)1, (_Bool)1, (void **)((char *)(& io_h)), (void **)((char *)(& io_public_h)),
                   (void const   *)io_static_initialiser_h, sizeof(io_state_t ), (void (*)())io_init_h);
  }
  }
#line 141
  return;
}
}
#line 141 "/home/wslee/tests/SOURCES/coan-4.2.2/src/io.c"
void io_finitor(void) 
{ 


  {
  {
  {
#line 141
  component_finitor((_Bool)1, (void **)((char *)(& io_h)), (void **)((char *)(& io_public_h)),
                    (void (*)())io_init_h);
  }
  }
#line 141
  return;
}
}
#line 149 "/home/wslee/tests/SOURCES/coan-4.2.2/src/io.c"
char *read_filename(void) 
{ 
  int ch ;
  size_t pos ;
  _Bool quoted ;
  char *in_name_buf ;
  void *tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 152
  pos = (size_t )0;
#line 154
  in_name_buf = io_state.in_name_buf;
#line 155
  if ((unsigned long )in_name_buf == (unsigned long )((void *)0)) {
    {
    {
#line 156
    tmp = zallocate((size_t )4097);
    }
#line 156
    io_state.in_name_buf = (char *)tmp;
#line 156
    in_name_buf = io_state.in_name_buf;
    }
  }
  {
  {
#line 158
  ch = getchar();
  }
#line 159
  *(in_name_buf + 0) = (char )'\000';
  }
  {
  {
#line 161
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 161
    if (ch != -1) {
      {
      {
#line 161
      tmp___0 = __ctype_b_loc();
      }
      }
#line 161
      if (! ((int const   )*(*tmp___0 + ch) & 8192)) {
#line 161
        goto while_break;
      }
    } else {
#line 161
      goto while_break;
    }
    {
    {
#line 161
    ch = getchar();
    }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  if (ch == -1) {
#line 163
    return ((char *)((void *)0));
  }
#line 165
  quoted = (_Bool )(ch == 34);
#line 166
  if (quoted) {
    {
    {
#line 167
    ch = getchar();
    }
    }
    {
    {
#line 167
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 167
      if (ch != -1) {
#line 167
        if (! (ch != 34)) {
#line 167
          goto while_break___0;
        }
      } else {
#line 167
        goto while_break___0;
      }
      {
      {
#line 168
      tmp___1 = __ctype_b_loc();
      }
      }
#line 168
      if ((int const   )*(*tmp___1 + ch) & 8192) {
#line 168
        if (ch != 32) {
          {
#line 169
          *(in_name_buf + pos) = (char )'\000';
          {
#line 170
          bail(33312, "Illegal whitespace in input filename: \"%s...", in_name_buf);
          }
          }
        }
      }
#line 174
      tmp___2 = pos;
#line 174
      pos ++;
#line 174
      *(in_name_buf + tmp___2) = (char )ch;
#line 175
      if (pos == 4096UL) {
        {
#line 176
        *(in_name_buf + pos) = (char )'\000';
        {
#line 177
        bail(33152, "A filename exceeds max %d bytes: \"%s...", 4096, in_name_buf);
        }
        }
      }
      {
      {
#line 167
      ch = getchar();
      }
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 182
    *(in_name_buf + pos) = (char )'\000';
#line 183
    if (ch == -1) {
      {
      {
#line 184
      bail(33168, "A quoted input filename is unterminated: \"%s...", in_name_buf);
      }
      }
    }
  } else {
    {
    {
#line 189
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 189
      if (ch != -1) {
        {
        {
#line 189
        tmp___4 = __ctype_b_loc();
        }
        }
#line 189
        if ((int const   )*(*tmp___4 + ch) & 8192) {
#line 189
          goto while_break___1;
        }
      } else {
#line 189
        goto while_break___1;
      }
#line 190
      tmp___3 = pos;
#line 190
      pos ++;
#line 190
      *(in_name_buf + tmp___3) = (char )ch;
#line 191
      if (pos == 4096UL) {
        {
#line 192
        *(in_name_buf + pos) = (char )'\000';
        {
#line 193
        bail(33152, "An input filename exceeds max %d bytes: \"%s...", 4096, in_name_buf);
        }
        }
      }
      {
      {
#line 189
      ch = getchar();
      }
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 198
    *(in_name_buf + pos) = (char )'\000';
  }
#line 200
  return (in_name_buf);
}
}
#line 203 "/home/wslee/tests/SOURCES/coan-4.2.2/src/io.c"
static _Bool readon(void) 
{ 
  size_t read ;
  char *bufp ;
  void *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp6 ;

  {
#line 206
  read = (size_t )0;
  {
  {
#line 207
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 209
    if (io_public_h->line_len + 1UL >= io_state.bufsz) {
      {
#line 211
      io_state.bufsz += 8192UL;
      {
#line 211
      tmp = reallocate((void *)io_public_h->line_start, io_state.bufsz);
      }
#line 211
      io_public_h->line_start = (char *)tmp;
      }
    }
    {
#line 216
    bufp = io_public_h->line_start + io_public_h->line_len;
    {
#line 218
    tmp___1 = fgets((char */* __restrict  */)bufp, (int )(io_state.bufsz - io_public_h->line_len),
                    (FILE */* __restrict  */)io_state.input);
    }
    }
#line 218
    if ((unsigned long )((void *)0) == (unsigned long )tmp___1) {
      {
      {
#line 221
      tmp___0 = ferror(io_state.input);
      }
      }
#line 221
      if (tmp___0) {
        {
        {
#line 222
        bail(33248, "Read error on file %s", io_public_h->filename);
        }
        }
      }
#line 225
      goto while_break;
    }
    {
    {
#line 228
    read = strlen((char const   *)bufp);
    }
#line 228
    io_public_h->line_len += read;
#line 229
    bufp += read;
    }
#line 230
    if ((int )*(bufp + -1) == 10) {
#line 232
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 235
  return ((_Bool )(read != 0UL));
}
}
#line 241 "/home/wslee/tests/SOURCES/coan-4.2.2/src/io.c"
static _Bool extend_line(void) 
{ 
  _Bool eof ;
  _Bool tmp ;
  int tmp___0 ;

  {
  {
  {
#line 244
  tmp = readon();
  }
  }
#line 244
  if (tmp) {
#line 244
    tmp___0 = 0;
  } else {
#line 244
    tmp___0 = 1;
  }
#line 244
  eof = (_Bool )tmp___0;
#line 245
  if (! eof) {
#line 246
    (io_public_h->line_num) ++;
#line 247
    return ((_Bool)1);
  }
#line 249
  return ((_Bool)0);
}
}
#line 252 "/home/wslee/tests/SOURCES/coan-4.2.2/src/io.c"
static void make_tempfile(void) 
{ 
  char *out_name_buf ;
  char const   *infile ;
  char const   *delim ;
  char *tmp ;
  char const   *tempname ;
  size_t dirlen ;
  long tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 255
  out_name_buf = io_state.out_name_buf;
#line 256
  infile = io_public_h->filename;
  {
#line 257
  tmp = strrchr(infile, '/');
  }
#line 257
  delim = (char const   *)tmp;
#line 258
  tempname = (char const   *)((void *)0);
  }
#line 259
  if (delim) {
#line 259
    tmp___0 = delim - infile;
  } else {
#line 259
    tmp___0 = 0L;
  }
#line 259
  dirlen = (size_t )tmp___0;
#line 260
  if ((unsigned long )out_name_buf == (unsigned long )((void *)0)) {
    {
    {
#line 261
    tmp___1 = zallocate((size_t )4096);
    }
#line 261
    io_state.out_name_buf = (char *)tmp___1;
#line 261
    out_name_buf = io_state.out_name_buf;
    }
  }
#line 264
  if (dirlen) {
    {
    {
#line 265
    strncpy((char */* __restrict  */)out_name_buf, (char const   */* __restrict  */)infile,
            dirlen);
    }
#line 266
    tmp___2 = dirlen;
#line 266
    dirlen ++;
#line 266
    *(out_name_buf + tmp___2) = (char )'/';
    }
  }
  {
  {
#line 268
  strcpy((char */* __restrict  */)(out_name_buf + dirlen), (char const   */* __restrict  */)"coan_out_XXXXXX");
  }
  {
#line 269
  tmp___3 = fs_tempname(out_name_buf);
  }
#line 269
  tempname = (char const   *)tmp___3;
  }
#line 270
  if (! tempname) {
    {
    {
#line 271
    bail(33360, "Cannot create temporary file");
    }
    }
  }
#line 274
  return;
}
}
#line 276 "/home/wslee/tests/SOURCES/coan-4.2.2/src/io.c"
static void replace_infile(void) 
{ 
  int tmp ;
  char *__cil_tmp2 ;

  {
  {
  {
#line 279
  tmp = rename((char const   *)io_state.out_name_buf, io_public_h->filename);
  }
  }
#line 279
  if (tmp) {
    {
    {
#line 281
    bail(33344, "Cannot rename file \"%s\" as \"%s\"", io_state.out_name_buf, io_public_h->filename);
    }
    }
  }
#line 286
  return;
}
}
#line 288 "/home/wslee/tests/SOURCES/coan-4.2.2/src/io.c"
static void make_backup_name(char const   *filename ) 
{ 
  FILE *exists ;
  size_t suffix_len ;
  size_t tmp ;
  size_t namelen ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 291
  exists = (FILE *)((void *)0);
  {
#line 292
  tmp = strlen((char const   *)args_public_h->backup_suffix);
  }
#line 292
  suffix_len = tmp;
  {
#line 293
  tmp___0 = strlen(filename);
  }
#line 293
  namelen = tmp___0 + suffix_len;
  }
#line 294
  if ((unsigned long )io_state.bak_name_buf == (unsigned long )((void *)0)) {
    {
    {
#line 295
    tmp___1 = zallocate((size_t )4097);
    }
#line 295
    io_state.bak_name_buf = (char *)tmp___1;
    }
  }
  {
  {
#line 297
  tmp___2 = strncpy((char */* __restrict  */)io_state.bak_name_buf, (char const   */* __restrict  */)io_public_h->filename,
                    (size_t )4096);
  }
#line 297
  *(tmp___2 + 4096) = (char)0;
  }
  {
  {
#line 299
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 300
    if (namelen > 4096UL) {
      {
      {
#line 301
      bail(33152, "A filename exceeds max %d bytes: \"%s...", 4096, io_state.bak_name_buf);
      }
      }
    }
    {
    {
#line 305
    strcat((char */* __restrict  */)io_state.bak_name_buf, (char const   */* __restrict  */)args_public_h->backup_suffix);
    }
    {
#line 307
    exists = fopen((char const   */* __restrict  */)io_state.bak_name_buf, (char const   */* __restrict  */)"r");
    }
    }
#line 308
    if (! exists) {
#line 309
      goto while_break;
    }
    {
    {
#line 311
    fclose(exists);
    }
#line 312
    namelen += suffix_len;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 314
  return;
}
}
#line 316 "/home/wslee/tests/SOURCES/coan-4.2.2/src/io.c"
static void backup_infile(void) 
{ 
  int tmp ;
  char *__cil_tmp2 ;

  {
  {
  {
#line 319
  make_backup_name(io_public_h->filename);
  }
  {
#line 320
  tmp = rename(io_public_h->filename, (char const   *)io_state.bak_name_buf);
  }
  }
#line 320
  if (tmp) {
    {
    {
#line 322
    bail(33344, "Cannot rename file \"%s\" as \"%s\"", io_public_h->filename, io_state.bak_name_buf);
    }
    }
  }
#line 327
  return;
}
}
#line 330 "/home/wslee/tests/SOURCES/coan-4.2.2/src/io.c"
static void open_output(void) 
{ 
  char *__cil_tmp1 ;

  {
#line 333
  if (! args_public_h->replace) {
#line 334
    io_public_h->output = stdout;
  } else {
    {
    {
#line 336
    make_tempfile();
    }
    {
#line 337
    io_public_h->output = open_file((char const   *)io_state.out_name_buf, "w");
    }
    }
  }
#line 340
  return;
}
}
#line 344 "/home/wslee/tests/SOURCES/coan-4.2.2/src/io.c"
FILE *open_file(char const   *file , char const   *mode ) 
{ 
  FILE *stream ;
  FILE *tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 346
  tmp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)mode);
  }
#line 346
  stream = tmp;
  }
#line 347
  if ((unsigned long )stream == (unsigned long )((void *)0)) {
#line 348
    if ((int const   )*(mode + 0) == 114) {
#line 348
      tmp___0 = "reading";
    } else {
#line 348
      tmp___0 = "writing";
    }
    {
    {
#line 348
    bail(33120, "Can\'t open %s for %s", file, tmp___0);
    }
    }
  }
#line 351
  return (stream);
}
}
#line 354 "/home/wslee/tests/SOURCES/coan-4.2.2/src/io.c"
void close_io(int error___0 ) 
{ 
  int tmp ;

  {
#line 357
  (dataset_public_h->donefiles) ++;
#line 358
  if ((unsigned long )io_state.input != (unsigned long )stdin) {
#line 358
    if ((unsigned long )io_state.input != (unsigned long )((void *)0)) {
      {
      {
#line 361
      fclose(io_state.input);
      }
#line 362
      io_state.input = (FILE *)((void *)0);
      }
#line 364
      if ((unsigned long )io_public_h->output != (unsigned long )stdout) {
#line 364
        if ((unsigned long )io_public_h->output != (unsigned long )((void *)0)) {
          {
          {
#line 366
          fclose(io_public_h->output);
          }
#line 367
          io_public_h->output = (FILE *)((void *)0);
          }
        }
      }
#line 369
      if (! error___0) {
#line 369
        if (args_public_h->replace) {
#line 370
          if ((unsigned long )args_public_h->backup_suffix != (unsigned long )((void *)0)) {
            {
            {
#line 371
            backup_infile();
            }
            }
          } else {
            {
            {
#line 373
            delete_infile();
            }
            }
          }
          {
          {
#line 375
          replace_infile();
          }
          }
        }
      }
    }
  }
#line 379
  if (error___0) {
#line 380
    (dataset_public_h->errorfiles) ++;
#line 381
    if (! args_public_h->keepgoing) {
      {
      {
#line 382
      tmp = exitcode();
      }
      {
#line 382
      exit(tmp);
      }
      }
    }
  }
  {
  {
#line 385
  io_toplevel();
  }
  }
#line 386
  return;
}
}
#line 389 "/home/wslee/tests/SOURCES/coan-4.2.2/src/io.c"
void open_io(char const   *filename ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 392
  io_public_h->filename = filename;
  {
#line 393
  tmp = strcmp(io_public_h->filename, "[stdin]");
  }
  }
#line 393
  if (tmp) {
    {
    {
#line 396
    io_state.input = open_file(io_public_h->filename, "r");
    }
#line 398
    io_public_h->line_num = 0;
    }
  } else {
#line 394
    io_state.input = stdin;
  }
  {
  {
#line 400
  open_output();
  }
  {
#line 401
  configured_symbols_rewind();
  }
  }
#line 402
  return;
}
}
#line 404 "/home/wslee/tests/SOURCES/coan-4.2.2/src/io.c"
_Bool get_line(void) 
{ 
  _Bool got_line ;
  char *pristine_line ;
  char *last_line_end ;
  void *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 408
  last_line_end = (io_public_h->line_start + io_public_h->line_len) - 1;
#line 409
  if ((unsigned long )last_line_end < (unsigned long )io_public_h->line_start) {
#line 410
    last_line_end = (char *)"\n";
  }
#line 412
  io_public_h->line_len = (size_t )0;
#line 413
  io_public_h->extension_lines = (size_t )0;
#line 414
  pristine_line = io_public_h->pristine_line;
#line 415
  if (pristine_line) {
    {
    {
#line 416
    free((void *)pristine_line);
    }
#line 417
    io_public_h->pristine_line = (char *)((void *)0);
    }
  }
  {
  {
#line 419
  got_line = extend_line();
  }
  }
#line 420
  if (! got_line) {
#line 421
    if (io_public_h->line_num != 0) {
#line 421
      if ((int )*last_line_end != 10) {
        {
        {
#line 422
        report((reason_code_t )8480, (heap_str *)((void *)0), "Missing newline at EOF");
        }
        }
      }
    }
  } else {
    {
    {
#line 426
    tmp = clone((void const   *)io_public_h->line_start, (size_t )0);
    }
#line 426
    io_public_h->pristine_line = (char *)tmp;
    }
  }
#line 428
  return (got_line);
}
}
#line 431 "/home/wslee/tests/SOURCES/coan-4.2.2/src/io.c"
char *read_more(char const   *readpos ) 
{ 
  char *tmp ;
  _Bool tmp___0 ;

  {
  {
  {
#line 434
  save_read_pos(readpos);
  }
  {
#line 435
  tmp___0 = extend_line();
  }
  }
#line 435
  if (tmp___0) {
    {
    {
#line 436
    tmp = saved_read_pos();
    }
    }
#line 436
    return (tmp);
  }
  {
  {
#line 438
  early_eof();
  }
  }
#line 439
  return ((char *)((void *)0));
}
}
#line 442 "/home/wslee/tests/SOURCES/coan-4.2.2/src/io.c"
size_t read_offset(char const   *readpos ) 
{ 
  char *linestart ;

  {
#line 445
  linestart = io_public_h->line_start;
#line 446
  return ((size_t )(readpos - (char const   *)linestart));
}
}
#line 449 "/home/wslee/tests/SOURCES/coan-4.2.2/src/io.c"
char *read_pos(size_t readoff ) 
{ 


  {
#line 452
  return (io_public_h->line_start + readoff);
}
}
#line 456 "/home/wslee/tests/SOURCES/coan-4.2.2/src/io.c"
void ensure_buf(size_t extra ) 
{ 
  size_t spare ;
  int i ;
  void *tmp ;

  {
#line 459
  spare = io_state.bufsz - io_public_h->line_len;
#line 461
  i = 0;
  {
  {
#line 461
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 461
    if (! (spare <= extra)) {
#line 461
      goto while_break;
    }
#line 462
    io_state.bufsz += 8192UL;
#line 463
    spare = io_state.bufsz - io_public_h->line_len;
#line 461
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 465
  if (i) {
    {
    {
#line 466
    tmp = reallocate((void *)io_public_h->line_start, io_state.bufsz);
    }
#line 466
    io_public_h->line_start = (char *)tmp;
    }
  }
#line 470
  return;
}
}
#line 472 "/home/wslee/tests/SOURCES/coan-4.2.2/src/io.c"
_Bool input_opened(void) 
{ 


  {
#line 475
  return ((_Bool )(! (! io_state.input)));
}
}
#line 478 "/home/wslee/tests/SOURCES/coan-4.2.2/src/io.c"
void save_read_pos(char const   *cp ) 
{ 


  {
#line 481
  io_state.saved_read_pos = (size_t )(cp - (char const   *)io_public_h->line_start);
#line 482
  return;
}
}
#line 484 "/home/wslee/tests/SOURCES/coan-4.2.2/src/io.c"
char *saved_read_pos(void) 
{ 


  {
#line 487
  return (io_public_h->line_start + io_state.saved_read_pos);
}
}
#line 490 "/home/wslee/tests/SOURCES/coan-4.2.2/src/io.c"
void io_toplevel(void) 
{ 


  {
#line 493
  io_public_h->line_num = 0;
#line 494
  io_public_h->filename = (char const   *)((void *)0);
#line 495
  return;
}
}
#line 74 "/home/wslee/tests/SOURCES/coan-4.2.2/src/includes_tally.h"
void hash_include_tally(char const   *arg , size_t arglen , canonical_string_const_h sym_def ) ;
#line 94
includes_tally_public_state_t *includes_tally_public_h ;
#line 94
void includes_tally_finitor(void) ;
#line 63 "/home/wslee/tests/SOURCES/coan-4.2.2/src/hash_include.h"
hash_include_h hash_include_new(char const   *arg , size_t arglen ) ;
#line 122
void hash_include_define(hash_include_h hi , canonical_string_const_h def ) ;
#line 135
int hash_include_compare(hash_include_const_h lhs , void const   *rhs , size_t arglen ) ;
#line 52 "/home/wslee/tests/SOURCES/coan-4.2.2/src/includes_tally.c"
static includes_tally_state_t includes_tally_state  ;
#line 52 "/home/wslee/tests/SOURCES/coan-4.2.2/src/includes_tally.c"
includes_tally_state_t *includes_tally_h  =    & includes_tally_state;
#line 52 "/home/wslee/tests/SOURCES/coan-4.2.2/src/includes_tally.c"
includes_tally_public_state_t *includes_tally_public_h  =    & includes_tally_state;
#line 52 "/home/wslee/tests/SOURCES/coan-4.2.2/src/includes_tally.c"
static includes_tally_state_t const   * const  includes_tally_static_initialiser_h  ;
#line 52
void (*includes_tally_init_h)(includes_tally_state_t * ) ;
#line 52
void (*includes_tally_finis_h)(includes_tally_state_t * ) ;
#line 52 "/home/wslee/tests/SOURCES/coan-4.2.2/src/includes_tally.c"
void includes_tally_initor(void) 
{ 


  {
  {
  {
#line 52
  component_initor((_Bool)1, (_Bool)0, (void **)((char *)(& includes_tally_h)), (void **)((char *)(& includes_tally_public_h)),
                   (void const   *)includes_tally_static_initialiser_h, sizeof(includes_tally_state_t ),
                   (void (*)())includes_tally_init_h);
  }
  }
#line 52
  return;
}
}
#line 52 "/home/wslee/tests/SOURCES/coan-4.2.2/src/includes_tally.c"
void includes_tally_finitor(void) 
{ 


  {
  {
  {
#line 52
  component_finitor((_Bool)1, (void **)((char *)(& includes_tally_h)), (void **)((char *)(& includes_tally_public_h)),
                    (void (*)())includes_tally_init_h);
  }
  }
#line 52
  return;
}
}
#line 54
void includes_tally_init(includes_tally_state_t *st_state ) ;
#line 54 "/home/wslee/tests/SOURCES/coan-4.2.2/src/includes_tally.c"
void (*includes_tally_init_h)(includes_tally_state_t * )  =    & includes_tally_init;
#line 54 "/home/wslee/tests/SOURCES/coan-4.2.2/src/includes_tally.c"
void includes_tally_init(includes_tally_state_t *st_state ) 
{ 


  {
  {
  {
#line 56
  st_state->includes_tab = ptr_set_new((int (*)(void const   *obj , void const   *key ,
                                                locator_t keylen ))(& hash_include_compare),
                                       (void (*)(void * ))(& symbol_dispose), (void *(*)(void const   * ))(& symbol_copy));
  }
  }
#line 61
  return;
}
}
#line 63
void includes_tally_finis(includes_tally_state_t *st_state ) ;
#line 63 "/home/wslee/tests/SOURCES/coan-4.2.2/src/includes_tally.c"
void (*includes_tally_finis_h)(includes_tally_state_t * )  =    & includes_tally_finis;
#line 63 "/home/wslee/tests/SOURCES/coan-4.2.2/src/includes_tally.c"
void includes_tally_finis(includes_tally_state_t *st_state ) 
{ 


  {
  {
  {
#line 65
  ptr_set_dispose(st_state->includes_tab);
  }
  }
#line 66
  return;
}
}
#line 87 "/home/wslee/tests/SOURCES/coan-4.2.2/src/includes_tally.c"
static hash_include_h hash_include_lookup(char const   *arg , size_t arglen ) 
{ 
  hash_include_h inc_arg ;
  void *tmp ;

  {
  {
  {
#line 90
  tmp = ptr_set_search(includes_tally_public_h->includes_tab, arg, (locator_t )arglen);
  }
#line 90
  inc_arg = (hash_include_h )tmp;
  }
#line 93
  return (inc_arg);
}
}
#line 99 "/home/wslee/tests/SOURCES/coan-4.2.2/src/includes_tally.c"
static void hash_include_add(hash_include_h inc_arg ) 
{ 


  {
  {
  {
#line 102
  ptr_set_insert(includes_tally_public_h->includes_tab, (void const   *)inc_arg);
  }
  }
#line 103
  return;
}
}
#line 109 "/home/wslee/tests/SOURCES/coan-4.2.2/src/includes_tally.c"
void hash_include_tally(char const   *arg , size_t arglen , canonical_string_const_h sym_def ) 
{ 
  hash_include_h inc_arg ;
  hash_include_h tmp ;
  canonical_string_const_h old_def ;
  canonical_string_const_h tmp___0 ;
  _Bool tmp___1 ;

  {
  {
  {
#line 114
  tmp = hash_include_lookup(arg, arglen);
  }
#line 114
  inc_arg = tmp;
  }
#line 115
  if (! inc_arg) {
    {
    {
#line 116
    inc_arg = hash_include_new(arg, arglen);
    }
    }
#line 117
    if (sym_def) {
      {
      {
#line 118
      hash_include_define(inc_arg, sym_def);
      }
      }
    }
    {
    {
#line 120
    hash_include_add(inc_arg);
    }
    {
#line 121
    report_include((hash_include_const_h )inc_arg);
    }
    }
  } else {
    {
    {
#line 123
    tmp___0 = symbol_definition((symbol_const_h )inc_arg);
    }
#line 123
    old_def = tmp___0;
    }
#line 124
    if (sym_def) {
#line 125
      if (! old_def) {
        {
        {
#line 126
        hash_include_define(inc_arg, sym_def);
        }
        }
      } else {
        {
        {
#line 125
        tmp___1 = canonical_string_equal(sym_def, old_def);
        }
        }
#line 125
        if (! tmp___1) {
          {
          {
#line 126
          hash_include_define(inc_arg, sym_def);
          }
          }
        }
      }
    } else
#line 128
    if (old_def) {
      {
      {
#line 129
      symbol_undefine(inc_arg, arg + arglen, (char const   **)((void *)0));
      }
      }
    }
#line 131
    if (! args_public_h->list_only_once) {
      {
      {
#line 132
      report_include((hash_include_const_h )inc_arg);
      }
      }
    }
  }
#line 135
  return;
}
}
#line 98 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.h"
_Bool was_unconditional_line(void) ;
#line 104
_Bool is_unconditional_line(void) ;
#line 131
void if_control_finitor(void) ;
#line 73 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
static void done_file(void) ;
#line 77
static void nest(void) ;
#line 82
static void set_state(if_state_t is ) ;
#line 86 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
static void Strue(void) 
{ 


  {
  {
  {
#line 88
  drop();
  }
  {
#line 89
  set_state((if_state_t )2);
  }
  }
#line 90
  return;
}
}
#line 92 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
static void Sfalse(void) 
{ 


  {
  {
  {
#line 94
  drop();
  }
  {
#line 95
  set_state((if_state_t )1);
  }
  }
#line 96
  return;
}
}
#line 98 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
static void Selse(void) 
{ 


  {
  {
  {
#line 100
  drop();
  }
  {
#line 101
  set_state((if_state_t )8);
  }
  }
#line 102
  return;
}
}
#line 104 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
static void Pelif(void) 
{ 


  {
  {
  {
#line 106
  print();
  }
  {
#line 107
  set_state((if_state_t )3);
  }
  }
#line 108
  return;
}
}
#line 110 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
static void Pelse(void) 
{ 


  {
  {
  {
#line 112
  print();
  }
  {
#line 113
  set_state((if_state_t )6);
  }
  }
#line 114
  return;
}
}
#line 116
static void Pendif(void) ;
#line 118 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
static void Dfalse(void) 
{ 


  {
  {
  {
#line 120
  drop();
  }
  {
#line 121
  set_state((if_state_t )9);
  }
  }
#line 122
  return;
}
}
#line 124 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
static void Delif(void) 
{ 


  {
  {
  {
#line 126
  drop();
  }
  {
#line 127
  set_state((if_state_t )4);
  }
  }
#line 128
  return;
}
}
#line 130 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
static void Delse(void) 
{ 


  {
  {
  {
#line 132
  drop();
  }
  {
#line 133
  set_state((if_state_t )7);
  }
  }
#line 134
  return;
}
}
#line 136
static void Dendif(void) ;
#line 138 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
static void Fdrop(void) 
{ 


  {
  {
  {
#line 140
  nest();
  }
  {
#line 141
  Dfalse();
  }
  }
#line 142
  return;
}
}
#line 144 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
static void Fpass(void) 
{ 


  {
  {
  {
#line 146
  nest();
  }
  {
#line 147
  Pelif();
  }
  }
#line 148
  return;
}
}
#line 150 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
static void Ftrue(void) 
{ 


  {
  {
  {
#line 152
  nest();
  }
  {
#line 153
  Strue();
  }
  }
#line 154
  return;
}
}
#line 156 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
static void Ffalse(void) 
{ 


  {
  {
  {
#line 158
  nest();
  }
  {
#line 159
  Sfalse();
  }
  }
#line 160
  return;
}
}
#line 162 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
static void Mpass(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 164
  strncpy((char */* __restrict  */)line_edit_public_h->keyword, (char const   */* __restrict  */)"if  ",
          (size_t )4);
  }
  {
#line 165
  Pelif();
  }
  }
#line 166
  return;
}
}
#line 168 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
static void Mtrue(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 170
  keywordedit("else\n");
  }
  {
#line 171
  set_state((if_state_t )5);
  }
  }
#line 172
  return;
}
}
#line 174 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
static void Melif(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 176
  keywordedit("endif\n");
  }
  {
#line 177
  set_state((if_state_t )9);
  }
  }
#line 178
  return;
}
}
#line 180 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
static void Melse(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 182
  keywordedit("endif\n");
  }
  {
#line 183
  set_state((if_state_t )7);
  }
  }
#line 184
  return;
}
}
#line 190 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
static transition_t * const  transition_table[10][12]  = 
#line 190
  { {        (transition_t */* const  */)(& Fpass),        (transition_t */* const  */)(& Ftrue),        (transition_t */* const  */)(& Ffalse),        (transition_t */* const  */)(& orphan_elif), 
            (transition_t */* const  */)(& orphan_elif),        (transition_t */* const  */)(& orphan_elif),        (transition_t */* const  */)(& orphan_else),        (transition_t */* const  */)(& orphan_endif), 
            (transition_t */* const  */)(& print),        (transition_t */* const  */)(& done_file)}, 
   {        (transition_t */* const  */)(& Fdrop),        (transition_t */* const  */)(& Fdrop),        (transition_t */* const  */)(& Fdrop),        (transition_t */* const  */)(& Mpass), 
            (transition_t */* const  */)(& Strue),        (transition_t */* const  */)(& Sfalse),        (transition_t */* const  */)(& Selse),        (transition_t */* const  */)(& Dendif), 
            (transition_t */* const  */)(& drop),        (transition_t */* const  */)(& early_eof)}, 
   {        (transition_t */* const  */)(& Fpass),        (transition_t */* const  */)(& Ftrue),        (transition_t */* const  */)(& Ffalse),        (transition_t */* const  */)(& Dfalse), 
            (transition_t */* const  */)(& Dfalse),        (transition_t */* const  */)(& Dfalse),        (transition_t */* const  */)(& Delse),        (transition_t */* const  */)(& Dendif), 
            (transition_t */* const  */)(& print),        (transition_t */* const  */)(& early_eof)}, 
   {        (transition_t */* const  */)(& Fpass),        (transition_t */* const  */)(& Ftrue),        (transition_t */* const  */)(& Ffalse),        (transition_t */* const  */)(& Pelif), 
            (transition_t */* const  */)(& Mtrue),        (transition_t */* const  */)(& Delif),        (transition_t */* const  */)(& Pelse),        (transition_t */* const  */)(& Pendif), 
            (transition_t */* const  */)(& print),        (transition_t */* const  */)(& early_eof)}, 
   {        (transition_t */* const  */)(& Fdrop),        (transition_t */* const  */)(& Fdrop),        (transition_t */* const  */)(& Fdrop),        (transition_t */* const  */)(& Pelif), 
            (transition_t */* const  */)(& Mtrue),        (transition_t */* const  */)(& Delif),        (transition_t */* const  */)(& Pelse),        (transition_t */* const  */)(& Pendif), 
            (transition_t */* const  */)(& drop),        (transition_t */* const  */)(& early_eof)}, 
   {        (transition_t */* const  */)(& Fpass),        (transition_t */* const  */)(& Ftrue),        (transition_t */* const  */)(& Ffalse),        (transition_t */* const  */)(& Melif), 
            (transition_t */* const  */)(& Melif),        (transition_t */* const  */)(& Melif),        (transition_t */* const  */)(& Melse),        (transition_t */* const  */)(& Pendif), 
            (transition_t */* const  */)(& print),        (transition_t */* const  */)(& early_eof)}, 
   {        (transition_t */* const  */)(& Fpass),        (transition_t */* const  */)(& Ftrue),        (transition_t */* const  */)(& Ffalse),        (transition_t */* const  */)(& orphan_elif), 
            (transition_t */* const  */)(& orphan_elif),        (transition_t */* const  */)(& orphan_elif),        (transition_t */* const  */)(& orphan_else),        (transition_t */* const  */)(& Pendif), 
            (transition_t */* const  */)(& print),        (transition_t */* const  */)(& early_eof)}, 
   {        (transition_t */* const  */)(& Fdrop),        (transition_t */* const  */)(& Fdrop),        (transition_t */* const  */)(& Fdrop),        (transition_t */* const  */)(& orphan_elif), 
            (transition_t */* const  */)(& orphan_elif),        (transition_t */* const  */)(& orphan_elif),        (transition_t */* const  */)(& orphan_else),        (transition_t */* const  */)(& Dendif), 
            (transition_t */* const  */)(& drop),        (transition_t */* const  */)(& early_eof)}, 
   {        (transition_t */* const  */)(& Fpass),        (transition_t */* const  */)(& Ftrue),        (transition_t */* const  */)(& Ffalse),        (transition_t */* const  */)(& orphan_elif), 
            (transition_t */* const  */)(& orphan_elif),        (transition_t */* const  */)(& orphan_elif),        (transition_t */* const  */)(& orphan_else),        (transition_t */* const  */)(& Dendif), 
            (transition_t */* const  */)(& print),        (transition_t */* const  */)(& early_eof)}, 
   {        (transition_t */* const  */)(& Fdrop),        (transition_t */* const  */)(& Fdrop),        (transition_t */* const  */)(& Fdrop),        (transition_t */* const  */)(& Dfalse), 
            (transition_t */* const  */)(& Dfalse),        (transition_t */* const  */)(& Dfalse),        (transition_t */* const  */)(& Delse),        (transition_t */* const  */)(& Dendif), 
            (transition_t */* const  */)(& drop),        (transition_t */* const  */)(& early_eof)}};
#line 350 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
static if_control_state_t if_control_state  ;
#line 350 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
if_control_state_t *if_control_h  =    & if_control_state;
#line 350 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
if_control_public_state_t *if_control_public_h  =    & if_control_state;
#line 350 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
static if_control_state_t const   * const  if_control_static_initialiser_h  ;
#line 350 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
void (*if_control_init_h)(if_control_state_t * )  ;
#line 350 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
void (*if_control_finis_h)(if_control_state_t * )  ;
#line 350 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
void if_control_initor(void) 
{ 


  {
  {
  {
#line 350
  component_initor((_Bool)1, (_Bool)1, (void **)((char *)(& if_control_h)), (void **)((char *)(& if_control_public_h)),
                   (void const   *)if_control_static_initialiser_h, sizeof(if_control_state_t ),
                   (void (*)())if_control_init_h);
  }
  }
#line 350
  return;
}
}
#line 350 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
void if_control_finitor(void) 
{ 


  {
  {
  {
#line 350
  component_finitor((_Bool)1, (void **)((char *)(& if_control_h)), (void **)((char *)(& if_control_public_h)),
                    (void (*)())if_control_init_h);
  }
  }
#line 350
  return;
}
}
#line 354 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
static void done_file(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;

  {
#line 357
  if ((unsigned int )chew_public_h->comment_state != 0U) {
    {
    {
#line 358
    parse_error(16592, "EOF in comment, #error ... or #define ... commencing line %d",
                chew_public_h->last_comment_start_line);
    }
    }
  }
#line 362
  if (chew_public_h->in_double_quote) {
    {
    {
#line 363
    parse_error(16608, "EOF in quotation commencing line %d", chew_public_h->last_quote_start_line);
    }
    }
  }
#line 367
  return;
}
}
#line 369 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
static void nest(void) 
{ 
  size_t deep ;
  char *__cil_tmp2 ;

  {
#line 372
  (if_control_state.depth) ++;
#line 372
  deep = if_control_state.depth;
#line 373
  if (deep >= 64UL) {
    {
    {
#line 374
    bail(16720, "Too many levels of nesting");
    }
    }
  }
#line 376
  if_control_state.if_start_lines[deep] = (size_t )io_public_h->line_num;
#line 377
  return;
}
}
#line 379 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
static void set_state(if_state_t is ) 
{ 
  size_t deep ;
  size_t tmp ;

  {
  {
  {
#line 382
  tmp = if_depth();
  }
#line 382
  deep = tmp;
#line 383
  if_control_state.ifstate[deep] = is;
  }
#line 384
  return;
}
}
#line 386 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
static void Pendif(void) 
{ 


  {
  {
  {
#line 388
  print();
  }
#line 389
  (if_control_state.depth) --;
  }
#line 390
  return;
}
}
#line 392 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
static void Dendif(void) 
{ 


  {
  {
  {
#line 394
  drop();
  }
#line 395
  (if_control_state.depth) --;
  }
#line 396
  return;
}
}
#line 400 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
void transition(line_type_t linetype ) 
{ 
  if_state_t state ;
  size_t tmp ;

  {
  {
  {
#line 403
  tmp = if_depth();
  }
#line 403
  state = if_control_state.ifstate[tmp];
  {
#line 404
  (*(transition_table[state][linetype]))();
  }
  }
#line 405
  return;
}
}
#line 407 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
_Bool dead_line(void) 
{ 
  if_state_t state ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
  {
#line 410
  tmp = if_depth();
  }
#line 410
  state = if_control_state.ifstate[tmp];
  }
#line 412
  if ((unsigned int )state == 1U) {
#line 412
    tmp___0 = 1;
  } else
#line 412
  if ((unsigned int )state == 4U) {
#line 412
    tmp___0 = 1;
  } else
#line 412
  if ((unsigned int )state == 7U) {
#line 412
    tmp___0 = 1;
  } else
#line 412
  if ((unsigned int )state == 9U) {
#line 412
    tmp___0 = 1;
  } else {
#line 412
    tmp___0 = 0;
  }
#line 412
  return ((_Bool )tmp___0);
}
}
#line 418 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
_Bool was_unconditional_line(void) 
{ 
  size_t tmp ;

  {
  {
  {
#line 421
  tmp = if_depth();
  }
  }
#line 421
  return ((_Bool )((unsigned int )if_control_state.ifstate[tmp] == 0U));
}
}
#line 426 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
_Bool is_unconditional_line(void) 
{ 
  if_state_t state ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
  {
#line 429
  tmp = if_depth();
  }
#line 429
  state = if_control_state.ifstate[tmp];
  }
#line 431
  if ((unsigned int )state == 0U) {
#line 431
    tmp___0 = 1;
  } else
#line 431
  if ((unsigned int )state == 2U) {
#line 431
    tmp___0 = 1;
  } else
#line 431
  if ((unsigned int )state == 5U) {
#line 431
    tmp___0 = 1;
  } else
#line 431
  if ((unsigned int )state == 8U) {
#line 431
    tmp___0 = 1;
  } else {
#line 431
    tmp___0 = 0;
  }
#line 431
  return ((_Bool )tmp___0);
}
}
#line 437 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
if_state_t if_state(void) 
{ 
  size_t tmp ;

  {
  {
  {
#line 440
  tmp = if_depth();
  }
  }
#line 440
  return (if_control_state.ifstate[tmp]);
}
}
#line 443 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
size_t if_depth(void) 
{ 


  {
#line 446
  return (if_control_state.depth);
}
}
#line 449 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
size_t if_start_line(void) 
{ 
  size_t tmp ;

  {
  {
  {
#line 452
  tmp = if_depth();
  }
  }
#line 452
  return (if_control_state.if_start_lines[tmp]);
}
}
#line 455 "/home/wslee/tests/SOURCES/coan-4.2.2/src/if_control.c"
void if_control_toplevel(void) 
{ 


  {
#line 458
  if_control_state.depth = (size_t )0;
#line 459
  return;
}
}
#line 109 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__)) ;
#line 113
extern  __attribute__((__nothrow__)) int strncasecmp(char const   *__s1 , char const   *__s2 ,
                                                     size_t __n )  __attribute__((__pure__)) ;
#line 108 "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.h"
void canonical_string_assign(canonical_string_h dest , canonical_string_const_h src ) ;
#line 46 "/home/wslee/tests/SOURCES/coan-4.2.2/src/hash_include.c"
hash_include_h hash_include_new(char const   *arg , size_t arglen ) 
{ 
  hash_include_h inc_arg ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 50
  if (! arg) {
    {
    {
#line 50
    __assert_fail("arg", "/home/wslee/tests/SOURCES/coan-4.2.2/src/hash_include.c",
                  50U, "hash_include_new");
    }
    }
  }
#line 51
  if (! arglen) {
    {
    {
#line 51
    __assert_fail("arglen", "/home/wslee/tests/SOURCES/coan-4.2.2/src/hash_include.c",
                  51U, "hash_include_new");
    }
    }
  }
  {
  {
#line 52
  inc_arg = symbol_new(arg, arglen);
  }
  }
#line 53
  return (inc_arg);
}
}
#line 56 "/home/wslee/tests/SOURCES/coan-4.2.2/src/hash_include.c"
int hash_include_compare(hash_include_const_h lhs , void const   *rhs , size_t arglen ) 
{ 
  int cmp ;
  hash_include_const_h rarg ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 60
  if (! lhs) {
    {
    {
#line 60
    __assert_fail("lhs", "/home/wslee/tests/SOURCES/coan-4.2.2/src/hash_include.c",
                  60U, "hash_include_compare");
    }
    }
  }
#line 61
  if (! rhs) {
    {
    {
#line 61
    __assert_fail("rhs", "/home/wslee/tests/SOURCES/coan-4.2.2/src/hash_include.c",
                  61U, "hash_include_compare");
    }
    }
  }
#line 62
  if (arglen) {
    {
    {
#line 63
    cmp = strncasecmp((char const   *)lhs->sym_name, (char const   *)rhs, arglen);
    }
    }
#line 64
    if (! cmp) {
#line 64
      if (*(lhs->sym_name + arglen)) {
#line 65
        cmp = 1;
      }
    }
  } else {
    {
#line 68
    rarg = (hash_include_const_h )rhs;
    {
#line 69
    cmp = strcasecmp((char const   *)lhs->sym_name, (char const   *)rarg->sym_name);
    }
    }
  }
#line 71
  return (cmp);
}
}
#line 75 "/home/wslee/tests/SOURCES/coan-4.2.2/src/hash_include.c"
void hash_include_define(hash_include_h hi , canonical_string_const_h def ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 78
  if (! hi) {
    {
    {
#line 78
    __assert_fail("hi", "/home/wslee/tests/SOURCES/coan-4.2.2/src/hash_include.c",
                  78U, "hash_include_define");
    }
    }
  }
#line 79
  if (hi->sym_def) {
    {
    {
#line 80
    canonical_string_assign(hi->sym_def, def);
    }
    }
  } else {
    {
    {
#line 82
    hi->sym_def = canonical_string_copy(def);
    }
    }
  }
#line 84
  return;
}
}
#line 51 "/home/wslee/tests/SOURCES/coan-4.2.2/src/get_options.h"
extern int optind ;
#line 53
extern int optopt ;
#line 55
extern char *optarg ;
#line 116
cmd_option_t const   *get_command_option(int argc , char **argv , cmd_option_t const   *commands___0 ) ;
#line 136
_Bool opts_are_compatible(int opt_excluder , int opt_excluded , struct exclusion_list  const  *exclusions ,
                          _Bool indexed ) ;
#line 148
int getopt_long(int argc , char **argv , char const   *optstr , struct option  const  *longopts ,
                int *longind ) ;
#line 160
char const   *get_long_opt_name(struct option  const  *longopts , int opt ) ;
#line 50 "/home/wslee/tests/SOURCES/coan-4.2.2/src/get_options.c"
cmd_option_t const   *get_command_option(int argc , char **argv , cmd_option_t const   *commands___0 ) 
{ 
  cmd_option_t const   *command ;
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 53
  if (argc > 1) {
#line 54
    command = commands___0;
#line 55
    if (! commands___0) {
      {
      {
#line 55
      __assert_fail("commands", "/home/wslee/tests/SOURCES/coan-4.2.2/src/get_options.c",
                    55U, "get_command_option");
      }
      }
    }
    {
    {
#line 56
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 56
      if (! command->name) {
#line 56
        goto while_break;
      }
      {
      {
#line 57
      tmp = strcmp((char const   *)*(argv + 1), (char const   *)command->name);
      }
      }
#line 57
      if (! tmp) {
#line 58
        return (command);
      }
#line 56
      command ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 62
  return ((cmd_option_t const   *)((void *)0));
}
}
#line 65 "/home/wslee/tests/SOURCES/coan-4.2.2/src/get_options.c"
_Bool opts_are_compatible(int opt_excluder , int opt_excluded , struct exclusion_list  const  *exclusions ,
                          _Bool indexed ) 
{ 
  struct exclusion_list  const  *which ;
  _Bool verdict ;
  int const   *excluded ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 70
  verdict = (_Bool)1;
#line 71
  if (! exclusions) {
    {
    {
#line 71
    __assert_fail("exclusions", "/home/wslee/tests/SOURCES/coan-4.2.2/src/get_options.c",
                  71U, "opts_are_compatible");
    }
    }
  }
#line 72
  if (indexed) {
#line 73
    which = exclusions + opt_excluder;
  } else {
#line 75
    which = exclusions;
    {
    {
#line 76
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 76
      if (! which->excluder) {
#line 76
        goto while_break;
      }
#line 77
      if (which->excluder == (int const   )opt_excluder) {
#line 78
        goto while_break;
      }
#line 76
      which ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 82
  if (which->excluder) {
#line 83
    excluded = (int const   *)which->excluded;
#line 84
    if (excluded) {
      {
      {
#line 85
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 85
        if (! *excluded) {
#line 85
          goto while_break___0;
        }
#line 86
        if (opt_excluded == (int )*excluded) {
#line 87
          verdict = (_Bool)0;
        }
#line 85
        excluded ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 92
  return (verdict);
}
}
#line 95 "/home/wslee/tests/SOURCES/coan-4.2.2/src/get_options.c"
int getopt_long(int argc , char **argv , char const   *optstr , struct option  const  *longopts ,
                int *longind ) 
{ 
  char *opt ;
  char *where ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int i ;
  int match ;
  size_t optlen ;
  char *eq___0 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  _Bool done ;
  int i___0 ;
  char *temp ;
  int tmp___6 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 100
  optarg = (char *)((void *)0);
#line 101
  if (longind) {
#line 102
    *longind = -1;
  }
#line 104
  if (optind < 0) {
#line 105
    return (-1);
  }
#line 107
  if (optind == 0) {
#line 108
    optind ++;
  }
#line 110
  if (optind >= argc) {
#line 111
    return (-1);
  }
#line 113
  opt = *(argv + optind);
#line 114
  if ((int )*opt == 45) {
#line 115
    optind ++;
#line 116
    opt ++;
#line 116
    if ((int )*opt == 58) {
#line 117
      optopt = ':';
#line 118
      return ('?');
    }
#line 120
    if ((int )*opt != 45) {
      {
      {
#line 121
      tmp = strchr(optstr, (int )*opt);
      }
#line 121
      where = tmp;
      }
#line 122
      if (! where) {
#line 123
        optopt = (int )*opt;
#line 124
        return ('?');
      }
#line 126
      if ((int )*(where + 1) != 58) {
#line 127
        if (*(opt + 1)) {
#line 128
          optopt = (int )*opt;
#line 129
          return ('?');
        }
#line 131
        optarg = (char *)((void *)0);
#line 132
        return ((int )*opt);
      } else
#line 133
      if ((int )*(where + 2) != 58) {
#line 134
        if ((int )*(opt + 1) != 0) {
#line 135
          optarg = opt + 1;
#line 136
          return ((int )*opt);
        } else
#line 137
        if (optind >= argc) {
#line 139
          optarg = (char *)((void *)0);
#line 140
          return ((int )*opt);
        } else
#line 137
        if ((int )*(*(argv + optind)) == 45) {
#line 139
          optarg = (char *)((void *)0);
#line 140
          return ((int )*opt);
        } else {
#line 142
          tmp___0 = optind;
#line 142
          optind ++;
#line 142
          optarg = *(argv + tmp___0);
#line 143
          return ((int )*opt);
        }
      } else
#line 146
      if ((int )*(opt + 1) != 0) {
#line 147
        optarg = opt + 1;
#line 148
        return ((int )*opt);
      } else
#line 149
      if (optind >= argc) {
#line 151
        optopt = (int )*opt;
#line 152
        return ('?');
      } else
#line 149
      if ((int )*(*(argv + optind)) == 45) {
#line 151
        optopt = (int )*opt;
#line 152
        return ('?');
      } else {
#line 154
        tmp___1 = optind;
#line 154
        optind ++;
#line 154
        optarg = *(argv + tmp___1);
#line 155
        return ((int )*opt);
      }
    } else {
      {
#line 159
      match = -1;
#line 162
      opt ++;
      {
#line 162
      tmp___2 = strchr((char const   *)opt, '=');
      }
#line 162
      eq___0 = tmp___2;
      }
#line 163
      if (eq___0) {
#line 164
        optarg = eq___0 + 1;
#line 165
        optlen = (size_t )(eq___0 - opt);
      } else {
        {
        {
#line 167
        optlen = strlen((char const   *)opt);
        }
        }
      }
#line 170
      i = 0;
      {
      {
#line 170
      while (1) {
        while_continue___1: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 170
        if (! ((unsigned long )(longopts + i)->name != (unsigned long )((void *)0))) {
#line 170
          goto while_break;
        }
        {
        {
#line 171
        tmp___3 = strncmp((char const   *)opt, (char const   *)(longopts + i)->name,
                          optlen);
        }
        }
#line 171
        if (! tmp___3) {
#line 172
          if (match != -1) {
#line 173
            match = -1;
#line 174
            goto while_break;
          }
#line 176
          match = i;
        }
#line 170
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
#line 179
      if ((unsigned long )longind != (unsigned long )((void *)0)) {
#line 180
        *longind = match;
      }
#line 182
      if (match == -1) {
#line 183
        return ('?');
      }
      {
#line 186
      if ((longopts + match)->has_arg == 0) {
#line 186
        goto case_0;
      }
#line 191
      if ((longopts + match)->has_arg == 1) {
#line 191
        goto case_1;
      }
#line 202
      if ((longopts + match)->has_arg == 2) {
#line 202
        goto case_2;
      }
#line 212
      goto switch_default;
      case_0: /* CIL Label */ 
#line 187
      if (optarg) {
#line 188
        return ('?');
      }
#line 190
      goto switch_break;
      case_1: /* CIL Label */ 
#line 192
      if (optarg) {
#line 193
        goto switch_break;
      }
#line 195
      if (optind >= argc) {
#line 197
        return ('?');
      } else
#line 195
      if ((int )*(*(argv + optind)) == 45) {
#line 197
        return ('?');
      }
#line 200
      tmp___4 = optind;
#line 200
      optind ++;
#line 200
      optarg = *(argv + tmp___4);
#line 201
      goto switch_break;
      case_2: /* CIL Label */ 
#line 203
      if (optarg) {
#line 204
        goto switch_break;
      }
#line 206
      if (optarg) {
#line 208
        goto switch_break;
      } else
#line 206
      if (optind >= argc) {
#line 208
        goto switch_break;
      } else
#line 206
      if ((int )*(*(argv + optind)) == 45) {
#line 208
        goto switch_break;
      }
#line 210
      tmp___5 = optind;
#line 210
      optind ++;
#line 210
      optarg = *(argv + tmp___5);
#line 211
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
      {
#line 213
      __assert_fail("0", "/home/wslee/tests/SOURCES/coan-4.2.2/src/get_options.c",
                    213U, "getopt_long");
      }
      }
      switch_break: /* CIL Label */ ;
      }
#line 216
      if ((unsigned long )(longopts + match)->flag != (unsigned long )((void *)0)) {
#line 217
        *((longopts + match)->flag) = (int )(longopts + i)->val;
#line 218
        return (0);
      } else {
#line 220
        return ((int )(longopts + match)->val);
      }
    }
  } else {
#line 226
    done = (_Bool)1;
#line 228
    i___0 = optind;
    {
    {
#line 228
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 228
      if (done) {
#line 228
        if (! (i___0 < argc)) {
#line 228
          goto while_break___0;
        }
      } else {
#line 228
        goto while_break___0;
      }
#line 230
      done = (_Bool )((int )*(*(argv + i___0)) != 45);
#line 228
      i___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 232
    if (done) {
#line 233
      optarg = *(argv + optind);
#line 234
      return (-1);
    } else {
      {
#line 237
      temp = *(argv + optind);
      {
#line 238
      memmove((void *)(argv + optind), (void const   *)((argv + optind) + 1), (unsigned long )((argc - optind) - 1) * sizeof(char *));
      }
#line 240
      *(argv + (argc - 1)) = temp;
      {
#line 242
      tmp___6 = getopt_long(argc, argv, optstr, longopts, longind);
      }
      }
#line 242
      return (tmp___6);
    }
  }
}
}
#line 247 "/home/wslee/tests/SOURCES/coan-4.2.2/src/get_options.c"
char const   *get_long_opt_name(struct option  const  *longopts , int opt ) 
{ 
  struct option  const  *longopt ;

  {
#line 250
  longopt = longopts;
  {
  {
#line 251
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 251
    if (! longopt->name) {
#line 251
      goto while_break;
    }
#line 252
    if (longopt->val == (int const   )opt) {
#line 253
      return ((char const   *)longopt->name);
    }
#line 251
    longopt ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 256
  return ((char const   *)((void *)0));
}
}
#line 209 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __file ,
                                                                                   struct stat * __restrict  __buf ) ;
#line 263
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) lstat)(char const   * __restrict  __file ,
                                                                                    struct stat * __restrict  __buf ) ;
#line 135 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 150
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 184
extern int ( __attribute__((__nonnull__(1,2,3))) readdir_r)(DIR * __restrict  __dirp ,
                                                            struct dirent * __restrict  __entry ,
                                                            struct dirent ** __restrict  __result ) ;
#line 729 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *realpath(char const   * __restrict  __name ,
                                                    char * __restrict  __resolved ) ;
#line 126 "/home/wslee/tests/SOURCES/coan-4.2.2/src/filesys.h"
fs_obj_type_t fs_obj_type(char const   *name ) ;
#line 150
fs_dir_t fs_open_dir(char const   *dirname , fs_dir_t const   parent ) ;
#line 156
void fs_close_dir(fs_dir_t dir ) ;
#line 176
char const   *fs_read_dir(fs_dir_t dir , char const   **fullname ) ;
#line 183
fs_dir_t fs_get_parent(fs_dir_t dir ) ;
#line 233
heap_str fs_real_path(char const   *relname , size_t *namelen ) ;
#line 259
char const   *fs_cur_dir_entry(fs_dir_t dir , char const   **entry ) ;
#line 73 "/home/wslee/tests/SOURCES/coan-4.2.2/src/fs_nix.c"
heap_str fs_real_path(char const   *relname , size_t *namelen ) 
{ 
  char buf[4096] ;
  char *full_path ;
  size_t len ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  void *__cil_tmp9 ;

  {
  {
  {
#line 77
  tmp___1 = realpath((char const   */* __restrict  */)relname, (char */* __restrict  */)(buf));
  }
  }
#line 77
  if (tmp___1) {
    {
    {
#line 79
    tmp = strlen((char const   *)(buf));
    }
#line 79
    len = tmp;
    }
#line 80
    if (namelen) {
#line 81
      *namelen = len;
    }
    {
    {
#line 83
    tmp___0 = zallocate(len + 1UL);
    }
#line 83
    full_path = (char *)tmp___0;
    {
#line 84
    strcpy((char */* __restrict  */)full_path, (char const   */* __restrict  */)(buf));
    }
    }
#line 85
    return (full_path);
  }
#line 87
  return ((heap_str )((void *)0));
}
}
#line 90 "/home/wslee/tests/SOURCES/coan-4.2.2/src/fs_nix.c"
fs_obj_type_t fs_obj_type(char const   *name ) 
{ 
  fs_obj_type_t type ;
  struct stat obj_info ;
  int res ;
  int tmp ;

  {
  {
#line 93
  type = (fs_obj_type_t )0;
  {
#line 95
  tmp = lstat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& obj_info));
  }
#line 95
  res = tmp;
  }
#line 96
  if (! res) {
#line 97
    if ((obj_info.st_mode & 61440U) == 40960U) {
#line 98
      type = (fs_obj_type_t )((unsigned int )type | 1U);
    }
    {
    {
#line 100
    res = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& obj_info));
    }
    }
#line 101
    if (! res) {
#line 102
      if ((obj_info.st_mode & 61440U) == 32768U) {
#line 103
        type = (fs_obj_type_t )((unsigned int )type | 2U);
      } else
#line 104
      if ((obj_info.st_mode & 61440U) == 16384U) {
#line 105
        type = (fs_obj_type_t )((unsigned int )type | 4U);
      }
    }
  }
#line 109
  return (type);
}
}
#line 112 "/home/wslee/tests/SOURCES/coan-4.2.2/src/fs_nix.c"
fs_dir_t fs_open_dir(char const   *dirname , fs_dir_t const   parent ) 
{ 
  fs_dir_nix_t *dir ;
  DIR *dir_handle ;
  DIR *tmp ;
  size_t namelen ;
  heap_str fullname ;
  heap_str tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 115
  dir = (fs_dir_nix_t *)((void *)0);
  {
#line 116
  tmp = opendir(dirname);
  }
#line 116
  dir_handle = tmp;
  }
#line 117
  if (dir_handle) {
    {
    {
#line 119
    tmp___0 = fs_real_path(dirname, & namelen);
    }
#line 119
    fullname = tmp___0;
    }
#line 120
    if (fullname) {
      {
      {
#line 121
      tmp___1 = zallocate(sizeof(fs_dir_nix_t ));
      }
#line 121
      dir = (fs_dir_nix_t *)tmp___1;
#line 122
      dir->parent = (fs_dir_nix_t *)parent;
#line 123
      dir->dir = dir_handle;
#line 124
      dir->dirname = fullname;
#line 125
      dir->dirname_end = dir->dirname + namelen;
      }
    }
  }
#line 128
  return ((fs_dir_t )dir);
}
}
#line 132 "/home/wslee/tests/SOURCES/coan-4.2.2/src/fs_nix.c"
void fs_close_dir(fs_dir_t dir ) 
{ 
  fs_dir_nix_t *nix_dir ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 135
  nix_dir = (fs_dir_nix_t *)dir;
#line 136
  if (! dir) {
    {
    {
#line 136
    __assert_fail("dir", "/home/wslee/tests/SOURCES/coan-4.2.2/src/fs_nix.c", 136U,
                  "fs_close_dir");
    }
    }
  }
#line 137
  if (nix_dir->dir) {
    {
    {
#line 138
    closedir(nix_dir->dir);
    }
    {
#line 139
    free((void *)nix_dir->dirname);
    }
    {
#line 140
    free((void *)nix_dir);
    }
    }
  }
#line 142
  return;
}
}
#line 144 "/home/wslee/tests/SOURCES/coan-4.2.2/src/fs_nix.c"
char const   *fs_read_dir(fs_dir_t dir , char const   **fullname ) 
{ 
  char *filename ;
  fs_dir_nix_t *nix_dir ;
  struct dirent *entry ;
  int res ;
  int tmp ;
  char const   *tmp___0 ;
  size_t len ;
  size_t available ;
  size_t tmp___1 ;
  size_t needed ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char *__cil_tmp15 ;

  {
  {
#line 147
  filename = (char *)((void *)0);
#line 148
  nix_dir = (fs_dir_nix_t *)dir;
  {
#line 150
  tmp = readdir_r((DIR */* __restrict  */)nix_dir->dir, (struct dirent */* __restrict  */)(& nix_dir->entry),
                  (struct dirent **/* __restrict  */)(& entry));
  }
#line 150
  res = tmp;
  }
#line 151
  if (res) {
    {
    {
#line 152
    bail(33456, "Read error on directory \"%s\"", nix_dir->dirname);
    }
    }
  }
#line 155
  if (entry) {
#line 156
    filename = nix_dir->entry.d_name;
#line 157
    if ((int )*(filename + 0) == 46) {
#line 157
      if ((int )*(filename + 1) == 46) {
#line 157
        if ((int )*(filename + 2) == 0) {
          {
          {
#line 159
          tmp___0 = fs_read_dir(dir, fullname);
          }
          }
#line 159
          return (tmp___0);
        } else {
#line 157
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 157
      if ((int )*(filename + 1) == 0) {
        {
        {
#line 159
        tmp___0 = fs_read_dir(dir, fullname);
        }
        }
#line 159
        return (tmp___0);
      }
    }
#line 161
    if (fullname) {
      {
#line 162
      len = (size_t )(nix_dir->dirname_end - nix_dir->dirname);
      {
#line 163
      tmp___1 = strlen((char const   *)nix_dir->dirname_end);
      }
#line 163
      available = tmp___1;
      {
#line 164
      tmp___2 = strlen((char const   *)filename);
      }
#line 164
      needed = tmp___2 + 1UL;
      }
#line 165
      if (available < needed) {
        {
        {
#line 166
        tmp___3 = reallocate((void *)nix_dir->dirname, (len + needed) + 1UL);
        }
#line 166
        nix_dir->dirname = (heap_str )tmp___3;
#line 167
        nix_dir->dirname_end = nix_dir->dirname + len;
        }
      }
      {
#line 169
      *(nix_dir->dirname_end) = (char )'/';
      {
#line 170
      strcpy((char */* __restrict  */)(nix_dir->dirname_end + 1), (char const   */* __restrict  */)filename);
      }
#line 171
      filename = nix_dir->dirname_end + 1;
#line 172
      *fullname = (char const   *)nix_dir->dirname;
      }
    }
  } else {
#line 175
    *(nix_dir->dirname_end) = (char )'\000';
  }
#line 177
  return ((char const   *)filename);
}
}
#line 180 "/home/wslee/tests/SOURCES/coan-4.2.2/src/fs_nix.c"
char const   *fs_cur_dir_entry(fs_dir_t dir , char const   **entry ) 
{ 
  fs_dir_nix_t *nix_dir ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 183
  nix_dir = (fs_dir_nix_t *)dir;
#line 184
  if (! dir) {
    {
    {
#line 184
    __assert_fail("dir", "/home/wslee/tests/SOURCES/coan-4.2.2/src/fs_nix.c", 184U,
                  "fs_cur_dir_entry");
    }
    }
  }
#line 185
  if (entry) {
#line 186
    *entry = (char const   *)nix_dir->dirname_end;
  }
#line 188
  return ((char const   *)nix_dir->dirname);
}
}
#line 191 "/home/wslee/tests/SOURCES/coan-4.2.2/src/fs_nix.c"
fs_dir_t fs_get_parent(fs_dir_t dir ) 
{ 
  fs_dir_nix_t *nix_dir ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 195
  if (! dir) {
    {
    {
#line 195
    __assert_fail("dir", "/home/wslee/tests/SOURCES/coan-4.2.2/src/fs_nix.c", 195U,
                  "fs_get_parent");
    }
    }
  }
#line 196
  nix_dir = (fs_dir_nix_t *)dir;
#line 197
  return ((fs_dir_t )nix_dir->parent);
}
}
#line 133 "/home/wslee/tests/SOURCES/coan-4.2.2/src/filesys.h"
fs_obj_type_t fs_file_or_dir(char const   *name ) ;
#line 195
heap_str fs_compose_filename(char const   *path , char const   *leafname ) ;
#line 215
heap_str fs_split_filename(char const   *path , char **leafname ) ;
#line 264
fs_path_type_t fs_path_type(char const   *filename ) ;
#line 312
char const   *fs_path_comp(char const   *first , char const   *second , size_t *sharedlen ) ;
#line 340 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
#line 49 "/home/wslee/tests/SOURCES/coan-4.2.2/src/filesys.c"
heap_str fs_compose_filename(char const   *path , char const   *leafname ) 
{ 
  size_t path_len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t leafname_len ;
  size_t tmp___1 ;
  heap_str filename ;
  void *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;

  {
#line 52
  if (path) {
    {
    {
#line 52
    tmp = strlen(path);
    }
#line 52
    tmp___0 = tmp;
    }
  } else {
#line 52
    tmp___0 = (size_t )0;
  }
  {
#line 52
  path_len = tmp___0;
  {
#line 53
  tmp___1 = strlen(leafname);
  }
#line 53
  leafname_len = tmp___1;
  {
#line 54
  tmp___2 = zallocate(((path_len + sizeof('/')) + leafname_len) + 1UL);
  }
#line 54
  filename = (heap_str )tmp___2;
  }
#line 56
  if (path) {
    {
    {
#line 57
    tmp___3 = strcpy((char */* __restrict  */)filename, (char const   */* __restrict  */)path);
    }
#line 57
    tmp___4 = path_len;
#line 57
    path_len ++;
#line 57
    *(tmp___3 + tmp___4) = (char )'/';
    }
  }
  {
  {
#line 59
  strcpy((char */* __restrict  */)(filename + path_len), (char const   */* __restrict  */)leafname);
  }
  }
#line 60
  return (filename);
}
}
#line 63 "/home/wslee/tests/SOURCES/coan-4.2.2/src/filesys.c"
fs_obj_type_t fs_file_or_dir(char const   *name ) 
{ 
  fs_obj_type_t obj_type ;
  fs_obj_type_t tmp ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 66
  tmp = fs_obj_type(name);
  }
#line 66
  obj_type = tmp;
  }
#line 67
  if ((unsigned int )obj_type == 0U) {
    {
    {
#line 68
    bail(33408, "No such file or directory as \"%s\"", name);
    }
    }
  }
#line 70
  return (obj_type);
}
}
#line 73 "/home/wslee/tests/SOURCES/coan-4.2.2/src/filesys.c"
char *fs_tempname(char *template ) 
{ 
  char *tempname ;
  char *suffix ;
  char *tmp ;
  unsigned int lim ;
  unsigned int i ;
  fs_obj_type_t tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 76
  tempname = (char *)((void *)0);
  {
#line 77
  tmp = strstr((char const   *)template, "XXXXXX");
  }
#line 77
  suffix = tmp;
  }
#line 78
  if (suffix) {
#line 79
    if (! *(suffix + 6)) {
#line 80
      lim = 16777216U;
#line 81
      i = 0U;
      {
      {
#line 82
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 82
        if (! (i < lim)) {
#line 82
          goto while_break;
        }
        {
        {
#line 83
        sprintf((char */* __restrict  */)suffix, (char const   */* __restrict  */)"%06x",
                i);
        }
        {
#line 84
        tmp___0 = fs_obj_type((char const   *)template);
        }
        }
#line 84
        if ((unsigned int )tmp___0 == 0U) {
#line 85
          tempname = template;
#line 86
          goto while_break;
        }
#line 82
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 91
  return (tempname);
}
}
#line 94 "/home/wslee/tests/SOURCES/coan-4.2.2/src/filesys.c"
fs_path_type_t fs_path_type(char const   *filename ) 
{ 
  fs_path_type_t pathtype ;
  char lastch ;
  char *tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  size_t tmp___2 ;

  {
#line 102
  pathtype = (fs_path_type_t )0;
#line 104
  if ((int const   )*(filename + 0) == 47) {
#line 105
    pathtype = (fs_path_type_t )((unsigned int )pathtype | 3U);
#line 106
    if (! *(filename + 1)) {
#line 107
      pathtype = (fs_path_type_t )((unsigned int )pathtype | 24U);
#line 107
      return (pathtype);
    }
  } else {
    {
    {
#line 109
    tmp___1 = __ctype_b_loc();
    }
    }
#line 109
    if ((int const   )*(*tmp___1 + (int )*(filename + 0)) & 1024) {
#line 109
      if ((int const   )*(filename + 1) == 58) {
#line 110
        pathtype = (fs_path_type_t )((unsigned int )pathtype | 7U);
#line 111
        if (! *(filename + 2)) {
#line 112
          pathtype = (fs_path_type_t )((unsigned int )pathtype | 16U);
#line 112
          return (pathtype);
        } else
#line 113
        if ((int const   )*(filename + 2) == 92) {
#line 113
          if (! *(filename + 3)) {
#line 114
            pathtype = (fs_path_type_t )((unsigned int )pathtype | 24U);
#line 114
            return (pathtype);
          }
        }
      } else {
#line 109
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
      {
#line 116
      tmp___0 = strchr(filename, '/');
      }
      }
#line 116
      if (tmp___0) {
#line 117
        pathtype = (fs_path_type_t )((unsigned int )pathtype | 2U);
      } else {
        {
        {
#line 118
        tmp = strchr(filename, '\\');
        }
        }
#line 118
        if (tmp) {
#line 119
          pathtype = (fs_path_type_t )((unsigned int )pathtype | 6U);
        }
      }
    }
  }
  {
  {
#line 121
  tmp___2 = strlen(filename);
  }
#line 121
  lastch = (char )*(filename + (tmp___2 - 1UL));
  }
#line 122
  if ((int )lastch == 47) {
#line 123
    pathtype = (fs_path_type_t )((unsigned int )pathtype | 8U);
  } else
#line 122
  if ((int )lastch == 92) {
#line 123
    pathtype = (fs_path_type_t )((unsigned int )pathtype | 8U);
  }
#line 125
  return (pathtype);
}
}
#line 128 "/home/wslee/tests/SOURCES/coan-4.2.2/src/filesys.c"
char const   *fs_path_comp(char const   *first , char const   *second , size_t *sharedlen ) 
{ 
  char const   *delim ;
  char const   *lhs ;
  char const   *rhs ;

  {
#line 131
  delim = (char const   *)((void *)0);
#line 132
  lhs = first;
#line 133
  rhs = second;
  {
  {
#line 134
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 134
    if (*lhs) {
#line 134
      if (! ((int const   )*lhs == (int const   )*rhs)) {
#line 134
        goto while_break;
      }
    } else {
#line 134
      goto while_break;
    }
#line 135
    if ((int const   )*lhs == 47) {
#line 136
      delim = lhs;
    }
#line 134
    lhs ++;
#line 134
    rhs ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  if ((int const   )*lhs != (int const   )*rhs) {
#line 140
    if (! *lhs) {
      {
      {
#line 141
      *sharedlen = strlen(first);
      }
      }
#line 142
      return (first);
    }
#line 144
    if (! *rhs) {
      {
      {
#line 145
      *sharedlen = strlen(second);
      }
      }
#line 146
      return (second);
    }
#line 148
    if (delim) {
#line 149
      *sharedlen = (size_t )(lhs - first);
#line 150
      return (first);
    }
#line 152
    *sharedlen = (size_t )0;
#line 153
    return ((char const   *)((void *)0));
  }
#line 155
  *sharedlen = (size_t )0;
#line 156
  return (first);
}
}
#line 159 "/home/wslee/tests/SOURCES/coan-4.2.2/src/filesys.c"
heap_str fs_split_filename(char const   *path , char **leafname ) 
{ 
  heap_str parent ;
  char const   *child ;
  char *delim ;
  char *tmp ;
  fs_obj_type_t obj_type ;
  fs_obj_type_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t len ;
  void *tmp___3 ;

  {
  {
#line 162
  parent = (heap_str )((void *)0);
#line 163
  child = (char const   *)((void *)0);
  {
#line 164
  tmp = strrchr(path, '/');
  }
#line 164
  delim = tmp;
  }
#line 165
  if (! delim) {
    {
    {
#line 166
    tmp___0 = fs_file_or_dir(path);
    }
#line 166
    obj_type = tmp___0;
    }
#line 167
    if (((unsigned int )obj_type & 2U) != 0U) {
#line 168
      child = path;
    } else {
      {
      {
#line 170
      tmp___1 = strlen(path);
      }
      {
#line 170
      tmp___2 = zallocate(tmp___1 + 1UL);
      }
#line 170
      parent = (heap_str )tmp___2;
      {
#line 171
      strcpy((char */* __restrict  */)parent, (char const   */* __restrict  */)path);
      }
      }
    }
  } else {
    {
#line 174
    len = (size_t )(delim - (char *)path);
    {
#line 175
    tmp___3 = zallocate(len + 1UL);
    }
#line 175
    parent = (heap_str )tmp___3;
    {
#line 176
    memcpy((void */* __restrict  */)parent, (void const   */* __restrict  */)path,
           len);
    }
#line 177
    child = (char const   *)(delim + 1);
    }
  }
#line 179
  if (leafname) {
#line 180
    *leafname = delim;
  }
#line 182
  return (parent);
}
}
#line 126 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.h"
heap_str file_tree_name(file_tree_const_h const   ft ) ;
#line 134
file_tree_h file_tree_new(void) ;
#line 138
file_tree_h file_tree_copy(file_tree_const_h src ) ;
#line 142
void file_tree_swap(file_tree_h lhs , file_tree_h rhs ) ;
#line 149
void file_tree_assign(file_tree_h dest , file_tree_const_h src ) ;
#line 156
_Bool file_tree_equal(file_tree_const_h lhs , file_tree_const_h rhs ) ;
#line 172
_Bool file_tree_set_filter(file_tree_h ft , _Bool (*filter)(char const   *leafname ) ) ;
#line 206
void file_tree_add(file_tree_h root , char const   *path , void (*callback)(file_tree_h ft ,
                                                                            char const   *name ,
                                                                            file_tree_traverse_state_t context ) ) ;
#line 216
void file_tree_dispose(file_tree_h ft ) ;
#line 264
file_tree_const_h file_tree_child(file_tree_const_h ft , size_t which ) ;
#line 131 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.c"
static _Bool null_filter(char const   *leafname ) 
{ 


  {
#line 134
  return ((_Bool)1);
}
}
#line 141 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.c"
static void null_callback(file_tree_h ft , char const   *name , file_tree_traverse_state_t context ) 
{ 


  {
#line 146
  return;
}
}
#line 157 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.c"
static file_tree_h new_node(char const   *leafname , size_t len ) 
{ 
  file_tree_h ft ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
  {
#line 160
  tmp = callocate((size_t )1, sizeof(struct file_tree ));
  }
#line 160
  ft = (file_tree_h )tmp;
  }
#line 161
  if (! len) {
    {
    {
#line 162
    len = strlen(leafname);
    }
    }
  }
  {
#line 164
  ft->parent = (struct file_tree *)((void *)-1);
  {
#line 165
  tmp___0 = zallocate(len + 1UL);
  }
#line 165
  ft->var.leafname = (heap_str )tmp___0;
  {
#line 166
  strncpy((char */* __restrict  */)ft->var.leafname, (char const   */* __restrict  */)leafname,
          len);
  }
  }
#line 167
  return (ft);
}
}
#line 181 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.c"
static file_tree_h new_file_node(char const   *leafname , _Bool (*filter)(char const   *leafname ) ) 
{ 
  file_tree_h ft ;
  _Bool tmp ;

  {
  {
#line 184
  ft = (file_tree_h )((void *)0);
  {
#line 185
  tmp = (*filter)(leafname);
  }
  }
#line 185
  if (tmp) {
    {
    {
#line 186
    ft = new_node(leafname, (size_t )0);
    }
#line 187
    ft->files = 1U;
    }
  }
#line 189
  return (ft);
}
}
#line 200 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.c"
static file_tree_h get_parent(file_tree_h child ) 
{ 
  struct file_tree *tmp ;

  {
#line 203
  if ((unsigned long )child->parent == (unsigned long )((void *)-1)) {
#line 203
    tmp = (struct file_tree *)((void *)0);
  } else
#line 203
  if ((unsigned long )child->parent == (unsigned long )((void *)0)) {
#line 203
    tmp = (struct file_tree *)((void *)0);
  } else {
#line 203
    tmp = child->parent;
  }
#line 203
  return (tmp);
}
}
#line 215 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.c"
static void link_in(file_tree_h parent , file_tree_h child ) 
{ 
  unsigned int new_files ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 219
  if (! (! ((unsigned long )child->parent == (unsigned long )((void *)0)))) {
    {
    {
#line 219
    __assert_fail("!((child)->parent == ((void *)0))", "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.c",
                  219U, "link_in");
    }
    }
  }
#line 220
  if (! parent->children) {
    {
    {
#line 221
    parent->children = ptr_vector_new((void (*)(void * ))(& file_tree_dispose), (void *(*)(void const   * ))((void *)0));
    }
    }
  }
  {
#line 223
  child->parent = parent;
  {
#line 224
  ptr_vector_append(parent->children, (void *)child);
  }
#line 225
  new_files = child->files;
  }
#line 226
  if (new_files) {
    {
    {
#line 227
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 227
      if (! parent) {
#line 227
        goto while_break;
      }
      {
#line 228
      parent->files += new_files;
#line 227
      child = parent;
      {
#line 227
      parent = get_parent(child);
      }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 231
  return;
}
}
#line 234
static void file_tree_add_symlink(file_tree_h root , fs_dir_t dir , char const   *symlink ,
                                  void (*callback)(file_tree_h ft , char const   *name ,
                                                   file_tree_traverse_state_t context ) ) ;
#line 262 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.c"
static file_tree_h new_dir_node(file_tree_h root , char const   *leafname , fs_dir_t dir ,
                                _Bool (*filter)(char const   *leafname ) , void (*callback)(file_tree_h ft ,
                                                                                            char const   *name ,
                                                                                            file_tree_traverse_state_t context ) ) 
{ 
  file_tree_h ft ;
  file_tree_h tmp ;
  char const   *cur_entry ;
  char const   *fullname ;
  char const   *tmp___0 ;
  fs_obj_type_t obj_type ;
  fs_obj_type_t tmp___1 ;
  file_tree_h child ;
  fs_dir_t subdir ;
  fs_dir_t tmp___2 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
  {
#line 269
  tmp = new_node(leafname, (size_t )0);
  }
#line 269
  ft = tmp;
  {
#line 271
  tmp___0 = fs_cur_dir_entry(dir, & cur_entry);
  }
#line 271
  fullname = tmp___0;
  }
#line 272
  if (! ((int const   )*(cur_entry + 0) == 0)) {
    {
    {
#line 272
    __assert_fail("cur_entry[0] == \'\\0\'", "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.c",
                  272U, "new_dir_node");
    }
    }
  }
  {
  {
#line 273
  (*callback)(ft, fullname, (file_tree_traverse_state_t )-1);
  }
  {
#line 274
  ft->children = ptr_vector_new((void (*)(void * ))(& file_tree_dispose), (void *(*)(void const   * ))((void *)0));
  }
  }
  {
  {
#line 275
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 275
    leafname = fs_read_dir(dir, & fullname);
    }
    }
#line 275
    if (! ((unsigned long )leafname != (unsigned long )((void *)0))) {
#line 275
      goto while_break;
    }
    {
    {
#line 276
    tmp___1 = fs_obj_type(fullname);
    }
#line 276
    obj_type = tmp___1;
    }
#line 277
    if (((unsigned int )obj_type & 1U) != 0U) {
      {
      {
#line 278
      file_tree_add_symlink(ft, dir, fullname, callback);
      }
      }
    } else {
      {
#line 280
      child = (file_tree_h )((void *)0);
      {
#line 281
      tmp___2 = fs_open_dir(fullname, (fs_dir_t const   )dir);
      }
#line 281
      subdir = tmp___2;
      }
#line 282
      if (subdir) {
        {
        {
#line 283
        child = new_dir_node(root, leafname, subdir, filter, callback);
        }
        {
#line 284
        fs_close_dir(subdir);
        }
        }
      } else {
        {
        {
#line 286
        child = new_file_node(leafname, filter);
        }
        }
#line 287
        if (child) {
          {
          {
#line 288
          (*callback)(child, fullname, (file_tree_traverse_state_t )0);
          }
          }
        }
      }
#line 291
      if (child) {
#line 292
        if (! child->files) {
          {
          {
#line 292
          __assert_fail("child->files", "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.c",
                        292U, "new_dir_node");
          }
          }
        }
        {
        {
#line 293
        link_in(ft, child);
        }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 297
  fullname = fs_cur_dir_entry(dir, & cur_entry);
  }
  }
#line 298
  if (! ((int const   )*(cur_entry + 0) == 0)) {
    {
    {
#line 298
    __assert_fail("cur_entry[0] == \'\\0\'", "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.c",
                  298U, "new_dir_node");
    }
    }
  }
  {
  {
#line 299
  (*callback)(ft, fullname, (file_tree_traverse_state_t )1);
  }
  }
#line 300
  if (! ft->files) {
    {
    {
#line 301
    file_tree_dispose(ft);
    }
#line 302
    ft = (file_tree_h )((void *)0);
    }
  }
#line 304
  return (ft);
}
}
#line 308 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.c"
static file_tree_h get_root(file_tree_h ft ) 
{ 
  file_tree_h tmp ;

  {
#line 311
  if ((unsigned long )ft->parent == (unsigned long )((void *)0)) {
#line 312
    return (ft);
  }
  {
  {
#line 314
  tmp = get_root(ft->parent);
  }
  }
#line 314
  return (tmp);
}
}
#line 324 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.c"
static file_tree_h seek_child(file_tree_h node , char const   *childname ) 
{ 
  file_tree_h child ;
  file_tree_h *start ;
  void **tmp ;
  file_tree_h *end ;
  void **tmp___0 ;
  int tmp___1 ;

  {
#line 327
  child = (file_tree_h )((void *)0);
#line 328
  if (node->children) {
    {
    {
#line 329
    tmp = ptr_vector_begin(node->children);
    }
#line 329
    start = (file_tree_h *)tmp;
    {
#line 331
    tmp___0 = ptr_vector_end(node->children);
    }
#line 331
    end = (file_tree_h *)tmp___0;
    }
    {
    {
#line 333
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 333
      if (! ((unsigned long )start != (unsigned long )end)) {
#line 333
        goto while_break;
      }
      {
      {
#line 334
      tmp___1 = strcmp(childname, (char const   *)(*start)->var.leafname);
      }
      }
#line 334
      if (! tmp___1) {
#line 335
        child = *start;
#line 336
        goto while_break;
      }
#line 333
      start ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 340
  return (child);
}
}
#line 362 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.c"
static file_tree_h seek(file_tree_h ft , char const   **path ) 
{ 
  char const   *posn ;
  char const   *end ;
  char *tmp ;
  fs_path_type_t path_type ;
  fs_path_type_t tmp___0 ;
  size_t tmp___1 ;
  size_t elmlen ;
  int tmp___2 ;
  file_tree_h child ;
  file_tree_h *start ;
  void **tmp___3 ;
  file_tree_h *end___0 ;
  void **tmp___4 ;

  {
  {
#line 365
  posn = *path;
  {
#line 366
  tmp = strchr(posn, '/');
  }
#line 366
  end = (char const   *)tmp;
  {
#line 367
  tmp___0 = fs_path_type(posn);
  }
#line 367
  path_type = tmp___0;
  }
#line 368
  if (! end) {
    {
    {
#line 369
    tmp___1 = strlen(posn);
    }
#line 369
    end = posn + tmp___1;
    }
  }
#line 371
  if (! ((unsigned long )ft->parent == (unsigned long )((void *)0))) {
#line 372
    elmlen = (size_t )(end - posn);
#line 373
    if (((unsigned int )path_type & 6U) == 6U) {
#line 373
      if (((unsigned int )path_type & 1U) == 1U) {
#line 374
        path_type = (fs_path_type_t )0;
      }
    }
#line 376
    if ((int )*(ft->var.leafname + elmlen) == 0) {
      {
      {
#line 376
      tmp___2 = strncmp((char const   *)ft->var.leafname, posn, elmlen);
      }
      }
#line 376
      if (tmp___2) {
#line 380
        return (ft);
      } else {
#line 378
        posn += elmlen;
#line 378
        *path = posn;
      }
    } else {
#line 380
      return (ft);
    }
  }
#line 383
  if (*posn) {
#line 384
    if (! (((unsigned int )path_type & 6U) == 6U)) {
#line 385
      posn = end + 1;
#line 385
      *path = posn;
    } else
#line 384
    if (! (((unsigned int )path_type & 1U) == 1U)) {
#line 385
      posn = end + 1;
#line 385
      *path = posn;
    }
#line 387
    if (ft->children) {
      {
#line 388
      child = (file_tree_h )((void *)0);
      {
#line 389
      tmp___3 = ptr_vector_begin(ft->children);
      }
#line 389
      start = (file_tree_h *)tmp___3;
      {
#line 391
      tmp___4 = ptr_vector_end(ft->children);
      }
#line 391
      end___0 = (file_tree_h *)tmp___4;
      }
      {
      {
#line 393
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 393
        if ((unsigned long )start != (unsigned long )end___0) {
#line 393
          if (! ((unsigned long )posn == (unsigned long )*path)) {
#line 393
            goto while_break;
          }
        } else {
#line 393
          goto while_break;
        }
        {
        {
#line 394
        child = seek(*start, & posn);
        }
#line 393
        start ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
#line 396
      if ((unsigned long )posn != (unsigned long )*path) {
#line 397
        *path = posn;
#line 398
        ft = child;
      }
    }
  }
#line 402
  return (ft);
}
}
#line 417 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.c"
static file_tree_h deepen(file_tree_h ft , char const   **path ) 
{ 
  char const   *end ;
  char *tmp ;
  file_tree_h child ;
  file_tree_h tmp___0 ;

  {
  {
  {
#line 420
  tmp = strchr(*path, '/');
  }
#line 420
  end = (char const   *)tmp;
  }
#line 421
  if (end) {
    {
    {
#line 422
    tmp___0 = new_node(*path, (size_t )(end - *path));
    }
#line 422
    child = tmp___0;
    {
#line 423
    child->children = ptr_vector_new((void (*)(void * ))(& file_tree_dispose), (void *(*)(void const   * ))((void *)0));
    }
    {
#line 424
    link_in(ft, child);
    }
#line 425
    *path = end + 1;
    {
#line 426
    ft = deepen(child, path);
    }
    }
  }
#line 428
  return (ft);
}
}
#line 448 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.c"
static void traverse(file_tree_h ft , void (*callback)(file_tree_h ft , char const   *name ,
                                                       file_tree_traverse_state_t context ) ,
                     char *path_start , char *path_end ) 
{ 
  size_t leaflen ;
  size_t tmp ;
  file_tree_h *start ;
  void **tmp___0 ;
  file_tree_h *end ;
  void **tmp___1 ;
  size_t tmp___2 ;

  {
  {
  {
#line 454
  strcpy((char */* __restrict  */)path_end, (char const   */* __restrict  */)ft->var.leafname);
  }
  }
#line 455
  if (! ((unsigned long )ft->children == (unsigned long )((void *)0))) {
    {
    {
#line 456
    tmp = strlen((char const   *)path_end);
    }
#line 456
    leaflen = tmp;
    {
#line 457
    tmp___0 = ptr_vector_begin(ft->children);
    }
#line 457
    start = (file_tree_h *)tmp___0;
    {
#line 458
    tmp___1 = ptr_vector_end(ft->children);
    }
#line 458
    end = (file_tree_h *)tmp___1;
    {
#line 459
    (*callback)(ft, (char const   *)path_start, (file_tree_traverse_state_t )-1);
    }
#line 460
    tmp___2 = leaflen;
#line 460
    leaflen ++;
#line 460
    *(path_end + tmp___2) = (char )'/';
    }
    {
    {
#line 461
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 461
      if (! ((unsigned long )start != (unsigned long )end)) {
#line 461
        goto while_break;
      }
      {
      {
#line 462
      traverse(*start, callback, path_start, path_end + leaflen);
      }
#line 461
      start ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 464
    leaflen --;
#line 464
    *(path_end + leaflen) = (char )'\000';
    {
#line 465
    (*callback)(ft, (char const   *)path_start, (file_tree_traverse_state_t )1);
    }
    }
  } else {
    {
    {
#line 467
    (*callback)(ft, (char const   *)path_start, (file_tree_traverse_state_t )0);
    }
    }
  }
#line 469
  *path_end = (char )'\000';
#line 470
  return;
}
}
#line 479 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.c"
static void file_tree_add_canon(file_tree_h root , char const   *path , void (*callback)(file_tree_h ft ,
                                                                                         char const   *name ,
                                                                                         file_tree_traverse_state_t context ) ) 
{ 
  char const   *fullpath ;
  heap_str parent_path ;
  heap_str tmp ;
  fs_dir_t parent_dir ;
  fs_dir_t tmp___0 ;
  fs_dir_t tmp___1 ;
  fs_dir_t dir ;
  fs_dir_t tmp___2 ;
  _Bool (*filter)(char const   *leafname ) ;
  file_tree_h lowest ;
  file_tree_h child ;
  char const   *leafname ;
  char const   *fullname ;
  fs_obj_type_t obj_type ;
  fs_obj_type_t tmp___3 ;
  file_tree_h child___0 ;
  file_tree_h tmp___4 ;
  fs_dir_t subdir ;
  fs_dir_t tmp___5 ;

  {
  {
#line 484
  fullpath = path;
  {
#line 485
  tmp = fs_split_filename(path, (char **)((void *)0));
  }
#line 485
  parent_path = tmp;
  }
#line 486
  if (parent_path) {
    {
    {
#line 486
    tmp___0 = fs_open_dir((char const   *)parent_path, (fs_dir_t const   )((void *)0));
    }
#line 486
    tmp___1 = tmp___0;
    }
  } else {
#line 486
    tmp___1 = (void *)0;
  }
  {
#line 486
  parent_dir = tmp___1;
  {
#line 487
  tmp___2 = fs_open_dir(path, (fs_dir_t const   )parent_dir);
  }
#line 487
  dir = tmp___2;
  }
#line 490
  if (parent_path) {
    {
    {
#line 491
    free((void *)parent_path);
    }
    }
  }
  {
  {
#line 493
  root = get_root(root);
  }
#line 494
  filter = root->var.filter;
  }
#line 495
  if (! callback) {
#line 496
    callback = & null_callback;
  }
  {
  {
#line 498
  lowest = seek(root, & path);
  }
  }
#line 499
  if (*path) {
    {
    {
#line 501
    lowest = deepen(lowest, & path);
    }
    }
#line 502
    if (! dir) {
      {
      {
#line 503
      child = new_file_node(path, filter);
      }
      }
#line 504
      if (child) {
        {
        {
#line 505
        (*callback)(child, fullpath, (file_tree_traverse_state_t )0);
        }
        }
      }
    } else {
      {
      {
#line 508
      child = new_dir_node(root, path, dir, filter, callback);
      }
      }
    }
#line 510
    if (child) {
      {
      {
#line 511
      link_in(lowest, child);
      }
      }
    }
  } else
#line 513
  if (dir) {
    {
    {
#line 516
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 516
      leafname = fs_read_dir(dir, & fullname);
      }
      }
#line 516
      if (! ((unsigned long )leafname != (unsigned long )((void *)0))) {
#line 516
        goto while_break;
      }
      {
      {
#line 517
      tmp___3 = fs_obj_type(fullname);
      }
#line 517
      obj_type = tmp___3;
      }
#line 518
      if (((unsigned int )obj_type & 1U) != 0U) {
        {
        {
#line 519
        file_tree_add_symlink(root, dir, fullname, callback);
        }
        }
      } else {
        {
        {
#line 521
        tmp___4 = seek_child(lowest, leafname);
        }
#line 521
        child___0 = tmp___4;
        }
#line 522
        if (! child___0) {
          {
          {
#line 523
          tmp___5 = fs_open_dir(fullname, (fs_dir_t const   )dir);
          }
#line 523
          subdir = tmp___5;
          }
#line 524
          if (! subdir) {
            {
            {
#line 525
            child___0 = new_file_node(leafname, filter);
            }
            }
#line 526
            if (child___0) {
              {
              {
#line 527
              (*callback)(child___0, fullname, (file_tree_traverse_state_t )0);
              }
              }
            }
          } else {
            {
            {
#line 530
            child___0 = new_dir_node(root, leafname, subdir, filter, callback);
            }
            {
#line 532
            fs_close_dir(subdir);
            }
            }
          }
#line 534
          if (child___0) {
            {
            {
#line 535
            link_in(lowest, child___0);
            }
            }
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 541
  if (parent_dir) {
    {
    {
#line 542
    fs_close_dir(parent_dir);
    }
    }
  }
#line 544
  if (dir) {
    {
    {
#line 545
    fs_close_dir(dir);
    }
    }
  }
#line 547
  return;
}
}
#line 597 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.c"
static void file_tree_add_symlink(file_tree_h root , fs_dir_t dir , char const   *symlink ,
                                  void (*callback)(file_tree_h ft , char const   *name ,
                                                   file_tree_traverse_state_t context ) ) 
{ 
  heap_str realpath___0 ;
  size_t shared_len ;
  char const   *entry ;
  char const   *dirname ;
  char const   *tmp ;
  char const   *shared_path ;
  char const   *tmp___0 ;
  char *__cil_tmp12 ;

  {
  {
  {
#line 604
  realpath___0 = fs_real_path(symlink, (size_t *)((void *)0));
  }
  {
#line 605
  report((reason_code_t )4864, (heap_str *)((void *)0), "Resolved symbolic link \"%s\"",
         symlink);
  }
  }
#line 606
  if (dir) {
    {
#line 607
    shared_len = (size_t )0;
    {
#line 609
    tmp = fs_cur_dir_entry(dir, & entry);
    }
#line 609
    dirname = tmp;
    {
#line 610
    tmp___0 = fs_path_comp(dirname, (char const   *)realpath___0, & shared_len);
    }
#line 610
    shared_path = tmp___0;
    }
    {
    {
#line 612
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 612
      if ((unsigned long )shared_path == (unsigned long )dirname) {
#line 612
        if ((int const   )*(dirname + shared_len) == 0) {
#line 612
          goto while_break;
        }
      }
      {
      {
#line 613
      dir = fs_get_parent(dir);
      }
      }
#line 613
      if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 614
        goto while_break;
      }
      {
      {
#line 616
      dirname = fs_cur_dir_entry(dir, & entry);
      }
      {
#line 617
      shared_path = fs_path_comp(dirname, (char const   *)realpath___0, & shared_len);
      }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 620
  if (! dir) {
    {
    {
#line 621
    file_tree_add_canon(root, (char const   *)realpath___0, callback);
    }
    }
  }
  {
  {
#line 623
  free((void *)realpath___0);
  }
  }
#line 624
  return;
}
}
#line 630 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.c"
static void file_tree_init(file_tree_h ft ) 
{ 


  {
  {
  {
#line 633
  memset((void *)ft, 0, sizeof(struct file_tree ));
  }
#line 634
  ft->var.filter = & null_filter;
  }
#line 635
  return;
}
}
#line 644 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.c"
static void file_tree_copy_init(file_tree_h dest , file_tree_const_h src ) 
{ 
  file_tree_const_h *start ;
  void const   **tmp ;
  file_tree_const_h *end ;
  void const   **tmp___0 ;
  file_tree_h child ;
  file_tree_h tmp___1 ;
  void *tmp___2 ;

  {
  {
  {
#line 647
  memset((void *)dest, 0, sizeof(struct file_tree ));
  }
  }
#line 648
  if (src->children) {
    {
    {
#line 649
    tmp = ptr_vector_begin_const((ptr_vector_const_h )src->children);
    }
#line 649
    start = (file_tree_const_h *)tmp;
    {
#line 651
    tmp___0 = ptr_vector_end_const((ptr_vector_const_h )src->children);
    }
#line 651
    end = (file_tree_const_h *)tmp___0;
    }
    {
    {
#line 653
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 653
      if (! ((unsigned long )start != (unsigned long )end)) {
#line 653
        goto while_break;
      }
      {
      {
#line 654
      tmp___1 = file_tree_copy(*start);
      }
#line 654
      child = tmp___1;
      {
#line 655
      link_in(dest, child);
      }
#line 653
      start ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 657
  if ((unsigned long )src->parent == (unsigned long )((void *)0)) {
#line 658
    dest->var.filter = (_Bool (*)(char const   *leafname ))src->var.filter;
  } else {
    {
    {
#line 660
    tmp___2 = clone((void const   *)src->var.leafname, (size_t )0);
    }
#line 660
    dest->var.leafname = (heap_str )tmp___2;
#line 661
    dest->files = (unsigned int )src->files;
    }
  }
#line 663
  return;
}
}
#line 668 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.c"
static void file_tree_finis(file_tree_h ft ) 
{ 


  {
#line 671
  if (ft->children) {
    {
    {
#line 672
    ptr_vector_dispose(ft->children);
    }
#line 673
    ft->children = (ptr_vector_h )((void *)0);
    }
  }
#line 675
  if (! ((unsigned long )ft->parent == (unsigned long )((void *)0))) {
#line 675
    if (ft->var.leafname) {
      {
      {
#line 676
      free((void *)ft->var.leafname);
      }
#line 677
      ft->var.leafname = (heap_str )((void *)0);
      }
    }
  }
#line 679
  return;
}
}
#line 705 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.c"
heap_str file_tree_name(file_tree_const_h const   ft ) 
{ 
  heap_str full_name ;
  void *tmp ;
  heap_str path_name ;
  heap_str tmp___0 ;

  {
#line 709
  if ((unsigned long )ft->parent == (unsigned long )((void *)0)) {
    {
    {
#line 710
    tmp = callocate((size_t )1, (size_t )1);
    }
#line 710
    full_name = (heap_str )tmp;
    }
  } else {
    {
    {
#line 712
    tmp___0 = file_tree_name((file_tree_const_h const   )ft->parent);
    }
#line 712
    path_name = tmp___0;
    {
#line 713
    full_name = fs_compose_filename((char const   *)path_name, (char const   *)ft->var.leafname);
    }
    {
#line 715
    free((void *)path_name);
    }
    }
  }
#line 717
  return (full_name);
}
}
#line 720 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.c"
file_tree_h file_tree_new(void) 
{ 
  file_tree_h ft ;
  void *tmp ;

  {
  {
  {
#line 723
  tmp = allocate(sizeof(struct file_tree ));
  }
#line 723
  ft = (file_tree_h )tmp;
  {
#line 724
  file_tree_init(ft);
  }
  }
#line 725
  return (ft);
}
}
#line 728 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.c"
file_tree_h file_tree_copy(file_tree_const_h src ) 
{ 
  file_tree_h dest ;
  void *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 732
  if (! src) {
    {
    {
#line 732
    __assert_fail("src", "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.c", 732U,
                  "file_tree_copy");
    }
    }
  }
  {
  {
#line 733
  tmp = allocate(sizeof(struct file_tree ));
  }
#line 733
  dest = (file_tree_h )tmp;
  {
#line 734
  file_tree_copy_init(dest, src);
  }
  }
#line 735
  return (dest);
}
}
#line 738 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.c"
void file_tree_swap(file_tree_h lhs , file_tree_h rhs ) 
{ 
  heap_str tmp ;
  file_tree_h tmp___0 ;
  ptr_vector_h tmp___1 ;
  unsigned int tmp___2 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 741
  if (! lhs) {
    {
    {
#line 741
    __assert_fail("lhs", "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.c", 741U,
                  "file_tree_swap");
    }
    }
  }
#line 742
  if (! rhs) {
    {
    {
#line 742
    __assert_fail("rhs", "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.c", 742U,
                  "file_tree_swap");
    }
    }
  }
  {
  {
#line 743
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 743
    tmp = lhs->var.leafname;
#line 743
    lhs->var.leafname = rhs->var.leafname;
#line 743
    rhs->var.leafname = tmp;
#line 743
    goto while_break;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 744
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 744
    tmp___0 = lhs->parent;
#line 744
    lhs->parent = rhs->parent;
#line 744
    rhs->parent = tmp___0;
#line 744
    goto while_break___0;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 745
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 745
    tmp___1 = lhs->children;
#line 745
    lhs->children = rhs->children;
#line 745
    rhs->children = tmp___1;
#line 745
    goto while_break___1;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  {
#line 746
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 746
    tmp___2 = lhs->files;
#line 746
    lhs->files = rhs->files;
#line 746
    rhs->files = tmp___2;
#line 746
    goto while_break___2;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 747
  return;
}
}
#line 749 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.c"
void file_tree_assign(file_tree_h dest , file_tree_const_h src ) 
{ 
  file_tree_h tmp ;
  file_tree_h tmp___0 ;

  {
#line 752
  if ((unsigned long )dest != (unsigned long )src) {
    {
    {
#line 753
    tmp___0 = file_tree_copy(src);
    }
#line 753
    tmp = tmp___0;
    {
#line 754
    file_tree_swap(dest, tmp);
    }
    {
#line 755
    file_tree_dispose(tmp);
    }
    }
  }
#line 757
  return;
}
}
#line 759 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.c"
_Bool file_tree_equal(file_tree_const_h lhs , file_tree_const_h rhs ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  file_tree_const_h *lh_iter ;
  void const   **tmp___1 ;
  file_tree_const_h *rh_iter ;
  void const   **tmp___2 ;
  file_tree_const_h *lh_end ;
  void const   **tmp___3 ;
  _Bool tmp___4 ;
  heap_str lh_name ;
  heap_str tmp___5 ;
  heap_str rh_name ;
  heap_str tmp___6 ;
  _Bool eq___0 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 762
  if ((unsigned long )lhs == (unsigned long )rhs) {
#line 763
    return ((_Bool)1);
  }
#line 765
  if (! lhs->children ^ ! rhs->children) {
#line 766
    return ((_Bool)0);
  }
#line 768
  if (lhs->children) {
    {
    {
#line 769
    tmp = ptr_vector_count((ptr_vector_const_h )lhs->children);
    }
    {
#line 769
    tmp___0 = ptr_vector_count((ptr_vector_const_h )rhs->children);
    }
    }
#line 769
    if (tmp != tmp___0) {
#line 770
      return ((_Bool)0);
    }
    {
    {
#line 772
    tmp___1 = ptr_vector_begin_const((ptr_vector_const_h )lhs->children);
    }
#line 772
    lh_iter = (file_tree_const_h *)tmp___1;
    {
#line 774
    tmp___2 = ptr_vector_begin_const((ptr_vector_const_h )rhs->children);
    }
#line 774
    rh_iter = (file_tree_const_h *)tmp___2;
    {
#line 776
    tmp___3 = ptr_vector_end_const((ptr_vector_const_h )lhs->children);
    }
#line 776
    lh_end = (file_tree_const_h *)tmp___3;
    }
    {
    {
#line 778
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 778
      if (! ((unsigned long )lh_iter != (unsigned long )lh_end)) {
#line 778
        goto while_break;
      }
      {
      {
#line 779
      tmp___4 = file_tree_equal(*lh_iter, *rh_iter);
      }
      }
#line 779
      if (! tmp___4) {
#line 780
        return ((_Bool)0);
      }
#line 778
      lh_iter ++;
#line 778
      rh_iter ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 784
  if (((unsigned long )lhs->parent == (unsigned long )((void *)0)) ^ ((unsigned long )rhs->parent == (unsigned long )((void *)0))) {
#line 785
    return ((_Bool)0);
  }
#line 787
  if ((unsigned long )lhs->parent == (unsigned long )((void *)0)) {
#line 788
    return ((_Bool)1);
  } else {
    {
    {
#line 790
    tmp___5 = file_tree_name((file_tree_const_h const   )lhs);
    }
#line 790
    lh_name = tmp___5;
    {
#line 791
    tmp___6 = file_tree_name((file_tree_const_h const   )rhs);
    }
#line 791
    rh_name = tmp___6;
    {
#line 792
    tmp___7 = strcmp((char const   *)lh_name, (char const   *)rh_name);
    }
    }
#line 792
    if (tmp___7) {
#line 792
      tmp___8 = 0;
    } else {
#line 792
      tmp___8 = 1;
    }
    {
#line 792
    eq___0 = (_Bool )tmp___8;
    {
#line 793
    free((void *)lh_name);
    }
    {
#line 794
    free((void *)rh_name);
    }
    }
#line 795
    return (eq___0);
  }
}
}
#line 800 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.c"
_Bool file_tree_set_filter(file_tree_h ft , _Bool (*filter)(char const   *leafname ) ) 
{ 
  _Bool tmp ;

  {
  {
  {
#line 803
  tmp = file_tree_is_empty((file_tree_const_h )ft);
  }
  }
#line 803
  if (! tmp) {
#line 804
    return ((_Bool)0);
  }
#line 806
  ft->var.filter = filter;
#line 807
  return ((_Bool)1);
}
}
#line 810 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.c"
void file_tree_dispose(file_tree_h ft ) 
{ 


  {
#line 813
  if (ft) {
    {
    {
#line 814
    file_tree_finis(ft);
    }
    {
#line 815
    free((void *)ft);
    }
    }
  }
#line 817
  return;
}
}
#line 819 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.c"
void file_tree_add(file_tree_h root , char const   *path , void (*callback)(file_tree_h ft ,
                                                                            char const   *name ,
                                                                            file_tree_traverse_state_t context ) ) 
{ 
  fs_obj_type_t obj_type ;
  fs_obj_type_t tmp ;
  heap_str fullpath ;
  heap_str tmp___0 ;

  {
  {
  {
#line 824
  tmp = fs_file_or_dir(path);
  }
#line 824
  obj_type = tmp;
  }
#line 825
  if (((unsigned int )obj_type & 1U) != 0U) {
    {
    {
#line 826
    file_tree_add_symlink(root, (void *)0, path, callback);
    }
    }
  } else {
    {
    {
#line 828
    tmp___0 = fs_real_path(path, (size_t *)((void *)0));
    }
#line 828
    fullpath = tmp___0;
    {
#line 829
    file_tree_add_canon(root, (char const   *)fullpath, callback);
    }
    {
#line 830
    free((void *)fullpath);
    }
    }
  }
#line 832
  return;
}
}
#line 834 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.c"
void file_tree_traverse(file_tree_h ft , void (*callback)(file_tree_h ft , char const   *name ,
                                                          file_tree_traverse_state_t context ) ) 
{ 
  file_tree_h *start ;
  file_tree_h *end ;
  heap_str pathstack ;
  void *tmp ;
  void **tmp___0 ;
  void **tmp___1 ;
  size_t tmp___2 ;
  char *__cil_tmp10 ;

  {
  {
  {
#line 838
  (*callback)(ft, (char const   *)((void *)0), (file_tree_traverse_state_t )-2);
  }
  }
#line 839
  if (ft->children) {
    {
    {
#line 842
    tmp = callocate((size_t )1, (size_t )4096);
    }
#line 842
    pathstack = (heap_str )tmp;
    {
#line 843
    strcpy((char */* __restrict  */)pathstack, (char const   */* __restrict  */)"/");
    }
    {
#line 844
    tmp___0 = ptr_vector_begin(ft->children);
    }
#line 844
    start = (file_tree_h *)tmp___0;
    {
#line 845
    tmp___1 = ptr_vector_end(ft->children);
    }
#line 845
    end = (file_tree_h *)tmp___1;
    }
    {
    {
#line 846
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 846
      if (! ((unsigned long )start != (unsigned long )end)) {
#line 846
        goto while_break;
      }
      {
      {
#line 847
      tmp___2 = strlen((char const   *)pathstack);
      }
      {
#line 847
      traverse(*start, callback, pathstack, pathstack + tmp___2);
      }
#line 846
      start ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 849
    free((void *)pathstack);
    }
    }
  }
  {
  {
#line 851
  (*callback)(ft, (char const   *)((void *)0), (file_tree_traverse_state_t )2);
  }
  }
#line 852
  return;
}
}
#line 854 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.c"
_Bool file_tree_is_empty(file_tree_const_h ft ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
#line 857
  if (! ((unsigned long )ft->parent == (unsigned long )((void *)0))) {
#line 858
    return ((_Bool)0);
  }
#line 860
  if (! ft->children) {
#line 860
    tmp___0 = 1;
  } else {
    {
    {
#line 860
    tmp = ptr_vector_count((ptr_vector_const_h )ft->children);
    }
    }
#line 860
    if (tmp == 0UL) {
#line 860
      tmp___0 = 1;
    } else {
#line 860
      tmp___0 = 0;
    }
  }
#line 860
  return ((_Bool )tmp___0);
}
}
#line 863 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.c"
size_t file_tree_count(file_tree_const_h ft , unsigned int flags , file_tree_count_t *counter ) 
{ 
  file_tree_count_t count ;
  int count_children ;
  int count_dirs ;
  int count_files ;
  file_tree_h *start ;
  void **tmp ;
  file_tree_h *end ;
  void **tmp___0 ;

  {
#line 866
  count.files = (size_t )0;
#line 866
  count.dirs = (size_t )0;
#line 866
  count.children = (size_t )0;
#line 867
  count_children = (flags & 4U) == 4U;
#line 868
  count_dirs = (flags & 2U) == 2U;
#line 869
  count_files = (flags & 1U) == 1U;
#line 870
  if (! count_children) {
#line 870
    if (count_files) {
#line 870
      if (! count_dirs) {
#line 871
        count.files = (size_t )ft->files;
      } else {
#line 870
        goto _L___0;
      }
    } else {
#line 870
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 873
    if (! ((unsigned long )ft->parent == (unsigned long )((void *)0))) {
#line 874
      if (! count_children) {
#line 875
        if (! ((unsigned long )ft->children == (unsigned long )((void *)0))) {
#line 876
          count.dirs += (size_t )count_dirs;
        } else {
#line 878
          count.files += (size_t )count_files;
        }
      }
    }
#line 882
    if (! ((unsigned long )ft->children == (unsigned long )((void *)0))) {
      {
      {
#line 883
      tmp = ptr_vector_begin((ptr_vector_h )ft->children);
      }
#line 883
      start = (file_tree_h *)tmp;
      {
#line 884
      tmp___0 = ptr_vector_end((ptr_vector_h )ft->children);
      }
#line 884
      end = (file_tree_h *)tmp___0;
      }
      {
      {
#line 885
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 885
        if (! ((unsigned long )start != (unsigned long )end)) {
#line 885
          goto while_break;
        }
#line 886
        if (count_children) {
#line 887
          (count.children) ++;
#line 888
          if (! ((unsigned long )(*start)->children == (unsigned long )((void *)0))) {
#line 889
            count.dirs += (size_t )count_dirs;
          } else {
#line 891
            count.files += (size_t )count_files;
          }
        } else {
          {
          {
#line 894
          file_tree_count((file_tree_const_h )*start, flags, & count);
          }
          }
        }
#line 885
        start ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 899
  if (counter) {
#line 900
    *counter = count;
  }
#line 902
  return (count.files + count.dirs);
}
}
#line 906 "/home/wslee/tests/SOURCES/coan-4.2.2/src/file_tree.c"
file_tree_const_h file_tree_child(file_tree_const_h ft , size_t which ) 
{ 
  file_tree_h child ;
  size_t children ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 909
  child = (file_tree_h )((void *)0);
#line 910
  if (! ((unsigned long )ft->children == (unsigned long )((void *)0))) {
    {
    {
#line 911
    tmp = ptr_vector_count((ptr_vector_const_h )ft->children);
    }
#line 911
    children = tmp;
    }
#line 912
    if (children) {
#line 913
      if (which == 0xffffffffffffffffUL) {
#line 914
        which = children - 1UL;
      }
#line 916
      if (which < children) {
        {
        {
#line 917
        tmp___0 = ptr_vector_at((ptr_vector_h )ft->children, which);
        }
#line 917
        child = *((file_tree_h *)tmp___0);
        }
      }
    }
  }
#line 921
  return ((file_tree_const_h )child);
}
}
#line 54 "/home/wslee/tests/SOURCES/coan-4.2.2/src/exception.h"
jmp_buf exception_context  ;
#line 46 "/home/wslee/tests/SOURCES/coan-4.2.2/src/exception.c"
_Bool exceptions_enabled  =    (_Bool)0;
#line 91 "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.h"
canonical_string_h canonical_identifier(char const   **cpp ) ;
#line 126
size_t canonical_string_length(canonical_string_const_h cs ) ;
#line 285 "/home/wslee/tests/SOURCES/coan-4.2.2/src/eval_result.h"
struct int_spec  const  int_spec_true ;
#line 83 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.h"
void evaluator_finitor(void) ;
#line 105 "/home/wslee/tests/SOURCES/coan-4.2.2/src/chew.h"
char const   *chew_on(char const   *cp ) ;
#line 143
char const   *chew_macro_call(char const   *cp ) ;
#line 153
char const   *chew_header_name(char const   *cp ) ;
#line 170
char const   *chew_string(char const   *cp ) ;
#line 86 "/home/wslee/tests/SOURCES/coan-4.2.2/src/directives_tally.h"
void directive_tally(canonical_string_const_h cl , directive_type_t directive_type ) ;
#line 97
directive_type_t get_directive_type(char const   **keyword ) ;
#line 88 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
static evaluator_state_t evaluator_state  ;
#line 88 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
evaluator_state_t *evaluator_h  =    & evaluator_state;
#line 88 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
evaluator_public_state_t *evaluator_public_h  =    & evaluator_state;
#line 88 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
static evaluator_state_t const   * const  evaluator_static_initialiser_h  ;
#line 88 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
void (*evaluator_init_h)(evaluator_state_t * )  ;
#line 88 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
void (*evaluator_finis_h)(evaluator_state_t * )  ;
#line 88 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
void evaluator_initor(void) 
{ 


  {
  {
  {
#line 88
  component_initor((_Bool)1, (_Bool)1, (void **)((char *)(& evaluator_h)), (void **)((char *)(& evaluator_public_h)),
                   (void const   *)evaluator_static_initialiser_h, sizeof(evaluator_state_t ),
                   (void (*)())evaluator_init_h);
  }
  }
#line 88
  return;
}
}
#line 88 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
void evaluator_finitor(void) 
{ 


  {
  {
  {
#line 88
  component_finitor((_Bool)1, (void **)((char *)(& evaluator_h)), (void **)((char *)(& evaluator_public_h)),
                    (void (*)())evaluator_init_h);
  }
  }
#line 88
  return;
}
}
#line 95
struct co_precedent_ops  const  *ops_tab ;
#line 110 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
static eval_result_t integer_binary_op(eval_result_t *lhs , eval_result_t *rhs , integer_bin_op_t *op ) 
{ 
  eval_result_t result ;
  int_spec_t int_spec ;
  int_spec_t tmp ;

  {
#line 115
  result.sym_name = (char *)0;
#line 115
  result.sym_def = (canonical_string_h )0;
#line 115
  result.most_resolved = (canonical_string_h )0;
#line 115
  result.value.val.ll = 0LL;
#line 115
  result.value.type = (int_type )0;
#line 115
  result.flags = 0;
#line 115
  result.line = 0;
#line 116
  if ((lhs->flags & 1) == 1) {
#line 116
    goto _L___0;
  } else
#line 116
  if (! ((lhs->flags & 24) == 0)) {
    _L___0: /* CIL Label */ 
#line 116
    if ((rhs->flags & 1) == 1) {
#line 116
      goto _L;
    } else
#line 116
    if (! ((rhs->flags & 24) == 0)) {
      _L: /* CIL Label */ 
      {
      {
#line 118
      tmp = (*op)((int_spec_t const   *)(& lhs->value), (int_spec_t const   *)(& rhs->value));
      }
#line 118
      int_spec = tmp;
      }
#line 119
      if ((unsigned int )int_spec.type != 0U) {
        {
        {
#line 120
        eval_result_set_value(& result, (int_spec_t const   *)(& int_spec));
        }
        }
      }
    }
  }
#line 123
  return (result);
}
}
#line 127 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
static eval_result_t op_lt(eval_result_t *lhs , eval_result_t *rhs ) 
{ 
  eval_result_t tmp ;

  {
  {
  {
#line 130
  tmp = integer_binary_op(lhs, rhs, & lt);
  }
  }
#line 130
  return (tmp);
}
}
#line 134 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
static eval_result_t op_gt(eval_result_t *lhs , eval_result_t *rhs ) 
{ 
  eval_result_t tmp ;

  {
  {
  {
#line 137
  tmp = integer_binary_op(lhs, rhs, & gt);
  }
  }
#line 137
  return (tmp);
}
}
#line 141 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
static eval_result_t op_le(eval_result_t *lhs , eval_result_t *rhs ) 
{ 
  eval_result_t tmp ;

  {
  {
  {
#line 144
  tmp = integer_binary_op(lhs, rhs, & le);
  }
  }
#line 144
  return (tmp);
}
}
#line 148 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
static eval_result_t op_ge(eval_result_t *lhs , eval_result_t *rhs ) 
{ 
  eval_result_t tmp ;

  {
  {
  {
#line 151
  tmp = integer_binary_op(lhs, rhs, & ge);
  }
  }
#line 151
  return (tmp);
}
}
#line 155 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
static eval_result_t op_eq(eval_result_t *lhs , eval_result_t *rhs ) 
{ 
  eval_result_t tmp ;

  {
  {
  {
#line 158
  tmp = integer_binary_op(lhs, rhs, & eq);
  }
  }
#line 158
  return (tmp);
}
}
#line 162 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
static eval_result_t op_ne(eval_result_t *lhs , eval_result_t *rhs ) 
{ 
  eval_result_t tmp ;

  {
  {
  {
#line 165
  tmp = integer_binary_op(lhs, rhs, & ne);
  }
  }
#line 165
  return (tmp);
}
}
#line 169 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
static eval_result_t op_or(eval_result_t *lhs , eval_result_t *rhs ) 
{ 
  eval_result_t result ;

  {
#line 172
  result.sym_name = (char *)0;
#line 172
  result.sym_def = (canonical_string_h )0;
#line 172
  result.most_resolved = (canonical_string_h )0;
#line 172
  result.value.val.ll = 0LL;
#line 172
  result.value.type = (int_type )0;
#line 172
  result.flags = 0;
#line 172
  result.line = 0;
#line 173
  if ((lhs->flags & 8) == 8) {
    {
    {
#line 174
    eval_result_set_value(& result, & int_spec_true);
    }
    }
  } else
#line 173
  if ((rhs->flags & 8) == 8) {
    {
    {
#line 174
    eval_result_set_value(& result, & int_spec_true);
    }
    }
  } else
#line 175
  if ((lhs->flags & 16) == 16) {
#line 175
    if ((rhs->flags & 16) == 16) {
      {
      {
#line 176
      eval_result_set_value(& result, & int_spec_false);
      }
      }
    }
  }
#line 178
  if ((lhs->flags & 24) == (rhs->flags & 24)) {
#line 179
    if (((lhs->flags & 3) == 3) | ((rhs->flags & 3) == 3)) {
#line 179
      result.flags |= 3;
    }
  } else
#line 181
  if ((lhs->flags & 8) == 8) {
#line 182
    if ((lhs->flags & 3) == 3) {
#line 182
      result.flags |= 3;
    }
#line 183
    if (! ((rhs->flags & 3) == 3)) {
#line 183
      rhs->flags &= -3;
    }
  } else
#line 184
  if ((rhs->flags & 8) == 8) {
#line 185
    if ((rhs->flags & 3) == 3) {
#line 185
      result.flags |= 3;
    }
#line 186
    if (! ((lhs->flags & 3) == 3)) {
#line 186
      lhs->flags &= -3;
    }
  } else
#line 187
  if ((lhs->flags & 16) == 16) {
#line 188
    if ((rhs->flags & 3) == 3) {
#line 188
      result.flags |= 3;
    }
  } else
#line 189
  if ((rhs->flags & 16) == 16) {
#line 190
    if ((lhs->flags & 3) == 3) {
#line 190
      result.flags |= 3;
    }
  }
#line 192
  return (result);
}
}
#line 196 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
static eval_result_t op_and(eval_result_t *lhs , eval_result_t *rhs ) 
{ 
  eval_result_t result ;
  int_spec_t int_spec ;
  int_spec_t tmp ;

  {
#line 199
  result.sym_name = (char *)0;
#line 199
  result.sym_def = (canonical_string_h )0;
#line 199
  result.most_resolved = (canonical_string_h )0;
#line 199
  result.value.val.ll = 0LL;
#line 199
  result.value.type = (int_type )0;
#line 199
  result.flags = 0;
#line 199
  result.line = 0;
#line 200
  if ((rhs->flags & 8) == 8) {
#line 200
    if ((lhs->flags & 16) == 16) {
      {
      {
#line 201
      eval_result_set_value(& result, & int_spec_false);
      }
      }
#line 202
      if ((lhs->flags & 3) == 3) {
#line 202
        result.flags |= 3;
      }
    } else {
#line 200
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 203
  if ((lhs->flags & 8) == 8) {
#line 203
    if ((rhs->flags & 16) == 16) {
      {
      {
#line 204
      eval_result_set_value(& result, & int_spec_false);
      }
      }
#line 205
      if ((rhs->flags & 3) == 3) {
#line 205
        result.flags |= 3;
      }
    } else {
#line 203
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 206
  if ((lhs->flags & 24) == 0) {
#line 207
    if ((rhs->flags & 16) == 16) {
      {
      {
#line 208
      eval_result_set_value(& result, & int_spec_false);
      }
      }
#line 209
      if ((rhs->flags & 3) == 3) {
#line 209
        result.flags |= 3;
      }
    } else
#line 211
    if ((lhs->flags & 3) == 3) {
#line 211
      result.flags |= 3;
    }
  } else
#line 213
  if ((rhs->flags & 24) == 0) {
#line 214
    if ((lhs->flags & 16) == 16) {
      {
      {
#line 215
      eval_result_set_value(& result, & int_spec_false);
      }
      }
#line 216
      if ((lhs->flags & 3) == 3) {
#line 216
        result.flags |= 3;
      }
    } else
#line 218
    if ((rhs->flags & 3) == 3) {
#line 218
      result.flags |= 3;
    }
  } else {
    {
    {
#line 221
    tmp = boolean_and((int_spec_t const   *)(& lhs->value), (int_spec_t const   *)(& rhs->value));
    }
#line 221
    int_spec = tmp;
    {
#line 222
    eval_result_set_value(& result, (int_spec_t const   *)(& int_spec));
    }
    }
#line 223
    if (((rhs->flags & 3) == 3) | ((lhs->flags & 3) == 3)) {
#line 223
      result.flags |= 3;
    }
  }
#line 226
  return (result);
}
}
#line 230 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
static eval_result_t op_bit_and(eval_result_t *lhs , eval_result_t *rhs ) 
{ 
  eval_result_t tmp ;

  {
  {
  {
#line 233
  tmp = integer_binary_op(lhs, rhs, & bit_and);
  }
  }
#line 233
  return (tmp);
}
}
#line 237 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
static eval_result_t op_bit_or(eval_result_t *lhs , eval_result_t *rhs ) 
{ 
  eval_result_t tmp ;

  {
  {
  {
#line 240
  tmp = integer_binary_op(lhs, rhs, & bit_or);
  }
  }
#line 240
  return (tmp);
}
}
#line 244 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
static eval_result_t op_bit_xor(eval_result_t *lhs , eval_result_t *rhs ) 
{ 
  eval_result_t tmp ;

  {
  {
  {
#line 247
  tmp = integer_binary_op(lhs, rhs, & bit_xor);
  }
  }
#line 247
  return (tmp);
}
}
#line 251 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
static eval_result_t op_lshift(eval_result_t *lhs , eval_result_t *rhs ) 
{ 
  eval_result_t tmp ;

  {
  {
  {
#line 254
  tmp = integer_binary_op(lhs, rhs, & lshift);
  }
  }
#line 254
  return (tmp);
}
}
#line 258 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
static eval_result_t op_rshift(eval_result_t *lhs , eval_result_t *rhs ) 
{ 
  eval_result_t tmp ;

  {
  {
  {
#line 261
  tmp = integer_binary_op(lhs, rhs, & rshift);
  }
  }
#line 261
  return (tmp);
}
}
#line 265 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
static eval_result_t op_add(eval_result_t *lhs , eval_result_t *rhs ) 
{ 
  eval_result_t tmp ;

  {
  {
  {
#line 268
  tmp = integer_binary_op(lhs, rhs, & add);
  }
  }
#line 268
  return (tmp);
}
}
#line 272 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
static eval_result_t op_subtract(eval_result_t *lhs , eval_result_t *rhs ) 
{ 
  eval_result_t tmp ;

  {
  {
  {
#line 275
  tmp = integer_binary_op(lhs, rhs, & subtract);
  }
  }
#line 275
  return (tmp);
}
}
#line 279 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
static eval_result_t op_mult(eval_result_t *lhs , eval_result_t *rhs ) 
{ 
  eval_result_t tmp ;

  {
  {
  {
#line 282
  tmp = integer_binary_op(lhs, rhs, & multiply);
  }
  }
#line 282
  return (tmp);
}
}
#line 286 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
static eval_result_t op_divide(eval_result_t *lhs , eval_result_t *rhs ) 
{ 
  eval_result_t result ;
  int_spec_t int_spec ;
  int_spec_t tmp ;
  char *__cil_tmp6 ;

  {
#line 289
  result.sym_name = (char *)0;
#line 289
  result.sym_def = (canonical_string_h )0;
#line 289
  result.most_resolved = (canonical_string_h )0;
#line 289
  result.value.val.ll = 0LL;
#line 289
  result.value.type = (int_type )0;
#line 289
  result.flags = 0;
#line 289
  result.line = 0;
#line 290
  if ((lhs->flags & 1) == 1) {
#line 290
    goto _L___0;
  } else
#line 290
  if (! ((lhs->flags & 24) == 0)) {
    _L___0: /* CIL Label */ 
#line 290
    if ((rhs->flags & 1) == 1) {
#line 290
      goto _L;
    } else
#line 290
    if (! ((rhs->flags & 24) == 0)) {
      _L: /* CIL Label */ 
#line 292
      if (! rhs->value.val.ull) {
        {
        {
#line 293
        report((reason_code_t )8800, (heap_str *)((void *)0), "Divide by zero");
        }
        }
      } else {
        {
        {
#line 296
        tmp = divide((int_spec_t const   *)(& lhs->value), (int_spec_t const   *)(& rhs->value));
        }
#line 296
        int_spec = tmp;
        {
#line 297
        eval_result_set_value(& result, (int_spec_t const   *)(& int_spec));
        }
        }
      }
    }
  }
#line 300
  return (result);
}
}
#line 304 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
static eval_result_t op_mod(eval_result_t *lhs , eval_result_t *rhs ) 
{ 
  eval_result_t result ;
  int_spec_t int_spec ;
  int_spec_t tmp ;
  char *__cil_tmp6 ;

  {
#line 307
  result.sym_name = (char *)0;
#line 307
  result.sym_def = (canonical_string_h )0;
#line 307
  result.most_resolved = (canonical_string_h )0;
#line 307
  result.value.val.ll = 0LL;
#line 307
  result.value.type = (int_type )0;
#line 307
  result.flags = 0;
#line 307
  result.line = 0;
#line 308
  if ((lhs->flags & 1) == 1) {
#line 308
    goto _L___0;
  } else
#line 308
  if (! ((lhs->flags & 24) == 0)) {
    _L___0: /* CIL Label */ 
#line 308
    if ((rhs->flags & 1) == 1) {
#line 308
      goto _L;
    } else
#line 308
    if (! ((rhs->flags & 24) == 0)) {
      _L: /* CIL Label */ 
#line 310
      if (! rhs->value.val.ull) {
        {
        {
#line 311
        report((reason_code_t )8800, (heap_str *)((void *)0), "Divide by zero");
        }
        }
      } else {
        {
        {
#line 314
        tmp = modulus((int_spec_t const   *)(& lhs->value), (int_spec_t const   *)(& rhs->value));
        }
#line 314
        int_spec = tmp;
        {
#line 315
        eval_result_set_value(& result, (int_spec_t const   *)(& int_spec));
        }
        }
      }
    }
  }
#line 318
  return (result);
}
}
#line 371
static eval_result_t eval_unary(struct co_precedent_ops  const  *ops , char const   **cpp ,
                                struct operation  const  **ignored ) ;
#line 399
static eval_result_t eval_table(struct co_precedent_ops  const  *ops , char const   **cpp ,
                                struct operation  const  **pbin_op ) ;
#line 422 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
struct co_precedent_ops  const  eval_ops[8]  = 
#line 422
  {      {& eval_table, {{"||", & op_or}}}, 
        {& eval_table, {{"&&", & op_and}}}, 
        {& eval_table, {{"|", & op_bit_or}, {"^", & op_bit_xor}, {"&", & op_bit_and}}}, 
        {& eval_table,
      {{"==", & op_eq}, {"!=", & op_ne}}}, 
        {& eval_table, {{"<=", & op_le}, {">=", & op_ge}, {"<", & op_lt}, {">", & op_gt}}}, 
        {& eval_table,
      {{"<<", & op_lshift}, {">>", & op_rshift}}}, 
        {& eval_table, {{"+", & op_add}, {"-", & op_subtract}}}, 
        {& eval_unary, {{"*", & op_mult}, {"/", & op_divide}, {"%", & op_mod}}}};
#line 484 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
struct co_precedent_ops  const  *ops_tab  =    eval_ops;
#line 500 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
static char const   *short_circuit_and(char const   *cp ) 
{ 
  int balance ;

  {
#line 503
  balance = 0;
  {
  {
#line 504
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 504
    cp = chew_on(cp);
    }
    }
#line 504
    if (! *cp) {
#line 504
      goto while_break;
    }
#line 505
    if ((int const   )*cp == 40) {
#line 506
      balance ++;
    } else
#line 507
    if ((int const   )*cp == 41) {
#line 508
      balance --;
    }
#line 510
    if (balance < 0) {
#line 511
      goto while_break;
    } else
#line 512
    if (balance == 0) {
#line 516
      if ((int const   )*(cp + 0) == (int const   )*(cp + 1)) {
#line 516
        if ((int const   )*(cp + 0) == 124) {
#line 517
          goto while_break;
        }
      }
    }
#line 504
    cp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 521
  return (cp);
}
}
#line 538 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
static char const   *short_circuit_or(char const   *cp ) 
{ 
  int balance ;

  {
#line 541
  balance = 0;
  {
  {
#line 542
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 542
    cp = chew_on(cp);
    }
    }
#line 542
    if (! *cp) {
#line 542
      goto while_break;
    }
#line 543
    if ((int const   )*cp == 40) {
#line 544
      balance ++;
    } else
#line 545
    if ((int const   )*cp == 41) {
#line 546
      balance --;
    }
#line 548
    if (balance < 0) {
#line 549
      goto while_break;
    }
#line 542
    cp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 552
  return (cp);
}
}
#line 559
static int eval_if(char const   **cpp ) ;
#line 571 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
static line_type_t eval_hash_define(char const   **cpp ) 
{ 
  canonical_string_h symname ;
  char const   *cp ;
  line_type_t retval ;
  size_t tmp ;
  canonical_string_h def_text ;
  canonical_string_h tmp___0 ;
  _Bool tmp___1 ;
  char const   *tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 574
  symname = (canonical_string_h )((void *)0);
#line 575
  cp = *cpp;
  {
#line 577
  tmp = line_len(*cpp);
  }
  {
#line 577
  debug((dbg_code_t )13, tmp, *cpp);
  }
  {
#line 578
  cp = chew_on(cp);
  }
  {
#line 579
  tmp___1 = eligible_line(6, 7);
  }
  }
#line 579
  if (tmp___1) {
    {
    {
#line 580
    tmp___0 = canonical_string_new(cp, (size_t )0, (char const   **)((void *)0));
    }
#line 580
    def_text = tmp___0;
    {
#line 581
    directive_tally((canonical_string_const_h )def_text, (directive_type_t )7);
    }
    }
  }
  {
  {
#line 584
  symname = canonical_identifier(& cp);
  }
  {
#line 585
  tmp___2 = canonical_string_text((canonical_string_const_h )symname);
  }
  {
#line 585
  retval = symbol_evaluate_status((_Bool)1, tmp___2, cp, & cp);
  }
  }
  {
  {
#line 586
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 586
    if (! *cp) {
#line 586
      goto while_break;
    }
    {
    {
#line 587
    cp = chew_string(cp);
    }
    {
#line 588
    cp = chew_on(cp);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 590
  canonical_string_dispose(symname);
  }
  {
#line 591
  tmp___3 = line_len(*cpp);
  }
  {
#line 591
  debug((dbg_code_t )14, tmp___3, *cpp, (unsigned int )retval);
  }
#line 592
  *cpp = cp;
  }
#line 593
  return (retval);
}
}
#line 605 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
static line_type_t eval_hash_undef(char const   **cpp ) 
{ 
  canonical_string_h symname ;
  char const   *cp ;
  line_type_t retval ;
  size_t tmp ;
  canonical_string_h tmp___0 ;
  _Bool tmp___1 ;
  char const   *tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 608
  symname = (canonical_string_h )((void *)0);
#line 609
  cp = *cpp;
#line 610
  retval = (line_type_t )11;
  {
#line 611
  tmp = line_len(*cpp);
  }
  {
#line 611
  debug((dbg_code_t )15, tmp, *cpp);
  }
  {
#line 612
  cp = chew_on(cp);
  }
  {
#line 613
  symname = canonical_identifier(& cp);
  }
  {
#line 614
  tmp___1 = eligible_line(6, 8);
  }
  }
#line 614
  if (tmp___1) {
    {
    {
#line 615
    tmp___0 = canonical_string_copy((canonical_string_const_h )symname);
    }
    {
#line 615
    directive_tally((canonical_string_const_h )tmp___0, (directive_type_t )8);
    }
    }
  }
  {
  {
#line 617
  tmp___2 = canonical_string_text((canonical_string_const_h )symname);
  }
  {
#line 617
  retval = symbol_evaluate_status((_Bool)0, tmp___2, cp, & cp);
  }
  {
#line 618
  tmp___3 = line_len(*cpp);
  }
  {
#line 618
  debug((dbg_code_t )16, tmp___3, *cpp, (unsigned int )retval);
  }
  {
#line 619
  canonical_string_dispose(symname);
  }
  {
#line 620
  cp = chew_on(cp);
  }
#line 620
  *cpp = cp;
  }
#line 621
  return (retval);
}
}
#line 639 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
static eval_result_t eval_possible_symbol(char const   **cpp , directive_type_t context ) 
{ 
  symbol_h sym ;
  eval_result_t result ;
  char const   *cp ;
  char const   *arg_start ;
  char const   *arg_end ;
  canonical_string_const_h sym_def ;
  canonical_string_h symname ;
  canonical_string_h tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  char const   *tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  char const   *tmp___5 ;
  size_t tmp___6 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 643
  result.sym_name = (char *)0;
#line 643
  result.sym_def = (canonical_string_h )0;
#line 643
  result.most_resolved = (canonical_string_h )0;
#line 643
  result.value.val.ll = 0LL;
#line 643
  result.value.type = (int_type )0;
#line 643
  result.flags = 0;
#line 643
  result.line = 0;
#line 644
  cp = *cpp;
#line 645
  arg_start = cp;
#line 647
  sym_def = (canonical_string_const_h )((void *)0);
  {
#line 648
  tmp = canonical_identifier(& cp);
  }
#line 648
  symname = tmp;
  }
#line 649
  if (! ((unsigned int )context == 1U)) {
#line 649
    if (! ((unsigned int )context == 9U)) {
      {
      {
#line 649
      __assert_fail("context == HASH_IF || context == HASH_INCLUDE", "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c",
                    649U, "eval_possible_symbol");
      }
      }
    }
  }
  {
  {
#line 650
  arg_end = chew_macro_call(arg_start);
  }
  }
#line 651
  if ((unsigned long )arg_end > (unsigned long )cp) {
    {
    {
#line 652
    report((reason_code_t )9200, (heap_str *)((void *)0), "Sorry. Function-like macro expansion is not supported: \"%.*s\"",
           arg_end - arg_start, arg_start);
    }
    }
  }
  {
#line 655
  cp = arg_end;
  {
#line 656
  tmp___0 = canonical_string_text((canonical_string_const_h )symname);
  }
  {
#line 656
  sym = configured_symbol_match(tmp___0, (size_t )0);
  }
  }
#line 657
  if (! sym) {
    {
    {
#line 658
    tmp___3 = eligible_line(4, (int )context);
    }
    }
#line 658
    if (tmp___3) {
#line 658
      if (evaluator_state.parsing_sym_def_depth == 0) {
        {
        {
#line 660
        tmp___1 = canonical_string_length((canonical_string_const_h )symname);
        }
        {
#line 660
        tmp___2 = canonical_string_text((canonical_string_const_h )symname);
        }
        {
#line 660
        unconfigured_symbol_tally(tmp___2, tmp___1);
        }
        }
      }
    }
#line 663
    if (args_public_h->implicit) {
      {
      {
#line 664
      eval_result_set_value(& result, & int_spec_false);
      }
      }
    }
  } else {
    {
    {
#line 668
    tmp___4 = eligible_line(4, (int )context);
    }
    }
#line 668
    if (tmp___4) {
#line 668
      if (evaluator_state.parsing_sym_def_depth == 0) {
        {
        {
#line 670
        report_symbol(sym);
        }
        }
      } else {
        {
        {
#line 673
        symbol_resolve(sym, (ptr_vector_h )((void *)0));
        }
        }
      }
    } else {
      {
      {
#line 673
      symbol_resolve(sym, (ptr_vector_h )((void *)0));
      }
      }
    }
#line 675
    if ((unsigned int )context == 1U) {
      {
      {
#line 675
      sym_def = symbol_definition((symbol_const_h )sym);
      }
      }
#line 675
      if (sym_def) {
        {
        {
#line 675
        tmp___6 = canonical_string_length(sym_def);
        }
        }
#line 675
        if (! tmp___6) {
#line 676
          if (evaluator_state.parsing_sym_def_depth == 0) {
            {
            {
#line 677
            tmp___5 = symbol_name((symbol_const_h )sym);
            }
            {
#line 677
            report((reason_code_t )9120, (heap_str *)((void *)0), "Empty symbol \"%s\" in expression",
                   tmp___5);
            }
            }
          }
        }
      }
    }
#line 681
    result = *sym;
  }
#line 683
  *cpp = cp;
#line 684
  return (result);
}
}
#line 798
static line_type_t eval_hash_include(char const   **cpp ) ;
#line 798 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
static int recursions  =    0;
#line 795 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
static line_type_t eval_hash_include(char const   **cpp ) 
{ 
  char const   *cp ;
  line_type_t retval ;
  canonical_string_const_h resolved_val ;
  char const   *arg_start ;
  size_t arg_len ;
  eval_result_t result ;
  char const   *ptext ;
  _Bool invalid ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 799
  cp = *cpp;
#line 800
  retval = (line_type_t )11;
#line 801
  resolved_val = (canonical_string_const_h )((void *)0);
#line 805
  chew_public_h->stop_at_quote = (_Bool)1;
  {
#line 806
  cp = chew_on(cp);
  }
#line 806
  arg_start = cp;
  }
#line 807
  if (! *cp) {
    {
    {
#line 808
    report((reason_code_t )9168, (heap_str *)((void *)0), "#include has no argument");
    }
    }
#line 810
    goto conclusion;
  }
  {
  {
#line 812
  tmp = is_symbol_start_char((char )*cp);
  }
  }
#line 812
  if (tmp) {
    {
    {
#line 813
    result = eval_possible_symbol(& cp, (directive_type_t )9);
    }
#line 814
    arg_len = (size_t )(cp - arg_start);
    }
#line 815
    if (result.most_resolved) {
      {
#line 817
      resolved_val = (canonical_string_const_h )result.most_resolved;
      {
#line 818
      ptext = canonical_string_text(resolved_val);
      }
#line 819
      recursions ++;
      {
#line 820
      retval = eval_hash_include(& ptext);
      }
#line 821
      recursions --;
      }
    } else {
      {
      {
#line 824
      report((reason_code_t )9168, (heap_str *)((void *)0), "\"#include %.*s\": #include requires header name or symbol evaluating to header name",
             arg_len, arg_start);
      }
      }
    }
  } else {
    {
#line 830
    invalid = (_Bool)0;
    {
#line 831
    cp = chew_header_name(arg_start);
    }
#line 832
    arg_len = (size_t )(cp - arg_start);
    }
#line 833
    if (! arg_len) {
      {
#line 834
      invalid = (_Bool)1;
      {
#line 835
      report((reason_code_t )9168, (heap_str *)((void *)0), "\"#include %s\": bad header name",
             arg_start);
      }
      }
    } else
#line 837
    if ((int const   )*arg_start == 34) {
#line 837
      goto _L___0;
    } else
#line 837
    if ((int const   )*arg_start == 60) {
      _L___0: /* CIL Label */ 
#line 838
      if ((int const   )*arg_start == 34) {
#line 838
        if ((int const   )*(cp + -1) != 34) {
          {
#line 839
          invalid = (_Bool)1;
          {
#line 840
          report((reason_code_t )9168, (heap_str *)((void *)0), "\"#include %.*s\": bad local header name",
                 arg_len, arg_start);
          }
          }
        } else
#line 838
        if (arg_len < 3UL) {
          {
#line 839
          invalid = (_Bool)1;
          {
#line 840
          report((reason_code_t )9168, (heap_str *)((void *)0), "\"#include %.*s\": bad local header name",
                 arg_len, arg_start);
          }
          }
        } else {
#line 838
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 841
      if ((int const   )*arg_start == 60) {
#line 841
        if ((int const   )*(cp + -1) != 62) {
          {
#line 842
          invalid = (_Bool)1;
          {
#line 843
          report((reason_code_t )9168, (heap_str *)((void *)0), "\"#include %.*s\": bad system header name",
                 arg_len, arg_start);
          }
          }
        } else
#line 841
        if (arg_len < 3UL) {
          {
#line 842
          invalid = (_Bool)1;
          {
#line 843
          report((reason_code_t )9168, (heap_str *)((void *)0), "\"#include %.*s\": bad system header name",
                 arg_len, arg_start);
          }
          }
        }
      }
    }
#line 846
    if (invalid) {
      {
      {
#line 847
      cp = chew_string(arg_start);
      }
#line 848
      arg_len = (size_t )(cp - arg_start);
      }
    }
  }
#line 851
  if (! recursions) {
    {
    {
#line 851
    tmp___0 = eligible_line(5, 9);
    }
    }
#line 851
    if (tmp___0) {
      {
      {
#line 853
      hash_include_tally(arg_start, arg_len, resolved_val);
      }
      }
    }
  }
  conclusion: 
  {
#line 856
  *cpp = cp;
  {
#line 857
  tmp___1 = dropping_line();
  }
  }
#line 857
  if (tmp___1) {
#line 858
    retval = (line_type_t )10;
  }
#line 860
  return (retval);
}
}
#line 869 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
static char const   *eval_free_form_directive(char const   *cp , directive_type_t directive_type ) 
{ 
  canonical_string_h cs ;
  canonical_string_h tmp ;

  {
  {
  {
#line 872
  tmp = canonical_string_new(cp, (size_t )0, & cp);
  }
#line 872
  cs = tmp;
  {
#line 873
  directive_tally((canonical_string_const_h )cs, directive_type);
  }
  }
#line 874
  return (cp);
}
}
#line 878 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
static eval_result_t eval_table(struct co_precedent_ops  const  *ops , char const   **cpp ,
                                struct operation  const  **pbin_op ) 
{ 
  char const   *start_cut ;
  struct operation  const  *lhs_bin_op ;
  struct operation  const  *rhs_bin_op ;
  eval_result_t lhs_result ;
  eval_result_t tmp ;
  eval_result_t result ;
  char const   *cp ;
  char const   *start_lhs_cut ;
  char const   *end_lhs_cut ;
  struct operation  const  *op ;
  eval_result_t rhs_result ;
  _Bool tmp___0 ;

  {
  {
  {
#line 881
  debug((dbg_code_t )7, ops - eval_ops);
  }
#line 881
  start_cut = *cpp;
#line 883
  lhs_bin_op = (struct operation  const  *)((void *)0);
#line 884
  rhs_bin_op = (struct operation  const  *)((void *)0);
  {
#line 885
  tmp = (*(ops->inner))(ops + 1, cpp, & lhs_bin_op);
  }
#line 885
  lhs_result = tmp;
#line 887
  result = lhs_result;
#line 888
  cp = *cpp;
#line 889
  start_lhs_cut = start_cut;
#line 890
  end_lhs_cut = cp;
  }
#line 891
  if (! ((result.flags & 32) == 32)) {
    {
    {
#line 892
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 892
      cp = chew_on(cp);
      }
      }
#line 892
      if (*cp) {
#line 892
        if (! ((int const   )*cp != 41)) {
#line 892
          goto while_break;
        }
      } else {
#line 892
        goto while_break;
      }
#line 894
      rhs_result.sym_name = (char *)0;
#line 894
      rhs_result.sym_def = (canonical_string_h )0;
#line 894
      rhs_result.most_resolved = (canonical_string_h )0;
#line 894
      rhs_result.value.val.ll = 0LL;
#line 894
      rhs_result.value.type = (int_type )0;
#line 894
      rhs_result.flags = 0;
#line 894
      rhs_result.line = 0;
#line 896
      end_lhs_cut = cp;
#line 898
      op = (struct operation  const  *)(ops->op);
      {
      {
#line 898
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 898
        if ((unsigned long )op->str != (unsigned long )((void *)0)) {
          {
          {
#line 898
          tmp___0 = match_op(& cp, (char const   *)op->str);
          }
          }
#line 898
          if (tmp___0) {
#line 898
            goto while_break___0;
          }
        } else {
#line 898
          goto while_break___0;
        }
#line 898
        op ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 899
      if ((unsigned long )op->str == (unsigned long )((void *)0)) {
#line 901
        if ((unsigned long )ops == (unsigned long )(eval_ops)) {
#line 903
          result.flags |= 32;
        }
#line 908
        goto while_break;
      }
#line 911
      if (pbin_op) {
#line 912
        *pbin_op = (struct operation  const  *)(ops->op);
      }
#line 915
      result.flags &= -5;
#line 916
      if (! ((lhs_result.flags & 24) == 0)) {
#line 916
        if (! ((lhs_result.flags & 3) == 3)) {
#line 918
          if ((lhs_result.flags & 8) == 8) {
#line 918
            if ((unsigned long )op->fn == (unsigned long )(& op_or)) {
              {
              {
#line 920
              cp = short_circuit_or(cp);
              }
              }
#line 922
              goto while_break;
            } else {
#line 918
              goto _L___1;
            }
          } else
          _L___1: /* CIL Label */ 
#line 923
          if ((lhs_result.flags & 16) == 16) {
#line 923
            if ((unsigned long )op->fn == (unsigned long )(& op_and)) {
              {
              {
#line 925
              cp = short_circuit_and(cp);
              }
              }
#line 927
              goto while_break;
            } else {
#line 923
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 928
          if ((lhs_result.flags & 8) == 8) {
#line 928
            if ((unsigned long )op->fn == (unsigned long )(& op_and)) {
              {
              {
#line 931
              cut_text(start_lhs_cut, cp);
              }
              }
            } else {
#line 928
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 928
          if ((lhs_result.flags & 16) == 16) {
#line 928
            if ((unsigned long )op->fn == (unsigned long )(& op_or)) {
              {
              {
#line 931
              cut_text(start_lhs_cut, cp);
              }
              }
            }
          }
        }
      }
      {
#line 934
      start_cut = end_lhs_cut;
#line 935
      end_lhs_cut = cp;
      {
#line 936
      debug((dbg_code_t )9, ops - eval_ops, op->str);
      }
      {
#line 938
      rhs_result = (*(ops->inner))(ops, & cp, & rhs_bin_op);
      }
      {
#line 939
      result = (*(op->fn))(& lhs_result, & rhs_result);
      }
      }
#line 941
      if ((rhs_result.flags & 2) == 2) {
#line 941
        if ((lhs_result.flags & 2) == 2) {
#line 942
          if (! ((lhs_result.flags & 4) == 4)) {
#line 942
            if ((rhs_result.flags & 4) == 4) {
#line 942
              if ((unsigned long )op != (unsigned long )rhs_bin_op) {
                {
                {
#line 943
                restore_paren((size_t )(start_cut - (char const   *)io_public_h->line_start),
                              (size_t )(cp - (char const   *)io_public_h->line_start));
                }
                }
              } else
#line 942
              if ((unsigned long )op != (unsigned long )lhs_bin_op) {
                {
                {
#line 943
                restore_paren((size_t )(start_cut - (char const   *)io_public_h->line_start),
                              (size_t )(cp - (char const   *)io_public_h->line_start));
                }
                }
              } else {
#line 942
                goto _L___3;
              }
            } else {
#line 942
              goto _L___3;
            }
          } else
          _L___3: /* CIL Label */ 
#line 945
          if ((lhs_result.flags & 4) == 4) {
#line 945
            if (! ((rhs_result.flags & 4) == 4)) {
#line 945
              if ((unsigned long )op != (unsigned long )rhs_bin_op) {
                {
                {
#line 946
                restore_paren((size_t )(start_lhs_cut - (char const   *)io_public_h->line_start),
                              (size_t )(end_lhs_cut - (char const   *)io_public_h->line_start));
                }
                }
              } else
#line 945
              if ((unsigned long )op != (unsigned long )lhs_bin_op) {
                {
                {
#line 946
                restore_paren((size_t )(start_lhs_cut - (char const   *)io_public_h->line_start),
                              (size_t )(end_lhs_cut - (char const   *)io_public_h->line_start));
                }
                }
              }
            }
          }
        } else {
#line 941
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ 
#line 950
        if (! ((lhs_result.flags & 2) == 2)) {
#line 952
          result.flags |= 4;
#line 953
          if ((rhs_result.flags & 2) == 2) {
#line 953
            if ((unsigned long )op->fn == (unsigned long )(& op_or)) {
              {
              {
#line 954
              cut_text(start_lhs_cut, end_lhs_cut);
              }
#line 955
              result.flags |= 2;
              }
            } else
#line 953
            if ((unsigned long )op->fn == (unsigned long )(& op_and)) {
              {
              {
#line 954
              cut_text(start_lhs_cut, end_lhs_cut);
              }
#line 955
              result.flags |= 2;
              }
            }
          }
        }
#line 959
        if (! ((rhs_result.flags & 2) == 2)) {
#line 960
          result.flags |= 4;
#line 961
          if ((lhs_result.flags & 2) == 2) {
#line 961
            if ((unsigned long )op->fn == (unsigned long )(& op_or)) {
              {
              {
#line 962
              cut_text(start_cut, cp);
              }
#line 963
              result.flags |= 2;
              }
            } else
#line 961
            if ((unsigned long )op->fn == (unsigned long )(& op_and)) {
              {
              {
#line 962
              cut_text(start_cut, cp);
              }
#line 963
              result.flags |= 2;
              }
            }
          }
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 968
    if ((result.flags & 4) == 4) {
      {
      {
#line 969
      delete_paren((size_t )(start_lhs_cut - (char const   *)io_public_h->line_start),
                   (size_t )(end_lhs_cut - (char const   *)io_public_h->line_start));
      }
      }
    }
#line 971
    if (! ((result.flags & 24) == 0)) {
      {
      {
#line 972
      debug((dbg_code_t )10, ops - eval_ops, result.value);
      }
      }
    } else {
#line 974
      result.flags |= 2;
    }
  }
#line 977
  *cpp = cp;
#line 978
  return (result);
}
}
#line 981 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
static eval_result_t eval_unary(struct co_precedent_ops  const  *ops , char const   **cpp ,
                                struct operation  const  **ignored ) 
{ 
  char const   *ep ;
  eval_result_t result ;
  char const   *cp ;
  canonical_string_h symname ;
  int_spec_t val ;
  char const   *start ;
  size_t tmp ;
  int_spec_t val___0 ;
  int tmp___0 ;
  int tmp___1 ;
  symbol_h sym ;
  _Bool paren ;
  char const   *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  char const   *tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  int_spec_t const   *tmp___9 ;
  canonical_string_const_h tmp___10 ;
  int_spec_t val___1 ;
  int_spec_t tmp___11 ;
  _Bool tmp___12 ;
  _Bool tmp___13 ;
  unsigned short const   **tmp___14 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
  {
#line 985
  result.sym_name = (char *)0;
#line 985
  result.sym_def = (canonical_string_h )0;
#line 985
  result.most_resolved = (canonical_string_h )0;
#line 985
  result.value.val.ll = 0LL;
#line 985
  result.value.type = (int_type )0;
#line 985
  result.flags = 0;
#line 985
  result.line = 0;
#line 987
  result.flags |= 4;
#line 988
  chew_public_h->stop_at_quote = (_Bool)1;
  {
#line 989
  cp = chew_on(*cpp);
  }
#line 990
  chew_public_h->stop_at_quote = (_Bool)0;
#line 991
  symname = (canonical_string_h )((void *)0);
  }
  {
  {
#line 992
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 994
    if ((int const   )*cp == 33) {
      {
      {
#line 995
      debug((dbg_code_t )1, ops - eval_ops);
      }
#line 996
      cp ++;
      {
#line 996
      cp = chew_continuation(cp);
      }
      {
#line 997
      result = eval_unary(ops, & cp, (struct operation  const  **)((void *)0));
      }
      }
#line 998
      if ((result.flags & 24) == 0) {
#line 999
        goto while_break;
      }
      {
      {
#line 1001
      result.value = negate((int_spec_t const   *)(& result.value));
      }
#line 1002
      result.flags ^= 24;
      }
    } else
#line 1003
    if ((int const   )*cp == 126) {
      {
      {
#line 1005
      debug((dbg_code_t )22, ops - eval_ops);
      }
#line 1006
      cp ++;
      {
#line 1006
      cp = chew_continuation(cp);
      }
      {
#line 1007
      result = eval_unary(ops, & cp, (struct operation  const  **)((void *)0));
      }
      }
#line 1008
      if ((result.flags & 24) == 0) {
#line 1009
        goto while_break;
      }
      {
      {
#line 1011
      val = complement((int_spec_t const   *)(& result.value));
      }
      {
#line 1012
      eval_result_set_value(& result, (int_spec_t const   *)(& val));
      }
      }
    } else
#line 1013
    if ((int const   )*cp == 40) {
      {
#line 1014
      start = cp;
#line 1015
      cp ++;
      {
#line 1015
      cp = chew_continuation(cp);
      }
      {
#line 1016
      debug((dbg_code_t )2, ops - eval_ops);
      }
      {
#line 1017
      result = eval_table(eval_ops, & cp, (struct operation  const  **)((void *)0));
      }
      {
#line 1018
      cp = chew_on(cp);
      }
      }
#line 1019
      if ((int const   )*cp != 41) {
#line 1020
        if (evaluator_state.parsing_sym_def_depth == 0) {
          {
          {
#line 1022
          tmp = line_len((char const   *)io_public_h->pristine_line);
          }
          {
#line 1022
          bail(17328, "Missing \")\" in \"%.*s\"", tmp, io_public_h->pristine_line);
          }
          }
        } else {
#line 1027
          result.flags |= 32;
#line 1028
          goto while_break;
        }
      } else
#line 1030
      if ((result.flags & 4) == 4) {
        {
        {
#line 1031
        delete_paren((size_t )(start - (char const   *)io_public_h->line_start), (size_t )(cp - (char const   *)io_public_h->line_start));
        }
        }
      }
      {
#line 1033
      cp ++;
      {
#line 1033
      cp = chew_continuation(cp);
      }
      }
    } else
#line 1034
    if ((int const   )*cp == 43) {
      {
      {
#line 1035
      debug((dbg_code_t )20, ops - eval_ops);
      }
#line 1036
      cp ++;
      {
#line 1036
      cp = chew_continuation(cp);
      }
      {
#line 1037
      result = eval_unary(ops, & cp, (struct operation  const  **)((void *)0));
      }
      }
#line 1038
      goto while_break;
    } else
#line 1039
    if ((int const   )*cp == 45) {
      {
      {
#line 1040
      debug((dbg_code_t )21, ops - eval_ops);
      }
#line 1041
      cp ++;
      {
#line 1041
      cp = chew_continuation(cp);
      }
      {
#line 1042
      result = eval_unary(ops, & cp, (struct operation  const  **)((void *)0));
      }
      {
#line 1043
      result.value = minus((int_spec_t const   *)(& result.value));
      }
      }
    } else {
      {
      {
#line 1044
      tmp___14 = __ctype_b_loc();
      }
      }
#line 1044
      if ((int const   )*(*tmp___14 + (int )((unsigned char )*cp)) & 2048) {
        {
        {
#line 1046
        debug((dbg_code_t )3, ops - eval_ops);
        }
        {
#line 1047
        val___0 = eval_numeral(cp, & ep);
        }
        }
#line 1048
        if ((unsigned int )val___0.type != 393216U) {
#line 1049
          result.value = val___0;
#line 1050
          if (evaluator_state.parsing_sym_def_depth == 0) {
#line 1051
            result.flags |= 1;
#line 1052
            if (args_public_h->eval_consts) {
#line 1053
              if (result.value.val.ull) {
#line 1053
                tmp___0 = 8;
              } else {
#line 1053
                tmp___0 = 16;
              }
#line 1053
              result.flags |= tmp___0;
            }
          } else {
#line 1056
            if (result.value.val.ull) {
#line 1056
              tmp___1 = 8;
            } else {
#line 1056
              tmp___1 = 16;
            }
#line 1056
            result.flags |= tmp___1;
          }
        }
#line 1059
        cp = (char const   *)((char *)ep);
      } else {
        {
        {
#line 1060
        tmp___13 = match_keyword(& cp, "defined");
        }
        }
#line 1060
        if (tmp___13) {
          {
          {
#line 1063
          cp = chew_on(cp);
          }
          {
#line 1064
          debug((dbg_code_t )4, ops - eval_ops);
          }
#line 1065
          paren = (_Bool )((int const   )*cp == 40);
          }
#line 1066
          if (paren) {
            {
#line 1067
            cp ++;
            {
#line 1067
            cp = chew_continuation(cp);
            }
            }
          }
          {
          {
#line 1069
          cp = chew_on(cp);
          }
          {
#line 1070
          symname = canonical_identifier(& cp);
          }
          {
#line 1071
          tmp___2 = canonical_string_text((canonical_string_const_h )symname);
          }
          {
#line 1071
          sym = configured_symbol_match(tmp___2, (size_t )0);
          }
          {
#line 1072
          cp = chew_on(cp);
          }
          }
#line 1073
          if (paren) {
#line 1074
            if ((int const   )*cp == 41) {
              {
#line 1075
              cp ++;
              {
#line 1075
              cp = chew_continuation(cp);
              }
              }
            } else
#line 1078
            if (evaluator_state.parsing_sym_def_depth == 0) {
              {
              {
#line 1079
              tmp___3 = line_len((char const   *)io_public_h->pristine_line);
              }
              {
#line 1079
              bail(17328, (char const   *)((void *)0), "Missing \")\" in \"%.*s\"",
                   tmp___3, io_public_h->pristine_line);
              }
              }
            } else {
#line 1084
              result.flags |= 32;
#line 1085
              goto while_break;
            }
          }
#line 1088
          if (! sym) {
            {
            {
#line 1089
            tmp___6 = eligible_line(4, 1);
            }
            }
#line 1089
            if (tmp___6) {
              {
              {
#line 1090
              tmp___4 = canonical_string_length((canonical_string_const_h )symname);
              }
              {
#line 1090
              tmp___5 = canonical_string_text((canonical_string_const_h )symname);
              }
              {
#line 1090
              unconfigured_symbol_tally(tmp___5, tmp___4);
              }
              }
            }
#line 1093
            if (args_public_h->implicit) {
              {
              {
#line 1094
              eval_result_set_value(& result, & int_spec_false);
              }
              }
            }
#line 1096
            goto while_break;
          } else {
            {
            {
#line 1097
            tmp___7 = eligible_line(4, 1);
            }
            }
#line 1097
            if (tmp___7) {
              {
              {
#line 1098
              report_symbol(sym);
              }
              }
            }
          }
          {
          {
#line 1100
          tmp___10 = symbol_definition((symbol_const_h )sym);
          }
          }
#line 1100
          if ((unsigned long )tmp___10 != (unsigned long )((void *)0)) {
#line 1100
            tmp___9 = & int_spec_true;
          } else {
#line 1100
            tmp___9 = & int_spec_false;
          }
          {
          {
#line 1100
          eval_result_set_value(& result, tmp___9);
          }
          }
        } else
#line 1101
        if ((int const   )*cp == 39) {
#line 1101
          goto _L;
        } else
#line 1101
        if ((int const   )*(cp + 0) == 76) {
          _L: /* CIL Label */ 
          {
          {
#line 1102
          tmp___11 = eval_character_constant(& cp);
          }
#line 1102
          val___1 = tmp___11;
          }
#line 1103
          if ((unsigned int )val___1.type != 393216U) {
            {
            {
#line 1104
            eval_result_set_value(& result, (int_spec_t const   *)(& val___1));
            }
            }
          }
        } else {
          {
          {
#line 1106
          tmp___12 = is_symbol_start_char((char )*cp);
          }
          }
#line 1106
          if (tmp___12) {
            {
            {
#line 1107
            result = eval_possible_symbol(& cp, (directive_type_t )1);
            }
            {
#line 1108
            cp = chew_on(cp);
            }
            }
          } else {
            {
#line 1110
            result.flags |= 32;
            {
#line 1111
            debug((dbg_code_t )6, ops - eval_ops);
            }
            }
#line 1112
            goto while_break;
          }
        }
      }
    }
#line 992
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1115
  *cpp = cp;
#line 1116
  if (! ((result.flags & 24) == 0)) {
    {
    {
#line 1117
    debug((dbg_code_t )8, ops - eval_ops, result.value);
    }
    }
  } else {
#line 1119
    result.flags |= 2;
  }
  {
  {
#line 1121
  canonical_string_dispose(symname);
  }
  }
#line 1122
  return (result);
}
}
#line 1126 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
static int eval_if(char const   **cpp ) 
{ 
  eval_result_t result ;
  char const   *cp ;
  line_type_t lineval ;
  char *__cil_tmp5 ;

  {
  {
#line 1130
  cp = *cpp;
#line 1131
  lineval = (line_type_t )0;
  {
#line 1132
  debug((dbg_code_t )11, *cpp);
  }
  {
#line 1133
  cp = chew_on(cp);
  }
  }
#line 1134
  if (! *cp) {
    {
    {
#line 1135
    bail(17632, "#if/elif has no argument.");
    }
    }
  }
  {
  {
#line 1137
  result = eval_table(eval_ops, & cp, (struct operation  const  **)((void *)0));
  }
  {
#line 1138
  debug((dbg_code_t )12, result.value);
  }
  }
#line 1140
  if ((result.flags & 3) == 3) {
#line 1141
    lineval = (line_type_t )0;
  } else
#line 1143
  if ((result.flags & 8) == 8) {
#line 1144
    lineval = (line_type_t )1;
  } else
#line 1146
  if ((result.flags & 16) == 16) {
#line 1147
    lineval = (line_type_t )2;
  }
#line 1149
  *cpp = cp;
#line 1150
  return ((int )lineval);
}
}
#line 1157 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
line_type_t eval_line(void) 
{ 
  char const   *cp ;
  symbol_h sym ;
  size_t kwlen ;
  line_type_t retval ;
  comment_state_t wascomment ;
  _Bool tmp ;
  size_t kwoff ;
  size_t tmp___0 ;
  char *kwpos ;
  directive_type_t directive ;
  int tmp___1 ;
  canonical_string_h symname ;
  char const   *tmp___2 ;
  _Bool tmp___3 ;
  canonical_string_const_h tmp___4 ;
  size_t tmp___5 ;
  char const   *tmp___6 ;
  _Bool tmp___7 ;
  int tmp___8 ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;
  _Bool tmp___11 ;
  _Bool tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
  {
#line 1166
  tmp = get_line();
  }
  }
#line 1166
  if (! tmp) {
    {
    {
#line 1167
    flush_contradiction();
    }
    {
#line 1168
    transition((line_type_t )9);
    }
    }
#line 1169
    return ((line_type_t )9);
  }
  {
#line 1172
  line_edit_public_h->ops_cut = (_Bool)0;
#line 1173
  line_edit_public_h->parens_deleted = (size_t )0;
#line 1175
  retval = (line_type_t )8;
#line 1176
  wascomment = chew_public_h->comment_state;
  {
#line 1177
  cp = chew_on((char const   *)io_public_h->line_start);
  }
  }
#line 1178
  if ((unsigned int )chew_public_h->line_state == 0U) {
#line 1179
    if ((int const   )*cp == 35) {
      {
#line 1180
      chew_public_h->line_state = (line_state_t )1;
      {
#line 1181
      cp = chew_on(cp + 1);
      }
      }
    } else
#line 1182
    if ((int const   )*cp != 0) {
      {
#line 1183
      chew_public_h->line_state = (line_state_t )2;
      {
#line 1184
      flush_contradiction();
      }
      }
    }
  }
#line 1187
  if ((unsigned int )chew_public_h->comment_state == 0U) {
#line 1187
    if ((unsigned int )chew_public_h->line_state == 1U) {
      {
      {
#line 1189
      tmp___0 = read_offset(cp);
      }
#line 1189
      kwoff = tmp___0;
#line 1192
      chew_public_h->stop_at_quote = (_Bool)0;
#line 1193
      chew_public_h->must_balance_quotes = (_Bool)1;
#line 1194
      evaluator_state.parsing_sym_def_depth = 0;
      {
#line 1195
      kwpos = read_pos(kwoff);
      }
#line 1196
      line_edit_public_h->keyword = kwpos;
      {
#line 1197
      directive = get_directive_type(& cp);
      }
#line 1198
      kwlen = (size_t )(cp - (char const   *)kwpos);
      {
#line 1199
      line_select_public_h->dropping_line = dropping_line();
      }
      }
      {
#line 1201
      if ((unsigned int )directive == 1U) {
#line 1201
        goto case_1;
      }
#line 1206
      if ((unsigned int )directive == 3U) {
#line 1206
        goto case_3;
      }
#line 1206
      if ((unsigned int )directive == 2U) {
#line 1206
        goto case_3;
      }
#line 1235
      if ((unsigned int )directive == 4U) {
#line 1235
        goto case_4;
      }
#line 1238
      if ((unsigned int )directive == 5U) {
#line 1238
        goto case_5;
      }
#line 1241
      if ((unsigned int )directive == 6U) {
#line 1241
        goto case_6;
      }
#line 1244
      if ((unsigned int )directive == 7U) {
#line 1244
        goto case_7;
      }
#line 1247
      if ((unsigned int )directive == 8U) {
#line 1247
        goto case_8;
      }
#line 1250
      if ((unsigned int )directive == 9U) {
#line 1250
        goto case_9;
      }
#line 1253
      if ((unsigned int )directive == 10U) {
#line 1253
        goto case_10;
      }
#line 1259
      if ((unsigned int )directive == 11U) {
#line 1259
        goto case_11;
      }
#line 1279
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 1202
      evaluator_state.ifpos = cp;
      {
#line 1203
      tmp___1 = eval_if(& cp);
      }
#line 1203
      retval = (line_type_t )tmp___1;
      }
#line 1204
      goto switch_break;
      case_3: /* CIL Label */ 
      case_2: /* CIL Label */ 
      {
#line 1207
      symname = (canonical_string_h )((void *)0);
      {
#line 1208
      cp = chew_on(cp);
      }
      {
#line 1209
      symname = canonical_identifier(& cp);
      }
      {
#line 1210
      tmp___2 = canonical_string_text((canonical_string_const_h )symname);
      }
      {
#line 1210
      sym = configured_symbol_match(tmp___2, (size_t )0);
      }
#line 1211
      retval = (line_type_t )0;
      }
#line 1212
      if (sym) {
        {
        {
#line 1213
        tmp___3 = eligible_line(4, (int )directive);
        }
        }
#line 1213
        if (tmp___3) {
          {
          {
#line 1214
          report_symbol(sym);
          }
          }
        }
        {
        {
#line 1216
        tmp___4 = symbol_definition((symbol_const_h )sym);
        }
        }
#line 1216
        if (tmp___4) {
#line 1218
          if ((unsigned int )directive == 2U) {
#line 1218
            retval = (line_type_t )1;
          } else {
#line 1218
            retval = (line_type_t )2;
          }
        } else
#line 1221
        if ((unsigned int )directive == 3U) {
#line 1221
          retval = (line_type_t )1;
        } else {
#line 1221
          retval = (line_type_t )2;
        }
      } else {
        {
        {
#line 1224
        tmp___7 = eligible_line(4, (int )directive);
        }
        }
#line 1224
        if (tmp___7) {
          {
          {
#line 1225
          tmp___5 = canonical_string_length((canonical_string_const_h )symname);
          }
          {
#line 1225
          tmp___6 = canonical_string_text((canonical_string_const_h )symname);
          }
          {
#line 1225
          unconfigured_symbol_tally(tmp___6, tmp___5);
          }
          }
        }
#line 1228
        if (args_public_h->implicit) {
#line 1229
          if ((unsigned int )directive == 2U) {
#line 1229
            retval = (line_type_t )2;
          } else {
#line 1229
            retval = (line_type_t )1;
          }
        }
      }
      {
      {
#line 1232
      canonical_string_dispose(symname);
      }
      }
#line 1234
      goto switch_break;
      case_4: /* CIL Label */ 
#line 1236
      retval = (line_type_t )6;
#line 1237
      goto switch_break;
      case_5: /* CIL Label */ 
      {
      {
#line 1239
      tmp___8 = eval_if(& cp);
      }
#line 1239
      retval = (line_type_t )(tmp___8 + 3);
      }
#line 1240
      goto switch_break;
      case_6: /* CIL Label */ 
#line 1242
      retval = (line_type_t )7;
#line 1243
      goto switch_break;
      case_7: /* CIL Label */ 
      {
      {
#line 1245
      retval = eval_hash_define(& cp);
      }
      }
#line 1246
      goto switch_break;
      case_8: /* CIL Label */ 
      {
      {
#line 1248
      retval = eval_hash_undef(& cp);
      }
      }
#line 1249
      goto switch_break;
      case_9: /* CIL Label */ 
      {
      {
#line 1251
      retval = eval_hash_include(& cp);
      }
      }
#line 1252
      goto switch_break;
      case_10: /* CIL Label */ 
      {
#line 1254
      chew_public_h->must_balance_quotes = (_Bool)0;
      {
#line 1255
      tmp___9 = eligible_line(7, 10);
      }
      }
#line 1255
      if (tmp___9) {
        {
        {
#line 1256
        cp = eval_free_form_directive(cp, (directive_type_t )10);
        }
        }
      }
#line 1258
      goto switch_break;
      case_11: /* CIL Label */ 
      {
#line 1260
      chew_public_h->must_balance_quotes = (_Bool)0;
      {
#line 1261
      tmp___10 = eligible_line(8, 11);
      }
      }
#line 1261
      if (tmp___10) {
        {
        {
#line 1262
        cp = eval_free_form_directive(cp, (directive_type_t )11);
        }
        }
      }
#line 1264
      if (! line_select_public_h->dropping_line) {
        {
#line 1265
        chew_public_h->last_comment_start_line = (size_t )io_public_h->line_num;
        {
#line 1267
        tmp___12 = is_unconditional_line();
        }
        }
#line 1267
        if (tmp___12) {
          {
          {
#line 1268
          set_exit_flags(73736, (_Bool)1);
          }
          {
#line 1269
          tmp___11 = was_unconditional_line();
          }
          }
#line 1269
          if (tmp___11) {
            {
            {
#line 1270
            report((reason_code_t )8272, (heap_str *)((void *)0), "An unconditional #error directive was input");
            }
            }
          } else {
            {
            {
#line 1273
            report((reason_code_t )8272, (heap_str *)((void *)0), "An unconditional #error directive becomes operative");
            }
            }
          }
        }
      }
#line 1278
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
      {
#line 1280
      report((reason_code_t )9152, (heap_str *)((void *)0), "Unknown directive #%.*s",
             kwlen, kwpos);
      }
#line 1282
      chew_public_h->line_state = (line_state_t )2;
#line 1283
      retval = (line_type_t )8;
      }
      switch_break: /* CIL Label */ ;
      }
      {
      {
#line 1285
      cp = chew_on(cp);
      }
      }
#line 1286
      if (*cp) {
#line 1287
        chew_public_h->line_state = (line_state_t )2;
#line 1288
        if ((unsigned int )retval != 8U) {
#line 1289
          if ((int const   )*cp == 41) {
            {
            {
#line 1290
            tmp___13 = line_len((char const   *)io_public_h->pristine_line);
            }
            {
#line 1290
            bail(17328, "Missing \"(\" in \"%.*s\"", tmp___13, io_public_h->pristine_line);
            }
            }
          } else {
            {
            {
#line 1295
            tmp___14 = line_len((char const   *)io_public_h->pristine_line);
            }
            {
#line 1295
            report((reason_code_t )8304, (heap_str *)((void *)0), "Garbage following preprocessor directive in \"%.*s\"",
                   tmp___14, io_public_h->pristine_line);
            }
            }
          }
        }
      }
#line 1302
      if (line_select_public_h->dropping_line) {
        {
        {
#line 1303
        forget_contradiction();
        }
        }
      } else
#line 1305
      if ((unsigned int )directive != 8U) {
        {
        {
#line 1306
        flush_contradiction();
        }
        }
      }
    }
  }
#line 1309
  if ((unsigned int )retval == 11U) {
#line 1311
    retval = (line_type_t )8;
  }
#line 1313
  if ((unsigned int )chew_public_h->line_state == 2U) {
    {
    {
#line 1314
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 1314
      if (! ((int const   )*cp != 0)) {
#line 1314
        goto while_break;
      }
      {
      {
#line 1315
      cp = chew_on(cp + 1);
      }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
  {
#line 1318
  debug((dbg_code_t )17);
  }
  }
#line 1319
  return (retval);
}
}
#line 1322 "/home/wslee/tests/SOURCES/coan-4.2.2/src/evaluator.c"
eval_result_t eval_definition_text(char const   **pdef ) 
{ 
  eval_result_t er ;

  {
  {
#line 1326
  (evaluator_state.parsing_sym_def_depth) ++;
#line 1327
  chew_public_h->in_source = (_Bool)0;
  {
#line 1328
  er = eval_table(eval_ops, pdef, (struct operation  const  **)((void *)0));
  }
#line 1329
  chew_public_h->in_source = (_Bool)1;
#line 1331
  chew_public_h->in_double_quote = (_Bool)0;
#line 1332
  (evaluator_state.parsing_sym_def_depth) --;
  }
#line 1333
  return (er);
}
}
#line 308 "/home/wslee/tests/SOURCES/coan-4.2.2/src/eval_result.h"
_Bool eval_result_parsed(eval_result_t *result ) ;
#line 55 "/home/wslee/tests/SOURCES/coan-4.2.2/src/eval_result.c"
struct int_spec  const  int_spec_false  =    {{0LL}, (int_type )197633};
#line 58 "/home/wslee/tests/SOURCES/coan-4.2.2/src/eval_result.c"
struct int_spec  const  int_spec_true  =    {{1LL}, (int_type )197633};
#line 60 "/home/wslee/tests/SOURCES/coan-4.2.2/src/eval_result.c"
void eval_result_set_value(eval_result_t *result , int_spec_t const   *int_spec ) 
{ 
  int tmp ;

  {
#line 63
  result->value = (int_spec_t )*int_spec;
#line 64
  if (int_spec->val.ull) {
#line 64
    tmp = 8;
  } else {
#line 64
    tmp = 16;
  }
#line 64
  result->flags |= tmp;
#line 65
  return;
}
}
#line 70 "/home/wslee/tests/SOURCES/coan-4.2.2/src/eval_result.c"
static eval_result_t initor  =    {(char *)0, (canonical_string_h )0, (canonical_string_h )0, {{0LL}, (int_type )0},
    0, 0};
#line 67 "/home/wslee/tests/SOURCES/coan-4.2.2/src/eval_result.c"
void eval_result_clear(eval_result_t *result ) 
{ 


  {
#line 71
  if (result) {
#line 72
    if (result->sym_name) {
      {
      {
#line 73
      free((void *)result->sym_name);
      }
#line 74
      result->sym_name = (char *)((void *)0);
      }
    }
#line 76
    if (result->sym_def) {
      {
      {
#line 77
      canonical_string_dispose(result->sym_def);
      }
#line 78
      result->sym_def = (canonical_string_h )((void *)0);
      }
    }
#line 80
    if (result->most_resolved) {
      {
      {
#line 81
      canonical_string_dispose(result->most_resolved);
      }
#line 82
      result->most_resolved = (canonical_string_h )((void *)0);
      }
    }
#line 84
    *result = initor;
  }
#line 86
  return;
}
}
#line 88 "/home/wslee/tests/SOURCES/coan-4.2.2/src/eval_result.c"
_Bool eval_result_parsed(eval_result_t *result ) 
{ 
  int tmp ;

  {
#line 91
  if (! ((result->flags & 24) == 0)) {
#line 91
    tmp = 1;
  } else
#line 91
  if ((result->flags & 2) == 2) {
#line 91
    tmp = 1;
  } else {
#line 91
    tmp = 0;
  }
#line 91
  return ((_Bool )tmp);
}
}
#line 140 "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.h"
int canonical_string_compare(canonical_string_const_h lhs , void const   *rhs , size_t rhslen ) ;
#line 63 "/home/wslee/tests/SOURCES/coan-4.2.2/src/directives_tally.c"
static directives_tally_state_t directives_tally_state  ;
#line 63 "/home/wslee/tests/SOURCES/coan-4.2.2/src/directives_tally.c"
directives_tally_state_t *directives_tally_h  =    & directives_tally_state;
#line 63 "/home/wslee/tests/SOURCES/coan-4.2.2/src/directives_tally.c"
directives_tally_public_state_t *directives_tally_public_h  =    & directives_tally_state;
#line 63 "/home/wslee/tests/SOURCES/coan-4.2.2/src/directives_tally.c"
static directives_tally_state_t const   * const  directives_tally_static_initialiser_h  ;
#line 63
void (*directives_tally_init_h)(directives_tally_state_t * ) ;
#line 63
void (*directives_tally_finis_h)(directives_tally_state_t * ) ;
#line 63 "/home/wslee/tests/SOURCES/coan-4.2.2/src/directives_tally.c"
void directives_tally_initor(void) 
{ 


  {
  {
  {
#line 63
  component_initor((_Bool)1, (_Bool)0, (void **)((char *)(& directives_tally_h)),
                   (void **)((char *)(& directives_tally_public_h)), (void const   *)directives_tally_static_initialiser_h,
                   sizeof(directives_tally_state_t ), (void (*)())directives_tally_init_h);
  }
  }
#line 63
  return;
}
}
#line 63 "/home/wslee/tests/SOURCES/coan-4.2.2/src/directives_tally.c"
void directives_tally_finitor(void) 
{ 


  {
  {
  {
#line 63
  component_finitor((_Bool)1, (void **)((char *)(& directives_tally_h)), (void **)((char *)(& directives_tally_public_h)),
                    (void (*)())directives_tally_init_h);
  }
  }
#line 63
  return;
}
}
#line 65
void directives_tally_init(directives_tally_state_t *st_state ) ;
#line 65 "/home/wslee/tests/SOURCES/coan-4.2.2/src/directives_tally.c"
void (*directives_tally_init_h)(directives_tally_state_t * )  =    & directives_tally_init;
#line 65 "/home/wslee/tests/SOURCES/coan-4.2.2/src/directives_tally.c"
void directives_tally_init(directives_tally_state_t *st_state ) 
{ 


  {
  {
  {
#line 67
  st_state->directives_tab = ptr_vector_new((void (*)(void * ))(& ptr_set_dispose),
                                            (void *(*)(void const   * ))(& ptr_set_copy));
  }
  }
#line 69
  return;
}
}
#line 71
void directives_tally_finis(directives_tally_state_t *st_state ) ;
#line 71 "/home/wslee/tests/SOURCES/coan-4.2.2/src/directives_tally.c"
void (*directives_tally_finis_h)(directives_tally_state_t * )  =    & directives_tally_finis;
#line 71 "/home/wslee/tests/SOURCES/coan-4.2.2/src/directives_tally.c"
void directives_tally_finis(directives_tally_state_t *st_state ) 
{ 


  {
  {
  {
#line 73
  ptr_vector_dispose(st_state->directives_tab);
  }
  }
#line 74
  return;
}
}
#line 91 "/home/wslee/tests/SOURCES/coan-4.2.2/src/directives_tally.c"
static directive_t const   directives_dict[12]  = 
#line 91
  {      {(directive_type_t )1, "if"}, 
        {(directive_type_t )2, "ifdef"}, 
        {(directive_type_t )3, "ifndef"}, 
        {(directive_type_t )4, "else"}, 
        {(directive_type_t )5, "elif"}, 
        {(directive_type_t )6, "endif"}, 
        {(directive_type_t )7, "define"}, 
        {(directive_type_t )8, "undef"}, 
        {(directive_type_t )9, "include"}, 
        {(directive_type_t )10, "pragma"}, 
        {(directive_type_t )11, "error"}, 
        {(directive_type_t )0, (char const   *)((void *)0)}};
#line 116 "/home/wslee/tests/SOURCES/coan-4.2.2/src/directives_tally.c"
static canonical_string_const_h directive_text_lookup(canonical_string_const_h cl ,
                                                      directive_type_t directive_type ) 
{ 
  canonical_string_h found ;
  char const   *text ;
  char const   *tmp ;
  ptr_vector_h directives_tab ;
  size_t ntypes ;
  size_t tmp___0 ;
  ptr_set_h directive_tab ;
  ptr_set_h tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 119
  found = (canonical_string_h )((void *)0);
  {
#line 120
  tmp = canonical_string_text(cl);
  }
#line 120
  text = tmp;
#line 121
  directives_tab = directives_tally_state.directives_tab;
  {
#line 122
  tmp___0 = ptr_vector_count((ptr_vector_const_h )directives_tab);
  }
#line 122
  ntypes = tmp___0;
#line 123
  directive_tab = (ptr_set_h )((void *)0);
  }
  {
  {
#line 124
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 124
    if (! (ntypes <= (size_t )directive_type)) {
#line 124
      goto while_break;
    }
    {
    {
#line 125
    tmp___1 = ptr_set_new((int (*)(void const   *obj , void const   *key , locator_t keylen ))(& canonical_string_compare),
                          (void (*)(void * ))(& canonical_string_dispose), (void *(*)(void const   * ))(& canonical_string_copy));
    }
    {
#line 125
    ptr_vector_append(directives_tab, (void *)tmp___1);
    }
#line 124
    ntypes ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 131
  tmp___2 = ptr_vector_at(directives_tab, (size_t )directive_type);
  }
#line 131
  directive_tab = (ptr_set_h )tmp___2;
  {
#line 132
  tmp___3 = strlen(text);
  }
  {
#line 132
  tmp___4 = ptr_set_search(directive_tab, text, (locator_t )tmp___3);
  }
#line 132
  found = (canonical_string_h )tmp___4;
  }
#line 133
  return ((canonical_string_const_h )found);
}
}
#line 142 "/home/wslee/tests/SOURCES/coan-4.2.2/src/directives_tally.c"
static void directive_text_add(canonical_string_const_h cl , directive_type_t directive_type ) 
{ 
  ptr_vector_h directives_tab ;
  ptr_set_h directive_tab ;
  void *tmp ;

  {
  {
#line 145
  directives_tab = directives_tally_state.directives_tab;
  {
#line 146
  tmp = ptr_vector_at(directives_tab, (size_t )directive_type);
  }
#line 146
  directive_tab = (ptr_set_h )tmp;
  {
#line 147
  ptr_set_insert(directive_tab, (void const   *)cl);
  }
  }
#line 148
  return;
}
}
#line 154 "/home/wslee/tests/SOURCES/coan-4.2.2/src/directives_tally.c"
directive_type_t get_directive_type(char const   **keyword ) 
{ 
  directive_t const   *directive ;
  _Bool tmp ;

  {
#line 157
  directive = directives_dict;
  {
  {
#line 158
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 158
    if (! ((unsigned int const   )directive->type != 0U)) {
#line 158
      goto while_break;
    }
    {
    {
#line 159
    tmp = match_keyword(keyword, (char const   *)directive->keyword);
    }
    }
#line 159
    if (tmp) {
#line 160
      goto while_break;
    }
#line 158
    directive ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 163
  return ((directive_type_t )directive->type);
}
}
#line 166 "/home/wslee/tests/SOURCES/coan-4.2.2/src/directives_tally.c"
char const   *get_directive_keyword(directive_type_t directive_type ) 
{ 
  directive_t const   *directive ;

  {
#line 169
  directive = directives_dict;
  {
  {
#line 170
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 170
    if (! ((unsigned int const   )directive->type != 0U)) {
#line 170
      goto while_break;
    }
#line 171
    if ((unsigned int const   )directive->type == (unsigned int const   )directive_type) {
#line 172
      goto while_break;
    }
#line 170
    directive ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  return ((char const   *)directive->keyword);
}
}
#line 178 "/home/wslee/tests/SOURCES/coan-4.2.2/src/directives_tally.c"
void directive_tally(canonical_string_const_h cl , directive_type_t directive_type ) 
{ 
  canonical_string_const_h found ;
  canonical_string_const_h tmp ;

  {
  {
  {
#line 181
  tmp = directive_text_lookup(cl, directive_type);
  }
#line 181
  found = tmp;
  }
#line 182
  if (! found) {
    {
    {
#line 183
    directive_text_add(cl, directive_type);
    }
    {
#line 184
    report_directive(cl, directive_type);
    }
    }
  } else
#line 185
  if (! args_public_h->list_only_once) {
    {
    {
#line 186
    report_directive(found, directive_type);
    }
    }
  }
#line 188
  return;
}
}
#line 57 "/home/wslee/tests/SOURCES/coan-4.2.2/src/dataset.h"
void dataset_filter_filetypes(char const   *optarg___0 ) ;
#line 73
void dataset_add(char const   *path ) ;
#line 94
void dataset_finitor(void) ;
#line 63 "/home/wslee/tests/SOURCES/coan-4.2.2/src/dataset.c"
static dataset_state_t dataset_state  ;
#line 63 "/home/wslee/tests/SOURCES/coan-4.2.2/src/dataset.c"
dataset_state_t *dataset_h  =    & dataset_state;
#line 63 "/home/wslee/tests/SOURCES/coan-4.2.2/src/dataset.c"
dataset_public_state_t *dataset_public_h  =    (dataset_public_state_t *)(& dataset_state);
#line 63 "/home/wslee/tests/SOURCES/coan-4.2.2/src/dataset.c"
static dataset_state_t const   * const  dataset_static_initialiser_h  ;
#line 63
void (*dataset_init_h)(dataset_state_t * ) ;
#line 63
void (*dataset_finis_h)(dataset_state_t * ) ;
#line 63 "/home/wslee/tests/SOURCES/coan-4.2.2/src/dataset.c"
void dataset_initor(void) 
{ 


  {
  {
  {
#line 63
  component_initor((_Bool)1, (_Bool)0, (void **)((char *)(& dataset_h)), (void **)((char *)(& dataset_public_h)),
                   (void const   *)dataset_static_initialiser_h, sizeof(dataset_state_t ),
                   (void (*)())dataset_init_h);
  }
  }
#line 63
  return;
}
}
#line 63 "/home/wslee/tests/SOURCES/coan-4.2.2/src/dataset.c"
void dataset_finitor(void) 
{ 


  {
  {
  {
#line 63
  component_finitor((_Bool)1, (void **)((char *)(& dataset_h)), (void **)((char *)(& dataset_public_h)),
                    (void (*)())dataset_init_h);
  }
  }
#line 63
  return;
}
}
#line 65
void dataset_init(dataset_state_t *dataset_st ) ;
#line 65 "/home/wslee/tests/SOURCES/coan-4.2.2/src/dataset.c"
void (*dataset_init_h)(dataset_state_t * )  =    & dataset_init;
#line 65 "/home/wslee/tests/SOURCES/coan-4.2.2/src/dataset.c"
void dataset_init(dataset_state_t *dataset_st ) 
{ 


  {
  {
  {
#line 67
  dataset_st->dataset_public_state.file_tree = file_tree_new();
  }
  }
#line 68
  return;
}
}
#line 70
void dataset_finis(dataset_state_t *dataset_st ) ;
#line 70 "/home/wslee/tests/SOURCES/coan-4.2.2/src/dataset.c"
void (*dataset_finis_h)(dataset_state_t * )  =    & dataset_finis;
#line 70 "/home/wslee/tests/SOURCES/coan-4.2.2/src/dataset.c"
void dataset_finis(dataset_state_t *dataset_st ) 
{ 


  {
  {
  {
#line 72
  file_tree_dispose(dataset_public_h->file_tree);
  }
#line 73
  dataset_public_h->file_tree = (file_tree_h )((void *)0);
  {
#line 74
  free((void *)dataset_state.filter_types);
  }
  }
#line 75
  return;
}
}
#line 85 "/home/wslee/tests/SOURCES/coan-4.2.2/src/dataset.c"
static _Bool filter_filename(char const   *filename ) 
{ 
  char const   *filter_filetypes ;
  char const   *leafname ;
  char *tmp ;
  char const   *extension ;
  size_t ext_len ;
  char *posn ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 88
  filter_filetypes = (char const   *)dataset_state.filter_types;
  {
#line 89
  tmp = strrchr(filename, '/');
  }
#line 89
  leafname = (char const   *)tmp;
  }
#line 90
  if (! leafname) {
#line 91
    leafname = filename;
  }
#line 93
  if (filter_filetypes) {
#line 94
    extension = filter_filetypes;
    {
    {
#line 96
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 96
      if (! *extension) {
#line 96
        goto while_break;
      }
      {
      {
#line 97
      tmp___0 = strrchr(leafname, '.');
      }
#line 97
      posn = tmp___0;
      {
#line 98
      ext_len = strlen(extension);
      }
      }
#line 99
      if (posn) {
#line 99
        if (*(posn + 1)) {
          {
#line 100
          posn ++;
          {
#line 100
          tmp___1 = strcmp((char const   *)posn, extension);
          }
          }
#line 100
          if (! tmp___1) {
#line 101
            return ((_Bool)1);
          }
        }
      }
#line 96
      extension += ext_len + 1UL;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 106
  return ((_Bool)0);
}
}
#line 120 "/home/wslee/tests/SOURCES/coan-4.2.2/src/dataset.c"
static void build_proc(file_tree_h ft , char const   *name , file_tree_traverse_state_t context ) 
{ 
  size_t tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 126
  if ((int )context == -1) {
#line 126
    goto case_neg_1;
  }
#line 129
  if ((int )context == 0) {
#line 129
    goto case_0;
  }
#line 132
  if ((int )context == 1) {
#line 132
    goto case_1;
  }
#line 139
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
  {
#line 127
  report((reason_code_t )2848, (heap_str *)((void *)0), "Searching dir \"%s\"", name);
  }
  }
#line 128
  goto switch_break;
  case_0: /* CIL Label */ 
  {
  {
#line 130
  report((reason_code_t )2864, (heap_str *)((void *)0), "Added file \"%s\"", name);
  }
  }
#line 131
  goto switch_break;
  case_1: /* CIL Label */ 
  {
  {
#line 133
  tmp = file_tree_count((file_tree_const_h )ft, 1U, (file_tree_count_t *)((void *)0));
  }
  {
#line 133
  report((reason_code_t )2880, (heap_str *)((void *)0), "Added %d files from dir \"%s\"",
         tmp, name);
  }
  }
#line 138
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 140
  __assert_fail("0", "/home/wslee/tests/SOURCES/coan-4.2.2/src/dataset.c", 140U, "build_proc");
  }
  }
  switch_break: /* CIL Label */ ;
  }
#line 142
  return;
}
}
#line 148 "/home/wslee/tests/SOURCES/coan-4.2.2/src/dataset.c"
void dataset_filter_filetypes(char const   *optarg___0 ) 
{ 
  size_t len ;
  size_t tmp ;
  heap_str list ;
  void *tmp___0 ;

  {
  {
  {
#line 151
  tmp = strlen(optarg___0);
  }
#line 151
  len = tmp;
  {
#line 152
  tmp___0 = zallocate(len + 2UL);
  }
#line 152
  dataset_state.filter_types = (heap_str )tmp___0;
#line 152
  list = dataset_state.filter_types;
  {
#line 153
  strcpy((char */* __restrict  */)list, (char const   */* __restrict  */)optarg___0);
  }
#line 154
  *(list + (len + 1UL)) = (char )'\000';
  }
  {
  {
#line 155
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 155
    len --;
#line 155
    if (! len) {
#line 155
      goto while_break;
    }
#line 156
    if ((int )*(list + len) == 44) {
#line 157
      *(list + len) = (char )'\000';
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 160
  file_tree_set_filter(dataset_public_h->file_tree, & filter_filename);
  }
  }
#line 161
  return;
}
}
#line 163 "/home/wslee/tests/SOURCES/coan-4.2.2/src/dataset.c"
void dataset_add(char const   *path ) 
{ 


  {
  {
  {
#line 166
  file_tree_add(dataset_public_h->file_tree, path, & build_proc);
  }
  }
#line 167
  return;
}
}
#line 59 "/home/wslee/tests/SOURCES/coan-4.2.2/src/configured_symbols.h"
symbol_h configured_symbol_seek(char const   **cpp ) ;
#line 69
symbol_const_h configured_symbol_seek_const(char const   **cpp ) ;
#line 83
symbol_const_h configured_symbol_match_const(char const   *symname , size_t namelen ) ;
#line 134
configured_symbols_public_state_t *configured_symbols_public_h ;
#line 134
void configured_symbols_finitor(void) ;
#line 52 "/home/wslee/tests/SOURCES/coan-4.2.2/src/configured_symbols.c"
static configured_symbols_state_t configured_symbols_state  ;
#line 52 "/home/wslee/tests/SOURCES/coan-4.2.2/src/configured_symbols.c"
configured_symbols_state_t *configured_symbols_h  =    & configured_symbols_state;
#line 52 "/home/wslee/tests/SOURCES/coan-4.2.2/src/configured_symbols.c"
configured_symbols_public_state_t *configured_symbols_public_h  =    & configured_symbols_state;
#line 52 "/home/wslee/tests/SOURCES/coan-4.2.2/src/configured_symbols.c"
static configured_symbols_state_t const   * const  configured_symbols_static_initialiser_h  ;
#line 52
void (*configured_symbols_init_h)(configured_symbols_state_t * ) ;
#line 52
void (*configured_symbols_finis_h)(configured_symbols_state_t * ) ;
#line 52 "/home/wslee/tests/SOURCES/coan-4.2.2/src/configured_symbols.c"
void configured_symbols_initor(void) 
{ 


  {
  {
  {
#line 52
  component_initor((_Bool)1, (_Bool)0, (void **)((char *)(& configured_symbols_h)),
                   (void **)((char *)(& configured_symbols_public_h)), (void const   *)configured_symbols_static_initialiser_h,
                   sizeof(configured_symbols_state_t ), (void (*)())configured_symbols_init_h);
  }
  }
#line 52
  return;
}
}
#line 52 "/home/wslee/tests/SOURCES/coan-4.2.2/src/configured_symbols.c"
void configured_symbols_finitor(void) 
{ 


  {
  {
  {
#line 52
  component_finitor((_Bool)1, (void **)((char *)(& configured_symbols_h)), (void **)((char *)(& configured_symbols_public_h)),
                    (void (*)())configured_symbols_init_h);
  }
  }
#line 52
  return;
}
}
#line 54
void configured_symbols_init(configured_symbols_state_t *st_state ) ;
#line 54 "/home/wslee/tests/SOURCES/coan-4.2.2/src/configured_symbols.c"
void (*configured_symbols_init_h)(configured_symbols_state_t * )  =    & configured_symbols_init;
#line 54 "/home/wslee/tests/SOURCES/coan-4.2.2/src/configured_symbols.c"
void configured_symbols_init(configured_symbols_state_t *st_state ) 
{ 


  {
  {
  {
#line 56
  st_state->global_sym_tab = ptr_set_new((int (*)(void const   *obj , void const   *key ,
                                                  locator_t keylen ))(& symbol_compare),
                                         (void (*)(void * ))(& symbol_dispose), (void *(*)(void const   * ))(& symbol_copy));
  }
  {
#line 60
  st_state->sym_tab = ptr_set_new((int (*)(void const   *obj , void const   *key ,
                                           locator_t keylen ))(& symbol_compare),
                                  (void (*)(void * ))(& symbol_dispose), (void *(*)(void const   * ))(& symbol_copy));
  }
  }
#line 64
  return;
}
}
#line 66
void configured_symbols_finis(configured_symbols_state_t *st_state ) ;
#line 66 "/home/wslee/tests/SOURCES/coan-4.2.2/src/configured_symbols.c"
void (*configured_symbols_finis_h)(configured_symbols_state_t * )  =    & configured_symbols_finis;
#line 66 "/home/wslee/tests/SOURCES/coan-4.2.2/src/configured_symbols.c"
void configured_symbols_finis(configured_symbols_state_t *st_state ) 
{ 


  {
  {
  {
#line 68
  ptr_set_dispose(st_state->global_sym_tab);
  }
  {
#line 69
  ptr_set_dispose(st_state->sym_tab);
  }
  }
#line 70
  return;
}
}
#line 75 "/home/wslee/tests/SOURCES/coan-4.2.2/src/configured_symbols.c"
symbol_const_h configured_symbol_seek_const(char const   **cpp ) 
{ 
  canonical_string_h symname ;
  canonical_string_h tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  symbol_const_h tmp___2 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 78
  if (! cpp) {
    {
    {
#line 78
    __assert_fail("cpp", "/home/wslee/tests/SOURCES/coan-4.2.2/src/configured_symbols.c",
                  78U, "configured_symbol_seek_const");
    }
    }
  }
  {
  {
#line 79
  tmp = canonical_identifier(cpp);
  }
#line 79
  symname = tmp;
  {
#line 80
  tmp___0 = canonical_string_text((canonical_string_const_h )symname);
  }
  }
#line 80
  if (! *tmp___0) {
    {
    {
#line 81
    bail(16912, "Identifier needed instead of \"%s\"", *cpp);
    }
    }
  }
  {
  {
#line 85
  tmp___1 = canonical_string_text((canonical_string_const_h )symname);
  }
  {
#line 85
  tmp___2 = configured_symbol_match_const(tmp___1, (size_t )0);
  }
  }
#line 85
  return (tmp___2);
}
}
#line 88 "/home/wslee/tests/SOURCES/coan-4.2.2/src/configured_symbols.c"
symbol_h configured_symbol_seek(char const   **cpp ) 
{ 
  symbol_const_h tmp ;

  {
  {
  {
#line 91
  tmp = configured_symbol_seek_const(cpp);
  }
  }
#line 91
  return ((symbol_h )tmp);
}
}
#line 94 "/home/wslee/tests/SOURCES/coan-4.2.2/src/configured_symbols.c"
symbol_const_h configured_symbol_match_const(char const   *symname , size_t namelen ) 
{ 
  symbol_const_h sym ;
  ptr_set_h sym_tab ;
  ptr_set_h tmp ;
  void *tmp___0 ;
  canonical_string_const_h tmp___1 ;
  char const   *tmp___2 ;
  _Bool tmp___3 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 97
  sym = (symbol_const_h )((void *)0);
#line 98
  if (! symname) {
    {
    {
#line 98
    __assert_fail("symname", "/home/wslee/tests/SOURCES/coan-4.2.2/src/configured_symbols.c",
                  98U, "configured_symbol_match_const");
    }
    }
  }
#line 99
  if (io_public_h->line_num != 0) {
#line 99
    tmp = configured_symbols_public_h->sym_tab;
  } else {
#line 99
    tmp = configured_symbols_public_h->global_sym_tab;
  }
#line 99
  sym_tab = tmp;
#line 101
  if (*(symname + 0)) {
#line 102
    if (! namelen) {
      {
      {
#line 103
      namelen = strlen(symname);
      }
      }
    }
    {
    {
#line 105
    tmp___0 = ptr_set_search(sym_tab, symname, (locator_t )namelen);
    }
#line 105
    sym = (symbol_const_h )tmp___0;
    }
#line 106
    if (sym) {
      {
      {
#line 107
      tmp___1 = symbol_definition(sym);
      }
      {
#line 107
      tmp___2 = symbol_name(sym);
      }
      {
#line 107
      debug((dbg_code_t )18, tmp___2, tmp___1);
      }
      {
#line 108
      tmp___3 = symbol_is_configured(sym);
      }
      }
#line 108
      if (! tmp___3) {
#line 109
        sym = (symbol_const_h )((void *)0);
      }
    }
  }
#line 113
  return (sym);
}
}
#line 116 "/home/wslee/tests/SOURCES/coan-4.2.2/src/configured_symbols.c"
symbol_h configured_symbol_match(char const   *symname , size_t namelen ) 
{ 
  symbol_const_h tmp ;

  {
  {
  {
#line 119
  tmp = configured_symbol_match_const(symname, namelen);
  }
  }
#line 119
  return ((symbol_h )tmp);
}
}
#line 122 "/home/wslee/tests/SOURCES/coan-4.2.2/src/configured_symbols.c"
line_type_t configured_symbol_add(_Bool define , symbol_h sym , char const   *tail ,
                                  char const   **pend ) 
{ 
  ptr_set_h sym_tab ;
  ptr_set_h tmp ;
  line_type_t retval ;
  line_type_t tmp___0 ;
  line_type_t tmp___1 ;
  unsigned int tmp___2 ;
  _Bool tmp___3 ;

  {
#line 125
  if (io_public_h->line_num != 0) {
#line 125
    tmp = configured_symbols_public_h->sym_tab;
  } else {
#line 125
    tmp = configured_symbols_public_h->global_sym_tab;
  }
#line 125
  sym_tab = tmp;
#line 126
  if (define) {
    {
    {
#line 126
    tmp___0 = symbol_define(sym, tail, pend);
    }
#line 126
    tmp___2 = (unsigned int )tmp___0;
    }
  } else {
    {
    {
#line 126
    tmp___1 = symbol_undefine(sym, tail, pend);
    }
#line 126
    tmp___2 = (unsigned int )tmp___1;
    }
  }
#line 126
  retval = (line_type_t )tmp___2;
#line 127
  if ((unsigned int )retval == 11U) {
    {
    {
#line 127
    tmp___3 = symbol_is_configured((symbol_const_h )sym);
    }
    }
#line 127
    if (tmp___3) {
      {
      {
#line 128
      ptr_set_insert(sym_tab, (void const   *)sym);
      }
      }
    }
  }
#line 130
  return (retval);
}
}
#line 133 "/home/wslee/tests/SOURCES/coan-4.2.2/src/configured_symbols.c"
void configured_symbols_rewind(void) 
{ 


  {
  {
  {
#line 136
  ptr_set_assign(configured_symbols_public_h->sym_tab, (ptr_set_const_h )configured_symbols_public_h->global_sym_tab);
  }
  }
#line 137
  return;
}
}
#line 139 "/home/wslee/tests/SOURCES/coan-4.2.2/src/configured_symbols.c"
symbol_h configured_symbol_find(canonical_string_const_h cs , size_t *start ) 
{ 
  size_t offset ;
  ptr_set_const_h ps ;
  symbol_h hit ;
  symbol_h *psym ;
  symbol_h *pend ;
  char const   *text ;
  char const   *tmp ;
  char const   *textend ;
  size_t tmp___0 ;
  void const   **tmp___1 ;
  void const   **tmp___2 ;
  symbol_h sym ;
  char const   *symname ;
  char const   *tmp___3 ;
  char const   *where ;
  char *tmp___4 ;
  char const   *symend ;
  size_t tmp___5 ;
  char const   *tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  size_t tmp___9 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 144
  hit = (symbol_h )((void *)0);
#line 145
  if (! cs) {
    {
    {
#line 145
    __assert_fail("cs", "/home/wslee/tests/SOURCES/coan-4.2.2/src/configured_symbols.c",
                  145U, "configured_symbol_find");
    }
    }
  }
#line 146
  if (! start) {
    {
    {
#line 146
    __assert_fail("start", "/home/wslee/tests/SOURCES/coan-4.2.2/src/configured_symbols.c",
                  146U, "configured_symbol_find");
    }
    }
  }
  {
#line 147
  offset = *start;
  {
#line 148
  tmp___9 = canonical_string_length(cs);
  }
  }
#line 148
  if (offset < tmp___9) {
    {
    {
#line 151
    tmp = canonical_string_text(cs);
    }
#line 151
    text = tmp + offset;
    {
#line 152
    tmp___0 = strlen(text);
    }
#line 152
    textend = text + tmp___0;
#line 153
    ps = (ptr_set_const_h )configured_symbols_public_h->sym_tab;
    {
#line 154
    tmp___1 = ptr_set_begin_const(ps);
    }
#line 154
    psym = (symbol_h *)tmp___1;
    {
#line 155
    tmp___2 = ptr_set_end_const(ps);
    }
#line 155
    pend = (symbol_h *)tmp___2;
    }
    {
    {
#line 156
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 156
      if ((unsigned long )psym < (unsigned long )pend) {
#line 156
        if (! (! hit)) {
#line 156
          goto while_break;
        }
      } else {
#line 156
        goto while_break;
      }
      {
#line 157
      sym = *psym;
      {
#line 158
      tmp___3 = symbol_name((symbol_const_h )sym);
      }
#line 158
      symname = tmp___3;
      {
#line 159
      tmp___4 = strstr(text, symname);
      }
#line 159
      where = (char const   *)tmp___4;
      }
#line 160
      if (where) {
        {
        {
#line 161
        tmp___5 = strlen(symname);
        }
#line 161
        symend = where + tmp___5;
        }
#line 162
        if ((unsigned long )where == (unsigned long )text) {
#line 162
          goto _L;
        } else {
          {
          {
#line 162
          tmp___7 = is_symbol_inner_char((char )*(where + -1));
          }
          }
#line 162
          if (! tmp___7) {
            _L: /* CIL Label */ 
#line 162
            if ((unsigned long )symend == (unsigned long )textend) {
              {
              {
#line 164
              tmp___6 = canonical_string_text(cs);
              }
#line 164
              *start = (size_t )(where - tmp___6);
#line 165
              hit = sym;
              }
            } else {
              {
              {
#line 162
              tmp___8 = is_symbol_inner_char((char )*(symend + 0));
              }
              }
#line 162
              if (! tmp___8) {
                {
                {
#line 164
                tmp___6 = canonical_string_text(cs);
                }
#line 164
                *start = (size_t )(where - tmp___6);
#line 165
                hit = sym;
                }
              }
            }
          }
        }
      }
#line 156
      psym ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 170
  return (hit);
}
}
#line 176 "/home/wslee/tests/SOURCES/coan-4.2.2/src/chew.h"
char const   *chew_unbroken_string(char const   *cp ) ;
#line 212
void chew_finitor(void) ;
#line 86 "/home/wslee/tests/SOURCES/coan-4.2.2/src/chew.c"
static chew_state_t chew_state  ;
#line 86 "/home/wslee/tests/SOURCES/coan-4.2.2/src/chew.c"
chew_state_t *chew_h  =    & chew_state;
#line 86 "/home/wslee/tests/SOURCES/coan-4.2.2/src/chew.c"
chew_public_state_t *chew_public_h  =    (chew_public_state_t *)(& chew_state);
#line 86 "/home/wslee/tests/SOURCES/coan-4.2.2/src/chew.c"
static chew_state_t const   * const  chew_static_initialiser_h  ;
#line 86 "/home/wslee/tests/SOURCES/coan-4.2.2/src/chew.c"
void (*chew_init_h)(chew_state_t * )  ;
#line 86 "/home/wslee/tests/SOURCES/coan-4.2.2/src/chew.c"
void (*chew_finis_h)(chew_state_t * )  ;
#line 86 "/home/wslee/tests/SOURCES/coan-4.2.2/src/chew.c"
void chew_initor(void) 
{ 


  {
  {
  {
#line 86
  component_initor((_Bool)1, (_Bool)1, (void **)((char *)(& chew_h)), (void **)((char *)(& chew_public_h)),
                   (void const   *)chew_static_initialiser_h, sizeof(chew_state_t ),
                   (void (*)())chew_init_h);
  }
  }
#line 86
  return;
}
}
#line 86 "/home/wslee/tests/SOURCES/coan-4.2.2/src/chew.c"
void chew_finitor(void) 
{ 


  {
  {
  {
#line 86
  component_finitor((_Bool)1, (void **)((char *)(& chew_h)), (void **)((char *)(& chew_public_h)),
                    (void (*)())chew_init_h);
  }
  }
#line 86
  return;
}
}
#line 124 "/home/wslee/tests/SOURCES/coan-4.2.2/src/chew.c"
static _Bool is_line_continuation(char const   *cp ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
#line 127
  if ((int const   )*cp == 92) {
    {
    {
#line 127
    tmp = eol(cp + 1);
    }
    }
#line 127
    if (tmp) {
#line 127
      tmp___0 = 1;
    } else {
#line 127
      tmp___0 = 0;
    }
  } else {
#line 127
    tmp___0 = 0;
  }
#line 127
  return ((_Bool )tmp___0);
}
}
#line 133 "/home/wslee/tests/SOURCES/coan-4.2.2/src/chew.c"
char const   *chew_continuation(char const   *cp ) 
{ 
  size_t nl_len ;
  char *tmp ;

  {
  {
  {
#line 137
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 137
    if ((int const   )*(cp + 0) == 92) {
      {
      {
#line 137
      nl_len = eol(cp + 1);
      }
      }
#line 137
      if (! nl_len) {
#line 137
        goto while_break;
      }
    } else {
#line 137
      goto while_break;
    }
#line 138
    if ((int const   )*(cp + (nl_len + 1UL)) == 0) {
      {
      {
#line 139
      tmp = read_more(cp);
      }
#line 139
      cp = (char const   *)tmp;
      }
    }
#line 137
    cp += nl_len + 1UL;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  return (cp);
}
}
#line 145 "/home/wslee/tests/SOURCES/coan-4.2.2/src/chew.c"
char const   *chew_symbol(char const   *cp ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;

  {
  {
  {
#line 148
  tmp___0 = is_symbol_start_char((char )*cp);
  }
  }
#line 148
  if (tmp___0) {
    {
    {
#line 149
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 149
      tmp = is_symbol_inner_char((char )*cp);
      }
      }
#line 149
      if (! tmp) {
#line 149
        goto while_break;
      }
      {
#line 149
      cp ++;
      {
#line 149
      cp = chew_continuation(cp);
      }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 151
  return (cp);
}
}
#line 154 "/home/wslee/tests/SOURCES/coan-4.2.2/src/chew.c"
char const   *chew_string(char const   *cp ) 
{ 
  char const   *save ;
  size_t tmp ;
  size_t read_off ;
  size_t tmp___0 ;
  char const   *leader ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *__cil_tmp10 ;

  {
#line 157
  save = cp;
#line 158
  if ((int const   )*cp == 34) {
#line 159
    cp ++;
    {
    {
#line 159
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 159
      if (*cp) {
#line 159
        if ((int const   )*cp != 34) {
          {
          {
#line 159
          tmp = eol(cp);
          }
          }
#line 159
          if (tmp) {
#line 159
            goto while_break;
          }
        } else {
#line 159
          goto while_break;
        }
      } else {
#line 159
        goto while_break;
      }
      {
#line 159
      cp ++;
      {
#line 159
      cp = chew_continuation(cp);
      }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 161
    if (! *cp) {
#line 161
      if (chew_public_h->in_source) {
        {
        {
#line 162
        report((reason_code_t )9232, (heap_str *)((void *)0), "Unclosed quotation in context \"%s\"",
               save);
        }
        }
      }
    }
#line 165
    cp ++;
  } else {
    {
    {
#line 166
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 166
      tmp___3 = __ctype_b_loc();
      }
      }
#line 166
      if (! ((int const   )*(*tmp___3 + (int )*cp) & 32768)) {
#line 166
        goto while_break___0;
      }
      {
      {
#line 167
      tmp___0 = read_offset(cp);
      }
#line 167
      read_off = tmp___0;
      {
#line 168
      tmp___1 = chew_on(cp);
      }
#line 168
      leader = tmp___1;
      {
#line 169
      tmp___2 = read_pos(read_off);
      }
#line 169
      cp = (char const   *)tmp___2;
      }
#line 170
      if ((unsigned long )leader != (unsigned long )cp) {
#line 171
        goto while_break___0;
      }
      {
#line 166
      cp ++;
      {
#line 166
      cp = chew_continuation(cp);
      }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 174
  return (cp);
}
}
#line 177 "/home/wslee/tests/SOURCES/coan-4.2.2/src/chew.c"
char const   *chew_unbroken_string(char const   *cp ) 
{ 
  char const   *save ;
  size_t tmp ;
  _Bool tmp___0 ;
  size_t read_off ;
  size_t tmp___1 ;
  char const   *leader ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  _Bool tmp___5 ;
  char *__cil_tmp12 ;

  {
#line 180
  save = cp;
#line 181
  if ((int const   )*cp == 34) {
#line 182
    cp ++;
    {
    {
#line 182
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 182
      if (*cp) {
#line 182
        if ((int const   )*cp != 34) {
          {
          {
#line 182
          tmp = eol(cp);
          }
          }
#line 182
          if (tmp) {
#line 182
            goto while_break;
          } else {
            {
            {
#line 182
            tmp___0 = is_line_continuation(cp);
            }
            }
#line 182
            if (tmp___0) {
#line 182
              goto while_break;
            }
          }
        } else {
#line 182
          goto while_break;
        }
      } else {
#line 182
        goto while_break;
      }
#line 182
      cp ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 183
    if (! *cp) {
#line 183
      if (chew_public_h->in_source) {
        {
        {
#line 184
        report((reason_code_t )9232, (heap_str *)((void *)0), "Unclosed quotation in context \"%s\"",
               save);
        }
        }
      } else {
#line 183
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 186
    if ((int const   )*cp == 34) {
#line 187
      cp ++;
    }
  } else {
    {
    {
#line 189
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 189
      tmp___4 = __ctype_b_loc();
      }
      }
#line 189
      if ((int const   )*(*tmp___4 + (int )*cp) & 32768) {
        {
        {
#line 189
        tmp___5 = is_line_continuation(cp);
        }
        }
#line 189
        if (tmp___5) {
#line 189
          goto while_break___0;
        }
      } else {
#line 189
        goto while_break___0;
      }
      {
      {
#line 190
      tmp___1 = read_offset(cp);
      }
#line 190
      read_off = tmp___1;
      {
#line 191
      tmp___2 = chew_on(cp);
      }
#line 191
      leader = tmp___2;
      {
#line 192
      tmp___3 = read_pos(read_off);
      }
#line 192
      cp = (char const   *)tmp___3;
      }
#line 193
      if ((unsigned long )leader != (unsigned long )cp) {
#line 194
        goto while_break___0;
      }
#line 189
      cp ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 197
  return (cp);
}
}
#line 201 "/home/wslee/tests/SOURCES/coan-4.2.2/src/chew.c"
char const   *chew_macro_call(char const   *cp ) 
{ 
  char const   *saved_cp ;
  unsigned short const   **tmp ;

  {
  {
  {
#line 204
  cp = chew_symbol(cp);
  }
  {
#line 205
  cp = chew_continuation(cp);
  }
  }
#line 206
  if ((int const   )*cp == 40) {
    {
#line 207
    cp ++;
    {
#line 207
    cp = chew_continuation(cp);
    }
    }
    {
    {
#line 208
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 208
      if (! ((int const   )*cp != 41)) {
#line 208
        goto while_break;
      }
      {
      {
#line 210
      cp = chew_on(cp);
      }
#line 210
      saved_cp = cp;
      {
#line 211
      cp = chew_string(cp);
      }
      }
#line 212
      if ((unsigned long )cp > (unsigned long )saved_cp) {
#line 212
        if ((int const   )*(cp + -1) == 41) {
#line 213
          return (cp);
        }
      }
      {
      {
#line 215
      cp = chew_on(cp);
      }
      }
#line 216
      if ((int const   )*cp == 44) {
        {
#line 217
        cp ++;
        {
#line 217
        cp = chew_continuation(cp);
        }
        }
      } else
#line 218
      if ((int const   )*cp == 40) {
        {
#line 219
        cp ++;
        {
#line 219
        cp = chew_continuation(cp);
        }
        {
#line 220
        cp = chew_on(cp);
        }
        {
#line 221
        cp = chew_macro_call(cp);
        }
        }
      } else {
#line 223
        goto while_break;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 226
    if ((int const   )*cp == 41) {
#line 227
      cp ++;
    } else {
      {
      {
#line 229
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
        {
        {
#line 229
        tmp = __ctype_b_loc();
        }
        }
#line 229
        if (! ((int const   )*(*tmp + (int )*(cp + -1)) & 8192)) {
#line 229
          goto while_break___0;
        }
#line 229
        cp --;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 232
  return (cp);
}
}
#line 235 "/home/wslee/tests/SOURCES/coan-4.2.2/src/chew.c"
char const   *chew_header_name(char const   *cp ) 
{ 
  char delim ;
  _Bool tmp ;

  {
#line 239
  if ((int const   )*cp == 34) {
#line 240
    delim = (char )*cp;
  } else
#line 241
  if ((int const   )*cp == 60) {
#line 242
    delim = (char )'>';
  } else {
#line 244
    delim = (char)0;
  }
#line 246
  if (delim) {
    {
#line 247
    cp ++;
    {
#line 247
    cp = chew_continuation(cp);
    }
    }
    {
    {
#line 247
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 247
      if ((int const   )*cp != (int const   )delim) {
        {
        {
#line 247
        tmp = is_symbol_inner_char((char )*cp);
        }
        }
#line 247
        if (! tmp) {
#line 247
          if (! ((int const   )*cp == 32)) {
#line 247
            if (! ((int const   )*cp == 47)) {
#line 247
              if (! ((int const   )*cp == 46)) {
#line 247
                goto while_break;
              }
            }
          }
        }
      } else {
#line 247
        goto while_break;
      }
      {
#line 247
      cp ++;
      {
#line 247
      cp = chew_continuation(cp);
      }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 257
    if ((int const   )*cp == (int const   )delim) {
      {
#line 258
      cp ++;
      {
#line 258
      cp = chew_continuation(cp);
      }
      }
    }
  }
#line 261
  return (cp);
}
}
#line 264 "/home/wslee/tests/SOURCES/coan-4.2.2/src/chew.c"
size_t eol(char const   *cp ) 
{ 


  {
#line 267
  if ((int const   )*(cp + 0) == 10) {
#line 268
    return ((size_t )1);
  }
#line 270
  if ((int const   )*(cp + 0) == 13) {
#line 270
    if ((int const   )*(cp + 1) == 10) {
#line 271
      return ((size_t )2);
    }
  }
#line 273
  return ((size_t )0);
}
}
#line 277 "/home/wslee/tests/SOURCES/coan-4.2.2/src/chew.c"
char const   *chew_on(char const   *cp ) 
{ 
  char const   *chew_start ;
  int nl_len ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  _Bool tmp___2 ;
  size_t single_quote_len ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 280
  chew_start = cp;
#line 288
  if (args_public_h->plaintext) {
    {
    {
#line 289
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 289
      tmp___0 = __ctype_b_loc();
      }
      }
#line 289
      if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*cp)) & 8192)) {
#line 289
        goto while_break;
      }
      {
      {
#line 290
      tmp = eol(cp);
      }
      }
#line 290
      if (tmp) {
#line 291
        chew_public_h->line_state = (line_state_t )0;
      }
#line 289
      cp ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 294
    return (cp);
  }
  {
  {
#line 296
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 296
    if (! ((int const   )*cp != 0)) {
#line 296
      goto while_break___0;
    }
#line 297
    if (chew_state.single_quote_length) {
#line 298
      (chew_state.single_quote_length) ++;
    }
#line 300
    if ((int const   )*(cp + 0) == 92) {
      {
      {
#line 301
      tmp___1 = eol(cp + 1);
      }
      }
#line 301
      if (tmp___1) {
#line 303
        chew_state.escape = (_Bool)1;
      } else
#line 304
      if (chew_state.single_quote_length) {
#line 306
        chew_state.escape = (_Bool )(! chew_state.escape);
#line 308
        (chew_state.single_quote_length) --;
      } else
#line 309
      if (chew_public_h->in_double_quote) {
#line 311
        chew_state.escape = (_Bool )(! chew_state.escape);
      } else
#line 312
      if ((unsigned int )chew_public_h->line_state != 2U) {
#line 315
        goto while_break___0;
      } else
#line 312
      if ((unsigned int )chew_public_h->comment_state == 0U) {
#line 315
        goto while_break___0;
      }
#line 317
      cp ++;
#line 318
      goto while_continue___0;
    }
#line 320
    if ((int const   )*(cp + 0) == 34) {
#line 321
      if (! chew_state.escape) {
#line 322
        if (chew_public_h->stop_at_quote) {
#line 322
          if ((unsigned int )chew_public_h->comment_state == 0U) {
#line 324
            goto while_break___0;
          }
        }
#line 331
        tmp___2 = (_Bool )(! chew_public_h->in_double_quote);
#line 331
        chew_public_h->in_double_quote = tmp___2;
#line 331
        if ((int )tmp___2 == 1) {
#line 333
          chew_public_h->last_quote_start_line = (size_t )io_public_h->line_num;
        }
      }
#line 337
      cp ++;
    } else
#line 338
    if ((int const   )*(cp + 0) == 39) {
#line 339
      if (! chew_state.escape) {
#line 341
        if (chew_public_h->stop_at_quote) {
#line 341
          if ((unsigned int )chew_public_h->comment_state == 0U) {
#line 343
            goto while_break___0;
          }
        }
#line 346
        single_quote_len = chew_state.single_quote_length;
#line 347
        if (single_quote_len == 0UL) {
#line 347
          if (! chew_public_h->in_double_quote) {
#line 351
            (chew_state.single_quote_length) ++;
          } else {
#line 347
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 352
        if (single_quote_len > 0UL) {
#line 353
          if (chew_public_h->in_double_quote) {
#line 367
            chew_public_h->in_double_quote = (_Bool)0;
          }
#line 369
          chew_state.single_quote_length = (size_t )0;
        }
#line 371
        cp ++;
      } else
#line 373
      if (chew_public_h->in_double_quote) {
#line 377
        cp ++;
      } else
#line 373
      if (chew_state.single_quote_length > 0UL) {
#line 377
        cp ++;
      } else
#line 373
      if ((unsigned int )chew_public_h->comment_state != 0U) {
#line 377
        cp ++;
      } else {
#line 380
        goto while_break___0;
      }
    } else {
      {
      {
#line 382
      tmp___10 = eol(cp);
      }
#line 382
      nl_len = (int )tmp___10;
      }
#line 382
      if (nl_len != 0) {
#line 383
        if (chew_state.escape) {
#line 385
          if ((int const   )*(cp + nl_len) == 0) {
            {
#line 387
            (io_public_h->extension_lines) ++;
            {
#line 388
            tmp___3 = read_more(cp);
            }
#line 388
            cp = (char const   *)tmp___3;
            }
          }
#line 390
          if (chew_state.single_quote_length) {
#line 393
            chew_state.single_quote_length -= 2UL;
          }
        } else {
#line 396
          chew_public_h->line_state = (line_state_t )0;
#line 397
          if ((unsigned int )chew_public_h->comment_state == 2U) {
#line 399
            chew_public_h->comment_state = (enum comment_state )0;
#line 400
            chew_public_h->in_double_quote = (_Bool)0;
          } else
#line 401
          if ((unsigned int )chew_public_h->comment_state == 1U) {
            {
#line 402
            chew_public_h->in_double_quote = (_Bool)0;
#line 403
            (io_public_h->extension_lines) ++;
            {
#line 404
            tmp___4 = read_more(cp);
            }
#line 404
            cp = (char const   *)tmp___4;
            }
          } else
#line 405
          if (chew_public_h->in_double_quote) {
#line 406
            chew_public_h->in_double_quote = (_Bool)0;
#line 407
            if (chew_public_h->must_balance_quotes) {
#line 407
              if (chew_public_h->in_source) {
#line 407
                tmp___5 = 1;
              } else {
#line 407
                tmp___5 = 0;
              }
            } else {
#line 407
              tmp___5 = 0;
            }
#line 407
            if (tmp___5) {
              {
              {
#line 410
              parse_error(16656, "Newline within quotation");
              }
              }
            }
          }
        }
#line 415
        if ((int const   )*cp == 13) {
#line 417
          cp ++;
        }
#line 419
        cp ++;
      } else
#line 420
      if ((int const   )*(cp + 0) == 32) {
#line 421
        cp ++;
      } else
#line 420
      if ((int const   )*(cp + 0) == 9) {
#line 421
        cp ++;
      } else
#line 424
      if ((unsigned int )chew_public_h->comment_state == 0U) {
#line 427
        if (! chew_public_h->in_double_quote) {
#line 427
          if (! chew_state.single_quote_length) {
            {
            {
#line 429
            tmp___6 = strncmp(cp, "/\\\n", (size_t )3);
            }
            }
#line 429
            if (! tmp___6) {
#line 430
              chew_public_h->comment_state = (enum comment_state )3;
#line 431
              chew_public_h->last_comment_start_line = (size_t )io_public_h->line_num;
#line 433
              cp += 3;
            }
            {
            {
#line 435
            tmp___7 = strncmp(cp, "/\\\r\n", (size_t )4);
            }
            }
#line 435
            if (tmp___7) {
#line 440
              if ((int const   )*(cp + 0) == 47) {
#line 440
                if ((int const   )*(cp + 1) == 42) {
#line 441
                  chew_public_h->comment_state = (enum comment_state )1;
#line 442
                  chew_public_h->last_comment_start_line = (size_t )io_public_h->line_num;
#line 444
                  cp += 2;
                } else {
#line 440
                  goto _L___1;
                }
              } else
              _L___1: /* CIL Label */ 
#line 445
              if ((int const   )*(cp + 0) == 47) {
#line 445
                if ((int const   )*(cp + 1) == (int const   )*(cp + 0)) {
#line 446
                  chew_public_h->comment_state = (enum comment_state )2;
#line 447
                  chew_public_h->last_comment_start_line = (size_t )io_public_h->line_num;
#line 449
                  cp += 2;
                } else {
#line 445
                  goto _L___0;
                }
              } else
              _L___0: /* CIL Label */ 
#line 450
              if ((unsigned int )chew_public_h->line_state == 2U) {
#line 453
                cp ++;
              } else {
#line 456
                goto while_break___0;
              }
            } else {
#line 436
              chew_public_h->comment_state = (enum comment_state )3;
#line 437
              chew_public_h->last_comment_start_line = (size_t )io_public_h->line_num;
#line 439
              cp += 4;
            }
          } else {
#line 459
            cp ++;
          }
        } else {
#line 459
          cp ++;
        }
      } else
#line 465
      if ((unsigned int )chew_public_h->comment_state == 1U) {
        {
        {
#line 466
        tmp___8 = strncmp(cp, "*\\\n", (size_t )3);
        }
        }
#line 466
        if (! tmp___8) {
#line 467
          chew_public_h->comment_state = (enum comment_state )4;
#line 468
          cp += 3;
        }
        {
        {
#line 470
        tmp___9 = strncmp(cp, "*\\\r\n", (size_t )4);
        }
        }
#line 470
        if (tmp___9) {
#line 473
          if ((int const   )*(cp + 0) == 42) {
#line 473
            if ((int const   )*(cp + 1) == 47) {
#line 474
              chew_public_h->comment_state = (enum comment_state )0;
#line 475
              chew_public_h->in_double_quote = (_Bool)0;
#line 476
              cp += 2;
            } else {
#line 478
              cp ++;
            }
          } else {
#line 478
            cp ++;
          }
        } else {
#line 471
          chew_public_h->comment_state = (enum comment_state )4;
#line 472
          cp += 4;
        }
      } else
#line 480
      if ((unsigned int )chew_public_h->comment_state == 3U) {
#line 481
        if ((int const   )*cp == 42) {
#line 482
          chew_public_h->comment_state = (enum comment_state )1;
#line 483
          cp ++;
        } else
#line 484
        if ((int const   )*cp == 47) {
#line 485
          chew_public_h->comment_state = (enum comment_state )2;
#line 486
          cp ++;
        } else {
#line 488
          chew_public_h->comment_state = (enum comment_state )0;
#line 489
          chew_public_h->line_state = (line_state_t )2;
        }
      } else
#line 491
      if ((unsigned int )chew_public_h->comment_state == 4U) {
#line 492
        if ((int const   )*cp == 47) {
#line 493
          chew_public_h->comment_state = (enum comment_state )0;
#line 494
          cp ++;
        } else {
#line 496
          chew_public_h->comment_state = (enum comment_state )1;
        }
      } else {
#line 499
        cp ++;
      }
    }
#line 501
    chew_state.escape = (_Bool)0;
#line 502
    if (chew_state.single_quote_length > 3UL) {
#line 503
      chew_state.single_quote_length = (size_t )0;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 506
  if (chew_state.escape) {
#line 507
    chew_state.escape = (_Bool)0;
#line 508
    if (chew_public_h->in_source) {
      {
      {
#line 509
      report((reason_code_t )9184, (heap_str *)((void *)0), "Stray \'\\\' ignored");
      }
      }
    }
  }
#line 512
  if (chew_public_h->in_double_quote) {
#line 512
    if (chew_public_h->in_source) {
      {
      {
#line 513
      report((reason_code_t )9232, (heap_str *)((void *)0), "Unclosed quotation in context \"%s\"",
             chew_start);
      }
      }
    }
  }
#line 516
  return (cp);
}
}
#line 519 "/home/wslee/tests/SOURCES/coan-4.2.2/src/chew.c"
void chew_toplevel(void) 
{ 


  {
#line 522
  chew_public_h->line_state = (line_state_t )0;
#line 523
  chew_public_h->comment_state = (enum comment_state )0;
#line 524
  chew_public_h->in_double_quote = (_Bool)0;
#line 525
  chew_state.single_quote_length = (size_t )0;
#line 526
  chew_public_h->stop_at_quote = (_Bool)0;
#line 527
  chew_public_h->must_balance_quotes = (_Bool)1;
#line 528
  chew_public_h->in_source = (_Bool)1;
#line 529
  return;
}
}
#line 72 "/home/wslee/tests/SOURCES/coan-4.2.2/src/contradiction.h"
void contradiction_policy(contradiction_policy_t p ) ;
#line 165
void contradiction_finitor(void) ;
#line 92 "/home/wslee/tests/SOURCES/coan-4.2.2/src/contradiction.c"
static contradiction_state_t contradiction_state  ;
#line 92 "/home/wslee/tests/SOURCES/coan-4.2.2/src/contradiction.c"
contradiction_state_t *contradiction_h  =    & contradiction_state;
#line 92 "/home/wslee/tests/SOURCES/coan-4.2.2/src/contradiction.c"
contradiction_public_state_t *contradiction_public_h  =    (contradiction_public_state_t *)(& contradiction_state);
#line 92
static contradiction_state_t const   * const  contradiction_static_initialiser_h ;
#line 92 "/home/wslee/tests/SOURCES/coan-4.2.2/src/contradiction.c"
void (*contradiction_init_h)(contradiction_state_t * )  ;
#line 92 "/home/wslee/tests/SOURCES/coan-4.2.2/src/contradiction.c"
void (*contradiction_finis_h)(contradiction_state_t * )  ;
#line 92 "/home/wslee/tests/SOURCES/coan-4.2.2/src/contradiction.c"
void contradiction_initor(void) 
{ 


  {
  {
  {
#line 92
  component_initor((_Bool)1, (_Bool)0, (void **)((char *)(& contradiction_h)), (void **)((char *)(& contradiction_public_h)),
                   (void const   *)contradiction_static_initialiser_h, sizeof(contradiction_state_t ),
                   (void (*)())contradiction_init_h);
  }
  }
#line 92
  return;
}
}
#line 92 "/home/wslee/tests/SOURCES/coan-4.2.2/src/contradiction.c"
void contradiction_finitor(void) 
{ 


  {
  {
  {
#line 92
  component_finitor((_Bool)1, (void **)((char *)(& contradiction_h)), (void **)((char *)(& contradiction_public_h)),
                    (void (*)())contradiction_init_h);
  }
  }
#line 92
  return;
}
}
#line 94
static struct contradiction_state_s  const  contradiction_static_initialiser ;
#line 94 "/home/wslee/tests/SOURCES/coan-4.2.2/src/contradiction.c"
static contradiction_state_t const   * const  contradiction_static_initialiser_h  =    (contradiction_state_t const   */* const  */)(& contradiction_static_initialiser);
#line 94 "/home/wslee/tests/SOURCES/coan-4.2.2/src/contradiction.c"
static struct contradiction_state_s  const  contradiction_static_initialiser  =    {{(symbol_const_h )((void *)0)}, (char *)"//", 8240, (_Bool)0, {(char *)0, (char *)0}};
#line 144 "/home/wslee/tests/SOURCES/coan-4.2.2/src/contradiction.c"
static void compose_contradiction_insert_format(heap_str *buf , char const   *sub_format ) 
{ 
  int buflen ;
  int startoff ;
  char *__cil_tmp5 ;

  {
  {
#line 147
  buflen = 0;
#line 148
  startoff = 0;
  {
#line 149
  format_output((void *)buf, & buflen, & startoff, "%serror : inserted by coan: %s at %s(%d)\n",
                contradiction_state.contradiction_insert_prefix, sub_format, io_public_h->filename,
                io_public_h->line_num);
  }
  }
#line 155
  return;
}
}
#line 171 "/home/wslee/tests/SOURCES/coan-4.2.2/src/contradiction.c"
static void forget_pending_contradiction(void) 
{ 


  {
  {
  {
#line 174
  release((void **)(& contradiction_state.err_msg_buf[1]));
  }
  {
#line 175
  release((void **)(& contradiction_state.err_msg_buf[0]));
  }
#line 176
  contradiction_public_h->last_contradictory_undef = (symbol_const_h )((void *)0);
  }
#line 177
  return;
}
}
#line 189 "/home/wslee/tests/SOURCES/coan-4.2.2/src/contradiction.c"
static void insert_pending_contradiction(void) 
{ 
  _Bool tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 192
  if (! contradiction_state.err_msg_buf[0]) {
    {
    {
#line 192
    __assert_fail("(((1) ? (void) (0) : __assert_fail (\"1\", \"/home/wslee/tests/SOURCES/coan-4.2.2/src/contradiction.c\", 192, __PRETTY_FUNCTION__)),contradiction_state.err_msg_buf)[ERR_MSG_BUF]",
                  "/home/wslee/tests/SOURCES/coan-4.2.2/src/contradiction.c", 192U,
                  "insert_pending_contradiction");
    }
    }
  }
  {
  {
#line 193
  report((reason_code_t )contradiction_state.contradiction_insert_reason, & contradiction_state.err_msg_buf[0],
         (char const   *)((void *)0));
  }
  }
#line 195
  if (contradiction_state.contradiction_insert_prefix) {
    {
    {
#line 196
    substitute((char const   *)contradiction_state.err_msg_buf[1]);
    }
    }
#line 197
    if (contradiction_state.contradiction_insert_reason == 8256) {
      {
      {
#line 199
      set_exit_flags(73732, (_Bool)1);
      }
      {
#line 200
      tmp = is_unconditional_line();
      }
      }
#line 200
      if (tmp) {
        {
        {
#line 201
        set_exit_flags(73736, (_Bool)1);
        }
        {
#line 202
        report((reason_code_t )8272, (heap_str *)((void *)0), "An unconditional #error directive was output");
        }
        }
      }
    }
  }
  {
  {
#line 207
  forget_pending_contradiction();
  }
  }
#line 208
  return;
}
}
#line 227 "/home/wslee/tests/SOURCES/coan-4.2.2/src/contradiction.c"
void insert_contradiction(char const   *sub_format ) 
{ 


  {
  {
  {
#line 230
  save_contradiction(sub_format);
  }
  {
#line 231
  insert_pending_contradiction();
  }
  }
#line 232
  return;
}
}
#line 235 "/home/wslee/tests/SOURCES/coan-4.2.2/src/contradiction.c"
void contradiction_policy(contradiction_policy_t p ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 239
  if ((unsigned int )p == 0U) {
#line 239
    goto case_0;
  }
#line 244
  if ((unsigned int )p == 1U) {
#line 244
    goto case_1;
  }
#line 249
  if ((unsigned int )p == 2U) {
#line 249
    goto case_2;
  }
#line 254
  goto switch_default;
  case_0: /* CIL Label */ 
#line 240
  contradiction_state.contradiction_insert_prefix = (char *)((void *)0);
#line 241
  contradiction_state.contradiction_insert_reason = 8224;
#line 243
  goto switch_break;
  case_1: /* CIL Label */ 
#line 245
  contradiction_state.contradiction_insert_prefix = (char *)"//";
#line 246
  contradiction_state.contradiction_insert_reason = 8240;
#line 248
  goto switch_break;
  case_2: /* CIL Label */ 
#line 250
  contradiction_state.contradiction_insert_prefix = (char *)"#";
#line 251
  contradiction_state.contradiction_insert_reason = 8256;
#line 253
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 255
  __assert_fail("0", "/home/wslee/tests/SOURCES/coan-4.2.2/src/contradiction.c", 255U,
                "contradiction_policy");
  }
  }
  switch_break: /* CIL Label */ ;
  }
#line 257
  return;
}
}
#line 259 "/home/wslee/tests/SOURCES/coan-4.2.2/src/contradiction.c"
void flush_contradiction(void) 
{ 


  {
#line 262
  if (contradiction_state.err_msg_buf[0]) {
    {
    {
#line 263
    insert_pending_contradiction();
    }
    }
  }
#line 265
  return;
}
}
#line 267 "/home/wslee/tests/SOURCES/coan-4.2.2/src/contradiction.c"
void forget_contradiction(void) 
{ 


  {
#line 270
  if (contradiction_state.err_msg_buf[1]) {
#line 271
    if (! contradiction_state.had_warnings) {
      {
      {
#line 272
      set_exit_flags(8192, (_Bool)0);
      }
      }
    }
    {
    {
#line 274
    forget_pending_contradiction();
    }
    }
  }
#line 276
  return;
}
}
#line 278 "/home/wslee/tests/SOURCES/coan-4.2.2/src/contradiction.c"
void save_contradiction(char const   *sub_format ) 
{ 
  size_t linelen ;
  size_t tmp ;
  size_t extension_lines ;
  int tmp___0 ;
  heap_str contradiction_insert_format ;
  int buflen ;
  int startoff ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 281
  tmp = line_len((char const   *)io_public_h->line_start);
  }
#line 281
  linelen = tmp;
#line 282
  extension_lines = io_public_h->extension_lines;
  }
#line 283
  if (! ((unsigned long )contradiction_state.err_msg_buf[0] == (unsigned long )((heap_str )0))) {
    {
    {
#line 283
    __assert_fail("(((1) ? (void) (0) : __assert_fail (\"1\", \"/home/wslee/tests/SOURCES/coan-4.2.2/src/contradiction.c\", 283, __PRETTY_FUNCTION__)),contradiction_state.err_msg_buf)[ERR_MSG_BUF] == 0",
                  "/home/wslee/tests/SOURCES/coan-4.2.2/src/contradiction.c", 283U,
                  "save_contradiction");
    }
    }
  }
#line 284
  if (extension_lines) {
    {
    {
#line 286
    flatten_line(io_public_h->line_start);
    }
    }
  }
  {
  {
#line 288
  tmp___0 = get_exit_flags(8192);
  }
#line 288
  contradiction_state.had_warnings = (_Bool )(tmp___0 != 0);
  {
#line 289
  report((reason_code_t )contradiction_state.contradiction_insert_reason, & contradiction_state.err_msg_buf[0],
         sub_format, linelen, io_public_h->line_start);
  }
  }
#line 294
  if (contradiction_state.contradiction_insert_prefix) {
    {
#line 295
    contradiction_insert_format = (heap_str )((void *)0);
#line 296
    buflen = 0;
    {
#line 298
    compose_contradiction_insert_format(& contradiction_insert_format, sub_format);
    }
    }
#line 300
    if (! ((unsigned long )contradiction_state.err_msg_buf[1] == (unsigned long )((heap_str )0))) {
      {
      {
#line 300
      __assert_fail("(((1) ? (void) (0) : __assert_fail (\"1\", \"/home/wslee/tests/SOURCES/coan-4.2.2/src/contradiction.c\", 300, __PRETTY_FUNCTION__)),contradiction_state.err_msg_buf)[OUT_MSG_BUF] == 0",
                    "/home/wslee/tests/SOURCES/coan-4.2.2/src/contradiction.c", 300U,
                    "save_contradiction");
      }
      }
    }
    {
    {
#line 301
    format_output((void *)(& contradiction_state.err_msg_buf[1]), & buflen, & startoff,
                  (char const   *)contradiction_insert_format, linelen, io_public_h->line_start,
                  io_public_h->filename, io_public_h->line_num);
    }
    {
#line 308
    free((void *)contradiction_insert_format);
    }
    }
  }
#line 310
  return;
}
}
#line 148 "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.h"
void canonical_string_appendc(canonical_string_h cs , char more ) ;
#line 157
void canonical_string_appends(canonical_string_h cs , canonical_string_const_h more ,
                              _Bool punct ) ;
#line 168
canonical_string_h canonical_string_substr(canonical_string_const_h cs , size_t start ,
                                           size_t len ) ;
#line 184 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
#line 116 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 108 "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c"
static void canonical_string_parse_next_part(char const   **start , size_t *len ) 
{ 
  char const   *cp ;
  char const   *advance ;
  char const   *tmp ;
  size_t read_off ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 111
  cp = *start;
  {
#line 112
  tmp = chew_continuation(cp);
  }
#line 112
  advance = tmp;
  }
#line 113
  if ((unsigned long )advance != (unsigned long )cp) {
#line 114
    *start = advance;
#line 115
    *len = (size_t )0;
  } else {
    {
    {
#line 117
    tmp___0 = read_offset(cp);
    }
#line 117
    read_off = tmp___0;
    {
#line 118
    advance = chew_on(cp);
    }
    {
#line 119
    tmp___1 = read_pos(read_off);
    }
#line 119
    cp = (char const   *)tmp___1;
    }
#line 120
    if ((unsigned long )advance != (unsigned long )cp) {
#line 121
      *start = advance;
#line 121
      *len = (size_t )(advance - cp);
    } else {
      {
      {
#line 124
      advance = chew_unbroken_string(cp);
      }
#line 125
      *len = (size_t )(advance - cp);
#line 126
      *start = cp;
      }
    }
  }
#line 129
  return;
}
}
#line 140 "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c"
static void canonical_string_init(canonical_string_h cs , char const   *start , size_t nbytes ,
                                  char const   **pend ) 
{ 
  size_t spare ;
  char const   *cp ;
  size_t tmp ;
  char *tp ;
  heap_str tmp___0 ;
  void *tmp___1 ;
  size_t used ;
  size_t tok_len ;
  char const   *save_cp ;
  size_t tp_off ;
  void *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  char *__cil_tmp20 ;

  {
#line 143
  spare = (size_t )0;
#line 144
  cp = start;
#line 145
  if (cp) {
#line 146
    if (nbytes) {
#line 146
      spare = nbytes;
    } else {
      {
      {
#line 146
      tmp = strlen(cp);
      }
#line 146
      spare = tmp;
      }
    }
  }
#line 148
  if (spare) {
    {
#line 149
    spare ++;
    {
#line 149
    tmp___1 = zallocate(spare);
    }
#line 149
    tmp___0 = (heap_str )tmp___1;
#line 149
    cs->text = tmp___0;
#line 149
    tp = tmp___0;
#line 150
    used = (size_t )0;
#line 151
    chew_public_h->stop_at_quote = (_Bool)1;
    {
#line 152
    cp = chew_on(cp);
    }
    }
    {
    {
#line 153
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
#line 155
      save_cp = cp;
      {
#line 156
      canonical_string_parse_next_part(& cp, & tok_len);
      }
      }
#line 157
      if ((unsigned long )save_cp == (unsigned long )cp) {
#line 158
        if (! tok_len) {
#line 161
          *(tp + - ((int )*(tp + -1) == 32)) = (char )'\000';
#line 162
          goto while_break;
        }
#line 164
        if (tok_len > spare) {
          {
#line 165
          tp_off = (size_t )(tp - cs->text);
          {
#line 166
          tmp___2 = reallocate((void *)cs->text, (used + tok_len) + 1UL);
          }
#line 166
          cs->text = (heap_str )tmp___2;
#line 167
          tp = cs->text + tp_off;
#line 168
          spare = tok_len + 1UL;
          }
        }
        {
        {
#line 170
        memcpy((void */* __restrict  */)tp, (void const   */* __restrict  */)cp, tok_len);
        }
#line 171
        spare -= tok_len;
#line 172
        used += tok_len;
#line 173
        tp += tok_len;
#line 174
        cp += tok_len;
        }
      } else
#line 175
      if (tok_len > 0UL) {
#line 176
        tmp___3 = tp;
#line 176
        tp ++;
#line 176
        *tmp___3 = (char )' ';
#line 177
        used ++;
#line 178
        spare --;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 181
    tp = cs->text;
    {
#line 182
    tmp___4 = strlen((char const   *)tp);
    }
    {
#line 182
    tmp___5 = reallocate((void *)tp, tmp___4 + 1UL);
    }
#line 182
    cs->text = (heap_str )tmp___5;
    }
#line 183
    if (pend) {
#line 184
      *pend = cp;
    }
#line 186
    chew_public_h->stop_at_quote = (_Bool)0;
  } else {
    {
    {
#line 188
    tmp___6 = clone((void const   *)"", (size_t )0);
    }
#line 188
    cs->text = (heap_str )tmp___6;
    }
  }
#line 190
  return;
}
}
#line 201 "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c"
static _Bool is_zero_digit(canonical_string_const_h cs ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 204
  if (! cs) {
    {
    {
#line 204
    __assert_fail("cs", "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c",
                  204U, "is_zero_digit");
    }
    }
  }
#line 205
  if (cs->text) {
#line 205
    if ((int )*(cs->text + 1) == 48) {
#line 205
      if ((int )*(cs->text + 1) == 0) {
#line 205
        tmp = 1;
      } else {
#line 205
        tmp = 0;
      }
    } else {
#line 205
      tmp = 0;
    }
  } else {
#line 205
    tmp = 0;
  }
#line 205
  return ((_Bool )tmp);
}
}
#line 209 "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c"
static _Bool is_octal_numeral(canonical_string_const_h cs ) 
{ 
  _Bool verdict ;
  char *num_end ;
  long l ;
  long tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 212
  verdict = (_Bool)0;
#line 213
  if (! cs) {
    {
    {
#line 213
    __assert_fail("cs", "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c",
                  213U, "is_octal_numeral");
    }
    }
  }
#line 214
  if (cs->text) {
#line 214
    if ((int )*(cs->text + 0) == 0) {
      {
      {
#line 216
      tmp = strtol((char const   */* __restrict  */)cs->text, (char **/* __restrict  */)(& num_end),
                   8);
      }
#line 216
      l = tmp;
#line 218
      verdict = (_Bool )((int )*num_end == 0);
      }
    }
  }
#line 220
  return (verdict);
}
}
#line 224 "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c"
static _Bool is_hex_numeral(canonical_string_const_h cs ) 
{ 
  _Bool verdict ;
  char *num_end ;
  long l ;
  long tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 227
  verdict = (_Bool)0;
#line 228
  if (! cs) {
    {
    {
#line 228
    __assert_fail("cs", "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c",
                  228U, "is_hex_numeral");
    }
    }
  }
#line 229
  if (cs->text) {
#line 229
    if ((int )*(cs->text + 0) == 0) {
      {
      {
#line 231
      tmp = strtol((char const   */* __restrict  */)cs->text, (char **/* __restrict  */)(& num_end),
                   16);
      }
#line 231
      l = tmp;
#line 233
      verdict = (_Bool )((int )*num_end == 0);
      }
    }
  }
#line 235
  return (verdict);
}
}
#line 239 "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c"
static _Bool is_decimal_numeral(canonical_string_const_h cs ) 
{ 
  _Bool verdict ;
  char *num_end ;
  long l ;
  long tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 242
  verdict = (_Bool)0;
#line 243
  if (! cs) {
    {
    {
#line 243
    __assert_fail("cs", "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c",
                  243U, "is_decimal_numeral");
    }
    }
  }
#line 244
  if (cs->text) {
    {
    {
#line 246
    tmp = strtol((char const   */* __restrict  */)cs->text, (char **/* __restrict  */)(& num_end),
                 10);
    }
#line 246
    l = tmp;
#line 248
    verdict = (_Bool )((int )*num_end == 0);
    }
  }
#line 250
  return (verdict);
}
}
#line 254 "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c"
static _Bool is_type_suffix_char(char ch ) 
{ 
  char lc ;
  int tmp ;
  int tmp___0 ;

  {
  {
  {
#line 257
  tmp = tolower((int )ch);
  }
#line 257
  lc = (char )tmp;
  }
#line 258
  if ((int )lc == 117) {
#line 258
    tmp___0 = 1;
  } else
#line 258
  if ((int )lc == 108) {
#line 258
    tmp___0 = 1;
  } else {
#line 258
    tmp___0 = 0;
  }
#line 258
  return ((_Bool )tmp___0);
}
}
#line 269 "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c"
static char const   *integer_type_suffix(canonical_string_const_h cs ) 
{ 
  char *suffix ;
  long l ;
  long tmp ;
  char *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 273
  if (! cs) {
    {
    {
#line 273
    __assert_fail("cs", "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c",
                  273U, "integer_type_suffix");
    }
    }
  }
#line 274
  suffix = (char *)((void *)0);
#line 275
  if (cs->text) {
    {
    {
#line 276
    tmp = strtol((char const   */* __restrict  */)cs->text, (char **/* __restrict  */)(& suffix),
                 16);
    }
#line 276
    l = tmp;
    }
  }
#line 279
  if ((unsigned long )suffix > (unsigned long )cs->text) {
#line 279
    tmp___0 = suffix;
  } else {
#line 279
    tmp___0 = (char *)((void *)0);
  }
#line 279
  return ((char const   *)tmp___0);
}
}
#line 291 "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c"
static _Bool is_valid_digit(char ch , canonical_string_const_h cs ) 
{ 
  unsigned short const   **tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  _Bool tmp___4 ;
  int tmp___5 ;
  unsigned short const   **tmp___6 ;
  _Bool tmp___7 ;
  int tmp___8 ;
  unsigned short const   **tmp___9 ;
  _Bool tmp___10 ;
  int tmp___11 ;
  char const   *suffix ;
  char const   *tmp___12 ;
  _Bool verdict ;
  int tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *lastl ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  unsigned short const   **tmp___22 ;
  int tmp___23 ;
  _Bool tmp___24 ;
  _Bool tmp___25 ;
  _Bool tmp___26 ;
  _Bool tmp___27 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
#line 294
  if (! cs) {
    {
    {
#line 294
    __assert_fail("cs", "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c",
                  294U, "is_valid_digit");
    }
    }
  }
  {
  {
#line 295
  tmp___27 = is_zero_digit(cs);
  }
  }
#line 295
  if (tmp___27) {
    {
    {
#line 297
    tmp = __ctype_b_loc();
    }
    }
#line 297
    if ((int const   )*(*tmp + (int )ch) & 2048) {
#line 297
      tmp___2 = 1;
    } else {
      {
      {
#line 297
      tmp___0 = tolower((int )ch);
      }
      }
#line 297
      if (tmp___0 == 120) {
#line 297
        tmp___2 = 1;
      } else {
        {
        {
#line 297
        tmp___1 = is_type_suffix_char(ch);
        }
        }
#line 297
        if (tmp___1) {
#line 297
          tmp___2 = 1;
        } else {
#line 297
          tmp___2 = 0;
        }
      }
    }
#line 297
    return ((_Bool )tmp___2);
  } else {
    {
    {
#line 298
    tmp___26 = is_octal_numeral(cs);
    }
    }
#line 298
    if (tmp___26) {
      {
      {
#line 300
      tmp___3 = __ctype_b_loc();
      }
      }
#line 300
      if ((int const   )*(*tmp___3 + (int )ch) & 2048) {
#line 300
        if ((int )ch < 56) {
#line 300
          tmp___5 = 1;
        } else {
#line 300
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
        {
#line 300
        tmp___4 = is_type_suffix_char(ch);
        }
        }
#line 300
        if (tmp___4) {
#line 300
          tmp___5 = 1;
        } else {
#line 300
          tmp___5 = 0;
        }
      }
#line 300
      return ((_Bool )tmp___5);
    } else {
      {
      {
#line 301
      tmp___25 = is_hex_numeral(cs);
      }
      }
#line 301
      if (tmp___25) {
        {
        {
#line 303
        tmp___6 = __ctype_b_loc();
        }
        }
#line 303
        if ((int const   )*(*tmp___6 + (int )ch) & 4096) {
#line 303
          tmp___8 = 1;
        } else {
          {
          {
#line 303
          tmp___7 = is_type_suffix_char(ch);
          }
          }
#line 303
          if (tmp___7) {
#line 303
            tmp___8 = 1;
          } else {
#line 303
            tmp___8 = 0;
          }
        }
#line 303
        return ((_Bool )tmp___8);
      } else {
        {
        {
#line 304
        tmp___24 = is_decimal_numeral(cs);
        }
        }
#line 304
        if (tmp___24) {
          {
          {
#line 306
          tmp___9 = __ctype_b_loc();
          }
          }
#line 306
          if ((int const   )*(*tmp___9 + (int )ch) & 2048) {
#line 306
            tmp___11 = 1;
          } else {
            {
            {
#line 306
            tmp___10 = is_type_suffix_char(ch);
            }
            }
#line 306
            if (tmp___10) {
#line 306
              tmp___11 = 1;
            } else {
#line 306
              tmp___11 = 0;
            }
          }
#line 306
          return ((_Bool )tmp___11);
        } else {
          {
          {
#line 308
          tmp___12 = integer_type_suffix(cs);
          }
#line 308
          suffix = tmp___12;
          }
#line 309
          if (suffix) {
            {
            {
#line 312
            tmp___13 = tolower((int )ch);
            }
            }
#line 312
            if (tmp___13 == 117) {
              {
              {
#line 312
              tmp___14 = strchr(suffix, 'u');
              }
              }
#line 312
              if (tmp___14) {
#line 312
                tmp___16 = 0;
              } else {
                {
                {
#line 312
                tmp___15 = strchr(suffix, 'U');
                }
                }
#line 312
                if (tmp___15) {
#line 312
                  tmp___16 = 0;
                } else {
#line 312
                  tmp___16 = 1;
                }
              }
            } else {
#line 312
              tmp___16 = 0;
            }
#line 312
            verdict = (_Bool )tmp___16;
#line 313
            if (! verdict) {
              {
              {
#line 314
              tmp___17 = strrchr(suffix, 'l');
              }
#line 314
              lastl = tmp___17;
              }
#line 315
              if (! lastl) {
                {
                {
#line 316
                lastl = strrchr(suffix, 'L');
                }
                }
              }
              {
              {
#line 319
              tmp___18 = tolower((int )ch);
              }
              }
#line 319
              if (tmp___18 == 108) {
#line 319
                if ((unsigned long )lastl == (unsigned long )((void *)0)) {
#line 319
                  tmp___21 = 1;
                } else {
                  {
                  {
#line 319
                  tmp___19 = tolower((int )*(lastl + -1));
                  }
                  }
#line 319
                  if (tmp___19 != 108) {
                    {
                    {
#line 319
                    tmp___20 = tolower((int )*(lastl + 1));
                    }
                    }
#line 319
                    if (tmp___20 == 0) {
#line 319
                      tmp___21 = 1;
                    } else {
#line 319
                      tmp___21 = 0;
                    }
                  } else {
#line 319
                    tmp___21 = 0;
                  }
                }
              } else {
#line 319
                tmp___21 = 0;
              }
#line 319
              verdict = (_Bool )tmp___21;
            }
#line 321
            return (verdict);
          } else {
#line 325
            if (! cs->text) {
#line 325
              goto _L___0;
            } else
#line 325
            if (! *(cs->text + 0)) {
              _L___0: /* CIL Label */ 
              {
              {
#line 325
              tmp___22 = __ctype_b_loc();
              }
              }
#line 325
              if ((int const   )*(*tmp___22 + (int )ch) & 2048) {
#line 325
                tmp___23 = 1;
              } else {
#line 325
                tmp___23 = 0;
              }
            } else {
#line 325
              tmp___23 = 0;
            }
#line 325
            return ((_Bool )tmp___23);
          }
        }
      }
    }
  }
}
}
#line 335 "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c"
static _Bool is_valid_symbol_char(char ch , canonical_string_const_h cs ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 338
  if (! cs) {
    {
    {
#line 338
    __assert_fail("cs", "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c",
                  338U, "is_valid_symbol_char");
    }
    }
  }
#line 339
  if (! cs->text) {
    {
    {
#line 340
    tmp = is_symbol_start_char(ch);
    }
    }
#line 340
    return (tmp);
  } else
#line 339
  if (! *(cs->text + 0)) {
    {
    {
#line 340
    tmp = is_symbol_start_char(ch);
    }
    }
#line 340
    return (tmp);
  } else {
    {
    {
#line 342
    tmp___0 = is_symbol_inner_char(ch);
    }
    }
#line 342
    return (tmp___0);
  }
}
}
#line 354 "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c"
static void canonical_string_init_by_test(canonical_string_h cs , char const   **cpp ,
                                          _Bool (*validator)(char ch , canonical_string_const_h cs ) ) 
{ 
  size_t spare ;
  size_t used ;
  char const   *cp ;
  char *tp ;
  void *tmp ;
  _Bool tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 359
  spare = (size_t )0;
#line 360
  used = (size_t )0;
#line 361
  if (! cpp) {
    {
    {
#line 361
    __assert_fail("cpp", "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c",
                  361U, "canonical_string_init_by_test");
    }
    }
  }
#line 362
  cp = *cpp;
#line 363
  tp = cs->text;
  {
  {
#line 364
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 364
    if (*cp) {
      {
      {
#line 364
      tmp___0 = (*validator)((char )*cp, (canonical_string_const_h )cs);
      }
      }
#line 364
      if (! tmp___0) {
#line 364
        goto while_break;
      }
    } else {
#line 364
      goto while_break;
    }
#line 365
    if (! spare) {
#line 366
      if (used > 4UL) {
#line 366
        spare = used >> 1;
      } else {
#line 366
        spare = (size_t )4;
      }
      {
      {
#line 367
      tmp = reallocate((void *)cs->text, (used + spare) + 1UL);
      }
#line 367
      cs->text = (heap_str )tmp;
      {
#line 368
      memset((void *)(cs->text + used), '\000', spare + 1UL);
      }
#line 369
      tp = cs->text + used;
      }
    }
    {
#line 371
    *tp = (char )*cp;
#line 364
    cp ++;
    {
#line 364
    cp = chew_continuation(cp);
    }
#line 364
    tp ++;
#line 364
    used ++;
#line 364
    spare --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 373
  *cpp = cp;
#line 374
  return;
}
}
#line 383 "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c"
static void canonical_string_copy_init(canonical_string_h dest , canonical_string_const_h src ) 
{ 
  void *tmp ;

  {
  {
  {
#line 386
  tmp = clone((void const   *)src->text, (size_t )0);
  }
#line 386
  dest->text = (heap_str )tmp;
  }
#line 387
  return;
}
}
#line 390 "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c"
static void canonical_string_finis(canonical_string_h cs ) 
{ 


  {
#line 393
  if (cs->text) {
    {
    {
#line 394
    free((void *)cs->text);
    }
#line 395
    cs->text = (heap_str )((void *)0);
    }
  }
#line 397
  return;
}
}
#line 403 "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c"
canonical_string_h canonical_string_new(char const   *start , size_t nbytes , char const   **pend ) 
{ 
  canonical_string_h cs ;
  void *tmp ;

  {
  {
  {
#line 406
  tmp = zallocate(sizeof(struct canonical_string_impl ));
  }
#line 406
  cs = (canonical_string_h )tmp;
  {
#line 407
  canonical_string_init(cs, start, nbytes, pend);
  }
  }
#line 408
  return (cs);
}
}
#line 411 "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c"
canonical_string_h canonical_numeral(struct int_spec  const  *int_spec ) 
{ 
  canonical_string_h cs ;
  void *tmp ;
  char *heap ;
  char *tmp___0 ;
  char const   *num ;

  {
  {
  {
#line 414
  tmp = zallocate(sizeof(struct canonical_string_impl ));
  }
#line 414
  cs = (canonical_string_h )tmp;
  {
#line 415
  tmp___0 = format_int(int_spec);
  }
#line 415
  heap = tmp___0;
#line 416
  num = (char const   *)heap;
  {
#line 417
  canonical_string_init_by_test(cs, & num, & is_valid_digit);
  }
  {
#line 418
  free((void *)heap);
  }
  }
#line 419
  return (cs);
}
}
#line 422 "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c"
canonical_string_h canonical_identifier(char const   **cpp ) 
{ 
  canonical_string_h cs ;
  void *tmp ;

  {
  {
  {
#line 425
  tmp = zallocate(sizeof(struct canonical_string_impl ));
  }
#line 425
  cs = (canonical_string_h )tmp;
  {
#line 426
  canonical_string_init_by_test(cs, cpp, & is_valid_symbol_char);
  }
  }
#line 427
  return (cs);
}
}
#line 430 "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c"
canonical_string_h canonical_string_copy(canonical_string_const_h src ) 
{ 
  canonical_string_h cs ;
  void *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 434
  if (! src) {
    {
    {
#line 434
    __assert_fail("src", "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c",
                  434U, "canonical_string_copy");
    }
    }
  }
  {
  {
#line 435
  tmp = allocate(sizeof(struct canonical_string_impl ));
  }
#line 435
  cs = (canonical_string_h )tmp;
  {
#line 436
  canonical_string_copy_init(cs, src);
  }
  }
#line 437
  return (cs);
}
}
#line 440 "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c"
void canonical_string_dispose(canonical_string_h cs ) 
{ 


  {
#line 443
  if (cs) {
    {
    {
#line 444
    canonical_string_finis(cs);
    }
    {
#line 445
    free((void *)cs);
    }
    }
  }
#line 447
  return;
}
}
#line 449 "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c"
void canonical_string_swap(canonical_string_h lhs , canonical_string_h rhs ) 
{ 
  heap_str tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 452
  if (! lhs) {
    {
    {
#line 452
    __assert_fail("lhs", "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c",
                  452U, "canonical_string_swap");
    }
    }
  }
#line 453
  if (! rhs) {
    {
    {
#line 453
    __assert_fail("rhs", "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c",
                  453U, "canonical_string_swap");
    }
    }
  }
  {
  {
#line 454
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 454
    tmp = lhs->text;
#line 454
    lhs->text = rhs->text;
#line 454
    rhs->text = tmp;
#line 454
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 455
  return;
}
}
#line 457 "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c"
void canonical_string_assign(canonical_string_h dest , canonical_string_const_h src ) 
{ 
  canonical_string_h tmp ;
  canonical_string_h tmp___0 ;

  {
#line 460
  if ((unsigned long )dest != (unsigned long )src) {
    {
    {
#line 461
    tmp___0 = canonical_string_copy(src);
    }
#line 461
    tmp = tmp___0;
    {
#line 462
    canonical_string_swap(dest, tmp);
    }
    {
#line 463
    canonical_string_dispose(tmp);
    }
    }
  }
#line 465
  return;
}
}
#line 467 "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c"
_Bool canonical_string_equal(canonical_string_const_h lhs , canonical_string_const_h rhs ) 
{ 
  _Bool eq___0 ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 470
  eq___0 = (_Bool )((unsigned long )lhs == (unsigned long )rhs);
#line 471
  if (! lhs) {
    {
    {
#line 471
    __assert_fail("lhs", "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c",
                  471U, "canonical_string_equal");
    }
    }
  }
#line 472
  if (! rhs) {
    {
    {
#line 472
    __assert_fail("rhs", "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c",
                  472U, "canonical_string_equal");
    }
    }
  }
#line 473
  if (! eq___0) {
#line 474
    if ((unsigned long )lhs->text == (unsigned long )rhs->text) {
#line 474
      tmp___0 = 1;
    } else {
      {
      {
#line 474
      tmp = strcmp((char const   *)lhs->text, (char const   *)rhs->text);
      }
      }
#line 474
      if (tmp) {
#line 474
        tmp___0 = 0;
      } else {
#line 474
        tmp___0 = 1;
      }
    }
#line 474
    eq___0 = (_Bool )tmp___0;
  }
#line 476
  return (eq___0);
}
}
#line 479 "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c"
int canonical_string_compare(canonical_string_const_h lhs , void const   *rhs , size_t rhslen ) 
{ 
  size_t lhs_len ;
  int cmp ;
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 482
  if (! lhs) {
    {
    {
#line 482
    __assert_fail("lhs", "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c",
                  482U, "canonical_string_compare");
    }
    }
  }
#line 483
  if (! rhs) {
    {
    {
#line 483
    __assert_fail("rhs", "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c",
                  483U, "canonical_string_compare");
    }
    }
  }
#line 486
  if (! rhslen) {
#line 487
    if ((unsigned long )lhs->text == (unsigned long )((canonical_string_const_h )rhs)->text) {
#line 489
      return (0);
    }
    {
    {
#line 491
    tmp = strcmp((char const   *)lhs->text, (char const   *)((canonical_string_const_h )rhs)->text);
    }
    }
#line 491
    return (tmp);
  }
#line 493
  if (! lhs->text) {
#line 494
    return (-1);
  }
  {
  {
#line 496
  lhs_len = strlen((char const   *)lhs->text);
  }
  {
#line 497
  cmp = strncmp((char const   *)lhs->text, (char const   *)((char *)rhs), rhslen);
  }
  }
#line 498
  if (! cmp) {
#line 498
    if (*(lhs->text + rhslen)) {
#line 499
      cmp = 1;
    }
  }
#line 501
  return (cmp);
}
}
#line 504 "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c"
char const   *canonical_string_text(canonical_string_const_h cs ) 
{ 
  char const   *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 507
  if (! cs) {
    {
    {
#line 507
    __assert_fail("cs", "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c",
                  507U, "canonical_string_text");
    }
    }
  }
#line 508
  if (cs->text) {
#line 508
    tmp = (char const   */* const  */)cs->text;
  } else {
#line 508
    tmp = (char const   */* const  */)"";
  }
#line 508
  return ((char const   *)tmp);
}
}
#line 511 "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c"
size_t canonical_string_length(canonical_string_const_h cs ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 514
  if (! cs) {
    {
    {
#line 514
    __assert_fail("cs", "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c",
                  514U, "canonical_string_length");
    }
    }
  }
#line 515
  if (cs->text) {
    {
    {
#line 515
    tmp = strlen((char const   *)cs->text);
    }
#line 515
    tmp___0 = tmp;
    }
  } else {
#line 515
    tmp___0 = (size_t )0;
  }
#line 515
  return (tmp___0);
}
}
#line 518 "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c"
void canonical_string_appends(canonical_string_h cs , canonical_string_const_h more ,
                              _Bool punct ) 
{ 
  size_t cs_len ;
  size_t tmp ;
  size_t more_len ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  {
  {
#line 522
  tmp = canonical_string_length((canonical_string_const_h )cs);
  }
#line 522
  cs_len = tmp;
  {
#line 523
  tmp___0 = canonical_string_length(more);
  }
#line 523
  more_len = tmp___0;
  }
#line 524
  if (more_len) {
#line 525
    if (! cs_len) {
      {
      {
#line 526
      canonical_string_assign(cs, more);
      }
      }
    } else {
      {
      {
#line 528
      tmp___1 = reallocate((void *)cs->text, ((cs_len + more_len) + 1UL) + (size_t )((int )punct));
      }
#line 528
      cs->text = (heap_str )tmp___1;
      }
#line 529
      if (punct) {
#line 530
        tmp___2 = cs_len;
#line 530
        cs_len ++;
#line 530
        *(cs->text + tmp___2) = (char )' ';
      }
      {
      {
#line 532
      strcpy((char */* __restrict  */)(cs->text + cs_len), (char const   */* __restrict  */)more->text);
      }
      }
    }
  }
#line 535
  return;
}
}
#line 537 "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c"
void canonical_string_appendc(canonical_string_h cs , char more ) 
{ 
  size_t cs_len ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
  {
  {
#line 540
  tmp = canonical_string_length((canonical_string_const_h )cs);
  }
#line 540
  cs_len = tmp;
  {
#line 541
  tmp___0 = reallocate((void *)cs->text, cs_len + 2UL);
  }
#line 541
  cs->text = (heap_str )tmp___0;
#line 542
  tmp___1 = cs_len;
#line 542
  cs_len ++;
#line 542
  *(cs->text + tmp___1) = more;
#line 543
  *(cs->text + cs_len) = (char)0;
  }
#line 544
  return;
}
}
#line 546 "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c"
canonical_string_h canonical_string_substr(canonical_string_const_h cs , size_t start ,
                                           size_t len ) 
{ 
  canonical_string_h substr ;
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 549
  substr = (canonical_string_h )((void *)0);
#line 550
  if (! cs) {
    {
    {
#line 550
    __assert_fail("cs", "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c",
                  550U, "canonical_string_substr");
    }
    }
  }
  {
  {
#line 551
  tmp___1 = canonical_string_length(cs);
  }
  }
#line 551
  if (start < tmp___1) {
    {
    {
#line 552
    tmp = zallocate(sizeof(struct canonical_string_impl ));
    }
#line 552
    substr = (canonical_string_h )tmp;
    {
#line 553
    tmp___0 = clone((void const   *)(cs->text + start), len);
    }
#line 553
    substr->text = (heap_str )tmp___0;
    }
  }
#line 555
  return (substr);
}
}
#line 558 "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c"
void canonical_string_replace(canonical_string_h cs , size_t start , size_t len ,
                              canonical_string_const_h subst ) 
{ 
  size_t cs_len ;
  size_t subst_len ;
  size_t tail_len ;
  heap_str text ;
  void *tmp ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 565
  if (! cs) {
    {
    {
#line 565
    __assert_fail("cs", "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c",
                  565U, "canonical_string_replace");
    }
    }
  }
#line 566
  if (! subst) {
    {
    {
#line 566
    __assert_fail("subst", "/home/wslee/tests/SOURCES/coan-4.2.2/src/canonical_string.c",
                  566U, "canonical_string_replace");
    }
    }
  }
  {
  {
#line 567
  cs_len = canonical_string_length((canonical_string_const_h )cs);
  }
  {
#line 568
  subst_len = canonical_string_length(subst);
  }
  }
#line 569
  if (start < cs_len) {
#line 572
    if (start + len < cs_len) {
#line 573
      tail_len = cs_len - (start + len);
    } else {
#line 576
      tail_len = (size_t )0;
    }
    {
    {
#line 578
    tmp = zallocate(((start + subst_len) + tail_len) + 1UL);
    }
#line 578
    text = (heap_str )tmp;
    }
#line 579
    if (start) {
      {
      {
#line 580
      memcpy((void */* __restrict  */)text, (void const   */* __restrict  */)cs->text,
             start);
      }
      }
    }
#line 582
    if (subst_len) {
      {
      {
#line 583
      memcpy((void */* __restrict  */)(text + start), (void const   */* __restrict  */)subst->text,
             subst_len);
      }
      }
    }
#line 585
    if (tail_len) {
      {
      {
#line 586
      memcpy((void */* __restrict  */)((text + start) + subst_len), (void const   */* __restrict  */)((cs->text + start) + len),
             tail_len);
      }
      }
    }
    {
    {
#line 588
    free((void *)cs->text);
    }
#line 589
    cs->text = text;
    }
  }
#line 591
  return;
}
}
#line 333 "/usr/include/stdio.h"
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 682
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 722
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 727
extern long ftell(FILE *__stream ) ;
#line 346 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2))) strtok)(char * __restrict  __s ,
                                                                                     char const   * __restrict  __delim ) ;
#line 180 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.h"
void args_finitor(void) ;
#line 78 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c"
static args_state_t args_state  ;
#line 78 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c"
args_state_t *args_h  =    & args_state;
#line 78 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c"
args_public_state_t *args_public_h  =    (args_public_state_t *)(& args_state);
#line 78 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c"
static args_state_t const   * const  args_static_initialiser_h  ;
#line 78
void (*args_init_h)(args_state_t * ) ;
#line 78
void (*args_finis_h)(args_state_t * ) ;
#line 78 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c"
void args_initor(void) 
{ 


  {
  {
  {
#line 78
  component_initor((_Bool)1, (_Bool)0, (void **)((char *)(& args_h)), (void **)((char *)(& args_public_h)),
                   (void const   *)args_static_initialiser_h, sizeof(args_state_t ),
                   (void (*)())args_init_h);
  }
  }
#line 78
  return;
}
}
#line 78 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c"
void args_finitor(void) 
{ 


  {
  {
  {
#line 78
  component_finitor((_Bool)1, (void **)((char *)(& args_h)), (void **)((char *)(& args_public_h)),
                    (void (*)())args_init_h);
  }
  }
#line 78
  return;
}
}
#line 84
void args_init(args_state_t *args_st ) ;
#line 84 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c"
void (*args_init_h)(args_state_t * )  =    & args_init;
#line 84 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c"
void args_init(args_state_t *args_st ) 
{ 


  {
  {
  {
#line 86
  args_st->argfile_argv = ptr_vector_new((void (*)(void * ))((void *)0), (void *(*)(void const   * ))((void *)0));
  }
  }
#line 87
  return;
}
}
#line 93
void args_finis(args_state_t *args_st ) ;
#line 93 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c"
void (*args_finis_h)(args_state_t * )  =    & args_finis;
#line 93 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c"
void args_finis(args_state_t *args_st ) 
{ 


  {
  {
  {
#line 95
  ptr_vector_dispose(args_state.argfile_argv);
  }
#line 96
  args_state.argfile_argv = (ptr_vector_h )((void *)0);
  }
#line 97
  return;
}
}
#line 143 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c"
static struct option long_options[30]  = 
#line 143
  {      {"file", 1, (int *)((void *)0), 102}, 
        {"replace", 0, (int *)((void *)0), 114}, 
        {"backup", 1, (int *)((void *)0), 98}, 
        {"define", 1, (int *)((void *)0), 68}, 
        {"undef", 1, (int *)((void *)0), 85}, 
        {"conflict", 1, (int *)((void *)0), 120}, 
        {"gag", 1, (int *)((void *)0), 103}, 
        {"verbose", 0, (int *)((void *)0), 86}, 
        {"complement", 0, (int *)((void *)0), 99}, 
        {"debug", 0, (int *)((void *)0), 1}, 
        {"evalconsts", 0, (int *)((void *)0), 69}, 
        {"discard", 1, (int *)((void *)0), 107}, 
        {"line", 0, (int *)((void *)0), 2}, 
        {"pod", 0, (int *)((void *)0), 80}, 
        {"recurse", 0, (int *)((void *)0), 82}, 
        {"filter", 1, (int *)((void *)0), 70}, 
        {"keepgoing", 0, (int *)((void *)0), 75}, 
        {"ifs", 0, (int *)((void *)0), 105}, 
        {"defs", 0, (int *)((void *)0), 100}, 
        {"undefs", 0, (int *)((void *)0), 117}, 
        {"includes", 0, (int *)((void *)0), 3}, 
        {"locate", 0, (int *)((void *)0), 76}, 
        {"once", 0, (int *)((void *)0), 111}, 
        {"system", 0, (int *)((void *)0), 115}, 
        {"local", 0, (int *)((void *)0), 108}, 
        {"active", 0, (int *)((void *)0), 65}, 
        {"inactive", 0, (int *)((void *)0), 73}, 
        {"evalsyms", 0, (int *)((void *)0), 101}, 
        {"implicit", 0, (int *)((void *)0), 109}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 181 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c"
static char opts[(sizeof(long_options) / sizeof(struct option )) * 3UL]  ;
#line 184 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c"
static struct cmd_option commands[14]  = 
#line 184
  {      {"help", 1, 1}, 
        {"-h", 1, 1}, 
        {"--help", 1, 1}, 
        {"version", 2, 2}, 
        {"-v", 2, 2}, 
        {"--version", 2, 2}, 
        {"source", 3, 4}, 
        {"symbols", 4, 8}, 
        {"includes", 5, 16}, 
        {"defs", 6, 32}, 
        {"pragmas", 7, 64}, 
        {"errors", 8, 128}, 
        {"directives", 9, 240}, 
        {(char const   *)0, 0, 0}};
#line 202 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c"
static int const   source_cmd_exclusions[12]  = 
#line 202
  {      (int const   )105,      (int const   )100,      (int const   )117,      (int const   )3, 
        (int const   )76,      (int const   )111,      (int const   )115,      (int const   )108, 
        (int const   )65,      (int const   )73,      (int const   )101,      (int const   )0};
#line 208 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c"
static int const   symbols_cmd_exclusions[9]  = 
#line 208
  {      (int const   )114,      (int const   )120,      (int const   )107,      (int const   )2, 
        (int const   )115,      (int const   )108,      (int const   )98,      (int const   )99, 
        (int const   )0};
#line 213 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c"
static int const   includes_cmd_exclusions[12]  = 
#line 213
  {      (int const   )114,      (int const   )120,      (int const   )107,      (int const   )2, 
        (int const   )98,      (int const   )105,      (int const   )100,      (int const   )117, 
        (int const   )3,      (int const   )99,      (int const   )101,      (int const   )0};
#line 218 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c"
static int const   directives_cmd_exclusions[12]  = 
#line 218
  {      (int const   )114,      (int const   )120,      (int const   )107,      (int const   )2, 
        (int const   )98,      (int const   )105,      (int const   )100,      (int const   )117, 
        (int const   )3,      (int const   )99,      (int const   )101,      (int const   )0};
#line 223 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c"
static int const   defs_cmd_exclusions[14]  = 
#line 223
  {      (int const   )114,      (int const   )120,      (int const   )107,      (int const   )2, 
        (int const   )98,      (int const   )115,      (int const   )108,      (int const   )105, 
        (int const   )100,      (int const   )117,      (int const   )3,      (int const   )99, 
        (int const   )101,      (int const   )0};
#line 229 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c"
static int const   pragmas_cmd_exclusions[14]  = 
#line 229
  {      (int const   )114,      (int const   )120,      (int const   )107,      (int const   )2, 
        (int const   )98,      (int const   )115,      (int const   )108,      (int const   )105, 
        (int const   )100,      (int const   )117,      (int const   )3,      (int const   )99, 
        (int const   )101,      (int const   )0};
#line 235 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c"
static int const   errors_cmd_exclusions[14]  = 
#line 235
  {      (int const   )114,      (int const   )120,      (int const   )107,      (int const   )2, 
        (int const   )98,      (int const   )115,      (int const   )108,      (int const   )105, 
        (int const   )100,      (int const   )117,      (int const   )3,      (int const   )99, 
        (int const   )101,      (int const   )0};
#line 246 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c"
static struct exclusion_list  const  cmd_exclusion_lists[11]  = 
#line 246
  {      {0, (int const   *)((void *)0)}, 
        {1, (int const   *)((void *)0)}, 
        {2, (int const   *)((void *)0)}, 
        {3, source_cmd_exclusions}, 
        {4, symbols_cmd_exclusions}, 
        {5, includes_cmd_exclusions}, 
        {6, defs_cmd_exclusions}, 
        {7, pragmas_cmd_exclusions}, 
        {8, errors_cmd_exclusions}, 
        {9, directives_cmd_exclusions}, 
        {0, (int const   *)((void *)0)}};
#line 277 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c"
static void make_opts_list(void) 
{ 
  struct option *longopt ;
  char *opts_str ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 280
  longopt = long_options;
#line 281
  opts_str = opts;
  {
  {
#line 282
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 282
    if (! longopt->name) {
#line 282
      goto while_break;
    }
#line 283
    *opts_str = (char )longopt->val;
    {
#line 285
    if (longopt->has_arg == 0) {
#line 285
      goto case_0;
    }
#line 287
    if (longopt->has_arg == 2) {
#line 287
      goto case_2;
    }
#line 291
    if (longopt->has_arg == 1) {
#line 291
      goto case_1;
    }
#line 295
    goto switch_default;
    case_0: /* CIL Label */ 
#line 286
    goto switch_break;
    case_2: /* CIL Label */ 
#line 288
    opts_str ++;
#line 289
    *opts_str = (char )':';
    case_1: /* CIL Label */ 
#line 292
    opts_str ++;
#line 293
    *opts_str = (char )':';
#line 294
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    {
#line 296
    __assert_fail("0", "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c", 296U, "make_opts_list");
    }
    }
    switch_break: /* CIL Label */ ;
    }
#line 282
    longopt ++;
#line 282
    opts_str ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 299
  return;
}
}
#line 305 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c"
static void usage(FILE *fp ) 
{ 
  char const   *prog_name ;
  char *__cil_tmp3 ;

  {
  {
#line 308
  prog_name = (char const   *)args_public_h->prog_name;
  {
#line 310
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"usage:\n%s COMMAND [OPTION... [FILE...]]\n1. %s { help | --help | -h }\n\tDisplay this message and exit.\n2. %s { version | --version | -v }\n\tDisplay version information and exit.\n3. %s source OPTION... [FILE...]\n\tSimplify source FILEs in accordance with OPTIONs, parsing in the manner of the C preprocessor.\n\tInput lines may be dropped from output. Truth functional directives may be simplified on output.\n4. %s symbols OPTION... [FILE...]\n\tList preprocessor symbols from FILEs in accordance with OPTIONs, parsing in the manner of the C preprocessor.\n5. %s includes OPTION... [FILE...]\n\tList #includes fom FILEs in accordance with OPTIONs, parsing in the manner of the C preprocessor\n6. %s defs OPTION... [FILE...]\n\tList #defines and #undefs fom FILEs in accordance with OPTIONs, parsing in the manner of the C preprocessor.\n7. %s pragmas OPTION... [FILE...]\n\tList #pragmas fom FILEs in accordance with OPTIONs, parsing in the manner of the C preprocessor\n8. %s directives OPTION... [FILE...]\n\tList #-directives fom FILEs in accordance with OPTIONs, parsing in the manner of the C preprocessor. (Directives are #includes, #defines, #undefs, #pragmas, #errors).\nGeneral OPTIONS:\n\t-fARGFILE, --file ARGFILE\n\t\tRead other arguments from ARGFILE.\n\t-R, --recurse\n\t\tRecurse into directories to find input files.\n\t-FEXT1[,EXT2...]\n\t--filter EXT1[,EXT2...]\n\t\tProcess only input files that have one of the file extensions EXT1,EXT2...\n\t-DSYM[=VAL], --define SYM[=VAL]\n\t\tAssume symbol SYM to be defined [=VAL]\n\t-USYM, --undef SYM\n\t\tAssume symbol SYM to be undefined.\n\t-m, --implicit\n\t\tAssume that any symbol that is not --define-ed is implicitly --undef-ed.\n\t-g{p|i|w|e|a},\n\t--gag { progress| info | warning | error | abend }\n\t\tSuppress diagnostics no worse than {progress | info | warning | error | abend}.\n\t-gs, --gag summary\n\t\tSuppress summary diagnostics at exit.\n\t\t(Default: -gp -gi -gs)\n\t-V, --verbose\n\t\tOutput all diagnostics.\n\t--debug\n\t\tDisplay debugging info.\n\t-K, --keepgoing\n\t\tIf a parse error is encountered in an input file, continue processing subsequent input files.\n\t-P, --pod\n\t\tApart from #-directives, input is Plain Old Data.\n\t\tComments and quotations will not be parsed.\n\t-E, --evalconsts\n\t\tEvaluate constants occurring as truth-functional operands #ifs. By default constants as truth-functional operands are not evaluated.\nsource OPTIONs:-\n\t-r, --replace\n\t\tOverwrite input file with output file. Implied by --recurse\n\t\tWith -r, stdin supplies the input *filenames*.\n\t\tOtherwise stdin supplies an input *file*; the output file is stdout.\n\t-BSUFFIX, --backup SUFFIX\n\t\tBackup each input file by appending SUFFIX to the name.\n\t\tApplies only with -r.\n\t-kd, --discard drop\n\t\tDrop discarded lines from output.\n\t-kb, --discard blank\n\t\tBlank discarded lines on output.\n\t-kc, --discard comment\n\t\tComment out discarded lines on output.\n\t-xd, --conflict delete\n\t\tDelete #defines and #undefs that contradict -D or -U options.\n\t-xc, --conflict comment\n\t\tInsert diagnostic comments on contradictions as per -xd. (Default.)\n\t-xe, --conflict error\n\t\tInsert diagnostic #errors on contradictions as per -xd.\n\t--line\n\t\tGenerate #line directives to make CPP line-numbering of output agree with input even of lines are dropped.\n\t-c, --complement\n\t\tComplement. Retain the lines that ought to be dropped and vice versa.\n\t\t(Retained #-directives will still be simplified where possible.)\nsymbols OPTIONs:-\n\t-i, --ifs\n\t\tList symbols that occur #if[[n]def]/#elif directives.\n\t-d, --defs\n\t\tList symbols that occur in #define directives.\n\t-u, --undefs\n\t\tList symbols that occur in #undef directives.\n\t--includes\n\t\tList symbols that occur in #include directives.\n\t(Default: -i -d -u --includes)\n\t-o, --once\n\t\tList only the first occurrence of each symbol. (Default: List all occurrences.)\n\t-A, --active\n\t\tList only symbols from operative directives\n\t-I, --inactive\n\t\tList only symbols from inoperative directives\n\t-L, --locate\n\t\tReport the source file and line number of each listed occurrence.\n\t-e, --evalsyms\n\t\tReport the resolved value of each symbol.\nincludes OPTIONs:-\n\t-s, --system\n\t\tList system headers, i.e. <header.h>\n\t-L, --local\n\t\tList local headers, i.e. \"header.h\"\n\t(Default: -s -L)\n\t-o, --once\n\t\tList only the first occurrence of each header. (Default: List all occurrences.)\n\t-A --active\n\t\tList only headers from operative directives.\n\t-I --inactive\n\t\tList only headers from inoperative directives.\n\t-L, --locate\n\t\tReport the source file and line number of each listed occurrence.\ndefs OPTIONs:-\n\t-o, --once\n\t\tList only the first occurrence of each distinct #define or #undef directive (Default: List all occurrences.)\n\t-A --active\n\t\tList only operative #define and #undef directives.\n\t-I --inactive\n\t\tList only inoperative #define and #undef directives.\n\t-L, --locate\n\t\tReport the source file and line number of each listed occurrence.\npragmas OPTIONs:-\n\t-o, --once\n\t\tList only the first occurrence of each distinct pragma (Default: List all occurrences.)\n\t-A, --active\n\t\tList only pragmas from lines that are retained.\n\t-I, --inactive\n\t\tList only pragmas from lines that are dropped.\n\t-L, --locate\n\t\tReport the source file and line number of each listed occurrence.\nerrors OPTIONs:-\n\t-o, --once\n\t\tList only the first occurrence of each #error directive (Default: List all occurrences.)\n\t-A, --active\n\t\tList only operative #error directives.\n\t-I, --inactive\n\t\tList only inoperative #error directives.\n\t-L, --locate\n\t\tReport the source file and line number of each listed occurrence.\ndirectives OPTIONs:-\n\t-o, --once\n\t\tList only the first occurrence of each distinct directive (Default: List all occurrences.)\n\t-A, --active\n\t\tList only operative directives.\n\t-I, --inactive\n\t\tList only inoperative directives.\n\t-L, --locate\n\t\tReport the source file and line number of each listed occurrence.\n",
          prog_name, prog_name, prog_name, prog_name, prog_name, prog_name, prog_name,
          prog_name, prog_name);
  }
  }
#line 487
  return;
}
}
#line 492 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c"
static void usage_error_summary(void) 
{ 


  {
  {
  {
#line 495
  usage(stderr);
  }
  }
#line 496
  return;
}
}
#line 507 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c"
static void usage_error(int reason , char const   *format  , ...) 
{ 
  va_list argp ;
  char *__cil_tmp4 ;

  {
#line 510
  if (format) {
    {
    {
#line 512
    atexit(& usage_error_summary);
    }
    {
#line 513
    __builtin_va_start(argp, format);
    }
    {
#line 514
    vbail(reason, format, argp);
    }
    {
#line 515
    __builtin_va_end(argp);
    }
    }
  } else {
    {
    {
#line 517
    usage_error(16704, "Invalid usage");
    }
    }
  }
#line 519
  return;
}
}
#line 525 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c"
static void usage_help(void) 
{ 


  {
  {
  {
#line 528
  usage(stdout);
  }
  {
#line 529
  exit(0);
  }
  }
}
}
#line 543 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c"
static void version(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 546
  printf((char const   */* __restrict  */)"%s, version %s for %s (built %s, %s)\n",
         args_public_h->prog_name, "4.2.2", "Unix/Linux", "Apr  6 2011", "13:52:02");
  }
  {
#line 548
  exit(0);
  }
  }
}
}
#line 555 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c"
static void config_diagnostics(char const   *arg ) 
{ 
  int mask ;
  int tmp ;
  int diagnostic_filter ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 558
  mask = 0;
#line 559
  if (args_public_h->diagnostic_filter < 0) {
    {
    {
#line 559
    tmp = strcmp(arg, "verbose");
    }
    }
#line 559
    if (tmp) {
      {
      {
#line 560
      report((reason_code_t )8656, (heap_str *)((void *)0), "Can\'t mix --verbose with --gag.\'--gag %s\' ignored",
             arg);
      }
      }
#line 562
      return;
    }
  }
  {
  {
#line 564
  tmp___6 = strcmp(arg, "progress");
  }
  }
#line 564
  if (tmp___6) {
    {
    {
#line 566
    tmp___5 = strcmp(arg, "info");
    }
    }
#line 566
    if (tmp___5) {
      {
      {
#line 568
      tmp___4 = strcmp(arg, "warning");
      }
      }
#line 568
      if (tmp___4) {
        {
        {
#line 570
        tmp___3 = strcmp(arg, "error");
        }
        }
#line 570
        if (tmp___3) {
          {
          {
#line 572
          tmp___2 = strcmp(arg, "abort");
          }
          }
#line 572
          if (tmp___2) {
            {
            {
#line 574
            tmp___1 = strcmp(arg, "summary");
            }
            }
#line 574
            if (tmp___1) {
              {
              {
#line 576
              tmp___0 = strcmp(arg, "verbose");
              }
              }
#line 576
              if (tmp___0) {
                {
                {
#line 589
                usage_error(16704, "Invalid argument for --gag: \"%s\"", arg);
                }
                }
              } else {
#line 577
                diagnostic_filter = args_public_h->diagnostic_filter;
#line 578
                if (diagnostic_filter > 0) {
                  {
                  {
#line 579
                  report((reason_code_t )8656, (heap_str *)((void *)0), "Can\'t mix --verbose with --gag. \'--verbose\' ignored");
                  }
                  }
#line 581
                  return;
                } else
#line 582
                if (diagnostic_filter < 0) {
                  {
                  {
#line 583
                  report((reason_code_t )4528, (heap_str *)((void *)0), "\'--verbose\' already seen");
                  }
                  }
#line 584
                  return;
                }
#line 586
                args_public_h->diagnostic_filter = -1;
#line 587
                return;
              }
            } else {
#line 575
              mask = 65536;
            }
          } else {
#line 573
            mask = 32768;
          }
        } else {
#line 571
          mask = 16384;
        }
      } else {
#line 569
        mask = 8192;
      }
    } else {
#line 567
      mask = 4096;
    }
  } else {
#line 565
    mask = 2048;
  }
#line 591
  if (mask & args_public_h->diagnostic_filter) {
    {
    {
#line 592
    report((reason_code_t )4528, (heap_str *)((void *)0), "\'--gag %s\' already seen",
           arg);
    }
    }
  }
#line 595
  args_public_h->diagnostic_filter |= mask;
#line 596
  if (mask == 4096) {
    {
    {
#line 597
    config_diagnostics("progress");
    }
    }
  } else
#line 598
  if (mask == 8192) {
    {
    {
#line 599
    config_diagnostics("info");
    }
    }
  } else
#line 600
  if (mask == 16384) {
    {
    {
#line 601
    config_diagnostics("warning");
    }
    }
  } else
#line 602
  if (mask == 32768) {
    {
    {
#line 603
    config_diagnostics("error");
    }
    }
  }
#line 605
  return;
}
}
#line 612 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c"
static void finalise_diagnostics(void) 
{ 
  int mask ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
#line 615
  mask = args_public_h->diagnostic_filter;
#line 616
  if (! mask) {
    {
    {
#line 619
    config_diagnostics("info");
    }
    {
#line 620
    config_diagnostics("summary");
    }
    }
  } else
#line 621
  if (mask == -1) {
#line 624
    args_public_h->diagnostic_filter = 0;
  }
#line 626
  return;
}
}
#line 633 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c"
static void error_invalid_opt(cmd_option_t const   *cmd , int bad_opt ) 
{ 
  char const   *cmdname ;
  char const   *optname ;
  char const   *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 636
  cmdname = (char const   *)cmd->name;
  {
#line 637
  tmp = get_long_opt_name((struct option  const  *)(long_options), bad_opt);
  }
#line 637
  optname = tmp;
  }
#line 638
  if (! optname) {
    {
    {
#line 638
    __assert_fail("optname", "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c", 638U,
                  "error_invalid_opt");
    }
    }
  }
  {
  {
#line 639
  usage_error(16688, "\"%s\" is not a valid option for command \"%s\"", optname, cmdname);
  }
  }
#line 641
  return;
}
}
#line 663 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c"
static _Bool add_files(char const   *path ) 
{ 
  fs_obj_type_t obj_type ;
  fs_obj_type_t tmp ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 666
  tmp = fs_file_or_dir(path);
  }
#line 666
  obj_type = tmp;
  }
#line 667
  if (((unsigned int )obj_type & 2U) != 0U) {
    {
    {
#line 668
    dataset_add(path);
    }
    }
#line 669
    return ((_Bool)1);
  } else
#line 667
  if (args_public_h->recurse) {
    {
    {
#line 668
    dataset_add(path);
    }
    }
#line 669
    return ((_Bool)1);
  }
  {
  {
#line 671
  report((reason_code_t )8848, (heap_str *)((void *)0), "--recurse not specified. Ignoring directory \"%s\"",
         path);
  }
  }
#line 673
  return ((_Bool)0);
}
}
#line 677
static void parse_args_file(char const   *argsfile ) ;
#line 688 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c"
static _Bool parsing_file  ;
#line 685 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c"
static void parse_command_args(int argc , char **argv ) 
{ 
  int args ;
  int opt ;
  int save_ind ;
  int long_index ;
  cmd_option_t const   *command ;
  _Bool tmp ;
  int conflict_policy ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  char const   *gag_arg ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  heap_str argstr ;
  heap_str tmp___9 ;
  ptr_set_h st ;
  size_t tmp___10 ;
  _Bool tmp___11 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;

  {
#line 689
  args = argc;
#line 691
  command = (cmd_option_t const   *)args_public_h->command;
#line 694
  if (! opts[0]) {
    {
    {
#line 695
    make_opts_list();
    }
    }
  }
#line 697
  optind = 0;
  {
  {
#line 697
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 697
    opt = getopt_long(argc, argv, (char const   *)(opts), (struct option  const  *)(long_options),
                      & long_index);
    }
    }
#line 697
    if (! (opt != -1)) {
#line 697
      goto while_break;
    }
    {
    {
#line 699
    tmp = opts_are_compatible((int )command->cmd_code, opt, cmd_exclusion_lists, (_Bool)1);
    }
    }
#line 699
    if (! tmp) {
      {
      {
#line 700
      error_invalid_opt(command, opt);
      }
      }
    }
    {
#line 703
    if (opt == 102) {
#line 703
      goto case_102;
    }
#line 711
    if (opt == 120) {
#line 711
      goto case_120;
    }
#line 743
    if (opt == 103) {
#line 743
      goto case_103;
    }
#line 772
    if (opt == 86) {
#line 772
      goto case_86;
    }
#line 775
    if (opt == 68) {
#line 775
      goto case_68;
    }
#line 778
    if (opt == 85) {
#line 778
      goto case_85;
    }
#line 781
    if (opt == 99) {
#line 781
      goto case_99___0;
    }
#line 784
    if (opt == 114) {
#line 784
      goto case_114;
    }
#line 787
    if (opt == 98) {
#line 787
      goto case_98;
    }
#line 790
    if (opt == 1) {
#line 790
      goto case_1;
    }
#line 793
    if (opt == 69) {
#line 793
      goto case_69;
    }
#line 796
    if (opt == 107) {
#line 796
      goto case_107;
    }
#line 825
    if (opt == 2) {
#line 825
      goto case_2;
    }
#line 828
    if (opt == 76) {
#line 828
      goto case_76;
    }
#line 831
    if (opt == 65) {
#line 831
      goto case_65;
    }
#line 834
    if (opt == 73) {
#line 834
      goto case_73;
    }
#line 837
    if (opt == 101) {
#line 837
      goto case_101___1;
    }
#line 840
    if (opt == 111) {
#line 840
      goto case_111;
    }
#line 843
    if (opt == 105) {
#line 843
      goto case_105___0;
    }
#line 846
    if (opt == 100) {
#line 846
      goto case_100___1;
    }
#line 849
    if (opt == 117) {
#line 849
      goto case_117;
    }
#line 852
    if (opt == 3) {
#line 852
      goto case_3;
    }
#line 855
    if (opt == 115) {
#line 855
      goto case_115___0;
    }
#line 858
    if (opt == 108) {
#line 858
      goto case_108;
    }
#line 861
    if (opt == 80) {
#line 861
      goto case_80;
    }
#line 864
    if (opt == 82) {
#line 864
      goto case_82;
    }
#line 870
    if (opt == 70) {
#line 870
      goto case_70;
    }
#line 873
    if (opt == 75) {
#line 873
      goto case_75;
    }
#line 877
    if (opt == 109) {
#line 877
      goto case_109;
    }
#line 880
    goto switch_default___2;
    case_102: /* CIL Label */ 
    {
#line 704
    save_ind = optind;
#line 706
    parsing_file = (_Bool)1;
    {
#line 707
    parse_args_file((char const   *)optarg);
    }
#line 708
    parsing_file = (_Bool)0;
#line 709
    optind = save_ind;
    }
#line 710
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 712
    conflict_policy = 1;
    {
#line 713
    tmp___3 = strlen((char const   *)optarg);
    }
    }
#line 713
    if (tmp___3 > 1UL) {
      {
      {
#line 714
      tmp___2 = strcmp((char const   *)optarg, "delete");
      }
      }
#line 714
      if (tmp___2) {
        {
        {
#line 716
        tmp___1 = strcmp((char const   *)optarg, "comment");
        }
        }
#line 716
        if (tmp___1) {
          {
          {
#line 718
          tmp___0 = strcmp((char const   *)optarg, "error");
          }
          }
#line 718
          if (tmp___0) {
            {
            {
#line 721
            usage_error(16704, "Invalid argument for --conflict: \"%s\"", optarg);
            }
            }
          } else {
#line 719
            conflict_policy = 2;
          }
        } else {
#line 717
          conflict_policy = 1;
        }
      } else {
#line 715
        conflict_policy = 0;
      }
    } else {
      {
#line 726
      if ((int )*optarg == 100) {
#line 726
        goto case_100;
      }
#line 729
      if ((int )*optarg == 99) {
#line 729
        goto case_99;
      }
#line 732
      if ((int )*optarg == 101) {
#line 732
        goto case_101;
      }
#line 735
      goto switch_default;
      case_100: /* CIL Label */ 
#line 727
      conflict_policy = 0;
#line 728
      goto switch_break___0;
      case_99: /* CIL Label */ 
#line 730
      conflict_policy = 1;
#line 731
      goto switch_break___0;
      case_101: /* CIL Label */ 
#line 733
      conflict_policy = 2;
#line 734
      goto switch_break___0;
      switch_default: /* CIL Label */ 
      {
      {
#line 736
      usage_error(16704, "Invalid argument for -x: \"%c\"", (int )*optarg);
      }
      }
      switch_break___0: /* CIL Label */ ;
      }
    }
    {
    {
#line 740
    contradiction_policy((contradiction_policy_t )conflict_policy);
    }
    }
#line 742
    goto switch_break;
    case_103: /* CIL Label */ 
    {
#line 744
    gag_arg = (char const   *)optarg;
    {
#line 745
    tmp___4 = strlen((char const   *)optarg);
    }
    }
#line 745
    if (tmp___4 == 1UL) {
      {
#line 747
      if ((int )*optarg == 112) {
#line 747
        goto case_112;
      }
#line 750
      if ((int )*optarg == 105) {
#line 750
        goto case_105;
      }
#line 753
      if ((int )*optarg == 119) {
#line 753
        goto case_119;
      }
#line 756
      if ((int )*optarg == 101) {
#line 756
        goto case_101___0;
      }
#line 759
      if ((int )*optarg == 97) {
#line 759
        goto case_97;
      }
#line 762
      if ((int )*optarg == 115) {
#line 762
        goto case_115;
      }
#line 765
      goto switch_default___0;
      case_112: /* CIL Label */ 
#line 748
      gag_arg = "progress";
#line 749
      goto switch_break___1;
      case_105: /* CIL Label */ 
#line 751
      gag_arg = "info";
#line 752
      goto switch_break___1;
      case_119: /* CIL Label */ 
#line 754
      gag_arg = "warning";
#line 755
      goto switch_break___1;
      case_101___0: /* CIL Label */ 
#line 757
      gag_arg = "error";
#line 758
      goto switch_break___1;
      case_97: /* CIL Label */ 
#line 760
      gag_arg = "abend";
#line 761
      goto switch_break___1;
      case_115: /* CIL Label */ 
#line 763
      gag_arg = "summary";
#line 764
      goto switch_break___1;
      switch_default___0: /* CIL Label */ 
      {
      {
#line 766
      __assert_fail("0", "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c", 764U,
                    "parse_command_args");
      }
      }
      switch_break___1: /* CIL Label */ ;
      }
    }
    {
    {
#line 769
    config_diagnostics(gag_arg);
    }
    }
#line 771
    goto switch_break;
    case_86: /* CIL Label */ 
    {
    {
#line 773
    config_diagnostics("verbose");
    }
    }
#line 774
    goto switch_break;
    case_68: /* CIL Label */ 
    {
    {
#line 776
    symbol_evaluate_status((_Bool)1, (char const   *)optarg, (char const   *)((void *)0),
                           (char const   **)((void *)0));
    }
    }
#line 777
    goto switch_break;
    case_85: /* CIL Label */ 
    {
    {
#line 779
    symbol_evaluate_status((_Bool)0, (char const   *)optarg, (char const   *)((void *)0),
                           (char const   **)((void *)0));
    }
    }
#line 780
    goto switch_break;
    case_99___0: /* CIL Label */ 
#line 782
    args_public_h->complement = (_Bool)1;
#line 783
    goto switch_break;
    case_114: /* CIL Label */ 
#line 785
    args_public_h->replace = (_Bool)1;
#line 786
    goto switch_break;
    case_98: /* CIL Label */ 
#line 788
    args_public_h->backup_suffix = optarg;
#line 789
    goto switch_break;
    case_1: /* CIL Label */ 
    {
    {
#line 791
    debugging((_Bool)1);
    }
    }
#line 792
    goto switch_break;
    case_69: /* CIL Label */ 
#line 794
    args_public_h->eval_consts = (_Bool)1;
#line 795
    goto switch_break;
    case_107: /* CIL Label */ 
    {
    {
#line 797
    tmp___8 = strlen((char const   *)optarg);
    }
    }
#line 797
    if (tmp___8 > 1UL) {
      {
      {
#line 798
      tmp___7 = strcmp("drop", (char const   *)optarg);
      }
      }
#line 798
      if (tmp___7) {
        {
        {
#line 800
        tmp___6 = strcmp("blank", (char const   *)optarg);
        }
        }
#line 800
        if (tmp___6) {
          {
          {
#line 802
          tmp___5 = strcmp("comment", (char const   *)optarg);
          }
          }
#line 802
          if (tmp___5) {
            {
            {
#line 805
            usage_error(16704, "Invalid argument for --discard: \"%s\"", optarg);
            }
            }
          } else {
#line 803
            args_public_h->discard_policy = (discard_policy_t )2;
          }
        } else {
#line 801
          args_public_h->discard_policy = (discard_policy_t )1;
        }
      } else {
#line 799
        args_public_h->discard_policy = (discard_policy_t )0;
      }
    } else {
      {
#line 810
      if ((int )*optarg == 100) {
#line 810
        goto case_100___0;
      }
#line 813
      if ((int )*optarg == 98) {
#line 813
        goto case_98___0;
      }
#line 816
      if ((int )*optarg == 99) {
#line 816
        goto case_99___1;
      }
#line 819
      goto switch_default___1;
      case_100___0: /* CIL Label */ 
#line 811
      args_public_h->discard_policy = (discard_policy_t )0;
#line 812
      goto switch_break___2;
      case_98___0: /* CIL Label */ 
#line 814
      args_public_h->discard_policy = (discard_policy_t )1;
#line 815
      goto switch_break___2;
      case_99___1: /* CIL Label */ 
#line 817
      args_public_h->discard_policy = (discard_policy_t )2;
#line 818
      goto switch_break___2;
      switch_default___1: /* CIL Label */ 
      {
      {
#line 820
      usage_error(16704, "Invalid argument for -k: \"%c\"", (int )*optarg);
      }
      }
      switch_break___2: /* CIL Label */ ;
      }
    }
#line 824
    goto switch_break;
    case_2: /* CIL Label */ 
#line 826
    args_public_h->line_directives = (_Bool)1;
#line 827
    goto switch_break;
    case_76: /* CIL Label */ 
#line 829
    args_public_h->list_locate = (_Bool)1;
#line 830
    goto switch_break;
    case_65: /* CIL Label */ 
#line 832
    args_public_h->list_only_active = (_Bool)1;
#line 833
    goto switch_break;
    case_73: /* CIL Label */ 
#line 835
    args_public_h->list_only_inactive = (_Bool)1;
#line 836
    goto switch_break;
    case_101___1: /* CIL Label */ 
#line 838
    args_public_h->resolve_symbols = (_Bool)1;
#line 839
    goto switch_break;
    case_111: /* CIL Label */ 
#line 841
    args_public_h->list_only_once = (_Bool)1;
#line 842
    goto switch_break;
    case_105___0: /* CIL Label */ 
#line 844
    args_public_h->list_symbols_in_ifs = (_Bool)1;
#line 845
    goto switch_break;
    case_100___1: /* CIL Label */ 
#line 847
    args_public_h->list_symbols_in_defs = (_Bool)1;
#line 848
    goto switch_break;
    case_117: /* CIL Label */ 
#line 850
    args_public_h->list_symbols_in_undefs = (_Bool)1;
#line 851
    goto switch_break;
    case_3: /* CIL Label */ 
#line 853
    args_public_h->list_symbols_in_includes = (_Bool)1;
#line 854
    goto switch_break;
    case_115___0: /* CIL Label */ 
#line 856
    args_public_h->list_system_includes = (_Bool)1;
#line 857
    goto switch_break;
    case_108: /* CIL Label */ 
#line 859
    args_public_h->list_local_includes = (_Bool)1;
#line 860
    goto switch_break;
    case_80: /* CIL Label */ 
#line 862
    args_public_h->plaintext = (_Bool)1;
#line 863
    goto switch_break;
    case_82: /* CIL Label */ 
#line 865
    args_public_h->recurse = (_Bool)1;
#line 866
    if (command->cmd_code == 3) {
#line 867
      args_public_h->replace = (_Bool)1;
    }
#line 869
    goto switch_break;
    case_70: /* CIL Label */ 
    {
    {
#line 871
    dataset_filter_filetypes((char const   *)optarg);
    }
    }
#line 872
    goto switch_break;
    case_75: /* CIL Label */ 
#line 875
    args_public_h->keepgoing = (_Bool)1;
#line 876
    goto switch_break;
    case_109: /* CIL Label */ 
#line 878
    args_public_h->implicit = (_Bool)1;
#line 879
    goto switch_break;
    switch_default___2: /* CIL Label */ 
    {
    {
#line 881
    usage_error(16704, "Invalid option: \"%s\"", *(argv + (optind - 1)));
    }
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 885
  if (! parsing_file) {
    {
#line 886
    args_public_h->got_opts = (_Bool)1;
    {
#line 887
    finalise_diagnostics();
    }
    }
#line 888
    if (! ((args_public_h->diagnostic_filter & 2048) != 0)) {
      {
      {
#line 889
      tmp___9 = concatenate((size_t )args, argv, ' ');
      }
#line 889
      argstr = tmp___9;
      {
#line 890
      report((reason_code_t )2912, (heap_str *)((void *)0), "Args: %s", argstr);
      }
      {
#line 891
      free((void *)argstr);
      }
      }
    }
#line 893
    if (command->cmd_code == 3) {
      {
#line 894
      st = configured_symbols_public_h->global_sym_tab;
      {
#line 895
      tmp___10 = ptr_set_count((ptr_set_const_h )st);
      }
      }
#line 895
      if (tmp___10 == 0UL) {
        {
        {
#line 896
        report((reason_code_t )9392, (heap_str *)((void *)0), "You have not --define-ed or --undef-ed any symbols. Only in-source #define/#undef directives will have any effects");
        }
        }
      }
    }
  }
#line 902
  if (argc) {
    {
    {
#line 903
    report((reason_code_t )2832, (heap_str *)((void *)0), "Building input tree");
    }
    }
  }
#line 905
  argc -= optind;
#line 906
  argv += optind;
  {
  {
#line 907
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 907
    if (! argc) {
#line 907
      goto while_break___0;
    }
    {
    {
#line 908
    tmp___11 = add_files((char const   *)*argv);
    }
    }
#line 908
    if (! tmp___11) {
#line 909
      (args_state.arg_dirs_ignored) ++;
    }
#line 907
    argc --;
#line 907
    argv ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 912
  return;
}
}
#line 919 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c"
static void parse_args_file(char const   *argsfile ) 
{ 
  char *arg ;
  char *delims ;
  char **argv ;
  int argc ;
  size_t filesz ;
  size_t read ;
  FILE *in ;
  long tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void **tmp___2 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 922
  delims = (char *)" \t\n\r";
#line 927
  if (args_state.memfile) {
    {
    {
#line 928
    bail(16880, "--file can only be used once");
    }
    }
  }
  {
  {
#line 930
  in = open_file(argsfile, "r");
  }
  {
#line 931
  fseek(in, 0L, 2);
  }
  {
#line 932
  tmp = ftell(in);
  }
#line 932
  filesz = (size_t )tmp;
  {
#line 933
  fseek(in, 0L, 0);
  }
  {
#line 934
  tmp___0 = zallocate(filesz + 1UL);
  }
#line 934
  args_state.memfile = (char *)tmp___0;
  {
#line 935
  ptr_vector_append(args_state.argfile_argv, (void *)args_public_h->prog_name);
  }
  {
#line 937
  read = fread((void */* __restrict  */)args_state.memfile, (size_t )1, filesz, (FILE */* __restrict  */)in);
  }
  }
#line 938
  if (! read) {
    {
    {
#line 939
    bail(33248, "Read error on file %s", argsfile);
    }
    }
  }
  {
  {
#line 947
  fclose(in);
  }
#line 948
  *(args_state.memfile + read) = (char )'\000';
  {
#line 949
  arg = strtok((char */* __restrict  */)args_state.memfile, (char const   */* __restrict  */)delims);
  }
  }
  {
  {
#line 949
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 949
    if (! ((unsigned long )arg != (unsigned long )((void *)0))) {
#line 949
      goto while_break;
    }
    {
    {
#line 951
    ptr_vector_append(args_state.argfile_argv, (void *)arg);
    }
    {
#line 949
    arg = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)delims);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 953
  tmp___1 = ptr_vector_count((ptr_vector_const_h )args_state.argfile_argv);
  }
#line 953
  argc = (int )tmp___1;
  {
#line 954
  tmp___2 = ptr_vector_begin(args_state.argfile_argv);
  }
#line 954
  argv = (char **)tmp___2;
  {
#line 955
  parse_command_args(argc, argv);
  }
  }
#line 956
  return;
}
}
#line 962 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c"
void parse_executable(char **argv ) 
{ 
  char *last_slash ;

  {
  {
#line 966
  args_public_h->exec_path = *argv;
  {
#line 967
  last_slash = strrchr((char const   *)*argv, '/');
  }
  }
#line 968
  if (! last_slash) {
#line 969
    args_public_h->prog_name = *argv;
  } else {
#line 971
    args_public_h->prog_name = last_slash + 1;
  }
#line 973
  return;
}
}
#line 975 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c"
void parse_args(int argc , char **argv ) 
{ 
  cmd_option_t const   *cmd ;
  cmd_option_t const   *tmp ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 978
  tmp = get_command_option(argc, argv, (cmd_option_t const   *)(commands));
  }
#line 978
  cmd = tmp;
  }
#line 979
  if (cmd) {
    {
#line 981
    if (cmd->cmd_code == 1) {
#line 981
      goto case_1;
    }
#line 984
    if (cmd->cmd_code == 2) {
#line 984
      goto case_2;
    }
#line 992
    if (cmd->cmd_code == 9) {
#line 992
      goto case_9;
    }
#line 992
    if (cmd->cmd_code == 8) {
#line 992
      goto case_9;
    }
#line 992
    if (cmd->cmd_code == 7) {
#line 992
      goto case_9;
    }
#line 992
    if (cmd->cmd_code == 6) {
#line 992
      goto case_9;
    }
#line 992
    if (cmd->cmd_code == 5) {
#line 992
      goto case_9;
    }
#line 992
    if (cmd->cmd_code == 4) {
#line 992
      goto case_9;
    }
#line 995
    goto switch_default;
    case_1: /* CIL Label */ 
    {
    {
#line 982
    usage_help();
    }
    }
#line 983
    goto switch_break;
    case_2: /* CIL Label */ 
    {
    {
#line 985
    version();
    }
    }
#line 986
    goto switch_break;
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
    {
    {
#line 993
    line_despatch_no_op();
    }
    }
    switch_default: /* CIL Label */ 
    {
#line 996
    args_public_h->command = (cmd_option_t *)cmd;
#line 997
    argc --;
#line 998
    argv ++;
    {
#line 999
    parse_command_args(argc, argv);
    }
    }
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
    {
#line 1002
    usage_error(16704, "\"%s\" is not a coan command", *(argv + 1));
    }
    }
  }
#line 1005
  return;
}
}
#line 1007 "/home/wslee/tests/SOURCES/coan-4.2.2/src/args.c"
void finish_args(void) 
{ 
  int command ;
  _Bool replace ;
  _Bool input_is_stdin ;
  char *infile ;
  _Bool tmp ;
  _Bool tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 1010
  command = (args_public_h->command)->cmd_code;
#line 1011
  replace = args_public_h->replace;
#line 1012
  input_is_stdin = (_Bool)0;
#line 1014
  if (args_public_h->list_only_active) {
#line 1014
    if (args_public_h->list_only_inactive) {
      {
      {
#line 1016
      usage_error(16704, "--active is inconsistent with --inactive");
      }
      }
    }
  }
  {
  {
#line 1019
  tmp = file_tree_is_empty((file_tree_const_h )dataset_public_h->file_tree);
  }
  }
#line 1019
  if (tmp) {
#line 1019
    if (args_state.arg_dirs_ignored == 0) {
#line 1022
      if (! args_public_h->replace) {
#line 1024
        input_is_stdin = (_Bool)1;
      } else {
        {
        {
#line 1028
        while (1) {
          while_continue___0: /* CIL Label */ ;
          while_continue: /* CIL Label */ ;
          {
          {
#line 1028
          infile = read_filename();
          }
          }
#line 1028
          if (! ((unsigned long )infile != (unsigned long )((void *)0))) {
#line 1028
            goto while_break;
          }
          {
          {
#line 1029
          add_files((char const   *)infile);
          }
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
  {
  {
#line 1033
  tmp___0 = file_tree_is_empty((file_tree_const_h )dataset_public_h->file_tree);
  }
  }
#line 1033
  if (tmp___0) {
#line 1033
    if (! input_is_stdin) {
      {
      {
#line 1034
      bail(16624, "Nothing to do. No input files.");
      }
      }
    }
  }
#line 1037
  if (command == 3) {
#line 1037
    if (! input_is_stdin) {
      {
      {
#line 1037
      tmp___1 = file_tree_count((file_tree_const_h )dataset_public_h->file_tree, 1U,
                                (file_tree_count_t *)((void *)0));
      }
      }
#line 1037
      if (tmp___1 > 1UL) {
#line 1037
        if (! replace) {
          {
          {
#line 1040
          bail(16640, "The \"source\" command needs --replace to process multiple files");
          }
          }
        }
      }
    }
  }
#line 1043
  if (command == 4) {
#line 1044
    if (! args_public_h->list_symbols_in_ifs) {
#line 1044
      if (! args_public_h->list_symbols_in_defs) {
#line 1044
        if (! args_public_h->list_symbols_in_undefs) {
#line 1044
          if (! args_public_h->list_symbols_in_includes) {
#line 1049
            args_public_h->list_symbols_in_ifs = (_Bool)1;
#line 1050
            args_public_h->list_symbols_in_defs = (_Bool)1;
#line 1051
            args_public_h->list_symbols_in_undefs = (_Bool)1;
#line 1052
            args_public_h->list_symbols_in_includes = (_Bool)1;
          }
        }
      }
    }
  }
#line 1055
  if (command == 5) {
#line 1056
    if (! args_public_h->list_system_includes) {
#line 1056
      if (! args_public_h->list_local_includes) {
#line 1059
        args_public_h->list_system_includes = (_Bool)1;
#line 1060
        args_public_h->list_local_includes = (_Bool)1;
      }
    }
  }
  {
  {
#line 1063
  tmp___2 = file_tree_count((file_tree_const_h )dataset_public_h->file_tree, 1U, (file_tree_count_t *)((void *)0));
  }
  {
#line 1063
  report((reason_code_t )2896, (heap_str *)((void *)0), "%d files to process", tmp___2);
  }
  }
#line 1065
  return;
}
}
