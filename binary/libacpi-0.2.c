/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 39 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.h"
enum __anonenum_power_state_t_31 {
    P_AC = 0,
    P_BATT = 1,
    P_ERR = 2
} ;
#line 39 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.h"
typedef enum __anonenum_power_state_t_31 power_state_t;
#line 49
enum __anonenum_thermal_state_t_32 {
    T_CRIT = 0,
    T_HOT = 1,
    T_PASS = 2,
    T_ACT = 3,
    T_OK = 4,
    T_ERR = 5
} ;
#line 49 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.h"
typedef enum __anonenum_thermal_state_t_32 thermal_state_t;
#line 62
enum __anonenum_charge_state_t_33 {
    C_CHARGE = 0,
    C_DISCHARGE = 1,
    C_CHARGED = 2,
    C_NOINFO = 3,
    C_ERR = 4
} ;
#line 62 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.h"
typedef enum __anonenum_charge_state_t_33 charge_state_t;
#line 74
enum __anonenum_batt_state_t_34 {
    B_HIGH = 0,
    B_MED = 1,
    B_LOW = 2,
    B_CRIT = 3,
    B_HARD_CRIT = 4,
    B_ERR = 5
} ;
#line 74 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.h"
typedef enum __anonenum_batt_state_t_34 batt_state_t;
#line 87
enum __anonenum_thermal_mode_t_35 {
    CO_ACT = 0,
    CO_PASS = 1,
    CO_CRIT = 2,
    CO_ERR = 3
} ;
#line 87 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.h"
typedef enum __anonenum_thermal_mode_t_35 thermal_mode_t;
#line 98
enum __anonenum_fan_state_t_36 {
    F_ON = 0,
    F_OFF = 1,
    F_ERR = 2
} ;
#line 98 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.h"
typedef enum __anonenum_fan_state_t_36 fan_state_t;
#line 108 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.h"
struct __anonstruct_fan_t_37 {
   char name[512] ;
   char state_file[512] ;
   fan_state_t fan_state ;
};
#line 108 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.h"
typedef struct __anonstruct_fan_t_37 fan_t;
#line 118 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.h"
struct __anonstruct_battery_t_38 {
   char name[512] ;
   char state_file[512] ;
   char info_file[512] ;
   char alarm_file[512] ;
   int present ;
   int design_cap ;
   int last_full_cap ;
   int design_voltage ;
   int present_rate ;
   int remaining_cap ;
   int present_voltage ;
   int design_warn ;
   int design_low ;
   int design_level1 ;
   int design_level2 ;
   int alarm ;
   int percentage ;
   int charge_time ;
   int remaining_time ;
   charge_state_t charge_state ;
   batt_state_t batt_state ;
};
#line 118 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.h"
typedef struct __anonstruct_battery_t_38 battery_t;
#line 149 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.h"
struct __anonstruct_thermal_t_39 {
   char name[512] ;
   int temperature ;
   int frequency ;
   char state_file[512] ;
   char cooling_file[512] ;
   char freq_file[512] ;
   char trips_file[512] ;
   char temp_file[512] ;
   thermal_mode_t therm_mode ;
   thermal_state_t therm_state ;
};
#line 149 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.h"
typedef struct __anonstruct_thermal_t_39 thermal_t;
#line 166 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.h"
struct __anonstruct_adapter_t_40 {
   char *name ;
   char state_file[512] ;
   power_state_t ac_state ;
};
#line 166 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.h"
typedef struct __anonstruct_adapter_t_40 adapter_t;
#line 176 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.h"
struct __anonstruct_global_t_41 {
   int batt_count ;
   int thermal_count ;
   int fan_count ;
   int temperature ;
   adapter_t adapt ;
   int sysstyle ;
};
#line 176 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.h"
typedef struct __anonstruct_global_t_41 global_t;
#line 15 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/list.h"
struct node {
   char *name ;
   struct node *next ;
};
#line 15 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/list.h"
typedef struct node node_t;
#line 24 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/list.h"
struct __anonstruct_list_t_42 {
   int length ;
   node_t *top ;
   node_t *last ;
};
#line 24 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/list.h"
typedef struct __anonstruct_list_t_42 list_t;
#line 23 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
struct __anonstruct_acpi_value_t_43 {
   char *value ;
   size_t offset ;
};
#line 23 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
typedef struct __anonstruct_acpi_value_t_43 acpi_value_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 189 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.h"
battery_t batteries[10]  ;
#line 194 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.h"
thermal_t thermals[10]  ;
#line 199 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.h"
fan_t fans[10]  ;
#line 206
int init_acpi_batt(global_t *globals ) ;
#line 213
int init_acpi_acadapt(global_t *globals ) ;
#line 220
int init_acpi_thermal(global_t *globals ) ;
#line 227
int init_acpi_fan(global_t *globals ) ;
#line 233
int check_acpi_support(void) ;
#line 240
int read_acpi_batt(int const   num ) ;
#line 247
void read_acpi_acstate(global_t *globals ) ;
#line 254
int read_acpi_zone(int const   num , global_t *globals ) ;
#line 260
int read_acpi_fan(int const   num ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/list.h"
list_t *dir_list(char *dir ) ;
#line 42
void delete_list(list_t *lst ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
static int read_acpi_battinfo(int const   num , int const   sysstyle ) ;
#line 19
static int read_acpi_battalarm(int const   num , int const   sysstyle ) ;
#line 20
static int read_acpi_battstate(int const   num ) ;
#line 21
static void read_acpi_thermalzones(global_t *globals ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
static acpi_value_t battinfo_values[7]  = {      {(char *)"last full capacity:", (unsigned long )(& ((battery_t *)0)->last_full_cap)}, 
        {(char *)"design voltage:",
      (unsigned long )(& ((battery_t *)0)->design_voltage)}, 
        {(char *)"design capacity warning:", (unsigned long )(& ((battery_t *)0)->design_warn)}, 
        {(char *)"design capacity low:",
      (unsigned long )(& ((battery_t *)0)->design_low)}, 
        {(char *)"capacity granularity 1:", (unsigned long )(& ((battery_t *)0)->design_level1)}, 
        {(char *)"capacity granularity 2:",
      (unsigned long )(& ((battery_t *)0)->design_level2)}, 
        {(char *)((void *)0), (size_t )0}};
#line 39 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
static acpi_value_t battstate_values[4]  = {      {(char *)"present rate:", (unsigned long )(& ((battery_t *)0)->present_rate)}, 
        {(char *)"remaining capacity:",
      (unsigned long )(& ((battery_t *)0)->remaining_cap)}, 
        {(char *)"present voltage:", (unsigned long )(& ((battery_t *)0)->present_voltage)}, 
        {(char *)((void *)0),
      (size_t )0}};
#line 49 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
static char *scan_acpi_value(char const   *buf , char const   *key ) 
{ 
  char *ptr ;
  char *tmpbuf ;
  char *tmpkey ;
  char *tmpval ;
  size_t tmp ;

  {
  {
#line 51
  ptr = (char *)((void *)0);
#line 52
  tmpbuf = (char *)((void *)0);
#line 53
  tmpkey = (char *)((void *)0);
#line 54
  tmpval = (char *)((void *)0);
#line 56
  tmpbuf = strdup(buf);
  }
#line 56
  if ((unsigned long )tmpbuf == (unsigned long )((void *)0)) {
#line 57
    return ((char *)((void *)0));
  }
  {
#line 60
  tmpkey = strstr((char const   *)tmpbuf, key);
  }
#line 60
  if (tmpkey) {
    {
#line 62
    tmp = strlen(key);
#line 62
    tmpkey += tmp;
    }
    {
#line 62
    while (1) {
      while_continue: /* CIL Label */ ;
#line 62
      if (*tmpkey) {
#line 62
        if (! ((int )*tmpkey == 32)) {
#line 62
          if (! ((int )*tmpkey == 9)) {
#line 62
            goto while_break;
          }
        }
      } else {
#line 62
        goto while_break;
      }
#line 62
      tmpkey ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 63
    tmpval = tmpkey;
    {
#line 63
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 63
      if (*tmpval) {
#line 63
        if ((int )*tmpval != 32) {
#line 63
          if ((int )*tmpval != 9) {
#line 63
            if ((int )*tmpval != 10) {
#line 63
              if (! ((int )*tmpval != 13)) {
#line 63
                goto while_break___0;
              }
            } else {
#line 63
              goto while_break___0;
            }
          } else {
#line 63
            goto while_break___0;
          }
        } else {
#line 63
          goto while_break___0;
        }
      } else {
#line 63
        goto while_break___0;
      }
#line 63
      tmpval ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 66
    if (tmpval) {
#line 67
      *tmpval = (char )'\000';
    }
    {
#line 69
    ptr = strdup((char const   *)tmpkey);
    }
#line 69
    if ((unsigned long )ptr == (unsigned long )((void *)0)) {
      {
#line 70
      free((void *)tmpbuf);
      }
#line 71
      return ((char *)((void *)0));
    }
  }
  {
#line 74
  free((void *)tmpbuf);
  }
#line 75
  return (ptr);
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
static char *get_acpi_content(char const   *file ) 
{ 
  FILE *input ;
  char *buf ;
  int read___0 ;
  void *tmp ;
  size_t tmp___0 ;

  {
  {
#line 81
  input = (FILE *)((void *)0);
#line 82
  buf = (char *)((void *)0);
#line 83
  read___0 = 0;
#line 85
  tmp = malloc((size_t )1025);
#line 85
  buf = (char *)tmp;
  }
#line 85
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 86
    return ((char *)((void *)0));
  }
  {
#line 87
  input = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
  }
#line 87
  if ((unsigned long )input == (unsigned long )((void *)0)) {
#line 88
    return ((char *)((void *)0));
  }
  {
#line 90
  tmp___0 = fread((void */* __restrict  */)buf, (size_t )1, (size_t )1024, (FILE */* __restrict  */)input);
#line 90
  read___0 = (int )tmp___0;
  }
#line 91
  if (read___0 > 0) {
#line 91
    *(buf + (read___0 - 1)) = (char )'\000';
  } else {
#line 92
    *(buf + 0) = (char )'\000';
  }
  {
#line 94
  fclose(input);
  }
#line 95
  return (buf);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
static int get_acpi_version(void) 
{ 
  long ret ;
  char *tmp ;
  char *tmp___0 ;
  char *version ;
  long ret___0 ;
  long tmp___1 ;

  {
  {
#line 101
  ret = -1L;
#line 102
  tmp___0 = get_acpi_content("/proc/acpi/info");
#line 102
  tmp = tmp___0;
#line 103
  version = (char *)((void *)0);
  }
#line 105
  if (! tmp) {
    {
#line 106
    tmp = get_acpi_content("/sys/module/acpi/parameters/acpica_version");
    }
#line 107
    if (tmp) {
      {
#line 108
      tmp___1 = strtol((char const   */* __restrict  */)tmp, (char **/* __restrict  */)((void *)0),
                       10);
#line 108
      ret___0 = tmp___1;
#line 109
      free((void *)tmp);
      }
#line 110
      return ((int )ret___0);
    } else {
#line 112
      return (-1);
    }
  }
  {
#line 115
  version = scan_acpi_value((char const   *)tmp, "version:");
  }
#line 115
  if ((unsigned long )version == (unsigned long )((void *)0)) {
    {
#line 116
    free((void *)tmp);
    }
#line 117
    return (-1);
  }
  {
#line 119
  ret = strtol((char const   */* __restrict  */)version, (char **/* __restrict  */)((void *)0),
               10);
#line 120
  free((void *)tmp);
#line 121
  free((void *)version);
  }
#line 122
  return ((int )ret);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
int check_acpi_support(void) 
{ 
  int version ;
  int tmp ;

  {
  {
#line 129
  tmp = get_acpi_version();
#line 129
  version = tmp;
  }
#line 132
  if (version == -1) {
#line 133
    return (-1);
  } else
#line 132
  if (version < 20020214) {
#line 133
    return (-1);
  }
#line 134
  return (0);
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
int init_acpi_batt(global_t *globals ) 
{ 
  char *names[10] ;
  battery_t *binfo ;
  list_t *lst ;
  node_t *node ;
  int i ;
  char *tmp ;
  char *tmp1 ;
  char *tmp2 ;
  int x ;
  int y ;
  int tmp___0 ;

  {
  {
#line 143
  lst = (list_t *)((void *)0);
#line 144
  node = (node_t *)((void *)0);
#line 145
  i = 0;
#line 147
  globals->batt_count = 0;
#line 148
  globals->sysstyle = 0;
#line 149
  lst = dir_list((char *)"/proc/acpi/battery");
  }
#line 149
  if ((unsigned long )lst == (unsigned long )((void *)0)) {
#line 149
    goto _L;
  } else
#line 149
  if (! lst->top) {
    _L: /* CIL Label */ 
    {
#line 152
    lst = dir_list((char *)"/sys/class/power_supply");
    }
#line 152
    if ((unsigned long )lst == (unsigned long )((void *)0)) {
#line 153
      return (-1);
    } else
#line 152
    if (! lst->top) {
#line 153
      return (-1);
    } else {
#line 155
      globals->sysstyle = 1;
    }
  }
#line 157
  node = lst->top;
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (! node) {
#line 157
      goto while_break;
    }
    {
#line 158
    tmp = strdup((char const   *)node->name);
#line 158
    names[globals->batt_count] = tmp;
    }
#line 158
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      {
#line 159
      delete_list(lst);
      }
#line 160
      return (-2);
    }
#line 162
    (globals->batt_count) ++;
#line 157
    node = node->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  if (globals->batt_count > 10) {
#line 165
    return (-5);
  }
#line 171
  x = 1;
  {
#line 171
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 171
    if (! (x < globals->batt_count)) {
#line 171
      goto while_break___0;
    }
#line 172
    tmp1 = names[x];
#line 173
    y = x - 1;
    {
#line 174
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 174
      if (y >= 0) {
        {
#line 174
        tmp___0 = strcmp((char const   *)tmp1, (char const   *)names[y]);
        }
#line 174
        if (! (tmp___0 < 0)) {
#line 174
          goto while_break___1;
        }
      } else {
#line 174
        goto while_break___1;
      }
#line 175
      tmp2 = names[y + 1];
#line 176
      names[y + 1] = names[y];
#line 177
      names[y] = tmp2;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 171
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 182
  i = 0;
  {
#line 182
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 182
    if (i < globals->batt_count) {
#line 182
      if (! (i < 10)) {
#line 182
        goto while_break___2;
      }
    } else {
#line 182
      goto while_break___2;
    }
    {
#line 183
    binfo = & batteries[i];
#line 184
    snprintf((char */* __restrict  */)(binfo->name), (size_t )512, (char const   */* __restrict  */)"%s",
             names[i]);
    }
#line 185
    if (globals->sysstyle) {
      {
#line 187
      snprintf((char */* __restrict  */)(binfo->state_file), (size_t )512, (char const   */* __restrict  */)"/%s/present",
               names[i]);
#line 188
      snprintf((char */* __restrict  */)(binfo->info_file), (size_t )512, (char const   */* __restrict  */)"/sys/class/power_supply/%s",
               names[i]);
#line 189
      snprintf((char */* __restrict  */)(binfo->alarm_file), (size_t )512, (char const   */* __restrict  */)"/sys/class/power_supply/%s/alarm",
               names[i]);
      }
    } else {
      {
#line 193
      snprintf((char */* __restrict  */)(binfo->state_file), (size_t )512, (char const   */* __restrict  */)"/proc/acpi/battery/%s/state",
               names[i]);
#line 194
      snprintf((char */* __restrict  */)(binfo->info_file), (size_t )512, (char const   */* __restrict  */)"/proc/acpi/battery/%s/info",
               names[i]);
#line 195
      snprintf((char */* __restrict  */)(binfo->alarm_file), (size_t )512, (char const   */* __restrict  */)"/proc/acpi/battery/%s/alarm",
               names[i]);
      }
    }
    {
#line 197
    read_acpi_battinfo((int const   )i, (int const   )globals->sysstyle);
#line 198
    read_acpi_battalarm((int const   )i, (int const   )globals->sysstyle);
#line 199
    free((void *)names[i]);
#line 182
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 201
  delete_list(lst);
  }
#line 202
  return (0);
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
void read_acpi_acstate(global_t *globals ) 
{ 
  adapter_t *ac ;
  char *buf ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 208
  ac = & globals->adapt;
#line 209
  buf = (char *)((void *)0);
#line 210
  tmp = (char *)((void *)0);
#line 212
  if (ac->state_file) {
    {
#line 212
    buf = get_acpi_content((char const   *)(ac->state_file));
    }
#line 212
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 213
      ac->ac_state = (power_state_t )2;
#line 214
      return;
    }
  }
#line 216
  if (globals->sysstyle) {
    {
#line 218
    tmp___1 = strcmp((char const   *)buf, "1");
    }
#line 218
    if (tmp___1) {
      {
#line 220
      tmp___0 = strcmp((char const   *)buf, "0");
      }
#line 220
      if (tmp___0) {
#line 222
        ac->ac_state = (power_state_t )2;
      } else {
#line 221
        ac->ac_state = (power_state_t )1;
      }
    } else {
#line 219
      ac->ac_state = (power_state_t )0;
    }
  } else {
    {
#line 226
    tmp = scan_acpi_value((char const   *)buf, "state:");
    }
#line 226
    if (tmp) {
      {
#line 226
      tmp___3 = strncmp((char const   *)tmp, "on-line", (size_t )7);
      }
#line 226
      if (tmp___3) {
#line 226
        goto _L;
      } else {
#line 227
        ac->ac_state = (power_state_t )0;
      }
    } else
    _L: /* CIL Label */ 
#line 228
    if (tmp) {
      {
#line 228
      tmp___2 = strncmp((char const   *)tmp, "off-line", (size_t )8);
      }
#line 228
      if (tmp___2) {
#line 230
        ac->ac_state = (power_state_t )2;
      } else {
#line 229
        ac->ac_state = (power_state_t )1;
      }
    } else {
#line 230
      ac->ac_state = (power_state_t )2;
    }
  }
  {
#line 232
  free((void *)buf);
#line 233
  free((void *)tmp);
  }
#line 234
  return;
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
int init_acpi_acadapt(global_t *globals ) 
{ 
  list_t *lst ;
  adapter_t *ac ;
  char *tmp ;

  {
  {
#line 240
  lst = (list_t *)((void *)0);
#line 241
  ac = & globals->adapt;
#line 243
  globals->sysstyle = 0;
#line 244
  lst = dir_list((char *)"/proc/acpi/ac_adapter");
  }
#line 244
  if ((unsigned long )lst == (unsigned long )((void *)0)) {
#line 244
    goto _L;
  } else
#line 244
  if (! lst->top) {
    _L: /* CIL Label */ 
    {
#line 246
    lst = dir_list((char *)"/sys/class/power_supply/AC");
    }
#line 246
    if ((unsigned long )lst == (unsigned long )((void *)0)) {
#line 247
      return (-1);
    } else
#line 246
    if (! lst->top) {
#line 247
      return (-1);
    } else {
#line 249
      globals->sysstyle = 1;
    }
  }
#line 251
  if (! (lst->top)->name) {
    {
#line 252
    delete_list(lst);
    }
#line 253
    return (-2);
  } else {
    {
#line 251
    tmp = strdup((char const   *)(lst->top)->name);
#line 251
    ac->name = tmp;
    }
#line 251
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      {
#line 252
      delete_list(lst);
      }
#line 253
      return (-2);
    }
  }
#line 255
  if (globals->sysstyle) {
    {
#line 256
    snprintf((char */* __restrict  */)(ac->state_file), (size_t )512, (char const   */* __restrict  */)"/sys/class/power_supply/AC/online");
    }
  } else {
    {
#line 258
    snprintf((char */* __restrict  */)(ac->state_file), (size_t )512, (char const   */* __restrict  */)"/proc/acpi/ac_adapter/%s/state",
             ac->name);
    }
  }
  {
#line 259
  delete_list(lst);
#line 260
  read_acpi_acstate(globals);
  }
#line 261
  return (0);
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
int read_acpi_fan(int const   num ) 
{ 
  char *buf ;
  char *tmp ;
  fan_t *info ;

  {
#line 267
  buf = (char *)((void *)0);
#line 268
  tmp = (char *)((void *)0);
#line 269
  info = & fans[num];
#line 271
  if (num > 10) {
#line 271
    return (-5);
  }
  {
#line 274
  buf = get_acpi_content((char const   *)(info->state_file));
  }
#line 274
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 275
    info->fan_state = (fan_state_t )2;
  }
#line 277
  if (! buf) {
#line 278
    info->fan_state = (fan_state_t )2;
#line 279
    return (-1);
  } else {
    {
#line 277
    tmp = scan_acpi_value((char const   *)buf, "status:");
    }
#line 277
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 278
      info->fan_state = (fan_state_t )2;
#line 279
      return (-1);
    }
  }
#line 281
  if ((int )*(tmp + 0) == 111) {
#line 281
    if ((int )*(tmp + 1) == 110) {
#line 281
      info->fan_state = (fan_state_t )0;
    } else {
#line 281
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 282
  if ((int )*(tmp + 0) == 111) {
#line 282
    if ((int )*(tmp + 1) == 102) {
#line 282
      info->fan_state = (fan_state_t )1;
    } else {
#line 283
      info->fan_state = (fan_state_t )2;
    }
  } else {
#line 283
    info->fan_state = (fan_state_t )2;
  }
  {
#line 284
  free((void *)buf);
#line 285
  free((void *)tmp);
  }
#line 286
  return (0);
}
}
#line 290 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
static void read_acpi_fans(global_t *globals ) 
{ 
  int i ;

  {
#line 293
  i = 0;
  {
#line 293
  while (1) {
    while_continue: /* CIL Label */ ;
#line 293
    if (! (i < globals->fan_count)) {
#line 293
      goto while_break;
    }
    {
#line 294
    read_acpi_fan((int const   )i);
#line 293
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 295
  return;
}
}
#line 299 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
int init_acpi_fan(global_t *globals ) 
{ 
  char *names[10] ;
  list_t *lst ;
  node_t *node ;
  int i ;
  fan_t *finfo ;
  char *tmp ;

  {
  {
#line 302
  lst = (list_t *)((void *)0);
#line 303
  node = (node_t *)((void *)0);
#line 304
  i = 0;
#line 305
  finfo = (fan_t *)((void *)0);
#line 306
  globals->fan_count = 0;
#line 308
  lst = dir_list((char *)"/proc/acpi/fan");
  }
#line 308
  if ((unsigned long )lst == (unsigned long )((void *)0)) {
#line 309
    return (-1);
  } else
#line 308
  if (! lst->top) {
#line 309
    return (-1);
  }
#line 310
  node = lst->top;
  {
#line 310
  while (1) {
    while_continue: /* CIL Label */ ;
#line 310
    if (! node) {
#line 310
      goto while_break;
    }
    {
#line 311
    tmp = strdup((char const   *)node->name);
#line 311
    names[globals->fan_count] = tmp;
    }
#line 311
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      {
#line 312
      delete_list(lst);
      }
#line 313
      return (-2);
    }
#line 315
    (globals->fan_count) ++;
#line 310
    node = node->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  if (globals->fan_count > 10) {
#line 318
    return (-5);
  }
  {
#line 320
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 320
    if (i < globals->fan_count) {
#line 320
      if (! (i < 10)) {
#line 320
        goto while_break___0;
      }
    } else {
#line 320
      goto while_break___0;
    }
    {
#line 321
    finfo = & fans[i];
#line 322
    snprintf((char */* __restrict  */)(finfo->name), (size_t )512, (char const   */* __restrict  */)"%s",
             names[i]);
#line 323
    snprintf((char */* __restrict  */)(finfo->state_file), (size_t )512, (char const   */* __restrict  */)"/proc/acpi/fan/%s/state",
             names[i]);
#line 324
    free((void *)names[i]);
#line 320
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 326
  delete_list(lst);
#line 327
  read_acpi_fans(globals);
  }
#line 328
  return (0);
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
int init_acpi_thermal(global_t *globals ) 
{ 
  char *names[10] ;
  list_t *lst ;
  node_t *node ;
  thermal_t *tinfo ;
  int i ;
  char *tmp ;

  {
  {
#line 336
  lst = (list_t *)((void *)0);
#line 337
  node = (node_t *)((void *)0);
#line 338
  tinfo = (thermal_t *)((void *)0);
#line 339
  i = 0;
#line 340
  globals->thermal_count = 0;
#line 342
  lst = dir_list((char *)"/proc/acpi/thermal_zone");
  }
#line 342
  if ((unsigned long )lst == (unsigned long )((void *)0)) {
#line 343
    return (-1);
  }
#line 344
  node = lst->top;
  {
#line 344
  while (1) {
    while_continue: /* CIL Label */ ;
#line 344
    if (! node) {
#line 344
      goto while_break;
    }
    {
#line 345
    tmp = strdup((char const   *)node->name);
#line 345
    names[globals->thermal_count] = tmp;
    }
#line 345
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      {
#line 346
      delete_list(lst);
      }
#line 347
      return (-2);
    }
#line 349
    (globals->thermal_count) ++;
#line 344
    node = node->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 352
  if (globals->thermal_count > 10) {
#line 352
    return (-5);
  }
  {
#line 354
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 354
    if (i < globals->thermal_count) {
#line 354
      if (! (i < 10)) {
#line 354
        goto while_break___0;
      }
    } else {
#line 354
      goto while_break___0;
    }
    {
#line 355
    tinfo = & thermals[i];
#line 356
    snprintf((char */* __restrict  */)(tinfo->name), (size_t )512, (char const   */* __restrict  */)"%s",
             names[i]);
#line 357
    snprintf((char */* __restrict  */)(tinfo->state_file), (size_t )512, (char const   */* __restrict  */)"/proc/acpi/thermal_zone/%s/state",
             names[i]);
#line 358
    snprintf((char */* __restrict  */)(tinfo->temp_file), (size_t )512, (char const   */* __restrict  */)"/proc/acpi/thermal_zone/%s/temperature",
             names[i]);
#line 359
    snprintf((char */* __restrict  */)(tinfo->cooling_file), (size_t )512, (char const   */* __restrict  */)"/proc/acpi/thermal_zone/%s/cooling_mode",
             names[i]);
#line 360
    snprintf((char */* __restrict  */)(tinfo->freq_file), (size_t )512, (char const   */* __restrict  */)"/proc/acpi/thermal_zone/%s/polling_frequency",
             names[i]);
#line 361
    snprintf((char */* __restrict  */)(tinfo->trips_file), (size_t )512, (char const   */* __restrict  */)"/proc/acpi/thermal_zone/%s/trip_points",
             names[i]);
#line 362
    free((void *)names[i]);
#line 354
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 364
  delete_list(lst);
#line 365
  read_acpi_thermalzones(globals);
  }
#line 366
  return (0);
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
static void thermal_state(char const   *state , thermal_t *info ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 372
  if ((int const   )*(state + 0) == 111) {
#line 373
    info->therm_state = (thermal_state_t )4;
  } else {
    {
#line 374
    tmp___1 = strncmp(state, "crit", (size_t )4);
    }
#line 374
    if (tmp___1) {
      {
#line 376
      tmp___0 = strncmp(state, "hot", (size_t )3);
      }
#line 376
      if (tmp___0) {
        {
#line 377
        tmp = strncmp(state, "pas", (size_t )3);
        }
#line 377
        if (tmp) {
#line 380
          info->therm_state = (thermal_state_t )3;
        } else {
#line 378
          info->therm_state = (thermal_state_t )2;
        }
      } else {
#line 377
        info->therm_state = (thermal_state_t )1;
      }
    } else {
#line 375
      info->therm_state = (thermal_state_t )0;
    }
  }
#line 381
  return;
}
}
#line 384 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
static void fill_cooling_mode(char const   *tmp , thermal_t *info ) 
{ 


  {
#line 386
  if ((int const   )*(tmp + 0) == 97) {
#line 387
    info->therm_mode = (thermal_mode_t )0;
  } else
#line 388
  if ((int const   )*(tmp + 0) == 112) {
#line 389
    info->therm_mode = (thermal_mode_t )1;
  } else {
#line 390
    info->therm_mode = (thermal_mode_t )2;
  }
#line 391
  return;
}
}
#line 394 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
int read_acpi_zone(int const   num , global_t *globals ) 
{ 
  char *buf ;
  char *tmp ;
  thermal_t *info ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 396
  buf = (char *)((void *)0);
#line 397
  tmp = (char *)((void *)0);
#line 398
  info = & thermals[num];
#line 400
  if (num > 10) {
#line 400
    return (-5);
  }
  {
#line 403
  buf = get_acpi_content((char const   *)(info->state_file));
  }
#line 403
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 404
    info->therm_state = (thermal_state_t )5;
  }
#line 406
  if (buf) {
    {
#line 406
    tmp = scan_acpi_value((char const   *)buf, "state:");
    }
#line 406
    if (tmp) {
      {
#line 407
      thermal_state((char const   *)tmp, info);
      }
    }
  }
  {
#line 408
  free((void *)tmp);
#line 409
  free((void *)buf);
#line 412
  buf = get_acpi_content((char const   *)(info->temp_file));
  }
#line 412
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 413
    info->temperature = -1;
  }
#line 415
  if (buf) {
    {
#line 415
    tmp = scan_acpi_value((char const   *)buf, "temperature:");
    }
#line 415
    if (tmp) {
      {
#line 416
      tmp___0 = strtol((char const   */* __restrict  */)tmp, (char **/* __restrict  */)((void *)0),
                       10);
#line 416
      info->temperature = (int )tmp___0;
      }
#line 418
      if (globals->thermal_count == 1) {
#line 419
        globals->temperature = info->temperature;
      }
    }
  }
  {
#line 421
  free((void *)tmp);
#line 422
  free((void *)buf);
#line 425
  buf = get_acpi_content((char const   *)(info->cooling_file));
  }
#line 425
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 426
    info->therm_mode = (thermal_mode_t )3;
  }
#line 427
  if (buf) {
    {
#line 427
    tmp = scan_acpi_value((char const   *)buf, "cooling mode:");
    }
#line 427
    if (tmp) {
      {
#line 428
      fill_cooling_mode((char const   *)tmp, info);
      }
    } else {
#line 429
      info->therm_mode = (thermal_mode_t )3;
    }
  } else {
#line 429
    info->therm_mode = (thermal_mode_t )3;
  }
  {
#line 430
  free((void *)tmp);
#line 431
  free((void *)buf);
#line 434
  buf = get_acpi_content((char const   *)(info->freq_file));
  }
#line 434
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 435
    info->frequency = -4;
  }
#line 436
  if (buf) {
    {
#line 436
    tmp = scan_acpi_value((char const   *)buf, "polling frequency:");
    }
#line 436
    if (tmp) {
      {
#line 437
      tmp___1 = strtol((char const   */* __restrict  */)tmp, (char **/* __restrict  */)((void *)0),
                       10);
#line 437
      info->frequency = (int )tmp___1;
      }
    } else {
#line 438
      info->frequency = -4;
    }
  } else {
#line 438
    info->frequency = -4;
  }
  {
#line 439
  free((void *)tmp);
#line 440
  free((void *)buf);
  }
#line 444
  return (0);
}
}
#line 448 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
static void read_acpi_thermalzones(global_t *globals ) 
{ 
  int i ;

  {
#line 451
  i = 0;
  {
#line 451
  while (1) {
    while_continue: /* CIL Label */ ;
#line 451
    if (! (i < globals->thermal_count)) {
#line 451
      goto while_break;
    }
    {
#line 452
    read_acpi_zone((int const   )i, globals);
#line 451
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 453
  return;
}
}
#line 456 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
static void batt_charge_state(battery_t *info ) 
{ 
  int high ;
  int med ;

  {
#line 458
  high = info->last_full_cap / 2;
#line 459
  med = high / 2;
#line 461
  if (info->remaining_cap > high) {
#line 462
    info->batt_state = (batt_state_t )0;
  } else
#line 463
  if (info->remaining_cap <= high) {
#line 463
    if (info->remaining_cap > med) {
#line 464
      info->batt_state = (batt_state_t )1;
    } else {
#line 463
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 465
  if (info->remaining_cap <= med) {
#line 465
    if (info->remaining_cap > info->design_warn) {
#line 466
      info->batt_state = (batt_state_t )2;
    } else {
#line 465
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 467
  if (info->remaining_cap <= info->design_warn) {
#line 467
    if (info->remaining_cap > info->design_low) {
#line 468
      info->batt_state = (batt_state_t )3;
    } else {
#line 469
      info->batt_state = (batt_state_t )4;
    }
  } else {
#line 469
    info->batt_state = (batt_state_t )4;
  }
#line 470
  return;
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
static void fill_charge_state(char const   *state , battery_t *info ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 475
  if ((int const   )*(state + 0) == 117) {
#line 476
    info->charge_state = (charge_state_t )4;
  } else {
    {
#line 477
    tmp___1 = strncmp(state, "disch", (size_t )5);
    }
#line 477
    if (tmp___1) {
      {
#line 479
      tmp___0 = strncmp(state, "charge", (size_t )6);
      }
#line 479
      if (tmp___0) {
        {
#line 481
        tmp = strncmp(state, "chargi", (size_t )6);
        }
#line 481
        if (tmp) {
#line 484
          info->charge_state = (charge_state_t )3;
        } else {
#line 482
          info->charge_state = (charge_state_t )0;
        }
      } else {
#line 480
        info->charge_state = (charge_state_t )2;
      }
    } else {
#line 478
      info->charge_state = (charge_state_t )1;
    }
  }
#line 485
  return;
}
}
#line 488 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
static int read_acpi_battalarm(int const   num , int const   sysstyle ) 
{ 
  char *buf ;
  char *tmp ;
  battery_t *info ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 490
  buf = (char *)((void *)0);
#line 491
  tmp = (char *)((void *)0);
#line 492
  info = & batteries[num];
#line 494
  buf = get_acpi_content((char const   *)(info->alarm_file));
  }
#line 494
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 495
    return (-1);
  }
#line 497
  if (sysstyle) {
    {
#line 499
    tmp___1 = strcmp((char const   *)buf, "0");
    }
#line 499
    if (tmp___1) {
      {
#line 501
      tmp___0 = strcmp((char const   *)buf, "1");
      }
#line 501
      if (tmp___0) {
#line 504
        info->alarm = -1;
      } else {
#line 502
        info->alarm = 1;
      }
    } else {
#line 500
      info->alarm = 0;
    }
  } else {
    {
#line 508
    tmp = scan_acpi_value((char const   *)buf, "alarm:");
    }
#line 508
    if (tmp) {
#line 508
      if ((int )*(tmp + 0) != 117) {
        {
#line 509
        tmp___2 = strtol((char const   */* __restrict  */)tmp, (char **/* __restrict  */)((void *)0),
                         10);
#line 509
        info->alarm = (int )tmp___2;
        }
      } else {
#line 511
        info->alarm = -1;
      }
    } else {
#line 511
      info->alarm = -1;
    }
  }
  {
#line 513
  free((void *)buf);
#line 514
  free((void *)tmp);
  }
#line 515
  return (0);
}
}
#line 519 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
static int read_acpi_battinfo(int const   num , int const   sysstyle ) 
{ 
  char *buf ;
  char *tmp ;
  battery_t *info ;
  int i ;
  char sysfile[512] ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;

  {
#line 521
  buf = (char *)((void *)0);
#line 522
  tmp = (char *)((void *)0);
#line 523
  info = & batteries[num];
#line 524
  i = 0;
#line 527
  if (sysstyle) {
    {
#line 529
    snprintf((char */* __restrict  */)(sysfile), (size_t )512, (char const   */* __restrict  */)"%s/present",
             info->info_file);
#line 530
    buf = get_acpi_content((char const   *)(sysfile));
    }
#line 530
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 531
      return (-1);
    }
    {
#line 532
    tmp___0 = strcmp((char const   *)buf, "1");
    }
#line 532
    if (tmp___0) {
#line 535
      info->present = 0;
#line 536
      return (-3);
    } else {
#line 533
      info->present = 1;
    }
    {
#line 539
    snprintf((char */* __restrict  */)(sysfile), (size_t )512, (char const   */* __restrict  */)"%s/charge_full_design",
             info->info_file);
#line 540
    buf = get_acpi_content((char const   *)(sysfile));
    }
#line 540
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 541
      return (-1);
    }
    {
#line 542
    tmp___1 = strtol((char const   */* __restrict  */)buf, (char **/* __restrict  */)((void *)0),
                     10);
#line 542
    info->design_cap = (int )tmp___1;
#line 544
    snprintf((char */* __restrict  */)(sysfile), (size_t )512, (char const   */* __restrict  */)"%s/charge_full",
             info->info_file);
#line 545
    buf = get_acpi_content((char const   *)(sysfile));
    }
#line 545
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 546
      return (-1);
    }
    {
#line 547
    tmp___2 = strtol((char const   */* __restrict  */)buf, (char **/* __restrict  */)((void *)0),
                     10);
#line 547
    info->last_full_cap = (int )tmp___2;
#line 549
    snprintf((char */* __restrict  */)(sysfile), (size_t )512, (char const   */* __restrict  */)"%s/charge_now",
             info->info_file);
#line 550
    buf = get_acpi_content((char const   *)(sysfile));
    }
#line 550
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 551
      return (-1);
    }
    {
#line 552
    tmp___3 = strtol((char const   */* __restrict  */)buf, (char **/* __restrict  */)((void *)0),
                     10);
#line 552
    info->remaining_cap = (int )tmp___3;
#line 554
    snprintf((char */* __restrict  */)(sysfile), (size_t )512, (char const   */* __restrict  */)"%s/voltage_min_design",
             info->info_file);
#line 555
    buf = get_acpi_content((char const   *)(sysfile));
    }
#line 555
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 556
      return (-1);
    }
    {
#line 557
    tmp___4 = strtol((char const   */* __restrict  */)buf, (char **/* __restrict  */)((void *)0),
                     10);
#line 557
    info->design_voltage = (int )tmp___4;
#line 559
    snprintf((char */* __restrict  */)(sysfile), (size_t )512, (char const   */* __restrict  */)"%s/voltage_now",
             info->info_file);
#line 560
    buf = get_acpi_content((char const   *)(sysfile));
    }
#line 560
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 561
      return (-1);
    }
    {
#line 562
    tmp___5 = strtol((char const   */* __restrict  */)buf, (char **/* __restrict  */)((void *)0),
                     10);
#line 562
    info->present_voltage = (int )tmp___5;
#line 565
    snprintf((char */* __restrict  */)(sysfile), (size_t )512, (char const   */* __restrict  */)"%s/current_now",
             info->info_file);
#line 566
    buf = get_acpi_content((char const   *)(sysfile));
    }
#line 566
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 567
      return (-1);
    }
    {
#line 568
    tmp___6 = strtol((char const   */* __restrict  */)buf, (char **/* __restrict  */)((void *)0),
                     10);
#line 568
    info->present_rate = (int )tmp___6;
    }
#line 570
    return (0);
  }
  {
#line 573
  buf = get_acpi_content((char const   *)(info->info_file));
  }
#line 573
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 574
    return (-1);
  }
  {
#line 578
  tmp = scan_acpi_value((char const   *)buf, "present:");
  }
#line 578
  if (tmp) {
    {
#line 578
    tmp___7 = strncmp((char const   *)tmp, "yes", (size_t )3);
    }
#line 578
    if (tmp___7) {
      {
#line 582
      info->present = 0;
#line 583
      free((void *)buf);
      }
#line 584
      return (-3);
    } else {
      {
#line 579
      free((void *)tmp);
#line 580
      info->present = 1;
      }
    }
  } else {
    {
#line 582
    info->present = 0;
#line 583
    free((void *)buf);
    }
#line 584
    return (-3);
  }
  {
#line 587
  tmp = scan_acpi_value((char const   *)buf, "design capacity:");
  }
#line 587
  if (tmp) {
#line 587
    if ((int )*(tmp + 0) != 117) {
      {
#line 588
      tmp___8 = strtol((char const   */* __restrict  */)tmp, (char **/* __restrict  */)((void *)0),
                       10);
#line 588
      info->design_cap = (int )tmp___8;
      }
#line 590
      if (info->design_cap == 655350) {
#line 590
        info->design_cap = -1;
      }
      {
#line 591
      free((void *)tmp);
      }
    } else {
#line 593
      info->design_cap = -1;
    }
  } else {
#line 593
    info->design_cap = -1;
  }
  {
#line 595
  while (1) {
    while_continue: /* CIL Label */ ;
#line 595
    if (! battinfo_values[i].value) {
#line 595
      goto while_break;
    }
    {
#line 596
    tmp = scan_acpi_value((char const   *)buf, (char const   *)battinfo_values[i].value);
    }
#line 596
    if (tmp) {
#line 596
      if ((int )*(tmp + 0) != 117) {
        {
#line 597
        tmp___9 = strtol((char const   */* __restrict  */)tmp, (char **/* __restrict  */)((void *)0),
                         10);
#line 597
        *((int *)((char *)info + battinfo_values[i].offset)) = (int )tmp___9;
#line 598
        free((void *)tmp);
        }
      } else {
#line 600
        *((int *)((char *)info + battinfo_values[i].offset)) = -1;
      }
    } else {
#line 600
      *((int *)((char *)info + battinfo_values[i].offset)) = -1;
    }
#line 595
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 606
  free((void *)buf);
  }
#line 608
  return (0);
}
}
#line 612 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
static int read_acpi_battstate(int const   num ) 
{ 
  char *buf ;
  char *tmp ;
  battery_t *info ;
  unsigned int i ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 614
  buf = (char *)((void *)0);
#line 615
  tmp = (char *)((void *)0);
#line 616
  info = & batteries[num];
#line 617
  i = 0U;
#line 619
  buf = get_acpi_content((char const   *)(info->state_file));
  }
#line 619
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 620
    return (-1);
  }
  {
#line 622
  tmp = scan_acpi_value((char const   *)buf, "present:");
  }
#line 622
  if (tmp) {
    {
#line 622
    tmp___0 = strncmp((char const   *)tmp, "yes", (size_t )3);
    }
#line 622
    if (tmp___0) {
      {
#line 626
      info->present = 0;
#line 627
      free((void *)buf);
      }
#line 628
      return (-3);
    } else {
      {
#line 623
      info->present = 1;
#line 624
      free((void *)tmp);
      }
    }
  } else {
    {
#line 626
    info->present = 0;
#line 627
    free((void *)buf);
    }
#line 628
    return (-3);
  }
  {
#line 634
  tmp = scan_acpi_value((char const   *)buf, "charging state:");
  }
#line 634
  if (tmp) {
#line 634
    if ((int )*(tmp + 0) != 117) {
      {
#line 635
      fill_charge_state((char const   *)tmp, info);
#line 636
      free((void *)tmp);
      }
    } else {
#line 638
      info->charge_state = (charge_state_t )3;
    }
  } else {
#line 638
    info->charge_state = (charge_state_t )3;
  }
  {
#line 641
  while (1) {
    while_continue: /* CIL Label */ ;
#line 641
    if (! battstate_values[i].value) {
#line 641
      goto while_break;
    }
    {
#line 642
    tmp = scan_acpi_value((char const   *)buf, (char const   *)battstate_values[i].value);
    }
#line 642
    if (tmp) {
#line 642
      if ((int )*(tmp + 0) != 117) {
        {
#line 643
        tmp___1 = strtol((char const   */* __restrict  */)tmp, (char **/* __restrict  */)((void *)0),
                         10);
#line 643
        *((int *)((char *)info + battstate_values[i].offset)) = (int )tmp___1;
#line 644
        free((void *)tmp);
        }
      } else {
#line 646
        *((int *)((char *)info + battstate_values[i].offset)) = -1;
      }
    } else {
#line 646
      *((int *)((char *)info + battstate_values[i].offset)) = -1;
    }
#line 641
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 651
  batt_charge_state(info);
#line 653
  free((void *)buf);
  }
#line 654
  return (0);
}
}
#line 658 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
static void calc_remain_perc(int const   num ) 
{ 
  float lfcap ;
  battery_t *info ;
  int perc ;

  {
#line 661
  info = & batteries[num];
#line 664
  if (info->remaining_cap < 0) {
#line 665
    info->percentage = -1;
#line 666
    return;
  } else {
#line 669
    lfcap = (float )info->last_full_cap;
#line 670
    if (lfcap <= (float )0) {
#line 670
      lfcap = (float )1;
    }
#line 671
    perc = (int )((double )((float )info->remaining_cap / lfcap) * 100.0);
  }
#line 673
  if (perc > 100) {
#line 673
    info->percentage = 100;
  } else {
#line 673
    info->percentage = perc;
  }
#line 674
  return;
}
}
#line 677 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
static void calc_remain_chargetime(int const   num ) 
{ 
  battery_t *info ;

  {
#line 679
  info = & batteries[num];
#line 681
  if (info->present_rate < 0) {
#line 682
    info->charge_time = 0;
#line 683
    return;
  } else
#line 681
  if ((unsigned int )info->charge_state != 0U) {
#line 682
    info->charge_time = 0;
#line 683
    return;
  }
#line 685
  info->charge_time = (int )((double )(((float )info->last_full_cap - (float )info->remaining_cap) / (float )info->present_rate) * 60.0);
#line 686
  return;
}
}
#line 689 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
static void calc_remain_time(int const   num ) 
{ 
  battery_t *info ;

  {
#line 691
  info = & batteries[num];
#line 693
  if (info->present_rate < 0) {
#line 694
    info->remaining_time = 0;
#line 695
    return;
  } else
#line 693
  if ((unsigned int )info->charge_state != 1U) {
#line 694
    info->remaining_time = 0;
#line 695
    return;
  }
#line 697
  info->remaining_time = (int )((double )((float )info->remaining_cap / (float )info->present_rate) * 60.0);
#line 698
  return;
}
}
#line 702 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
int read_acpi_batt(int const   num ) 
{ 


  {
#line 704
  if (num > 10) {
#line 704
    return (-5);
  }
  {
#line 705
  read_acpi_battstate(num);
#line 706
  read_acpi_battalarm(num, (int const   )0);
#line 707
  calc_remain_perc(num);
#line 708
  calc_remain_chargetime(num);
#line 709
  calc_remain_time(num);
  }
#line 710
  return (0);
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/test-libacpi.c"
int main(void) 
{ 
  int i ;
  int acstate ;
  int battstate ;
  int thermstate ;
  int fanstate ;
  global_t *global ;
  void *tmp ;
  battery_t *binfo ;
  adapter_t *ac ;
  thermal_t *tp ;
  fan_t *fa ;
  int tmp___0 ;

  {
  {
#line 15
  i = 0;
#line 19
  tmp = malloc(sizeof(global_t ));
#line 19
  global = (global_t *)tmp;
#line 21
  ac = & global->adapt;
#line 25
  tmp___0 = check_acpi_support();
  }
#line 25
  if (tmp___0 == -1) {
    {
#line 26
    printf((char const   */* __restrict  */)"No acpi support for your system?\n");
    }
#line 27
    return (-1);
  }
  {
#line 31
  battstate = init_acpi_batt(global);
#line 32
  thermstate = init_acpi_thermal(global);
#line 33
  fanstate = init_acpi_fan(global);
#line 34
  acstate = init_acpi_acadapt(global);
  }
#line 36
  if (acstate == 0) {
#line 36
    if ((unsigned int )ac->ac_state == 1U) {
      {
#line 37
      printf((char const   */* __restrict  */)"AC adapter: off-line\n");
      }
    } else {
#line 36
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 38
  if (acstate == 0) {
#line 38
    if ((unsigned int )ac->ac_state == 0U) {
      {
#line 39
      printf((char const   */* __restrict  */)"AC adapter: on-line\n");
      }
    } else {
      {
#line 40
      printf((char const   */* __restrict  */)"AC information:\t\tnot supported\n");
      }
    }
  } else {
    {
#line 40
    printf((char const   */* __restrict  */)"AC information:\t\tnot supported\n");
    }
  }
#line 42
  if (battstate == 0) {
#line 43
    i = 0;
    {
#line 43
    while (1) {
      while_continue: /* CIL Label */ ;
#line 43
      if (! (i < global->batt_count)) {
#line 43
        goto while_break;
      }
      {
#line 44
      binfo = & batteries[i];
#line 46
      read_acpi_batt((int const   )i);
      }
#line 48
      if (binfo->present) {
        {
#line 50
        printf((char const   */* __restrict  */)"\n%s:\tpresent: %d\n\tdesign capacity: %d\n\tlast full capacity: %d\n\tdesign voltage: %d\n\tpresent rate: %d\n\tremaining capacity: %d\n\tpresent voltage: %d\n\tcharge state: %d\n\tbattery state: %d\n\tpercentage: %d%%\n\tremaining charge time: %02d:%02d h\n\tremaining time: %02d:%02d h\n",
               binfo->name, binfo->present, binfo->design_cap, binfo->last_full_cap,
               binfo->design_voltage, binfo->present_rate, binfo->remaining_cap, binfo->present_voltage,
               (unsigned int )binfo->charge_state, (unsigned int )binfo->batt_state,
               binfo->percentage, binfo->charge_time / 60, binfo->charge_time % 60,
               binfo->remaining_time / 60, binfo->remaining_time % 60);
        }
#line 69
        if (binfo->alarm) {
          {
#line 70
          printf((char const   */* __restrict  */)"%s: Alarm!\n", binfo->name);
          }
        }
      }
#line 43
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 73
    printf((char const   */* __restrict  */)"Battery information:\tnot supported\n");
    }
  }
#line 75
  if (thermstate == 0) {
#line 76
    i = 0;
    {
#line 76
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 76
      if (! (i < global->thermal_count)) {
#line 76
        goto while_break___0;
      }
      {
#line 78
      read_acpi_zone((int const   )i, global);
#line 79
      tp = & thermals[i];
      }
#line 80
      if (tp->frequency == -4) {
        {
#line 81
        printf((char const   */* __restrict  */)"\n%s:\ttemperature: %d C\n\tfrequency: disabled\n\tmode: %d\n\tstate: %d\n",
               tp->name, tp->temperature, (unsigned int )tp->therm_mode, (unsigned int )tp->therm_state);
        }
      } else {
        {
#line 87
        printf((char const   */* __restrict  */)"\n%s:\ttemperature: %d \260C\n\tfrequency: %d seconds\n\tmode: %d\n\tstate: %d\n",
               tp->name, tp->temperature, tp->frequency, (unsigned int )tp->therm_mode,
               (unsigned int )tp->therm_state);
        }
      }
#line 76
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 93
    if (global->thermal_count == 1) {
      {
#line 94
      printf((char const   */* __restrict  */)"Temperature: %d \260C\n", global->temperature);
      }
    }
  } else {
    {
#line 95
    printf((char const   */* __restrict  */)"Thermal information not supported\n");
    }
  }
#line 97
  if (fanstate == 0) {
#line 98
    i = 0;
    {
#line 98
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 98
      if (! (i < global->fan_count)) {
#line 98
        goto while_break___1;
      }
      {
#line 100
      read_acpi_fan((int const   )i);
#line 101
      fa = & fans[i];
#line 102
      printf((char const   */* __restrict  */)"\n%s:\tstate: %d\n", fa->name, (unsigned int )fa->fan_state);
#line 98
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 104
    printf((char const   */* __restrict  */)"Fan information:\tnot supported\n");
    }
  }
  {
#line 106
  free((void *)global);
  }
#line 108
  return (0);
}
}
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/list.c"
static list_t *new_list(void) 
{ 
  list_t *l ;
  void *tmp ;
  node_t *tmp___0 ;

  {
  {
#line 18
  tmp = malloc(sizeof(list_t ));
#line 18
  l = (list_t *)tmp;
  }
#line 19
  if (! l) {
#line 19
    return ((list_t *)((void *)0));
  }
#line 20
  tmp___0 = (node_t *)((void *)0);
#line 20
  l->last = tmp___0;
#line 20
  l->top = tmp___0;
#line 21
  l->length = 0;
#line 22
  return (l);
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/list.c"
static void append_node(list_t *lst , char *name ) 
{ 
  node_t *n ;
  void *tmp ;
  char *tmp___0 ;
  node_t *tmp___1 ;

  {
#line 28
  if (! lst) {
#line 28
    return;
  }
  {
#line 29
  tmp = malloc(sizeof(node_t ));
#line 29
  n = (node_t *)tmp;
  }
#line 29
  if ((unsigned long )n == (unsigned long )((void *)0)) {
#line 29
    return;
  }
  {
#line 30
  tmp___0 = strdup((char const   *)name);
#line 30
  n->name = tmp___0;
  }
#line 30
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
#line 31
    free((void *)n);
    }
#line 32
    return;
  }
#line 34
  n->next = (struct node *)((void *)0);
#line 35
  if (lst->top) {
#line 36
    (lst->last)->next = n;
#line 37
    lst->last = (lst->last)->next;
  } else {
#line 39
    tmp___1 = n;
#line 39
    lst->last = tmp___1;
#line 39
    lst->top = tmp___1;
  }
#line 41
  (lst->length) ++;
#line 42
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/list.c"
void delete_list(list_t *lst ) 
{ 
  node_t *tmp ;
  node_t *tmp___0 ;

  {
#line 48
  tmp = lst->top;
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 49
      goto while_break;
    }
#line 50
    lst->top = tmp->next;
#line 51
    if (tmp->name) {
      {
#line 51
      free((void *)tmp->name);
      }
    }
    {
#line 52
    free((void *)tmp);
#line 53
    tmp = lst->top;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 55
  tmp___0 = (node_t *)((void *)0);
#line 55
  lst->last = tmp___0;
#line 55
  lst->top = tmp___0;
#line 56
  free((void *)lst);
  }
#line 57
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/list.c"
list_t *dir_list(char *dir ) 
{ 
  list_t *list ;
  list_t *tmp ;
  DIR *rddir ;
  struct dirent *rd ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 62
  tmp = new_list();
#line 62
  list = tmp;
#line 63
  rddir = (DIR *)((void *)0);
#line 66
  rddir = opendir((char const   *)dir);
  }
#line 66
  if ((unsigned long )rddir == (unsigned long )((void *)0)) {
#line 67
    return ((list_t *)((void *)0));
  }
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 68
    rd = readdir(rddir);
    }
#line 68
    if (! rd) {
#line 68
      goto while_break;
    }
    {
#line 69
    tmp___0 = strncmp(".", (char const   *)(rd->d_name), (size_t )1);
    }
#line 69
    if (tmp___0) {
      {
#line 69
      tmp___1 = strncmp("..", (char const   *)(rd->d_name), (size_t )2);
      }
#line 69
      if (! tmp___1) {
#line 70
        goto while_continue;
      }
    } else {
#line 70
      goto while_continue;
    }
    {
#line 72
    append_node(list, rd->d_name);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 74
  closedir(rddir);
  }
#line 75
  return (list);
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/list.c"
static list_t *new_list___0(void) 
{ 
  list_t *l ;
  void *tmp ;
  node_t *tmp___0 ;

  {
  {
#line 18
  tmp = malloc(sizeof(list_t ));
#line 18
  l = (list_t *)tmp;
  }
#line 19
  if (! l) {
#line 19
    return ((list_t *)((void *)0));
  }
#line 20
  tmp___0 = (node_t *)((void *)0);
#line 20
  l->last = tmp___0;
#line 20
  l->top = tmp___0;
#line 21
  l->length = 0;
#line 22
  return (l);
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/list.c"
static void append_node___0(list_t *lst , char *name ) 
{ 
  node_t *n ;
  void *tmp ;
  char *tmp___0 ;
  node_t *tmp___1 ;

  {
#line 28
  if (! lst) {
#line 28
    return;
  }
  {
#line 29
  tmp = malloc(sizeof(node_t ));
#line 29
  n = (node_t *)tmp;
  }
#line 29
  if ((unsigned long )n == (unsigned long )((void *)0)) {
#line 29
    return;
  }
  {
#line 30
  tmp___0 = strdup((char const   *)name);
#line 30
  n->name = tmp___0;
  }
#line 30
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
#line 31
    free((void *)n);
    }
#line 32
    return;
  }
#line 34
  n->next = (struct node *)((void *)0);
#line 35
  if (lst->top) {
#line 36
    (lst->last)->next = n;
#line 37
    lst->last = (lst->last)->next;
  } else {
#line 39
    tmp___1 = n;
#line 39
    lst->last = tmp___1;
#line 39
    lst->top = tmp___1;
  }
#line 41
  (lst->length) ++;
#line 42
  return;
}
}
#line 18 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
static int read_acpi_battinfo___0(int const   num , int const   sysstyle ) ;
#line 19
static int read_acpi_battalarm___0(int const   num , int const   sysstyle ) ;
#line 20
static int read_acpi_battstate___0(int const   num ) ;
#line 21
static void read_acpi_thermalzones___0(global_t *globals ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
static acpi_value_t battinfo_values___0[7]  = {      {(char *)"last full capacity:", (unsigned long )(& ((battery_t *)0)->last_full_cap)}, 
        {(char *)"design voltage:",
      (unsigned long )(& ((battery_t *)0)->design_voltage)}, 
        {(char *)"design capacity warning:", (unsigned long )(& ((battery_t *)0)->design_warn)}, 
        {(char *)"design capacity low:",
      (unsigned long )(& ((battery_t *)0)->design_low)}, 
        {(char *)"capacity granularity 1:", (unsigned long )(& ((battery_t *)0)->design_level1)}, 
        {(char *)"capacity granularity 2:",
      (unsigned long )(& ((battery_t *)0)->design_level2)}, 
        {(char *)((void *)0), (size_t )0}};
#line 39 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
static acpi_value_t battstate_values___0[4]  = {      {(char *)"present rate:", (unsigned long )(& ((battery_t *)0)->present_rate)}, 
        {(char *)"remaining capacity:",
      (unsigned long )(& ((battery_t *)0)->remaining_cap)}, 
        {(char *)"present voltage:", (unsigned long )(& ((battery_t *)0)->present_voltage)}, 
        {(char *)((void *)0),
      (size_t )0}};
#line 49 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
static char *scan_acpi_value___0(char const   *buf , char const   *key ) 
{ 
  char *ptr ;
  char *tmpbuf ;
  char *tmpkey ;
  char *tmpval ;
  size_t tmp ;

  {
  {
#line 51
  ptr = (char *)((void *)0);
#line 52
  tmpbuf = (char *)((void *)0);
#line 53
  tmpkey = (char *)((void *)0);
#line 54
  tmpval = (char *)((void *)0);
#line 56
  tmpbuf = strdup(buf);
  }
#line 56
  if ((unsigned long )tmpbuf == (unsigned long )((void *)0)) {
#line 57
    return ((char *)((void *)0));
  }
  {
#line 60
  tmpkey = strstr((char const   *)tmpbuf, key);
  }
#line 60
  if (tmpkey) {
    {
#line 62
    tmp = strlen(key);
#line 62
    tmpkey += tmp;
    }
    {
#line 62
    while (1) {
      while_continue: /* CIL Label */ ;
#line 62
      if (*tmpkey) {
#line 62
        if (! ((int )*tmpkey == 32)) {
#line 62
          if (! ((int )*tmpkey == 9)) {
#line 62
            goto while_break;
          }
        }
      } else {
#line 62
        goto while_break;
      }
#line 62
      tmpkey ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 63
    tmpval = tmpkey;
    {
#line 63
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 63
      if (*tmpval) {
#line 63
        if ((int )*tmpval != 32) {
#line 63
          if ((int )*tmpval != 9) {
#line 63
            if ((int )*tmpval != 10) {
#line 63
              if (! ((int )*tmpval != 13)) {
#line 63
                goto while_break___0;
              }
            } else {
#line 63
              goto while_break___0;
            }
          } else {
#line 63
            goto while_break___0;
          }
        } else {
#line 63
          goto while_break___0;
        }
      } else {
#line 63
        goto while_break___0;
      }
#line 63
      tmpval ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 66
    if (tmpval) {
#line 67
      *tmpval = (char )'\000';
    }
    {
#line 69
    ptr = strdup((char const   *)tmpkey);
    }
#line 69
    if ((unsigned long )ptr == (unsigned long )((void *)0)) {
      {
#line 70
      free((void *)tmpbuf);
      }
#line 71
      return ((char *)((void *)0));
    }
  }
  {
#line 74
  free((void *)tmpbuf);
  }
#line 75
  return (ptr);
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
static char *get_acpi_content___0(char const   *file ) 
{ 
  FILE *input ;
  char *buf ;
  int read___0 ;
  void *tmp ;
  size_t tmp___0 ;

  {
  {
#line 81
  input = (FILE *)((void *)0);
#line 82
  buf = (char *)((void *)0);
#line 83
  read___0 = 0;
#line 85
  tmp = malloc((size_t )1025);
#line 85
  buf = (char *)tmp;
  }
#line 85
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 86
    return ((char *)((void *)0));
  }
  {
#line 87
  input = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
  }
#line 87
  if ((unsigned long )input == (unsigned long )((void *)0)) {
#line 88
    return ((char *)((void *)0));
  }
  {
#line 90
  tmp___0 = fread((void */* __restrict  */)buf, (size_t )1, (size_t )1024, (FILE */* __restrict  */)input);
#line 90
  read___0 = (int )tmp___0;
  }
#line 91
  if (read___0 > 0) {
#line 91
    *(buf + (read___0 - 1)) = (char )'\000';
  } else {
#line 92
    *(buf + 0) = (char )'\000';
  }
  {
#line 94
  fclose(input);
  }
#line 95
  return (buf);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
static int get_acpi_version___0(void) 
{ 
  long ret ;
  char *tmp ;
  char *tmp___0 ;
  char *version ;
  long ret___0 ;
  long tmp___1 ;

  {
  {
#line 101
  ret = -1L;
#line 102
  tmp___0 = get_acpi_content___0("/proc/acpi/info");
#line 102
  tmp = tmp___0;
#line 103
  version = (char *)((void *)0);
  }
#line 105
  if (! tmp) {
    {
#line 106
    tmp = get_acpi_content___0("/sys/module/acpi/parameters/acpica_version");
    }
#line 107
    if (tmp) {
      {
#line 108
      tmp___1 = strtol((char const   */* __restrict  */)tmp, (char **/* __restrict  */)((void *)0),
                       10);
#line 108
      ret___0 = tmp___1;
#line 109
      free((void *)tmp);
      }
#line 110
      return ((int )ret___0);
    } else {
#line 112
      return (-1);
    }
  }
  {
#line 115
  version = scan_acpi_value___0((char const   *)tmp, "version:");
  }
#line 115
  if ((unsigned long )version == (unsigned long )((void *)0)) {
    {
#line 116
    free((void *)tmp);
    }
#line 117
    return (-1);
  }
  {
#line 119
  ret = strtol((char const   */* __restrict  */)version, (char **/* __restrict  */)((void *)0),
               10);
#line 120
  free((void *)tmp);
#line 121
  free((void *)version);
  }
#line 122
  return ((int )ret);
}
}
#line 290 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
static void read_acpi_fans___0(global_t *globals ) 
{ 
  int i ;

  {
#line 293
  i = 0;
  {
#line 293
  while (1) {
    while_continue: /* CIL Label */ ;
#line 293
    if (! (i < globals->fan_count)) {
#line 293
      goto while_break;
    }
    {
#line 294
    read_acpi_fan((int const   )i);
#line 293
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 295
  return;
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
static void thermal_state___0(char const   *state , thermal_t *info ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 372
  if ((int const   )*(state + 0) == 111) {
#line 373
    info->therm_state = (thermal_state_t )4;
  } else {
    {
#line 374
    tmp___1 = strncmp(state, "crit", (size_t )4);
    }
#line 374
    if (tmp___1) {
      {
#line 376
      tmp___0 = strncmp(state, "hot", (size_t )3);
      }
#line 376
      if (tmp___0) {
        {
#line 377
        tmp = strncmp(state, "pas", (size_t )3);
        }
#line 377
        if (tmp) {
#line 380
          info->therm_state = (thermal_state_t )3;
        } else {
#line 378
          info->therm_state = (thermal_state_t )2;
        }
      } else {
#line 377
        info->therm_state = (thermal_state_t )1;
      }
    } else {
#line 375
      info->therm_state = (thermal_state_t )0;
    }
  }
#line 381
  return;
}
}
#line 384 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
static void fill_cooling_mode___0(char const   *tmp , thermal_t *info ) 
{ 


  {
#line 386
  if ((int const   )*(tmp + 0) == 97) {
#line 387
    info->therm_mode = (thermal_mode_t )0;
  } else
#line 388
  if ((int const   )*(tmp + 0) == 112) {
#line 389
    info->therm_mode = (thermal_mode_t )1;
  } else {
#line 390
    info->therm_mode = (thermal_mode_t )2;
  }
#line 391
  return;
}
}
#line 448 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
static void read_acpi_thermalzones___0(global_t *globals ) 
{ 
  int i ;

  {
#line 451
  i = 0;
  {
#line 451
  while (1) {
    while_continue: /* CIL Label */ ;
#line 451
    if (! (i < globals->thermal_count)) {
#line 451
      goto while_break;
    }
    {
#line 452
    read_acpi_zone((int const   )i, globals);
#line 451
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 453
  return;
}
}
#line 456 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
static void batt_charge_state___0(battery_t *info ) 
{ 
  int high ;
  int med ;

  {
#line 458
  high = info->last_full_cap / 2;
#line 459
  med = high / 2;
#line 461
  if (info->remaining_cap > high) {
#line 462
    info->batt_state = (batt_state_t )0;
  } else
#line 463
  if (info->remaining_cap <= high) {
#line 463
    if (info->remaining_cap > med) {
#line 464
      info->batt_state = (batt_state_t )1;
    } else {
#line 463
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 465
  if (info->remaining_cap <= med) {
#line 465
    if (info->remaining_cap > info->design_warn) {
#line 466
      info->batt_state = (batt_state_t )2;
    } else {
#line 465
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 467
  if (info->remaining_cap <= info->design_warn) {
#line 467
    if (info->remaining_cap > info->design_low) {
#line 468
      info->batt_state = (batt_state_t )3;
    } else {
#line 469
      info->batt_state = (batt_state_t )4;
    }
  } else {
#line 469
    info->batt_state = (batt_state_t )4;
  }
#line 470
  return;
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
static void fill_charge_state___0(char const   *state , battery_t *info ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 475
  if ((int const   )*(state + 0) == 117) {
#line 476
    info->charge_state = (charge_state_t )4;
  } else {
    {
#line 477
    tmp___1 = strncmp(state, "disch", (size_t )5);
    }
#line 477
    if (tmp___1) {
      {
#line 479
      tmp___0 = strncmp(state, "charge", (size_t )6);
      }
#line 479
      if (tmp___0) {
        {
#line 481
        tmp = strncmp(state, "chargi", (size_t )6);
        }
#line 481
        if (tmp) {
#line 484
          info->charge_state = (charge_state_t )3;
        } else {
#line 482
          info->charge_state = (charge_state_t )0;
        }
      } else {
#line 480
        info->charge_state = (charge_state_t )2;
      }
    } else {
#line 478
      info->charge_state = (charge_state_t )1;
    }
  }
#line 485
  return;
}
}
#line 488 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
static int read_acpi_battalarm___0(int const   num , int const   sysstyle ) 
{ 
  char *buf ;
  char *tmp ;
  battery_t *info ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 490
  buf = (char *)((void *)0);
#line 491
  tmp = (char *)((void *)0);
#line 492
  info = & batteries[num];
#line 494
  buf = get_acpi_content___0((char const   *)(info->alarm_file));
  }
#line 494
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 495
    return (-1);
  }
#line 497
  if (sysstyle) {
    {
#line 499
    tmp___1 = strcmp((char const   *)buf, "0");
    }
#line 499
    if (tmp___1) {
      {
#line 501
      tmp___0 = strcmp((char const   *)buf, "1");
      }
#line 501
      if (tmp___0) {
#line 504
        info->alarm = -1;
      } else {
#line 502
        info->alarm = 1;
      }
    } else {
#line 500
      info->alarm = 0;
    }
  } else {
    {
#line 508
    tmp = scan_acpi_value___0((char const   *)buf, "alarm:");
    }
#line 508
    if (tmp) {
#line 508
      if ((int )*(tmp + 0) != 117) {
        {
#line 509
        tmp___2 = strtol((char const   */* __restrict  */)tmp, (char **/* __restrict  */)((void *)0),
                         10);
#line 509
        info->alarm = (int )tmp___2;
        }
      } else {
#line 511
        info->alarm = -1;
      }
    } else {
#line 511
      info->alarm = -1;
    }
  }
  {
#line 513
  free((void *)buf);
#line 514
  free((void *)tmp);
  }
#line 515
  return (0);
}
}
#line 519 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
static int read_acpi_battinfo___0(int const   num , int const   sysstyle ) 
{ 
  char *buf ;
  char *tmp ;
  battery_t *info ;
  int i ;
  char sysfile[512] ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;

  {
#line 521
  buf = (char *)((void *)0);
#line 522
  tmp = (char *)((void *)0);
#line 523
  info = & batteries[num];
#line 524
  i = 0;
#line 527
  if (sysstyle) {
    {
#line 529
    snprintf((char */* __restrict  */)(sysfile), (size_t )512, (char const   */* __restrict  */)"%s/present",
             info->info_file);
#line 530
    buf = get_acpi_content___0((char const   *)(sysfile));
    }
#line 530
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 531
      return (-1);
    }
    {
#line 532
    tmp___0 = strcmp((char const   *)buf, "1");
    }
#line 532
    if (tmp___0) {
#line 535
      info->present = 0;
#line 536
      return (-3);
    } else {
#line 533
      info->present = 1;
    }
    {
#line 539
    snprintf((char */* __restrict  */)(sysfile), (size_t )512, (char const   */* __restrict  */)"%s/charge_full_design",
             info->info_file);
#line 540
    buf = get_acpi_content___0((char const   *)(sysfile));
    }
#line 540
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 541
      return (-1);
    }
    {
#line 542
    tmp___1 = strtol((char const   */* __restrict  */)buf, (char **/* __restrict  */)((void *)0),
                     10);
#line 542
    info->design_cap = (int )tmp___1;
#line 544
    snprintf((char */* __restrict  */)(sysfile), (size_t )512, (char const   */* __restrict  */)"%s/charge_full",
             info->info_file);
#line 545
    buf = get_acpi_content___0((char const   *)(sysfile));
    }
#line 545
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 546
      return (-1);
    }
    {
#line 547
    tmp___2 = strtol((char const   */* __restrict  */)buf, (char **/* __restrict  */)((void *)0),
                     10);
#line 547
    info->last_full_cap = (int )tmp___2;
#line 549
    snprintf((char */* __restrict  */)(sysfile), (size_t )512, (char const   */* __restrict  */)"%s/charge_now",
             info->info_file);
#line 550
    buf = get_acpi_content___0((char const   *)(sysfile));
    }
#line 550
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 551
      return (-1);
    }
    {
#line 552
    tmp___3 = strtol((char const   */* __restrict  */)buf, (char **/* __restrict  */)((void *)0),
                     10);
#line 552
    info->remaining_cap = (int )tmp___3;
#line 554
    snprintf((char */* __restrict  */)(sysfile), (size_t )512, (char const   */* __restrict  */)"%s/voltage_min_design",
             info->info_file);
#line 555
    buf = get_acpi_content___0((char const   *)(sysfile));
    }
#line 555
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 556
      return (-1);
    }
    {
#line 557
    tmp___4 = strtol((char const   */* __restrict  */)buf, (char **/* __restrict  */)((void *)0),
                     10);
#line 557
    info->design_voltage = (int )tmp___4;
#line 559
    snprintf((char */* __restrict  */)(sysfile), (size_t )512, (char const   */* __restrict  */)"%s/voltage_now",
             info->info_file);
#line 560
    buf = get_acpi_content___0((char const   *)(sysfile));
    }
#line 560
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 561
      return (-1);
    }
    {
#line 562
    tmp___5 = strtol((char const   */* __restrict  */)buf, (char **/* __restrict  */)((void *)0),
                     10);
#line 562
    info->present_voltage = (int )tmp___5;
#line 565
    snprintf((char */* __restrict  */)(sysfile), (size_t )512, (char const   */* __restrict  */)"%s/current_now",
             info->info_file);
#line 566
    buf = get_acpi_content___0((char const   *)(sysfile));
    }
#line 566
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 567
      return (-1);
    }
    {
#line 568
    tmp___6 = strtol((char const   */* __restrict  */)buf, (char **/* __restrict  */)((void *)0),
                     10);
#line 568
    info->present_rate = (int )tmp___6;
    }
#line 570
    return (0);
  }
  {
#line 573
  buf = get_acpi_content___0((char const   *)(info->info_file));
  }
#line 573
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 574
    return (-1);
  }
  {
#line 578
  tmp = scan_acpi_value___0((char const   *)buf, "present:");
  }
#line 578
  if (tmp) {
    {
#line 578
    tmp___7 = strncmp((char const   *)tmp, "yes", (size_t )3);
    }
#line 578
    if (tmp___7) {
      {
#line 582
      info->present = 0;
#line 583
      free((void *)buf);
      }
#line 584
      return (-3);
    } else {
      {
#line 579
      free((void *)tmp);
#line 580
      info->present = 1;
      }
    }
  } else {
    {
#line 582
    info->present = 0;
#line 583
    free((void *)buf);
    }
#line 584
    return (-3);
  }
  {
#line 587
  tmp = scan_acpi_value___0((char const   *)buf, "design capacity:");
  }
#line 587
  if (tmp) {
#line 587
    if ((int )*(tmp + 0) != 117) {
      {
#line 588
      tmp___8 = strtol((char const   */* __restrict  */)tmp, (char **/* __restrict  */)((void *)0),
                       10);
#line 588
      info->design_cap = (int )tmp___8;
      }
#line 590
      if (info->design_cap == 655350) {
#line 590
        info->design_cap = -1;
      }
      {
#line 591
      free((void *)tmp);
      }
    } else {
#line 593
      info->design_cap = -1;
    }
  } else {
#line 593
    info->design_cap = -1;
  }
  {
#line 595
  while (1) {
    while_continue: /* CIL Label */ ;
#line 595
    if (! battinfo_values___0[i].value) {
#line 595
      goto while_break;
    }
    {
#line 596
    tmp = scan_acpi_value___0((char const   *)buf, (char const   *)battinfo_values___0[i].value);
    }
#line 596
    if (tmp) {
#line 596
      if ((int )*(tmp + 0) != 117) {
        {
#line 597
        tmp___9 = strtol((char const   */* __restrict  */)tmp, (char **/* __restrict  */)((void *)0),
                         10);
#line 597
        *((int *)((char *)info + battinfo_values___0[i].offset)) = (int )tmp___9;
#line 598
        free((void *)tmp);
        }
      } else {
#line 600
        *((int *)((char *)info + battinfo_values___0[i].offset)) = -1;
      }
    } else {
#line 600
      *((int *)((char *)info + battinfo_values___0[i].offset)) = -1;
    }
#line 595
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 606
  free((void *)buf);
  }
#line 608
  return (0);
}
}
#line 612 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
static int read_acpi_battstate___0(int const   num ) 
{ 
  char *buf ;
  char *tmp ;
  battery_t *info ;
  unsigned int i ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 614
  buf = (char *)((void *)0);
#line 615
  tmp = (char *)((void *)0);
#line 616
  info = & batteries[num];
#line 617
  i = 0U;
#line 619
  buf = get_acpi_content___0((char const   *)(info->state_file));
  }
#line 619
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 620
    return (-1);
  }
  {
#line 622
  tmp = scan_acpi_value___0((char const   *)buf, "present:");
  }
#line 622
  if (tmp) {
    {
#line 622
    tmp___0 = strncmp((char const   *)tmp, "yes", (size_t )3);
    }
#line 622
    if (tmp___0) {
      {
#line 626
      info->present = 0;
#line 627
      free((void *)buf);
      }
#line 628
      return (-3);
    } else {
      {
#line 623
      info->present = 1;
#line 624
      free((void *)tmp);
      }
    }
  } else {
    {
#line 626
    info->present = 0;
#line 627
    free((void *)buf);
    }
#line 628
    return (-3);
  }
  {
#line 634
  tmp = scan_acpi_value___0((char const   *)buf, "charging state:");
  }
#line 634
  if (tmp) {
#line 634
    if ((int )*(tmp + 0) != 117) {
      {
#line 635
      fill_charge_state___0((char const   *)tmp, info);
#line 636
      free((void *)tmp);
      }
    } else {
#line 638
      info->charge_state = (charge_state_t )3;
    }
  } else {
#line 638
    info->charge_state = (charge_state_t )3;
  }
  {
#line 641
  while (1) {
    while_continue: /* CIL Label */ ;
#line 641
    if (! battstate_values___0[i].value) {
#line 641
      goto while_break;
    }
    {
#line 642
    tmp = scan_acpi_value___0((char const   *)buf, (char const   *)battstate_values___0[i].value);
    }
#line 642
    if (tmp) {
#line 642
      if ((int )*(tmp + 0) != 117) {
        {
#line 643
        tmp___1 = strtol((char const   */* __restrict  */)tmp, (char **/* __restrict  */)((void *)0),
                         10);
#line 643
        *((int *)((char *)info + battstate_values___0[i].offset)) = (int )tmp___1;
#line 644
        free((void *)tmp);
        }
      } else {
#line 646
        *((int *)((char *)info + battstate_values___0[i].offset)) = -1;
      }
    } else {
#line 646
      *((int *)((char *)info + battstate_values___0[i].offset)) = -1;
    }
#line 641
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 651
  batt_charge_state___0(info);
#line 653
  free((void *)buf);
  }
#line 654
  return (0);
}
}
#line 658 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
static void calc_remain_perc___0(int const   num ) 
{ 
  float lfcap ;
  battery_t *info ;
  int perc ;

  {
#line 661
  info = & batteries[num];
#line 664
  if (info->remaining_cap < 0) {
#line 665
    info->percentage = -1;
#line 666
    return;
  } else {
#line 669
    lfcap = (float )info->last_full_cap;
#line 670
    if (lfcap <= (float )0) {
#line 670
      lfcap = (float )1;
    }
#line 671
    perc = (int )((double )((float )info->remaining_cap / lfcap) * 100.0);
  }
#line 673
  if (perc > 100) {
#line 673
    info->percentage = 100;
  } else {
#line 673
    info->percentage = perc;
  }
#line 674
  return;
}
}
#line 677 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
static void calc_remain_chargetime___0(int const   num ) 
{ 
  battery_t *info ;

  {
#line 679
  info = & batteries[num];
#line 681
  if (info->present_rate < 0) {
#line 682
    info->charge_time = 0;
#line 683
    return;
  } else
#line 681
  if ((unsigned int )info->charge_state != 0U) {
#line 682
    info->charge_time = 0;
#line 683
    return;
  }
#line 685
  info->charge_time = (int )((double )(((float )info->last_full_cap - (float )info->remaining_cap) / (float )info->present_rate) * 60.0);
#line 686
  return;
}
}
#line 689 "/home/june/repo/benchmarks/collector/temp/libacpi-0.2/libacpi.c"
static void calc_remain_time___0(int const   num ) 
{ 
  battery_t *info ;

  {
#line 691
  info = & batteries[num];
#line 693
  if (info->present_rate < 0) {
#line 694
    info->remaining_time = 0;
#line 695
    return;
  } else
#line 693
  if ((unsigned int )info->charge_state != 1U) {
#line 694
    info->remaining_time = 0;
#line 695
    return;
  }
#line 697
  info->remaining_time = (int )((double )((float )info->remaining_cap / (float )info->present_rate) * 60.0);
#line 698
  return;
}
}
