/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 90 "/usr/include/stdio.h"
typedef __off_t off_t;
#line 194 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef signed char int8_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 387 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef void *voidp;
#line 1224 "/usr/include/zlib.h"
struct gzFile_s;
#line 1224 "/usr/include/zlib.h"
typedef struct gzFile_s *gzFile;
#line 1670 "/usr/include/zlib.h"
struct gzFile_s {
   unsigned int have ;
   unsigned char *next ;
   off_t pos ;
};
#line 81 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/kseq.h"
struct __kstring_t {
   size_t l ;
   size_t m ;
   char *s ;
};
#line 81 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/kseq.h"
typedef struct __kstring_t kstring_t;
#line 37 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
struct __kstream_t {
   unsigned char *buf ;
   int begin ;
   int end ;
   int is_eof ;
   gzFile f ;
};
#line 37 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
typedef struct __kstream_t kstream_t;
#line 37 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
struct __anonstruct_kseq_t_31 {
   kstring_t name ;
   kstring_t comment ;
   kstring_t seq ;
   kstring_t qual ;
   int last_char ;
   kstream_t *f ;
};
#line 37 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
typedef struct __anonstruct_kseq_t_31 kseq_t;
#line 39 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
struct __anonstruct_reglist_t_32 {
   int n ;
   int m ;
   uint64_t *a ;
};
#line 39 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
typedef struct __anonstruct_reglist_t_32 reglist_t;
#line 122 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/khash.h"
typedef unsigned int khint32_t;
#line 137 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/khash.h"
typedef khint32_t khint_t;
#line 138 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/khash.h"
typedef khint_t khiter_t;
#line 532 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/khash.h"
typedef char const   *kh_cstr_t;
#line 45 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
struct __anonstruct_kh_reg_t_33 {
   khint_t n_buckets ;
   khint_t size ;
   khint_t n_occupied ;
   khint_t upper_bound ;
   khint32_t *flags ;
   kh_cstr_t *keys ;
   reglist_t *vals ;
};
#line 45 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
typedef struct __anonstruct_kh_reg_t_33 kh_reg_t;
#line 47 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
typedef kh_reg_t reghash_t;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 580
extern int putchar(int __c ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 695
extern int puts(char const   *__s ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 144 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 150
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 389
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) drand48)(void) ;
#line 393
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) lrand48)(void) ;
#line 403
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand48)(long __seedval ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 1264 "/usr/include/zlib.h"
extern gzFile gzdopen(int fd , char const   *mode ) ;
#line 1313
extern int gzread(gzFile file , voidp buf , unsigned int len ) ;
#line 1511
extern int gzclose(gzFile file ) ;
#line 1725
extern gzFile gzopen(char const   * , char const   * ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) pow)(double __x ,
                                                                             double __y ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
__inline static kstream_t *ks_init(gzFile f ) 
{ 
  kstream_t *ks ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 37
  tmp = calloc((size_t )1, sizeof(kstream_t ));
#line 37
  ks = (kstream_t *)tmp;
#line 37
  ks->f = f;
#line 37
  tmp___0 = malloc((size_t )16384);
#line 37
  ks->buf = (unsigned char *)tmp___0;
  }
#line 37
  return (ks);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
__inline static void ks_destroy(kstream_t *ks ) 
{ 


  {
#line 37
  if (ks) {
    {
#line 37
    free((void *)ks->buf);
#line 37
    free((void *)ks);
    }
  }
#line 37
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
__inline static int ks_getc(kstream_t *ks ) 
{ 
  int tmp ;

  {
#line 37
  if (ks->is_eof) {
#line 37
    if (ks->begin >= ks->end) {
#line 37
      return (-1);
    }
  }
#line 37
  if (ks->begin >= ks->end) {
    {
#line 37
    ks->begin = 0;
#line 37
    ks->end = gzread(ks->f, (voidp )ks->buf, 16384U);
    }
#line 37
    if (ks->end < 16384) {
#line 37
      ks->is_eof = 1;
    }
#line 37
    if (ks->end == 0) {
#line 37
      return (-1);
    }
  }
#line 37
  tmp = ks->begin;
#line 37
  (ks->begin) ++;
#line 37
  return ((int )*(ks->buf + tmp));
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
static int ks_getuntil2(kstream_t *ks , int delimiter , kstring_t *str , int *dret ,
                        int append ) 
{ 
  int i ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 37
  if (dret) {
#line 37
    *dret = 0;
  }
#line 37
  if (append) {
#line 37
    str->l = str->l;
  } else {
#line 37
    str->l = (size_t )0;
  }
#line 37
  if (ks->begin >= ks->end) {
#line 37
    if (ks->is_eof) {
#line 37
      return (-1);
    }
  }
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (ks->begin >= ks->end) {
#line 37
      if (! ks->is_eof) {
        {
#line 37
        ks->begin = 0;
#line 37
        ks->end = gzread(ks->f, (voidp )ks->buf, 16384U);
        }
#line 37
        if (ks->end < 16384) {
#line 37
          ks->is_eof = 1;
        }
#line 37
        if (ks->end == 0) {
#line 37
          goto while_break;
        }
      } else {
#line 37
        goto while_break;
      }
    }
#line 37
    if (delimiter == 2) {
#line 37
      i = ks->begin;
      {
#line 37
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 37
        if (! (i < ks->end)) {
#line 37
          goto while_break___0;
        }
#line 37
        if ((int )*(ks->buf + i) == 10) {
#line 37
          goto while_break___0;
        }
#line 37
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 37
    if (delimiter > 2) {
#line 37
      i = ks->begin;
      {
#line 37
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 37
        if (! (i < ks->end)) {
#line 37
          goto while_break___1;
        }
#line 37
        if ((int )*(ks->buf + i) == delimiter) {
#line 37
          goto while_break___1;
        }
#line 37
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 37
    if (delimiter == 0) {
#line 37
      i = ks->begin;
      {
#line 37
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 37
        if (! (i < ks->end)) {
#line 37
          goto while_break___2;
        }
        {
#line 37
        tmp = __ctype_b_loc();
        }
#line 37
        if ((int const   )*(*tmp + (int )*(ks->buf + i)) & 8192) {
#line 37
          goto while_break___2;
        }
#line 37
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else
#line 37
    if (delimiter == 1) {
#line 37
      i = ks->begin;
      {
#line 37
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 37
        if (! (i < ks->end)) {
#line 37
          goto while_break___3;
        }
        {
#line 37
        tmp___0 = __ctype_b_loc();
        }
#line 37
        if ((int const   )*(*tmp___0 + (int )*(ks->buf + i)) & 8192) {
#line 37
          if ((int )*(ks->buf + i) != 32) {
#line 37
            goto while_break___3;
          }
        }
#line 37
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
#line 37
      i = 0;
    }
#line 37
    if (str->m - str->l < (size_t )((i - ks->begin) + 1)) {
      {
#line 37
      str->m = (str->l + (size_t )(i - ks->begin)) + 1UL;
#line 37
      (str->m) --;
#line 37
      str->m |= str->m >> 1;
#line 37
      str->m |= str->m >> 2;
#line 37
      str->m |= str->m >> 4;
#line 37
      str->m |= str->m >> 8;
#line 37
      str->m |= str->m >> 16;
#line 37
      (str->m) ++;
#line 37
      tmp___1 = realloc((void *)str->s, str->m);
#line 37
      str->s = (char *)tmp___1;
      }
    }
    {
#line 37
    memcpy((void */* __restrict  */)(str->s + str->l), (void const   */* __restrict  */)(ks->buf + ks->begin),
           (size_t )(i - ks->begin));
#line 37
    str->l += (size_t )(i - ks->begin);
#line 37
    ks->begin = i + 1;
    }
#line 37
    if (i < ks->end) {
#line 37
      if (dret) {
#line 37
        *dret = (int )*(ks->buf + i);
      }
#line 37
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 37
  if ((unsigned long )str->s == (unsigned long )((char *)0)) {
    {
#line 37
    str->m = (size_t )1;
#line 37
    tmp___2 = calloc((size_t )1, (size_t )1);
#line 37
    str->s = (char *)tmp___2;
    }
  } else
#line 37
  if (delimiter == 2) {
#line 37
    if (str->l > 1UL) {
#line 37
      if ((int )*(str->s + (str->l - 1UL)) == 13) {
#line 37
        (str->l) --;
      }
    }
  }
#line 37
  *(str->s + str->l) = (char )'\000';
#line 37
  return ((int )str->l);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
__inline static int ks_getuntil(kstream_t *ks , int delimiter , kstring_t *str , int *dret ) 
{ 
  int tmp ;

  {
  {
#line 37
  tmp = ks_getuntil2(ks, delimiter, str, dret, 0);
  }
#line 37
  return (tmp);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
static kseq_t *kseq_init(gzFile fd ) 
{ 
  kseq_t *s ;
  void *tmp ;

  {
  {
#line 37
  tmp = calloc((size_t )1, sizeof(kseq_t ));
#line 37
  s = (kseq_t *)tmp;
#line 37
  s->f = ks_init(fd);
  }
#line 37
  return (s);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
static void kseq_destroy(kseq_t *ks ) 
{ 


  {
#line 37
  if (! ks) {
#line 37
    return;
  }
  {
#line 37
  free((void *)ks->name.s);
#line 37
  free((void *)ks->comment.s);
#line 37
  free((void *)ks->seq.s);
#line 37
  free((void *)ks->qual.s);
#line 37
  ks_destroy(ks->f);
#line 37
  free((void *)ks);
  }
#line 37
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
static int kseq_read(kseq_t *seq ) 
{ 
  int c ;
  kstream_t *ks ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;

  {
#line 37
  ks = seq->f;
#line 37
  if (seq->last_char == 0) {
    {
#line 37
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 37
      c = ks_getc(ks);
      }
#line 37
      if (c != -1) {
#line 37
        if (c != 62) {
#line 37
          if (! (c != 64)) {
#line 37
            goto while_break;
          }
        } else {
#line 37
          goto while_break;
        }
      } else {
#line 37
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 37
    if (c == -1) {
#line 37
      return (-1);
    }
#line 37
    seq->last_char = c;
  }
  {
#line 37
  tmp___0 = (size_t )0;
#line 37
  seq->qual.l = tmp___0;
#line 37
  tmp = tmp___0;
#line 37
  seq->seq.l = tmp;
#line 37
  seq->comment.l = tmp;
#line 37
  tmp___1 = ks_getuntil(ks, 0, & seq->name, & c);
  }
#line 37
  if (tmp___1 < 0) {
#line 37
    return (-1);
  }
#line 37
  if (c != 10) {
    {
#line 37
    ks_getuntil(ks, 2, & seq->comment, (int *)0);
    }
  }
#line 37
  if ((unsigned long )seq->seq.s == (unsigned long )((char *)0)) {
    {
#line 37
    seq->seq.m = (size_t )256;
#line 37
    tmp___2 = malloc(seq->seq.m);
#line 37
    seq->seq.s = (char *)tmp___2;
    }
  }
  {
#line 37
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 37
    c = ks_getc(ks);
    }
#line 37
    if (c != -1) {
#line 37
      if (c != 62) {
#line 37
        if (c != 43) {
#line 37
          if (! (c != 64)) {
#line 37
            goto while_break___0;
          }
        } else {
#line 37
          goto while_break___0;
        }
      } else {
#line 37
        goto while_break___0;
      }
    } else {
#line 37
      goto while_break___0;
    }
#line 37
    if (c == 10) {
#line 37
      goto while_continue___0;
    }
    {
#line 37
    tmp___3 = seq->seq.l;
#line 37
    (seq->seq.l) ++;
#line 37
    *(seq->seq.s + tmp___3) = (char )c;
#line 37
    ks_getuntil2(ks, 2, & seq->seq, (int *)0, 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 37
  if (c == 62) {
#line 37
    seq->last_char = c;
  } else
#line 37
  if (c == 64) {
#line 37
    seq->last_char = c;
  }
#line 37
  if (seq->seq.l + 1UL >= seq->seq.m) {
    {
#line 37
    seq->seq.m = seq->seq.l + 2UL;
#line 37
    (seq->seq.m) --;
#line 37
    seq->seq.m |= seq->seq.m >> 1;
#line 37
    seq->seq.m |= seq->seq.m >> 2;
#line 37
    seq->seq.m |= seq->seq.m >> 4;
#line 37
    seq->seq.m |= seq->seq.m >> 8;
#line 37
    seq->seq.m |= seq->seq.m >> 16;
#line 37
    (seq->seq.m) ++;
#line 37
    tmp___4 = realloc((void *)seq->seq.s, seq->seq.m);
#line 37
    seq->seq.s = (char *)tmp___4;
    }
  }
#line 37
  *(seq->seq.s + seq->seq.l) = (char)0;
#line 37
  if (c != 43) {
#line 37
    return ((int )seq->seq.l);
  }
#line 37
  if (seq->qual.m < seq->seq.m) {
    {
#line 37
    seq->qual.m = seq->seq.m;
#line 37
    tmp___5 = realloc((void *)seq->qual.s, seq->qual.m);
#line 37
    seq->qual.s = (char *)tmp___5;
    }
  }
  {
#line 37
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 37
    c = ks_getc(ks);
    }
#line 37
    if (c != -1) {
#line 37
      if (! (c != 10)) {
#line 37
        goto while_break___1;
      }
    } else {
#line 37
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 37
  if (c == -1) {
#line 37
    return (-2);
  }
  {
#line 37
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 37
    tmp___6 = ks_getuntil2(ks, 2, & seq->qual, (int *)0, 1);
    }
#line 37
    if (tmp___6 >= 0) {
#line 37
      if (! (seq->qual.l < seq->seq.l)) {
#line 37
        goto while_break___2;
      }
    } else {
#line 37
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 37
  seq->last_char = 0;
#line 37
  if (seq->seq.l != seq->qual.l) {
#line 37
    return (-2);
  }
#line 37
  return ((int )seq->seq.l);
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/khash.h"
static double const   __ac_HASH_UPPER  =    (double const   )0.77;
#line 345 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/khash.h"
__inline static khint_t __ac_X31_hash_string(char const   *s ) 
{ 
  khint_t h ;

  {
#line 347
  h = (khint_t )*s;
#line 348
  if (h) {
#line 348
    s ++;
    {
#line 348
    while (1) {
      while_continue: /* CIL Label */ ;
#line 348
      if (! *s) {
#line 348
        goto while_break;
      }
#line 348
      h = ((h << 5) - h) + (khint_t )*s;
#line 348
      s ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 349
  return (h);
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
__inline static kh_reg_t *kh_init_reg(void) 
{ 
  void *tmp ;

  {
  {
#line 45
  tmp = calloc((size_t )1, sizeof(kh_reg_t ));
  }
#line 45
  return ((kh_reg_t *)tmp);
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
__inline static void kh_destroy_reg(kh_reg_t *h ) 
{ 


  {
#line 45
  if (h) {
    {
#line 45
    free((void *)h->keys);
#line 45
    free((void *)h->flags);
#line 45
    free((void *)h->vals);
#line 45
    free((void *)h);
    }
  }
#line 45
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
__inline static khint_t kh_get_reg(kh_reg_t const   *h , kh_cstr_t key ) 
{ 
  khint_t inc ;
  khint_t k ;
  khint_t i ;
  khint_t last ;
  khint_t mask ;
  int tmp ;
  khint_t tmp___0 ;

  {
#line 45
  if (h->n_buckets) {
    {
#line 45
    mask = (khint_t )(h->n_buckets - 1U);
#line 45
    k = __ac_X31_hash_string(key);
#line 45
    i = k & mask;
#line 45
    inc = (((k >> 3) ^ (k << 3)) | 1U) & mask;
#line 45
    last = i;
    }
    {
#line 45
    while (1) {
      while_continue: /* CIL Label */ ;
#line 45
      if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U)) {
#line 45
        if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U)) {
          {
#line 45
          tmp = strcmp(*(h->keys + i), key);
          }
#line 45
          if (tmp == 0) {
#line 45
            goto while_break;
          }
        }
      } else {
#line 45
        goto while_break;
      }
#line 45
      i = (i + inc) & mask;
#line 45
      if (i == last) {
#line 45
        return ((khint_t )h->n_buckets);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 45
    if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 3U) {
#line 45
      tmp___0 = h->n_buckets;
    } else {
#line 45
      tmp___0 = (khint_t const   )i;
    }
#line 45
    return ((khint_t )tmp___0);
  } else {
#line 45
    return ((khint_t )0);
  }
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
__inline static void kh_resize_reg(kh_reg_t *h , khint_t new_n_buckets ) 
{ 
  khint32_t *new_flags ;
  khint_t j ;
  khint_t tmp ;
  void *tmp___0 ;
  khint_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  kh_cstr_t key ;
  reglist_t val ;
  khint_t new_mask ;
  khint_t inc ;
  khint_t k ;
  khint_t i ;
  kh_cstr_t tmp___4 ;
  reglist_t tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;

  {
#line 45
  new_flags = (khint32_t *)0;
#line 45
  j = (khint_t )1;
#line 45
  new_n_buckets --;
#line 45
  new_n_buckets |= new_n_buckets >> 1;
#line 45
  new_n_buckets |= new_n_buckets >> 2;
#line 45
  new_n_buckets |= new_n_buckets >> 4;
#line 45
  new_n_buckets |= new_n_buckets >> 8;
#line 45
  new_n_buckets |= new_n_buckets >> 16;
#line 45
  new_n_buckets ++;
#line 45
  if (new_n_buckets < 4U) {
#line 45
    new_n_buckets = (khint_t )4;
  }
#line 45
  if (h->size >= (khint_t )((double const   )new_n_buckets * __ac_HASH_UPPER + (double const   )0.5)) {
#line 45
    j = (khint_t )0;
  } else {
#line 45
    if (new_n_buckets < 16U) {
#line 45
      tmp = (khint_t )1;
    } else {
#line 45
      tmp = new_n_buckets >> 4;
    }
    {
#line 45
    tmp___0 = malloc((unsigned long )tmp * sizeof(khint32_t ));
#line 45
    new_flags = (khint32_t *)tmp___0;
    }
#line 45
    if (new_n_buckets < 16U) {
#line 45
      tmp___1 = (khint_t )1;
    } else {
#line 45
      tmp___1 = new_n_buckets >> 4;
    }
    {
#line 45
    memset((void *)new_flags, 170, (unsigned long )tmp___1 * sizeof(khint32_t ));
    }
#line 45
    if (h->n_buckets < new_n_buckets) {
      {
#line 45
      tmp___2 = realloc((void *)h->keys, (unsigned long )new_n_buckets * sizeof(kh_cstr_t ));
#line 45
      h->keys = (kh_cstr_t *)tmp___2;
#line 45
      tmp___3 = realloc((void *)h->vals, (unsigned long )new_n_buckets * sizeof(reglist_t ));
#line 45
      h->vals = (reglist_t *)tmp___3;
      }
    }
  }
#line 45
  if (j) {
#line 45
    j = (khint_t )0;
    {
#line 45
    while (1) {
      while_continue: /* CIL Label */ ;
#line 45
      if (! (j != h->n_buckets)) {
#line 45
        goto while_break;
      }
#line 45
      if (((*(h->flags + (j >> 4)) >> ((j & 15U) << 1)) & 3U) == 0U) {
#line 45
        key = *(h->keys + j);
#line 45
        new_mask = new_n_buckets - 1U;
#line 45
        val = *(h->vals + j);
#line 45
        *(h->flags + (j >> 4)) = (khint32_t )((unsigned long )*(h->flags + (j >> 4)) | (1UL << ((j & 15U) << 1)));
        {
#line 45
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 45
          k = __ac_X31_hash_string(key);
#line 45
          i = k & new_mask;
#line 45
          inc = (((k >> 3) ^ (k << 3)) | 1U) & new_mask;
          }
          {
#line 45
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 45
            if (! (! ((*(new_flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U))) {
#line 45
              goto while_break___1;
            }
#line 45
            i = (i + inc) & new_mask;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 45
          *(new_flags + (i >> 4)) = (khint32_t )((unsigned long )*(new_flags + (i >> 4)) & ~ (2UL << ((i & 15U) << 1)));
#line 45
          if (i < h->n_buckets) {
#line 45
            if (((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 3U) == 0U) {
#line 45
              tmp___4 = *(h->keys + i);
#line 45
              *(h->keys + i) = key;
#line 45
              key = tmp___4;
#line 45
              tmp___5 = *(h->vals + i);
#line 45
              *(h->vals + i) = val;
#line 45
              val = tmp___5;
#line 45
              *(h->flags + (i >> 4)) = (khint32_t )((unsigned long )*(h->flags + (i >> 4)) | (1UL << ((i & 15U) << 1)));
            } else {
#line 45
              *(h->keys + i) = key;
#line 45
              *(h->vals + i) = val;
#line 45
              goto while_break___0;
            }
          } else {
#line 45
            *(h->keys + i) = key;
#line 45
            *(h->vals + i) = val;
#line 45
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 45
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 45
    if (h->n_buckets > new_n_buckets) {
      {
#line 45
      tmp___6 = realloc((void *)h->keys, (unsigned long )new_n_buckets * sizeof(kh_cstr_t ));
#line 45
      h->keys = (kh_cstr_t *)tmp___6;
#line 45
      tmp___7 = realloc((void *)h->vals, (unsigned long )new_n_buckets * sizeof(reglist_t ));
#line 45
      h->vals = (reglist_t *)tmp___7;
      }
    }
    {
#line 45
    free((void *)h->flags);
#line 45
    h->flags = new_flags;
#line 45
    h->n_buckets = new_n_buckets;
#line 45
    h->n_occupied = h->size;
#line 45
    h->upper_bound = (khint_t )((double const   )h->n_buckets * __ac_HASH_UPPER + (double const   )0.5);
    }
  }
#line 45
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
__inline static khint_t kh_put_reg(kh_reg_t *h , kh_cstr_t key , int *ret ) 
{ 
  khint_t x ;
  khint_t inc ;
  khint_t k ;
  khint_t i ;
  khint_t site ;
  khint_t last ;
  khint_t mask ;
  int tmp ;

  {
#line 45
  if (h->n_occupied >= h->upper_bound) {
#line 45
    if (h->n_buckets > h->size << 1) {
      {
#line 45
      kh_resize_reg(h, h->n_buckets - 1U);
      }
    } else {
      {
#line 45
      kh_resize_reg(h, h->n_buckets + 1U);
      }
    }
  }
  {
#line 45
  mask = h->n_buckets - 1U;
#line 45
  site = h->n_buckets;
#line 45
  x = site;
#line 45
  k = __ac_X31_hash_string(key);
#line 45
  i = k & mask;
  }
#line 45
  if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U) {
#line 45
    x = i;
  } else {
#line 45
    inc = (((k >> 3) ^ (k << 3)) | 1U) & mask;
#line 45
    last = i;
    {
#line 45
    while (1) {
      while_continue: /* CIL Label */ ;
#line 45
      if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U)) {
#line 45
        if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U)) {
          {
#line 45
          tmp = strcmp(*(h->keys + i), key);
          }
#line 45
          if (tmp == 0) {
#line 45
            goto while_break;
          }
        }
      } else {
#line 45
        goto while_break;
      }
#line 45
      if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U) {
#line 45
        site = i;
      }
#line 45
      i = (i + inc) & mask;
#line 45
      if (i == last) {
#line 45
        x = site;
#line 45
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 45
    if (x == h->n_buckets) {
#line 45
      if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U) {
#line 45
        if (site != h->n_buckets) {
#line 45
          x = site;
        } else {
#line 45
          x = i;
        }
      } else {
#line 45
        x = i;
      }
    }
  }
#line 45
  if ((*(h->flags + (x >> 4)) >> ((x & 15U) << 1)) & 2U) {
#line 45
    *(h->keys + x) = key;
#line 45
    *(h->flags + (x >> 4)) = (khint32_t )((unsigned long )*(h->flags + (x >> 4)) & ~ (3UL << ((x & 15U) << 1)));
#line 45
    (h->size) ++;
#line 45
    (h->n_occupied) ++;
#line 45
    *ret = 1;
  } else
#line 45
  if ((*(h->flags + (x >> 4)) >> ((x & 15U) << 1)) & 1U) {
#line 45
    *(h->keys + x) = key;
#line 45
    *(h->flags + (x >> 4)) = (khint32_t )((unsigned long )*(h->flags + (x >> 4)) & ~ (3UL << ((x & 15U) << 1)));
#line 45
    (h->size) ++;
#line 45
    *ret = 2;
  } else {
#line 45
    *ret = 0;
  }
#line 45
  return (x);
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
reghash_t *stk_reg_read(char const   *fn ) 
{ 
  reghash_t *h ;
  kh_reg_t *tmp ;
  gzFile fp ;
  kstream_t *ks ;
  int dret ;
  kstring_t *str ;
  void *tmp___0 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  gzFile tmp___4 ;
  int tmp___5 ;
  int beg ;
  int end ;
  reglist_t *p ;
  khint_t k ;
  khint_t tmp___6 ;
  int ret ;
  char *s ;
  char *tmp___7 ;
  int tmp___8 ;
  unsigned short const   **tmp___9 ;
  int tmp___10 ;
  unsigned short const   **tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  {
#line 51
  tmp = kh_init_reg();
#line 51
  h = tmp;
#line 57
  tmp___0 = calloc((size_t )1, sizeof(kstring_t ));
#line 57
  str = (kstring_t *)tmp___0;
#line 58
  tmp___5 = strcmp(fn, "-");
  }
#line 58
  if (tmp___5) {
    {
#line 58
    tmp___2 = gzopen(fn, "r");
#line 58
    fp = tmp___2;
    }
  } else {
    {
#line 58
    tmp___3 = fileno(stdin);
#line 58
    tmp___4 = gzdopen(tmp___3, "r");
#line 58
    fp = tmp___4;
    }
  }
  {
#line 59
  ks = ks_init(fp);
  }
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 60
    tmp___14 = ks_getuntil(ks, 0, str, & dret);
    }
#line 60
    if (! (tmp___14 >= 0)) {
#line 60
      goto while_break;
    }
    {
#line 61
    beg = -1;
#line 61
    end = -1;
#line 63
    tmp___6 = kh_get_reg((kh_reg_t const   *)h, (kh_cstr_t )str->s);
#line 63
    k = tmp___6;
    }
#line 64
    if (k == h->n_buckets) {
      {
#line 66
      tmp___7 = strdup((char const   *)str->s);
#line 66
      s = tmp___7;
#line 67
      k = kh_put_reg(h, (kh_cstr_t )s, & ret);
#line 68
      memset((void *)(h->vals + k), 0, sizeof(reglist_t ));
      }
    }
#line 70
    p = h->vals + k;
#line 71
    if (dret != 10) {
      {
#line 72
      tmp___10 = ks_getuntil(ks, 0, str, & dret);
      }
#line 72
      if (tmp___10 > 0) {
        {
#line 72
        tmp___11 = __ctype_b_loc();
        }
#line 72
        if ((int const   )*(*tmp___11 + (int )*(str->s + 0)) & 2048) {
          {
#line 73
          beg = atoi((char const   *)str->s);
          }
#line 74
          if (dret != 10) {
            {
#line 75
            tmp___8 = ks_getuntil(ks, 0, str, & dret);
            }
#line 75
            if (tmp___8 > 0) {
              {
#line 75
              tmp___9 = __ctype_b_loc();
              }
#line 75
              if ((int const   )*(*tmp___9 + (int )*(str->s + 0)) & 2048) {
                {
#line 76
                end = atoi((char const   *)str->s);
                }
#line 77
                if (end < 0) {
#line 77
                  end = -1;
                }
              }
            }
          }
        }
      }
    }
#line 83
    if (dret != 10) {
      {
#line 83
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 83
        dret = ks_getc(ks);
        }
#line 83
        if (dret > 0) {
#line 83
          if (! (dret != 10)) {
#line 83
            goto while_break___0;
          }
        } else {
#line 83
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 84
    if (end < 0) {
#line 84
      if (beg > 0) {
#line 84
        end = beg;
#line 84
        beg --;
      }
    }
#line 85
    if (beg < 0) {
#line 85
      beg = 0;
#line 85
      end = 2147483647;
    }
#line 86
    if (p->n == p->m) {
#line 87
      if (p->m) {
#line 87
        p->m <<= 1;
      } else {
#line 87
        p->m = 4;
      }
      {
#line 88
      tmp___12 = realloc((void *)p->a, (size_t )(p->m * 8));
#line 88
      p->a = (uint64_t *)tmp___12;
      }
    }
#line 90
    tmp___13 = p->n;
#line 90
    (p->n) ++;
#line 90
    *(p->a + tmp___13) = ((uint64_t )beg << 32) | (unsigned long )end;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 92
  ks_destroy(ks);
#line 93
  gzclose(fp);
#line 94
  free((void *)str->s);
#line 94
  free((void *)str);
  }
#line 95
  return (h);
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
void stk_reg_destroy(reghash_t *h ) 
{ 
  khint_t k ;

  {
#line 101
  if ((unsigned long )h == (unsigned long )((reghash_t *)0)) {
#line 101
    return;
  }
#line 102
  k = (khint_t )0;
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (! (k < h->n_buckets)) {
#line 102
      goto while_break;
    }
#line 103
    if (! ((*(h->flags + (k >> 4)) >> ((k & 15U) << 1)) & 3U)) {
      {
#line 104
      free((void *)(h->vals + k)->a);
#line 105
      free((void *)((char *)*(h->keys + k)));
      }
    }
#line 102
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 108
  kh_destroy_reg(h);
  }
#line 109
  return;
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
unsigned char seq_nt16_table[256]  = 
#line 113
  {      (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)1,      (unsigned char)14,      (unsigned char)2, 
        (unsigned char)13,      (unsigned char)15,      (unsigned char)15,      (unsigned char)4, 
        (unsigned char)11,      (unsigned char)15,      (unsigned char)15,      (unsigned char)12, 
        (unsigned char)15,      (unsigned char)3,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)8,      (unsigned char)15,      (unsigned char)7,      (unsigned char)9, 
        (unsigned char)0,      (unsigned char)10,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)1,      (unsigned char)14,      (unsigned char)2, 
        (unsigned char)13,      (unsigned char)15,      (unsigned char)15,      (unsigned char)4, 
        (unsigned char)11,      (unsigned char)15,      (unsigned char)15,      (unsigned char)12, 
        (unsigned char)15,      (unsigned char)3,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)8,      (unsigned char)15,      (unsigned char)7,      (unsigned char)9, 
        (unsigned char)0,      (unsigned char)10,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15};
#line 132 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
char *seq_nt16_rev_table  =    (char *)"XACMGRSVTWYHKDBN";
#line 133 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
unsigned char seq_nt16to4_table[16]  = 
#line 133
  {      (unsigned char)4,      (unsigned char)0,      (unsigned char)1,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4};
#line 134 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
unsigned char seq_nt16comp_table[16]  = 
#line 134
  {      (unsigned char)0,      (unsigned char)8,      (unsigned char)4,      (unsigned char)12, 
        (unsigned char)2,      (unsigned char)10,      (unsigned char)9,      (unsigned char)14, 
        (unsigned char)1,      (unsigned char)6,      (unsigned char)5,      (unsigned char)13, 
        (unsigned char)3,      (unsigned char)11,      (unsigned char)7,      (unsigned char)15};
#line 135 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
int bitcnt_table[16]  = 
#line 135
  {      4,      1,      1,      2, 
        1,      2,      2,      3, 
        1,      2,      2,      3, 
        2,      3,      3,      4};
#line 136 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
char comp_tab[128]  = 
#line 136
  {      (char)0,      (char)1,      (char)2,      (char)3, 
        (char)4,      (char)5,      (char)6,      (char)7, 
        (char)8,      (char)9,      (char)10,      (char)11, 
        (char)12,      (char)13,      (char)14,      (char)15, 
        (char)16,      (char)17,      (char)18,      (char)19, 
        (char)20,      (char)21,      (char)22,      (char)23, 
        (char)24,      (char)25,      (char)26,      (char)27, 
        (char)28,      (char)29,      (char)30,      (char)31, 
        (char)32,      (char)33,      (char)34,      (char)35, 
        (char)36,      (char)37,      (char)38,      (char)39, 
        (char)40,      (char)41,      (char)42,      (char)43, 
        (char)44,      (char)45,      (char)46,      (char)47, 
        (char)48,      (char)49,      (char)50,      (char)51, 
        (char)52,      (char)53,      (char)54,      (char)55, 
        (char)56,      (char)57,      (char)58,      (char)59, 
        (char)60,      (char)61,      (char)62,      (char)63, 
        (char)64,      (char )'T',      (char )'V',      (char )'G', 
        (char )'H',      (char )'E',      (char )'F',      (char )'C', 
        (char )'D',      (char )'I',      (char )'J',      (char )'M', 
        (char )'L',      (char )'K',      (char )'N',      (char )'O', 
        (char )'P',      (char )'Q',      (char )'Y',      (char )'S', 
        (char )'A',      (char )'A',      (char )'B',      (char )'W', 
        (char )'X',      (char )'R',      (char )'Z',      (char)91, 
        (char)92,      (char)93,      (char)94,      (char)95, 
        (char)64,      (char )'t',      (char )'v',      (char )'g', 
        (char )'h',      (char )'e',      (char )'f',      (char )'c', 
        (char )'d',      (char )'i',      (char )'j',      (char )'m', 
        (char )'l',      (char )'k',      (char )'n',      (char )'o', 
        (char )'p',      (char )'q',      (char )'y',      (char )'s', 
        (char )'a',      (char )'a',      (char )'b',      (char )'w', 
        (char )'x',      (char )'r',      (char )'z',      (char)123, 
        (char)124,      (char)125,      (char)126,      (char)127};
#line 147 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
static void stk_printstr(kstring_t const   *s , unsigned int line_len ) 
{ 
  int i ;
  int rest ;

  {
#line 149
  if (line_len != 4294967295U) {
#line 150
    rest = (int )s->l;
#line 151
    i = 0;
    {
#line 151
    while (1) {
      while_continue: /* CIL Label */ ;
#line 151
      if (! ((size_t const   )i < s->l)) {
#line 151
        goto while_break;
      }
      {
#line 152
      putchar('\n');
      }
#line 153
      if ((unsigned int )rest > line_len) {
        {
#line 153
        fwrite((void const   */* __restrict  */)(s->s + i), (size_t )1, (size_t )line_len,
               (FILE */* __restrict  */)stdout);
        }
      } else {
        {
#line 154
        fwrite((void const   */* __restrict  */)(s->s + i), (size_t )1, (size_t )rest,
               (FILE */* __restrict  */)stdout);
        }
      }
#line 151
      i = (int )((unsigned int )i + line_len);
#line 151
      rest = (int )((unsigned int )rest - line_len);
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 156
    putchar('\n');
    }
  } else {
    {
#line 158
    putchar('\n');
#line 159
    puts((char const   *)s->s);
    }
  }
#line 161
  return;
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
void stk_printseq(kseq_t const   *s , int line_len ) 
{ 
  int tmp ;

  {
#line 165
  if (s->qual.l) {
#line 165
    tmp = '@';
  } else {
#line 165
    tmp = '>';
  }
  {
#line 165
  putchar(tmp);
#line 166
  fputs((char const   */* __restrict  */)s->name.s, (FILE */* __restrict  */)stdout);
  }
#line 167
  if (s->comment.l) {
    {
#line 168
    putchar(' ');
#line 168
    fputs((char const   */* __restrict  */)s->comment.s, (FILE */* __restrict  */)stdout);
    }
  }
  {
#line 170
  stk_printstr(& s->seq, (unsigned int )line_len);
  }
#line 171
  if (s->qual.l) {
    {
#line 172
    putchar('+');
#line 173
    stk_printstr(& s->qual, (unsigned int )line_len);
    }
  }
#line 175
  return;
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
int stk_trimfq(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *seq ;
  double param ;
  double q_int2real[128] ;
  int i ;
  int c ;
  int min_len ;
  int left ;
  int right ;
  gzFile tmp___0 ;
  int tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  int beg ;
  int tmp___4 ;
  int end ;
  double s ;
  double max ;
  int q ;
  int is ;
  int imax ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 182
  param = 0.05;
#line 183
  min_len = 30;
#line 183
  left = 0;
#line 183
  right = 0;
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 184
    c = getopt(argc, (char * const  *)argv, "l:q:b:e:");
    }
#line 184
    if (! (c >= 0)) {
#line 184
      goto while_break;
    }
    {
#line 186
    if (c == 113) {
#line 186
      goto case_113;
    }
#line 187
    if (c == 108) {
#line 187
      goto case_108;
    }
#line 188
    if (c == 98) {
#line 188
      goto case_98;
    }
#line 189
    if (c == 101) {
#line 189
      goto case_101;
    }
#line 185
    goto switch_break;
    case_113: /* CIL Label */ 
    {
#line 186
    param = atof((char const   *)optarg);
    }
#line 186
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 187
    min_len = atoi((char const   *)optarg);
    }
#line 187
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 188
    left = atoi((char const   *)optarg);
    }
#line 188
    goto switch_break;
    case_101: /* CIL Label */ 
    {
#line 189
    right = atoi((char const   *)optarg);
    }
#line 189
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  if (optind == argc) {
    {
#line 193
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 194
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage:   seqtk trimfq [options] <in.fq>\n\n");
#line 195
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options: -q FLOAT    error rate threshold (disabled by -b/-e) [%.2f]\n",
            param);
#line 196
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -l INT      maximally trim down to INT bp (disabled by -b/-e) [%d]\n",
            min_len);
#line 197
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -b INT      trim INT bp from left (non-zero to disable -q/-l) [0]\n");
#line 198
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -e INT      trim INT bp from right (non-zero to disable -q/-l) [0]\n");
#line 199
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
#line 200
    return (1);
  }
  {
#line 202
  tmp___3 = strcmp((char const   *)*(argv + optind), "-");
  }
#line 202
  if (tmp___3) {
    {
#line 202
    tmp___0 = gzopen((char const   *)*(argv + optind), "r");
#line 202
    fp = tmp___0;
    }
  } else {
    {
#line 202
    tmp___1 = fileno(stdin);
#line 202
    tmp___2 = gzdopen(tmp___1, "r");
#line 202
    fp = tmp___2;
    }
  }
  {
#line 203
  seq = kseq_init(fp);
#line 204
  i = 0;
  }
  {
#line 204
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 204
    if (! (i < 128)) {
#line 204
      goto while_break___0;
    }
    {
#line 205
    q_int2real[i] = pow(10., (double )(- (i - 33)) / 10.);
#line 204
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 206
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 206
    tmp___6 = kseq_read(seq);
    }
#line 206
    if (! (tmp___6 >= 0)) {
#line 206
      goto while_break___1;
    }
#line 209
    if (left) {
#line 209
      goto _L;
    } else
#line 209
    if (right) {
      _L: /* CIL Label */ 
#line 210
      beg = left;
#line 210
      end = (int )(seq->seq.l - (size_t )right);
#line 211
      if (beg >= end) {
#line 211
        end = 0;
#line 211
        beg = end;
      }
    } else
#line 212
    if (seq->qual.l > (size_t )min_len) {
#line 213
      i = 0;
#line 213
      tmp___4 = 0;
#line 213
      beg = tmp___4;
#line 213
      end = (int )seq->qual.l;
#line 213
      max = 0.;
#line 213
      s = max;
      {
#line 213
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 213
        if (! ((size_t )i < seq->qual.l)) {
#line 213
          goto while_break___2;
        }
#line 214
        q = (int )*(seq->qual.s + i);
#line 215
        if (q < 36) {
#line 215
          q = 36;
        }
#line 216
        if (q > 127) {
#line 216
          q = 127;
        }
#line 217
        s += param - q_int2real[q];
#line 218
        if (s > max) {
#line 218
          max = s;
#line 218
          beg = tmp___4;
#line 218
          end = i + 1;
        }
#line 219
        if (s < (double )0) {
#line 219
          s = (double )0;
#line 219
          tmp___4 = i + 1;
        }
#line 213
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 221
      if (end - beg < min_len) {
#line 223
        i = 0;
#line 223
        is = 0;
        {
#line 223
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 223
          if (! (i < min_len)) {
#line 223
            goto while_break___3;
          }
#line 224
          is += (int )*(seq->qual.s + i) - 33;
#line 223
          i ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 225
        imax = is;
#line 225
        beg = 0;
        {
#line 225
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 225
          if (! ((size_t )i < seq->qual.l)) {
#line 225
            goto while_break___4;
          }
#line 226
          is += (int )*(seq->qual.s + i) - (int )*(seq->qual.s + (i - min_len));
#line 227
          if (imax < is) {
#line 227
            imax = is;
#line 227
            beg = (i - min_len) + 1;
          }
#line 225
          i ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 229
        end = beg + min_len;
      }
    } else {
#line 231
      beg = 0;
#line 231
      end = (int )seq->seq.l;
    }
#line 232
    if (seq->qual.l) {
#line 232
      tmp___5 = '@';
    } else {
#line 232
      tmp___5 = '>';
    }
    {
#line 232
    putchar(tmp___5);
#line 232
    fputs((char const   */* __restrict  */)seq->name.s, (FILE */* __restrict  */)stdout);
    }
#line 233
    if (seq->comment.l) {
      {
#line 234
      putchar(' ');
#line 234
      puts((char const   *)seq->comment.s);
      }
    } else {
      {
#line 235
      putchar('\n');
      }
    }
    {
#line 236
    fwrite((void const   */* __restrict  */)(seq->seq.s + beg), (size_t )1, (size_t )(end - beg),
           (FILE */* __restrict  */)stdout);
#line 236
    putchar('\n');
    }
#line 237
    if (seq->qual.l) {
      {
#line 238
      puts("+");
#line 239
      fwrite((void const   */* __restrict  */)(seq->qual.s + beg), (size_t )1, (size_t )(end - beg),
             (FILE */* __restrict  */)stdout);
#line 239
      putchar('\n');
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 242
  kseq_destroy(seq);
#line 243
  gzclose(fp);
  }
#line 244
  return (0);
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
int stk_comp(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *seq ;
  int l ;
  int c ;
  int upper_only ;
  reghash_t *h ;
  reglist_t dummy ;
  int tmp___0 ;
  gzFile tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  int i ;
  int k ;
  reglist_t *p ;
  khint_t k___0 ;
  khint_t tmp___5 ;
  int beg ;
  int end ;
  int la ;
  int lb ;
  int lc ;
  int na ;
  int nb ;
  int nc ;
  int cnt[11] ;
  int is_CpG ;
  int a ;
  int b ;
  int c___0 ;
  unsigned short const   **tmp___6 ;

  {
#line 252
  upper_only = 0;
#line 253
  h = (reghash_t *)0;
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 255
    c = getopt(argc, (char * const  *)argv, "ur:");
    }
#line 255
    if (! (c >= 0)) {
#line 255
      goto while_break;
    }
    {
#line 257
    if (c == 117) {
#line 257
      goto case_117;
    }
#line 258
    if (c == 114) {
#line 258
      goto case_114;
    }
#line 256
    goto switch_break;
    case_117: /* CIL Label */ 
#line 257
    upper_only = 1;
#line 257
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 258
    h = stk_reg_read((char const   *)optarg);
    }
#line 258
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 261
  if (argc == optind) {
    {
#line 262
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage:  seqtk comp [-u] [-r in.bed] <in.fa>\n\n");
#line 263
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Output format: chr, length, #A, #C, #G, #T, #2, #3, #4, #CpG, #tv, #ts, #CpG-ts\n");
    }
#line 264
    return (1);
  }
  {
#line 266
  tmp___3 = strcmp((char const   *)*(argv + optind), "-");
  }
#line 266
  if (tmp___3 == 0) {
    {
#line 266
    tmp___0 = fileno(stdin);
#line 266
    tmp___1 = gzdopen(tmp___0, "r");
#line 266
    fp = tmp___1;
    }
  } else {
    {
#line 266
    tmp___2 = gzopen((char const   *)*(argv + optind), "r");
#line 266
    fp = tmp___2;
    }
  }
  {
#line 267
  seq = kseq_init(fp);
#line 268
  dummy.m = 1;
#line 268
  dummy.n = dummy.m;
#line 268
  tmp___4 = calloc((size_t )1, (size_t )8);
#line 268
  dummy.a = (uint64_t *)tmp___4;
  }
  {
#line 269
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 269
    l = kseq_read(seq);
    }
#line 269
    if (! (l >= 0)) {
#line 269
      goto while_break___0;
    }
#line 271
    p = (reglist_t *)0;
#line 272
    if (h) {
      {
#line 273
      tmp___5 = kh_get_reg((kh_reg_t const   *)h, (kh_cstr_t )seq->name.s);
#line 273
      k___0 = tmp___5;
      }
#line 274
      if (k___0 != h->n_buckets) {
#line 274
        p = h->vals + k___0;
      }
    } else {
#line 276
      p = & dummy;
#line 277
      *(dummy.a + 0) = (uint64_t )l;
    }
#line 279
    k = 0;
    {
#line 279
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 279
      if (p) {
#line 279
        if (! (k < p->n)) {
#line 279
          goto while_break___1;
        }
      } else {
#line 279
        goto while_break___1;
      }
#line 280
      beg = (int )(*(p->a + k) >> 32);
#line 280
      end = (int )(*(p->a + k) & 4294967295UL);
#line 282
      if (beg > 0) {
#line 282
        la = (int )*(seq->seq.s + (beg - 1));
#line 282
        lb = (int )seq_nt16_table[la];
#line 282
        lc = bitcnt_table[lb];
      } else {
#line 283
        la = 'a';
#line 283
        lb = -1;
#line 283
        lc = 0;
      }
      {
#line 284
      na = (int )*(seq->seq.s + beg);
#line 284
      nb = (int )seq_nt16_table[na];
#line 284
      nc = bitcnt_table[nb];
#line 285
      memset((void *)(cnt), 0, 11UL * sizeof(int ));
#line 286
      i = beg;
      }
      {
#line 286
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 286
        if (! (i < end)) {
#line 286
          goto while_break___2;
        }
#line 287
        is_CpG = 0;
#line 288
        a = na;
#line 288
        b = nb;
#line 288
        c___0 = nc;
#line 289
        na = (int )*(seq->seq.s + (i + 1));
#line 289
        nb = (int )seq_nt16_table[na];
#line 289
        nc = bitcnt_table[nb];
#line 290
        if (b == 2) {
#line 290
          goto _L___0;
        } else
#line 290
        if (b == 10) {
          _L___0: /* CIL Label */ 
#line 291
          if (nb == 4) {
#line 291
            is_CpG = 1;
          } else
#line 291
          if (nb == 5) {
#line 291
            is_CpG = 1;
          }
        } else
#line 292
        if (b == 4) {
#line 292
          goto _L;
        } else
#line 292
        if (b == 5) {
          _L: /* CIL Label */ 
#line 293
          if (lb == 2) {
#line 293
            is_CpG = 1;
          } else
#line 293
          if (lb == 10) {
#line 293
            is_CpG = 1;
          }
        }
#line 295
        if (upper_only == 0) {
#line 295
          goto _L___1;
        } else {
          {
#line 295
          tmp___6 = __ctype_b_loc();
          }
#line 295
          if ((int const   )*(*tmp___6 + a) & 256) {
            _L___1: /* CIL Label */ 
#line 296
            if (c___0 > 1) {
#line 296
              (cnt[c___0 + 2]) ++;
            }
#line 297
            if (c___0 == 1) {
#line 297
              (cnt[seq_nt16to4_table[b]]) ++;
            }
#line 298
            if (b == 10) {
#line 298
              (cnt[9]) ++;
            } else
#line 298
            if (b == 5) {
#line 298
              (cnt[9]) ++;
            } else
#line 299
            if (c___0 == 2) {
#line 300
              (cnt[8]) ++;
            }
#line 302
            if (is_CpG) {
#line 303
              (cnt[7]) ++;
#line 304
              if (b == 10) {
#line 304
                (cnt[10]) ++;
              } else
#line 304
              if (b == 5) {
#line 304
                (cnt[10]) ++;
              }
            }
          }
        }
#line 307
        la = a;
#line 307
        lb = b;
#line 307
        lc = c___0;
#line 286
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 309
      if (h) {
        {
#line 309
        printf((char const   */* __restrict  */)"%s\t%d\t%d", seq->name.s, beg, end);
        }
      } else {
        {
#line 310
        printf((char const   */* __restrict  */)"%s\t%d", seq->name.s, l);
        }
      }
#line 311
      i = 0;
      {
#line 311
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 311
        if (! (i < 11)) {
#line 311
          goto while_break___3;
        }
        {
#line 311
        printf((char const   */* __restrict  */)"\t%d", cnt[i]);
#line 311
        i ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 312
      putchar('\n');
#line 279
      k ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 314
    fflush(stdout);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 316
  free((void *)dummy.a);
#line 317
  kseq_destroy(seq);
#line 318
  gzclose(fp);
  }
#line 319
  return (0);
}
}
#line 322 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
int stk_randbase(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *seq ;
  int l ;
  int tmp___0 ;
  gzFile tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  int i ;
  int c ;
  int b ;
  int a ;
  int j ;
  int k ;
  int m ;
  double tmp___4 ;
  unsigned short const   **tmp___6 ;

  {
#line 327
  if (argc == 1) {
    {
#line 328
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: seqtk randbase <in.fa>\n");
    }
#line 329
    return (1);
  }
  {
#line 331
  tmp___3 = strcmp((char const   *)*(argv + 1), "-");
  }
#line 331
  if (tmp___3 == 0) {
    {
#line 331
    tmp___0 = fileno(stdin);
#line 331
    tmp___1 = gzdopen(tmp___0, "r");
#line 331
    fp = tmp___1;
    }
  } else {
    {
#line 331
    tmp___2 = gzopen((char const   *)*(argv + 1), "r");
#line 331
    fp = tmp___2;
    }
  }
  {
#line 332
  seq = kseq_init(fp);
  }
  {
#line 333
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 333
    l = kseq_read(seq);
    }
#line 333
    if (! (l >= 0)) {
#line 333
      goto while_break;
    }
    {
#line 335
    printf((char const   */* __restrict  */)">%s", seq->name.s);
#line 336
    i = 0;
    }
    {
#line 336
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 336
      if (! (i < l)) {
#line 336
        goto while_break___0;
      }
#line 338
      b = (int )*(seq->seq.s + i);
#line 339
      c = (int )seq_nt16_table[b];
#line 340
      a = bitcnt_table[c];
#line 341
      if (a == 2) {
        {
#line 342
        tmp___4 = drand48();
#line 342
        m = tmp___4 < 0.5;
#line 343
        k = 0;
#line 343
        j = k;
        }
        {
#line 343
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 343
          if (! (j < 4)) {
#line 343
            goto while_break___1;
          }
#line 344
          if (((1 << j) & c) == 0) {
#line 344
            goto __Cont;
          }
#line 345
          if (k == m) {
#line 345
            goto while_break___1;
          }
#line 346
          k ++;
          __Cont: /* CIL Label */ 
#line 343
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 348
        tmp___6 = __ctype_b_loc();
        }
#line 348
        if ((int const   )*(*tmp___6 + b) & 512) {
#line 348
          *(seq->seq.s + i) = (char )*("acgt" + j);
        } else {
#line 348
          *(seq->seq.s + i) = (char )*("ACGT" + j);
        }
      }
#line 350
      if (i % 60 == 0) {
        {
#line 350
        putchar('\n');
        }
      }
      {
#line 351
      putchar((int )*(seq->seq.s + i));
#line 336
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 353
    putchar('\n');
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 355
  kseq_destroy(seq);
#line 356
  gzclose(fp);
  }
#line 357
  return (0);
}
}
#line 360 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
int stk_hety(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *seq ;
  int l ;
  int c ;
  int win_size ;
  int n_start ;
  int win_step ;
  int is_lower_mask ;
  char *buf ;
  uint32_t cnt[3] ;
  int tmp___0 ;
  gzFile tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  int x ;
  int i ;
  int y ;
  int z ;
  int next ;
  unsigned short const   **tmp___5 ;
  int tmp___6 ;

  {
#line 364
  win_size = 50000;
#line 364
  n_start = 5;
#line 364
  is_lower_mask = 0;
#line 367
  if (argc == 1) {
    {
#line 368
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 369
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage:   seqtk hety [options] <in.fa>\n\n");
#line 370
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options: -w INT   window size [%d]\n",
            win_size);
#line 371
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -t INT   # start positions in a window [%d]\n",
            n_start);
#line 372
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -m       treat lowercases as masked\n");
#line 373
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
#line 374
    return (1);
  }
  {
#line 376
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 376
    c = getopt(argc, (char * const  *)argv, "w:t:m");
    }
#line 376
    if (! (c >= 0)) {
#line 376
      goto while_break;
    }
    {
#line 378
    if (c == 119) {
#line 378
      goto case_119;
    }
#line 379
    if (c == 116) {
#line 379
      goto case_116;
    }
#line 380
    if (c == 109) {
#line 380
      goto case_109;
    }
#line 377
    goto switch_break;
    case_119: /* CIL Label */ 
    {
#line 378
    win_size = atoi((char const   *)optarg);
    }
#line 378
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 379
    n_start = atoi((char const   *)optarg);
    }
#line 379
    goto switch_break;
    case_109: /* CIL Label */ 
#line 380
    is_lower_mask = 1;
#line 380
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 383
  tmp___3 = strcmp((char const   *)*(argv + optind), "-");
  }
#line 383
  if (tmp___3 == 0) {
    {
#line 383
    tmp___0 = fileno(stdin);
#line 383
    tmp___1 = gzdopen(tmp___0, "r");
#line 383
    fp = tmp___1;
    }
  } else {
    {
#line 383
    tmp___2 = gzopen((char const   *)*(argv + optind), "r");
#line 383
    fp = tmp___2;
    }
  }
  {
#line 384
  seq = kseq_init(fp);
#line 385
  win_step = win_size / n_start;
#line 386
  tmp___4 = calloc((size_t )win_size, (size_t )1);
#line 386
  buf = (char *)tmp___4;
  }
  {
#line 387
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 387
    l = kseq_read(seq);
    }
#line 387
    if (! (l >= 0)) {
#line 387
      goto while_break___0;
    }
#line 388
    next = 0;
#line 389
    cnt[2] = (uint32_t )0;
#line 389
    cnt[1] = cnt[2];
#line 389
    cnt[0] = cnt[1];
#line 390
    i = 0;
    {
#line 390
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 390
      if (! (i <= l)) {
#line 390
        goto while_break___1;
      }
#line 391
      if (i >= win_size) {
#line 391
        if (i % win_step == 0) {
#line 391
          goto _L;
        } else {
#line 391
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 391
      if (i == l) {
        _L: /* CIL Label */ 
#line 392
        if (i == l) {
#line 392
          if (l >= win_size) {
#line 393
            y = l - win_size;
            {
#line 393
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 393
              if (! (y < next)) {
#line 393
                goto while_break___2;
              }
#line 393
              (cnt[(int )*(buf + y % win_size)]) --;
#line 393
              y ++;
            }
            while_break___2: /* CIL Label */ ;
            }
          }
        }
#line 395
        if (cnt[1] + cnt[2] > 0U) {
          {
#line 396
          printf((char const   */* __restrict  */)"%s\t%d\t%d\t%.2lf\t%d\t%d\n", seq->name.s,
                 next, i, ((double )cnt[2] / (double )(cnt[1] + cnt[2])) * (double )win_size,
                 cnt[1] + cnt[2], cnt[2]);
          }
        }
#line 398
        next = i;
      }
#line 400
      if (i < l) {
#line 401
        y = i % win_size;
#line 402
        c = (int )*(seq->seq.s + i);
#line 403
        if (is_lower_mask) {
          {
#line 403
          tmp___5 = __ctype_b_loc();
          }
#line 403
          if ((int const   )*(*tmp___5 + c) & 512) {
#line 403
            c = 'N';
          }
        }
#line 404
        c = (int )seq_nt16_table[c];
#line 405
        x = bitcnt_table[c];
#line 406
        if (i >= win_size) {
#line 406
          (cnt[(int )*(buf + y)]) --;
        }
#line 407
        if (x > 2) {
#line 407
          z = 0;
        } else {
#line 407
          if (x == 2) {
#line 407
            tmp___6 = 2;
          } else {
#line 407
            tmp___6 = 1;
          }
#line 407
          z = tmp___6;
        }
#line 407
        *(buf + y) = (char )z;
#line 408
        (cnt[z]) ++;
      }
#line 390
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 412
  free((void *)buf);
#line 413
  kseq_destroy(seq);
#line 414
  gzclose(fp);
  }
#line 415
  return (0);
}
}
#line 420 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
int stk_subseq(int argc , char **argv ) 
{ 
  kh_reg_t *h ;
  kh_reg_t *tmp ;
  gzFile fp ;
  kseq_t *seq ;
  int l ;
  int i ;
  int j ;
  int c ;
  int is_tab ;
  int line ;
  khint_t k ;
  gzFile tmp___1 ;
  int tmp___2 ;
  gzFile tmp___3 ;
  int tmp___4 ;
  reglist_t *p ;
  int beg ;
  int end ;
  int tmp___5 ;

  {
  {
#line 422
  tmp = kh_init_reg();
#line 422
  h = tmp;
#line 425
  is_tab = 0;
#line 425
  line = 1024;
  }
  {
#line 427
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 427
    c = getopt(argc, (char * const  *)argv, "tl:");
    }
#line 427
    if (! (c >= 0)) {
#line 427
      goto while_break;
    }
    {
#line 429
    if (c == 116) {
#line 429
      goto case_116;
    }
#line 430
    if (c == 108) {
#line 430
      goto case_108;
    }
#line 428
    goto switch_break;
    case_116: /* CIL Label */ 
#line 429
    is_tab = 1;
#line 429
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 430
    line = atoi((char const   *)optarg);
    }
#line 430
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 433
  if (optind + 2 > argc) {
    {
#line 434
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 435
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage:   seqtk subseq [options] <in.fa> <in.bed>|<name.list>\n\n");
#line 436
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options: -t       TAB delimited output\n");
#line 437
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -l INT   sequence line length [%d]\n\n",
            line);
#line 438
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: Use \'samtools faidx\' if only a few regions are intended.\n\n");
    }
#line 439
    return (1);
  }
  {
#line 441
  h = stk_reg_read((char const   *)*(argv + (optind + 1)));
#line 443
  tmp___4 = strcmp((char const   *)*(argv + optind), "-");
  }
#line 443
  if (tmp___4) {
    {
#line 443
    tmp___1 = gzopen((char const   *)*(argv + optind), "r");
#line 443
    fp = tmp___1;
    }
  } else {
    {
#line 443
    tmp___2 = fileno(stdin);
#line 443
    tmp___3 = gzdopen(tmp___2, "r");
#line 443
    fp = tmp___3;
    }
  }
  {
#line 444
  seq = kseq_init(fp);
  }
  {
#line 445
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 445
    l = kseq_read(seq);
    }
#line 445
    if (! (l >= 0)) {
#line 445
      goto while_break___0;
    }
    {
#line 447
    k = kh_get_reg((kh_reg_t const   *)h, (kh_cstr_t )seq->name.s);
    }
#line 448
    if (k == h->n_buckets) {
#line 448
      goto while_continue___0;
    }
#line 449
    p = h->vals + k;
#line 450
    i = 0;
    {
#line 450
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 450
      if (! (i < p->n)) {
#line 450
        goto while_break___1;
      }
#line 451
      beg = (int )(*(p->a + i) >> 32);
#line 451
      end = (int )*(p->a + i);
#line 452
      if ((size_t )beg >= seq->seq.l) {
        {
#line 453
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[subseq] %s: %d >= %ld\n",
                seq->name.s, beg, seq->seq.l);
        }
#line 454
        goto __Cont;
      }
#line 456
      if ((size_t )end > seq->seq.l) {
#line 456
        end = (int )seq->seq.l;
      }
#line 457
      if (is_tab == 0) {
#line 458
        if (seq->qual.l == seq->seq.l) {
#line 458
          tmp___5 = '@';
        } else {
#line 458
          tmp___5 = '>';
        }
        {
#line 458
        printf((char const   */* __restrict  */)"%c%s", tmp___5, seq->name.s);
        }
#line 459
        if (beg > 0) {
#line 459
          goto _L;
        } else
#line 459
        if ((int )*(p->a + i) != 2147483647) {
          _L: /* CIL Label */ 
#line 460
          if (end == 2147483647) {
#line 461
            if (beg) {
              {
#line 461
              printf((char const   */* __restrict  */)":%d", beg + 1);
              }
            }
          } else {
            {
#line 462
            printf((char const   */* __restrict  */)":%d-%d", beg + 1, end);
            }
          }
        }
      } else {
        {
#line 464
        printf((char const   */* __restrict  */)"%s\t%d\t", seq->name.s, beg + 1);
        }
      }
#line 465
      if ((size_t )end > seq->seq.l) {
#line 465
        end = (int )seq->seq.l;
      }
#line 466
      j = 0;
      {
#line 466
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 466
        if (! (j < end - beg)) {
#line 466
          goto while_break___2;
        }
#line 467
        if (is_tab == 0) {
#line 467
          if (j % line == 0) {
            {
#line 467
            putchar('\n');
            }
          }
        }
        {
#line 468
        putchar((int )*(seq->seq.s + (j + beg)));
#line 466
        j ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 470
      putchar('\n');
      }
#line 471
      if (seq->qual.l != seq->seq.l) {
#line 471
        goto __Cont;
      } else
#line 471
      if (is_tab) {
#line 471
        goto __Cont;
      }
      {
#line 472
      printf((char const   */* __restrict  */)"+");
#line 473
      j = 0;
      }
      {
#line 473
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 473
        if (! (j < end - beg)) {
#line 473
          goto while_break___3;
        }
#line 474
        if (j % line == 0) {
          {
#line 474
          putchar('\n');
          }
        }
        {
#line 475
        putchar((int )*(seq->qual.s + (j + beg)));
#line 473
        j ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 477
      putchar('\n');
      }
      __Cont: /* CIL Label */ 
#line 450
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 481
  kseq_destroy(seq);
#line 482
  gzclose(fp);
#line 483
  stk_reg_destroy(h);
  }
#line 484
  return (0);
}
}
#line 488 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
int stk_mergefa(int argc , char **argv ) 
{ 
  gzFile fp[2] ;
  kseq_t *seq[2] ;
  int i ;
  int l ;
  int c ;
  int is_intersect ;
  int is_haploid ;
  int qual ;
  int is_mask ;
  int is_randhet ;
  uint64_t cnt[5] ;
  gzFile tmp___0 ;
  int tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  int min_l ;
  int c___0[2] ;
  int b[2] ;
  int is_upper ;
  int tmp___4 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___11 ;
  unsigned short const   **tmp___12 ;
  unsigned short const   **tmp___15 ;
  unsigned short const   **tmp___16 ;
  long tmp___18 ;
  long tmp___19 ;
  long tmp___20 ;
  int tmp___21 ;

  {
#line 492
  is_intersect = 0;
#line 492
  is_haploid = 0;
#line 492
  qual = 0;
#line 492
  is_mask = 0;
#line 492
  is_randhet = 0;
  {
#line 494
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 494
    c = getopt(argc, (char * const  *)argv, "himrq:");
    }
#line 494
    if (! (c >= 0)) {
#line 494
      goto while_break;
    }
    {
#line 496
    if (c == 105) {
#line 496
      goto case_105;
    }
#line 497
    if (c == 104) {
#line 497
      goto case_104;
    }
#line 498
    if (c == 109) {
#line 498
      goto case_109;
    }
#line 499
    if (c == 114) {
#line 499
      goto case_114;
    }
#line 500
    if (c == 113) {
#line 500
      goto case_113;
    }
#line 495
    goto switch_break;
    case_105: /* CIL Label */ 
#line 496
    is_intersect = 1;
#line 496
    goto switch_break;
    case_104: /* CIL Label */ 
#line 497
    is_haploid = 1;
#line 497
    goto switch_break;
    case_109: /* CIL Label */ 
#line 498
    is_mask = 1;
#line 498
    goto switch_break;
    case_114: /* CIL Label */ 
#line 499
    is_randhet = 1;
#line 499
    goto switch_break;
    case_113: /* CIL Label */ 
    {
#line 500
    qual = atoi((char const   *)optarg);
    }
#line 500
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 503
  if (is_mask) {
#line 503
    if (is_intersect) {
      {
#line 504
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%s] `-i\' and `-h\' cannot be applied at the same time.\n",
              "stk_mergefa");
      }
#line 505
      return (1);
    }
  }
#line 507
  if (optind + 2 > argc) {
    {
#line 508
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nUsage: seqtk mergefa [options] <in1.fa> <in2.fa>\n\n");
#line 509
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options: -q INT   quality threshold [0]\n");
#line 510
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -i       take intersection\n");
#line 511
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -m       convert to lowercase when one of the input base is N\n");
#line 512
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -r       pick a random allele from het\n");
#line 513
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -h       suppress hets in the input\n\n");
    }
#line 514
    return (1);
  }
#line 516
  i = 0;
  {
#line 516
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 516
    if (! (i < 2)) {
#line 516
      goto while_break___0;
    }
    {
#line 517
    tmp___3 = strcmp((char const   *)*(argv + (optind + i)), "-");
    }
#line 517
    if (tmp___3) {
      {
#line 517
      tmp___0 = gzopen((char const   *)*(argv + (optind + i)), "r");
#line 517
      fp[i] = tmp___0;
      }
    } else {
      {
#line 517
      tmp___1 = fileno(stdin);
#line 517
      tmp___2 = gzdopen(tmp___1, "r");
#line 517
      fp[i] = tmp___2;
      }
    }
    {
#line 518
    seq[i] = kseq_init(fp[i]);
#line 516
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 520
  cnt[4] = (uint64_t )0;
#line 520
  cnt[3] = cnt[4];
#line 520
  cnt[2] = cnt[3];
#line 520
  cnt[1] = cnt[2];
#line 520
  cnt[0] = cnt[1];
#line 521
  srand48(11L);
  }
  {
#line 522
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 522
    tmp___21 = kseq_read(seq[0]);
    }
#line 522
    if (! (tmp___21 >= 0)) {
#line 522
      goto while_break___1;
    }
    {
#line 524
    kseq_read(seq[1]);
#line 525
    tmp___4 = strcmp((char const   *)(seq[0])->name.s, (char const   *)(seq[1])->name.s);
    }
#line 525
    if (tmp___4) {
      {
#line 526
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%s] Different sequence names: %s != %s\n",
              "stk_mergefa", (seq[0])->name.s, (seq[1])->name.s);
      }
    }
#line 527
    if ((seq[0])->seq.l != (seq[1])->seq.l) {
      {
#line 528
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%s] Unequal sequence length: %ld != %ld\n",
              "stk_mergefa", (seq[0])->seq.l, (seq[1])->seq.l);
      }
    }
#line 529
    if ((seq[0])->seq.l < (seq[1])->seq.l) {
#line 529
      min_l = (int )(seq[0])->seq.l;
    } else {
#line 529
      min_l = (int )(seq[1])->seq.l;
    }
    {
#line 530
    printf((char const   */* __restrict  */)">%s", (seq[0])->name.s);
#line 531
    l = 0;
    }
    {
#line 531
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 531
      if (! (l < min_l)) {
#line 531
        goto while_break___2;
      }
#line 532
      c___0[0] = (int )*((seq[0])->seq.s + l);
#line 532
      c___0[1] = (int )*((seq[1])->seq.s + l);
#line 533
      if ((seq[0])->qual.l) {
#line 533
        if ((int )*((seq[0])->qual.s + l) - 33 < qual) {
          {
#line 533
          c___0[0] = tolower(c___0[0]);
          }
        }
      }
#line 534
      if ((seq[1])->qual.l) {
#line 534
        if ((int )*((seq[1])->qual.s + l) - 33 < qual) {
          {
#line 534
          c___0[1] = tolower(c___0[1]);
          }
        }
      }
#line 535
      if (is_intersect) {
        {
#line 535
        tmp___7 = __ctype_b_loc();
        }
#line 535
        if ((int const   )*(*tmp___7 + c___0[0]) & 256) {
#line 535
          is_upper = 1;
        } else {
          {
#line 535
          tmp___8 = __ctype_b_loc();
          }
#line 535
          if ((int const   )*(*tmp___8 + c___0[1]) & 256) {
#line 535
            is_upper = 1;
          } else {
#line 535
            is_upper = 0;
          }
        }
      } else
#line 536
      if (is_mask) {
        {
#line 536
        tmp___11 = __ctype_b_loc();
        }
#line 536
        if ((int const   )*(*tmp___11 + c___0[0]) & 256) {
#line 536
          is_upper = 1;
        } else {
          {
#line 536
          tmp___12 = __ctype_b_loc();
          }
#line 536
          if ((int const   )*(*tmp___12 + c___0[1]) & 256) {
#line 536
            is_upper = 1;
          } else {
#line 536
            is_upper = 0;
          }
        }
      } else {
        {
#line 537
        tmp___15 = __ctype_b_loc();
        }
#line 537
        if ((int const   )*(*tmp___15 + c___0[0]) & 256) {
          {
#line 537
          tmp___16 = __ctype_b_loc();
          }
#line 537
          if ((int const   )*(*tmp___16 + c___0[1]) & 256) {
#line 537
            is_upper = 1;
          } else {
#line 537
            is_upper = 0;
          }
        } else {
#line 537
          is_upper = 0;
        }
      }
#line 538
      c___0[0] = (int )seq_nt16_table[c___0[0]];
#line 538
      c___0[1] = (int )seq_nt16_table[c___0[1]];
#line 539
      if (c___0[0] == 0) {
#line 539
        c___0[0] = 15;
      }
#line 540
      if (c___0[1] == 0) {
#line 540
        c___0[1] = 15;
      }
#line 541
      b[0] = bitcnt_table[c___0[0]];
#line 542
      b[1] = bitcnt_table[c___0[1]];
#line 543
      if (is_upper) {
#line 544
        if (b[0] == 1) {
#line 544
          if (b[1] == 1) {
#line 545
            if (c___0[0] == c___0[1]) {
#line 545
              (cnt[0]) ++;
            } else {
#line 546
              (cnt[1]) ++;
            }
          } else {
#line 544
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 547
        if (b[0] == 1) {
#line 547
          if (b[1] == 2) {
#line 547
            (cnt[2]) ++;
          } else {
#line 547
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 548
        if (b[0] == 2) {
#line 548
          if (b[1] == 1) {
#line 548
            (cnt[3]) ++;
          } else {
#line 548
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 549
        if (b[0] == 2) {
#line 549
          if (b[1] == 2) {
#line 549
            (cnt[4]) ++;
          }
        }
      }
#line 551
      if (is_haploid) {
#line 551
        if (b[0] > 1) {
#line 551
          is_upper = 0;
        } else
#line 551
        if (b[1] > 1) {
#line 551
          is_upper = 0;
        }
      }
#line 552
      if (is_intersect) {
#line 553
        c___0[0] &= c___0[1];
#line 554
        if (c___0[0] == 0) {
#line 554
          is_upper = 0;
        }
      } else
#line 555
      if (is_mask) {
#line 556
        if (c___0[0] == 15) {
#line 556
          is_upper = 0;
        } else
#line 556
        if (c___0[1] == 15) {
#line 556
          is_upper = 0;
        }
#line 557
        c___0[0] &= c___0[1];
#line 558
        if (c___0[0] == 0) {
#line 558
          is_upper = 0;
        }
      } else
#line 559
      if (is_randhet) {
#line 560
        if (b[0] == 1) {
#line 560
          if (b[1] == 1) {
#line 561
            c___0[0] |= c___0[1];
          } else {
#line 560
            goto _L___6;
          }
        } else
        _L___6: /* CIL Label */ 
#line 562
        if (b[0] == 1) {
#line 562
          if (b[1] == 2) {
#line 562
            goto _L___3;
          } else {
#line 562
            goto _L___5;
          }
        } else
        _L___5: /* CIL Label */ 
#line 562
        if (b[0] == 2) {
#line 562
          if (b[1] == 1) {
            _L___3: /* CIL Label */ 
#line 562
            if (c___0[0] & c___0[1]) {
              {
#line 563
              tmp___18 = lrand48();
              }
#line 563
              if (tmp___18 & 1L) {
#line 563
                c___0[0] &= c___0[1];
              } else {
#line 563
                c___0[0] |= c___0[1];
              }
            } else {
#line 562
              goto _L___4;
            }
          } else {
#line 562
            goto _L___4;
          }
        } else
        _L___4: /* CIL Label */ 
#line 564
        if (b[0] == 2) {
#line 564
          if (b[1] == 2) {
#line 564
            if (c___0[0] == c___0[1]) {
              {
#line 565
              tmp___20 = lrand48();
              }
#line 565
              if (tmp___20 & 1L) {
                {
#line 566
                tmp___19 = lrand48();
                }
#line 566
                if (tmp___19 & 1L) {
#line 567
                  i = 8;
                  {
#line 567
                  while (1) {
                    while_continue___3: /* CIL Label */ ;
#line 567
                    if (! (i >= 1)) {
#line 567
                      goto while_break___3;
                    }
#line 568
                    if (c___0[0] & i) {
#line 568
                      c___0[0] &= i;
                    }
#line 567
                    i >>= 1;
                  }
                  while_break___3: /* CIL Label */ ;
                  }
                } else {
#line 570
                  i = 1;
                  {
#line 570
                  while (1) {
                    while_continue___4: /* CIL Label */ ;
#line 570
                    if (! (i <= 8)) {
#line 570
                      goto while_break___4;
                    }
#line 571
                    if (c___0[0] & i) {
#line 571
                      c___0[0] &= i;
                    }
#line 570
                    i <<= 1;
                  }
                  while_break___4: /* CIL Label */ ;
                  }
                }
              }
            } else {
#line 574
              is_upper = 0;
            }
          } else {
#line 574
            is_upper = 0;
          }
        } else {
#line 574
          is_upper = 0;
        }
      } else {
#line 575
        c___0[0] |= c___0[1];
      }
#line 576
      c___0[0] = (int )*(seq_nt16_rev_table + c___0[0]);
#line 577
      if (! is_upper) {
        {
#line 577
        c___0[0] = tolower(c___0[0]);
        }
      }
#line 578
      if (l % 60 == 0) {
        {
#line 578
        putchar('\n');
        }
      }
      {
#line 579
      putchar(c___0[0]);
#line 531
      l ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 581
    putchar('\n');
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 583
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%s] (same,diff,hom-het,het-hom,het-het)=(%ld,%ld,%ld,%ld,%ld)\n",
          "stk_mergefa", (long )cnt[0], (long )cnt[1], (long )cnt[2], (long )cnt[3],
          (long )cnt[4]);
  }
#line 584
  return (0);
}
}
#line 587 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
int stk_famask(int argc , char **argv ) 
{ 
  gzFile fp[2] ;
  kseq_t *seq[2] ;
  int i ;
  int l ;
  gzFile tmp___0 ;
  int tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  int min_l ;
  int c[2] ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 592
  if (argc < 3) {
    {
#line 593
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: seqtk famask <src.fa> <mask.fa>\n");
    }
#line 594
    return (1);
  }
#line 596
  i = 0;
  {
#line 596
  while (1) {
    while_continue: /* CIL Label */ ;
#line 596
    if (! (i < 2)) {
#line 596
      goto while_break;
    }
    {
#line 597
    tmp___3 = strcmp((char const   *)*(argv + (optind + i)), "-");
    }
#line 597
    if (tmp___3) {
      {
#line 597
      tmp___0 = gzopen((char const   *)*(argv + (optind + i)), "r");
#line 597
      fp[i] = tmp___0;
      }
    } else {
      {
#line 597
      tmp___1 = fileno(stdin);
#line 597
      tmp___2 = gzdopen(tmp___1, "r");
#line 597
      fp[i] = tmp___2;
      }
    }
    {
#line 598
    seq[i] = kseq_init(fp[i]);
#line 596
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 600
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 600
    tmp___5 = kseq_read(seq[0]);
    }
#line 600
    if (! (tmp___5 >= 0)) {
#line 600
      goto while_break___0;
    }
    {
#line 602
    kseq_read(seq[1]);
#line 603
    tmp___4 = strcmp((char const   *)(seq[0])->name.s, (char const   *)(seq[1])->name.s);
    }
#line 603
    if (tmp___4) {
      {
#line 604
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%s] Different sequence names: %s != %s\n",
              "stk_famask", (seq[0])->name.s, (seq[1])->name.s);
      }
    }
#line 605
    if ((seq[0])->seq.l != (seq[1])->seq.l) {
      {
#line 606
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%s] Unequal sequence length: %ld != %ld\n",
              "stk_famask", (seq[0])->seq.l, (seq[1])->seq.l);
      }
    }
#line 607
    if ((seq[0])->seq.l < (seq[1])->seq.l) {
#line 607
      min_l = (int )(seq[0])->seq.l;
    } else {
#line 607
      min_l = (int )(seq[1])->seq.l;
    }
    {
#line 608
    printf((char const   */* __restrict  */)">%s", (seq[0])->name.s);
#line 609
    l = 0;
    }
    {
#line 609
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 609
      if (! (l < min_l)) {
#line 609
        goto while_break___1;
      }
#line 610
      c[0] = (int )*((seq[0])->seq.s + l);
#line 610
      c[1] = (int )*((seq[1])->seq.s + l);
#line 611
      if (c[1] == 120) {
        {
#line 611
        c[0] = tolower(c[0]);
        }
      } else
#line 612
      if (c[1] != 88) {
#line 612
        c[0] = c[1];
      }
#line 613
      if (l % 60 == 0) {
        {
#line 613
        putchar('\n');
        }
      }
      {
#line 614
      putchar(c[0]);
#line 609
      l ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 616
    putchar('\n');
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 618
  return (0);
}
}
#line 621 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
int stk_mutfa(int argc , char **argv ) 
{ 
  kh_reg_t *h ;
  kh_reg_t *tmp ;
  gzFile fp ;
  kseq_t *seq ;
  kstream_t *ks ;
  int l ;
  int i ;
  int dret ;
  kstring_t *str ;
  khint_t k ;
  void *tmp___0 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  gzFile tmp___4 ;
  int tmp___5 ;
  char *s ;
  char *tmp___6 ;
  int beg ;
  int ret ;
  reglist_t *p ;
  long tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  unsigned short const   **tmp___11 ;
  int tmp___12 ;
  gzFile tmp___14 ;
  int tmp___15 ;
  gzFile tmp___16 ;
  int tmp___17 ;
  reglist_t *p___0 ;
  int beg___0 ;

  {
  {
#line 623
  tmp = kh_init_reg();
#line 623
  h = tmp;
  }
#line 630
  if (argc < 3) {
    {
#line 631
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: seqtk mutfa <in.fa> <in.snp>\n\n");
#line 632
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: <in.snp> contains at least four columns per line which are:\n");
#line 633
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      \'chr  1-based-pos  any  base-changed-to\'.\n");
    }
#line 634
    return (1);
  }
  {
#line 637
  tmp___0 = calloc((size_t )1, sizeof(kstring_t ));
#line 637
  str = (kstring_t *)tmp___0;
#line 638
  tmp___5 = strcmp((char const   *)*(argv + 2), "-");
  }
#line 638
  if (tmp___5) {
    {
#line 638
    tmp___2 = gzopen((char const   *)*(argv + 2), "r");
#line 638
    fp = tmp___2;
    }
  } else {
    {
#line 638
    tmp___3 = fileno(stdin);
#line 638
    tmp___4 = gzdopen(tmp___3, "r");
#line 638
    fp = tmp___4;
    }
  }
  {
#line 639
  ks = ks_init(fp);
  }
  {
#line 640
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 640
    tmp___12 = ks_getuntil(ks, 0, str, & dret);
    }
#line 640
    if (! (tmp___12 >= 0)) {
#line 640
      goto while_break;
    }
    {
#line 641
    tmp___6 = strdup((char const   *)str->s);
#line 641
    s = tmp___6;
#line 642
    beg = 0;
#line 644
    k = kh_get_reg((kh_reg_t const   *)h, (kh_cstr_t )s);
    }
#line 645
    if (k == h->n_buckets) {
      {
#line 646
      k = kh_put_reg(h, (kh_cstr_t )s, & ret);
#line 647
      memset((void *)(h->vals + k), 0, sizeof(reglist_t ));
      }
    }
    {
#line 649
    p = h->vals + k;
#line 650
    tmp___8 = ks_getuntil(ks, 0, str, & dret);
    }
#line 650
    if (tmp___8 > 0) {
      {
#line 650
      tmp___7 = atol((char const   *)str->s);
#line 650
      beg = (int )(tmp___7 - 1L);
      }
    }
    {
#line 651
    ks_getuntil(ks, 0, str, & dret);
#line 652
    ks_getuntil(ks, 0, str, & dret);
    }
#line 654
    if (dret != 10) {
      {
#line 654
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 654
        dret = ks_getc(ks);
        }
#line 654
        if (dret > 0) {
#line 654
          if (! (dret != 10)) {
#line 654
            goto while_break___0;
          }
        } else {
#line 654
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 655
    tmp___11 = __ctype_b_loc();
    }
#line 655
    if ((int const   )*(*tmp___11 + (int )*(str->s + 0)) & 1024) {
#line 655
      if (str->l == 1UL) {
#line 656
        if (p->n == p->m) {
#line 657
          if (p->m) {
#line 657
            p->m <<= 1;
          } else {
#line 657
            p->m = 4;
          }
          {
#line 658
          tmp___9 = realloc((void *)p->a, (size_t )(p->m * 8));
#line 658
          p->a = (uint64_t *)tmp___9;
          }
        }
#line 660
        tmp___10 = p->n;
#line 660
        (p->n) ++;
#line 660
        *(p->a + tmp___10) = ((uint64_t )beg << 32) | (unsigned long )*(str->s + 0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 663
  ks_destroy(ks);
#line 664
  gzclose(fp);
#line 665
  free((void *)str->s);
#line 665
  free((void *)str);
#line 667
  tmp___17 = strcmp((char const   *)*(argv + 1), "-");
  }
#line 667
  if (tmp___17) {
    {
#line 667
    tmp___14 = gzopen((char const   *)*(argv + 1), "r");
#line 667
    fp = tmp___14;
    }
  } else {
    {
#line 667
    tmp___15 = fileno(stdin);
#line 667
    tmp___16 = gzdopen(tmp___15, "r");
#line 667
    fp = tmp___16;
    }
  }
  {
#line 668
  seq = kseq_init(fp);
  }
  {
#line 669
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 669
    l = kseq_read(seq);
    }
#line 669
    if (! (l >= 0)) {
#line 669
      goto while_break___1;
    }
    {
#line 671
    k = kh_get_reg((kh_reg_t const   *)h, (kh_cstr_t )seq->name.s);
    }
#line 672
    if (k != h->n_buckets) {
#line 673
      p___0 = h->vals + k;
#line 674
      i = 0;
      {
#line 674
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 674
        if (! (i < p___0->n)) {
#line 674
          goto while_break___2;
        }
#line 675
        beg___0 = (int )(*(p___0->a + i) >> 32);
#line 676
        if ((size_t )beg___0 < seq->seq.l) {
#line 677
          *(seq->seq.s + beg___0) = (char )((int )*(p___0->a + i));
        }
#line 674
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    {
#line 680
    printf((char const   */* __restrict  */)">%s", seq->name.s);
#line 681
    i = 0;
    }
    {
#line 681
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 681
      if (! (i < l)) {
#line 681
        goto while_break___3;
      }
#line 682
      if (i % 60 == 0) {
        {
#line 682
        putchar('\n');
        }
      }
      {
#line 683
      putchar((int )*(seq->seq.s + i));
#line 681
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 685
    putchar('\n');
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 688
  kseq_destroy(seq);
#line 689
  gzclose(fp);
#line 690
  k = (khint_t )0;
  }
  {
#line 690
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 690
    if (! (k < h->n_buckets)) {
#line 690
      goto while_break___4;
    }
#line 691
    if (! ((*(h->flags + (k >> 4)) >> ((k & 15U) << 1)) & 3U)) {
      {
#line 692
      free((void *)(h->vals + k)->a);
#line 693
      free((void *)((char *)*(h->keys + k)));
      }
    }
#line 690
    k ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 696
  kh_destroy_reg(h);
  }
#line 697
  return (0);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
int stk_listhet(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *seq ;
  int i ;
  int l ;
  int tmp___0 ;
  gzFile tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  int b ;

  {
#line 705
  if (argc == 1) {
    {
#line 706
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: seqtk listhet <in.fa>\n");
    }
#line 707
    return (1);
  }
  {
#line 709
  tmp___3 = strcmp((char const   *)*(argv + 1), "-");
  }
#line 709
  if (tmp___3 == 0) {
    {
#line 709
    tmp___0 = fileno(stdin);
#line 709
    tmp___1 = gzdopen(tmp___0, "r");
#line 709
    fp = tmp___1;
    }
  } else {
    {
#line 709
    tmp___2 = gzopen((char const   *)*(argv + 1), "r");
#line 709
    fp = tmp___2;
    }
  }
  {
#line 710
  seq = kseq_init(fp);
  }
  {
#line 711
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 711
    l = kseq_read(seq);
    }
#line 711
    if (! (l >= 0)) {
#line 711
      goto while_break;
    }
#line 712
    i = 0;
    {
#line 712
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 712
      if (! (i < l)) {
#line 712
        goto while_break___0;
      }
#line 713
      b = (int )*(seq->seq.s + i);
#line 714
      if (bitcnt_table[seq_nt16_table[b]] == 2) {
        {
#line 715
        printf((char const   */* __restrict  */)"%s\t%d\t%c\n", seq->name.s, i + 1,
               b);
        }
      }
#line 712
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 718
  kseq_destroy(seq);
#line 719
  gzclose(fp);
  }
#line 720
  return (0);
}
}
#line 724 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
static int cutN_min_N_tract  =    1000;
#line 725 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
static int cutN_nonN_penalty  =    10;
#line 727 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
static int find_next_cut(kseq_t const   *ks , int k , int *begin , int *end ) 
{ 
  int i ;
  int b ;
  int e ;
  int score ;
  int max ;

  {
  {
#line 730
  while (1) {
    while_continue: /* CIL Label */ ;
#line 730
    if (! ((size_t const   )k < ks->seq.l)) {
#line 730
      goto while_break;
    }
#line 731
    if ((int )seq_nt16_table[(int )*(ks->seq.s + k)] == 15) {
#line 733
      score = 0;
#line 733
      max = -1;
#line 733
      e = max;
#line 734
      i = k;
      {
#line 734
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 734
        if ((size_t const   )i < ks->seq.l) {
#line 734
          if (! (score >= 0)) {
#line 734
            goto while_break___0;
          }
        } else {
#line 734
          goto while_break___0;
        }
#line 735
        if ((int )seq_nt16_table[(int )*(ks->seq.s + i)] == 15) {
#line 735
          score ++;
        } else {
#line 736
          score -= cutN_nonN_penalty;
        }
#line 737
        if (score > max) {
#line 737
          max = score;
#line 737
          e = i;
        }
#line 734
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 739
      score = 0;
#line 739
      max = -1;
#line 739
      b = max;
#line 740
      i = e;
      {
#line 740
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 740
        if (i >= 0) {
#line 740
          if (! (score >= 0)) {
#line 740
            goto while_break___1;
          }
        } else {
#line 740
          goto while_break___1;
        }
#line 741
        if ((int )seq_nt16_table[(int )*(ks->seq.s + i)] == 15) {
#line 741
          score ++;
        } else {
#line 742
          score -= cutN_nonN_penalty;
        }
#line 743
        if (score > max) {
#line 743
          max = score;
#line 743
          b = i;
        }
#line 740
        i --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 745
      if ((e + 1) - b >= cutN_min_N_tract) {
#line 746
        *begin = b;
#line 747
        *end = e + 1;
#line 748
        return (*end);
      }
#line 750
      k = e + 1;
    } else {
#line 751
      k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 753
  return (-1);
}
}
#line 755 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
static void print_seq(FILE *fpout , kseq_t const   *ks , int begin , int end ) 
{ 
  int i ;

  {
#line 758
  if (begin >= end) {
#line 758
    return;
  }
  {
#line 759
  fprintf((FILE */* __restrict  */)fpout, (char const   */* __restrict  */)">%s:%d-%d",
          ks->name.s, begin + 1, end);
#line 760
  i = begin;
  }
  {
#line 760
  while (1) {
    while_continue: /* CIL Label */ ;
#line 760
    if (i < end) {
#line 760
      if (! ((size_t const   )i < ks->seq.l)) {
#line 760
        goto while_break;
      }
    } else {
#line 760
      goto while_break;
    }
#line 761
    if ((i - begin) % 60 == 0) {
      {
#line 761
      fputc('\n', fpout);
      }
    }
    {
#line 762
    fputc((int )*(ks->seq.s + i), fpout);
#line 760
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 764
  fputc('\n', fpout);
  }
#line 765
  return;
}
}
#line 766 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
int stk_cutN(int argc , char **argv ) 
{ 
  int c ;
  int l ;
  int gap_only ;
  gzFile fp ;
  kseq_t *ks ;
  int tmp___0 ;
  gzFile tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  int k ;
  int begin ;
  int end ;
  int tmp___4 ;

  {
#line 768
  gap_only = 0;
  {
#line 771
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 771
    c = getopt(argc, (char * const  *)argv, "n:p:g");
    }
#line 771
    if (! (c >= 0)) {
#line 771
      goto while_break;
    }
    {
#line 773
    if (c == 110) {
#line 773
      goto case_110;
    }
#line 774
    if (c == 112) {
#line 774
      goto case_112;
    }
#line 775
    if (c == 103) {
#line 775
      goto case_103;
    }
#line 776
    goto switch_default;
    case_110: /* CIL Label */ 
    {
#line 773
    cutN_min_N_tract = atoi((char const   *)optarg);
    }
#line 773
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 774
    cutN_nonN_penalty = atoi((char const   *)optarg);
    }
#line 774
    goto switch_break;
    case_103: /* CIL Label */ 
#line 775
    gap_only = 1;
#line 775
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 776
    return (1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 779
  if (argc == optind) {
    {
#line 780
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 781
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage:   seqtk cutN [options] <in.fa>\n\n");
#line 782
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options: -n INT    min size of N tract [%d]\n",
            cutN_min_N_tract);
#line 783
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -p INT    penalty for a non-N [%d]\n",
            cutN_nonN_penalty);
#line 784
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -g        print gaps only, no sequence\n\n");
    }
#line 785
    return (1);
  }
  {
#line 787
  tmp___3 = strcmp((char const   *)*(argv + optind), "-");
  }
#line 787
  if (tmp___3 == 0) {
    {
#line 787
    tmp___0 = fileno(stdin);
#line 787
    tmp___1 = gzdopen(tmp___0, "r");
#line 787
    fp = tmp___1;
    }
  } else {
    {
#line 787
    tmp___2 = gzopen((char const   *)*(argv + optind), "r");
#line 787
    fp = tmp___2;
    }
  }
  {
#line 788
  ks = kseq_init(fp);
  }
  {
#line 789
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 789
    l = kseq_read(ks);
    }
#line 789
    if (! (l >= 0)) {
#line 789
      goto while_break___0;
    }
#line 790
    k = 0;
#line 790
    begin = 0;
#line 790
    end = 0;
    {
#line 791
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 791
      tmp___4 = find_next_cut((kseq_t const   *)ks, k, & begin, & end);
      }
#line 791
      if (! (tmp___4 >= 0)) {
#line 791
        goto while_break___1;
      }
#line 792
      if (begin != 0) {
#line 793
        if (gap_only) {
          {
#line 793
          printf((char const   */* __restrict  */)"%s\t%d\t%d\n", ks->name.s, begin,
                 end);
          }
        } else {
          {
#line 794
          print_seq(stdout, (kseq_t const   *)ks, k, begin);
          }
        }
      }
#line 796
      k = end;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 798
    if (! gap_only) {
      {
#line 798
      print_seq(stdout, (kseq_t const   *)ks, k, l);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 800
  kseq_destroy(ks);
#line 801
  gzclose(fp);
  }
#line 802
  return (0);
}
}
#line 805 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
int stk_hrun(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *ks ;
  int min_len ;
  int l ;
  int c ;
  int beg ;
  int i ;
  int tmp___0 ;
  gzFile tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 809
  min_len = 7;
#line 809
  l = 0;
#line 809
  c = 0;
#line 809
  beg = 0;
#line 810
  if (argc == optind) {
    {
#line 811
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: seqtk hrun <in.fa> [minLen=%d]\n",
            min_len);
    }
#line 812
    return (1);
  }
#line 814
  if (argc == optind + 2) {
    {
#line 814
    min_len = atoi((char const   *)*(argv + (optind + 1)));
    }
  }
  {
#line 815
  tmp___3 = strcmp((char const   *)*(argv + optind), "-");
  }
#line 815
  if (tmp___3 == 0) {
    {
#line 815
    tmp___0 = fileno(stdin);
#line 815
    tmp___1 = gzdopen(tmp___0, "r");
#line 815
    fp = tmp___1;
    }
  } else {
    {
#line 815
    tmp___2 = gzopen((char const   *)*(argv + optind), "r");
#line 815
    fp = tmp___2;
    }
  }
  {
#line 816
  ks = kseq_init(fp);
  }
  {
#line 817
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 817
    tmp___4 = kseq_read(ks);
    }
#line 817
    if (! (tmp___4 >= 0)) {
#line 817
      goto while_break;
    }
#line 818
    c = (int )*(ks->seq.s + 0);
#line 818
    l = 1;
#line 818
    beg = 0;
#line 819
    i = 1;
    {
#line 819
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 819
      if (! ((size_t )i < ks->seq.l)) {
#line 819
        goto while_break___0;
      }
#line 820
      if ((int )*(ks->seq.s + i) != c) {
#line 821
        if (l >= min_len) {
          {
#line 821
          printf((char const   */* __restrict  */)"%s\t%d\t%d\t%c\n", ks->name.s,
                 beg, beg + l, c);
          }
        }
#line 822
        c = (int )*(ks->seq.s + i);
#line 822
        l = 1;
#line 822
        beg = i;
      } else {
#line 823
        l ++;
      }
#line 819
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 826
  if (l >= min_len) {
    {
#line 826
    printf((char const   */* __restrict  */)"%s\t%d\t%d\t%c\n", ks->name.s, beg, beg + l,
           c);
    }
  }
  {
#line 827
  kseq_destroy(ks);
#line 828
  gzclose(fp);
  }
#line 829
  return (0);
}
}
#line 834 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
static void cpy_kstr(kstring_t *dst , kstring_t const   *src ) 
{ 
  void *tmp ;

  {
#line 836
  if (src->l == 0UL) {
#line 836
    return;
  }
#line 837
  if (src->l + 1UL > (size_t const   )dst->m) {
    {
#line 838
    dst->m = (size_t )(src->l + 1UL);
#line 839
    (dst->m) --;
#line 839
    dst->m |= dst->m >> 1;
#line 839
    dst->m |= dst->m >> 2;
#line 839
    dst->m |= dst->m >> 4;
#line 839
    dst->m |= dst->m >> 8;
#line 839
    dst->m |= dst->m >> 16;
#line 839
    (dst->m) ++;
#line 840
    tmp = realloc((void *)dst->s, dst->m);
#line 840
    dst->s = (char *)tmp;
    }
  }
  {
#line 842
  dst->l = (size_t )src->l;
#line 843
  memcpy((void */* __restrict  */)dst->s, (void const   */* __restrict  */)src->s,
         (size_t )(src->l + 1UL));
  }
#line 844
  return;
}
}
#line 846 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
static void cpy_kseq(kseq_t *dst , kseq_t const   *src ) 
{ 


  {
  {
#line 848
  cpy_kstr(& dst->name, & src->name);
#line 849
  cpy_kstr(& dst->seq, & src->seq);
#line 850
  cpy_kstr(& dst->qual, & src->qual);
  }
#line 851
  return;
}
}
#line 853 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
int stk_sample(int argc , char **argv ) 
{ 
  int c ;
  uint64_t i ;
  uint64_t num ;
  uint64_t n_seqs ;
  double frac ;
  gzFile fp ;
  kseq_t *seq ;
  kseq_t *buf ;
  int tmp ;
  void *tmp___0 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  gzFile tmp___4 ;
  int tmp___5 ;
  double r ;
  double tmp___6 ;
  uint64_t y ;
  uint64_t tmp___7 ;
  int tmp___8 ;
  kseq_t *p ;

  {
  {
#line 856
  num = (uint64_t )0;
#line 856
  n_seqs = (uint64_t )0;
#line 857
  frac = 0.;
#line 859
  buf = (kseq_t *)0;
#line 861
  srand48(11L);
  }
  {
#line 862
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 862
    c = getopt(argc, (char * const  *)argv, "s:");
    }
#line 862
    if (! (c >= 0)) {
#line 862
      goto while_break;
    }
    {
#line 864
    if (c == 115) {
#line 864
      goto case_115;
    }
#line 863
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 864
    tmp = atoi((char const   *)optarg);
#line 864
    srand48((long )tmp);
    }
#line 864
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 866
  if (optind + 2 > argc) {
    {
#line 867
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: seqtk sample [-s seed=11] <in.fa> <frac>|<number>\n\n");
#line 868
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Large memory consumption for large <number>.\n");
    }
#line 869
    return (1);
  }
  {
#line 871
  frac = atof((char const   *)*(argv + (optind + 1)));
  }
#line 872
  if (frac > 1.) {
#line 872
    num = (uint64_t )(frac + .499);
#line 872
    frac = 0.;
  }
#line 873
  if (num > 0UL) {
    {
#line 873
    tmp___0 = calloc(num, sizeof(kseq_t ));
#line 873
    buf = (kseq_t *)tmp___0;
    }
  }
  {
#line 875
  tmp___5 = strcmp((char const   *)*(argv + optind), "-");
  }
#line 875
  if (tmp___5) {
    {
#line 875
    tmp___2 = gzopen((char const   *)*(argv + optind), "r");
#line 875
    fp = tmp___2;
    }
  } else {
    {
#line 875
    tmp___3 = fileno(stdin);
#line 875
    tmp___4 = gzdopen(tmp___3, "r");
#line 875
    fp = tmp___4;
    }
  }
  {
#line 876
  seq = kseq_init(fp);
  }
  {
#line 877
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 877
    tmp___8 = kseq_read(seq);
    }
#line 877
    if (! (tmp___8 >= 0)) {
#line 877
      goto while_break___0;
    }
    {
#line 878
    tmp___6 = drand48();
#line 878
    r = tmp___6;
#line 879
    n_seqs ++;
    }
#line 880
    if (num) {
#line 881
      if (n_seqs - 1UL < num) {
#line 881
        tmp___7 = n_seqs - 1UL;
      } else {
#line 881
        tmp___7 = (uint64_t )(r * (double )n_seqs);
      }
#line 881
      y = tmp___7;
#line 882
      if (y < num) {
        {
#line 882
        cpy_kseq(buf + y, (kseq_t const   *)seq);
        }
      }
    } else
#line 883
    if (r < frac) {
      {
#line 883
      stk_printseq((kseq_t const   *)seq, -1);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 885
  kseq_destroy(seq);
#line 886
  gzclose(fp);
#line 887
  i = (uint64_t )0;
  }
  {
#line 887
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 887
    if (! (i < num)) {
#line 887
      goto while_break___1;
    }
#line 888
    p = buf + i;
#line 889
    if (p->seq.l) {
      {
#line 889
      stk_printseq((kseq_t const   *)p, -1);
      }
    }
    {
#line 890
    free((void *)p->seq.s);
#line 890
    free((void *)p->qual.s);
#line 890
    free((void *)p->name.s);
#line 887
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 892
  free((void *)buf);
  }
#line 893
  return (0);
}
}
#line 898 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
void stk_mask(kseq_t *seq , kh_reg_t const   *h , int is_complement , int mask_chr ) 
{ 
  unsigned int i ;
  unsigned int j ;
  khiter_t k ;
  int tmp ;
  reglist_t *p ;
  unsigned int beg ;
  unsigned int end ;
  int tmp___0 ;
  int8_t *mask ;
  void *tmp___1 ;
  unsigned int beg___0 ;
  unsigned int end___0 ;
  int tmp___2 ;

  {
  {
#line 902
  k = kh_get_reg(h, (kh_cstr_t )seq->name.s);
  }
#line 903
  if (k == (khiter_t )h->n_buckets) {
#line 904
    if (is_complement) {
#line 905
      if (mask_chr) {
#line 906
        j = 0U;
        {
#line 906
        while (1) {
          while_continue: /* CIL Label */ ;
#line 906
          if (! ((size_t )j < seq->seq.l)) {
#line 906
            goto while_break;
          }
#line 907
          *(seq->seq.s + j) = (char )mask_chr;
#line 906
          j ++;
        }
        while_break: /* CIL Label */ ;
        }
      } else {
#line 909
        j = 0U;
        {
#line 909
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 909
          if (! ((size_t )j < seq->seq.l)) {
#line 909
            goto while_break___0;
          }
          {
#line 910
          tmp = tolower((int )*(seq->seq.s + j));
#line 910
          *(seq->seq.s + j) = (char )tmp;
#line 909
          j ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
  } else {
#line 914
    p = h->vals + k;
#line 915
    if (! is_complement) {
#line 916
      i = 0U;
      {
#line 916
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 916
        if (! (i < (unsigned int )p->n)) {
#line 916
          goto while_break___1;
        }
#line 917
        beg = (unsigned int )(*(p->a + i) >> 32);
#line 917
        end = (unsigned int )*(p->a + i);
#line 918
        if ((size_t )beg >= seq->seq.l) {
#line 918
          goto __Cont;
        }
#line 919
        if ((size_t )end > seq->seq.l) {
#line 919
          end = (unsigned int )seq->seq.l;
        }
#line 920
        if (! mask_chr) {
#line 920
          j = beg;
          {
#line 920
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 920
            if (! (j < end)) {
#line 920
              goto while_break___2;
            }
            {
#line 920
            tmp___0 = tolower((int )*(seq->seq.s + j));
#line 920
            *(seq->seq.s + j) = (char )tmp___0;
#line 920
            j ++;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
        } else {
#line 921
          j = beg;
          {
#line 921
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 921
            if (! (j < end)) {
#line 921
              goto while_break___3;
            }
#line 921
            *(seq->seq.s + j) = (char )mask_chr;
#line 921
            j ++;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
        __Cont: /* CIL Label */ 
#line 916
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      {
#line 924
      tmp___1 = calloc(seq->seq.l, (size_t )1);
#line 924
      mask = (int8_t *)tmp___1;
#line 925
      i = 0U;
      }
      {
#line 925
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 925
        if (! (i < (unsigned int )p->n)) {
#line 925
          goto while_break___4;
        }
#line 926
        beg___0 = (unsigned int )(*(p->a + i) >> 32);
#line 926
        end___0 = (unsigned int )*(p->a + i);
#line 927
        if ((size_t )end___0 >= seq->seq.l) {
#line 927
          end___0 = (unsigned int )seq->seq.l;
        }
#line 928
        j = beg___0;
        {
#line 928
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 928
          if (! (j < end___0)) {
#line 928
            goto while_break___5;
          }
#line 928
          *(mask + j) = (int8_t )1;
#line 928
          j ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 925
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 930
      if (mask_chr) {
#line 931
        j = 0U;
        {
#line 931
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 931
          if (! ((size_t )j < seq->seq.l)) {
#line 931
            goto while_break___6;
          }
#line 932
          if ((int )*(mask + j) == 0) {
#line 932
            *(seq->seq.s + j) = (char )mask_chr;
          }
#line 931
          j ++;
        }
        while_break___6: /* CIL Label */ ;
        }
      } else {
#line 934
        j = 0U;
        {
#line 934
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 934
          if (! ((size_t )j < seq->seq.l)) {
#line 934
            goto while_break___7;
          }
#line 935
          if ((int )*(mask + j) == 0) {
            {
#line 935
            tmp___2 = tolower((int )*(seq->seq.s + j));
#line 935
            *(seq->seq.s + j) = (char )tmp___2;
            }
          }
#line 934
          j ++;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
      {
#line 937
      free((void *)mask);
      }
    }
  }
#line 940
  return;
}
}
#line 942 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
int stk_seq(int argc , char **argv ) 
{ 
  gzFile fp ;
  kseq_t *seq ;
  int c ;
  int qual_thres ;
  int flag ;
  int qual_shift ;
  int mask_chr ;
  int min_len ;
  unsigned int line_len ;
  double frac ;
  kh_reg_t *h ;
  int tmp ;
  int tmp___0 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  gzFile tmp___4 ;
  int tmp___5 ;
  double tmp___6 ;
  unsigned int i ;
  int tmp___7 ;
  int c0 ;
  int c1 ;
  unsigned int i___0 ;
  int tmp___8 ;

  {
  {
#line 946
  qual_thres = 0;
#line 946
  flag = 0;
#line 946
  qual_shift = 33;
#line 946
  mask_chr = 0;
#line 946
  min_len = 0;
#line 947
  line_len = 0U;
#line 948
  frac = 1.;
#line 949
  h = (kh_reg_t *)0;
#line 951
  srand48(11L);
  }
  {
#line 952
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 952
    c = getopt(argc, (char * const  *)argv, "q:l:Q:aACrn:s:f:M:L:c");
    }
#line 952
    if (! (c >= 0)) {
#line 952
      goto while_break;
    }
    {
#line 955
    if (c == 65) {
#line 955
      goto case_65;
    }
#line 955
    if (c == 97) {
#line 955
      goto case_65;
    }
#line 956
    if (c == 67) {
#line 956
      goto case_67;
    }
#line 957
    if (c == 114) {
#line 957
      goto case_114;
    }
#line 958
    if (c == 99) {
#line 958
      goto case_99;
    }
#line 959
    if (c == 77) {
#line 959
      goto case_77;
    }
#line 960
    if (c == 110) {
#line 960
      goto case_110;
    }
#line 961
    if (c == 81) {
#line 961
      goto case_81;
    }
#line 962
    if (c == 113) {
#line 962
      goto case_113;
    }
#line 963
    if (c == 108) {
#line 963
      goto case_108;
    }
#line 964
    if (c == 76) {
#line 964
      goto case_76;
    }
#line 965
    if (c == 115) {
#line 965
      goto case_115;
    }
#line 966
    if (c == 102) {
#line 966
      goto case_102;
    }
#line 953
    goto switch_break;
    case_65: /* CIL Label */ 
    case_97: /* CIL Label */ 
#line 955
    flag |= 1;
#line 955
    goto switch_break;
    case_67: /* CIL Label */ 
#line 956
    flag |= 2;
#line 956
    goto switch_break;
    case_114: /* CIL Label */ 
#line 957
    flag |= 4;
#line 957
    goto switch_break;
    case_99: /* CIL Label */ 
#line 958
    flag |= 8;
#line 958
    goto switch_break;
    case_77: /* CIL Label */ 
    {
#line 959
    h = stk_reg_read((char const   *)optarg);
    }
#line 959
    goto switch_break;
    case_110: /* CIL Label */ 
#line 960
    mask_chr = (int )*optarg;
#line 960
    goto switch_break;
    case_81: /* CIL Label */ 
    {
#line 961
    qual_shift = atoi((char const   *)optarg);
    }
#line 961
    goto switch_break;
    case_113: /* CIL Label */ 
    {
#line 962
    qual_thres = atoi((char const   *)optarg);
    }
#line 962
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 963
    tmp = atoi((char const   *)optarg);
#line 963
    line_len = (unsigned int )tmp;
    }
#line 963
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 964
    min_len = atoi((char const   *)optarg);
    }
#line 964
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 965
    tmp___0 = atoi((char const   *)optarg);
#line 965
    srand48((long )tmp___0);
    }
#line 965
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 966
    frac = atof((char const   *)optarg);
    }
#line 966
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 969
  if (argc == optind) {
    {
#line 970
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 971
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage:   seqtk seq [options] <in.fq>|<in.fa>\n\n");
#line 972
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options: -q INT    mask bases with quality lower than INT [0]\n");
#line 973
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -n CHAR   masked bases converted to CHAR; 0 for lowercase [0]\n");
#line 974
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -l INT    number of residues per line; 0 for 2^32-1 [%d]\n",
            line_len);
#line 975
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -Q INT    quality shift: ASCII-INT gives base quality [%d]\n",
            qual_shift);
#line 976
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -s INT    random seed (effective with -f) [11]\n");
#line 977
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -f FLOAT  sample FLOAT fraction of sequences [1]\n");
#line 978
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -M FILE   mask regions in BED or name list FILE [null]\n");
#line 979
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -L INT    drop sequences with length shorter than INT [0]\n");
#line 980
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -c        mask complement region (effective with -M)\n");
#line 981
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -r        reverse complement\n");
#line 982
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -A        force FASTA output (discard quality)\n");
#line 983
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -C        drop comments at the header lines\n");
#line 984
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
#line 985
    return (1);
  }
#line 987
  if (line_len == 0U) {
#line 987
    line_len = 4294967295U;
  }
  {
#line 988
  tmp___5 = strcmp((char const   *)*(argv + optind), "-");
  }
#line 988
  if (tmp___5) {
    {
#line 988
    tmp___2 = gzopen((char const   *)*(argv + optind), "r");
#line 988
    fp = tmp___2;
    }
  } else {
    {
#line 988
    tmp___3 = fileno(stdin);
#line 988
    tmp___4 = gzdopen(tmp___3, "r");
#line 988
    fp = tmp___4;
    }
  }
  {
#line 989
  seq = kseq_init(fp);
#line 990
  qual_thres += qual_shift;
  }
  {
#line 991
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 991
    tmp___8 = kseq_read(seq);
    }
#line 991
    if (! (tmp___8 >= 0)) {
#line 991
      goto while_break___0;
    }
#line 992
    if (seq->seq.l < (size_t )min_len) {
#line 992
      goto while_continue___0;
    }
#line 993
    if (frac < 1.) {
      {
#line 993
      tmp___6 = drand48();
      }
#line 993
      if (tmp___6 >= frac) {
#line 993
        goto while_continue___0;
      }
    }
#line 994
    if (seq->qual.l) {
#line 994
      if (qual_thres > qual_shift) {
#line 996
        if (mask_chr) {
#line 997
          i = 0U;
          {
#line 997
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 997
            if (! ((size_t )i < seq->seq.l)) {
#line 997
              goto while_break___1;
            }
#line 998
            if ((int )*(seq->qual.s + i) < qual_thres) {
#line 999
              *(seq->seq.s + i) = (char )mask_chr;
            }
#line 997
            i ++;
          }
          while_break___1: /* CIL Label */ ;
          }
        } else {
#line 1001
          i = 0U;
          {
#line 1001
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1001
            if (! ((size_t )i < seq->seq.l)) {
#line 1001
              goto while_break___2;
            }
#line 1002
            if ((int )*(seq->qual.s + i) < qual_thres) {
              {
#line 1003
              tmp___7 = tolower((int )*(seq->seq.s + i));
#line 1003
              *(seq->seq.s + i) = (char )tmp___7;
              }
            }
#line 1001
            i ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
      }
    }
#line 1006
    if (flag & 1) {
#line 1006
      seq->qual.l = (size_t )0;
    }
#line 1007
    if (flag & 2) {
#line 1007
      seq->comment.l = (size_t )0;
    }
#line 1008
    if (h) {
      {
#line 1008
      stk_mask(seq, (kh_reg_t const   *)h, flag & 8, mask_chr);
      }
    }
#line 1009
    if (flag & 4) {
#line 1012
      i___0 = 0U;
      {
#line 1012
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1012
        if (! ((size_t )i___0 < seq->seq.l >> 1)) {
#line 1012
          goto while_break___3;
        }
#line 1013
        c0 = (int )comp_tab[(int )*(seq->seq.s + i___0)];
#line 1014
        c1 = (int )comp_tab[(int )*(seq->seq.s + ((seq->seq.l - 1UL) - (size_t )i___0))];
#line 1015
        *(seq->seq.s + i___0) = (char )c1;
#line 1016
        *(seq->seq.s + ((seq->seq.l - 1UL) - (size_t )i___0)) = (char )c0;
#line 1012
        i___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1018
      if (seq->seq.l & 1UL) {
#line 1019
        *(seq->seq.s + (seq->seq.l >> 1)) = comp_tab[(int )*(seq->seq.s + (seq->seq.l >> 1))];
      }
#line 1020
      if (seq->qual.l) {
#line 1021
        i___0 = 0U;
        {
#line 1021
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1021
          if (! ((size_t )i___0 < seq->seq.l >> 1)) {
#line 1021
            goto while_break___4;
          }
#line 1022
          c0 = (int )*(seq->qual.s + i___0);
#line 1022
          *(seq->qual.s + i___0) = *(seq->qual.s + ((seq->qual.l - 1UL) - (size_t )i___0));
#line 1022
          *(seq->qual.s + ((seq->qual.l - 1UL) - (size_t )i___0)) = (char )c0;
#line 1021
          i___0 ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    }
    {
#line 1025
    stk_printseq((kseq_t const   *)seq, (int )line_len);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1027
  kseq_destroy(seq);
#line 1028
  gzclose(fp);
#line 1029
  stk_reg_destroy(h);
  }
#line 1030
  return (0);
}
}
#line 1034 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
static int usage(void) 
{ 


  {
  {
#line 1036
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 1037
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage:   seqtk <command> <arguments>\n");
#line 1038
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Version: 1.0-r31\n\n");
#line 1039
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Command: seq       common transformation of FASTA/Q\n");
#line 1040
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         comp      get the nucleotide composition of FASTA/Q\n");
#line 1041
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         sample    subsample sequences\n");
#line 1042
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         subseq    extract subsequences from FASTA/Q\n");
#line 1043
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         trimfq    trim FASTQ using the Phred algorithm\n\n");
#line 1044
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         hety      regional heterozygosity\n");
#line 1045
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         mutfa     point mutate FASTA at specified positions\n");
#line 1046
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         mergefa   merge two FASTA/Q files\n");
#line 1047
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         randbase  choose a random base from hets\n");
#line 1048
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         cutN      cut sequence at long N\n");
#line 1049
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         listhet   extract the position of each het\n");
#line 1050
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 1051
  return (1);
}
}
#line 1054 "/home/june/repo/benchmarks/collector/temp/seqtk-1.0/seqtk.c"
int main(int argc , char **argv ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 1056
  if (argc == 1) {
    {
#line 1056
    tmp = usage();
    }
#line 1056
    return (tmp);
  }
  {
#line 1057
  tmp___12 = strcmp((char const   *)*(argv + 1), "comp");
  }
#line 1057
  if (tmp___12 == 0) {
    {
#line 1057
    stk_comp(argc - 1, argv + 1);
    }
  } else {
    {
#line 1058
    tmp___11 = strcmp((char const   *)*(argv + 1), "hety");
    }
#line 1058
    if (tmp___11 == 0) {
      {
#line 1058
      stk_hety(argc - 1, argv + 1);
      }
    } else {
      {
#line 1059
      tmp___10 = strcmp((char const   *)*(argv + 1), "subseq");
      }
#line 1059
      if (tmp___10 == 0) {
        {
#line 1059
        stk_subseq(argc - 1, argv + 1);
        }
      } else {
        {
#line 1060
        tmp___9 = strcmp((char const   *)*(argv + 1), "mutfa");
        }
#line 1060
        if (tmp___9 == 0) {
          {
#line 1060
          stk_mutfa(argc - 1, argv + 1);
          }
        } else {
          {
#line 1061
          tmp___8 = strcmp((char const   *)*(argv + 1), "mergefa");
          }
#line 1061
          if (tmp___8 == 0) {
            {
#line 1061
            stk_mergefa(argc - 1, argv + 1);
            }
          } else {
            {
#line 1062
            tmp___7 = strcmp((char const   *)*(argv + 1), "randbase");
            }
#line 1062
            if (tmp___7 == 0) {
              {
#line 1062
              stk_randbase(argc - 1, argv + 1);
              }
            } else {
              {
#line 1063
              tmp___6 = strcmp((char const   *)*(argv + 1), "cutN");
              }
#line 1063
              if (tmp___6 == 0) {
                {
#line 1063
                stk_cutN(argc - 1, argv + 1);
                }
              } else {
                {
#line 1064
                tmp___5 = strcmp((char const   *)*(argv + 1), "listhet");
                }
#line 1064
                if (tmp___5 == 0) {
                  {
#line 1064
                  stk_listhet(argc - 1, argv + 1);
                  }
                } else {
                  {
#line 1065
                  tmp___4 = strcmp((char const   *)*(argv + 1), "famask");
                  }
#line 1065
                  if (tmp___4 == 0) {
                    {
#line 1065
                    stk_famask(argc - 1, argv + 1);
                    }
                  } else {
                    {
#line 1066
                    tmp___3 = strcmp((char const   *)*(argv + 1), "trimfq");
                    }
#line 1066
                    if (tmp___3 == 0) {
                      {
#line 1066
                      stk_trimfq(argc - 1, argv + 1);
                      }
                    } else {
                      {
#line 1067
                      tmp___2 = strcmp((char const   *)*(argv + 1), "hrun");
                      }
#line 1067
                      if (tmp___2 == 0) {
                        {
#line 1067
                        stk_hrun(argc - 1, argv + 1);
                        }
                      } else {
                        {
#line 1068
                        tmp___1 = strcmp((char const   *)*(argv + 1), "sample");
                        }
#line 1068
                        if (tmp___1 == 0) {
                          {
#line 1068
                          stk_sample(argc - 1, argv + 1);
                          }
                        } else {
                          {
#line 1069
                          tmp___0 = strcmp((char const   *)*(argv + 1), "seq");
                          }
#line 1069
                          if (tmp___0 == 0) {
                            {
#line 1069
                            stk_seq(argc - 1, argv + 1);
                            }
                          } else {
                            {
#line 1071
                            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[main] unrecognized commad \'%s\'. Abort!\n",
                                    *(argv + 1));
                            }
#line 1072
                            return (1);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 1074
  return (0);
}
}
