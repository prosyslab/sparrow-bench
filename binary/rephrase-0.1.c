/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 49 "/home/june/repo/benchmarks/collector/temp/rephrase-0.1/rephrase.c"
struct secrets {
   char pattern[513] ;
   int alternatives[256] ;
   int try[256] ;
   int i ;
   int a ;
   int b ;
   int alt_n ;
   short is_alt ;
   short is_literal ;
   short error ;
   ssize_t io_count ;
};
#line 271 "/home/june/repo/benchmarks/collector/temp/rephrase-0.1/rephrase.c"
union __anonunion_52 {
   int __in ;
   int __i ;
};
#line 275 "/home/june/repo/benchmarks/collector/temp/rephrase-0.1/rephrase.c"
union __anonunion_53 {
   int __in ;
   int __i ;
};
#line 103 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) mlock)(void const   *__addr ,
                                                                            size_t __len ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 66 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 573
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *__path ,
                                                                                              char const   *__arg 
                                                                                              , ...) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 681
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
#line 705
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setreuid)(__uid_t __ruid ,
                                                                               __uid_t __euid ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/rephrase-0.1/rephrase.c"
char const   LF  =    (char const   )'\n';
#line 58 "/home/june/repo/benchmarks/collector/temp/rephrase-0.1/rephrase.c"
void read_pattern(struct secrets *s ) 
{ 
  FILE *tty_fp ;
  struct termios term_save ;
  struct termios term ;
  int pattern_err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  int tmp___4 ;
  ssize_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 65
  tty_fp = fopen((char const   */* __restrict  */)"/dev/tty", (char const   */* __restrict  */)"r+");
  }
#line 65
  if (! tty_fp) {
    {
#line 66
    perror("fopen: ");
#line 67
    exit(8);
    }
  }
  {
#line 69
  tmp = fileno(tty_fp);
#line 69
  tmp___0 = tcgetattr(tmp, & term_save);
  }
#line 69
  if (tmp___0) {
    {
#line 70
    perror("tcgetattr: ");
#line 71
    exit(9);
    }
  }
  {
#line 73
  term = term_save;
#line 74
  term.c_lflag &= 4294967175U;
#line 75
  tmp___1 = fileno(tty_fp);
#line 75
  tmp___2 = tcsetattr(tmp___1, 2, (struct termios  const  *)(& term));
  }
#line 75
  if (tmp___2) {
    {
#line 76
    perror("(1st) tcsetattr: ");
#line 77
    exit(10);
    }
  }
  {
#line 80
  fprintf((FILE */* __restrict  */)tty_fp, (char const   */* __restrict  */)"Enter pattern: ");
#line 81
  fflush(tty_fp);
#line 82
  s->i = 0;
#line 82
  pattern_err = 0;
  }
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! (s->i <= 512)) {
#line 82
      goto while_break;
    }
    {
#line 83
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 83
      tmp___4 = fileno(tty_fp);
#line 83
      tmp___3 = read(tmp___4, (void *)(s->pattern + s->i), (size_t )1);
#line 83
      s->io_count = tmp___3;
      }
#line 83
      if (tmp___3) {
#line 83
        goto while_break___0;
      }
      {
#line 84
      sleep(1U);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 86
    if (s->io_count == -1L) {
      {
#line 87
      fprintf((FILE */* __restrict  */)tty_fp, (char const   */* __restrict  */)"\n");
#line 88
      perror("read: ");
#line 89
      pattern_err = 11;
      }
#line 90
      goto while_break;
    }
#line 92
    if ((int )s->pattern[s->i] == 10) {
      {
#line 93
      s->pattern[s->i] = (char )'\000';
#line 94
      fprintf((FILE */* __restrict  */)tty_fp, (char const   */* __restrict  */)"\n");
      }
#line 95
      goto while_break;
    }
#line 82
    (s->i) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  if (s->i > 512) {
    {
#line 99
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 100
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 100
        tmp___6 = fileno(tty_fp);
#line 100
        tmp___5 = read(tmp___6, (void *)(s->pattern), (size_t )1);
#line 100
        s->io_count = tmp___5;
        }
#line 100
        if (tmp___5) {
#line 100
          goto while_break___2;
        }
        {
#line 101
        sleep(1U);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 103
      if (s->io_count == -1L) {
        {
#line 104
        fprintf((FILE */* __restrict  */)tty_fp, (char const   */* __restrict  */)"\n");
#line 105
        perror("read: ");
#line 106
        pattern_err = 11;
        }
#line 107
        goto while_break___1;
      }
#line 99
      if (! ((int )s->pattern[0] != 10)) {
#line 99
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 110
    if (! pattern_err) {
      {
#line 111
      fprintf((FILE */* __restrict  */)tty_fp, (char const   */* __restrict  */)"\n");
#line 112
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Pattern is too long\n(maximum length is %d; you could redefine PATTERN_MAX and recompile)\n",
              512);
#line 114
      pattern_err = 12;
      }
    }
  }
  {
#line 118
  tmp___8 = fileno(tty_fp);
#line 118
  tmp___9 = tcsetattr(tmp___8, 2, (struct termios  const  *)(& term_save));
  }
#line 118
  if (tmp___9) {
    {
#line 119
    perror("(2nd) tcsetattr: ");
    }
#line 120
    if (pattern_err) {
#line 120
      tmp___7 = pattern_err;
    } else {
#line 120
      tmp___7 = 13;
    }
    {
#line 120
    exit(tmp___7);
    }
  }
#line 122
  if (pattern_err) {
    {
#line 123
    exit(pattern_err);
    }
  }
#line 125
  return;
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/rephrase-0.1/rephrase.c"
void parse_pattern(struct secrets *s ) 
{ 
  int tmp ;
  short tmp___0 ;
  short tmp___1 ;

  {
#line 130
  tmp___1 = (short)0;
#line 130
  s->error = tmp___1;
#line 130
  tmp___0 = tmp___1;
#line 130
  s->is_alt = tmp___0;
#line 130
  tmp = (int )tmp___0;
#line 130
  s->a = tmp;
#line 130
  s->i = tmp;
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 130
    if (s->pattern[s->i]) {
#line 130
      if (! (! s->error)) {
#line 130
        goto while_break;
      }
    } else {
#line 130
      goto while_break;
    }
    {
#line 133
    if ((int )s->pattern[s->i] == 92) {
#line 133
      goto case_92;
    }
#line 138
    if ((int )s->pattern[s->i] == 40) {
#line 138
      goto case_40;
    }
#line 145
    if ((int )s->pattern[s->i] == 124) {
#line 145
      goto case_124;
    }
#line 151
    if ((int )s->pattern[s->i] == 41) {
#line 151
      goto case_41;
    }
#line 132
    goto switch_break;
    case_92: /* CIL Label */ 
#line 133
    (s->i) ++;
#line 134
    if (! s->pattern[s->i]) {
#line 135
      s->error = (short)1;
    }
#line 137
    goto switch_break;
    case_40: /* CIL Label */ 
#line 138
    if (s->is_alt) {
#line 139
      s->error = (short)1;
    } else {
#line 141
      s->is_alt = (short)1;
#line 142
      s->alternatives[s->a] = 0;
    }
#line 144
    goto switch_break;
    case_124: /* CIL Label */ 
#line 145
    if (! s->is_alt) {
#line 146
      s->error = (short)1;
    } else {
#line 148
      (s->alternatives[s->a]) ++;
    }
#line 150
    goto switch_break;
    case_41: /* CIL Label */ 
#line 151
    if (! s->is_alt) {
#line 152
      s->error = (short)1;
    } else {
#line 154
      s->is_alt = (short)0;
#line 155
      (s->a) ++;
    }
#line 157
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 130
    (s->i) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if (s->error) {
    {
#line 161
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Pattern is malformed\n");
#line 162
    exit(14);
    }
  } else
#line 160
  if (s->is_alt) {
    {
#line 161
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Pattern is malformed\n");
#line 162
    exit(14);
    }
  }
#line 165
  s->b = 0;
  {
#line 165
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 165
    if (! (s->b < s->a)) {
#line 165
      goto while_break___0;
    }
#line 166
    s->try[s->b] = 0;
#line 165
    (s->b) ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 168
  return;
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/rephrase-0.1/rephrase.c"
void spawn_gpg(char const   *key , int dev_null , int *pass_writer , pid_t *kid ) 
{ 
  int pass_fds[2] ;
  char s_pass_reader[21] ;
  int tmp ;
  pid_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 176
  tmp = pipe((int *)(pass_fds));
  }
#line 176
  if (tmp) {
    {
#line 177
    perror("pipe: ");
#line 178
    exit(16);
    }
  }
  {
#line 180
  *pass_writer = pass_fds[1];
#line 181
  snprintf((char */* __restrict  */)(s_pass_reader), sizeof(s_pass_reader), (char const   */* __restrict  */)"%d",
           pass_fds[0]);
#line 183
  tmp___0 = fork();
#line 183
  *kid = tmp___0;
  }
#line 183
  if (tmp___0 == -1) {
    {
#line 184
    perror("fork: ");
#line 185
    exit(17);
    }
  }
#line 188
  if (! *kid) {
    {
#line 189
    tmp___1 = close(pass_fds[1]);
    }
#line 189
    if (tmp___1) {
      {
#line 190
      perror("(kid) close: ");
#line 191
      exit(18);
      }
    }
    {
#line 193
    tmp___2 = dup2(dev_null, 0);
    }
#line 193
    if (tmp___2 == -1) {
      {
#line 195
      perror("(kid) dup2: ");
#line 196
      exit(19);
      }
    } else {
      {
#line 193
      tmp___3 = dup2(dev_null, 1);
      }
#line 193
      if (tmp___3 == -1) {
        {
#line 195
        perror("(kid) dup2: ");
#line 196
        exit(19);
        }
      } else {
        {
#line 193
        tmp___4 = dup2(dev_null, 2);
        }
#line 193
        if (tmp___4 == -1) {
          {
#line 195
          perror("(kid) dup2: ");
#line 196
          exit(19);
          }
        }
      }
    }
    {
#line 198
    execl("/usr/local/bin/gpg", "gpg", "--default-key", key, "--passphrase-fd", s_pass_reader,
          "--batch", "--dry-run", "--clearsign", "/dev/null", (void *)0);
#line 200
    perror("(kid) execlp: ");
#line 201
    exit(20);
    }
  }
  {
#line 204
  tmp___5 = close(pass_fds[0]);
  }
#line 204
  if (tmp___5) {
    {
#line 205
    perror("(parent) close: ");
#line 206
    exit(21);
    }
  }
#line 208
  return;
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/rephrase-0.1/rephrase.c"
void write_passphrase(struct secrets *s , int pass_writer ) 
{ 
  int tmp ;
  ssize_t tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;

  {
#line 213
  tmp = 0;
#line 213
  s->b = tmp;
#line 213
  s->i = tmp;
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
#line 213
    if (! s->pattern[s->i]) {
#line 213
      goto while_break;
    }
    {
#line 215
    if ((int )s->pattern[s->i] == 92) {
#line 215
      goto case_92;
    }
#line 218
    if ((int )s->pattern[s->i] == 40) {
#line 218
      goto case_40;
    }
#line 222
    if ((int )s->pattern[s->i] == 124) {
#line 222
      goto case_124;
    }
#line 225
    if ((int )s->pattern[s->i] == 41) {
#line 225
      goto case_41;
    }
#line 229
    goto switch_default;
    case_92: /* CIL Label */ 
#line 215
    (s->i) ++;
#line 216
    s->is_literal = (short)1;
#line 217
    goto switch_break;
    case_40: /* CIL Label */ 
#line 218
    s->is_alt = (short)1;
#line 219
    s->alt_n = 0;
#line 220
    s->is_literal = (short)0;
#line 221
    goto switch_break;
    case_124: /* CIL Label */ 
#line 222
    (s->alt_n) ++;
#line 223
    s->is_literal = (short)0;
#line 224
    goto switch_break;
    case_41: /* CIL Label */ 
#line 225
    s->is_alt = (short)0;
#line 226
    (s->b) ++;
#line 227
    s->is_literal = (short)0;
#line 228
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 229
    s->is_literal = (short)1;
#line 230
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 232
    if (s->is_literal) {
#line 232
      if (! s->is_alt) {
#line 232
        goto _L;
      } else
#line 232
      if (s->alt_n == s->try[s->b]) {
        _L: /* CIL Label */ 
        {
#line 233
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 233
          tmp___0 = write(pass_writer, (void const   *)(s->pattern + s->i), (size_t )1);
#line 233
          s->io_count = tmp___0;
          }
#line 233
          if (tmp___0) {
#line 233
            goto while_break___0;
          }
          {
#line 234
          sleep(1U);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 236
        if (s->io_count == -1L) {
          {
#line 237
          perror("write: ");
#line 238
          exit(22);
          }
        }
      }
    }
#line 213
    (s->i) ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 242
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 242
    tmp___1 = write(pass_writer, (void const   *)(& LF), (size_t )1);
#line 242
    s->io_count = tmp___1;
    }
#line 242
    if (tmp___1) {
#line 242
      goto while_break___1;
    }
    {
#line 243
    sleep(1U);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 245
  if (s->io_count == -1L) {
    {
#line 246
    perror("(last) write: ");
#line 247
    exit(23);
    }
  }
  {
#line 250
  tmp___2 = close(pass_writer);
  }
#line 250
  if (tmp___2) {
    {
#line 251
    perror("(final) close: ");
#line 252
    exit(24);
    }
  }
#line 254
  return;
}
}
#line 256 "/home/june/repo/benchmarks/collector/temp/rephrase-0.1/rephrase.c"
int passphrase_is_correct(char const   *key , struct secrets *s , int dev_null ) 
{ 
  int pass_writer ;
  pid_t kid ;
  int status ;
  __pid_t tmp ;
  union __anonunion_52 __constr_expr_0 ;
  union __anonunion_53 __constr_expr_1 ;

  {
  {
#line 263
  spawn_gpg(key, dev_null, & pass_writer, & kid);
#line 265
  write_passphrase(s, pass_writer);
#line 267
  tmp = waitpid(kid, & status, 0);
  }
#line 267
  if (tmp == -1) {
    {
#line 268
    perror("waitpid: ");
#line 269
    exit(25);
    }
  }
#line 271
  __constr_expr_0.__in = status;
#line 271
  if (! ((__constr_expr_0.__i & 127) == 0)) {
    {
#line 272
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gpg didn\'t exit normally");
#line 273
    exit(26);
    }
  }
#line 275
  __constr_expr_1.__in = status;
#line 275
  return ((__constr_expr_1.__i & 65280) >> 8 == 0);
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/rephrase-0.1/rephrase.c"
int find_passphrase(char const   *key , struct secrets *s ) 
{ 
  int dev_null ;
  char const   *tmp ;
  int tmp___0 ;

  {
  {
#line 283
  dev_null = open("/dev/null", 2);
  }
#line 283
  if (dev_null == -1) {
    {
#line 284
    perror("open: ");
#line 285
    exit(15);
    }
  }
  {
#line 288
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 289
    tmp___0 = passphrase_is_correct(key, s, dev_null);
    }
#line 289
    if (tmp___0) {
      {
#line 290
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Passphrase found\n");
#line 291
      s->b = 0;
      }
      {
#line 291
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 291
        if (! (s->b < s->a)) {
#line 291
          goto while_break___0;
        }
#line 292
        if (s->b) {
#line 292
          tmp = " %d";
        } else {
#line 292
          tmp = "%d";
        }
        {
#line 292
        printf((char const   */* __restrict  */)tmp, s->try[s->b] + 1);
#line 291
        (s->b) ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 294
      printf((char const   */* __restrict  */)"\n");
      }
#line 295
      return (0);
    }
#line 298
    s->error = (short)1;
#line 299
    s->b = s->a - 1;
    {
#line 299
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 299
      if (! (s->b >= 0)) {
#line 299
        goto while_break___1;
      }
#line 300
      if (s->try[s->b] < s->alternatives[s->b]) {
#line 301
        (s->try[s->b]) ++;
#line 302
        s->i = s->b + 1;
        {
#line 302
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 302
          if (! (s->i < s->a)) {
#line 302
            goto while_break___2;
          }
#line 303
          s->try[s->i] = 0;
#line 302
          (s->i) ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 305
        s->error = (short)0;
#line 306
        goto while_break___1;
      }
#line 299
      (s->b) --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 288
    if (! (! s->error)) {
#line 288
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 311
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Passphrase doesn\'t match pattern (or no such key)\n");
  }
#line 312
  return (1);
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/rephrase-0.1/rephrase.c"
int main(int argc , char **argv ) 
{ 
  struct secrets sec ;
  struct stat stat_buf ;
  int tmp ;
  __uid_t tmp___0 ;
  __uid_t tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___7 ;
  __gid_t tmp___8 ;
  int tmp___9 ;
  __uid_t tmp___10 ;
  int tmp___11 ;

  {
  {
#line 321
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s (Rephrase) %s\nCopyright (C) 2003  Phil Lanch\nThis program comes with ABSOLUTELY NO WARRANTY.\nThis is free software, and you are welcome to redistribute it\nunder certain conditions.  See the file COPYING for details.\n\n",
          "rephrase", "0.1");
#line 327
  tmp = mlock((void const   *)(& sec), sizeof(struct secrets ));
  }
#line 327
  if (tmp) {
    {
#line 328
    perror("mlock: ");
#line 329
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(%s should be installed setuid root)\n",
            "rephrase");
#line 330
    exit(2);
    }
  }
  {
#line 332
  tmp___0 = getuid();
#line 332
  tmp___1 = getuid();
#line 332
  tmp___2 = setreuid(tmp___1, tmp___0);
  }
#line 332
  if (tmp___2) {
    {
#line 333
    perror("setreuid: ");
#line 334
    exit(3);
    }
  }
  {
#line 337
  tmp___4 = stat((char const   */* __restrict  */)"/usr/local/bin/gpg", (struct stat */* __restrict  */)(& stat_buf));
  }
#line 337
  if (tmp___4) {
    {
#line 338
    tmp___3 = __errno_location();
    }
#line 338
    if (*tmp___3 & 22) {
      {
#line 339
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s does not exist (or is in a directory I cannot read)\n(perhaps you need to redefine GPG and recompile)\n",
              "/usr/local/bin/gpg");
#line 341
      exit(4);
      }
    }
    {
#line 343
    perror("stat: ");
#line 344
    exit(5);
    }
  }
#line 346
  if (! ((stat_buf.st_mode & 61440U) == 32768U)) {
    {
#line 349
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s is not an executable (by me) file\n",
            "/usr/local/bin/gpg");
#line 350
    exit(6);
    }
  } else {
    {
#line 346
    tmp___10 = getuid();
    }
#line 346
    if (stat_buf.st_uid == tmp___10) {
#line 346
      tmp___9 = 64;
    } else {
      {
#line 346
      tmp___8 = getgid();
      }
#line 346
      if (stat_buf.st_gid == tmp___8) {
#line 346
        tmp___7 = 64 >> 3;
      } else {
#line 346
        tmp___7 = (64 >> 3) >> 3;
      }
#line 346
      tmp___9 = tmp___7;
    }
#line 346
    if (! (stat_buf.st_mode & (unsigned int )tmp___9)) {
      {
#line 349
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s is not an executable (by me) file\n",
              "/usr/local/bin/gpg");
#line 350
      exit(6);
      }
    }
  }
#line 353
  if (argc != 2) {
    {
#line 354
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s <key>\n",
            "rephrase");
#line 355
    exit(7);
    }
  }
  {
#line 358
  read_pattern(& sec);
#line 360
  parse_pattern(& sec);
#line 362
  tmp___11 = find_passphrase((char const   *)*(argv + 1), & sec);
  }
#line 362
  return (tmp___11);
}
}
