/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 122 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 60 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/xcrypt.h"
struct __anonstruct_gl_des_ctx_25 {
   uint32_t encrypt_subkeys[32] ;
   uint32_t decrypt_subkeys[32] ;
};
#line 60 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/xcrypt.h"
typedef struct __anonstruct_gl_des_ctx_25 gl_des_ctx;
#line 66 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/xcrypt.h"
struct md4_ctx {
   uint32_t A ;
   uint32_t B ;
   uint32_t C ;
   uint32_t D ;
   uint32_t total[2] ;
   uint32_t buflen ;
   uint32_t buffer[32] ;
};
#line 77 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/xcrypt.h"
struct md5_ctx {
   uint32_t A ;
   uint32_t B ;
   uint32_t C ;
   uint32_t D ;
   uint32_t total[2] ;
   uint32_t buflen ;
   uint32_t buffer[32] ;
};
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 69 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_4 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_4 pthread_mutex_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 59 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.h"
struct hlist_s;
#line 59 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.h"
typedef struct hlist_s *hlist_t;
#line 60 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.h"
struct hlist_s {
   char *key ;
   char *value ;
   int islist ;
   struct hlist_s *next ;
};
#line 67
struct plist_s;
#line 67 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.h"
typedef struct plist_s *plist_t;
#line 68 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.h"
struct plist_s {
   unsigned long key ;
   void *aux ;
   struct plist_s *next ;
};
#line 74
enum __anonenum_hlist_add_t_73 {
    HLIST_NOALLOC = 0,
    HLIST_ALLOC = 1
} ;
#line 74 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.h"
typedef enum __anonenum_hlist_add_t_73 hlist_add_t;
#line 83
struct rr_data_s;
#line 83 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.h"
typedef struct rr_data_s *rr_data_t;
#line 84 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.h"
struct rr_data_s {
   int req ;
   hlist_t headers ;
   int code ;
   int skip_http ;
   int body_len ;
   int empty ;
   int port ;
   int http_version ;
   char *method ;
   char *url ;
   char *rel_url ;
   char *hostname ;
   char *http ;
   char *msg ;
   char *body ;
   char *errmsg ;
};
#line 106 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.h"
struct thread_arg_s {
   int fd ;
   char *target ;
   struct sockaddr_in addr ;
};
#line 34 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/auth.h"
struct auth_s {
   char user[50] ;
   char domain[50] ;
   char workstation[50] ;
   char passlm[50] ;
   char passnt[50] ;
   char passntlm2[50] ;
   int hashntlm2 ;
   int hashnt ;
   int hashlm ;
   uint32_t flags ;
};
#line 32 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/config.h"
struct config_s;
#line 32 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/config.h"
typedef struct config_s *config_t;
#line 33 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/config.h"
struct config_s {
   hlist_t options ;
};
#line 32 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/acl.h"
enum acl_t {
    ACL_ALLOW = 0,
    ACL_DENY = 1
} ;
#line 54 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/globals.h"
struct __anonstruct_proxy_t_76 {
   char hostname[64] ;
   struct auth_s creds ;
   struct in_addr host ;
   int port ;
   int resolved ;
};
#line 54 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/globals.h"
typedef struct __anonstruct_proxy_t_76 proxy_t;
#line 37 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/http.h"
typedef long long length_t;
#line 197 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long int64_t;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 37 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/acl.h"
struct __anonstruct_network_t_42 {
   unsigned int ip ;
   int mask ;
};
#line 37 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/acl.h"
typedef struct __anonstruct_network_t_42 network_t;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 709 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 88 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/xcrypt.h"
_Bool gl_des_is_weak_key(char const   *key ) ;
#line 89
void gl_des_setkey(gl_des_ctx *ctx , char const   *key ) ;
#line 90
_Bool gl_des_makekey(gl_des_ctx *ctx , char const   *key , size_t keylen ) ;
#line 91
void gl_des_ecb_crypt(gl_des_ctx *ctx , char const   *_from , char *_to , int mode ) ;
#line 93
void md4_process_block(void const   *buffer , size_t len , struct md4_ctx *ctx ) ;
#line 94
void md4_init_ctx(struct md4_ctx *ctx ) ;
#line 95
void *md4_read_ctx(struct md4_ctx  const  *ctx , void *resbuf ) ;
#line 96
void *md4_finish_ctx(struct md4_ctx *ctx , void *resbuf ) ;
#line 97
void md4_process_bytes(void const   *buffer , size_t len , struct md4_ctx *ctx ) ;
#line 98
int md4_stream(FILE *stream , void *resblock ) ;
#line 99
void *md4_buffer(char const   *buffer , size_t len , void *resblock ) ;
#line 101
int hmac_md5(void const   *key , size_t keylen , void const   *in , size_t inlen ,
             void *resbuf ) ;
#line 103
void md5_init_ctx(struct md5_ctx *ctx ) ;
#line 104
void md5_process_block(void const   *buffer , size_t len , struct md5_ctx *ctx ) ;
#line 105
void md5_process_bytes(void const   *buffer , size_t len , struct md5_ctx *ctx ) ;
#line 106
void *md5_finish_ctx(struct md5_ctx *ctx , void *resbuf ) ;
#line 107
void *md5_read_ctx(struct md5_ctx  const  *ctx , void *resbuf ) ;
#line 108
int md5_stream(FILE *stream , void *resblock ) ;
#line 109
void *md5_buffer(char const   *buffer , size_t len , void *resblock ) ;
#line 85 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/xcrypt.c"
static unsigned char const   fillbuf[64]  = {      (unsigned char const   )128,      (unsigned char const   )0};
#line 91 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/xcrypt.c"
static uint32_t const   sbox1[64]  = 
#line 91
  {      (uint32_t const   )16843776,      (uint32_t const   )0,      (uint32_t const   )65536,      (uint32_t const   )16843780, 
        (uint32_t const   )16842756,      (uint32_t const   )66564,      (uint32_t const   )4,      (uint32_t const   )65536, 
        (uint32_t const   )1024,      (uint32_t const   )16843776,      (uint32_t const   )16843780,      (uint32_t const   )1024, 
        (uint32_t const   )16778244,      (uint32_t const   )16842756,      (uint32_t const   )16777216,      (uint32_t const   )4, 
        (uint32_t const   )1028,      (uint32_t const   )16778240,      (uint32_t const   )16778240,      (uint32_t const   )66560, 
        (uint32_t const   )66560,      (uint32_t const   )16842752,      (uint32_t const   )16842752,      (uint32_t const   )16778244, 
        (uint32_t const   )65540,      (uint32_t const   )16777220,      (uint32_t const   )16777220,      (uint32_t const   )65540, 
        (uint32_t const   )0,      (uint32_t const   )1028,      (uint32_t const   )66564,      (uint32_t const   )16777216, 
        (uint32_t const   )65536,      (uint32_t const   )16843780,      (uint32_t const   )4,      (uint32_t const   )16842752, 
        (uint32_t const   )16843776,      (uint32_t const   )16777216,      (uint32_t const   )16777216,      (uint32_t const   )1024, 
        (uint32_t const   )16842756,      (uint32_t const   )65536,      (uint32_t const   )66560,      (uint32_t const   )16777220, 
        (uint32_t const   )1024,      (uint32_t const   )4,      (uint32_t const   )16778244,      (uint32_t const   )66564, 
        (uint32_t const   )16843780,      (uint32_t const   )65540,      (uint32_t const   )16842752,      (uint32_t const   )16778244, 
        (uint32_t const   )16777220,      (uint32_t const   )1028,      (uint32_t const   )66564,      (uint32_t const   )16843776, 
        (uint32_t const   )1028,      (uint32_t const   )16778240,      (uint32_t const   )16778240,      (uint32_t const   )0, 
        (uint32_t const   )65540,      (uint32_t const   )66560,      (uint32_t const   )0,      (uint32_t const   )16842756};
#line 105 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/xcrypt.c"
static uint32_t const   sbox2[64]  = 
#line 105
  {      (uint32_t const   )2148565024U,      (uint32_t const   )2147516416U,      (uint32_t const   )32768,      (uint32_t const   )1081376, 
        (uint32_t const   )1048576,      (uint32_t const   )32,      (uint32_t const   )2148532256U,      (uint32_t const   )2147516448U, 
        (uint32_t const   )2147483680U,      (uint32_t const   )2148565024U,      (uint32_t const   )2148564992U,      (uint32_t const   )2147483648U, 
        (uint32_t const   )2147516416U,      (uint32_t const   )1048576,      (uint32_t const   )32,      (uint32_t const   )2148532256U, 
        (uint32_t const   )1081344,      (uint32_t const   )1048608,      (uint32_t const   )2147516448U,      (uint32_t const   )0, 
        (uint32_t const   )2147483648U,      (uint32_t const   )32768,      (uint32_t const   )1081376,      (uint32_t const   )2148532224U, 
        (uint32_t const   )1048608,      (uint32_t const   )2147483680U,      (uint32_t const   )0,      (uint32_t const   )1081344, 
        (uint32_t const   )32800,      (uint32_t const   )2148564992U,      (uint32_t const   )2148532224U,      (uint32_t const   )32800, 
        (uint32_t const   )0,      (uint32_t const   )1081376,      (uint32_t const   )2148532256U,      (uint32_t const   )1048576, 
        (uint32_t const   )2147516448U,      (uint32_t const   )2148532224U,      (uint32_t const   )2148564992U,      (uint32_t const   )32768, 
        (uint32_t const   )2148532224U,      (uint32_t const   )2147516416U,      (uint32_t const   )32,      (uint32_t const   )2148565024U, 
        (uint32_t const   )1081376,      (uint32_t const   )32,      (uint32_t const   )32768,      (uint32_t const   )2147483648U, 
        (uint32_t const   )32800,      (uint32_t const   )2148564992U,      (uint32_t const   )1048576,      (uint32_t const   )2147483680U, 
        (uint32_t const   )1048608,      (uint32_t const   )2147516448U,      (uint32_t const   )2147483680U,      (uint32_t const   )1048608, 
        (uint32_t const   )1081344,      (uint32_t const   )0,      (uint32_t const   )2147516416U,      (uint32_t const   )32800, 
        (uint32_t const   )2147483648U,      (uint32_t const   )2148532256U,      (uint32_t const   )2148565024U,      (uint32_t const   )1081344};
#line 119 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/xcrypt.c"
static uint32_t const   sbox3[64]  = 
#line 119
  {      (uint32_t const   )520,      (uint32_t const   )134349312,      (uint32_t const   )0,      (uint32_t const   )134348808, 
        (uint32_t const   )134218240,      (uint32_t const   )0,      (uint32_t const   )131592,      (uint32_t const   )134218240, 
        (uint32_t const   )131080,      (uint32_t const   )134217736,      (uint32_t const   )134217736,      (uint32_t const   )131072, 
        (uint32_t const   )134349320,      (uint32_t const   )131080,      (uint32_t const   )134348800,      (uint32_t const   )520, 
        (uint32_t const   )134217728,      (uint32_t const   )8,      (uint32_t const   )134349312,      (uint32_t const   )512, 
        (uint32_t const   )131584,      (uint32_t const   )134348800,      (uint32_t const   )134348808,      (uint32_t const   )131592, 
        (uint32_t const   )134218248,      (uint32_t const   )131584,      (uint32_t const   )131072,      (uint32_t const   )134218248, 
        (uint32_t const   )8,      (uint32_t const   )134349320,      (uint32_t const   )512,      (uint32_t const   )134217728, 
        (uint32_t const   )134349312,      (uint32_t const   )134217728,      (uint32_t const   )131080,      (uint32_t const   )520, 
        (uint32_t const   )131072,      (uint32_t const   )134349312,      (uint32_t const   )134218240,      (uint32_t const   )0, 
        (uint32_t const   )512,      (uint32_t const   )131080,      (uint32_t const   )134349320,      (uint32_t const   )134218240, 
        (uint32_t const   )134217736,      (uint32_t const   )512,      (uint32_t const   )0,      (uint32_t const   )134348808, 
        (uint32_t const   )134218248,      (uint32_t const   )131072,      (uint32_t const   )134217728,      (uint32_t const   )134349320, 
        (uint32_t const   )8,      (uint32_t const   )131592,      (uint32_t const   )131584,      (uint32_t const   )134217736, 
        (uint32_t const   )134348800,      (uint32_t const   )134218248,      (uint32_t const   )520,      (uint32_t const   )134348800, 
        (uint32_t const   )131592,      (uint32_t const   )8,      (uint32_t const   )134348808,      (uint32_t const   )131584};
#line 133 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/xcrypt.c"
static uint32_t const   sbox4[64]  = 
#line 133
  {      (uint32_t const   )8396801,      (uint32_t const   )8321,      (uint32_t const   )8321,      (uint32_t const   )128, 
        (uint32_t const   )8396928,      (uint32_t const   )8388737,      (uint32_t const   )8388609,      (uint32_t const   )8193, 
        (uint32_t const   )0,      (uint32_t const   )8396800,      (uint32_t const   )8396800,      (uint32_t const   )8396929, 
        (uint32_t const   )129,      (uint32_t const   )0,      (uint32_t const   )8388736,      (uint32_t const   )8388609, 
        (uint32_t const   )1,      (uint32_t const   )8192,      (uint32_t const   )8388608,      (uint32_t const   )8396801, 
        (uint32_t const   )128,      (uint32_t const   )8388608,      (uint32_t const   )8193,      (uint32_t const   )8320, 
        (uint32_t const   )8388737,      (uint32_t const   )1,      (uint32_t const   )8320,      (uint32_t const   )8388736, 
        (uint32_t const   )8192,      (uint32_t const   )8396928,      (uint32_t const   )8396929,      (uint32_t const   )129, 
        (uint32_t const   )8388736,      (uint32_t const   )8388609,      (uint32_t const   )8396800,      (uint32_t const   )8396929, 
        (uint32_t const   )129,      (uint32_t const   )0,      (uint32_t const   )0,      (uint32_t const   )8396800, 
        (uint32_t const   )8320,      (uint32_t const   )8388736,      (uint32_t const   )8388737,      (uint32_t const   )1, 
        (uint32_t const   )8396801,      (uint32_t const   )8321,      (uint32_t const   )8321,      (uint32_t const   )128, 
        (uint32_t const   )8396929,      (uint32_t const   )129,      (uint32_t const   )1,      (uint32_t const   )8192, 
        (uint32_t const   )8388609,      (uint32_t const   )8193,      (uint32_t const   )8396928,      (uint32_t const   )8388737, 
        (uint32_t const   )8193,      (uint32_t const   )8320,      (uint32_t const   )8388608,      (uint32_t const   )8396801, 
        (uint32_t const   )128,      (uint32_t const   )8388608,      (uint32_t const   )8192,      (uint32_t const   )8396928};
#line 147 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/xcrypt.c"
static uint32_t const   sbox5[64]  = 
#line 147
  {      (uint32_t const   )256,      (uint32_t const   )34078976,      (uint32_t const   )34078720,      (uint32_t const   )1107296512, 
        (uint32_t const   )524288,      (uint32_t const   )256,      (uint32_t const   )1073741824,      (uint32_t const   )34078720, 
        (uint32_t const   )1074266368,      (uint32_t const   )524288,      (uint32_t const   )33554688,      (uint32_t const   )1074266368, 
        (uint32_t const   )1107296512,      (uint32_t const   )1107820544,      (uint32_t const   )524544,      (uint32_t const   )1073741824, 
        (uint32_t const   )33554432,      (uint32_t const   )1074266112,      (uint32_t const   )1074266112,      (uint32_t const   )0, 
        (uint32_t const   )1073742080,      (uint32_t const   )1107820800,      (uint32_t const   )1107820800,      (uint32_t const   )33554688, 
        (uint32_t const   )1107820544,      (uint32_t const   )1073742080,      (uint32_t const   )0,      (uint32_t const   )1107296256, 
        (uint32_t const   )34078976,      (uint32_t const   )33554432,      (uint32_t const   )1107296256,      (uint32_t const   )524544, 
        (uint32_t const   )524288,      (uint32_t const   )1107296512,      (uint32_t const   )256,      (uint32_t const   )33554432, 
        (uint32_t const   )1073741824,      (uint32_t const   )34078720,      (uint32_t const   )1107296512,      (uint32_t const   )1074266368, 
        (uint32_t const   )33554688,      (uint32_t const   )1073741824,      (uint32_t const   )1107820544,      (uint32_t const   )34078976, 
        (uint32_t const   )1074266368,      (uint32_t const   )256,      (uint32_t const   )33554432,      (uint32_t const   )1107820544, 
        (uint32_t const   )1107820800,      (uint32_t const   )524544,      (uint32_t const   )1107296256,      (uint32_t const   )1107820800, 
        (uint32_t const   )34078720,      (uint32_t const   )0,      (uint32_t const   )1074266112,      (uint32_t const   )1107296256, 
        (uint32_t const   )524544,      (uint32_t const   )33554688,      (uint32_t const   )1073742080,      (uint32_t const   )524288, 
        (uint32_t const   )0,      (uint32_t const   )1074266112,      (uint32_t const   )34078976,      (uint32_t const   )1073742080};
#line 161 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/xcrypt.c"
static uint32_t const   sbox6[64]  = 
#line 161
  {      (uint32_t const   )536870928,      (uint32_t const   )541065216,      (uint32_t const   )16384,      (uint32_t const   )541081616, 
        (uint32_t const   )541065216,      (uint32_t const   )16,      (uint32_t const   )541081616,      (uint32_t const   )4194304, 
        (uint32_t const   )536887296,      (uint32_t const   )4210704,      (uint32_t const   )4194304,      (uint32_t const   )536870928, 
        (uint32_t const   )4194320,      (uint32_t const   )536887296,      (uint32_t const   )536870912,      (uint32_t const   )16400, 
        (uint32_t const   )0,      (uint32_t const   )4194320,      (uint32_t const   )536887312,      (uint32_t const   )16384, 
        (uint32_t const   )4210688,      (uint32_t const   )536887312,      (uint32_t const   )16,      (uint32_t const   )541065232, 
        (uint32_t const   )541065232,      (uint32_t const   )0,      (uint32_t const   )4210704,      (uint32_t const   )541081600, 
        (uint32_t const   )16400,      (uint32_t const   )4210688,      (uint32_t const   )541081600,      (uint32_t const   )536870912, 
        (uint32_t const   )536887296,      (uint32_t const   )16,      (uint32_t const   )541065232,      (uint32_t const   )4210688, 
        (uint32_t const   )541081616,      (uint32_t const   )4194304,      (uint32_t const   )16400,      (uint32_t const   )536870928, 
        (uint32_t const   )4194304,      (uint32_t const   )536887296,      (uint32_t const   )536870912,      (uint32_t const   )16400, 
        (uint32_t const   )536870928,      (uint32_t const   )541081616,      (uint32_t const   )4210688,      (uint32_t const   )541065216, 
        (uint32_t const   )4210704,      (uint32_t const   )541081600,      (uint32_t const   )0,      (uint32_t const   )541065232, 
        (uint32_t const   )16,      (uint32_t const   )16384,      (uint32_t const   )541065216,      (uint32_t const   )4210704, 
        (uint32_t const   )16384,      (uint32_t const   )4194320,      (uint32_t const   )536887312,      (uint32_t const   )0, 
        (uint32_t const   )541081600,      (uint32_t const   )536870912,      (uint32_t const   )4194320,      (uint32_t const   )536887312};
#line 175 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/xcrypt.c"
static uint32_t const   sbox7[64]  = 
#line 175
  {      (uint32_t const   )2097152,      (uint32_t const   )69206018,      (uint32_t const   )67110914,      (uint32_t const   )0, 
        (uint32_t const   )2048,      (uint32_t const   )67110914,      (uint32_t const   )2099202,      (uint32_t const   )69208064, 
        (uint32_t const   )69208066,      (uint32_t const   )2097152,      (uint32_t const   )0,      (uint32_t const   )67108866, 
        (uint32_t const   )2,      (uint32_t const   )67108864,      (uint32_t const   )69206018,      (uint32_t const   )2050, 
        (uint32_t const   )67110912,      (uint32_t const   )2099202,      (uint32_t const   )2097154,      (uint32_t const   )67110912, 
        (uint32_t const   )67108866,      (uint32_t const   )69206016,      (uint32_t const   )69208064,      (uint32_t const   )2097154, 
        (uint32_t const   )69206016,      (uint32_t const   )2048,      (uint32_t const   )2050,      (uint32_t const   )69208066, 
        (uint32_t const   )2099200,      (uint32_t const   )2,      (uint32_t const   )67108864,      (uint32_t const   )2099200, 
        (uint32_t const   )67108864,      (uint32_t const   )2099200,      (uint32_t const   )2097152,      (uint32_t const   )67110914, 
        (uint32_t const   )67110914,      (uint32_t const   )69206018,      (uint32_t const   )69206018,      (uint32_t const   )2, 
        (uint32_t const   )2097154,      (uint32_t const   )67108864,      (uint32_t const   )67110912,      (uint32_t const   )2097152, 
        (uint32_t const   )69208064,      (uint32_t const   )2050,      (uint32_t const   )2099202,      (uint32_t const   )69208064, 
        (uint32_t const   )2050,      (uint32_t const   )67108866,      (uint32_t const   )69208066,      (uint32_t const   )69206016, 
        (uint32_t const   )2099200,      (uint32_t const   )0,      (uint32_t const   )2,      (uint32_t const   )69208066, 
        (uint32_t const   )0,      (uint32_t const   )2099202,      (uint32_t const   )69206016,      (uint32_t const   )2048, 
        (uint32_t const   )67108866,      (uint32_t const   )67110912,      (uint32_t const   )2048,      (uint32_t const   )2097154};
#line 189 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/xcrypt.c"
static uint32_t const   sbox8[64]  = 
#line 189
  {      (uint32_t const   )268439616,      (uint32_t const   )4096,      (uint32_t const   )262144,      (uint32_t const   )268701760, 
        (uint32_t const   )268435456,      (uint32_t const   )268439616,      (uint32_t const   )64,      (uint32_t const   )268435456, 
        (uint32_t const   )262208,      (uint32_t const   )268697600,      (uint32_t const   )268701760,      (uint32_t const   )266240, 
        (uint32_t const   )268701696,      (uint32_t const   )266304,      (uint32_t const   )4096,      (uint32_t const   )64, 
        (uint32_t const   )268697600,      (uint32_t const   )268435520,      (uint32_t const   )268439552,      (uint32_t const   )4160, 
        (uint32_t const   )266240,      (uint32_t const   )262208,      (uint32_t const   )268697664,      (uint32_t const   )268701696, 
        (uint32_t const   )4160,      (uint32_t const   )0,      (uint32_t const   )0,      (uint32_t const   )268697664, 
        (uint32_t const   )268435520,      (uint32_t const   )268439552,      (uint32_t const   )266304,      (uint32_t const   )262144, 
        (uint32_t const   )266304,      (uint32_t const   )262144,      (uint32_t const   )268701696,      (uint32_t const   )4096, 
        (uint32_t const   )64,      (uint32_t const   )268697664,      (uint32_t const   )4096,      (uint32_t const   )266304, 
        (uint32_t const   )268439552,      (uint32_t const   )64,      (uint32_t const   )268435520,      (uint32_t const   )268697600, 
        (uint32_t const   )268697664,      (uint32_t const   )268435456,      (uint32_t const   )262144,      (uint32_t const   )268439616, 
        (uint32_t const   )0,      (uint32_t const   )268701760,      (uint32_t const   )262208,      (uint32_t const   )268435520, 
        (uint32_t const   )268697600,      (uint32_t const   )268439552,      (uint32_t const   )268439616,      (uint32_t const   )0, 
        (uint32_t const   )268701760,      (uint32_t const   )266240,      (uint32_t const   )266240,      (uint32_t const   )4160, 
        (uint32_t const   )4160,      (uint32_t const   )262208,      (uint32_t const   )268435456,      (uint32_t const   )268701696};
#line 207 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/xcrypt.c"
static uint32_t const   leftkey_swap[16]  = 
#line 207
  {      (uint32_t const   )0,      (uint32_t const   )1,      (uint32_t const   )256,      (uint32_t const   )257, 
        (uint32_t const   )65536,      (uint32_t const   )65537,      (uint32_t const   )65792,      (uint32_t const   )65793, 
        (uint32_t const   )16777216,      (uint32_t const   )16777217,      (uint32_t const   )16777472,      (uint32_t const   )16777473, 
        (uint32_t const   )16842752,      (uint32_t const   )16842753,      (uint32_t const   )16843008,      (uint32_t const   )16843009};
#line 214 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/xcrypt.c"
static uint32_t const   rightkey_swap[16]  = 
#line 214
  {      (uint32_t const   )0,      (uint32_t const   )16777216,      (uint32_t const   )65536,      (uint32_t const   )16842752, 
        (uint32_t const   )256,      (uint32_t const   )16777472,      (uint32_t const   )65792,      (uint32_t const   )16843008, 
        (uint32_t const   )1,      (uint32_t const   )16777217,      (uint32_t const   )65537,      (uint32_t const   )16842753, 
        (uint32_t const   )257,      (uint32_t const   )16777473,      (uint32_t const   )65793,      (uint32_t const   )16843009};
#line 227 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/xcrypt.c"
static unsigned char const   encrypt_rotate_tab[16]  = 
#line 227
  {      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )1};
#line 238 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/xcrypt.c"
static unsigned char const   weak_keys[64][8]  = 
#line 238
  { {        (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )0, 
            (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )0}, 
   {        (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )30,        (unsigned char const   )30, 
            (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )14,        (unsigned char const   )14}, 
   {        (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )224,        (unsigned char const   )224, 
            (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )240,        (unsigned char const   )240}, 
   {        (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )254, 
            (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )254}, 
   {        (unsigned char const   )0,        (unsigned char const   )30,        (unsigned char const   )0,        (unsigned char const   )30, 
            (unsigned char const   )0,        (unsigned char const   )14,        (unsigned char const   )0,        (unsigned char const   )14}, 
   {        (unsigned char const   )0,        (unsigned char const   )30,        (unsigned char const   )30,        (unsigned char const   )0, 
            (unsigned char const   )0,        (unsigned char const   )14,        (unsigned char const   )14,        (unsigned char const   )0}, 
   {        (unsigned char const   )0,        (unsigned char const   )30,        (unsigned char const   )224,        (unsigned char const   )254, 
            (unsigned char const   )0,        (unsigned char const   )14,        (unsigned char const   )240,        (unsigned char const   )254}, 
   {        (unsigned char const   )0,        (unsigned char const   )30,        (unsigned char const   )254,        (unsigned char const   )224, 
            (unsigned char const   )0,        (unsigned char const   )14,        (unsigned char const   )254,        (unsigned char const   )240}, 
   {        (unsigned char const   )0,        (unsigned char const   )224,        (unsigned char const   )0,        (unsigned char const   )224, 
            (unsigned char const   )0,        (unsigned char const   )240,        (unsigned char const   )0,        (unsigned char const   )240}, 
   {        (unsigned char const   )0,        (unsigned char const   )224,        (unsigned char const   )30,        (unsigned char const   )254, 
            (unsigned char const   )0,        (unsigned char const   )240,        (unsigned char const   )14,        (unsigned char const   )254}, 
   {        (unsigned char const   )0,        (unsigned char const   )224,        (unsigned char const   )224,        (unsigned char const   )0, 
            (unsigned char const   )0,        (unsigned char const   )240,        (unsigned char const   )240,        (unsigned char const   )0}, 
   {        (unsigned char const   )0,        (unsigned char const   )224,        (unsigned char const   )254,        (unsigned char const   )30, 
            (unsigned char const   )0,        (unsigned char const   )240,        (unsigned char const   )254,        (unsigned char const   )14}, 
   {        (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )254, 
            (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )254}, 
   {        (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )30,        (unsigned char const   )224, 
            (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )14,        (unsigned char const   )240}, 
   {        (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )224,        (unsigned char const   )30, 
            (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )240,        (unsigned char const   )14}, 
   {        (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )0, 
            (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )0}, 
   {        (unsigned char const   )30,        (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )30, 
            (unsigned char const   )14,        (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )14}, 
   {        (unsigned char const   )30,        (unsigned char const   )0,        (unsigned char const   )30,        (unsigned char const   )0, 
            (unsigned char const   )14,        (unsigned char const   )0,        (unsigned char const   )14,        (unsigned char const   )0}, 
   {        (unsigned char const   )30,        (unsigned char const   )0,        (unsigned char const   )224,        (unsigned char const   )254, 
            (unsigned char const   )14,        (unsigned char const   )0,        (unsigned char const   )240,        (unsigned char const   )254}, 
   {        (unsigned char const   )30,        (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )224, 
            (unsigned char const   )14,        (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )240}, 
   {        (unsigned char const   )30,        (unsigned char const   )30,        (unsigned char const   )0,        (unsigned char const   )0, 
            (unsigned char const   )14,        (unsigned char const   )14,        (unsigned char const   )0,        (unsigned char const   )0}, 
   {        (unsigned char const   )30,        (unsigned char const   )30,        (unsigned char const   )30,        (unsigned char const   )30, 
            (unsigned char const   )14,        (unsigned char const   )14,        (unsigned char const   )14,        (unsigned char const   )14}, 
   {        (unsigned char const   )30,        (unsigned char const   )30,        (unsigned char const   )224,        (unsigned char const   )224, 
            (unsigned char const   )14,        (unsigned char const   )14,        (unsigned char const   )240,        (unsigned char const   )240}, 
   {        (unsigned char const   )30,        (unsigned char const   )30,        (unsigned char const   )254,        (unsigned char const   )254, 
            (unsigned char const   )14,        (unsigned char const   )14,        (unsigned char const   )254,        (unsigned char const   )254}, 
   {        (unsigned char const   )30,        (unsigned char const   )224,        (unsigned char const   )0,        (unsigned char const   )254, 
            (unsigned char const   )14,        (unsigned char const   )240,        (unsigned char const   )0,        (unsigned char const   )254}, 
   {        (unsigned char const   )30,        (unsigned char const   )224,        (unsigned char const   )30,        (unsigned char const   )224, 
            (unsigned char const   )14,        (unsigned char const   )240,        (unsigned char const   )14,        (unsigned char const   )240}, 
   {        (unsigned char const   )30,        (unsigned char const   )224,        (unsigned char const   )224,        (unsigned char const   )30, 
            (unsigned char const   )14,        (unsigned char const   )240,        (unsigned char const   )240,        (unsigned char const   )14}, 
   {        (unsigned char const   )30,        (unsigned char const   )224,        (unsigned char const   )254,        (unsigned char const   )0, 
            (unsigned char const   )14,        (unsigned char const   )240,        (unsigned char const   )254,        (unsigned char const   )0}, 
   {        (unsigned char const   )30,        (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )224, 
            (unsigned char const   )14,        (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )240}, 
   {        (unsigned char const   )30,        (unsigned char const   )254,        (unsigned char const   )30,        (unsigned char const   )254, 
            (unsigned char const   )14,        (unsigned char const   )254,        (unsigned char const   )14,        (unsigned char const   )254}, 
   {        (unsigned char const   )30,        (unsigned char const   )254,        (unsigned char const   )224,        (unsigned char const   )0, 
            (unsigned char const   )14,        (unsigned char const   )254,        (unsigned char const   )240,        (unsigned char const   )0}, 
   {        (unsigned char const   )30,        (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )30, 
            (unsigned char const   )14,        (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )14}, 
   {        (unsigned char const   )224,        (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )224, 
            (unsigned char const   )240,        (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )240}, 
   {        (unsigned char const   )224,        (unsigned char const   )0,        (unsigned char const   )30,        (unsigned char const   )254, 
            (unsigned char const   )240,        (unsigned char const   )0,        (unsigned char const   )14,        (unsigned char const   )254}, 
   {        (unsigned char const   )224,        (unsigned char const   )0,        (unsigned char const   )224,        (unsigned char const   )0, 
            (unsigned char const   )240,        (unsigned char const   )0,        (unsigned char const   )240,        (unsigned char const   )0}, 
   {        (unsigned char const   )224,        (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )30, 
            (unsigned char const   )240,        (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )14}, 
   {        (unsigned char const   )224,        (unsigned char const   )30,        (unsigned char const   )0,        (unsigned char const   )254, 
            (unsigned char const   )240,        (unsigned char const   )14,        (unsigned char const   )0,        (unsigned char const   )254}, 
   {        (unsigned char const   )224,        (unsigned char const   )30,        (unsigned char const   )30,        (unsigned char const   )224, 
            (unsigned char const   )240,        (unsigned char const   )14,        (unsigned char const   )14,        (unsigned char const   )240}, 
   {        (unsigned char const   )224,        (unsigned char const   )30,        (unsigned char const   )224,        (unsigned char const   )30, 
            (unsigned char const   )240,        (unsigned char const   )14,        (unsigned char const   )240,        (unsigned char const   )14}, 
   {        (unsigned char const   )224,        (unsigned char const   )30,        (unsigned char const   )254,        (unsigned char const   )0, 
            (unsigned char const   )240,        (unsigned char const   )14,        (unsigned char const   )254,        (unsigned char const   )0}, 
   {        (unsigned char const   )224,        (unsigned char const   )224,        (unsigned char const   )0,        (unsigned char const   )0, 
            (unsigned char const   )240,        (unsigned char const   )240,        (unsigned char const   )0,        (unsigned char const   )0}, 
   {        (unsigned char const   )224,        (unsigned char const   )224,        (unsigned char const   )30,        (unsigned char const   )30, 
            (unsigned char const   )240,        (unsigned char const   )240,        (unsigned char const   )14,        (unsigned char const   )14}, 
   {        (unsigned char const   )224,        (unsigned char const   )224,        (unsigned char const   )224,        (unsigned char const   )224, 
            (unsigned char const   )240,        (unsigned char const   )240,        (unsigned char const   )240,        (unsigned char const   )240}, 
   {        (unsigned char const   )224,        (unsigned char const   )224,        (unsigned char const   )254,        (unsigned char const   )254, 
            (unsigned char const   )240,        (unsigned char const   )240,        (unsigned char const   )254,        (unsigned char const   )254}, 
   {        (unsigned char const   )224,        (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )30, 
            (unsigned char const   )240,        (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )14}, 
   {        (unsigned char const   )224,        (unsigned char const   )254,        (unsigned char const   )30,        (unsigned char const   )0, 
            (unsigned char const   )240,        (unsigned char const   )254,        (unsigned char const   )14,        (unsigned char const   )0}, 
   {        (unsigned char const   )224,        (unsigned char const   )254,        (unsigned char const   )224,        (unsigned char const   )254, 
            (unsigned char const   )240,        (unsigned char const   )254,        (unsigned char const   )240,        (unsigned char const   )254}, 
   {        (unsigned char const   )224,        (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )224, 
            (unsigned char const   )240,        (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )240}, 
   {        (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )254, 
            (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )254}, 
   {        (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )30,        (unsigned char const   )224, 
            (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )14,        (unsigned char const   )240}, 
   {        (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )224,        (unsigned char const   )30, 
            (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )240,        (unsigned char const   )14}, 
   {        (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )0, 
            (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )0}, 
   {        (unsigned char const   )254,        (unsigned char const   )30,        (unsigned char const   )0,        (unsigned char const   )224, 
            (unsigned char const   )254,        (unsigned char const   )14,        (unsigned char const   )0,        (unsigned char const   )240}, 
   {        (unsigned char const   )254,        (unsigned char const   )30,        (unsigned char const   )30,        (unsigned char const   )254, 
            (unsigned char const   )254,        (unsigned char const   )14,        (unsigned char const   )14,        (unsigned char const   )254}, 
   {        (unsigned char const   )254,        (unsigned char const   )30,        (unsigned char const   )224,        (unsigned char const   )0, 
            (unsigned char const   )254,        (unsigned char const   )14,        (unsigned char const   )240,        (unsigned char const   )0}, 
   {        (unsigned char const   )254,        (unsigned char const   )30,        (unsigned char const   )254,        (unsigned char const   )30, 
            (unsigned char const   )254,        (unsigned char const   )14,        (unsigned char const   )254,        (unsigned char const   )14}, 
   {        (unsigned char const   )254,        (unsigned char const   )224,        (unsigned char const   )0,        (unsigned char const   )30, 
            (unsigned char const   )254,        (unsigned char const   )240,        (unsigned char const   )0,        (unsigned char const   )14}, 
   {        (unsigned char const   )254,        (unsigned char const   )224,        (unsigned char const   )30,        (unsigned char const   )0, 
            (unsigned char const   )254,        (unsigned char const   )240,        (unsigned char const   )14,        (unsigned char const   )0}, 
   {        (unsigned char const   )254,        (unsigned char const   )224,        (unsigned char const   )224,        (unsigned char const   )254, 
            (unsigned char const   )254,        (unsigned char const   )240,        (unsigned char const   )240,        (unsigned char const   )254}, 
   {        (unsigned char const   )254,        (unsigned char const   )224,        (unsigned char const   )254,        (unsigned char const   )224, 
            (unsigned char const   )254,        (unsigned char const   )240,        (unsigned char const   )254,        (unsigned char const   )240}, 
   {        (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )0, 
            (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )0}, 
   {        (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )30,        (unsigned char const   )30, 
            (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )14,        (unsigned char const   )14}, 
   {        (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )224,        (unsigned char const   )224, 
            (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )240,        (unsigned char const   )240}, 
   {        (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )254, 
            (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )254}};
#line 306 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/xcrypt.c"
_Bool gl_des_is_weak_key(char const   *key ) 
{ 
  char work[8] ;
  int i ;
  int left ;
  int right ;
  int middle ;
  int cmp_result ;

  {
#line 311
  i = 0;
  {
#line 311
  while (1) {
    while_continue: /* CIL Label */ ;
#line 311
    if (! (i < 8)) {
#line 311
      goto while_break;
    }
#line 312
    work[i] = (char )((int )((unsigned char )*(key + i)) & 254);
#line 311
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 315
  left = 0;
#line 316
  right = 63;
  {
#line 317
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 317
    if (! (left <= right)) {
#line 317
      goto while_break___0;
    }
    {
#line 319
    middle = (left + right) / 2;
#line 321
    cmp_result = memcmp((void const   *)(work), (void const   *)(weak_keys[middle]),
                        (size_t )8);
    }
#line 321
    if (! cmp_result) {
#line 322
      return ((_Bool)1);
    }
#line 324
    if (cmp_result > 0) {
#line 325
      left = middle + 1;
    } else {
#line 327
      right = middle - 1;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 330
  return ((_Bool)0);
}
}
#line 415 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/xcrypt.c"
static void des_key_schedule(char const   *_rawkey , uint32_t *subkey ) 
{ 
  unsigned char const   *rawkey ;
  uint32_t left ;
  uint32_t right ;
  uint32_t work ;
  int round ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;

  {
#line 416
  rawkey = (unsigned char const   *)_rawkey;
#line 420
  left = (uint32_t )(((((int const   )*(rawkey + 0) << 24) | ((int const   )*(rawkey + 1) << 16)) | ((int const   )*(rawkey + 2) << 8)) | (int const   )*(rawkey + 3));
#line 420
  right = (uint32_t )(((((int const   )*(rawkey + 4) << 24) | ((int const   )*(rawkey + 5) << 16)) | ((int const   )*(rawkey + 6) << 8)) | (int const   )*(rawkey + 7));
#line 421
  work = ((right >> 4) ^ left) & 252645135U;
#line 421
  left ^= work;
#line 421
  right ^= work << 4;
#line 422
  work = (right ^ left) & 269488144U;
#line 422
  left ^= work;
#line 422
  right ^= work;
#line 423
  left = (uint32_t )((((((((leftkey_swap[left & 15U] << 3) | (leftkey_swap[(left >> 8) & 15U] << 2)) | (leftkey_swap[(left >> 16) & 15U] << 1)) | leftkey_swap[(left >> 24) & 15U]) | (leftkey_swap[(left >> 5) & 15U] << 7)) | (leftkey_swap[(left >> 13) & 15U] << 6)) | (leftkey_swap[(left >> 21) & 15U] << 5)) | (leftkey_swap[(left >> 29) & 15U] << 4));
#line 432
  left &= 268435455U;
#line 434
  right = (uint32_t )((((((((rightkey_swap[(right >> 1) & 15U] << 3) | (rightkey_swap[(right >> 9) & 15U] << 2)) | (rightkey_swap[(right >> 17) & 15U] << 1)) | rightkey_swap[(right >> 25) & 15U]) | (rightkey_swap[(right >> 4) & 15U] << 7)) | (rightkey_swap[(right >> 12) & 15U] << 6)) | (rightkey_swap[(right >> 20) & 15U] << 5)) | (rightkey_swap[(right >> 28) & 15U] << 4));
#line 443
  right &= 268435455U;
#line 445
  round = 0;
  {
#line 445
  while (1) {
    while_continue: /* CIL Label */ ;
#line 445
    if (! (round < 16)) {
#line 445
      goto while_break;
    }
#line 447
    left = ((left << (int const   )encrypt_rotate_tab[round]) | (left >> (28 - (int )encrypt_rotate_tab[round]))) & 268435455U;
#line 449
    right = ((right << (int const   )encrypt_rotate_tab[round]) | (right >> (28 - (int )encrypt_rotate_tab[round]))) & 268435455U;
#line 452
    tmp = subkey;
#line 452
    subkey ++;
#line 452
    *tmp = ((((((((((((((((((((((left << 4) & 603979776U) | ((left << 28) & 268435456U)) | ((left << 14) & 134217728U)) | ((left << 18) & 34078720U)) | ((left << 6) & 16777216U)) | ((left << 9) & 2097152U)) | ((left >> 1) & 1048576U)) | ((left << 10) & 262144U)) | ((left << 2) & 131072U)) | ((left >> 10) & 65536U)) | ((right >> 13) & 8192U)) | ((right >> 4) & 4096U)) | ((right << 6) & 2048U)) | ((right >> 1) & 1024U)) | ((right >> 14) & 512U)) | (right & 256U)) | ((right >> 5) & 32U)) | ((right >> 10) & 16U)) | ((right >> 3) & 8U)) | ((right >> 18) & 4U)) | ((right >> 26) & 2U)) | ((right >> 24) & 1U);
#line 475
    tmp___0 = subkey;
#line 475
    subkey ++;
#line 475
    *tmp___0 = ((((((((((((((((((((((left << 15) & 536870912U) | ((left << 17) & 268435456U)) | ((left << 10) & 134217728U)) | ((left << 22) & 67108864U)) | ((left >> 2) & 33554432U)) | ((left << 1) & 16777216U)) | ((left << 16) & 2097152U)) | ((left << 11) & 1048576U)) | ((left << 3) & 524288U)) | ((left >> 6) & 262144U)) | ((left << 15) & 131072U)) | ((left >> 4) & 65536U)) | ((right >> 2) & 8192U)) | ((right << 8) & 4096U)) | ((right >> 14) & 2056U)) | ((right >> 9) & 1024U)) | (right & 512U)) | ((right << 7) & 256U)) | ((right >> 7) & 32U)) | ((right >> 3) & 17U)) | ((right << 2) & 4U)) | ((right >> 21) & 2U);
#line 445
    round ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 498
  return;
}
}
#line 500 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/xcrypt.c"
void gl_des_setkey(gl_des_ctx *ctx , char const   *key ) 
{ 
  int i ;

  {
  {
#line 503
  des_key_schedule(key, ctx->encrypt_subkeys);
#line 505
  i = 0;
  }
  {
#line 505
  while (1) {
    while_continue: /* CIL Label */ ;
#line 505
    if (! (i < 32)) {
#line 505
      goto while_break;
    }
#line 507
    ctx->decrypt_subkeys[i] = ctx->encrypt_subkeys[30 - i];
#line 508
    ctx->decrypt_subkeys[i + 1] = ctx->encrypt_subkeys[31 - i];
#line 505
    i += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 510
  return;
}
}
#line 512 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/xcrypt.c"
_Bool gl_des_makekey(gl_des_ctx *ctx , char const   *key , size_t keylen ) 
{ 
  _Bool tmp ;
  int tmp___0 ;

  {
#line 513
  if (keylen != 8UL) {
#line 514
    return ((_Bool)0);
  }
  {
#line 516
  gl_des_setkey(ctx, key);
#line 518
  tmp = gl_des_is_weak_key(key);
  }
#line 518
  if (tmp) {
#line 518
    tmp___0 = 0;
  } else {
#line 518
    tmp___0 = 1;
  }
#line 518
  return ((_Bool )tmp___0);
}
}
#line 521 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/xcrypt.c"
void gl_des_ecb_crypt(gl_des_ctx *ctx , char const   *_from , char *_to , int mode ) 
{ 
  unsigned char const   *from ;
  unsigned char *to ;
  uint32_t left ;
  uint32_t right ;
  uint32_t work ;
  uint32_t *keys ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t *tmp___2 ;
  uint32_t *tmp___3 ;
  uint32_t *tmp___4 ;
  uint32_t *tmp___5 ;
  uint32_t *tmp___6 ;
  uint32_t *tmp___7 ;
  uint32_t *tmp___8 ;
  uint32_t *tmp___9 ;
  uint32_t *tmp___10 ;
  uint32_t *tmp___11 ;
  uint32_t *tmp___12 ;
  uint32_t *tmp___13 ;
  uint32_t *tmp___14 ;
  uint32_t *tmp___15 ;
  uint32_t *tmp___16 ;
  uint32_t *tmp___17 ;
  uint32_t *tmp___18 ;
  uint32_t *tmp___19 ;
  uint32_t *tmp___20 ;
  uint32_t *tmp___21 ;
  uint32_t *tmp___22 ;
  uint32_t *tmp___23 ;
  uint32_t *tmp___24 ;
  uint32_t *tmp___25 ;
  uint32_t *tmp___26 ;
  uint32_t *tmp___27 ;
  uint32_t *tmp___28 ;
  uint32_t *tmp___29 ;
  uint32_t *tmp___30 ;

  {
#line 522
  from = (unsigned char const   *)_from;
#line 523
  to = (unsigned char *)_to;
#line 527
  if (mode) {
#line 527
    keys = ctx->decrypt_subkeys;
  } else {
#line 527
    keys = ctx->encrypt_subkeys;
  }
#line 529
  left = (uint32_t )(((((int const   )*(from + 0) << 24) | ((int const   )*(from + 1) << 16)) | ((int const   )*(from + 2) << 8)) | (int const   )*(from + 3));
#line 529
  right = (uint32_t )(((((int const   )*(from + 4) << 24) | ((int const   )*(from + 5) << 16)) | ((int const   )*(from + 6) << 8)) | (int const   )*(from + 7));
#line 530
  work = ((left >> 4) ^ right) & 252645135U;
#line 530
  right ^= work;
#line 530
  left ^= work << 4;
#line 530
  work = ((left >> 16) ^ right) & 65535U;
#line 530
  right ^= work;
#line 530
  left ^= work << 16;
#line 530
  work = ((right >> 2) ^ left) & 858993459U;
#line 530
  left ^= work;
#line 530
  right ^= work << 2;
#line 530
  work = ((right >> 8) ^ left) & 16711935U;
#line 530
  left ^= work;
#line 530
  right ^= work << 8;
#line 530
  right = (right << 1) | (right >> 31);
#line 530
  work = (left ^ right) & 2863311530U;
#line 530
  right ^= work;
#line 530
  left ^= work;
#line 530
  left = (left << 1) | (left >> 31);
#line 531
  tmp = keys;
#line 531
  keys ++;
#line 531
  work = right ^ *tmp;
#line 531
  left ^= (unsigned int )sbox8[work & 63U];
#line 531
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 531
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 531
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 531
  tmp___0 = keys;
#line 531
  keys ++;
#line 531
  work = ((right << 28) | (right >> 4)) ^ *tmp___0;
#line 531
  left ^= (unsigned int )sbox7[work & 63U];
#line 531
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 531
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 531
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 531
  tmp___1 = keys;
#line 531
  keys ++;
#line 531
  work = left ^ *tmp___1;
#line 531
  right ^= (unsigned int )sbox8[work & 63U];
#line 531
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 531
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 531
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 531
  tmp___2 = keys;
#line 531
  keys ++;
#line 531
  work = ((left << 28) | (left >> 4)) ^ *tmp___2;
#line 531
  right ^= (unsigned int )sbox7[work & 63U];
#line 531
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 531
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 531
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 532
  tmp___3 = keys;
#line 532
  keys ++;
#line 532
  work = right ^ *tmp___3;
#line 532
  left ^= (unsigned int )sbox8[work & 63U];
#line 532
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 532
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 532
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 532
  tmp___4 = keys;
#line 532
  keys ++;
#line 532
  work = ((right << 28) | (right >> 4)) ^ *tmp___4;
#line 532
  left ^= (unsigned int )sbox7[work & 63U];
#line 532
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 532
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 532
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 532
  tmp___5 = keys;
#line 532
  keys ++;
#line 532
  work = left ^ *tmp___5;
#line 532
  right ^= (unsigned int )sbox8[work & 63U];
#line 532
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 532
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 532
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 532
  tmp___6 = keys;
#line 532
  keys ++;
#line 532
  work = ((left << 28) | (left >> 4)) ^ *tmp___6;
#line 532
  right ^= (unsigned int )sbox7[work & 63U];
#line 532
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 532
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 532
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 533
  tmp___7 = keys;
#line 533
  keys ++;
#line 533
  work = right ^ *tmp___7;
#line 533
  left ^= (unsigned int )sbox8[work & 63U];
#line 533
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 533
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 533
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 533
  tmp___8 = keys;
#line 533
  keys ++;
#line 533
  work = ((right << 28) | (right >> 4)) ^ *tmp___8;
#line 533
  left ^= (unsigned int )sbox7[work & 63U];
#line 533
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 533
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 533
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 533
  tmp___9 = keys;
#line 533
  keys ++;
#line 533
  work = left ^ *tmp___9;
#line 533
  right ^= (unsigned int )sbox8[work & 63U];
#line 533
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 533
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 533
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 533
  tmp___10 = keys;
#line 533
  keys ++;
#line 533
  work = ((left << 28) | (left >> 4)) ^ *tmp___10;
#line 533
  right ^= (unsigned int )sbox7[work & 63U];
#line 533
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 533
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 533
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 534
  tmp___11 = keys;
#line 534
  keys ++;
#line 534
  work = right ^ *tmp___11;
#line 534
  left ^= (unsigned int )sbox8[work & 63U];
#line 534
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 534
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 534
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 534
  tmp___12 = keys;
#line 534
  keys ++;
#line 534
  work = ((right << 28) | (right >> 4)) ^ *tmp___12;
#line 534
  left ^= (unsigned int )sbox7[work & 63U];
#line 534
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 534
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 534
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 534
  tmp___13 = keys;
#line 534
  keys ++;
#line 534
  work = left ^ *tmp___13;
#line 534
  right ^= (unsigned int )sbox8[work & 63U];
#line 534
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 534
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 534
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 534
  tmp___14 = keys;
#line 534
  keys ++;
#line 534
  work = ((left << 28) | (left >> 4)) ^ *tmp___14;
#line 534
  right ^= (unsigned int )sbox7[work & 63U];
#line 534
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 534
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 534
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 535
  tmp___15 = keys;
#line 535
  keys ++;
#line 535
  work = right ^ *tmp___15;
#line 535
  left ^= (unsigned int )sbox8[work & 63U];
#line 535
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 535
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 535
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 535
  tmp___16 = keys;
#line 535
  keys ++;
#line 535
  work = ((right << 28) | (right >> 4)) ^ *tmp___16;
#line 535
  left ^= (unsigned int )sbox7[work & 63U];
#line 535
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 535
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 535
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 535
  tmp___17 = keys;
#line 535
  keys ++;
#line 535
  work = left ^ *tmp___17;
#line 535
  right ^= (unsigned int )sbox8[work & 63U];
#line 535
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 535
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 535
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 535
  tmp___18 = keys;
#line 535
  keys ++;
#line 535
  work = ((left << 28) | (left >> 4)) ^ *tmp___18;
#line 535
  right ^= (unsigned int )sbox7[work & 63U];
#line 535
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 535
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 535
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 536
  tmp___19 = keys;
#line 536
  keys ++;
#line 536
  work = right ^ *tmp___19;
#line 536
  left ^= (unsigned int )sbox8[work & 63U];
#line 536
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 536
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 536
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 536
  tmp___20 = keys;
#line 536
  keys ++;
#line 536
  work = ((right << 28) | (right >> 4)) ^ *tmp___20;
#line 536
  left ^= (unsigned int )sbox7[work & 63U];
#line 536
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 536
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 536
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 536
  tmp___21 = keys;
#line 536
  keys ++;
#line 536
  work = left ^ *tmp___21;
#line 536
  right ^= (unsigned int )sbox8[work & 63U];
#line 536
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 536
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 536
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 536
  tmp___22 = keys;
#line 536
  keys ++;
#line 536
  work = ((left << 28) | (left >> 4)) ^ *tmp___22;
#line 536
  right ^= (unsigned int )sbox7[work & 63U];
#line 536
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 536
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 536
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 537
  tmp___23 = keys;
#line 537
  keys ++;
#line 537
  work = right ^ *tmp___23;
#line 537
  left ^= (unsigned int )sbox8[work & 63U];
#line 537
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 537
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 537
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 537
  tmp___24 = keys;
#line 537
  keys ++;
#line 537
  work = ((right << 28) | (right >> 4)) ^ *tmp___24;
#line 537
  left ^= (unsigned int )sbox7[work & 63U];
#line 537
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 537
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 537
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 537
  tmp___25 = keys;
#line 537
  keys ++;
#line 537
  work = left ^ *tmp___25;
#line 537
  right ^= (unsigned int )sbox8[work & 63U];
#line 537
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 537
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 537
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 537
  tmp___26 = keys;
#line 537
  keys ++;
#line 537
  work = ((left << 28) | (left >> 4)) ^ *tmp___26;
#line 537
  right ^= (unsigned int )sbox7[work & 63U];
#line 537
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 537
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 537
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 538
  tmp___27 = keys;
#line 538
  keys ++;
#line 538
  work = right ^ *tmp___27;
#line 538
  left ^= (unsigned int )sbox8[work & 63U];
#line 538
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 538
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 538
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 538
  tmp___28 = keys;
#line 538
  keys ++;
#line 538
  work = ((right << 28) | (right >> 4)) ^ *tmp___28;
#line 538
  left ^= (unsigned int )sbox7[work & 63U];
#line 538
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 538
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 538
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 538
  tmp___29 = keys;
#line 538
  keys ++;
#line 538
  work = left ^ *tmp___29;
#line 538
  right ^= (unsigned int )sbox8[work & 63U];
#line 538
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 538
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 538
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 538
  tmp___30 = keys;
#line 538
  keys ++;
#line 538
  work = ((left << 28) | (left >> 4)) ^ *tmp___30;
#line 538
  right ^= (unsigned int )sbox7[work & 63U];
#line 538
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 538
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 538
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 539
  right = (right << 31) | (right >> 1);
#line 539
  work = (right ^ left) & 2863311530U;
#line 539
  right ^= work;
#line 539
  left ^= work;
#line 539
  left = (left << 31) | (left >> 1);
#line 539
  work = ((left >> 8) ^ right) & 16711935U;
#line 539
  right ^= work;
#line 539
  left ^= work << 8;
#line 539
  work = ((left >> 2) ^ right) & 858993459U;
#line 539
  right ^= work;
#line 539
  left ^= work << 2;
#line 539
  work = ((right >> 16) ^ left) & 65535U;
#line 539
  left ^= work;
#line 539
  right ^= work << 16;
#line 539
  work = ((right >> 4) ^ left) & 252645135U;
#line 539
  left ^= work;
#line 539
  right ^= work << 4;
#line 540
  *(to + 0) = (unsigned char )((right >> 24) & 255U);
#line 540
  *(to + 1) = (unsigned char )((right >> 16) & 255U);
#line 540
  *(to + 2) = (unsigned char )((right >> 8) & 255U);
#line 540
  *(to + 3) = (unsigned char )(right & 255U);
#line 540
  *(to + 4) = (unsigned char )((left >> 24) & 255U);
#line 540
  *(to + 5) = (unsigned char )((left >> 16) & 255U);
#line 540
  *(to + 6) = (unsigned char )((left >> 8) & 255U);
#line 540
  *(to + 7) = (unsigned char )(left & 255U);
#line 541
  return;
}
}
#line 545 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/xcrypt.c"
void md4_process_block(void const   *buffer , size_t len , struct md4_ctx *ctx ) 
{ 
  uint32_t const   *words ;
  size_t nwords ;
  uint32_t const   *endp ;
  uint32_t x[16] ;
  uint32_t A ;
  uint32_t B ;
  uint32_t C ;
  uint32_t D ;
  int t ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;

  {
#line 546
  words = (uint32_t const   *)buffer;
#line 547
  nwords = len / sizeof(uint32_t );
#line 548
  endp = words + nwords;
#line 550
  A = ctx->A;
#line 551
  B = ctx->B;
#line 552
  C = ctx->C;
#line 553
  D = ctx->D;
#line 558
  ctx->total[0] = (uint32_t )((size_t )ctx->total[0] + len);
#line 559
  if ((size_t )ctx->total[0] < len) {
#line 560
    (ctx->total[1]) ++;
  }
  {
#line 564
  while (1) {
    while_continue: /* CIL Label */ ;
#line 564
    if (! ((unsigned long )words < (unsigned long )endp)) {
#line 564
      goto while_break;
    }
#line 567
    t = 0;
    {
#line 567
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 567
      if (! (t < 16)) {
#line 567
        goto while_break___0;
      }
#line 569
      x[t] = (uint32_t )*words;
#line 570
      words ++;
#line 567
      t ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 574
    A = (((A + (D ^ (B & (C ^ D)))) + x[0]) << 3) | (((A + (D ^ (B & (C ^ D)))) + x[0]) >> 29);
#line 575
    D = (((D + (C ^ (A & (B ^ C)))) + x[1]) << 7) | (((D + (C ^ (A & (B ^ C)))) + x[1]) >> 25);
#line 576
    C = (((C + (B ^ (D & (A ^ B)))) + x[2]) << 11) | (((C + (B ^ (D & (A ^ B)))) + x[2]) >> 21);
#line 577
    B = (((B + (A ^ (C & (D ^ A)))) + x[3]) << 19) | (((B + (A ^ (C & (D ^ A)))) + x[3]) >> 13);
#line 578
    A = (((A + (D ^ (B & (C ^ D)))) + x[4]) << 3) | (((A + (D ^ (B & (C ^ D)))) + x[4]) >> 29);
#line 579
    D = (((D + (C ^ (A & (B ^ C)))) + x[5]) << 7) | (((D + (C ^ (A & (B ^ C)))) + x[5]) >> 25);
#line 580
    C = (((C + (B ^ (D & (A ^ B)))) + x[6]) << 11) | (((C + (B ^ (D & (A ^ B)))) + x[6]) >> 21);
#line 581
    B = (((B + (A ^ (C & (D ^ A)))) + x[7]) << 19) | (((B + (A ^ (C & (D ^ A)))) + x[7]) >> 13);
#line 582
    A = (((A + (D ^ (B & (C ^ D)))) + x[8]) << 3) | (((A + (D ^ (B & (C ^ D)))) + x[8]) >> 29);
#line 583
    D = (((D + (C ^ (A & (B ^ C)))) + x[9]) << 7) | (((D + (C ^ (A & (B ^ C)))) + x[9]) >> 25);
#line 584
    C = (((C + (B ^ (D & (A ^ B)))) + x[10]) << 11) | (((C + (B ^ (D & (A ^ B)))) + x[10]) >> 21);
#line 585
    B = (((B + (A ^ (C & (D ^ A)))) + x[11]) << 19) | (((B + (A ^ (C & (D ^ A)))) + x[11]) >> 13);
#line 586
    A = (((A + (D ^ (B & (C ^ D)))) + x[12]) << 3) | (((A + (D ^ (B & (C ^ D)))) + x[12]) >> 29);
#line 587
    D = (((D + (C ^ (A & (B ^ C)))) + x[13]) << 7) | (((D + (C ^ (A & (B ^ C)))) + x[13]) >> 25);
#line 588
    C = (((C + (B ^ (D & (A ^ B)))) + x[14]) << 11) | (((C + (B ^ (D & (A ^ B)))) + x[14]) >> 21);
#line 589
    B = (((B + (A ^ (C & (D ^ A)))) + x[15]) << 19) | (((B + (A ^ (C & (D ^ A)))) + x[15]) >> 13);
#line 592
    A = ((((A + (((B & C) | (B & D)) | (C & D))) + x[0]) + 1518500249U) << 3) | ((((A + (((B & C) | (B & D)) | (C & D))) + x[0]) + 1518500249U) >> 29);
#line 593
    D = ((((D + (((A & B) | (A & C)) | (B & C))) + x[4]) + 1518500249U) << 5) | ((((D + (((A & B) | (A & C)) | (B & C))) + x[4]) + 1518500249U) >> 27);
#line 594
    C = ((((C + (((D & A) | (D & B)) | (A & B))) + x[8]) + 1518500249U) << 9) | ((((C + (((D & A) | (D & B)) | (A & B))) + x[8]) + 1518500249U) >> 23);
#line 595
    B = ((((B + (((C & D) | (C & A)) | (D & A))) + x[12]) + 1518500249U) << 13) | ((((B + (((C & D) | (C & A)) | (D & A))) + x[12]) + 1518500249U) >> 19);
#line 596
    A = ((((A + (((B & C) | (B & D)) | (C & D))) + x[1]) + 1518500249U) << 3) | ((((A + (((B & C) | (B & D)) | (C & D))) + x[1]) + 1518500249U) >> 29);
#line 597
    D = ((((D + (((A & B) | (A & C)) | (B & C))) + x[5]) + 1518500249U) << 5) | ((((D + (((A & B) | (A & C)) | (B & C))) + x[5]) + 1518500249U) >> 27);
#line 598
    C = ((((C + (((D & A) | (D & B)) | (A & B))) + x[9]) + 1518500249U) << 9) | ((((C + (((D & A) | (D & B)) | (A & B))) + x[9]) + 1518500249U) >> 23);
#line 599
    B = ((((B + (((C & D) | (C & A)) | (D & A))) + x[13]) + 1518500249U) << 13) | ((((B + (((C & D) | (C & A)) | (D & A))) + x[13]) + 1518500249U) >> 19);
#line 600
    A = ((((A + (((B & C) | (B & D)) | (C & D))) + x[2]) + 1518500249U) << 3) | ((((A + (((B & C) | (B & D)) | (C & D))) + x[2]) + 1518500249U) >> 29);
#line 601
    D = ((((D + (((A & B) | (A & C)) | (B & C))) + x[6]) + 1518500249U) << 5) | ((((D + (((A & B) | (A & C)) | (B & C))) + x[6]) + 1518500249U) >> 27);
#line 602
    C = ((((C + (((D & A) | (D & B)) | (A & B))) + x[10]) + 1518500249U) << 9) | ((((C + (((D & A) | (D & B)) | (A & B))) + x[10]) + 1518500249U) >> 23);
#line 603
    B = ((((B + (((C & D) | (C & A)) | (D & A))) + x[14]) + 1518500249U) << 13) | ((((B + (((C & D) | (C & A)) | (D & A))) + x[14]) + 1518500249U) >> 19);
#line 604
    A = ((((A + (((B & C) | (B & D)) | (C & D))) + x[3]) + 1518500249U) << 3) | ((((A + (((B & C) | (B & D)) | (C & D))) + x[3]) + 1518500249U) >> 29);
#line 605
    D = ((((D + (((A & B) | (A & C)) | (B & C))) + x[7]) + 1518500249U) << 5) | ((((D + (((A & B) | (A & C)) | (B & C))) + x[7]) + 1518500249U) >> 27);
#line 606
    C = ((((C + (((D & A) | (D & B)) | (A & B))) + x[11]) + 1518500249U) << 9) | ((((C + (((D & A) | (D & B)) | (A & B))) + x[11]) + 1518500249U) >> 23);
#line 607
    B = ((((B + (((C & D) | (C & A)) | (D & A))) + x[15]) + 1518500249U) << 13) | ((((B + (((C & D) | (C & A)) | (D & A))) + x[15]) + 1518500249U) >> 19);
#line 610
    A = ((((A + ((B ^ C) ^ D)) + x[0]) + 1859775393U) << 3) | ((((A + ((B ^ C) ^ D)) + x[0]) + 1859775393U) >> 29);
#line 611
    D = ((((D + ((A ^ B) ^ C)) + x[8]) + 1859775393U) << 9) | ((((D + ((A ^ B) ^ C)) + x[8]) + 1859775393U) >> 23);
#line 612
    C = ((((C + ((D ^ A) ^ B)) + x[4]) + 1859775393U) << 11) | ((((C + ((D ^ A) ^ B)) + x[4]) + 1859775393U) >> 21);
#line 613
    B = ((((B + ((C ^ D) ^ A)) + x[12]) + 1859775393U) << 15) | ((((B + ((C ^ D) ^ A)) + x[12]) + 1859775393U) >> 17);
#line 614
    A = ((((A + ((B ^ C) ^ D)) + x[2]) + 1859775393U) << 3) | ((((A + ((B ^ C) ^ D)) + x[2]) + 1859775393U) >> 29);
#line 615
    D = ((((D + ((A ^ B) ^ C)) + x[10]) + 1859775393U) << 9) | ((((D + ((A ^ B) ^ C)) + x[10]) + 1859775393U) >> 23);
#line 616
    C = ((((C + ((D ^ A) ^ B)) + x[6]) + 1859775393U) << 11) | ((((C + ((D ^ A) ^ B)) + x[6]) + 1859775393U) >> 21);
#line 617
    B = ((((B + ((C ^ D) ^ A)) + x[14]) + 1859775393U) << 15) | ((((B + ((C ^ D) ^ A)) + x[14]) + 1859775393U) >> 17);
#line 618
    A = ((((A + ((B ^ C) ^ D)) + x[1]) + 1859775393U) << 3) | ((((A + ((B ^ C) ^ D)) + x[1]) + 1859775393U) >> 29);
#line 619
    D = ((((D + ((A ^ B) ^ C)) + x[9]) + 1859775393U) << 9) | ((((D + ((A ^ B) ^ C)) + x[9]) + 1859775393U) >> 23);
#line 620
    C = ((((C + ((D ^ A) ^ B)) + x[5]) + 1859775393U) << 11) | ((((C + ((D ^ A) ^ B)) + x[5]) + 1859775393U) >> 21);
#line 621
    B = ((((B + ((C ^ D) ^ A)) + x[13]) + 1859775393U) << 15) | ((((B + ((C ^ D) ^ A)) + x[13]) + 1859775393U) >> 17);
#line 622
    A = ((((A + ((B ^ C) ^ D)) + x[3]) + 1859775393U) << 3) | ((((A + ((B ^ C) ^ D)) + x[3]) + 1859775393U) >> 29);
#line 623
    D = ((((D + ((A ^ B) ^ C)) + x[11]) + 1859775393U) << 9) | ((((D + ((A ^ B) ^ C)) + x[11]) + 1859775393U) >> 23);
#line 624
    C = ((((C + ((D ^ A) ^ B)) + x[7]) + 1859775393U) << 11) | ((((C + ((D ^ A) ^ B)) + x[7]) + 1859775393U) >> 21);
#line 625
    B = ((((B + ((C ^ D) ^ A)) + x[15]) + 1859775393U) << 15) | ((((B + ((C ^ D) ^ A)) + x[15]) + 1859775393U) >> 17);
#line 627
    tmp = ctx->A + A;
#line 627
    ctx->A = tmp;
#line 627
    A = tmp;
#line 628
    tmp___0 = ctx->B + B;
#line 628
    ctx->B = tmp___0;
#line 628
    B = tmp___0;
#line 629
    tmp___1 = ctx->C + C;
#line 629
    ctx->C = tmp___1;
#line 629
    C = tmp___1;
#line 630
    tmp___2 = ctx->D + D;
#line 630
    ctx->D = tmp___2;
#line 630
    D = tmp___2;
  }
  while_break: /* CIL Label */ ;
  }
#line 632
  return;
}
}
#line 636 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/xcrypt.c"
void md4_init_ctx(struct md4_ctx *ctx ) 
{ 
  uint32_t tmp ;

  {
#line 637
  ctx->A = (uint32_t )1732584193;
#line 638
  ctx->B = 4023233417U;
#line 639
  ctx->C = 2562383102U;
#line 640
  ctx->D = (uint32_t )271733878;
#line 642
  tmp = (uint32_t )0;
#line 642
  ctx->total[1] = tmp;
#line 642
  ctx->total[0] = tmp;
#line 643
  ctx->buflen = (uint32_t )0;
#line 644
  return;
}
}
#line 651 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/xcrypt.c"
void *md4_read_ctx(struct md4_ctx  const  *ctx , void *resbuf ) 
{ 


  {
#line 652
  *((uint32_t *)resbuf + 0) = (uint32_t )ctx->A;
#line 653
  *((uint32_t *)resbuf + 1) = (uint32_t )ctx->B;
#line 654
  *((uint32_t *)resbuf + 2) = (uint32_t )ctx->C;
#line 655
  *((uint32_t *)resbuf + 3) = (uint32_t )ctx->D;
#line 657
  return (resbuf);
}
}
#line 665 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/xcrypt.c"
void *md4_finish_ctx(struct md4_ctx *ctx , void *resbuf ) 
{ 
  uint32_t bytes ;
  size_t pad ;
  void *tmp ;

  {
#line 667
  bytes = ctx->buflen;
#line 671
  ctx->total[0] += bytes;
#line 672
  if (ctx->total[0] < bytes) {
#line 673
    (ctx->total[1]) ++;
  }
#line 675
  if (bytes >= 56U) {
#line 675
    pad = (size_t )(120U - bytes);
  } else {
#line 675
    pad = (size_t )(56U - bytes);
  }
  {
#line 676
  memcpy((void */* __restrict  */)((char *)(ctx->buffer) + bytes), (void const   */* __restrict  */)(fillbuf),
         pad);
#line 679
  ctx->buffer[((size_t )bytes + pad) / 4UL] = ctx->total[0] << 3;
#line 680
  ctx->buffer[((size_t )bytes + pad) / 4UL + 1UL] = (ctx->total[1] << 3) | (ctx->total[0] >> 29);
#line 684
  md4_process_block((void const   *)(ctx->buffer), ((size_t )bytes + pad) + 8UL, ctx);
#line 686
  tmp = md4_read_ctx((struct md4_ctx  const  *)ctx, resbuf);
  }
#line 686
  return (tmp);
}
}
#line 689 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/xcrypt.c"
void md4_process_bytes(void const   *buffer , size_t len , struct md4_ctx *ctx ) 
{ 
  size_t left_over ;
  size_t add ;
  size_t tmp ;
  void *tmp___0 ;
  size_t left_over___0 ;

  {
#line 692
  if (ctx->buflen != 0U) {
#line 694
    left_over = (size_t )ctx->buflen;
#line 695
    if (128UL - left_over > len) {
#line 695
      tmp = len;
    } else {
#line 695
      tmp = 128UL - left_over;
    }
    {
#line 695
    add = tmp;
#line 697
    memcpy((void */* __restrict  */)((char *)(ctx->buffer) + left_over), (void const   */* __restrict  */)buffer,
           add);
#line 698
    ctx->buflen = (uint32_t )((size_t )ctx->buflen + add);
    }
#line 700
    if (ctx->buflen > 64U) {
      {
#line 702
      md4_process_block((void const   *)(ctx->buffer), (size_t )(ctx->buflen & 4294967232U),
                        ctx);
#line 704
      ctx->buflen &= 63U;
#line 706
      memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)((char *)(ctx->buffer) + ((left_over + add) & 0xffffffffffffffc0UL)),
             (size_t )ctx->buflen);
      }
    }
#line 710
    buffer = (void const   *)((char const   *)buffer + add);
#line 711
    len -= add;
  }
#line 715
  if (len >= 64UL) {
#line 718
    if ((uintptr_t )buffer % __alignof__(uint32_t ) != 0UL) {
      {
#line 719
      while (1) {
        while_continue: /* CIL Label */ ;
#line 719
        if (! (len > 64UL)) {
#line 719
          goto while_break;
        }
        {
#line 721
        tmp___0 = memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)buffer,
                         (size_t )64);
#line 721
        md4_process_block((void const   *)tmp___0, (size_t )64, ctx);
#line 722
        buffer = (void const   *)((char const   *)buffer + 64);
#line 723
        len -= 64UL;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 728
      md4_process_block(buffer, len & 0xffffffffffffffc0UL, ctx);
#line 729
      buffer = (void const   *)((char const   *)buffer + (len & 0xffffffffffffffc0UL));
#line 730
      len &= 63UL;
      }
    }
  }
#line 735
  if (len > 0UL) {
    {
#line 737
    left_over___0 = (size_t )ctx->buflen;
#line 739
    memcpy((void */* __restrict  */)((char *)(ctx->buffer) + left_over___0), (void const   */* __restrict  */)buffer,
           len);
#line 740
    left_over___0 += len;
    }
#line 741
    if (left_over___0 >= 64UL) {
      {
#line 743
      md4_process_block((void const   *)(ctx->buffer), (size_t )64, ctx);
#line 744
      left_over___0 -= 64UL;
#line 745
      memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)(& ctx->buffer[16]),
             left_over___0);
      }
    }
#line 747
    ctx->buflen = (uint32_t )left_over___0;
  }
#line 749
  return;
}
}
#line 754 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/xcrypt.c"
int md4_stream(FILE *stream , void *resblock ) 
{ 
  struct md4_ctx ctx ;
  char buffer[4168] ;
  size_t sum ;
  size_t n ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 760
  md4_init_ctx(& ctx);
  }
  {
#line 763
  while (1) {
    while_continue: /* CIL Label */ ;
#line 769
    sum = (size_t )0;
    {
#line 772
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 774
      n = fread((void */* __restrict  */)(buffer + sum), (size_t )1, 4096UL - sum,
                (FILE */* __restrict  */)stream);
#line 776
      sum += n;
      }
#line 778
      if (sum == 4096UL) {
#line 779
        goto while_break___0;
      }
#line 781
      if (n == 0UL) {
        {
#line 786
        tmp = ferror(stream);
        }
#line 786
        if (tmp) {
#line 787
          return (1);
        }
#line 788
        goto process_partial_block;
      }
      {
#line 794
      tmp___0 = feof(stream);
      }
#line 794
      if (tmp___0) {
#line 795
        goto process_partial_block;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 801
    md4_process_block((void const   *)(buffer), (size_t )4096, & ctx);
    }
  }
  while_break: /* CIL Label */ ;
  }
  process_partial_block: ;
#line 807
  if (sum > 0UL) {
    {
#line 808
    md4_process_bytes((void const   *)(buffer), sum, & ctx);
    }
  }
  {
#line 811
  md4_finish_ctx(& ctx, resblock);
  }
#line 812
  return (0);
}
}
#line 819 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/xcrypt.c"
void *md4_buffer(char const   *buffer , size_t len , void *resblock ) 
{ 
  struct md4_ctx ctx ;
  void *tmp ;

  {
  {
#line 823
  md4_init_ctx(& ctx);
#line 826
  md4_process_bytes((void const   *)buffer, len, & ctx);
#line 829
  tmp = md4_finish_ctx(& ctx, resblock);
  }
#line 829
  return (tmp);
}
}
#line 832 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/xcrypt.c"
void *memxor(void *dest , void const   *src , size_t n ) 
{ 
  char const   *s ;
  char *d ;
  char *tmp ;
  char const   *tmp___0 ;

  {
#line 833
  s = (char const   *)src;
#line 834
  d = (char *)dest;
  {
#line 836
  while (1) {
    while_continue: /* CIL Label */ ;
#line 836
    if (! (n > 0UL)) {
#line 836
      goto while_break;
    }
#line 837
    tmp = d;
#line 837
    d ++;
#line 837
    tmp___0 = s;
#line 837
    s ++;
#line 837
    *tmp = (char )((int )*tmp ^ (int )*tmp___0);
#line 836
    n --;
  }
  while_break: /* CIL Label */ ;
  }
#line 839
  return (dest);
}
}
#line 842 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/xcrypt.c"
int hmac_md5(void const   *key , size_t keylen , void const   *in , size_t inlen ,
             void *resbuf ) 
{ 
  struct md5_ctx inner ;
  struct md5_ctx outer ;
  char optkeybuf[16] ;
  char block[64] ;
  char innerhash[16] ;
  struct md5_ctx keyhash ;

  {
#line 852
  if (keylen > 64UL) {
    {
#line 856
    md5_init_ctx(& keyhash);
#line 857
    md5_process_bytes(key, keylen, & keyhash);
#line 858
    md5_finish_ctx(& keyhash, (void *)(optkeybuf));
#line 860
    key = (void const   *)(optkeybuf);
#line 861
    keylen = (size_t )16;
    }
  }
  {
#line 866
  md5_init_ctx(& inner);
#line 868
  memset((void *)(block), 54, sizeof(block));
#line 869
  memxor((void *)(block), key, keylen);
#line 871
  md5_process_block((void const   *)(block), (size_t )64, & inner);
#line 872
  md5_process_bytes(in, inlen, & inner);
#line 874
  md5_finish_ctx(& inner, (void *)(innerhash));
#line 878
  md5_init_ctx(& outer);
#line 880
  memset((void *)(block), 92, sizeof(block));
#line 881
  memxor((void *)(block), key, keylen);
#line 883
  md5_process_block((void const   *)(block), (size_t )64, & outer);
#line 884
  md5_process_bytes((void const   *)(innerhash), (size_t )16, & outer);
#line 886
  md5_finish_ctx(& outer, resbuf);
  }
#line 888
  return (0);
}
}
#line 895 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/xcrypt.c"
void md5_init_ctx(struct md5_ctx *ctx ) 
{ 
  uint32_t tmp ;

  {
#line 898
  ctx->A = (uint32_t )1732584193;
#line 899
  ctx->B = 4023233417U;
#line 900
  ctx->C = 2562383102U;
#line 901
  ctx->D = (uint32_t )271733878;
#line 903
  tmp = (uint32_t )0;
#line 903
  ctx->total[1] = tmp;
#line 903
  ctx->total[0] = tmp;
#line 904
  ctx->buflen = (uint32_t )0;
#line 905
  return;
}
}
#line 912 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/xcrypt.c"
void *md5_read_ctx(struct md5_ctx  const  *ctx , void *resbuf ) 
{ 


  {
#line 915
  *((uint32_t *)resbuf + 0) = (uint32_t )ctx->A;
#line 916
  *((uint32_t *)resbuf + 1) = (uint32_t )ctx->B;
#line 917
  *((uint32_t *)resbuf + 2) = (uint32_t )ctx->C;
#line 918
  *((uint32_t *)resbuf + 3) = (uint32_t )ctx->D;
#line 920
  return (resbuf);
}
}
#line 928 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/xcrypt.c"
void *md5_finish_ctx(struct md5_ctx *ctx , void *resbuf ) 
{ 
  uint32_t bytes ;
  size_t size ;
  int tmp ;
  void *tmp___0 ;

  {
#line 932
  bytes = ctx->buflen;
#line 933
  if (bytes < 56U) {
#line 933
    tmp = 16;
  } else {
#line 933
    tmp = 32;
  }
#line 933
  size = (size_t )tmp;
#line 936
  ctx->total[0] += bytes;
#line 937
  if (ctx->total[0] < bytes) {
#line 938
    (ctx->total[1]) ++;
  }
  {
#line 941
  ctx->buffer[size - 2UL] = ctx->total[0] << 3;
#line 942
  ctx->buffer[size - 1UL] = (ctx->total[1] << 3) | (ctx->total[0] >> 29);
#line 944
  memcpy((void */* __restrict  */)((char *)(ctx->buffer) + bytes), (void const   */* __restrict  */)(fillbuf),
         (size - 2UL) * 4UL - (size_t )bytes);
#line 947
  md5_process_block((void const   *)(ctx->buffer), size * 4UL, ctx);
#line 949
  tmp___0 = md5_read_ctx((struct md5_ctx  const  *)ctx, resbuf);
  }
#line 949
  return (tmp___0);
}
}
#line 955 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/xcrypt.c"
int md5_stream(FILE *stream , void *resblock ) 
{ 
  struct md5_ctx ctx ;
  char buffer[4168] ;
  size_t sum ;
  size_t n ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 963
  md5_init_ctx(& ctx);
  }
  {
#line 966
  while (1) {
    while_continue: /* CIL Label */ ;
#line 972
    sum = (size_t )0;
    {
#line 975
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 977
      n = fread((void */* __restrict  */)(buffer + sum), (size_t )1, 4096UL - sum,
                (FILE */* __restrict  */)stream);
#line 979
      sum += n;
      }
#line 981
      if (sum == 4096UL) {
#line 982
        goto while_break___0;
      }
#line 984
      if (n == 0UL) {
        {
#line 989
        tmp = ferror(stream);
        }
#line 989
        if (tmp) {
#line 990
          return (1);
        }
#line 991
        goto process_partial_block;
      }
      {
#line 997
      tmp___0 = feof(stream);
      }
#line 997
      if (tmp___0) {
#line 998
        goto process_partial_block;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1004
    md5_process_block((void const   *)(buffer), (size_t )4096, & ctx);
    }
  }
  while_break: /* CIL Label */ ;
  }
  process_partial_block: 
#line 1010
  if (sum > 0UL) {
    {
#line 1011
    md5_process_bytes((void const   *)(buffer), sum, & ctx);
    }
  }
  {
#line 1014
  md5_finish_ctx(& ctx, resblock);
  }
#line 1015
  return (0);
}
}
#line 1022 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/xcrypt.c"
void *md5_buffer(char const   *buffer , size_t len , void *resblock ) 
{ 
  struct md5_ctx ctx ;
  void *tmp ;

  {
  {
#line 1028
  md5_init_ctx(& ctx);
#line 1031
  md5_process_bytes((void const   *)buffer, len, & ctx);
#line 1034
  tmp = md5_finish_ctx(& ctx, resblock);
  }
#line 1034
  return (tmp);
}
}
#line 1038 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/xcrypt.c"
void md5_process_bytes(void const   *buffer , size_t len , struct md5_ctx *ctx ) 
{ 
  size_t left_over ;
  size_t add ;
  size_t tmp ;
  void *tmp___0 ;
  size_t left_over___0 ;

  {
#line 1043
  if (ctx->buflen != 0U) {
#line 1045
    left_over = (size_t )ctx->buflen;
#line 1046
    if (128UL - left_over > len) {
#line 1046
      tmp = len;
    } else {
#line 1046
      tmp = 128UL - left_over;
    }
    {
#line 1046
    add = tmp;
#line 1048
    memcpy((void */* __restrict  */)((char *)(ctx->buffer) + left_over), (void const   */* __restrict  */)buffer,
           add);
#line 1049
    ctx->buflen = (uint32_t )((size_t )ctx->buflen + add);
    }
#line 1051
    if (ctx->buflen > 64U) {
      {
#line 1053
      md5_process_block((void const   *)(ctx->buffer), (size_t )(ctx->buflen & 4294967232U),
                        ctx);
#line 1055
      ctx->buflen &= 63U;
#line 1057
      memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)((char *)(ctx->buffer) + ((left_over + add) & 0xffffffffffffffc0UL)),
             (size_t )ctx->buflen);
      }
    }
#line 1062
    buffer = (void const   *)((char const   *)buffer + add);
#line 1063
    len -= add;
  }
#line 1067
  if (len >= 64UL) {
#line 1070
    if ((uintptr_t )buffer % __alignof__(uint32_t ) != 0UL) {
      {
#line 1071
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1071
        if (! (len > 64UL)) {
#line 1071
          goto while_break;
        }
        {
#line 1073
        tmp___0 = memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)buffer,
                         (size_t )64);
#line 1073
        md5_process_block((void const   *)tmp___0, (size_t )64, ctx);
#line 1074
        buffer = (void const   *)((char const   *)buffer + 64);
#line 1075
        len -= 64UL;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 1080
      md5_process_block(buffer, len & 0xffffffffffffffc0UL, ctx);
#line 1081
      buffer = (void const   *)((char const   *)buffer + (len & 0xffffffffffffffc0UL));
#line 1082
      len &= 63UL;
      }
    }
  }
#line 1087
  if (len > 0UL) {
    {
#line 1089
    left_over___0 = (size_t )ctx->buflen;
#line 1091
    memcpy((void */* __restrict  */)((char *)(ctx->buffer) + left_over___0), (void const   */* __restrict  */)buffer,
           len);
#line 1092
    left_over___0 += len;
    }
#line 1093
    if (left_over___0 >= 64UL) {
      {
#line 1095
      md5_process_block((void const   *)(ctx->buffer), (size_t )64, ctx);
#line 1096
      left_over___0 -= 64UL;
#line 1097
      memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)(& ctx->buffer[16]),
             left_over___0);
      }
    }
#line 1099
    ctx->buflen = (uint32_t )left_over___0;
  }
#line 1101
  return;
}
}
#line 1116 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/xcrypt.c"
void md5_process_block(void const   *buffer , size_t len , struct md5_ctx *ctx ) 
{ 
  uint32_t correct_words[16] ;
  uint32_t const   *words ;
  size_t nwords ;
  uint32_t const   *endp ;
  uint32_t A ;
  uint32_t B ;
  uint32_t C ;
  uint32_t D ;
  uint32_t *cwp ;
  uint32_t A_save ;
  uint32_t B_save ;
  uint32_t C_save ;
  uint32_t D_save ;
  uint32_t *tmp ;
  uint32_t tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t *tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t *tmp___5 ;
  uint32_t tmp___6 ;
  uint32_t *tmp___7 ;
  uint32_t tmp___8 ;
  uint32_t *tmp___9 ;
  uint32_t tmp___10 ;
  uint32_t *tmp___11 ;
  uint32_t tmp___12 ;
  uint32_t *tmp___13 ;
  uint32_t tmp___14 ;
  uint32_t *tmp___15 ;
  uint32_t tmp___16 ;
  uint32_t *tmp___17 ;
  uint32_t tmp___18 ;
  uint32_t *tmp___19 ;
  uint32_t tmp___20 ;
  uint32_t *tmp___21 ;
  uint32_t tmp___22 ;
  uint32_t *tmp___23 ;
  uint32_t tmp___24 ;
  uint32_t *tmp___25 ;
  uint32_t tmp___26 ;
  uint32_t *tmp___27 ;
  uint32_t tmp___28 ;
  uint32_t *tmp___29 ;
  uint32_t tmp___30 ;

  {
#line 1120
  words = (uint32_t const   *)buffer;
#line 1121
  nwords = len / sizeof(uint32_t );
#line 1122
  endp = words + nwords;
#line 1123
  A = ctx->A;
#line 1124
  B = ctx->B;
#line 1125
  C = ctx->C;
#line 1126
  D = ctx->D;
#line 1131
  ctx->total[0] = (uint32_t )((size_t )ctx->total[0] + len);
#line 1132
  if ((size_t )ctx->total[0] < len) {
#line 1133
    (ctx->total[1]) ++;
  }
  {
#line 1137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1137
    if (! ((unsigned long )words < (unsigned long )endp)) {
#line 1137
      goto while_break;
    }
#line 1139
    cwp = correct_words;
#line 1140
    A_save = A;
#line 1141
    B_save = B;
#line 1142
    C_save = C;
#line 1143
    D_save = D;
    {
#line 1177
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1177
      tmp = cwp;
#line 1177
      cwp ++;
#line 1177
      tmp___0 = (uint32_t )*words;
#line 1177
      *tmp = tmp___0;
#line 1177
      A += ((D ^ (B & (C ^ D))) + tmp___0) + 3614090360U;
#line 1177
      words ++;
#line 1177
      A = (A << 7) | (A >> 25);
#line 1177
      A += B;
#line 1177
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1178
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1178
      tmp___1 = cwp;
#line 1178
      cwp ++;
#line 1178
      tmp___2 = (uint32_t )*words;
#line 1178
      *tmp___1 = tmp___2;
#line 1178
      D += ((C ^ (A & (B ^ C))) + tmp___2) + 3905402710U;
#line 1178
      words ++;
#line 1178
      D = (D << 12) | (D >> 20);
#line 1178
      D += A;
#line 1178
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1179
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1179
      tmp___3 = cwp;
#line 1179
      cwp ++;
#line 1179
      tmp___4 = (uint32_t )*words;
#line 1179
      *tmp___3 = tmp___4;
#line 1179
      C += ((B ^ (D & (A ^ B))) + tmp___4) + 606105819U;
#line 1179
      words ++;
#line 1179
      C = (C << 17) | (C >> 15);
#line 1179
      C += D;
#line 1179
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1180
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1180
      tmp___5 = cwp;
#line 1180
      cwp ++;
#line 1180
      tmp___6 = (uint32_t )*words;
#line 1180
      *tmp___5 = tmp___6;
#line 1180
      B += ((A ^ (C & (D ^ A))) + tmp___6) + 3250441966U;
#line 1180
      words ++;
#line 1180
      B = (B << 22) | (B >> 10);
#line 1180
      B += C;
#line 1180
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 1181
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1181
      tmp___7 = cwp;
#line 1181
      cwp ++;
#line 1181
      tmp___8 = (uint32_t )*words;
#line 1181
      *tmp___7 = tmp___8;
#line 1181
      A += ((D ^ (B & (C ^ D))) + tmp___8) + 4118548399U;
#line 1181
      words ++;
#line 1181
      A = (A << 7) | (A >> 25);
#line 1181
      A += B;
#line 1181
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 1182
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1182
      tmp___9 = cwp;
#line 1182
      cwp ++;
#line 1182
      tmp___10 = (uint32_t )*words;
#line 1182
      *tmp___9 = tmp___10;
#line 1182
      D += ((C ^ (A & (B ^ C))) + tmp___10) + 1200080426U;
#line 1182
      words ++;
#line 1182
      D = (D << 12) | (D >> 20);
#line 1182
      D += A;
#line 1182
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 1183
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1183
      tmp___11 = cwp;
#line 1183
      cwp ++;
#line 1183
      tmp___12 = (uint32_t )*words;
#line 1183
      *tmp___11 = tmp___12;
#line 1183
      C += ((B ^ (D & (A ^ B))) + tmp___12) + 2821735955U;
#line 1183
      words ++;
#line 1183
      C = (C << 17) | (C >> 15);
#line 1183
      C += D;
#line 1183
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 1184
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1184
      tmp___13 = cwp;
#line 1184
      cwp ++;
#line 1184
      tmp___14 = (uint32_t )*words;
#line 1184
      *tmp___13 = tmp___14;
#line 1184
      B += ((A ^ (C & (D ^ A))) + tmp___14) + 4249261313U;
#line 1184
      words ++;
#line 1184
      B = (B << 22) | (B >> 10);
#line 1184
      B += C;
#line 1184
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 1185
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1185
      tmp___15 = cwp;
#line 1185
      cwp ++;
#line 1185
      tmp___16 = (uint32_t )*words;
#line 1185
      *tmp___15 = tmp___16;
#line 1185
      A += ((D ^ (B & (C ^ D))) + tmp___16) + 1770035416U;
#line 1185
      words ++;
#line 1185
      A = (A << 7) | (A >> 25);
#line 1185
      A += B;
#line 1185
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 1186
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 1186
      tmp___17 = cwp;
#line 1186
      cwp ++;
#line 1186
      tmp___18 = (uint32_t )*words;
#line 1186
      *tmp___17 = tmp___18;
#line 1186
      D += ((C ^ (A & (B ^ C))) + tmp___18) + 2336552879U;
#line 1186
      words ++;
#line 1186
      D = (D << 12) | (D >> 20);
#line 1186
      D += A;
#line 1186
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 1187
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 1187
      tmp___19 = cwp;
#line 1187
      cwp ++;
#line 1187
      tmp___20 = (uint32_t )*words;
#line 1187
      *tmp___19 = tmp___20;
#line 1187
      C += ((B ^ (D & (A ^ B))) + tmp___20) + 4294925233U;
#line 1187
      words ++;
#line 1187
      C = (C << 17) | (C >> 15);
#line 1187
      C += D;
#line 1187
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 1188
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 1188
      tmp___21 = cwp;
#line 1188
      cwp ++;
#line 1188
      tmp___22 = (uint32_t )*words;
#line 1188
      *tmp___21 = tmp___22;
#line 1188
      B += ((A ^ (C & (D ^ A))) + tmp___22) + 2304563134U;
#line 1188
      words ++;
#line 1188
      B = (B << 22) | (B >> 10);
#line 1188
      B += C;
#line 1188
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 1189
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 1189
      tmp___23 = cwp;
#line 1189
      cwp ++;
#line 1189
      tmp___24 = (uint32_t )*words;
#line 1189
      *tmp___23 = tmp___24;
#line 1189
      A += ((D ^ (B & (C ^ D))) + tmp___24) + 1804603682U;
#line 1189
      words ++;
#line 1189
      A = (A << 7) | (A >> 25);
#line 1189
      A += B;
#line 1189
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 1190
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 1190
      tmp___25 = cwp;
#line 1190
      cwp ++;
#line 1190
      tmp___26 = (uint32_t )*words;
#line 1190
      *tmp___25 = tmp___26;
#line 1190
      D += ((C ^ (A & (B ^ C))) + tmp___26) + 4254626195U;
#line 1190
      words ++;
#line 1190
      D = (D << 12) | (D >> 20);
#line 1190
      D += A;
#line 1190
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
    {
#line 1191
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 1191
      tmp___27 = cwp;
#line 1191
      cwp ++;
#line 1191
      tmp___28 = (uint32_t )*words;
#line 1191
      *tmp___27 = tmp___28;
#line 1191
      C += ((B ^ (D & (A ^ B))) + tmp___28) + 2792965006U;
#line 1191
      words ++;
#line 1191
      C = (C << 17) | (C >> 15);
#line 1191
      C += D;
#line 1191
      goto while_break___14;
    }
    while_break___14: /* CIL Label */ ;
    }
    {
#line 1192
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 1192
      tmp___29 = cwp;
#line 1192
      cwp ++;
#line 1192
      tmp___30 = (uint32_t )*words;
#line 1192
      *tmp___29 = tmp___30;
#line 1192
      B += ((A ^ (C & (D ^ A))) + tmp___30) + 1236535329U;
#line 1192
      words ++;
#line 1192
      B = (B << 22) | (B >> 10);
#line 1192
      B += C;
#line 1192
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
    {
#line 1208
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 1208
      A += ((C ^ (D & (B ^ C))) + correct_words[1]) + 4129170786U;
#line 1208
      A = (A << 5) | (A >> 27);
#line 1208
      A += B;
#line 1208
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
    {
#line 1209
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 1209
      D += ((B ^ (C & (A ^ B))) + correct_words[6]) + 3225465664U;
#line 1209
      D = (D << 9) | (D >> 23);
#line 1209
      D += A;
#line 1209
      goto while_break___17;
    }
    while_break___17: /* CIL Label */ ;
    }
    {
#line 1210
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 1210
      C += ((A ^ (B & (D ^ A))) + correct_words[11]) + 643717713U;
#line 1210
      C = (C << 14) | (C >> 18);
#line 1210
      C += D;
#line 1210
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
    {
#line 1211
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 1211
      B += ((D ^ (A & (C ^ D))) + correct_words[0]) + 3921069994U;
#line 1211
      B = (B << 20) | (B >> 12);
#line 1211
      B += C;
#line 1211
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
    {
#line 1212
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 1212
      A += ((C ^ (D & (B ^ C))) + correct_words[5]) + 3593408605U;
#line 1212
      A = (A << 5) | (A >> 27);
#line 1212
      A += B;
#line 1212
      goto while_break___20;
    }
    while_break___20: /* CIL Label */ ;
    }
    {
#line 1213
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 1213
      D += ((B ^ (C & (A ^ B))) + correct_words[10]) + 38016083U;
#line 1213
      D = (D << 9) | (D >> 23);
#line 1213
      D += A;
#line 1213
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
    {
#line 1214
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 1214
      C += ((A ^ (B & (D ^ A))) + correct_words[15]) + 3634488961U;
#line 1214
      C = (C << 14) | (C >> 18);
#line 1214
      C += D;
#line 1214
      goto while_break___22;
    }
    while_break___22: /* CIL Label */ ;
    }
    {
#line 1215
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 1215
      B += ((D ^ (A & (C ^ D))) + correct_words[4]) + 3889429448U;
#line 1215
      B = (B << 20) | (B >> 12);
#line 1215
      B += C;
#line 1215
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
    {
#line 1216
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 1216
      A += ((C ^ (D & (B ^ C))) + correct_words[9]) + 568446438U;
#line 1216
      A = (A << 5) | (A >> 27);
#line 1216
      A += B;
#line 1216
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
    {
#line 1217
    while (1) {
      while_continue___25: /* CIL Label */ ;
#line 1217
      D += ((B ^ (C & (A ^ B))) + correct_words[14]) + 3275163606U;
#line 1217
      D = (D << 9) | (D >> 23);
#line 1217
      D += A;
#line 1217
      goto while_break___25;
    }
    while_break___25: /* CIL Label */ ;
    }
    {
#line 1218
    while (1) {
      while_continue___26: /* CIL Label */ ;
#line 1218
      C += ((A ^ (B & (D ^ A))) + correct_words[3]) + 4107603335U;
#line 1218
      C = (C << 14) | (C >> 18);
#line 1218
      C += D;
#line 1218
      goto while_break___26;
    }
    while_break___26: /* CIL Label */ ;
    }
    {
#line 1219
    while (1) {
      while_continue___27: /* CIL Label */ ;
#line 1219
      B += ((D ^ (A & (C ^ D))) + correct_words[8]) + 1163531501U;
#line 1219
      B = (B << 20) | (B >> 12);
#line 1219
      B += C;
#line 1219
      goto while_break___27;
    }
    while_break___27: /* CIL Label */ ;
    }
    {
#line 1220
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 1220
      A += ((C ^ (D & (B ^ C))) + correct_words[13]) + 2850285829U;
#line 1220
      A = (A << 5) | (A >> 27);
#line 1220
      A += B;
#line 1220
      goto while_break___28;
    }
    while_break___28: /* CIL Label */ ;
    }
    {
#line 1221
    while (1) {
      while_continue___29: /* CIL Label */ ;
#line 1221
      D += ((B ^ (C & (A ^ B))) + correct_words[2]) + 4243563512U;
#line 1221
      D = (D << 9) | (D >> 23);
#line 1221
      D += A;
#line 1221
      goto while_break___29;
    }
    while_break___29: /* CIL Label */ ;
    }
    {
#line 1222
    while (1) {
      while_continue___30: /* CIL Label */ ;
#line 1222
      C += ((A ^ (B & (D ^ A))) + correct_words[7]) + 1735328473U;
#line 1222
      C = (C << 14) | (C >> 18);
#line 1222
      C += D;
#line 1222
      goto while_break___30;
    }
    while_break___30: /* CIL Label */ ;
    }
    {
#line 1223
    while (1) {
      while_continue___31: /* CIL Label */ ;
#line 1223
      B += ((D ^ (A & (C ^ D))) + correct_words[12]) + 2368359562U;
#line 1223
      B = (B << 20) | (B >> 12);
#line 1223
      B += C;
#line 1223
      goto while_break___31;
    }
    while_break___31: /* CIL Label */ ;
    }
    {
#line 1226
    while (1) {
      while_continue___32: /* CIL Label */ ;
#line 1226
      A += (((B ^ C) ^ D) + correct_words[5]) + 4294588738U;
#line 1226
      A = (A << 4) | (A >> 28);
#line 1226
      A += B;
#line 1226
      goto while_break___32;
    }
    while_break___32: /* CIL Label */ ;
    }
    {
#line 1227
    while (1) {
      while_continue___33: /* CIL Label */ ;
#line 1227
      D += (((A ^ B) ^ C) + correct_words[8]) + 2272392833U;
#line 1227
      D = (D << 11) | (D >> 21);
#line 1227
      D += A;
#line 1227
      goto while_break___33;
    }
    while_break___33: /* CIL Label */ ;
    }
    {
#line 1228
    while (1) {
      while_continue___34: /* CIL Label */ ;
#line 1228
      C += (((D ^ A) ^ B) + correct_words[11]) + 1839030562U;
#line 1228
      C = (C << 16) | (C >> 16);
#line 1228
      C += D;
#line 1228
      goto while_break___34;
    }
    while_break___34: /* CIL Label */ ;
    }
    {
#line 1229
    while (1) {
      while_continue___35: /* CIL Label */ ;
#line 1229
      B += (((C ^ D) ^ A) + correct_words[14]) + 4259657740U;
#line 1229
      B = (B << 23) | (B >> 9);
#line 1229
      B += C;
#line 1229
      goto while_break___35;
    }
    while_break___35: /* CIL Label */ ;
    }
    {
#line 1230
    while (1) {
      while_continue___36: /* CIL Label */ ;
#line 1230
      A += (((B ^ C) ^ D) + correct_words[1]) + 2763975236U;
#line 1230
      A = (A << 4) | (A >> 28);
#line 1230
      A += B;
#line 1230
      goto while_break___36;
    }
    while_break___36: /* CIL Label */ ;
    }
    {
#line 1231
    while (1) {
      while_continue___37: /* CIL Label */ ;
#line 1231
      D += (((A ^ B) ^ C) + correct_words[4]) + 1272893353U;
#line 1231
      D = (D << 11) | (D >> 21);
#line 1231
      D += A;
#line 1231
      goto while_break___37;
    }
    while_break___37: /* CIL Label */ ;
    }
    {
#line 1232
    while (1) {
      while_continue___38: /* CIL Label */ ;
#line 1232
      C += (((D ^ A) ^ B) + correct_words[7]) + 4139469664U;
#line 1232
      C = (C << 16) | (C >> 16);
#line 1232
      C += D;
#line 1232
      goto while_break___38;
    }
    while_break___38: /* CIL Label */ ;
    }
    {
#line 1233
    while (1) {
      while_continue___39: /* CIL Label */ ;
#line 1233
      B += (((C ^ D) ^ A) + correct_words[10]) + 3200236656U;
#line 1233
      B = (B << 23) | (B >> 9);
#line 1233
      B += C;
#line 1233
      goto while_break___39;
    }
    while_break___39: /* CIL Label */ ;
    }
    {
#line 1234
    while (1) {
      while_continue___40: /* CIL Label */ ;
#line 1234
      A += (((B ^ C) ^ D) + correct_words[13]) + 681279174U;
#line 1234
      A = (A << 4) | (A >> 28);
#line 1234
      A += B;
#line 1234
      goto while_break___40;
    }
    while_break___40: /* CIL Label */ ;
    }
    {
#line 1235
    while (1) {
      while_continue___41: /* CIL Label */ ;
#line 1235
      D += (((A ^ B) ^ C) + correct_words[0]) + 3936430074U;
#line 1235
      D = (D << 11) | (D >> 21);
#line 1235
      D += A;
#line 1235
      goto while_break___41;
    }
    while_break___41: /* CIL Label */ ;
    }
    {
#line 1236
    while (1) {
      while_continue___42: /* CIL Label */ ;
#line 1236
      C += (((D ^ A) ^ B) + correct_words[3]) + 3572445317U;
#line 1236
      C = (C << 16) | (C >> 16);
#line 1236
      C += D;
#line 1236
      goto while_break___42;
    }
    while_break___42: /* CIL Label */ ;
    }
    {
#line 1237
    while (1) {
      while_continue___43: /* CIL Label */ ;
#line 1237
      B += (((C ^ D) ^ A) + correct_words[6]) + 76029189U;
#line 1237
      B = (B << 23) | (B >> 9);
#line 1237
      B += C;
#line 1237
      goto while_break___43;
    }
    while_break___43: /* CIL Label */ ;
    }
    {
#line 1238
    while (1) {
      while_continue___44: /* CIL Label */ ;
#line 1238
      A += (((B ^ C) ^ D) + correct_words[9]) + 3654602809U;
#line 1238
      A = (A << 4) | (A >> 28);
#line 1238
      A += B;
#line 1238
      goto while_break___44;
    }
    while_break___44: /* CIL Label */ ;
    }
    {
#line 1239
    while (1) {
      while_continue___45: /* CIL Label */ ;
#line 1239
      D += (((A ^ B) ^ C) + correct_words[12]) + 3873151461U;
#line 1239
      D = (D << 11) | (D >> 21);
#line 1239
      D += A;
#line 1239
      goto while_break___45;
    }
    while_break___45: /* CIL Label */ ;
    }
    {
#line 1240
    while (1) {
      while_continue___46: /* CIL Label */ ;
#line 1240
      C += (((D ^ A) ^ B) + correct_words[15]) + 530742520U;
#line 1240
      C = (C << 16) | (C >> 16);
#line 1240
      C += D;
#line 1240
      goto while_break___46;
    }
    while_break___46: /* CIL Label */ ;
    }
    {
#line 1241
    while (1) {
      while_continue___47: /* CIL Label */ ;
#line 1241
      B += (((C ^ D) ^ A) + correct_words[2]) + 3299628645U;
#line 1241
      B = (B << 23) | (B >> 9);
#line 1241
      B += C;
#line 1241
      goto while_break___47;
    }
    while_break___47: /* CIL Label */ ;
    }
    {
#line 1244
    while (1) {
      while_continue___48: /* CIL Label */ ;
#line 1244
      A += ((C ^ (B | ~ D)) + correct_words[0]) + 4096336452U;
#line 1244
      A = (A << 6) | (A >> 26);
#line 1244
      A += B;
#line 1244
      goto while_break___48;
    }
    while_break___48: /* CIL Label */ ;
    }
    {
#line 1245
    while (1) {
      while_continue___49: /* CIL Label */ ;
#line 1245
      D += ((B ^ (A | ~ C)) + correct_words[7]) + 1126891415U;
#line 1245
      D = (D << 10) | (D >> 22);
#line 1245
      D += A;
#line 1245
      goto while_break___49;
    }
    while_break___49: /* CIL Label */ ;
    }
    {
#line 1246
    while (1) {
      while_continue___50: /* CIL Label */ ;
#line 1246
      C += ((A ^ (D | ~ B)) + correct_words[14]) + 2878612391U;
#line 1246
      C = (C << 15) | (C >> 17);
#line 1246
      C += D;
#line 1246
      goto while_break___50;
    }
    while_break___50: /* CIL Label */ ;
    }
    {
#line 1247
    while (1) {
      while_continue___51: /* CIL Label */ ;
#line 1247
      B += ((D ^ (C | ~ A)) + correct_words[5]) + 4237533241U;
#line 1247
      B = (B << 21) | (B >> 11);
#line 1247
      B += C;
#line 1247
      goto while_break___51;
    }
    while_break___51: /* CIL Label */ ;
    }
    {
#line 1248
    while (1) {
      while_continue___52: /* CIL Label */ ;
#line 1248
      A += ((C ^ (B | ~ D)) + correct_words[12]) + 1700485571U;
#line 1248
      A = (A << 6) | (A >> 26);
#line 1248
      A += B;
#line 1248
      goto while_break___52;
    }
    while_break___52: /* CIL Label */ ;
    }
    {
#line 1249
    while (1) {
      while_continue___53: /* CIL Label */ ;
#line 1249
      D += ((B ^ (A | ~ C)) + correct_words[3]) + 2399980690U;
#line 1249
      D = (D << 10) | (D >> 22);
#line 1249
      D += A;
#line 1249
      goto while_break___53;
    }
    while_break___53: /* CIL Label */ ;
    }
    {
#line 1250
    while (1) {
      while_continue___54: /* CIL Label */ ;
#line 1250
      C += ((A ^ (D | ~ B)) + correct_words[10]) + 4293915773U;
#line 1250
      C = (C << 15) | (C >> 17);
#line 1250
      C += D;
#line 1250
      goto while_break___54;
    }
    while_break___54: /* CIL Label */ ;
    }
    {
#line 1251
    while (1) {
      while_continue___55: /* CIL Label */ ;
#line 1251
      B += ((D ^ (C | ~ A)) + correct_words[1]) + 2240044497U;
#line 1251
      B = (B << 21) | (B >> 11);
#line 1251
      B += C;
#line 1251
      goto while_break___55;
    }
    while_break___55: /* CIL Label */ ;
    }
    {
#line 1252
    while (1) {
      while_continue___56: /* CIL Label */ ;
#line 1252
      A += ((C ^ (B | ~ D)) + correct_words[8]) + 1873313359U;
#line 1252
      A = (A << 6) | (A >> 26);
#line 1252
      A += B;
#line 1252
      goto while_break___56;
    }
    while_break___56: /* CIL Label */ ;
    }
    {
#line 1253
    while (1) {
      while_continue___57: /* CIL Label */ ;
#line 1253
      D += ((B ^ (A | ~ C)) + correct_words[15]) + 4264355552U;
#line 1253
      D = (D << 10) | (D >> 22);
#line 1253
      D += A;
#line 1253
      goto while_break___57;
    }
    while_break___57: /* CIL Label */ ;
    }
    {
#line 1254
    while (1) {
      while_continue___58: /* CIL Label */ ;
#line 1254
      C += ((A ^ (D | ~ B)) + correct_words[6]) + 2734768916U;
#line 1254
      C = (C << 15) | (C >> 17);
#line 1254
      C += D;
#line 1254
      goto while_break___58;
    }
    while_break___58: /* CIL Label */ ;
    }
    {
#line 1255
    while (1) {
      while_continue___59: /* CIL Label */ ;
#line 1255
      B += ((D ^ (C | ~ A)) + correct_words[13]) + 1309151649U;
#line 1255
      B = (B << 21) | (B >> 11);
#line 1255
      B += C;
#line 1255
      goto while_break___59;
    }
    while_break___59: /* CIL Label */ ;
    }
    {
#line 1256
    while (1) {
      while_continue___60: /* CIL Label */ ;
#line 1256
      A += ((C ^ (B | ~ D)) + correct_words[4]) + 4149444226U;
#line 1256
      A = (A << 6) | (A >> 26);
#line 1256
      A += B;
#line 1256
      goto while_break___60;
    }
    while_break___60: /* CIL Label */ ;
    }
    {
#line 1257
    while (1) {
      while_continue___61: /* CIL Label */ ;
#line 1257
      D += ((B ^ (A | ~ C)) + correct_words[11]) + 3174756917U;
#line 1257
      D = (D << 10) | (D >> 22);
#line 1257
      D += A;
#line 1257
      goto while_break___61;
    }
    while_break___61: /* CIL Label */ ;
    }
    {
#line 1258
    while (1) {
      while_continue___62: /* CIL Label */ ;
#line 1258
      C += ((A ^ (D | ~ B)) + correct_words[2]) + 718787259U;
#line 1258
      C = (C << 15) | (C >> 17);
#line 1258
      C += D;
#line 1258
      goto while_break___62;
    }
    while_break___62: /* CIL Label */ ;
    }
    {
#line 1259
    while (1) {
      while_continue___63: /* CIL Label */ ;
#line 1259
      B += ((D ^ (C | ~ A)) + correct_words[9]) + 3951481745U;
#line 1259
      B = (B << 21) | (B >> 11);
#line 1259
      B += C;
#line 1259
      goto while_break___63;
    }
    while_break___63: /* CIL Label */ ;
    }
#line 1262
    A += A_save;
#line 1263
    B += B_save;
#line 1264
    C += C_save;
#line 1265
    D += D_save;
  }
  while_break: /* CIL Label */ ;
  }
#line 1269
  ctx->A = A;
#line 1270
  ctx->B = B;
#line 1271
  ctx->C = C;
#line 1272
  ctx->D = D;
#line 1273
  return;
}
}
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 312 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 243 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 244 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
#line 261
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 286
extern  __attribute__((__nothrow__)) pthread_t ( __attribute__((__leaf__)) pthread_self)(void)  __attribute__((__const__)) ;
#line 298
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_init)(pthread_attr_t *__attr ) ;
#line 301
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_destroy)(pthread_attr_t *__attr ) ;
#line 321
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setguardsize)(pthread_attr_t *__attr ,
                                                                                                                size_t __guardsize ) ;
#line 386
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setstacksize)(pthread_attr_t *__attr ,
                                                                                                                size_t __stacksize ) ;
#line 773
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
#line 784
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 170
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 53 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 681
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
#line 700
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 717
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts )  __asm__("__posix_getopt")  ;
#line 879 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *name ,
                                                                                                  size_t len ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 150
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 187
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 324
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srandom)(unsigned int __seed ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *src )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 285
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 359
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2,3), __leaf__)) strtok_r)(char * __restrict  __s ,
                                                                                                   char const   * __restrict  __delim ,
                                                                                                   char ** __restrict  __save_ptr ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 116 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 181 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 66 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 56 "/usr/include/fnmatch.h"
extern int fnmatch(char const   *__pattern , char const   *__name , int __flags ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/socket.h"
int so_resolv(struct in_addr *host , char const   *name ) ;
#line 40
int so_listen(int port , struct in_addr source ) ;
#line 112 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.h"
void myexit(int rc ) ;
#line 113
void croak(char const   *msg , int console ) ;
#line 115
plist_t plist_add(plist_t list , unsigned long key , void *aux ) ;
#line 117
int plist_in(plist_t list , unsigned long key ) ;
#line 119
char *plist_get(plist_t list , int key ) ;
#line 122
plist_t plist_free(plist_t list ) ;
#line 124
hlist_t hlist_add(hlist_t list , char *key , char *value , hlist_add_t allockey ,
                  hlist_add_t allocvalue ) ;
#line 128
int hlist_in(hlist_t list , char const   *key ) ;
#line 129
int hlist_count(hlist_t list ) ;
#line 130
char *hlist_get(hlist_t list , char const   *key ) ;
#line 131
int hlist_subcmp(hlist_t list , char const   *key , char const   *substr___0 ) ;
#line 133
hlist_t hlist_free(hlist_t list ) ;
#line 136
char *substr(char const   *src , int pos , int len ) ;
#line 137
size_t strlcpy(char *dst , char const   *src , size_t siz ) ;
#line 138
size_t strlcat(char *dst , char const   *src , size_t siz ) ;
#line 143
char *new(size_t size ) ;
#line 146
rr_data_t new_rr_data(void) ;
#line 150
void free_rr_data(rr_data_t data ) ;
#line 152
char *printmem(char *src , size_t len , int bitwidth ) ;
#line 153
char *scanmem(char *src , int bitwidth ) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/auth.h"
struct auth_s *new_auth(void) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/ntlm.h"
char *ntlm_hash_lm_password(char *password ) ;
#line 32
char *ntlm_hash_nt_password(char *password ) ;
#line 33
char *ntlm2_hash_password(char *username , char *domain , char *password ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/config.h"
config_t config_open(char const   *fname ) ;
#line 39
char *config_pop(config_t cf , char const   *option ) ;
#line 41
void config_close(config_t cf ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/acl.h"
int acl_add(plist_t *rules , char *spec , enum acl_t acl ) ;
#line 43
enum acl_t acl_check(plist_t rules , struct in_addr naddr ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/http.h"
int is_http_header(char const   *src ) ;
#line 40
char *get_http_header_name(char const   *src ) ;
#line 41
char *get_http_header_value(char const   *src ) ;
#line 43
int headers_recv(int fd , rr_data_t data ) ;
#line 45
int tunnel(int cd , int sd ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/globals.h"
int debug ;
#line 35
struct auth_s *g_creds ;
#line 37
int ntlmbasic ;
#line 38
int serialize ;
#line 39
int scanner_plugin ;
#line 40
long scanner_plugin_maxsize ;
#line 42
plist_t threads_list ;
#line 43
pthread_mutex_t threads_mtx ;
#line 45
plist_t connection_list ;
#line 46
pthread_mutex_t connection_mtx ;
#line 48
int parent_count ;
#line 49
plist_t parent_list ;
#line 62
hlist_t header_list ;
#line 63
hlist_t users_list ;
#line 64
plist_t scanner_agent_list ;
#line 65
plist_t noproxy_list ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/pages.h"
char *gen_denied_page(char const   *ip ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/forward.h"
int proxy_connect(struct auth_s *credentials ) ;
#line 28
int prepare_http_connect(int sd , struct auth_s *credentials , char const   *thost ) ;
#line 29
rr_data_t forward_request(void *thread_data , rr_data_t request ) ;
#line 30
void forward_tunnel(void *thread_data ) ;
#line 31
void magic_auth_detect(char const   *url ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/direct.h"
int host_connect(char const   *hostname , int port ) ;
#line 26
rr_data_t direct_request(void *cdata , rr_data_t request ) ;
#line 27
void direct_tunnel(void *thread_data ) ;
#line 70 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/main.c"
int debug  =    0;
#line 72 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/main.c"
struct auth_s *g_creds  =    (struct auth_s *)((void *)0);
#line 74 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/main.c"
int quit  =    0;
#line 75 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/main.c"
int ntlmbasic  =    0;
#line 76 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/main.c"
int serialize  =    0;
#line 77 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/main.c"
int scanner_plugin  =    0;
#line 78 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/main.c"
long scanner_plugin_maxsize  =    0L;
#line 84 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/main.c"
plist_t threads_list  =    (plist_t )((void *)0);
#line 85 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/main.c"
pthread_mutex_t threads_mtx  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 90 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/main.c"
plist_t connection_list  =    (plist_t )((void *)0);
#line 91 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/main.c"
pthread_mutex_t connection_mtx  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 96 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/main.c"
int parent_count  =    0;
#line 97 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/main.c"
plist_t parent_list  =    (plist_t )((void *)0);
#line 103 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/main.c"
hlist_t header_list  =    (hlist_t )((void *)0);
#line 104 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/main.c"
hlist_t users_list  =    (hlist_t )((void *)0);
#line 105 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/main.c"
plist_t scanner_agent_list  =    (plist_t )((void *)0);
#line 106 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/main.c"
plist_t noproxy_list  =    (plist_t )((void *)0);
#line 111 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/main.c"
void sighandler(int p ) 
{ 
  int tmp ;

  {
#line 112
  if (! quit) {
    {
#line 113
    syslog(6, "Signal %d received, issuing clean shutdown\n", p);
    }
  } else {
    {
#line 115
    syslog(6, "Signal %d received, forcing shutdown\n", p);
    }
  }
#line 117
  tmp = quit;
#line 117
  quit ++;
#line 117
  if (tmp) {
#line 118
    quit ++;
  } else
#line 117
  if (debug) {
#line 118
    quit ++;
  }
#line 119
  return;
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/main.c"
int parent_add(char *parent , int port ) 
{ 
  int len ;
  int i ;
  char *proxy ;
  proxy_t *aux ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 132
  proxy = strdup((char const   *)parent);
#line 133
  tmp = strlen((char const   *)proxy);
#line 133
  len = (int )tmp;
#line 134
  tmp___0 = strcspn((char const   *)proxy, ": ");
#line 134
  i = (int )tmp___0;
  }
#line 135
  if (i != len) {
#line 136
    tmp___1 = i;
#line 136
    i ++;
#line 136
    *(proxy + tmp___1) = (char)0;
    {
#line 137
    while (1) {
      while_continue: /* CIL Label */ ;
#line 137
      if (i < len) {
#line 137
        if (! ((int )*(proxy + i) == 32)) {
#line 137
          if (! ((int )*(proxy + i) == 9)) {
#line 137
            goto while_break;
          }
        }
      } else {
#line 137
        goto while_break;
      }
#line 138
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 140
    if (i >= len) {
      {
#line 141
      free((void *)proxy);
      }
#line 142
      return (0);
    }
    {
#line 145
    port = atoi((char const   *)(proxy + i));
    }
  }
#line 151
  if (! port) {
    {
#line 152
    syslog(3, "Invalid proxy specification %s.\n", parent);
#line 153
    free((void *)proxy);
#line 154
    myexit(1);
    }
  }
  {
#line 169
  tmp___2 = new(sizeof(proxy_t ));
#line 169
  aux = (proxy_t *)tmp___2;
#line 170
  strlcpy(aux->hostname, (char const   *)proxy, sizeof(aux->hostname));
#line 171
  aux->port = port;
#line 172
  aux->resolved = 0;
#line 173
  parent_count ++;
#line 173
  parent_list = plist_add(parent_list, (unsigned long )parent_count, (void *)((char *)aux));
#line 175
  free((void *)proxy);
  }
#line 176
  return (1);
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/main.c"
void listen_add(char const   *service , plist_t *list , char *spec , int gateway ) 
{ 
  struct in_addr source ;
  int i ;
  int p ;
  int len ;
  int port ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  in_addr_t tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 187
  tmp___0 = strlen((char const   *)spec);
#line 187
  len = (int )tmp___0;
#line 188
  tmp___1 = strcspn((char const   *)spec, ":");
#line 188
  p = (int )tmp___1;
  }
#line 189
  if (p < len - 1) {
    {
#line 190
    tmp = substr((char const   *)spec, 0, p);
#line 191
    tmp___2 = so_resolv(& source, (char const   *)tmp);
    }
#line 191
    if (! tmp___2) {
      {
#line 192
      syslog(3, "Cannot resolve listen address %s\n", tmp);
#line 193
      myexit(1);
      }
    }
    {
#line 195
    free((void *)tmp);
#line 196
    tmp = (spec + p) + 1;
#line 196
    port = atoi((char const   *)tmp);
    }
  } else {
#line 198
    if (gateway) {
#line 198
      tmp___3 = (in_addr_t )0;
    } else {
#line 198
      tmp___3 = (in_addr_t )2130706433;
    }
    {
#line 198
    source.s_addr = htonl(tmp___3);
#line 199
    tmp = spec;
#line 199
    port = atoi((char const   *)tmp);
    }
  }
#line 202
  if (! port) {
    {
#line 203
    syslog(3, "Invalid listen port %s.\n", tmp);
#line 204
    myexit(1);
    }
  }
  {
#line 207
  i = so_listen(port, source);
  }
#line 208
  if (i > 0) {
    {
#line 209
    *list = plist_add(*list, (unsigned long )i, (void *)0);
#line 210
    tmp___4 = inet_ntoa(source);
#line 210
    syslog(6, "%s listening on %s:%d\n", service, tmp___4, port);
    }
  }
#line 212
  return;
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/main.c"
void tunnel_add(plist_t *list , char *spec , int gateway ) 
{ 
  struct in_addr source ;
  int i ;
  int len ;
  int count ;
  int pos ;
  int port ;
  char *field[4] ;
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  in_addr_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;

  {
  {
#line 223
  spec = strdup((char const   *)spec);
#line 224
  tmp___0 = strlen((char const   *)spec);
#line 224
  len = (int )tmp___0;
#line 225
  field[0] = spec;
#line 226
  count = 1;
#line 226
  i = 0;
  }
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 226
    if (count < 4) {
#line 226
      if (! (i < len)) {
#line 226
        goto while_break;
      }
    } else {
#line 226
      goto while_break;
    }
#line 227
    if ((int )*(spec + i) == 58) {
#line 228
      *(spec + i) = (char)0;
#line 229
      tmp___1 = count;
#line 229
      count ++;
#line 229
      field[tmp___1] = (spec + i) + 1;
    }
#line 226
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 232
  pos = 0;
#line 233
  if (count == 4) {
    {
#line 234
    tmp___2 = so_resolv(& source, (char const   *)field[pos]);
    }
#line 234
    if (! tmp___2) {
      {
#line 235
      syslog(3, "Cannot resolve tunel bind address: %s\n", field[pos]);
#line 236
      myexit(1);
      }
    }
#line 238
    pos ++;
  } else {
#line 240
    if (gateway) {
#line 240
      tmp___3 = (in_addr_t )0;
    } else {
#line 240
      tmp___3 = (in_addr_t )2130706433;
    }
    {
#line 240
    source.s_addr = htonl(tmp___3);
    }
  }
#line 242
  if (count - pos == 3) {
    {
#line 243
    port = atoi((char const   *)field[pos]);
    }
#line 244
    if (port == 0) {
      {
#line 245
      syslog(3, "Invalid tunnel local port: %s\n", field[pos]);
#line 246
      myexit(1);
      }
    }
    {
#line 249
    tmp___4 = strlen((char const   *)field[pos + 1]);
    }
#line 249
    if (tmp___4) {
      {
#line 249
      tmp___5 = strlen((char const   *)field[pos + 2]);
      }
#line 249
      if (! tmp___5) {
        {
#line 250
        syslog(3, "Invalid tunnel target: %s:%s\n", field[pos + 1], field[pos + 2]);
#line 251
        myexit(1);
        }
      }
    } else {
      {
#line 250
      syslog(3, "Invalid tunnel target: %s:%s\n", field[pos + 1], field[pos + 2]);
#line 251
      myexit(1);
      }
    }
    {
#line 254
    tmp___6 = strlen((char const   *)field[pos + 1]);
#line 254
    tmp___7 = strlen((char const   *)field[pos + 2]);
#line 254
    tmp = new(((tmp___6 + tmp___7) + 2UL) + 1UL);
#line 255
    strcpy((char */* __restrict  */)tmp, (char const   */* __restrict  */)field[pos + 1]);
#line 256
    strcat((char */* __restrict  */)tmp, (char const   */* __restrict  */)":");
#line 257
    strcat((char */* __restrict  */)tmp, (char const   */* __restrict  */)field[pos + 2]);
#line 259
    i = so_listen(port, source);
    }
#line 260
    if (i > 0) {
      {
#line 261
      *list = plist_add(*list, (unsigned long )i, (void *)tmp);
#line 262
      tmp___8 = inet_ntoa(source);
#line 262
      syslog(6, "New tunnel from %s:%d to %s\n", tmp___8, port, tmp);
      }
    } else {
      {
#line 264
      free((void *)tmp);
      }
    }
  } else {
    {
#line 266
    printf((char const   */* __restrict  */)"Tunnel specification incorrect ([laddress:]lport:rserver:rport).\n");
#line 267
    myexit(1);
    }
  }
  {
#line 270
  free((void *)spec);
  }
#line 271
  return;
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/main.c"
plist_t noproxy_add(plist_t list , char *spec ) 
{ 
  char *tok ;
  char *save ;
  char *tmp ;

  {
  {
#line 279
  tok = strtok_r((char */* __restrict  */)spec, (char const   */* __restrict  */)", ",
                 (char **/* __restrict  */)(& save));
  }
  {
#line 280
  while (1) {
    while_continue: /* CIL Label */ ;
#line 280
    if (! ((unsigned long )tok != (unsigned long )((void *)0))) {
#line 280
      goto while_break;
    }
#line 281
    if (debug) {
      {
#line 282
      printf((char const   */* __restrict  */)"Adding no-proxy for: \'%s\'\n", tok);
      }
    }
    {
#line 283
    tmp = strdup((char const   *)tok);
#line 283
    list = plist_add(list, 0UL, (void *)tmp);
#line 284
    tok = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)", ",
                   (char **/* __restrict  */)(& save));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 287
  return (list);
}
}
#line 290 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/main.c"
int noproxy_match(char const   *addr ) 
{ 
  plist_t list ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 293
  list = noproxy_list;
  {
#line 294
  while (1) {
    while_continue: /* CIL Label */ ;
#line 294
    if (! list) {
#line 294
      goto while_break;
    }
#line 295
    if (list->aux) {
      {
#line 295
      tmp = strlen((char const   *)list->aux);
      }
#line 295
      if (tmp) {
        {
#line 295
        tmp___0 = fnmatch((char const   *)list->aux, addr, 0);
        }
#line 295
        if (tmp___0 == 0) {
#line 297
          if (debug) {
            {
#line 298
            printf((char const   */* __restrict  */)"MATCH: %s (%s)\n", addr, (char *)list->aux);
            }
          }
#line 299
          return (1);
        } else {
#line 295
          goto _L___0;
        }
      } else {
#line 295
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 300
    if (debug) {
      {
#line 301
      printf((char const   */* __restrict  */)"   NO: %s (%s)\n", addr, (char *)list->aux);
      }
    }
#line 303
    list = list->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  return (0);
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/main.c"
void *proxy_thread(void *thread_data ) 
{ 
  rr_data_t request ;
  rr_data_t ret ;
  int keep_alive ;
  int cd ;
  int tmp ;
  int tmp___0 ;
  pthread_t tmp___1 ;

  {
#line 316
  cd = ((struct thread_arg_s *)thread_data)->fd;
  {
#line 318
  while (1) {
    while_continue: /* CIL Label */ ;
#line 319
    ret = (rr_data_t )((void *)0);
#line 320
    keep_alive = 0;
#line 322
    if (debug) {
      {
#line 323
      printf((char const   */* __restrict  */)"\n******* Round 1 C: %d *******\n",
             cd);
#line 324
      printf((char const   */* __restrict  */)"Reading headers (%d)...\n", cd);
      }
    }
    {
#line 327
    request = new_rr_data();
#line 328
    tmp = headers_recv(cd, request);
    }
#line 328
    if (! tmp) {
      {
#line 329
      free_rr_data(request);
      }
#line 330
      goto while_break;
    }
    {
#line 333
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 337
      if (ret) {
        {
#line 338
        free_rr_data(request);
#line 339
        request = ret;
        }
      }
      {
#line 342
      keep_alive = hlist_subcmp(request->headers, "Proxy-Connection", "keep-alive");
#line 344
      tmp___0 = noproxy_match((char const   *)request->hostname);
      }
#line 344
      if (tmp___0) {
        {
#line 345
        ret = direct_request(thread_data, request);
        }
      } else {
        {
#line 347
        ret = forward_request(thread_data, request);
        }
      }
#line 349
      if (debug) {
        {
#line 350
        printf((char const   */* __restrict  */)"proxy_thread: request rc = %p\n",
               (void *)ret);
        }
      }
#line 333
      if ((unsigned long )ret != (unsigned long )((void *)0)) {
#line 333
        if (! ((unsigned long )ret != (unsigned long )((void *)-1))) {
#line 333
          goto while_break___0;
        }
      } else {
#line 333
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 353
    free_rr_data(request);
    }
#line 318
    if (keep_alive) {
#line 318
      if ((unsigned long )ret != (unsigned long )((void *)-1)) {
#line 318
        if (! (! serialize)) {
#line 318
          goto while_break;
        }
      } else {
#line 318
        goto while_break;
      }
    } else {
#line 318
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 363
  if (! serialize) {
    {
#line 364
    pthread_mutex_lock(& threads_mtx);
#line 365
    tmp___1 = pthread_self();
#line 365
    threads_list = plist_add(threads_list, tmp___1, (void *)0);
#line 366
    pthread_mutex_unlock(& threads_mtx);
    }
  }
  {
#line 369
  free(thread_data);
#line 370
  close(cd);
  }
#line 372
  return ((void *)0);
}
}
#line 380 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/main.c"
void *tunnel_thread(void *thread_data ) 
{ 
  char *hostname ;
  char *pos ;
  char *thost ;
  int tmp ;
  pthread_t tmp___0 ;

  {
  {
#line 382
  thost = ((struct thread_arg_s *)thread_data)->target;
#line 384
  hostname = strdup((char const   *)thost);
#line 385
  pos = strchr((char const   *)hostname, ':');
  }
#line 385
  if ((unsigned long )pos != (unsigned long )((void *)0)) {
#line 386
    *pos = (char)0;
  }
  {
#line 388
  tmp = noproxy_match((char const   *)hostname);
  }
#line 388
  if (tmp) {
    {
#line 389
    direct_tunnel(thread_data);
    }
  } else {
    {
#line 391
    forward_tunnel(thread_data);
    }
  }
  {
#line 393
  free((void *)hostname);
#line 394
  free(thread_data);
#line 399
  pthread_mutex_lock(& threads_mtx);
#line 400
  tmp___0 = pthread_self();
#line 400
  threads_list = plist_add(threads_list, tmp___0, (void *)0);
#line 401
  pthread_mutex_unlock(& threads_mtx);
  }
#line 403
  return ((void *)0);
}
}
#line 409 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/main.c"
void *socks5_thread(void *thread_data ) 
{ 
  char *tmp ;
  char *thost ;
  char *tport ;
  char *uname ;
  char *upass ;
  unsigned short port ;
  int ver ;
  int r ;
  int c ;
  int i ;
  int w ;
  struct auth_s *tcreds ;
  unsigned char *bs ;
  unsigned char *auths ;
  unsigned char *addr ;
  int found ;
  int sd ;
  int open___0 ;
  int tmp___0 ;
  int tmp___1 ;
  int cd ;
  struct sockaddr_in caddr ;
  char *tmp___2 ;
  ssize_t tmp___3 ;
  char *tmp___4 ;
  ssize_t tmp___5 ;
  ssize_t tmp___6 ;
  ssize_t tmp___7 ;
  ssize_t tmp___8 ;
  ssize_t tmp___9 ;
  ssize_t tmp___10 ;
  ssize_t tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  ssize_t tmp___14 ;
  ssize_t tmp___15 ;
  ssize_t tmp___16 ;
  ssize_t tmp___17 ;
  char *tmp___18 ;
  ssize_t tmp___19 ;
  ssize_t tmp___20 ;
  uint16_t tmp___21 ;
  uint16_t tmp___22 ;
  int tmp___23 ;
  ssize_t tmp___24 ;
  ssize_t tmp___25 ;
  char *tmp___26 ;

  {
  {
#line 414
  tcreds = (struct auth_s *)((void *)0);
#line 415
  bs = (unsigned char *)((void *)0);
#line 415
  auths = (unsigned char *)((void *)0);
#line 415
  addr = (unsigned char *)((void *)0);
#line 416
  found = -1;
#line 417
  sd = -1;
#line 418
  tmp___0 = hlist_count(users_list);
  }
#line 418
  if (tmp___0) {
#line 418
    tmp___1 = 0;
  } else {
#line 418
    tmp___1 = 1;
  }
  {
#line 418
  open___0 = tmp___1;
#line 420
  cd = ((struct thread_arg_s *)thread_data)->fd;
#line 421
  caddr = ((struct thread_arg_s *)thread_data)->addr;
#line 422
  free(thread_data);
#line 427
  tmp___2 = new((size_t )10);
#line 427
  bs = (unsigned char *)tmp___2;
#line 428
  thost = new((size_t )50);
#line 429
  tport = new((size_t )50);
#line 430
  tmp___3 = read(cd, (void *)bs, (size_t )2);
#line 430
  r = (int )tmp___3;
  }
#line 431
  if (r != 2) {
#line 432
    goto bailout;
  } else
#line 431
  if ((int )*(bs + 0) != 5) {
#line 432
    goto bailout;
  }
  {
#line 437
  c = (int )*(bs + 1);
#line 438
  tmp___4 = new((size_t )(c + 1));
#line 438
  auths = (unsigned char *)tmp___4;
#line 439
  tmp___5 = read(cd, (void *)auths, (size_t )c);
#line 439
  r = (int )tmp___5;
  }
#line 440
  if (r != c) {
#line 441
    goto bailout;
  }
#line 446
  if (open___0) {
#line 447
    i = 0;
    {
#line 447
    while (1) {
      while_continue: /* CIL Label */ ;
#line 447
      if (i < c) {
#line 447
        if (! *(auths + i)) {
#line 447
          found = 0;
#line 447
          if (! found) {
#line 447
            goto while_break;
          }
        }
      } else {
#line 447
        goto while_break;
      }
#line 447
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 453
  if (found < 0) {
#line 454
    i = 0;
    {
#line 454
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 454
      if (i < c) {
#line 454
        if (! ((int )*(auths + i) != 2)) {
#line 454
          found = 2;
#line 454
          if (found) {
#line 454
            goto while_break___0;
          }
        }
      } else {
#line 454
        goto while_break___0;
      }
#line 454
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 461
  if (found < 0) {
    {
#line 462
    *(bs + 0) = (unsigned char)5;
#line 463
    *(bs + 1) = (unsigned char)255;
#line 464
    tmp___6 = write(cd, (void const   *)bs, (size_t )2);
#line 464
    w = (int )tmp___6;
    }
#line 465
    goto bailout;
  } else {
    {
#line 467
    *(bs + 0) = (unsigned char)5;
#line 468
    *(bs + 1) = (unsigned char )found;
#line 469
    tmp___7 = write(cd, (void const   *)bs, (size_t )2);
#line 469
    w = (int )tmp___7;
    }
  }
#line 475
  if (found != 0) {
    {
#line 479
    tmp___8 = read(cd, (void *)bs, (size_t )2);
#line 479
    r = (int )tmp___8;
    }
#line 480
    if (r != 2) {
      {
#line 481
      *(bs + 0) = (unsigned char)1;
#line 482
      *(bs + 1) = (unsigned char)255;
#line 483
      tmp___9 = write(cd, (void const   *)bs, (size_t )2);
#line 483
      w = (int )tmp___9;
      }
#line 484
      goto bailout;
    }
    {
#line 486
    c = (int )*(bs + 1);
#line 491
    uname = new((size_t )(c + 1));
#line 492
    tmp___10 = read(cd, (void *)uname, (size_t )(c + 1));
#line 492
    r = (int )tmp___10;
    }
#line 493
    if (r != c + 1) {
      {
#line 494
      free((void *)uname);
      }
#line 495
      goto bailout;
    }
    {
#line 497
    i = (int )*(uname + c);
#line 498
    *(uname + c) = (char)0;
#line 499
    c = i;
#line 504
    upass = new((size_t )(c + 1));
#line 505
    tmp___11 = read(cd, (void *)upass, (size_t )c);
#line 505
    r = (int )tmp___11;
    }
#line 506
    if (r != c) {
      {
#line 507
      free((void *)upass);
#line 508
      free((void *)uname);
      }
#line 509
      goto bailout;
    }
    {
#line 511
    *(upass + c) = (char)0;
#line 516
    tmp = hlist_get(users_list, (char const   *)uname);
#line 517
    tmp___12 = hlist_count(users_list);
    }
#line 517
    if (tmp___12) {
#line 517
      if (tmp) {
        {
#line 517
        tmp___13 = strcmp((char const   *)tmp, (char const   *)upass);
        }
#line 517
        if (tmp___13) {
#line 521
          *(bs + 0) = (unsigned char)1;
#line 522
          *(bs + 1) = (unsigned char)255;
        } else {
#line 518
          *(bs + 0) = (unsigned char)1;
#line 519
          *(bs + 1) = (unsigned char)0;
        }
      } else {
#line 521
        *(bs + 0) = (unsigned char)1;
#line 522
        *(bs + 1) = (unsigned char)255;
      }
    } else {
#line 518
      *(bs + 0) = (unsigned char)1;
#line 519
      *(bs + 1) = (unsigned char)0;
    }
    {
#line 528
    tmp___14 = write(cd, (void const   *)bs, (size_t )2);
#line 528
    w = (int )tmp___14;
#line 529
    free((void *)upass);
#line 530
    free((void *)uname);
    }
#line 535
    if (*(bs + 1)) {
#line 536
      goto bailout;
    }
  }
  {
#line 542
  tmp___15 = read(cd, (void *)bs, (size_t )4);
#line 542
  r = (int )tmp___15;
  }
#line 543
  if (r != 4) {
#line 544
    goto bailout;
  }
#line 549
  if ((int )*(bs + 1) != 1) {
#line 549
    goto _L;
  } else
#line 549
  if ((int )*(bs + 3) != 1) {
#line 549
    if ((int )*(bs + 3) != 3) {
      _L: /* CIL Label */ 
      {
#line 550
      *(bs + 0) = (unsigned char)5;
#line 551
      *(bs + 1) = (unsigned char)2;
#line 552
      *(bs + 2) = (unsigned char)0;
#line 553
      *(bs + 3) = (unsigned char)1;
#line 554
      memset((void *)(bs + 4), 0, (size_t )6);
#line 555
      tmp___16 = write(cd, (void const   *)bs, (size_t )10);
#line 555
      w = (int )tmp___16;
      }
#line 556
      goto bailout;
    }
  }
#line 563
  if ((int )*(bs + 3) == 1) {
#line 564
    ver = 1;
#line 565
    c = 4;
  } else
#line 566
  if ((int )*(bs + 3) == 3) {
    {
#line 567
    ver = 2;
#line 568
    tmp___17 = read(cd, (void *)(& c), (size_t )1);
#line 568
    r = (int )tmp___17;
    }
#line 569
    if (r != 1) {
#line 570
      goto bailout;
    }
  } else {
#line 572
    goto bailout;
  }
  {
#line 574
  tmp___18 = new((size_t )((c + 10) + 1));
#line 574
  addr = (unsigned char *)tmp___18;
#line 575
  tmp___19 = read(cd, (void *)addr, (size_t )c);
#line 575
  r = (int )tmp___19;
  }
#line 576
  if (r != c) {
#line 577
    goto bailout;
  }
#line 578
  *(addr + c) = (unsigned char)0;
#line 583
  if (ver == 1) {
    {
#line 584
    sprintf((char */* __restrict  */)thost, (char const   */* __restrict  */)"%d.%d.%d.%d",
            (int )*(addr + 0), (int )*(addr + 1), (int )*(addr + 2), (int )*(addr + 3));
    }
  } else {
    {
#line 586
    strlcpy(thost, (char const   *)((char *)addr), (size_t )50);
    }
  }
  {
#line 592
  tmp___20 = read(cd, (void *)(& port), (size_t )2);
#line 592
  r = (int )tmp___20;
  }
#line 593
  if (r != 2) {
#line 594
    goto bailout;
  }
  {
#line 596
  i = 0;
#line 597
  tmp___23 = noproxy_match((char const   *)thost);
  }
#line 597
  if (tmp___23) {
    {
#line 598
    tmp___21 = ntohs(port);
#line 598
    sd = host_connect((char const   *)thost, (int )tmp___21);
#line 599
    i = sd >= 0;
    }
  } else {
    {
#line 601
    tmp___22 = ntohs(port);
#line 601
    sprintf((char */* __restrict  */)tport, (char const   */* __restrict  */)"%d",
            (int )tmp___22);
#line 602
    strlcat(thost, ":", (size_t )50);
#line 603
    strlcat(thost, (char const   *)tport, (size_t )50);
#line 605
    tcreds = new_auth();
#line 606
    sd = proxy_connect(tcreds);
    }
#line 607
    if (sd >= 0) {
      {
#line 608
      i = prepare_http_connect(sd, tcreds, (char const   *)thost);
      }
    }
  }
#line 614
  if (! i) {
    {
#line 618
    *(bs + 0) = (unsigned char)5;
#line 619
    *(bs + 1) = (unsigned char)1;
#line 620
    *(bs + 2) = (unsigned char)0;
#line 621
    *(bs + 3) = (unsigned char)1;
#line 622
    memset((void *)(bs + 4), 0, (size_t )6);
#line 623
    tmp___24 = write(cd, (void const   *)bs, (size_t )10);
#line 623
    w = (int )tmp___24;
    }
#line 624
    goto bailout;
  } else {
    {
#line 629
    *(bs + 0) = (unsigned char)5;
#line 630
    *(bs + 1) = (unsigned char)0;
#line 631
    *(bs + 2) = (unsigned char)0;
#line 632
    *(bs + 3) = (unsigned char)1;
#line 633
    memset((void *)(bs + 4), 0, (size_t )6);
#line 634
    tmp___25 = write(cd, (void const   *)bs, (size_t )10);
#line 634
    w = (int )tmp___25;
    }
  }
  {
#line 637
  tmp___26 = inet_ntoa(caddr.sin_addr);
#line 637
  syslog(7, "%s SOCKS %s", tmp___26, thost);
#line 642
  tunnel(cd, sd);
  }
  bailout: 
#line 645
  if (addr) {
    {
#line 646
    free((void *)addr);
    }
  }
#line 647
  if (auths) {
    {
#line 648
    free((void *)auths);
    }
  }
#line 649
  if (thost) {
    {
#line 650
    free((void *)thost);
    }
  }
#line 651
  if (tport) {
    {
#line 652
    free((void *)tport);
    }
  }
#line 653
  if (bs) {
    {
#line 654
    free((void *)bs);
    }
  }
#line 655
  if (tcreds) {
    {
#line 656
    free((void *)tcreds);
    }
  }
#line 657
  if (sd) {
    {
#line 658
    close(sd);
    }
  }
  {
#line 659
  close(cd);
  }
#line 661
  return ((void *)0);
}
}
#line 664 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/main.c"
int main(int argc , char **argv ) 
{ 
  char *tmp ;
  char *head ;
  char *cpassword ;
  char *cpassntlm2 ;
  char *cpassnt ;
  char *cpasslm ;
  char *cuser ;
  char *cdomain ;
  char *cworkstation ;
  char *cuid ;
  char *cpidfile ;
  char *cauth ;
  struct passwd *pw ;
  struct termios termold ;
  struct termios termnew ;
  pthread_attr_t pattr ;
  pthread_t pthr ;
  hlist_t list ;
  int i ;
  int w ;
  int cd ;
  int help ;
  int nuid ;
  int ngid ;
  int gateway ;
  int tc ;
  int tj ;
  int interactivepwd ;
  int interactivehash ;
  int tracefile ;
  int cflags ;
  int asdaemon ;
  plist_t tunneld_list ;
  plist_t proxyd_list ;
  plist_t socksd_list ;
  plist_t rules ;
  config_t cf ;
  char *magic_detect ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char *__tmp ;
  size_t tmp___18 ;
  int tmp___19 ;
  char *__tmp___0 ;
  size_t tmp___20 ;
  int tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  char *__tmp___1 ;
  size_t tmp___28 ;
  char *__tmp___2 ;
  size_t tmp___29 ;
  char *__tmp___3 ;
  size_t tmp___30 ;
  char *__tmp___4 ;
  size_t tmp___31 ;
  char *__tmp___5 ;
  size_t tmp___32 ;
  char *__tmp___6 ;
  size_t tmp___33 ;
  char *__tmp___7 ;
  size_t tmp___34 ;
  char *__tmp___8 ;
  size_t tmp___35 ;
  char *__tmp___9 ;
  size_t tmp___36 ;
  unsigned long tmp___37 ;
  unsigned long tmp___38 ;
  unsigned long tmp___39 ;
  unsigned long tmp___40 ;
  char *__tmp___10 ;
  size_t tmp___41 ;
  int tmp___42 ;
  size_t tmp___43 ;
  size_t tmp___44 ;
  size_t tmp___45 ;
  int tmp___46 ;
  size_t tmp___47 ;
  size_t tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  size_t tmp___54 ;
  size_t tmp___55 ;
  size_t tmp___56 ;
  size_t tmp___57 ;
  size_t tmp___58 ;
  size_t tmp___59 ;
  size_t tmp___60 ;
  __gid_t tmp___61 ;
  __uid_t tmp___62 ;
  unsigned short const   **tmp___63 ;
  int *tmp___64 ;
  char *tmp___65 ;
  __uid_t tmp___66 ;
  __uid_t tmp___67 ;
  size_t tmp___68 ;
  __pid_t tmp___69 ;
  size_t tmp___70 ;
  ssize_t tmp___71 ;
  size_t tmp___72 ;
  time_t tmp___73 ;
  struct thread_arg_s *data ;
  struct sockaddr_in caddr ;
  struct timeval tv ;
  socklen_t clen ;
  fd_set set ;
  plist_t t ;
  int tid ;
  int __d0 ;
  int __d1 ;
  int *tmp___74 ;
  char *tmp___75 ;
  uint16_t tmp___76 ;
  char *tmp___77 ;
  char *tmp___78 ;
  size_t tmp___79 ;
  ssize_t tmp___80 ;
  enum acl_t tmp___81 ;
  char *tmp___82 ;
  char *tmp___83 ;
  char *tmp___84 ;
  int tmp___85 ;
  int tmp___86 ;
  int *tmp___87 ;
  char *tmp___88 ;
  plist_t tmp___89 ;
  size_t tmp___90 ;

  {
  {
#line 675
  cd = 0;
#line 676
  help = 0;
#line 677
  nuid = 0;
#line 678
  ngid = 0;
#line 679
  gateway = 0;
#line 680
  tc = 0;
#line 681
  tj = 0;
#line 682
  interactivepwd = 0;
#line 683
  interactivehash = 0;
#line 684
  tracefile = 0;
#line 685
  cflags = 0;
#line 686
  asdaemon = 1;
#line 687
  tunneld_list = (plist_t )((void *)0);
#line 688
  proxyd_list = (plist_t )((void *)0);
#line 689
  socksd_list = (plist_t )((void *)0);
#line 690
  rules = (plist_t )((void *)0);
#line 691
  cf = (config_t )((void *)0);
#line 692
  magic_detect = (char *)((void *)0);
#line 694
  g_creds = new_auth();
#line 695
  cuser = new((size_t )50);
#line 696
  cdomain = new((size_t )50);
#line 697
  cpassword = new((size_t )50);
#line 698
  cpassntlm2 = new((size_t )50);
#line 699
  cpassnt = new((size_t )50);
#line 700
  cpasslm = new((size_t )50);
#line 701
  cworkstation = new((size_t )50);
#line 702
  cpidfile = new((size_t )50);
#line 703
  cuid = new((size_t )50);
#line 704
  cauth = new((size_t )50);
#line 706
  openlog("cntlm", 2, 3 << 3);
#line 711
  syslog(6, "Starting cntlm version 0.92.3 for LITTLE endian\n");
  }
  {
#line 714
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 714
    i = getopt(argc, (char * const  *)argv, ":-:a:c:d:fghIl:p:r:su:vw:A:BD:F:G:HL:M:N:O:P:R:S:T:U:");
    }
#line 714
    if (! (i != -1)) {
#line 714
      goto while_break;
    }
    {
#line 717
    if (i == 68) {
#line 717
      goto case_68;
    }
#line 717
    if (i == 65) {
#line 717
      goto case_68;
    }
#line 721
    if (i == 97) {
#line 721
      goto case_97;
    }
#line 724
    if (i == 66) {
#line 724
      goto case_66;
    }
#line 727
    if (i == 99) {
#line 727
      goto case_99;
    }
#line 733
    if (i == 100) {
#line 733
      goto case_100;
    }
#line 736
    if (i == 70) {
#line 736
      goto case_70;
    }
#line 739
    if (i == 102) {
#line 739
      goto case_102;
    }
#line 742
    if (i == 71) {
#line 742
      goto case_71;
    }
#line 753
    if (i == 103) {
#line 753
      goto case_103;
    }
#line 756
    if (i == 72) {
#line 756
      goto case_72;
    }
#line 759
    if (i == 73) {
#line 759
      goto case_73;
    }
#line 762
    if (i == 76) {
#line 762
      goto case_76;
    }
#line 769
    if (i == 108) {
#line 769
      goto case_108;
    }
#line 775
    if (i == 77) {
#line 775
      goto case_77;
    }
#line 778
    if (i == 78) {
#line 778
      goto case_78;
    }
#line 782
    if (i == 79) {
#line 782
      goto case_79;
    }
#line 785
    if (i == 80) {
#line 785
      goto case_80;
    }
#line 788
    if (i == 112) {
#line 788
      goto case_112;
    }
#line 797
    if (i == 82) {
#line 797
      goto case_82;
    }
#line 808
    if (i == 114) {
#line 808
      goto case_114;
    }
#line 815
    if (i == 83) {
#line 815
      goto case_83;
    }
#line 819
    if (i == 115) {
#line 819
      goto case_115;
    }
#line 825
    if (i == 84) {
#line 825
      goto case_84;
    }
#line 844
    if (i == 85) {
#line 844
      goto case_85;
    }
#line 847
    if (i == 117) {
#line 847
      goto case_117;
    }
#line 856
    if (i == 118) {
#line 856
      goto case_118;
    }
#line 861
    if (i == 119) {
#line 861
      goto case_119;
    }
#line 865
    goto switch_default;
    case_68: /* CIL Label */ 
    case_65: /* CIL Label */ 
#line 718
    if (i == 65) {
#line 718
      tmp___0 = 0;
    } else {
#line 718
      tmp___0 = 1;
    }
    {
#line 718
    tmp___1 = acl_add(& rules, optarg, (enum acl_t )tmp___0);
    }
#line 718
    if (! tmp___1) {
      {
#line 719
      myexit(1);
      }
    }
#line 720
    goto switch_break;
    case_97: /* CIL Label */ 
    {
#line 722
    strlcpy(cauth, (char const   *)optarg, (size_t )50);
    }
#line 723
    goto switch_break;
    case_66: /* CIL Label */ 
#line 725
    ntlmbasic = 1;
#line 726
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 728
    cf = config_open((char const   *)optarg);
    }
#line 728
    if (! cf) {
      {
#line 729
      syslog(3, "Cannot access specified config file: %s\n", optarg);
#line 730
      myexit(1);
      }
    }
#line 732
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 734
    strlcpy(cdomain, (char const   *)optarg, (size_t )50);
    }
#line 735
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 737
    tmp___2 = strtoul((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& tmp),
                      0);
#line 737
    tmp___3 = strtoul((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& tmp),
                      0);
#line 737
    tmp___4 = strtoul((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& tmp),
                      0);
#line 737
    tmp___5 = strtoul((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& tmp),
                      0);
#line 737
    cflags = (int )((((((uint32_t )tmp___2 & 255U) << 24) | (((uint32_t )tmp___3 & 65280U) << 8)) | (((uint32_t )tmp___4 & 16711680U) >> 8)) | (((uint32_t )tmp___5 & 4278190080U) >> 24));
    }
#line 738
    goto switch_break;
    case_102: /* CIL Label */ 
#line 740
    asdaemon = 0;
#line 741
    goto switch_break;
    case_71: /* CIL Label */ 
    {
#line 743
    tmp___7 = strlen((char const   *)optarg);
    }
#line 743
    if (tmp___7) {
#line 744
      scanner_plugin = 1;
#line 745
      if (! scanner_plugin_maxsize) {
#line 746
        scanner_plugin_maxsize = 1L;
      }
      {
#line 747
      tmp___6 = strlen((char const   *)optarg);
#line 747
      i = (int )(tmp___6 + 3UL);
#line 748
      tmp = new((size_t )i);
#line 749
      snprintf((char */* __restrict  */)tmp, (size_t )i, (char const   */* __restrict  */)"*%s*",
               optarg);
#line 750
      scanner_agent_list = plist_add(scanner_agent_list, 0UL, (void *)tmp);
      }
    }
#line 752
    goto switch_break;
    case_103: /* CIL Label */ 
#line 754
    gateway = 1;
#line 755
    goto switch_break;
    case_72: /* CIL Label */ 
#line 757
    interactivehash = 1;
#line 758
    goto switch_break;
    case_73: /* CIL Label */ 
#line 760
    interactivepwd = 1;
#line 761
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 767
    tunnel_add(& tunneld_list, optarg, gateway);
    }
#line 768
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 773
    listen_add("Proxy", & proxyd_list, optarg, gateway);
    }
#line 774
    goto switch_break;
    case_77: /* CIL Label */ 
    {
#line 776
    magic_detect = strdup((char const   *)optarg);
    }
#line 777
    goto switch_break;
    case_78: /* CIL Label */ 
    {
#line 779
    tmp = strdup((char const   *)optarg);
#line 779
    noproxy_list = noproxy_add(noproxy_list, tmp);
#line 780
    free((void *)tmp);
    }
#line 781
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 783
    listen_add("SOCKS5 proxy", & socksd_list, optarg, gateway);
    }
#line 784
    goto switch_break;
    case_80: /* CIL Label */ 
    {
#line 786
    strlcpy(cpidfile, (char const   *)optarg, (size_t )50);
    }
#line 787
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 793
    strlcpy(cpassword, (char const   *)optarg, (size_t )50);
#line 794
    tmp___8 = strlen((char const   *)optarg);
#line 794
    i = (int )(tmp___8 - 1UL);
    }
    {
#line 794
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 794
      if (! (i >= 0)) {
#line 794
        goto while_break___0;
      }
#line 795
      *(optarg + i) = (char )'*';
#line 794
      i --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 796
    goto switch_break;
    case_82: /* CIL Label */ 
    {
#line 798
    tmp = strdup((char const   *)optarg);
#line 799
    head = strchr((char const   *)tmp, ':');
    }
#line 800
    if (! head) {
      {
#line 801
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid username:password format for -R: %s\n",
              tmp);
      }
    } else {
      {
#line 803
      *(head + 0) = (char)0;
#line 804
      users_list = hlist_add(users_list, tmp, head + 1, (hlist_add_t )1, (hlist_add_t )1);
      }
    }
#line 807
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 809
    tmp___11 = is_http_header((char const   *)optarg);
    }
#line 809
    if (tmp___11) {
      {
#line 810
      tmp___9 = get_http_header_value((char const   *)optarg);
#line 810
      tmp___10 = get_http_header_name((char const   *)optarg);
#line 810
      header_list = hlist_add(header_list, tmp___10, tmp___9, (hlist_add_t )0, (hlist_add_t )0);
      }
    }
#line 814
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 816
    scanner_plugin = 1;
#line 817
    scanner_plugin_maxsize = atol((char const   *)optarg);
    }
#line 818
    goto switch_break;
    case_115: /* CIL Label */ 
#line 823
    serialize = 1;
#line 824
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 826
    tracefile = open((char const   *)optarg, 577, 384);
    }
#line 827
    if (tracefile < 0) {
      {
#line 828
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot create trace file.\n");
#line 829
      myexit(1);
      }
    } else {
      {
#line 831
      printf((char const   */* __restrict  */)"Redirecting all output to %s\n", optarg);
#line 832
      dup2(tracefile, 1);
#line 833
      dup2(tracefile, 2);
#line 834
      printf((char const   */* __restrict  */)"Cntlm debug trace, version 0.92.3");
#line 838
      printf((char const   */* __restrict  */)".\nCommand line: ");
#line 839
      i = 0;
      }
      {
#line 839
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 839
        if (! (i < argc)) {
#line 839
          goto while_break___1;
        }
        {
#line 840
        printf((char const   */* __restrict  */)"%s ", *(argv + i));
#line 839
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 841
      printf((char const   */* __restrict  */)"\n");
      }
    }
#line 843
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 845
    strlcpy(cuid, (char const   *)optarg, (size_t )50);
    }
#line 846
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 848
    tmp___12 = strcspn((char const   *)optarg, "@");
#line 848
    i = (int )tmp___12;
#line 849
    tmp___14 = strlen((char const   *)optarg);
    }
#line 849
    if ((size_t )i != tmp___14) {
#line 850
      if (50 < i + 1) {
#line 850
        tmp___13 = 50;
      } else {
#line 850
        tmp___13 = i + 1;
      }
      {
#line 850
      strlcpy(cuser, (char const   *)optarg, (size_t )tmp___13);
#line 851
      strlcpy(cdomain, (char const   *)((optarg + i) + 1), (size_t )50);
      }
    } else {
      {
#line 853
      strlcpy(cuser, (char const   *)optarg, (size_t )50);
      }
    }
#line 855
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 857
    debug = 1;
#line 858
    asdaemon = 0;
#line 859
    openlog("cntlm", 34, 3 << 3);
    }
#line 860
    goto switch_break;
    case_119: /* CIL Label */ 
    {
#line 862
    strlcpy(cworkstation, (char const   *)optarg, (size_t )50);
    }
#line 863
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 866
    help = 1;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 873
  if (help) {
    {
#line 874
    printf((char const   */* __restrict  */)"CNTLM - Accelerating NTLM Authentication Proxy version 0.92.3\n");
#line 875
    printf((char const   */* __restrict  */)"Copyright (c) 2oo7-2o1o David Kubicek\n\nThis program comes with NO WARRANTY, to the extent permitted by law. You\nmay redistribute copies of it under the terms of the GNU GPL Version 2 or\nnewer. For more information about these matters, see the file LICENSE.\nFor copyright holders of included encryption routines see headers.\n\n");
#line 881
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [-AaBcDdFfgHhILlMPpSsTUuvw] <proxy_host>[:]<proxy_port> ...\n",
            *(argv + 0));
#line 882
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-A  <address>[/<net>]\n\t    ACL allow rule. IP or hostname, net must be a number (CIDR notation)\n");
#line 884
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-a  ntlm | nt | lm\n\t    Authentication type - combined NTLM, just LM, or just NT. Default NTLM.\n\t    It is the most versatile setting and likely to work for you.\n");
#line 887
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-B  Enable NTLM-to-basic authentication.\n");
#line 888
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-c  <config_file>\n\t    Configuration file. Other arguments can be used as well, overriding\n\t    config file settings.\n");
#line 891
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-D  <address>[/<net>]\n\t    ACL deny rule. Syntax same as -A.\n");
#line 893
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-d  <domain>\n\t    Domain/workgroup can be set separately.\n");
#line 895
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-f  Run in foreground, do not fork into daemon mode.\n");
#line 896
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-F  <flags>\n\t    NTLM authentication flags.\n");
#line 898
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-G  <pattern>\n\t    User-Agent matching for the trans-isa-scan plugin.\n");
#line 900
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-g  Gateway mode - listen on all interfaces, not only loopback.\n");
#line 901
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-H  Print password hashes for use in config file (NTLMv2 needs -u and -d).\n");
#line 902
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-h  Print this help info along with version number.\n");
#line 903
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-I  Prompt for the password interactively.\n");
#line 904
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-L  [<saddr>:]<lport>:<rhost>:<rport>\n\t    Forwarding/tunneling a la OpenSSH. Same syntax - listen on lport\n\t    and forward all connections through the proxy to rhost:rport.\n\t    Can be used for direct tunneling without corkscrew, etc.\n");
#line 908
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-l  [<saddr>:]<lport>\n\t    Main listening port for the NTLM proxy.\n");
#line 910
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-M  <testurl>\n\t    Magic autodetection of proxy\'s NTLM dialect.\n");
#line 912
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-N  \"<hostname_wildcard1>[, <hostname_wildcardN>\"\n\t    List of URL\'s to serve direcly as stand-alone proxy (e.g. \'*.local\')\n");
#line 914
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-O  [<saddr>:]<lport>\n\t    Enable SOCKS5 proxy on port lport (binding to address saddr)\n");
#line 916
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-P  <pidfile>\n\t    Create a PID file upon successful start.\n");
#line 918
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-p  <password>\n\t    Account password. Will not be visible in \"ps\", /proc, etc.\n");
#line 920
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-r  \"HeaderName: value\"\n\t    Add a header substitution. All such headers will be added/replaced\n\t    in the client\'s requests.\n");
#line 923
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-S  <size_in_kb>\n\t    Enable automation of GFI WebMonitor ISA scanner for files < size_in_kb.\n");
#line 925
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-s  Do not use threads, serialize all requests - for debugging only.\n");
#line 926
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-U  <uid>\n\t    Run as uid. It is an important security measure not to run as root.\n");
#line 928
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-u  <user>[@<domain]\n\t    Domain/workgroup can be set separately.\n");
#line 930
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-v  Print debugging information.\n");
#line 931
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-w  <workstation>\n\t    Some proxies require correct NetBIOS hostname.\n\n");
#line 933
    exit(1);
    }
  }
#line 939
  i = optind;
  {
#line 940
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 940
    if (! (i < argc)) {
#line 940
      goto while_break___2;
    }
    {
#line 941
    tmp = strchr((char const   *)*(argv + i), ':');
    }
#line 942
    if (! tmp) {
#line 942
      if (i + 1 < argc) {
        {
#line 942
        tmp___15 = atoi((char const   *)*(argv + (i + 1)));
#line 942
        tmp___16 = tmp___15;
        }
      } else {
#line 942
        tmp___16 = 0;
      }
    } else {
#line 942
      tmp___16 = 0;
    }
    {
#line 942
    parent_add(*(argv + i), tmp___16);
    }
#line 943
    if (! tmp) {
#line 943
      tmp___17 = 2;
    } else {
#line 943
      tmp___17 = 1;
    }
#line 943
    i += tmp___17;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 950
  if (! cf) {
    {
#line 963
    cf = config_open("/etc/cntlm.conf");
    }
#line 965
    if (debug) {
#line 966
      if (cf) {
        {
#line 967
        printf((char const   */* __restrict  */)"Default config file opened successfully\n");
        }
      } else {
        {
#line 969
        syslog(3, "Could not open default config file\n");
        }
      }
    }
  }
#line 977
  if (cf) {
    {
#line 981
    tmp = new((size_t )50);
#line 982
    __tmp = (char *)((void *)0);
#line 982
    __tmp = config_pop(cf, "Gateway");
    }
#line 982
    if (__tmp) {
      {
#line 982
      tmp___18 = strlen((char const   *)tmp);
      }
#line 982
      if (! tmp___18) {
        {
#line 982
        strlcpy(tmp, (char const   *)__tmp, (size_t )50);
        }
      }
    }
#line 982
    if (__tmp) {
      {
#line 982
      free((void *)__tmp);
      }
    }
    {
#line 983
    tmp___19 = strcasecmp("yes", (char const   *)tmp);
    }
#line 983
    if (! tmp___19) {
#line 984
      gateway = 1;
    }
    {
#line 985
    free((void *)tmp);
#line 990
    tmp = new((size_t )50);
#line 991
    __tmp___0 = (char *)((void *)0);
#line 991
    __tmp___0 = config_pop(cf, "NTLMToBasic");
    }
#line 991
    if (__tmp___0) {
      {
#line 991
      tmp___20 = strlen((char const   *)tmp);
      }
#line 991
      if (! tmp___20) {
        {
#line 991
        strlcpy(tmp, (char const   *)__tmp___0, (size_t )50);
        }
      }
    }
#line 991
    if (__tmp___0) {
      {
#line 991
      free((void *)__tmp___0);
      }
    }
    {
#line 992
    tmp___21 = strcasecmp("yes", (char const   *)tmp);
    }
#line 992
    if (! tmp___21) {
#line 993
      ntlmbasic = 1;
    }
    {
#line 994
    free((void *)tmp);
    }
    {
#line 999
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 999
      tmp = config_pop(cf, "Tunnel");
      }
#line 999
      if (! tmp) {
#line 999
        goto while_break___3;
      }
      {
#line 1000
      tunnel_add(& tunneld_list, tmp, gateway);
#line 1001
      free((void *)tmp);
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 1007
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 1007
      tmp = config_pop(cf, "Listen");
      }
#line 1007
      if (! tmp) {
#line 1007
        goto while_break___4;
      }
      {
#line 1008
      listen_add("Proxy", & proxyd_list, tmp, gateway);
#line 1009
      free((void *)tmp);
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 1015
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 1015
      tmp = config_pop(cf, "SOCKS5Proxy");
      }
#line 1015
      if (! tmp) {
#line 1015
        goto while_break___5;
      }
      {
#line 1016
      listen_add("SOCKS5 proxy", & socksd_list, tmp, gateway);
#line 1017
      free((void *)tmp);
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 1024
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 1024
      tmp = config_pop(cf, "Header");
      }
#line 1024
      if (! tmp) {
#line 1024
        goto while_break___6;
      }
      {
#line 1025
      tmp___24 = is_http_header((char const   *)tmp);
      }
#line 1025
      if (tmp___24) {
        {
#line 1026
        head = get_http_header_name((char const   *)tmp);
#line 1027
        tmp___23 = hlist_in(header_list, (char const   *)head);
        }
#line 1027
        if (! tmp___23) {
          {
#line 1028
          tmp___22 = get_http_header_value((char const   *)tmp);
#line 1028
          header_list = hlist_add(header_list, head, tmp___22, (hlist_add_t )1, (hlist_add_t )0);
          }
        }
        {
#line 1030
        free((void *)head);
        }
      } else {
        {
#line 1032
        syslog(3, "Invalid header format: %s\n", tmp);
        }
      }
      {
#line 1034
      free((void *)tmp);
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 1040
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 1040
      tmp = config_pop(cf, "Proxy");
      }
#line 1040
      if (! tmp) {
#line 1040
        goto while_break___7;
      }
      {
#line 1041
      parent_add(tmp, 0);
#line 1042
      free((void *)tmp);
      }
    }
    while_break___7: /* CIL Label */ ;
    }
#line 1048
    if ((unsigned long )rules == (unsigned long )((void *)0)) {
#line 1049
      list = cf->options;
      {
#line 1050
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 1050
        if (! list) {
#line 1050
          goto while_break___8;
        }
        {
#line 1051
        i = strcasecmp("Allow", (char const   *)list->key);
        }
#line 1051
        if (i) {
          {
#line 1051
          tmp___27 = strcasecmp("Deny", (char const   *)list->key);
          }
#line 1051
          if (! tmp___27) {
            _L: /* CIL Label */ 
#line 1052
            if (i) {
#line 1052
              tmp___25 = 1;
            } else {
#line 1052
              tmp___25 = 0;
            }
            {
#line 1052
            tmp___26 = acl_add(& rules, list->value, (enum acl_t )tmp___25);
            }
#line 1052
            if (! tmp___26) {
              {
#line 1053
              myexit(1);
              }
            }
          }
        } else {
#line 1051
          goto _L;
        }
#line 1054
        list = list->next;
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 1057
      while (1) {
        while_continue___9: /* CIL Label */ ;
        {
#line 1057
        tmp = config_pop(cf, "Allow");
        }
#line 1057
        if (! tmp) {
#line 1057
          goto while_break___9;
        }
        {
#line 1058
        free((void *)tmp);
        }
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 1059
      while (1) {
        while_continue___10: /* CIL Label */ ;
        {
#line 1059
        tmp = config_pop(cf, "Deny");
        }
#line 1059
        if (! tmp) {
#line 1059
          goto while_break___10;
        }
        {
#line 1060
        free((void *)tmp);
        }
      }
      while_break___10: /* CIL Label */ ;
      }
    }
    {
#line 1066
    __tmp___1 = (char *)((void *)0);
#line 1066
    __tmp___1 = config_pop(cf, "Auth");
    }
#line 1066
    if (__tmp___1) {
      {
#line 1066
      tmp___28 = strlen((char const   *)cauth);
      }
#line 1066
      if (! tmp___28) {
        {
#line 1066
        strlcpy(cauth, (char const   *)__tmp___1, (size_t )50);
        }
      }
    }
#line 1066
    if (__tmp___1) {
      {
#line 1066
      free((void *)__tmp___1);
      }
    }
    {
#line 1067
    __tmp___2 = (char *)((void *)0);
#line 1067
    __tmp___2 = config_pop(cf, "Domain");
    }
#line 1067
    if (__tmp___2) {
      {
#line 1067
      tmp___29 = strlen((char const   *)cdomain);
      }
#line 1067
      if (! tmp___29) {
        {
#line 1067
        strlcpy(cdomain, (char const   *)__tmp___2, (size_t )50);
        }
      }
    }
#line 1067
    if (__tmp___2) {
      {
#line 1067
      free((void *)__tmp___2);
      }
    }
    {
#line 1068
    __tmp___3 = (char *)((void *)0);
#line 1068
    __tmp___3 = config_pop(cf, "Password");
    }
#line 1068
    if (__tmp___3) {
      {
#line 1068
      tmp___30 = strlen((char const   *)cpassword);
      }
#line 1068
      if (! tmp___30) {
        {
#line 1068
        strlcpy(cpassword, (char const   *)__tmp___3, (size_t )50);
        }
      }
    }
#line 1068
    if (__tmp___3) {
      {
#line 1068
      free((void *)__tmp___3);
      }
    }
    {
#line 1069
    __tmp___4 = (char *)((void *)0);
#line 1069
    __tmp___4 = config_pop(cf, "PassNTLMv2");
    }
#line 1069
    if (__tmp___4) {
      {
#line 1069
      tmp___31 = strlen((char const   *)cpassntlm2);
      }
#line 1069
      if (! tmp___31) {
        {
#line 1069
        strlcpy(cpassntlm2, (char const   *)__tmp___4, (size_t )50);
        }
      }
    }
#line 1069
    if (__tmp___4) {
      {
#line 1069
      free((void *)__tmp___4);
      }
    }
    {
#line 1070
    __tmp___5 = (char *)((void *)0);
#line 1070
    __tmp___5 = config_pop(cf, "PassNT");
    }
#line 1070
    if (__tmp___5) {
      {
#line 1070
      tmp___32 = strlen((char const   *)cpassnt);
      }
#line 1070
      if (! tmp___32) {
        {
#line 1070
        strlcpy(cpassnt, (char const   *)__tmp___5, (size_t )50);
        }
      }
    }
#line 1070
    if (__tmp___5) {
      {
#line 1070
      free((void *)__tmp___5);
      }
    }
    {
#line 1071
    __tmp___6 = (char *)((void *)0);
#line 1071
    __tmp___6 = config_pop(cf, "PassLM");
    }
#line 1071
    if (__tmp___6) {
      {
#line 1071
      tmp___33 = strlen((char const   *)cpasslm);
      }
#line 1071
      if (! tmp___33) {
        {
#line 1071
        strlcpy(cpasslm, (char const   *)__tmp___6, (size_t )50);
        }
      }
    }
#line 1071
    if (__tmp___6) {
      {
#line 1071
      free((void *)__tmp___6);
      }
    }
    {
#line 1072
    __tmp___7 = (char *)((void *)0);
#line 1072
    __tmp___7 = config_pop(cf, "Username");
    }
#line 1072
    if (__tmp___7) {
      {
#line 1072
      tmp___34 = strlen((char const   *)cuser);
      }
#line 1072
      if (! tmp___34) {
        {
#line 1072
        strlcpy(cuser, (char const   *)__tmp___7, (size_t )50);
        }
      }
    }
#line 1072
    if (__tmp___7) {
      {
#line 1072
      free((void *)__tmp___7);
      }
    }
    {
#line 1073
    __tmp___8 = (char *)((void *)0);
#line 1073
    __tmp___8 = config_pop(cf, "Workstation");
    }
#line 1073
    if (__tmp___8) {
      {
#line 1073
      tmp___35 = strlen((char const   *)cworkstation);
      }
#line 1073
      if (! tmp___35) {
        {
#line 1073
        strlcpy(cworkstation, (char const   *)__tmp___8, (size_t )50);
        }
      }
    }
#line 1073
    if (__tmp___8) {
      {
#line 1073
      free((void *)__tmp___8);
      }
    }
    {
#line 1075
    tmp = new((size_t )50);
#line 1076
    __tmp___9 = (char *)((void *)0);
#line 1076
    __tmp___9 = config_pop(cf, "Flags");
    }
#line 1076
    if (__tmp___9) {
      {
#line 1076
      tmp___36 = strlen((char const   *)tmp);
      }
#line 1076
      if (! tmp___36) {
        {
#line 1076
        strlcpy(tmp, (char const   *)__tmp___9, (size_t )50);
        }
      }
    }
#line 1076
    if (__tmp___9) {
      {
#line 1076
      free((void *)__tmp___9);
      }
    }
#line 1077
    if (! cflags) {
      {
#line 1078
      tmp___37 = strtoul((char const   */* __restrict  */)tmp, (char **/* __restrict  */)((void *)0),
                         0);
#line 1078
      tmp___38 = strtoul((char const   */* __restrict  */)tmp, (char **/* __restrict  */)((void *)0),
                         0);
#line 1078
      tmp___39 = strtoul((char const   */* __restrict  */)tmp, (char **/* __restrict  */)((void *)0),
                         0);
#line 1078
      tmp___40 = strtoul((char const   */* __restrict  */)tmp, (char **/* __restrict  */)((void *)0),
                         0);
#line 1078
      cflags = (int )((((((uint32_t )tmp___37 & 255U) << 24) | (((uint32_t )tmp___38 & 65280U) << 8)) | (((uint32_t )tmp___39 & 16711680U) >> 8)) | (((uint32_t )tmp___40 & 4278190080U) >> 24));
      }
    }
    {
#line 1079
    free((void *)tmp);
#line 1081
    tmp = new((size_t )50);
#line 1082
    __tmp___10 = (char *)((void *)0);
#line 1082
    __tmp___10 = config_pop(cf, "ISAScannerSize");
    }
#line 1082
    if (__tmp___10) {
      {
#line 1082
      tmp___41 = strlen((char const   *)tmp);
      }
#line 1082
      if (! tmp___41) {
        {
#line 1082
        strlcpy(tmp, (char const   *)__tmp___10, (size_t )50);
        }
      }
    }
#line 1082
    if (__tmp___10) {
      {
#line 1082
      free((void *)__tmp___10);
      }
    }
#line 1083
    if (! scanner_plugin_maxsize) {
      {
#line 1083
      tmp___43 = strlen((char const   *)tmp);
      }
#line 1083
      if (tmp___43) {
        {
#line 1084
        scanner_plugin = 1;
#line 1085
        tmp___42 = atoi((char const   *)tmp);
#line 1085
        scanner_plugin_maxsize = (long )tmp___42;
        }
      }
    }
    {
#line 1087
    free((void *)tmp);
    }
    {
#line 1089
    while (1) {
      while_continue___11: /* CIL Label */ ;
      {
#line 1089
      tmp = config_pop(cf, "NoProxy");
      }
#line 1089
      if (! tmp) {
#line 1089
        goto while_break___11;
      }
      {
#line 1090
      tmp___44 = strlen((char const   *)tmp);
      }
#line 1090
      if (tmp___44) {
        {
#line 1091
        noproxy_list = noproxy_add(noproxy_list, tmp);
        }
      }
      {
#line 1093
      free((void *)tmp);
      }
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 1096
    while (1) {
      while_continue___12: /* CIL Label */ ;
      {
#line 1096
      tmp = config_pop(cf, "SOCKS5Users");
      }
#line 1096
      if (! tmp) {
#line 1096
        goto while_break___12;
      }
      {
#line 1097
      head = strchr((char const   *)tmp, ':');
      }
#line 1098
      if (! head) {
        {
#line 1099
        syslog(3, "Invalid username:password format for SOCKS5User: %s\n", tmp);
        }
      } else {
        {
#line 1101
        *(head + 0) = (char)0;
#line 1102
        users_list = hlist_add(users_list, tmp, head + 1, (hlist_add_t )1, (hlist_add_t )1);
        }
      }
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 1110
    while (1) {
      while_continue___13: /* CIL Label */ ;
      {
#line 1110
      tmp = config_pop(cf, "ISAScannerAgent");
      }
#line 1110
      if (! tmp) {
#line 1110
        goto while_break___13;
      }
#line 1111
      scanner_plugin = 1;
#line 1112
      if (! scanner_plugin_maxsize) {
#line 1113
        scanner_plugin_maxsize = 1L;
      }
      {
#line 1115
      tmp___45 = strlen((char const   *)tmp);
#line 1115
      i = (int )tmp___45;
      }
#line 1115
      if (i) {
        {
#line 1116
        head = new((size_t )(i + 3));
#line 1117
        snprintf((char */* __restrict  */)head, (size_t )(i + 3), (char const   */* __restrict  */)"*%s*",
                 tmp);
#line 1118
        scanner_agent_list = plist_add(scanner_agent_list, 0UL, (void *)head);
        }
      }
      {
#line 1120
      free((void *)tmp);
      }
    }
    while_break___13: /* CIL Label */ ;
    }
#line 1126
    list = cf->options;
    {
#line 1127
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 1127
      if (! list) {
#line 1127
        goto while_break___14;
      }
      {
#line 1128
      syslog(6, "Ignoring config file option: %s\n", list->key);
#line 1129
      list = list->next;
      }
    }
    while_break___14: /* CIL Label */ ;
    }
  }
  {
#line 1133
  config_close(cf);
  }
#line 1135
  if (! interactivehash) {
#line 1135
    if (! parent_list) {
#line 1136
      if (interactivepwd) {
#line 1136
        tmp___46 = 1;
      } else
#line 1136
      if (magic_detect) {
#line 1136
        tmp___46 = 1;
      } else {
#line 1136
        tmp___46 = 0;
      }
      {
#line 1136
      croak("Parent proxy address missing.\n", tmp___46);
      }
    }
  }
#line 1138
  if (! interactivehash) {
#line 1138
    if (! magic_detect) {
#line 1138
      if (! proxyd_list) {
        {
#line 1139
        croak("No proxy service ports were successfully opened.\n", interactivepwd);
        }
      }
    }
  }
  {
#line 1144
  tmp___48 = strlen((char const   *)cworkstation);
  }
#line 1144
  if (! tmp___48) {
    {
#line 1146
    gethostname(cworkstation, (size_t )50);
#line 1148
    tmp___47 = strlen((char const   *)cworkstation);
    }
#line 1148
    if (! tmp___47) {
      {
#line 1149
      strlcpy(cworkstation, "cntlm", (size_t )50);
      }
    }
    {
#line 1151
    syslog(6, "Workstation name used: %s\n", cworkstation);
    }
  }
  {
#line 1157
  tmp___54 = strlen((char const   *)cauth);
  }
#line 1157
  if (tmp___54) {
    {
#line 1158
    tmp___53 = strcasecmp("ntlm", (char const   *)cauth);
    }
#line 1158
    if (tmp___53) {
      {
#line 1162
      tmp___52 = strcasecmp("nt", (char const   *)cauth);
      }
#line 1162
      if (tmp___52) {
        {
#line 1166
        tmp___51 = strcasecmp("lm", (char const   *)cauth);
        }
#line 1166
        if (tmp___51) {
          {
#line 1170
          tmp___50 = strcasecmp("ntlmv2", (char const   *)cauth);
          }
#line 1170
          if (tmp___50) {
            {
#line 1174
            tmp___49 = strcasecmp("ntlm2sr", (char const   *)cauth);
            }
#line 1174
            if (tmp___49) {
              {
#line 1179
              syslog(3, "Unknown NTLM auth combination.\n");
#line 1180
              myexit(1);
              }
            } else {
#line 1175
              g_creds->hashnt = 2;
#line 1176
              g_creds->hashlm = 0;
#line 1177
              g_creds->hashntlm2 = 0;
            }
          } else {
#line 1171
            g_creds->hashnt = 0;
#line 1172
            g_creds->hashlm = 0;
#line 1173
            g_creds->hashntlm2 = 1;
          }
        } else {
#line 1167
          g_creds->hashnt = 0;
#line 1168
          g_creds->hashlm = 1;
#line 1169
          g_creds->hashntlm2 = 0;
        }
      } else {
#line 1163
        g_creds->hashnt = 1;
#line 1164
        g_creds->hashlm = 0;
#line 1165
        g_creds->hashntlm2 = 0;
      }
    } else {
#line 1159
      g_creds->hashnt = 1;
#line 1160
      g_creds->hashlm = 1;
#line 1161
      g_creds->hashntlm2 = 0;
    }
  }
#line 1184
  if (socksd_list) {
#line 1184
    if (! users_list) {
      {
#line 1185
      syslog(4, "SOCKS5 proxy will NOT require any authentication\n");
      }
    }
  }
#line 1187
  if (! magic_detect) {
    {
#line 1188
    syslog(6, "Using following NTLM hashes: NTLMv2(%d) NT(%d) LM(%d)\n", g_creds->hashntlm2,
           g_creds->hashnt, g_creds->hashlm);
    }
  }
#line 1191
  if (cflags) {
    {
#line 1192
    syslog(6, "Using manual NTLM flags: 0x%X\n", (((((uint32_t )cflags & 255U) << 24) | (((uint32_t )cflags & 65280U) << 8)) | (((uint32_t )cflags & 16711680U) >> 8)) | (((uint32_t )cflags & 4278190080U) >> 24));
#line 1193
    g_creds->flags = (uint32_t )cflags;
    }
  }
#line 1199
  if (interactivehash) {
#line 1199
    goto _L___0;
  } else
#line 1199
  if (magic_detect) {
#line 1199
    goto _L___0;
  } else
#line 1199
  if (interactivepwd) {
#line 1199
    if (! ntlmbasic) {
      _L___0: /* CIL Label */ 
      {
#line 1200
      printf((char const   */* __restrict  */)"Password: ");
#line 1201
      tcgetattr(0, & termold);
#line 1202
      termnew = termold;
#line 1203
      termnew.c_lflag &= 4294967286U;
#line 1204
      tcsetattr(0, 1, (struct termios  const  *)(& termnew));
#line 1205
      tmp = fgets((char */* __restrict  */)cpassword, 50, (FILE */* __restrict  */)stdin);
#line 1206
      tcsetattr(0, 1, (struct termios  const  *)(& termold));
#line 1207
      tmp___55 = strlen((char const   *)cpassword);
#line 1207
      i = (int )(tmp___55 - 1UL);
      }
#line 1208
      if ((int )*(cpassword + i) == 10) {
#line 1209
        *(cpassword + i) = (char)0;
#line 1210
        if ((int )*(cpassword + (i - 1)) == 13) {
#line 1211
          *(cpassword + (i - 1)) = (char)0;
        }
      }
      {
#line 1213
      printf((char const   */* __restrict  */)"\n");
      }
    }
  }
  {
#line 1223
  tmp___60 = strlen((char const   *)cpassword);
  }
#line 1223
  if (tmp___60) {
#line 1252
    if (g_creds->hashnt) {
#line 1252
      goto _L___1;
    } else
#line 1252
    if (magic_detect) {
#line 1252
      goto _L___1;
    } else
#line 1252
    if (interactivehash) {
      _L___1: /* CIL Label */ 
      {
#line 1253
      tmp = ntlm_hash_nt_password(cpassword);
      }
#line 1254
      if (g_creds) {
#line 1254
        if (tmp) {
          {
#line 1254
          memcpy((void */* __restrict  */)(g_creds->passnt), (void const   */* __restrict  */)tmp,
                 (size_t )21);
          }
        }
      }
      {
#line 1255
      free((void *)tmp);
      }
    }
#line 1256
    if (g_creds->hashlm) {
#line 1256
      goto _L___2;
    } else
#line 1256
    if (magic_detect) {
#line 1256
      goto _L___2;
    } else
#line 1256
    if (interactivehash) {
      _L___2: /* CIL Label */ 
      {
#line 1257
      tmp = ntlm_hash_lm_password(cpassword);
      }
#line 1258
      if (g_creds) {
#line 1258
        if (tmp) {
          {
#line 1258
          memcpy((void */* __restrict  */)(g_creds->passlm), (void const   */* __restrict  */)tmp,
                 (size_t )21);
          }
        }
      }
      {
#line 1259
      free((void *)tmp);
      }
    }
#line 1260
    if (g_creds->hashntlm2) {
#line 1260
      goto _L___3;
    } else
#line 1260
    if (magic_detect) {
#line 1260
      goto _L___3;
    } else
#line 1260
    if (interactivehash) {
      _L___3: /* CIL Label */ 
      {
#line 1261
      tmp = ntlm2_hash_password(cuser, cdomain, cpassword);
      }
#line 1262
      if (g_creds) {
#line 1262
        if (tmp) {
          {
#line 1262
          memcpy((void */* __restrict  */)(g_creds->passntlm2), (void const   */* __restrict  */)tmp,
                 (size_t )16);
          }
        }
      }
      {
#line 1263
      free((void *)tmp);
      }
    }
    {
#line 1265
    tmp___59 = strlen((char const   *)cpassword);
#line 1265
    memset((void *)cpassword, 0, tmp___59);
    }
  } else {
    {
#line 1224
    tmp___56 = strlen((char const   *)cpassntlm2);
    }
#line 1224
    if (tmp___56) {
      {
#line 1225
      tmp = scanmem(cpassntlm2, 8);
      }
#line 1226
      if (! tmp) {
        {
#line 1227
        syslog(3, "Invalid PassNTLMv2 hash, terminating\n");
#line 1228
        exit(1);
        }
      }
#line 1230
      if (g_creds) {
#line 1230
        if (tmp) {
          {
#line 1230
          memcpy((void */* __restrict  */)(g_creds->passntlm2), (void const   */* __restrict  */)tmp,
                 (size_t )16);
          }
        }
      }
      {
#line 1231
      free((void *)tmp);
      }
    }
    {
#line 1233
    tmp___57 = strlen((char const   *)cpassnt);
    }
#line 1233
    if (tmp___57) {
      {
#line 1234
      tmp = scanmem(cpassnt, 8);
      }
#line 1235
      if (! tmp) {
        {
#line 1236
        syslog(3, "Invalid PassNT hash, terminating\n");
#line 1237
        exit(1);
        }
      }
#line 1239
      if (g_creds) {
#line 1239
        if (tmp) {
          {
#line 1239
          memcpy((void */* __restrict  */)(g_creds->passnt), (void const   */* __restrict  */)tmp,
                 (size_t )16);
          }
        }
      }
      {
#line 1240
      free((void *)tmp);
      }
    }
    {
#line 1242
    tmp___58 = strlen((char const   *)cpasslm);
    }
#line 1242
    if (tmp___58) {
      {
#line 1243
      tmp = scanmem(cpasslm, 8);
      }
#line 1244
      if (! tmp) {
        {
#line 1245
        syslog(3, "Invalid PassLM hash, terminating\n");
#line 1246
        exit(1);
        }
      }
#line 1248
      if (g_creds) {
#line 1248
        if (tmp) {
          {
#line 1248
          memcpy((void */* __restrict  */)(g_creds->passlm), (void const   */* __restrict  */)tmp,
                 (size_t )16);
          }
        }
      }
      {
#line 1249
      free((void *)tmp);
      }
    }
  }
#line 1268
  if (g_creds) {
#line 1268
    if (cuser) {
      {
#line 1268
      strlcpy(g_creds->user, (char const   *)cuser, (size_t )50);
      }
    }
  }
#line 1269
  if (g_creds) {
#line 1269
    if (cdomain) {
      {
#line 1269
      strlcpy(g_creds->domain, (char const   *)cdomain, (size_t )50);
      }
    }
  }
#line 1270
  if (g_creds) {
#line 1270
    if (cworkstation) {
      {
#line 1270
      strlcpy(g_creds->workstation, (char const   *)cworkstation, (size_t )50);
      }
    }
  }
  {
#line 1272
  free((void *)cuser);
#line 1273
  free((void *)cdomain);
#line 1274
  free((void *)cworkstation);
#line 1275
  free((void *)cpassword);
#line 1276
  free((void *)cpassntlm2);
#line 1277
  free((void *)cpassnt);
#line 1278
  free((void *)cpasslm);
#line 1279
  free((void *)cauth);
  }
#line 1285
  if (magic_detect) {
    {
#line 1286
    magic_auth_detect((char const   *)magic_detect);
    }
#line 1287
    goto bailout;
  }
#line 1290
  if (interactivehash) {
#line 1291
    if (g_creds->passlm) {
      {
#line 1292
      tmp = printmem(g_creds->passlm, (size_t )16, 8);
#line 1293
      printf((char const   */* __restrict  */)"PassLM          %s\n", tmp);
#line 1294
      free((void *)tmp);
      }
    }
#line 1297
    if (g_creds->passnt) {
      {
#line 1298
      tmp = printmem(g_creds->passnt, (size_t )16, 8);
#line 1299
      printf((char const   */* __restrict  */)"PassNT          %s\n", tmp);
#line 1300
      free((void *)tmp);
      }
    }
#line 1303
    if (g_creds->passntlm2) {
      {
#line 1304
      tmp = printmem(g_creds->passntlm2, (size_t )16, 8);
#line 1305
      printf((char const   */* __restrict  */)"PassNTLMv2      %s    # Only for user \'%s\', domain \'%s\'\n",
             tmp, g_creds->user, g_creds->domain);
#line 1307
      free((void *)tmp);
      }
    }
#line 1309
    goto bailout;
  }
#line 1315
  if (! ntlmbasic) {
#line 1315
    if (g_creds->hashnt) {
#line 1315
      if (! (g_creds->passnt)) {
        {
#line 1319
        syslog(3, "Parent proxy account password (or required hashes) missing.\n");
#line 1320
        myexit(1);
        }
      } else {
#line 1315
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 1315
    if (g_creds->hashlm) {
#line 1315
      if (! (g_creds->passlm)) {
        {
#line 1319
        syslog(3, "Parent proxy account password (or required hashes) missing.\n");
#line 1320
        myexit(1);
        }
      } else {
#line 1315
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 1315
    if (g_creds->hashntlm2) {
#line 1315
      if (! (g_creds->passntlm2)) {
        {
#line 1319
        syslog(3, "Parent proxy account password (or required hashes) missing.\n");
#line 1320
        myexit(1);
        }
      }
    }
  }
#line 1329
  if (asdaemon) {
#line 1330
    if (debug) {
      {
#line 1331
      printf((char const   */* __restrict  */)"Forking into background as requested.\n");
      }
    }
    {
#line 1333
    i = fork();
    }
#line 1334
    if (i == -1) {
      {
#line 1335
      perror("Fork into background failed");
#line 1336
      myexit(1);
      }
    } else
#line 1337
    if (i) {
      {
#line 1338
      myexit(0);
      }
    }
    {
#line 1340
    setsid();
#line 1341
    umask((__mode_t )0);
#line 1342
    w = chdir("/");
#line 1343
    i = open("/dev/null", 2);
    }
#line 1344
    if (i >= 0) {
      {
#line 1345
      dup2(i, 0);
#line 1346
      dup2(i, 1);
#line 1347
      dup2(i, 2);
      }
#line 1348
      if (i > 2) {
        {
#line 1349
        close(i);
        }
      }
    }
  }
#line 1357
  if (asdaemon) {
    {
#line 1358
    openlog("cntlm", 3, 3 << 3);
#line 1359
    syslog(6, "Daemon ready");
    }
  } else {
    {
#line 1361
    openlog("cntlm", 35, 3 << 3);
#line 1362
    syslog(6, "Cntlm ready, staying in the foreground");
    }
  }
  {
#line 1368
  tmp___68 = strlen((char const   *)cuid);
  }
#line 1368
  if (tmp___68) {
    {
#line 1369
    tmp___66 = getuid();
    }
#line 1369
    if (tmp___66) {
      {
#line 1369
      tmp___67 = geteuid();
      }
#line 1369
      if (tmp___67) {
        {
#line 1370
        tmp___61 = getgid();
#line 1370
        tmp___62 = getuid();
#line 1370
        syslog(4, "No root privileges; keeping identity %d:%d\n", tmp___62, tmp___61);
        }
      } else {
#line 1369
        goto _L___6;
      }
    } else {
      _L___6: /* CIL Label */ 
      {
#line 1372
      tmp___63 = __ctype_b_loc();
      }
#line 1372
      if ((int const   )*(*tmp___63 + (int )*(cuid + 0)) & 2048) {
        {
#line 1373
        nuid = atoi((char const   *)cuid);
#line 1374
        ngid = nuid;
        }
#line 1375
        if (nuid <= 0) {
          {
#line 1376
          syslog(3, "Numerical uid parameter invalid\n");
#line 1377
          myexit(1);
          }
        }
      } else {
        {
#line 1380
        pw = getpwnam((char const   *)cuid);
        }
#line 1381
        if (! pw) {
          {
#line 1382
          syslog(3, "Username %s in -U is invalid\n", cuid);
#line 1383
          myexit(1);
          }
        } else
#line 1381
        if (! pw->pw_uid) {
          {
#line 1382
          syslog(3, "Username %s in -U is invalid\n", cuid);
#line 1383
          myexit(1);
          }
        }
#line 1385
        nuid = (int )pw->pw_uid;
#line 1386
        ngid = (int )pw->pw_gid;
      }
      {
#line 1388
      setgid((__gid_t )ngid);
#line 1389
      i = setuid((__uid_t )nuid);
#line 1390
      tmp___64 = __errno_location();
#line 1390
      tmp___65 = strerror(*tmp___64);
#line 1390
      syslog(6, "Changing uid:gid to %d:%d - %s\n", nuid, ngid, tmp___65);
      }
#line 1391
      if (i) {
        {
#line 1392
        syslog(3, "Terminating\n");
#line 1393
        myexit(1);
        }
      }
    }
  }
  {
#line 1402
  tmp___72 = strlen((char const   *)cpidfile);
  }
#line 1402
  if (tmp___72) {
    {
#line 1403
    umask((__mode_t )0);
#line 1404
    cd = open((char const   *)cpidfile, 577, 420);
    }
#line 1405
    if (cd < 0) {
      {
#line 1406
      syslog(3, "Error creating a new PID file\n");
#line 1407
      myexit(1);
      }
    }
    {
#line 1410
    tmp = new((size_t )50);
#line 1411
    tmp___69 = getpid();
#line 1411
    snprintf((char */* __restrict  */)tmp, (size_t )50, (char const   */* __restrict  */)"%d\n",
             tmp___69);
#line 1412
    tmp___70 = strlen((char const   *)tmp);
#line 1412
    tmp___71 = write(cd, (void const   *)tmp, tmp___70);
#line 1412
    w = (int )tmp___71;
#line 1413
    free((void *)tmp);
#line 1414
    close(cd);
    }
  }
  {
#line 1422
  signal(13, (void (*)(int  ))1);
#line 1423
  signal(2, & sighandler);
#line 1424
  signal(15, & sighandler);
#line 1425
  signal(1, & sighandler);
#line 1430
  tmp___73 = time((time_t *)((void *)0));
#line 1430
  srandom((unsigned int )tmp___73);
  }
  {
#line 1446
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 1446
    if (! (quit == 0)) {
#line 1446
      if (tc != tj) {
#line 1446
        if (! (quit < 2)) {
#line 1446
          goto while_break___15;
        }
      } else {
#line 1446
        goto while_break___15;
      }
    }
#line 1453
    tid = 0;
    {
#line 1455
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 1455
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& set.fds_bits[0]): "memory");
#line 1455
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 1460
    t = proxyd_list;
    {
#line 1461
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 1461
      if (! t) {
#line 1461
        goto while_break___17;
      }
#line 1462
      set.fds_bits[t->key / (unsigned long )(8 * (int )sizeof(__fd_mask ))] |= 1L << t->key % (unsigned long )(8 * (int )sizeof(__fd_mask ));
#line 1463
      t = t->next;
    }
    while_break___17: /* CIL Label */ ;
    }
#line 1469
    t = socksd_list;
    {
#line 1470
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 1470
      if (! t) {
#line 1470
        goto while_break___18;
      }
#line 1471
      set.fds_bits[t->key / (unsigned long )(8 * (int )sizeof(__fd_mask ))] |= 1L << t->key % (unsigned long )(8 * (int )sizeof(__fd_mask ));
#line 1472
      t = t->next;
    }
    while_break___18: /* CIL Label */ ;
    }
#line 1478
    t = tunneld_list;
    {
#line 1479
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 1479
      if (! t) {
#line 1479
        goto while_break___19;
      }
#line 1480
      set.fds_bits[t->key / (unsigned long )(8 * (int )sizeof(__fd_mask ))] |= 1L << t->key % (unsigned long )(8 * (int )sizeof(__fd_mask ));
#line 1481
      t = t->next;
    }
    while_break___19: /* CIL Label */ ;
    }
    {
#line 1484
    tv.tv_sec = (__time_t )1;
#line 1485
    tv.tv_usec = (__suseconds_t )0;
#line 1498
    cd = select(1024, (fd_set */* __restrict  */)(& set), (fd_set */* __restrict  */)((void *)0),
                (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
#line 1499
    if (cd > 0) {
#line 1500
      i = 0;
      {
#line 1500
      while (1) {
        while_continue___20: /* CIL Label */ ;
#line 1500
        if (! (i < 1024)) {
#line 1500
          goto while_break___20;
        }
#line 1501
        if (! ((set.fds_bits[i / (8 * (int )sizeof(__fd_mask ))] & (1L << i % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
#line 1502
          goto __Cont;
        }
        {
#line 1504
        clen = (socklen_t )sizeof(caddr);
#line 1505
        cd = accept(i, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& caddr)),
                    (socklen_t */* __restrict  */)(& clen));
        }
#line 1507
        if (cd < 0) {
          {
#line 1508
          tmp___74 = __errno_location();
#line 1508
          tmp___75 = strerror(*tmp___74);
#line 1508
          syslog(3, "Serious error during accept: %s\n", tmp___75);
          }
#line 1509
          goto __Cont;
        }
        {
#line 1515
        tmp___81 = acl_check(rules, caddr.sin_addr);
        }
#line 1515
        if ((unsigned int )tmp___81 != 0U) {
          {
#line 1516
          tmp___76 = ntohs(caddr.sin_port);
#line 1516
          tmp___77 = inet_ntoa(caddr.sin_addr);
#line 1516
          syslog(4, "Connection denied for %s:%d\n", tmp___77, (int )tmp___76);
#line 1518
          tmp___78 = inet_ntoa(caddr.sin_addr);
#line 1518
          tmp = gen_denied_page((char const   *)tmp___78);
#line 1519
          tmp___79 = strlen((char const   *)tmp);
#line 1519
          tmp___80 = write(cd, (void const   *)tmp, tmp___79);
#line 1519
          w = (int )tmp___80;
#line 1520
          free((void *)tmp);
#line 1521
          close(cd);
          }
#line 1522
          goto __Cont;
        }
        {
#line 1533
        pthread_attr_init(& pattr);
#line 1534
        pthread_attr_setstacksize(& pattr, (sizeof(void *) * 8UL) * 1024UL);
#line 1536
        pthread_attr_setguardsize(& pattr, (size_t )256);
#line 1539
        tmp___86 = plist_in(proxyd_list, (unsigned long )i);
        }
#line 1539
        if (tmp___86) {
          {
#line 1540
          tmp___82 = new(sizeof(struct thread_arg_s ));
#line 1540
          data = (struct thread_arg_s *)tmp___82;
#line 1541
          data->fd = cd;
#line 1542
          data->addr = caddr;
          }
#line 1543
          if (! serialize) {
            {
#line 1544
            tid = pthread_create((pthread_t */* __restrict  */)(& pthr), (pthread_attr_t const   */* __restrict  */)(& pattr),
                                 & proxy_thread, (void */* __restrict  */)((void *)data));
            }
          } else {
            {
#line 1546
            proxy_thread((void *)data);
            }
          }
        } else {
          {
#line 1547
          tmp___85 = plist_in(socksd_list, (unsigned long )i);
          }
#line 1547
          if (tmp___85) {
            {
#line 1548
            tmp___83 = new(sizeof(struct thread_arg_s ));
#line 1548
            data = (struct thread_arg_s *)tmp___83;
#line 1549
            data->fd = cd;
#line 1550
            data->addr = caddr;
#line 1551
            tid = pthread_create((pthread_t */* __restrict  */)(& pthr), (pthread_attr_t const   */* __restrict  */)(& pattr),
                                 & socks5_thread, (void */* __restrict  */)((void *)data));
            }
          } else {
            {
#line 1553
            tmp___84 = new(sizeof(struct thread_arg_s ));
#line 1553
            data = (struct thread_arg_s *)tmp___84;
#line 1554
            data->fd = cd;
#line 1555
            data->addr = caddr;
#line 1556
            data->target = plist_get(tunneld_list, i);
#line 1557
            tid = pthread_create((pthread_t */* __restrict  */)(& pthr), (pthread_attr_t const   */* __restrict  */)(& pattr),
                                 & tunnel_thread, (void */* __restrict  */)((void *)data));
            }
          }
        }
        {
#line 1560
        pthread_attr_destroy(& pattr);
        }
#line 1562
        if (tid) {
          {
#line 1563
          syslog(3, "Serious error during pthread_create: %d\n", tid);
          }
        } else {
#line 1565
          tc ++;
        }
        __Cont: /* CIL Label */ 
#line 1500
        i ++;
      }
      while_break___20: /* CIL Label */ ;
      }
    } else
#line 1567
    if (cd < 0) {
#line 1567
      if (! quit) {
        {
#line 1568
        tmp___87 = __errno_location();
#line 1568
        tmp___88 = strerror(*tmp___87);
#line 1568
        syslog(3, "Serious error during select: %s\n", tmp___88);
        }
      }
    }
#line 1570
    if (threads_list) {
      {
#line 1571
      pthread_mutex_lock(& threads_mtx);
#line 1572
      t = threads_list;
      }
      {
#line 1573
      while (1) {
        while_continue___21: /* CIL Label */ ;
#line 1573
        if (! t) {
#line 1573
          goto while_break___21;
        }
        {
#line 1574
        tmp___89 = t->next;
#line 1575
        tid = pthread_join(t->key, (void **)((void *)(& i)));
        }
#line 1577
        if (! tid) {
#line 1578
          tj ++;
#line 1579
          if (debug) {
            {
#line 1580
            printf((char const   */* __restrict  */)"Joining thread %lu; rc: %d\n",
                   t->key, i);
            }
          }
        } else {
          {
#line 1582
          syslog(3, "Serious error during pthread_join: %d\n", tid);
          }
        }
        {
#line 1584
        free((void *)t);
#line 1585
        t = tmp___89;
        }
      }
      while_break___21: /* CIL Label */ ;
      }
      {
#line 1587
      threads_list = (plist_t )((void *)0);
#line 1588
      pthread_mutex_unlock(& threads_mtx);
      }
    }
  }
  while_break___15: /* CIL Label */ ;
  }
  bailout: 
  {
#line 1593
  tmp___90 = strlen((char const   *)cpidfile);
  }
#line 1593
  if (tmp___90) {
    {
#line 1594
    unlink((char const   *)cpidfile);
    }
  }
  {
#line 1596
  syslog(6, "Terminating with %d active threads\n", tc - tj);
#line 1597
  pthread_mutex_lock(& connection_mtx);
#line 1598
  plist_free(connection_list);
#line 1599
  pthread_mutex_unlock(& connection_mtx);
#line 1601
  hlist_free(header_list);
#line 1602
  plist_free(scanner_agent_list);
#line 1603
  plist_free(noproxy_list);
#line 1604
  plist_free(tunneld_list);
#line 1605
  plist_free(proxyd_list);
#line 1606
  plist_free(socksd_list);
#line 1607
  plist_free(rules);
#line 1609
  free((void *)cuid);
#line 1610
  free((void *)cpidfile);
#line 1611
  free((void *)magic_detect);
#line 1612
  free((void *)g_creds);
#line 1614
  plist_free(parent_list);
#line 1616
  exit(0);
  }
}
}
#line 29 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/pages.c"
char *gen_407_page(char const   *http ) 
{ 
  char *tmp ;

  {
#line 31
  if ((unsigned long )http == (unsigned long )((void *)0)) {
#line 32
    http = "HTTP/1.0";
  }
  {
#line 33
  tmp = new((size_t )4096);
#line 34
  snprintf((char */* __restrict  */)tmp, (size_t )4095, (char const   */* __restrict  */)"%s 407 Access denied\r\nProxy-Authenticate: Basic realm=\"Cntlm Proxy\"\r\nContent-Type: text/html\r\n\r\n<html><body><h1>407 Access denied</h1><p><a href=\'http://cntlm.sf.net/\'>Cntlm</a> requests your credentials for proxy access.</p></body></html>",
           http);
  }
#line 40
  return (tmp);
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/pages.c"
char *gen_401_page(char const   *http , char const   *host , int port ) 
{ 
  char *tmp ;

  {
#line 45
  if ((unsigned long )http == (unsigned long )((void *)0)) {
#line 46
    http = "HTTP/1.0";
  }
  {
#line 47
  tmp = new((size_t )4096);
#line 48
  snprintf((char */* __restrict  */)tmp, (size_t )4095, (char const   */* __restrict  */)"%s 401 Access denied\r\nWWW-Authenticate: Basic realm=\"%s:%d\"\r\nContent-Type: text/html\r\n\r\n<html><body><h1>401 Access denied</h1><p><a href=\'http://cntlm.sf.net/\'>Cntlm</a> proxy requests your credentials for this URL.</p></body></html>",
           http, host, port);
  }
#line 54
  return (tmp);
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/pages.c"
char *gen_denied_page(char const   *ip ) 
{ 
  char *tmp ;

  {
#line 59
  if ((unsigned long )ip == (unsigned long )((void *)0)) {
#line 60
    ip = "client";
  }
  {
#line 61
  tmp = new((size_t )4096);
#line 62
  snprintf((char */* __restrict  */)tmp, (size_t )4095, (char const   */* __restrict  */)"HTTP/1.0 407 Access denied\r\nContent-Type: text/html\r\n\r\n<html><body><h1>Access denied</h1><p>Your request has been declined, %s is not allowed to connect.</p></body></html>",
           ip);
  }
#line 67
  return (tmp);
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/pages.c"
char *gen_502_page(char const   *http , char const   *msg ) 
{ 
  char *tmp ;

  {
#line 72
  if ((unsigned long )http == (unsigned long )((void *)0)) {
#line 73
    http = "HTTP/1.0";
  }
#line 74
  if ((unsigned long )msg == (unsigned long )((void *)0)) {
#line 75
    msg = "Proxy error";
  }
  {
#line 76
  tmp = new((size_t )4096);
#line 77
  snprintf((char */* __restrict  */)tmp, (size_t )4095, (char const   */* __restrict  */)"%s 502 %s\r\nContent-Type: text/html\r\n\r\n<html><body><h1>502 %s</h1><p><a href=\'http://cntlm.sf.net/\'>Cntlm</a> proxy failed to complete the request.</p></body></html>",
           http, msg, msg);
  }
#line 82
  return (tmp);
}
}
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 342 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 127 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.h"
hlist_t hlist_mod(hlist_t list , char *key , char *value , int add ) ;
#line 134
void hlist_dump(hlist_t list ) ;
#line 140
char *lowercase(char *str ) ;
#line 144
char *urlencode(char const   *str ) ;
#line 147
rr_data_t copy_rr_data(rr_data_t dst , rr_data_t src ) ;
#line 148
rr_data_t dup_rr_data(rr_data_t data ) ;
#line 149
rr_data_t reset_rr_data(rr_data_t data ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/socket.h"
int so_recvln(int fd , char **buf , int *size ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/http.h"
int headers_send(int fd , rr_data_t data ) ;
#line 46
length_t http_has_body(rr_data_t request , rr_data_t response ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/forward.h"
int proxy_authenticate(int *sd , rr_data_t request , rr_data_t response , struct auth_s *credentials ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/scanner.h"
int scanner_hook(rr_data_t request , rr_data_t response , struct auth_s *credentials ,
                 int cd , int *sd , long maxKBs ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/scanner.c"
int scanner_hook(rr_data_t request , rr_data_t response , struct auth_s *credentials ,
                 int cd , int *sd , long maxKBs ) 
{ 
  char *buf ;
  char *line ;
  char *pos ;
  char *tmp ;
  char *pat ;
  char *post ;
  char *isaid ;
  char *uurl ;
  int bsize ;
  int lsize ;
  int size ;
  int len ;
  int i ;
  int w ;
  int nc ;
  rr_data_t newreq ;
  rr_data_t newres ;
  plist_t list ;
  int ok ;
  int done ;
  int headers_initiated ;
  long c ;
  long progress ;
  long filesize ;
  length_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  ssize_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  ssize_t tmp___11 ;
  size_t tmp___12 ;
  ssize_t tmp___13 ;
  unsigned short const   **tmp___14 ;
  unsigned short const   **tmp___15 ;
  size_t tmp___16 ;
  int tmp___17 ;
  long tmp___18 ;
  int tmp___19 ;
  size_t tmp___20 ;
  ssize_t tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;
  ssize_t tmp___27 ;

  {
#line 47
  ok = 1;
#line 48
  done = 0;
#line 49
  headers_initiated = 0;
#line 50
  progress = 0L;
#line 50
  filesize = 0L;
#line 55
  if (! request->req) {
#line 59
    return (3);
  } else
#line 55
  if (response->code != 200) {
#line 59
    return (3);
  } else {
    {
#line 55
    tmp___0 = http_has_body(request, response);
    }
#line 55
    if (tmp___0 != -1LL) {
#line 59
      return (3);
    } else {
      {
#line 55
      tmp___1 = hlist_subcmp(response->headers, "Transfer-Encoding", "chunked");
      }
#line 55
      if (tmp___1) {
#line 59
        return (3);
      } else {
        {
#line 55
        tmp___2 = hlist_subcmp(response->headers, "Proxy-Connection", "close");
        }
#line 55
        if (! tmp___2) {
#line 59
          return (3);
        }
      }
    }
  }
  {
#line 61
  tmp = hlist_get(request->headers, "User-Agent");
  }
#line 62
  if (tmp) {
    {
#line 63
    tmp___3 = strdup((char const   *)tmp);
#line 63
    tmp = lowercase(tmp___3);
#line 64
    list = scanner_agent_list;
    }
    {
#line 65
    while (1) {
      while_continue: /* CIL Label */ ;
#line 65
      if (! list) {
#line 65
        goto while_break;
      }
      {
#line 66
      tmp___4 = strdup((char const   *)list->aux);
#line 66
      pat = lowercase(tmp___4);
      }
#line 67
      if (debug) {
        {
#line 68
        printf((char const   */* __restrict  */)"scanner_hook: matching U-A header (%s) to %s\n",
               tmp, pat);
        }
      }
      {
#line 69
      tmp___5 = fnmatch((char const   *)pat, (char const   *)tmp, 0);
      }
#line 69
      if (! tmp___5) {
#line 70
        if (debug) {
          {
#line 71
          printf((char const   */* __restrict  */)"scanner_hook: positive match!\n");
          }
        }
        {
#line 72
        maxKBs = 0L;
#line 73
        free((void *)pat);
        }
#line 74
        goto while_break;
      }
      {
#line 76
      free((void *)pat);
#line 77
      list = list->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 79
    free((void *)tmp);
    }
  }
  {
#line 82
  bsize = 4096;
#line 83
  buf = new((size_t )bsize);
#line 85
  len = 0;
  }
  {
#line 86
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 87
    tmp___6 = read(*sd, (void *)(buf + len), (size_t )((4096 - len) - 1));
#line 87
    size = (int )tmp___6;
    }
#line 88
    if (debug) {
      {
#line 89
      printf((char const   */* __restrict  */)"scanner_hook: read %d of %d\n", size,
             4096 - len);
      }
    }
#line 90
    if (size > 0) {
#line 91
      len += size;
    }
#line 86
    if (size > 0) {
#line 86
      if (! (len < 4095)) {
#line 86
        goto while_break___0;
      }
    } else {
#line 86
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 94
  tmp___25 = strstr((char const   *)buf, "<title>Downloading status</title>");
  }
#line 94
  if (tmp___25) {
    {
#line 94
    pos = strstr((char const   *)buf, "ISAServerUniqueID=");
    }
#line 94
    if (pos) {
      {
#line 94
      pos = strchr((char const   *)pos, '\"');
      }
#line 94
      if (pos) {
        {
#line 95
        pos ++;
#line 96
        tmp___7 = strlen((char const   *)pos);
#line 96
        c = (long )tmp___7;
#line 97
        i = 0;
        }
        {
#line 97
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 97
          if ((long )i < c) {
#line 97
            if (! ((int )*(pos + i) != 34)) {
#line 97
              goto while_break___1;
            }
          } else {
#line 97
            goto while_break___1;
          }
#line 97
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 99
        if ((int )*(pos + i) == 34) {
          {
#line 100
          isaid = substr((char const   *)pos, 0, i);
          }
#line 101
          if (debug) {
            {
#line 102
            printf((char const   */* __restrict  */)"scanner_hook: ISA id = %s\n",
                   isaid);
            }
          }
          {
#line 104
          lsize = 4096;
#line 105
          line = new((size_t )lsize);
          }
          {
#line 106
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 107
            i = so_recvln(*sd, & line, & lsize);
#line 109
            tmp___8 = strlen((char const   *)line);
#line 109
            c = (long )tmp___8;
            }
#line 110
            if ((long )len + c >= (long )bsize) {
              {
#line 111
              bsize *= 2;
#line 112
              tmp___9 = realloc((void *)buf, (size_t )bsize);
#line 112
              tmp = (char *)tmp___9;
              }
#line 113
              if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 114
                goto while_break___2;
              } else {
#line 116
                buf = tmp;
              }
            }
            {
#line 119
            strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)line);
#line 120
            len = (int )((long )len + c);
            }
#line 122
            if (i >= 0) {
              {
#line 122
              pos = strstr((char const   *)line, "UpdatePage(");
              }
#line 122
              if (pos) {
                {
#line 122
                tmp___14 = __ctype_b_loc();
                }
#line 122
                if ((int const   )*(*tmp___14 + (int )*(pos + 11)) & 2048) {
#line 122
                  goto _L;
                } else {
#line 122
                  goto _L___0;
                }
              } else {
                _L___0: /* CIL Label */ 
                {
#line 122
                pos = strstr((char const   *)line, "DownloadFinished(");
                }
#line 122
                if (pos) {
                  {
#line 122
                  tmp___15 = __ctype_b_loc();
                  }
#line 122
                  if ((int const   )*(*tmp___15 + (int )*(pos + 17)) & 2048) {
#line 122
                    done = 1;
#line 122
                    if (done) {
                      _L: /* CIL Label */ 
#line 129
                      if (debug) {
                        {
#line 130
                        printf((char const   */* __restrict  */)"scanner_hook: %s",
                               line);
                        }
                      }
                      {
#line 132
                      pos = strstr((char const   *)line, "To be downloaded");
                      }
#line 132
                      if (pos) {
                        {
#line 133
                        filesize = atol((char const   *)(pos + 16));
                        }
#line 134
                        if (debug) {
#line 135
                          if (filesize > 0L) {
                            {
#line 136
                            printf((char const   */* __restrict  */)"scanner_hook: file size detected: %ld KiBs (max: %ld)\n",
                                   filesize / 1024L, maxKBs);
                            }
                          } else {
                            {
#line 138
                            printf((char const   */* __restrict  */)"scanner_hook: file size unknown -- quitting\n");
                            }
#line 139
                            goto while_break___2;
                          }
                        }
#line 143
                        if (maxKBs) {
#line 143
                          if (maxKBs == 1L) {
#line 144
                            goto while_break___2;
                          } else
#line 143
                          if (filesize / 1024L > maxKBs) {
#line 144
                            goto while_break___2;
                          }
                        }
                        {
#line 152
                        headers_initiated = 1;
#line 153
                        tmp = new((size_t )50);
#line 154
                        snprintf((char */* __restrict  */)tmp, (size_t )50, (char const   */* __restrict  */)"%s 200 OK\r\n",
                                 request->http);
#line 155
                        tmp___10 = strlen((char const   *)tmp);
#line 155
                        tmp___11 = write(cd, (void const   *)tmp, tmp___10);
#line 155
                        w = (int )tmp___11;
#line 156
                        free((void *)tmp);
                        }
                      }
#line 159
                      if (! headers_initiated) {
#line 160
                        if (debug) {
                          {
#line 161
                          printf((char const   */* __restrict  */)"scanner_hook: Giving up, \"To be downloaded\" line not found!\n");
                          }
                        }
#line 162
                        goto while_break___2;
                      }
#line 168
                      if (! done) {
                        {
#line 169
                        tmp = new((size_t )50);
#line 170
                        progress = atol((char const   *)(line + 12));
#line 171
                        snprintf((char */* __restrict  */)tmp, (size_t )50, (char const   */* __restrict  */)"ISA-Scanner: %ld of %ld\r\n",
                                 progress, filesize);
#line 172
                        tmp___12 = strlen((char const   *)tmp);
#line 172
                        tmp___13 = write(cd, (void const   *)tmp, tmp___12);
#line 172
                        w = (int )tmp___13;
#line 173
                        free((void *)tmp);
                        }
                      }
#line 179
                      if (! filesize) {
#line 179
                        if (maxKBs) {
#line 179
                          if (maxKBs != 1L) {
#line 179
                            if (progress / 1024L > maxKBs) {
#line 180
                              goto while_break___2;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
#line 106
            if (i > 0) {
#line 106
              if (! (! done)) {
#line 106
                goto while_break___2;
              }
            } else {
#line 106
              goto while_break___2;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
#line 184
          if (i >= 0) {
#line 184
            if (done) {
              {
#line 184
              tmp___23 = strstr((char const   *)line, "\",\"");
#line 184
              pos = tmp___23 + 3;
              }
#line 184
              if (pos) {
                {
#line 184
                tmp___24 = strchr((char const   *)pos, '\"');
#line 184
                c = tmp___24 - pos;
                }
#line 184
                if (c > 0L) {
                  {
#line 185
                  tmp = substr((char const   *)pos, 0, (int )c);
#line 186
                  pos = urlencode((char const   *)tmp);
#line 187
                  free((void *)tmp);
#line 189
                  uurl = urlencode((char const   *)request->url);
#line 191
                  post = new((size_t )4096);
#line 192
                  snprintf((char */* __restrict  */)post, (size_t )4095, (char const   */* __restrict  */)"%surl=%s&%sSaveToDisk=YES&%sOrig=%s",
                           isaid, pos, isaid, isaid, uurl);
                  }
#line 194
                  if (debug) {
                    {
#line 195
                    printf((char const   */* __restrict  */)"scanner_hook: Getting file with URL data = %s\n",
                           request->url);
                    }
                  }
                  {
#line 197
                  tmp = new((size_t )50);
#line 198
                  tmp___16 = strlen((char const   *)post);
#line 198
                  snprintf((char */* __restrict  */)tmp, (size_t )50, (char const   */* __restrict  */)"%d",
                           (int )tmp___16);
#line 200
                  newres = new_rr_data();
#line 201
                  newreq = dup_rr_data(request);
#line 203
                  free((void *)newreq->method);
#line 204
                  newreq->method = strdup("POST");
#line 205
                  hlist_mod(newreq->headers, (char *)"Referer", request->url, 1);
#line 206
                  hlist_mod(newreq->headers, (char *)"Content-Type", (char *)"application/x-www-form-urlencoded",
                            1);
#line 207
                  hlist_mod(newreq->headers, (char *)"Content-Length", tmp, 1);
#line 208
                  free((void *)tmp);
#line 210
                  nc = proxy_connect(credentials);
#line 211
                  tmp___17 = proxy_authenticate(& nc, newreq, newres, credentials);
#line 211
                  c = (long )tmp___17;
                  }
#line 212
                  if (c) {
#line 212
                    if (newres->code == 407) {
#line 213
                      if (debug) {
                        {
#line 214
                        printf((char const   */* __restrict  */)"scanner_hook: Authentication OK, getting the file...\n");
                        }
                      }
                    } else {
#line 212
                      goto _L___1;
                    }
                  } else {
                    _L___1: /* CIL Label */ 
#line 216
                    if (debug) {
                      {
#line 217
                      printf((char const   */* __restrict  */)"scanner_hook: Authentication failed or refused!\n");
                      }
                    }
                    {
#line 218
                    close(nc);
#line 219
                    nc = 0;
                    }
                  }
                  {
#line 225
                  reset_rr_data(newres);
                  }
#line 226
                  if (nc) {
                    {
#line 226
                    tmp___19 = headers_send(nc, newreq);
                    }
#line 226
                    if (tmp___19) {
                      {
#line 226
                      tmp___20 = strlen((char const   *)post);
#line 226
                      tmp___21 = write(nc, (void const   *)post, tmp___20);
                      }
#line 226
                      if (tmp___21) {
                        {
#line 226
                        tmp___22 = headers_recv(nc, newres);
                        }
#line 226
                        if (tmp___22) {
#line 227
                          if (debug) {
                            {
#line 228
                            hlist_dump(newres->headers);
                            }
                          }
#line 234
                          if (filesize) {
#line 234
                            goto _L___2;
                          } else
#line 234
                          if (progress) {
                            _L___2: /* CIL Label */ 
                            {
#line 235
                            tmp = new((size_t )20);
                            }
#line 236
                            if (filesize) {
#line 236
                              tmp___18 = filesize;
                            } else {
#line 236
                              tmp___18 = progress;
                            }
                            {
#line 236
                            snprintf((char */* __restrict  */)tmp, (size_t )20, (char const   */* __restrict  */)"%ld",
                                     tmp___18);
#line 237
                            newres->headers = hlist_mod(newres->headers, (char *)"Content-Length",
                                                        tmp, 1);
                            }
                          }
                          {
#line 244
                          newres->skip_http = headers_initiated;
#line 245
                          copy_rr_data(response, newres);
#line 246
                          close(*sd);
#line 247
                          *sd = nc;
#line 249
                          len = 0;
#line 250
                          ok = 3;
                          }
                        } else {
#line 226
                          goto _L___5;
                        }
                      } else {
#line 226
                        goto _L___5;
                      }
                    } else {
#line 226
                      goto _L___5;
                    }
                  } else
                  _L___5: /* CIL Label */ 
#line 251
                  if (debug) {
                    {
#line 252
                    printf((char const   */* __restrict  */)"scanner_hook: New request failed\n");
                    }
                  }
                  {
#line 254
                  free((void *)newreq);
#line 255
                  free((void *)newres);
#line 256
                  free((void *)post);
#line 257
                  free((void *)uurl);
                  }
                }
              }
            }
          }
          {
#line 260
          free((void *)line);
#line 261
          free((void *)isaid);
          }
        } else
#line 262
        if (debug) {
          {
#line 263
          printf((char const   */* __restrict  */)"scanner_hook: ISA id not found\n");
          }
        }
      }
    }
  }
#line 266
  if (len) {
#line 267
    if (debug) {
      {
#line 268
      printf((char const   */* __restrict  */)"scanner_hook: flushing %d original bytes\n",
             len);
#line 269
      hlist_dump(response->headers);
      }
    }
    {
#line 272
    tmp___26 = headers_send(cd, response);
    }
#line 272
    if (! tmp___26) {
#line 273
      if (debug) {
        {
#line 274
        printf((char const   */* __restrict  */)"scanner_hook: failed to send headers\n");
        }
      }
      {
#line 275
      free((void *)buf);
      }
#line 276
      return (32768);
    }
    {
#line 279
    tmp___27 = write(cd, (void const   *)buf, (size_t )len);
#line 279
    size = (int )tmp___27;
    }
#line 280
    if (size > 0) {
#line 281
      ok = 2;
    } else {
#line 283
      ok = 32768;
    }
  }
#line 286
  if (debug) {
    {
#line 287
    printf((char const   */* __restrict  */)"scanner_hook: ending with %d\n", ok);
    }
  }
  {
#line 289
  free((void *)buf);
  }
#line 290
  return (ok);
}
}
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 321 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) random)(void) ;
#line 141 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.h"
char *uppercase(char *str ) ;
#line 142
int unicode(char **dst , char *src ) ;
#line 64 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/auth.h"
void dump_auth(struct auth_s *creds ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/ntlm.h"
int ntlm_request(char **dst , struct auth_s *creds ) ;
#line 35
int ntlm_response(char **dst , char *challenge , int challen , struct auth_s *creds ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/ntlm.c"
static void ntlm_set_key(unsigned char *src , gl_des_ctx *context ) 
{ 
  char key[8] ;

  {
  {
#line 38
  key[0] = (char )*(src + 0);
#line 39
  key[1] = (char )((((int )*(src + 0) << 7) & 255) | ((int )*(src + 1) >> 1));
#line 40
  key[2] = (char )((((int )*(src + 1) << 6) & 255) | ((int )*(src + 2) >> 2));
#line 41
  key[3] = (char )((((int )*(src + 2) << 5) & 255) | ((int )*(src + 3) >> 3));
#line 42
  key[4] = (char )((((int )*(src + 3) << 4) & 255) | ((int )*(src + 4) >> 4));
#line 43
  key[5] = (char )((((int )*(src + 4) << 3) & 255) | ((int )*(src + 5) >> 5));
#line 44
  key[6] = (char )((((int )*(src + 5) << 2) & 255) | ((int )*(src + 6) >> 6));
#line 45
  key[7] = (char )(((int )*(src + 6) << 1) & 255);
#line 47
  gl_des_setkey(context, (char const   *)(key));
  }
#line 48
  return;
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/ntlm.c"
static int ntlm_calc_resp(char **dst , char *keys , char *challenge ) 
{ 
  gl_des_ctx context ;

  {
  {
#line 53
  *dst = new((size_t )25);
#line 55
  ntlm_set_key((unsigned char *)(keys + 0), & context);
#line 56
  gl_des_ecb_crypt(& context, (char const   *)challenge, *dst, 0);
#line 58
  ntlm_set_key((unsigned char *)(keys + 7), & context);
#line 59
  gl_des_ecb_crypt(& context, (char const   *)challenge, *dst + 8, 0);
#line 61
  ntlm_set_key((unsigned char *)(keys + 14), & context);
#line 62
  gl_des_ecb_crypt(& context, (char const   *)challenge, *dst + 16, 0);
  }
#line 64
  return (24);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/ntlm.c"
static void ntlm2_calc_resp(char **nthash , int *ntlen , char **lmhash , int *lmlen ,
                            char *passnt2 , char *challenge , int tbofs , int tblen ) 
{ 
  char *tmp ;
  char *blob ;
  char *nonce ;
  char *buf ;
  int64_t tw ;
  int blen ;
  long tmp___0 ;
  long tmp___1 ;
  time_t tmp___2 ;

  {
  {
#line 73
  nonce = new((size_t )9);
#line 74
  tmp___0 = random();
#line 74
  tmp___1 = random();
#line 74
  *((uint64_t *)(nonce + 0)) = ((uint64_t )tmp___0 << 32) | (unsigned long )tmp___1;
#line 75
  tmp___2 = time((time_t *)((void *)0));
#line 75
  tw = (int64_t )(((unsigned long long )((uint64_t )tmp___2) + 11644473600ULL) * 10000000ULL);
  }
#line 77
  if (debug) {
    {
#line 78
    tmp = printmem(nonce, (size_t )8, 7);
#line 82
    printf((char const   */* __restrict  */)"NTLMv2:\n\t    Nonce: %s\n\tTimestamp: %ld\n",
           tmp, tw);
#line 84
    free((void *)tmp);
    }
  }
  {
#line 87
  blob = new((size_t )(((28 + tblen) + 4) + 1));
#line 88
  *((uint32_t *)(blob + 0)) = (uint32_t )257;
#line 89
  *((uint32_t *)(blob + 4)) = (uint32_t )0;
#line 90
  *((uint64_t *)(blob + 8)) = (uint64_t )tw;
#line 91
  *((uint64_t *)(blob + 16)) = *((uint64_t *)(nonce + 0));
#line 92
  *((uint32_t *)(blob + 24)) = (uint32_t )0;
#line 93
  memcpy((void */* __restrict  */)(blob + 28), (void const   */* __restrict  */)(challenge + tbofs),
         (size_t )tblen);
#line 94
  *((uint32_t *)((blob + 28) + tblen)) = (uint32_t )0;
#line 95
  blen = (28 + tblen) + 4;
#line 103
  *ntlen = 16 + blen;
#line 104
  *nthash = new((size_t )(*ntlen + 1));
#line 105
  buf = new((size_t )((8 + blen) + 1));
#line 106
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)(challenge + 24),
         (size_t )8);
#line 107
  memcpy((void */* __restrict  */)(buf + 8), (void const   */* __restrict  */)blob,
         (size_t )blen);
#line 108
  hmac_md5((void const   *)passnt2, (size_t )16, (void const   *)buf, (size_t )(8 + blen),
           (void *)*nthash);
#line 109
  memcpy((void */* __restrict  */)(*nthash + 16), (void const   */* __restrict  */)blob,
         (size_t )blen);
#line 110
  free((void *)buf);
#line 112
  *lmlen = 24;
#line 113
  *lmhash = new((size_t )(*lmlen + 1));
#line 114
  buf = new((size_t )17);
#line 115
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)(challenge + 24),
         (size_t )8);
#line 116
  memcpy((void */* __restrict  */)(buf + 8), (void const   */* __restrict  */)nonce,
         (size_t )8);
#line 117
  hmac_md5((void const   *)passnt2, (size_t )16, (void const   *)buf, (size_t )16,
           (void *)*lmhash);
#line 118
  memcpy((void */* __restrict  */)(*lmhash + 16), (void const   */* __restrict  */)nonce,
         (size_t )8);
#line 119
  free((void *)buf);
#line 121
  free((void *)blob);
#line 122
  free((void *)nonce);
  }
#line 123
  return;
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/ntlm.c"
static void ntlm2sr_calc_rest(char **nthash , int *ntlen , char **lmhash , int *lmlen ,
                              char *passnt , char *challenge ) 
{ 
  char *sess ;
  char *nonce ;
  char *buf ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 129
  nonce = new((size_t )9);
#line 130
  tmp = random();
#line 130
  tmp___0 = random();
#line 130
  *((uint64_t *)(nonce + 0)) = ((uint64_t )tmp << 32) | (unsigned long )tmp___0;
#line 132
  *lmlen = 24;
#line 133
  *lmhash = new((size_t )(*lmlen + 1));
#line 134
  memcpy((void */* __restrict  */)*lmhash, (void const   */* __restrict  */)nonce,
         (size_t )8);
#line 135
  memset((void *)(*lmhash + 8), 0, (size_t )16);
#line 137
  buf = new((size_t )17);
#line 138
  sess = new((size_t )17);
#line 139
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)(challenge + 24),
         (size_t )8);
#line 140
  memcpy((void */* __restrict  */)(buf + 8), (void const   */* __restrict  */)nonce,
         (size_t )8);
#line 141
  md5_buffer((char const   *)buf, (size_t )16, (void *)sess);
#line 142
  free((void *)buf);
#line 144
  *ntlen = 24;
#line 145
  ntlm_calc_resp(nthash, passnt, sess);
#line 147
  free((void *)sess);
#line 148
  free((void *)nonce);
  }
#line 149
  return;
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/ntlm.c"
char *ntlm_hash_lm_password(char *password ) 
{ 
  char magic[8] ;
  gl_des_ctx context ;
  char *keys ;
  char *pass ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 153
  magic[0] = (char)75;
#line 153
  magic[1] = (char)71;
#line 153
  magic[2] = (char)83;
#line 153
  magic[3] = (char)33;
#line 153
  magic[4] = (char)64;
#line 153
  magic[5] = (char)35;
#line 153
  magic[6] = (char)36;
#line 153
  magic[7] = (char)37;
#line 157
  keys = new((size_t )22);
#line 158
  pass = new((size_t )15);
#line 159
  tmp___2 = strlen((char const   *)password);
  }
#line 159
  if (14UL < tmp___2) {
#line 159
    tmp___1 = (size_t )14;
  } else {
    {
#line 159
    tmp___0 = strlen((char const   *)password);
#line 159
    tmp___1 = tmp___0;
    }
  }
  {
#line 159
  tmp___3 = strncpy((char */* __restrict  */)pass, (char const   */* __restrict  */)password,
                    tmp___1);
#line 159
  uppercase(tmp___3);
#line 161
  ntlm_set_key((unsigned char *)(pass + 0), & context);
#line 162
  gl_des_ecb_crypt(& context, (char const   *)(magic), keys, 0);
#line 164
  ntlm_set_key((unsigned char *)(pass + 7), & context);
#line 165
  gl_des_ecb_crypt(& context, (char const   *)(magic), keys + 8, 0);
#line 167
  memset((void *)(keys + 16), 0, (size_t )5);
#line 168
  memset((void *)pass, 0, (size_t )14);
#line 169
  free((void *)pass);
  }
#line 171
  return (keys);
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/ntlm.c"
char *ntlm_hash_nt_password(char *password ) 
{ 
  char *u16 ;
  char *keys ;
  int len ;

  {
  {
#line 178
  keys = new((size_t )22);
#line 179
  len = unicode(& u16, password);
#line 180
  md4_buffer((char const   *)u16, (size_t )len, (void *)keys);
#line 182
  memset((void *)(keys + 16), 0, (size_t )5);
#line 183
  memset((void *)u16, 0, (size_t )len);
#line 184
  free((void *)u16);
  }
#line 186
  return (keys);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/ntlm.c"
char *ntlm2_hash_password(char *username , char *domain , char *password ) 
{ 
  char *tmp ;
  char *buf ;
  char *passnt ;
  char *passnt2 ;
  int len ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 193
  passnt = ntlm_hash_nt_password(password);
#line 195
  tmp___0 = strlen((char const   *)username);
#line 195
  tmp___1 = strlen((char const   *)domain);
#line 195
  buf = new((tmp___0 + tmp___1) + 1UL);
#line 196
  strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)username);
#line 197
  strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)domain);
#line 198
  uppercase(buf);
#line 199
  len = unicode(& tmp, buf);
#line 201
  passnt2 = new((size_t )17);
#line 202
  hmac_md5((void const   *)passnt, (size_t )16, (void const   *)tmp, (size_t )len,
           (void *)passnt2);
#line 204
  free((void *)passnt);
#line 205
  free((void *)tmp);
#line 206
  free((void *)buf);
  }
#line 208
  return (passnt2);
}
}
#line 211 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/ntlm.c"
int ntlm_request(char **dst , struct auth_s *creds ) 
{ 
  char *buf ;
  char *tmp ;
  int dlen ;
  int hlen ;
  uint32_t flags ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 214
  flags = (uint32_t )45574;
#line 216
  *dst = (char *)((void *)0);
#line 217
  tmp___0 = strlen((char const   *)(creds->domain));
#line 217
  dlen = (int )tmp___0;
#line 218
  tmp___1 = strlen((char const   *)(creds->workstation));
#line 218
  hlen = (int )tmp___1;
  }
#line 220
  if (! creds->flags) {
#line 221
    if (creds->hashntlm2) {
#line 222
      flags = 2718478853U;
    } else
#line 223
    if (creds->hashnt == 2) {
#line 224
      flags = 2718478855U;
    } else
#line 225
    if (creds->hashnt) {
#line 225
      if (creds->hashlm) {
#line 226
        flags = (uint32_t )45575;
      } else {
#line 225
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 227
    if (creds->hashnt) {
#line 228
      flags = (uint32_t )45573;
    } else
#line 229
    if (creds->hashlm) {
#line 230
      flags = (uint32_t )45574;
    } else {
#line 232
      if (debug) {
        {
#line 233
        printf((char const   */* __restrict  */)"You\'re requesting with empty auth_s?!\n");
#line 234
        dump_auth(creds);
        }
      }
#line 236
      return (0);
    }
  } else {
#line 239
    flags = creds->flags;
  }
#line 241
  if (debug) {
    {
#line 242
    printf((char const   */* __restrict  */)"NTLM Request:\n");
#line 243
    printf((char const   */* __restrict  */)"\t   Domain: %s\n", creds->domain);
#line 244
    printf((char const   */* __restrict  */)"\t Hostname: %s\n", creds->workstation);
#line 245
    printf((char const   */* __restrict  */)"\t    Flags: 0x%X\n", (int )flags);
    }
  }
  {
#line 248
  buf = new((size_t )1024);
#line 249
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)"NTLMSSP\000",
         (size_t )8);
#line 250
  *((uint32_t *)(buf + 8)) = (uint32_t )1;
#line 251
  *((uint32_t *)(buf + 12)) = flags;
#line 252
  *((uint16_t *)(buf + 16)) = (uint16_t )dlen;
#line 253
  *((uint16_t *)(buf + 18)) = (uint16_t )dlen;
#line 254
  *((uint32_t *)(buf + 20)) = (uint32_t )(32 + hlen);
#line 255
  *((uint16_t *)(buf + 24)) = (uint16_t )hlen;
#line 256
  *((uint16_t *)(buf + 26)) = (uint16_t )hlen;
#line 257
  *((uint32_t *)(buf + 28)) = (uint32_t )32;
#line 259
  tmp___2 = strdup((char const   *)(creds->workstation));
#line 259
  tmp = uppercase(tmp___2);
#line 260
  memcpy((void */* __restrict  */)(buf + 32), (void const   */* __restrict  */)tmp,
         (size_t )hlen);
#line 261
  free((void *)tmp);
#line 263
  tmp___3 = strdup((char const   *)(creds->domain));
#line 263
  tmp = uppercase(tmp___3);
#line 264
  memcpy((void */* __restrict  */)((buf + 32) + hlen), (void const   */* __restrict  */)tmp,
         (size_t )dlen);
#line 265
  free((void *)tmp);
#line 267
  *dst = buf;
  }
#line 268
  return ((32 + dlen) + hlen);
}
}
#line 271 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/ntlm.c"
static char *printuc(char *src , int len ) 
{ 
  char *tmp ;
  int i ;

  {
  {
#line 275
  tmp = new((size_t )((len + 1) / 2 + 1));
#line 276
  i = 0;
  }
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;
#line 276
    if (! (i < len / 2)) {
#line 276
      goto while_break;
    }
#line 277
    *(tmp + i) = *(src + i * 2);
#line 276
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  return (tmp);
}
}
#line 298 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/ntlm.c"
int ntlm_response(char **dst , char *challenge , int challen , struct auth_s *creds ) 
{ 
  char *buf ;
  char *udomain ;
  char *uuser ;
  char *uhost ;
  char *tmp ;
  int dlen ;
  int ulen ;
  int hlen ;
  uint16_t tpos ;
  uint16_t tlen ;
  uint16_t ttype ;
  uint16_t tbofs ;
  uint16_t tblen ;
  char *lmhash ;
  char *nthash ;
  int lmlen ;
  int ntlen ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
#line 301
  ttype = (uint16_t )-1;
#line 301
  tbofs = (uint16_t )0;
#line 301
  tblen = (uint16_t )0;
#line 302
  lmhash = (char *)((void *)0);
#line 302
  nthash = (char *)((void *)0);
#line 303
  lmlen = 0;
#line 303
  ntlen = 0;
#line 305
  if (debug) {
    {
#line 306
    printf((char const   */* __restrict  */)"NTLM Challenge:\n");
#line 307
    tmp = printmem(challenge + 24, (size_t )8, 7);
#line 308
    printf((char const   */* __restrict  */)"\tChallenge: %s (len: %d)\n", tmp, challen);
#line 309
    free((void *)tmp);
#line 310
    printf((char const   */* __restrict  */)"\t    Flags: 0x%X\n", *((uint32_t *)(challenge + 20)));
    }
  }
#line 313
  if (challen > 48) {
#line 314
    tpos = *((uint16_t *)(challenge + 44));
#line 314
    tbofs = tpos;
    {
#line 315
    while (1) {
      while_continue: /* CIL Label */ ;
#line 315
      if ((int )tpos + 4 <= challen) {
#line 315
        ttype = *((uint16_t *)(challenge + (int )tpos));
#line 315
        if (! ttype) {
#line 315
          goto while_break;
        }
      } else {
#line 315
        goto while_break;
      }
#line 316
      tlen = *((uint16_t *)((challenge + (int )tpos) + 2));
#line 317
      if (((int )tpos + 4) + (int )tlen > challen) {
#line 318
        goto while_break;
      }
#line 320
      if (debug) {
        {
#line 322
        if ((int )ttype == 1) {
#line 322
          goto case_1;
        }
#line 325
        if ((int )ttype == 2) {
#line 325
          goto case_2;
        }
#line 328
        if ((int )ttype == 3) {
#line 328
          goto case_3;
        }
#line 331
        if ((int )ttype == 4) {
#line 331
          goto case_4;
        }
#line 334
        if ((int )ttype == 5) {
#line 334
          goto case_5;
        }
#line 337
        goto switch_default;
        case_1: /* CIL Label */ 
        {
#line 323
        printf((char const   */* __restrict  */)"\t   Server: ");
        }
#line 324
        goto switch_break;
        case_2: /* CIL Label */ 
        {
#line 326
        printf((char const   */* __restrict  */)"\tNT domain: ");
        }
#line 327
        goto switch_break;
        case_3: /* CIL Label */ 
        {
#line 329
        printf((char const   */* __restrict  */)"\t     FQDN: ");
        }
#line 330
        goto switch_break;
        case_4: /* CIL Label */ 
        {
#line 332
        printf((char const   */* __restrict  */)"\t   Domain: ");
        }
#line 333
        goto switch_break;
        case_5: /* CIL Label */ 
        {
#line 335
        printf((char const   */* __restrict  */)"\t      TLD: ");
        }
#line 336
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 338
        printf((char const   */* __restrict  */)"\t      %3d: ", (int )ttype);
        }
#line 339
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
        {
#line 341
        tmp = printuc((challenge + (int )tpos) + 4, (int )tlen);
#line 342
        printf((char const   */* __restrict  */)"%s\n", tmp);
#line 343
        free((void *)tmp);
        }
      }
#line 346
      tpos = (uint16_t )((int )tpos + (4 + (int )tlen));
#line 347
      tblen = (uint16_t )((int )tblen + (4 + (int )tlen));
    }
    while_break: /* CIL Label */ ;
    }
#line 350
    if (tblen) {
#line 350
      if ((int )ttype == 0) {
#line 351
        tblen = (uint16_t )((int )tblen + 4);
      }
    }
#line 353
    if (debug) {
      {
#line 354
      printf((char const   */* __restrict  */)"\t    TBofs: %d\n\t    TBlen: %d\n\t    ttype: %d\n",
             (int )tbofs, (int )tblen, (int )ttype);
      }
    }
  }
#line 358
  if (creds->hashntlm2) {
#line 358
    if (! tblen) {
#line 359
      return (0);
    }
  }
#line 362
  if (creds->hashntlm2) {
    {
#line 363
    ntlm2_calc_resp(& nthash, & ntlen, & lmhash, & lmlen, creds->passntlm2, challenge,
                    (int )tbofs, (int )tblen);
    }
  }
#line 366
  if (creds->hashnt == 2) {
    {
#line 367
    ntlm2sr_calc_rest(& nthash, & ntlen, & lmhash, & lmlen, creds->passnt, challenge);
    }
  }
#line 370
  if (creds->hashnt == 1) {
    {
#line 371
    ntlen = ntlm_calc_resp(& nthash, creds->passnt, challenge + 24);
    }
  }
#line 374
  if (creds->hashlm) {
    {
#line 375
    lmlen = ntlm_calc_resp(& lmhash, creds->passlm, challenge + 24);
    }
  }
#line 378
  if (creds->hashnt) {
#line 378
    goto _L;
  } else
#line 378
  if (creds->hashntlm2) {
    _L: /* CIL Label */ 
    {
#line 379
    tmp___0 = strdup((char const   *)(creds->domain));
#line 379
    tmp = uppercase(tmp___0);
#line 380
    dlen = unicode(& udomain, tmp);
#line 381
    free((void *)tmp);
#line 382
    ulen = unicode(& uuser, creds->user);
#line 383
    tmp___1 = strdup((char const   *)(creds->workstation));
#line 383
    tmp = uppercase(tmp___1);
#line 384
    hlen = unicode(& uhost, tmp);
#line 385
    free((void *)tmp);
    }
  } else {
    {
#line 387
    tmp___2 = strdup((char const   *)(creds->domain));
#line 387
    udomain = uppercase(tmp___2);
#line 388
    tmp___3 = strdup((char const   *)(creds->user));
#line 388
    uuser = uppercase(tmp___3);
#line 389
    tmp___4 = strdup((char const   *)(creds->workstation));
#line 389
    uhost = uppercase(tmp___4);
#line 391
    tmp___5 = strlen((char const   *)(creds->domain));
#line 391
    dlen = (int )tmp___5;
#line 392
    tmp___6 = strlen((char const   *)(creds->user));
#line 392
    ulen = (int )tmp___6;
#line 393
    tmp___7 = strlen((char const   *)(creds->workstation));
#line 393
    hlen = (int )tmp___7;
    }
  }
#line 396
  if (debug) {
    {
#line 397
    printf((char const   */* __restrict  */)"NTLM Response:\n");
#line 398
    printf((char const   */* __restrict  */)"\t Hostname: \'%s\'\n", creds->workstation);
#line 399
    printf((char const   */* __restrict  */)"\t   Domain: \'%s\'\n", creds->domain);
#line 400
    printf((char const   */* __restrict  */)"\t Username: \'%s\'\n", creds->user);
    }
#line 401
    if (ntlen) {
      {
#line 402
      tmp = printmem(nthash, (size_t )ntlen, 7);
#line 403
      printf((char const   */* __restrict  */)"\t Response: \'%s\' (%d)\n", tmp, ntlen);
#line 404
      free((void *)tmp);
      }
    }
#line 406
    if (lmlen) {
      {
#line 407
      tmp = printmem(lmhash, (size_t )lmlen, 7);
#line 408
      printf((char const   */* __restrict  */)"\t Response: \'%s\' (%d)\n", tmp, lmlen);
#line 409
      free((void *)tmp);
      }
    }
  }
  {
#line 413
  buf = new((size_t )1024);
#line 414
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)"NTLMSSP\000",
         (size_t )8);
#line 415
  *((uint32_t *)(buf + 8)) = (uint32_t )3;
#line 418
  *((uint16_t *)(buf + 12)) = (uint16_t )lmlen;
#line 419
  *((uint16_t *)(buf + 14)) = (uint16_t )lmlen;
#line 420
  *((uint32_t *)(buf + 16)) = (uint32_t )(((64 + dlen) + ulen) + hlen);
#line 423
  *((uint16_t *)(buf + 20)) = (uint16_t )ntlen;
#line 424
  *((uint16_t *)(buf + 22)) = (uint16_t )ntlen;
#line 425
  *((uint32_t *)(buf + 24)) = (uint32_t )((((64 + dlen) + ulen) + hlen) + lmlen);
#line 428
  *((uint16_t *)(buf + 28)) = (uint16_t )dlen;
#line 429
  *((uint16_t *)(buf + 30)) = (uint16_t )dlen;
#line 430
  *((uint32_t *)(buf + 32)) = (uint32_t )64;
#line 433
  *((uint16_t *)(buf + 36)) = (uint16_t )ulen;
#line 434
  *((uint16_t *)(buf + 38)) = (uint16_t )ulen;
#line 435
  *((uint32_t *)(buf + 40)) = (uint32_t )(64 + dlen);
#line 438
  *((uint16_t *)(buf + 44)) = (uint16_t )hlen;
#line 439
  *((uint16_t *)(buf + 46)) = (uint16_t )hlen;
#line 440
  *((uint32_t *)(buf + 48)) = (uint32_t )((64 + dlen) + ulen);
#line 443
  *((uint16_t *)(buf + 52)) = (uint16_t )0;
#line 444
  *((uint16_t *)(buf + 54)) = (uint16_t )0;
#line 445
  *((uint16_t *)(buf + 56)) = (uint16_t )(((((64 + dlen) + ulen) + hlen) + lmlen) + ntlen);
#line 448
  *((uint32_t *)(buf + 60)) = *((uint32_t *)(challenge + 20));
#line 450
  memcpy((void */* __restrict  */)(buf + 64), (void const   */* __restrict  */)udomain,
         (size_t )dlen);
#line 451
  memcpy((void */* __restrict  */)((buf + 64) + dlen), (void const   */* __restrict  */)uuser,
         (size_t )ulen);
#line 452
  memcpy((void */* __restrict  */)(((buf + 64) + dlen) + ulen), (void const   */* __restrict  */)uhost,
         (size_t )hlen);
#line 453
  memcpy((void */* __restrict  */)((((buf + 64) + dlen) + ulen) + hlen), (void const   */* __restrict  */)lmhash,
         (size_t )lmlen);
#line 454
  memcpy((void */* __restrict  */)(((((buf + 64) + dlen) + ulen) + hlen) + 24), (void const   */* __restrict  */)nthash,
         (size_t )ntlen);
  }
#line 456
  if (nthash) {
    {
#line 457
    free((void *)nthash);
    }
  }
#line 458
  if (lmhash) {
    {
#line 459
    free((void *)lmhash);
    }
  }
  {
#line 461
  free((void *)uhost);
#line 462
  free((void *)uuser);
#line 463
  free((void *)udomain);
#line 465
  *dst = buf;
  }
#line 466
  return (((((64 + dlen) + ulen) + hlen) + lmlen) + ntlen);
}
}
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/acl.c"
int acl_add(plist_t *rules , char *spec , enum acl_t acl ) 
{ 
  struct in_addr source ;
  network_t *aux ;
  int i ;
  int mask ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  long tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char const   *tmp___9 ;

  {
#line 44
  mask = 32;
#line 47
  if ((unsigned long )rules == (unsigned long )((void *)0)) {
#line 48
    return (0);
  }
  {
#line 50
  spec = strdup((char const   *)spec);
#line 51
  tmp___0 = new(sizeof(network_t ));
#line 51
  aux = (network_t *)tmp___0;
#line 52
  tmp___1 = strcspn((char const   *)spec, "/");
#line 52
  i = (int )tmp___1;
#line 53
  tmp___3 = strlen((char const   *)spec);
  }
#line 53
  if ((size_t )i < tmp___3) {
    {
#line 54
    *(spec + i) = (char)0;
#line 55
    tmp___2 = strtol((char const   */* __restrict  */)((spec + i) + 1), (char **/* __restrict  */)(& tmp),
                     10);
#line 55
    mask = (int )tmp___2;
    }
#line 56
    if (mask < 0) {
      {
#line 57
      syslog(3, "ACL netmask for %s is invalid\n", spec);
#line 58
      free((void *)aux);
#line 59
      free((void *)spec);
      }
#line 60
      return (0);
    } else
#line 56
    if (mask > 32) {
      {
#line 57
      syslog(3, "ACL netmask for %s is invalid\n", spec);
#line 58
      free((void *)aux);
#line 59
      free((void *)spec);
      }
#line 60
      return (0);
    } else
#line 56
    if ((int )*(spec + (i + 1)) == 0) {
      {
#line 57
      syslog(3, "ACL netmask for %s is invalid\n", spec);
#line 58
      free((void *)aux);
#line 59
      free((void *)spec);
      }
#line 60
      return (0);
    } else
#line 56
    if ((int )*tmp != 0) {
      {
#line 57
      syslog(3, "ACL netmask for %s is invalid\n", spec);
#line 58
      free((void *)aux);
#line 59
      free((void *)spec);
      }
#line 60
      return (0);
    }
  }
  {
#line 64
  tmp___6 = strcmp("*", (char const   *)spec);
  }
#line 64
  if (tmp___6) {
    {
#line 68
    tmp___5 = strcmp("0", (char const   *)spec);
    }
#line 68
    if (tmp___5) {
      {
#line 70
      tmp___4 = so_resolv(& source, (char const   *)spec);
      }
#line 70
      if (! tmp___4) {
        {
#line 71
        syslog(3, "ACL source address %s is invalid\n", spec);
#line 72
        free((void *)aux);
#line 73
        free((void *)spec);
        }
#line 74
        return (0);
      }
    } else {
#line 69
      source.s_addr = (in_addr_t )0;
    }
  } else {
#line 65
    source.s_addr = (in_addr_t )0;
#line 66
    mask = 0;
  }
#line 78
  aux->ip = source.s_addr;
#line 79
  aux->mask = mask;
#line 80
  mask = (int )((((((uint32_t )(~ ((1UL << (32 - mask)) - 1UL)) & 255U) << 24) | (((uint32_t )(~ ((1UL << (32 - mask)) - 1UL)) & 65280U) << 8)) | (((uint32_t )(~ ((1UL << (32 - mask)) - 1UL)) & 16711680U) >> 8)) | (((uint32_t )(~ ((1UL << (32 - mask)) - 1UL)) & 4278190080U) >> 24));
#line 81
  if ((source.s_addr & (unsigned int )mask) != source.s_addr) {
    {
#line 82
    tmp___7 = inet_ntoa(source);
#line 82
    syslog(4, "Subnet definition might be incorrect: %s/%d\n", tmp___7, aux->mask);
    }
  }
  {
#line 84
  tmp___8 = inet_ntoa(source);
  }
#line 84
  if ((unsigned int )acl == 0U) {
#line 84
    tmp___9 = "allow";
  } else {
#line 84
    tmp___9 = "deny";
  }
  {
#line 84
  syslog(6, "New ACL rule: %s %s/%d\n", tmp___9, tmp___8, aux->mask);
#line 85
  *rules = plist_add(*rules, (unsigned long )acl, (void *)((char *)aux));
#line 87
  free((void *)spec);
  }
#line 88
  return (1);
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/acl.c"
enum acl_t acl_check(plist_t rules , struct in_addr naddr ) 
{ 
  network_t *aux ;
  int mask ;

  {
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if (! rules) {
#line 105
      goto while_break;
    }
#line 106
    aux = (network_t *)rules->aux;
#line 107
    mask = (int )((((((uint32_t )(~ ((1UL << (32 - aux->mask)) - 1UL)) & 255U) << 24) | (((uint32_t )(~ ((1UL << (32 - aux->mask)) - 1UL)) & 65280U) << 8)) | (((uint32_t )(~ ((1UL << (32 - aux->mask)) - 1UL)) & 16711680U) >> 8)) | (((uint32_t )(~ ((1UL << (32 - aux->mask)) - 1UL)) & 4278190080U) >> 24));
#line 109
    if ((naddr.s_addr & (unsigned int )mask) == (aux->ip & (unsigned int )mask)) {
#line 110
      return ((enum acl_t )rules->key);
    }
#line 112
    rules = rules->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  return ((enum acl_t )0);
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.h"
void plist_dump(plist_t list ) ;
#line 120
int plist_pop(plist_t *list , void **aux ) ;
#line 126
hlist_t hlist_del(hlist_t list , char const   *key ) ;
#line 132
int hlist_subcmp_all(hlist_t list , char const   *key , char const   *substr___0 ) ;
#line 155
void to_base64(unsigned char *out , unsigned char const   *in , size_t len , size_t olen ) ;
#line 156
int from_base64(char *out , char const   *in ) ;
#line 62 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/auth.h"
struct auth_s *copy_auth(struct auth_s *dst , struct auth_s *src , int fullcopy ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/http.h"
int http_parse_basic(hlist_t headers , char const   *header , struct auth_s *tcreds ) ;
#line 47
int http_body_send(int writefd , int readfd , rr_data_t request , rr_data_t response ) ;
#line 48
int http_body_drop(int fd , rr_data_t response ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/socket.h"
int so_connect(struct in_addr host , int port ) ;
#line 42
int so_closed(int fd ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/forward.c"
int parent_curr  =    0;
#line 42 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/forward.c"
pthread_mutex_t parent_mtx  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 52 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/forward.c"
int proxy_connect(struct auth_s *credentials ) 
{ 
  proxy_t *aux ;
  int i ;
  int prev ;
  plist_t list ;
  plist_t tmp ;
  int loop ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 56
  loop = 0;
#line 58
  prev = parent_curr;
#line 59
  pthread_mutex_lock(& parent_mtx);
  }
#line 60
  if (parent_curr == 0) {
    {
#line 61
    parent_curr ++;
#line 61
    tmp___0 = plist_get(parent_list, parent_curr);
#line 61
    aux = (proxy_t *)tmp___0;
#line 62
    syslog(6, "Using proxy %s:%d\n", aux->hostname, aux->port);
    }
  }
  {
#line 64
  pthread_mutex_unlock(& parent_mtx);
  }
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 67
    pthread_mutex_lock(& parent_mtx);
#line 68
    tmp___1 = plist_get(parent_list, parent_curr);
#line 68
    aux = (proxy_t *)tmp___1;
#line 69
    pthread_mutex_unlock(& parent_mtx);
    }
#line 70
    if (aux->resolved == 0) {
#line 71
      if (debug) {
        {
#line 72
        syslog(6, "Resolving proxy %s...\n", aux->hostname);
        }
      }
      {
#line 73
      tmp___2 = so_resolv(& aux->host, (char const   *)(aux->hostname));
      }
#line 73
      if (tmp___2) {
#line 74
        aux->resolved = 1;
      } else {
        {
#line 76
        syslog(3, "Cannot resolve proxy %s\n", aux->hostname);
        }
      }
    }
#line 80
    i = 0;
#line 81
    if (aux->resolved != 0) {
      {
#line 82
      i = so_connect(aux->host, aux->port);
      }
    }
#line 87
    if (i <= 0) {
      {
#line 88
      pthread_mutex_lock(& parent_mtx);
      }
#line 89
      if (parent_curr >= parent_count) {
#line 90
        parent_curr = 0;
      }
      {
#line 91
      parent_curr ++;
#line 91
      tmp___3 = plist_get(parent_list, parent_curr);
#line 91
      aux = (proxy_t *)tmp___3;
#line 92
      pthread_mutex_unlock(& parent_mtx);
#line 93
      syslog(3, "Proxy connect failed, will try %s:%d\n", aux->hostname, aux->port);
      }
    }
#line 66
    if (i <= 0) {
#line 66
      loop ++;
#line 66
      if (! (loop < parent_count)) {
#line 66
        goto while_break;
      }
    } else {
#line 66
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  if (i <= 0) {
#line 97
    if (loop >= parent_count) {
      {
#line 98
      syslog(3, "No proxy on the list works. You lose.\n");
      }
    }
  }
#line 103
  if (prev != parent_curr) {
    {
#line 104
    pthread_mutex_lock(& connection_mtx);
#line 105
    list = connection_list;
    }
    {
#line 106
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 106
      if (! list) {
#line 106
        goto while_break___0;
      }
      {
#line 107
      tmp = list->next;
#line 108
      close((int )list->key);
#line 109
      list = tmp;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 111
    plist_free(connection_list);
#line 112
    pthread_mutex_unlock(& connection_mtx);
    }
  }
#line 115
  if (i > 0) {
#line 115
    if ((unsigned long )credentials != (unsigned long )((void *)0)) {
      {
#line 116
      copy_auth(credentials, g_creds, ! ntlmbasic);
      }
    }
  }
#line 118
  return (i);
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/forward.c"
int proxy_authenticate(int *sd , rr_data_t request , rr_data_t response , struct auth_s *credentials ) 
{ 
  char *tmp ;
  char *buf ;
  char *challenge ;
  rr_data_t auth ;
  int len ;
  int pretend407 ;
  int rc ;
  int tmp___0 ;
  length_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
#line 140
  pretend407 = 0;
#line 141
  rc = 0;
#line 143
  buf = new((size_t )4096);
#line 145
  strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)"NTLM ");
#line 146
  len = ntlm_request(& tmp, credentials);
  }
#line 147
  if (len) {
    {
#line 148
    to_base64((uint8_t *)(buf + 5), (unsigned char const   *)((uint8_t *)(tmp + 0)),
              (size_t )len, (size_t )4091);
#line 149
    free((void *)tmp);
    }
  }
  {
#line 152
  auth = dup_rr_data(request);
#line 153
  auth->headers = hlist_mod(auth->headers, (char *)"Proxy-Authorization", buf, 1);
  }
#line 155
  if (request) {
#line 155
    if (request->req) {
      {
#line 155
      tmp___0 = strcasecmp("HEAD", (char const   *)request->method);
      }
#line 155
      if (tmp___0) {
#line 155
        goto _L___1;
      } else {
#line 155
        goto _L;
      }
    } else {
#line 155
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    {
#line 155
    tmp___1 = http_has_body(request, response);
    }
#line 155
    if (tmp___1 != 0LL) {
      _L: /* CIL Label */ 
#line 173
      if (debug) {
        {
#line 174
        printf((char const   */* __restrict  */)"Will send just a probe request.\n");
        }
      }
#line 175
      pretend407 = 1;
    }
  }
#line 181
  if (request) {
#line 181
    if (request->req) {
      {
#line 181
      tmp___2 = strcasecmp("HEAD", (char const   *)request->method);
      }
#line 181
      if (! tmp___2) {
        {
#line 182
        free((void *)auth->method);
#line 183
        auth->method = strdup("GET");
        }
      }
    }
  }
  {
#line 186
  auth->headers = hlist_mod(auth->headers, (char *)"Content-Length", (char *)"0",
                            1);
#line 187
  auth->headers = hlist_del(auth->headers, "Transfer-Encoding");
  }
#line 189
  if (debug) {
    {
#line 190
    printf((char const   */* __restrict  */)"\nSending PROXY auth request...\n");
#line 191
    hlist_dump(auth->headers);
    }
  }
  {
#line 194
  tmp___3 = headers_send(*sd, auth);
  }
#line 194
  if (! tmp___3) {
#line 195
    goto bailout;
  }
#line 198
  if (debug) {
    {
#line 199
    printf((char const   */* __restrict  */)"\nReading PROXY auth response...\n");
    }
  }
#line 205
  if (response) {
    {
#line 206
    free_rr_data(auth);
#line 207
    auth = response;
    }
  }
  {
#line 210
  reset_rr_data(auth);
#line 211
  tmp___4 = headers_recv(*sd, auth);
  }
#line 211
  if (! tmp___4) {
#line 212
    goto bailout;
  }
#line 215
  if (debug) {
    {
#line 216
    hlist_dump(auth->headers);
    }
  }
#line 218
  rc = 1;
#line 223
  if (auth->code == 407) {
    {
#line 224
    tmp___5 = http_body_drop(*sd, auth);
    }
#line 224
    if (! tmp___5) {
#line 225
      rc = 0;
#line 226
      goto bailout;
    }
    {
#line 228
    tmp = hlist_get(auth->headers, "Proxy-Authenticate");
    }
#line 229
    if (tmp) {
      {
#line 230
      tmp___6 = strlen((char const   *)tmp);
#line 230
      challenge = new((tmp___6 + 5UL) + 1UL);
#line 231
      len = from_base64(challenge, (char const   *)(tmp + 5));
      }
#line 232
      if (len > 24) {
        {
#line 233
        len = ntlm_response(& tmp, challenge, len, credentials);
        }
#line 234
        if (len > 0) {
          {
#line 235
          strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)"NTLM ");
#line 236
          to_base64((uint8_t *)(buf + 5), (unsigned char const   *)((uint8_t *)(tmp + 0)),
                    (size_t )len, (size_t )4091);
#line 237
          request->headers = hlist_mod(request->headers, (char *)"Proxy-Authorization",
                                       buf, 1);
#line 238
          free((void *)tmp);
          }
        } else {
          {
#line 240
          syslog(3, "No target info block. Cannot do NTLMv2!\n");
#line 241
          free((void *)challenge);
          }
#line 242
          goto bailout;
        }
      } else {
        {
#line 245
        syslog(3, "Proxy returning invalid challenge!\n");
#line 246
        free((void *)challenge);
        }
#line 247
        goto bailout;
      }
      {
#line 250
      free((void *)challenge);
      }
    } else {
      {
#line 252
      syslog(4, "No Proxy-Authenticate, NTLM not supported?\n");
      }
    }
  } else
#line 254
  if (pretend407) {
#line 255
    if (debug) {
#line 256
      if (request) {
#line 256
        if (request->req) {
          {
#line 256
          tmp___9 = strcasecmp("HEAD", (char const   *)request->method);
          }
#line 256
          if (tmp___9) {
#line 256
            tmp___8 = "has a body";
          } else {
#line 256
            tmp___8 = "sent HEAD";
          }
        } else {
#line 256
          tmp___8 = "has a body";
        }
      } else {
#line 256
        tmp___8 = "has a body";
      }
      {
#line 256
      printf((char const   */* __restrict  */)"Client %s - forcing second request.\n",
             tmp___8);
      }
    }
#line 257
    if (response) {
#line 258
      response->code = 407;
    }
    {
#line 259
    tmp___10 = http_body_drop(*sd, auth);
    }
#line 259
    if (! tmp___10) {
#line 260
      rc = 0;
#line 261
      goto bailout;
    }
  }
  {
#line 268
  tmp___11 = so_closed(*sd);
  }
#line 268
  if (tmp___11) {
#line 269
    if (debug) {
      {
#line 270
      printf((char const   */* __restrict  */)"Proxy closed on us, reconnect.\n");
      }
    }
    {
#line 271
    close(*sd);
#line 272
    *sd = proxy_connect(credentials);
    }
#line 273
    if (*sd < 0) {
#line 274
      rc = 0;
#line 275
      goto bailout;
    }
  }
  bailout: 
#line 280
  if (! response) {
    {
#line 281
    free_rr_data(auth);
    }
  }
  {
#line 283
  free((void *)buf);
  }
#line 285
  return (rc);
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/forward.c"
rr_data_t forward_request(void *thread_data , rr_data_t request ) 
{ 
  int i ;
  int w ;
  int loop ;
  int plugin ;
  int retry ;
  int *rsocket[2] ;
  int *wsocket[2] ;
  rr_data_t data[2] ;
  rr_data_t rc ;
  hlist_t tl ;
  char *tmp ;
  struct auth_s *tcreds ;
  char *hostname ;
  int proxy_alive ;
  int conn_alive ;
  int authok ;
  int noauth ;
  int was_cached ;
  int sd ;
  int cd ;
  struct sockaddr_in caddr ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  ssize_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;
  ssize_t tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 319
  retry = 0;
#line 321
  rc = (rr_data_t )((void *)0);
#line 324
  tcreds = (struct auth_s *)((void *)0);
#line 325
  hostname = (char *)((void *)0);
#line 333
  cd = ((struct thread_arg_s *)thread_data)->fd;
#line 334
  caddr = ((struct thread_arg_s *)thread_data)->addr;
  beginning: 
#line 337
  proxy_alive = 0;
#line 337
  conn_alive = proxy_alive;
#line 337
  authok = conn_alive;
#line 337
  noauth = authok;
#line 337
  was_cached = noauth;
#line 337
  sd = was_cached;
#line 339
  wsocket[1] = & cd;
#line 339
  rsocket[0] = wsocket[1];
#line 340
  wsocket[0] = & sd;
#line 340
  rsocket[1] = wsocket[0];
#line 342
  if (debug) {
#line 343
    if (retry) {
#line 343
      tmp___0 = " (retry)";
    } else {
#line 343
      tmp___0 = "";
    }
    {
#line 343
    printf((char const   */* __restrict  */)"Thread processing%s...\n", tmp___0);
#line 344
    pthread_mutex_lock(& connection_mtx);
#line 345
    plist_dump(connection_list);
#line 346
    pthread_mutex_unlock(& connection_mtx);
    }
  }
  {
#line 357
  pthread_mutex_lock(& connection_mtx);
#line 358
  i = plist_pop(& connection_list, (void **)(& tcreds));
#line 359
  pthread_mutex_unlock(& connection_mtx);
  }
#line 360
  if (i) {
#line 361
    if (debug) {
      {
#line 362
      printf((char const   */* __restrict  */)"Found autenticated connection %d!\n",
             i);
      }
    }
#line 363
    sd = i;
#line 364
    authok = 1;
#line 365
    was_cached = 1;
  } else {
    {
#line 367
    tcreds = new_auth();
#line 368
    sd = proxy_connect(tcreds);
    }
#line 369
    if (sd <= 0) {
      {
#line 370
      tmp = gen_502_page((char const   *)request->http, "Parent proxy unreacheable");
#line 371
      tmp___1 = strlen((char const   *)tmp);
#line 371
      tmp___2 = write(cd, (void const   *)tmp, tmp___1);
#line 371
      w = (int )tmp___2;
#line 372
      free((void *)tmp);
#line 373
      rc = (rr_data_t )((void *)-1);
      }
#line 374
      goto bailout;
    }
  }
#line 382
  if (! hostname) {
#line 382
    if (request->hostname) {
      {
#line 383
      hostname = strdup((char const   *)request->hostname);
      }
    }
  }
  {
#line 386
  while (1) {
    while_continue: /* CIL Label */ ;
#line 406
    if (request) {
#line 407
      if (retry) {
#line 408
        data[0] = request;
      } else {
        {
#line 410
        data[0] = dup_rr_data(request);
        }
      }
#line 411
      request = (rr_data_t )((void *)0);
    } else {
      {
#line 413
      data[0] = new_rr_data();
      }
    }
    {
#line 415
    data[1] = new_rr_data();
#line 417
    retry = 0;
#line 418
    proxy_alive = 0;
#line 419
    conn_alive = 0;
#line 421
    loop = 0;
    }
    {
#line 421
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 421
      if (! (loop < 2)) {
#line 421
        goto while_break___0;
      }
#line 422
      if ((data[loop])->empty) {
#line 423
        if (debug) {
          {
#line 424
          printf((char const   */* __restrict  */)"\n******* Round %d C: %d, S: %d (authok=%d, noauth=%d) *******\n",
                 loop + 1, cd, sd, authok, noauth);
#line 425
          printf((char const   */* __restrict  */)"Reading headers (%d)...\n", *(rsocket[loop]));
          }
        }
        {
#line 427
        tmp___3 = headers_recv(*(rsocket[loop]), data[loop]);
        }
#line 427
        if (! tmp___3) {
          {
#line 428
          free_rr_data(data[0]);
#line 429
          free_rr_data(data[1]);
#line 430
          rc = (rr_data_t )((void *)-1);
          }
#line 432
          goto bailout;
        }
      }
#line 445
      if (loop == 0) {
#line 445
        if (hostname) {
#line 445
          if ((data[0])->hostname) {
            {
#line 445
            tmp___6 = strcasecmp((char const   *)hostname, (char const   *)(data[0])->hostname);
            }
#line 445
            if (tmp___6) {
#line 447
              if (debug) {
                {
#line 448
                printf((char const   */* __restrict  */)"\n******* F RETURN: %s *******\n",
                       (data[0])->url);
                }
              }
#line 449
              if (authok) {
#line 449
                if ((data[0])->http_version >= 11) {
                  {
#line 449
                  tmp___4 = hlist_subcmp((data[0])->headers, "Proxy-Connection", "keep-alive");
                  }
#line 449
                  if (tmp___4) {
#line 452
                    proxy_alive = 1;
                  } else {
                    {
#line 449
                    tmp___5 = hlist_subcmp((data[0])->headers, "Connection", "keep-alive");
                    }
#line 449
                    if (tmp___5) {
#line 452
                      proxy_alive = 1;
                    }
                  }
                }
              }
              {
#line 454
              rc = dup_rr_data(data[0]);
#line 455
              free_rr_data(data[0]);
#line 456
              free_rr_data(data[1]);
              }
#line 457
              goto bailout;
            }
          }
        }
      }
#line 460
      if (debug) {
        {
#line 461
        hlist_dump((data[loop])->headers);
        }
      }
#line 463
      if (loop == 0) {
#line 463
        if ((data[0])->req) {
          {
#line 464
          tmp___7 = inet_ntoa(caddr.sin_addr);
#line 464
          syslog(7, "%s %s %s", tmp___7, (data[0])->method, (data[0])->url);
          }
        }
      }
      shortcut: 
#line 473
      if (loop == 0) {
#line 473
        if ((data[0])->req) {
          {
#line 477
          tmp___10 = http_parse_basic((data[loop])->headers, "Proxy-Authorization",
                                      tcreds);
          }
#line 477
          if (tmp___10 > 0) {
#line 478
            if (debug) {
              {
#line 479
              printf((char const   */* __restrict  */)"NTLM-to-basic: Credentials parsed: %s\\%s at %s\n",
                     tcreds->domain, tcreds->user, tcreds->workstation);
              }
            }
          } else
#line 480
          if (ntlmbasic) {
#line 481
            if (debug) {
              {
#line 482
              printf((char const   */* __restrict  */)"NTLM-to-basic: Returning client auth request.\n");
              }
            }
            {
#line 484
            tmp = gen_407_page((char const   *)(data[loop])->http);
#line 485
            tmp___8 = strlen((char const   *)tmp);
#line 485
            tmp___9 = write(cd, (void const   *)tmp, tmp___8);
#line 485
            w = (int )tmp___9;
#line 486
            free((void *)tmp);
#line 488
            free_rr_data(data[0]);
#line 489
            free_rr_data(data[1]);
#line 490
            rc = (rr_data_t )((void *)-1);
            }
#line 491
            goto bailout;
          }
#line 497
          tl = header_list;
          {
#line 498
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 498
            if (! tl) {
#line 498
              goto while_break___1;
            }
            {
#line 499
            (data[0])->headers = hlist_mod((data[0])->headers, tl->key, tl->value,
                                           0);
#line 500
            tl = tl->next;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 506
          if ((data[0])->http_version >= 11) {
            {
#line 507
            (data[0])->headers = hlist_mod((data[0])->headers, (char *)"Proxy-Connection",
                                           (char *)"keep-alive", 1);
            }
          }
          {
#line 513
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 513
            tmp___11 = hlist_get((data[loop])->headers, "Proxy-Authorization");
            }
#line 513
            if (! tmp___11) {
#line 513
              goto while_break___2;
            }
            {
#line 514
            (data[loop])->headers = hlist_del((data[loop])->headers, "Proxy-Authorization");
            }
          }
          while_break___2: /* CIL Label */ ;
          }
        }
      }
#line 522
      if (loop == 0) {
#line 522
        if ((data[0])->req) {
#line 522
          if (! authok) {
#line 522
            if (! noauth) {
              {
#line 523
              tmp___12 = proxy_authenticate(wsocket[0], data[0], data[1], tcreds);
              }
#line 523
              if (! tmp___12) {
#line 524
                if (debug) {
                  {
#line 525
                  printf((char const   */* __restrict  */)"Proxy auth connection error.\n");
                  }
                }
                {
#line 526
                free_rr_data(data[0]);
#line 527
                free_rr_data(data[1]);
#line 528
                rc = (rr_data_t )((void *)-1);
                }
#line 530
                goto bailout;
              }
#line 546
              if ((data[1])->code != 407) {
#line 547
                if (debug) {
                  {
#line 548
                  printf((char const   */* __restrict  */)"Proxy auth not requested - just forwarding.\n");
                  }
                }
#line 549
                if ((data[1])->code < 400) {
#line 550
                  noauth = 1;
                }
#line 551
                loop = 1;
#line 552
                goto shortcut;
              }
              {
#line 559
              reset_rr_data(data[1]);
              }
            }
          }
        }
      }
#line 567
      if (loop == 1) {
#line 567
        if ((data[1])->code == 407) {
#line 567
          if (was_cached) {
#line 567
            goto _L;
          } else
#line 567
          if (noauth) {
            _L: /* CIL Label */ 
#line 568
            if (debug) {
              {
#line 569
              printf((char const   */* __restrict  */)"\nFinal reply is 407 - retrying (cached=%d, noauth=%d).\n",
                     was_cached, noauth);
              }
            }
#line 570
            if (tcreds) {
              {
#line 571
              free((void *)tcreds);
              }
            }
            {
#line 573
            retry = 1;
#line 574
            request = data[0];
#line 575
            free_rr_data(data[1]);
#line 576
            close(sd);
            }
#line 577
            goto beginning;
          }
        }
      }
#line 584
      if (loop == 1) {
#line 584
        if (! noauth) {
#line 584
          if ((data[1])->code != 407) {
#line 585
            authok = 1;
          }
        }
      }
#line 593
      plugin = 32767;
#line 594
      if (loop == 1) {
#line 594
        if (scanner_plugin) {
          {
#line 595
          plugin = scanner_hook(data[0], data[1], tcreds, *(wsocket[loop]), rsocket[loop],
                                scanner_plugin_maxsize);
          }
        }
      }
#line 605
      if (loop == 1) {
        {
#line 606
        conn_alive = hlist_subcmp((data[1])->headers, "Connection", "keep-alive");
        }
#line 607
        if (! conn_alive) {
          {
#line 608
          (data[1])->headers = hlist_mod((data[1])->headers, (char *)"Connection",
                                         (char *)"close", 1);
          }
        }
        {
#line 613
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 613
          tmp___13 = hlist_get((data[loop])->headers, "Proxy-Authenticate");
          }
#line 613
          if (! tmp___13) {
#line 613
            goto while_break___3;
          }
          {
#line 614
          (data[loop])->headers = hlist_del((data[loop])->headers, "Proxy-Authenticate");
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 621
        if ((data[1])->code == 407) {
          {
#line 622
          (data[1])->headers = hlist_mod((data[1])->headers, (char *)"Proxy-Authenticate",
                                         (char *)"Basic realm=\"Cntlm for parent\"",
                                         1);
          }
        }
      }
#line 626
      if (plugin & 1) {
#line 627
        if (debug) {
          {
#line 628
          printf((char const   */* __restrict  */)"Sending headers (%d)...\n", *(wsocket[loop]));
          }
#line 629
          if (loop == 0) {
            {
#line 630
            hlist_dump((data[loop])->headers);
            }
          }
        }
        {
#line 638
        tmp___14 = headers_send(*(wsocket[loop]), data[loop]);
        }
#line 638
        if (! tmp___14) {
          {
#line 639
          free_rr_data(data[0]);
#line 640
          free_rr_data(data[1]);
#line 641
          rc = (rr_data_t )((void *)-1);
          }
#line 643
          goto bailout;
        }
      }
#line 650
      if (loop == 1) {
#line 650
        if (data[0]) {
#line 650
          if ((data[0])->req) {
            {
#line 650
            tmp___15 = strcasecmp("CONNECT", (char const   *)(data[0])->method);
            }
#line 650
            if (! tmp___15) {
#line 650
              if ((data[1])->code == 200) {
#line 651
                if (debug) {
                  {
#line 652
                  printf((char const   */* __restrict  */)"Ok CONNECT response. Tunneling...\n");
                  }
                }
                {
#line 654
                tunnel(cd, sd);
#line 655
                free_rr_data(data[0]);
#line 656
                free_rr_data(data[1]);
#line 657
                rc = (rr_data_t )((void *)-1);
                }
#line 658
                goto bailout;
              }
            }
          }
        }
      }
#line 661
      if (plugin & 2) {
        {
#line 662
        tmp___16 = http_body_send(*(wsocket[loop]), *(rsocket[loop]), data[0], data[1]);
        }
#line 662
        if (! tmp___16) {
          {
#line 663
          free_rr_data(data[0]);
#line 664
          free_rr_data(data[1]);
#line 665
          rc = (rr_data_t )((void *)-1);
          }
#line 666
          goto bailout;
        }
      }
#line 677
      if (loop == 1) {
        {
#line 678
        tmp___17 = hlist_subcmp((data[1])->headers, "Proxy-Connection", "keep-alive");
        }
#line 678
        if (tmp___17) {
#line 678
          if ((data[0])->http_version >= 11) {
#line 678
            tmp___18 = 1;
          } else {
#line 678
            tmp___18 = 0;
          }
        } else {
#line 678
          tmp___18 = 0;
        }
#line 678
        proxy_alive = tmp___18;
#line 680
        if (proxy_alive) {
          {
#line 681
          (data[1])->headers = hlist_mod((data[1])->headers, (char *)"Proxy-Connection",
                                         (char *)"keep-alive", 1);
#line 682
          (data[1])->headers = hlist_mod((data[1])->headers, (char *)"Connection",
                                         (char *)"keep-alive", 1);
          }
        } else {
          {
#line 684
          (data[1])->headers = hlist_mod((data[1])->headers, (char *)"Proxy-Connection",
                                         (char *)"close", 1);
#line 685
          (data[1])->headers = hlist_mod((data[1])->headers, (char *)"Connection",
                                         (char *)"close", 1);
          }
#line 686
          if (debug) {
            {
#line 687
            printf((char const   */* __restrict  */)"PROXY CLOSING CONNECTION\n");
            }
          }
#line 688
          rc = (rr_data_t )((void *)-1);
        }
      }
#line 421
      loop ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 693
    free_rr_data(data[0]);
#line 694
    free_rr_data(data[1]);
    }
#line 386
    if (conn_alive) {
#line 386
      if (proxy_alive) {
        {
#line 386
        tmp___19 = so_closed(sd);
        }
#line 386
        if (tmp___19) {
#line 386
          goto while_break;
        } else {
          {
#line 386
          tmp___20 = so_closed(cd);
          }
#line 386
          if (tmp___20) {
#line 386
            goto while_break;
          } else
#line 386
          if (! (! serialize)) {
#line 386
            goto while_break;
          }
        }
      } else {
#line 386
        goto while_break;
      }
    } else {
#line 386
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  bailout: 
#line 703
  if (hostname) {
    {
#line 704
    free((void *)hostname);
    }
  }
#line 706
  if (debug) {
    {
#line 707
    tmp___21 = so_closed(sd);
#line 707
    printf((char const   */* __restrict  */)"forward_request: palive=%d, authok=%d, ntlm=%d, closed=%d\n",
           proxy_alive, authok, ntlmbasic, tmp___21);
#line 708
    printf((char const   */* __restrict  */)"\nThread finished.\n");
    }
  }
#line 711
  if (proxy_alive) {
#line 711
    if (authok) {
#line 711
      if (! ntlmbasic) {
        {
#line 711
        tmp___22 = so_closed(sd);
        }
#line 711
        if (tmp___22) {
          {
#line 718
          free((void *)tcreds);
#line 719
          close(sd);
          }
        } else {
#line 712
          if (debug) {
            {
#line 713
            printf((char const   */* __restrict  */)"Storing the connection for reuse (%d:%d).\n",
                   cd, sd);
            }
          }
          {
#line 714
          pthread_mutex_lock(& connection_mtx);
#line 715
          connection_list = plist_add(connection_list, (unsigned long )sd, (void *)tcreds);
#line 716
          pthread_mutex_unlock(& connection_mtx);
          }
        }
      } else {
        {
#line 718
        free((void *)tcreds);
#line 719
        close(sd);
        }
      }
    } else {
      {
#line 718
      free((void *)tcreds);
#line 719
      close(sd);
      }
    }
  } else {
    {
#line 718
    free((void *)tcreds);
#line 719
    close(sd);
    }
  }
#line 722
  return (rc);
}
}
#line 731 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/forward.c"
int prepare_http_connect(int sd , struct auth_s *credentials , char const   *thost ) 
{ 
  rr_data_t data1 ;
  rr_data_t data2 ;
  int rc ;
  hlist_t tl ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 733
  rc = 0;
#line 736
  if (! sd) {
#line 737
    return (0);
  } else
#line 736
  if (! thost) {
#line 737
    return (0);
  } else {
    {
#line 736
    tmp = strlen(thost);
    }
#line 736
    if (! tmp) {
#line 737
      return (0);
    }
  }
  {
#line 739
  data1 = new_rr_data();
#line 740
  data2 = new_rr_data();
#line 742
  data1->req = 1;
#line 743
  data1->method = strdup("CONNECT");
#line 744
  data1->url = strdup(thost);
#line 745
  data1->http = strdup("HTTP/1.1");
#line 746
  data1->headers = hlist_mod(data1->headers, (char *)"Proxy-Connection", (char *)"keep-alive",
                             1);
#line 751
  tl = header_list;
  }
  {
#line 752
  while (1) {
    while_continue: /* CIL Label */ ;
#line 752
    if (! tl) {
#line 752
      goto while_break;
    }
    {
#line 753
    data1->headers = hlist_mod(data1->headers, tl->key, tl->value, 1);
#line 754
    tl = tl->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 757
  if (debug) {
    {
#line 758
    printf((char const   */* __restrict  */)"Starting authentication...\n");
    }
  }
  {
#line 760
  tmp___2 = proxy_authenticate(& sd, data1, data2, credentials);
  }
#line 760
  if (tmp___2) {
#line 764
    if (data2->code == 407) {
#line 765
      if (debug) {
        {
#line 766
        printf((char const   */* __restrict  */)"Sending real request:\n");
#line 767
        hlist_dump(data1->headers);
        }
      }
      {
#line 769
      tmp___0 = headers_send(sd, data1);
      }
#line 769
      if (! tmp___0) {
        {
#line 770
        printf((char const   */* __restrict  */)"Sending request failed!\n");
        }
#line 771
        goto bailout;
      }
#line 774
      if (debug) {
        {
#line 775
        printf((char const   */* __restrict  */)"\nReading real response:\n");
        }
      }
      {
#line 776
      reset_rr_data(data2);
#line 777
      tmp___1 = headers_recv(sd, data2);
      }
#line 777
      if (! tmp___1) {
#line 778
        if (debug) {
          {
#line 779
          printf((char const   */* __restrict  */)"Reading response failed!\n");
          }
        }
#line 780
        goto bailout;
      }
#line 782
      if (debug) {
        {
#line 783
        hlist_dump(data2->headers);
        }
      }
    }
#line 786
    if (data2->code == 200) {
#line 787
      if (debug) {
        {
#line 788
        printf((char const   */* __restrict  */)"Ok CONNECT response. Tunneling...\n");
        }
      }
#line 789
      rc = 1;
    } else
#line 790
    if (data2->code == 407) {
      {
#line 791
      syslog(3, "Authentication for tunnel %s failed!\n", thost);
      }
    } else {
      {
#line 793
      syslog(3, "Request for CONNECT to %s denied!\n", thost);
      }
    }
  } else {
    {
#line 796
    syslog(3, "Tunnel requests failed!\n");
    }
  }
  bailout: 
  {
#line 799
  free_rr_data(data1);
#line 800
  free_rr_data(data2);
  }
#line 802
  return (rc);
}
}
#line 805 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/forward.c"
void forward_tunnel(void *thread_data ) 
{ 
  struct auth_s *tcreds ;
  int sd ;
  int cd ;
  char *thost ;
  struct sockaddr_in caddr ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 809
  cd = ((struct thread_arg_s *)thread_data)->fd;
#line 810
  thost = ((struct thread_arg_s *)thread_data)->target;
#line 811
  caddr = ((struct thread_arg_s *)thread_data)->addr;
#line 813
  tcreds = new_auth();
#line 814
  sd = proxy_connect(tcreds);
  }
#line 816
  if (sd <= 0) {
#line 817
    goto bailout;
  }
  {
#line 819
  tmp = inet_ntoa(caddr.sin_addr);
#line 819
  syslog(7, "%s TUNNEL %s", tmp, thost);
  }
#line 820
  if (debug) {
    {
#line 821
    printf((char const   */* __restrict  */)"Tunneling to %s for client %d...\n",
           thost, cd);
    }
  }
  {
#line 823
  tmp___0 = prepare_http_connect(sd, tcreds, (char const   *)thost);
  }
#line 823
  if (tmp___0) {
    {
#line 824
    tunnel(cd, sd);
    }
  }
  bailout: 
  {
#line 827
  close(sd);
#line 828
  close(cd);
#line 829
  free((void *)tcreds);
  }
#line 831
  return;
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/forward.c"
void magic_auth_detect(char const   *url ) 
{ 
  int i ;
  int nc ;
  int c ;
  int ign ;
  int found ;
  rr_data_t req ;
  rr_data_t res ;
  char *tmp ;
  char *pos ;
  char *host ;
  struct auth_s *tcreds ;
  char *authstr[5] ;
  int prefs[4][5] ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 837
  ign = 0;
#line 837
  found = -1;
#line 839
  host = (char *)((void *)0);
#line 842
  authstr[0] = (char *)"NTLMv2";
#line 842
  authstr[1] = (char *)"NTLM2SR";
#line 842
  authstr[2] = (char *)"NT";
#line 842
  authstr[3] = (char *)"NTLM";
#line 842
  authstr[4] = (char *)"LM";
#line 843
  prefs[0][0] = 0;
#line 843
  prefs[0][1] = 0;
#line 843
  prefs[0][2] = 1;
#line 843
  prefs[0][3] = 0;
#line 843
  prefs[0][4] = 0;
#line 843
  prefs[1][0] = 1;
#line 843
  prefs[1][1] = 1;
#line 843
  prefs[1][2] = 0;
#line 843
  prefs[1][3] = 0;
#line 843
  prefs[1][4] = 3;
#line 843
  prefs[2][0] = 0;
#line 843
  prefs[2][1] = 1;
#line 843
  prefs[2][2] = 0;
#line 843
  prefs[2][3] = 0;
#line 843
  prefs[2][4] = 4;
#line 843
  prefs[3][0] = 2;
#line 843
  prefs[3][1] = 0;
#line 843
  prefs[3][2] = 0;
#line 843
  prefs[3][3] = 0;
#line 843
  prefs[3][4] = 1;
#line 851
  tcreds = new_auth();
#line 852
  copy_auth(tcreds, g_creds, 1);
  }
#line 854
  if (! (tcreds->passnt)) {
    {
#line 855
    printf((char const   */* __restrict  */)"Cannot detect NTLM dialect - password or all its hashes must be defined, try -I\n");
#line 856
    exit(1);
    }
  } else
#line 854
  if (! (tcreds->passlm)) {
    {
#line 855
    printf((char const   */* __restrict  */)"Cannot detect NTLM dialect - password or all its hashes must be defined, try -I\n");
#line 856
    exit(1);
    }
  } else
#line 854
  if (! (tcreds->passntlm2)) {
    {
#line 855
    printf((char const   */* __restrict  */)"Cannot detect NTLM dialect - password or all its hashes must be defined, try -I\n");
#line 856
    exit(1);
    }
  }
  {
#line 859
  pos = strstr(url, "://");
  }
#line 860
  if (pos) {
    {
#line 861
    tmp = strchr((char const   *)(pos + 3), '/');
    }
#line 862
    if (tmp) {
#line 862
      tmp___0 = (tmp - pos) - 3L;
    } else {
#line 862
      tmp___0 = 0L;
    }
    {
#line 862
    host = substr((char const   *)(pos + 3), 0, (int )tmp___0);
    }
  } else {
    {
#line 864
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid URL (%s)\n",
            url);
    }
#line 865
    return;
  }
#line 868
  i = 0;
  {
#line 868
  while (1) {
    while_continue: /* CIL Label */ ;
#line 868
    if (! (i < 4)) {
#line 868
      goto while_break;
    }
    {
#line 869
    res = new_rr_data();
#line 870
    req = new_rr_data();
#line 872
    req->req = 1;
#line 873
    req->method = strdup("GET");
#line 874
    req->url = strdup(url);
#line 875
    req->http = strdup("HTTP/1.1");
#line 876
    req->headers = hlist_add(req->headers, (char *)"Proxy-Connection", (char *)"keep-alive",
                             (hlist_add_t )1, (hlist_add_t )1);
    }
#line 877
    if (host) {
      {
#line 878
      req->headers = hlist_add(req->headers, (char *)"Host", host, (hlist_add_t )1,
                               (hlist_add_t )1);
      }
    }
    {
#line 880
    tcreds->hashnt = prefs[i][0];
#line 881
    tcreds->hashlm = prefs[i][1];
#line 882
    tcreds->hashntlm2 = prefs[i][2];
#line 883
    tcreds->flags = (uint32_t )prefs[i][3];
#line 885
    printf((char const   */* __restrict  */)"Config profile %2d/%d... ", i + 1, 4);
#line 887
    nc = proxy_connect((struct auth_s *)((void *)0));
    }
#line 888
    if (nc <= 0) {
      {
#line 889
      printf((char const   */* __restrict  */)"\nConnection to proxy failed, bailing out\n");
#line 890
      free_rr_data(res);
#line 891
      free_rr_data(req);
#line 892
      close(nc);
      }
#line 893
      if (host) {
        {
#line 894
        free((void *)host);
        }
      }
#line 895
      return;
    }
    {
#line 898
    c = proxy_authenticate(& nc, req, res, tcreds);
    }
#line 899
    if (c) {
#line 899
      if (res->code != 407) {
        {
#line 900
        ign ++;
#line 901
        printf((char const   */* __restrict  */)"Auth not required (HTTP code: %d)\n",
               res->code);
#line 902
        free_rr_data(res);
#line 903
        free_rr_data(req);
#line 904
        close(nc);
        }
#line 905
        goto __Cont;
      }
    }
    {
#line 908
    reset_rr_data(res);
#line 909
    tmp___3 = headers_send(nc, req);
    }
#line 909
    if (tmp___3) {
      {
#line 909
      tmp___4 = headers_recv(nc, res);
      }
#line 909
      if (tmp___4) {
#line 912
        if (res->code == 407) {
          {
#line 913
          tmp___1 = hlist_subcmp_all(res->headers, "Proxy-Authenticate", "NTLM");
          }
#line 913
          if (tmp___1) {
            {
#line 914
            printf((char const   */* __restrict  */)"Credentials rejected\n");
            }
          } else {
            {
#line 913
            tmp___2 = hlist_subcmp_all(res->headers, "Proxy-Authenticate", "BASIC");
            }
#line 913
            if (tmp___2) {
              {
#line 914
              printf((char const   */* __restrict  */)"Credentials rejected\n");
              }
            } else {
              {
#line 916
              printf((char const   */* __restrict  */)"Proxy doesn\'t offer NTLM or BASIC\n");
              }
#line 917
              goto while_break;
            }
          }
        } else {
          {
#line 920
          printf((char const   */* __restrict  */)"OK (HTTP code: %d)\n", res->code);
          }
#line 921
          if (found < 0) {
            {
#line 922
            found = i;
#line 923
            free_rr_data(res);
#line 924
            free_rr_data(req);
#line 925
            close(nc);
            }
#line 926
            goto while_break;
          }
        }
      } else {
        {
#line 910
        printf((char const   */* __restrict  */)"Connection closed\n");
        }
      }
    } else {
      {
#line 910
      printf((char const   */* __restrict  */)"Connection closed\n");
      }
    }
    {
#line 931
    free_rr_data(res);
#line 932
    free_rr_data(req);
#line 933
    close(nc);
    }
    __Cont: /* CIL Label */ 
#line 868
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 936
  if (found > -1) {
    {
#line 937
    printf((char const   */* __restrict  */)"----------------------------[ Profile %2d ]------\n",
           found);
#line 938
    printf((char const   */* __restrict  */)"Auth            %s\n", authstr[prefs[found][4]]);
    }
#line 939
    if (prefs[found][3]) {
      {
#line 940
      printf((char const   */* __restrict  */)"Flags           0x%x\n", prefs[found][3]);
      }
    }
#line 941
    if (prefs[found][0]) {
      {
#line 942
      tmp = printmem(tcreds->passnt, (size_t )16, 8);
#line 942
      printf((char const   */* __restrict  */)"PassNT          %s\n", tmp);
#line 943
      free((void *)tmp);
      }
    }
#line 945
    if (prefs[found][1]) {
      {
#line 946
      tmp = printmem(tcreds->passlm, (size_t )16, 8);
#line 946
      printf((char const   */* __restrict  */)"PassLM          %s\n", tmp);
#line 947
      free((void *)tmp);
      }
    }
#line 949
    if (prefs[found][2]) {
      {
#line 950
      tmp = printmem(tcreds->passntlm2, (size_t )16, 8);
#line 950
      printf((char const   */* __restrict  */)"PassNTLMv2      %s\n", tmp);
#line 951
      free((void *)tmp);
      }
    }
    {
#line 953
    printf((char const   */* __restrict  */)"------------------------------------------------\n");
    }
  } else
#line 954
  if (ign == 4) {
    {
#line 955
    printf((char const   */* __restrict  */)"\nYour proxy is open, you don\'t need another proxy.\n");
    }
  } else {
    {
#line 957
    printf((char const   */* __restrict  */)"\nWrong credentials, invalid URL or proxy doesn\'t support NTLM nor BASIC.\n");
    }
  }
#line 959
  if (host) {
    {
#line 960
    free((void *)host);
    }
  }
#line 961
  return;
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 139 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.h"
char *trimr(char *buf ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/config.h"
void config_set(config_t cf , char *option , char *value ) ;
#line 40
int config_count(config_t cf ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/config.c"
config_t config_open(char const   *fname ) 
{ 
  config_t rc ;
  FILE *fp ;
  char *buf ;
  char *tmp ;
  char *key ;
  char *value ;
  char section[50] ;
  unsigned int tmp___0 ;
  int i ;
  int j ;
  int slen ;
  int len ;
  int quote ;
  char *tmp___1 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  unsigned short const   **tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;

  {
#line 47
  section[0] = (char )'g';
#line 47
  section[1] = (char )'l';
#line 47
  section[2] = (char )'o';
#line 47
  section[3] = (char )'b';
#line 47
  section[4] = (char )'a';
#line 47
  section[5] = (char )'l';
#line 47
  section[6] = (char )'\000';
#line 47
  tmp___0 = 7U;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (tmp___0 >= 50U) {
#line 47
      goto while_break;
    }
#line 47
    section[tmp___0] = (char)0;
#line 47
    tmp___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 52
  fp = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"r");
  }
#line 53
  if (! fp) {
#line 54
    return ((config_t )((void *)0));
  }
  {
#line 56
  buf = new((size_t )4096);
#line 57
  tmp___1 = new(sizeof(struct config_s ));
#line 57
  rc = (config_t )tmp___1;
#line 58
  rc->options = (hlist_t )((void *)0);
  }
  {
#line 60
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 60
    tmp___13 = feof(fp);
    }
#line 60
    if (tmp___13) {
#line 60
      goto while_break___0;
    }
    {
#line 61
    quote = 0;
#line 62
    tmp = fgets((char */* __restrict  */)buf, 4096, (FILE */* __restrict  */)fp);
    }
#line 63
    if (! tmp) {
#line 64
      goto while_break___0;
    }
    {
#line 66
    tmp___4 = strlen((char const   *)buf);
    }
#line 66
    if (4096UL < tmp___4) {
#line 66
      len = 4096;
    } else {
      {
#line 66
      tmp___3 = strlen((char const   *)buf);
#line 66
      len = (int )tmp___3;
      }
    }
#line 67
    if (! len) {
#line 68
      goto while_continue___0;
    } else {
      {
#line 67
      tmp___5 = feof(fp);
      }
#line 67
      if (tmp___5) {
#line 68
        goto while_continue___0;
      }
    }
#line 73
    j = 0;
#line 73
    i = j;
    {
#line 73
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 73
      if (j < len) {
        {
#line 73
        tmp___6 = __ctype_b_loc();
        }
#line 73
        if (! ((int const   )*(*tmp___6 + (int )*(buf + j)) & 8192)) {
#line 73
          goto while_break___1;
        }
      } else {
#line 73
        goto while_break___1;
      }
#line 73
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 78
    if (j >= len) {
#line 79
      goto while_continue___0;
    } else
#line 78
    if ((int )*(buf + j) == 35) {
#line 79
      goto while_continue___0;
    } else
#line 78
    if ((int )*(buf + j) == 59) {
#line 79
      goto while_continue___0;
    }
#line 84
    i = j;
    {
#line 84
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 84
      if (j < len) {
        {
#line 84
        tmp___7 = __ctype_b_loc();
        }
#line 84
        if (! ((int const   )*(*tmp___7 + (int )*(buf + j)) & 8)) {
#line 84
          goto while_break___2;
        }
      } else {
#line 84
        goto while_break___2;
      }
#line 84
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 89
    if (j >= len) {
#line 90
      goto while_continue___0;
    }
#line 95
    if ((int )*(buf + j) == 91) {
#line 96
      j ++;
      {
#line 96
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 96
        if (j < len) {
          {
#line 96
          tmp___8 = __ctype_b_loc();
          }
#line 96
          if (! ((int const   )*(*tmp___8 + (int )*(buf + j)) & 8192)) {
#line 96
            goto while_break___3;
          }
        } else {
#line 96
          goto while_break___3;
        }
#line 96
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 97
      slen = j;
      {
#line 97
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 97
        if (j < len) {
#line 97
          if (j - slen < 49) {
#line 97
            if ((int )*(buf + j) != 93) {
              {
#line 97
              tmp___9 = __ctype_b_loc();
              }
#line 97
              if ((int const   )*(*tmp___9 + (int )*(buf + j)) & 8192) {
#line 97
                goto while_break___4;
              }
            } else {
#line 97
              goto while_break___4;
            }
          } else {
#line 97
            goto while_break___4;
          }
        } else {
#line 97
          goto while_break___4;
        }
#line 97
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 98
      if (j - slen > 0) {
        {
#line 99
        strlcpy(section, (char const   *)(buf + slen), (size_t )((j - slen) + 1));
        }
      }
#line 101
      goto while_continue___0;
    }
    {
#line 107
    key = substr((char const   *)buf, i, j - i);
#line 112
    i = j;
    }
    {
#line 112
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 112
      if (j < len) {
        {
#line 112
        tmp___10 = __ctype_b_loc();
        }
#line 112
        if (! ((int const   )*(*tmp___10 + (int )*(buf + j)) & 8192)) {
#line 112
          goto while_break___5;
        }
      } else {
#line 112
        goto while_break___5;
      }
#line 112
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 113
    if (j >= len) {
#line 114
      goto while_continue___0;
    } else
#line 113
    if ((int )*(buf + j) == 35) {
#line 114
      goto while_continue___0;
    } else
#line 113
    if ((int )*(buf + j) == 59) {
#line 114
      goto while_continue___0;
    }
#line 119
    if ((int )*(buf + j) == 34) {
#line 120
      quote = 1;
#line 121
      j ++;
#line 121
      i = j;
      {
#line 121
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 121
        if (j < len) {
#line 121
          if (! ((int )*(buf + i) != 34)) {
#line 121
            goto while_break___6;
          }
        } else {
#line 121
          goto while_break___6;
        }
#line 121
        i ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 122
      if (i >= len) {
#line 123
        goto while_continue___0;
      }
    } else {
#line 125
      i = len;
    }
    {
#line 130
    value = substr((char const   *)buf, j, i - j);
    }
#line 131
    if (! quote) {
      {
#line 132
      tmp___11 = strcspn((char const   *)value, "#");
#line 132
      i = (int )tmp___11;
#line 133
      tmp___12 = strlen((char const   *)value);
      }
#line 133
      if ((size_t )i != tmp___12) {
#line 134
        *(value + i) = (char)0;
      }
      {
#line 135
      trimr(value);
      }
    }
#line 138
    if (debug) {
      {
#line 139
      printf((char const   */* __restrict  */)"section: %s, %s = \'%s\'\n", section,
             key, value);
      }
    }
    {
#line 140
    rc->options = hlist_add(rc->options, key, value, (hlist_add_t )0, (hlist_add_t )0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 143
  free((void *)buf);
#line 144
  fclose(fp);
  }
#line 146
  return (rc);
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/config.c"
void config_set(config_t cf , char *option , char *value ) 
{ 


  {
  {
#line 150
  cf->options = hlist_mod(cf->options, option, value, 1);
  }
#line 151
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/config.c"
char *config_pop(config_t cf , char const   *option ) 
{ 
  char *tmp ;

  {
  {
#line 156
  tmp = hlist_get(cf->options, option);
  }
#line 157
  if (tmp) {
    {
#line 158
    tmp = strdup((char const   *)tmp);
#line 159
    cf->options = hlist_del(cf->options, option);
    }
  }
#line 162
  return (tmp);
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/config.c"
int config_count(config_t cf ) 
{ 
  int tmp ;

  {
  {
#line 166
  tmp = hlist_count(cf->options);
  }
#line 166
  return (tmp);
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/config.c"
void config_close(config_t cf ) 
{ 


  {
#line 170
  if ((unsigned long )cf == (unsigned long )((void *)0)) {
#line 171
    return;
  }
  {
#line 173
  cf->options = hlist_free(cf->options);
#line 174
  free((void *)cf);
  }
#line 175
  return;
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 116 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.h"
plist_t plist_del(plist_t list , unsigned long key ) ;
#line 121
int plist_count(plist_t list ) ;
#line 125
hlist_t hlist_dup(hlist_t list ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
char hextab[17]  = 
#line 38 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
  {      (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'A',      (char )'B', 
        (char )'C',      (char )'D',      (char )'E',      (char )'F', 
        (char)0};
#line 39 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
int hexindex[128]  = 
#line 39
  {      -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        0,      1,      2,      3, 
        4,      5,      6,      7, 
        8,      9,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      10,      11,      12, 
        13,      14,      15,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      10,      11,      12, 
        13,      14,      15,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1};
#line 46 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
void myexit(int rc ) 
{ 


  {
#line 47
  if (rc) {
    {
#line 48
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Exitting with error. Check daemon logs or run with -v.\n");
    }
  }
  {
#line 50
  exit(rc);
  }
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
void croak(char const   *msg , int console ) 
{ 


  {
#line 54
  if (console) {
    {
#line 55
    printf((char const   */* __restrict  */)"%s", msg);
    }
  } else {
    {
#line 57
    syslog(3, "%s", msg);
    }
  }
  {
#line 59
  myexit(1);
  }
#line 60
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
plist_t plist_add(plist_t list , unsigned long key , void *aux ) 
{ 
  plist_t tmp ;
  plist_t t ;
  void *tmp___0 ;

  {
  {
#line 72
  t = list;
#line 74
  tmp___0 = malloc(sizeof(struct plist_s ));
#line 74
  tmp = (plist_t )tmp___0;
#line 75
  tmp->key = key;
#line 76
  tmp->aux = aux;
#line 77
  tmp->next = (struct plist_s *)((void *)0);
  }
#line 79
  if ((unsigned long )list == (unsigned long )((void *)0)) {
#line 80
    return (tmp);
  }
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! t->next) {
#line 82
      goto while_break;
    }
#line 83
    t = t->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  t->next = tmp;
#line 87
  return (list);
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
plist_t plist_del(plist_t list , unsigned long key ) 
{ 
  plist_t ot ;
  plist_t t ;
  plist_t tmp ;

  {
#line 95
  ot = (plist_t )((void *)0);
#line 95
  t = list;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! t) {
#line 97
      goto while_break;
    }
#line 98
    if (t->key == key) {
#line 99
      goto while_break;
    }
#line 100
    ot = t;
#line 101
    t = t->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  if (t) {
#line 105
    tmp = t->next;
#line 107
    if (t->aux) {
      {
#line 108
      free(t->aux);
      }
    }
    {
#line 109
    free((void *)t);
    }
#line 110
    if ((unsigned long )ot == (unsigned long )((void *)0)) {
#line 111
      return (tmp);
    }
#line 113
    ot->next = tmp;
  }
#line 116
  return (list);
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
int plist_in(plist_t list , unsigned long key ) 
{ 
  plist_t t ;

  {
#line 123
  t = list;
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 125
    if (! t) {
#line 125
      goto while_break;
    }
#line 126
    if (t->key == key) {
#line 127
      goto while_break;
    }
#line 128
    t = t->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  return ((unsigned long )t != (unsigned long )((void *)0));
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
void plist_dump(plist_t list ) 
{ 
  plist_t t ;

  {
#line 141
  t = list;
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (! t) {
#line 142
      goto while_break;
    }
    {
#line 143
    printf((char const   */* __restrict  */)"List data: %lu => 0x%8p\n", t->key, t->aux);
#line 144
    t = t->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
char *plist_get(plist_t list , int key ) 
{ 
  plist_t t ;
  void *tmp ;

  {
#line 152
  t = list;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! t) {
#line 154
      goto while_break;
    }
#line 155
    if (t->key == (unsigned long )key) {
#line 156
      goto while_break;
    }
#line 157
    t = t->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if ((unsigned long )t == (unsigned long )((void *)0)) {
#line 160
    tmp = (void *)0;
  } else {
#line 160
    tmp = t->aux;
  }
#line 160
  return ((char *)tmp);
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
int plist_pop(plist_t *list , void **aux ) 
{ 
  plist_t tmp ;
  plist_t t ;
  int id ;
  int ok ;
  void *a ;
  int tmp___0 ;

  {
#line 180
  id = 0;
#line 181
  ok = 0;
#line 182
  a = (void *)0;
#line 184
  if ((unsigned long )list == (unsigned long )((void *)0)) {
#line 185
    return (0);
  } else
#line 184
  if ((unsigned long )*list == (unsigned long )((void *)0)) {
#line 185
    return (0);
  }
#line 187
  t = *list;
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    if (! ok) {
#line 188
      if (! t) {
#line 188
        goto while_break;
      }
    } else {
#line 188
      goto while_break;
    }
    {
#line 189
    id = (int )t->key;
#line 190
    a = t->aux;
#line 191
    tmp = t->next;
#line 193
    tmp___0 = so_closed(id);
    }
#line 193
    if (tmp___0) {
      {
#line 194
      close(id);
      }
#line 195
      if (t->aux) {
        {
#line 196
        free(t->aux);
        }
      }
    } else {
#line 198
      ok = 1;
    }
    {
#line 200
    free((void *)t);
#line 201
    t = tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 204
  *list = t;
#line 206
  if (ok) {
#line 207
    if ((unsigned long )aux != (unsigned long )((void *)0)) {
#line 208
      *aux = a;
    }
#line 209
    return (id);
  }
#line 212
  return (0);
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
int plist_count(plist_t list ) 
{ 
  plist_t t ;
  int rc ;

  {
#line 219
  t = list;
#line 220
  rc = 0;
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
#line 222
    if (! t) {
#line 222
      goto while_break;
    }
#line 223
    rc ++;
#line 224
    t = t->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 227
  return (rc);
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
plist_t plist_free(plist_t list ) 
{ 
  plist_t t ;

  {
#line 234
  t = list;
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (! list) {
#line 236
      goto while_break;
    }
#line 237
    t = list->next;
#line 238
    if (list->aux) {
      {
#line 239
      free(list->aux);
      }
    }
    {
#line 240
    free((void *)list);
#line 241
    list = t;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 244
  return ((plist_t )((void *)0));
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
hlist_t hlist_add(hlist_t list , char *key , char *value , hlist_add_t allockey ,
                  hlist_add_t allocvalue ) 
{ 
  hlist_t tmp ;
  hlist_t t ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 260
  t = list;
#line 262
  if ((unsigned long )key == (unsigned long )((void *)0)) {
#line 263
    return (list);
  } else
#line 262
  if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 263
    return (list);
  }
  {
#line 265
  tmp___0 = malloc(sizeof(struct hlist_s ));
#line 265
  tmp = (hlist_t )tmp___0;
  }
#line 266
  if ((unsigned int )allockey == 1U) {
    {
#line 266
    tmp___1 = strdup((char const   *)key);
#line 266
    tmp->key = tmp___1;
    }
  } else {
#line 266
    tmp->key = key;
  }
#line 267
  if ((unsigned int )allocvalue == 1U) {
    {
#line 267
    tmp___2 = strdup((char const   *)value);
#line 267
    tmp->value = tmp___2;
    }
  } else {
#line 267
    tmp->value = value;
  }
#line 268
  tmp->next = (struct hlist_s *)((void *)0);
#line 269
  tmp->islist = 0;
#line 271
  if ((unsigned long )list == (unsigned long )((void *)0)) {
#line 272
    return (tmp);
  }
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 274
    if (! t->next) {
#line 274
      goto while_break;
    }
#line 275
    t = t->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 277
  t->next = tmp;
#line 279
  return (list);
}
}
#line 285 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
hlist_t hlist_dup(hlist_t list ) 
{ 
  hlist_t tmp ;
  hlist_t t ;

  {
#line 286
  tmp = (hlist_t )((void *)0);
#line 286
  t = list;
  {
#line 288
  while (1) {
    while_continue: /* CIL Label */ ;
#line 288
    if (! t) {
#line 288
      goto while_break;
    }
    {
#line 289
    tmp = hlist_add(tmp, t->key, t->value, (hlist_add_t )1, (hlist_add_t )1);
#line 290
    t = t->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 293
  return (tmp);
}
}
#line 299 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
hlist_t hlist_del(hlist_t list , char const   *key ) 
{ 
  hlist_t ot ;
  hlist_t t ;
  int tmp ;
  hlist_t tmp___0 ;

  {
#line 300
  ot = (hlist_t )((void *)0);
#line 300
  t = list;
  {
#line 302
  while (1) {
    while_continue: /* CIL Label */ ;
#line 302
    if (! t) {
#line 302
      goto while_break;
    }
    {
#line 303
    tmp = strcasecmp((char const   *)t->key, key);
    }
#line 303
    if (! tmp) {
#line 304
      goto while_break;
    }
#line 305
    ot = t;
#line 306
    t = t->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 309
  if (t) {
    {
#line 310
    tmp___0 = t->next;
#line 312
    free((void *)t->key);
#line 313
    free((void *)t->value);
#line 314
    free((void *)t);
    }
#line 316
    if ((unsigned long )ot == (unsigned long )((void *)0)) {
#line 317
      return (tmp___0);
    }
#line 319
    ot->next = tmp___0;
  }
#line 322
  return (list);
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
hlist_t hlist_mod(hlist_t list , char *key , char *value , int add ) 
{ 
  hlist_t t ;
  int tmp ;

  {
#line 334
  t = list;
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 336
    if (! t) {
#line 336
      goto while_break;
    }
    {
#line 337
    tmp = strcasecmp((char const   *)t->key, (char const   *)key);
    }
#line 337
    if (! tmp) {
#line 338
      goto while_break;
    }
#line 339
    t = t->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  if (t) {
    {
#line 343
    free((void *)t->value);
#line 344
    t->value = strdup((char const   *)value);
    }
  } else
#line 345
  if (add) {
    {
#line 346
    list = hlist_add(list, key, value, (hlist_add_t )1, (hlist_add_t )1);
    }
  }
#line 349
  return (list);
}
}
#line 355 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
int hlist_in(hlist_t list , char const   *key ) 
{ 
  hlist_t t ;
  int tmp ;

  {
#line 356
  t = list;
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 358
    if (! t) {
#line 358
      goto while_break;
    }
    {
#line 359
    tmp = strcasecmp((char const   *)t->key, key);
    }
#line 359
    if (! tmp) {
#line 360
      goto while_break;
    }
#line 361
    t = t->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 364
  return ((unsigned long )t != (unsigned long )((void *)0));
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
int hlist_count(hlist_t list ) 
{ 
  hlist_t t ;
  int rc ;

  {
#line 371
  t = list;
#line 372
  rc = 0;
  {
#line 374
  while (1) {
    while_continue: /* CIL Label */ ;
#line 374
    if (! t) {
#line 374
      goto while_break;
    }
#line 375
    rc ++;
#line 376
    t = t->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 379
  return (rc);
}
}
#line 385 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
char *hlist_get(hlist_t list , char const   *key ) 
{ 
  hlist_t t ;
  int tmp ;
  char *tmp___0 ;

  {
#line 386
  t = list;
  {
#line 388
  while (1) {
    while_continue: /* CIL Label */ ;
#line 388
    if (! t) {
#line 388
      goto while_break;
    }
    {
#line 389
    tmp = strcasecmp((char const   *)t->key, key);
    }
#line 389
    if (! tmp) {
#line 390
      goto while_break;
    }
#line 391
    t = t->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 394
  if ((unsigned long )t == (unsigned long )((void *)0)) {
#line 394
    tmp___0 = (char *)((void *)0);
  } else {
#line 394
    tmp___0 = t->value;
  }
#line 394
  return (tmp___0);
}
}
#line 401 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
int hlist_subcmp(hlist_t list , char const   *key , char const   *substr___0 ) 
{ 
  int found ;
  char *tmp ;
  char *low ;
  char *tmp___0 ;

  {
  {
#line 402
  found = 0;
#line 405
  low = strdup(substr___0);
#line 405
  lowercase(low);
#line 406
  tmp = hlist_get(list, key);
  }
#line 407
  if (tmp) {
    {
#line 408
    tmp = strdup((char const   *)tmp);
#line 408
    lowercase(tmp);
#line 409
    tmp___0 = strstr((char const   *)tmp, (char const   *)low);
    }
#line 409
    if (tmp___0) {
#line 410
      found = 1;
    }
    {
#line 412
    free((void *)tmp);
    }
  }
  {
#line 415
  free((void *)low);
  }
#line 416
  return (found);
}
}
#line 423 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
int hlist_subcmp_all(hlist_t list , char const   *key , char const   *substr___0 ) 
{ 
  hlist_t t ;
  int found ;
  char *tmp ;
  char *low ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 424
  t = list;
#line 425
  found = 0;
#line 428
  low = strdup(substr___0);
#line 428
  lowercase(low);
  }
  {
#line 429
  while (1) {
    while_continue: /* CIL Label */ ;
#line 429
    if (! t) {
#line 429
      goto while_break;
    }
    {
#line 430
    tmp___1 = strcasecmp((char const   *)t->key, key);
    }
#line 430
    if (! tmp___1) {
      {
#line 431
      tmp = strdup((char const   *)t->value);
#line 431
      lowercase(tmp);
#line 432
      tmp___0 = strstr((char const   *)tmp, (char const   *)low);
      }
#line 432
      if (tmp___0) {
#line 433
        found = 1;
      }
      {
#line 435
      free((void *)tmp);
      }
    }
#line 437
    t = t->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 440
  free((void *)low);
  }
#line 441
  return (found);
}
}
#line 448 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
hlist_t hlist_free(hlist_t list ) 
{ 
  hlist_t t ;

  {
#line 449
  t = list;
  {
#line 451
  while (1) {
    while_continue: /* CIL Label */ ;
#line 451
    if (! list) {
#line 451
      goto while_break;
    }
    {
#line 452
    t = list->next;
#line 454
    free((void *)list->key);
#line 455
    free((void *)list->value);
#line 456
    free((void *)list);
#line 458
    list = t;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 461
  return ((hlist_t )((void *)0));
}
}
#line 467 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
void hlist_dump(hlist_t list ) 
{ 
  hlist_t t ;

  {
#line 470
  t = list;
  {
#line 471
  while (1) {
    while_continue: /* CIL Label */ ;
#line 471
    if (! t) {
#line 471
      goto while_break;
    }
    {
#line 472
    printf((char const   */* __restrict  */)"%-30s => %s\n", t->key, t->value);
#line 473
    t = t->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 475
  return;
}
}
#line 481 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
char *substr(char const   *src , int pos , int len ) 
{ 
  int l ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;

  {
#line 485
  if (len == 0) {
    {
#line 486
    tmp___0 = strlen(src);
#line 486
    len = (int )tmp___0;
    }
  }
  {
#line 488
  tmp___3 = strlen(src);
  }
#line 488
  if ((size_t )len < tmp___3 - (size_t )pos) {
#line 488
    l = len;
  } else {
    {
#line 488
    tmp___2 = strlen(src);
#line 488
    l = (int )(tmp___2 - (size_t )pos);
    }
  }
#line 489
  if (l <= 0) {
    {
#line 490
    tmp___4 = new((size_t )1);
    }
#line 490
    return (tmp___4);
  }
  {
#line 492
  tmp = new((size_t )(l + 1));
#line 493
  strlcpy(tmp, src + pos, (size_t )(l + 1));
  }
#line 495
  return (tmp);
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
rr_data_t new_rr_data(void) 
{ 
  rr_data_t data ;
  void *tmp ;

  {
  {
#line 504
  tmp = malloc(sizeof(struct rr_data_s ));
#line 504
  data = (rr_data_t )tmp;
#line 505
  data->req = 0;
#line 506
  data->code = 0;
#line 507
  data->skip_http = 0;
#line 508
  data->body_len = 0;
#line 509
  data->empty = 1;
#line 510
  data->port = 0;
#line 511
  data->http_version = -1;
#line 512
  data->headers = (hlist_t )((void *)0);
#line 513
  data->method = (char *)((void *)0);
#line 514
  data->url = (char *)((void *)0);
#line 515
  data->rel_url = (char *)((void *)0);
#line 516
  data->hostname = (char *)((void *)0);
#line 517
  data->http = (char *)((void *)0);
#line 518
  data->msg = (char *)((void *)0);
#line 519
  data->body = (char *)((void *)0);
#line 520
  data->errmsg = (char *)((void *)0);
  }
#line 522
  return (data);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
rr_data_t copy_rr_data(rr_data_t dst , rr_data_t src ) 
{ 


  {
#line 529
  if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 530
    return ((rr_data_t )((void *)0));
  } else
#line 529
  if ((unsigned long )dst == (unsigned long )((void *)0)) {
#line 530
    return ((rr_data_t )((void *)0));
  }
  {
#line 532
  reset_rr_data(dst);
#line 533
  dst->req = src->req;
#line 534
  dst->code = src->code;
#line 535
  dst->skip_http = src->skip_http;
#line 536
  dst->body_len = src->body_len;
#line 537
  dst->empty = src->empty;
#line 538
  dst->port = src->port;
#line 539
  dst->http_version = src->http_version;
  }
#line 541
  if (src->headers) {
    {
#line 542
    dst->headers = hlist_dup(src->headers);
    }
  }
#line 543
  if (src->method) {
    {
#line 544
    dst->method = strdup((char const   *)src->method);
    }
  }
#line 545
  if (src->url) {
    {
#line 546
    dst->url = strdup((char const   *)src->url);
    }
  }
#line 547
  if (src->rel_url) {
    {
#line 548
    dst->rel_url = strdup((char const   *)src->rel_url);
    }
  }
#line 549
  if (src->hostname) {
    {
#line 550
    dst->hostname = strdup((char const   *)src->hostname);
    }
  }
#line 551
  if (src->http) {
    {
#line 552
    dst->http = strdup((char const   *)src->http);
    }
  }
#line 553
  if (src->msg) {
    {
#line 554
    dst->msg = strdup((char const   *)src->msg);
    }
  }
#line 555
  if (src->body) {
#line 555
    if (src->body_len > 0) {
      {
#line 556
      dst->body = new((size_t )src->body_len);
#line 557
      memcpy((void */* __restrict  */)dst->body, (void const   */* __restrict  */)src->body,
             (size_t )src->body_len);
      }
    }
  }
#line 560
  return (dst);
}
}
#line 566 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
rr_data_t dup_rr_data(rr_data_t data ) 
{ 
  rr_data_t tmp ;
  rr_data_t tmp___0 ;

  {
#line 569
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 570
    return ((rr_data_t )((void *)0));
  }
  {
#line 572
  tmp = new_rr_data();
#line 573
  tmp___0 = copy_rr_data(tmp, data);
  }
#line 573
  return (tmp___0);
}
}
#line 579 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
rr_data_t reset_rr_data(rr_data_t data ) 
{ 


  {
#line 580
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 581
    return ((rr_data_t )((void *)0));
  }
#line 583
  data->req = 0;
#line 584
  data->code = 0;
#line 585
  data->skip_http = 0;
#line 586
  data->body_len = 0;
#line 587
  data->empty = 1;
#line 588
  data->port = 0;
#line 589
  data->http_version = -1;
#line 591
  if (data->headers) {
    {
#line 591
    hlist_free(data->headers);
    }
  }
#line 592
  if (data->method) {
    {
#line 592
    free((void *)data->method);
    }
  }
#line 593
  if (data->url) {
    {
#line 593
    free((void *)data->url);
    }
  }
#line 594
  if (data->rel_url) {
    {
#line 594
    free((void *)data->rel_url);
    }
  }
#line 595
  if (data->hostname) {
    {
#line 595
    free((void *)data->hostname);
    }
  }
#line 596
  if (data->http) {
    {
#line 596
    free((void *)data->http);
    }
  }
#line 597
  if (data->msg) {
    {
#line 597
    free((void *)data->msg);
    }
  }
#line 598
  if (data->body) {
    {
#line 598
    free((void *)data->body);
    }
  }
#line 600
  data->headers = (hlist_t )((void *)0);
#line 601
  data->method = (char *)((void *)0);
#line 602
  data->url = (char *)((void *)0);
#line 603
  data->rel_url = (char *)((void *)0);
#line 604
  data->hostname = (char *)((void *)0);
#line 605
  data->http = (char *)((void *)0);
#line 606
  data->msg = (char *)((void *)0);
#line 607
  data->body = (char *)((void *)0);
#line 608
  data->errmsg = (char *)((void *)0);
#line 610
  return (data);
}
}
#line 617 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
void free_rr_data(rr_data_t data ) 
{ 


  {
#line 618
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 619
    return;
  }
#line 621
  if (data->headers) {
    {
#line 621
    hlist_free(data->headers);
    }
  }
#line 622
  if (data->method) {
    {
#line 622
    free((void *)data->method);
    }
  }
#line 623
  if (data->url) {
    {
#line 623
    free((void *)data->url);
    }
  }
#line 624
  if (data->rel_url) {
    {
#line 624
    free((void *)data->rel_url);
    }
  }
#line 625
  if (data->hostname) {
    {
#line 625
    free((void *)data->hostname);
    }
  }
#line 626
  if (data->http) {
    {
#line 626
    free((void *)data->http);
    }
  }
#line 627
  if (data->msg) {
    {
#line 627
    free((void *)data->msg);
    }
  }
#line 628
  if (data->body) {
    {
#line 628
    free((void *)data->body);
    }
  }
  {
#line 629
  memset((void *)data, 0, sizeof(struct rr_data_s ));
#line 630
  free((void *)data);
  }
#line 631
  return;
}
}
#line 636 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
char *trimr(char *buf ) 
{ 
  int i ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 639
  tmp = strlen((char const   *)buf);
#line 639
  i = (int )(tmp - 1UL);
  }
  {
#line 639
  while (1) {
    while_continue: /* CIL Label */ ;
#line 639
    if (i >= 0) {
      {
#line 639
      tmp___0 = __ctype_b_loc();
      }
#line 639
      if (! ((int const   )*(*tmp___0 + (int )*(buf + i)) & 8192)) {
#line 639
        goto while_break;
      }
    } else {
#line 639
      goto while_break;
    }
#line 639
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 640
  *(buf + (i + 1)) = (char)0;
#line 642
  return (buf);
}
}
#line 668 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
size_t strlcpy(char *dst , char const   *src , size_t siz ) 
{ 
  char *d ;
  char const   *s ;
  size_t n ;
  char *tmp ;
  char tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 669
  d = dst;
#line 670
  s = src;
#line 671
  n = siz;
#line 674
  if (n != 0UL) {
    {
#line 675
    while (1) {
      while_continue: /* CIL Label */ ;
#line 675
      n --;
#line 675
      if (! (n != 0UL)) {
#line 675
        goto while_break;
      }
#line 676
      tmp = d;
#line 676
      d ++;
#line 676
      tmp___1 = s;
#line 676
      s ++;
#line 676
      tmp___0 = (char )*tmp___1;
#line 676
      *tmp = tmp___0;
#line 676
      if ((int )tmp___0 == 0) {
#line 677
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 682
  if (n == 0UL) {
#line 683
    if (siz != 0UL) {
#line 684
      *d = (char )'\000';
    }
    {
#line 685
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 685
      tmp___2 = s;
#line 685
      s ++;
#line 685
      if (! *tmp___2) {
#line 685
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 688
  return ((size_t )((s - src) - 1L));
}
}
#line 695 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
size_t strlcat(char *dst , char const   *src , size_t siz ) 
{ 
  char *d ;
  char const   *s ;
  size_t n ;
  size_t dlen ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
#line 696
  d = dst;
#line 697
  s = src;
#line 698
  n = siz;
  {
#line 702
  while (1) {
    while_continue: /* CIL Label */ ;
#line 702
    tmp = n;
#line 702
    n --;
#line 702
    if (tmp != 0UL) {
#line 702
      if (! ((int )*d != 0)) {
#line 702
        goto while_break;
      }
    } else {
#line 702
      goto while_break;
    }
#line 703
    d ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 705
  dlen = (size_t )(d - dst);
#line 706
  n = siz - dlen;
#line 708
  if (n == 0UL) {
    {
#line 709
    tmp___0 = strlen(s);
    }
#line 709
    return (dlen + tmp___0);
  }
  {
#line 711
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 711
    if (! ((int const   )*s != 0)) {
#line 711
      goto while_break___0;
    }
#line 712
    if (n != 1UL) {
#line 713
      tmp___1 = d;
#line 713
      d ++;
#line 713
      *tmp___1 = (char )*s;
#line 714
      n --;
    }
#line 716
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 718
  *d = (char )'\000';
#line 720
  return (dlen + (size_t )(s - src));
}
}
#line 726 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
char *new(size_t size ) 
{ 
  char *tmp ;
  void *tmp___0 ;

  {
  {
#line 729
  tmp___0 = malloc(size);
#line 729
  tmp = (char *)tmp___0;
#line 730
  memset((void *)tmp, 0, size);
  }
#line 732
  return (tmp);
}
}
#line 738 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
char *lowercase(char *str ) 
{ 
  int i ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 741
  i = 0;
  {
#line 741
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 741
    tmp___0 = strlen((char const   *)str);
    }
#line 741
    if (! ((size_t )i < tmp___0)) {
#line 741
      goto while_break;
    }
    {
#line 742
    tmp = tolower((int )*(str + i));
#line 742
    *(str + i) = (char )tmp;
#line 741
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 744
  return (str);
}
}
#line 750 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
char *uppercase(char *str ) 
{ 
  int i ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 753
  i = 0;
  {
#line 753
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 753
    tmp___0 = strlen((char const   *)str);
    }
#line 753
    if (! ((size_t )i < tmp___0)) {
#line 753
      goto while_break;
    }
    {
#line 754
    tmp = toupper((int )*(str + i));
#line 754
    *(str + i) = (char )tmp;
#line 753
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 756
  return (str);
}
}
#line 759 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
int unicode(char **dst , char *src ) 
{ 
  char *tmp ;
  int l ;
  int i ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 763
  if (! src) {
#line 764
    *dst = (char *)((void *)0);
#line 765
    return (0);
  }
  {
#line 768
  tmp___2 = strlen((char const   *)src);
  }
#line 768
  if (64UL < tmp___2) {
#line 768
    l = 64;
  } else {
    {
#line 768
    tmp___1 = strlen((char const   *)src);
#line 768
    l = (int )tmp___1;
    }
  }
  {
#line 769
  tmp = new((size_t )(2 * l));
#line 770
  i = 0;
  }
  {
#line 770
  while (1) {
    while_continue: /* CIL Label */ ;
#line 770
    if (! (i < l)) {
#line 770
      goto while_break;
    }
#line 771
    *(tmp + 2 * i) = *(src + i);
#line 770
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 773
  *dst = tmp;
#line 774
  return (2 * l);
}
}
#line 777 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
char *urlencode(char const   *str ) 
{ 
  char *tmp ;
  int i ;
  int pos ;
  size_t tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;

  {
  {
#line 781
  tmp___0 = strlen(str);
#line 781
  tmp = new(tmp___0 * 3UL + 1UL);
#line 782
  pos = 0;
#line 782
  i = 0;
  }
  {
#line 782
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 782
    tmp___5 = strlen(str);
    }
#line 782
    if (! ((size_t )i < tmp___5)) {
#line 782
      goto while_break;
    }
    {
#line 783
    tmp___2 = __ctype_b_loc();
    }
#line 783
    if ((int const   )*(*tmp___2 + (int )*(str + i)) & 2048) {
#line 784
      tmp___1 = pos;
#line 784
      pos ++;
#line 784
      *(tmp + tmp___1) = (char )*(str + i);
    } else {
      {
#line 783
      tmp___3 = tolower((int )*(str + i));
      }
#line 783
      if (tmp___3 >= 97) {
        {
#line 783
        tmp___4 = tolower((int )*(str + i));
        }
#line 783
        if (tmp___4 <= 122) {
#line 784
          tmp___1 = pos;
#line 784
          pos ++;
#line 784
          *(tmp + tmp___1) = (char )*(str + i);
        } else {
#line 783
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 783
      if ((int const   )*(str + i) == 46) {
#line 784
        tmp___1 = pos;
#line 784
        pos ++;
#line 784
        *(tmp + tmp___1) = (char )*(str + i);
      } else
#line 783
      if ((int const   )*(str + i) == 45) {
#line 784
        tmp___1 = pos;
#line 784
        pos ++;
#line 784
        *(tmp + tmp___1) = (char )*(str + i);
      } else
#line 783
      if ((int const   )*(str + i) == 95) {
#line 784
        tmp___1 = pos;
#line 784
        pos ++;
#line 784
        *(tmp + tmp___1) = (char )*(str + i);
      } else
#line 783
      if ((int const   )*(str + i) == 126) {
#line 784
        tmp___1 = pos;
#line 784
        pos ++;
#line 784
        *(tmp + tmp___1) = (char )*(str + i);
      } else {
        {
#line 786
        sprintf((char */* __restrict  */)(tmp + pos), (char const   */* __restrict  */)"%%%X",
                (int )((unsigned char )*(str + i)));
#line 787
        pos += 3;
        }
      }
    }
#line 782
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 791
  return (tmp);
}
}
#line 794 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
char *printmem(char *src , size_t len , int bitwidth ) 
{ 
  char *tmp ;
  int i ;

  {
  {
#line 798
  tmp = new(2UL * len + 1UL);
#line 799
  i = 0;
  }
  {
#line 799
  while (1) {
    while_continue: /* CIL Label */ ;
#line 799
    if (! ((size_t )i < len)) {
#line 799
      goto while_break;
    }
#line 800
    *(tmp + i * 2) = hextab[((int )((uint8_t )*(src + i)) ^ (int )((uint8_t )(7 - bitwidth))) >> 4];
#line 801
    *(tmp + (i * 2 + 1)) = hextab[((int )*(src + i) ^ (int )((uint8_t )(7 - bitwidth))) & 15];
#line 799
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 804
  return (tmp);
}
}
#line 807 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
char *scanmem(char *src , int bitwidth ) 
{ 
  int h ;
  int l ;
  int i ;
  int bytes ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 811
  tmp___0 = strlen((char const   *)src);
  }
#line 811
  if (tmp___0 % 2UL) {
#line 812
    return ((char *)((void *)0));
  }
  {
#line 814
  tmp___1 = strlen((char const   *)src);
#line 814
  bytes = (int )(tmp___1 / 2UL);
#line 815
  tmp = new((size_t )(bytes + 1));
#line 816
  i = 0;
  }
  {
#line 816
  while (1) {
    while_continue: /* CIL Label */ ;
#line 816
    if (! (i < bytes)) {
#line 816
      goto while_break;
    }
#line 817
    h = hexindex[(int )*(src + i * 2)];
#line 818
    l = hexindex[(int )*(src + (i * 2 + 1))];
#line 819
    if (h < 0) {
      {
#line 820
      free((void *)tmp);
      }
#line 821
      return ((char *)((void *)0));
    } else
#line 819
    if (l < 0) {
      {
#line 820
      free((void *)tmp);
      }
#line 821
      return ((char *)((void *)0));
    }
#line 823
    *(tmp + i) = (char )(((h << 4) + l) ^ (int )((uint8_t )(7 - bitwidth)));
#line 816
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 825
  *(tmp + i) = (char)0;
#line 827
  return (tmp);
}
}
#line 848 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
char base64[64]  = 
#line 848
  {      (char )'A',      (char )'B',      (char )'C',      (char )'D', 
        (char )'E',      (char )'F',      (char )'G',      (char )'H', 
        (char )'I',      (char )'J',      (char )'K',      (char )'L', 
        (char )'M',      (char )'N',      (char )'O',      (char )'P', 
        (char )'Q',      (char )'R',      (char )'S',      (char )'T', 
        (char )'U',      (char )'V',      (char )'W',      (char )'X', 
        (char )'Y',      (char )'Z',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f', 
        (char )'g',      (char )'h',      (char )'i',      (char )'j', 
        (char )'k',      (char )'l',      (char )'m',      (char )'n', 
        (char )'o',      (char )'p',      (char )'q',      (char )'r', 
        (char )'s',      (char )'t',      (char )'u',      (char )'v', 
        (char )'w',      (char )'x',      (char )'y',      (char )'z', 
        (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'+',      (char )'/'};
#line 856 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
int index64[128]  = 
#line 856
  {      -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      62, 
        -1,      -1,      -1,      63, 
        52,      53,      54,      55, 
        56,      57,      58,      59, 
        60,      61,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      0,      1,      2, 
        3,      4,      5,      6, 
        7,      8,      9,      10, 
        11,      12,      13,      14, 
        15,      16,      17,      18, 
        19,      20,      21,      22, 
        23,      24,      25,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      26,      27,      28, 
        29,      30,      31,      32, 
        33,      34,      35,      36, 
        37,      38,      39,      40, 
        41,      42,      43,      44, 
        45,      46,      47,      48, 
        49,      50,      51,      -1, 
        -1,      -1,      -1,      -1};
#line 866 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
void to_base64(unsigned char *out , unsigned char const   *in , size_t len , size_t olen ) 
{ 
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char fragment ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;

  {
  {
#line 867
  while (1) {
    while_continue: /* CIL Label */ ;
#line 867
    if (len >= 3UL) {
#line 867
      if (! (olen > 10UL)) {
#line 867
        goto while_break;
      }
    } else {
#line 867
      goto while_break;
    }
#line 868
    tmp = out;
#line 868
    out ++;
#line 868
    *tmp = (unsigned char )base64[(int const   )*(in + 0) >> 2];
#line 869
    tmp___0 = out;
#line 869
    out ++;
#line 869
    *tmp___0 = (unsigned char )base64[(((int const   )*(in + 0) << 4) & 48) | ((int const   )*(in + 1) >> 4)];
#line 870
    tmp___1 = out;
#line 870
    out ++;
#line 870
    *tmp___1 = (unsigned char )base64[(((int const   )*(in + 1) << 2) & 60) | ((int const   )*(in + 2) >> 6)];
#line 871
    tmp___2 = out;
#line 871
    out ++;
#line 871
    *tmp___2 = (unsigned char )base64[(int const   )*(in + 2) & 63];
#line 872
    olen -= 4UL;
#line 873
    len -= 3UL;
#line 874
    in += 3;
  }
  while_break: /* CIL Label */ ;
  }
#line 878
  if (len > 0UL) {
#line 878
    if (olen > 4UL) {
#line 881
      tmp___3 = out;
#line 881
      out ++;
#line 881
      *tmp___3 = (unsigned char )base64[(int const   )*(in + 0) >> 2];
#line 882
      fragment = (unsigned char )(((int const   )*(in + 0) << 4) & 48);
#line 883
      if (len > 1UL) {
#line 884
        fragment = (unsigned char )((int )fragment | (int )((int const   )*(in + 1) >> 4));
      }
#line 885
      tmp___4 = out;
#line 885
      out ++;
#line 885
      *tmp___4 = (unsigned char )base64[fragment];
#line 886
      tmp___5 = out;
#line 886
      out ++;
#line 886
      if (len < 2UL) {
#line 886
        *tmp___5 = (unsigned char )'=';
      } else {
#line 886
        *tmp___5 = (unsigned char )base64[((int const   )*(in + 1) << 2) & 60];
      }
#line 887
      tmp___6 = out;
#line 887
      out ++;
#line 887
      *tmp___6 = (unsigned char )'=';
    }
  }
#line 889
  *out = (unsigned char )'\000';
#line 890
  return;
}
}
#line 894 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/utils.c"
int from_base64(char *out , char const   *in ) 
{ 
  int len ;
  register unsigned char digit1 ;
  register unsigned char digit2 ;
  register unsigned char digit3 ;
  register unsigned char digit4 ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 896
  len = 0;
  {
#line 899
  while (1) {
    while_continue: /* CIL Label */ ;
#line 900
    digit1 = (unsigned char )*(in + 0);
#line 901
    if ((int )digit1 > 127) {
#line 902
      return (-1);
    } else
#line 901
    if (index64[(unsigned int )digit1] == -1) {
#line 902
      return (-1);
    }
#line 904
    digit2 = (unsigned char )*(in + 1);
#line 905
    if ((int )digit2 > 127) {
#line 906
      return (-1);
    } else
#line 905
    if (index64[(unsigned int )digit2] == -1) {
#line 906
      return (-1);
    }
#line 908
    digit3 = (unsigned char )*(in + 2);
#line 909
    if ((int )digit3 > 127) {
#line 910
      return (-1);
    } else
#line 909
    if ((int )digit3 != 61) {
#line 909
      if (index64[(unsigned int )digit3] == -1) {
#line 910
        return (-1);
      }
    }
#line 912
    digit4 = (unsigned char )*(in + 3);
#line 913
    if ((int )digit4 > 127) {
#line 914
      return (-1);
    } else
#line 913
    if ((int )digit4 != 61) {
#line 913
      if (index64[(unsigned int )digit4] == -1) {
#line 914
        return (-1);
      }
    }
#line 916
    in += 4;
#line 919
    tmp = out;
#line 919
    out ++;
#line 919
    *tmp = (char )((index64[(unsigned int )digit1] << 2) | (index64[(unsigned int )digit2] >> 4));
#line 920
    len ++;
#line 921
    if ((int )digit3 != 61) {
#line 922
      tmp___0 = out;
#line 922
      out ++;
#line 922
      *tmp___0 = (char )(((index64[(unsigned int )digit2] << 4) & 240) | (index64[(unsigned int )digit3] >> 2));
#line 923
      len ++;
#line 924
      if ((int )digit4 != 61) {
#line 925
        tmp___1 = out;
#line 925
        out ++;
#line 925
        *tmp___1 = (char )(((index64[(unsigned int )digit3] << 6) & 192) | index64[(unsigned int )digit4]);
#line 926
        len ++;
      }
    }
#line 899
    if (*in) {
#line 899
      if (! ((int )digit4 != 61)) {
#line 899
        goto while_break;
      }
    } else {
#line 899
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 931
  return (len);
}
}
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 156
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 379 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 671
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) gai_strerror)(int __ecode ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/socket.c"
int so_resolv(struct in_addr *host , char const   *name ) 
{ 
  struct addrinfo hints ;
  struct addrinfo *res ;
  struct addrinfo *p ;
  int rc ;
  int tmp ;
  char const   *tmp___0 ;
  int addr_set ;
  struct sockaddr_in *ad ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 56
  memset((void *)(& hints), 0, sizeof(hints));
#line 57
  hints.ai_family = 2;
#line 58
  hints.ai_socktype = 1;
#line 59
  tmp = getaddrinfo((char const   */* __restrict  */)name, (char const   */* __restrict  */)((void *)0),
                    (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& res));
#line 59
  rc = tmp;
  }
#line 60
  if (rc != 0) {
#line 61
    if (debug) {
      {
#line 62
      tmp___0 = gai_strerror(rc);
#line 62
      printf((char const   */* __restrict  */)"so_resolv: %s failed: %s (%d)\n", name,
             tmp___0, rc);
      }
    }
#line 63
    return (0);
  }
#line 66
  if (debug) {
    {
#line 67
    printf((char const   */* __restrict  */)"Resolve %s:\n", name);
    }
  }
#line 68
  addr_set = 0;
#line 69
  p = res;
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 69
      goto while_break;
    }
#line 70
    ad = (struct sockaddr_in *)p->ai_addr;
#line 71
    if ((unsigned long )ad == (unsigned long )((void *)0)) {
      {
#line 72
      freeaddrinfo(res);
      }
#line 73
      return (0);
    }
#line 75
    if (! addr_set) {
      {
#line 76
      memcpy((void */* __restrict  */)host, (void const   */* __restrict  */)(& ad->sin_addr),
             sizeof(ad->sin_addr));
#line 77
      addr_set = 1;
      }
#line 78
      if (debug) {
        {
#line 79
        tmp___1 = inet_ntoa(ad->sin_addr);
#line 79
        printf((char const   */* __restrict  */)"  -> %s\n", tmp___1);
        }
      }
    } else
#line 81
    if (debug) {
      {
#line 82
      tmp___2 = inet_ntoa(ad->sin_addr);
#line 82
      printf((char const   */* __restrict  */)"     %s\n", tmp___2);
      }
    }
#line 69
    p = p->ai_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 85
  freeaddrinfo(res);
  }
#line 87
  return (1);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/socket.c"
int so_connect(struct in_addr host , int port ) 
{ 
  int flags ;
  int fd ;
  int rc ;
  struct sockaddr_in saddr ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
  {
#line 101
  fd = socket(2, 1, 0);
  }
#line 101
  if (fd < 0) {
#line 102
    if (debug) {
      {
#line 103
      tmp = __errno_location();
#line 103
      tmp___0 = strerror(*tmp);
#line 103
      printf((char const   */* __restrict  */)"so_connect: create: %s\n", tmp___0);
      }
    }
#line 104
    return (-1);
  }
  {
#line 107
  memset((void *)(& saddr), 0, sizeof(saddr));
#line 108
  saddr.sin_family = (sa_family_t )2;
#line 109
  saddr.sin_port = htons((uint16_t )port);
#line 110
  saddr.sin_addr = host;
#line 112
  flags = fcntl(fd, 3, 0);
  }
#line 112
  if (flags < 0) {
#line 113
    if (debug) {
      {
#line 114
      tmp___1 = __errno_location();
#line 114
      tmp___2 = strerror(*tmp___1);
#line 114
      printf((char const   */* __restrict  */)"so_connect: get flags: %s\n", tmp___2);
      }
    }
    {
#line 115
    close(fd);
    }
#line 116
    return (-1);
  }
  {
#line 128
  rc = connect(fd, (struct sockaddr  const  *)((struct sockaddr *)(& saddr)), (socklen_t )sizeof(saddr));
  }
#line 143
  if (rc < 0) {
#line 144
    if (debug) {
      {
#line 145
      tmp___3 = __errno_location();
#line 145
      tmp___4 = strerror(*tmp___3);
#line 145
      printf((char const   */* __restrict  */)"so_connect: %s\n", tmp___4);
      }
    }
    {
#line 146
    close(fd);
    }
#line 147
    return (-1);
  }
  {
#line 150
  tmp___7 = fcntl(fd, 4, flags & -2049);
  }
#line 150
  if (tmp___7 < 0) {
#line 151
    if (debug) {
      {
#line 152
      tmp___5 = __errno_location();
#line 152
      tmp___6 = strerror(*tmp___5);
#line 152
      printf((char const   */* __restrict  */)"so_connect: set blocking: %s\n", tmp___6);
      }
    }
    {
#line 153
    close(fd);
    }
#line 154
    return (-1);
  }
#line 157
  return (fd);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/socket.c"
int so_listen(int port , struct in_addr source ) 
{ 
  struct sockaddr_in saddr ;
  int fd ;
  socklen_t clen ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 169
  fd = socket(2, 1, 0);
  }
#line 170
  if (fd < 0) {
#line 171
    if (debug) {
      {
#line 172
      tmp = __errno_location();
#line 172
      tmp___0 = strerror(*tmp);
#line 172
      printf((char const   */* __restrict  */)"so_listen: new socket: %s\n", tmp___0);
      }
    }
    {
#line 173
    close(fd);
    }
#line 174
    return (-1);
  }
  {
#line 177
  clen = (socklen_t )1;
#line 178
  setsockopt(fd, 1, 2, (void const   *)(& clen), (socklen_t )sizeof(clen));
#line 179
  memset((void *)(& saddr), 0, sizeof(saddr));
#line 180
  saddr.sin_family = (sa_family_t )2;
#line 181
  saddr.sin_port = htons((uint16_t )port);
#line 182
  saddr.sin_addr.s_addr = source.s_addr;
#line 184
  tmp___3 = bind(fd, (struct sockaddr  const  *)((struct sockaddr *)(& saddr)), (socklen_t )sizeof(saddr));
  }
#line 184
  if (tmp___3) {
    {
#line 185
    tmp___1 = __errno_location();
#line 185
    tmp___2 = strerror(*tmp___1);
#line 185
    syslog(3, "Cannot bind port %d: %s!\n", port, tmp___2);
#line 186
    close(fd);
    }
#line 187
    return (-1);
  }
  {
#line 190
  tmp___4 = listen(fd, 5);
  }
#line 190
  if (tmp___4) {
    {
#line 191
    close(fd);
    }
#line 192
    return (-1);
  }
#line 195
  return (fd);
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/socket.c"
int so_recvtest(int fd ) 
{ 
  char buf ;
  int i ;
  ssize_t tmp ;

  {
  {
#line 214
  tmp = recv(fd, (void *)(& buf), (size_t )1, 66);
#line 214
  i = (int )tmp;
  }
#line 217
  return (i);
}
}
#line 223 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/socket.c"
int so_dataready(int fd ) 
{ 
  int tmp ;

  {
  {
#line 224
  tmp = so_recvtest(fd);
  }
#line 224
  return (tmp > 0);
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/socket.c"
int so_closed(int fd ) 
{ 
  int i ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 234
  if (fd == -1) {
#line 235
    return (1);
  }
  {
#line 237
  i = so_recvtest(fd);
  }
#line 238
  if (i == 0) {
#line 238
    tmp___1 = 1;
  } else
#line 238
  if (i == -1) {
    {
#line 238
    tmp = __errno_location();
    }
#line 238
    if (*tmp != 11) {
      {
#line 238
      tmp___0 = __errno_location();
      }
#line 238
      if (*tmp___0 != 2) {
#line 238
        tmp___1 = 1;
      } else {
#line 238
        tmp___1 = 0;
      }
    } else {
#line 238
      tmp___1 = 0;
    }
  } else {
#line 238
    tmp___1 = 0;
  }
#line 238
  return (tmp___1);
}
}
#line 252 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/socket.c"
int so_recvln(int fd , char **buf , int *size ) 
{ 
  int len ;
  int r ;
  char c ;
  char *tmp ;
  ssize_t tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 253
  len = 0;
#line 254
  r = 1;
#line 255
  c = (char)0;
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    if (len < *size - 1) {
#line 258
      if (! ((int )c != 10)) {
#line 258
        goto while_break;
      }
    } else {
#line 258
      goto while_break;
    }
    {
#line 259
    tmp___0 = read(fd, (void *)(& c), (size_t )1);
#line 259
    r = (int )tmp___0;
    }
#line 260
    if (r <= 0) {
#line 261
      goto while_break;
    }
#line 263
    tmp___1 = len;
#line 263
    len ++;
#line 263
    *(*buf + tmp___1) = c;
#line 268
    if (len == *size - 1) {
#line 268
      if ((int )c != 10) {
#line 269
        if (debug) {
          {
#line 270
          printf((char const   */* __restrict  */)"so_recvln(%d): realloc %d\n", fd,
                 *size * 2);
          }
        }
        {
#line 271
        *size *= 2;
#line 272
        tmp___2 = realloc((void *)*buf, (size_t )*size);
#line 272
        tmp = (char *)tmp___2;
        }
#line 273
        if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 274
          return (-1);
        } else {
#line 276
          *buf = tmp;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 279
  *(*buf + len) = (char)0;
#line 281
  return (r);
}
}
#line 538 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 157 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1), __leaf__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/http.c"
int is_http_header(char const   *src ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 48
  tmp = strcspn(src, ":");
#line 48
  tmp___0 = strlen(src);
  }
#line 48
  return (tmp != tmp___0);
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/http.c"
char *get_http_header_name(char const   *src ) 
{ 
  int i ;
  size_t tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 57
  tmp = strcspn(src, ":");
#line 57
  i = (int )tmp;
#line 58
  tmp___1 = strlen(src);
  }
#line 58
  if ((size_t )i != tmp___1) {
    {
#line 59
    tmp___0 = substr(src, 0, i);
    }
#line 59
    return (tmp___0);
  } else {
#line 61
    return ((char *)((void *)0));
  }
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/http.c"
char *get_http_header_value(char const   *src ) 
{ 
  char *sub ;
  char *tmp ;

  {
  {
#line 70
  sub = strchr(src, ':');
  }
#line 70
  if (sub) {
#line 71
    sub ++;
    {
#line 72
    while (1) {
      while_continue: /* CIL Label */ ;
#line 72
      if (! ((int )*sub == 32)) {
#line 72
        goto while_break;
      }
#line 73
      sub ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 75
    tmp = strdup((char const   *)sub);
    }
#line 75
    return (tmp);
  } else {
#line 77
    return ((char *)((void *)0));
  }
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/http.c"
int headers_recv(int fd , rr_data_t data ) 
{ 
  int i ;
  int bsize ;
  int len ;
  int is_http ;
  char *buf ;
  char *tok ;
  char *s3 ;
  char *orig ;
  char *ccode ;
  char *host ;
  size_t tmp ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  unsigned short const   **tmp___9 ;
  unsigned short const   **tmp___10 ;
  size_t tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  size_t tmp___19 ;
  char *tmp___20 ;
  size_t tmp___21 ;
  int tmp___22 ;
  size_t tmp___23 ;

  {
  {
#line 87
  is_http = 0;
#line 89
  s3 = (char *)0;
#line 90
  orig = (char *)((void *)0);
#line 91
  ccode = (char *)((void *)0);
#line 92
  host = (char *)((void *)0);
#line 94
  bsize = 4096;
#line 95
  buf = new((size_t )bsize);
#line 97
  i = so_recvln(fd, & buf, & bsize);
  }
#line 98
  if (i <= 0) {
#line 99
    goto bailout;
  }
#line 101
  if (debug) {
    {
#line 102
    printf((char const   */* __restrict  */)"HEAD: %s", buf);
    }
  }
  {
#line 107
  trimr(buf);
#line 108
  orig = strdup((char const   *)buf);
#line 109
  tmp = strlen((char const   *)buf);
#line 109
  len = (int )tmp;
#line 110
  tok = strtok_r((char */* __restrict  */)buf, (char const   */* __restrict  */)" ",
                 (char **/* __restrict  */)(& s3));
  }
#line 111
  if (tok) {
    {
#line 111
    tmp___13 = strncasecmp((char const   *)tok, "HTTP/", (size_t )5);
    }
#line 111
    if (tmp___13) {
#line 111
      tmp___14 = 0;
    } else {
#line 111
      tmp___14 = 1;
    }
#line 111
    is_http = tmp___14;
#line 111
    if (is_http) {
#line 111
      goto _L___1;
    } else {
      {
#line 111
      tmp___15 = strncasecmp((char const   *)tok, "ICY", (size_t )3);
      }
#line 111
      if (tmp___15) {
#line 111
        goto _L___0;
      } else {
        _L___1: /* CIL Label */ 
        {
#line 112
        data->req = 0;
#line 113
        data->empty = 0;
#line 114
        data->http = strdup((char const   *)tok);
#line 115
        data->msg = (char *)((void *)0);
        }
#line 121
        if (is_http) {
          {
#line 121
          tok = strchr((char const   *)data->http, '/');
          }
#line 121
          if (tok) {
            {
#line 121
            tmp___0 = strlen((char const   *)tok);
            }
#line 121
            if (tmp___0 >= 4UL) {
              {
#line 121
              tmp___1 = __ctype_b_loc();
              }
#line 121
              if ((int const   )*(*tmp___1 + (int )*(tok + 1)) & 2048) {
                {
#line 121
                tmp___2 = __ctype_b_loc();
                }
#line 121
                if ((int const   )*(*tmp___2 + (int )*(tok + 3)) & 2048) {
#line 122
                  data->http_version = ((int )*(tok + 1) - 48) * 10 + ((int )*(tok + 3) - 48);
                } else {
#line 124
                  data->http_version = -1;
                }
              } else {
#line 124
                data->http_version = -1;
              }
            } else {
#line 124
              data->http_version = -1;
            }
          } else {
#line 124
            data->http_version = -1;
          }
        } else {
#line 124
          data->http_version = -1;
        }
        {
#line 127
        tok = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ",
                       (char **/* __restrict  */)(& s3));
        }
#line 128
        if (tok) {
          {
#line 129
          ccode = strdup((char const   *)tok);
#line 131
          tmp___3 = strlen((char const   *)ccode);
#line 131
          tok += tmp___3;
          }
          {
#line 132
          while (1) {
            while_continue: /* CIL Label */ ;
#line 132
            if ((unsigned long )tok < (unsigned long )(buf + len)) {
#line 132
              tmp___4 = tok;
#line 132
              tok ++;
#line 132
              if (! ((int )*tmp___4 == 32)) {
#line 132
                goto while_break;
              }
            } else {
#line 132
              goto while_break;
            }
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 134
          tmp___5 = strlen((char const   *)tok);
          }
#line 134
          if (tmp___5) {
            {
#line 135
            data->msg = strdup((char const   *)tok);
            }
          }
        }
#line 138
        if (! data->msg) {
          {
#line 139
          data->msg = strdup("");
          }
        }
#line 141
        if (! ccode) {
#line 142
          i = -2;
#line 143
          goto bailout;
        } else {
          {
#line 141
          tmp___6 = strlen((char const   *)ccode);
          }
#line 141
          if (tmp___6 != 3UL) {
#line 142
            i = -2;
#line 143
            goto bailout;
          } else {
            {
#line 141
            tmp___7 = atoi((char const   *)ccode);
#line 141
            data->code = tmp___7;
            }
#line 141
            if (tmp___7 == 0) {
#line 142
              i = -2;
#line 143
              goto bailout;
            }
          }
        }
      }
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 145
    tmp___12 = strstr((char const   *)orig, " HTTP/");
    }
#line 145
    if (tmp___12) {
#line 145
      if (tok) {
        {
#line 146
        data->req = 1;
#line 147
        data->empty = 0;
#line 148
        data->method = (char *)((void *)0);
#line 149
        data->url = (char *)((void *)0);
#line 150
        data->rel_url = (char *)((void *)0);
#line 151
        data->http = (char *)((void *)0);
#line 152
        data->hostname = (char *)((void *)0);
#line 154
        data->method = strdup((char const   *)tok);
#line 156
        tok = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ",
                       (char **/* __restrict  */)(& s3));
        }
#line 157
        if (tok) {
          {
#line 158
          data->url = strdup((char const   *)tok);
          }
        }
        {
#line 160
        tok = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ",
                       (char **/* __restrict  */)(& s3));
        }
#line 161
        if (tok) {
          {
#line 162
          data->http = strdup((char const   *)tok);
          }
        }
#line 164
        if (! data->url) {
#line 165
          i = -3;
#line 166
          goto bailout;
        } else
#line 164
        if (! data->http) {
#line 165
          i = -3;
#line 166
          goto bailout;
        }
        {
#line 173
        tok = strchr((char const   *)data->http, '/');
        }
#line 173
        if (tok) {
          {
#line 173
          tmp___8 = strlen((char const   *)tok);
          }
#line 173
          if (tmp___8 >= 4UL) {
            {
#line 173
            tmp___9 = __ctype_b_loc();
            }
#line 173
            if ((int const   )*(*tmp___9 + (int )*(tok + 1)) & 2048) {
              {
#line 173
              tmp___10 = __ctype_b_loc();
              }
#line 173
              if ((int const   )*(*tmp___10 + (int )*(tok + 3)) & 2048) {
#line 174
                data->http_version = ((int )*(tok + 1) - 48) * 10 + ((int )*(tok + 3) - 48);
              } else {
#line 176
                data->http_version = -1;
              }
            } else {
#line 176
              data->http_version = -1;
            }
          } else {
#line 176
            data->http_version = -1;
          }
        } else {
#line 176
          data->http_version = -1;
        }
        {
#line 179
        tok = strstr((char const   *)data->url, "://");
        }
#line 179
        if (tok) {
#line 180
          tok += 3;
        } else {
#line 182
          tok = data->url;
        }
        {
#line 185
        s3 = strchr((char const   *)tok, '/');
        }
#line 186
        if (s3) {
          {
#line 187
          host = substr((char const   *)tok, 0, (int )(s3 - tok));
#line 188
          data->rel_url = strdup((char const   *)s3);
          }
        } else {
          {
#line 190
          tmp___11 = strlen((char const   *)tok);
#line 190
          host = substr((char const   *)tok, 0, (int )tmp___11);
#line 191
          data->rel_url = strdup("/");
          }
        }
      } else {
#line 145
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 195
      if (debug) {
        {
#line 196
        printf((char const   */* __restrict  */)"headers_recv: Unknown header (%s).\n",
               orig);
        }
      }
#line 197
      i = -4;
#line 198
      goto bailout;
    }
  }
  {
#line 204
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 205
    i = so_recvln(fd, & buf, & bsize);
#line 206
    trimr(buf);
    }
#line 207
    if (i > 0) {
      {
#line 207
      tmp___18 = is_http_header((char const   *)buf);
      }
#line 207
      if (tmp___18) {
        {
#line 208
        tmp___16 = get_http_header_value((char const   *)buf);
#line 208
        tmp___17 = get_http_header_name((char const   *)buf);
#line 208
        data->headers = hlist_add(data->headers, tmp___17, tmp___16, (hlist_add_t )0,
                                  (hlist_add_t )0);
        }
      }
    }
    {
#line 204
    tmp___19 = strlen((char const   *)buf);
    }
#line 204
    if (tmp___19 != 0UL) {
#line 204
      if (! (i > 0)) {
#line 204
        goto while_break___0;
      }
    } else {
#line 204
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 212
  if (data->req) {
#line 216
    if (host) {
      {
#line 216
      tmp___21 = strlen((char const   *)host);
      }
#line 216
      if (tmp___21) {
        {
#line 217
        data->hostname = strdup((char const   *)host);
#line 218
        tmp___20 = hlist_get(data->headers, "Host");
        }
#line 218
        if (! tmp___20) {
          {
#line 219
          data->headers = hlist_add(data->headers, (char *)"Host", host, (hlist_add_t )1,
                                    (hlist_add_t )1);
          }
        }
      } else {
#line 216
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
#line 221
      if (debug) {
        {
#line 222
        printf((char const   */* __restrict  */)"headers_recv: no host name (%s)\n",
               orig);
        }
      }
#line 223
      i = -6;
#line 224
      goto bailout;
    }
#line 230
    if (data->hostname) {
      {
#line 230
      tok = strchr((char const   *)data->hostname, ':');
      }
#line 230
      if (tok) {
        {
#line 231
        *tok = (char)0;
#line 232
        data->port = atoi((char const   *)(tok + 1));
        }
      } else {
#line 230
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 233
    if (data->url) {
      {
#line 234
      tmp___22 = strncasecmp((char const   *)data->url, "https", (size_t )5);
      }
#line 234
      if (tmp___22) {
#line 237
        data->port = 80;
      } else {
#line 235
        data->port = 443;
      }
    }
    {
#line 240
    tmp___23 = strlen((char const   *)data->hostname);
    }
#line 240
    if (tmp___23) {
#line 240
      if (! data->port) {
#line 241
        i = -5;
#line 242
        goto bailout;
      }
    } else {
#line 241
      i = -5;
#line 242
      goto bailout;
    }
  }
  bailout: 
#line 247
  if (orig) {
    {
#line 247
    free((void *)orig);
    }
  }
#line 248
  if (ccode) {
    {
#line 248
    free((void *)ccode);
    }
  }
#line 249
  if (host) {
    {
#line 249
    free((void *)host);
    }
  }
  {
#line 250
  free((void *)buf);
  }
#line 252
  if (i <= 0) {
#line 253
    if (debug) {
      {
#line 254
      printf((char const   */* __restrict  */)"headers_recv: fd %d error %d\n", fd,
             i);
      }
    }
#line 255
    return (0);
  }
#line 258
  return (1);
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/http.c"
int headers_send(int fd , rr_data_t data ) 
{ 
  hlist_t t ;
  char *buf ;
  int i ;
  int len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  ssize_t tmp___7 ;
  int tmp___8 ;

  {
#line 273
  if (data->req) {
    {
#line 274
    tmp = strlen((char const   *)data->method);
#line 274
    tmp___0 = strlen((char const   *)data->url);
#line 274
    tmp___1 = strlen((char const   *)data->http);
#line 274
    len = (int )(((20UL + tmp) + tmp___0) + tmp___1);
    }
  } else {
    {
#line 276
    tmp___2 = strlen((char const   *)data->http);
#line 276
    tmp___3 = strlen((char const   *)data->msg);
#line 276
    len = (int )((20UL + tmp___2) + tmp___3);
    }
  }
#line 278
  t = data->headers;
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
#line 279
    if (! t) {
#line 279
      goto while_break;
    }
    {
#line 280
    tmp___4 = strlen((char const   *)t->key);
#line 280
    tmp___5 = strlen((char const   *)t->value);
#line 280
    len = (int )((size_t )len + ((20UL + tmp___4) + tmp___5));
#line 281
    t = t->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 287
  buf = new((size_t )len);
#line 292
  len = 0;
  }
#line 293
  if (data->req) {
    {
#line 294
    len = sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"%s %s %s\r\n",
                  data->method, data->url, data->http);
    }
  } else
#line 295
  if (! data->skip_http) {
    {
#line 296
    len = sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"%s %03d %s\r\n",
                  data->http, data->code, data->msg);
    }
  }
#line 301
  t = data->headers;
  {
#line 302
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 302
    if (! t) {
#line 302
      goto while_break___0;
    }
    {
#line 303
    tmp___6 = sprintf((char */* __restrict  */)(buf + len), (char const   */* __restrict  */)"%s: %s\r\n",
                      t->key, t->value);
#line 303
    len += tmp___6;
#line 304
    t = t->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 310
  strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)"\r\n");
#line 315
  tmp___8 = so_closed(fd);
  }
#line 315
  if (tmp___8) {
#line 318
    i = -999;
  } else {
    {
#line 316
    tmp___7 = write(fd, (void const   *)buf, (size_t )(len + 2));
#line 316
    i = (int )tmp___7;
    }
  }
  {
#line 320
  free((void *)buf);
  }
#line 322
  if (i <= 0) {
#line 322
    goto _L;
  } else
#line 322
  if (i != len + 2) {
    _L: /* CIL Label */ 
#line 323
    if (debug) {
      {
#line 324
      printf((char const   */* __restrict  */)"headers_send: fd %d warning %d (connection closed)\n",
             fd, i);
      }
    }
#line 325
    return (0);
  }
#line 328
  return (1);
}
}
#line 336 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/http.c"
int data_send(int dst , int src , length_t len ) 
{ 
  char *buf ;
  int i ;
  int block ;
  int c ;
  int j ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;

  {
#line 339
  c = 0;
#line 340
  j = 1;
#line 342
  if (! len) {
#line 343
    return (1);
  }
  {
#line 345
  buf = new((size_t )2048);
  }
  {
#line 347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 348
    if (len == -1LL) {
#line 348
      block = 2048;
    } else
#line 348
    if (len - (length_t )c > 2048LL) {
#line 348
      block = 2048;
    } else {
#line 348
      block = (int )(len - (length_t )c);
    }
    {
#line 349
    tmp = read(src, (void *)buf, (size_t )block);
#line 349
    i = (int )tmp;
    }
#line 351
    if (i > 0) {
#line 352
      c += i;
    }
#line 354
    if (dst >= 0) {
#line 354
      if (debug) {
#line 355
        if (i < 0) {
          {
#line 355
          tmp___0 = __errno_location();
#line 355
          tmp___1 = strerror(*tmp___0);
#line 355
          tmp___2 = (char const   *)tmp___1;
          }
        } else {
#line 355
          tmp___2 = "ok";
        }
        {
#line 355
        printf((char const   */* __restrict  */)"data_send: read %d of %d / %d of %lld (errno = %s)\n",
               i, block, c, len, tmp___2);
        }
      }
    }
#line 357
    if (dst >= 0) {
      {
#line 357
      tmp___3 = so_closed(dst);
      }
#line 357
      if (tmp___3) {
#line 358
        i = -999;
#line 359
        goto while_break;
      }
    }
#line 362
    if (dst >= 0) {
#line 362
      if (i > 0) {
        {
#line 363
        tmp___4 = write(dst, (void const   *)buf, (size_t )i);
#line 363
        j = (int )tmp___4;
        }
#line 364
        if (debug) {
          {
#line 365
          printf((char const   */* __restrict  */)"data_send: wrote %d of %d\n", j,
                 i);
          }
        }
      }
    }
#line 347
    if (i > 0) {
#line 347
      if (j > 0) {
#line 347
        if (! (len == -1LL)) {
#line 347
          if (! ((length_t )c < len)) {
#line 347
            goto while_break;
          }
        }
      } else {
#line 347
        goto while_break;
      }
    } else {
#line 347
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 370
  free((void *)buf);
  }
#line 372
  if (i <= 0) {
#line 372
    goto _L;
  } else
#line 372
  if (j <= 0) {
    _L: /* CIL Label */ 
#line 373
    if (i == 0) {
#line 373
      if (j > 0) {
#line 373
        if (len == -1LL) {
#line 374
          return (1);
        } else
#line 373
        if ((length_t )c == len) {
#line 374
          return (1);
        }
      }
    }
#line 376
    if (debug) {
      {
#line 377
      printf((char const   */* __restrict  */)"data_send: fds %d:%d warning %d (connection closed)\n",
             dst, src, i);
      }
    }
#line 378
    return (0);
  }
#line 381
  return (1);
}
}
#line 388 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/http.c"
int chunked_data_send(int dst , int src ) 
{ 
  char *buf ;
  int bsize ;
  int i ;
  int w ;
  int csize ;
  char *err ;
  long tmp ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  ssize_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  ssize_t tmp___5 ;

  {
  {
#line 393
  err = (char *)((void *)0);
#line 395
  bsize = 4096;
#line 396
  buf = new((size_t )bsize);
  }
  {
#line 399
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 400
    i = so_recvln(src, & buf, & bsize);
    }
#line 401
    if (i <= 0) {
#line 402
      if (debug) {
        {
#line 403
        printf((char const   */* __restrict  */)"chunked_data_send: aborting, read error\n");
        }
      }
      {
#line 404
      free((void *)buf);
      }
#line 405
      return (0);
    }
    {
#line 408
    tmp = strtol((char const   */* __restrict  */)buf, (char **/* __restrict  */)(& err),
                 16);
#line 408
    csize = (int )tmp;
#line 410
    tmp___0 = __ctype_b_loc();
    }
#line 410
    if (! ((int const   )*(*tmp___0 + (int )*err) & 8192)) {
#line 410
      if ((int )*err != 59) {
#line 411
        if (debug) {
          {
#line 412
          printf((char const   */* __restrict  */)"chunked_data_send: aborting, chunk size format error\n");
          }
        }
        {
#line 413
        free((void *)buf);
        }
#line 414
        return (0);
      }
    }
#line 417
    if (dst >= 0) {
      {
#line 418
      tmp___1 = strlen((char const   *)buf);
#line 418
      tmp___2 = write(dst, (void const   *)buf, tmp___1);
#line 418
      i = (int )tmp___2;
      }
    }
#line 420
    if (csize) {
      {
#line 421
      tmp___3 = data_send(dst, src, (length_t )(csize + 2));
      }
#line 421
      if (! tmp___3) {
#line 422
        if (debug) {
          {
#line 423
          printf((char const   */* __restrict  */)"chunked_data_send: aborting, data_send failed\n");
          }
        }
        {
#line 425
        free((void *)buf);
        }
#line 426
        return (0);
      }
    }
#line 399
    if (! (csize != 0)) {
#line 399
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 431
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 432
    i = so_recvln(src, & buf, & bsize);
    }
#line 433
    if (dst >= 0) {
#line 433
      if (i > 0) {
        {
#line 434
        tmp___4 = strlen((char const   *)buf);
#line 434
        tmp___5 = write(dst, (void const   *)buf, tmp___4);
#line 434
        w = (int )tmp___5;
        }
      }
    }
#line 431
    if (i > 0) {
#line 431
      if ((int )*(buf + 0) != 13) {
#line 431
        if (! ((int )*(buf + 0) != 10)) {
#line 431
          goto while_break___0;
        }
      } else {
#line 431
        goto while_break___0;
      }
    } else {
#line 431
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 437
  free((void *)buf);
  }
#line 438
  return (1);
}
}
#line 445 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/http.c"
int tunnel(int cd , int sd ) 
{ 
  fd_set set ;
  int from ;
  int to ;
  int ret ;
  int sel ;
  char *buf ;
  int __d0 ;
  int __d1 ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 450
  buf = new((size_t )4096);
  }
#line 452
  if (debug) {
    {
#line 453
    printf((char const   */* __restrict  */)"tunnel: select cli: %d, srv: %d\n", cd,
           sd);
    }
  }
  {
#line 455
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 456
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 456
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& set.fds_bits[0]): "memory");
#line 456
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 457
    set.fds_bits[cd / (8 * (int )sizeof(__fd_mask ))] |= 1L << cd % (8 * (int )sizeof(__fd_mask ));
#line 458
    set.fds_bits[sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << sd % (8 * (int )sizeof(__fd_mask ));
#line 460
    sel = select(1024, (fd_set */* __restrict  */)(& set), (fd_set */* __restrict  */)((void *)0),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
    }
#line 461
    if (sel > 0) {
#line 462
      if ((set.fds_bits[cd / (8 * (int )sizeof(__fd_mask ))] & (1L << cd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 463
        from = cd;
#line 464
        to = sd;
      } else {
#line 466
        from = sd;
#line 467
        to = cd;
      }
      {
#line 470
      tmp = read(from, (void *)buf, (size_t )4096);
#line 470
      ret = (int )tmp;
      }
#line 471
      if (ret > 0) {
        {
#line 472
        tmp___0 = write(to, (void const   *)buf, (size_t )ret);
#line 472
        ret = (int )tmp___0;
        }
      } else {
        {
#line 474
        free((void *)buf);
        }
#line 475
        return (ret == 0);
      }
    } else
#line 477
    if (sel < 0) {
      {
#line 478
      free((void *)buf);
      }
#line 479
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 483
  free((void *)buf);
  }
#line 484
  return (1);
}
}
#line 491 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/http.c"
length_t http_has_body(rr_data_t request , rr_data_t response ) 
{ 
  rr_data_t current ;
  length_t length ;
  int nobody ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  long long tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 501
  if (! response) {
#line 501
    current = request;
  } else
#line 501
  if (response->empty) {
#line 501
    current = request;
  } else {
#line 501
    current = response;
  }
#line 508
  if ((unsigned long )current == (unsigned long )response) {
#line 509
    if (request) {
#line 509
      if (request->req) {
        {
#line 509
        tmp___0 = strcasecmp("HEAD", (char const   *)request->method);
        }
#line 509
        if (tmp___0) {
#line 509
          goto _L___1;
        } else {
#line 509
          tmp___1 = 1;
        }
      } else {
#line 509
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 509
    if (response->code >= 100) {
#line 509
      if (response->code < 200) {
#line 509
        tmp___1 = 1;
      } else {
#line 509
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 509
    if (response->code == 204) {
#line 509
      tmp___1 = 1;
    } else
#line 509
    if (response->code == 304) {
#line 509
      tmp___1 = 1;
    } else {
#line 509
      tmp___1 = 0;
    }
#line 509
    nobody = tmp___1;
  } else {
#line 514
    if (request) {
#line 514
      if (request->req) {
        {
#line 514
        tmp___2 = strcasecmp("GET", (char const   *)request->method);
        }
#line 514
        if (tmp___2) {
#line 514
          goto _L___3;
        } else {
#line 514
          tmp___4 = 1;
        }
      } else {
#line 514
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 514
    if (request) {
#line 514
      if (request->req) {
        {
#line 514
        tmp___3 = strcasecmp("HEAD", (char const   *)request->method);
        }
#line 514
        if (tmp___3) {
#line 514
          tmp___4 = 0;
        } else {
#line 514
          tmp___4 = 1;
        }
      } else {
#line 514
        tmp___4 = 0;
      }
    } else {
#line 514
      tmp___4 = 0;
    }
#line 514
    nobody = tmp___4;
  }
  {
#line 527
  tmp = hlist_get(current->headers, "Content-Length");
  }
#line 528
  if (! nobody) {
#line 528
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      {
#line 528
      tmp___8 = hlist_in(current->headers, "Content-Type");
      }
#line 528
      if (tmp___8) {
#line 528
        goto _L___5;
      } else {
        {
#line 528
        tmp___9 = hlist_in(current->headers, "Transfer-Encoding");
        }
#line 528
        if (tmp___9) {
#line 528
          goto _L___5;
        } else {
          {
#line 528
          tmp___10 = hlist_subcmp(current->headers, "Connection", "close");
          }
#line 528
          if (tmp___10) {
            _L___5: /* CIL Label */ 
            {
#line 532
            tmp___5 = hlist_in(current->headers, "Transfer-Encoding");
            }
#line 532
            if (tmp___5) {
              {
#line 532
              tmp___6 = hlist_subcmp(current->headers, "Transfer-Encoding", "chunked");
              }
#line 532
              if (tmp___6) {
#line 534
                length = (length_t )1;
              } else {
#line 536
                length = (length_t )-1;
              }
            } else {
#line 536
              length = (length_t )-1;
            }
          } else {
#line 528
            goto _L___6;
          }
        }
      }
    } else {
#line 528
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
#line 538
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 538
    length = (length_t )0;
  } else
#line 538
  if (nobody) {
#line 538
    length = (length_t )0;
  } else {
    {
#line 538
    tmp___7 = atoll((char const   *)tmp);
#line 538
    length = tmp___7;
    }
  }
#line 540
  if ((unsigned long )current == (unsigned long )request) {
#line 540
    if (length == -1LL) {
#line 541
      length = (length_t )0;
    }
  }
#line 543
  return (length);
}
}
#line 549 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/http.c"
int http_body_send(int writefd , int readfd , rr_data_t request , rr_data_t response ) 
{ 
  length_t bodylen ;
  int rc ;
  rr_data_t current ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 551
  rc = 1;
#line 558
  if (response->empty) {
#line 558
    current = request;
  } else {
#line 558
    current = response;
  }
  {
#line 563
  bodylen = http_has_body(request, response);
  }
#line 564
  if (bodylen) {
    {
#line 568
    tmp___1 = hlist_subcmp(current->headers, "Transfer-Encoding", "chunked");
    }
#line 568
    if (tmp___1) {
#line 569
      if (debug) {
        {
#line 570
        printf((char const   */* __restrict  */)"Chunked body included.\n");
        }
      }
      {
#line 572
      rc = chunked_data_send(writefd, readfd);
      }
#line 573
      if (debug) {
#line 574
        if (rc) {
#line 574
          tmp = "Chunked body sent.\n";
        } else {
#line 574
          tmp = "Could not chunk send whole body\n";
        }
        {
#line 574
        printf((char const   */* __restrict  */)tmp);
        }
      }
    } else {
#line 576
      if (debug) {
        {
#line 577
        printf((char const   */* __restrict  */)"Body included. Length: %lld\n", bodylen);
        }
      }
      {
#line 579
      rc = data_send(writefd, readfd, bodylen);
      }
#line 580
      if (debug) {
#line 581
        if (rc) {
#line 581
          tmp___0 = "Body sent.\n";
        } else {
#line 581
          tmp___0 = "Could not send whole body\n";
        }
        {
#line 581
        printf((char const   */* __restrict  */)tmp___0);
        }
      }
    }
  } else
#line 583
  if (debug) {
    {
#line 584
    printf((char const   */* __restrict  */)"No body.\n");
    }
  }
#line 586
  return (rc);
}
}
#line 593 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/http.c"
int http_body_drop(int fd , rr_data_t response ) 
{ 
  length_t bodylen ;
  int rc ;
  int tmp ;

  {
  {
#line 595
  rc = 1;
#line 597
  bodylen = http_has_body((rr_data_t )((void *)0), response);
  }
#line 598
  if (bodylen) {
    {
#line 599
    tmp = hlist_subcmp(response->headers, "Transfer-Encoding", "chunked");
    }
#line 599
    if (tmp) {
#line 600
      if (debug) {
        {
#line 601
        printf((char const   */* __restrict  */)"Discarding chunked body.\n");
        }
      }
      {
#line 602
      rc = chunked_data_send(-1, fd);
      }
    } else {
#line 604
      if (debug) {
        {
#line 605
        printf((char const   */* __restrict  */)"Discarding %lld bytes.\n", bodylen);
        }
      }
      {
#line 606
      rc = data_send(-1, fd, bodylen);
      }
    }
  }
#line 610
  return (rc);
}
}
#line 618 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/http.c"
int http_parse_basic(hlist_t headers , char const   *header , struct auth_s *tcreds ) 
{ 
  char *tmp ;
  char *pos ;
  char *buf ;
  char *dom ;
  int i ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
  {
#line 619
  tmp = (char *)((void *)0);
#line 619
  pos = (char *)((void *)0);
#line 619
  buf = (char *)((void *)0);
#line 619
  dom = (char *)((void *)0);
#line 622
  tmp___0 = hlist_subcmp(headers, header, "basic");
  }
#line 622
  if (! tmp___0) {
#line 623
    return (0);
  }
  {
#line 625
  tmp = hlist_get(headers, header);
#line 626
  tmp___1 = strlen((char const   *)tmp);
#line 626
  buf = new(tmp___1 + 1UL);
#line 627
  i = 5;
  }
  {
#line 628
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 628
    tmp___2 = strlen((char const   *)tmp);
    }
#line 628
    if ((size_t )i < tmp___2) {
#line 628
      i ++;
#line 628
      if (! ((int )*(tmp + i) == 32)) {
#line 628
        goto while_break;
      }
    } else {
#line 628
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 629
  from_base64(buf, (char const   *)(tmp + i));
#line 630
  pos = strchr((char const   *)buf, ':');
  }
#line 632
  if ((unsigned long )pos == (unsigned long )((void *)0)) {
    {
#line 633
    tmp___3 = strlen((char const   *)buf);
#line 633
    memset((void *)buf, 0, tmp___3);
#line 634
    free((void *)buf);
    }
#line 635
    return (-1);
  } else {
    {
#line 637
    *pos = (char)0;
#line 638
    dom = strchr((char const   *)buf, '\\');
    }
#line 639
    if ((unsigned long )dom == (unsigned long )((void *)0)) {
#line 640
      if (tcreds) {
#line 640
        if (buf) {
          {
#line 640
          strlcpy(tcreds->user, (char const   *)buf, (size_t )50);
          }
        }
      }
    } else {
#line 642
      *dom = (char)0;
#line 643
      if (tcreds) {
#line 643
        if (buf) {
          {
#line 643
          strlcpy(tcreds->domain, (char const   *)buf, (size_t )50);
          }
        }
      }
#line 644
      if (tcreds) {
#line 644
        if (dom + 1) {
          {
#line 644
          strlcpy(tcreds->user, (char const   *)(dom + 1), (size_t )50);
          }
        }
      }
    }
#line 647
    if (tcreds->hashntlm2) {
      {
#line 648
      tmp = ntlm2_hash_password(tcreds->user, tcreds->domain, pos + 1);
      }
#line 649
      if (tcreds) {
#line 649
        if (tmp) {
          {
#line 649
          memcpy((void */* __restrict  */)(tcreds->passntlm2), (void const   */* __restrict  */)tmp,
                 (size_t )16);
          }
        }
      }
      {
#line 650
      free((void *)tmp);
      }
    }
#line 653
    if (tcreds->hashnt) {
      {
#line 654
      tmp = ntlm_hash_nt_password(pos + 1);
      }
#line 655
      if (tcreds) {
#line 655
        if (tmp) {
          {
#line 655
          memcpy((void */* __restrict  */)(tcreds->passnt), (void const   */* __restrict  */)tmp,
                 (size_t )21);
          }
        }
      }
      {
#line 656
      free((void *)tmp);
      }
    }
#line 659
    if (tcreds->hashlm) {
      {
#line 660
      tmp = ntlm_hash_lm_password(pos + 1);
      }
#line 661
      if (tcreds) {
#line 661
        if (tmp) {
          {
#line 661
          memcpy((void */* __restrict  */)(tcreds->passlm), (void const   */* __restrict  */)tmp,
                 (size_t )21);
          }
        }
      }
      {
#line 662
      free((void *)tmp);
      }
    }
    {
#line 665
    tmp___4 = strlen((char const   *)buf);
#line 665
    memset((void *)buf, 0, tmp___4);
#line 666
    free((void *)buf);
    }
  }
#line 669
  return (1);
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/auth.h"
struct auth_s *dup_auth(struct auth_s *creds , int fullcopy ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/direct.c"
int host_connect(char const   *hostname , int port ) 
{ 
  struct in_addr addr ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 48
  tmp = __errno_location();
#line 48
  *tmp = 0;
#line 49
  tmp___0 = so_resolv(& addr, hostname);
  }
#line 49
  if (! tmp___0) {
#line 52
    return (-1);
  }
  {
#line 55
  tmp___1 = so_connect(addr, port);
  }
#line 55
  return (tmp___1);
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/direct.c"
int www_authenticate(int sd , rr_data_t request , rr_data_t response , struct auth_s *creds ) 
{ 
  char *tmp ;
  char *buf ;
  char *challenge ;
  rr_data_t auth ;
  int len ;
  int rc ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 64
  rc = 0;
#line 66
  buf = new((size_t )4096);
#line 68
  strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)"NTLM ");
#line 69
  len = ntlm_request(& tmp, creds);
  }
#line 70
  if (len) {
    {
#line 71
    to_base64((uint8_t *)(buf + 5), (unsigned char const   *)((uint8_t *)(tmp + 0)),
              (size_t )len, (size_t )4091);
#line 72
    free((void *)tmp);
    }
  }
  {
#line 75
  auth = dup_rr_data(request);
#line 76
  auth->headers = hlist_mod(auth->headers, (char *)"Connection", (char *)"keep-alive",
                            1);
#line 77
  auth->headers = hlist_mod(auth->headers, (char *)"Authorization", buf, 1);
#line 78
  auth->headers = hlist_mod(auth->headers, (char *)"Content-Length", (char *)"0",
                            1);
#line 79
  auth->headers = hlist_del(auth->headers, "Transfer-Encoding");
#line 84
  tmp___0 = http_body_drop(sd, response);
  }
#line 84
  if (! tmp___0) {
#line 85
    goto bailout;
  }
#line 87
  if (debug) {
    {
#line 88
    printf((char const   */* __restrict  */)"\nSending WWW auth request...\n");
#line 89
    hlist_dump(auth->headers);
    }
  }
  {
#line 92
  tmp___1 = headers_send(sd, auth);
  }
#line 92
  if (! tmp___1) {
#line 93
    goto bailout;
  }
#line 95
  if (debug) {
    {
#line 96
    printf((char const   */* __restrict  */)"\nReading WWW auth response...\n");
    }
  }
  {
#line 101
  reset_rr_data(auth);
#line 102
  tmp___2 = headers_recv(sd, auth);
  }
#line 102
  if (! tmp___2) {
#line 103
    goto bailout;
  }
#line 106
  if (debug) {
    {
#line 107
    hlist_dump(auth->headers);
    }
  }
#line 112
  if (auth->code == 401) {
    {
#line 113
    tmp___3 = http_body_drop(sd, auth);
    }
#line 113
    if (! tmp___3) {
#line 114
      goto bailout;
    }
    {
#line 116
    tmp = hlist_get(auth->headers, "WWW-Authenticate");
    }
#line 117
    if (tmp) {
      {
#line 117
      tmp___5 = strlen((char const   *)tmp);
      }
#line 117
      if (tmp___5 > 14UL) {
        {
#line 118
        tmp___4 = strlen((char const   *)tmp);
#line 118
        challenge = new((tmp___4 + 5UL) + 1UL);
#line 119
        len = from_base64(challenge, (char const   *)(tmp + 5));
        }
#line 120
        if (len > 24) {
          {
#line 121
          len = ntlm_response(& tmp, challenge, len, creds);
          }
#line 122
          if (len > 0) {
            {
#line 123
            strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)"NTLM ");
#line 124
            to_base64((uint8_t *)(buf + 5), (unsigned char const   *)((uint8_t *)(tmp + 0)),
                      (size_t )len, (size_t )4091);
#line 125
            request->headers = hlist_mod(request->headers, (char *)"Authorization",
                                         buf, 1);
#line 126
            free((void *)tmp);
            }
          } else {
            {
#line 128
            syslog(3, "No target info block. Cannot do NTLMv2!\n");
#line 129
            response->errmsg = (char *)"Invalid NTLM challenge from web server";
#line 130
            free((void *)challenge);
            }
#line 131
            goto bailout;
          }
        } else {
          {
#line 134
          syslog(3, "Server returning invalid challenge!\n");
#line 135
          response->errmsg = (char *)"Invalid NTLM challenge from web server";
#line 136
          free((void *)challenge);
          }
#line 137
          goto bailout;
        }
        {
#line 140
        free((void *)challenge);
        }
      } else {
        {
#line 142
        syslog(4, "No challenge in WWW-Authenticate!\n");
#line 143
        response->errmsg = (char *)"Web server reply missing NTLM challenge";
        }
#line 144
        goto bailout;
      }
    } else {
      {
#line 142
      syslog(4, "No challenge in WWW-Authenticate!\n");
#line 143
      response->errmsg = (char *)"Web server reply missing NTLM challenge";
      }
#line 144
      goto bailout;
    }
  } else {
#line 147
    goto bailout;
  }
#line 150
  if (debug) {
    {
#line 151
    printf((char const   */* __restrict  */)"\nSending WWW auth...\n");
    }
  }
  {
#line 153
  tmp___6 = headers_send(sd, request);
  }
#line 153
  if (! tmp___6) {
#line 154
    goto bailout;
  }
#line 157
  if (debug) {
    {
#line 158
    printf((char const   */* __restrict  */)"\nReading final server response...\n");
    }
  }
  {
#line 160
  reset_rr_data(auth);
#line 161
  tmp___7 = headers_recv(sd, auth);
  }
#line 161
  if (! tmp___7) {
#line 162
    goto bailout;
  }
#line 165
  rc = 1;
#line 167
  if (debug) {
    {
#line 168
    hlist_dump(auth->headers);
    }
  }
  bailout: 
#line 171
  if (rc) {
    {
#line 172
    response = copy_rr_data(response, auth);
    }
  }
  {
#line 173
  free_rr_data(auth);
#line 174
  free((void *)buf);
  }
#line 176
  return (rc);
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/direct.c"
rr_data_t direct_request(void *cdata , rr_data_t request ) 
{ 
  rr_data_t data[2] ;
  rr_data_t rc ;
  struct auth_s *tcreds ;
  int *rsocket[2] ;
  int *wsocket[2] ;
  int w ;
  int loop ;
  int sd ;
  char *tmp ;
  char *hostname ;
  int port ;
  int conn_alive ;
  int cd ;
  struct sockaddr_in caddr ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  ssize_t tmp___5 ;
  size_t tmp___6 ;
  ssize_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  ssize_t tmp___16 ;
  int tmp___17 ;
  char const   *tmp___18 ;
  size_t tmp___19 ;
  ssize_t tmp___20 ;
  size_t tmp___21 ;
  ssize_t tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  length_t tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;

  {
#line 180
  rc = (rr_data_t )((void *)0);
#line 181
  tcreds = (struct auth_s *)((void *)0);
#line 186
  hostname = (char *)((void *)0);
#line 187
  port = 0;
#line 188
  conn_alive = 0;
#line 190
  cd = ((struct thread_arg_s *)cdata)->fd;
#line 191
  caddr = ((struct thread_arg_s *)cdata)->addr;
#line 193
  if (debug) {
    {
#line 194
    printf((char const   */* __restrict  */)"Direct thread processing...\n");
    }
  }
  {
#line 196
  sd = host_connect((char const   *)request->hostname, request->port);
  }
#line 197
  if (sd < 0) {
    {
#line 198
    tmp___0 = __errno_location();
#line 198
    tmp___1 = strerror(*tmp___0);
#line 198
    syslog(4, "Connection failed for %s:%d (%s)", request->hostname, request->port,
           tmp___1);
#line 199
    tmp___2 = __errno_location();
#line 199
    tmp___3 = strerror(*tmp___2);
#line 199
    tmp = gen_502_page((char const   *)request->http, (char const   *)tmp___3);
#line 200
    tmp___4 = strlen((char const   *)tmp);
#line 200
    tmp___5 = write(cd, (void const   *)tmp, tmp___4);
#line 200
    w = (int )tmp___5;
#line 201
    free((void *)tmp);
#line 203
    rc = (rr_data_t )((void *)-1);
    }
#line 204
    goto bailout;
  }
  {
#line 211
  tcreds = dup_auth(g_creds, 1);
  }
#line 213
  if (request->hostname) {
    {
#line 214
    hostname = strdup((char const   *)request->hostname);
#line 215
    port = request->port;
    }
  } else {
    {
#line 217
    tmp = gen_502_page((char const   *)request->http, "Invalid request URL");
#line 218
    tmp___6 = strlen((char const   *)tmp);
#line 218
    tmp___7 = write(cd, (void const   *)tmp, tmp___6);
#line 218
    w = (int )tmp___7;
#line 219
    free((void *)tmp);
#line 221
    rc = (rr_data_t )((void *)-1);
    }
#line 222
    goto bailout;
  }
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 226
    if (request) {
      {
#line 227
      data[0] = dup_rr_data(request);
#line 228
      request = (rr_data_t )((void *)0);
      }
    } else {
      {
#line 230
      data[0] = new_rr_data();
      }
    }
    {
#line 232
    data[1] = new_rr_data();
#line 234
    wsocket[1] = & cd;
#line 234
    rsocket[0] = wsocket[1];
#line 235
    wsocket[0] = & sd;
#line 235
    rsocket[1] = wsocket[0];
#line 237
    conn_alive = 0;
#line 239
    loop = 0;
    }
    {
#line 239
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 239
      if (! (loop < 2)) {
#line 239
        goto while_break___0;
      }
#line 240
      if ((data[loop])->empty) {
#line 241
        if (debug) {
          {
#line 242
          printf((char const   */* __restrict  */)"\n******* Round %d C: %d, S: %d *******\n",
                 loop + 1, cd, sd);
#line 243
          printf((char const   */* __restrict  */)"Reading headers (%d)...\n", *(rsocket[loop]));
          }
        }
        {
#line 245
        tmp___8 = headers_recv(*(rsocket[loop]), data[loop]);
        }
#line 245
        if (! tmp___8) {
          {
#line 246
          free_rr_data(data[0]);
#line 247
          free_rr_data(data[1]);
#line 248
          rc = (rr_data_t )((void *)-1);
          }
#line 249
          goto bailout;
        }
      }
#line 258
      if (loop == 0) {
#line 258
        if (hostname) {
#line 258
          if ((data[0])->hostname) {
            {
#line 258
            tmp___9 = strcasecmp((char const   *)hostname, (char const   *)(data[0])->hostname);
            }
#line 258
            if (tmp___9) {
#line 258
              goto _L;
            } else
#line 258
            if (port != (data[0])->port) {
              _L: /* CIL Label */ 
#line 260
              if (debug) {
                {
#line 261
                printf((char const   */* __restrict  */)"\n******* D RETURN: %s *******\n",
                       (data[0])->url);
                }
              }
              {
#line 263
              rc = dup_rr_data(data[0]);
#line 264
              free_rr_data(data[0]);
#line 265
              free_rr_data(data[1]);
              }
#line 266
              goto bailout;
            }
          }
        }
      }
#line 269
      if (debug) {
        {
#line 270
        hlist_dump((data[loop])->headers);
        }
      }
#line 272
      if (loop == 0) {
#line 272
        if ((data[0])->req) {
          {
#line 273
          tmp___10 = inet_ntoa(caddr.sin_addr);
#line 273
          syslog(7, "%s %s %s", tmp___10, (data[0])->method, (data[0])->url);
          }
#line 279
          if ((data[0])->rel_url) {
#line 280
            if ((data[0])->url) {
              {
#line 281
              free((void *)(data[0])->url);
              }
            }
            {
#line 282
            (data[0])->url = strdup((char const   *)(data[0])->rel_url);
            }
          }
#line 288
          if ((data[0])->http_version >= 11) {
            {
#line 289
            (data[0])->headers = hlist_mod((data[0])->headers, (char *)"Connection",
                                           (char *)"keep-alive", 1);
            }
          }
          {
#line 295
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 295
            tmp___11 = hlist_get((data[loop])->headers, "Proxy-Authorization");
            }
#line 295
            if (! tmp___11) {
#line 295
              goto while_break___1;
            }
            {
#line 296
            (data[loop])->headers = hlist_del((data[loop])->headers, "Proxy-Authorization");
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 302
          tmp___12 = http_parse_basic((data[0])->headers, "Authorization", tcreds);
          }
#line 302
          if (tmp___12 > 0) {
#line 302
            if (debug) {
              {
#line 303
              printf((char const   */* __restrict  */)"NTLM-to-basic: Credentials parsed: %s\\%s at %s\n",
                     tcreds->domain, tcreds->user, tcreds->workstation);
              }
            }
          }
        }
      }
#line 309
      if (loop == 0) {
#line 309
        if (data[0]) {
#line 309
          if ((data[0])->req) {
            {
#line 309
            tmp___14 = strcasecmp("CONNECT", (char const   *)(data[0])->method);
            }
#line 309
            if (! tmp___14) {
#line 310
              if (debug) {
                {
#line 311
                printf((char const   */* __restrict  */)"CONNECTing...\n");
                }
              }
              {
#line 313
              (data[1])->empty = 0;
#line 314
              (data[1])->req = 0;
#line 315
              (data[1])->code = 200;
#line 316
              (data[1])->msg = strdup("Connection established");
#line 317
              (data[1])->http = strdup((char const   *)(data[0])->http);
#line 319
              tmp___13 = headers_send(cd, data[1]);
              }
#line 319
              if (tmp___13) {
                {
#line 320
                tunnel(cd, sd);
                }
              }
              {
#line 322
              free_rr_data(data[0]);
#line 323
              free_rr_data(data[1]);
#line 324
              rc = (rr_data_t )((void *)-1);
              }
#line 325
              goto bailout;
            }
          }
        }
      }
#line 328
      if (loop == 1) {
#line 328
        if ((data[1])->code == 401) {
          {
#line 328
          tmp___24 = hlist_subcmp_all((data[1])->headers, "WWW-Authenticate", "NTLM");
          }
#line 328
          if (tmp___24) {
            {
#line 333
            tmp___17 = hlist_subcmp((data[1])->headers, "Connection", "close");
            }
#line 333
            if (tmp___17) {
#line 334
              if (debug) {
                {
#line 335
                printf((char const   */* __restrict  */)"Reconnect before WWW auth\n");
                }
              }
              {
#line 336
              close(sd);
#line 337
              sd = host_connect((char const   *)(data[0])->hostname, (data[0])->port);
              }
#line 338
              if (sd < 0) {
                {
#line 339
                tmp = gen_502_page((char const   *)(data[0])->http, "WWW authentication reconnect failed");
#line 340
                tmp___15 = strlen((char const   *)tmp);
#line 340
                tmp___16 = write(cd, (void const   *)tmp, tmp___15);
#line 340
                w = (int )tmp___16;
#line 341
                free((void *)tmp);
#line 343
                rc = (rr_data_t )((void *)-1);
                }
#line 344
                goto bailout;
              }
            }
            {
#line 347
            tmp___23 = www_authenticate(*(wsocket[0]), data[0], data[1], tcreds);
            }
#line 347
            if (tmp___23) {
#line 360
              if ((data[1])->code == 401) {
                {
#line 365
                tmp = gen_401_page((char const   *)(data[1])->http, (char const   *)(data[0])->hostname,
                                   (data[0])->port);
#line 366
                tmp___21 = strlen((char const   *)tmp);
#line 366
                tmp___22 = write(cd, (void const   *)tmp, tmp___21);
#line 366
                w = (int )tmp___22;
#line 367
                free((void *)tmp);
#line 369
                free_rr_data(data[0]);
#line 370
                free_rr_data(data[1]);
#line 372
                rc = (rr_data_t )((void *)-1);
                }
#line 373
                goto bailout;
              }
            } else {
#line 348
              if (debug) {
                {
#line 349
                printf((char const   */* __restrict  */)"WWW auth connection error.\n");
                }
              }
#line 351
              if ((data[1])->errmsg) {
#line 351
                tmp___18 = (char const   *)(data[1])->errmsg;
              } else {
#line 351
                tmp___18 = "Error during WWW-Authenticate";
              }
              {
#line 351
              tmp = gen_502_page((char const   *)(data[1])->http, tmp___18);
#line 352
              tmp___19 = strlen((char const   *)tmp);
#line 352
              tmp___20 = write(cd, (void const   *)tmp, tmp___19);
#line 352
              w = (int )tmp___20;
#line 353
              free((void *)tmp);
#line 355
              free_rr_data(data[0]);
#line 356
              free_rr_data(data[1]);
#line 358
              rc = (rr_data_t )((void *)-1);
              }
#line 359
              goto bailout;
            }
          }
        }
      }
#line 385
      if (loop == 1) {
        {
#line 386
        tmp___25 = hlist_subcmp((data[1])->headers, "Connection", "close");
        }
#line 386
        if (tmp___25) {
#line 386
          tmp___27 = 0;
        } else {
          {
#line 386
          tmp___26 = http_has_body(data[0], data[1]);
          }
#line 386
          if (tmp___26 != -1LL) {
#line 386
            if ((data[0])->http_version >= 11) {
#line 386
              tmp___27 = 1;
            } else {
#line 386
              tmp___27 = 0;
            }
          } else {
#line 386
            tmp___27 = 0;
          }
        }
#line 386
        conn_alive = tmp___27;
#line 389
        if (conn_alive) {
          {
#line 390
          (data[1])->headers = hlist_mod((data[1])->headers, (char *)"Proxy-Connection",
                                         (char *)"keep-alive", 1);
#line 391
          (data[1])->headers = hlist_mod((data[1])->headers, (char *)"Connection",
                                         (char *)"keep-alive", 1);
          }
        } else {
          {
#line 393
          (data[1])->headers = hlist_mod((data[1])->headers, (char *)"Proxy-Connection",
                                         (char *)"close", 1);
#line 394
          (data[1])->headers = hlist_mod((data[1])->headers, (char *)"Connection",
                                         (char *)"close", 1);
#line 395
          rc = (rr_data_t )((void *)-1);
          }
        }
      }
#line 399
      if (debug) {
        {
#line 400
        printf((char const   */* __restrict  */)"Sending headers (%d)...\n", *(wsocket[loop]));
        }
#line 401
        if (loop == 0) {
          {
#line 402
          printf((char const   */* __restrict  */)"HEAD: %s %s %s\n", (data[loop])->method,
                 (data[loop])->url, (data[loop])->http);
#line 403
          hlist_dump((data[loop])->headers);
          }
        }
      }
      {
#line 410
      tmp___28 = headers_send(*(wsocket[loop]), data[loop]);
      }
#line 410
      if (! tmp___28) {
        {
#line 411
        free_rr_data(data[0]);
#line 412
        free_rr_data(data[1]);
#line 413
        rc = (rr_data_t )((void *)-1);
        }
#line 414
        goto bailout;
      }
      {
#line 417
      tmp___29 = http_body_send(*(wsocket[loop]), *(rsocket[loop]), data[0], data[1]);
      }
#line 417
      if (! tmp___29) {
        {
#line 418
        free_rr_data(data[0]);
#line 419
        free_rr_data(data[1]);
#line 420
        rc = (rr_data_t )((void *)-1);
        }
#line 421
        goto bailout;
      }
#line 239
      loop ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 425
    free_rr_data(data[0]);
#line 426
    free_rr_data(data[1]);
    }
#line 225
    if (conn_alive) {
      {
#line 225
      tmp___30 = so_closed(sd);
      }
#line 225
      if (tmp___30) {
#line 225
        goto while_break;
      } else {
        {
#line 225
        tmp___31 = so_closed(cd);
        }
#line 225
        if (tmp___31) {
#line 225
          goto while_break;
        } else
#line 225
        if (! (! serialize)) {
#line 225
          goto while_break;
        }
      }
    } else {
#line 225
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  bailout: 
#line 431
  if (tcreds) {
    {
#line 432
    free((void *)tcreds);
    }
  }
#line 433
  if (hostname) {
    {
#line 434
    free((void *)hostname);
    }
  }
  {
#line 436
  close(sd);
  }
#line 438
  return (rc);
}
}
#line 441 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/direct.c"
void direct_tunnel(void *thread_data ) 
{ 
  int sd ;
  int port ;
  char *pos ;
  char *hostname ;
  int cd ;
  char *thost ;
  struct sockaddr_in caddr ;
  char *tmp ;

  {
  {
#line 442
  port = 0;
#line 445
  cd = ((struct thread_arg_s *)thread_data)->fd;
#line 446
  thost = ((struct thread_arg_s *)thread_data)->target;
#line 447
  caddr = ((struct thread_arg_s *)thread_data)->addr;
#line 449
  hostname = strdup((char const   *)thost);
#line 450
  pos = strchr((char const   *)hostname, ':');
  }
#line 450
  if ((unsigned long )pos != (unsigned long )((void *)0)) {
    {
#line 451
    *pos = (char)0;
#line 452
    pos ++;
#line 452
    port = atoi((char const   *)pos);
    }
  }
  {
#line 455
  sd = host_connect((char const   *)hostname, port);
  }
#line 456
  if (sd <= 0) {
#line 457
    goto bailout;
  }
  {
#line 459
  tmp = inet_ntoa(caddr.sin_addr);
#line 459
  syslog(7, "%s FORWARD %s", tmp, thost);
  }
#line 460
  if (debug) {
    {
#line 461
    printf((char const   */* __restrict  */)"Portforwarding to %s for client %d...\n",
           thost, cd);
    }
  }
  {
#line 463
  tunnel(cd, sd);
  }
  bailout: 
  {
#line 466
  free((void *)hostname);
#line 467
  close(sd);
#line 468
  close(cd);
  }
#line 470
  return;
}
}
#line 29 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/auth.c"
struct auth_s *new_auth(void) 
{ 
  struct auth_s *tmp ;
  void *tmp___0 ;

  {
  {
#line 32
  tmp___0 = malloc(sizeof(struct auth_s ));
#line 32
  tmp = (struct auth_s *)tmp___0;
  }
#line 33
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 34
    return ((struct auth_s *)((void *)0));
  }
  {
#line 36
  memset((void *)(tmp->user), 0, (size_t )50);
#line 37
  memset((void *)(tmp->domain), 0, (size_t )50);
#line 38
  memset((void *)(tmp->workstation), 0, (size_t )50);
#line 39
  memset((void *)(tmp->passntlm2), 0, (size_t )50);
#line 40
  memset((void *)(tmp->passnt), 0, (size_t )50);
#line 41
  memset((void *)(tmp->passlm), 0, (size_t )50);
#line 42
  tmp->hashntlm2 = 1;
#line 43
  tmp->hashnt = 0;
#line 44
  tmp->hashlm = 0;
#line 45
  tmp->flags = (uint32_t )0;
  }
#line 47
  return (tmp);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/auth.c"
struct auth_s *copy_auth(struct auth_s *dst , struct auth_s *src , int fullcopy ) 
{ 


  {
  {
#line 51
  dst->hashntlm2 = src->hashntlm2;
#line 52
  dst->hashnt = src->hashnt;
#line 53
  dst->hashlm = src->hashlm;
#line 54
  dst->flags = src->flags;
#line 56
  strlcpy(dst->domain, (char const   *)(src->domain), (size_t )50);
#line 57
  strlcpy(dst->workstation, (char const   *)(src->workstation), (size_t )50);
  }
#line 59
  if (fullcopy) {
    {
#line 60
    strlcpy(dst->user, (char const   *)(src->user), (size_t )50);
    }
#line 61
    if (src->passntlm2) {
      {
#line 62
      memcpy((void */* __restrict  */)(dst->passntlm2), (void const   */* __restrict  */)(src->passntlm2),
             (size_t )50);
      }
    }
#line 63
    if (src->passnt) {
      {
#line 64
      memcpy((void */* __restrict  */)(dst->passnt), (void const   */* __restrict  */)(src->passnt),
             (size_t )50);
      }
    }
#line 65
    if (src->passlm) {
      {
#line 66
      memcpy((void */* __restrict  */)(dst->passlm), (void const   */* __restrict  */)(src->passlm),
             (size_t )50);
      }
    }
  } else {
    {
#line 68
    memset((void *)(dst->user), 0, (size_t )50);
#line 69
    memset((void *)(dst->passntlm2), 0, (size_t )50);
#line 70
    memset((void *)(dst->passnt), 0, (size_t )50);
#line 71
    memset((void *)(dst->passlm), 0, (size_t )50);
    }
  }
#line 74
  return (dst);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/auth.c"
struct auth_s *dup_auth(struct auth_s *creds , int fullcopy ) 
{ 
  struct auth_s *tmp ;
  struct auth_s *tmp___0 ;

  {
  {
#line 80
  tmp = new_auth();
  }
#line 81
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 82
    return ((struct auth_s *)((void *)0));
  }
  {
#line 84
  tmp___0 = copy_auth(tmp, creds, fullcopy);
  }
#line 84
  return (tmp___0);
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/cntlm-0.92.3/auth.c"
void dump_auth(struct auth_s *creds ) 
{ 
  char *tmp ;

  {
  {
#line 90
  printf((char const   */* __restrict  */)"Credentials structure dump:\n");
  }
#line 91
  if ((unsigned long )creds == (unsigned long )((void *)0)) {
    {
#line 92
    printf((char const   */* __restrict  */)"Struct is not allocated!\n");
    }
#line 93
    return;
  }
  {
#line 96
  printf((char const   */* __restrict  */)"User:       %s\n", creds->user);
#line 97
  printf((char const   */* __restrict  */)"Domain:     %s\n", creds->domain);
#line 98
  printf((char const   */* __restrict  */)"Wks:        %s\n", creds->workstation);
#line 99
  printf((char const   */* __restrict  */)"HashNTLMv2: %d\n", creds->hashntlm2);
#line 100
  printf((char const   */* __restrict  */)"HashNT:     %d\n", creds->hashnt);
#line 101
  printf((char const   */* __restrict  */)"HashLM:     %d\n", creds->hashlm);
#line 102
  printf((char const   */* __restrict  */)"Flags:      %X\n", creds->flags);
  }
#line 103
  if (creds->passntlm2) {
    {
#line 104
    tmp = printmem(creds->passntlm2, (size_t )16, 8);
#line 105
    printf((char const   */* __restrict  */)"PassNTLMv2: %s\n", tmp);
#line 106
    free((void *)tmp);
    }
  }
#line 109
  if (creds->passnt) {
    {
#line 110
    tmp = printmem(creds->passnt, (size_t )16, 8);
#line 111
    printf((char const   */* __restrict  */)"PassNT:     %s\n", tmp);
#line 112
    free((void *)tmp);
    }
  }
#line 115
  if (creds->passlm) {
    {
#line 116
    tmp = printmem(creds->passlm, (size_t )16, 8);
#line 117
    printf((char const   */* __restrict  */)"PassLM:     %s\n\n", tmp);
#line 118
    free((void *)tmp);
    }
  }
#line 120
  return;
}
}
