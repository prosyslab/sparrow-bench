/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 86 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 147 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
struct mtd_file {
   unsigned char *pname ;
   int fwrite ;
   int fverify ;
   int fprogress ;
   int fwritten ;
   int fchanged ;
   int fd ;
   struct stat stat ;
   size_t cbbuf ;
   off_t useroffset ;
   off_t bufferoffset ;
   off_t deviceoffset ;
   off_t endoffset ;
   unsigned char *pbuf ;
   unsigned char *pwritebuf ;
};
#line 147 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
typedef struct mtd_file mtd_file;
#line 675 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
struct parse_buf {
   int fverify ;
   int fprogress ;
   int cstack ;
   int fbreak ;
   mtd_file *pfrom ;
   mtd_file *pto ;
   unsigned long variables[256] ;
   unsigned long stack[256] ;
   mtd_file files[16] ;
};
#line 675 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
typedef struct parse_buf parse_buf;
#line 1246 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
struct stack {
   int Al ;
   int Ac ;
};
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 353
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 1112
extern int fdatasync(int __fildes ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 538
extern int getchar(void) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 580
extern int putchar(int __c ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 57 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
static int error_level  =    1;
#line 58 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
static int progress  =    0;
#line 73
static  __attribute__((__noreturn__)) void do_die(unsigned char const   *why , unsigned char const   *infile ) ;
#line 75
static  __attribute__((__noreturn__)) void do_die(unsigned char const   *why , unsigned char const   *infile ) ;
#line 75 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
static void do_die(unsigned char const   *why , unsigned char const   *infile ) 
{ 


  {
#line 76
  if (progress) {
    {
#line 76
    fputc('\n', stderr);
    }
  }
  {
#line 77
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"devio: %s: %s\n",
          infile, why);
#line 78
  exit(error_level);
  }
}
}
#line 92
static  __attribute__((__noreturn__)) void do_pdie(unsigned char const   *why , unsigned char const   *infile ) ;
#line 94
static  __attribute__((__noreturn__)) void do_pdie(unsigned char const   *why , unsigned char const   *infile ) ;
#line 94 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
static void do_pdie(unsigned char const   *why , unsigned char const   *infile ) 
{ 
  int *tmp ;
  char *tmp___0 ;

  {
#line 95
  if (progress) {
    {
#line 95
    fputc('\n', stderr);
    }
  }
  {
#line 96
  tmp = __errno_location();
#line 96
  tmp___0 = strerror(*tmp);
#line 96
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"devio: %s: %s: %s\n",
          infile, why, tmp___0);
#line 97
  exit(error_level);
  }
}
}
#line 116
static  __attribute__((__noreturn__)) void do_assert(int line ) ;
#line 117
static  __attribute__((__noreturn__)) void do_assert(int line ) ;
#line 117 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
static void do_assert(int line ) 
{ 


  {
  {
#line 118
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"devio: internal error: %d\n",
          line);
#line 119
  exit(error_level);
  }
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
unsigned char *my_strdup(unsigned char const   *from ) 
{ 
  size_t cb ;
  size_t tmp ;
  unsigned char *to ;
  void *tmp___0 ;

  {
  {
#line 126
  tmp = strlen((char const   *)from);
#line 126
  cb = tmp + 1UL;
#line 127
  tmp___0 = malloc(cb);
#line 127
  to = (unsigned char *)tmp___0;
  }
#line 128
  if ((unsigned long )to == (unsigned long )((unsigned char *)0)) {
    {
#line 129
    do_die((unsigned char const   *)"out of memory", from);
    }
  }
  {
#line 130
  memcpy((void */* __restrict  */)to, (void const   */* __restrict  */)from, cb);
  }
#line 131
  return (to);
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
static void init_mtd(mtd_file *pfile ) 
{ 


  {
  {
#line 173
  pfile->pname = (unsigned char *)0;
#line 174
  pfile->fwrite = 0;
#line 175
  pfile->fverify = 0;
#line 176
  pfile->fwritten = 0;
#line 177
  pfile->fchanged = 0;
#line 178
  pfile->fd = -1;
#line 179
  memset((void *)(& pfile->stat), 0, sizeof(pfile->stat));
#line 180
  pfile->cbbuf = (size_t )0;
#line 181
  pfile->useroffset = (off_t )0;
#line 182
  pfile->bufferoffset = (off_t )0;
#line 183
  pfile->deviceoffset = (off_t )0;
#line 184
  pfile->endoffset = (off_t )-1;
#line 185
  pfile->pbuf = (unsigned char *)0;
#line 186
  pfile->pwritebuf = (unsigned char *)0;
  }
#line 187
  return;
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
static size_t size_mtd(mtd_file *pfile ) 
{ 
  off_t len ;
  __off_t tmp ;

  {
#line 192
  if ((pfile->stat.st_mode & 61440U) == 8192U) {
#line 192
    goto _L;
  } else
#line 192
  if ((pfile->stat.st_mode & 61440U) == 24576U) {
    _L: /* CIL Label */ 
#line 193
    if (pfile->endoffset == -1L) {
      {
#line 195
      while (1) {
        while_continue: /* CIL Label */ ;
#line 195
        if (! (pfile->stat.st_size == 0L)) {
          {
#line 195
          do_assert(195);
          }
        }
#line 195
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 196
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 196
        if (! (pfile->stat.st_blocks == 0L)) {
          {
#line 196
          do_assert(196);
          }
        }
#line 196
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 197
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 197
        if (! (pfile->stat.st_blksize > 0L)) {
          {
#line 197
          do_assert(197);
          }
        }
#line 197
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 199
      len = lseek(pfile->fd, - pfile->stat.st_blksize, 2);
      }
#line 200
      if (len == -1L) {
        {
#line 201
        do_pdie((unsigned char const   *)"lseek(length)", (unsigned char const   *)pfile->pname);
        }
      }
      {
#line 202
      tmp = lseek(pfile->fd, pfile->deviceoffset, 0);
      }
#line 202
      if (tmp != pfile->deviceoffset) {
        {
#line 203
        do_pdie((unsigned char const   *)"lseek(length reset)", (unsigned char const   *)pfile->pname);
        }
      }
#line 204
      len += pfile->stat.st_blksize;
#line 205
      pfile->endoffset = len;
    }
#line 207
    return ((size_t )pfile->endoffset);
  } else
#line 208
  if ((pfile->stat.st_mode & 61440U) == 16384U) {
    {
#line 210
    do_die((unsigned char const   *)"cannot find size of this device", (unsigned char const   *)pfile->pname);
    }
  } else
#line 208
  if ((pfile->stat.st_mode & 61440U) == 4096U) {
    {
#line 210
    do_die((unsigned char const   *)"cannot find size of this device", (unsigned char const   *)pfile->pname);
    }
  } else
#line 208
  if ((pfile->stat.st_mode & 61440U) == 49152U) {
    {
#line 210
    do_die((unsigned char const   *)"cannot find size of this device", (unsigned char const   *)pfile->pname);
    }
  } else {
#line 212
    return ((size_t )pfile->stat.st_size);
  }
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
static void new_mtd(mtd_file *pfile , char const   *pname , int fwrite___0 , int fverify ,
                    int fprogress , int fd ) 
{ 
  int tmp ;

  {
  {
#line 220
  pfile->pname = my_strdup((unsigned char const   *)pname);
#line 221
  pfile->fwrite = fwrite___0;
#line 222
  pfile->fverify = fverify;
#line 223
  pfile->fprogress = fprogress;
#line 224
  pfile->fwritten = 0;
#line 225
  pfile->fchanged = 0;
#line 226
  pfile->fd = fd;
#line 228
  tmp = fstat(fd, & pfile->stat);
  }
#line 228
  if (tmp != 0) {
    {
#line 229
    do_pdie((unsigned char const   *)"fstat", (unsigned char const   *)pname);
    }
  }
#line 234
  if ((pfile->stat.st_mode & 61440U) == 16384U) {
    {
#line 236
    do_die((unsigned char const   *)"invalid device", (unsigned char const   *)pname);
    }
  } else
#line 234
  if ((pfile->stat.st_mode & 61440U) == 4096U) {
    {
#line 236
    do_die((unsigned char const   *)"invalid device", (unsigned char const   *)pname);
    }
  } else
#line 234
  if ((pfile->stat.st_mode & 61440U) == 49152U) {
    {
#line 236
    do_die((unsigned char const   *)"invalid device", (unsigned char const   *)pname);
    }
  }
#line 238
  pfile->cbbuf = (size_t )pfile->stat.st_blksize;
#line 239
  if (pfile->cbbuf == 0UL) {
#line 240
    pfile->cbbuf = (size_t )4096;
  }
#line 241
  pfile->useroffset = (off_t )0;
#line 242
  pfile->bufferoffset = (off_t )0;
#line 243
  pfile->deviceoffset = (off_t )0;
#line 244
  pfile->pbuf = (unsigned char *)0;
#line 245
  pfile->pwritebuf = (unsigned char *)0;
#line 246
  return;
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
static void open_mtd(mtd_file *pfile , char const   *pname , int fwrite___0 , int fverify ,
                     int fprogress ) 
{ 
  int fd ;
  int tmp ;
  int tmp___0 ;

  {
#line 250
  if (fwrite___0) {
#line 250
    if (! fverify) {
#line 250
      tmp = 2;
    } else {
#line 250
      tmp = 0;
    }
  } else {
#line 250
    tmp = 0;
  }
  {
#line 250
  tmp___0 = open(pname, tmp);
#line 250
  fd = tmp___0;
  }
#line 251
  if (fd < 0) {
    {
#line 252
    do_pdie((unsigned char const   *)"open", (unsigned char const   *)pname);
    }
  } else
#line 253
  if (fd < 3) {
    {
#line 254
    do_die((unsigned char const   *)"no standard streams", (unsigned char const   *)"-");
    }
  }
  {
#line 255
  new_mtd(pfile, pname, fwrite___0, fverify, fprogress, fd);
  }
#line 256
  return;
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
static void write_mtd(mtd_file *pfile ) 
{ 
  size_t count ;
  unsigned char *pbuf ;
  __off_t tmp ;
  ssize_t cb ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 266
  if (pfile->fwritten) {
#line 267
    count = (size_t )(pfile->deviceoffset - pfile->bufferoffset);
#line 268
    pbuf = pfile->pwritebuf;
    {
#line 270
    while (1) {
      while_continue: /* CIL Label */ ;
#line 270
      if (! ((unsigned long )pfile->pbuf != (unsigned long )((unsigned char *)0))) {
        {
#line 270
        do_assert(270);
        }
      }
#line 270
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 271
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 271
      if (! ((unsigned long )pbuf != (unsigned long )((unsigned char *)0))) {
        {
#line 271
        do_assert(271);
        }
      }
#line 271
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 272
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 272
      if (! (pfile->deviceoffset > pfile->bufferoffset)) {
        {
#line 272
        do_assert(272);
        }
      }
#line 272
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 273
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 273
      if (! ((size_t )pfile->deviceoffset <= (size_t )pfile->bufferoffset + pfile->cbbuf)) {
        {
#line 273
        do_assert(273);
        }
      }
#line 273
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 275
    tmp___2 = memcmp((void const   *)pfile->pbuf, (void const   *)pbuf, count);
    }
#line 275
    if (tmp___2 != 0) {
#line 277
      if (pfile->fverify) {
        {
#line 278
        do_die((unsigned char const   *)"verification failed", (unsigned char const   *)pfile->pname);
        }
      }
      {
#line 284
      tmp = lseek(pfile->fd, pfile->bufferoffset, 0);
      }
#line 284
      if (tmp != pfile->bufferoffset) {
        {
#line 285
        do_pdie((unsigned char const   *)"lseek(write)", (unsigned char const   *)pfile->pname);
        }
      }
      {
#line 291
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 292
        tmp___0 = write(pfile->fd, (void const   *)pbuf, count);
#line 292
        cb = tmp___0;
        }
        {
#line 293
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 293
          if (! (cb != 0L)) {
            {
#line 293
            do_assert(293);
            }
          }
#line 293
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 294
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 294
          if (! ((size_t )cb <= count)) {
            {
#line 294
            do_assert(294);
            }
          }
#line 294
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 295
        if (cb < 0L) {
          {
#line 295
          tmp___1 = __errno_location();
          }
          {
#line 296
          if (*tmp___1 == 4) {
#line 296
            goto case_4;
          }
#line 302
          if (*tmp___1 == 11) {
#line 302
            goto case_11;
          }
#line 308
          if (*tmp___1 == 32) {
#line 308
            goto case_32;
          }
#line 319
          goto switch_default;
          case_4: /* CIL Label */ 
#line 301
          goto switch_break;
          case_11: /* CIL Label */ 
#line 307
          goto switch_break;
          case_32: /* CIL Label */ 
          {
#line 318
          exit(1);
          }
          switch_default: /* CIL Label */ 
          {
#line 320
          do_pdie((unsigned char const   *)"write", (unsigned char const   *)pfile->pname);
          }
          switch_break: /* CIL Label */ ;
          }
        } else {
#line 322
          count -= (size_t )cb;
#line 329
          pfile->fchanged = 1;
#line 334
          error_level = 3;
        }
#line 291
        if (! (count > 0UL)) {
#line 291
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 341
      memcpy((void */* __restrict  */)pfile->pbuf, (void const   */* __restrict  */)pfile->pwritebuf,
             (size_t )(pfile->deviceoffset - pfile->bufferoffset));
      }
#line 344
      if (pfile->fprogress) {
        {
#line 345
        fputc('+', stderr);
        }
      }
    } else
#line 346
    if (pfile->fprogress) {
      {
#line 347
      fputc('.', stderr);
      }
    }
#line 352
    pfile->fwritten = 0;
  }
#line 354
  return;
}
}
#line 359 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
static void close_mtd(mtd_file *pfile ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 360
  write_mtd(pfile);
  }
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! (! pfile->fwritten)) {
      {
#line 361
      do_assert(361);
      }
    }
#line 361
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 362
  if ((unsigned long )pfile->pbuf != (unsigned long )((unsigned char *)0)) {
    {
#line 363
    free((void *)pfile->pbuf);
#line 364
    pfile->pbuf = (unsigned char *)0;
    }
  }
#line 366
  if ((unsigned long )pfile->pwritebuf != (unsigned long )((unsigned char *)0)) {
    {
#line 367
    free((void *)pfile->pwritebuf);
#line 368
    pfile->pwritebuf = (unsigned char *)0;
    }
  }
#line 370
  if (pfile->fd >= 0) {
#line 376
    if (pfile->fchanged) {
#line 383
      if (pfile->fprogress) {
        {
#line 384
        fputc('*', stderr);
        }
      }
      {
#line 386
      tmp___0 = fdatasync(pfile->fd);
      }
#line 386
      if (tmp___0 != 0) {
        {
#line 391
        tmp = __errno_location();
        }
#line 391
        if (*tmp != 22) {
          {
#line 392
          do_pdie((unsigned char const   *)"sync", (unsigned char const   *)pfile->pname);
          }
        }
      }
#line 395
      if (pfile->fprogress) {
        {
#line 396
        fputc(';', stderr);
        }
      }
      {
#line 398
      tmp___1 = close(pfile->fd);
      }
#line 398
      if (tmp___1 != 0) {
        {
#line 399
        do_pdie((unsigned char const   *)"close", (unsigned char const   *)pfile->pname);
        }
      }
    } else {
      {
#line 401
      close(pfile->fd);
      }
    }
#line 402
    pfile->fd = -1;
  }
#line 404
  if ((unsigned long )pfile->pname != (unsigned long )((unsigned char *)0)) {
    {
#line 405
    free((void *)pfile->pname);
#line 406
    pfile->pname = (unsigned char *)0;
    }
  }
  {
#line 408
  init_mtd(pfile);
  }
#line 409
  return;
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
static void buffer_mtd(mtd_file *pfile ) 
{ 
  size_t blksize ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 414
  if ((unsigned long )pfile->pbuf == (unsigned long )((unsigned char *)0)) {
#line 415
    blksize = pfile->cbbuf;
    {
#line 416
    while (1) {
      while_continue: /* CIL Label */ ;
#line 416
      if (! (blksize > 0UL)) {
        {
#line 416
        do_assert(416);
        }
      }
#line 416
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 417
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 417
      if (! ((unsigned long )pfile->pwritebuf == (unsigned long )((unsigned char *)0))) {
        {
#line 417
        do_assert(417);
        }
      }
#line 417
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 423
    tmp = malloc(blksize);
#line 423
    pfile->pbuf = (unsigned char *)tmp;
    }
#line 424
    if (pfile->fwrite) {
      {
#line 425
      tmp___0 = malloc(blksize);
#line 425
      pfile->pwritebuf = (unsigned char *)tmp___0;
      }
    }
#line 426
    if ((unsigned long )pfile->pbuf == (unsigned long )((unsigned char *)0)) {
      {
#line 427
      do_die((unsigned char const   *)"out of memory", (unsigned char const   *)pfile->pname);
      }
    } else
#line 426
    if (pfile->fwrite) {
#line 426
      if ((unsigned long )pfile->pwritebuf == (unsigned long )((unsigned char *)0)) {
        {
#line 427
        do_die((unsigned char const   *)"out of memory", (unsigned char const   *)pfile->pname);
        }
      }
    }
  }
#line 429
  return;
}
}
#line 442 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
static void read_mtd(mtd_file *pfile ) 
{ 
  size_t cbread ;
  int ioffset ;
  size_t tmp ;
  off_t base ;
  __off_t tmp___0 ;
  ssize_t cb ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  __off_t tmp___3 ;

  {
#line 449
  if (pfile->useroffset >= pfile->bufferoffset) {
#line 449
    if (pfile->useroffset < pfile->deviceoffset) {
#line 451
      return;
    }
  }
#line 453
  if (pfile->useroffset < 0L) {
    {
#line 454
    do_die((unsigned char const   *)"read outside file", (unsigned char const   *)pfile->pname);
    }
  } else {
    {
#line 453
    tmp = size_mtd(pfile);
    }
#line 453
    if ((size_t )pfile->useroffset >= tmp) {
      {
#line 454
      do_die((unsigned char const   *)"read outside file", (unsigned char const   *)pfile->pname);
      }
    }
  }
  {
#line 457
  buffer_mtd(pfile);
#line 460
  cbread = pfile->cbbuf;
  }
#line 461
  if (pfile->useroffset >= pfile->bufferoffset) {
#line 461
    if ((size_t )pfile->useroffset < (size_t )pfile->bufferoffset + cbread) {
#line 464
      ioffset = (int )(pfile->deviceoffset - pfile->bufferoffset);
      {
#line 466
      while (1) {
        while_continue: /* CIL Label */ ;
#line 466
        if (! ((size_t )pfile->deviceoffset < (size_t )pfile->bufferoffset + cbread)) {
          {
#line 466
          do_assert(466);
          }
        }
#line 466
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 467
      cbread -= (size_t )ioffset;
    } else {
#line 461
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 472
    write_mtd(pfile);
    }
    {
#line 473
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 473
      if (! (! pfile->fwritten)) {
        {
#line 473
        do_assert(473);
        }
      }
#line 473
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 476
    base = (off_t )(((size_t )pfile->useroffset / cbread) * cbread);
#line 477
    if (base != pfile->deviceoffset) {
      {
#line 478
      tmp___0 = lseek(pfile->fd, base, 0);
      }
#line 478
      if (tmp___0 != base) {
        {
#line 479
        do_pdie((unsigned char const   *)"lseek(read)", (unsigned char const   *)pfile->pname);
        }
      }
#line 480
      pfile->deviceoffset = base;
    }
#line 482
    pfile->bufferoffset = base;
#line 483
    ioffset = 0;
  }
  {
#line 489
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 489
    if (! (pfile->bufferoffset <= pfile->useroffset)) {
      {
#line 489
      do_assert(489);
      }
    }
#line 489
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 490
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 490
    if (! ((size_t )pfile->useroffset < (size_t )pfile->bufferoffset + cbread)) {
      {
#line 490
      do_assert(490);
      }
    }
#line 490
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 491
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 491
    if (! (pfile->deviceoffset <= pfile->useroffset)) {
      {
#line 491
      do_assert(491);
      }
    }
#line 491
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 492
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 493
    tmp___1 = read(pfile->fd, (void *)(pfile->pbuf + ioffset), cbread);
#line 493
    cb = tmp___1;
    }
#line 494
    if (cb < 0L) {
      {
#line 494
      tmp___2 = __errno_location();
      }
      {
#line 495
      if (*tmp___2 == 4) {
#line 495
        goto case_4;
      }
#line 502
      if (*tmp___2 == 11) {
#line 502
        goto case_11;
      }
#line 504
      goto switch_default;
      case_4: /* CIL Label */ 
      {
#line 499
      tmp___3 = lseek(pfile->fd, pfile->deviceoffset, 0);
      }
#line 499
      if (tmp___3 != pfile->deviceoffset) {
        {
#line 500
        do_pdie((unsigned char const   *)"lseek(read reset)", (unsigned char const   *)pfile->pname);
        }
      }
#line 501
      goto switch_break;
      case_11: /* CIL Label */ 
#line 503
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 505
      do_pdie((unsigned char const   *)"read", (unsigned char const   *)pfile->pname);
      }
      switch_break: /* CIL Label */ ;
      }
    } else
#line 506
    if (cb == 0L) {
      {
#line 507
      do_die((unsigned char const   *)"unexpected end of file", (unsigned char const   *)pfile->pname);
      }
    } else {
#line 512
      if ((unsigned long )pfile->pwritebuf != (unsigned long )((unsigned char *)0)) {
        {
#line 513
        memcpy((void */* __restrict  */)(pfile->pwritebuf + ioffset), (void const   */* __restrict  */)(pfile->pbuf + ioffset),
               (size_t )cb);
        }
      }
#line 514
      cbread -= (size_t )cb;
#line 515
      ioffset = (int )((ssize_t )ioffset + cb);
#line 516
      pfile->deviceoffset += cb;
    }
#line 492
    if (cbread > 0UL) {
#line 492
      if (! (pfile->useroffset >= pfile->deviceoffset)) {
#line 492
        goto while_break___4;
      }
    } else {
#line 492
      goto while_break___4;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 520
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 520
    if (! (pfile->useroffset < pfile->deviceoffset)) {
      {
#line 520
      do_assert(520);
      }
    }
#line 520
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 521
  return;
}
}
#line 536 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
static unsigned char mtd_getb(mtd_file *pfile ) 
{ 
  unsigned char *tmp ;
  off_t tmp___0 ;

  {
  {
#line 537
  read_mtd(pfile);
  }
#line 538
  if (pfile->fwrite) {
#line 538
    tmp = pfile->pwritebuf;
  } else {
#line 538
    tmp = pfile->pbuf;
  }
#line 538
  tmp___0 = pfile->useroffset;
#line 538
  (pfile->useroffset) ++;
#line 538
  return (*(tmp + (tmp___0 - pfile->bufferoffset)));
}
}
#line 544 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
static void mtd_putb(mtd_file *pfile , unsigned long b ) 
{ 


  {
#line 545
  if (! pfile->fwrite) {
    {
#line 546
    do_die((unsigned char const   *)"file is not writeable", (unsigned char const   *)pfile->pname);
    }
  }
  {
#line 547
  read_mtd(pfile);
  }
#line 548
  if (b != (unsigned long )*(pfile->pwritebuf + (pfile->useroffset - pfile->bufferoffset))) {
#line 549
    *(pfile->pwritebuf + (pfile->useroffset - pfile->bufferoffset)) = (unsigned char )b;
#line 550
    pfile->fwritten = 1;
  }
#line 552
  (pfile->useroffset) ++;
#line 553
  return;
}
}
#line 559 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
static void mtd_readbytes(mtd_file *pfile , unsigned char *pbuf , size_t cb ) 
{ 
  size_t tmp ;
  int cbavail ;
  unsigned char *tmp___0 ;

  {
  {
#line 560
  tmp = size_mtd(pfile);
  }
#line 560
  if ((size_t )pfile->useroffset + cb > tmp) {
    {
#line 561
    do_die((unsigned char const   *)"read beyond end of file", (unsigned char const   *)pfile->pname);
    }
  }
  {
#line 563
  while (1) {
    while_continue: /* CIL Label */ ;
#line 563
    if (! (cb > 0UL)) {
#line 563
      goto while_break;
    }
    {
#line 566
    read_mtd(pfile);
#line 567
    cbavail = (int )(pfile->deviceoffset - pfile->useroffset);
    }
    {
#line 568
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 568
      if (cbavail > 0) {
#line 568
        if (! ((size_t )cbavail <= pfile->cbbuf)) {
          {
#line 568
          do_assert(568);
          }
        }
      } else {
        {
#line 568
        do_assert(568);
        }
      }
#line 568
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 569
    if ((size_t )cbavail > cb) {
#line 570
      cbavail = (int )cb;
    }
    {
#line 572
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 572
      if (! (pfile->useroffset >= pfile->bufferoffset)) {
        {
#line 572
        do_assert(572);
        }
      }
#line 572
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 573
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 573
      if (! (pfile->useroffset < pfile->deviceoffset)) {
        {
#line 573
        do_assert(573);
        }
      }
#line 573
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 574
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 574
      if (! ((size_t )pfile->deviceoffset <= (size_t )pfile->bufferoffset + pfile->cbbuf)) {
        {
#line 574
        do_assert(574);
        }
      }
#line 574
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 576
    if (pfile->fwrite) {
#line 576
      tmp___0 = pfile->pwritebuf;
    } else {
#line 576
      tmp___0 = pfile->pbuf;
    }
    {
#line 576
    memcpy((void */* __restrict  */)pbuf, (void const   */* __restrict  */)(tmp___0 + (pfile->useroffset - pfile->bufferoffset)),
           (size_t )cbavail);
#line 578
    pfile->useroffset += (off_t )cbavail;
#line 579
    pbuf += cbavail;
#line 580
    cb -= (size_t )cbavail;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 582
  return;
}
}
#line 589 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
static void mtd_writebytes(mtd_file *pfile , unsigned char const   *pbuf , size_t cb ) 
{ 
  size_t tmp ;
  int cbavail ;

  {
#line 590
  if (! pfile->fwrite) {
    {
#line 591
    do_die((unsigned char const   *)"file is not writeable", (unsigned char const   *)pfile->pname);
    }
  }
  {
#line 592
  tmp = size_mtd(pfile);
  }
#line 592
  if ((size_t )pfile->useroffset + cb > tmp) {
    {
#line 593
    do_die((unsigned char const   *)"write beyond end of file", (unsigned char const   *)pfile->pname);
    }
  }
  {
#line 594
  while (1) {
    while_continue: /* CIL Label */ ;
#line 594
    if (! (cb > 0UL)) {
#line 594
      goto while_break;
    }
    {
#line 600
    read_mtd(pfile);
#line 601
    cbavail = (int )(pfile->deviceoffset - pfile->useroffset);
    }
#line 602
    if ((size_t )cbavail > cb) {
#line 603
      cbavail = (int )cb;
    }
    {
#line 604
    memcpy((void */* __restrict  */)(pfile->pwritebuf + (pfile->useroffset - pfile->bufferoffset)),
           (void const   */* __restrict  */)pbuf, (size_t )cbavail);
#line 605
    pfile->fwritten = 1;
#line 606
    pfile->useroffset += (off_t )cbavail;
#line 607
    pbuf += cbavail;
#line 608
    cb -= (size_t )cbavail;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 610
  return;
}
}
#line 691 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
static void init_parse(parse_buf *pp , int fverify , int fprogress ) 
{ 
  int i ;

  {
  {
#line 693
  memset((void *)pp, 0, sizeof(*pp));
#line 694
  pp->fverify = fverify;
#line 695
  pp->fprogress = fprogress;
#line 696
  pp->cstack = 8;
#line 697
  pp->fbreak = 0;
#line 698
  pp->pfrom = (mtd_file *)0;
#line 699
  pp->pto = (mtd_file *)0;
#line 700
  i = 0;
  }
  {
#line 700
  while (1) {
    while_continue: /* CIL Label */ ;
#line 700
    if (! (i < 16)) {
#line 700
      goto while_break;
    }
    {
#line 701
    init_mtd(pp->files + i);
#line 700
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 702
  return;
}
}
#line 706
static  __attribute__((__noreturn__)) void quit(parse_buf *pp , int exit_code ) ;
#line 707
static  __attribute__((__noreturn__)) void quit(parse_buf *pp , int exit_code ) ;
#line 707 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
static void quit(parse_buf *pp , int exit_code ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 710
  i = 0;
  {
#line 710
  while (1) {
    while_continue: /* CIL Label */ ;
#line 710
    if (! (i < 16)) {
#line 710
      goto while_break;
    }
#line 711
    if ((unsigned long )pp->files[i].pname != (unsigned long )((unsigned char *)0)) {
      {
#line 712
      close_mtd(pp->files + i);
      }
    }
#line 710
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 715
  tmp = fflush(stdout);
  }
#line 715
  if (tmp == -1) {
    {
#line 716
    do_pdie((unsigned char const   *)"output failed", (unsigned char const   *)"stdout");
    }
  } else {
    {
#line 715
    tmp___0 = ferror(stdout);
    }
#line 715
    if (tmp___0) {
      {
#line 716
      do_pdie((unsigned char const   *)"output failed", (unsigned char const   *)"stdout");
      }
    } else {
      {
#line 715
      tmp___1 = fclose(stdout);
      }
#line 715
      if (tmp___1 == -1) {
        {
#line 716
        do_pdie((unsigned char const   *)"output failed", (unsigned char const   *)"stdout");
        }
      }
    }
  }
  {
#line 718
  exit(exit_code);
  }
}
}
#line 723 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
static unsigned char inb(parse_buf *pp ) 
{ 
  int b ;
  unsigned char tmp ;

  {
#line 725
  if ((unsigned long )pp->pfrom == (unsigned long )((mtd_file *)0)) {
    {
#line 726
    b = getchar();
    }
#line 727
    if (b == -1) {
      {
#line 728
      do_pdie((unsigned char const   *)"read error", (unsigned char const   *)"stdin");
      }
    }
  } else {
    {
#line 730
    tmp = mtd_getb(pp->pfrom);
#line 730
    b = (int )tmp;
    }
  }
#line 732
  return ((unsigned char )b);
}
}
#line 737 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
static void outb(parse_buf *pp , unsigned long b ) 
{ 
  int tmp ;

  {
#line 738
  if ((unsigned long )pp->pto == (unsigned long )((mtd_file *)0)) {
    {
#line 739
    tmp = putchar((int )b);
    }
#line 739
    if (tmp == -1) {
      {
#line 740
      do_pdie((unsigned char const   *)"write error", (unsigned char const   *)"stdout");
      }
    }
  } else {
    {
#line 742
    mtd_putb(pp->pto, b);
    }
  }
#line 744
  return;
}
}
#line 748 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
static void outputbytes(parse_buf *pp , char const   *pbuf , size_t cb ) 
{ 
  size_t tmp ;

  {
#line 749
  if ((unsigned long )pp->pto == (unsigned long )((mtd_file *)0)) {
    {
#line 750
    tmp = fwrite((void const   */* __restrict  */)pbuf, cb, (size_t )1, (FILE */* __restrict  */)stdout);
    }
#line 750
    if (tmp != 1UL) {
      {
#line 751
      do_pdie((unsigned char const   *)"write error", (unsigned char const   *)"stdout");
      }
    }
  } else {
    {
#line 753
    mtd_writebytes(pp->pto, (unsigned char const   *)pbuf, cb);
    }
  }
#line 754
  return;
}
}
#line 759 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
static void swapbytes(unsigned char *buf , size_t cb , size_t count ) 
{ 
  int i ;
  unsigned char tmp ;

  {
  {
#line 760
  while (1) {
    while_continue: /* CIL Label */ ;
#line 760
    if (! (cb >= count)) {
#line 760
      goto while_break;
    }
#line 762
    i = 0;
    {
#line 762
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 762
      if (! ((size_t )(i * 2) < count)) {
#line 762
        goto while_break___0;
      }
#line 763
      tmp = *(buf + i);
#line 764
      *(buf + i) = *(buf + ((count - (size_t )i) - 1UL));
#line 765
      *(buf + ((count - (size_t )i) - 1UL)) = tmp;
#line 762
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 767
    buf += count;
#line 768
    cb -= count;
  }
  while_break: /* CIL Label */ ;
  }
#line 770
  return;
}
}
#line 773 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
static void copybytes(parse_buf *pp , size_t cb , size_t count ) 
{ 
  size_t cbavail ;
  unsigned char buf[1024] ;
  size_t tmp ;

  {
  {
#line 774
  while (1) {
    while_continue: /* CIL Label */ ;
#line 774
    if (! (cb > 0UL)) {
#line 774
      goto while_break;
    }
#line 775
    cbavail = cb;
#line 777
    if (cbavail > sizeof(buf)) {
#line 778
      cbavail = sizeof(buf);
    }
#line 779
    if ((unsigned long )pp->pfrom == (unsigned long )((mtd_file *)0)) {
      {
#line 780
      tmp = fread((void */* __restrict  */)(buf), cbavail, (size_t )1, (FILE */* __restrict  */)stdin);
      }
#line 780
      if (tmp != 1UL) {
        {
#line 781
        do_pdie((unsigned char const   *)"read error", (unsigned char const   *)"stdin");
        }
      }
    } else {
      {
#line 783
      mtd_readbytes(pp->pfrom, buf, cbavail);
      }
    }
#line 785
    if (count > 1UL) {
      {
#line 786
      swapbytes(buf, cbavail, count);
      }
    }
    {
#line 788
    outputbytes(pp, (char const   *)(buf), cbavail);
#line 790
    cb -= cbavail;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 792
  return;
}
}
#line 796 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
static void fillbytes(parse_buf *pp , unsigned long val , size_t cb ) 
{ 
  unsigned char buf[1024] ;
  size_t cbavail ;

  {
  {
#line 798
  memset((void *)(buf), (int )val, sizeof(buf));
  }
  {
#line 800
  while (1) {
    while_continue: /* CIL Label */ ;
#line 800
    if (! (cb > 0UL)) {
#line 800
      goto while_break;
    }
#line 801
    cbavail = cb;
#line 802
    if (cbavail > sizeof(buf)) {
#line 803
      cbavail = sizeof(buf);
    }
    {
#line 805
    outputbytes(pp, (char const   *)(buf), cbavail);
#line 807
    cb -= cbavail;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 809
  return;
}
}
#line 813 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
static void push(parse_buf *pp , unsigned long num , unsigned char const   *str ) 
{ 
  int tmp ;

  {
#line 814
  if (pp->cstack >= 256) {
    {
#line 815
    do_die((unsigned char const   *)"stack overflow", str);
    }
  }
#line 816
  tmp = pp->cstack;
#line 816
  (pp->cstack) ++;
#line 816
  pp->stack[tmp] = num;
#line 817
  return;
}
}
#line 821 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
static void pop(parse_buf *pp , int num , unsigned char const   *str ) 
{ 


  {
#line 822
  if (pp->cstack < 8 + num) {
    {
#line 823
    do_die((unsigned char const   *)"stack underflow", str);
    }
  }
#line 824
  pp->cstack -= num;
#line 825
  return;
}
}
#line 828 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
static unsigned long top(parse_buf *pp , unsigned char const   *str ) 
{ 


  {
#line 829
  if (pp->cstack <= 8) {
    {
#line 830
    do_die((unsigned char const   *)"stack underflow", str);
    }
  }
#line 831
  (pp->cstack) --;
#line 831
  return (pp->stack[pp->cstack]);
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
static void op(parse_buf *pp , int numpop , unsigned long num , unsigned char const   *str ) 
{ 


  {
  {
#line 838
  pop(pp, numpop, str);
#line 839
  push(pp, num, str);
  }
#line 840
  return;
}
}
#line 847 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
static int parse_expression(parse_buf *pp , unsigned char const   *line , int Ac ,
                            int AcEnd ) 
{ 
  int SP ;
  int fnoexec ;
  int test ;
  int stack[16] ;
  unsigned char const   *lp ;
  unsigned char ch ;
  int tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  char *end ;
  unsigned long num ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  unsigned long left ;
  unsigned long right ;
  unsigned long tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  __dev_t tmp___9 ;
  unsigned char tmp___10 ;
  unsigned short const   **tmp___11 ;
  unsigned short const   **tmp___12 ;

  {
#line 848
  SP = 0;
#line 848
  fnoexec = 0;
#line 848
  test = 0;
  {
#line 851
  while (1) {
    while_continue: /* CIL Label */ ;
#line 851
    if (! (Ac < AcEnd)) {
#line 851
      goto while_break;
    }
#line 852
    lp = line + Ac;
#line 853
    ch = (unsigned char )*lp;
    {
#line 858
    if ((int )ch == 40) {
#line 858
      goto case_40;
    }
#line 869
    if ((int )ch == 91) {
#line 869
      goto case_91;
    }
#line 885
    if ((int )ch == 58) {
#line 885
      goto case_58;
    }
#line 919
    if ((int )ch == 41) {
#line 919
      goto case_41;
    }
#line 960
    if ((int )ch == 10) {
#line 960
      goto case_10;
    }
#line 960
    if ((int )ch == 59) {
#line 960
      goto case_10;
    }
#line 972
    if ((int )ch == 44) {
#line 972
      goto case_44;
    }
#line 972
    if ((int )ch == 11) {
#line 972
      goto case_44;
    }
#line 972
    if ((int )ch == 9) {
#line 972
      goto case_44;
    }
#line 972
    if ((int )ch == 13) {
#line 972
      goto case_44;
    }
#line 972
    if ((int )ch == 12) {
#line 972
      goto case_44;
    }
#line 972
    if ((int )ch == 32) {
#line 972
      goto case_44;
    }
#line 980
    goto switch_default;
    case_40: /* CIL Label */ 
#line 859
    if (SP >= 16) {
      {
#line 860
      do_die((unsigned char const   *)"() stack overflow", lp);
      }
    }
#line 861
    tmp = SP;
#line 861
    SP ++;
#line 861
    stack[tmp] = Ac;
#line 862
    if (fnoexec) {
#line 863
      fnoexec += 3;
    } else {
      {
#line 865
      tmp___0 = top(pp, lp);
#line 865
      fnoexec = tmp___0 == 0UL;
      }
    }
#line 867
    goto switch_break;
    case_91: /* CIL Label */ 
#line 871
    if (fnoexec <= 2) {
#line 875
      if (test != 0) {
#line 876
        goto badnest;
      } else
#line 875
      if (SP <= 0) {
#line 876
        goto badnest;
      }
#line 878
      test = Ac + 1;
#line 880
      if (fnoexec == 0) {
#line 881
        fnoexec = 2;
      }
    }
#line 883
    goto switch_break;
    case_58: /* CIL Label */ 
#line 891
    if (fnoexec <= 2) {
#line 892
      if (test == 0) {
#line 893
        goto badnest;
      } else
#line 892
      if (SP <= 0) {
#line 893
        goto badnest;
      }
      {
#line 895
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 895
        if (! (fnoexec > 0)) {
          {
#line 895
          do_assert(895);
          }
        }
#line 895
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 896
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 896
        if (! (! pp->fbreak)) {
          {
#line 896
          do_assert(896);
          }
        }
#line 896
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 900
      if (fnoexec == 1) {
        {
#line 906
        parse_expression(pp, line, test, Ac);
        }
#line 907
        if (pp->fbreak) {
#line 908
          fnoexec = 3;
#line 909
          pp->fbreak = 0;
        } else {
          {
#line 911
          tmp___1 = top(pp, lp);
#line 911
          fnoexec = tmp___1 == 0UL;
          }
        }
      }
#line 915
      test = 0;
    }
#line 917
    goto switch_break;
    case_41: /* CIL Label */ 
#line 921
    if (SP <= 0) {
#line 922
      goto badnest;
    }
#line 923
    SP --;
#line 928
    if (fnoexec > 2) {
#line 929
      fnoexec -= 3;
    } else {
#line 932
      if (test == 0) {
#line 933
        goto badnest;
      }
#line 936
      fnoexec = 0;
      {
#line 937
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 937
        if (! (! pp->fbreak)) {
          {
#line 937
          do_assert(937);
          }
        }
#line 937
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 943
      parse_expression(pp, line, test, Ac);
      }
#line 944
      if (pp->fbreak) {
#line 945
        pp->fbreak = 0;
      } else {
        {
#line 946
        tmp___2 = top(pp, lp);
        }
#line 946
        if (tmp___2 != 0UL) {
#line 947
          Ac = stack[SP] - 1;
        }
      }
#line 951
      test = 0;
    }
#line 953
    goto switch_break;
    badnest: 
    {
#line 956
    do_die((unsigned char const   *)"bad [: or [) nesting", lp);
    }
#line 957
    goto switch_break;
    case_10: /* CIL Label */ 
    case_59: /* CIL Label */ 
#line 964
    Ac ++;
#line 965
    goto end;
    case_44: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 974
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 981
    if (fnoexec) {
#line 982
      goto switch_break;
    }
    {
#line 984
    tmp___12 = __ctype_b_loc();
    }
#line 984
    if ((int const   )*(*tmp___12 + (int )ch) & 256) {
      {
#line 985
      push(pp, pp->variables[ch], lp);
      }
    } else {
      {
#line 986
      tmp___11 = __ctype_b_loc();
      }
#line 986
      if ((int const   )*(*tmp___11 + (int )ch) & 2048) {
        {
#line 987
        end = (char *)lp;
#line 989
        tmp___3 = __errno_location();
#line 989
        *tmp___3 = 0;
#line 990
        num = strtoul((char const   */* __restrict  */)lp, (char **/* __restrict  */)(& end),
                      0);
        }
#line 991
        if (num == 0xffffffffffffffffUL) {
          {
#line 991
          tmp___4 = __errno_location();
          }
#line 991
          if (*tmp___4 == 22) {
            {
#line 992
            do_pdie((unsigned char const   *)"invalid number", lp);
            }
          } else {
            {
#line 991
            tmp___5 = __errno_location();
            }
#line 991
            if (*tmp___5 == 34) {
              {
#line 992
              do_pdie((unsigned char const   *)"invalid number", lp);
              }
            }
          }
        }
        {
#line 993
        push(pp, num, lp);
#line 997
        Ac = (int )(((unsigned char const   *)end - line) - 1L);
        }
      } else {
#line 1003
        left = pp->stack[pp->cstack - 2];
#line 1004
        right = pp->stack[pp->cstack - 1];
        {
#line 1007
        if ((int )ch == 63) {
#line 1007
          goto case_63;
        }
#line 1024
        if ((int )ch == 42) {
#line 1024
          goto case_42;
        }
#line 1025
        if ((int )ch == 43) {
#line 1025
          goto case_43;
        }
#line 1026
        if ((int )ch == 45) {
#line 1026
          goto case_45;
        }
#line 1027
        if ((int )ch == 47) {
#line 1027
          goto case_47;
        }
#line 1028
        if ((int )ch == 37) {
#line 1028
          goto case_37;
        }
#line 1029
        if ((int )ch == 60) {
#line 1029
          goto case_60;
        }
#line 1030
        if ((int )ch == 62) {
#line 1030
          goto case_62;
        }
#line 1031
        if ((int )ch == 124) {
#line 1031
          goto case_124;
        }
#line 1032
        if ((int )ch == 38) {
#line 1032
          goto case_38;
        }
#line 1033
        if ((int )ch == 94) {
#line 1033
          goto case_94;
        }
#line 1034
        if ((int )ch == 126) {
#line 1034
          goto case_126;
        }
#line 1035
        if ((int )ch == 33) {
#line 1035
          goto case_33;
        }
#line 1036
        if ((int )ch == 61) {
#line 1036
          goto case_61;
        }
#line 1039
        if ((int )ch == 123) {
#line 1039
          goto case_123;
        }
#line 1042
        if ((int )ch == 125) {
#line 1042
          goto case_125;
        }
#line 1045
        if ((int )ch == 114) {
#line 1045
          goto case_114;
        }
#line 1048
        if ((int )ch == 101) {
#line 1048
          goto case_101;
        }
#line 1051
        if ((int )ch == 109) {
#line 1051
          goto case_109;
        }
#line 1054
        if ((int )ch == 36) {
#line 1054
          goto case_36;
        }
#line 1059
        if ((int )ch == 102) {
#line 1059
          goto case_102;
        }
#line 1064
        if ((int )ch == 35) {
#line 1064
          goto case_35;
        }
#line 1069
        if ((int )ch == 116) {
#line 1069
          goto case_116;
        }
#line 1074
        if ((int )ch == 100) {
#line 1074
          goto case_100;
        }
#line 1080
        if ((int )ch == 111) {
#line 1080
          goto case_111;
        }
#line 1085
        if ((int )ch == 105) {
#line 1085
          goto case_105;
        }
#line 1090
        if ((int )ch == 64) {
#line 1090
          goto case_64;
        }
#line 1093
        if ((int )ch == 98) {
#line 1093
          goto case_98;
        }
#line 1097
        if ((int )ch == 108) {
#line 1097
          goto case_108;
        }
#line 1100
        if ((int )ch == 46) {
#line 1100
          goto case_46;
        }
#line 1103
        if ((int )ch == 112) {
#line 1103
          goto case_112;
        }
#line 1106
        if ((int )ch == 115) {
#line 1106
          goto case_115;
        }
#line 1111
        goto switch_default___0;
        case_63: /* CIL Label */ 
        {
#line 1013
        tmp___6 = top(pp, lp);
        }
#line 1013
        if (tmp___6 != 0UL) {
#line 1017
          fnoexec = 3;
        }
#line 1019
        goto switch_break___0;
        case_42: /* CIL Label */ 
        {
#line 1024
        op(pp, 2, left * right, lp);
        }
#line 1024
        goto switch_break___0;
        case_43: /* CIL Label */ 
        {
#line 1025
        op(pp, 2, left + right, lp);
        }
#line 1025
        goto switch_break___0;
        case_45: /* CIL Label */ 
        {
#line 1026
        op(pp, 2, left - right, lp);
        }
#line 1026
        goto switch_break___0;
        case_47: /* CIL Label */ 
        {
#line 1027
        op(pp, 2, left / right, lp);
        }
#line 1027
        goto switch_break___0;
        case_37: /* CIL Label */ 
        {
#line 1028
        op(pp, 2, left % right, lp);
        }
#line 1028
        goto switch_break___0;
        case_60: /* CIL Label */ 
        {
#line 1029
        op(pp, 2, (unsigned long )(left < right), lp);
        }
#line 1029
        goto switch_break___0;
        case_62: /* CIL Label */ 
        {
#line 1030
        op(pp, 2, (unsigned long )(left > right), lp);
        }
#line 1030
        goto switch_break___0;
        case_124: /* CIL Label */ 
        {
#line 1031
        op(pp, 2, left | right, lp);
        }
#line 1031
        goto switch_break___0;
        case_38: /* CIL Label */ 
        {
#line 1032
        op(pp, 2, left & right, lp);
        }
#line 1032
        goto switch_break___0;
        case_94: /* CIL Label */ 
        {
#line 1033
        op(pp, 2, left ^ right, lp);
        }
#line 1033
        goto switch_break___0;
        case_126: /* CIL Label */ 
        {
#line 1034
        op(pp, 1, ~ right, lp);
        }
#line 1034
        goto switch_break___0;
        case_33: /* CIL Label */ 
        {
#line 1035
        op(pp, 1, (unsigned long )(! right), lp);
        }
#line 1035
        goto switch_break___0;
        case_61: /* CIL Label */ 
        {
#line 1037
        op(pp, 2, (unsigned long )(left == right), lp);
        }
#line 1038
        goto switch_break___0;
        case_123: /* CIL Label */ 
        {
#line 1040
        op(pp, 2, left << right, lp);
        }
#line 1041
        goto switch_break___0;
        case_125: /* CIL Label */ 
        {
#line 1043
        op(pp, 2, left >> right, lp);
        }
#line 1044
        goto switch_break___0;
        case_114: /* CIL Label */ 
        {
#line 1046
        op(pp, 2, (left >> right) + (left << (32UL - right)), lp);
        }
#line 1047
        goto switch_break___0;
        case_101: /* CIL Label */ 
        {
#line 1049
        op(pp, 2, (unsigned long )((long )(left << (32UL - right)) >> (32UL - right)),
           lp);
        }
#line 1050
        goto switch_break___0;
        case_109: /* CIL Label */ 
        {
#line 1052
        op(pp, 2, (left << (32UL - right)) >> (32UL - right), lp);
        }
#line 1053
        goto switch_break___0;
        case_36: /* CIL Label */ 
#line 1055
        if ((unsigned long )pp->pfrom == (unsigned long )((mtd_file *)0)) {
          {
#line 1056
          do_die((unsigned char const   *)"size of input unknown", lp);
          }
        }
        {
#line 1057
        tmp___7 = size_mtd(pp->pfrom);
#line 1057
        push(pp, tmp___7, lp);
        }
#line 1058
        goto switch_break___0;
        case_102: /* CIL Label */ 
#line 1060
        if ((unsigned long )pp->pfrom == (unsigned long )((mtd_file *)0)) {
          {
#line 1061
          do_die((unsigned char const   *)"position of input unknown", lp);
          }
        }
        {
#line 1062
        push(pp, (unsigned long )(pp->pfrom)->useroffset, lp);
        }
#line 1063
        goto switch_break___0;
        case_35: /* CIL Label */ 
#line 1065
        if ((unsigned long )pp->pto == (unsigned long )((mtd_file *)0)) {
          {
#line 1066
          do_die((unsigned char const   *)"size of output unknown", lp);
          }
        }
        {
#line 1067
        tmp___8 = size_mtd(pp->pto);
#line 1067
        push(pp, tmp___8, lp);
        }
#line 1068
        goto switch_break___0;
        case_116: /* CIL Label */ 
#line 1070
        if ((unsigned long )pp->pto == (unsigned long )((mtd_file *)0)) {
          {
#line 1071
          do_die((unsigned char const   *)"position of output unknown", lp);
          }
        }
        {
#line 1072
        push(pp, (unsigned long )(pp->pto)->useroffset, lp);
        }
#line 1073
        goto switch_break___0;
        case_100: /* CIL Label */ 
#line 1075
        if ((unsigned long )pp->pfrom == (unsigned long )((mtd_file *)0)) {
          {
#line 1076
          do_die((unsigned char const   *)"input device number unknown", lp);
          }
        }
#line 1077
        if ((pp->pfrom)->stat.st_rdev == 0UL) {
#line 1077
          tmp___9 = (pp->pfrom)->stat.st_dev;
        } else {
#line 1077
          tmp___9 = (pp->pfrom)->stat.st_rdev;
        }
        {
#line 1077
        push(pp, tmp___9, lp);
        }
#line 1079
        goto switch_break___0;
        case_111: /* CIL Label */ 
#line 1081
        if ((unsigned long )pp->pto == (unsigned long )((mtd_file *)0)) {
          {
#line 1082
          do_die((unsigned char const   *)"output block size unknown", lp);
          }
        }
        {
#line 1083
        push(pp, (unsigned long )(pp->pto)->stat.st_blksize, lp);
        }
#line 1084
        goto switch_break___0;
        case_105: /* CIL Label */ 
#line 1086
        if ((unsigned long )pp->pfrom == (unsigned long )((mtd_file *)0)) {
          {
#line 1087
          do_die((unsigned char const   *)"input block size unknown", lp);
          }
        }
        {
#line 1088
        push(pp, (unsigned long )(pp->pfrom)->stat.st_blksize, lp);
        }
#line 1089
        goto switch_break___0;
        case_64: /* CIL Label */ 
        {
#line 1091
        tmp___10 = inb(pp);
#line 1091
        push(pp, (unsigned long )tmp___10, lp);
        }
#line 1092
        goto switch_break___0;
        case_98: /* CIL Label */ 
        {
#line 1095
        parse_expression(pp, (unsigned char const   *)"@8{@+8{@+8{@+;# 4 byte big-endian read",
                         0, (int )(sizeof("@8{@+8{@+8{@+;# 4 byte big-endian read") - 1UL));
        }
#line 1096
        goto switch_break___0;
        case_108: /* CIL Label */ 
        {
#line 1098
        parse_expression(pp, (unsigned char const   *)"@@@@8{+8{+8{+;# 4 byte little-endian read",
                         0, (int )(sizeof("@@@@8{+8{+8{+;# 4 byte little-endian read") - 1UL));
        }
#line 1099
        goto switch_break___0;
        case_46: /* CIL Label */ 
        {
#line 1101
        push(pp, right, lp);
        }
#line 1102
        goto switch_break___0;
        case_112: /* CIL Label */ 
        {
#line 1104
        pop(pp, 1, lp);
        }
#line 1105
        goto switch_break___0;
        case_115: /* CIL Label */ 
        {
#line 1107
        pop(pp, 2, lp);
#line 1108
        push(pp, right, lp);
#line 1109
        push(pp, left, lp);
        }
#line 1110
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
        {
#line 1112
        do_die((unsigned char const   *)"invalid operator", lp);
        }
        switch_break___0: /* CIL Label */ ;
        }
      }
    }
    switch_break: /* CIL Label */ ;
    }
#line 851
    Ac ++;
  }
  while_break: /* CIL Label */ ;
  }
  end: 
#line 1123
  if (SP > 0) {
    {
#line 1124
    do_die((unsigned char const   *)"unclosed ( )", line);
    }
  }
  {
#line 1125
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1125
    if (! (fnoexec == 0)) {
#line 1125
      if (! (fnoexec == 3)) {
        {
#line 1125
        do_assert(1125);
        }
      }
    }
#line 1125
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1126
  if (fnoexec == 3) {
#line 1127
    pp->fbreak = 1;
  }
#line 1128
  return (Ac);
}
}
#line 1133 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
static int need(parse_buf *pp , unsigned long *arg , unsigned char const   *line ,
                int Ac , int AcEnd , int num ) 
{ 
  int Acnew ;
  int tmp ;

  {
  {
#line 1135
  tmp = parse_expression(pp, line, Ac, AcEnd);
#line 1135
  Acnew = tmp;
  }
  {
#line 1137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1137
    if (! (num <= 2)) {
      {
#line 1137
      do_assert(1137);
      }
    }
#line 1137
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1138
  if (pp->cstack < 8 + num) {
    {
#line 1139
    do_die((unsigned char const   *)"too few arguments", line + Ac);
    }
  }
  {
#line 1141
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1141
    if (! (num > 0)) {
#line 1141
      goto while_break___0;
    }
#line 1142
    num --;
#line 1142
    (pp->cstack) --;
#line 1142
    *(arg + num) = pp->stack[pp->cstack];
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1145
  pp->fbreak = 0;
#line 1146
  return (Acnew);
}
}
#line 1156 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
static int string(unsigned char *buffer , unsigned char const   *line , int Ac ) 
{ 
  int start ;
  int end ;
  unsigned short const   **tmp ;
  unsigned char quote ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 1159
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1159
    tmp = __ctype_b_loc();
    }
#line 1159
    if ((int const   )*(*tmp + (int )*(line + Ac)) & 8192) {
#line 1159
      if (! ((int const   )*(line + Ac) != 10)) {
#line 1159
        goto while_break;
      }
    } else {
#line 1159
      goto while_break;
    }
#line 1159
    Ac ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1161
  if ((int const   )*(line + Ac) == 34) {
#line 1161
    goto _L;
  } else
#line 1161
  if ((int const   )*(line + Ac) == 39) {
    _L: /* CIL Label */ 
#line 1162
    quote = (unsigned char )*(line + Ac);
#line 1163
    start = Ac;
#line 1164
    end = Ac + 1;
    {
#line 1165
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1165
      if ((int const   )*(line + end) != 0) {
#line 1165
        if ((int const   )*(line + end) != 10) {
#line 1165
          if (! ((int const   )*(line + end) != (int const   )quote)) {
#line 1165
            goto while_break___0;
          }
        } else {
#line 1165
          goto while_break___0;
        }
      } else {
#line 1165
        goto while_break___0;
      }
#line 1165
      end ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1166
    if ((int const   )*(line + end) != (int const   )quote) {
      {
#line 1167
      do_die((unsigned char const   *)"unterminated quoted string", line + start);
      }
    }
#line 1168
    Ac = end + 1;
    {
#line 1169
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1169
      tmp___0 = __ctype_b_loc();
      }
#line 1169
      if ((int const   )*(*tmp___0 + (int )*(line + Ac)) & 8192) {
#line 1169
        if (! ((int const   )*(line + Ac) != 10)) {
#line 1169
          goto while_break___1;
        }
      } else {
#line 1169
        goto while_break___1;
      }
#line 1169
      Ac ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1170
    if ((int const   )*(line + Ac) != 0) {
#line 1170
      if ((int const   )*(line + Ac) != 59) {
#line 1170
        if ((int const   )*(line + Ac) != 10) {
          {
#line 1171
          do_die((unsigned char const   *)"stuff on line after quoted string", line + start);
          }
        }
      }
    }
#line 1172
    start ++;
  } else {
#line 1174
    start = Ac;
    {
#line 1175
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1175
      if ((int const   )*(line + Ac) != 0) {
#line 1175
        if ((int const   )*(line + Ac) != 59) {
#line 1175
          if (! ((int const   )*(line + Ac) != 10)) {
#line 1175
            goto while_break___2;
          }
        } else {
#line 1175
          goto while_break___2;
        }
      } else {
#line 1175
        goto while_break___2;
      }
#line 1175
      Ac ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1176
    end = Ac;
  }
#line 1179
  end -= start;
#line 1180
  if (end >= 4096) {
    {
#line 1181
    do_die((unsigned char const   *)"string too long", line + start);
    }
  }
  {
#line 1184
  memcpy((void */* __restrict  */)buffer, (void const   */* __restrict  */)(line + start),
         (size_t )end);
#line 1185
  *(buffer + end) = (unsigned char)0;
  }
#line 1188
  if ((int const   )*(line + Ac) != 0) {
#line 1188
    Ac ++;
  }
#line 1189
  return (Ac);
}
}
#line 1194 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
static int eol(unsigned char const   *line , int Ac ) 
{ 
  unsigned char quote ;

  {
#line 1195
  quote = (unsigned char)0;
  {
#line 1196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1196
    if ((int const   )*(line + Ac) != 10) {
#line 1196
      if (! ((int const   )*(line + Ac) != 59)) {
#line 1196
        if (! quote) {
#line 1196
          goto while_break;
        }
      }
    } else {
#line 1196
      goto while_break;
    }
#line 1197
    if ((int const   )*(line + Ac) == 0) {
#line 1198
      return (Ac);
    }
#line 1199
    if ((int const   )*(line + Ac) == 34) {
#line 1199
      goto _L;
    } else
#line 1199
    if ((int const   )*(line + Ac) == 34) {
      _L: /* CIL Label */ 
#line 1200
      if ((int )quote == 0) {
#line 1201
        quote = (unsigned char )*(line + Ac);
      } else
#line 1202
      if ((int )quote == (int )*(line + Ac)) {
#line 1203
        quote = (unsigned char)0;
      }
    }
#line 1205
    Ac ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1207
  return (Ac + 1);
}
}
#line 1212 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
static mtd_file *find_file(parse_buf *pp , unsigned char const   *name ) 
{ 
  int i ;
  int tmp ;

  {
#line 1214
  i = 0;
  {
#line 1214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1214
    if (! (i < 16)) {
#line 1214
      goto while_break;
    }
#line 1215
    if ((unsigned long )pp->files[i].pname != (unsigned long )((unsigned char *)0)) {
      {
#line 1215
      tmp = strcmp((char const   *)name, (char const   *)pp->files[i].pname);
      }
#line 1215
      if (tmp == 0) {
#line 1217
        return (pp->files + i);
      }
    }
#line 1214
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1219
  return ((mtd_file *)0);
}
}
#line 1224 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
static mtd_file *open_file(parse_buf *pp , unsigned char const   *name , int fwrite___0 ) 
{ 
  int i ;

  {
#line 1226
  i = 0;
  {
#line 1226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1226
    if (! (i < 16)) {
#line 1226
      goto while_break;
    }
#line 1227
    if ((unsigned long )pp->files[i].pname == (unsigned long )((unsigned char *)0)) {
#line 1228
      goto while_break;
    }
#line 1226
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1229
  if (i >= 16) {
    {
#line 1230
    do_die((unsigned char const   *)"no more files", name);
    }
  }
  {
#line 1231
  open_mtd(pp->files + i, (char const   *)name, fwrite___0, pp->fverify, pp->fprogress);
  }
#line 1232
  return (pp->files + i);
}
}
#line 1240 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
static void parse(parse_buf *pp , int lines , char const   **prog ) 
{ 
  int Al ;
  int SP ;
  int fnoexec ;
  struct stack stack[16] ;
  int Ac ;
  unsigned char const   *line ;
  int AcEnd ;
  size_t tmp ;
  unsigned char const   *lp ;
  unsigned char ch ;
  unsigned long arg[2] ;
  unsigned char buffer[4096] ;
  int tmp___0 ;
  mtd_file *pfile ;
  mtd_file *tmp___1 ;
  mtd_file *pfile___0 ;
  mtd_file *tmp___2 ;
  mtd_file *pfile___1 ;
  mtd_file *tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  unsigned long *stack___0 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;

  {
#line 1245
  Al = 0;
#line 1245
  SP = 0;
#line 1245
  fnoexec = 0;
  {
#line 1265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1265
    if (! (Al < lines)) {
#line 1265
      goto while_break;
    }
    {
#line 1266
    Ac = 0;
#line 1267
    line = (unsigned char const   *)*(prog + Al);
#line 1268
    tmp = strlen((char const   *)line);
#line 1268
    AcEnd = (int )tmp;
    }
    {
#line 1270
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1270
      if (! *(line + Ac)) {
#line 1270
        goto while_break___0;
      }
      {
#line 1271
      lp = line + Ac;
#line 1272
      ch = (unsigned char )*lp;
#line 1278
      tmp___7 = __ctype_b_loc();
      }
#line 1278
      if ((int const   )*(*tmp___7 + (int )ch) & 8192) {
#line 1279
        Ac ++;
      } else
#line 1278
      if ((int )ch == 59) {
#line 1279
        Ac ++;
      } else
#line 1280
      if ((int )ch != 36) {
#line 1280
        if (fnoexec) {
          {
#line 1284
          Ac = eol(line, Ac);
          }
        } else {
#line 1280
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1280
      if ((int )ch == 35) {
        {
#line 1284
        Ac = eol(line, Ac);
        }
      } else {
        {
#line 1293
        if (((int )ch << 8) + (int )*(line + (Ac + 1)) == (36 << 8) + 40) {
#line 1293
          goto case_exp;
        }
#line 1306
        if (((int )ch << 8) + (int )*(line + (Ac + 1)) == (36 << 8) + 58) {
#line 1306
          goto case_exp___0;
        }
#line 1322
        if (((int )ch << 8) + (int )*(line + (Ac + 1)) == (36 << 8) + 41) {
#line 1322
          goto case_exp___1;
        }
#line 1351
        if (((int )ch << 8) + (int )*(line + (Ac + 1)) == (36 << 8) + 63) {
#line 1351
          goto case_exp___2;
        }
#line 1373
        if (((int )ch << 8) + (int )*(line + (Ac + 1)) == (33 << 8) + 63) {
#line 1373
          goto case_exp___3;
        }
#line 1379
        if (((int )ch << 8) + (int )*(line + (Ac + 1)) == (33 << 8) + 33) {
#line 1379
          goto case_exp___4;
        }
#line 1385
        if (((int )ch << 8) + (int )*(line + (Ac + 1)) == (62 << 8) + 62) {
#line 1385
          goto case_exp___5;
        }
#line 1398
        if (((int )ch << 8) + (int )*(line + (Ac + 1)) == (60 << 8) + 60) {
#line 1398
          goto case_exp___6;
        }
#line 1410
        if (((int )ch << 8) + (int )*(line + (Ac + 1)) == (62 << 8) + 60) {
#line 1410
          goto case_exp___7;
        }
#line 1410
        if (((int )ch << 8) + (int )*(line + (Ac + 1)) == (60 << 8) + 62) {
#line 1410
          goto case_exp___7;
        }
#line 1426
        if (((int )ch << 8) + (int )*(line + (Ac + 1)) == (62 << 8) + 61) {
#line 1426
          goto case_exp___9;
        }
#line 1433
        if (((int )ch << 8) + (int )*(line + (Ac + 1)) == (60 << 8) + 61) {
#line 1433
          goto case_exp___10;
        }
#line 1441
        if (((int )ch << 8) + (int )*(line + (Ac + 1)) == (119 << 8) + 98) {
#line 1441
          goto case_exp___11;
        }
#line 1453
        if (((int )ch << 8) + (int )*(line + (Ac + 1)) == (119 << 8) + 108) {
#line 1453
          goto case_exp___12;
        }
#line 1465
        if (((int )ch << 8) + (int )*(line + (Ac + 1)) == (119 << 8) + 115) {
#line 1465
          goto case_exp___13;
        }
#line 1470
        if (((int )ch << 8) + (int )*(line + (Ac + 1)) == (102 << 8) + 98) {
#line 1470
          goto case_exp___14;
        }
#line 1485
        if (((int )ch << 8) + (int )*(line + (Ac + 1)) == (99 << 8) + 112) {
#line 1485
          goto case_exp___15;
        }
#line 1490
        if (((int )ch << 8) + (int )*(line + (Ac + 1)) == (120 << 8) + 112) {
#line 1490
          goto case_exp___16;
        }
#line 1500
        if (((int )ch << 8) + (int )*(line + (Ac + 1)) == (112 << 8) + 114) {
#line 1500
          goto case_exp___17;
        }
#line 1508
        if (((int )ch << 8) + (int )*(line + (Ac + 1)) == (112 << 8) + 102) {
#line 1508
          goto case_exp___18;
        }
#line 1521
        if (((int )ch << 8) + (int )*(line + (Ac + 1)) == (112 << 8) + 110) {
#line 1521
          goto case_exp___19;
        }
#line 1527
        if (((int )ch << 8) + (int )*(line + (Ac + 1)) == (46 << 8) + 61) {
#line 1527
          goto case_exp___20;
        }
#line 1531
        goto switch_default___1;
        case_exp: /* CIL Label */ 
#line 1294
        if (SP >= 16) {
          {
#line 1295
          do_die((unsigned char const   *)"exec stack overflow", lp);
          }
        }
#line 1296
        stack[SP].Al = Al;
#line 1297
        tmp___0 = SP;
#line 1297
        SP ++;
#line 1297
        stack[tmp___0].Ac = Ac;
#line 1298
        if (fnoexec) {
#line 1299
          fnoexec += 3;
#line 1300
          goto noexec;
        }
        {
#line 1302
        Ac = need(pp, (unsigned long *)(arg), line, Ac + 2, AcEnd, 1);
#line 1303
        fnoexec = arg[0] == 0UL;
        }
#line 1304
        goto switch_break;
        case_exp___0: /* CIL Label */ 
#line 1310
        if (SP <= 0) {
#line 1311
          goto underflow;
        }
#line 1312
        if (fnoexec != 1) {
#line 1314
          if (fnoexec == 0) {
#line 1315
            fnoexec = 2;
          }
#line 1316
          goto noexec;
        }
        {
#line 1318
        Ac = need(pp, (unsigned long *)(arg), line, Ac + 2, AcEnd, 1);
#line 1319
        fnoexec = arg[0] == 0UL;
        }
#line 1320
        goto switch_break;
        case_exp___1: /* CIL Label */ 
#line 1324
        if (SP <= 0) {
#line 1325
          goto underflow;
        }
#line 1326
        SP --;
#line 1331
        if (fnoexec > 2) {
#line 1332
          fnoexec -= 3;
#line 1333
          goto noexec;
        }
        {
#line 1335
        fnoexec = 0;
#line 1339
        Ac = need(pp, (unsigned long *)(arg), line, Ac + 2, AcEnd, 1);
        }
#line 1340
        if (arg[0] != 0UL) {
#line 1341
          Al = stack[SP].Al;
#line 1342
          Ac = stack[SP].Ac;
#line 1347
          line = (unsigned char const   *)*(prog + Al);
        }
#line 1349
        goto switch_break;
        case_exp___2: /* CIL Label */ 
#line 1352
        if (SP <= 0) {
#line 1353
          goto underflow;
        }
#line 1354
        if (fnoexec) {
#line 1355
          goto noexec;
        }
        {
#line 1356
        Ac = need(pp, (unsigned long *)(arg), line, Ac + 2, AcEnd, 1);
        }
#line 1357
        if (arg[0] != 0UL) {
#line 1361
          fnoexec = 3;
        }
#line 1363
        goto switch_break;
        underflow: 
        {
#line 1366
        do_die((unsigned char const   *)"exec stack underflow", lp);
        }
        noexec: 
        {
#line 1369
        Ac = eol(line, Ac);
        }
#line 1370
        goto switch_break;
        case_exp___3: /* CIL Label */ 
        {
#line 1374
        Ac = need(pp, (unsigned long *)(arg), line, Ac + 2, AcEnd, 1);
        }
#line 1375
        if (arg[0] != 0UL) {
          {
#line 1376
          quit(pp, (int )arg[0]);
          }
        }
#line 1377
        goto switch_break;
        case_exp___4: /* CIL Label */ 
        {
#line 1380
        Ac = need(pp, (unsigned long *)(arg), line, Ac + 2, AcEnd, 1);
#line 1381
        quit(pp, (int )arg[0]);
        }
#line 1382
        goto switch_break;
        case_exp___5: /* CIL Label */ 
        {
#line 1386
        Ac = string(buffer, line, Ac + 2);
        }
#line 1387
        if ((int )buffer[0] != 0) {
          {
#line 1388
          tmp___1 = find_file(pp, (unsigned char const   *)(buffer));
#line 1388
          pfile = tmp___1;
          }
#line 1389
          if ((unsigned long )pfile == (unsigned long )((mtd_file *)0)) {
            {
#line 1390
            pfile = open_file(pp, (unsigned char const   *)(buffer), 1);
            }
          } else
#line 1391
          if (! pfile->fwrite) {
            {
#line 1392
            do_die((unsigned char const   *)"attempt to open a read file for write",
                   (unsigned char const   *)(buffer));
            }
          }
#line 1393
          pp->pto = pfile;
        } else {
#line 1395
          pp->pto = (mtd_file *)0;
        }
#line 1396
        goto switch_break;
        case_exp___6: /* CIL Label */ 
        {
#line 1399
        Ac = string(buffer, line, Ac + 2);
        }
#line 1400
        if ((int )buffer[0] != 0) {
          {
#line 1401
          tmp___2 = find_file(pp, (unsigned char const   *)(buffer));
#line 1401
          pfile___0 = tmp___2;
          }
#line 1402
          if ((unsigned long )pfile___0 == (unsigned long )((mtd_file *)0)) {
            {
#line 1403
            pfile___0 = open_file(pp, (unsigned char const   *)(buffer), 0);
            }
          }
#line 1404
          pp->pfrom = pfile___0;
        } else {
#line 1406
          pp->pfrom = (mtd_file *)0;
        }
#line 1407
        goto switch_break;
        case_exp___7: /* CIL Label */ 
        case_exp___8: /* CIL Label */ 
        {
#line 1411
        Ac = string(buffer, line, Ac + 2);
        }
#line 1412
        if ((int )buffer[0] != 0) {
          {
#line 1413
          tmp___3 = find_file(pp, (unsigned char const   *)(buffer));
#line 1413
          pfile___1 = tmp___3;
          }
#line 1414
          if ((unsigned long )pfile___1 == (unsigned long )((mtd_file *)0)) {
            {
#line 1415
            do_die((unsigned char const   *)"no such file to close", (unsigned char const   *)(buffer));
            }
          }
#line 1417
          if ((unsigned long )pfile___1 == (unsigned long )pp->pfrom) {
#line 1418
            pp->pfrom = (mtd_file *)0;
          }
#line 1419
          if ((unsigned long )pfile___1 == (unsigned long )pp->pto) {
#line 1420
            pp->pto = (mtd_file *)0;
          }
          {
#line 1421
          close_mtd(pfile___1);
          }
        } else {
          {
#line 1423
          do_die((unsigned char const   *)"<> (close) requires an argument", lp);
          }
        }
#line 1424
        goto switch_break;
        case_exp___9: /* CIL Label */ 
        {
#line 1427
        Ac = need(pp, (unsigned long *)(arg), line, Ac + 2, AcEnd, 1);
        }
#line 1428
        if ((unsigned long )pp->pto == (unsigned long )((mtd_file *)0)) {
          {
#line 1429
          do_die((unsigned char const   *)"no output file", lp);
          }
        }
#line 1430
        (pp->pto)->useroffset = (off_t )arg[0];
#line 1431
        goto switch_break;
        case_exp___10: /* CIL Label */ 
        {
#line 1434
        Ac = need(pp, (unsigned long *)(arg), line, Ac + 2, AcEnd, 1);
        }
#line 1435
        if ((unsigned long )pp->pfrom == (unsigned long )((mtd_file *)0)) {
          {
#line 1436
          do_die((unsigned char const   *)"no input file", lp);
          }
        }
#line 1437
        (pp->pfrom)->useroffset = (off_t )arg[0];
#line 1438
        goto switch_break;
        case_exp___11: /* CIL Label */ 
        {
#line 1442
        Ac = need(pp, (unsigned long *)(arg), line, Ac + 2, AcEnd, 2);
        }
        {
#line 1444
        if (arg[1] == 4UL) {
#line 1444
          goto case_4;
        }
#line 1445
        if (arg[1] == 3UL) {
#line 1445
          goto case_3;
        }
#line 1446
        if (arg[1] == 2UL) {
#line 1446
          goto case_2;
        }
#line 1447
        if (arg[1] == 1UL) {
#line 1447
          goto case_1;
        }
#line 1449
        goto switch_default;
        case_4: /* CIL Label */ 
        {
#line 1444
        outb(pp, arg[0] >> 24);
        }
        case_3: /* CIL Label */ 
        {
#line 1445
        outb(pp, arg[0] >> 16);
        }
        case_2: /* CIL Label */ 
        {
#line 1446
        outb(pp, arg[0] >> 8);
        }
        case_1: /* CIL Label */ 
        {
#line 1447
        outb(pp, arg[0]);
        }
#line 1448
        goto switch_break___0;
        switch_default: /* CIL Label */ 
        {
#line 1449
        do_die((unsigned char const   *)"byte count out of range", lp);
        }
        switch_break___0: /* CIL Label */ ;
        }
#line 1451
        goto switch_break;
        case_exp___12: /* CIL Label */ 
        {
#line 1454
        Ac = need(pp, (unsigned long *)(arg), line, Ac + 2, AcEnd, 2);
        }
        {
#line 1456
        if (arg[1] == 4UL) {
#line 1456
          goto case_4___0;
        }
#line 1457
        if (arg[1] == 3UL) {
#line 1457
          goto case_3___0;
        }
#line 1458
        if (arg[1] == 2UL) {
#line 1458
          goto case_2___0;
        }
#line 1459
        if (arg[1] == 1UL) {
#line 1459
          goto case_1___0;
        }
#line 1461
        goto switch_default___0;
        case_4___0: /* CIL Label */ 
        {
#line 1456
        outb(pp, arg[0]);
#line 1456
        arg[0] >>= 8;
        }
        case_3___0: /* CIL Label */ 
        {
#line 1457
        outb(pp, arg[0]);
#line 1457
        arg[0] >>= 8;
        }
        case_2___0: /* CIL Label */ 
        {
#line 1458
        outb(pp, arg[0]);
#line 1458
        arg[0] >>= 8;
        }
        case_1___0: /* CIL Label */ 
        {
#line 1459
        outb(pp, arg[0]);
        }
#line 1460
        goto switch_break___1;
        switch_default___0: /* CIL Label */ 
        {
#line 1461
        do_die((unsigned char const   *)"byte count out of range", lp);
        }
        switch_break___1: /* CIL Label */ ;
        }
#line 1463
        goto switch_break;
        case_exp___13: /* CIL Label */ 
        {
#line 1466
        Ac = string(buffer, line, Ac + 2);
#line 1467
        tmp___4 = strlen((char const   *)(buffer));
#line 1467
        outputbytes(pp, (char const   *)(buffer), tmp___4);
        }
#line 1468
        goto switch_break;
        case_exp___14: /* CIL Label */ 
        {
#line 1471
        Ac = need(pp, (unsigned long *)(arg), line, Ac + 2, AcEnd, 2);
        }
#line 1476
        if (arg[1] > 255UL) {
          {
#line 1477
          do_die((unsigned char const   *)"fill value out of range", lp);
          }
        }
        {
#line 1482
        fillbytes(pp, arg[1], arg[0]);
        }
#line 1483
        goto switch_break;
        case_exp___15: /* CIL Label */ 
        {
#line 1486
        Ac = need(pp, (unsigned long *)(arg), line, Ac + 2, AcEnd, 1);
#line 1487
        copybytes(pp, arg[0], (size_t )1);
        }
#line 1488
        goto switch_break;
        case_exp___16: /* CIL Label */ 
        {
#line 1491
        Ac = need(pp, (unsigned long *)(arg), line, Ac + 2, AcEnd, 2);
        }
#line 1492
        if (arg[1] > 256UL) {
          {
#line 1495
          do_die((unsigned char const   *)"invalid byte count", lp);
          }
        } else
#line 1492
        if (arg[1] & (arg[1] - 1UL)) {
          {
#line 1495
          do_die((unsigned char const   *)"invalid byte count", lp);
          }
        } else
#line 1492
        if (arg[0] & (arg[1] - 1UL)) {
          {
#line 1495
          do_die((unsigned char const   *)"invalid byte count", lp);
          }
        }
        {
#line 1496
        copybytes(pp, arg[0], arg[1]);
        }
#line 1497
        goto switch_break;
        case_exp___17: /* CIL Label */ 
        {
#line 1501
        Ac = need(pp, (unsigned long *)(arg), line, Ac + 2, AcEnd, 1);
#line 1502
        printf((char const   */* __restrict  */)"%lu\n", arg[0]);
        }
        stdout_check: 
        {
#line 1504
        tmp___5 = ferror(stdout);
        }
#line 1504
        if (tmp___5) {
          {
#line 1505
          do_pdie((unsigned char const   *)"write error", (unsigned char const   *)"stdout");
          }
        }
#line 1506
        goto switch_break;
        case_exp___18: /* CIL Label */ 
        {
#line 1509
        Ac = string(buffer, line, Ac + 2);
#line 1514
        stack___0 = (pp->stack + pp->cstack) - 1;
#line 1515
        pp->cstack = 8;
#line 1516
        printf((char const   */* __restrict  */)(buffer), *(stack___0 + 0), *(stack___0 + -1),
               *(stack___0 + -2), *(stack___0 + -3), *(stack___0 + -4), *(stack___0 + -5),
               *(stack___0 + -6), *(stack___0 + -7));
        }
#line 1519
        goto stdout_check;
        case_exp___19: /* CIL Label */ 
        {
#line 1522
        Ac = need(pp, (unsigned long *)(arg), line, Ac + 2, AcEnd, 0);
#line 1523
        printf((char const   */* __restrict  */)"\n");
        }
#line 1524
        goto stdout_check;
        case_exp___20: /* CIL Label */ 
        {
#line 1528
        Ac = need(pp, (unsigned long *)(arg), line, Ac + 2, AcEnd, 0);
        }
#line 1529
        goto switch_break;
        switch_default___1: /* CIL Label */ 
        {
#line 1533
        tmp___6 = __ctype_b_loc();
        }
#line 1533
        if ((int const   )*(*tmp___6 + (int )ch) & 256) {
#line 1533
          if ((int const   )*(line + (Ac + 1)) == 61) {
            {
#line 1535
            Ac = need(pp, (unsigned long *)(arg), line, Ac + 2, AcEnd, 1);
#line 1536
            pp->variables[ch] = arg[0];
            }
          } else {
            {
#line 1538
            do_die((unsigned char const   *)"unknown command", lp);
            }
          }
        } else {
          {
#line 1538
          do_die((unsigned char const   *)"unknown command", lp);
          }
        }
#line 1539
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1544
    Al ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1550
  if (SP > 0) {
    {
#line 1551
    do_die((unsigned char const   *)"unclosed $( $)", (unsigned char const   *)"eof");
    }
  }
  {
#line 1552
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1552
    if (! (fnoexec == 0)) {
      {
#line 1552
      do_assert(1552);
      }
    }
#line 1552
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1553
  return;
}
}
#line 1560 "/home/june/repo/benchmarks/collector/temp/devio-1.2/src/devio.c"
int main(int argc , char const   **argv ) 
{ 
  int i ;
  int fhelp ;
  int fverify ;
  int fprogress ;
  parse_buf p ;
  int j ;
  unsigned char const   *p___0 ;

  {
#line 1561
  i = 0;
#line 1561
  fhelp = 0;
#line 1561
  fverify = 0;
#line 1561
  fprogress = 0;
  {
#line 1565
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1565
    i ++;
#line 1565
    if (i < argc) {
#line 1565
      if (! ((int const   )*(*(argv + i) + 0) == 45)) {
#line 1565
        goto while_break;
      }
    } else {
#line 1565
      goto while_break;
    }
#line 1566
    j = 0;
    {
#line 1567
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1567
      j ++;
#line 1567
      if (! ((int const   )*(*(argv + i) + j) != 0)) {
#line 1567
        goto while_break___0;
      }
      {
#line 1568
      if ((int const   )*(*(argv + i) + j) == 86) {
#line 1568
        goto case_86;
      }
#line 1568
      if ((int const   )*(*(argv + i) + j) == 118) {
#line 1568
        goto case_86;
      }
#line 1569
      if ((int const   )*(*(argv + i) + j) == 80) {
#line 1569
        goto case_80;
      }
#line 1569
      if ((int const   )*(*(argv + i) + j) == 112) {
#line 1569
        goto case_80;
      }
#line 1570
      if ((int const   )*(*(argv + i) + j) == 45) {
#line 1570
        goto case_45;
      }
#line 1571
      goto switch_default;
      case_86: /* CIL Label */ 
      case_118: /* CIL Label */ 
#line 1568
      fverify = 1;
#line 1568
      goto switch_break;
      case_80: /* CIL Label */ 
      case_112: /* CIL Label */ 
#line 1569
      fprogress = 1;
#line 1569
      progress = 1;
#line 1569
      goto switch_break;
      case_45: /* CIL Label */ 
#line 1570
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1571
      fhelp = 1;
#line 1571
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1575
  if (i >= argc) {
#line 1575
    goto _L;
  } else
#line 1575
  if (fhelp) {
    _L: /* CIL Label */ 
    {
#line 1576
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: usage: %s ([-v] [-p] {comands} |-h [command])\n",
            *(argv + 0), *(argv + 0));
    }
#line 1578
    if (i >= argc) {
      {
#line 1579
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" options:\n  -v: do not write, just verify a previous write\n  -p: output a progress indicator on write\n  -h: output this help\n  -h commands: output command help\n  -h <command>: output help for command <command>\n");
      }
    } else {
      {
#line 1586
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1586
        if (! (i < argc)) {
#line 1586
          goto while_break___1;
        }
#line 1587
        p___0 = (unsigned char const   *)*(argv + i);
        {
#line 1589
        if (((int const   )*(*(argv + i) + 0) << 8) + (int const   )*(*(argv + i) + 1) == (int const   )((97 << 8) + 100)) {
#line 1589
          goto case_exp;
        }
#line 1593
        if (((int const   )*(*(argv + i) + 0) << 8) + (int const   )*(*(argv + i) + 1) == (int const   )((99 << 8) + 111)) {
#line 1593
          goto case_exp___0;
        }
#line 1637
        if (((int const   )*(*(argv + i) + 0) << 8) + (int const   )*(*(argv + i) + 1) == (int const   )((36 << 8) + 40)) {
#line 1637
          goto case_exp___1;
        }
#line 1640
        if (((int const   )*(*(argv + i) + 0) << 8) + (int const   )*(*(argv + i) + 1) == (int const   )((36 << 8) + 58)) {
#line 1640
          goto case_exp___2;
        }
#line 1643
        if (((int const   )*(*(argv + i) + 0) << 8) + (int const   )*(*(argv + i) + 1) == (int const   )((36 << 8) + 41)) {
#line 1643
          goto case_exp___3;
        }
#line 1646
        if (((int const   )*(*(argv + i) + 0) << 8) + (int const   )*(*(argv + i) + 1) == (int const   )((36 << 8) + 63)) {
#line 1646
          goto case_exp___4;
        }
#line 1649
        if (((int const   )*(*(argv + i) + 0) << 8) + (int const   )*(*(argv + i) + 1) == (int const   )((101 << 8) + 120)) {
#line 1649
          goto case_exp___5;
        }
#line 1657
        if (((int const   )*(*(argv + i) + 0) << 8) + (int const   )*(*(argv + i) + 1) == (int const   )((33 << 8) + 63)) {
#line 1657
          goto case_exp___6;
        }
#line 1660
        if (((int const   )*(*(argv + i) + 0) << 8) + (int const   )*(*(argv + i) + 1) == (int const   )((33 << 8) + 33)) {
#line 1660
          goto case_exp___7;
        }
#line 1663
        if (((int const   )*(*(argv + i) + 0) << 8) + (int const   )*(*(argv + i) + 1) == (int const   )((105 << 8) + 111)) {
#line 1663
          goto case_exp___8;
        }
#line 1679
        if (((int const   )*(*(argv + i) + 0) << 8) + (int const   )*(*(argv + i) + 1) == (int const   )((62 << 8) + 62)) {
#line 1679
          goto case_exp___9;
        }
#line 1683
        if (((int const   )*(*(argv + i) + 0) << 8) + (int const   )*(*(argv + i) + 1) == (int const   )((60 << 8) + 60)) {
#line 1683
          goto case_exp___10;
        }
#line 1687
        if (((int const   )*(*(argv + i) + 0) << 8) + (int const   )*(*(argv + i) + 1) == (int const   )((60 << 8) + 62)) {
#line 1687
          goto case_exp___11;
        }
#line 1690
        if (((int const   )*(*(argv + i) + 0) << 8) + (int const   )*(*(argv + i) + 1) == (int const   )((62 << 8) + 60)) {
#line 1690
          goto case_exp___12;
        }
#line 1693
        if (((int const   )*(*(argv + i) + 0) << 8) + (int const   )*(*(argv + i) + 1) == (int const   )((62 << 8) + 61)) {
#line 1693
          goto case_exp___13;
        }
#line 1696
        if (((int const   )*(*(argv + i) + 0) << 8) + (int const   )*(*(argv + i) + 1) == (int const   )((60 << 8) + 61)) {
#line 1696
          goto case_exp___14;
        }
#line 1699
        if (((int const   )*(*(argv + i) + 0) << 8) + (int const   )*(*(argv + i) + 1) == (int const   )((119 << 8) + 114)) {
#line 1699
          goto case_exp___15;
        }
#line 1705
        if (((int const   )*(*(argv + i) + 0) << 8) + (int const   )*(*(argv + i) + 1) == (int const   )((119 << 8) + 98)) {
#line 1705
          goto case_exp___16;
        }
#line 1708
        if (((int const   )*(*(argv + i) + 0) << 8) + (int const   )*(*(argv + i) + 1) == (int const   )((119 << 8) + 108)) {
#line 1708
          goto case_exp___17;
        }
#line 1711
        if (((int const   )*(*(argv + i) + 0) << 8) + (int const   )*(*(argv + i) + 1) == (int const   )((119 << 8) + 115)) {
#line 1711
          goto case_exp___18;
        }
#line 1714
        if (((int const   )*(*(argv + i) + 0) << 8) + (int const   )*(*(argv + i) + 1) == (int const   )((102 << 8) + 98)) {
#line 1714
          goto case_exp___19;
        }
#line 1717
        if (((int const   )*(*(argv + i) + 0) << 8) + (int const   )*(*(argv + i) + 1) == (int const   )((99 << 8) + 112)) {
#line 1717
          goto case_exp___20;
        }
#line 1720
        if (((int const   )*(*(argv + i) + 0) << 8) + (int const   )*(*(argv + i) + 1) == (int const   )((120 << 8) + 112)) {
#line 1720
          goto case_exp___21;
        }
#line 1724
        if (((int const   )*(*(argv + i) + 0) << 8) + (int const   )*(*(argv + i) + 1) == (int const   )((109 << 8) + 101)) {
#line 1724
          goto case_exp___22;
        }
#line 1734
        if (((int const   )*(*(argv + i) + 0) << 8) + (int const   )*(*(argv + i) + 1) == (int const   )((112 << 8) + 114)) {
#line 1734
          goto case_exp___23;
        }
#line 1737
        if (((int const   )*(*(argv + i) + 0) << 8) + (int const   )*(*(argv + i) + 1) == (int const   )((112 << 8) + 102)) {
#line 1737
          goto case_exp___24;
        }
#line 1743
        if (((int const   )*(*(argv + i) + 0) << 8) + (int const   )*(*(argv + i) + 1) == (int const   )((112 << 8) + 110)) {
#line 1743
          goto case_exp___25;
        }
#line 1746
        if (((int const   )*(*(argv + i) + 0) << 8) + (int const   )*(*(argv + i) + 1) == (int const   )((46 << 8) + 61)) {
#line 1746
          goto case_exp___26;
        }
#line 1749
        if (((int const   )*(*(argv + i) + 0) << 8) + (int const   )*(*(argv + i) + 1) == (int const   )((97 << 8) + 115)) {
#line 1749
          goto case_exp___27;
        }
#line 1753
        if (((int const   )*(*(argv + i) + 0) << 8) + (int const   )*(*(argv + i) + 1) == (int const   )((115 << 8) + 116)) {
#line 1753
          goto case_exp___28;
        }
#line 1761
        if (((int const   )*(*(argv + i) + 0) << 8) + (int const   )*(*(argv + i) + 1) == (int const   )((110 << 8) + 117)) {
#line 1761
          goto case_exp___29;
        }
#line 1776
        if (((int const   )*(*(argv + i) + 0) << 8) + (int const   )*(*(argv + i) + 1) == (int const   )((111 << 8) + 112)) {
#line 1776
          goto case_exp___30;
        }
#line 1830
        goto switch_default___0;
        case_exp: /* CIL Label */ 
#line 1590
        p___0 = (unsigned char const   *)"Enter the keyword in [] contained after the command list\nfor more information about those commands";
#line 1592
        goto switch_break___0;
        case_exp___0: /* CIL Label */ 
#line 1594
        if ((int const   )*(*(argv + i) + 2) != 110) {
#line 1595
          p___0 = (unsigned char const   *)" commands are terminated by \';\', newline or the end of input:\n  <command> {arguments} ;\n\n command: a two character command:         [additional info]\n  conditional execution: $( $: $? $)       [conditional]\n  program termination:   !? !!             [exit]\n  input/output control:  >> << <> >= <=    [io]\n  writing to the output: wb wl ws fb cp xp [write]\n  writing to stdout:     pr pf pn          [messages]\n  assignment:            <C>= .=           [assign]\n  comment:               #\n\n  -h <command>: output the syntax of command <command>\n\n arguments: a string or a postfix numeric expression\n  -h string:   output the syntax of a string argument\n  -h number:   output the syntax of a numeric argument\n  -h operator: output a summary of the operators\n\n A command which starts with \'#\' is ignored (a comment).";
        } else {
#line 1612
          p___0 = (unsigned char const   *)"conditional evalation\n  Conditional evalation has the general form:\n\n    $( cond; $? cond; $: cond; $) cond;  (command form)\n    cond(,  cond?,  [cond:,  [cond),     (operator from)\n\n  Conditional commands bracket other commands, conditional\n  operators bracket other numbers and operators in the expression\n  The conditions (cond) are intrepreted as boolean values, with 0\n  false and any other value true.  Notice that the numbers come off\n  the number stack so it is not necessary for them to be given with\n  the specific command or before the specifc operator but it can\n  be very confusing if this is not done.\n\n  The commands/operators behave exactly as the following ANSI C\n  syntax:\n\n    $( n       do if (n) {\n    $? n       if (n) break;\n    $: n       } else if (n) {\n    $) n       } while (n);\n\n  Thus a simple if/then/else sequence might be:\n\n    $( condition; $: 1; $) 0\n    condition( [1: [0)\n\n  And a simple do while loop:\n\n    $( 1; $) condition\n    1( [condition)\n\n  Notice that the operator syntax requires [cond: and [cond)";
        }
#line 1636
        goto switch_break___0;
        case_exp___1: /* CIL Label */ 
#line 1638
        p___0 = (unsigned char const   *)"conditional: $( condition;  do if (condition) {\n";
#line 1639
        goto switch_break___0;
        case_exp___2: /* CIL Label */ 
#line 1641
        p___0 = (unsigned char const   *)"conditional: $( condition;  } else if (condition) {\n";
#line 1642
        goto switch_break___0;
        case_exp___3: /* CIL Label */ 
#line 1644
        p___0 = (unsigned char const   *)"conditional: $: condition;  } while (condition);\n";
#line 1645
        goto switch_break___0;
        case_exp___4: /* CIL Label */ 
#line 1647
        p___0 = (unsigned char const   *)"conditional: $: condition;  if (condition) break;\n";
#line 1648
        goto switch_break___0;
        case_exp___5: /* CIL Label */ 
#line 1650
        p___0 = (unsigned char const   *)"program termination commands:\n  !? and !! cause immediate termination of the program.\n  The currently opened files are closed (and flushed) on\n  termination and the program exits with the given code.\n  !? is condition - it only causes an exit if the code is\n  non zero.";
#line 1656
        goto switch_break___0;
        case_exp___6: /* CIL Label */ 
#line 1658
        p___0 = (unsigned char const   *)"exit: !? code;  if (code != 0) exit(code);\n";
#line 1659
        goto switch_break___0;
        case_exp___7: /* CIL Label */ 
#line 1661
        p___0 = (unsigned char const   *)"exit: !! code;  exit(code);\n";
#line 1662
        goto switch_break___0;
        case_exp___8: /* CIL Label */ 
#line 1664
        p___0 = (unsigned char const   *)"input/output control:\n  >> << allow files to be opened for write or read (respectively)\n  A file may be opened for both write and read, but in that case\n  the first open must be the write one.  Such a file has only one\n  position pointer.  Supplying an empty file name to the commands\n  causes the standard IO stream (stdout or stdin) to be used, but\n  the file remains open.  A file may be reselected by repeating\n  the open command.  The position pointer will not have changed.\n\n  <> closes a file.  If it is the current input or output then the\n  input or output, as appropriate, is redirected to the standard\n  streams.\n\n  <= >= set the input (from) or output (to) pointer.  The pointer is\n  changed on the current input or output device and is a property of\n  that device, not a global setting.";
#line 1678
        goto switch_break___0;
        case_exp___9: /* CIL Label */ 
#line 1680
        p___0 = (unsigned char const   *)"io: >> file;  select file as the current output device\n    >> ;      select stdout as the current output device\n";
#line 1682
        goto switch_break___0;
        case_exp___10: /* CIL Label */ 
#line 1684
        p___0 = (unsigned char const   *)"io: << file;  select file as the current input device\n    << ;      select stdin as the current input device\n";
#line 1686
        goto switch_break___0;
        case_exp___11: /* CIL Label */ 
#line 1688
        p___0 = (unsigned char const   *)"io: <> file;  close file\n";
#line 1689
        goto switch_break___0;
        case_exp___12: /* CIL Label */ 
#line 1691
        p___0 = (unsigned char const   *)"io: >< file;  close file\n";
#line 1692
        goto switch_break___0;
        case_exp___13: /* CIL Label */ 
#line 1694
        p___0 = (unsigned char const   *)"io: >= offset;  set the \'to\' pointer: output device file pointer\n";
#line 1695
        goto switch_break___0;
        case_exp___14: /* CIL Label */ 
#line 1697
        p___0 = (unsigned char const   *)"io: <= offset;  set the \'from\' pointer: input device file pointer\n";
#line 1698
        goto switch_break___0;
        case_exp___15: /* CIL Label */ 
#line 1700
        p___0 = (unsigned char const   *)"writing to the output:\n  wb, wl, ws, fb, cp and xp write bytes to the current output device\n  at the current output position (which may be set using >=.)\n\n  See the individual command descriptions for more information.";
#line 1704
        goto switch_break___0;
        case_exp___16: /* CIL Label */ 
#line 1706
        p___0 = (unsigned char const   *)"write: wb number bytes; write number in bytes big endian bytes\n";
#line 1707
        goto switch_break___0;
        case_exp___17: /* CIL Label */ 
#line 1709
        p___0 = (unsigned char const   *)"write: wl number bytes; write number in bytes little endian bytes\n";
#line 1710
        goto switch_break___0;
        case_exp___18: /* CIL Label */ 
#line 1712
        p___0 = (unsigned char const   *)"write: ws string;       write string\n";
#line 1713
        goto switch_break___0;
        case_exp___19: /* CIL Label */ 
#line 1715
        p___0 = (unsigned char const   *)"write: fb number byte;  write number bytes of value \'byte\'\n";
#line 1716
        goto switch_break___0;
        case_exp___20: /* CIL Label */ 
#line 1718
        p___0 = (unsigned char const   *)"write: cp number;       copy number bytes from input to output\n";
#line 1719
        goto switch_break___0;
        case_exp___21: /* CIL Label */ 
#line 1721
        p___0 = (unsigned char const   *)"write: xp number bytes; byte swap number bytes from input to output\n                        each group of \'bytes\' bytes is swapped\n";
#line 1723
        goto switch_break___0;
        case_exp___22: /* CIL Label */ 
#line 1725
        p___0 = (unsigned char const   *)"writing to stdout:\n  pr pf and pn allow output to stdout ignoring the current output\n  device.  pf uses a C printf(3) format string and no checking is\n  made on the validity or number of parameters.  The program will\n  crash if a pointer format (like %s) is used.  This is by design.\n  Use of \\ escapes within the string will probably not produce the\n  expected result.  The only way to output a newline is via the\n  separate pn command.";
#line 1733
        goto switch_break___0;
        case_exp___23: /* CIL Label */ 
#line 1735
        p___0 = (unsigned char const   *)"message: pr number;   printf(\"%lu\\n\", number);\n";
#line 1736
        goto switch_break___0;
        case_exp___24: /* CIL Label */ 
#line 1738
        p___0 = (unsigned char const   *)"message: pf string;   printf(string, 1, 2, 3, 4, 5, 6, 7, 8)\n                      uses string as a format string for the\n                      top (up to) 8 arguments on the stack\n                      Empties the stack!\n";
#line 1742
        goto switch_break___0;
        case_exp___25: /* CIL Label */ 
#line 1744
        p___0 = (unsigned char const   *)"message: pn;          prints a newline (printf(\"\\n\");)\n";
#line 1745
        goto switch_break___0;
        case_exp___26: /* CIL Label */ 
#line 1747
        p___0 = (unsigned char const   *)".= [number]\n  The number is evaluated and pushed to the stack";
        case_exp___27: /* CIL Label */ 
#line 1750
        p___0 = (unsigned char const   *)"<C>= [number] (<C> is an upper case character in the range A-Z)\n  The number is assigned to the variable <C>.";
#line 1752
        goto switch_break___0;
        case_exp___28: /* CIL Label */ 
#line 1754
        p___0 = (unsigned char const   *)"string format\n  A string is either quoted or unquoted.  An unquoted string is\n  the rest of the line, terminated by \';\' or newline (or the end\n  of the command).  A quoted string is enclosed in either single\n  or double quotes (which are removed) and must be the only thing\n  on the line apart from white space.";
#line 1760
        goto switch_break___0;
        case_exp___29: /* CIL Label */ 
#line 1762
        p___0 = (unsigned char const   *)"number format\n  A number is a post-fix expression consisting of numeric values,\n  variable values and operators.\n  A numeric value is anything starting with a digit.  0x prefixes a\n  hexadecimal value, 0 prefixes an octal value otherwise the value\n  is interpreted as decimal.\n  Variables are single upper case characters in the range A-Z,\n  thus 26 variables are available.\n  Numeric values and variables are pushed onto a stack which can\n  store up to 248 numbers.\n  Operators are single characters not identified as numeric values\n  or variables.  They operate on the stack combining elements.\n  Use -h operators for more information.";
#line 1775
        goto switch_break___0;
        case_exp___30: /* CIL Label */ 
#line 1777
        p___0 = (unsigned char const   *)"operators\n  The following operators are defined.  Operators take one or\n  two elements from the stack and push back up to two elements\n  The conditional operators (:?) are special, see the description\n  under -h conditionals for more information.  (Conditional\n  operators and the conditional commands behave identically.)\n\n  In the following descriptions \'left\' is the last-but-one\n  number on the stack and \'right\' is the last number pushed.\n  \'new\' is a new number pushed on to the top of the stack.\n\n arithmetic operators:\n     *: new := left * right        (multiplication)\n     +: new := left + right\n     -: new := left - right\n     /: new := left / right        (division)\n     %: new := left % right        (i.e. C style modulus)\n     <: new := left < right\n     >: new := left > right\n     =: new := left == right       (i.e. equality)\n     |: new := left | right        (bitwise or)\n     &: new := left & right        (bitwise and)\n     ^: new := left ^ right        (bitwise xor)\n     ~: new := ~right              (ones complement)\n     !: new := !right              (logical complement - right == 0)\n     {: new := left << right       (bitwise shift left by right bits)\n     }: new := left << right       (bitwise shift right by right bits)\n     r: new := left ROR right      (bitwise rotate right by right bits)\n     e: new := left SXT right      (right least significant bits of\n                                    left are sign extended to 32 bits)\n     m: new := left MASK right     (right least significant bits of left\n                                    are masked, upper bits become 0)\n operators to read bytes:\n     @: new := input-byte          (one byte is read from current input)\n     b: new := input-big-endian    (4 big endian bytes are read)\n     l: new := input-little-endian (4 little endian bytes)\n enquiry operators:\n     $: the size of the current input device\n     f: the current \'from\' offset\n     #: the size of the current output device\n     t: the current \'to\' offset\n     d: the full device number of the current input device\n        this returns the number of the underlying device for a file\n     o: the block size of the current output device\n     i: the block size of the current input device\n operators to manipulate the stack:\n     .: new := right,right         (i.e. right is duplicated)\n     p: pop - right is removed from the stack\n     s: swap - right and left are swapped on the stack\n conditional operators:\n     ( exec := right         (execution is stopped if right is 0)\n     : exec := else if right (execution is resumed or stopped)\n     ? if right break        (break out of if/loop if right)\n     ) loop if right         (end of current if/loop)";
#line 1829
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
        {
#line 1831
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"command \'%s\' not recognised\n",
                p___0);
#line 1832
        p___0 = (unsigned char const   *)0;
        }
        switch_break___0: /* CIL Label */ ;
        }
#line 1835
        if ((unsigned long )p___0 != (unsigned long )((unsigned char const   *)0)) {
          {
#line 1836
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
                  p___0);
          }
        }
#line 1586
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 1840
    exit(1);
    }
  }
  {
#line 1843
  init_parse(& p, fverify, fprogress);
#line 1844
  parse(& p, argc - i, argv + i);
#line 1845
  quit(& p, 0);
  }
}
}
