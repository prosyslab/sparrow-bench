/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 59 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmorecfg.h"
typedef unsigned char JSAMPLE;
#line 99 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmorecfg.h"
typedef short JCOEF;
#line 110 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmorecfg.h"
typedef unsigned char JOCTET;
#line 135 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmorecfg.h"
typedef unsigned char UINT8;
#line 147 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmorecfg.h"
typedef unsigned short UINT16;
#line 171 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmorecfg.h"
typedef unsigned int JDIMENSION;
#line 227 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmorecfg.h"
typedef int boolean;
#line 66 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpeglib.h"
typedef JSAMPLE *JSAMPROW;
#line 67 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpeglib.h"
typedef JSAMPROW *JSAMPARRAY;
#line 68 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpeglib.h"
typedef JSAMPARRAY *JSAMPIMAGE;
#line 70 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpeglib.h"
typedef JCOEF JBLOCK[64];
#line 71 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpeglib.h"
typedef JBLOCK *JBLOCKROW;
#line 72 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpeglib.h"
typedef JBLOCKROW *JBLOCKARRAY;
#line 83 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpeglib.h"
struct __anonstruct_JQUANT_TBL_25 {
   UINT16 quantval[64] ;
   boolean sent_table ;
};
#line 83 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpeglib.h"
typedef struct __anonstruct_JQUANT_TBL_25 JQUANT_TBL;
#line 100 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpeglib.h"
struct __anonstruct_JHUFF_TBL_26 {
   UINT8 bits[17] ;
   UINT8 huffval[256] ;
   boolean sent_table ;
};
#line 100 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpeglib.h"
typedef struct __anonstruct_JHUFF_TBL_26 JHUFF_TBL;
#line 116 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpeglib.h"
struct __anonstruct_jpeg_component_info_27 {
   int component_id ;
   int component_index ;
   int h_samp_factor ;
   int v_samp_factor ;
   int quant_tbl_no ;
   int dc_tbl_no ;
   int ac_tbl_no ;
   JDIMENSION width_in_blocks ;
   JDIMENSION height_in_blocks ;
   int DCT_scaled_size ;
   JDIMENSION downsampled_width ;
   JDIMENSION downsampled_height ;
   boolean component_needed ;
   int MCU_width ;
   int MCU_height ;
   int MCU_blocks ;
   int MCU_sample_width ;
   int last_col_width ;
   int last_row_height ;
   JQUANT_TBL *quant_table ;
   void *dct_table ;
};
#line 116 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpeglib.h"
typedef struct __anonstruct_jpeg_component_info_27 jpeg_component_info;
#line 184 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpeglib.h"
struct __anonstruct_jpeg_scan_info_28 {
   int comps_in_scan ;
   int component_index[4] ;
   int Ss ;
   int Se ;
   int Ah ;
   int Al ;
};
#line 184 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpeglib.h"
typedef struct __anonstruct_jpeg_scan_info_28 jpeg_scan_info;
#line 206
enum __anonenum_J_COLOR_SPACE_29 {
    JCS_UNKNOWN = 0,
    JCS_GRAYSCALE = 1,
    JCS_RGB = 2,
    JCS_YCbCr = 3,
    JCS_CMYK = 4,
    JCS_YCCK = 5
} ;
#line 206 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpeglib.h"
typedef enum __anonenum_J_COLOR_SPACE_29 J_COLOR_SPACE;
#line 217
enum __anonenum_J_DCT_METHOD_30 {
    JDCT_ISLOW = 0,
    JDCT_IFAST = 1,
    JDCT_FLOAT = 2
} ;
#line 217 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpeglib.h"
typedef enum __anonenum_J_DCT_METHOD_30 J_DCT_METHOD;
#line 253
struct jpeg_error_mgr;
#line 253
struct jpeg_memory_mgr;
#line 253
struct jpeg_progress_mgr;
#line 253 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpeglib.h"
struct jpeg_common_struct {
   struct jpeg_error_mgr *err ;
   struct jpeg_memory_mgr *mem ;
   struct jpeg_progress_mgr *progress ;
   void *client_data ;
   boolean is_decompressor ;
   int global_state ;
};
#line 261 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpeglib.h"
typedef struct jpeg_common_struct *j_common_ptr;
#line 262
struct jpeg_compress_struct;
#line 262 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpeglib.h"
typedef struct jpeg_compress_struct *j_compress_ptr;
#line 268
struct jpeg_destination_mgr;
#line 268
struct jpeg_comp_master;
#line 268
struct jpeg_c_main_controller;
#line 268
struct jpeg_c_prep_controller;
#line 268
struct jpeg_c_coef_controller;
#line 268
struct jpeg_marker_writer;
#line 268
struct jpeg_color_converter;
#line 268
struct jpeg_downsampler;
#line 268
struct jpeg_forward_dct;
#line 268
struct jpeg_entropy_encoder;
#line 268 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpeglib.h"
struct jpeg_compress_struct {
   struct jpeg_error_mgr *err ;
   struct jpeg_memory_mgr *mem ;
   struct jpeg_progress_mgr *progress ;
   void *client_data ;
   boolean is_decompressor ;
   int global_state ;
   struct jpeg_destination_mgr *dest ;
   JDIMENSION image_width ;
   JDIMENSION image_height ;
   int input_components ;
   J_COLOR_SPACE in_color_space ;
   double input_gamma ;
   int data_precision ;
   int num_components ;
   J_COLOR_SPACE jpeg_color_space ;
   jpeg_component_info *comp_info ;
   JQUANT_TBL *quant_tbl_ptrs[4] ;
   JHUFF_TBL *dc_huff_tbl_ptrs[4] ;
   JHUFF_TBL *ac_huff_tbl_ptrs[4] ;
   UINT8 arith_dc_L[16] ;
   UINT8 arith_dc_U[16] ;
   UINT8 arith_ac_K[16] ;
   int num_scans ;
   jpeg_scan_info const   *scan_info ;
   boolean raw_data_in ;
   boolean arith_code ;
   boolean optimize_coding ;
   boolean CCIR601_sampling ;
   int smoothing_factor ;
   J_DCT_METHOD dct_method ;
   unsigned int restart_interval ;
   int restart_in_rows ;
   boolean write_JFIF_header ;
   UINT8 JFIF_major_version ;
   UINT8 JFIF_minor_version ;
   UINT8 density_unit ;
   UINT16 X_density ;
   UINT16 Y_density ;
   boolean write_Adobe_marker ;
   JDIMENSION next_scanline ;
   boolean progressive_mode ;
   int max_h_samp_factor ;
   int max_v_samp_factor ;
   JDIMENSION total_iMCU_rows ;
   int comps_in_scan ;
   jpeg_component_info *cur_comp_info[4] ;
   JDIMENSION MCUs_per_row ;
   JDIMENSION MCU_rows_in_scan ;
   int blocks_in_MCU ;
   int MCU_membership[10] ;
   int Ss ;
   int Se ;
   int Ah ;
   int Al ;
   struct jpeg_comp_master *master ;
   struct jpeg_c_main_controller *main ;
   struct jpeg_c_prep_controller *prep ;
   struct jpeg_c_coef_controller *coef ;
   struct jpeg_marker_writer *marker ;
   struct jpeg_color_converter *cconvert ;
   struct jpeg_downsampler *downsample ;
   struct jpeg_forward_dct *fdct ;
   struct jpeg_entropy_encoder *entropy ;
   jpeg_scan_info *script_space ;
   int script_space_size ;
};
#line 643 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpeglib.h"
union __anonunion_msg_parm_32 {
   int i[8] ;
   char s[80] ;
};
#line 643 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpeglib.h"
struct jpeg_error_mgr {
   void (*error_exit)(j_common_ptr cinfo ) ;
   void (*emit_message)(j_common_ptr cinfo , int msg_level ) ;
   void (*output_message)(j_common_ptr cinfo ) ;
   void (*format_message)(j_common_ptr cinfo , char *buffer ) ;
   void (*reset_error_mgr)(j_common_ptr cinfo ) ;
   int msg_code ;
   union __anonunion_msg_parm_32 msg_parm ;
   int trace_level ;
   long num_warnings ;
   char const   * const  *jpeg_message_table ;
   int last_jpeg_message ;
   char const   * const  *addon_message_table ;
   int first_addon_message ;
   int last_addon_message ;
};
#line 701 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpeglib.h"
struct jpeg_progress_mgr {
   void (*progress_monitor)(j_common_ptr cinfo ) ;
   long pass_counter ;
   long pass_limit ;
   int completed_passes ;
   int total_passes ;
};
#line 713 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpeglib.h"
struct jpeg_destination_mgr {
   JOCTET *next_output_byte ;
   size_t free_in_buffer ;
   void (*init_destination)(j_compress_ptr cinfo ) ;
   boolean (*empty_output_buffer)(j_compress_ptr cinfo ) ;
   void (*term_destination)(j_compress_ptr cinfo ) ;
};
#line 752
struct jvirt_sarray_control;
#line 752 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpeglib.h"
typedef struct jvirt_sarray_control *jvirt_sarray_ptr;
#line 753
struct jvirt_barray_control;
#line 753 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpeglib.h"
typedef struct jvirt_barray_control *jvirt_barray_ptr;
#line 756 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpeglib.h"
struct jpeg_memory_mgr {
   void *(*alloc_small)(j_common_ptr cinfo , int pool_id , size_t sizeofobject ) ;
   void *(*alloc_large)(j_common_ptr cinfo , int pool_id , size_t sizeofobject ) ;
   JSAMPARRAY (*alloc_sarray)(j_common_ptr cinfo , int pool_id , JDIMENSION samplesperrow ,
                              JDIMENSION numrows ) ;
   JBLOCKARRAY (*alloc_barray)(j_common_ptr cinfo , int pool_id , JDIMENSION blocksperrow ,
                               JDIMENSION numrows ) ;
   jvirt_sarray_ptr (*request_virt_sarray)(j_common_ptr cinfo , int pool_id , boolean pre_zero ,
                                           JDIMENSION samplesperrow , JDIMENSION numrows ,
                                           JDIMENSION maxaccess ) ;
   jvirt_barray_ptr (*request_virt_barray)(j_common_ptr cinfo , int pool_id , boolean pre_zero ,
                                           JDIMENSION blocksperrow , JDIMENSION numrows ,
                                           JDIMENSION maxaccess ) ;
   void (*realize_virt_arrays)(j_common_ptr cinfo ) ;
   JSAMPARRAY (*access_virt_sarray)(j_common_ptr cinfo , jvirt_sarray_ptr ptr , JDIMENSION start_row ,
                                    JDIMENSION num_rows , boolean writable ) ;
   JBLOCKARRAY (*access_virt_barray)(j_common_ptr cinfo , jvirt_barray_ptr ptr , JDIMENSION start_row ,
                                     JDIMENSION num_rows , boolean writable ) ;
   void (*free_pool)(j_common_ptr cinfo , int pool_id ) ;
   void (*self_destruct)(j_common_ptr cinfo ) ;
   long max_memory_to_use ;
   long max_alloc_chunk ;
};
#line 16 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpegint.h"
enum __anonenum_J_BUF_MODE_33 {
    JBUF_PASS_THRU = 0,
    JBUF_SAVE_SOURCE = 1,
    JBUF_CRANK_DEST = 2,
    JBUF_SAVE_AND_PASS = 3
} ;
#line 16 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpegint.h"
typedef enum __anonenum_J_BUF_MODE_33 J_BUF_MODE;
#line 45 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpegint.h"
struct jpeg_comp_master {
   void (*prepare_for_pass)(j_compress_ptr cinfo ) ;
   void (*pass_startup)(j_compress_ptr cinfo ) ;
   void (*finish_pass)(j_compress_ptr cinfo ) ;
   boolean call_pass_startup ;
   boolean is_last_pass ;
};
#line 56 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpegint.h"
struct jpeg_c_main_controller {
   void (*start_pass)(j_compress_ptr cinfo , J_BUF_MODE pass_mode ) ;
   void (*process_data)(j_compress_ptr cinfo , JSAMPARRAY input_buf , JDIMENSION *in_row_ctr ,
                        JDIMENSION in_rows_avail ) ;
};
#line 64 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpegint.h"
struct jpeg_c_prep_controller {
   void (*start_pass)(j_compress_ptr cinfo , J_BUF_MODE pass_mode ) ;
   void (*pre_process_data)(j_compress_ptr cinfo , JSAMPARRAY input_buf , JDIMENSION *in_row_ctr ,
                            JDIMENSION in_rows_avail , JSAMPIMAGE output_buf , JDIMENSION *out_row_group_ctr ,
                            JDIMENSION out_row_groups_avail ) ;
};
#line 76 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpegint.h"
struct jpeg_c_coef_controller {
   void (*start_pass)(j_compress_ptr cinfo , J_BUF_MODE pass_mode ) ;
   boolean (*compress_data)(j_compress_ptr cinfo , JSAMPIMAGE input_buf ) ;
};
#line 83 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpegint.h"
struct jpeg_color_converter {
   void (*start_pass)(j_compress_ptr cinfo ) ;
   void (*color_convert)(j_compress_ptr cinfo , JSAMPARRAY input_buf , JSAMPIMAGE output_buf ,
                         JDIMENSION output_row , int num_rows ) ;
};
#line 91 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpegint.h"
struct jpeg_downsampler {
   void (*start_pass)(j_compress_ptr cinfo ) ;
   void (*downsample)(j_compress_ptr cinfo , JSAMPIMAGE input_buf , JDIMENSION in_row_index ,
                      JSAMPIMAGE output_buf , JDIMENSION out_row_group_index ) ;
   boolean need_context_rows ;
};
#line 102 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpegint.h"
struct jpeg_forward_dct {
   void (*start_pass)(j_compress_ptr cinfo ) ;
   void (*forward_DCT)(j_compress_ptr cinfo , jpeg_component_info *compptr , JSAMPARRAY sample_data ,
                       JBLOCKROW coef_blocks , JDIMENSION start_row , JDIMENSION start_col ,
                       JDIMENSION num_blocks ) ;
};
#line 113 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpegint.h"
struct jpeg_entropy_encoder {
   void (*start_pass)(j_compress_ptr cinfo , boolean gather_statistics ) ;
   boolean (*encode_mcu)(j_compress_ptr cinfo , JBLOCKROW *MCU_data ) ;
   void (*finish_pass)(j_compress_ptr cinfo ) ;
};
#line 120 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpegint.h"
struct jpeg_marker_writer {
   void (*write_file_header)(j_compress_ptr cinfo ) ;
   void (*write_frame_header)(j_compress_ptr cinfo ) ;
   void (*write_scan_header)(j_compress_ptr cinfo ) ;
   void (*write_file_trailer)(j_compress_ptr cinfo ) ;
   void (*write_tables_only)(j_compress_ptr cinfo ) ;
   void (*write_marker_header)(j_compress_ptr cinfo , int marker , unsigned int datalen ) ;
   void (*write_marker_byte)(j_compress_ptr cinfo , int val ) ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 58 "/home/wheatley/newnew/temp/outguess-0.2/outguess.h"
struct _bitmap {
   u_char *bitmap ;
   u_char *locked ;
   u_char *metalock ;
   char *detect ;
   char *data ;
   int bytes ;
   int bits ;
   int (*preserve)(struct _bitmap * , int  ) ;
   size_t maxcorrect ;
};
#line 58 "/home/wheatley/newnew/temp/outguess-0.2/outguess.h"
typedef struct _bitmap bitmap;
#line 46 "/home/wheatley/newnew/temp/outguess-0.2/pnm.h"
struct _image {
   int x ;
   int y ;
   int depth ;
   int max ;
   u_char *img ;
   bitmap *bitmap ;
   int flags ;
};
#line 46 "/home/wheatley/newnew/temp/outguess-0.2/pnm.h"
typedef struct _image image;
#line 53 "/home/wheatley/newnew/temp/outguess-0.2/pnm.h"
struct _handler {
   char *extension ;
   void (*init)(char * ) ;
   image *(*read)(FILE * ) ;
   void (*write)(FILE * , image * ) ;
   void (*get_bitmap)(bitmap * , image * , int  ) ;
   void (*put_bitmap)(image * , bitmap * , int  ) ;
   int (*preserve)(bitmap * , int  ) ;
};
#line 53 "/home/wheatley/newnew/temp/outguess-0.2/pnm.h"
typedef struct _handler handler;
#line 11 "/home/wheatley/newnew/temp/outguess-0.2/missing/md5.h"
typedef unsigned long uint32;
#line 13 "/home/wheatley/newnew/temp/outguess-0.2/missing/md5.h"
struct MD5Context {
   uint32 buf[4] ;
   uint32 bits[2] ;
   unsigned char in[64] ;
};
#line 75 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpeglib.h"
typedef JCOEF *JCOEFPTR;
#line 193
struct jpeg_marker_struct;
#line 193 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpeglib.h"
typedef struct jpeg_marker_struct *jpeg_saved_marker_ptr;
#line 195 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpeglib.h"
struct jpeg_marker_struct {
   jpeg_saved_marker_ptr next ;
   UINT8 marker ;
   unsigned int original_length ;
   unsigned int data_length ;
   JOCTET *data ;
};
#line 232
enum __anonenum_J_DITHER_MODE_31 {
    JDITHER_NONE = 0,
    JDITHER_ORDERED = 1,
    JDITHER_FS = 2
} ;
#line 232 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpeglib.h"
typedef enum __anonenum_J_DITHER_MODE_31 J_DITHER_MODE;
#line 263
struct jpeg_decompress_struct;
#line 263 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpeglib.h"
typedef struct jpeg_decompress_struct *j_decompress_ptr;
#line 411
struct jpeg_source_mgr;
#line 411
struct jpeg_decomp_master;
#line 411
struct jpeg_d_main_controller;
#line 411
struct jpeg_d_coef_controller;
#line 411
struct jpeg_d_post_controller;
#line 411
struct jpeg_input_controller;
#line 411
struct jpeg_marker_reader;
#line 411
struct jpeg_entropy_decoder;
#line 411
struct jpeg_inverse_dct;
#line 411
struct jpeg_upsampler;
#line 411
struct jpeg_color_deconverter;
#line 411
struct jpeg_color_quantizer;
#line 411 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpeglib.h"
struct jpeg_decompress_struct {
   struct jpeg_error_mgr *err ;
   struct jpeg_memory_mgr *mem ;
   struct jpeg_progress_mgr *progress ;
   void *client_data ;
   boolean is_decompressor ;
   int global_state ;
   struct jpeg_source_mgr *src ;
   JDIMENSION image_width ;
   JDIMENSION image_height ;
   int num_components ;
   J_COLOR_SPACE jpeg_color_space ;
   J_COLOR_SPACE out_color_space ;
   unsigned int scale_num ;
   unsigned int scale_denom ;
   double output_gamma ;
   boolean buffered_image ;
   boolean raw_data_out ;
   J_DCT_METHOD dct_method ;
   boolean do_fancy_upsampling ;
   boolean do_block_smoothing ;
   boolean quantize_colors ;
   J_DITHER_MODE dither_mode ;
   boolean two_pass_quantize ;
   int desired_number_of_colors ;
   boolean enable_1pass_quant ;
   boolean enable_external_quant ;
   boolean enable_2pass_quant ;
   JDIMENSION output_width ;
   JDIMENSION output_height ;
   int out_color_components ;
   int output_components ;
   int rec_outbuf_height ;
   int actual_number_of_colors ;
   JSAMPARRAY colormap ;
   JDIMENSION output_scanline ;
   int input_scan_number ;
   JDIMENSION input_iMCU_row ;
   int output_scan_number ;
   JDIMENSION output_iMCU_row ;
   int (*coef_bits)[64] ;
   JQUANT_TBL *quant_tbl_ptrs[4] ;
   JHUFF_TBL *dc_huff_tbl_ptrs[4] ;
   JHUFF_TBL *ac_huff_tbl_ptrs[4] ;
   int data_precision ;
   jpeg_component_info *comp_info ;
   boolean progressive_mode ;
   boolean arith_code ;
   UINT8 arith_dc_L[16] ;
   UINT8 arith_dc_U[16] ;
   UINT8 arith_ac_K[16] ;
   unsigned int restart_interval ;
   boolean saw_JFIF_marker ;
   UINT8 JFIF_major_version ;
   UINT8 JFIF_minor_version ;
   UINT8 density_unit ;
   UINT16 X_density ;
   UINT16 Y_density ;
   boolean saw_Adobe_marker ;
   UINT8 Adobe_transform ;
   boolean CCIR601_sampling ;
   jpeg_saved_marker_ptr marker_list ;
   int max_h_samp_factor ;
   int max_v_samp_factor ;
   int min_DCT_scaled_size ;
   JDIMENSION total_iMCU_rows ;
   JSAMPLE *sample_range_limit ;
   int comps_in_scan ;
   jpeg_component_info *cur_comp_info[4] ;
   JDIMENSION MCUs_per_row ;
   JDIMENSION MCU_rows_in_scan ;
   int blocks_in_MCU ;
   int MCU_membership[10] ;
   int Ss ;
   int Se ;
   int Ah ;
   int Al ;
   int unread_marker ;
   struct jpeg_decomp_master *master ;
   struct jpeg_d_main_controller *main ;
   struct jpeg_d_coef_controller *coef ;
   struct jpeg_d_post_controller *post ;
   struct jpeg_input_controller *inputctl ;
   struct jpeg_marker_reader *marker ;
   struct jpeg_entropy_decoder *entropy ;
   struct jpeg_inverse_dct *idct ;
   struct jpeg_upsampler *upsample ;
   struct jpeg_color_deconverter *cconvert ;
   struct jpeg_color_quantizer *cquantize ;
};
#line 725 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpeglib.h"
struct jpeg_source_mgr {
   JOCTET const   *next_input_byte ;
   size_t bytes_in_buffer ;
   void (*init_source)(j_decompress_ptr cinfo ) ;
   boolean (*fill_input_buffer)(j_decompress_ptr cinfo ) ;
   void (*skip_input_data)(j_decompress_ptr cinfo , long num_bytes ) ;
   boolean (*resync_to_restart)(j_decompress_ptr cinfo , int desired ) ;
   void (*term_source)(j_decompress_ptr cinfo ) ;
};
#line 137 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpegint.h"
struct jpeg_decomp_master {
   void (*prepare_for_output_pass)(j_decompress_ptr cinfo ) ;
   void (*finish_output_pass)(j_decompress_ptr cinfo ) ;
   boolean is_dummy_pass ;
};
#line 146 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpegint.h"
struct jpeg_input_controller {
   int (*consume_input)(j_decompress_ptr cinfo ) ;
   void (*reset_input_controller)(j_decompress_ptr cinfo ) ;
   void (*start_input_pass)(j_decompress_ptr cinfo ) ;
   void (*finish_input_pass)(j_decompress_ptr cinfo ) ;
   boolean has_multiple_scans ;
   boolean eoi_reached ;
};
#line 158 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpegint.h"
struct jpeg_d_main_controller {
   void (*start_pass)(j_decompress_ptr cinfo , J_BUF_MODE pass_mode ) ;
   void (*process_data)(j_decompress_ptr cinfo , JSAMPARRAY output_buf , JDIMENSION *out_row_ctr ,
                        JDIMENSION out_rows_avail ) ;
};
#line 166 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpegint.h"
struct jpeg_d_coef_controller {
   void (*start_input_pass)(j_decompress_ptr cinfo ) ;
   int (*consume_data)(j_decompress_ptr cinfo ) ;
   void (*start_output_pass)(j_decompress_ptr cinfo ) ;
   int (*decompress_data)(j_decompress_ptr cinfo , JSAMPIMAGE output_buf ) ;
   jvirt_barray_ptr *coef_arrays ;
};
#line 177 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpegint.h"
struct jpeg_d_post_controller {
   void (*start_pass)(j_decompress_ptr cinfo , J_BUF_MODE pass_mode ) ;
   void (*post_process_data)(j_decompress_ptr cinfo , JSAMPIMAGE input_buf , JDIMENSION *in_row_group_ctr ,
                             JDIMENSION in_row_groups_avail , JSAMPARRAY output_buf ,
                             JDIMENSION *out_row_ctr , JDIMENSION out_rows_avail ) ;
};
#line 189 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpegint.h"
struct jpeg_marker_reader {
   void (*reset_marker_reader)(j_decompress_ptr cinfo ) ;
   int (*read_markers)(j_decompress_ptr cinfo ) ;
   boolean (*read_restart_marker)(j_decompress_ptr cinfo ) ;
   boolean saw_SOI ;
   boolean saw_SOF ;
   int next_restart_num ;
   unsigned int discarded_bytes ;
};
#line 209 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpegint.h"
struct jpeg_entropy_decoder {
   void (*start_pass)(j_decompress_ptr cinfo ) ;
   boolean (*decode_mcu)(j_decompress_ptr cinfo , JBLOCKROW *MCU_data ) ;
   boolean insufficient_data ;
};
#line 220 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpegint.h"
typedef void (*inverse_DCT_method_ptr)(j_decompress_ptr cinfo , jpeg_component_info *compptr ,
                                       JCOEFPTR coef_block , JSAMPARRAY output_buf ,
                                       JDIMENSION output_col );
#line 225 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpegint.h"
struct jpeg_inverse_dct {
   void (*start_pass)(j_decompress_ptr cinfo ) ;
   inverse_DCT_method_ptr inverse_DCT[10] ;
};
#line 232 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpegint.h"
struct jpeg_upsampler {
   void (*start_pass)(j_decompress_ptr cinfo ) ;
   void (*upsample)(j_decompress_ptr cinfo , JSAMPIMAGE input_buf , JDIMENSION *in_row_group_ctr ,
                    JDIMENSION in_row_groups_avail , JSAMPARRAY output_buf , JDIMENSION *out_row_ctr ,
                    JDIMENSION out_rows_avail ) ;
   boolean need_context_rows ;
};
#line 246 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpegint.h"
struct jpeg_color_deconverter {
   void (*start_pass)(j_decompress_ptr cinfo ) ;
   void (*color_convert)(j_decompress_ptr cinfo , JSAMPIMAGE input_buf , JDIMENSION input_row ,
                         JSAMPARRAY output_buf , int num_rows ) ;
};
#line 254 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpegint.h"
struct jpeg_color_quantizer {
   void (*start_pass)(j_decompress_ptr cinfo , boolean is_pre_scan ) ;
   void (*color_quantize)(j_decompress_ptr cinfo , JSAMPARRAY input_buf , JSAMPARRAY output_buf ,
                          int num_rows ) ;
   void (*finish_pass)(j_decompress_ptr cinfo ) ;
   void (*new_color_map)(j_decompress_ptr cinfo ) ;
};
#line 114 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jdmainct.c"
struct __anonstruct_my_main_controller_35 {
   struct jpeg_d_main_controller pub ;
   JSAMPARRAY buffer[10] ;
   boolean buffer_full ;
   JDIMENSION rowgroup_ctr ;
   JSAMPIMAGE xbuffer[2] ;
   int whichptr ;
   int context_state ;
   JDIMENSION rowgroups_avail ;
   JDIMENSION iMCU_row_ctr ;
};
#line 114 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jdmainct.c"
typedef struct __anonstruct_my_main_controller_35 my_main_controller;
#line 134 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jdmainct.c"
typedef my_main_controller *my_main_ptr;
#line 161 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmorecfg.h"
typedef long INT32;
#line 18 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jccolor.c"
struct __anonstruct_my_color_converter_35 {
   struct jpeg_color_converter pub ;
   INT32 *rgb_ycc_tab ;
};
#line 18 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jccolor.c"
typedef struct __anonstruct_my_color_converter_35 my_color_converter;
#line 25 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jccolor.c"
typedef my_color_converter *my_cconvert_ptr;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned char u_int8_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 27 "missing/md5.h"
typedef struct MD5Context MD5_CTX;
#line 44 "/home/wheatley/newnew/temp/outguess-0.2/arc.h"
struct arc4_stream {
   u_int8_t i ;
   u_int8_t j ;
   u_int8_t s[256] ;
};
#line 155 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmorecfg.h"
typedef short INT16;
#line 30 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jdct.h"
typedef int DCTELEM;
#line 22 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcdctmgr.c"
struct __anonstruct_my_fdct_controller_35 {
   struct jpeg_forward_dct pub ;
   void (*do_dct)(DCTELEM *data ) ;
   DCTELEM *divisors[4] ;
   void (*do_float_dct)(float *data ) ;
   float *float_divisors[4] ;
};
#line 22 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcdctmgr.c"
typedef struct __anonstruct_my_fdct_controller_35 my_fdct_controller;
#line 41 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcdctmgr.c"
typedef my_fdct_controller *my_fdct_ptr;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 201 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short u_int16_t;
#line 203 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned long u_int64_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 76 "/home/wheatley/newnew/temp/outguess-0.2/outguess.h"
struct _stegres {
   int error ;
   int changed ;
   int bias ;
};
#line 76 "/home/wheatley/newnew/temp/outguess-0.2/outguess.h"
typedef struct _stegres stegres;
#line 82 "/home/wheatley/newnew/temp/outguess-0.2/outguess.h"
struct _config {
   int flags ;
   int siter ;
   int siterstart ;
};
#line 82 "/home/wheatley/newnew/temp/outguess-0.2/outguess.h"
typedef struct _config config;
#line 99
struct _iterator;
#line 44 "/home/wheatley/newnew/temp/outguess-0.2/iterator.h"
struct _iterator {
   struct arc4_stream as ;
   u_int32_t skipmod ;
   int off ;
};
#line 44 "/home/wheatley/newnew/temp/outguess-0.2/iterator.h"
typedef struct _iterator iterator;
#line 27 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jchuff.h"
struct __anonstruct_c_derived_tbl_35 {
   unsigned int ehufco[256] ;
   char ehufsi[256] ;
};
#line 27 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jchuff.h"
typedef struct __anonstruct_c_derived_tbl_35 c_derived_tbl;
#line 29 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jchuff.c"
struct __anonstruct_savable_state_36 {
   INT32 put_buffer ;
   int put_bits ;
   int last_dc_val[4] ;
};
#line 29 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jchuff.c"
typedef struct __anonstruct_savable_state_36 savable_state;
#line 55 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jchuff.c"
struct __anonstruct_huff_entropy_encoder_37 {
   struct jpeg_entropy_encoder pub ;
   savable_state saved ;
   unsigned int restarts_to_go ;
   int next_restart_num ;
   c_derived_tbl *dc_derived_tbls[4] ;
   c_derived_tbl *ac_derived_tbls[4] ;
   long *dc_count_ptrs[4] ;
   long *ac_count_ptrs[4] ;
};
#line 55 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jchuff.c"
typedef struct __anonstruct_huff_entropy_encoder_37 huff_entropy_encoder;
#line 74 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jchuff.c"
typedef huff_entropy_encoder *huff_entropy_ptr;
#line 80 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jchuff.c"
struct __anonstruct_working_state_38 {
   JOCTET *next_output_byte ;
   size_t free_in_buffer ;
   savable_state cur ;
   j_compress_ptr cinfo ;
};
#line 80 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jchuff.c"
typedef struct __anonstruct_working_state_38 working_state;
#line 34 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jccoefct.c"
struct __anonstruct_my_coef_controller_35 {
   struct jpeg_c_coef_controller pub ;
   JDIMENSION iMCU_row_num ;
   JDIMENSION mcu_ctr ;
   int MCU_vert_offset ;
   int MCU_rows_per_iMCU_row ;
   JBLOCKROW MCU_buffer[10] ;
   jvirt_barray_ptr whole_image[10] ;
};
#line 34 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jccoefct.c"
typedef struct __anonstruct_my_coef_controller_35 my_coef_controller;
#line 57 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jccoefct.c"
typedef my_coef_controller *my_coef_ptr;
#line 755 "/home/wheatley/newnew/temp/outguess-0.2/jpg.c"
struct __anonstruct_my_destination_mgr_34 {
   struct jpeg_destination_mgr pub ;
};
#line 755 "/home/wheatley/newnew/temp/outguess-0.2/jpg.c"
typedef struct __anonstruct_my_destination_mgr_34 my_destination_mgr;
#line 763 "/home/wheatley/newnew/temp/outguess-0.2/jpg.c"
typedef my_destination_mgr *my_dest_ptr;
#line 16 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmarker.c"
enum __anonenum_JPEG_MARKER_35 {
    M_SOF0 = 192,
    M_SOF1 = 193,
    M_SOF2 = 194,
    M_SOF3 = 195,
    M_SOF5 = 197,
    M_SOF6 = 198,
    M_SOF7 = 199,
    M_JPG = 200,
    M_SOF9 = 201,
    M_SOF10 = 202,
    M_SOF11 = 203,
    M_SOF13 = 205,
    M_SOF14 = 206,
    M_SOF15 = 207,
    M_DHT = 196,
    M_DAC = 204,
    M_RST0 = 208,
    M_RST1 = 209,
    M_RST2 = 210,
    M_RST3 = 211,
    M_RST4 = 212,
    M_RST5 = 213,
    M_RST6 = 214,
    M_RST7 = 215,
    M_SOI = 216,
    M_EOI = 217,
    M_SOS = 218,
    M_DQT = 219,
    M_DNL = 220,
    M_DRI = 221,
    M_DHP = 222,
    M_EXP = 223,
    M_APP0 = 224,
    M_APP1 = 225,
    M_APP2 = 226,
    M_APP3 = 227,
    M_APP4 = 228,
    M_APP5 = 229,
    M_APP6 = 230,
    M_APP7 = 231,
    M_APP8 = 232,
    M_APP9 = 233,
    M_APP10 = 234,
    M_APP11 = 235,
    M_APP12 = 236,
    M_APP13 = 237,
    M_APP14 = 238,
    M_APP15 = 239,
    M_JPG0 = 240,
    M_JPG13 = 253,
    M_COM = 254,
    M_TEM = 1,
    M_ERROR = 256
} ;
#line 16 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmarker.c"
typedef enum __anonenum_JPEG_MARKER_35 JPEG_MARKER;
#line 86 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmarker.c"
struct __anonstruct_my_marker_writer_36 {
   struct jpeg_marker_writer pub ;
   unsigned int last_restart_interval ;
};
#line 86 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmarker.c"
typedef struct __anonstruct_my_marker_writer_36 my_marker_writer;
#line 92 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmarker.c"
typedef my_marker_writer *my_marker_ptr;
#line 21 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmaster.c"
enum __anonenum_c_pass_type_35 {
    main_pass = 0,
    huff_opt_pass = 1,
    output_pass = 2
} ;
#line 21 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmaster.c"
typedef enum __anonenum_c_pass_type_35 c_pass_type;
#line 27 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmaster.c"
struct __anonstruct_my_comp_master_36 {
   struct jpeg_comp_master pub ;
   c_pass_type pass_type ;
   int pass_number ;
   int total_passes ;
   int scan_number ;
};
#line 27 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmaster.c"
typedef struct __anonstruct_my_comp_master_36 my_comp_master;
#line 38 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmaster.c"
typedef my_comp_master *my_master_ptr;
#line 28 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmainct.c"
struct __anonstruct_my_main_controller_35___0 {
   struct jpeg_c_main_controller pub ;
   JDIMENSION cur_iMCU_row ;
   JDIMENSION rowgroup_ctr ;
   boolean suspended ;
   J_BUF_MODE pass_mode ;
   JSAMPARRAY buffer[10] ;
};
#line 28 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmainct.c"
typedef struct __anonstruct_my_main_controller_35___0 my_main_controller___0;
#line 50 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmainct.c"
typedef my_main_controller___0 *my_main_ptr___0;
#line 137 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmemsys.h"
struct backing_store_struct;
#line 137 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmemsys.h"
typedef struct backing_store_struct *backing_store_ptr;
#line 139 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmemsys.h"
struct backing_store_struct {
   void (*read_backing_store)(j_common_ptr cinfo , backing_store_ptr info , void *buffer_address ,
                              long file_offset , long byte_count ) ;
   void (*write_backing_store)(j_common_ptr cinfo , backing_store_ptr info , void *buffer_address ,
                               long file_offset , long byte_count ) ;
   void (*close_backing_store)(j_common_ptr cinfo , backing_store_ptr info ) ;
   FILE *temp_file ;
   char temp_name[64] ;
};
#line 139 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmemsys.h"
typedef struct backing_store_struct backing_store_info;
#line 89 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmemmgr.c"
union small_pool_struct;
#line 89 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmemmgr.c"
typedef union small_pool_struct *small_pool_ptr;
#line 91 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmemmgr.c"
struct __anonstruct_hdr_35 {
   small_pool_ptr next ;
   size_t bytes_used ;
   size_t bytes_left ;
};
#line 91 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmemmgr.c"
union small_pool_struct {
   struct __anonstruct_hdr_35 hdr ;
   double dummy ;
};
#line 91 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmemmgr.c"
typedef union small_pool_struct small_pool_hdr;
#line 100
union large_pool_struct;
#line 100 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmemmgr.c"
typedef union large_pool_struct *large_pool_ptr;
#line 102 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmemmgr.c"
struct __anonstruct_hdr_36 {
   large_pool_ptr next ;
   size_t bytes_used ;
   size_t bytes_left ;
};
#line 102 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmemmgr.c"
union large_pool_struct {
   struct __anonstruct_hdr_36 hdr ;
   double dummy ;
};
#line 102 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmemmgr.c"
typedef union large_pool_struct large_pool_hdr;
#line 116 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmemmgr.c"
struct __anonstruct_my_memory_mgr_37 {
   struct jpeg_memory_mgr pub ;
   small_pool_ptr small_list[2] ;
   large_pool_ptr large_list[2] ;
   jvirt_sarray_ptr virt_sarray_list ;
   jvirt_barray_ptr virt_barray_list ;
   long total_space_allocated ;
   JDIMENSION last_rowsperchunk ;
};
#line 116 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmemmgr.c"
typedef struct __anonstruct_my_memory_mgr_37 my_memory_mgr;
#line 140 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmemmgr.c"
typedef my_memory_mgr *my_mem_ptr;
#line 150 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmemmgr.c"
struct jvirt_sarray_control {
   JSAMPARRAY mem_buffer ;
   JDIMENSION rows_in_array ;
   JDIMENSION samplesperrow ;
   JDIMENSION maxaccess ;
   JDIMENSION rows_in_mem ;
   JDIMENSION rowsperchunk ;
   JDIMENSION cur_start_row ;
   JDIMENSION first_undef_row ;
   boolean pre_zero ;
   boolean dirty ;
   boolean b_s_open ;
   jvirt_sarray_ptr next ;
   backing_store_info b_s_info ;
};
#line 166 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmemmgr.c"
struct jvirt_barray_control {
   JBLOCKARRAY mem_buffer ;
   JDIMENSION rows_in_array ;
   JDIMENSION blocksperrow ;
   JDIMENSION maxaccess ;
   JDIMENSION rows_in_mem ;
   JDIMENSION rowsperchunk ;
   JDIMENSION cur_start_row ;
   JDIMENSION first_undef_row ;
   boolean pre_zero ;
   boolean dirty ;
   boolean b_s_open ;
   jvirt_barray_ptr next ;
   backing_store_info b_s_info ;
};
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 900 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpeglib.h"
void jpeg_CreateCompress(j_compress_ptr cinfo , int version , size_t structsize ) ;
#line 905
void jpeg_destroy_compress(j_compress_ptr cinfo ) ;
#line 930
void jpeg_suppress_tables(j_compress_ptr cinfo , boolean suppress ) ;
#line 941
void jpeg_finish_compress(j_compress_ptr cinfo ) ;
#line 949
void jpeg_write_marker(j_compress_ptr cinfo , int marker , JOCTET const   *dataptr ,
                       unsigned int datalen ) ;
#line 953
void jpeg_write_m_header(j_compress_ptr cinfo , int marker , unsigned int datalen ) ;
#line 955
void jpeg_write_m_byte(j_compress_ptr cinfo , int val ) ;
#line 959
void jpeg_write_tables(j_compress_ptr cinfo ) ;
#line 1027
void jpeg_abort_compress(j_compress_ptr cinfo ) ;
#line 1033
extern void jpeg_abort(j_common_ptr cinfo ) ;
#line 1034
extern void jpeg_destroy(j_common_ptr cinfo ) ;
#line 348 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpegint.h"
void jinit_marker_writer(j_compress_ptr cinfo ) ;
#line 368
void jinit_memory_mgr(j_common_ptr cinfo ) ;
#line 29 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcapimin.c"
void jpeg_CreateCompress(j_compress_ptr cinfo , int version , size_t structsize ) 
{ 
  int i ;
  struct jpeg_error_mgr *err___0 ;
  void *client_data ;

  {
#line 35
  cinfo->mem = (struct jpeg_memory_mgr *)((void *)0);
#line 36
  if (version != 62) {
    {
#line 37
    (cinfo->err)->msg_code = 12;
#line 37
    (cinfo->err)->msg_parm.i[0] = 62;
#line 37
    (cinfo->err)->msg_parm.i[1] = version;
#line 37
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
#line 38
  if (structsize != sizeof(struct jpeg_compress_struct )) {
    {
#line 39
    (cinfo->err)->msg_code = 21;
#line 39
    (cinfo->err)->msg_parm.i[0] = (int )sizeof(struct jpeg_compress_struct );
#line 39
    (cinfo->err)->msg_parm.i[1] = (int )structsize;
#line 39
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
  {
#line 49
  err___0 = cinfo->err;
#line 50
  client_data = cinfo->client_data;
#line 51
  memset((void *)cinfo, 0, sizeof(struct jpeg_compress_struct ));
#line 52
  cinfo->err = err___0;
#line 53
  cinfo->client_data = client_data;
#line 55
  cinfo->is_decompressor = 0;
#line 58
  jinit_memory_mgr((j_common_ptr )cinfo);
#line 61
  cinfo->progress = (struct jpeg_progress_mgr *)((void *)0);
#line 62
  cinfo->dest = (struct jpeg_destination_mgr *)((void *)0);
#line 64
  cinfo->comp_info = (jpeg_component_info *)((void *)0);
#line 66
  i = 0;
  }
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! (i < 4)) {
#line 66
      goto while_break;
    }
#line 67
    cinfo->quant_tbl_ptrs[i] = (JQUANT_TBL *)((void *)0);
#line 66
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  i = 0;
  {
#line 69
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 69
    if (! (i < 4)) {
#line 69
      goto while_break___0;
    }
#line 70
    cinfo->dc_huff_tbl_ptrs[i] = (JHUFF_TBL *)((void *)0);
#line 71
    cinfo->ac_huff_tbl_ptrs[i] = (JHUFF_TBL *)((void *)0);
#line 69
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 74
  cinfo->script_space = (jpeg_scan_info *)((void *)0);
#line 76
  cinfo->input_gamma = 1.0;
#line 79
  cinfo->global_state = 100;
#line 80
  return;
}
}
#line 87 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcapimin.c"
void jpeg_destroy_compress(j_compress_ptr cinfo ) 
{ 


  {
  {
#line 90
  jpeg_destroy((j_common_ptr )cinfo);
  }
#line 91
  return;
}
}
#line 99 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcapimin.c"
void jpeg_abort_compress(j_compress_ptr cinfo ) 
{ 


  {
  {
#line 102
  jpeg_abort((j_common_ptr )cinfo);
  }
#line 103
  return;
}
}
#line 118 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcapimin.c"
void jpeg_suppress_tables(j_compress_ptr cinfo , boolean suppress ) 
{ 
  int i ;
  JQUANT_TBL *qtbl ;
  JHUFF_TBL *htbl ;

  {
#line 125
  i = 0;
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 125
    if (! (i < 4)) {
#line 125
      goto while_break;
    }
#line 126
    qtbl = cinfo->quant_tbl_ptrs[i];
#line 126
    if ((unsigned long )qtbl != (unsigned long )((void *)0)) {
#line 127
      qtbl->sent_table = suppress;
    }
#line 125
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  i = 0;
  {
#line 130
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 130
    if (! (i < 4)) {
#line 130
      goto while_break___0;
    }
#line 131
    htbl = cinfo->dc_huff_tbl_ptrs[i];
#line 131
    if ((unsigned long )htbl != (unsigned long )((void *)0)) {
#line 132
      htbl->sent_table = suppress;
    }
#line 133
    htbl = cinfo->ac_huff_tbl_ptrs[i];
#line 133
    if ((unsigned long )htbl != (unsigned long )((void *)0)) {
#line 134
      htbl->sent_table = suppress;
    }
#line 130
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 136
  return;
}
}
#line 146 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcapimin.c"
void jpeg_finish_compress(j_compress_ptr cinfo ) 
{ 
  JDIMENSION iMCU_row ;
  boolean tmp ;

  {
#line 151
  if (cinfo->global_state == 101) {
#line 151
    goto _L;
  } else
#line 151
  if (cinfo->global_state == 102) {
    _L: /* CIL Label */ 
#line 154
    if (cinfo->next_scanline < cinfo->image_height) {
      {
#line 155
      (cinfo->err)->msg_code = 67;
#line 155
      (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
      }
    }
    {
#line 156
    (*((cinfo->master)->finish_pass))(cinfo);
    }
  } else
#line 157
  if (cinfo->global_state != 103) {
    {
#line 158
    (cinfo->err)->msg_code = 20;
#line 158
    (cinfo->err)->msg_parm.i[0] = cinfo->global_state;
#line 158
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    if (! (! (cinfo->master)->is_last_pass)) {
#line 160
      goto while_break;
    }
    {
#line 161
    (*((cinfo->master)->prepare_for_pass))(cinfo);
#line 162
    iMCU_row = (JDIMENSION )0;
    }
    {
#line 162
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 162
      if (! (iMCU_row < cinfo->total_iMCU_rows)) {
#line 162
        goto while_break___0;
      }
#line 163
      if ((unsigned long )cinfo->progress != (unsigned long )((void *)0)) {
        {
#line 164
        (cinfo->progress)->pass_counter = (long )iMCU_row;
#line 165
        (cinfo->progress)->pass_limit = (long )cinfo->total_iMCU_rows;
#line 166
        (*((cinfo->progress)->progress_monitor))((j_common_ptr )cinfo);
        }
      }
      {
#line 171
      tmp = (*((cinfo->coef)->compress_data))(cinfo, (JSAMPIMAGE )((void *)0));
      }
#line 171
      if (! tmp) {
        {
#line 172
        (cinfo->err)->msg_code = 24;
#line 172
        (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
        }
      }
#line 162
      iMCU_row ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 174
    (*((cinfo->master)->finish_pass))(cinfo);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 177
  (*((cinfo->marker)->write_file_trailer))(cinfo);
#line 178
  (*((cinfo->dest)->term_destination))(cinfo);
#line 180
  jpeg_abort((j_common_ptr )cinfo);
  }
#line 181
  return;
}
}
#line 191 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcapimin.c"
void jpeg_write_marker(j_compress_ptr cinfo , int marker , JOCTET const   *dataptr ,
                       unsigned int datalen ) 
{ 
  void (*write_marker_byte___0)(j_compress_ptr info , int val ) ;
  unsigned int tmp ;

  {
#line 197
  if (cinfo->next_scanline != 0U) {
    {
#line 201
    (cinfo->err)->msg_code = 20;
#line 201
    (cinfo->err)->msg_parm.i[0] = cinfo->global_state;
#line 201
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  } else
#line 197
  if (cinfo->global_state != 101) {
#line 197
    if (cinfo->global_state != 102) {
#line 197
      if (cinfo->global_state != 103) {
        {
#line 201
        (cinfo->err)->msg_code = 20;
#line 201
        (cinfo->err)->msg_parm.i[0] = cinfo->global_state;
#line 201
        (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
        }
      }
    }
  }
  {
#line 203
  (*((cinfo->marker)->write_marker_header))(cinfo, marker, datalen);
#line 204
  write_marker_byte___0 = (cinfo->marker)->write_marker_byte;
  }
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 205
    tmp = datalen;
#line 205
    datalen --;
#line 205
    if (! tmp) {
#line 205
      goto while_break;
    }
    {
#line 206
    (*write_marker_byte___0)(cinfo, (int )*dataptr);
#line 207
    dataptr ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 209
  return;
}
}
#line 213 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcapimin.c"
void jpeg_write_m_header(j_compress_ptr cinfo , int marker , unsigned int datalen ) 
{ 


  {
#line 216
  if (cinfo->next_scanline != 0U) {
    {
#line 220
    (cinfo->err)->msg_code = 20;
#line 220
    (cinfo->err)->msg_parm.i[0] = cinfo->global_state;
#line 220
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  } else
#line 216
  if (cinfo->global_state != 101) {
#line 216
    if (cinfo->global_state != 102) {
#line 216
      if (cinfo->global_state != 103) {
        {
#line 220
        (cinfo->err)->msg_code = 20;
#line 220
        (cinfo->err)->msg_parm.i[0] = cinfo->global_state;
#line 220
        (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
        }
      }
    }
  }
  {
#line 222
  (*((cinfo->marker)->write_marker_header))(cinfo, marker, datalen);
  }
#line 223
  return;
}
}
#line 225 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcapimin.c"
void jpeg_write_m_byte(j_compress_ptr cinfo , int val ) 
{ 


  {
  {
#line 228
  (*((cinfo->marker)->write_marker_byte))(cinfo, val);
  }
#line 229
  return;
}
}
#line 253 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcapimin.c"
void jpeg_write_tables(j_compress_ptr cinfo ) 
{ 


  {
#line 256
  if (cinfo->global_state != 100) {
    {
#line 257
    (cinfo->err)->msg_code = 20;
#line 257
    (cinfo->err)->msg_parm.i[0] = cinfo->global_state;
#line 257
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
  {
#line 260
  (*((cinfo->err)->reset_error_mgr))((j_common_ptr )cinfo);
#line 261
  (*((cinfo->dest)->init_destination))(cinfo);
#line 263
  jinit_marker_writer(cinfo);
#line 265
  (*((cinfo->marker)->write_tables_only))(cinfo);
#line 267
  (*((cinfo->dest)->term_destination))(cinfo);
  }
#line 280
  return;
}
}
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 702
extern int ungetc(int __c , FILE *__stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 94 "/home/wheatley/newnew/temp/outguess-0.2/outguess.h"
void *checkedmalloc(size_t n ) ;
#line 63 "/home/wheatley/newnew/temp/outguess-0.2/pnm.h"
handler pnm_handler ;
#line 65
void skip_white(FILE *f ) ;
#line 67
void init_pnm(char *parameter ) ;
#line 69
int preserve_pnm(bitmap *bitmap___0 , int off___0 ) ;
#line 71
void bitmap_to_pnm(image *image___0 , bitmap *bitmap___0 , int flags ) ;
#line 72
void bitmap_from_pnm(bitmap *bitmap___0 , image *image___0 , int flags ) ;
#line 74
image *read_pnm(FILE *fin ) ;
#line 75
void write_pnm(FILE *fout , image *image___0 ) ;
#line 77
void free_pnm(image *image___0 ) ;
#line 48 "/home/wheatley/newnew/temp/outguess-0.2/pnm.c"
handler pnm_handler  =    {(char *)"ppm", & init_pnm, & read_pnm, & write_pnm, & bitmap_from_pnm, & bitmap_to_pnm,
    & preserve_pnm};
#line 58 "/home/wheatley/newnew/temp/outguess-0.2/pnm.c"
void init_pnm(char *parameter ) 
{ 


  {
#line 61
  return;
}
}
#line 63 "/home/wheatley/newnew/temp/outguess-0.2/pnm.c"
int preserve_pnm(bitmap *bitmap___0 , int off___0 ) 
{ 


  {
#line 67
  return (-1);
}
}
#line 71 "/home/wheatley/newnew/temp/outguess-0.2/pnm.c"
void skip_white(FILE *f ) 
{ 
  int c ;
  unsigned short const   **tmp ;

  {
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 77
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 77
      tmp = __ctype_b_loc();
#line 77
      c = _IO_getc(f);
      }
#line 77
      if (! ((int const   )*(*tmp + c) & 8192)) {
#line 77
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 78
    if (c == 35) {
      {
#line 79
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 79
        c = _IO_getc(f);
        }
#line 79
        if (c != 10) {
#line 79
          if (! (c != -1)) {
#line 79
            goto while_break___1;
          }
        } else {
#line 79
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      {
#line 81
      ungetc(c, f);
      }
#line 82
      return;
    }
#line 76
    if (! (c != -1)) {
#line 76
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  return;
}
}
#line 87 "/home/wheatley/newnew/temp/outguess-0.2/pnm.c"
void bitmap_to_pnm(image *image___0 , bitmap *bitmap___0 , int flags ) 
{ 
  int i ;
  int j ;
  int off___0 ;
  u_char tmp ;
  u_char *img ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 92
  img = image___0->img;
#line 94
  off___0 = 0;
#line 95
  i = 0;
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! (i < bitmap___0->bits)) {
#line 95
      goto while_break;
    }
#line 96
    tmp___0 = off___0;
#line 96
    off___0 ++;
#line 96
    tmp = *(bitmap___0->bitmap + tmp___0);
#line 97
    j = 0;
    {
#line 97
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 97
      if (j < 8) {
#line 97
        if (! (i < bitmap___0->bits)) {
#line 97
          goto while_break___0;
        }
      } else {
#line 97
        goto while_break___0;
      }
#line 98
      if (flags & 2) {
#line 98
        if ((int )*(bitmap___0->locked + i / 8) & (1 << (i & 7))) {
#line 99
          *(img + i) = (u_char )255;
        }
      }
#line 101
      tmp___1 = i;
#line 101
      i ++;
#line 101
      *(img + i) = (u_char )(((int )*(img + tmp___1) & -2) | ((int )tmp & 1));
#line 103
      tmp = (u_char )((int )tmp >> 1);
#line 97
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  return;
}
}
#line 108 "/home/wheatley/newnew/temp/outguess-0.2/pnm.c"
void bitmap_from_pnm(bitmap *bitmap___0 , image *image___0 , int flags ) 
{ 
  int i ;
  int j ;
  int off___0 ;
  u_char tmp ;
  u_char *img ;
  int x ;
  int y ;
  int depth ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 116
  img = image___0->img;
#line 117
  x = image___0->x;
#line 118
  y = image___0->y;
#line 119
  depth = image___0->depth;
#line 121
  memset((void *)bitmap___0, 0, sizeof(*bitmap___0));
#line 123
  bitmap___0->bits = (x * y) * depth;
#line 124
  bitmap___0->bytes = (bitmap___0->bits + 7) / 8;
#line 125
  tmp___0 = checkedmalloc((size_t )bitmap___0->bytes);
#line 125
  bitmap___0->bitmap = (u_char *)tmp___0;
#line 126
  tmp___1 = checkedmalloc((size_t )bitmap___0->bytes);
#line 126
  bitmap___0->locked = (u_char *)tmp___1;
#line 127
  tmp___2 = checkedmalloc((size_t )bitmap___0->bytes);
#line 127
  bitmap___0->metalock = (u_char *)tmp___2;
#line 128
  tmp___3 = checkedmalloc((size_t )bitmap___0->bits);
#line 128
  bitmap___0->detect = (char *)tmp___3;
#line 129
  tmp___4 = checkedmalloc((size_t )bitmap___0->bits);
#line 129
  bitmap___0->data = (char *)tmp___4;
#line 131
  memset((void *)bitmap___0->locked, 0, (size_t )bitmap___0->bytes);
#line 133
  off___0 = 0;
#line 134
  i = 0;
  }
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (! (i < bitmap___0->bits)) {
#line 134
      goto while_break;
    }
#line 135
    tmp = (u_char )0;
#line 136
    j = 0;
    {
#line 136
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 136
      if (j < 8) {
#line 136
        if (! (i < bitmap___0->bits)) {
#line 136
          goto while_break___0;
        }
      } else {
#line 136
        goto while_break___0;
      }
#line 138
      if ((int )*(img + i) >= 240) {
#line 139
        *(bitmap___0->detect + i) = (char)-1;
      } else
#line 140
      if ((int )*(img + i) <= 16) {
#line 141
        *(bitmap___0->detect + i) = (char)1;
      } else {
#line 143
        *(bitmap___0->detect + i) = (char)0;
      }
#line 145
      *(bitmap___0->data + i) = (char )*(img + i);
#line 147
      tmp___5 = i;
#line 147
      i ++;
#line 147
      tmp = (u_char )((int )tmp | (((int )*(img + tmp___5) & 1) << j));
#line 136
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 149
    tmp___6 = off___0;
#line 149
    off___0 ++;
#line 149
    *(bitmap___0->bitmap + tmp___6) = tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 151
  return;
}
}
#line 154 "/home/wheatley/newnew/temp/outguess-0.2/pnm.c"
image *read_pnm(FILE *fin ) 
{ 
  image *image___0 ;
  char magic[10] ;
  int i ;
  int v ;
  void *tmp ;
  unsigned short const   **tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 161
  tmp = checkedmalloc(sizeof(*image___0));
#line 161
  image___0 = (image *)tmp;
#line 162
  memset((void *)image___0, 0, sizeof(*image___0));
#line 164
  fgets((char */* __restrict  */)(magic), 10, (FILE */* __restrict  */)fin);
  }
#line 165
  if ((int )magic[0] != 80) {
    {
#line 166
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unsupported input file type!\n");
#line 167
    exit(1);
    }
  } else {
    {
#line 165
    tmp___0 = __ctype_b_loc();
    }
#line 165
    if ((int const   )*(*tmp___0 + (int )magic[1]) & 2048) {
#line 165
      if ((int )magic[2] != 10) {
        {
#line 166
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unsupported input file type!\n");
#line 167
        exit(1);
        }
      }
    } else {
      {
#line 166
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unsupported input file type!\n");
#line 167
      exit(1);
      }
    }
  }
  {
#line 169
  skip_white(fin);
#line 170
  fscanf((FILE */* __restrict  */)fin, (char const   */* __restrict  */)"%d", & image___0->x);
#line 171
  skip_white(fin);
#line 172
  fscanf((FILE */* __restrict  */)fin, (char const   */* __restrict  */)"%d", & image___0->y);
#line 173
  skip_white(fin);
#line 174
  fscanf((FILE */* __restrict  */)fin, (char const   */* __restrict  */)"%d", & image___0->max);
#line 175
  _IO_getc(fin);
  }
#line 176
  if (image___0->max > 255) {
    {
#line 178
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unsupported value range!\n");
#line 179
    exit(1);
    }
  } else
#line 176
  if (image___0->max <= 0) {
    {
#line 178
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unsupported value range!\n");
#line 179
    exit(1);
    }
  } else
#line 176
  if (image___0->x <= 1) {
    {
#line 178
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unsupported value range!\n");
#line 179
    exit(1);
    }
  } else
#line 176
  if (image___0->y <= 1) {
    {
#line 178
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unsupported value range!\n");
#line 179
    exit(1);
    }
  }
  {
#line 184
  if ((int )magic[1] == 53) {
#line 184
    goto case_53;
  }
#line 184
  if ((int )magic[1] == 50) {
#line 184
    goto case_53;
  }
#line 188
  if ((int )magic[1] == 54) {
#line 188
    goto case_54;
  }
#line 188
  if ((int )magic[1] == 51) {
#line 188
    goto case_54;
  }
#line 191
  goto switch_default;
  case_53: /* CIL Label */ 
  case_50: /* CIL Label */ 
#line 185
  image___0->depth = 1;
#line 186
  goto switch_break;
  case_54: /* CIL Label */ 
  case_51: /* CIL Label */ 
#line 189
  image___0->depth = 3;
#line 190
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 192
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unsupported input file type \'P%c\'!\n",
          (int )magic[1]);
#line 193
  exit(1);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 196
  tmp___1 = checkedmalloc(((sizeof(unsigned char ) * (unsigned long )image___0->x) * (unsigned long )image___0->y) * (unsigned long )image___0->depth);
#line 196
  image___0->img = (unsigned char *)tmp___1;
  }
  {
#line 202
  if ((int )magic[1] == 51) {
#line 202
    goto case_51___0;
  }
#line 202
  if ((int )magic[1] == 50) {
#line 202
    goto case_51___0;
  }
#line 214
  if ((int )magic[1] == 54) {
#line 214
    goto case_54___0;
  }
#line 214
  if ((int )magic[1] == 53) {
#line 214
    goto case_54___0;
  }
#line 200
  goto switch_break___0;
  case_51___0: /* CIL Label */ 
  case_50___0: /* CIL Label */ 
#line 203
  i = 0;
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (! (i < (image___0->x * image___0->y) * image___0->depth)) {
#line 203
      goto while_break;
    }
    {
#line 204
    skip_white(fin);
#line 205
    fscanf((FILE */* __restrict  */)fin, (char const   */* __restrict  */)"%d", & v);
    }
#line 206
    if (v < 0) {
      {
#line 207
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of range value!\n");
#line 208
      exit(1);
      }
    } else
#line 206
    if (v > image___0->max) {
      {
#line 207
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of range value!\n");
#line 208
      exit(1);
      }
    }
#line 210
    *(image___0->img + i) = (u_char )v;
#line 203
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 212
  goto switch_break___0;
  case_54___0: /* CIL Label */ 
  case_53___0: /* CIL Label */ 
  {
#line 215
  fread((void */* __restrict  */)image___0->img, (size_t )(image___0->x * image___0->depth),
        (size_t )image___0->y, (FILE */* __restrict  */)fin);
  }
#line 216
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 219
  tmp___2 = ferror(fin);
  }
#line 219
  if (tmp___2) {
    {
#line 220
    perror("Error occured while reading input file");
#line 221
    exit(1);
    }
  }
  {
#line 223
  tmp___3 = feof(fin);
  }
#line 223
  if (tmp___3) {
    {
#line 224
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected end of input file!\n");
#line 225
    exit(1);
    }
  }
#line 228
  return (image___0);
}
}
#line 231 "/home/wheatley/newnew/temp/outguess-0.2/pnm.c"
void write_pnm(FILE *fout , image *image___0 ) 
{ 
  int tmp ;

  {
#line 234
  if (image___0->depth == 1) {
#line 234
    tmp = 5;
  } else {
#line 234
    tmp = 6;
  }
  {
#line 234
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"P%d\n%d %d\n%d\n",
          tmp, image___0->x, image___0->y, image___0->max);
#line 237
  fwrite((void const   */* __restrict  */)image___0->img, (size_t )((image___0->x * image___0->y) * image___0->depth),
         sizeof(u_char ), (FILE */* __restrict  */)fout);
  }
#line 239
  return;
}
}
#line 241 "/home/wheatley/newnew/temp/outguess-0.2/pnm.c"
void free_pnm(image *image___0 ) 
{ 


  {
  {
#line 244
  free((void *)image___0->img);
#line 245
  free((void *)image___0);
  }
#line 246
  return;
}
}
#line 19 "/home/wheatley/newnew/temp/outguess-0.2/missing/md5.h"
void MD5Init(struct MD5Context *ctx ) ;
#line 20
void MD5Update(struct MD5Context *ctx , unsigned char const   *buf , unsigned int len ) ;
#line 21
void MD5Final(unsigned char *digest , struct MD5Context *ctx ) ;
#line 22
void MD5Transform(uint32 *buf , unsigned char const   *inraw ) ;
#line 38 "/home/wheatley/newnew/temp/outguess-0.2/missing/md5.c"
static uint32 getu32(unsigned char const   *addr ) 
{ 


  {
#line 42
  return (((((((unsigned long )*(addr + 3) << 8) | (unsigned long )*(addr + 2)) << 8) | (unsigned long )*(addr + 1)) << 8) | (unsigned long )*(addr + 0));
}
}
#line 46 "/home/wheatley/newnew/temp/outguess-0.2/missing/md5.c"
static void putu32(uint32 data___0 , unsigned char *addr ) 
{ 


  {
#line 51
  *(addr + 0) = (unsigned char )data___0;
#line 52
  *(addr + 1) = (unsigned char )(data___0 >> 8);
#line 53
  *(addr + 2) = (unsigned char )(data___0 >> 16);
#line 54
  *(addr + 3) = (unsigned char )(data___0 >> 24);
#line 55
  return;
}
}
#line 61 "/home/wheatley/newnew/temp/outguess-0.2/missing/md5.c"
void MD5Init(struct MD5Context *ctx ) 
{ 


  {
#line 65
  ctx->buf[0] = (uint32 )1732584193;
#line 66
  ctx->buf[1] = (uint32 )4023233417U;
#line 67
  ctx->buf[2] = (uint32 )2562383102U;
#line 68
  ctx->buf[3] = (uint32 )271733878;
#line 70
  ctx->bits[0] = (uint32 )0;
#line 71
  ctx->bits[1] = (uint32 )0;
#line 72
  return;
}
}
#line 102
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 78 "/home/wheatley/newnew/temp/outguess-0.2/missing/md5.c"
void MD5Update(struct MD5Context *ctx , unsigned char const   *buf , unsigned int len ) 
{ 
  uint32 t ;
  uint32 tmp ;
  unsigned char *p ;

  {
#line 88
  t = ctx->bits[0];
#line 89
  tmp = (t + ((uint32 )len << 3)) & 4294967295UL;
#line 89
  ctx->bits[0] = tmp;
#line 89
  if (tmp < t) {
#line 90
    (ctx->bits[1]) ++;
  }
#line 91
  ctx->bits[1] += (uint32 )(len >> 29);
#line 93
  t = (t >> 3) & 63UL;
#line 97
  if (t) {
#line 98
    p = ctx->in + t;
#line 100
    t = 64UL - t;
#line 101
    if ((uint32 )len < t) {
      {
#line 102
      memcpy(p, buf, len);
      }
#line 103
      return;
    }
    {
#line 105
    memcpy(p, buf, t);
#line 106
    MD5Transform((uint32 *)(ctx->buf), (unsigned char const   *)(ctx->in));
#line 107
    buf += t;
#line 108
    len = (unsigned int )((uint32 )len - t);
    }
  }
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! (len >= 64U)) {
#line 113
      goto while_break;
    }
    {
#line 114
    memcpy(ctx->in, buf, 64);
#line 115
    MD5Transform((uint32 *)(ctx->buf), (unsigned char const   *)(ctx->in));
#line 116
    buf += 64;
#line 117
    len -= 64U;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 122
  memcpy(ctx->in, buf, len);
  }
#line 123
  return;
}
}
#line 129 "/home/wheatley/newnew/temp/outguess-0.2/missing/md5.c"
void MD5Final(unsigned char *digest , struct MD5Context *ctx ) 
{ 
  unsigned int count ;
  unsigned char *p ;
  unsigned char *tmp ;

  {
#line 138
  count = (unsigned int )((ctx->bits[0] >> 3) & 63UL);
#line 142
  p = ctx->in + count;
#line 143
  tmp = p;
#line 143
  p ++;
#line 143
  *tmp = (unsigned char)128;
#line 146
  count = 63U - count;
#line 149
  if (count < 8U) {
    {
#line 151
    memset(p, 0, count);
#line 152
    MD5Transform((uint32 *)(ctx->buf), (unsigned char const   *)(ctx->in));
#line 155
    memset(ctx->in, 0, 56);
    }
  } else {
    {
#line 158
    memset(p, 0, count - 8U);
    }
  }
  {
#line 162
  putu32(ctx->bits[0], ctx->in + 56);
#line 163
  putu32(ctx->bits[1], ctx->in + 60);
#line 165
  MD5Transform((uint32 *)(ctx->buf), (unsigned char const   *)(ctx->in));
#line 166
  putu32(ctx->buf[0], (unsigned char *)digest);
#line 167
  putu32(ctx->buf[1], (unsigned char *)(digest + 4));
#line 168
  putu32(ctx->buf[2], (unsigned char *)(digest + 8));
#line 169
  putu32(ctx->buf[3], (unsigned char *)(digest + 12));
#line 170
  memset(ctx, 0, sizeof(ctx));
  }
#line 171
  return;
}
}
#line 192 "/home/wheatley/newnew/temp/outguess-0.2/missing/md5.c"
void MD5Transform(uint32 *buf , unsigned char const   *inraw ) 
{ 
  register uint32 a___0 ;
  register uint32 b ;
  register uint32 c ;
  register uint32 d ;
  uint32 in[16] ;
  int i ;

  {
#line 201
  i = 0;
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    if (! (i < 16)) {
#line 201
      goto while_break;
    }
    {
#line 202
    in[i] = getu32((unsigned char const   *)(inraw + 4 * i));
#line 201
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 204
  a___0 = *(buf + 0);
#line 205
  b = *(buf + 1);
#line 206
  c = *(buf + 2);
#line 207
  d = *(buf + 3);
#line 209
  a___0 += ((d ^ (b & (c ^ d))) + in[0]) + 3614090360UL;
#line 209
  a___0 &= 4294967295UL;
#line 209
  a___0 = (a___0 << 7) | (a___0 >> 25);
#line 209
  a___0 += b;
#line 210
  d += ((c ^ (a___0 & (b ^ c))) + in[1]) + 3905402710UL;
#line 210
  d &= 4294967295UL;
#line 210
  d = (d << 12) | (d >> 20);
#line 210
  d += a___0;
#line 211
  c += ((b ^ (d & (a___0 ^ b))) + in[2]) + 606105819UL;
#line 211
  c &= 4294967295UL;
#line 211
  c = (c << 17) | (c >> 15);
#line 211
  c += d;
#line 212
  b += ((a___0 ^ (c & (d ^ a___0))) + in[3]) + 3250441966UL;
#line 212
  b &= 4294967295UL;
#line 212
  b = (b << 22) | (b >> 10);
#line 212
  b += c;
#line 213
  a___0 += ((d ^ (b & (c ^ d))) + in[4]) + 4118548399UL;
#line 213
  a___0 &= 4294967295UL;
#line 213
  a___0 = (a___0 << 7) | (a___0 >> 25);
#line 213
  a___0 += b;
#line 214
  d += ((c ^ (a___0 & (b ^ c))) + in[5]) + 1200080426UL;
#line 214
  d &= 4294967295UL;
#line 214
  d = (d << 12) | (d >> 20);
#line 214
  d += a___0;
#line 215
  c += ((b ^ (d & (a___0 ^ b))) + in[6]) + 2821735955UL;
#line 215
  c &= 4294967295UL;
#line 215
  c = (c << 17) | (c >> 15);
#line 215
  c += d;
#line 216
  b += ((a___0 ^ (c & (d ^ a___0))) + in[7]) + 4249261313UL;
#line 216
  b &= 4294967295UL;
#line 216
  b = (b << 22) | (b >> 10);
#line 216
  b += c;
#line 217
  a___0 += ((d ^ (b & (c ^ d))) + in[8]) + 1770035416UL;
#line 217
  a___0 &= 4294967295UL;
#line 217
  a___0 = (a___0 << 7) | (a___0 >> 25);
#line 217
  a___0 += b;
#line 218
  d += ((c ^ (a___0 & (b ^ c))) + in[9]) + 2336552879UL;
#line 218
  d &= 4294967295UL;
#line 218
  d = (d << 12) | (d >> 20);
#line 218
  d += a___0;
#line 219
  c += ((b ^ (d & (a___0 ^ b))) + in[10]) + 4294925233UL;
#line 219
  c &= 4294967295UL;
#line 219
  c = (c << 17) | (c >> 15);
#line 219
  c += d;
#line 220
  b += ((a___0 ^ (c & (d ^ a___0))) + in[11]) + 2304563134UL;
#line 220
  b &= 4294967295UL;
#line 220
  b = (b << 22) | (b >> 10);
#line 220
  b += c;
#line 221
  a___0 += ((d ^ (b & (c ^ d))) + in[12]) + 1804603682UL;
#line 221
  a___0 &= 4294967295UL;
#line 221
  a___0 = (a___0 << 7) | (a___0 >> 25);
#line 221
  a___0 += b;
#line 222
  d += ((c ^ (a___0 & (b ^ c))) + in[13]) + 4254626195UL;
#line 222
  d &= 4294967295UL;
#line 222
  d = (d << 12) | (d >> 20);
#line 222
  d += a___0;
#line 223
  c += ((b ^ (d & (a___0 ^ b))) + in[14]) + 2792965006UL;
#line 223
  c &= 4294967295UL;
#line 223
  c = (c << 17) | (c >> 15);
#line 223
  c += d;
#line 224
  b += ((a___0 ^ (c & (d ^ a___0))) + in[15]) + 1236535329UL;
#line 224
  b &= 4294967295UL;
#line 224
  b = (b << 22) | (b >> 10);
#line 224
  b += c;
#line 226
  a___0 += ((c ^ (d & (b ^ c))) + in[1]) + 4129170786UL;
#line 226
  a___0 &= 4294967295UL;
#line 226
  a___0 = (a___0 << 5) | (a___0 >> 27);
#line 226
  a___0 += b;
#line 227
  d += ((b ^ (c & (a___0 ^ b))) + in[6]) + 3225465664UL;
#line 227
  d &= 4294967295UL;
#line 227
  d = (d << 9) | (d >> 23);
#line 227
  d += a___0;
#line 228
  c += ((a___0 ^ (b & (d ^ a___0))) + in[11]) + 643717713UL;
#line 228
  c &= 4294967295UL;
#line 228
  c = (c << 14) | (c >> 18);
#line 228
  c += d;
#line 229
  b += ((d ^ (a___0 & (c ^ d))) + in[0]) + 3921069994UL;
#line 229
  b &= 4294967295UL;
#line 229
  b = (b << 20) | (b >> 12);
#line 229
  b += c;
#line 230
  a___0 += ((c ^ (d & (b ^ c))) + in[5]) + 3593408605UL;
#line 230
  a___0 &= 4294967295UL;
#line 230
  a___0 = (a___0 << 5) | (a___0 >> 27);
#line 230
  a___0 += b;
#line 231
  d += ((b ^ (c & (a___0 ^ b))) + in[10]) + 38016083UL;
#line 231
  d &= 4294967295UL;
#line 231
  d = (d << 9) | (d >> 23);
#line 231
  d += a___0;
#line 232
  c += ((a___0 ^ (b & (d ^ a___0))) + in[15]) + 3634488961UL;
#line 232
  c &= 4294967295UL;
#line 232
  c = (c << 14) | (c >> 18);
#line 232
  c += d;
#line 233
  b += ((d ^ (a___0 & (c ^ d))) + in[4]) + 3889429448UL;
#line 233
  b &= 4294967295UL;
#line 233
  b = (b << 20) | (b >> 12);
#line 233
  b += c;
#line 234
  a___0 += ((c ^ (d & (b ^ c))) + in[9]) + 568446438UL;
#line 234
  a___0 &= 4294967295UL;
#line 234
  a___0 = (a___0 << 5) | (a___0 >> 27);
#line 234
  a___0 += b;
#line 235
  d += ((b ^ (c & (a___0 ^ b))) + in[14]) + 3275163606UL;
#line 235
  d &= 4294967295UL;
#line 235
  d = (d << 9) | (d >> 23);
#line 235
  d += a___0;
#line 236
  c += ((a___0 ^ (b & (d ^ a___0))) + in[3]) + 4107603335UL;
#line 236
  c &= 4294967295UL;
#line 236
  c = (c << 14) | (c >> 18);
#line 236
  c += d;
#line 237
  b += ((d ^ (a___0 & (c ^ d))) + in[8]) + 1163531501UL;
#line 237
  b &= 4294967295UL;
#line 237
  b = (b << 20) | (b >> 12);
#line 237
  b += c;
#line 238
  a___0 += ((c ^ (d & (b ^ c))) + in[13]) + 2850285829UL;
#line 238
  a___0 &= 4294967295UL;
#line 238
  a___0 = (a___0 << 5) | (a___0 >> 27);
#line 238
  a___0 += b;
#line 239
  d += ((b ^ (c & (a___0 ^ b))) + in[2]) + 4243563512UL;
#line 239
  d &= 4294967295UL;
#line 239
  d = (d << 9) | (d >> 23);
#line 239
  d += a___0;
#line 240
  c += ((a___0 ^ (b & (d ^ a___0))) + in[7]) + 1735328473UL;
#line 240
  c &= 4294967295UL;
#line 240
  c = (c << 14) | (c >> 18);
#line 240
  c += d;
#line 241
  b += ((d ^ (a___0 & (c ^ d))) + in[12]) + 2368359562UL;
#line 241
  b &= 4294967295UL;
#line 241
  b = (b << 20) | (b >> 12);
#line 241
  b += c;
#line 243
  a___0 += (((b ^ c) ^ d) + in[5]) + 4294588738UL;
#line 243
  a___0 &= 4294967295UL;
#line 243
  a___0 = (a___0 << 4) | (a___0 >> 28);
#line 243
  a___0 += b;
#line 244
  d += (((a___0 ^ b) ^ c) + in[8]) + 2272392833UL;
#line 244
  d &= 4294967295UL;
#line 244
  d = (d << 11) | (d >> 21);
#line 244
  d += a___0;
#line 245
  c += (((d ^ a___0) ^ b) + in[11]) + 1839030562UL;
#line 245
  c &= 4294967295UL;
#line 245
  c = (c << 16) | (c >> 16);
#line 245
  c += d;
#line 246
  b += (((c ^ d) ^ a___0) + in[14]) + 4259657740UL;
#line 246
  b &= 4294967295UL;
#line 246
  b = (b << 23) | (b >> 9);
#line 246
  b += c;
#line 247
  a___0 += (((b ^ c) ^ d) + in[1]) + 2763975236UL;
#line 247
  a___0 &= 4294967295UL;
#line 247
  a___0 = (a___0 << 4) | (a___0 >> 28);
#line 247
  a___0 += b;
#line 248
  d += (((a___0 ^ b) ^ c) + in[4]) + 1272893353UL;
#line 248
  d &= 4294967295UL;
#line 248
  d = (d << 11) | (d >> 21);
#line 248
  d += a___0;
#line 249
  c += (((d ^ a___0) ^ b) + in[7]) + 4139469664UL;
#line 249
  c &= 4294967295UL;
#line 249
  c = (c << 16) | (c >> 16);
#line 249
  c += d;
#line 250
  b += (((c ^ d) ^ a___0) + in[10]) + 3200236656UL;
#line 250
  b &= 4294967295UL;
#line 250
  b = (b << 23) | (b >> 9);
#line 250
  b += c;
#line 251
  a___0 += (((b ^ c) ^ d) + in[13]) + 681279174UL;
#line 251
  a___0 &= 4294967295UL;
#line 251
  a___0 = (a___0 << 4) | (a___0 >> 28);
#line 251
  a___0 += b;
#line 252
  d += (((a___0 ^ b) ^ c) + in[0]) + 3936430074UL;
#line 252
  d &= 4294967295UL;
#line 252
  d = (d << 11) | (d >> 21);
#line 252
  d += a___0;
#line 253
  c += (((d ^ a___0) ^ b) + in[3]) + 3572445317UL;
#line 253
  c &= 4294967295UL;
#line 253
  c = (c << 16) | (c >> 16);
#line 253
  c += d;
#line 254
  b += (((c ^ d) ^ a___0) + in[6]) + 76029189UL;
#line 254
  b &= 4294967295UL;
#line 254
  b = (b << 23) | (b >> 9);
#line 254
  b += c;
#line 255
  a___0 += (((b ^ c) ^ d) + in[9]) + 3654602809UL;
#line 255
  a___0 &= 4294967295UL;
#line 255
  a___0 = (a___0 << 4) | (a___0 >> 28);
#line 255
  a___0 += b;
#line 256
  d += (((a___0 ^ b) ^ c) + in[12]) + 3873151461UL;
#line 256
  d &= 4294967295UL;
#line 256
  d = (d << 11) | (d >> 21);
#line 256
  d += a___0;
#line 257
  c += (((d ^ a___0) ^ b) + in[15]) + 530742520UL;
#line 257
  c &= 4294967295UL;
#line 257
  c = (c << 16) | (c >> 16);
#line 257
  c += d;
#line 258
  b += (((c ^ d) ^ a___0) + in[2]) + 3299628645UL;
#line 258
  b &= 4294967295UL;
#line 258
  b = (b << 23) | (b >> 9);
#line 258
  b += c;
#line 260
  a___0 += ((c ^ (b | ~ d)) + in[0]) + 4096336452UL;
#line 260
  a___0 &= 4294967295UL;
#line 260
  a___0 = (a___0 << 6) | (a___0 >> 26);
#line 260
  a___0 += b;
#line 261
  d += ((b ^ (a___0 | ~ c)) + in[7]) + 1126891415UL;
#line 261
  d &= 4294967295UL;
#line 261
  d = (d << 10) | (d >> 22);
#line 261
  d += a___0;
#line 262
  c += ((a___0 ^ (d | ~ b)) + in[14]) + 2878612391UL;
#line 262
  c &= 4294967295UL;
#line 262
  c = (c << 15) | (c >> 17);
#line 262
  c += d;
#line 263
  b += ((d ^ (c | ~ a___0)) + in[5]) + 4237533241UL;
#line 263
  b &= 4294967295UL;
#line 263
  b = (b << 21) | (b >> 11);
#line 263
  b += c;
#line 264
  a___0 += ((c ^ (b | ~ d)) + in[12]) + 1700485571UL;
#line 264
  a___0 &= 4294967295UL;
#line 264
  a___0 = (a___0 << 6) | (a___0 >> 26);
#line 264
  a___0 += b;
#line 265
  d += ((b ^ (a___0 | ~ c)) + in[3]) + 2399980690UL;
#line 265
  d &= 4294967295UL;
#line 265
  d = (d << 10) | (d >> 22);
#line 265
  d += a___0;
#line 266
  c += ((a___0 ^ (d | ~ b)) + in[10]) + 4293915773UL;
#line 266
  c &= 4294967295UL;
#line 266
  c = (c << 15) | (c >> 17);
#line 266
  c += d;
#line 267
  b += ((d ^ (c | ~ a___0)) + in[1]) + 2240044497UL;
#line 267
  b &= 4294967295UL;
#line 267
  b = (b << 21) | (b >> 11);
#line 267
  b += c;
#line 268
  a___0 += ((c ^ (b | ~ d)) + in[8]) + 1873313359UL;
#line 268
  a___0 &= 4294967295UL;
#line 268
  a___0 = (a___0 << 6) | (a___0 >> 26);
#line 268
  a___0 += b;
#line 269
  d += ((b ^ (a___0 | ~ c)) + in[15]) + 4264355552UL;
#line 269
  d &= 4294967295UL;
#line 269
  d = (d << 10) | (d >> 22);
#line 269
  d += a___0;
#line 270
  c += ((a___0 ^ (d | ~ b)) + in[6]) + 2734768916UL;
#line 270
  c &= 4294967295UL;
#line 270
  c = (c << 15) | (c >> 17);
#line 270
  c += d;
#line 271
  b += ((d ^ (c | ~ a___0)) + in[13]) + 1309151649UL;
#line 271
  b &= 4294967295UL;
#line 271
  b = (b << 21) | (b >> 11);
#line 271
  b += c;
#line 272
  a___0 += ((c ^ (b | ~ d)) + in[4]) + 4149444226UL;
#line 272
  a___0 &= 4294967295UL;
#line 272
  a___0 = (a___0 << 6) | (a___0 >> 26);
#line 272
  a___0 += b;
#line 273
  d += ((b ^ (a___0 | ~ c)) + in[11]) + 3174756917UL;
#line 273
  d &= 4294967295UL;
#line 273
  d = (d << 10) | (d >> 22);
#line 273
  d += a___0;
#line 274
  c += ((a___0 ^ (d | ~ b)) + in[2]) + 718787259UL;
#line 274
  c &= 4294967295UL;
#line 274
  c = (c << 15) | (c >> 17);
#line 274
  c += d;
#line 275
  b += ((d ^ (c | ~ a___0)) + in[9]) + 3951481745UL;
#line 275
  b &= 4294967295UL;
#line 275
  b = (b << 21) | (b >> 11);
#line 275
  b += c;
#line 277
  *(buf + 0) += a___0;
#line 278
  *(buf + 1) += b;
#line 279
  *(buf + 2) += c;
#line 280
  *(buf + 3) += d;
#line 281
  return;
}
}
#line 351 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpegint.h"
void jinit_d_main_controller(j_decompress_ptr cinfo , boolean need_full_buffer ) ;
#line 143 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jdmainct.c"
static void process_data_simple_main(j_decompress_ptr cinfo , JSAMPARRAY output_buf ,
                                     JDIMENSION *out_row_ctr , JDIMENSION out_rows_avail ) ;
#line 146
static void process_data_context_main(j_decompress_ptr cinfo , JSAMPARRAY output_buf ,
                                      JDIMENSION *out_row_ctr , JDIMENSION out_rows_avail ) ;
#line 150
static void process_data_crank_post(j_decompress_ptr cinfo , JSAMPARRAY output_buf ,
                                    JDIMENSION *out_row_ctr , JDIMENSION out_rows_avail ) ;
#line 156 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jdmainct.c"
static void alloc_funny_pointers(j_decompress_ptr cinfo ) 
{ 
  my_main_ptr main___0 ;
  int ci ;
  int rgroup ;
  int M ;
  jpeg_component_info *compptr ;
  JSAMPARRAY xbuf ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 162
  main___0 = (my_main_ptr )cinfo->main;
#line 164
  M = cinfo->min_DCT_scaled_size;
#line 171
  tmp = (*((cinfo->mem)->alloc_small))((j_common_ptr )cinfo, 1, (size_t )(cinfo->num_components * 2) * sizeof(JSAMPARRAY ));
#line 171
  main___0->xbuffer[0] = (JSAMPIMAGE )tmp;
#line 174
  main___0->xbuffer[1] = main___0->xbuffer[0] + cinfo->num_components;
#line 176
  ci = 0;
#line 176
  compptr = cinfo->comp_info;
  }
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! (ci < cinfo->num_components)) {
#line 176
      goto while_break;
    }
    {
#line 178
    rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) / cinfo->min_DCT_scaled_size;
#line 183
    tmp___0 = (*((cinfo->mem)->alloc_small))((j_common_ptr )cinfo, 1, (size_t )(2 * (rgroup * (M + 4))) * sizeof(JSAMPROW ));
#line 183
    xbuf = (JSAMPARRAY )tmp___0;
#line 186
    xbuf += rgroup;
#line 187
    *(main___0->xbuffer[0] + ci) = xbuf;
#line 188
    xbuf += rgroup * (M + 4);
#line 189
    *(main___0->xbuffer[1] + ci) = xbuf;
#line 176
    ci ++;
#line 176
    compptr ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  return;
}
}
#line 194 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jdmainct.c"
static void make_funny_pointers(j_decompress_ptr cinfo ) 
{ 
  my_main_ptr main___0 ;
  int ci ;
  int i ;
  int rgroup ;
  int M ;
  jpeg_component_info *compptr ;
  JSAMPARRAY buf ;
  JSAMPARRAY xbuf0 ;
  JSAMPARRAY xbuf1 ;
  JSAMPROW tmp ;

  {
#line 203
  main___0 = (my_main_ptr )cinfo->main;
#line 205
  M = cinfo->min_DCT_scaled_size;
#line 209
  ci = 0;
#line 209
  compptr = cinfo->comp_info;
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (! (ci < cinfo->num_components)) {
#line 209
      goto while_break;
    }
#line 211
    rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) / cinfo->min_DCT_scaled_size;
#line 213
    xbuf0 = *(main___0->xbuffer[0] + ci);
#line 214
    xbuf1 = *(main___0->xbuffer[1] + ci);
#line 216
    buf = main___0->buffer[ci];
#line 217
    i = 0;
    {
#line 217
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 217
      if (! (i < rgroup * (M + 2))) {
#line 217
        goto while_break___0;
      }
#line 218
      tmp = *(buf + i);
#line 218
      *(xbuf1 + i) = tmp;
#line 218
      *(xbuf0 + i) = tmp;
#line 217
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 221
    i = 0;
    {
#line 221
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 221
      if (! (i < rgroup * 2)) {
#line 221
        goto while_break___1;
      }
#line 222
      *(xbuf1 + (rgroup * (M - 2) + i)) = *(buf + (rgroup * M + i));
#line 223
      *(xbuf1 + (rgroup * M + i)) = *(buf + (rgroup * (M - 2) + i));
#line 221
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 230
    i = 0;
    {
#line 230
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 230
      if (! (i < rgroup)) {
#line 230
        goto while_break___2;
      }
#line 231
      *(xbuf0 + (i - rgroup)) = *(xbuf0 + 0);
#line 230
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 209
    ci ++;
#line 209
    compptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  return;
}
}
#line 237 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jdmainct.c"
static void set_wraparound_pointers(j_decompress_ptr cinfo ) 
{ 
  my_main_ptr main___0 ;
  int ci ;
  int i ;
  int rgroup ;
  int M ;
  jpeg_component_info *compptr ;
  JSAMPARRAY xbuf0 ;
  JSAMPARRAY xbuf1 ;

  {
#line 243
  main___0 = (my_main_ptr )cinfo->main;
#line 245
  M = cinfo->min_DCT_scaled_size;
#line 249
  ci = 0;
#line 249
  compptr = cinfo->comp_info;
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    if (! (ci < cinfo->num_components)) {
#line 249
      goto while_break;
    }
#line 251
    rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) / cinfo->min_DCT_scaled_size;
#line 253
    xbuf0 = *(main___0->xbuffer[0] + ci);
#line 254
    xbuf1 = *(main___0->xbuffer[1] + ci);
#line 255
    i = 0;
    {
#line 255
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 255
      if (! (i < rgroup)) {
#line 255
        goto while_break___0;
      }
#line 256
      *(xbuf0 + (i - rgroup)) = *(xbuf0 + (rgroup * (M + 1) + i));
#line 257
      *(xbuf1 + (i - rgroup)) = *(xbuf1 + (rgroup * (M + 1) + i));
#line 258
      *(xbuf0 + (rgroup * (M + 2) + i)) = *(xbuf0 + i);
#line 259
      *(xbuf1 + (rgroup * (M + 2) + i)) = *(xbuf1 + i);
#line 255
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 249
    ci ++;
#line 249
    compptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  return;
}
}
#line 265 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jdmainct.c"
static void set_bottom_pointers(j_decompress_ptr cinfo ) 
{ 
  my_main_ptr main___0 ;
  int ci ;
  int i ;
  int rgroup ;
  int iMCUheight ;
  int rows_left ;
  jpeg_component_info *compptr ;
  JSAMPARRAY xbuf ;

  {
#line 272
  main___0 = (my_main_ptr )cinfo->main;
#line 277
  ci = 0;
#line 277
  compptr = cinfo->comp_info;
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 277
    if (! (ci < cinfo->num_components)) {
#line 277
      goto while_break;
    }
#line 280
    iMCUheight = compptr->v_samp_factor * compptr->DCT_scaled_size;
#line 281
    rgroup = iMCUheight / cinfo->min_DCT_scaled_size;
#line 283
    rows_left = (int )(compptr->downsampled_height % (JDIMENSION )iMCUheight);
#line 284
    if (rows_left == 0) {
#line 284
      rows_left = iMCUheight;
    }
#line 288
    if (ci == 0) {
#line 289
      main___0->rowgroups_avail = (JDIMENSION )((rows_left - 1) / rgroup + 1);
    }
#line 294
    xbuf = *(main___0->xbuffer[main___0->whichptr] + ci);
#line 295
    i = 0;
    {
#line 295
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 295
      if (! (i < rgroup * 2)) {
#line 295
        goto while_break___0;
      }
#line 296
      *(xbuf + (rows_left + i)) = *(xbuf + (rows_left - 1));
#line 295
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 277
    ci ++;
#line 277
    compptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 299
  return;
}
}
#line 306 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jdmainct.c"
static void start_pass_main(j_decompress_ptr cinfo , J_BUF_MODE pass_mode ) 
{ 
  my_main_ptr main___0 ;

  {
#line 309
  main___0 = (my_main_ptr )cinfo->main;
  {
#line 312
  if ((unsigned int )pass_mode == 0U) {
#line 312
    goto case_0;
  }
#line 327
  if ((unsigned int )pass_mode == 2U) {
#line 327
    goto case_2;
  }
#line 332
  goto switch_default;
  case_0: /* CIL Label */ 
#line 313
  if ((cinfo->upsample)->need_context_rows) {
    {
#line 314
    main___0->pub.process_data = & process_data_context_main;
#line 315
    make_funny_pointers(cinfo);
#line 316
    main___0->whichptr = 0;
#line 317
    main___0->context_state = 0;
#line 318
    main___0->iMCU_row_ctr = (JDIMENSION )0;
    }
  } else {
#line 321
    main___0->pub.process_data = & process_data_simple_main;
  }
#line 323
  main___0->buffer_full = 0;
#line 324
  main___0->rowgroup_ctr = (JDIMENSION )0;
#line 325
  goto switch_break;
  case_2: /* CIL Label */ 
#line 329
  main___0->pub.process_data = & process_data_crank_post;
#line 330
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 333
  (cinfo->err)->msg_code = 4;
#line 333
  (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
  }
#line 334
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 336
  return;
}
}
#line 344 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jdmainct.c"
static void process_data_simple_main(j_decompress_ptr cinfo , JSAMPARRAY output_buf ,
                                     JDIMENSION *out_row_ctr , JDIMENSION out_rows_avail ) 
{ 
  my_main_ptr main___0 ;
  JDIMENSION rowgroups_avail ;
  int tmp ;

  {
#line 349
  main___0 = (my_main_ptr )cinfo->main;
#line 353
  if (! main___0->buffer_full) {
    {
#line 354
    tmp = (*((cinfo->coef)->decompress_data))(cinfo, main___0->buffer);
    }
#line 354
    if (! tmp) {
#line 355
      return;
    }
#line 356
    main___0->buffer_full = 1;
  }
  {
#line 360
  rowgroups_avail = (JDIMENSION )cinfo->min_DCT_scaled_size;
#line 367
  (*((cinfo->post)->post_process_data))(cinfo, main___0->buffer, & main___0->rowgroup_ctr,
                                        rowgroups_avail, output_buf, out_row_ctr,
                                        out_rows_avail);
  }
#line 372
  if (main___0->rowgroup_ctr >= rowgroups_avail) {
#line 373
    main___0->buffer_full = 0;
#line 374
    main___0->rowgroup_ctr = (JDIMENSION )0;
  }
#line 376
  return;
}
}
#line 384 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jdmainct.c"
static void process_data_context_main(j_decompress_ptr cinfo , JSAMPARRAY output_buf ,
                                      JDIMENSION *out_row_ctr , JDIMENSION out_rows_avail ) 
{ 
  my_main_ptr main___0 ;
  int tmp ;

  {
#line 389
  main___0 = (my_main_ptr )cinfo->main;
#line 392
  if (! main___0->buffer_full) {
    {
#line 393
    tmp = (*((cinfo->coef)->decompress_data))(cinfo, main___0->xbuffer[main___0->whichptr]);
    }
#line 393
    if (! tmp) {
#line 395
      return;
    }
#line 396
    main___0->buffer_full = 1;
#line 397
    (main___0->iMCU_row_ctr) ++;
  }
  {
#line 406
  if (main___0->context_state == 2) {
#line 406
    goto case_2;
  }
#line 417
  if (main___0->context_state == 0) {
#line 417
    goto case_0;
  }
#line 428
  if (main___0->context_state == 1) {
#line 428
    goto case_1;
  }
#line 405
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 408
  (*((cinfo->post)->post_process_data))(cinfo, main___0->xbuffer[main___0->whichptr],
                                        & main___0->rowgroup_ctr, main___0->rowgroups_avail,
                                        output_buf, out_row_ctr, out_rows_avail);
  }
#line 411
  if (main___0->rowgroup_ctr < main___0->rowgroups_avail) {
#line 412
    return;
  }
#line 413
  main___0->context_state = 0;
#line 414
  if (*out_row_ctr >= out_rows_avail) {
#line 415
    return;
  }
  case_0: /* CIL Label */ 
#line 419
  main___0->rowgroup_ctr = (JDIMENSION )0;
#line 420
  main___0->rowgroups_avail = (JDIMENSION )(cinfo->min_DCT_scaled_size - 1);
#line 424
  if (main___0->iMCU_row_ctr == cinfo->total_iMCU_rows) {
    {
#line 425
    set_bottom_pointers(cinfo);
    }
  }
#line 426
  main___0->context_state = 1;
  case_1: /* CIL Label */ 
  {
#line 430
  (*((cinfo->post)->post_process_data))(cinfo, main___0->xbuffer[main___0->whichptr],
                                        & main___0->rowgroup_ctr, main___0->rowgroups_avail,
                                        output_buf, out_row_ctr, out_rows_avail);
  }
#line 433
  if (main___0->rowgroup_ctr < main___0->rowgroups_avail) {
#line 434
    return;
  }
#line 436
  if (main___0->iMCU_row_ctr == 1U) {
    {
#line 437
    set_wraparound_pointers(cinfo);
    }
  }
#line 439
  main___0->whichptr ^= 1;
#line 440
  main___0->buffer_full = 0;
#line 443
  main___0->rowgroup_ctr = (JDIMENSION )(cinfo->min_DCT_scaled_size + 1);
#line 444
  main___0->rowgroups_avail = (JDIMENSION )(cinfo->min_DCT_scaled_size + 2);
#line 445
  main___0->context_state = 2;
  switch_break: /* CIL Label */ ;
  }
#line 447
  return;
}
}
#line 458 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jdmainct.c"
static void process_data_crank_post(j_decompress_ptr cinfo , JSAMPARRAY output_buf ,
                                    JDIMENSION *out_row_ctr , JDIMENSION out_rows_avail ) 
{ 


  {
  {
#line 463
  (*((cinfo->post)->post_process_data))(cinfo, (JSAMPIMAGE )((void *)0), (JDIMENSION *)((void *)0),
                                        (JDIMENSION )0, output_buf, out_row_ctr, out_rows_avail);
  }
#line 466
  return;
}
}
#line 475 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jdmainct.c"
void jinit_d_main_controller(j_decompress_ptr cinfo , boolean need_full_buffer ) 
{ 
  my_main_ptr main___0 ;
  int ci ;
  int rgroup ;
  int ngroups ;
  jpeg_component_info *compptr ;
  void *tmp ;

  {
  {
#line 482
  tmp = (*((cinfo->mem)->alloc_small))((j_common_ptr )cinfo, 1, sizeof(my_main_controller ));
#line 482
  main___0 = (my_main_ptr )tmp;
#line 485
  cinfo->main = (struct jpeg_d_main_controller *)main___0;
#line 486
  main___0->pub.start_pass = & start_pass_main;
  }
#line 488
  if (need_full_buffer) {
    {
#line 489
    (cinfo->err)->msg_code = 4;
#line 489
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
#line 494
  if ((cinfo->upsample)->need_context_rows) {
#line 495
    if (cinfo->min_DCT_scaled_size < 2) {
      {
#line 496
      (cinfo->err)->msg_code = 47;
#line 496
      (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
      }
    }
    {
#line 497
    alloc_funny_pointers(cinfo);
#line 498
    ngroups = cinfo->min_DCT_scaled_size + 2;
    }
  } else {
#line 500
    ngroups = cinfo->min_DCT_scaled_size;
  }
#line 503
  ci = 0;
#line 503
  compptr = cinfo->comp_info;
  {
#line 503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 503
    if (! (ci < cinfo->num_components)) {
#line 503
      goto while_break;
    }
    {
#line 505
    rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) / cinfo->min_DCT_scaled_size;
#line 507
    main___0->buffer[ci] = (*((cinfo->mem)->alloc_sarray))((j_common_ptr )cinfo, 1,
                                                           compptr->width_in_blocks * (JDIMENSION )compptr->DCT_scaled_size,
                                                           (JDIMENSION )(rgroup * ngroups));
#line 503
    ci ++;
#line 503
    compptr ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 512
  return;
}
}
#line 343 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpegint.h"
void jinit_color_converter(j_compress_ptr cinfo ) ;
#line 85 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jccolor.c"
static void rgb_ycc_start(j_compress_ptr cinfo ) 
{ 
  my_cconvert_ptr cconvert ;
  INT32 *rgb_ycc_tab ;
  INT32 i ;
  void *tmp ;

  {
  {
#line 88
  cconvert = (my_cconvert_ptr )cinfo->cconvert;
#line 93
  tmp = (*((cinfo->mem)->alloc_small))((j_common_ptr )cinfo, 1, 2048UL * sizeof(INT32 ));
#line 93
  rgb_ycc_tab = (INT32 *)tmp;
#line 93
  cconvert->rgb_ycc_tab = rgb_ycc_tab;
#line 97
  i = (INT32 )0;
  }
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! (i <= 255L)) {
#line 97
      goto while_break;
    }
#line 98
    *(rgb_ycc_tab + i) = (INT32 )(0.29900 * (double )(1L << 16) + 0.5) * i;
#line 99
    *(rgb_ycc_tab + (i + 256L)) = (INT32 )(0.58700 * (double )(1L << 16) + 0.5) * i;
#line 100
    *(rgb_ycc_tab + (i + 512L)) = (INT32 )(0.11400 * (double )(1L << 16) + 0.5) * i + (1L << 15);
#line 101
    *(rgb_ycc_tab + (i + 768L)) = - ((INT32 )(0.16874 * (double )(1L << 16) + 0.5)) * i;
#line 102
    *(rgb_ycc_tab + (i + 1024L)) = - ((INT32 )(0.33126 * (double )(1L << 16) + 0.5)) * i;
#line 107
    *(rgb_ycc_tab + (i + 1280L)) = (((INT32 )(0.50000 * (double )(1L << 16) + 0.5) * i + (128L << 16)) + (1L << 15)) - 1L;
#line 111
    *(rgb_ycc_tab + (i + 1536L)) = - ((INT32 )(0.41869 * (double )(1L << 16) + 0.5)) * i;
#line 112
    *(rgb_ycc_tab + (i + 1792L)) = - ((INT32 )(0.08131 * (double )(1L << 16) + 0.5)) * i;
#line 97
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  return;
}
}
#line 129 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jccolor.c"
static void rgb_ycc_convert(j_compress_ptr cinfo , JSAMPARRAY input_buf , JSAMPIMAGE output_buf ,
                            JDIMENSION output_row , int num_rows ) 
{ 
  my_cconvert_ptr cconvert ;
  register int r ;
  register int g ;
  register int b ;
  register INT32 *ctab ;
  register JSAMPROW inptr ;
  register JSAMPROW outptr0 ;
  register JSAMPROW outptr1 ;
  register JSAMPROW outptr2 ;
  register JDIMENSION col ;
  JDIMENSION num_cols ;
  JSAMPARRAY tmp ;

  {
#line 134
  cconvert = (my_cconvert_ptr )cinfo->cconvert;
#line 136
  ctab = cconvert->rgb_ycc_tab;
#line 140
  num_cols = cinfo->image_width;
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    num_rows --;
#line 142
    if (! (num_rows >= 0)) {
#line 142
      goto while_break;
    }
#line 143
    tmp = input_buf;
#line 143
    input_buf ++;
#line 143
    inptr = *tmp;
#line 144
    outptr0 = *(*(output_buf + 0) + output_row);
#line 145
    outptr1 = *(*(output_buf + 1) + output_row);
#line 146
    outptr2 = *(*(output_buf + 2) + output_row);
#line 147
    output_row ++;
#line 148
    col = (JDIMENSION )0;
    {
#line 148
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 148
      if (! (col < num_cols)) {
#line 148
        goto while_break___0;
      }
#line 149
      r = (int )*(inptr + 0);
#line 150
      g = (int )*(inptr + 1);
#line 151
      b = (int )*(inptr + 2);
#line 152
      inptr += 3;
#line 159
      *(outptr0 + col) = (JSAMPLE )(((*(ctab + r) + *(ctab + (g + 256))) + *(ctab + (b + 512))) >> 16);
#line 163
      *(outptr1 + col) = (JSAMPLE )(((*(ctab + (r + 768)) + *(ctab + (g + 1024))) + *(ctab + (b + 1280))) >> 16);
#line 167
      *(outptr2 + col) = (JSAMPLE )(((*(ctab + (r + 1280)) + *(ctab + (g + 1536))) + *(ctab + (b + 1792))) >> 16);
#line 148
      col ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 172
  return;
}
}
#line 185 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jccolor.c"
static void rgb_gray_convert(j_compress_ptr cinfo , JSAMPARRAY input_buf , JSAMPIMAGE output_buf ,
                             JDIMENSION output_row , int num_rows ) 
{ 
  my_cconvert_ptr cconvert ;
  register int r ;
  register int g ;
  register int b ;
  register INT32 *ctab ;
  register JSAMPROW inptr ;
  register JSAMPROW outptr ;
  register JDIMENSION col ;
  JDIMENSION num_cols ;
  JSAMPARRAY tmp ;

  {
#line 190
  cconvert = (my_cconvert_ptr )cinfo->cconvert;
#line 192
  ctab = cconvert->rgb_ycc_tab;
#line 196
  num_cols = cinfo->image_width;
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    num_rows --;
#line 198
    if (! (num_rows >= 0)) {
#line 198
      goto while_break;
    }
#line 199
    tmp = input_buf;
#line 199
    input_buf ++;
#line 199
    inptr = *tmp;
#line 200
    outptr = *(*(output_buf + 0) + output_row);
#line 201
    output_row ++;
#line 202
    col = (JDIMENSION )0;
    {
#line 202
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 202
      if (! (col < num_cols)) {
#line 202
        goto while_break___0;
      }
#line 203
      r = (int )*(inptr + 0);
#line 204
      g = (int )*(inptr + 1);
#line 205
      b = (int )*(inptr + 2);
#line 206
      inptr += 3;
#line 208
      *(outptr + col) = (JSAMPLE )(((*(ctab + r) + *(ctab + (g + 256))) + *(ctab + (b + 512))) >> 16);
#line 202
      col ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  return;
}
}
#line 224 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jccolor.c"
static void cmyk_ycck_convert(j_compress_ptr cinfo , JSAMPARRAY input_buf , JSAMPIMAGE output_buf ,
                              JDIMENSION output_row , int num_rows ) 
{ 
  my_cconvert_ptr cconvert ;
  register int r ;
  register int g ;
  register int b ;
  register INT32 *ctab ;
  register JSAMPROW inptr ;
  register JSAMPROW outptr0 ;
  register JSAMPROW outptr1 ;
  register JSAMPROW outptr2 ;
  register JSAMPROW outptr3 ;
  register JDIMENSION col ;
  JDIMENSION num_cols ;
  JSAMPARRAY tmp ;

  {
#line 229
  cconvert = (my_cconvert_ptr )cinfo->cconvert;
#line 231
  ctab = cconvert->rgb_ycc_tab;
#line 235
  num_cols = cinfo->image_width;
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 237
    num_rows --;
#line 237
    if (! (num_rows >= 0)) {
#line 237
      goto while_break;
    }
#line 238
    tmp = input_buf;
#line 238
    input_buf ++;
#line 238
    inptr = *tmp;
#line 239
    outptr0 = *(*(output_buf + 0) + output_row);
#line 240
    outptr1 = *(*(output_buf + 1) + output_row);
#line 241
    outptr2 = *(*(output_buf + 2) + output_row);
#line 242
    outptr3 = *(*(output_buf + 3) + output_row);
#line 243
    output_row ++;
#line 244
    col = (JDIMENSION )0;
    {
#line 244
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 244
      if (! (col < num_cols)) {
#line 244
        goto while_break___0;
      }
#line 245
      r = 255 - (int )*(inptr + 0);
#line 246
      g = 255 - (int )*(inptr + 1);
#line 247
      b = 255 - (int )*(inptr + 2);
#line 249
      *(outptr3 + col) = *(inptr + 3);
#line 250
      inptr += 4;
#line 257
      *(outptr0 + col) = (JSAMPLE )(((*(ctab + r) + *(ctab + (g + 256))) + *(ctab + (b + 512))) >> 16);
#line 261
      *(outptr1 + col) = (JSAMPLE )(((*(ctab + (r + 768)) + *(ctab + (g + 1024))) + *(ctab + (b + 1280))) >> 16);
#line 265
      *(outptr2 + col) = (JSAMPLE )(((*(ctab + (r + 1280)) + *(ctab + (g + 1536))) + *(ctab + (b + 1792))) >> 16);
#line 244
      col ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 270
  return;
}
}
#line 279 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jccolor.c"
static void grayscale_convert(j_compress_ptr cinfo , JSAMPARRAY input_buf , JSAMPIMAGE output_buf ,
                              JDIMENSION output_row , int num_rows ) 
{ 
  register JSAMPROW inptr ;
  register JSAMPROW outptr ;
  register JDIMENSION col ;
  JDIMENSION num_cols ;
  int instride ;
  JSAMPARRAY tmp ;

  {
#line 287
  num_cols = cinfo->image_width;
#line 288
  instride = cinfo->input_components;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 290
    num_rows --;
#line 290
    if (! (num_rows >= 0)) {
#line 290
      goto while_break;
    }
#line 291
    tmp = input_buf;
#line 291
    input_buf ++;
#line 291
    inptr = *tmp;
#line 292
    outptr = *(*(output_buf + 0) + output_row);
#line 293
    output_row ++;
#line 294
    col = (JDIMENSION )0;
    {
#line 294
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 294
      if (! (col < num_cols)) {
#line 294
        goto while_break___0;
      }
#line 295
      *(outptr + col) = *(inptr + 0);
#line 296
      inptr += instride;
#line 294
      col ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 299
  return;
}
}
#line 308 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jccolor.c"
static void null_convert(j_compress_ptr cinfo , JSAMPARRAY input_buf , JSAMPIMAGE output_buf ,
                         JDIMENSION output_row , int num_rows ) 
{ 
  register JSAMPROW inptr ;
  register JSAMPROW outptr ;
  register JDIMENSION col ;
  register int ci ;
  int nc ;
  JDIMENSION num_cols ;

  {
#line 317
  nc = cinfo->num_components;
#line 318
  num_cols = cinfo->image_width;
  {
#line 320
  while (1) {
    while_continue: /* CIL Label */ ;
#line 320
    num_rows --;
#line 320
    if (! (num_rows >= 0)) {
#line 320
      goto while_break;
    }
#line 322
    ci = 0;
    {
#line 322
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 322
      if (! (ci < nc)) {
#line 322
        goto while_break___0;
      }
#line 323
      inptr = *input_buf;
#line 324
      outptr = *(*(output_buf + ci) + output_row);
#line 325
      col = (JDIMENSION )0;
      {
#line 325
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 325
        if (! (col < num_cols)) {
#line 325
          goto while_break___1;
        }
#line 326
        *(outptr + col) = *(inptr + ci);
#line 327
        inptr += nc;
#line 325
        col ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 322
      ci ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 330
    input_buf ++;
#line 331
    output_row ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 333
  return;
}
}
#line 340 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jccolor.c"
static void null_method(j_compress_ptr cinfo ) 
{ 


  {
#line 344
  return;
}
}
#line 351 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jccolor.c"
void jinit_color_converter(j_compress_ptr cinfo ) 
{ 
  my_cconvert_ptr cconvert ;
  void *tmp ;

  {
  {
#line 356
  tmp = (*((cinfo->mem)->alloc_small))((j_common_ptr )cinfo, 1, sizeof(my_color_converter ));
#line 356
  cconvert = (my_cconvert_ptr )tmp;
#line 359
  cinfo->cconvert = (struct jpeg_color_converter *)cconvert;
#line 361
  cconvert->pub.start_pass = & null_method;
  }
  {
#line 365
  if ((unsigned int )cinfo->in_color_space == 1U) {
#line 365
    goto case_1;
  }
#line 377
  if ((unsigned int )cinfo->in_color_space == 3U) {
#line 377
    goto case_3;
  }
#line 377
  if ((unsigned int )cinfo->in_color_space == 2U) {
#line 377
    goto case_3;
  }
#line 383
  if ((unsigned int )cinfo->in_color_space == 5U) {
#line 383
    goto case_5;
  }
#line 383
  if ((unsigned int )cinfo->in_color_space == 4U) {
#line 383
    goto case_5;
  }
#line 388
  goto switch_default;
  case_1: /* CIL Label */ 
#line 366
  if (cinfo->input_components != 1) {
    {
#line 367
    (cinfo->err)->msg_code = 9;
#line 367
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
#line 368
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 378
  if (cinfo->input_components != 3) {
    {
#line 379
    (cinfo->err)->msg_code = 9;
#line 379
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
#line 380
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 384
  if (cinfo->input_components != 4) {
    {
#line 385
    (cinfo->err)->msg_code = 9;
#line 385
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
#line 386
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 389
  if (cinfo->input_components < 1) {
    {
#line 390
    (cinfo->err)->msg_code = 9;
#line 390
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
#line 391
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 396
  if ((unsigned int )cinfo->jpeg_color_space == 1U) {
#line 396
    goto case_1___0;
  }
#line 410
  if ((unsigned int )cinfo->jpeg_color_space == 2U) {
#line 410
    goto case_2___0;
  }
#line 419
  if ((unsigned int )cinfo->jpeg_color_space == 3U) {
#line 419
    goto case_3___0;
  }
#line 431
  if ((unsigned int )cinfo->jpeg_color_space == 4U) {
#line 431
    goto case_4___0;
  }
#line 440
  if ((unsigned int )cinfo->jpeg_color_space == 5U) {
#line 440
    goto case_5___0;
  }
#line 452
  goto switch_default___0;
  case_1___0: /* CIL Label */ 
#line 397
  if (cinfo->num_components != 1) {
    {
#line 398
    (cinfo->err)->msg_code = 10;
#line 398
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
#line 399
  if ((unsigned int )cinfo->in_color_space == 1U) {
#line 400
    cconvert->pub.color_convert = & grayscale_convert;
  } else
#line 401
  if ((unsigned int )cinfo->in_color_space == 2U) {
#line 402
    cconvert->pub.start_pass = & rgb_ycc_start;
#line 403
    cconvert->pub.color_convert = & rgb_gray_convert;
  } else
#line 404
  if ((unsigned int )cinfo->in_color_space == 3U) {
#line 405
    cconvert->pub.color_convert = & grayscale_convert;
  } else {
    {
#line 407
    (cinfo->err)->msg_code = 27;
#line 407
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
#line 408
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 411
  if (cinfo->num_components != 3) {
    {
#line 412
    (cinfo->err)->msg_code = 10;
#line 412
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
#line 413
  if ((unsigned int )cinfo->in_color_space == 2U) {
#line 414
    cconvert->pub.color_convert = & null_convert;
  } else {
    {
#line 416
    (cinfo->err)->msg_code = 27;
#line 416
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
#line 417
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 420
  if (cinfo->num_components != 3) {
    {
#line 421
    (cinfo->err)->msg_code = 10;
#line 421
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
#line 422
  if ((unsigned int )cinfo->in_color_space == 2U) {
#line 423
    cconvert->pub.start_pass = & rgb_ycc_start;
#line 424
    cconvert->pub.color_convert = & rgb_ycc_convert;
  } else
#line 425
  if ((unsigned int )cinfo->in_color_space == 3U) {
#line 426
    cconvert->pub.color_convert = & null_convert;
  } else {
    {
#line 428
    (cinfo->err)->msg_code = 27;
#line 428
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
#line 429
  goto switch_break___0;
  case_4___0: /* CIL Label */ 
#line 432
  if (cinfo->num_components != 4) {
    {
#line 433
    (cinfo->err)->msg_code = 10;
#line 433
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
#line 434
  if ((unsigned int )cinfo->in_color_space == 4U) {
#line 435
    cconvert->pub.color_convert = & null_convert;
  } else {
    {
#line 437
    (cinfo->err)->msg_code = 27;
#line 437
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
#line 438
  goto switch_break___0;
  case_5___0: /* CIL Label */ 
#line 441
  if (cinfo->num_components != 4) {
    {
#line 442
    (cinfo->err)->msg_code = 10;
#line 442
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
#line 443
  if ((unsigned int )cinfo->in_color_space == 4U) {
#line 444
    cconvert->pub.start_pass = & rgb_ycc_start;
#line 445
    cconvert->pub.color_convert = & cmyk_ycck_convert;
  } else
#line 446
  if ((unsigned int )cinfo->in_color_space == 5U) {
#line 447
    cconvert->pub.color_convert = & null_convert;
  } else {
    {
#line 449
    (cinfo->err)->msg_code = 27;
#line 449
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
#line 450
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 453
  if ((unsigned int )cinfo->jpeg_color_space != (unsigned int )cinfo->in_color_space) {
    {
#line 455
    (cinfo->err)->msg_code = 27;
#line 455
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  } else
#line 453
  if (cinfo->num_components != cinfo->input_components) {
    {
#line 455
    (cinfo->err)->msg_code = 27;
#line 455
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
#line 456
  cconvert->pub.color_convert = & null_convert;
#line 457
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 459
  return;
}
}
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 52 "/home/wheatley/newnew/temp/outguess-0.2/arc.h"
void arc4_init(struct arc4_stream *as ) ;
#line 53
u_int8_t arc4_getbyte(struct arc4_stream *as ) ;
#line 54
u_int32_t arc4_getword(struct arc4_stream *as ) ;
#line 55
void arc4_addrandom(struct arc4_stream *as , u_char *dat , int datlen ) ;
#line 56
void arc4_initkey(struct arc4_stream *as , char *type , u_char *key , int keylen ) ;
#line 53 "/home/wheatley/newnew/temp/outguess-0.2/arc.c"
void arc4_init(struct arc4_stream *as ) 
{ 
  int n ;

  {
#line 58
  n = 0;
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! (n < 256)) {
#line 58
      goto while_break;
    }
#line 59
    as->s[n] = (u_int8_t )n;
#line 58
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 60
  as->i = (u_int8_t )0;
#line 61
  as->j = (u_int8_t )0;
#line 62
  return;
}
}
#line 64 "/home/wheatley/newnew/temp/outguess-0.2/arc.c"
u_int8_t arc4_getbyte(struct arc4_stream *as ) 
{ 
  u_int8_t si ;
  u_int8_t sj ;

  {
#line 69
  as->i = (u_int8_t )((int )as->i + 1);
#line 70
  si = as->s[as->i];
#line 71
  as->j = (u_int8_t )((int )as->j + (int )si);
#line 72
  sj = as->s[as->j];
#line 73
  as->s[as->i] = sj;
#line 74
  as->s[as->j] = si;
#line 75
  return (as->s[((int )si + (int )sj) & 255]);
}
}
#line 78 "/home/wheatley/newnew/temp/outguess-0.2/arc.c"
u_int32_t arc4_getword(struct arc4_stream *as ) 
{ 
  u_int32_t val ;
  u_int8_t tmp ;
  u_int8_t tmp___0 ;
  u_int8_t tmp___1 ;
  u_int8_t tmp___2 ;

  {
  {
#line 83
  tmp = arc4_getbyte(as);
#line 83
  val = (u_int32_t )((int )tmp << 24);
#line 84
  tmp___0 = arc4_getbyte(as);
#line 84
  val |= (unsigned int )((int )tmp___0 << 16);
#line 85
  tmp___1 = arc4_getbyte(as);
#line 85
  val |= (unsigned int )((int )tmp___1 << 8);
#line 86
  tmp___2 = arc4_getbyte(as);
#line 86
  val |= (unsigned int )tmp___2;
  }
#line 87
  return (val);
}
}
#line 90 "/home/wheatley/newnew/temp/outguess-0.2/arc.c"
void arc4_addrandom(struct arc4_stream *as , u_char *dat , int datlen ) 
{ 
  int n ;
  u_int8_t si ;

  {
#line 96
  as->i = (u_int8_t )((int )as->i - 1);
#line 97
  n = 0;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! (n < 256)) {
#line 97
      goto while_break;
    }
#line 98
    as->i = (u_int8_t )((int )as->i + 1);
#line 99
    si = as->s[as->i];
#line 100
    as->j = (u_int8_t )(((int )as->j + (int )si) + (int )*(dat + n % datlen));
#line 101
    as->s[as->i] = as->s[as->j];
#line 102
    as->s[as->j] = si;
#line 97
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  return;
}
}
#line 106 "/home/wheatley/newnew/temp/outguess-0.2/arc.c"
void arc4_initkey(struct arc4_stream *as , char *type , u_char *key , int keylen ) 
{ 
  MD5_CTX ctx ;
  u_char digest[16] ;
  size_t tmp ;

  {
  {
#line 113
  MD5Init(& ctx);
#line 114
  tmp = strlen((char const   *)type);
#line 114
  MD5Update(& ctx, (unsigned char const   *)type, (unsigned int )tmp);
#line 115
  MD5Update(& ctx, (unsigned char const   *)key, (unsigned int )keylen);
#line 116
  MD5Final((unsigned char *)(digest), & ctx);
#line 118
  arc4_init(as);
#line 119
  arc4_addrandom(as, digest, 16);
  }
#line 120
  return;
}
}
#line 345 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpegint.h"
void jinit_forward_dct(j_compress_ptr cinfo ) ;
#line 97 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jdct.h"
extern void jpeg_fdct_islow(DCTELEM *data ) ;
#line 98
extern void jpeg_fdct_ifast(DCTELEM *data ) ;
#line 99
extern void jpeg_fdct_float(float *data ) ;
#line 99 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcdctmgr.c"
static void start_pass_fdctmgr(j_compress_ptr cinfo ) ;
#line 99 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcdctmgr.c"
static INT16 const   aanscales[64]  = 
#line 99
  {      (INT16 const   )16384,      (INT16 const   )22725,      (INT16 const   )21407,      (INT16 const   )19266, 
        (INT16 const   )16384,      (INT16 const   )12873,      (INT16 const   )8867,      (INT16 const   )4520, 
        (INT16 const   )22725,      (INT16 const   )31521,      (INT16 const   )29692,      (INT16 const   )26722, 
        (INT16 const   )22725,      (INT16 const   )17855,      (INT16 const   )12299,      (INT16 const   )6270, 
        (INT16 const   )21407,      (INT16 const   )29692,      (INT16 const   )27969,      (INT16 const   )25172, 
        (INT16 const   )21407,      (INT16 const   )16819,      (INT16 const   )11585,      (INT16 const   )5906, 
        (INT16 const   )19266,      (INT16 const   )26722,      (INT16 const   )25172,      (INT16 const   )22654, 
        (INT16 const   )19266,      (INT16 const   )15137,      (INT16 const   )10426,      (INT16 const   )5315, 
        (INT16 const   )16384,      (INT16 const   )22725,      (INT16 const   )21407,      (INT16 const   )19266, 
        (INT16 const   )16384,      (INT16 const   )12873,      (INT16 const   )8867,      (INT16 const   )4520, 
        (INT16 const   )12873,      (INT16 const   )17855,      (INT16 const   )16819,      (INT16 const   )15137, 
        (INT16 const   )12873,      (INT16 const   )10114,      (INT16 const   )6967,      (INT16 const   )3552, 
        (INT16 const   )8867,      (INT16 const   )12299,      (INT16 const   )11585,      (INT16 const   )10426, 
        (INT16 const   )8867,      (INT16 const   )6967,      (INT16 const   )4799,      (INT16 const   )2446, 
        (INT16 const   )4520,      (INT16 const   )6270,      (INT16 const   )5906,      (INT16 const   )5315, 
        (INT16 const   )4520,      (INT16 const   )3552,      (INT16 const   )2446,      (INT16 const   )1247};
#line 140 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcdctmgr.c"
static double const   aanscalefactor[8]  = 
#line 140
  {      (double const   )1.0,      (double const   )1.387039845,      (double const   )1.306562965,      (double const   )1.175875602, 
        (double const   )1.0,      (double const   )0.785694958,      (double const   )0.541196100,      (double const   )0.275899379};
#line 53 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcdctmgr.c"
static void start_pass_fdctmgr(j_compress_ptr cinfo ) 
{ 
  my_fdct_ptr fdct ;
  int ci ;
  int qtblno ;
  int i ;
  jpeg_component_info *compptr ;
  JQUANT_TBL *qtbl ;
  DCTELEM *dtbl ;
  void *tmp ;
  void *tmp___0 ;
  float *fdtbl ;
  int row ;
  int col ;
  void *tmp___1 ;

  {
#line 56
  fdct = (my_fdct_ptr )cinfo->fdct;
#line 62
  ci = 0;
#line 62
  compptr = cinfo->comp_info;
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    if (! (ci < cinfo->num_components)) {
#line 62
      goto while_break;
    }
#line 64
    qtblno = compptr->quant_tbl_no;
#line 66
    if (qtblno < 0) {
      {
#line 68
      (cinfo->err)->msg_code = 52;
#line 68
      (cinfo->err)->msg_parm.i[0] = qtblno;
#line 68
      (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
      }
    } else
#line 66
    if (qtblno >= 4) {
      {
#line 68
      (cinfo->err)->msg_code = 52;
#line 68
      (cinfo->err)->msg_parm.i[0] = qtblno;
#line 68
      (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
      }
    } else
#line 66
    if ((unsigned long )cinfo->quant_tbl_ptrs[qtblno] == (unsigned long )((void *)0)) {
      {
#line 68
      (cinfo->err)->msg_code = 52;
#line 68
      (cinfo->err)->msg_parm.i[0] = qtblno;
#line 68
      (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
      }
    }
#line 69
    qtbl = cinfo->quant_tbl_ptrs[qtblno];
    {
#line 74
    if ((unsigned int )cinfo->dct_method == 0U) {
#line 74
      goto case_0;
    }
#line 90
    if ((unsigned int )cinfo->dct_method == 1U) {
#line 90
      goto case_1;
    }
#line 128
    if ((unsigned int )cinfo->dct_method == 2U) {
#line 128
      goto case_2;
    }
#line 163
    goto switch_default;
    case_0: /* CIL Label */ 
#line 78
    if ((unsigned long )fdct->divisors[qtblno] == (unsigned long )((void *)0)) {
      {
#line 79
      tmp = (*((cinfo->mem)->alloc_small))((j_common_ptr )cinfo, 1, 64UL * sizeof(DCTELEM ));
#line 79
      fdct->divisors[qtblno] = (DCTELEM *)tmp;
      }
    }
#line 83
    dtbl = fdct->divisors[qtblno];
#line 84
    i = 0;
    {
#line 84
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 84
      if (! (i < 64)) {
#line 84
        goto while_break___0;
      }
#line 85
      *(dtbl + i) = (DCTELEM )qtbl->quantval[i] << 3;
#line 84
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 87
    goto switch_break;
    case_1: /* CIL Label */ 
#line 112
    if ((unsigned long )fdct->divisors[qtblno] == (unsigned long )((void *)0)) {
      {
#line 113
      tmp___0 = (*((cinfo->mem)->alloc_small))((j_common_ptr )cinfo, 1, 64UL * sizeof(DCTELEM ));
#line 113
      fdct->divisors[qtblno] = (DCTELEM *)tmp___0;
      }
    }
#line 117
    dtbl = fdct->divisors[qtblno];
#line 118
    i = 0;
    {
#line 118
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 118
      if (! (i < 64)) {
#line 118
        goto while_break___1;
      }
#line 119
      *(dtbl + i) = (DCTELEM )(((INT32 )qtbl->quantval[i] * (INT32 )aanscales[i] + (1L << 10)) >> 11);
#line 118
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 125
    goto switch_break;
    case_2: /* CIL Label */ 
#line 145
    if ((unsigned long )fdct->float_divisors[qtblno] == (unsigned long )((void *)0)) {
      {
#line 146
      tmp___1 = (*((cinfo->mem)->alloc_small))((j_common_ptr )cinfo, 1, 64UL * sizeof(float ));
#line 146
      fdct->float_divisors[qtblno] = (float *)tmp___1;
      }
    }
#line 150
    fdtbl = fdct->float_divisors[qtblno];
#line 151
    i = 0;
#line 152
    row = 0;
    {
#line 152
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 152
      if (! (row < 8)) {
#line 152
        goto while_break___2;
      }
#line 153
      col = 0;
      {
#line 153
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 153
        if (! (col < 8)) {
#line 153
          goto while_break___3;
        }
#line 154
        *(fdtbl + i) = (float )(1.0 / ((((double )qtbl->quantval[i] * (double )aanscalefactor[row]) * (double )aanscalefactor[col]) * 8.0));
#line 157
        i ++;
#line 153
        col ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 152
      row ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 161
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 164
    (cinfo->err)->msg_code = 48;
#line 164
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
#line 165
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 62
    ci ++;
#line 62
    compptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 168
  return;
}
}
#line 260
short steg_use_bit(unsigned short temp ) ;
#line 179 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcdctmgr.c"
static void forward_DCT(j_compress_ptr cinfo , jpeg_component_info *compptr , JSAMPARRAY sample_data ,
                        JBLOCKROW coef_blocks , JDIMENSION start_row , JDIMENSION start_col ,
                        JDIMENSION num_blocks ) 
{ 
  my_fdct_ptr fdct ;
  void (*do_dct)(DCTELEM *data ) ;
  DCTELEM *divisors ;
  DCTELEM workspace[64] ;
  JDIMENSION bi ;
  register DCTELEM *workspaceptr ;
  register JSAMPROW elemptr ;
  register int elemr ;
  DCTELEM *tmp ;
  JSAMPROW tmp___0 ;
  DCTELEM *tmp___1 ;
  JSAMPROW tmp___2 ;
  DCTELEM *tmp___3 ;
  JSAMPROW tmp___4 ;
  DCTELEM *tmp___5 ;
  JSAMPROW tmp___6 ;
  DCTELEM *tmp___7 ;
  JSAMPROW tmp___8 ;
  DCTELEM *tmp___9 ;
  JSAMPROW tmp___10 ;
  DCTELEM *tmp___11 ;
  JSAMPROW tmp___12 ;
  DCTELEM *tmp___13 ;
  JSAMPROW tmp___14 ;
  register DCTELEM temp ;
  register DCTELEM qval ;
  register int i ;
  register JCOEFPTR output_ptr ;
  int tmp___15 ;

  {
#line 187
  fdct = (my_fdct_ptr )cinfo->fdct;
#line 188
  do_dct = fdct->do_dct;
#line 189
  divisors = fdct->divisors[compptr->quant_tbl_no];
#line 193
  sample_data += start_row;
#line 195
  bi = (JDIMENSION )0;
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if (! (bi < num_blocks)) {
#line 195
      goto while_break;
    }
#line 201
    workspaceptr = workspace;
#line 202
    elemr = 0;
    {
#line 202
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 202
      if (! (elemr < 8)) {
#line 202
        goto while_break___0;
      }
#line 203
      elemptr = *(sample_data + elemr) + start_col;
#line 205
      tmp = workspaceptr;
#line 205
      workspaceptr ++;
#line 205
      tmp___0 = elemptr;
#line 205
      elemptr ++;
#line 205
      *tmp = (int )*tmp___0 - 128;
#line 206
      tmp___1 = workspaceptr;
#line 206
      workspaceptr ++;
#line 206
      tmp___2 = elemptr;
#line 206
      elemptr ++;
#line 206
      *tmp___1 = (int )*tmp___2 - 128;
#line 207
      tmp___3 = workspaceptr;
#line 207
      workspaceptr ++;
#line 207
      tmp___4 = elemptr;
#line 207
      elemptr ++;
#line 207
      *tmp___3 = (int )*tmp___4 - 128;
#line 208
      tmp___5 = workspaceptr;
#line 208
      workspaceptr ++;
#line 208
      tmp___6 = elemptr;
#line 208
      elemptr ++;
#line 208
      *tmp___5 = (int )*tmp___6 - 128;
#line 209
      tmp___7 = workspaceptr;
#line 209
      workspaceptr ++;
#line 209
      tmp___8 = elemptr;
#line 209
      elemptr ++;
#line 209
      *tmp___7 = (int )*tmp___8 - 128;
#line 210
      tmp___9 = workspaceptr;
#line 210
      workspaceptr ++;
#line 210
      tmp___10 = elemptr;
#line 210
      elemptr ++;
#line 210
      *tmp___9 = (int )*tmp___10 - 128;
#line 211
      tmp___11 = workspaceptr;
#line 211
      workspaceptr ++;
#line 211
      tmp___12 = elemptr;
#line 211
      elemptr ++;
#line 211
      *tmp___11 = (int )*tmp___12 - 128;
#line 212
      tmp___13 = workspaceptr;
#line 212
      workspaceptr ++;
#line 212
      tmp___14 = elemptr;
#line 212
      elemptr ++;
#line 212
      *tmp___13 = (int )*tmp___14 - 128;
#line 202
      elemr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 224
    (*do_dct)(workspace);
#line 229
    output_ptr = *(coef_blocks + bi);
#line 231
    i = 0;
    }
    {
#line 231
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 231
      if (! (i < 64)) {
#line 231
        goto while_break___1;
      }
#line 232
      qval = *(divisors + i);
#line 233
      temp = workspace[i];
#line 251
      if (temp < 0) {
#line 252
        temp = - temp;
#line 253
        temp += qval >> 1;
#line 254
        if (temp >= qval) {
#line 254
          temp /= qval;
        } else {
#line 254
          temp = 0;
        }
#line 255
        temp = - temp;
      } else {
#line 257
        temp += qval >> 1;
#line 258
        if (temp >= qval) {
#line 258
          temp /= qval;
        } else {
#line 258
          temp = 0;
        }
      }
      {
#line 260
      tmp___15 = (int )steg_use_bit(temp);
#line 260
      *(output_ptr + i) = (JCOEF )tmp___15;
#line 231
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 195
    bi ++;
#line 195
    start_col += 8U;
  }
  while_break: /* CIL Label */ ;
  }
#line 264
  return;
}
}
#line 269 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcdctmgr.c"
static void forward_DCT_float(j_compress_ptr cinfo , jpeg_component_info *compptr ,
                              JSAMPARRAY sample_data , JBLOCKROW coef_blocks , JDIMENSION start_row ,
                              JDIMENSION start_col , JDIMENSION num_blocks ) 
{ 
  my_fdct_ptr fdct ;
  void (*do_dct)(float *data ) ;
  float *divisors ;
  float workspace[64] ;
  JDIMENSION bi ;
  register float *workspaceptr ;
  register JSAMPROW elemptr ;
  register int elemr ;
  float *tmp ;
  JSAMPROW tmp___0 ;
  float *tmp___1 ;
  JSAMPROW tmp___2 ;
  float *tmp___3 ;
  JSAMPROW tmp___4 ;
  float *tmp___5 ;
  JSAMPROW tmp___6 ;
  float *tmp___7 ;
  JSAMPROW tmp___8 ;
  float *tmp___9 ;
  JSAMPROW tmp___10 ;
  float *tmp___11 ;
  JSAMPROW tmp___12 ;
  float *tmp___13 ;
  JSAMPROW tmp___14 ;
  register float temp ;
  register int i ;
  register JCOEFPTR output_ptr ;

  {
#line 277
  fdct = (my_fdct_ptr )cinfo->fdct;
#line 278
  do_dct = fdct->do_float_dct;
#line 279
  divisors = fdct->float_divisors[compptr->quant_tbl_no];
#line 283
  sample_data += start_row;
#line 285
  bi = (JDIMENSION )0;
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 285
    if (! (bi < num_blocks)) {
#line 285
      goto while_break;
    }
#line 291
    workspaceptr = workspace;
#line 292
    elemr = 0;
    {
#line 292
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 292
      if (! (elemr < 8)) {
#line 292
        goto while_break___0;
      }
#line 293
      elemptr = *(sample_data + elemr) + start_col;
#line 295
      tmp = workspaceptr;
#line 295
      workspaceptr ++;
#line 295
      tmp___0 = elemptr;
#line 295
      elemptr ++;
#line 295
      *tmp = (float )((int )*tmp___0 - 128);
#line 296
      tmp___1 = workspaceptr;
#line 296
      workspaceptr ++;
#line 296
      tmp___2 = elemptr;
#line 296
      elemptr ++;
#line 296
      *tmp___1 = (float )((int )*tmp___2 - 128);
#line 297
      tmp___3 = workspaceptr;
#line 297
      workspaceptr ++;
#line 297
      tmp___4 = elemptr;
#line 297
      elemptr ++;
#line 297
      *tmp___3 = (float )((int )*tmp___4 - 128);
#line 298
      tmp___5 = workspaceptr;
#line 298
      workspaceptr ++;
#line 298
      tmp___6 = elemptr;
#line 298
      elemptr ++;
#line 298
      *tmp___5 = (float )((int )*tmp___6 - 128);
#line 299
      tmp___7 = workspaceptr;
#line 299
      workspaceptr ++;
#line 299
      tmp___8 = elemptr;
#line 299
      elemptr ++;
#line 299
      *tmp___7 = (float )((int )*tmp___8 - 128);
#line 300
      tmp___9 = workspaceptr;
#line 300
      workspaceptr ++;
#line 300
      tmp___10 = elemptr;
#line 300
      elemptr ++;
#line 300
      *tmp___9 = (float )((int )*tmp___10 - 128);
#line 301
      tmp___11 = workspaceptr;
#line 301
      workspaceptr ++;
#line 301
      tmp___12 = elemptr;
#line 301
      elemptr ++;
#line 301
      *tmp___11 = (float )((int )*tmp___12 - 128);
#line 302
      tmp___13 = workspaceptr;
#line 302
      workspaceptr ++;
#line 302
      tmp___14 = elemptr;
#line 302
      elemptr ++;
#line 302
      *tmp___13 = (float )((int )*tmp___14 - 128);
#line 292
      elemr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 315
    (*do_dct)(workspace);
#line 320
    output_ptr = *(coef_blocks + bi);
#line 322
    i = 0;
    }
    {
#line 322
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 322
      if (! (i < 64)) {
#line 322
        goto while_break___1;
      }
#line 324
      temp = workspace[i] * *(divisors + i);
#line 331
      *(output_ptr + i) = (JCOEF )((int )(temp + (float )16384.5) - 16384);
#line 322
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 285
    bi ++;
#line 285
    start_col += 8U;
  }
  while_break: /* CIL Label */ ;
  }
#line 335
  return;
}
}
#line 344 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcdctmgr.c"
void jinit_forward_dct(j_compress_ptr cinfo ) 
{ 
  my_fdct_ptr fdct ;
  int i ;
  void *tmp ;

  {
  {
#line 350
  tmp = (*((cinfo->mem)->alloc_small))((j_common_ptr )cinfo, 1, sizeof(my_fdct_controller ));
#line 350
  fdct = (my_fdct_ptr )tmp;
#line 353
  cinfo->fdct = (struct jpeg_forward_dct *)fdct;
#line 354
  fdct->pub.start_pass = & start_pass_fdctmgr;
  }
  {
#line 358
  if ((unsigned int )cinfo->dct_method == 0U) {
#line 358
    goto case_0;
  }
#line 364
  if ((unsigned int )cinfo->dct_method == 1U) {
#line 364
    goto case_1;
  }
#line 370
  if ((unsigned int )cinfo->dct_method == 2U) {
#line 370
    goto case_2;
  }
#line 375
  goto switch_default;
  case_0: /* CIL Label */ 
#line 359
  fdct->pub.forward_DCT = & forward_DCT;
#line 360
  fdct->do_dct = & jpeg_fdct_islow;
#line 361
  goto switch_break;
  case_1: /* CIL Label */ 
#line 365
  fdct->pub.forward_DCT = & forward_DCT;
#line 366
  fdct->do_dct = & jpeg_fdct_ifast;
#line 367
  goto switch_break;
  case_2: /* CIL Label */ 
#line 371
  fdct->pub.forward_DCT = & forward_DCT_float;
#line 372
  fdct->do_float_dct = & jpeg_fdct_float;
#line 373
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 376
  (cinfo->err)->msg_code = 48;
#line 376
  (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
  }
#line 377
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 381
  i = 0;
  {
#line 381
  while (1) {
    while_continue: /* CIL Label */ ;
#line 381
    if (! (i < 4)) {
#line 381
      goto while_break;
    }
#line 382
    fdct->divisors[i] = (DCTELEM *)((void *)0);
#line 384
    fdct->float_divisors[i] = (float *)((void *)0);
#line 381
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 387
  return;
}
}
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off_t __offset ) ;
#line 76
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
#line 377 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 775
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 156 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 49 "/home/wheatley/newnew/temp/outguess-0.2/outguess.h"
int steg_stat  ;
#line 96
u_char *encode_data(u_char *data___0 , int *len , struct arc4_stream *as , int flags ) ;
#line 97
u_char *decode_data(u_char *encdata , int *len , struct arc4_stream *as , int flags ) ;
#line 101
stegres steg_embed(bitmap *bitmap___0 , struct _iterator *iter , struct arc4_stream *as ,
                   u_char *data___0 , u_int datalen , u_int16_t seed , int embed ) ;
#line 104
u_int32_t steg_retrbyte(bitmap *bitmap___0 , int bits , struct _iterator *iter ) ;
#line 106
char *steg_retrieve(int *len , bitmap *bitmap___0 , struct _iterator *iter , struct arc4_stream *as ,
                    int flags ) ;
#line 109
void mmap_file(char *name , u_char **data___0 , int *size ) ;
#line 110
void munmap_file(u_char *data___0 , int len ) ;
#line 2 "/home/wheatley/newnew/temp/outguess-0.2/golay.h"
long encoding_table[4096] ;
#line 3
long decoding_table[2048] ;
#line 5
void init_golay(void) ;
#line 6
long get_syndrome(long pattern___0 ) ;
#line 50 "/home/wheatley/newnew/temp/outguess-0.2/jpg.h"
handler jpg_handler ;
#line 52 "/home/wheatley/newnew/temp/outguess-0.2/iterator.h"
void iterator_init(iterator *iter , struct _bitmap *bitmap___0 , u_char *key , u_int klen ) ;
#line 53
int iterator_next(iterator *iter , struct _bitmap *bitmap___0 ) ;
#line 57
void iterator_seed(iterator *iter , struct _bitmap *bitmap___0 , u_int16_t seed ) ;
#line 58
void iterator_adapt(iterator *iter , struct _bitmap *bitmap___0 , int datalen ) ;
#line 68 "/home/wheatley/newnew/temp/outguess-0.2/outguess.c"
static int steg_err_buf[23]  ;
#line 69 "/home/wheatley/newnew/temp/outguess-0.2/outguess.c"
static int steg_err_cnt  ;
#line 70 "/home/wheatley/newnew/temp/outguess-0.2/outguess.c"
static int steg_errors  ;
#line 71 "/home/wheatley/newnew/temp/outguess-0.2/outguess.c"
static int steg_encoded  ;
#line 73 "/home/wheatley/newnew/temp/outguess-0.2/outguess.c"
static int steg_offset[1024]  ;
#line 74 "/home/wheatley/newnew/temp/outguess-0.2/outguess.c"
int steg_foil  ;
#line 75 "/home/wheatley/newnew/temp/outguess-0.2/outguess.c"
int steg_foilfail  ;
#line 77 "/home/wheatley/newnew/temp/outguess-0.2/outguess.c"
static int steg_count  ;
#line 78 "/home/wheatley/newnew/temp/outguess-0.2/outguess.c"
static int steg_mis  ;
#line 79 "/home/wheatley/newnew/temp/outguess-0.2/outguess.c"
static int steg_mod  ;
#line 80 "/home/wheatley/newnew/temp/outguess-0.2/outguess.c"
static int steg_data  ;
#line 88 "/home/wheatley/newnew/temp/outguess-0.2/outguess.c"
handler *handlers[2]  = {      & pnm_handler,      & jpg_handler};
#line 93 "/home/wheatley/newnew/temp/outguess-0.2/outguess.c"
handler *get_handler(char *name ) 
{ 
  int i ;
  int tmp ;

  {
  {
#line 98
  name = strrchr((char const   *)name, '.');
  }
#line 98
  if (! name) {
#line 99
    return ((handler *)((void *)0));
  }
#line 100
  name ++;
#line 102
  i = (int )(sizeof(handlers) / sizeof(handler *) - 1UL);
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (! (i >= 0)) {
#line 102
      goto while_break;
    }
    {
#line 103
    tmp = strcasecmp((char const   *)name, (char const   *)(handlers[i])->extension);
    }
#line 103
    if (! tmp) {
#line 104
      return (handlers[i]);
    }
#line 102
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  return ((handler *)((void *)0));
}
}
#line 109 "/home/wheatley/newnew/temp/outguess-0.2/outguess.c"
void *checkedmalloc(size_t n ) 
{ 
  void *p ;

  {
  {
#line 114
  p = malloc(n);
  }
#line 114
  if (! p) {
    {
#line 115
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"checkedmalloc: not enough memory\n");
#line 116
    exit(1);
    }
  }
#line 119
  return (p);
}
}
#line 128 "/home/wheatley/newnew/temp/outguess-0.2/outguess.c"
void steg_adjust_errors(bitmap *bitmap___0 , int flags ) 
{ 
  int i ;
  int j ;
  int n ;
  int many ;
  int flag ;
  int priority[3] ;
  int detect[3] ;
  int n___0 ;
  int n___1 ;

  {
#line 134
  many = 3 - steg_errors;
#line 135
  j = 0;
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (j < many) {
#line 135
      if (! (j < steg_err_cnt)) {
#line 135
        goto while_break;
      }
    } else {
#line 135
      goto while_break;
    }
#line 136
    priority[j] = steg_err_buf[j];
#line 137
    detect[j] = (int )*(bitmap___0->detect + priority[j]);
#line 135
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 141
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 142
    flag = 0;
#line 142
    i = 0;
    {
#line 142
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 142
      if (! (i < j - 1)) {
#line 142
        goto while_break___1;
      }
#line 143
      if (detect[i] < detect[i + 1]) {
        {
#line 144
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 144
          n___0 = detect[i];
#line 144
          detect[i] = detect[i + 1];
#line 144
          detect[i + 1] = n___0;
#line 144
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 145
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 145
          n___1 = priority[i];
#line 145
          priority[i] = priority[i + 1];
#line 145
          priority[i + 1] = n___1;
#line 145
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 146
        flag = 1;
      }
#line 142
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 141
    if (! flag) {
#line 141
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 150
  i = j;
  {
#line 150
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 150
    if (! (i < steg_err_cnt)) {
#line 150
      goto while_break___4;
    }
#line 151
    n = 0;
    {
#line 151
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 151
      if (! (n < j)) {
#line 151
        goto while_break___5;
      }
#line 152
      if (detect[n] < (int )*(bitmap___0->detect + steg_err_buf[i])) {
#line 153
        goto while_break___5;
      }
#line 151
      n ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 154
    if (n < j - 1) {
      {
#line 155
      memmove((void *)((detect + n) + 1), (void const   *)(detect + n), (unsigned long )(j - n) * sizeof(int ));
#line 157
      memmove((void *)((priority + n) + 1), (void const   *)(priority + n), (unsigned long )(j - n) * sizeof(int ));
      }
    }
#line 160
    if (n < j) {
#line 161
      priority[n] = steg_err_buf[i];
#line 162
      detect[n] = (int )*(bitmap___0->detect + steg_err_buf[i]);
    }
#line 150
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 166
  i = 0;
  {
#line 166
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 166
    if (! (i < j)) {
#line 166
      goto while_break___6;
    }
#line 167
    if (flags & 1) {
#line 168
      *(bitmap___0->locked + i / 8) = (u_char )((int )*(bitmap___0->locked + i / 8) & ~ (1 << (i & 7)));
#line 169
      if ((int )*(bitmap___0->bitmap + priority[i] / 8) & (1 << (priority[i] & 7))) {
#line 170
        *(bitmap___0->bitmap + i / 8) = (u_char )((int )*(bitmap___0->bitmap + i / 8) & ~ (1 << (i & 7)));
      } else {
#line 172
        *(bitmap___0->bitmap + i / 8) = (u_char )(((int )*(bitmap___0->bitmap + i / 8) & ~ (1 << (i & 7))) | (1 << (i & 7)));
      }
    }
#line 174
    steg_mis --;
#line 175
    steg_mod -= detect[i];
#line 166
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 177
  return;
}
}
#line 179 "/home/wheatley/newnew/temp/outguess-0.2/outguess.c"
int steg_embedchunk(bitmap *bitmap___0 , iterator *iter , u_int32_t data___0 , int bits ,
                    int embed ) 
{ 
  int i ;
  u_int8_t bit ;
  u_int32_t val ;
  u_char *pbits ;
  u_char *plocked ;
  int nbits ;
  int tmp ;

  {
#line 183
  i = iter->off;
#line 189
  pbits = bitmap___0->bitmap;
#line 190
  plocked = bitmap___0->locked;
#line 191
  nbits = bitmap___0->bits;
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 193
    if (i < nbits) {
#line 193
      if (! bits) {
#line 193
        goto while_break;
      }
    } else {
#line 193
      goto while_break;
    }
#line 194
    if (embed & 8) {
#line 194
      if (! steg_encoded) {
#line 195
        if (steg_err_cnt > 0) {
          {
#line 196
          steg_adjust_errors(bitmap___0, embed);
          }
        }
        {
#line 197
        steg_encoded = 23;
#line 198
        steg_errors = 0;
#line 199
        steg_err_cnt = 0;
#line 200
        memset((void *)(steg_err_buf), 0, sizeof(steg_err_buf));
        }
      }
    }
#line 202
    steg_encoded --;
#line 204
    if ((int )*(pbits + i / 8) & (1 << (i & 7))) {
#line 204
      bit = (u_int8_t )1;
    } else {
#line 204
      bit = (u_int8_t )0;
    }
#line 205
    val = (unsigned int )bit ^ (data___0 & 1U);
#line 206
    steg_count ++;
#line 207
    if (val == 1U) {
#line 208
      steg_mod += (int )*(bitmap___0->detect + i);
#line 209
      steg_mis ++;
    }
#line 213
    if (val == 1U) {
#line 213
      if ((int )*(plocked + i / 8) & (1 << (i & 7))) {
#line 214
        if (! (embed & 8)) {
#line 215
          return (0);
        } else {
#line 214
          steg_errors ++;
#line 214
          if (steg_errors > 3) {
#line 215
            return (0);
          }
        }
#line 216
        val = (u_int32_t )2;
      }
    }
#line 220
    if (embed & 8) {
#line 220
      if (val == 1U) {
#line 221
        tmp = steg_err_cnt;
#line 221
        steg_err_cnt ++;
#line 221
        steg_err_buf[tmp] = i;
      }
    }
#line 223
    if (val != 2U) {
#line 223
      if (embed & 1) {
#line 224
        *(plocked + i / 8) = (u_char )(((int )*(plocked + i / 8) & ~ (1 << (i & 7))) | (1 << (i & 7)));
#line 225
        *(pbits + i / 8) = (u_char )((unsigned int )((int )*(pbits + i / 8) & ~ (1 << (i & 7))) | ((data___0 & 1U) << (i & 7)));
      }
    }
    {
#line 228
    data___0 >>= 1;
#line 229
    bits --;
#line 231
    i = iterator_next(iter, bitmap___0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  return (1);
}
}
#line 237 "/home/wheatley/newnew/temp/outguess-0.2/outguess.c"
stegres steg_embed(bitmap *bitmap___0 , struct _iterator *iter , struct arc4_stream *as ,
                   u_char *data___0 , u_int datalen , u_int16_t seed , int embed ) 
{ 
  int i ;
  int len ;
  u_int32_t tmp ;
  u_char tmpbuf[4] ;
  u_char *encbuf ;
  stegres result ;
  int tmp___0 ;
  u_char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 242
  tmp = (u_int32_t )0;
#line 246
  steg_mod = 0;
#line 246
  steg_mis = steg_mod;
#line 246
  steg_count = steg_mis;
#line 248
  memset((void *)(& result), 0, sizeof(result));
  }
#line 250
  if ((u_int )bitmap___0->bits / (datalen * 8U) < 2U) {
    {
#line 251
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"steg_embed: not enough bits in bitmap for embedding: %d > %d/2\n",
            datalen * 8U, bitmap___0->bits);
#line 254
    exit(1);
    }
  }
#line 257
  if (embed & 1) {
    {
#line 258
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Embedding data: %d in %d\n",
            datalen * 8U, bitmap___0->bits);
    }
  }
  {
#line 262
  steg_encoded = 0;
#line 263
  steg_err_cnt = 0;
#line 266
  tmpbuf[0] = (u_char )((int )seed & 255);
#line 267
  tmpbuf[1] = (u_char )((int )seed >> 8);
#line 268
  tmpbuf[2] = (u_char )(datalen & 255U);
#line 269
  tmpbuf[3] = (u_char )(datalen >> 8);
#line 272
  len = 4;
#line 273
  encbuf = encode_data(tmpbuf, & len, as, embed);
#line 275
  i = 0;
  }
  {
#line 275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 275
    if (! (i < len)) {
#line 275
      goto while_break;
    }
    {
#line 276
    tmp___0 = steg_embedchunk(bitmap___0, iter, (u_int32_t )*(encbuf + i), 8, embed);
    }
#line 276
    if (! tmp___0) {
      {
#line 277
      free((void *)encbuf);
      }
#line 282
      if (embed & 8) {
#line 284
        result.error = 1;
      } else
#line 282
      if (steg_count < 16) {
#line 284
        result.error = 1;
      } else {
#line 286
        result.error = 3;
      }
#line 287
      return (result);
    }
#line 275
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 289
  free((void *)encbuf);
#line 292
  steg_encoded = 0;
#line 294
  iterator_seed(iter, bitmap___0, seed);
  }
  {
#line 296
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 296
    if (iter->off < bitmap___0->bits) {
#line 296
      if (! (datalen > 0U)) {
#line 296
        goto while_break___0;
      }
    } else {
#line 296
      goto while_break___0;
    }
    {
#line 297
    iterator_adapt(iter, bitmap___0, (int )datalen);
#line 299
    tmp___1 = data___0;
#line 299
    data___0 ++;
#line 299
    tmp = (u_int32_t )*tmp___1;
#line 300
    datalen --;
#line 302
    tmp___2 = steg_embedchunk(bitmap___0, iter, tmp, 8, embed);
    }
#line 302
    if (! tmp___2) {
#line 303
      result.error = 2;
#line 304
      return (result);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 309
  if (embed & 8) {
#line 309
    if (steg_err_cnt > 0) {
      {
#line 310
      steg_adjust_errors(bitmap___0, embed);
      }
    }
  }
#line 312
  if (embed & 1) {
    {
#line 313
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bits embedded: %d, changed: %d(%2.1f%%)[%2.1f%%], bias: %d, tot: %d, skip: %d\n",
            steg_count, steg_mis, (double )(((float )100 * (float )steg_mis) / (float )steg_count),
            (double )(((float )100 * (float )steg_mis) / (float )steg_data), steg_mod,
            iter->off, iter->off - steg_count);
    }
  }
#line 324
  result.changed = steg_mis;
#line 325
  result.bias = steg_mod;
#line 327
  return (result);
}
}
#line 330 "/home/wheatley/newnew/temp/outguess-0.2/outguess.c"
u_int32_t steg_retrbyte(bitmap *bitmap___0 , int bits , struct _iterator *iter ) 
{ 
  u_int32_t i ;
  int where ;
  u_int32_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 333
  i = (u_int32_t )iter->off;
#line 335
  tmp = (u_int32_t )0;
#line 337
  where = 0;
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    if (! (where < bits)) {
#line 337
      goto while_break;
    }
#line 338
    if ((int )*(bitmap___0->bitmap + i / 8U) & (1 << (i & 7U))) {
#line 338
      tmp___0 = 1;
    } else {
#line 338
      tmp___0 = 0;
    }
    {
#line 338
    tmp |= (unsigned int )(tmp___0 << where);
#line 340
    tmp___1 = iterator_next(iter, bitmap___0);
#line 340
    i = (u_int32_t )tmp___1;
#line 337
    where ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 343
  return (tmp);
}
}
#line 346 "/home/wheatley/newnew/temp/outguess-0.2/outguess.c"
char *steg_retrieve(int *len , bitmap *bitmap___0 , struct _iterator *iter , struct arc4_stream *as ,
                    int flags ) 
{ 
  u_int32_t n ;
  int i ;
  u_int32_t origlen ;
  u_int16_t seed ;
  u_int datalen ;
  u_char *buf ;
  u_int8_t *tmpbuf ;
  void *tmp ;
  u_int32_t tmp___0 ;
  void *tmp___1 ;
  u_int32_t tmp___2 ;
  u_int32_t tmp___3 ;

  {
  {
#line 359
  datalen = (u_int )4;
#line 360
  encode_data((u_char *)((void *)0), (int *)(& datalen), (struct arc4_stream *)((void *)0),
              flags);
#line 361
  tmp = checkedmalloc((size_t )datalen);
#line 361
  tmpbuf = (u_int8_t *)tmp;
#line 363
  i = 0;
  }
  {
#line 363
  while (1) {
    while_continue: /* CIL Label */ ;
#line 363
    if (! ((u_int )i < datalen)) {
#line 363
      goto while_break;
    }
    {
#line 364
    tmp___0 = steg_retrbyte(bitmap___0, 8, iter);
#line 364
    *(tmpbuf + i) = (u_int8_t )tmp___0;
#line 363
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 366
  buf = decode_data(tmpbuf, (int *)(& datalen), as, flags);
  }
#line 368
  if (datalen != 4U) {
    {
#line 369
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Steg retrieve: wrong data len: %d\n",
            datalen);
#line 371
    exit(1);
    }
  }
  {
#line 374
  free((void *)tmpbuf);
#line 376
  seed = (u_int16_t )((int )*(buf + 0) | ((int )*(buf + 1) << 8));
#line 377
  datalen = (u_int )((int )*(buf + 2) | ((int )*(buf + 3) << 8));
#line 377
  origlen = datalen;
#line 379
  free((void *)buf);
#line 381
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Steg retrieve: seed: %d, len: %d\n",
          (int )seed, datalen);
  }
#line 383
  if (datalen > (u_int )bitmap___0->bytes) {
    {
#line 384
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Extracted datalen is too long: %d > %d\n",
            datalen, bitmap___0->bytes);
#line 386
    exit(1);
    }
  }
  {
#line 389
  tmp___1 = checkedmalloc((size_t )datalen);
#line 389
  buf = (u_char *)tmp___1;
#line 391
  iterator_seed(iter, bitmap___0, seed);
#line 393
  n = (u_int32_t )0;
  }
  {
#line 394
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 394
    if (! (datalen > 0U)) {
#line 394
      goto while_break___0;
    }
    {
#line 395
    iterator_adapt(iter, bitmap___0, (int )datalen);
#line 396
    tmp___2 = n;
#line 396
    n ++;
#line 396
    tmp___3 = steg_retrbyte(bitmap___0, 8, iter);
#line 396
    *(buf + tmp___2) = (u_char )tmp___3;
#line 397
    datalen --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 400
  *len = (int )origlen;
#line 401
  return ((char *)buf);
}
}
#line 404 "/home/wheatley/newnew/temp/outguess-0.2/outguess.c"
int steg_find(bitmap *bitmap___0 , iterator *iter , struct arc4_stream *as , int siter ,
              int siterstart , u_char *data___0 , int datalen , int flags ) 
{ 
  int changed ;
  int tch ;
  int half ;
  int chmax ;
  int chmin ;
  int j ;
  int i ;
  int size ;
  struct arc4_stream tas ;
  iterator titer ;
  u_int16_t *chstats ;
  stegres result ;
  void *tmp ;
  double mean ;
  double dev ;
  double sq ;
  int cnt ;
  int count ;
  u_int16_t *chtab ;
  int chtabcnt ;
  void *tmp___0 ;
  double tmp___1 ;

  {
#line 410
  size = 0;
#line 413
  chstats = (u_int16_t *)((void *)0);
#line 416
  half = (datalen * 8) / 2;
#line 418
  if (! siter) {
#line 418
    if (! siterstart) {
#line 419
      siter = 256;
    }
  }
#line 421
  if (siter) {
#line 421
    if (siterstart < siter) {
#line 422
      if (steg_stat) {
        {
#line 424
        size = siter - siterstart;
#line 425
        tmp = checkedmalloc((unsigned long )size * sizeof(u_int16_t ));
#line 425
        chstats = (u_int16_t *)tmp;
#line 426
        memset((void *)chstats, 0, (unsigned long )size * sizeof(u_int16_t ));
        }
      }
      {
#line 429
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Finding best embedding...\n");
#line 430
      chmax = -1;
#line 430
      chmin = chmax;
#line 430
      changed = chmin;
#line 430
      j = -1;
#line 432
      i = siterstart;
      }
      {
#line 432
      while (1) {
        while_continue: /* CIL Label */ ;
#line 432
        if (! (i < siter)) {
#line 432
          goto while_break;
        }
        {
#line 433
        titer = *iter;
#line 434
        tas = *as;
#line 435
        result = steg_embed(bitmap___0, & titer, & tas, data___0, (u_int )datalen,
                            (u_int16_t )i, flags);
        }
#line 438
        if (result.error == 3) {
#line 439
          return (- result.error);
        } else
#line 440
        if (result.error) {
#line 441
          goto __Cont;
        }
#line 447
        tch = result.changed + result.bias;
#line 449
        if (steg_stat) {
#line 450
          *(chstats + (i - siterstart)) = (u_int16_t )result.changed;
        }
#line 452
        if (chmax == -1) {
#line 453
          chmax = result.changed;
        } else
#line 452
        if (result.changed > chmax) {
#line 453
          chmax = result.changed;
        }
#line 454
        if (chmin == -1) {
#line 455
          chmin = result.changed;
        } else
#line 454
        if (result.changed < chmin) {
#line 455
          chmin = result.changed;
        }
#line 457
        if (changed == -1) {
          {
#line 458
          changed = tch;
#line 459
          j = i;
#line 460
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5u: %5u(%3.1f%%)[%3.1f%%], bias %5d(%1.2f), saved: % 5d, total: %5.2f%%\n",
                  j, result.changed, (double )(((float )100 * (float )steg_mis) / (float )steg_count),
                  (double )(((float )100 * (float )steg_mis) / (float )steg_data),
                  result.bias, (double )((float )result.bias / (float )steg_mis),
                  (half - result.changed) / 8, (double )(((float )100 * (float )steg_mis) / (float )bitmap___0->bits));
          }
        } else
#line 457
        if (tch < changed) {
          {
#line 458
          changed = tch;
#line 459
          j = i;
#line 460
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%5u: %5u(%3.1f%%)[%3.1f%%], bias %5d(%1.2f), saved: % 5d, total: %5.2f%%\n",
                  j, result.changed, (double )(((float )100 * (float )steg_mis) / (float )steg_count),
                  (double )(((float )100 * (float )steg_mis) / (float )steg_data),
                  result.bias, (double )((float )result.bias / (float )steg_mis),
                  (half - result.changed) / 8, (double )(((float )100 * (float )steg_mis) / (float )bitmap___0->bits));
          }
        }
        __Cont: /* CIL Label */ 
#line 432
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 471
      if (steg_stat) {
#line 471
        if (chmax - chmin > 1) {
          {
#line 472
          mean = (double )0;
#line 473
          cnt = 0;
#line 473
          count = (chmax - chmin) + 1;
#line 475
          chtabcnt = 0;
#line 477
          tmp___0 = checkedmalloc((unsigned long )count * sizeof(u_int16_t ));
#line 477
          chtab = (u_int16_t *)tmp___0;
#line 478
          memset((void *)chtab, 0, (unsigned long )count * sizeof(u_int16_t ));
#line 480
          i = 0;
          }
          {
#line 480
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 480
            if (! (i < size)) {
#line 480
              goto while_break___0;
            }
#line 481
            if ((int )*(chstats + i) > 0) {
#line 482
              mean += (double )*(chstats + i);
#line 483
              cnt ++;
#line 484
              *(chtab + ((int )*(chstats + i) - chmin)) = (u_int16_t )((int )*(chtab + ((int )*(chstats + i) - chmin)) + 1);
#line 485
              chtabcnt ++;
            }
#line 480
            i ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 488
          mean /= (double )cnt;
#line 489
          dev = (double )0;
#line 490
          i = 0;
          {
#line 490
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 490
            if (! (i < size)) {
#line 490
              goto while_break___1;
            }
#line 491
            if ((int )*(chstats + i) > 0) {
#line 492
              sq = (double )*(chstats + i) - mean;
#line 493
              dev += sq * sq;
            }
#line 490
            i ++;
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 496
          tmp___1 = sqrt(dev / (double )(cnt - 1));
#line 496
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Changed bits. Min: %d, Mean: %f, +- %f, Max: %d\n",
                  chmin, mean, tmp___1, chmax);
          }
#line 501
          if (steg_stat > 1) {
#line 502
            i = 0;
            {
#line 502
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 502
              if (! (i < count)) {
#line 502
                goto while_break___2;
              }
#line 503
              if (! *(chtab + i)) {
#line 504
                goto __Cont___0;
              }
              {
#line 505
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d: %.9f\n",
                      chmin + i, (double )*(chtab + i) / (double )chtabcnt);
              }
              __Cont___0: /* CIL Label */ 
#line 502
              i ++;
            }
            while_break___2: /* CIL Label */ ;
            }
          }
          {
#line 510
          free((void *)chtab);
#line 511
          free((void *)chstats);
          }
        }
      }
      {
#line 514
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d, %d: ",
              j, changed);
      }
    } else {
#line 516
      j = siterstart;
    }
  } else {
#line 516
    j = siterstart;
  }
#line 518
  return (j);
}
}
#line 523 "/home/wheatley/newnew/temp/outguess-0.2/outguess.c"
u_char *encode_data(u_char *data___0 , int *len , struct arc4_stream *as , int flags ) 
{ 
  int j ;
  int datalen ;
  u_char *encdata ;
  int eclen ;
  int i ;
  int length ;
  u_int32_t tmp ;
  u_int64_t code ;
  u_char edata[3] ;
  void *tmp___0 ;
  int adj ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  u_int8_t tmp___4 ;

  {
#line 526
  datalen = *len;
#line 529
  if (flags & 8) {
#line 530
    i = 0;
#line 530
    length = 0;
#line 532
    code = (u_int64_t )0;
#line 535
    datalen += 3 - datalen % 3;
#line 536
    eclen = (((datalen * 8) / 12) * 23 + 7) / 8;
#line 538
    if ((unsigned long )data___0 == (unsigned long )((void *)0)) {
#line 539
      *len = eclen;
#line 540
      return ((u_char *)((void *)0));
    }
    {
#line 543
    tmp___0 = checkedmalloc((unsigned long )(3 * eclen) * sizeof(u_char ));
#line 543
    encdata = (u_char *)tmp___0;
    }
    {
#line 544
    while (1) {
      while_continue: /* CIL Label */ ;
#line 544
      if (! (datalen > 0)) {
#line 544
        goto while_break;
      }
#line 545
      if (datalen > 3) {
        {
#line 546
        memcpy((void */* __restrict  */)(edata), (void const   */* __restrict  */)data___0,
               (size_t )3);
        }
      } else {
        {
#line 548
        adj = *len % 3;
#line 549
        memcpy((void */* __restrict  */)(edata), (void const   */* __restrict  */)data___0,
               (size_t )adj);
#line 552
        j = 2;
        }
        {
#line 552
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 552
          if (! (j >= adj)) {
#line 552
            goto while_break___0;
          }
#line 553
          edata[j] = (u_char )(j - adj);
#line 552
          j --;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 555
      tmp = (u_int32_t )edata[0];
#line 556
      tmp |= (unsigned int )((int )edata[1] << 8);
#line 557
      tmp |= (unsigned int )((int )edata[2] << 16);
#line 559
      data___0 += 3;
#line 560
      datalen -= 3;
#line 562
      j = 0;
      {
#line 562
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 562
        if (! (j < 2)) {
#line 562
          goto while_break___1;
        }
#line 563
        code |= (unsigned long )(encoding_table[tmp & 4095U] << length);
#line 564
        length += 23;
        {
#line 565
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 565
          if (! (length >= 8)) {
#line 565
            goto while_break___2;
          }
#line 566
          tmp___1 = i;
#line 566
          i ++;
#line 566
          *(encdata + tmp___1) = (u_char )(code & 255UL);
#line 567
          code >>= 8;
#line 568
          length -= 8;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 570
        tmp >>= 12;
#line 562
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 575
    if (length > 0) {
#line 576
      tmp___2 = i;
#line 576
      i ++;
#line 576
      *(encdata + tmp___2) = (u_char )(code & 255UL);
    }
#line 578
    datalen = eclen;
#line 579
    data___0 = encdata;
  } else {
#line 581
    if ((unsigned long )data___0 == (unsigned long )((void *)0)) {
#line 582
      *len = datalen;
#line 583
      return ((u_char *)((void *)0));
    }
    {
#line 585
    tmp___3 = checkedmalloc((unsigned long )datalen * sizeof(u_char ));
#line 585
    encdata = (u_char *)tmp___3;
    }
  }
#line 589
  j = 0;
  {
#line 589
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 589
    if (! (j < datalen)) {
#line 589
      goto while_break___3;
    }
    {
#line 590
    tmp___4 = arc4_getbyte(as);
#line 590
    *(encdata + j) = (u_char )((int )*(data___0 + j) ^ (int )tmp___4);
#line 589
    j ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 592
  *len = datalen;
#line 594
  return (encdata);
}
}
#line 597 "/home/wheatley/newnew/temp/outguess-0.2/outguess.c"
u_char *decode_data(u_char *encdata , int *len , struct arc4_stream *as , int flags ) 
{ 
  int i ;
  int j ;
  int enclen ;
  int declen ;
  u_char *data___0 ;
  u_int8_t tmp ;
  u_int32_t inbits ;
  u_int32_t outbits ;
  u_int32_t etmp ;
  u_int32_t dtmp ;
  void *tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
#line 600
  enclen = *len;
#line 603
  j = 0;
  {
#line 603
  while (1) {
    while_continue: /* CIL Label */ ;
#line 603
    if (! (j < enclen)) {
#line 603
      goto while_break;
    }
    {
#line 604
    tmp = arc4_getbyte(as);
#line 604
    *(encdata + j) = (u_char )((int )*(encdata + j) ^ (int )tmp);
#line 603
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 606
  if (flags & 8) {
    {
#line 607
    inbits = (u_int32_t )0;
#line 607
    outbits = (u_int32_t )0;
#line 609
    declen = (enclen * 12) / 23;
#line 610
    tmp___0 = checkedmalloc((unsigned long )declen * sizeof(u_char ));
#line 610
    data___0 = (u_char *)tmp___0;
#line 612
    dtmp = (u_int32_t )0;
#line 612
    etmp = dtmp;
#line 613
    i = 0;
#line 613
    j = 0;
    }
    {
#line 613
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 613
      if (i < enclen) {
#line 613
        if (! (j < declen)) {
#line 613
          goto while_break___0;
        }
      } else {
#line 613
        goto while_break___0;
      }
      {
#line 614
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 614
        if (! (outbits < 23U)) {
#line 614
          goto while_break___1;
        }
#line 615
        etmp |= (unsigned int )((int )*((encdata + i) + 0) << outbits);
#line 616
        i ++;
#line 617
        outbits += 8U;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 619
      tmp___1 = get_syndrome((long )(etmp & 8388607U));
#line 619
      dtmp = (u_int32_t )((long )dtmp | ((((long )(etmp & 8388607U) ^ decoding_table[tmp___1]) >> 11) << inbits));
#line 621
      inbits += 12U;
#line 622
      etmp >>= 23;
#line 623
      outbits -= 23U;
      }
      {
#line 624
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 624
        if (! (inbits >= 8U)) {
#line 624
          goto while_break___2;
        }
#line 625
        tmp___2 = j;
#line 625
        j ++;
#line 625
        *(data___0 + tmp___2) = (u_char )(dtmp & 255U);
#line 626
        dtmp >>= 8;
#line 627
        inbits -= 8U;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 631
    i = (int )*(data___0 + (declen - 1));
#line 632
    if (i > 2) {
      {
#line 633
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"decode_data: padding is incorrect: %d\n",
              i);
#line 635
      *len = 0;
      }
#line 636
      return (data___0);
    }
#line 638
    j = i;
    {
#line 638
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 638
      if (! (j >= 0)) {
#line 638
        goto while_break___3;
      }
#line 639
      if ((int )*(data___0 + (((declen - 1) - i) + j)) != j) {
#line 640
        goto while_break___3;
      }
#line 638
      j --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 641
    if (j >= 0) {
      {
#line 642
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"decode_data: padding is incorrect: %d\n",
              i);
#line 644
      *len = 0;
      }
#line 645
      return (data___0);
    }
    {
#line 648
    declen -= i + 1;
#line 649
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Decode: %d data after ECC: %d\n",
            *len, declen);
    }
  } else {
    {
#line 653
    tmp___3 = checkedmalloc((unsigned long )enclen * sizeof(u_char ));
#line 653
    data___0 = (u_char *)tmp___3;
#line 654
    declen = enclen;
#line 655
    memcpy((void */* __restrict  */)data___0, (void const   */* __restrict  */)encdata,
           (size_t )declen);
    }
  }
#line 658
  *len = declen;
#line 659
  return (data___0);
}
}
#line 662 "/home/wheatley/newnew/temp/outguess-0.2/outguess.c"
int do_embed(bitmap *bitmap___0 , u_char *filename , u_char *key , u_int klen , config *cfg ,
             stegres *result ) 
{ 
  iterator iter ;
  struct arc4_stream as ;
  struct arc4_stream tas ;
  u_char *encdata ;
  u_char *data___0 ;
  u_int datalen ;
  u_int enclen ;
  size_t correctlen ;
  int j ;

  {
  {
#line 674
  arc4_initkey(& as, (char *)"Encryption", key, (int )klen);
#line 675
  tas = as;
#line 677
  iterator_init(& iter, bitmap___0, key, klen);
#line 680
  mmap_file((char *)filename, & data___0, (int *)(& datalen));
#line 681
  steg_data = (int )(datalen * 8U);
#line 682
  enclen = datalen;
#line 683
  encdata = encode_data(data___0, (int *)(& enclen), & tas, cfg->flags);
  }
#line 684
  if (cfg->flags & 8) {
    {
#line 685
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Encoded \'%s\' with ECC: %d bits, %d bytes\n",
            filename, enclen * 8U, enclen);
#line 687
    correctlen = (size_t )((enclen / 2U) * 8U);
    }
  } else {
    {
#line 689
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Encoded \'%s\': %d bits, %d bytes\n",
            filename, enclen * 8U, enclen);
#line 691
    correctlen = (size_t )(enclen * 8U);
    }
  }
#line 693
  if (bitmap___0->maxcorrect) {
#line 693
    if (correctlen > bitmap___0->maxcorrect) {
      {
#line 694
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"steg_embed: message larger than correctable size %d > %d\n",
              correctlen, bitmap___0->maxcorrect);
#line 697
      exit(1);
      }
    }
  }
  {
#line 700
  munmap_file(data___0, (int )datalen);
#line 702
  j = steg_find(bitmap___0, & iter, & as, cfg->siter, cfg->siterstart, encdata, (int )enclen,
                cfg->flags);
  }
#line 704
  if (j < 0) {
    {
#line 705
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to find embedding.\n");
    }
#line 706
    goto out;
  }
  {
#line 709
  *result = steg_embed(bitmap___0, & iter, & as, encdata, enclen, (u_int16_t )j, cfg->flags | 1);
  }
  out: 
  {
#line 713
  free((void *)encdata);
  }
#line 715
  return (j);
}
}
#line 718 "/home/wheatley/newnew/temp/outguess-0.2/outguess.c"
void mmap_file(char *name , u_char **data___0 , int *size ) 
{ 
  int fd ;
  struct stat fs ;
  char *p ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 725
  fd = open((char const   *)name, 0, 0);
  }
#line 725
  if (fd == -1) {
    {
#line 726
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can not open %s\n",
            name);
#line 727
    exit(1);
    }
  }
  {
#line 730
  tmp = fstat(fd, & fs);
  }
#line 730
  if (tmp == -1) {
    {
#line 731
    perror("fstat");
#line 732
    exit(1);
    }
  }
  {
#line 736
  tmp___0 = mmap((void *)0, (size_t )fs.st_size, 1, 1, fd, (__off_t )0);
#line 736
  p = (char *)tmp___0;
  }
#line 736
  if ((unsigned long )p == (unsigned long )((void *)-1)) {
    {
#line 737
    perror("mmap");
#line 738
    exit(1);
    }
  }
  {
#line 747
  close(fd);
#line 749
  *data___0 = (u_char *)p;
#line 750
  *size = (int )fs.st_size;
  }
#line 751
  return;
}
}
#line 753 "/home/wheatley/newnew/temp/outguess-0.2/outguess.c"
void munmap_file(u_char *data___0 , int len ) 
{ 
  int tmp ;

  {
  {
#line 757
  tmp = munmap((void *)data___0, (size_t )len);
  }
#line 757
  if (tmp == -1) {
    {
#line 758
    perror("munmap");
#line 759
    exit(1);
    }
  }
#line 764
  return;
}
}
#line 766 "/home/wheatley/newnew/temp/outguess-0.2/outguess.c"
int main(int argc , char **argv ) 
{ 
  char version[56] ;
  char usage___0[577] ;
  char *progname___0 ;
  FILE *fin ;
  FILE *fout ;
  image *image___0 ;
  handler *srch ;
  handler *dsth ;
  char *param ;
  unsigned char *encdata ;
  bitmap bitmap___0 ;
  iterator iter ;
  int j ;
  int ch ;
  int derive ;
  stegres cumres ;
  stegres tmpres ;
  config cfg1 ;
  config cfg2 ;
  u_char *data___0 ;
  u_char *data2 ;
  int datalen ;
  char *key ;
  char *key2 ;
  struct arc4_stream as ;
  struct arc4_stream tas ;
  char mark ;
  char doretrieve ;
  char doerror ;
  char doerror2 ;
  char *cp ;
  int extractonly ;
  int foil ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int bits ;
  uint32_t tmp___2 ;
  size_t tmp___3 ;
  char derivekey[128] ;
  int i ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int i___0 ;
  int count ;
  double mean ;
  double dev ;
  double sq ;
  int n ;
  u_char cbit ;
  u_char *pbits ;
  u_char *data___1 ;
  u_char *plocked ;
  double tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  char *tmp___9 ;

  {
  {
#line 769
  version[0] = (char )'O';
#line 769
  version[1] = (char )'u';
#line 769
  version[2] = (char )'t';
#line 769
  version[3] = (char )'G';
#line 769
  version[4] = (char )'u';
#line 769
  version[5] = (char )'e';
#line 769
  version[6] = (char )'s';
#line 769
  version[7] = (char )'s';
#line 769
  version[8] = (char )' ';
#line 769
  version[9] = (char )'0';
#line 769
  version[10] = (char )'.';
#line 769
  version[11] = (char )'2';
#line 769
  version[12] = (char )' ';
#line 769
  version[13] = (char )'U';
#line 769
  version[14] = (char )'n';
#line 769
  version[15] = (char )'i';
#line 769
  version[16] = (char )'v';
#line 769
  version[17] = (char )'e';
#line 769
  version[18] = (char )'r';
#line 769
  version[19] = (char )'s';
#line 769
  version[20] = (char )'a';
#line 769
  version[21] = (char )'l';
#line 769
  version[22] = (char )' ';
#line 769
  version[23] = (char )'S';
#line 769
  version[24] = (char )'t';
#line 769
  version[25] = (char )'e';
#line 769
  version[26] = (char )'g';
#line 769
  version[27] = (char )'o';
#line 769
  version[28] = (char )' ';
#line 769
  version[29] = (char )'(';
#line 769
  version[30] = (char )'c';
#line 769
  version[31] = (char )')';
#line 769
  version[32] = (char )' ';
#line 769
  version[33] = (char )'1';
#line 769
  version[34] = (char )'9';
#line 769
  version[35] = (char )'9';
#line 769
  version[36] = (char )'9';
#line 769
  version[37] = (char )'-';
#line 769
  version[38] = (char )'2';
#line 769
  version[39] = (char )'0';
#line 769
  version[40] = (char )'0';
#line 769
  version[41] = (char )'1';
#line 769
  version[42] = (char )' ';
#line 769
  version[43] = (char )'N';
#line 769
  version[44] = (char )'i';
#line 769
  version[45] = (char )'e';
#line 769
  version[46] = (char )'l';
#line 769
  version[47] = (char )'s';
#line 769
  version[48] = (char )' ';
#line 769
  version[49] = (char )'P';
#line 769
  version[50] = (char )'r';
#line 769
  version[51] = (char )'o';
#line 769
  version[52] = (char )'v';
#line 769
  version[53] = (char )'o';
#line 769
  version[54] = (char )'s';
#line 769
  version[55] = (char )'\000';
#line 770
  usage___0[0] = (char )'%';
#line 770
  usage___0[1] = (char )'s';
#line 770
  usage___0[2] = (char )'\n';
#line 770
  usage___0[3] = (char )'\n';
#line 770
  usage___0[4] = (char )'%';
#line 770
  usage___0[5] = (char )'s';
#line 770
  usage___0[6] = (char )' ';
#line 770
  usage___0[7] = (char )'[';
#line 770
  usage___0[8] = (char )'o';
#line 770
  usage___0[9] = (char )'p';
#line 770
  usage___0[10] = (char )'t';
#line 770
  usage___0[11] = (char )'i';
#line 770
  usage___0[12] = (char )'o';
#line 770
  usage___0[13] = (char )'n';
#line 770
  usage___0[14] = (char )'s';
#line 770
  usage___0[15] = (char )']';
#line 770
  usage___0[16] = (char )' ';
#line 770
  usage___0[17] = (char )'[';
#line 770
  usage___0[18] = (char )'<';
#line 770
  usage___0[19] = (char )'i';
#line 770
  usage___0[20] = (char )'n';
#line 770
  usage___0[21] = (char )'p';
#line 770
  usage___0[22] = (char )'u';
#line 770
  usage___0[23] = (char )'t';
#line 770
  usage___0[24] = (char )' ';
#line 770
  usage___0[25] = (char )'f';
#line 770
  usage___0[26] = (char )'i';
#line 770
  usage___0[27] = (char )'l';
#line 770
  usage___0[28] = (char )'e';
#line 770
  usage___0[29] = (char )'>';
#line 770
  usage___0[30] = (char )' ';
#line 770
  usage___0[31] = (char )'[';
#line 770
  usage___0[32] = (char )'<';
#line 770
  usage___0[33] = (char )'o';
#line 770
  usage___0[34] = (char )'u';
#line 770
  usage___0[35] = (char )'t';
#line 770
  usage___0[36] = (char )'p';
#line 770
  usage___0[37] = (char )'u';
#line 770
  usage___0[38] = (char )'t';
#line 770
  usage___0[39] = (char )' ';
#line 770
  usage___0[40] = (char )'f';
#line 770
  usage___0[41] = (char )'i';
#line 770
  usage___0[42] = (char )'l';
#line 770
  usage___0[43] = (char )'e';
#line 770
  usage___0[44] = (char )'>';
#line 770
  usage___0[45] = (char )']';
#line 770
  usage___0[46] = (char )']';
#line 770
  usage___0[47] = (char )'\n';
#line 770
  usage___0[48] = (char )'\t';
#line 770
  usage___0[49] = (char )'-';
#line 770
  usage___0[50] = (char )'[';
#line 770
  usage___0[51] = (char )'s';
#line 770
  usage___0[52] = (char )'S';
#line 770
  usage___0[53] = (char )']';
#line 770
  usage___0[54] = (char )' ';
#line 770
  usage___0[55] = (char )'<';
#line 770
  usage___0[56] = (char )'n';
#line 770
  usage___0[57] = (char )'>';
#line 770
  usage___0[58] = (char )' ';
#line 770
  usage___0[59] = (char )' ';
#line 770
  usage___0[60] = (char )' ';
#line 770
  usage___0[61] = (char )' ';
#line 770
  usage___0[62] = (char )'i';
#line 770
  usage___0[63] = (char )'t';
#line 770
  usage___0[64] = (char )'e';
#line 770
  usage___0[65] = (char )'r';
#line 770
  usage___0[66] = (char )'a';
#line 770
  usage___0[67] = (char )'t';
#line 770
  usage___0[68] = (char )'i';
#line 770
  usage___0[69] = (char )'o';
#line 770
  usage___0[70] = (char )'n';
#line 770
  usage___0[71] = (char )' ';
#line 770
  usage___0[72] = (char )'s';
#line 770
  usage___0[73] = (char )'t';
#line 770
  usage___0[74] = (char )'a';
#line 770
  usage___0[75] = (char )'r';
#line 770
  usage___0[76] = (char )'t';
#line 770
  usage___0[77] = (char )',';
#line 770
  usage___0[78] = (char )' ';
#line 770
  usage___0[79] = (char )'c';
#line 770
  usage___0[80] = (char )'a';
#line 770
  usage___0[81] = (char )'p';
#line 770
  usage___0[82] = (char )'i';
#line 770
  usage___0[83] = (char )'t';
#line 770
  usage___0[84] = (char )'a';
#line 770
  usage___0[85] = (char )'l';
#line 770
  usage___0[86] = (char )' ';
#line 770
  usage___0[87] = (char )'l';
#line 770
  usage___0[88] = (char )'e';
#line 770
  usage___0[89] = (char )'t';
#line 770
  usage___0[90] = (char )'t';
#line 770
  usage___0[91] = (char )'e';
#line 770
  usage___0[92] = (char )'r';
#line 770
  usage___0[93] = (char )' ';
#line 770
  usage___0[94] = (char )'f';
#line 770
  usage___0[95] = (char )'o';
#line 770
  usage___0[96] = (char )'r';
#line 770
  usage___0[97] = (char )' ';
#line 770
  usage___0[98] = (char )'2';
#line 770
  usage___0[99] = (char )'n';
#line 770
  usage___0[100] = (char )'d';
#line 770
  usage___0[101] = (char )' ';
#line 770
  usage___0[102] = (char )'d';
#line 770
  usage___0[103] = (char )'a';
#line 770
  usage___0[104] = (char )'t';
#line 770
  usage___0[105] = (char )'a';
#line 770
  usage___0[106] = (char )'s';
#line 770
  usage___0[107] = (char )'e';
#line 770
  usage___0[108] = (char )'t';
#line 770
  usage___0[109] = (char )'\n';
#line 770
  usage___0[110] = (char )'\t';
#line 770
  usage___0[111] = (char )'-';
#line 770
  usage___0[112] = (char )'[';
#line 770
  usage___0[113] = (char )'i';
#line 770
  usage___0[114] = (char )'I';
#line 770
  usage___0[115] = (char )']';
#line 770
  usage___0[116] = (char )' ';
#line 770
  usage___0[117] = (char )'<';
#line 770
  usage___0[118] = (char )'n';
#line 770
  usage___0[119] = (char )'>';
#line 770
  usage___0[120] = (char )' ';
#line 770
  usage___0[121] = (char )' ';
#line 770
  usage___0[122] = (char )' ';
#line 770
  usage___0[123] = (char )' ';
#line 770
  usage___0[124] = (char )'i';
#line 770
  usage___0[125] = (char )'t';
#line 770
  usage___0[126] = (char )'e';
#line 770
  usage___0[127] = (char )'r';
#line 770
  usage___0[128] = (char )'a';
#line 770
  usage___0[129] = (char )'t';
#line 770
  usage___0[130] = (char )'i';
#line 770
  usage___0[131] = (char )'o';
#line 770
  usage___0[132] = (char )'n';
#line 770
  usage___0[133] = (char )' ';
#line 770
  usage___0[134] = (char )'l';
#line 770
  usage___0[135] = (char )'i';
#line 770
  usage___0[136] = (char )'m';
#line 770
  usage___0[137] = (char )'i';
#line 770
  usage___0[138] = (char )'t';
#line 770
  usage___0[139] = (char )'\n';
#line 770
  usage___0[140] = (char )'\t';
#line 770
  usage___0[141] = (char )'-';
#line 770
  usage___0[142] = (char )'[';
#line 770
  usage___0[143] = (char )'k';
#line 770
  usage___0[144] = (char )'K';
#line 770
  usage___0[145] = (char )']';
#line 770
  usage___0[146] = (char )' ';
#line 770
  usage___0[147] = (char )'<';
#line 770
  usage___0[148] = (char )'k';
#line 770
  usage___0[149] = (char )'e';
#line 770
  usage___0[150] = (char )'y';
#line 770
  usage___0[151] = (char )'>';
#line 770
  usage___0[152] = (char )' ';
#line 770
  usage___0[153] = (char )' ';
#line 770
  usage___0[154] = (char )'k';
#line 770
  usage___0[155] = (char )'e';
#line 770
  usage___0[156] = (char )'y';
#line 770
  usage___0[157] = (char )'\n';
#line 770
  usage___0[158] = (char )'\t';
#line 770
  usage___0[159] = (char )'-';
#line 770
  usage___0[160] = (char )'[';
#line 770
  usage___0[161] = (char )'d';
#line 770
  usage___0[162] = (char )'D';
#line 770
  usage___0[163] = (char )']';
#line 770
  usage___0[164] = (char )' ';
#line 770
  usage___0[165] = (char )'<';
#line 770
  usage___0[166] = (char )'n';
#line 770
  usage___0[167] = (char )'a';
#line 770
  usage___0[168] = (char )'m';
#line 770
  usage___0[169] = (char )'e';
#line 770
  usage___0[170] = (char )'>';
#line 770
  usage___0[171] = (char )' ';
#line 770
  usage___0[172] = (char )'f';
#line 770
  usage___0[173] = (char )'i';
#line 770
  usage___0[174] = (char )'l';
#line 770
  usage___0[175] = (char )'e';
#line 770
  usage___0[176] = (char )'n';
#line 770
  usage___0[177] = (char )'a';
#line 770
  usage___0[178] = (char )'m';
#line 770
  usage___0[179] = (char )'e';
#line 770
  usage___0[180] = (char )' ';
#line 770
  usage___0[181] = (char )'o';
#line 770
  usage___0[182] = (char )'f';
#line 770
  usage___0[183] = (char )' ';
#line 770
  usage___0[184] = (char )'d';
#line 770
  usage___0[185] = (char )'a';
#line 770
  usage___0[186] = (char )'t';
#line 770
  usage___0[187] = (char )'a';
#line 770
  usage___0[188] = (char )'s';
#line 770
  usage___0[189] = (char )'e';
#line 770
  usage___0[190] = (char )'t';
#line 770
  usage___0[191] = (char )'\n';
#line 770
  usage___0[192] = (char )'\t';
#line 770
  usage___0[193] = (char )'-';
#line 770
  usage___0[194] = (char )'[';
#line 770
  usage___0[195] = (char )'e';
#line 770
  usage___0[196] = (char )'E';
#line 770
  usage___0[197] = (char )']';
#line 770
  usage___0[198] = (char )' ';
#line 770
  usage___0[199] = (char )' ';
#line 770
  usage___0[200] = (char )' ';
#line 770
  usage___0[201] = (char )' ';
#line 770
  usage___0[202] = (char )' ';
#line 770
  usage___0[203] = (char )' ';
#line 770
  usage___0[204] = (char )' ';
#line 770
  usage___0[205] = (char )' ';
#line 770
  usage___0[206] = (char )'u';
#line 770
  usage___0[207] = (char )'s';
#line 770
  usage___0[208] = (char )'e';
#line 770
  usage___0[209] = (char )' ';
#line 770
  usage___0[210] = (char )'e';
#line 770
  usage___0[211] = (char )'r';
#line 770
  usage___0[212] = (char )'r';
#line 770
  usage___0[213] = (char )'o';
#line 770
  usage___0[214] = (char )'r';
#line 770
  usage___0[215] = (char )' ';
#line 770
  usage___0[216] = (char )'c';
#line 770
  usage___0[217] = (char )'o';
#line 770
  usage___0[218] = (char )'r';
#line 770
  usage___0[219] = (char )'r';
#line 770
  usage___0[220] = (char )'e';
#line 770
  usage___0[221] = (char )'c';
#line 770
  usage___0[222] = (char )'t';
#line 770
  usage___0[223] = (char )'i';
#line 770
  usage___0[224] = (char )'n';
#line 770
  usage___0[225] = (char )'g';
#line 770
  usage___0[226] = (char )' ';
#line 770
  usage___0[227] = (char )'e';
#line 770
  usage___0[228] = (char )'n';
#line 770
  usage___0[229] = (char )'c';
#line 770
  usage___0[230] = (char )'o';
#line 770
  usage___0[231] = (char )'d';
#line 770
  usage___0[232] = (char )'i';
#line 770
  usage___0[233] = (char )'n';
#line 770
  usage___0[234] = (char )'g';
#line 770
  usage___0[235] = (char )'\n';
#line 770
  usage___0[236] = (char )'\t';
#line 770
  usage___0[237] = (char )'-';
#line 770
  usage___0[238] = (char )'p';
#line 770
  usage___0[239] = (char )' ';
#line 770
  usage___0[240] = (char )'<';
#line 770
  usage___0[241] = (char )'p';
#line 770
  usage___0[242] = (char )'a';
#line 770
  usage___0[243] = (char )'r';
#line 770
  usage___0[244] = (char )'a';
#line 770
  usage___0[245] = (char )'m';
#line 770
  usage___0[246] = (char )'>';
#line 770
  usage___0[247] = (char )' ';
#line 770
  usage___0[248] = (char )' ';
#line 770
  usage___0[249] = (char )' ';
#line 770
  usage___0[250] = (char )'p';
#line 770
  usage___0[251] = (char )'a';
#line 770
  usage___0[252] = (char )'r';
#line 770
  usage___0[253] = (char )'a';
#line 770
  usage___0[254] = (char )'m';
#line 770
  usage___0[255] = (char )'e';
#line 770
  usage___0[256] = (char )'t';
#line 770
  usage___0[257] = (char )'e';
#line 770
  usage___0[258] = (char )'r';
#line 770
  usage___0[259] = (char )' ';
#line 770
  usage___0[260] = (char )'p';
#line 770
  usage___0[261] = (char )'a';
#line 770
  usage___0[262] = (char )'s';
#line 770
  usage___0[263] = (char )'s';
#line 770
  usage___0[264] = (char )'e';
#line 770
  usage___0[265] = (char )'d';
#line 770
  usage___0[266] = (char )' ';
#line 770
  usage___0[267] = (char )'t';
#line 770
  usage___0[268] = (char )'o';
#line 770
  usage___0[269] = (char )' ';
#line 770
  usage___0[270] = (char )'d';
#line 770
  usage___0[271] = (char )'e';
#line 770
  usage___0[272] = (char )'s';
#line 770
  usage___0[273] = (char )'t';
#line 770
  usage___0[274] = (char )'i';
#line 770
  usage___0[275] = (char )'n';
#line 770
  usage___0[276] = (char )'a';
#line 770
  usage___0[277] = (char )'t';
#line 770
  usage___0[278] = (char )'i';
#line 770
  usage___0[279] = (char )'o';
#line 770
  usage___0[280] = (char )'n';
#line 770
  usage___0[281] = (char )' ';
#line 770
  usage___0[282] = (char )'d';
#line 770
  usage___0[283] = (char )'a';
#line 770
  usage___0[284] = (char )'t';
#line 770
  usage___0[285] = (char )'a';
#line 770
  usage___0[286] = (char )' ';
#line 770
  usage___0[287] = (char )'h';
#line 770
  usage___0[288] = (char )'a';
#line 770
  usage___0[289] = (char )'n';
#line 770
  usage___0[290] = (char )'d';
#line 770
  usage___0[291] = (char )'l';
#line 770
  usage___0[292] = (char )'e';
#line 770
  usage___0[293] = (char )'r';
#line 770
  usage___0[294] = (char )'\n';
#line 770
  usage___0[295] = (char )'\t';
#line 770
  usage___0[296] = (char )'-';
#line 770
  usage___0[297] = (char )'r';
#line 770
  usage___0[298] = (char )' ';
#line 770
  usage___0[299] = (char )' ';
#line 770
  usage___0[300] = (char )' ';
#line 770
  usage___0[301] = (char )' ';
#line 770
  usage___0[302] = (char )' ';
#line 770
  usage___0[303] = (char )' ';
#line 770
  usage___0[304] = (char )' ';
#line 770
  usage___0[305] = (char )' ';
#line 770
  usage___0[306] = (char )' ';
#line 770
  usage___0[307] = (char )' ';
#line 770
  usage___0[308] = (char )' ';
#line 770
  usage___0[309] = (char )'r';
#line 770
  usage___0[310] = (char )'e';
#line 770
  usage___0[311] = (char )'t';
#line 770
  usage___0[312] = (char )'r';
#line 770
  usage___0[313] = (char )'i';
#line 770
  usage___0[314] = (char )'e';
#line 770
  usage___0[315] = (char )'v';
#line 770
  usage___0[316] = (char )'e';
#line 770
  usage___0[317] = (char )' ';
#line 770
  usage___0[318] = (char )'m';
#line 770
  usage___0[319] = (char )'e';
#line 770
  usage___0[320] = (char )'s';
#line 770
  usage___0[321] = (char )'s';
#line 770
  usage___0[322] = (char )'a';
#line 770
  usage___0[323] = (char )'g';
#line 770
  usage___0[324] = (char )'e';
#line 770
  usage___0[325] = (char )' ';
#line 770
  usage___0[326] = (char )'f';
#line 770
  usage___0[327] = (char )'r';
#line 770
  usage___0[328] = (char )'o';
#line 770
  usage___0[329] = (char )'m';
#line 770
  usage___0[330] = (char )' ';
#line 770
  usage___0[331] = (char )'d';
#line 770
  usage___0[332] = (char )'a';
#line 770
  usage___0[333] = (char )'t';
#line 770
  usage___0[334] = (char )'a';
#line 770
  usage___0[335] = (char )'\n';
#line 770
  usage___0[336] = (char )'\t';
#line 770
  usage___0[337] = (char )'-';
#line 770
  usage___0[338] = (char )'x';
#line 770
  usage___0[339] = (char )' ';
#line 770
  usage___0[340] = (char )'<';
#line 770
  usage___0[341] = (char )'n';
#line 770
  usage___0[342] = (char )'>';
#line 770
  usage___0[343] = (char )' ';
#line 770
  usage___0[344] = (char )' ';
#line 770
  usage___0[345] = (char )' ';
#line 770
  usage___0[346] = (char )' ';
#line 770
  usage___0[347] = (char )' ';
#line 770
  usage___0[348] = (char )' ';
#line 770
  usage___0[349] = (char )' ';
#line 770
  usage___0[350] = (char )'n';
#line 770
  usage___0[351] = (char )'u';
#line 770
  usage___0[352] = (char )'m';
#line 770
  usage___0[353] = (char )'b';
#line 770
  usage___0[354] = (char )'e';
#line 770
  usage___0[355] = (char )'r';
#line 770
  usage___0[356] = (char )' ';
#line 770
  usage___0[357] = (char )'o';
#line 770
  usage___0[358] = (char )'f';
#line 770
  usage___0[359] = (char )' ';
#line 770
  usage___0[360] = (char )'k';
#line 770
  usage___0[361] = (char )'e';
#line 770
  usage___0[362] = (char )'y';
#line 770
  usage___0[363] = (char )' ';
#line 770
  usage___0[364] = (char )'d';
#line 770
  usage___0[365] = (char )'e';
#line 770
  usage___0[366] = (char )'r';
#line 770
  usage___0[367] = (char )'i';
#line 770
  usage___0[368] = (char )'v';
#line 770
  usage___0[369] = (char )'a';
#line 770
  usage___0[370] = (char )'t';
#line 770
  usage___0[371] = (char )'i';
#line 770
  usage___0[372] = (char )'o';
#line 770
  usage___0[373] = (char )'n';
#line 770
  usage___0[374] = (char )'s';
#line 770
  usage___0[375] = (char )' ';
#line 770
  usage___0[376] = (char )'t';
#line 770
  usage___0[377] = (char )'o';
#line 770
  usage___0[378] = (char )' ';
#line 770
  usage___0[379] = (char )'b';
#line 770
  usage___0[380] = (char )'e';
#line 770
  usage___0[381] = (char )' ';
#line 770
  usage___0[382] = (char )'t';
#line 770
  usage___0[383] = (char )'r';
#line 770
  usage___0[384] = (char )'i';
#line 770
  usage___0[385] = (char )'e';
#line 770
  usage___0[386] = (char )'d';
#line 770
  usage___0[387] = (char )'\n';
#line 770
  usage___0[388] = (char )'\t';
#line 770
  usage___0[389] = (char )'-';
#line 770
  usage___0[390] = (char )'m';
#line 770
  usage___0[391] = (char )' ';
#line 770
  usage___0[392] = (char )' ';
#line 770
  usage___0[393] = (char )' ';
#line 770
  usage___0[394] = (char )' ';
#line 770
  usage___0[395] = (char )' ';
#line 770
  usage___0[396] = (char )' ';
#line 770
  usage___0[397] = (char )' ';
#line 770
  usage___0[398] = (char )' ';
#line 770
  usage___0[399] = (char )' ';
#line 770
  usage___0[400] = (char )' ';
#line 770
  usage___0[401] = (char )' ';
#line 770
  usage___0[402] = (char )'m';
#line 770
  usage___0[403] = (char )'a';
#line 770
  usage___0[404] = (char )'r';
#line 770
  usage___0[405] = (char )'k';
#line 770
  usage___0[406] = (char )' ';
#line 770
  usage___0[407] = (char )'p';
#line 770
  usage___0[408] = (char )'i';
#line 770
  usage___0[409] = (char )'x';
#line 770
  usage___0[410] = (char )'e';
#line 770
  usage___0[411] = (char )'l';
#line 770
  usage___0[412] = (char )'s';
#line 770
  usage___0[413] = (char )' ';
#line 770
  usage___0[414] = (char )'t';
#line 770
  usage___0[415] = (char )'h';
#line 770
  usage___0[416] = (char )'a';
#line 770
  usage___0[417] = (char )'t';
#line 770
  usage___0[418] = (char )' ';
#line 770
  usage___0[419] = (char )'h';
#line 770
  usage___0[420] = (char )'a';
#line 770
  usage___0[421] = (char )'v';
#line 770
  usage___0[422] = (char )'e';
#line 770
  usage___0[423] = (char )' ';
#line 770
  usage___0[424] = (char )'b';
#line 770
  usage___0[425] = (char )'e';
#line 770
  usage___0[426] = (char )'e';
#line 770
  usage___0[427] = (char )'n';
#line 770
  usage___0[428] = (char )' ';
#line 770
  usage___0[429] = (char )'m';
#line 770
  usage___0[430] = (char )'o';
#line 770
  usage___0[431] = (char )'d';
#line 770
  usage___0[432] = (char )'i';
#line 770
  usage___0[433] = (char )'f';
#line 770
  usage___0[434] = (char )'i';
#line 770
  usage___0[435] = (char )'e';
#line 770
  usage___0[436] = (char )'d';
#line 770
  usage___0[437] = (char )'\n';
#line 770
  usage___0[438] = (char )'\t';
#line 770
  usage___0[439] = (char )'-';
#line 770
  usage___0[440] = (char )'t';
#line 770
  usage___0[441] = (char )' ';
#line 770
  usage___0[442] = (char )' ';
#line 770
  usage___0[443] = (char )' ';
#line 770
  usage___0[444] = (char )' ';
#line 770
  usage___0[445] = (char )' ';
#line 770
  usage___0[446] = (char )' ';
#line 770
  usage___0[447] = (char )' ';
#line 770
  usage___0[448] = (char )' ';
#line 770
  usage___0[449] = (char )' ';
#line 770
  usage___0[450] = (char )' ';
#line 770
  usage___0[451] = (char )' ';
#line 770
  usage___0[452] = (char )'c';
#line 770
  usage___0[453] = (char )'o';
#line 770
  usage___0[454] = (char )'l';
#line 770
  usage___0[455] = (char )'l';
#line 770
  usage___0[456] = (char )'e';
#line 770
  usage___0[457] = (char )'c';
#line 770
  usage___0[458] = (char )'t';
#line 770
  usage___0[459] = (char )' ';
#line 770
  usage___0[460] = (char )'s';
#line 770
  usage___0[461] = (char )'t';
#line 770
  usage___0[462] = (char )'a';
#line 770
  usage___0[463] = (char )'t';
#line 770
  usage___0[464] = (char )'i';
#line 770
  usage___0[465] = (char )'s';
#line 770
  usage___0[466] = (char )'t';
#line 770
  usage___0[467] = (char )'i';
#line 770
  usage___0[468] = (char )'c';
#line 770
  usage___0[469] = (char )' ';
#line 770
  usage___0[470] = (char )'i';
#line 770
  usage___0[471] = (char )'n';
#line 770
  usage___0[472] = (char )'f';
#line 770
  usage___0[473] = (char )'o';
#line 770
  usage___0[474] = (char )'r';
#line 770
  usage___0[475] = (char )'m';
#line 770
  usage___0[476] = (char )'a';
#line 770
  usage___0[477] = (char )'t';
#line 770
  usage___0[478] = (char )'i';
#line 770
  usage___0[479] = (char )'o';
#line 770
  usage___0[480] = (char )'n';
#line 770
  usage___0[481] = (char )'\n';
#line 770
  usage___0[482] = (char )'\t';
#line 770
  usage___0[483] = (char )'-';
#line 770
  usage___0[484] = (char )'F';
#line 770
  usage___0[485] = (char )'[';
#line 770
  usage___0[486] = (char )'+';
#line 770
  usage___0[487] = (char )'-';
#line 770
  usage___0[488] = (char )']';
#line 770
  usage___0[489] = (char )' ';
#line 770
  usage___0[490] = (char )' ';
#line 770
  usage___0[491] = (char )' ';
#line 770
  usage___0[492] = (char )' ';
#line 770
  usage___0[493] = (char )' ';
#line 770
  usage___0[494] = (char )' ';
#line 770
  usage___0[495] = (char )' ';
#line 770
  usage___0[496] = (char )'t';
#line 770
  usage___0[497] = (char )'u';
#line 770
  usage___0[498] = (char )'r';
#line 770
  usage___0[499] = (char )'n';
#line 770
  usage___0[500] = (char )'s';
#line 770
  usage___0[501] = (char )' ';
#line 770
  usage___0[502] = (char )'s';
#line 770
  usage___0[503] = (char )'t';
#line 770
  usage___0[504] = (char )'a';
#line 770
  usage___0[505] = (char )'t';
#line 770
  usage___0[506] = (char )'i';
#line 770
  usage___0[507] = (char )'s';
#line 770
  usage___0[508] = (char )'t';
#line 770
  usage___0[509] = (char )'i';
#line 770
  usage___0[510] = (char )'c';
#line 770
  usage___0[511] = (char )'a';
#line 770
  usage___0[512] = (char )'l';
#line 770
  usage___0[513] = (char )' ';
#line 770
  usage___0[514] = (char )'s';
#line 770
  usage___0[515] = (char )'t';
#line 770
  usage___0[516] = (char )'e';
#line 770
  usage___0[517] = (char )'g';
#line 770
  usage___0[518] = (char )'a';
#line 770
  usage___0[519] = (char )'n';
#line 770
  usage___0[520] = (char )'a';
#line 770
  usage___0[521] = (char )'l';
#line 770
  usage___0[522] = (char )'y';
#line 770
  usage___0[523] = (char )'s';
#line 770
  usage___0[524] = (char )'i';
#line 770
  usage___0[525] = (char )'s';
#line 770
  usage___0[526] = (char )' ';
#line 770
  usage___0[527] = (char )'f';
#line 770
  usage___0[528] = (char )'o';
#line 770
  usage___0[529] = (char )'i';
#line 770
  usage___0[530] = (char )'l';
#line 770
  usage___0[531] = (char )'i';
#line 770
  usage___0[532] = (char )'n';
#line 770
  usage___0[533] = (char )'g';
#line 770
  usage___0[534] = (char )' ';
#line 770
  usage___0[535] = (char )'o';
#line 770
  usage___0[536] = (char )'n';
#line 770
  usage___0[537] = (char )'/';
#line 770
  usage___0[538] = (char )'o';
#line 770
  usage___0[539] = (char )'f';
#line 770
  usage___0[540] = (char )'f';
#line 770
  usage___0[541] = (char )'.';
#line 770
  usage___0[542] = (char )'\n';
#line 770
  usage___0[543] = (char )'\t';
#line 770
  usage___0[544] = (char )' ';
#line 770
  usage___0[545] = (char )' ';
#line 770
  usage___0[546] = (char )' ';
#line 770
  usage___0[547] = (char )' ';
#line 770
  usage___0[548] = (char )' ';
#line 770
  usage___0[549] = (char )' ';
#line 770
  usage___0[550] = (char )' ';
#line 770
  usage___0[551] = (char )' ';
#line 770
  usage___0[552] = (char )' ';
#line 770
  usage___0[553] = (char )' ';
#line 770
  usage___0[554] = (char )' ';
#line 770
  usage___0[555] = (char )' ';
#line 770
  usage___0[556] = (char )' ';
#line 770
  usage___0[557] = (char )'T';
#line 770
  usage___0[558] = (char )'h';
#line 770
  usage___0[559] = (char )'e';
#line 770
  usage___0[560] = (char )' ';
#line 770
  usage___0[561] = (char )'d';
#line 770
  usage___0[562] = (char )'e';
#line 770
  usage___0[563] = (char )'f';
#line 770
  usage___0[564] = (char )'a';
#line 770
  usage___0[565] = (char )'u';
#line 770
  usage___0[566] = (char )'l';
#line 770
  usage___0[567] = (char )'t';
#line 770
  usage___0[568] = (char )' ';
#line 770
  usage___0[569] = (char )'i';
#line 770
  usage___0[570] = (char )'s';
#line 770
  usage___0[571] = (char )' ';
#line 770
  usage___0[572] = (char )'o';
#line 770
  usage___0[573] = (char )'n';
#line 770
  usage___0[574] = (char )'.';
#line 770
  usage___0[575] = (char )'\n';
#line 770
  usage___0[576] = (char )'\000';
#line 789
  fin = stdin;
#line 789
  fout = stdout;
#line 791
  srch = (handler *)((void *)0);
#line 791
  dsth = (handler *)((void *)0);
#line 792
  param = (char *)((void *)0);
#line 796
  derive = 0;
#line 799
  data___0 = (u_char *)((void *)0);
#line 799
  data2 = (u_char *)((void *)0);
#line 801
  key = (char *)"Default key";
#line 801
  key2 = (char *)((void *)0);
#line 803
  mark = (char)0;
#line 803
  doretrieve = (char)0;
#line 804
  doerror = (char)0;
#line 804
  doerror2 = (char)0;
#line 806
  extractonly = 0;
#line 806
  foil = 1;
#line 811
  progname___0 = *(argv + 0);
#line 812
  steg_stat = 0;
#line 814
  memset((void *)(& cfg1), 0, sizeof(cfg1));
#line 815
  memset((void *)(& cfg2), 0, sizeof(cfg2));
#line 817
  tmp___0 = strchr((char const   *)*(argv + 0), '/');
  }
#line 817
  if (tmp___0) {
    {
#line 818
    tmp = strrchr((char const   *)*(argv + 0), '/');
#line 818
    cp = tmp + 1;
    }
  } else {
#line 820
    cp = *(argv + 0);
  }
  {
#line 821
  tmp___1 = strcmp("outguess-extract", (char const   *)cp);
  }
#line 821
  if (! tmp___1) {
#line 822
    extractonly = 1;
#line 823
    doretrieve = (char)1;
#line 824
    argv ++;
#line 825
    argc --;
#line 826
    goto aftergetop;
  }
  {
#line 830
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 830
    ch = getopt(argc, (char * const  *)argv, "eErmftp:s:S:i:I:k:d:D:K:x:F:");
    }
#line 830
    if (! (ch != -1)) {
#line 830
      goto while_break;
    }
    {
#line 832
    if ((int )((char )ch) == 70) {
#line 832
      goto case_70;
    }
#line 836
    if ((int )((char )ch) == 107) {
#line 836
      goto case_107;
    }
#line 839
    if ((int )((char )ch) == 75) {
#line 839
      goto case_75;
    }
#line 842
    if ((int )((char )ch) == 112) {
#line 842
      goto case_112;
    }
#line 845
    if ((int )((char )ch) == 120) {
#line 845
      goto case_120;
    }
#line 848
    if ((int )((char )ch) == 105) {
#line 848
      goto case_105;
    }
#line 851
    if ((int )((char )ch) == 73) {
#line 851
      goto case_73;
    }
#line 854
    if ((int )((char )ch) == 114) {
#line 854
      goto case_114;
    }
#line 857
    if ((int )((char )ch) == 116) {
#line 857
      goto case_116;
    }
#line 860
    if ((int )((char )ch) == 115) {
#line 860
      goto case_115;
    }
#line 863
    if ((int )((char )ch) == 83) {
#line 863
      goto case_83;
    }
#line 871
    if ((int )((char )ch) == 109) {
#line 871
      goto case_109;
    }
#line 874
    if ((int )((char )ch) == 100) {
#line 874
      goto case_100;
    }
#line 877
    if ((int )((char )ch) == 68) {
#line 877
      goto case_68;
    }
#line 880
    if ((int )((char )ch) == 101) {
#line 880
      goto case_101;
    }
#line 883
    if ((int )((char )ch) == 69) {
#line 883
      goto case_69;
    }
#line 886
    goto switch_default;
    case_70: /* CIL Label */ 
#line 833
    if ((int )*(optarg + 0) == 45) {
#line 834
      foil = 0;
    }
#line 835
    goto switch_break;
    case_107: /* CIL Label */ 
#line 837
    key = optarg;
#line 838
    goto switch_break;
    case_75: /* CIL Label */ 
#line 840
    key2 = optarg;
#line 841
    goto switch_break;
    case_112: /* CIL Label */ 
#line 843
    param = optarg;
#line 844
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 846
    derive = atoi((char const   *)optarg);
    }
#line 847
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 849
    cfg1.siter = atoi((char const   *)optarg);
    }
#line 850
    goto switch_break;
    case_73: /* CIL Label */ 
    {
#line 852
    cfg2.siter = atoi((char const   *)optarg);
    }
#line 853
    goto switch_break;
    case_114: /* CIL Label */ 
#line 855
    doretrieve = (char)1;
#line 856
    goto switch_break;
    case_116: /* CIL Label */ 
#line 858
    steg_stat ++;
#line 859
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 861
    cfg1.siterstart = atoi((char const   *)optarg);
    }
#line 862
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 864
    cfg2.siterstart = atoi((char const   *)optarg);
    }
#line 865
    goto switch_break;
    case_109: /* CIL Label */ 
#line 872
    mark = (char)1;
#line 873
    goto switch_break;
    case_100: /* CIL Label */ 
#line 875
    data___0 = (u_char *)optarg;
#line 876
    goto switch_break;
    case_68: /* CIL Label */ 
#line 878
    data2 = (u_char *)optarg;
#line 879
    goto switch_break;
    case_101: /* CIL Label */ 
#line 881
    doerror = (char)1;
#line 882
    goto switch_break;
    case_69: /* CIL Label */ 
#line 884
    doerror2 = (char)1;
#line 885
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 887
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)(usage___0),
            version, *(argv + 0));
#line 888
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 891
  argc -= optind;
#line 892
  argv += optind;
  aftergetop: 
#line 895
  if (argc != 2) {
#line 895
    if (argc != 0) {
      {
#line 898
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)(usage___0),
              version, progname___0);
#line 899
      exit(1);
      }
    } else {
#line 895
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 895
  if (extractonly) {
#line 895
    if (argc != 2) {
      {
#line 898
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)(usage___0),
              version, progname___0);
#line 899
      exit(1);
      }
    } else {
#line 895
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 895
  if (! doretrieve) {
#line 895
    if (! extractonly) {
#line 895
      if ((unsigned long )data___0 == (unsigned long )((void *)0)) {
        {
#line 898
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)(usage___0),
                version, progname___0);
#line 899
        exit(1);
        }
      }
    }
  }
#line 902
  if (argc == 2) {
    {
#line 903
    srch = get_handler(*(argv + 0));
    }
#line 904
    if ((unsigned long )srch == (unsigned long )((void *)0)) {
      {
#line 905
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown data type of %s\n",
              *(argv + 0));
#line 906
      exit(1);
      }
    }
#line 908
    if (! doretrieve) {
      {
#line 909
      dsth = get_handler(*(argv + 1));
      }
#line 910
      if ((unsigned long )dsth == (unsigned long )((void *)0)) {
        {
#line 911
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown data type of %s\n",
                *(argv + 1));
#line 913
        exit(1);
        }
      }
    }
    {
#line 916
    fin = fopen((char const   */* __restrict  */)*(argv + 0), (char const   */* __restrict  */)"rb");
    }
#line 917
    if ((unsigned long )fin == (unsigned long )((void *)0)) {
      {
#line 918
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t open input file \'%s\': ",
              *(argv + 0));
#line 920
      perror("fopen");
#line 921
      exit(1);
      }
    }
    {
#line 923
    fout = fopen((char const   */* __restrict  */)*(argv + 1), (char const   */* __restrict  */)"wb");
    }
#line 924
    if ((unsigned long )fout == (unsigned long )((void *)0)) {
      {
#line 925
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t open output file \'%s\': ",
              *(argv + 1));
#line 927
      perror("fopen");
#line 928
      exit(1);
      }
    }
  } else {
    {
#line 931
    fin = stdin;
#line 932
    fout = stdout;
#line 934
    dsth = get_handler((char *)".ppm");
#line 934
    srch = dsth;
    }
  }
#line 938
  if (doerror) {
    {
#line 939
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Initalize encoding/decoding tables\n");
#line 940
    init_golay();
    }
  } else
#line 938
  if (doerror2) {
    {
#line 939
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Initalize encoding/decoding tables\n");
#line 940
    init_golay();
    }
  }
  {
#line 943
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reading %s....\n",
          *(argv + 0));
#line 944
  image___0 = (*(srch->read))(fin);
  }
#line 946
  if (extractonly) {
    {
#line 949
    (*(srch->get_bitmap))(& bitmap___0, image___0, 16);
#line 951
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Writing %d bits\n",
            bitmap___0.bits);
#line 952
    tmp___2 = htonl((uint32_t )bitmap___0.bits);
#line 952
    bits = (int )tmp___2;
#line 953
    fwrite((void const   */* __restrict  */)(& bits), (size_t )1, sizeof(int ), (FILE */* __restrict  */)fout);
#line 954
    fwrite((void const   */* __restrict  */)bitmap___0.bitmap, (size_t )bitmap___0.bytes,
           sizeof(char ), (FILE */* __restrict  */)fout);
#line 955
    exit(1);
    }
  } else
#line 956
  if (doretrieve) {
    {
#line 958
    (*(srch->get_bitmap))(& bitmap___0, image___0, 16);
    }
  } else {
    {
#line 961
    (*(dsth->init))(param);
#line 963
    (*(dsth->get_bitmap))(& bitmap___0, image___0, 0);
    }
  }
  {
#line 965
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Extracting usable bits:   %d bits\n",
          bitmap___0.bits);
  }
#line 967
  if (doerror) {
#line 968
    cfg1.flags |= 8;
  }
#line 970
  if (! doretrieve) {
#line 971
    if (mark) {
#line 972
      cfg1.flags |= 2;
    }
#line 973
    if (foil) {
      {
#line 974
      (*(dsth->preserve))(& bitmap___0, -1);
      }
#line 975
      if (bitmap___0.maxcorrect) {
        {
#line 976
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Correctable message size: %d bits, %0.2f%%\n",
                bitmap___0.maxcorrect, (double )(((float )100 * (float )bitmap___0.maxcorrect) / (float )bitmap___0.bits));
        }
      }
    }
    {
#line 982
    tmp___3 = strlen((char const   *)key);
#line 982
    do_embed(& bitmap___0, data___0, (u_char *)key, (u_int )tmp___3, & cfg1, & cumres);
    }
#line 984
    if (key2) {
#line 984
      if (data2) {
#line 989
        cfg2.flags = cfg1.flags;
#line 990
        if (doerror2) {
#line 991
          cfg2.flags |= 8;
        } else {
#line 993
          cfg2.flags &= -9;
        }
#line 995
        j = -1;
#line 995
        i = 0;
        {
#line 995
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 995
          if (i <= derive) {
#line 995
            if (! (j < 0)) {
#line 995
              goto while_break___0;
            }
          } else {
#line 995
            goto while_break___0;
          }
          {
#line 997
          snprintf((char */* __restrict  */)(derivekey), (size_t )128, (char const   */* __restrict  */)"%s%d",
                   key2, i);
          }
#line 1001
          if (i == 0) {
            {
#line 1002
            tmp___4 = strlen((char const   *)key2);
#line 1002
            derivekey[tmp___4] = (char )'\000';
            }
          }
          {
#line 1004
          tmp___5 = strlen((char const   *)(derivekey));
#line 1004
          j = do_embed(& bitmap___0, data2, (u_char *)(derivekey), (u_int )tmp___5,
                       & cfg2, & tmpres);
#line 995
          i ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1009
        if (j < 0) {
          {
#line 1010
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to find embedding.\n");
#line 1011
          exit(1);
          }
        }
#line 1014
        cumres.changed += tmpres.changed;
#line 1015
        cumres.bias += tmpres.bias;
      }
    }
#line 1018
    if (foil) {
      {
#line 1023
      pbits = bitmap___0.bitmap;
#line 1024
      data___1 = (u_char *)bitmap___0.data;
#line 1025
      plocked = bitmap___0.locked;
#line 1027
      memset((void *)(steg_offset), 0, sizeof(steg_offset));
#line 1028
      steg_foilfail = 0;
#line 1028
      steg_foil = steg_foilfail;
#line 1030
      i___0 = 0;
      }
      {
#line 1030
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1030
        if (! (i___0 < bitmap___0.bits)) {
#line 1030
          goto while_break___1;
        }
#line 1031
        if (! ((int )*(plocked + i___0 / 8) & (1 << (i___0 & 7)))) {
#line 1032
          goto __Cont;
        }
#line 1034
        if ((int )*(pbits + i___0 / 8) & (1 << (i___0 & 7))) {
#line 1034
          cbit = (u_char )1;
        } else {
#line 1034
          cbit = (u_char )0;
        }
#line 1036
        if ((int )cbit == ((int )*(data___1 + i___0) & 1)) {
#line 1037
          goto __Cont;
        }
        {
#line 1039
        n = (*(bitmap___0.preserve))(& bitmap___0, i___0);
        }
#line 1040
        if (n > 0) {
          {
#line 1042
          n = abs(n - i___0);
          }
#line 1043
          if (n > 1024) {
#line 1044
            n = 1024;
          }
#line 1046
          (steg_offset[n - 1]) ++;
        }
        __Cont: /* CIL Label */ 
#line 1030
        i___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1051
      (*(bitmap___0.preserve))(& bitmap___0, bitmap___0.bits);
#line 1054
      count = 0;
#line 1055
      mean = (double )0;
#line 1056
      i___0 = 0;
      }
      {
#line 1056
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1056
        if (! (i___0 < 1024)) {
#line 1056
          goto while_break___2;
        }
#line 1057
        count += steg_offset[i___0];
#line 1058
        mean += (double )(steg_offset[i___0] * (i___0 + 1));
#line 1056
        i___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1060
      mean /= (double )count;
#line 1062
      dev = (double )0;
#line 1063
      i___0 = 0;
      {
#line 1063
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1063
        if (! (i___0 < 1024)) {
#line 1063
          goto while_break___3;
        }
#line 1064
        sq = ((double )(i___0 + 1) - mean) * ((double )(i___0 + 1) - mean);
#line 1065
        dev += (double )steg_offset[i___0] * sq;
#line 1063
        i___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 1068
      tmp___6 = sqrt(dev / (double )(count - 1));
#line 1068
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Foiling statistics: corrections: %d, failed: %d, offset: %f +- %f\n",
              steg_foil, steg_foilfail, mean, tmp___6);
      }
    }
    {
#line 1075
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Total bits changed: %d (change %d + bias %d)\n",
            cumres.changed + cumres.bias, cumres.changed, cumres.bias);
#line 1078
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Storing bitmap into data...\n");
#line 1079
    (*(dsth->put_bitmap))(image___0, & bitmap___0, cfg1.flags);
#line 1087
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Writing %s....\n",
            *(argv + 1));
#line 1088
    (*(dsth->write))(fout, image___0);
    }
  } else {
    {
#line 1091
    tmp___7 = strlen((char const   *)key);
#line 1091
    arc4_initkey(& as, (char *)"Encryption", (u_char *)key, (int )tmp___7);
#line 1092
    tas = as;
#line 1094
    tmp___8 = strlen((char const   *)key);
#line 1094
    iterator_init(& iter, & bitmap___0, (u_char *)key, (u_int )tmp___8);
#line 1096
    tmp___9 = steg_retrieve(& datalen, & bitmap___0, & iter, & as, cfg1.flags);
#line 1096
    encdata = (unsigned char *)tmp___9;
#line 1099
    data___0 = decode_data(encdata, & datalen, & tas, cfg1.flags);
#line 1100
    free((void *)encdata);
#line 1102
    fwrite((void const   */* __restrict  */)data___0, (size_t )datalen, sizeof(u_char ),
           (FILE */* __restrict  */)fout);
#line 1103
    free((void *)data___0);
    }
  }
  {
#line 1106
  free((void *)bitmap___0.bitmap);
#line 1107
  free((void *)bitmap___0.locked);
#line 1109
  free_pnm(image___0);
  }
#line 1111
  return (0);
}
}
#line 70 "/home/wheatley/newnew/temp/outguess-0.2/golay.c"
long pattern  ;
#line 71 "/home/wheatley/newnew/temp/outguess-0.2/golay.c"
long encoding_table[4096]  ;
#line 71 "/home/wheatley/newnew/temp/outguess-0.2/golay.c"
long decoding_table[2048]  ;
#line 72 "/home/wheatley/newnew/temp/outguess-0.2/golay.c"
long data  ;
#line 72 "/home/wheatley/newnew/temp/outguess-0.2/golay.c"
long codeword  ;
#line 72 "/home/wheatley/newnew/temp/outguess-0.2/golay.c"
long recd  ;
#line 73 "/home/wheatley/newnew/temp/outguess-0.2/golay.c"
long position[23]  = 
#line 73
  {      1L,      2L,      4L,      8L, 
        16L,      32L,      64L,      128L, 
        256L,      512L,      1024L,      2048L, 
        4096L,      8192L,      16384L,      32768L, 
        65536L,      131072L,      262144L,      524288L, 
        1048576L,      2097152L,      4194304L};
#line 79 "/home/wheatley/newnew/temp/outguess-0.2/golay.c"
long numerr  ;
#line 79 "/home/wheatley/newnew/temp/outguess-0.2/golay.c"
long errpos[23]  ;
#line 79 "/home/wheatley/newnew/temp/outguess-0.2/golay.c"
long decerror  =    0L;
#line 80 "/home/wheatley/newnew/temp/outguess-0.2/golay.c"
int a[4]  ;
#line 82 "/home/wheatley/newnew/temp/outguess-0.2/golay.c"
long arr2int(int *a___0 , int r ) 
{ 
  int i ;
  long mul ;
  long result ;
  long temp ;
  long tmp ;

  {
#line 90
  result = 0L;
#line 92
  i = 1;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! (i <= r)) {
#line 92
      goto while_break;
    }
#line 93
    mul = 1L;
#line 94
    temp = (long )(*(a___0 + i) - 1);
    {
#line 95
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 95
      tmp = temp;
#line 95
      temp --;
#line 95
      if (! tmp) {
#line 95
        goto while_break___0;
      }
#line 96
      mul <<= 1;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 97
    result += mul;
#line 92
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  return (result);
}
}
#line 102 "/home/wheatley/newnew/temp/outguess-0.2/golay.c"
void nextcomb(int n , int r , int *a___0 ) 
{ 
  int i ;
  int j ;

  {
#line 110
  (*(a___0 + r)) ++;
#line 111
  if (*(a___0 + r) <= n) {
#line 112
    return;
  }
#line 114
  j = r - 1;
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    if (! (*(a___0 + j) == (n - r) + j)) {
#line 115
      goto while_break;
    }
#line 116
    j --;
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  i = r;
  {
#line 118
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 118
    if (! (i >= j)) {
#line 118
      goto while_break___0;
    }
#line 119
    *(a___0 + i) = ((*(a___0 + j) + i) - j) + 1;
#line 118
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 121
  return;
}
}
#line 124 "/home/wheatley/newnew/temp/outguess-0.2/golay.c"
long get_syndrome(long pattern___0 ) 
{ 
  long aux ;

  {
#line 136
  aux = 4194304L;
#line 138
  if (pattern___0 >= 2048L) {
    {
#line 139
    while (1) {
      while_continue: /* CIL Label */ ;
#line 139
      if (! (pattern___0 & 4294965248L)) {
#line 139
        goto while_break;
      }
      {
#line 140
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 140
        if (! (! (aux & pattern___0))) {
#line 140
          goto while_break___0;
        }
#line 141
        aux >>= 1;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 142
      pattern___0 ^= (aux / 2048L) * 3189L;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 146
  return (pattern___0);
}
}
#line 149 "/home/wheatley/newnew/temp/outguess-0.2/golay.c"
void init_golay(void) 
{ 
  register int i ;
  long temp ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
#line 167
  pattern = 0L;
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! (pattern < 4096L)) {
#line 167
      goto while_break;
    }
    {
#line 168
    temp = pattern << 11;
#line 169
    tmp = get_syndrome(temp);
#line 169
    encoding_table[pattern] = temp + tmp;
#line 167
    pattern ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  decoding_table[0] = 0L;
#line 185
  decoding_table[1] = 1L;
#line 186
  temp = 1L;
#line 187
  i = 2;
  {
#line 187
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 187
    if (! (i <= 23)) {
#line 187
      goto while_break___0;
    }
    {
#line 188
    temp *= 2L;
#line 189
    tmp___0 = get_syndrome(temp);
#line 189
    decoding_table[tmp___0] = temp;
#line 187
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 195
  a[1] = 1;
#line 195
  a[2] = 2;
#line 196
  temp = arr2int(a, 2);
#line 197
  tmp___1 = get_syndrome(temp);
#line 197
  decoding_table[tmp___1] = temp;
#line 198
  i = 1;
  }
  {
#line 198
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 198
    if (! (i < 253)) {
#line 198
      goto while_break___1;
    }
    {
#line 199
    nextcomb(23, 2, a);
#line 200
    temp = arr2int(a, 2);
#line 201
    tmp___2 = get_syndrome(temp);
#line 201
    decoding_table[tmp___2] = temp;
#line 198
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 206
  a[1] = 1;
#line 206
  a[2] = 2;
#line 206
  a[3] = 3;
#line 207
  temp = arr2int(a, 3);
#line 208
  tmp___3 = get_syndrome(temp);
#line 208
  decoding_table[tmp___3] = temp;
#line 209
  i = 1;
  }
  {
#line 209
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 209
    if (! (i < 1771)) {
#line 209
      goto while_break___2;
    }
    {
#line 210
    nextcomb(23, 3, a);
#line 211
    temp = arr2int(a, 3);
#line 212
    tmp___4 = get_syndrome(temp);
#line 212
    decoding_table[tmp___4] = temp;
#line 209
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 214
  return;
}
}
#line 933 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpeglib.h"
extern JHUFF_TBL *jpeg_alloc_huff_table(j_common_ptr cinfo ) ;
#line 346 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpegint.h"
void jinit_huff_encoder(j_compress_ptr cinfo ) ;
#line 383
extern int const   jpeg_natural_order[] ;
#line 41 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jchuff.h"
void jpeg_make_c_derived_tbl(j_compress_ptr cinfo , boolean isDC , int tblno , c_derived_tbl **pdtbl ) ;
#line 46
void jpeg_gen_optimal_table(j_compress_ptr cinfo , JHUFF_TBL *htbl , long *freq ) ;
#line 89 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jchuff.c"
static boolean encode_mcu_huff(j_compress_ptr cinfo , JBLOCKROW *MCU_data ) ;
#line 91
static void finish_pass_huff(j_compress_ptr cinfo ) ;
#line 93
static boolean encode_mcu_gather(j_compress_ptr cinfo , JBLOCKROW *MCU_data ) ;
#line 95
static void finish_pass_gather(j_compress_ptr cinfo ) ;
#line 105 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jchuff.c"
static void start_pass_huff(j_compress_ptr cinfo , boolean gather_statistics ) 
{ 
  huff_entropy_ptr entropy ;
  int ci ;
  int dctbl ;
  int actbl ;
  jpeg_component_info *compptr ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 108
  entropy = (huff_entropy_ptr )cinfo->entropy;
#line 112
  if (gather_statistics) {
#line 114
    entropy->pub.encode_mcu = & encode_mcu_gather;
#line 115
    entropy->pub.finish_pass = & finish_pass_gather;
  } else {
#line 120
    entropy->pub.encode_mcu = & encode_mcu_huff;
#line 121
    entropy->pub.finish_pass = & finish_pass_huff;
  }
#line 124
  ci = 0;
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (ci < cinfo->comps_in_scan)) {
#line 124
      goto while_break;
    }
#line 125
    compptr = cinfo->cur_comp_info[ci];
#line 126
    dctbl = compptr->dc_tbl_no;
#line 127
    actbl = compptr->ac_tbl_no;
#line 128
    if (gather_statistics) {
#line 132
      if (dctbl < 0) {
        {
#line 133
        (cinfo->err)->msg_code = 50;
#line 133
        (cinfo->err)->msg_parm.i[0] = dctbl;
#line 133
        (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
        }
      } else
#line 132
      if (dctbl >= 4) {
        {
#line 133
        (cinfo->err)->msg_code = 50;
#line 133
        (cinfo->err)->msg_parm.i[0] = dctbl;
#line 133
        (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
        }
      }
#line 134
      if (actbl < 0) {
        {
#line 135
        (cinfo->err)->msg_code = 50;
#line 135
        (cinfo->err)->msg_parm.i[0] = actbl;
#line 135
        (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
        }
      } else
#line 134
      if (actbl >= 4) {
        {
#line 135
        (cinfo->err)->msg_code = 50;
#line 135
        (cinfo->err)->msg_parm.i[0] = actbl;
#line 135
        (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
        }
      }
#line 138
      if ((unsigned long )entropy->dc_count_ptrs[dctbl] == (unsigned long )((void *)0)) {
        {
#line 139
        tmp = (*((cinfo->mem)->alloc_small))((j_common_ptr )cinfo, 1, 257UL * sizeof(long ));
#line 139
        entropy->dc_count_ptrs[dctbl] = (long *)tmp;
        }
      }
      {
#line 142
      memset((void *)entropy->dc_count_ptrs[dctbl], 0, 257UL * sizeof(long ));
      }
#line 143
      if ((unsigned long )entropy->ac_count_ptrs[actbl] == (unsigned long )((void *)0)) {
        {
#line 144
        tmp___0 = (*((cinfo->mem)->alloc_small))((j_common_ptr )cinfo, 1, 257UL * sizeof(long ));
#line 144
        entropy->ac_count_ptrs[actbl] = (long *)tmp___0;
        }
      }
      {
#line 147
      memset((void *)entropy->ac_count_ptrs[actbl], 0, 257UL * sizeof(long ));
      }
    } else {
      {
#line 152
      jpeg_make_c_derived_tbl(cinfo, 1, dctbl, & entropy->dc_derived_tbls[dctbl]);
#line 154
      jpeg_make_c_derived_tbl(cinfo, 0, actbl, & entropy->ac_derived_tbls[actbl]);
      }
    }
#line 158
    entropy->saved.last_dc_val[ci] = 0;
#line 124
    ci ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  entropy->saved.put_buffer = (INT32 )0;
#line 163
  entropy->saved.put_bits = 0;
#line 166
  entropy->restarts_to_go = cinfo->restart_interval;
#line 167
  entropy->next_restart_num = 0;
#line 168
  return;
}
}
#line 178 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jchuff.c"
void jpeg_make_c_derived_tbl(j_compress_ptr cinfo , boolean isDC , int tblno , c_derived_tbl **pdtbl ) 
{ 
  JHUFF_TBL *htbl ;
  c_derived_tbl *dtbl ;
  int p ;
  int i ;
  int l ;
  int lastp ;
  int si ;
  int maxsymbol ;
  char huffsize[257] ;
  unsigned int huffcode[257] ;
  unsigned int code ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 194
  if (tblno < 0) {
    {
#line 195
    (cinfo->err)->msg_code = 50;
#line 195
    (cinfo->err)->msg_parm.i[0] = tblno;
#line 195
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  } else
#line 194
  if (tblno >= 4) {
    {
#line 195
    (cinfo->err)->msg_code = 50;
#line 195
    (cinfo->err)->msg_parm.i[0] = tblno;
#line 195
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
#line 196
  if (isDC) {
#line 196
    htbl = cinfo->dc_huff_tbl_ptrs[tblno];
  } else {
#line 196
    htbl = cinfo->ac_huff_tbl_ptrs[tblno];
  }
#line 198
  if ((unsigned long )htbl == (unsigned long )((void *)0)) {
    {
#line 199
    (cinfo->err)->msg_code = 50;
#line 199
    (cinfo->err)->msg_parm.i[0] = tblno;
#line 199
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
#line 202
  if ((unsigned long )*pdtbl == (unsigned long )((void *)0)) {
    {
#line 203
    tmp = (*((cinfo->mem)->alloc_small))((j_common_ptr )cinfo, 1, sizeof(c_derived_tbl ));
#line 203
    *pdtbl = (c_derived_tbl *)tmp;
    }
  }
#line 206
  dtbl = *pdtbl;
#line 210
  p = 0;
#line 211
  l = 1;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    if (! (l <= 16)) {
#line 211
      goto while_break;
    }
#line 212
    i = (int )htbl->bits[l];
#line 213
    if (i < 0) {
      {
#line 214
      (cinfo->err)->msg_code = 8;
#line 214
      (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
      }
    } else
#line 213
    if (p + i > 256) {
      {
#line 214
      (cinfo->err)->msg_code = 8;
#line 214
      (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
      }
    }
    {
#line 215
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 215
      tmp___1 = i;
#line 215
      i --;
#line 215
      if (! tmp___1) {
#line 215
        goto while_break___0;
      }
#line 216
      tmp___0 = p;
#line 216
      p ++;
#line 216
      huffsize[tmp___0] = (char )l;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 211
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 218
  huffsize[p] = (char)0;
#line 219
  lastp = p;
#line 224
  code = 0U;
#line 225
  si = (int )huffsize[0];
#line 226
  p = 0;
  {
#line 227
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 227
    if (! huffsize[p]) {
#line 227
      goto while_break___1;
    }
    {
#line 228
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 228
      if (! ((int )huffsize[p] == si)) {
#line 228
        goto while_break___2;
      }
#line 229
      tmp___2 = p;
#line 229
      p ++;
#line 229
      huffcode[tmp___2] = code;
#line 230
      code ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 235
    if ((INT32 )code >= 1L << si) {
      {
#line 236
      (cinfo->err)->msg_code = 8;
#line 236
      (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
      }
    }
#line 237
    code <<= 1;
#line 238
    si ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 248
  memset((void *)(dtbl->ehufsi), 0, sizeof(dtbl->ehufsi));
  }
#line 255
  if (isDC) {
#line 255
    maxsymbol = 15;
  } else {
#line 255
    maxsymbol = 255;
  }
#line 257
  p = 0;
  {
#line 257
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 257
    if (! (p < lastp)) {
#line 257
      goto while_break___3;
    }
#line 258
    i = (int )htbl->huffval[p];
#line 259
    if (i < 0) {
      {
#line 260
      (cinfo->err)->msg_code = 8;
#line 260
      (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
      }
    } else
#line 259
    if (i > maxsymbol) {
      {
#line 260
      (cinfo->err)->msg_code = 8;
#line 260
      (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
      }
    } else
#line 259
    if (dtbl->ehufsi[i]) {
      {
#line 260
      (cinfo->err)->msg_code = 8;
#line 260
      (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
      }
    }
#line 261
    dtbl->ehufco[i] = huffcode[p];
#line 262
    dtbl->ehufsi[i] = huffsize[p];
#line 257
    p ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 264
  return;
}
}
#line 277 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jchuff.c"
static boolean dump_buffer(working_state *state ) 
{ 
  struct jpeg_destination_mgr *dest ;
  boolean tmp ;

  {
  {
#line 281
  dest = (state->cinfo)->dest;
#line 283
  tmp = (*(dest->empty_output_buffer))(state->cinfo);
  }
#line 283
  if (! tmp) {
#line 284
    return (0);
  }
#line 286
  state->next_output_byte = dest->next_output_byte;
#line 287
  state->free_in_buffer = dest->free_in_buffer;
#line 288
  return (1);
}
}
#line 300 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jchuff.c"
__inline static boolean emit_bits(working_state *state , unsigned int code , int size ) 
{ 
  register INT32 put_buffer ;
  register int put_bits ;
  int c ;
  JOCTET *tmp ;
  boolean tmp___0 ;
  JOCTET *tmp___1 ;
  boolean tmp___2 ;

  {
#line 306
  put_buffer = (INT32 )code;
#line 307
  put_bits = state->cur.put_bits;
#line 310
  if (size == 0) {
    {
#line 311
    ((state->cinfo)->err)->msg_code = 40;
#line 311
    (*(((state->cinfo)->err)->error_exit))((j_common_ptr )state->cinfo);
    }
  }
#line 313
  put_buffer &= (1L << size) - 1L;
#line 315
  put_bits += size;
#line 317
  put_buffer <<= 24 - put_bits;
#line 319
  put_buffer |= state->cur.put_buffer;
  {
#line 321
  while (1) {
    while_continue: /* CIL Label */ ;
#line 321
    if (! (put_bits >= 8)) {
#line 321
      goto while_break;
    }
#line 322
    c = (int )((put_buffer >> 16) & 255L);
#line 324
    tmp = state->next_output_byte;
#line 324
    (state->next_output_byte) ++;
#line 324
    *tmp = (JOCTET )c;
#line 324
    (state->free_in_buffer) --;
#line 324
    if (state->free_in_buffer == 0UL) {
      {
#line 324
      tmp___0 = dump_buffer(state);
      }
#line 324
      if (! tmp___0) {
#line 324
        return (0);
      }
    }
#line 325
    if (c == 255) {
#line 326
      tmp___1 = state->next_output_byte;
#line 326
      (state->next_output_byte) ++;
#line 326
      *tmp___1 = (JOCTET )0;
#line 326
      (state->free_in_buffer) --;
#line 326
      if (state->free_in_buffer == 0UL) {
        {
#line 326
        tmp___2 = dump_buffer(state);
        }
#line 326
        if (! tmp___2) {
#line 326
          return (0);
        }
      }
    }
#line 328
    put_buffer <<= 8;
#line 329
    put_bits -= 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 332
  state->cur.put_buffer = put_buffer;
#line 333
  state->cur.put_bits = put_bits;
#line 335
  return (1);
}
}
#line 339 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jchuff.c"
static boolean flush_bits(working_state *state ) 
{ 
  boolean tmp ;

  {
  {
#line 342
  tmp = emit_bits(state, 127U, 7);
  }
#line 342
  if (! tmp) {
#line 343
    return (0);
  }
#line 344
  state->cur.put_buffer = (INT32 )0;
#line 345
  state->cur.put_bits = 0;
#line 346
  return (1);
}
}
#line 352 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jchuff.c"
static boolean encode_one_block(working_state *state , JCOEFPTR block , int last_dc_val ,
                                c_derived_tbl *dctbl , c_derived_tbl *actbl ) 
{ 
  register int temp ;
  register int temp2 ;
  register int nbits ;
  register int k ;
  register int r ;
  register int i ;
  boolean tmp ;
  boolean tmp___0 ;
  boolean tmp___1 ;
  boolean tmp___2 ;
  boolean tmp___3 ;
  boolean tmp___4 ;

  {
#line 362
  temp2 = (int )*(block + 0) - last_dc_val;
#line 362
  temp = temp2;
#line 364
  if (temp < 0) {
#line 365
    temp = - temp;
#line 368
    temp2 --;
  }
#line 372
  nbits = 0;
  {
#line 373
  while (1) {
    while_continue: /* CIL Label */ ;
#line 373
    if (! temp) {
#line 373
      goto while_break;
    }
#line 374
    nbits ++;
#line 375
    temp >>= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 380
  if (nbits > 11) {
    {
#line 381
    ((state->cinfo)->err)->msg_code = 6;
#line 381
    (*(((state->cinfo)->err)->error_exit))((j_common_ptr )state->cinfo);
    }
  }
  {
#line 384
  tmp = emit_bits(state, dctbl->ehufco[nbits], (int )dctbl->ehufsi[nbits]);
  }
#line 384
  if (! tmp) {
#line 385
    return (0);
  }
#line 389
  if (nbits) {
    {
#line 390
    tmp___0 = emit_bits(state, (unsigned int )temp2, nbits);
    }
#line 390
    if (! tmp___0) {
#line 391
      return (0);
    }
  }
#line 395
  r = 0;
#line 397
  k = 1;
  {
#line 397
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 397
    if (! (k < 64)) {
#line 397
      goto while_break___0;
    }
#line 398
    temp = (int )*(block + jpeg_natural_order[k]);
#line 398
    if (temp == 0) {
#line 399
      r ++;
    } else {
      {
#line 402
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 402
        if (! (r > 15)) {
#line 402
          goto while_break___1;
        }
        {
#line 403
        tmp___1 = emit_bits(state, actbl->ehufco[240], (int )actbl->ehufsi[240]);
        }
#line 403
        if (! tmp___1) {
#line 404
          return (0);
        }
#line 405
        r -= 16;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 408
      temp2 = temp;
#line 409
      if (temp < 0) {
#line 410
        temp = - temp;
#line 412
        temp2 --;
      }
#line 416
      nbits = 1;
      {
#line 417
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 417
        temp >>= 1;
#line 417
        if (! temp) {
#line 417
          goto while_break___2;
        }
#line 418
        nbits ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 420
      if (nbits > 10) {
        {
#line 421
        ((state->cinfo)->err)->msg_code = 6;
#line 421
        (*(((state->cinfo)->err)->error_exit))((j_common_ptr )state->cinfo);
        }
      }
      {
#line 424
      i = (r << 4) + nbits;
#line 425
      tmp___2 = emit_bits(state, actbl->ehufco[i], (int )actbl->ehufsi[i]);
      }
#line 425
      if (! tmp___2) {
#line 426
        return (0);
      }
      {
#line 430
      tmp___3 = emit_bits(state, (unsigned int )temp2, nbits);
      }
#line 430
      if (! tmp___3) {
#line 431
        return (0);
      }
#line 433
      r = 0;
    }
#line 397
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 438
  if (r > 0) {
    {
#line 439
    tmp___4 = emit_bits(state, actbl->ehufco[0], (int )actbl->ehufsi[0]);
    }
#line 439
    if (! tmp___4) {
#line 440
      return (0);
    }
  }
#line 442
  return (1);
}
}
#line 450 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jchuff.c"
static boolean emit_restart(working_state *state , int restart_num ) 
{ 
  int ci ;
  boolean tmp ;
  JOCTET *tmp___0 ;
  boolean tmp___1 ;
  JOCTET *tmp___2 ;
  boolean tmp___3 ;

  {
  {
#line 455
  tmp = flush_bits(state);
  }
#line 455
  if (! tmp) {
#line 456
    return (0);
  }
#line 458
  tmp___0 = state->next_output_byte;
#line 458
  (state->next_output_byte) ++;
#line 458
  *tmp___0 = (JOCTET )255;
#line 458
  (state->free_in_buffer) --;
#line 458
  if (state->free_in_buffer == 0UL) {
    {
#line 458
    tmp___1 = dump_buffer(state);
    }
#line 458
    if (! tmp___1) {
#line 458
      return (0);
    }
  }
#line 459
  tmp___2 = state->next_output_byte;
#line 459
  (state->next_output_byte) ++;
#line 459
  *tmp___2 = (JOCTET )(208 + restart_num);
#line 459
  (state->free_in_buffer) --;
#line 459
  if (state->free_in_buffer == 0UL) {
    {
#line 459
    tmp___3 = dump_buffer(state);
    }
#line 459
    if (! tmp___3) {
#line 459
      return (0);
    }
  }
#line 462
  ci = 0;
  {
#line 462
  while (1) {
    while_continue: /* CIL Label */ ;
#line 462
    if (! (ci < (state->cinfo)->comps_in_scan)) {
#line 462
      goto while_break;
    }
#line 463
    state->cur.last_dc_val[ci] = 0;
#line 462
    ci ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 467
  return (1);
}
}
#line 475 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jchuff.c"
static boolean encode_mcu_huff(j_compress_ptr cinfo , JBLOCKROW *MCU_data ) 
{ 
  huff_entropy_ptr entropy ;
  working_state state ;
  int blkn ;
  int ci ;
  jpeg_component_info *compptr ;
  boolean tmp ;
  boolean tmp___0 ;

  {
#line 478
  entropy = (huff_entropy_ptr )cinfo->entropy;
#line 484
  state.next_output_byte = (cinfo->dest)->next_output_byte;
#line 485
  state.free_in_buffer = (cinfo->dest)->free_in_buffer;
#line 486
  state.cur = entropy->saved;
#line 487
  state.cinfo = cinfo;
#line 490
  if (cinfo->restart_interval) {
#line 491
    if (entropy->restarts_to_go == 0U) {
      {
#line 492
      tmp = emit_restart(& state, entropy->next_restart_num);
      }
#line 492
      if (! tmp) {
#line 493
        return (0);
      }
    }
  }
#line 497
  blkn = 0;
  {
#line 497
  while (1) {
    while_continue: /* CIL Label */ ;
#line 497
    if (! (blkn < cinfo->blocks_in_MCU)) {
#line 497
      goto while_break;
    }
    {
#line 498
    ci = cinfo->MCU_membership[blkn];
#line 499
    compptr = cinfo->cur_comp_info[ci];
#line 500
    tmp___0 = encode_one_block(& state, *(*(MCU_data + blkn) + 0), state.cur.last_dc_val[ci],
                               entropy->dc_derived_tbls[compptr->dc_tbl_no], entropy->ac_derived_tbls[compptr->ac_tbl_no]);
    }
#line 500
    if (! tmp___0) {
#line 504
      return (0);
    }
#line 506
    state.cur.last_dc_val[ci] = (int )(*(*(MCU_data + blkn) + 0))[0];
#line 497
    blkn ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 510
  (cinfo->dest)->next_output_byte = state.next_output_byte;
#line 511
  (cinfo->dest)->free_in_buffer = state.free_in_buffer;
#line 512
  entropy->saved = state.cur;
#line 515
  if (cinfo->restart_interval) {
#line 516
    if (entropy->restarts_to_go == 0U) {
#line 517
      entropy->restarts_to_go = cinfo->restart_interval;
#line 518
      (entropy->next_restart_num) ++;
#line 519
      entropy->next_restart_num &= 7;
    }
#line 521
    (entropy->restarts_to_go) --;
  }
#line 524
  return (1);
}
}
#line 532 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jchuff.c"
static void finish_pass_huff(j_compress_ptr cinfo ) 
{ 
  huff_entropy_ptr entropy ;
  working_state state ;
  boolean tmp ;

  {
  {
#line 535
  entropy = (huff_entropy_ptr )cinfo->entropy;
#line 539
  state.next_output_byte = (cinfo->dest)->next_output_byte;
#line 540
  state.free_in_buffer = (cinfo->dest)->free_in_buffer;
#line 541
  state.cur = entropy->saved;
#line 542
  state.cinfo = cinfo;
#line 545
  tmp = flush_bits(& state);
  }
#line 545
  if (! tmp) {
    {
#line 546
    (cinfo->err)->msg_code = 24;
#line 546
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
#line 549
  (cinfo->dest)->next_output_byte = state.next_output_byte;
#line 550
  (cinfo->dest)->free_in_buffer = state.free_in_buffer;
#line 551
  entropy->saved = state.cur;
#line 552
  return;
}
}
#line 571 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jchuff.c"
static void htest_one_block(j_compress_ptr cinfo , JCOEFPTR block , int last_dc_val ,
                            long *dc_counts , long *ac_counts ) 
{ 
  register int temp ;
  register int nbits ;
  register int k ;
  register int r ;

  {
#line 581
  temp = (int )*(block + 0) - last_dc_val;
#line 582
  if (temp < 0) {
#line 583
    temp = - temp;
  }
#line 586
  nbits = 0;
  {
#line 587
  while (1) {
    while_continue: /* CIL Label */ ;
#line 587
    if (! temp) {
#line 587
      goto while_break;
    }
#line 588
    nbits ++;
#line 589
    temp >>= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 594
  if (nbits > 11) {
    {
#line 595
    (cinfo->err)->msg_code = 6;
#line 595
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
#line 598
  (*(dc_counts + nbits)) ++;
#line 602
  r = 0;
#line 604
  k = 1;
  {
#line 604
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 604
    if (! (k < 64)) {
#line 604
      goto while_break___0;
    }
#line 605
    temp = (int )*(block + jpeg_natural_order[k]);
#line 605
    if (temp == 0) {
#line 606
      r ++;
    } else {
      {
#line 609
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 609
        if (! (r > 15)) {
#line 609
          goto while_break___1;
        }
#line 610
        (*(ac_counts + 240)) ++;
#line 611
        r -= 16;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 615
      if (temp < 0) {
#line 616
        temp = - temp;
      }
#line 619
      nbits = 1;
      {
#line 620
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 620
        temp >>= 1;
#line 620
        if (! temp) {
#line 620
          goto while_break___2;
        }
#line 621
        nbits ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 623
      if (nbits > 10) {
        {
#line 624
        (cinfo->err)->msg_code = 6;
#line 624
        (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
        }
      }
#line 627
      (*(ac_counts + ((r << 4) + nbits))) ++;
#line 629
      r = 0;
    }
#line 604
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 634
  if (r > 0) {
#line 635
    (*(ac_counts + 0)) ++;
  }
#line 636
  return;
}
}
#line 644 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jchuff.c"
static boolean encode_mcu_gather(j_compress_ptr cinfo , JBLOCKROW *MCU_data ) 
{ 
  huff_entropy_ptr entropy ;
  int blkn ;
  int ci ;
  jpeg_component_info *compptr ;

  {
#line 647
  entropy = (huff_entropy_ptr )cinfo->entropy;
#line 652
  if (cinfo->restart_interval) {
#line 653
    if (entropy->restarts_to_go == 0U) {
#line 655
      ci = 0;
      {
#line 655
      while (1) {
        while_continue: /* CIL Label */ ;
#line 655
        if (! (ci < cinfo->comps_in_scan)) {
#line 655
          goto while_break;
        }
#line 656
        entropy->saved.last_dc_val[ci] = 0;
#line 655
        ci ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 658
      entropy->restarts_to_go = cinfo->restart_interval;
    }
#line 660
    (entropy->restarts_to_go) --;
  }
#line 663
  blkn = 0;
  {
#line 663
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 663
    if (! (blkn < cinfo->blocks_in_MCU)) {
#line 663
      goto while_break___0;
    }
    {
#line 664
    ci = cinfo->MCU_membership[blkn];
#line 665
    compptr = cinfo->cur_comp_info[ci];
#line 666
    htest_one_block(cinfo, *(*(MCU_data + blkn) + 0), entropy->saved.last_dc_val[ci],
                    entropy->dc_count_ptrs[compptr->dc_tbl_no], entropy->ac_count_ptrs[compptr->ac_tbl_no]);
#line 669
    entropy->saved.last_dc_val[ci] = (int )(*(*(MCU_data + blkn) + 0))[0];
#line 663
    blkn ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 672
  return (1);
}
}
#line 704 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jchuff.c"
void jpeg_gen_optimal_table(j_compress_ptr cinfo , JHUFF_TBL *htbl , long *freq ) 
{ 
  UINT8 bits[33] ;
  int codesize[257] ;
  int others[257] ;
  int c1 ;
  int c2 ;
  int p ;
  int i ;
  int j ;
  long v ;

  {
  {
#line 717
  memset((void *)(bits), 0, sizeof(bits));
#line 718
  memset((void *)(codesize), 0, sizeof(codesize));
#line 719
  i = 0;
  }
  {
#line 719
  while (1) {
    while_continue: /* CIL Label */ ;
#line 719
    if (! (i < 257)) {
#line 719
      goto while_break;
    }
#line 720
    others[i] = -1;
#line 719
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 722
  *(freq + 256) = 1L;
  {
#line 730
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 733
    c1 = -1;
#line 734
    v = 1000000000L;
#line 735
    i = 0;
    {
#line 735
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 735
      if (! (i <= 256)) {
#line 735
        goto while_break___1;
      }
#line 736
      if (*(freq + i)) {
#line 736
        if (*(freq + i) <= v) {
#line 737
          v = *(freq + i);
#line 738
          c1 = i;
        }
      }
#line 735
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 744
    c2 = -1;
#line 745
    v = 1000000000L;
#line 746
    i = 0;
    {
#line 746
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 746
      if (! (i <= 256)) {
#line 746
        goto while_break___2;
      }
#line 747
      if (*(freq + i)) {
#line 747
        if (*(freq + i) <= v) {
#line 747
          if (i != c1) {
#line 748
            v = *(freq + i);
#line 749
            c2 = i;
          }
        }
      }
#line 746
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 754
    if (c2 < 0) {
#line 755
      goto while_break___0;
    }
#line 758
    *(freq + c1) += *(freq + c2);
#line 759
    *(freq + c2) = 0L;
#line 762
    (codesize[c1]) ++;
    {
#line 763
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 763
      if (! (others[c1] >= 0)) {
#line 763
        goto while_break___3;
      }
#line 764
      c1 = others[c1];
#line 765
      (codesize[c1]) ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 768
    others[c1] = c2;
#line 771
    (codesize[c2]) ++;
    {
#line 772
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 772
      if (! (others[c2] >= 0)) {
#line 772
        goto while_break___4;
      }
#line 773
      c2 = others[c2];
#line 774
      (codesize[c2]) ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 779
  i = 0;
  {
#line 779
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 779
    if (! (i <= 256)) {
#line 779
      goto while_break___5;
    }
#line 780
    if (codesize[i]) {
#line 783
      if (codesize[i] > 32) {
        {
#line 784
        (cinfo->err)->msg_code = 39;
#line 784
        (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
        }
      }
#line 786
      bits[codesize[i]] = (UINT8 )((int )bits[codesize[i]] + 1);
    }
#line 779
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 801
  i = 32;
  {
#line 801
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 801
    if (! (i > 16)) {
#line 801
      goto while_break___6;
    }
    {
#line 802
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 802
      if (! ((int )bits[i] > 0)) {
#line 802
        goto while_break___7;
      }
#line 803
      j = i - 2;
      {
#line 804
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 804
        if (! ((int )bits[j] == 0)) {
#line 804
          goto while_break___8;
        }
#line 805
        j --;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 807
      bits[i] = (UINT8 )((int )bits[i] - 2);
#line 808
      bits[i - 1] = (UINT8 )((int )bits[i - 1] + 1);
#line 809
      bits[j + 1] = (UINT8 )((int )bits[j + 1] + 2);
#line 810
      bits[j] = (UINT8 )((int )bits[j] - 1);
    }
    while_break___7: /* CIL Label */ ;
    }
#line 801
    i --;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 815
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 815
    if (! ((int )bits[i] == 0)) {
#line 815
      goto while_break___9;
    }
#line 816
    i --;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 817
  bits[i] = (UINT8 )((int )bits[i] - 1);
#line 820
  memcpy((void */* __restrict  */)((void *)(htbl->bits)), (void const   */* __restrict  */)((void const   *)(bits)),
         sizeof(htbl->bits));
#line 826
  p = 0;
#line 827
  i = 1;
  }
  {
#line 827
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 827
    if (! (i <= 32)) {
#line 827
      goto while_break___10;
    }
#line 828
    j = 0;
    {
#line 828
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 828
      if (! (j <= 255)) {
#line 828
        goto while_break___11;
      }
#line 829
      if (codesize[j] == i) {
#line 830
        htbl->huffval[p] = (UINT8 )j;
#line 831
        p ++;
      }
#line 828
      j ++;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 827
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 837
  htbl->sent_table = 0;
#line 838
  return;
}
}
#line 845 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jchuff.c"
static void finish_pass_gather(j_compress_ptr cinfo ) 
{ 
  huff_entropy_ptr entropy ;
  int ci ;
  int dctbl ;
  int actbl ;
  jpeg_component_info *compptr ;
  JHUFF_TBL **htblptr ;
  boolean did_dc[4] ;
  boolean did_ac[4] ;

  {
  {
#line 848
  entropy = (huff_entropy_ptr )cinfo->entropy;
#line 858
  memset((void *)(did_dc), 0, sizeof(did_dc));
#line 859
  memset((void *)(did_ac), 0, sizeof(did_ac));
#line 861
  ci = 0;
  }
  {
#line 861
  while (1) {
    while_continue: /* CIL Label */ ;
#line 861
    if (! (ci < cinfo->comps_in_scan)) {
#line 861
      goto while_break;
    }
#line 862
    compptr = cinfo->cur_comp_info[ci];
#line 863
    dctbl = compptr->dc_tbl_no;
#line 864
    actbl = compptr->ac_tbl_no;
#line 865
    if (! did_dc[dctbl]) {
#line 866
      htblptr = & cinfo->dc_huff_tbl_ptrs[dctbl];
#line 867
      if ((unsigned long )*htblptr == (unsigned long )((void *)0)) {
        {
#line 868
        *htblptr = jpeg_alloc_huff_table((j_common_ptr )cinfo);
        }
      }
      {
#line 869
      jpeg_gen_optimal_table(cinfo, *htblptr, entropy->dc_count_ptrs[dctbl]);
#line 870
      did_dc[dctbl] = 1;
      }
    }
#line 872
    if (! did_ac[actbl]) {
#line 873
      htblptr = & cinfo->ac_huff_tbl_ptrs[actbl];
#line 874
      if ((unsigned long )*htblptr == (unsigned long )((void *)0)) {
        {
#line 875
        *htblptr = jpeg_alloc_huff_table((j_common_ptr )cinfo);
        }
      }
      {
#line 876
      jpeg_gen_optimal_table(cinfo, *htblptr, entropy->ac_count_ptrs[actbl]);
#line 877
      did_ac[actbl] = 1;
      }
    }
#line 861
    ci ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 880
  return;
}
}
#line 890 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jchuff.c"
void jinit_huff_encoder(j_compress_ptr cinfo ) 
{ 
  huff_entropy_ptr entropy ;
  int i ;
  void *tmp ;
  c_derived_tbl *tmp___0 ;
  long *tmp___1 ;

  {
  {
#line 896
  tmp = (*((cinfo->mem)->alloc_small))((j_common_ptr )cinfo, 1, sizeof(huff_entropy_encoder ));
#line 896
  entropy = (huff_entropy_ptr )tmp;
#line 899
  cinfo->entropy = (struct jpeg_entropy_encoder *)entropy;
#line 900
  entropy->pub.start_pass = & start_pass_huff;
#line 903
  i = 0;
  }
  {
#line 903
  while (1) {
    while_continue: /* CIL Label */ ;
#line 903
    if (! (i < 4)) {
#line 903
      goto while_break;
    }
#line 904
    tmp___0 = (c_derived_tbl *)((void *)0);
#line 904
    entropy->ac_derived_tbls[i] = tmp___0;
#line 904
    entropy->dc_derived_tbls[i] = tmp___0;
#line 906
    tmp___1 = (long *)((void *)0);
#line 906
    entropy->ac_count_ptrs[i] = tmp___1;
#line 906
    entropy->dc_count_ptrs[i] = tmp___1;
#line 903
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 909
  return;
}
}
#line 341 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpegint.h"
void jinit_c_coef_controller(j_compress_ptr cinfo , boolean need_full_buffer ) ;
#line 372
extern long jround_up(long a , long b ) ;
#line 378
extern void jzero_far(void *target , size_t bytestozero ) ;
#line 61 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jccoefct.c"
static boolean compress_data(j_compress_ptr cinfo , JSAMPIMAGE input_buf ) ;
#line 64
static boolean compress_first_pass(j_compress_ptr cinfo , JSAMPIMAGE input_buf ) ;
#line 66
static boolean compress_output(j_compress_ptr cinfo , JSAMPIMAGE input_buf ) ;
#line 71 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jccoefct.c"
static void start_iMCU_row(j_compress_ptr cinfo ) 
{ 
  my_coef_ptr coef ;

  {
#line 75
  coef = (my_coef_ptr )cinfo->coef;
#line 81
  if (cinfo->comps_in_scan > 1) {
#line 82
    coef->MCU_rows_per_iMCU_row = 1;
  } else
#line 84
  if (coef->iMCU_row_num < cinfo->total_iMCU_rows - 1U) {
#line 85
    coef->MCU_rows_per_iMCU_row = (cinfo->cur_comp_info[0])->v_samp_factor;
  } else {
#line 87
    coef->MCU_rows_per_iMCU_row = (cinfo->cur_comp_info[0])->last_row_height;
  }
#line 90
  coef->mcu_ctr = (JDIMENSION )0;
#line 91
  coef->MCU_vert_offset = 0;
#line 92
  return;
}
}
#line 99 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jccoefct.c"
static void start_pass_coef(j_compress_ptr cinfo , J_BUF_MODE pass_mode ) 
{ 
  my_coef_ptr coef ;

  {
  {
#line 102
  coef = (my_coef_ptr )cinfo->coef;
#line 104
  coef->iMCU_row_num = (JDIMENSION )0;
#line 105
  start_iMCU_row(cinfo);
  }
  {
#line 108
  if ((unsigned int )pass_mode == 0U) {
#line 108
    goto case_0;
  }
#line 114
  if ((unsigned int )pass_mode == 3U) {
#line 114
    goto case_3;
  }
#line 119
  if ((unsigned int )pass_mode == 2U) {
#line 119
    goto case_2;
  }
#line 125
  goto switch_default;
  case_0: /* CIL Label */ 
#line 109
  if ((unsigned long )coef->whole_image[0] != (unsigned long )((void *)0)) {
    {
#line 110
    (cinfo->err)->msg_code = 4;
#line 110
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
#line 111
  coef->pub.compress_data = & compress_data;
#line 112
  goto switch_break;
  case_3: /* CIL Label */ 
#line 115
  if ((unsigned long )coef->whole_image[0] == (unsigned long )((void *)0)) {
    {
#line 116
    (cinfo->err)->msg_code = 4;
#line 116
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
#line 117
  coef->pub.compress_data = & compress_first_pass;
#line 118
  goto switch_break;
  case_2: /* CIL Label */ 
#line 120
  if ((unsigned long )coef->whole_image[0] == (unsigned long )((void *)0)) {
    {
#line 121
    (cinfo->err)->msg_code = 4;
#line 121
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
#line 122
  coef->pub.compress_data = & compress_output;
#line 123
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 126
  (cinfo->err)->msg_code = 4;
#line 126
  (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
  }
#line 127
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 129
  return;
}
}
#line 142 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jccoefct.c"
static boolean compress_data(j_compress_ptr cinfo , JSAMPIMAGE input_buf ) 
{ 
  my_coef_ptr coef ;
  JDIMENSION MCU_col_num ;
  JDIMENSION last_MCU_col ;
  JDIMENSION last_iMCU_row ;
  int blkn ;
  int bi ;
  int ci ;
  int yindex ;
  int yoffset ;
  int blockcnt ;
  JDIMENSION ypos ;
  JDIMENSION xpos ;
  jpeg_component_info *compptr ;
  boolean tmp ;

  {
#line 145
  coef = (my_coef_ptr )cinfo->coef;
#line 147
  last_MCU_col = cinfo->MCUs_per_row - 1U;
#line 148
  last_iMCU_row = cinfo->total_iMCU_rows - 1U;
#line 154
  yoffset = coef->MCU_vert_offset;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! (yoffset < coef->MCU_rows_per_iMCU_row)) {
#line 154
      goto while_break;
    }
#line 156
    MCU_col_num = coef->mcu_ctr;
    {
#line 156
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 156
      if (! (MCU_col_num <= last_MCU_col)) {
#line 156
        goto while_break___0;
      }
#line 167
      blkn = 0;
#line 168
      ci = 0;
      {
#line 168
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 168
        if (! (ci < cinfo->comps_in_scan)) {
#line 168
          goto while_break___1;
        }
#line 169
        compptr = cinfo->cur_comp_info[ci];
#line 170
        if (MCU_col_num < last_MCU_col) {
#line 170
          blockcnt = compptr->MCU_width;
        } else {
#line 170
          blockcnt = compptr->last_col_width;
        }
#line 172
        xpos = MCU_col_num * (JDIMENSION )compptr->MCU_sample_width;
#line 173
        ypos = (JDIMENSION )(yoffset * 8);
#line 174
        yindex = 0;
        {
#line 174
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 174
          if (! (yindex < compptr->MCU_height)) {
#line 174
            goto while_break___2;
          }
#line 175
          if (coef->iMCU_row_num < last_iMCU_row) {
#line 175
            goto _L;
          } else
#line 175
          if (yoffset + yindex < compptr->last_row_height) {
            _L: /* CIL Label */ 
            {
#line 177
            (*((cinfo->fdct)->forward_DCT))(cinfo, compptr, *(input_buf + compptr->component_index),
                                            coef->MCU_buffer[blkn], ypos, xpos, (JDIMENSION )blockcnt);
            }
#line 181
            if (blockcnt < compptr->MCU_width) {
              {
#line 183
              jzero_far((void *)coef->MCU_buffer[blkn + blockcnt], (size_t )(compptr->MCU_width - blockcnt) * sizeof(JBLOCK ));
#line 185
              bi = blockcnt;
              }
              {
#line 185
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 185
                if (! (bi < compptr->MCU_width)) {
#line 185
                  goto while_break___3;
                }
#line 186
                (*(coef->MCU_buffer[blkn + bi] + 0))[0] = (*(coef->MCU_buffer[(blkn + bi) - 1] + 0))[0];
#line 185
                bi ++;
              }
              while_break___3: /* CIL Label */ ;
              }
            }
          } else {
            {
#line 191
            jzero_far((void *)coef->MCU_buffer[blkn], (size_t )compptr->MCU_width * sizeof(JBLOCK ));
#line 193
            bi = 0;
            }
            {
#line 193
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 193
              if (! (bi < compptr->MCU_width)) {
#line 193
                goto while_break___4;
              }
#line 194
              (*(coef->MCU_buffer[blkn + bi] + 0))[0] = (*(coef->MCU_buffer[blkn - 1] + 0))[0];
#line 193
              bi ++;
            }
            while_break___4: /* CIL Label */ ;
            }
          }
#line 197
          blkn += compptr->MCU_width;
#line 198
          ypos += 8U;
#line 174
          yindex ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 168
        ci ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 204
      tmp = (*((cinfo->entropy)->encode_mcu))(cinfo, coef->MCU_buffer);
      }
#line 204
      if (! tmp) {
#line 206
        coef->MCU_vert_offset = yoffset;
#line 207
        coef->mcu_ctr = MCU_col_num;
#line 208
        return (0);
      }
#line 156
      MCU_col_num ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 212
    coef->mcu_ctr = (JDIMENSION )0;
#line 154
    yoffset ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 215
  (coef->iMCU_row_num) ++;
#line 216
  start_iMCU_row(cinfo);
  }
#line 217
  return (1);
}
}
#line 244 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jccoefct.c"
static boolean compress_first_pass(j_compress_ptr cinfo , JSAMPIMAGE input_buf ) 
{ 
  my_coef_ptr coef ;
  JDIMENSION last_iMCU_row ;
  JDIMENSION blocks_across ;
  JDIMENSION MCUs_across ;
  JDIMENSION MCUindex ;
  int bi ;
  int ci ;
  int h_samp_factor ;
  int block_row ;
  int block_rows ;
  int ndummy ;
  JCOEF lastDC ;
  jpeg_component_info *compptr ;
  JBLOCKARRAY buffer ;
  JBLOCKROW thisblockrow ;
  JBLOCKROW lastblockrow ;
  boolean tmp ;

  {
#line 247
  coef = (my_coef_ptr )cinfo->coef;
#line 248
  last_iMCU_row = cinfo->total_iMCU_rows - 1U;
#line 256
  ci = 0;
#line 256
  compptr = cinfo->comp_info;
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 256
    if (! (ci < cinfo->num_components)) {
#line 256
      goto while_break;
    }
    {
#line 259
    buffer = (*((cinfo->mem)->access_virt_barray))((j_common_ptr )cinfo, coef->whole_image[ci],
                                                   coef->iMCU_row_num * (JDIMENSION )compptr->v_samp_factor,
                                                   (JDIMENSION )compptr->v_samp_factor,
                                                   1);
    }
#line 264
    if (coef->iMCU_row_num < last_iMCU_row) {
#line 265
      block_rows = compptr->v_samp_factor;
    } else {
#line 268
      block_rows = (int )(compptr->height_in_blocks % (unsigned int )compptr->v_samp_factor);
#line 269
      if (block_rows == 0) {
#line 269
        block_rows = compptr->v_samp_factor;
      }
    }
#line 271
    blocks_across = compptr->width_in_blocks;
#line 272
    h_samp_factor = compptr->h_samp_factor;
#line 274
    ndummy = (int )(blocks_across % (unsigned int )h_samp_factor);
#line 275
    if (ndummy > 0) {
#line 276
      ndummy = h_samp_factor - ndummy;
    }
#line 280
    block_row = 0;
    {
#line 280
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 280
      if (! (block_row < block_rows)) {
#line 280
        goto while_break___0;
      }
      {
#line 281
      thisblockrow = *(buffer + block_row);
#line 282
      (*((cinfo->fdct)->forward_DCT))(cinfo, compptr, *(input_buf + ci), thisblockrow,
                                      (JDIMENSION )(block_row * 8), (JDIMENSION )0,
                                      blocks_across);
      }
#line 286
      if (ndummy > 0) {
        {
#line 288
        thisblockrow += blocks_across;
#line 289
        jzero_far((void *)thisblockrow, (size_t )ndummy * sizeof(JBLOCK ));
#line 290
        lastDC = (*(thisblockrow + -1))[0];
#line 291
        bi = 0;
        }
        {
#line 291
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 291
          if (! (bi < ndummy)) {
#line 291
            goto while_break___1;
          }
#line 292
          (*(thisblockrow + bi))[0] = lastDC;
#line 291
          bi ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 280
      block_row ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 301
    if (coef->iMCU_row_num == last_iMCU_row) {
#line 302
      blocks_across += (JDIMENSION )ndummy;
#line 303
      MCUs_across = blocks_across / (JDIMENSION )h_samp_factor;
#line 304
      block_row = block_rows;
      {
#line 304
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 304
        if (! (block_row < compptr->v_samp_factor)) {
#line 304
          goto while_break___2;
        }
        {
#line 306
        thisblockrow = *(buffer + block_row);
#line 307
        lastblockrow = *(buffer + (block_row - 1));
#line 308
        jzero_far((void *)thisblockrow, (size_t )blocks_across * sizeof(JBLOCK ));
#line 310
        MCUindex = (JDIMENSION )0;
        }
        {
#line 310
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 310
          if (! (MCUindex < MCUs_across)) {
#line 310
            goto while_break___3;
          }
#line 311
          lastDC = (*(lastblockrow + (h_samp_factor - 1)))[0];
#line 312
          bi = 0;
          {
#line 312
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 312
            if (! (bi < h_samp_factor)) {
#line 312
              goto while_break___4;
            }
#line 313
            (*(thisblockrow + bi))[0] = lastDC;
#line 312
            bi ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 315
          thisblockrow += h_samp_factor;
#line 316
          lastblockrow += h_samp_factor;
#line 310
          MCUindex ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 304
        block_row ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 256
    ci ++;
#line 256
    compptr ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 326
  tmp = compress_output(cinfo, input_buf);
  }
#line 326
  return (tmp);
}
}
#line 340 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jccoefct.c"
static boolean compress_output(j_compress_ptr cinfo , JSAMPIMAGE input_buf ) 
{ 
  my_coef_ptr coef ;
  JDIMENSION MCU_col_num ;
  int blkn ;
  int ci ;
  int xindex ;
  int yindex ;
  int yoffset ;
  JDIMENSION start_col ;
  JBLOCKARRAY buffer[4] ;
  JBLOCKROW buffer_ptr ;
  jpeg_component_info *compptr ;
  int tmp ;
  JBLOCKROW tmp___0 ;
  boolean tmp___1 ;

  {
#line 343
  coef = (my_coef_ptr )cinfo->coef;
#line 355
  ci = 0;
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 355
    if (! (ci < cinfo->comps_in_scan)) {
#line 355
      goto while_break;
    }
    {
#line 356
    compptr = cinfo->cur_comp_info[ci];
#line 357
    buffer[ci] = (*((cinfo->mem)->access_virt_barray))((j_common_ptr )cinfo, coef->whole_image[compptr->component_index],
                                                       coef->iMCU_row_num * (JDIMENSION )compptr->v_samp_factor,
                                                       (JDIMENSION )compptr->v_samp_factor,
                                                       0);
#line 355
    ci ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 364
  yoffset = coef->MCU_vert_offset;
  {
#line 364
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 364
    if (! (yoffset < coef->MCU_rows_per_iMCU_row)) {
#line 364
      goto while_break___0;
    }
#line 366
    MCU_col_num = coef->mcu_ctr;
    {
#line 366
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 366
      if (! (MCU_col_num < cinfo->MCUs_per_row)) {
#line 366
        goto while_break___1;
      }
#line 369
      blkn = 0;
#line 370
      ci = 0;
      {
#line 370
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 370
        if (! (ci < cinfo->comps_in_scan)) {
#line 370
          goto while_break___2;
        }
#line 371
        compptr = cinfo->cur_comp_info[ci];
#line 372
        start_col = MCU_col_num * (JDIMENSION )compptr->MCU_width;
#line 373
        yindex = 0;
        {
#line 373
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 373
          if (! (yindex < compptr->MCU_height)) {
#line 373
            goto while_break___3;
          }
#line 374
          buffer_ptr = *(buffer[ci] + (yindex + yoffset)) + start_col;
#line 375
          xindex = 0;
          {
#line 375
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 375
            if (! (xindex < compptr->MCU_width)) {
#line 375
              goto while_break___4;
            }
#line 376
            tmp = blkn;
#line 376
            blkn ++;
#line 376
            tmp___0 = buffer_ptr;
#line 376
            buffer_ptr ++;
#line 376
            coef->MCU_buffer[tmp] = tmp___0;
#line 375
            xindex ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 373
          yindex ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 370
        ci ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 381
      tmp___1 = (*((cinfo->entropy)->encode_mcu))(cinfo, coef->MCU_buffer);
      }
#line 381
      if (! tmp___1) {
#line 383
        coef->MCU_vert_offset = yoffset;
#line 384
        coef->mcu_ctr = MCU_col_num;
#line 385
        return (0);
      }
#line 366
      MCU_col_num ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 389
    coef->mcu_ctr = (JDIMENSION )0;
#line 364
    yoffset ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 392
  (coef->iMCU_row_num) ++;
#line 393
  start_iMCU_row(cinfo);
  }
#line 394
  return (1);
}
}
#line 404 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jccoefct.c"
void jinit_c_coef_controller(j_compress_ptr cinfo , boolean need_full_buffer ) 
{ 
  my_coef_ptr coef ;
  void *tmp ;
  int ci ;
  jpeg_component_info *compptr ;
  long tmp___0 ;
  long tmp___1 ;
  JBLOCKROW buffer ;
  int i ;
  void *tmp___2 ;

  {
  {
#line 409
  tmp = (*((cinfo->mem)->alloc_small))((j_common_ptr )cinfo, 1, sizeof(my_coef_controller ));
#line 409
  coef = (my_coef_ptr )tmp;
#line 412
  cinfo->coef = (struct jpeg_c_coef_controller *)coef;
#line 413
  coef->pub.start_pass = & start_pass_coef;
  }
#line 416
  if (need_full_buffer) {
#line 423
    ci = 0;
#line 423
    compptr = cinfo->comp_info;
    {
#line 423
    while (1) {
      while_continue: /* CIL Label */ ;
#line 423
      if (! (ci < cinfo->num_components)) {
#line 423
        goto while_break;
      }
      {
#line 425
      tmp___0 = jround_up((long )compptr->height_in_blocks, (long )compptr->v_samp_factor);
#line 425
      tmp___1 = jround_up((long )compptr->width_in_blocks, (long )compptr->h_samp_factor);
#line 425
      coef->whole_image[ci] = (*((cinfo->mem)->request_virt_barray))((j_common_ptr )cinfo,
                                                                     1, 0, (JDIMENSION )tmp___1,
                                                                     (JDIMENSION )tmp___0,
                                                                     (JDIMENSION )compptr->v_samp_factor);
#line 423
      ci ++;
#line 423
      compptr ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 441
    tmp___2 = (*((cinfo->mem)->alloc_large))((j_common_ptr )cinfo, 1, 10UL * sizeof(JBLOCK ));
#line 441
    buffer = (JBLOCKROW )tmp___2;
#line 444
    i = 0;
    }
    {
#line 444
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 444
      if (! (i < 10)) {
#line 444
        goto while_break___0;
      }
#line 445
      coef->MCU_buffer[i] = buffer + i;
#line 444
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 447
    coef->whole_image[0] = (jvirt_barray_ptr )((void *)0);
  }
#line 449
  return;
}
}
#line 334 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpegint.h"
void jinit_compress_master(j_compress_ptr cinfo ) ;
#line 335
void jinit_c_master_control(j_compress_ptr cinfo , boolean transcode_only ) ;
#line 337
void jinit_c_main_controller(j_compress_ptr cinfo , boolean need_full_buffer ) ;
#line 339
extern void jinit_c_prep_controller(j_compress_ptr cinfo , boolean need_full_buffer ) ;
#line 344
extern void jinit_downsampler(j_compress_ptr cinfo ) ;
#line 347
extern void jinit_phuff_encoder(j_compress_ptr cinfo ) ;
#line 29 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcinit.c"
void jinit_compress_master(j_compress_ptr cinfo ) 
{ 
  int tmp ;

  {
  {
#line 33
  jinit_c_master_control(cinfo, 0);
  }
#line 36
  if (! cinfo->raw_data_in) {
    {
#line 37
    jinit_color_converter(cinfo);
#line 38
    jinit_downsampler(cinfo);
#line 39
    jinit_c_prep_controller(cinfo, 0);
    }
  }
  {
#line 42
  jinit_forward_dct(cinfo);
  }
#line 44
  if (cinfo->arith_code) {
    {
#line 45
    (cinfo->err)->msg_code = 1;
#line 45
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  } else
#line 47
  if (cinfo->progressive_mode) {
    {
#line 49
    jinit_phuff_encoder(cinfo);
    }
  } else {
    {
#line 54
    jinit_huff_encoder(cinfo);
    }
  }
#line 58
  if (cinfo->num_scans > 1) {
#line 58
    tmp = 1;
  } else
#line 58
  if (cinfo->optimize_coding) {
#line 58
    tmp = 1;
  } else {
#line 58
    tmp = 0;
  }
  {
#line 58
  jinit_c_coef_controller(cinfo, tmp);
#line 60
  jinit_c_main_controller(cinfo, 0);
#line 62
  jinit_marker_writer(cinfo);
#line 65
  (*((cinfo->mem)->realize_virt_arrays))((j_common_ptr )cinfo);
#line 71
  (*((cinfo->marker)->write_file_header))(cinfo);
  }
#line 72
  return;
}
}
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 884 "./jpeg-6b-steg/jpeglib.h"
extern struct jpeg_error_mgr *jpeg_std_error(struct jpeg_error_mgr *err ) ;
#line 902
extern void jpeg_CreateDecompress(j_decompress_ptr cinfo , int version , size_t structsize ) ;
#line 906
extern void jpeg_destroy_decompress(j_decompress_ptr cinfo ) ;
#line 910
extern void jpeg_stdio_dest(j_compress_ptr cinfo , FILE *outfile ) ;
#line 911
extern void jpeg_stdio_src(j_decompress_ptr cinfo , FILE *infile ) ;
#line 914
extern void jpeg_set_defaults(j_compress_ptr cinfo ) ;
#line 919
extern void jpeg_set_quality(j_compress_ptr cinfo , int quality , boolean force_baseline ) ;
#line 936
void jpeg_start_compress(j_compress_ptr cinfo , boolean write_all_tables ) ;
#line 938
JDIMENSION jpeg_write_scanlines(j_compress_ptr cinfo , JSAMPARRAY scanlines , JDIMENSION num_lines ) ;
#line 962
extern int jpeg_read_header(j_decompress_ptr cinfo , boolean require_image ) ;
#line 975
extern boolean jpeg_start_decompress(j_decompress_ptr cinfo ) ;
#line 976
extern JDIMENSION jpeg_read_scanlines(j_decompress_ptr cinfo , JSAMPARRAY scanlines ,
                                      JDIMENSION max_lines ) ;
#line 979
extern boolean jpeg_finish_decompress(j_decompress_ptr cinfo ) ;
#line 38 "/home/wheatley/newnew/temp/outguess-0.2/jpg.h"
void init_JPEG_handler(char *parameter ) ;
#line 40
int preserve_jpg(bitmap *bitmap___0 , int off___0 ) ;
#line 42
void write_JPEG_file(FILE *outfile , image *image___0 ) ;
#line 43
image *read_JPEG_file(FILE *infile ) ;
#line 45
void bitmap_from_jpg(bitmap *dbitmap , image *image___0 , int flags ) ;
#line 46
void bitmap_to_jpg(image *image___0 , bitmap *bitmap___0 , int flags ) ;
#line 48
bitmap *compress_JPEG(image *image___0 ) ;
#line 47 "/home/wheatley/newnew/temp/outguess-0.2/jpg.c"
void jpeg_dummy_dest(j_compress_ptr cinfo ) ;
#line 51 "/home/wheatley/newnew/temp/outguess-0.2/jpg.c"
handler jpg_handler  =    {(char *)"jpg", & init_JPEG_handler, & read_JPEG_file, & write_JPEG_file, & bitmap_from_jpg,
    & bitmap_to_jpg, & preserve_jpg};
#line 61 "/home/wheatley/newnew/temp/outguess-0.2/jpg.c"
static int jpeg_state  ;
#line 62 "/home/wheatley/newnew/temp/outguess-0.2/jpg.c"
static bitmap tbitmap  ;
#line 63 "/home/wheatley/newnew/temp/outguess-0.2/jpg.c"
static u_int32_t off  ;
#line 64 "/home/wheatley/newnew/temp/outguess-0.2/jpg.c"
static int quality  =    75;
#line 65 "/home/wheatley/newnew/temp/outguess-0.2/jpg.c"
static int jpeg_eval  ;
#line 66 "/home/wheatley/newnew/temp/outguess-0.2/jpg.c"
static int eval_cnt  ;
#line 68 "/home/wheatley/newnew/temp/outguess-0.2/jpg.c"
static int dctmin  ;
#line 69 "/home/wheatley/newnew/temp/outguess-0.2/jpg.c"
static int dctmax  ;
#line 76 "/home/wheatley/newnew/temp/outguess-0.2/jpg.c"
static int dctadjust[256]  ;
#line 81 "/home/wheatley/newnew/temp/outguess-0.2/jpg.c"
static int dctfreq[256]  ;
#line 82 "/home/wheatley/newnew/temp/outguess-0.2/jpg.c"
static int dctpending  ;
#line 84 "/home/wheatley/newnew/temp/outguess-0.2/jpg.c"
void init_state(int state , int eval , bitmap *bitmap___0 ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 87
  jpeg_state = state;
#line 88
  jpeg_eval = eval;
#line 89
  eval_cnt = 0;
#line 91
  dctmin = 127;
#line 92
  dctmax = -127;
#line 94
  off = (u_int32_t )0;
#line 95
  if (state == 0) {
    {
#line 96
    memset((void *)(& tbitmap), 0, sizeof(tbitmap));
#line 97
    tbitmap.bytes = 256;
#line 98
    tbitmap.bits = tbitmap.bytes * 8;
#line 99
    tmp = checkedmalloc((size_t )tbitmap.bytes);
#line 99
    tbitmap.bitmap = (u_char *)tmp;
#line 100
    tmp___0 = checkedmalloc((size_t )tbitmap.bytes);
#line 100
    tbitmap.locked = (u_char *)tmp___0;
#line 101
    memset((void *)tbitmap.locked, 0, (size_t )tbitmap.bytes);
#line 102
    tmp___1 = checkedmalloc((size_t )tbitmap.bits);
#line 102
    tbitmap.data = (char *)tmp___1;
    }
  } else
#line 103
  if (bitmap___0) {
    {
#line 104
    memcpy((void */* __restrict  */)(& tbitmap), (void const   */* __restrict  */)bitmap___0,
           sizeof(tbitmap));
    }
  }
#line 106
  return;
}
}
#line 108 "/home/wheatley/newnew/temp/outguess-0.2/jpg.c"
int preserve_single(bitmap *bitmap___0 , int off___0 , char coeff ) 
{ 
  int i ;
  char *data___0 ;
  char *pbits ;
  char *plock ;
  char *pmetalock ;
  char cbit ;

  {
#line 112
  data___0 = bitmap___0->data;
#line 113
  pbits = (char *)bitmap___0->bitmap;
#line 114
  plock = (char *)bitmap___0->locked;
#line 115
  pmetalock = (char *)bitmap___0->metalock;
#line 117
  i = off___0 - 1;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (i >= 0)) {
#line 117
      goto while_break;
    }
#line 118
    if ((int )*(plock + i / 8) & (1 << (i & 7))) {
#line 119
      goto __Cont;
    }
#line 120
    if ((int )*(pmetalock + i / 8) & (1 << (i & 7))) {
#line 121
      goto __Cont;
    }
#line 124
    if ((int )*(data___0 + i) == (int )coeff) {
#line 127
      *(data___0 + i) = (char )((int )coeff ^ 1);
#line 129
      cbit = (char )((int )((unsigned char )coeff) & 1);
#line 130
      *(pbits + i / 8) = (char )(((int )*(pbits + i / 8) & ~ (1 << (i & 7))) | (((int )cbit ^ 1) << (i & 7)));
#line 132
      *(pmetalock + i / 8) = (char )(((int )*(pmetalock + i / 8) & ~ (1 << (i & 7))) | (1 << (i & 7)));
#line 134
      if (jpeg_eval) {
        {
#line 135
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"off: %d, i: %d, coeff: %d, data: %d\n",
                off___0, i, (int )coeff, (int )*(data___0 + i));
        }
      }
#line 139
      return (i);
    }
    __Cont: /* CIL Label */ 
#line 117
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  return (-1);
}
}
#line 147 "/home/wheatley/newnew/temp/outguess-0.2/jpg.c"
int preserve_jpg(bitmap *bitmap___0 , int off___0 ) 
{ 
  char coeff ;
  int i ;
  int a___0 ;
  int b ;
  char *data___0 ;
  int res ;
  int tmp ;

  {
#line 152
  data___0 = bitmap___0->data;
#line 154
  if (off___0 == -1) {
#line 157
    if (jpeg_eval) {
      {
#line 158
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DCT: %d<->%d\n",
              dctmin, dctmax);
      }
    }
    {
#line 160
    bitmap___0->preserve = & preserve_jpg;
#line 161
    memset((void *)bitmap___0->metalock, 0, (size_t )bitmap___0->bytes);
#line 163
    memset((void *)(dctadjust), 0, sizeof(dctadjust));
#line 164
    memset((void *)(dctfreq), 0, sizeof(dctfreq));
#line 165
    dctpending = 0;
#line 168
    i = 0;
    }
    {
#line 168
    while (1) {
      while_continue: /* CIL Label */ ;
#line 168
      if (! (i < bitmap___0->bits)) {
#line 168
        goto while_break;
      }
#line 169
      (dctfreq[(int )*(data___0 + i) + 127]) ++;
#line 168
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 172
    a___0 = dctfreq[126];
#line 173
    b = dctfreq[125];
#line 175
    if (a___0 < b) {
      {
#line 176
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can not calculate estimate\n");
#line 177
      res = -1;
      }
    } else {
#line 179
      res = ((2 * bitmap___0->bits) * b) / (a___0 + b);
    }
#line 182
    i = 0;
    {
#line 182
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 182
      if (! (i < 256)) {
#line 182
        goto while_break___0;
      }
#line 183
      dctfreq[i] = (int )((float )dctfreq[i] / ((float )bitmap___0->bits / (float )5000));
#line 185
      dctfreq[i] /= 33;
#line 186
      if (dctfreq[i] < 2) {
#line 187
        dctfreq[i] = 2;
      }
#line 189
      if (jpeg_eval) {
        {
#line 190
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Foil: %d :< %d\n",
                i - 127, dctfreq[i]);
        }
      }
#line 182
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 194
    bitmap___0->maxcorrect = (size_t )res;
#line 195
    return (res);
  } else
#line 196
  if (off___0 >= bitmap___0->bits) {
#line 198
    i = 0;
    {
#line 198
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 198
      if (! (i < 256)) {
#line 198
        goto while_break___1;
      }
      {
#line 199
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 199
        if (! dctadjust[i]) {
#line 199
          goto while_break___2;
        }
        {
#line 200
        (dctadjust[i]) --;
#line 202
        coeff = (char )(i - 127);
#line 204
        tmp = preserve_single(bitmap___0, bitmap___0->bits - 1, coeff);
        }
#line 204
        if (tmp != -1) {
#line 206
          steg_foil ++;
        } else {
#line 208
          steg_foilfail ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 198
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 212
    return (0);
  }
#line 216
  coeff = (char )((int )*(data___0 + off___0) ^ 1);
#line 218
  if (dctadjust[(int )*(data___0 + off___0) + 127]) {
#line 220
    (dctadjust[(int )*(data___0 + off___0) + 127]) --;
#line 221
    dctpending --;
#line 222
    return (0);
  }
#line 225
  if (dctadjust[(int )coeff + 127] < dctfreq[(int )coeff + 127]) {
#line 226
    (dctadjust[(int )coeff + 127]) ++;
#line 227
    dctpending ++;
#line 228
    return (0);
  }
  {
#line 231
  i = preserve_single(bitmap___0, off___0, coeff);
  }
#line 233
  if (i != -1) {
#line 234
    steg_foil ++;
#line 235
    return (i);
  }
#line 239
  (dctadjust[(int )coeff + 127]) ++;
#line 240
  dctpending ++;
#line 242
  return (-1);
}
}
#line 245 "/home/wheatley/newnew/temp/outguess-0.2/jpg.c"
bitmap *finish_state(void) 
{ 
  int i ;
  bitmap *pbitmap ;
  void *tmp ;
  void *tmp___0 ;
  char temp ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 251
  if (jpeg_eval) {
    {
#line 252
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
#line 254
  if (jpeg_state != 0) {
#line 255
    return ((bitmap *)((void *)0));
  }
  {
#line 257
  tbitmap.bits = (int )off;
#line 258
  tbitmap.bytes = (int )((off + 7U) / 8U);
#line 260
  tmp = checkedmalloc((size_t )tbitmap.bits);
#line 260
  tbitmap.detect = (char *)tmp;
#line 261
  tmp___0 = checkedmalloc((size_t )tbitmap.bytes);
#line 261
  tbitmap.metalock = (u_char *)tmp___0;
#line 263
  i = 0;
  }
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 263
    if (! ((u_int32_t )i < off)) {
#line 263
      goto while_break;
    }
    {
#line 264
    tmp___1 = abs((int )*(tbitmap.data + i));
#line 264
    temp = (char )tmp___1;
    }
#line 265
    if ((int )temp >= 37) {
#line 266
      *(tbitmap.detect + i) = (char)-1;
    } else
#line 267
    if ((int )temp >= 4) {
#line 268
      *(tbitmap.detect + i) = (char)0;
    } else
#line 269
    if ((int )temp >= 3) {
#line 270
      *(tbitmap.detect + i) = (char)1;
    } else {
#line 272
      *(tbitmap.detect + i) = (char)2;
    }
#line 263
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 275
  tmp___2 = checkedmalloc(sizeof(bitmap ));
#line 275
  pbitmap = (bitmap *)tmp___2;
#line 277
  memcpy((void */* __restrict  */)pbitmap, (void const   */* __restrict  */)(& tbitmap),
         sizeof(tbitmap));
  }
#line 279
  return (pbitmap);
}
}
#line 282 "/home/wheatley/newnew/temp/outguess-0.2/jpg.c"
short steg_use_bit(unsigned short temp ) 
{ 
  u_char *buf ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 285
  if (((int )temp & 1) == (int )temp) {
#line 286
    goto steg_end;
  }
  {
#line 289
  if (jpeg_state == 0) {
#line 289
    goto case_0;
  }
#line 323
  goto switch_default;
  case_0: /* CIL Label */ 
#line 290
  *(tbitmap.bitmap + off / 8U) = (u_char )(((int )*(tbitmap.bitmap + off / 8U) & ~ (1 << (off & 7U))) | (((int )temp & 1) << (off & 7U)));
#line 291
  *(tbitmap.data + off) = (char )temp;
#line 293
  if ((int )((short )temp) < dctmin) {
#line 294
    dctmin = (int )((short )temp);
  }
#line 295
  if ((int )((short )temp) > dctmax) {
#line 296
    dctmax = (int )((short )temp);
  }
#line 298
  off ++;
#line 300
  if (off >= (u_int32_t )tbitmap.bits) {
    {
#line 303
    tbitmap.bytes += 256;
#line 304
    tbitmap.bits += 2048;
#line 305
    tmp = realloc((void *)tbitmap.bitmap, (size_t )tbitmap.bytes);
#line 305
    buf = (u_char *)tmp;
    }
#line 305
    if (! buf) {
      {
#line 306
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"steg_use_bit: realloc()\n");
#line 307
      exit(1);
      }
    }
    {
#line 309
    tbitmap.bitmap = buf;
#line 310
    tmp___0 = realloc((void *)tbitmap.locked, (size_t )tbitmap.bytes);
#line 310
    buf = (u_char *)tmp___0;
    }
#line 310
    if (! buf) {
      {
#line 311
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"steg_use_bit: realloc()\n");
#line 312
      exit(1);
      }
    }
    {
#line 314
    tbitmap.locked = buf;
#line 315
    memset((void *)((tbitmap.locked + tbitmap.bytes) - 256), 0, (size_t )256);
#line 316
    tmp___1 = realloc((void *)tbitmap.data, (size_t )tbitmap.bits);
#line 316
    buf = (u_char *)tmp___1;
    }
#line 316
    if (! buf) {
      {
#line 317
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"steg_use_bit: realloc()\n");
#line 318
      exit(1);
      }
    }
#line 320
    tbitmap.data = (char *)buf;
  }
#line 322
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 324
  if ((int )*(tbitmap.bitmap + off / 8U) & (1 << (off & 7U))) {
#line 324
    tmp___2 = 1;
  } else {
#line 324
    tmp___2 = 0;
  }
#line 324
  temp = (unsigned short )(((int )temp & -2) | tmp___2);
#line 325
  off ++;
#line 327
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  steg_end: 
#line 331
  if (jpeg_eval) {
#line 332
    if (eval_cnt % 64 == 0) {
      {
#line 333
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n[%d]%.7d: ",
              jpeg_state, eval_cnt);
      }
    }
#line 334
    if (((int )temp & 1) != (int )temp) {
      {
#line 335
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"% .3d,",
              (int )((short )temp));
      }
    }
#line 336
    eval_cnt ++;
  }
#line 339
  return ((short )temp);
}
}
#line 342 "/home/wheatley/newnew/temp/outguess-0.2/jpg.c"
void init_JPEG_handler(char *parameter ) 
{ 


  {
#line 345
  if (parameter) {
    {
#line 346
    quality = atoi((char const   *)parameter);
    }
  }
#line 347
  if (quality < 75) {
#line 348
    quality = 75;
  }
#line 349
  if (quality > 100) {
#line 350
    quality = 100;
  }
  {
#line 351
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"JPEG compression quality set to %d\n",
          quality);
  }
#line 352
  return;
}
}
#line 354 "/home/wheatley/newnew/temp/outguess-0.2/jpg.c"
void bitmap_from_jpg(bitmap *dbitmap , image *image___0 , int flags ) 
{ 
  bitmap *tmpmap ;

  {
#line 359
  if (flags & 16) {
    {
#line 360
    memcpy((void */* __restrict  */)dbitmap, (void const   */* __restrict  */)image___0->bitmap,
           sizeof(*dbitmap));
#line 361
    free((void *)image___0->bitmap);
#line 362
    image___0->bitmap = (bitmap *)((void *)0);
    }
#line 363
    return;
  }
#line 366
  if (image___0->bitmap) {
    {
#line 367
    tmpmap = image___0->bitmap;
#line 368
    free((void *)tmpmap->bitmap);
#line 369
    free((void *)tmpmap->locked);
#line 370
    free((void *)tmpmap);
#line 371
    image___0->bitmap = (bitmap *)((void *)0);
    }
  }
  {
#line 374
  tmpmap = compress_JPEG(image___0);
#line 375
  memcpy((void */* __restrict  */)dbitmap, (void const   */* __restrict  */)tmpmap,
         sizeof(*dbitmap));
#line 376
  free((void *)tmpmap);
  }
#line 377
  return;
}
}
#line 379 "/home/wheatley/newnew/temp/outguess-0.2/jpg.c"
void bitmap_to_jpg(image *image___0 , bitmap *bitmap___0 , int flags ) 
{ 
  int tmp ;

  {
#line 382
  if (steg_stat >= 3) {
#line 382
    tmp = 1;
  } else {
#line 382
    tmp = 0;
  }
  {
#line 382
  init_state(1, tmp, bitmap___0);
  }
#line 383
  return;
}
}
#line 414 "/home/wheatley/newnew/temp/outguess-0.2/jpg.c"
bitmap *compress_JPEG(image *image___0 ) 
{ 
  struct jpeg_compress_struct cinfo ;
  struct jpeg_error_mgr jerr ;
  JSAMPROW row_pointer[1] ;
  int row_stride ;
  int tmp ;
  bitmap *tmp___0 ;

  {
#line 423
  if (steg_stat >= 3) {
#line 423
    tmp = 1;
  } else {
#line 423
    tmp = 0;
  }
  {
#line 423
  init_state(0, tmp, (bitmap *)((void *)0));
#line 425
  cinfo.err = jpeg_std_error(& jerr);
#line 426
  jpeg_CreateCompress(& cinfo, 62, sizeof(struct jpeg_compress_struct ));
#line 428
  jpeg_dummy_dest(& cinfo);
#line 430
  cinfo.image_width = (JDIMENSION )image___0->x;
#line 431
  cinfo.image_height = (JDIMENSION )image___0->y;
#line 432
  cinfo.input_components = image___0->depth;
#line 433
  cinfo.in_color_space = (J_COLOR_SPACE )2;
#line 435
  jpeg_set_defaults(& cinfo);
#line 437
  jpeg_set_quality(& cinfo, quality, 1);
#line 439
  jpeg_start_compress(& cinfo, 1);
#line 441
  row_stride = image___0->x * 3;
  }
  {
#line 443
  while (1) {
    while_continue: /* CIL Label */ ;
#line 443
    if (! (cinfo.next_scanline < cinfo.image_height)) {
#line 443
      goto while_break;
    }
    {
#line 444
    row_pointer[0] = image___0->img + cinfo.next_scanline * (JDIMENSION )row_stride;
#line 445
    jpeg_write_scanlines(& cinfo, row_pointer, (JDIMENSION )1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 448
  jpeg_finish_compress(& cinfo);
#line 449
  jpeg_destroy_compress(& cinfo);
#line 451
  tmp___0 = finish_state();
  }
#line 451
  return (tmp___0);
}
}
#line 459 "/home/wheatley/newnew/temp/outguess-0.2/jpg.c"
void write_JPEG_file(FILE *outfile , image *image___0 ) 
{ 
  struct jpeg_compress_struct cinfo ;
  struct jpeg_error_mgr jerr ;
  JSAMPROW row_pointer[1] ;
  int row_stride ;

  {
  {
#line 489
  cinfo.err = jpeg_std_error(& jerr);
#line 491
  jpeg_CreateCompress(& cinfo, 62, sizeof(struct jpeg_compress_struct ));
#line 499
  jpeg_stdio_dest(& cinfo, outfile);
#line 506
  cinfo.image_width = (JDIMENSION )image___0->x;
#line 507
  cinfo.image_height = (JDIMENSION )image___0->y;
#line 508
  cinfo.input_components = image___0->depth;
#line 509
  cinfo.in_color_space = (J_COLOR_SPACE )2;
#line 514
  jpeg_set_defaults(& cinfo);
#line 518
  jpeg_set_quality(& cinfo, quality, 1);
#line 525
  jpeg_start_compress(& cinfo, 1);
#line 535
  row_stride = image___0->x * 3;
  }
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! (cinfo.next_scanline < cinfo.image_height)) {
#line 537
      goto while_break;
    }
    {
#line 542
    row_pointer[0] = image___0->img + cinfo.next_scanline * (JDIMENSION )row_stride;
#line 543
    jpeg_write_scanlines(& cinfo, row_pointer, (JDIMENSION )1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 548
  jpeg_finish_compress(& cinfo);
#line 550
  fclose(outfile);
#line 555
  jpeg_destroy_compress(& cinfo);
#line 558
  finish_state();
  }
#line 559
  return;
}
}
#line 615 "/home/wheatley/newnew/temp/outguess-0.2/jpg.c"
image *read_JPEG_file(FILE *infile ) 
{ 
  struct jpeg_decompress_struct cinfo ;
  struct jpeg_error_mgr jerr ;
  image *image___0 ;
  JSAMPARRAY buffer ;
  int row_stride ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 633
  init_state(0, 0, (bitmap *)((void *)0));
#line 635
  tmp = checkedmalloc(sizeof(*image___0));
#line 635
  image___0 = (image *)tmp;
#line 636
  memset((void *)image___0, 0, sizeof(*image___0));
#line 640
  cinfo.err = jpeg_std_error(& jerr);
#line 642
  jpeg_CreateDecompress(& cinfo, 62, sizeof(struct jpeg_decompress_struct ));
#line 646
  jpeg_stdio_src(& cinfo, infile);
#line 650
  jpeg_read_header(& cinfo, 1);
#line 665
  jpeg_start_decompress(& cinfo);
#line 677
  image___0->x = (int )cinfo.output_width;
#line 678
  image___0->y = (int )cinfo.output_height;
#line 679
  image___0->depth = cinfo.output_components;
#line 680
  image___0->max = 255;
#line 682
  tmp___0 = checkedmalloc((size_t )((cinfo.output_width * cinfo.output_height) * (JDIMENSION )cinfo.output_components));
#line 682
  image___0->img = (u_char *)tmp___0;
#line 686
  row_stride = (int )(cinfo.output_width * (JDIMENSION )cinfo.output_components);
#line 688
  buffer = (*((cinfo.mem)->alloc_sarray))((j_common_ptr )(& cinfo), 1, (JDIMENSION )row_stride,
                                          (JDIMENSION )1);
  }
  {
#line 697
  while (1) {
    while_continue: /* CIL Label */ ;
#line 697
    if (! (cinfo.output_scanline < cinfo.output_height)) {
#line 697
      goto while_break;
    }
    {
#line 702
    jpeg_read_scanlines(& cinfo, buffer, (JDIMENSION )1);
#line 705
    memcpy((void */* __restrict  */)(image___0->img + (cinfo.output_scanline - 1U) * (JDIMENSION )row_stride),
           (void const   */* __restrict  */)*(buffer + 0), (size_t )row_stride);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 711
  jpeg_finish_decompress(& cinfo);
#line 719
  jpeg_destroy_decompress(& cinfo);
#line 721
  image___0->bitmap = finish_state();
  }
#line 724
  return (image___0);
}
}
#line 761 "/home/wheatley/newnew/temp/outguess-0.2/jpg.c"
char dummy_buf[256]  ;
#line 765 "/home/wheatley/newnew/temp/outguess-0.2/jpg.c"
static void init_destination(j_compress_ptr cinfo ) 
{ 
  my_dest_ptr dest ;

  {
#line 768
  dest = (my_dest_ptr )cinfo->dest;
#line 770
  dest->pub.next_output_byte = (JOCTET *)(dummy_buf);
#line 771
  dest->pub.free_in_buffer = (size_t )256;
#line 772
  return;
}
}
#line 774 "/home/wheatley/newnew/temp/outguess-0.2/jpg.c"
static boolean empty_output_buffer(j_compress_ptr cinfo ) 
{ 
  my_dest_ptr dest ;

  {
#line 777
  dest = (my_dest_ptr )cinfo->dest;
#line 779
  dest->pub.next_output_byte = (JOCTET *)(dummy_buf);
#line 780
  dest->pub.free_in_buffer = (size_t )256;
#line 782
  return (1);
}
}
#line 785 "/home/wheatley/newnew/temp/outguess-0.2/jpg.c"
static void term_destination(j_compress_ptr cinfo ) 
{ 


  {
#line 788
  return;
}
}
#line 790 "/home/wheatley/newnew/temp/outguess-0.2/jpg.c"
void jpeg_dummy_dest(j_compress_ptr cinfo ) 
{ 
  my_dest_ptr dest ;
  void *tmp ;

  {
#line 801
  if ((unsigned long )cinfo->dest == (unsigned long )((void *)0)) {
    {
#line 802
    tmp = (*((cinfo->mem)->alloc_small))((j_common_ptr )cinfo, 0, sizeof(my_destination_mgr ));
#line 802
    cinfo->dest = (struct jpeg_destination_mgr *)tmp;
    }
  }
#line 807
  dest = (my_dest_ptr )cinfo->dest;
#line 808
  dest->pub.init_destination = & init_destination;
#line 809
  dest->pub.empty_output_buffer = & empty_output_buffer;
#line 810
  dest->pub.term_destination = & term_destination;
#line 811
  return;
}
}
#line 107 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmarker.c"
static void emit_byte(j_compress_ptr cinfo , int val ) 
{ 
  struct jpeg_destination_mgr *dest ;
  JOCTET *tmp ;
  boolean tmp___0 ;

  {
#line 111
  dest = cinfo->dest;
#line 113
  tmp = dest->next_output_byte;
#line 113
  (dest->next_output_byte) ++;
#line 113
  *tmp = (JOCTET )val;
#line 114
  (dest->free_in_buffer) --;
#line 114
  if (dest->free_in_buffer == 0UL) {
    {
#line 115
    tmp___0 = (*(dest->empty_output_buffer))(cinfo);
    }
#line 115
    if (! tmp___0) {
      {
#line 116
      (cinfo->err)->msg_code = 24;
#line 116
      (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
      }
    }
  }
#line 118
  return;
}
}
#line 121 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmarker.c"
static void emit_marker(j_compress_ptr cinfo , JPEG_MARKER mark ) 
{ 


  {
  {
#line 125
  emit_byte(cinfo, 255);
#line 126
  emit_byte(cinfo, (int )mark);
  }
#line 127
  return;
}
}
#line 130 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmarker.c"
static void emit_2bytes(j_compress_ptr cinfo , int value ) 
{ 


  {
  {
#line 134
  emit_byte(cinfo, (value >> 8) & 255);
#line 135
  emit_byte(cinfo, value & 255);
  }
#line 136
  return;
}
}
#line 143 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmarker.c"
static int emit_dqt(j_compress_ptr cinfo , int index___0 ) 
{ 
  JQUANT_TBL *qtbl ;
  int prec ;
  int i ;
  int tmp ;
  unsigned int qval ;

  {
#line 148
  qtbl = cinfo->quant_tbl_ptrs[index___0];
#line 152
  if ((unsigned long )qtbl == (unsigned long )((void *)0)) {
    {
#line 153
    (cinfo->err)->msg_code = 52;
#line 153
    (cinfo->err)->msg_parm.i[0] = index___0;
#line 153
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
#line 155
  prec = 0;
#line 156
  i = 0;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! (i < 64)) {
#line 156
      goto while_break;
    }
#line 157
    if ((int )qtbl->quantval[i] > 255) {
#line 158
      prec = 1;
    }
#line 156
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  if (! qtbl->sent_table) {
    {
#line 162
    emit_marker(cinfo, (JPEG_MARKER )219);
    }
#line 164
    if (prec) {
#line 164
      tmp = 131;
    } else {
#line 164
      tmp = 67;
    }
    {
#line 164
    emit_2bytes(cinfo, tmp);
#line 166
    emit_byte(cinfo, index___0 + (prec << 4));
#line 168
    i = 0;
    }
    {
#line 168
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 168
      if (! (i < 64)) {
#line 168
        goto while_break___0;
      }
#line 170
      qval = (unsigned int )qtbl->quantval[jpeg_natural_order[i]];
#line 171
      if (prec) {
        {
#line 172
        emit_byte(cinfo, (int )(qval >> 8));
        }
      }
      {
#line 173
      emit_byte(cinfo, (int )(qval & 255U));
#line 168
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 176
    qtbl->sent_table = 1;
  }
#line 179
  return (prec);
}
}
#line 183 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmarker.c"
static void emit_dht(j_compress_ptr cinfo , int index___0 , boolean is_ac ) 
{ 
  JHUFF_TBL *htbl ;
  int length ;
  int i ;

  {
#line 190
  if (is_ac) {
#line 191
    htbl = cinfo->ac_huff_tbl_ptrs[index___0];
#line 192
    index___0 += 16;
  } else {
#line 194
    htbl = cinfo->dc_huff_tbl_ptrs[index___0];
  }
#line 197
  if ((unsigned long )htbl == (unsigned long )((void *)0)) {
    {
#line 198
    (cinfo->err)->msg_code = 50;
#line 198
    (cinfo->err)->msg_parm.i[0] = index___0;
#line 198
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
#line 200
  if (! htbl->sent_table) {
    {
#line 201
    emit_marker(cinfo, (JPEG_MARKER )196);
#line 203
    length = 0;
#line 204
    i = 1;
    }
    {
#line 204
    while (1) {
      while_continue: /* CIL Label */ ;
#line 204
      if (! (i <= 16)) {
#line 204
        goto while_break;
      }
#line 205
      length += (int )htbl->bits[i];
#line 204
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 207
    emit_2bytes(cinfo, ((length + 2) + 1) + 16);
#line 208
    emit_byte(cinfo, index___0);
#line 210
    i = 1;
    }
    {
#line 210
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 210
      if (! (i <= 16)) {
#line 210
        goto while_break___0;
      }
      {
#line 211
      emit_byte(cinfo, (int )htbl->bits[i]);
#line 210
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 213
    i = 0;
    {
#line 213
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 213
      if (! (i < length)) {
#line 213
        goto while_break___1;
      }
      {
#line 214
      emit_byte(cinfo, (int )htbl->huffval[i]);
#line 213
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 216
    htbl->sent_table = 1;
  }
#line 218
  return;
}
}
#line 221 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmarker.c"
static void emit_dac(j_compress_ptr cinfo ) 
{ 


  {
#line 261
  return;
}
}
#line 264 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmarker.c"
static void emit_dri(j_compress_ptr cinfo ) 
{ 


  {
  {
#line 268
  emit_marker(cinfo, (JPEG_MARKER )221);
#line 270
  emit_2bytes(cinfo, 4);
#line 272
  emit_2bytes(cinfo, (int )cinfo->restart_interval);
  }
#line 273
  return;
}
}
#line 276 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmarker.c"
static void emit_sof(j_compress_ptr cinfo , JPEG_MARKER code ) 
{ 
  int ci ;
  jpeg_component_info *compptr ;

  {
  {
#line 283
  emit_marker(cinfo, code);
#line 285
  emit_2bytes(cinfo, ((3 * cinfo->num_components + 2) + 5) + 1);
  }
#line 288
  if ((long )cinfo->image_height > 65535L) {
    {
#line 290
    (cinfo->err)->msg_code = 41;
#line 290
    (cinfo->err)->msg_parm.i[0] = 65535;
#line 290
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  } else
#line 288
  if ((long )cinfo->image_width > 65535L) {
    {
#line 290
    (cinfo->err)->msg_code = 41;
#line 290
    (cinfo->err)->msg_parm.i[0] = 65535;
#line 290
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
  {
#line 292
  emit_byte(cinfo, cinfo->data_precision);
#line 293
  emit_2bytes(cinfo, (int )cinfo->image_height);
#line 294
  emit_2bytes(cinfo, (int )cinfo->image_width);
#line 296
  emit_byte(cinfo, cinfo->num_components);
#line 298
  ci = 0;
#line 298
  compptr = cinfo->comp_info;
  }
  {
#line 298
  while (1) {
    while_continue: /* CIL Label */ ;
#line 298
    if (! (ci < cinfo->num_components)) {
#line 298
      goto while_break;
    }
    {
#line 300
    emit_byte(cinfo, compptr->component_id);
#line 301
    emit_byte(cinfo, (compptr->h_samp_factor << 4) + compptr->v_samp_factor);
#line 302
    emit_byte(cinfo, compptr->quant_tbl_no);
#line 298
    ci ++;
#line 298
    compptr ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 304
  return;
}
}
#line 307 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmarker.c"
static void emit_sos(j_compress_ptr cinfo ) 
{ 
  int i ;
  int td ;
  int ta ;
  jpeg_component_info *compptr ;

  {
  {
#line 314
  emit_marker(cinfo, (JPEG_MARKER )218);
#line 316
  emit_2bytes(cinfo, ((2 * cinfo->comps_in_scan + 2) + 1) + 3);
#line 318
  emit_byte(cinfo, cinfo->comps_in_scan);
#line 320
  i = 0;
  }
  {
#line 320
  while (1) {
    while_continue: /* CIL Label */ ;
#line 320
    if (! (i < cinfo->comps_in_scan)) {
#line 320
      goto while_break;
    }
    {
#line 321
    compptr = cinfo->cur_comp_info[i];
#line 322
    emit_byte(cinfo, compptr->component_id);
#line 323
    td = compptr->dc_tbl_no;
#line 324
    ta = compptr->ac_tbl_no;
    }
#line 325
    if (cinfo->progressive_mode) {
#line 331
      if (cinfo->Ss == 0) {
#line 332
        ta = 0;
#line 333
        if (cinfo->Ah != 0) {
#line 333
          if (! cinfo->arith_code) {
#line 334
            td = 0;
          }
        }
      } else {
#line 336
        td = 0;
      }
    }
    {
#line 339
    emit_byte(cinfo, (td << 4) + ta);
#line 320
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 342
  emit_byte(cinfo, cinfo->Ss);
#line 343
  emit_byte(cinfo, cinfo->Se);
#line 344
  emit_byte(cinfo, (cinfo->Ah << 4) + cinfo->Al);
  }
#line 345
  return;
}
}
#line 348 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmarker.c"
static void emit_jfif_app0(j_compress_ptr cinfo ) 
{ 


  {
  {
#line 364
  emit_marker(cinfo, (JPEG_MARKER )224);
#line 366
  emit_2bytes(cinfo, 16);
#line 368
  emit_byte(cinfo, 74);
#line 369
  emit_byte(cinfo, 70);
#line 370
  emit_byte(cinfo, 73);
#line 371
  emit_byte(cinfo, 70);
#line 372
  emit_byte(cinfo, 0);
#line 373
  emit_byte(cinfo, (int )cinfo->JFIF_major_version);
#line 374
  emit_byte(cinfo, (int )cinfo->JFIF_minor_version);
#line 375
  emit_byte(cinfo, (int )cinfo->density_unit);
#line 376
  emit_2bytes(cinfo, (int )cinfo->X_density);
#line 377
  emit_2bytes(cinfo, (int )cinfo->Y_density);
#line 378
  emit_byte(cinfo, 0);
#line 379
  emit_byte(cinfo, 0);
  }
#line 380
  return;
}
}
#line 383 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmarker.c"
static void emit_adobe_app14(j_compress_ptr cinfo ) 
{ 


  {
  {
#line 403
  emit_marker(cinfo, (JPEG_MARKER )238);
#line 405
  emit_2bytes(cinfo, 14);
#line 407
  emit_byte(cinfo, 65);
#line 408
  emit_byte(cinfo, 100);
#line 409
  emit_byte(cinfo, 111);
#line 410
  emit_byte(cinfo, 98);
#line 411
  emit_byte(cinfo, 101);
#line 412
  emit_2bytes(cinfo, 100);
#line 413
  emit_2bytes(cinfo, 0);
#line 414
  emit_2bytes(cinfo, 0);
  }
  {
#line 416
  if ((unsigned int )cinfo->jpeg_color_space == 3U) {
#line 416
    goto case_3;
  }
#line 419
  if ((unsigned int )cinfo->jpeg_color_space == 5U) {
#line 419
    goto case_5;
  }
#line 422
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 417
  emit_byte(cinfo, 1);
  }
#line 418
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 420
  emit_byte(cinfo, 2);
  }
#line 421
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 423
  emit_byte(cinfo, 0);
  }
#line 424
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 426
  return;
}
}
#line 437 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmarker.c"
static void write_marker_header(j_compress_ptr cinfo , int marker , unsigned int datalen ) 
{ 


  {
#line 441
  if (datalen > 65533U) {
    {
#line 442
    (cinfo->err)->msg_code = 11;
#line 442
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
  {
#line 444
  emit_marker(cinfo, (JPEG_MARKER )marker);
#line 446
  emit_2bytes(cinfo, (int )(datalen + 2U));
  }
#line 447
  return;
}
}
#line 449 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmarker.c"
static void write_marker_byte(j_compress_ptr cinfo , int val ) 
{ 


  {
  {
#line 453
  emit_byte(cinfo, val);
  }
#line 454
  return;
}
}
#line 468 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmarker.c"
static void write_file_header(j_compress_ptr cinfo ) 
{ 
  my_marker_ptr marker ;

  {
  {
#line 471
  marker = (my_marker_ptr )cinfo->marker;
#line 473
  emit_marker(cinfo, (JPEG_MARKER )216);
#line 476
  marker->last_restart_interval = 0U;
  }
#line 478
  if (cinfo->write_JFIF_header) {
    {
#line 479
    emit_jfif_app0(cinfo);
    }
  }
#line 480
  if (cinfo->write_Adobe_marker) {
    {
#line 481
    emit_adobe_app14(cinfo);
    }
  }
#line 482
  return;
}
}
#line 493 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmarker.c"
static void write_frame_header(j_compress_ptr cinfo ) 
{ 
  int ci ;
  int prec ;
  boolean is_baseline ;
  jpeg_component_info *compptr ;
  int tmp ;

  {
#line 503
  prec = 0;
#line 504
  ci = 0;
#line 504
  compptr = cinfo->comp_info;
  {
#line 504
  while (1) {
    while_continue: /* CIL Label */ ;
#line 504
    if (! (ci < cinfo->num_components)) {
#line 504
      goto while_break;
    }
    {
#line 506
    tmp = emit_dqt(cinfo, compptr->quant_tbl_no);
#line 506
    prec += tmp;
#line 504
    ci ++;
#line 504
    compptr ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 513
  if (cinfo->arith_code) {
#line 515
    is_baseline = 0;
  } else
#line 513
  if (cinfo->progressive_mode) {
#line 515
    is_baseline = 0;
  } else
#line 513
  if (cinfo->data_precision != 8) {
#line 515
    is_baseline = 0;
  } else {
#line 517
    is_baseline = 1;
#line 518
    ci = 0;
#line 518
    compptr = cinfo->comp_info;
    {
#line 518
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 518
      if (! (ci < cinfo->num_components)) {
#line 518
        goto while_break___0;
      }
#line 520
      if (compptr->dc_tbl_no > 1) {
#line 521
        is_baseline = 0;
      } else
#line 520
      if (compptr->ac_tbl_no > 1) {
#line 521
        is_baseline = 0;
      }
#line 518
      ci ++;
#line 518
      compptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 523
    if (prec) {
#line 523
      if (is_baseline) {
        {
#line 524
        is_baseline = 0;
#line 526
        (cinfo->err)->msg_code = 75;
#line 526
        (*((cinfo->err)->emit_message))((j_common_ptr )cinfo, 0);
        }
      }
    }
  }
#line 531
  if (cinfo->arith_code) {
    {
#line 532
    emit_sof(cinfo, (JPEG_MARKER )201);
    }
  } else
#line 534
  if (cinfo->progressive_mode) {
    {
#line 535
    emit_sof(cinfo, (JPEG_MARKER )194);
    }
  } else
#line 536
  if (is_baseline) {
    {
#line 537
    emit_sof(cinfo, (JPEG_MARKER )192);
    }
  } else {
    {
#line 539
    emit_sof(cinfo, (JPEG_MARKER )193);
    }
  }
#line 541
  return;
}
}
#line 550 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmarker.c"
static void write_scan_header(j_compress_ptr cinfo ) 
{ 
  my_marker_ptr marker ;
  int i ;
  jpeg_component_info *compptr ;

  {
#line 553
  marker = (my_marker_ptr )cinfo->marker;
#line 557
  if (cinfo->arith_code) {
    {
#line 562
    emit_dac(cinfo);
    }
  } else {
#line 567
    i = 0;
    {
#line 567
    while (1) {
      while_continue: /* CIL Label */ ;
#line 567
      if (! (i < cinfo->comps_in_scan)) {
#line 567
        goto while_break;
      }
#line 568
      compptr = cinfo->cur_comp_info[i];
#line 569
      if (cinfo->progressive_mode) {
#line 571
        if (cinfo->Ss == 0) {
#line 572
          if (cinfo->Ah == 0) {
            {
#line 573
            emit_dht(cinfo, compptr->dc_tbl_no, 0);
            }
          }
        } else {
          {
#line 575
          emit_dht(cinfo, compptr->ac_tbl_no, 1);
          }
        }
      } else {
        {
#line 579
        emit_dht(cinfo, compptr->dc_tbl_no, 0);
#line 580
        emit_dht(cinfo, compptr->ac_tbl_no, 1);
        }
      }
#line 567
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 588
  if (cinfo->restart_interval != marker->last_restart_interval) {
    {
#line 589
    emit_dri(cinfo);
#line 590
    marker->last_restart_interval = cinfo->restart_interval;
    }
  }
  {
#line 593
  emit_sos(cinfo);
  }
#line 594
  return;
}
}
#line 601 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmarker.c"
static void write_file_trailer(j_compress_ptr cinfo ) 
{ 


  {
  {
#line 604
  emit_marker(cinfo, (JPEG_MARKER )217);
  }
#line 605
  return;
}
}
#line 615 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmarker.c"
static void write_tables_only(j_compress_ptr cinfo ) 
{ 
  int i ;

  {
  {
#line 620
  emit_marker(cinfo, (JPEG_MARKER )216);
#line 622
  i = 0;
  }
  {
#line 622
  while (1) {
    while_continue: /* CIL Label */ ;
#line 622
    if (! (i < 4)) {
#line 622
      goto while_break;
    }
#line 623
    if ((unsigned long )cinfo->quant_tbl_ptrs[i] != (unsigned long )((void *)0)) {
      {
#line 624
      emit_dqt(cinfo, i);
      }
    }
#line 622
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 627
  if (! cinfo->arith_code) {
#line 628
    i = 0;
    {
#line 628
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 628
      if (! (i < 4)) {
#line 628
        goto while_break___0;
      }
#line 629
      if ((unsigned long )cinfo->dc_huff_tbl_ptrs[i] != (unsigned long )((void *)0)) {
        {
#line 630
        emit_dht(cinfo, i, 0);
        }
      }
#line 631
      if ((unsigned long )cinfo->ac_huff_tbl_ptrs[i] != (unsigned long )((void *)0)) {
        {
#line 632
        emit_dht(cinfo, i, 1);
        }
      }
#line 628
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 636
  emit_marker(cinfo, (JPEG_MARKER )217);
  }
#line 637
  return;
}
}
#line 644 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmarker.c"
void jinit_marker_writer(j_compress_ptr cinfo ) 
{ 
  my_marker_ptr marker ;
  void *tmp ;

  {
  {
#line 650
  tmp = (*((cinfo->mem)->alloc_small))((j_common_ptr )cinfo, 1, sizeof(my_marker_writer ));
#line 650
  marker = (my_marker_ptr )tmp;
#line 653
  cinfo->marker = (struct jpeg_marker_writer *)marker;
#line 655
  marker->pub.write_file_header = & write_file_header;
#line 656
  marker->pub.write_frame_header = & write_frame_header;
#line 657
  marker->pub.write_scan_header = & write_scan_header;
#line 658
  marker->pub.write_file_trailer = & write_file_trailer;
#line 659
  marker->pub.write_tables_only = & write_tables_only;
#line 660
  marker->pub.write_marker_header = & write_marker_header;
#line 661
  marker->pub.write_marker_byte = & write_marker_byte;
#line 663
  marker->last_restart_interval = 0U;
  }
#line 664
  return;
}
}
#line 371 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpegint.h"
extern long jdiv_round_up(long a , long b ) ;
#line 45 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmaster.c"
static void initial_setup(j_compress_ptr cinfo ) 
{ 
  int ci ;
  jpeg_component_info *compptr ;
  long samplesperrow ;
  JDIMENSION jd_samplesperrow ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 55
  if (cinfo->image_height <= 0U) {
    {
#line 57
    (cinfo->err)->msg_code = 32;
#line 57
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  } else
#line 55
  if (cinfo->image_width <= 0U) {
    {
#line 57
    (cinfo->err)->msg_code = 32;
#line 57
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  } else
#line 55
  if (cinfo->num_components <= 0) {
    {
#line 57
    (cinfo->err)->msg_code = 32;
#line 57
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  } else
#line 55
  if (cinfo->input_components <= 0) {
    {
#line 57
    (cinfo->err)->msg_code = 32;
#line 57
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
#line 60
  if ((long )cinfo->image_height > 65500L) {
    {
#line 62
    (cinfo->err)->msg_code = 41;
#line 62
    (cinfo->err)->msg_parm.i[0] = 65500;
#line 62
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  } else
#line 60
  if ((long )cinfo->image_width > 65500L) {
    {
#line 62
    (cinfo->err)->msg_code = 41;
#line 62
    (cinfo->err)->msg_parm.i[0] = 65500;
#line 62
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
#line 65
  samplesperrow = (long )cinfo->image_width * (long )cinfo->input_components;
#line 66
  jd_samplesperrow = (JDIMENSION )samplesperrow;
#line 67
  if ((long )jd_samplesperrow != samplesperrow) {
    {
#line 68
    (cinfo->err)->msg_code = 70;
#line 68
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
#line 71
  if (cinfo->data_precision != 8) {
    {
#line 72
    (cinfo->err)->msg_code = 15;
#line 72
    (cinfo->err)->msg_parm.i[0] = cinfo->data_precision;
#line 72
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
#line 75
  if (cinfo->num_components > 10) {
    {
#line 76
    (cinfo->err)->msg_code = 26;
#line 76
    (cinfo->err)->msg_parm.i[0] = cinfo->num_components;
#line 76
    (cinfo->err)->msg_parm.i[1] = 10;
#line 76
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
#line 80
  cinfo->max_h_samp_factor = 1;
#line 81
  cinfo->max_v_samp_factor = 1;
#line 82
  ci = 0;
#line 82
  compptr = cinfo->comp_info;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! (ci < cinfo->num_components)) {
#line 82
      goto while_break;
    }
#line 84
    if (compptr->h_samp_factor <= 0) {
      {
#line 86
      (cinfo->err)->msg_code = 18;
#line 86
      (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
      }
    } else
#line 84
    if (compptr->h_samp_factor > 4) {
      {
#line 86
      (cinfo->err)->msg_code = 18;
#line 86
      (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
      }
    } else
#line 84
    if (compptr->v_samp_factor <= 0) {
      {
#line 86
      (cinfo->err)->msg_code = 18;
#line 86
      (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
      }
    } else
#line 84
    if (compptr->v_samp_factor > 4) {
      {
#line 86
      (cinfo->err)->msg_code = 18;
#line 86
      (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
      }
    }
#line 87
    if (cinfo->max_h_samp_factor > compptr->h_samp_factor) {
#line 87
      cinfo->max_h_samp_factor = cinfo->max_h_samp_factor;
    } else {
#line 87
      cinfo->max_h_samp_factor = compptr->h_samp_factor;
    }
#line 89
    if (cinfo->max_v_samp_factor > compptr->v_samp_factor) {
#line 89
      cinfo->max_v_samp_factor = cinfo->max_v_samp_factor;
    } else {
#line 89
      cinfo->max_v_samp_factor = compptr->v_samp_factor;
    }
#line 82
    ci ++;
#line 82
    compptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  ci = 0;
#line 94
  compptr = cinfo->comp_info;
  {
#line 94
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 94
    if (! (ci < cinfo->num_components)) {
#line 94
      goto while_break___0;
    }
    {
#line 97
    compptr->component_index = ci;
#line 99
    compptr->DCT_scaled_size = 8;
#line 101
    tmp = jdiv_round_up((long )cinfo->image_width * (long )compptr->h_samp_factor,
                        (long )(cinfo->max_h_samp_factor * 8));
#line 101
    compptr->width_in_blocks = (JDIMENSION )tmp;
#line 104
    tmp___0 = jdiv_round_up((long )cinfo->image_height * (long )compptr->v_samp_factor,
                            (long )(cinfo->max_v_samp_factor * 8));
#line 104
    compptr->height_in_blocks = (JDIMENSION )tmp___0;
#line 108
    tmp___1 = jdiv_round_up((long )cinfo->image_width * (long )compptr->h_samp_factor,
                            (long )cinfo->max_h_samp_factor);
#line 108
    compptr->downsampled_width = (JDIMENSION )tmp___1;
#line 111
    tmp___2 = jdiv_round_up((long )cinfo->image_height * (long )compptr->v_samp_factor,
                            (long )cinfo->max_v_samp_factor);
#line 111
    compptr->downsampled_height = (JDIMENSION )tmp___2;
#line 115
    compptr->component_needed = 1;
#line 94
    ci ++;
#line 94
    compptr ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 121
  tmp___3 = jdiv_round_up((long )cinfo->image_height, (long )(cinfo->max_v_samp_factor * 8));
#line 121
  cinfo->total_iMCU_rows = (JDIMENSION )tmp___3;
  }
#line 124
  return;
}
}
#line 129 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmaster.c"
static void validate_script(j_compress_ptr cinfo ) 
{ 
  jpeg_scan_info const   *scanptr ;
  int scanno ;
  int ncomps ;
  int ci ;
  int coefi ;
  int thisi ;
  int Ss ;
  int Se ;
  int Ah ;
  int Al ;
  boolean component_sent[10] ;
  int *last_bitpos_ptr ;
  int last_bitpos[10][64] ;
  int *tmp ;

  {
#line 145
  if (cinfo->num_scans <= 0) {
    {
#line 146
    (cinfo->err)->msg_code = 19;
#line 146
    (cinfo->err)->msg_parm.i[0] = 0;
#line 146
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
#line 151
  scanptr = cinfo->scan_info;
#line 152
  if (scanptr->Ss != 0) {
#line 152
    goto _L;
  } else
#line 152
  if (scanptr->Se != 63) {
    _L: /* CIL Label */ 
#line 154
    cinfo->progressive_mode = 1;
#line 155
    last_bitpos_ptr = & last_bitpos[0][0];
#line 156
    ci = 0;
    {
#line 156
    while (1) {
      while_continue: /* CIL Label */ ;
#line 156
      if (! (ci < cinfo->num_components)) {
#line 156
        goto while_break;
      }
#line 157
      coefi = 0;
      {
#line 157
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 157
        if (! (coefi < 64)) {
#line 157
          goto while_break___0;
        }
#line 158
        tmp = last_bitpos_ptr;
#line 158
        last_bitpos_ptr ++;
#line 158
        *tmp = -1;
#line 157
        coefi ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 156
      ci ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 163
    cinfo->progressive_mode = 0;
#line 164
    ci = 0;
    {
#line 164
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 164
      if (! (ci < cinfo->num_components)) {
#line 164
        goto while_break___1;
      }
#line 165
      component_sent[ci] = 0;
#line 164
      ci ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 168
  scanno = 1;
  {
#line 168
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 168
    if (! (scanno <= cinfo->num_scans)) {
#line 168
      goto while_break___2;
    }
#line 170
    ncomps = (int )scanptr->comps_in_scan;
#line 171
    if (ncomps <= 0) {
      {
#line 172
      (cinfo->err)->msg_code = 26;
#line 172
      (cinfo->err)->msg_parm.i[0] = ncomps;
#line 172
      (cinfo->err)->msg_parm.i[1] = 4;
#line 172
      (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
      }
    } else
#line 171
    if (ncomps > 4) {
      {
#line 172
      (cinfo->err)->msg_code = 26;
#line 172
      (cinfo->err)->msg_parm.i[0] = ncomps;
#line 172
      (cinfo->err)->msg_parm.i[1] = 4;
#line 172
      (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
      }
    }
#line 173
    ci = 0;
    {
#line 173
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 173
      if (! (ci < ncomps)) {
#line 173
        goto while_break___3;
      }
#line 174
      thisi = scanptr->component_index[ci];
#line 175
      if (thisi < 0) {
        {
#line 176
        (cinfo->err)->msg_code = 19;
#line 176
        (cinfo->err)->msg_parm.i[0] = scanno;
#line 176
        (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
        }
      } else
#line 175
      if (thisi >= cinfo->num_components) {
        {
#line 176
        (cinfo->err)->msg_code = 19;
#line 176
        (cinfo->err)->msg_parm.i[0] = scanno;
#line 176
        (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
        }
      }
#line 178
      if (ci > 0) {
#line 178
        if (thisi <= scanptr->component_index[ci - 1]) {
          {
#line 179
          (cinfo->err)->msg_code = 19;
#line 179
          (cinfo->err)->msg_parm.i[0] = scanno;
#line 179
          (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
          }
        }
      }
#line 173
      ci ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 182
    Ss = (int )scanptr->Ss;
#line 183
    Se = (int )scanptr->Se;
#line 184
    Ah = (int )scanptr->Ah;
#line 185
    Al = (int )scanptr->Al;
#line 186
    if (cinfo->progressive_mode) {
#line 200
      if (Ss < 0) {
        {
#line 202
        (cinfo->err)->msg_code = 17;
#line 202
        (cinfo->err)->msg_parm.i[0] = scanno;
#line 202
        (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
        }
      } else
#line 200
      if (Ss >= 64) {
        {
#line 202
        (cinfo->err)->msg_code = 17;
#line 202
        (cinfo->err)->msg_parm.i[0] = scanno;
#line 202
        (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
        }
      } else
#line 200
      if (Se < Ss) {
        {
#line 202
        (cinfo->err)->msg_code = 17;
#line 202
        (cinfo->err)->msg_parm.i[0] = scanno;
#line 202
        (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
        }
      } else
#line 200
      if (Se >= 64) {
        {
#line 202
        (cinfo->err)->msg_code = 17;
#line 202
        (cinfo->err)->msg_parm.i[0] = scanno;
#line 202
        (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
        }
      } else
#line 200
      if (Ah < 0) {
        {
#line 202
        (cinfo->err)->msg_code = 17;
#line 202
        (cinfo->err)->msg_parm.i[0] = scanno;
#line 202
        (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
        }
      } else
#line 200
      if (Ah > 10) {
        {
#line 202
        (cinfo->err)->msg_code = 17;
#line 202
        (cinfo->err)->msg_parm.i[0] = scanno;
#line 202
        (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
        }
      } else
#line 200
      if (Al < 0) {
        {
#line 202
        (cinfo->err)->msg_code = 17;
#line 202
        (cinfo->err)->msg_parm.i[0] = scanno;
#line 202
        (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
        }
      } else
#line 200
      if (Al > 10) {
        {
#line 202
        (cinfo->err)->msg_code = 17;
#line 202
        (cinfo->err)->msg_parm.i[0] = scanno;
#line 202
        (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
        }
      }
#line 203
      if (Ss == 0) {
#line 204
        if (Se != 0) {
          {
#line 205
          (cinfo->err)->msg_code = 17;
#line 205
          (cinfo->err)->msg_parm.i[0] = scanno;
#line 205
          (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
          }
        }
      } else
#line 207
      if (ncomps != 1) {
        {
#line 208
        (cinfo->err)->msg_code = 17;
#line 208
        (cinfo->err)->msg_parm.i[0] = scanno;
#line 208
        (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
        }
      }
#line 210
      ci = 0;
      {
#line 210
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 210
        if (! (ci < ncomps)) {
#line 210
          goto while_break___4;
        }
#line 211
        last_bitpos_ptr = & last_bitpos[scanptr->component_index[ci]][0];
#line 212
        if (Ss != 0) {
#line 212
          if (*(last_bitpos_ptr + 0) < 0) {
            {
#line 213
            (cinfo->err)->msg_code = 17;
#line 213
            (cinfo->err)->msg_parm.i[0] = scanno;
#line 213
            (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
            }
          }
        }
#line 214
        coefi = Ss;
        {
#line 214
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 214
          if (! (coefi <= Se)) {
#line 214
            goto while_break___5;
          }
#line 215
          if (*(last_bitpos_ptr + coefi) < 0) {
#line 217
            if (Ah != 0) {
              {
#line 218
              (cinfo->err)->msg_code = 17;
#line 218
              (cinfo->err)->msg_parm.i[0] = scanno;
#line 218
              (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
              }
            }
          } else
#line 221
          if (Ah != *(last_bitpos_ptr + coefi)) {
            {
#line 222
            (cinfo->err)->msg_code = 17;
#line 222
            (cinfo->err)->msg_parm.i[0] = scanno;
#line 222
            (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
            }
          } else
#line 221
          if (Al != Ah - 1) {
            {
#line 222
            (cinfo->err)->msg_code = 17;
#line 222
            (cinfo->err)->msg_parm.i[0] = scanno;
#line 222
            (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
            }
          }
#line 224
          *(last_bitpos_ptr + coefi) = Al;
#line 214
          coefi ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 210
        ci ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else {
#line 230
      if (Ss != 0) {
        {
#line 231
        (cinfo->err)->msg_code = 17;
#line 231
        (cinfo->err)->msg_parm.i[0] = scanno;
#line 231
        (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
        }
      } else
#line 230
      if (Se != 63) {
        {
#line 231
        (cinfo->err)->msg_code = 17;
#line 231
        (cinfo->err)->msg_parm.i[0] = scanno;
#line 231
        (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
        }
      } else
#line 230
      if (Ah != 0) {
        {
#line 231
        (cinfo->err)->msg_code = 17;
#line 231
        (cinfo->err)->msg_parm.i[0] = scanno;
#line 231
        (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
        }
      } else
#line 230
      if (Al != 0) {
        {
#line 231
        (cinfo->err)->msg_code = 17;
#line 231
        (cinfo->err)->msg_parm.i[0] = scanno;
#line 231
        (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
        }
      }
#line 233
      ci = 0;
      {
#line 233
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 233
        if (! (ci < ncomps)) {
#line 233
          goto while_break___6;
        }
#line 234
        thisi = scanptr->component_index[ci];
#line 235
        if (component_sent[thisi]) {
          {
#line 236
          (cinfo->err)->msg_code = 19;
#line 236
          (cinfo->err)->msg_parm.i[0] = scanno;
#line 236
          (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
          }
        }
#line 237
        component_sent[thisi] = 1;
#line 233
        ci ++;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 168
    scanptr ++;
#line 168
    scanno ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 243
  if (cinfo->progressive_mode) {
#line 250
    ci = 0;
    {
#line 250
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 250
      if (! (ci < cinfo->num_components)) {
#line 250
        goto while_break___7;
      }
#line 251
      if (last_bitpos[ci][0] < 0) {
        {
#line 252
        (cinfo->err)->msg_code = 45;
#line 252
        (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
        }
      }
#line 250
      ci ++;
    }
    while_break___7: /* CIL Label */ ;
    }
  } else {
#line 256
    ci = 0;
    {
#line 256
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 256
      if (! (ci < cinfo->num_components)) {
#line 256
        goto while_break___8;
      }
#line 257
      if (! component_sent[ci]) {
        {
#line 258
        (cinfo->err)->msg_code = 45;
#line 258
        (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
        }
      }
#line 256
      ci ++;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 261
  return;
}
}
#line 266 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmaster.c"
static void select_scan_parameters(j_compress_ptr cinfo ) 
{ 
  int ci ;
  my_master_ptr master ;
  jpeg_scan_info const   *scanptr ;

  {
#line 273
  if ((unsigned long )cinfo->scan_info != (unsigned long )((void *)0)) {
#line 275
    master = (my_master_ptr )cinfo->master;
#line 276
    scanptr = cinfo->scan_info + master->scan_number;
#line 278
    cinfo->comps_in_scan = (int )scanptr->comps_in_scan;
#line 279
    ci = 0;
    {
#line 279
    while (1) {
      while_continue: /* CIL Label */ ;
#line 279
      if (! (ci < (int )scanptr->comps_in_scan)) {
#line 279
        goto while_break;
      }
#line 280
      cinfo->cur_comp_info[ci] = cinfo->comp_info + scanptr->component_index[ci];
#line 279
      ci ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 283
    cinfo->Ss = (int )scanptr->Ss;
#line 284
    cinfo->Se = (int )scanptr->Se;
#line 285
    cinfo->Ah = (int )scanptr->Ah;
#line 286
    cinfo->Al = (int )scanptr->Al;
  } else {
#line 292
    if (cinfo->num_components > 4) {
      {
#line 293
      (cinfo->err)->msg_code = 26;
#line 293
      (cinfo->err)->msg_parm.i[0] = cinfo->num_components;
#line 293
      (cinfo->err)->msg_parm.i[1] = 4;
#line 293
      (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
      }
    }
#line 295
    cinfo->comps_in_scan = cinfo->num_components;
#line 296
    ci = 0;
    {
#line 296
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 296
      if (! (ci < cinfo->num_components)) {
#line 296
        goto while_break___0;
      }
#line 297
      cinfo->cur_comp_info[ci] = cinfo->comp_info + ci;
#line 296
      ci ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 299
    cinfo->Ss = 0;
#line 300
    cinfo->Se = 63;
#line 301
    cinfo->Ah = 0;
#line 302
    cinfo->Al = 0;
  }
#line 304
  return;
}
}
#line 307 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmaster.c"
static void per_scan_setup(j_compress_ptr cinfo ) 
{ 
  int ci ;
  int mcublks ;
  int tmp ;
  jpeg_component_info *compptr ;
  long tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long nominal ;
  long tmp___4 ;

  {
#line 315
  if (cinfo->comps_in_scan == 1) {
#line 318
    compptr = cinfo->cur_comp_info[0];
#line 321
    cinfo->MCUs_per_row = compptr->width_in_blocks;
#line 322
    cinfo->MCU_rows_in_scan = compptr->height_in_blocks;
#line 325
    compptr->MCU_width = 1;
#line 326
    compptr->MCU_height = 1;
#line 327
    compptr->MCU_blocks = 1;
#line 328
    compptr->MCU_sample_width = 8;
#line 329
    compptr->last_col_width = 1;
#line 333
    tmp = (int )(compptr->height_in_blocks % (unsigned int )compptr->v_samp_factor);
#line 334
    if (tmp == 0) {
#line 334
      tmp = compptr->v_samp_factor;
    }
#line 335
    compptr->last_row_height = tmp;
#line 338
    cinfo->blocks_in_MCU = 1;
#line 339
    cinfo->MCU_membership[0] = 0;
  } else {
#line 344
    if (cinfo->comps_in_scan <= 0) {
      {
#line 345
      (cinfo->err)->msg_code = 26;
#line 345
      (cinfo->err)->msg_parm.i[0] = cinfo->comps_in_scan;
#line 345
      (cinfo->err)->msg_parm.i[1] = 4;
#line 345
      (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
      }
    } else
#line 344
    if (cinfo->comps_in_scan > 4) {
      {
#line 345
      (cinfo->err)->msg_code = 26;
#line 345
      (cinfo->err)->msg_parm.i[0] = cinfo->comps_in_scan;
#line 345
      (cinfo->err)->msg_parm.i[1] = 4;
#line 345
      (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
      }
    }
    {
#line 349
    tmp___0 = jdiv_round_up((long )cinfo->image_width, (long )(cinfo->max_h_samp_factor * 8));
#line 349
    cinfo->MCUs_per_row = (JDIMENSION )tmp___0;
#line 352
    tmp___1 = jdiv_round_up((long )cinfo->image_height, (long )(cinfo->max_v_samp_factor * 8));
#line 352
    cinfo->MCU_rows_in_scan = (JDIMENSION )tmp___1;
#line 356
    cinfo->blocks_in_MCU = 0;
#line 358
    ci = 0;
    }
    {
#line 358
    while (1) {
      while_continue: /* CIL Label */ ;
#line 358
      if (! (ci < cinfo->comps_in_scan)) {
#line 358
        goto while_break;
      }
#line 359
      compptr = cinfo->cur_comp_info[ci];
#line 361
      compptr->MCU_width = compptr->h_samp_factor;
#line 362
      compptr->MCU_height = compptr->v_samp_factor;
#line 363
      compptr->MCU_blocks = compptr->MCU_width * compptr->MCU_height;
#line 364
      compptr->MCU_sample_width = compptr->MCU_width * 8;
#line 366
      tmp = (int )(compptr->width_in_blocks % (unsigned int )compptr->MCU_width);
#line 367
      if (tmp == 0) {
#line 367
        tmp = compptr->MCU_width;
      }
#line 368
      compptr->last_col_width = tmp;
#line 369
      tmp = (int )(compptr->height_in_blocks % (unsigned int )compptr->MCU_height);
#line 370
      if (tmp == 0) {
#line 370
        tmp = compptr->MCU_height;
      }
#line 371
      compptr->last_row_height = tmp;
#line 373
      mcublks = compptr->MCU_blocks;
#line 374
      if (cinfo->blocks_in_MCU + mcublks > 10) {
        {
#line 375
        (cinfo->err)->msg_code = 13;
#line 375
        (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
        }
      }
      {
#line 376
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 376
        tmp___3 = mcublks;
#line 376
        mcublks --;
#line 376
        if (! (tmp___3 > 0)) {
#line 376
          goto while_break___0;
        }
#line 377
        tmp___2 = cinfo->blocks_in_MCU;
#line 377
        (cinfo->blocks_in_MCU) ++;
#line 377
        cinfo->MCU_membership[tmp___2] = ci;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 358
      ci ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 385
  if (cinfo->restart_in_rows > 0) {
#line 386
    nominal = (long )cinfo->restart_in_rows * (long )cinfo->MCUs_per_row;
#line 387
    if (nominal < 65535L) {
#line 387
      tmp___4 = nominal;
    } else {
#line 387
      tmp___4 = 65535L;
    }
#line 387
    cinfo->restart_interval = (unsigned int )tmp___4;
  }
#line 389
  return;
}
}
#line 400 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmaster.c"
static void prepare_for_pass(j_compress_ptr cinfo ) 
{ 
  my_master_ptr master ;
  int tmp ;

  {
#line 403
  master = (my_master_ptr )cinfo->master;
  {
#line 406
  if ((unsigned int )master->pass_type == 0U) {
#line 406
    goto case_0;
  }
#line 432
  if ((unsigned int )master->pass_type == 1U) {
#line 432
    goto case_1;
  }
#line 449
  if ((unsigned int )master->pass_type == 2U) {
#line 449
    goto case_2;
  }
#line 464
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 410
  select_scan_parameters(cinfo);
#line 411
  per_scan_setup(cinfo);
  }
#line 412
  if (! cinfo->raw_data_in) {
    {
#line 413
    (*((cinfo->cconvert)->start_pass))(cinfo);
#line 414
    (*((cinfo->downsample)->start_pass))(cinfo);
#line 415
    (*((cinfo->prep)->start_pass))(cinfo, (J_BUF_MODE )0);
    }
  }
  {
#line 417
  (*((cinfo->fdct)->start_pass))(cinfo);
#line 418
  (*((cinfo->entropy)->start_pass))(cinfo, cinfo->optimize_coding);
  }
#line 419
  if (master->total_passes > 1) {
#line 419
    tmp = 3;
  } else {
#line 419
    tmp = 0;
  }
  {
#line 419
  (*((cinfo->coef)->start_pass))(cinfo, (J_BUF_MODE )tmp);
#line 422
  (*((cinfo->main)->start_pass))(cinfo, (J_BUF_MODE )0);
  }
#line 423
  if (cinfo->optimize_coding) {
#line 425
    master->pub.call_pass_startup = 0;
  } else {
#line 428
    master->pub.call_pass_startup = 1;
  }
#line 430
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 434
  select_scan_parameters(cinfo);
#line 435
  per_scan_setup(cinfo);
  }
#line 436
  if (cinfo->Ss != 0) {
    {
#line 437
    (*((cinfo->entropy)->start_pass))(cinfo, 1);
#line 438
    (*((cinfo->coef)->start_pass))(cinfo, (J_BUF_MODE )2);
#line 439
    master->pub.call_pass_startup = 0;
    }
#line 440
    goto switch_break;
  } else
#line 436
  if (cinfo->Ah == 0) {
    {
#line 437
    (*((cinfo->entropy)->start_pass))(cinfo, 1);
#line 438
    (*((cinfo->coef)->start_pass))(cinfo, (J_BUF_MODE )2);
#line 439
    master->pub.call_pass_startup = 0;
    }
#line 440
    goto switch_break;
  } else
#line 436
  if (cinfo->arith_code) {
    {
#line 437
    (*((cinfo->entropy)->start_pass))(cinfo, 1);
#line 438
    (*((cinfo->coef)->start_pass))(cinfo, (J_BUF_MODE )2);
#line 439
    master->pub.call_pass_startup = 0;
    }
#line 440
    goto switch_break;
  }
#line 445
  master->pass_type = (c_pass_type )2;
#line 446
  (master->pass_number) ++;
  case_2: /* CIL Label */ 
#line 452
  if (! cinfo->optimize_coding) {
    {
#line 453
    select_scan_parameters(cinfo);
#line 454
    per_scan_setup(cinfo);
    }
  }
  {
#line 456
  (*((cinfo->entropy)->start_pass))(cinfo, 0);
#line 457
  (*((cinfo->coef)->start_pass))(cinfo, (J_BUF_MODE )2);
  }
#line 459
  if (master->scan_number == 0) {
    {
#line 460
    (*((cinfo->marker)->write_frame_header))(cinfo);
    }
  }
  {
#line 461
  (*((cinfo->marker)->write_scan_header))(cinfo);
#line 462
  master->pub.call_pass_startup = 0;
  }
#line 463
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 465
  (cinfo->err)->msg_code = 48;
#line 465
  (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
  }
  switch_break: /* CIL Label */ ;
  }
#line 468
  master->pub.is_last_pass = master->pass_number == master->total_passes - 1;
#line 471
  if ((unsigned long )cinfo->progress != (unsigned long )((void *)0)) {
#line 472
    (cinfo->progress)->completed_passes = master->pass_number;
#line 473
    (cinfo->progress)->total_passes = master->total_passes;
  }
#line 475
  return;
}
}
#line 488 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmaster.c"
static void pass_startup(j_compress_ptr cinfo ) 
{ 


  {
  {
#line 491
  (cinfo->master)->call_pass_startup = 0;
#line 493
  (*((cinfo->marker)->write_frame_header))(cinfo);
#line 494
  (*((cinfo->marker)->write_scan_header))(cinfo);
  }
#line 495
  return;
}
}
#line 502 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmaster.c"
static void finish_pass_master(j_compress_ptr cinfo ) 
{ 
  my_master_ptr master ;

  {
  {
#line 505
  master = (my_master_ptr )cinfo->master;
#line 510
  (*((cinfo->entropy)->finish_pass))(cinfo);
  }
  {
#line 514
  if ((unsigned int )master->pass_type == 0U) {
#line 514
    goto case_0;
  }
#line 522
  if ((unsigned int )master->pass_type == 1U) {
#line 522
    goto case_1;
  }
#line 526
  if ((unsigned int )master->pass_type == 2U) {
#line 526
    goto case_2;
  }
#line 513
  goto switch_break;
  case_0: /* CIL Label */ 
#line 518
  master->pass_type = (c_pass_type )2;
#line 519
  if (! cinfo->optimize_coding) {
#line 520
    (master->scan_number) ++;
  }
#line 521
  goto switch_break;
  case_1: /* CIL Label */ 
#line 524
  master->pass_type = (c_pass_type )2;
#line 525
  goto switch_break;
  case_2: /* CIL Label */ 
#line 528
  if (cinfo->optimize_coding) {
#line 529
    master->pass_type = (c_pass_type )1;
  }
#line 530
  (master->scan_number) ++;
#line 531
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 534
  (master->pass_number) ++;
#line 535
  return;
}
}
#line 542 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmaster.c"
void jinit_c_master_control(j_compress_ptr cinfo , boolean transcode_only ) 
{ 
  my_master_ptr master ;
  void *tmp ;

  {
  {
#line 547
  tmp = (*((cinfo->mem)->alloc_small))((j_common_ptr )cinfo, 1, sizeof(my_comp_master ));
#line 547
  master = (my_master_ptr )tmp;
#line 550
  cinfo->master = (struct jpeg_comp_master *)master;
#line 551
  master->pub.prepare_for_pass = & prepare_for_pass;
#line 552
  master->pub.pass_startup = & pass_startup;
#line 553
  master->pub.finish_pass = & finish_pass_master;
#line 554
  master->pub.is_last_pass = 0;
#line 557
  initial_setup(cinfo);
  }
#line 559
  if ((unsigned long )cinfo->scan_info != (unsigned long )((void *)0)) {
    {
#line 561
    validate_script(cinfo);
    }
  } else {
#line 566
    cinfo->progressive_mode = 0;
#line 567
    cinfo->num_scans = 1;
  }
#line 570
  if (cinfo->progressive_mode) {
#line 571
    cinfo->optimize_coding = 1;
  }
#line 574
  if (transcode_only) {
#line 576
    if (cinfo->optimize_coding) {
#line 577
      master->pass_type = (c_pass_type )1;
    } else {
#line 579
      master->pass_type = (c_pass_type )2;
    }
  } else {
#line 582
    master->pass_type = (c_pass_type )0;
  }
#line 584
  master->scan_number = 0;
#line 585
  master->pass_number = 0;
#line 586
  if (cinfo->optimize_coding) {
#line 587
    master->total_passes = cinfo->num_scans * 2;
  } else {
#line 589
    master->total_passes = cinfo->num_scans;
  }
#line 590
  return;
}
}
#line 54 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmainct.c"
static void process_data_simple_main___0(j_compress_ptr cinfo , JSAMPARRAY input_buf ,
                                         JDIMENSION *in_row_ctr , JDIMENSION in_rows_avail ) ;
#line 68 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmainct.c"
static void start_pass_main___0(j_compress_ptr cinfo , J_BUF_MODE pass_mode ) 
{ 
  my_main_ptr___0 main___0 ;

  {
#line 71
  main___0 = (my_main_ptr___0 )cinfo->main;
#line 74
  if (cinfo->raw_data_in) {
#line 75
    return;
  }
#line 77
  main___0->cur_iMCU_row = (JDIMENSION )0;
#line 78
  main___0->rowgroup_ctr = (JDIMENSION )0;
#line 79
  main___0->suspended = 0;
#line 80
  main___0->pass_mode = pass_mode;
  {
#line 83
  if ((unsigned int )pass_mode == 0U) {
#line 83
    goto case_0;
  }
#line 99
  goto switch_default;
  case_0: /* CIL Label */ 
#line 88
  main___0->pub.process_data = & process_data_simple_main___0;
#line 89
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 100
  (cinfo->err)->msg_code = 4;
#line 100
  (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
  }
#line 101
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 103
  return;
}
}
#line 112 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmainct.c"
static void process_data_simple_main___0(j_compress_ptr cinfo , JSAMPARRAY input_buf ,
                                         JDIMENSION *in_row_ctr , JDIMENSION in_rows_avail ) 
{ 
  my_main_ptr___0 main___0 ;
  boolean tmp ;

  {
#line 117
  main___0 = (my_main_ptr___0 )cinfo->main;
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    if (! (main___0->cur_iMCU_row < cinfo->total_iMCU_rows)) {
#line 119
      goto while_break;
    }
#line 121
    if (main___0->rowgroup_ctr < 8U) {
      {
#line 122
      (*((cinfo->prep)->pre_process_data))(cinfo, input_buf, in_row_ctr, in_rows_avail,
                                           main___0->buffer, & main___0->rowgroup_ctr,
                                           (JDIMENSION )8);
      }
    }
#line 131
    if (main___0->rowgroup_ctr != 8U) {
#line 132
      return;
    }
    {
#line 135
    tmp = (*((cinfo->coef)->compress_data))(cinfo, main___0->buffer);
    }
#line 135
    if (! tmp) {
#line 142
      if (! main___0->suspended) {
#line 143
        (*in_row_ctr) --;
#line 144
        main___0->suspended = 1;
      }
#line 146
      return;
    }
#line 151
    if (main___0->suspended) {
#line 152
      (*in_row_ctr) ++;
#line 153
      main___0->suspended = 0;
    }
#line 155
    main___0->rowgroup_ctr = (JDIMENSION )0;
#line 156
    (main___0->cur_iMCU_row) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  return;
}
}
#line 244 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcmainct.c"
void jinit_c_main_controller(j_compress_ptr cinfo , boolean need_full_buffer ) 
{ 
  my_main_ptr___0 main___0 ;
  int ci ;
  jpeg_component_info *compptr ;
  void *tmp ;

  {
  {
#line 251
  tmp = (*((cinfo->mem)->alloc_small))((j_common_ptr )cinfo, 1, sizeof(my_main_controller___0 ));
#line 251
  main___0 = (my_main_ptr___0 )tmp;
#line 254
  cinfo->main = (struct jpeg_c_main_controller *)main___0;
#line 255
  main___0->pub.start_pass = & start_pass_main___0;
  }
#line 258
  if (cinfo->raw_data_in) {
#line 259
    return;
  }
#line 264
  if (need_full_buffer) {
    {
#line 278
    (cinfo->err)->msg_code = 4;
#line 278
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  } else {
#line 285
    ci = 0;
#line 285
    compptr = cinfo->comp_info;
    {
#line 285
    while (1) {
      while_continue: /* CIL Label */ ;
#line 285
      if (! (ci < cinfo->num_components)) {
#line 285
        goto while_break;
      }
      {
#line 287
      main___0->buffer[ci] = (*((cinfo->mem)->alloc_sarray))((j_common_ptr )cinfo,
                                                             1, compptr->width_in_blocks * 8U,
                                                             (JDIMENSION )(compptr->v_samp_factor * 8));
#line 285
      ci ++;
#line 285
      compptr ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 293
  return;
}
}
#line 41 "/home/wheatley/newnew/temp/outguess-0.2/iterator.c"
void iterator_init(iterator *iter , struct _bitmap *bitmap___0 , u_char *key , u_int klen ) 
{ 
  u_int32_t tmp ;

  {
  {
#line 44
  iter->skipmod = (u_int32_t )32;
#line 46
  arc4_initkey(& iter->as, (char *)"Seeding", key, (int )klen);
#line 48
  tmp = arc4_getword(& iter->as);
#line 48
  iter->off = (int )(tmp % iter->skipmod);
  }
#line 49
  return;
}
}
#line 53 "/home/wheatley/newnew/temp/outguess-0.2/iterator.c"
int iterator_next(iterator *iter , struct _bitmap *bitmap___0 ) 
{ 
  u_int32_t tmp ;

  {
  {
#line 56
  tmp = arc4_getword(& iter->as);
#line 56
  iter->off = (int )((unsigned int )iter->off + (tmp % iter->skipmod + 1U));
  }
#line 58
  return (iter->off);
}
}
#line 61 "/home/wheatley/newnew/temp/outguess-0.2/iterator.c"
void iterator_seed(iterator *iter , struct _bitmap *bitmap___0 , u_int16_t seed ) 
{ 
  u_int8_t reseed[2] ;

  {
  {
#line 66
  reseed[0] = (u_int8_t )seed;
#line 67
  reseed[1] = (u_int8_t )((int )seed >> 8);
#line 69
  arc4_addrandom(& iter->as, reseed, 2);
  }
#line 70
  return;
}
}
#line 72 "/home/wheatley/newnew/temp/outguess-0.2/iterator.c"
void iterator_adapt(iterator *iter , struct _bitmap *bitmap___0 , int datalen ) 
{ 
  float tmp ;

  {
#line 75
  if (bitmap___0->bits - iter->off > bitmap___0->bits / 32) {
#line 75
    tmp = (float )2;
  } else {
#line 75
    tmp = (float )2 - (float )(bitmap___0->bits / 32 - (bitmap___0->bits - iter->off)) / (float )(bitmap___0->bits / 32);
  }
#line 75
  iter->skipmod = (u_int32_t )((tmp * (float )(bitmap___0->bits - iter->off)) / (float )(8 * datalen));
#line 77
  return;
}
}
#line 944 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jpeglib.h"
JDIMENSION jpeg_write_raw_data(j_compress_ptr cinfo , JSAMPIMAGE data___0 , JDIMENSION num_lines ) ;
#line 37 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcapistd.c"
void jpeg_start_compress(j_compress_ptr cinfo , boolean write_all_tables ) 
{ 


  {
#line 40
  if (cinfo->global_state != 100) {
    {
#line 41
    (cinfo->err)->msg_code = 20;
#line 41
    (cinfo->err)->msg_parm.i[0] = cinfo->global_state;
#line 41
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
#line 43
  if (write_all_tables) {
    {
#line 44
    jpeg_suppress_tables(cinfo, 0);
    }
  }
  {
#line 47
  (*((cinfo->err)->reset_error_mgr))((j_common_ptr )cinfo);
#line 48
  (*((cinfo->dest)->init_destination))(cinfo);
#line 50
  jinit_compress_master(cinfo);
#line 52
  (*((cinfo->master)->prepare_for_pass))(cinfo);
#line 56
  cinfo->next_scanline = (JDIMENSION )0;
  }
#line 57
  if (cinfo->raw_data_in) {
#line 57
    cinfo->global_state = 102;
  } else {
#line 57
    cinfo->global_state = 101;
  }
#line 58
  return;
}
}
#line 76 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcapistd.c"
JDIMENSION jpeg_write_scanlines(j_compress_ptr cinfo , JSAMPARRAY scanlines , JDIMENSION num_lines ) 
{ 
  JDIMENSION row_ctr ;
  JDIMENSION rows_left ;

  {
#line 82
  if (cinfo->global_state != 101) {
    {
#line 83
    (cinfo->err)->msg_code = 20;
#line 83
    (cinfo->err)->msg_parm.i[0] = cinfo->global_state;
#line 83
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
#line 84
  if (cinfo->next_scanline >= cinfo->image_height) {
    {
#line 85
    (cinfo->err)->msg_code = 123;
#line 85
    (*((cinfo->err)->emit_message))((j_common_ptr )cinfo, -1);
    }
  }
#line 88
  if ((unsigned long )cinfo->progress != (unsigned long )((void *)0)) {
    {
#line 89
    (cinfo->progress)->pass_counter = (long )cinfo->next_scanline;
#line 90
    (cinfo->progress)->pass_limit = (long )cinfo->image_height;
#line 91
    (*((cinfo->progress)->progress_monitor))((j_common_ptr )cinfo);
    }
  }
#line 99
  if ((cinfo->master)->call_pass_startup) {
    {
#line 100
    (*((cinfo->master)->pass_startup))(cinfo);
    }
  }
#line 103
  rows_left = cinfo->image_height - cinfo->next_scanline;
#line 104
  if (num_lines > rows_left) {
#line 105
    num_lines = rows_left;
  }
  {
#line 107
  row_ctr = (JDIMENSION )0;
#line 108
  (*((cinfo->main)->process_data))(cinfo, scanlines, & row_ctr, num_lines);
#line 109
  cinfo->next_scanline += row_ctr;
  }
#line 110
  return (row_ctr);
}
}
#line 119 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jcapistd.c"
JDIMENSION jpeg_write_raw_data(j_compress_ptr cinfo , JSAMPIMAGE data___0 , JDIMENSION num_lines ) 
{ 
  JDIMENSION lines_per_iMCU_row ;
  boolean tmp ;

  {
#line 125
  if (cinfo->global_state != 102) {
    {
#line 126
    (cinfo->err)->msg_code = 20;
#line 126
    (cinfo->err)->msg_parm.i[0] = cinfo->global_state;
#line 126
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
#line 127
  if (cinfo->next_scanline >= cinfo->image_height) {
    {
#line 128
    (cinfo->err)->msg_code = 123;
#line 128
    (*((cinfo->err)->emit_message))((j_common_ptr )cinfo, -1);
    }
#line 129
    return ((JDIMENSION )0);
  }
#line 133
  if ((unsigned long )cinfo->progress != (unsigned long )((void *)0)) {
    {
#line 134
    (cinfo->progress)->pass_counter = (long )cinfo->next_scanline;
#line 135
    (cinfo->progress)->pass_limit = (long )cinfo->image_height;
#line 136
    (*((cinfo->progress)->progress_monitor))((j_common_ptr )cinfo);
    }
  }
#line 144
  if ((cinfo->master)->call_pass_startup) {
    {
#line 145
    (*((cinfo->master)->pass_startup))(cinfo);
    }
  }
#line 148
  lines_per_iMCU_row = (JDIMENSION )(cinfo->max_v_samp_factor * 8);
#line 149
  if (num_lines < lines_per_iMCU_row) {
    {
#line 150
    (cinfo->err)->msg_code = 23;
#line 150
    (*((cinfo->err)->error_exit))((j_common_ptr )cinfo);
    }
  }
  {
#line 153
  tmp = (*((cinfo->coef)->compress_data))(cinfo, data___0);
  }
#line 153
  if (! tmp) {
#line 155
    return ((JDIMENSION )0);
  }
#line 159
  cinfo->next_scanline += lines_per_iMCU_row;
#line 160
  return (lines_per_iMCU_row);
}
}
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 47 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmemsys.h"
extern void *jpeg_get_small(j_common_ptr cinfo , size_t sizeofobject ) ;
#line 48
extern void jpeg_free_small(j_common_ptr cinfo , void *object , size_t sizeofobject ) ;
#line 60
extern void *jpeg_get_large(j_common_ptr cinfo , size_t sizeofobject ) ;
#line 62
extern void jpeg_free_large(j_common_ptr cinfo , void *object , size_t sizeofobject ) ;
#line 103
extern long jpeg_mem_available(j_common_ptr cinfo , long min_bytes_needed , long max_bytes_needed ,
                               long already_allocated ) ;
#line 180
extern void jpeg_open_backing_store(j_common_ptr cinfo , backing_store_ptr info ,
                                    long total_bytes_needed ) ;
#line 197
extern long jpeg_mem_init(j_common_ptr cinfo ) ;
#line 198
extern void jpeg_mem_term(j_common_ptr cinfo ) ;
#line 216 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmemmgr.c"
static void out_of_memory(j_common_ptr cinfo , int which ) 
{ 


  {
  {
#line 224
  (cinfo->err)->msg_code = 54;
#line 224
  (cinfo->err)->msg_parm.i[0] = which;
#line 224
  (*((cinfo->err)->error_exit))(cinfo);
  }
#line 225
  return;
}
}
#line 241 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmemmgr.c"
static size_t const   first_pool_slop[2]  = {      (size_t const   )1600,      (size_t const   )16000};
#line 247 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmemmgr.c"
static size_t const   extra_pool_slop[2]  = {      (size_t const   )0,      (size_t const   )5000};
#line 256 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmemmgr.c"
static void *alloc_small(j_common_ptr cinfo , int pool_id , size_t sizeofobject ) 
{ 
  my_mem_ptr mem ;
  small_pool_ptr hdr_ptr ;
  small_pool_ptr prev_hdr_ptr ;
  char *data_ptr ;
  size_t odd_bytes ;
  size_t min_request ;
  size_t slop ;
  void *tmp ;

  {
#line 260
  mem = (my_mem_ptr )cinfo->mem;
#line 266
  if (sizeofobject > 1000000000UL - sizeof(small_pool_hdr )) {
    {
#line 267
    out_of_memory(cinfo, 1);
    }
  }
#line 270
  odd_bytes = sizeofobject % sizeof(double );
#line 271
  if (odd_bytes > 0UL) {
#line 272
    sizeofobject += sizeof(double ) - odd_bytes;
  }
#line 275
  if (pool_id < 0) {
    {
#line 276
    (cinfo->err)->msg_code = 14;
#line 276
    (cinfo->err)->msg_parm.i[0] = pool_id;
#line 276
    (*((cinfo->err)->error_exit))(cinfo);
    }
  } else
#line 275
  if (pool_id >= 2) {
    {
#line 276
    (cinfo->err)->msg_code = 14;
#line 276
    (cinfo->err)->msg_parm.i[0] = pool_id;
#line 276
    (*((cinfo->err)->error_exit))(cinfo);
    }
  }
#line 277
  prev_hdr_ptr = (small_pool_ptr )((void *)0);
#line 278
  hdr_ptr = mem->small_list[pool_id];
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
#line 279
    if (! ((unsigned long )hdr_ptr != (unsigned long )((void *)0))) {
#line 279
      goto while_break;
    }
#line 280
    if (hdr_ptr->hdr.bytes_left >= sizeofobject) {
#line 281
      goto while_break;
    }
#line 282
    prev_hdr_ptr = hdr_ptr;
#line 283
    hdr_ptr = hdr_ptr->hdr.next;
  }
  while_break: /* CIL Label */ ;
  }
#line 287
  if ((unsigned long )hdr_ptr == (unsigned long )((void *)0)) {
#line 289
    min_request = sizeofobject + sizeof(small_pool_hdr );
#line 290
    if ((unsigned long )prev_hdr_ptr == (unsigned long )((void *)0)) {
#line 291
      slop = (size_t )first_pool_slop[pool_id];
    } else {
#line 293
      slop = (size_t )extra_pool_slop[pool_id];
    }
#line 295
    if (slop > 1000000000UL - min_request) {
#line 296
      slop = 1000000000UL - min_request;
    }
    {
#line 298
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 299
      tmp = jpeg_get_small(cinfo, min_request + slop);
#line 299
      hdr_ptr = (small_pool_ptr )tmp;
      }
#line 300
      if ((unsigned long )hdr_ptr != (unsigned long )((void *)0)) {
#line 301
        goto while_break___0;
      }
#line 302
      slop /= 2UL;
#line 303
      if (slop < 50UL) {
        {
#line 304
        out_of_memory(cinfo, 2);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 306
    mem->total_space_allocated = (long )((size_t )mem->total_space_allocated + (min_request + slop));
#line 308
    hdr_ptr->hdr.next = (small_pool_ptr )((void *)0);
#line 309
    hdr_ptr->hdr.bytes_used = (size_t )0;
#line 310
    hdr_ptr->hdr.bytes_left = sizeofobject + slop;
#line 311
    if ((unsigned long )prev_hdr_ptr == (unsigned long )((void *)0)) {
#line 312
      mem->small_list[pool_id] = hdr_ptr;
    } else {
#line 314
      prev_hdr_ptr->hdr.next = hdr_ptr;
    }
  }
#line 318
  data_ptr = (char *)(hdr_ptr + 1);
#line 319
  data_ptr += hdr_ptr->hdr.bytes_used;
#line 320
  hdr_ptr->hdr.bytes_used += sizeofobject;
#line 321
  hdr_ptr->hdr.bytes_left -= sizeofobject;
#line 323
  return ((void *)data_ptr);
}
}
#line 341 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmemmgr.c"
static void *alloc_large(j_common_ptr cinfo , int pool_id , size_t sizeofobject ) 
{ 
  my_mem_ptr mem ;
  large_pool_ptr hdr_ptr ;
  size_t odd_bytes ;
  void *tmp ;

  {
#line 345
  mem = (my_mem_ptr )cinfo->mem;
#line 350
  if (sizeofobject > 1000000000UL - sizeof(large_pool_hdr )) {
    {
#line 351
    out_of_memory(cinfo, 3);
    }
  }
#line 354
  odd_bytes = sizeofobject % sizeof(double );
#line 355
  if (odd_bytes > 0UL) {
#line 356
    sizeofobject += sizeof(double ) - odd_bytes;
  }
#line 359
  if (pool_id < 0) {
    {
#line 360
    (cinfo->err)->msg_code = 14;
#line 360
    (cinfo->err)->msg_parm.i[0] = pool_id;
#line 360
    (*((cinfo->err)->error_exit))(cinfo);
    }
  } else
#line 359
  if (pool_id >= 2) {
    {
#line 360
    (cinfo->err)->msg_code = 14;
#line 360
    (cinfo->err)->msg_parm.i[0] = pool_id;
#line 360
    (*((cinfo->err)->error_exit))(cinfo);
    }
  }
  {
#line 362
  tmp = jpeg_get_large(cinfo, sizeofobject + sizeof(large_pool_hdr ));
#line 362
  hdr_ptr = (large_pool_ptr )tmp;
  }
#line 364
  if ((unsigned long )hdr_ptr == (unsigned long )((void *)0)) {
    {
#line 365
    out_of_memory(cinfo, 4);
    }
  }
#line 366
  mem->total_space_allocated = (long )((size_t )mem->total_space_allocated + (sizeofobject + sizeof(large_pool_hdr )));
#line 369
  hdr_ptr->hdr.next = mem->large_list[pool_id];
#line 373
  hdr_ptr->hdr.bytes_used = sizeofobject;
#line 374
  hdr_ptr->hdr.bytes_left = (size_t )0;
#line 375
  mem->large_list[pool_id] = hdr_ptr;
#line 377
  return ((void *)(hdr_ptr + 1));
}
}
#line 394 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmemmgr.c"
static JSAMPARRAY alloc_sarray(j_common_ptr cinfo , int pool_id , JDIMENSION samplesperrow ,
                               JDIMENSION numrows ) 
{ 
  my_mem_ptr mem ;
  JSAMPARRAY result ;
  JSAMPROW workspace ;
  JDIMENSION rowsperchunk ;
  JDIMENSION currow ;
  JDIMENSION i ;
  long ltemp ;
  void *tmp ;
  void *tmp___0 ;
  JDIMENSION tmp___1 ;

  {
#line 399
  mem = (my_mem_ptr )cinfo->mem;
#line 406
  ltemp = (long )((1000000000UL - sizeof(large_pool_hdr )) / ((size_t )((long )samplesperrow) * sizeof(JSAMPLE )));
#line 408
  if (ltemp <= 0L) {
    {
#line 409
    (cinfo->err)->msg_code = 70;
#line 409
    (*((cinfo->err)->error_exit))(cinfo);
    }
  }
#line 410
  if (ltemp < (long )numrows) {
#line 411
    rowsperchunk = (JDIMENSION )ltemp;
  } else {
#line 413
    rowsperchunk = numrows;
  }
  {
#line 414
  mem->last_rowsperchunk = rowsperchunk;
#line 417
  tmp = alloc_small(cinfo, pool_id, (size_t )numrows * sizeof(JSAMPROW ));
#line 417
  result = (JSAMPARRAY )tmp;
#line 421
  currow = (JDIMENSION )0;
  }
  {
#line 422
  while (1) {
    while_continue: /* CIL Label */ ;
#line 422
    if (! (currow < numrows)) {
#line 422
      goto while_break;
    }
#line 423
    if (rowsperchunk < numrows - currow) {
#line 423
      rowsperchunk = rowsperchunk;
    } else {
#line 423
      rowsperchunk = numrows - currow;
    }
    {
#line 424
    tmp___0 = alloc_large(cinfo, pool_id, ((size_t )rowsperchunk * (size_t )samplesperrow) * sizeof(JSAMPLE ));
#line 424
    workspace = (JSAMPROW )tmp___0;
#line 427
    i = rowsperchunk;
    }
    {
#line 427
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 427
      if (! (i > 0U)) {
#line 427
        goto while_break___0;
      }
#line 428
      tmp___1 = currow;
#line 428
      currow ++;
#line 428
      *(result + tmp___1) = workspace;
#line 429
      workspace += samplesperrow;
#line 427
      i --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 433
  return (result);
}
}
#line 442 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmemmgr.c"
static JBLOCKARRAY alloc_barray(j_common_ptr cinfo , int pool_id , JDIMENSION blocksperrow ,
                                JDIMENSION numrows ) 
{ 
  my_mem_ptr mem ;
  JBLOCKARRAY result ;
  JBLOCKROW workspace ;
  JDIMENSION rowsperchunk ;
  JDIMENSION currow ;
  JDIMENSION i ;
  long ltemp ;
  void *tmp ;
  void *tmp___0 ;
  JDIMENSION tmp___1 ;

  {
#line 447
  mem = (my_mem_ptr )cinfo->mem;
#line 454
  ltemp = (long )((1000000000UL - sizeof(large_pool_hdr )) / ((size_t )((long )blocksperrow) * sizeof(JBLOCK )));
#line 456
  if (ltemp <= 0L) {
    {
#line 457
    (cinfo->err)->msg_code = 70;
#line 457
    (*((cinfo->err)->error_exit))(cinfo);
    }
  }
#line 458
  if (ltemp < (long )numrows) {
#line 459
    rowsperchunk = (JDIMENSION )ltemp;
  } else {
#line 461
    rowsperchunk = numrows;
  }
  {
#line 462
  mem->last_rowsperchunk = rowsperchunk;
#line 465
  tmp = alloc_small(cinfo, pool_id, (size_t )numrows * sizeof(JBLOCKROW ));
#line 465
  result = (JBLOCKARRAY )tmp;
#line 469
  currow = (JDIMENSION )0;
  }
  {
#line 470
  while (1) {
    while_continue: /* CIL Label */ ;
#line 470
    if (! (currow < numrows)) {
#line 470
      goto while_break;
    }
#line 471
    if (rowsperchunk < numrows - currow) {
#line 471
      rowsperchunk = rowsperchunk;
    } else {
#line 471
      rowsperchunk = numrows - currow;
    }
    {
#line 472
    tmp___0 = alloc_large(cinfo, pool_id, ((size_t )rowsperchunk * (size_t )blocksperrow) * sizeof(JBLOCK ));
#line 472
    workspace = (JBLOCKROW )tmp___0;
#line 475
    i = rowsperchunk;
    }
    {
#line 475
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 475
      if (! (i > 0U)) {
#line 475
        goto while_break___0;
      }
#line 476
      tmp___1 = currow;
#line 476
      currow ++;
#line 476
      *(result + tmp___1) = workspace;
#line 477
      workspace += blocksperrow;
#line 475
      i --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 481
  return (result);
}
}
#line 522 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmemmgr.c"
static jvirt_sarray_ptr request_virt_sarray(j_common_ptr cinfo , int pool_id , boolean pre_zero ,
                                            JDIMENSION samplesperrow , JDIMENSION numrows ,
                                            JDIMENSION maxaccess ) 
{ 
  my_mem_ptr mem ;
  jvirt_sarray_ptr result ;
  void *tmp ;

  {
#line 528
  mem = (my_mem_ptr )cinfo->mem;
#line 532
  if (pool_id != 1) {
    {
#line 533
    (cinfo->err)->msg_code = 14;
#line 533
    (cinfo->err)->msg_parm.i[0] = pool_id;
#line 533
    (*((cinfo->err)->error_exit))(cinfo);
    }
  }
  {
#line 536
  tmp = alloc_small(cinfo, pool_id, sizeof(struct jvirt_sarray_control ));
#line 536
  result = (jvirt_sarray_ptr )tmp;
#line 539
  result->mem_buffer = (JSAMPARRAY )((void *)0);
#line 540
  result->rows_in_array = numrows;
#line 541
  result->samplesperrow = samplesperrow;
#line 542
  result->maxaccess = maxaccess;
#line 543
  result->pre_zero = pre_zero;
#line 544
  result->b_s_open = 0;
#line 545
  result->next = mem->virt_sarray_list;
#line 546
  mem->virt_sarray_list = result;
  }
#line 548
  return (result);
}
}
#line 552 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmemmgr.c"
static jvirt_barray_ptr request_virt_barray(j_common_ptr cinfo , int pool_id , boolean pre_zero ,
                                            JDIMENSION blocksperrow , JDIMENSION numrows ,
                                            JDIMENSION maxaccess ) 
{ 
  my_mem_ptr mem ;
  jvirt_barray_ptr result ;
  void *tmp ;

  {
#line 558
  mem = (my_mem_ptr )cinfo->mem;
#line 562
  if (pool_id != 1) {
    {
#line 563
    (cinfo->err)->msg_code = 14;
#line 563
    (cinfo->err)->msg_parm.i[0] = pool_id;
#line 563
    (*((cinfo->err)->error_exit))(cinfo);
    }
  }
  {
#line 566
  tmp = alloc_small(cinfo, pool_id, sizeof(struct jvirt_barray_control ));
#line 566
  result = (jvirt_barray_ptr )tmp;
#line 569
  result->mem_buffer = (JBLOCKARRAY )((void *)0);
#line 570
  result->rows_in_array = numrows;
#line 571
  result->blocksperrow = blocksperrow;
#line 572
  result->maxaccess = maxaccess;
#line 573
  result->pre_zero = pre_zero;
#line 574
  result->b_s_open = 0;
#line 575
  result->next = mem->virt_barray_list;
#line 576
  mem->virt_barray_list = result;
  }
#line 578
  return (result);
}
}
#line 582 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmemmgr.c"
static void realize_virt_arrays(j_common_ptr cinfo ) 
{ 
  my_mem_ptr mem ;
  long space_per_minheight ;
  long maximum_space ;
  long avail_mem ;
  long minheights ;
  long max_minheights ;
  jvirt_sarray_ptr sptr ;
  jvirt_barray_ptr bptr ;

  {
#line 586
  mem = (my_mem_ptr )cinfo->mem;
#line 596
  space_per_minheight = 0L;
#line 597
  maximum_space = 0L;
#line 598
  sptr = mem->virt_sarray_list;
  {
#line 598
  while (1) {
    while_continue: /* CIL Label */ ;
#line 598
    if (! ((unsigned long )sptr != (unsigned long )((void *)0))) {
#line 598
      goto while_break;
    }
#line 599
    if ((unsigned long )sptr->mem_buffer == (unsigned long )((void *)0)) {
#line 600
      space_per_minheight = (long )((size_t )space_per_minheight + (size_t )((long )sptr->maxaccess * (long )sptr->samplesperrow) * sizeof(JSAMPLE ));
#line 602
      maximum_space = (long )((size_t )maximum_space + (size_t )((long )sptr->rows_in_array * (long )sptr->samplesperrow) * sizeof(JSAMPLE ));
    }
#line 598
    sptr = sptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 606
  bptr = mem->virt_barray_list;
  {
#line 606
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 606
    if (! ((unsigned long )bptr != (unsigned long )((void *)0))) {
#line 606
      goto while_break___0;
    }
#line 607
    if ((unsigned long )bptr->mem_buffer == (unsigned long )((void *)0)) {
#line 608
      space_per_minheight = (long )((size_t )space_per_minheight + (size_t )((long )bptr->maxaccess * (long )bptr->blocksperrow) * sizeof(JBLOCK ));
#line 610
      maximum_space = (long )((size_t )maximum_space + (size_t )((long )bptr->rows_in_array * (long )bptr->blocksperrow) * sizeof(JBLOCK ));
    }
#line 606
    bptr = bptr->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 615
  if (space_per_minheight <= 0L) {
#line 616
    return;
  }
  {
#line 619
  avail_mem = jpeg_mem_available(cinfo, space_per_minheight, maximum_space, mem->total_space_allocated);
  }
#line 626
  if (avail_mem >= maximum_space) {
#line 627
    max_minheights = 1000000000L;
  } else {
#line 629
    max_minheights = avail_mem / space_per_minheight;
#line 633
    if (max_minheights <= 0L) {
#line 634
      max_minheights = 1L;
    }
  }
#line 639
  sptr = mem->virt_sarray_list;
  {
#line 639
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 639
    if (! ((unsigned long )sptr != (unsigned long )((void *)0))) {
#line 639
      goto while_break___1;
    }
#line 640
    if ((unsigned long )sptr->mem_buffer == (unsigned long )((void *)0)) {
#line 641
      minheights = ((long )sptr->rows_in_array - 1L) / (long )sptr->maxaccess + 1L;
#line 642
      if (minheights <= max_minheights) {
#line 644
        sptr->rows_in_mem = sptr->rows_in_array;
      } else {
        {
#line 647
        sptr->rows_in_mem = (JDIMENSION )(max_minheights * (long )sptr->maxaccess);
#line 648
        jpeg_open_backing_store(cinfo, & sptr->b_s_info, ((long )sptr->rows_in_array * (long )sptr->samplesperrow) * (long )sizeof(JSAMPLE ));
#line 652
        sptr->b_s_open = 1;
        }
      }
      {
#line 654
      sptr->mem_buffer = alloc_sarray(cinfo, 1, sptr->samplesperrow, sptr->rows_in_mem);
#line 656
      sptr->rowsperchunk = mem->last_rowsperchunk;
#line 657
      sptr->cur_start_row = (JDIMENSION )0;
#line 658
      sptr->first_undef_row = (JDIMENSION )0;
#line 659
      sptr->dirty = 0;
      }
    }
#line 639
    sptr = sptr->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 663
  bptr = mem->virt_barray_list;
  {
#line 663
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 663
    if (! ((unsigned long )bptr != (unsigned long )((void *)0))) {
#line 663
      goto while_break___2;
    }
#line 664
    if ((unsigned long )bptr->mem_buffer == (unsigned long )((void *)0)) {
#line 665
      minheights = ((long )bptr->rows_in_array - 1L) / (long )bptr->maxaccess + 1L;
#line 666
      if (minheights <= max_minheights) {
#line 668
        bptr->rows_in_mem = bptr->rows_in_array;
      } else {
        {
#line 671
        bptr->rows_in_mem = (JDIMENSION )(max_minheights * (long )bptr->maxaccess);
#line 672
        jpeg_open_backing_store(cinfo, & bptr->b_s_info, ((long )bptr->rows_in_array * (long )bptr->blocksperrow) * (long )sizeof(JBLOCK ));
#line 676
        bptr->b_s_open = 1;
        }
      }
      {
#line 678
      bptr->mem_buffer = alloc_barray(cinfo, 1, bptr->blocksperrow, bptr->rows_in_mem);
#line 680
      bptr->rowsperchunk = mem->last_rowsperchunk;
#line 681
      bptr->cur_start_row = (JDIMENSION )0;
#line 682
      bptr->first_undef_row = (JDIMENSION )0;
#line 683
      bptr->dirty = 0;
      }
    }
#line 663
    bptr = bptr->next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 686
  return;
}
}
#line 689 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmemmgr.c"
static void do_sarray_io(j_common_ptr cinfo , jvirt_sarray_ptr ptr , boolean writing ) 
{ 
  long bytesperrow ;
  long file_offset ;
  long byte_count ;
  long rows ;
  long thisrow ;
  long i ;

  {
#line 695
  bytesperrow = (long )((size_t )((long )ptr->samplesperrow) * sizeof(JSAMPLE ));
#line 696
  file_offset = (long )ptr->cur_start_row * bytesperrow;
#line 698
  i = 0L;
  {
#line 698
  while (1) {
    while_continue: /* CIL Label */ ;
#line 698
    if (! (i < (long )ptr->rows_in_mem)) {
#line 698
      goto while_break;
    }
#line 700
    if ((long )ptr->rowsperchunk < (long )ptr->rows_in_mem - i) {
#line 700
      rows = (long )ptr->rowsperchunk;
    } else {
#line 700
      rows = (long )ptr->rows_in_mem - i;
    }
#line 702
    thisrow = (long )ptr->cur_start_row + i;
#line 703
    if (rows < (long )ptr->first_undef_row - thisrow) {
#line 703
      rows = rows;
    } else {
#line 703
      rows = (long )ptr->first_undef_row - thisrow;
    }
#line 705
    if (rows < (long )ptr->rows_in_array - thisrow) {
#line 705
      rows = rows;
    } else {
#line 705
      rows = (long )ptr->rows_in_array - thisrow;
    }
#line 706
    if (rows <= 0L) {
#line 707
      goto while_break;
    }
#line 708
    byte_count = rows * bytesperrow;
#line 709
    if (writing) {
      {
#line 710
      (*(ptr->b_s_info.write_backing_store))(cinfo, & ptr->b_s_info, (void *)*(ptr->mem_buffer + i),
                                             file_offset, byte_count);
      }
    } else {
      {
#line 714
      (*(ptr->b_s_info.read_backing_store))(cinfo, & ptr->b_s_info, (void *)*(ptr->mem_buffer + i),
                                            file_offset, byte_count);
      }
    }
#line 717
    file_offset += byte_count;
#line 698
    i += (long )ptr->rowsperchunk;
  }
  while_break: /* CIL Label */ ;
  }
#line 719
  return;
}
}
#line 722 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmemmgr.c"
static void do_barray_io(j_common_ptr cinfo , jvirt_barray_ptr ptr , boolean writing ) 
{ 
  long bytesperrow ;
  long file_offset ;
  long byte_count ;
  long rows ;
  long thisrow ;
  long i ;

  {
#line 728
  bytesperrow = (long )((size_t )((long )ptr->blocksperrow) * sizeof(JBLOCK ));
#line 729
  file_offset = (long )ptr->cur_start_row * bytesperrow;
#line 731
  i = 0L;
  {
#line 731
  while (1) {
    while_continue: /* CIL Label */ ;
#line 731
    if (! (i < (long )ptr->rows_in_mem)) {
#line 731
      goto while_break;
    }
#line 733
    if ((long )ptr->rowsperchunk < (long )ptr->rows_in_mem - i) {
#line 733
      rows = (long )ptr->rowsperchunk;
    } else {
#line 733
      rows = (long )ptr->rows_in_mem - i;
    }
#line 735
    thisrow = (long )ptr->cur_start_row + i;
#line 736
    if (rows < (long )ptr->first_undef_row - thisrow) {
#line 736
      rows = rows;
    } else {
#line 736
      rows = (long )ptr->first_undef_row - thisrow;
    }
#line 738
    if (rows < (long )ptr->rows_in_array - thisrow) {
#line 738
      rows = rows;
    } else {
#line 738
      rows = (long )ptr->rows_in_array - thisrow;
    }
#line 739
    if (rows <= 0L) {
#line 740
      goto while_break;
    }
#line 741
    byte_count = rows * bytesperrow;
#line 742
    if (writing) {
      {
#line 743
      (*(ptr->b_s_info.write_backing_store))(cinfo, & ptr->b_s_info, (void *)*(ptr->mem_buffer + i),
                                             file_offset, byte_count);
      }
    } else {
      {
#line 747
      (*(ptr->b_s_info.read_backing_store))(cinfo, & ptr->b_s_info, (void *)*(ptr->mem_buffer + i),
                                            file_offset, byte_count);
      }
    }
#line 750
    file_offset += byte_count;
#line 731
    i += (long )ptr->rowsperchunk;
  }
  while_break: /* CIL Label */ ;
  }
#line 752
  return;
}
}
#line 755 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmemmgr.c"
static JSAMPARRAY access_virt_sarray(j_common_ptr cinfo , jvirt_sarray_ptr ptr , JDIMENSION start_row ,
                                     JDIMENSION num_rows , boolean writable ) 
{ 
  JDIMENSION end_row ;
  JDIMENSION undef_row ;
  long ltemp ;
  size_t bytesperrow ;

  {
#line 763
  end_row = start_row + num_rows;
#line 767
  if (end_row > ptr->rows_in_array) {
    {
#line 769
    (cinfo->err)->msg_code = 22;
#line 769
    (*((cinfo->err)->error_exit))(cinfo);
    }
  } else
#line 767
  if (num_rows > ptr->maxaccess) {
    {
#line 769
    (cinfo->err)->msg_code = 22;
#line 769
    (*((cinfo->err)->error_exit))(cinfo);
    }
  } else
#line 767
  if ((unsigned long )ptr->mem_buffer == (unsigned long )((void *)0)) {
    {
#line 769
    (cinfo->err)->msg_code = 22;
#line 769
    (*((cinfo->err)->error_exit))(cinfo);
    }
  }
#line 772
  if (start_row < ptr->cur_start_row) {
#line 772
    goto _L;
  } else
#line 772
  if (end_row > ptr->cur_start_row + ptr->rows_in_mem) {
    _L: /* CIL Label */ 
#line 774
    if (! ptr->b_s_open) {
      {
#line 775
      (cinfo->err)->msg_code = 69;
#line 775
      (*((cinfo->err)->error_exit))(cinfo);
      }
    }
#line 777
    if (ptr->dirty) {
      {
#line 778
      do_sarray_io(cinfo, ptr, 1);
#line 779
      ptr->dirty = 0;
      }
    }
#line 788
    if (start_row > ptr->cur_start_row) {
#line 789
      ptr->cur_start_row = start_row;
    } else {
#line 794
      ltemp = (long )end_row - (long )ptr->rows_in_mem;
#line 795
      if (ltemp < 0L) {
#line 796
        ltemp = 0L;
      }
#line 797
      ptr->cur_start_row = (JDIMENSION )ltemp;
    }
    {
#line 803
    do_sarray_io(cinfo, ptr, 0);
    }
  }
#line 809
  if (ptr->first_undef_row < end_row) {
#line 810
    if (ptr->first_undef_row < start_row) {
#line 811
      if (writable) {
        {
#line 812
        (cinfo->err)->msg_code = 22;
#line 812
        (*((cinfo->err)->error_exit))(cinfo);
        }
      }
#line 813
      undef_row = start_row;
    } else {
#line 815
      undef_row = ptr->first_undef_row;
    }
#line 817
    if (writable) {
#line 818
      ptr->first_undef_row = end_row;
    }
#line 819
    if (ptr->pre_zero) {
#line 820
      bytesperrow = (size_t )ptr->samplesperrow * sizeof(JSAMPLE );
#line 821
      undef_row -= ptr->cur_start_row;
#line 822
      end_row -= ptr->cur_start_row;
      {
#line 823
      while (1) {
        while_continue: /* CIL Label */ ;
#line 823
        if (! (undef_row < end_row)) {
#line 823
          goto while_break;
        }
        {
#line 824
        jzero_far((void *)*(ptr->mem_buffer + undef_row), bytesperrow);
#line 825
        undef_row ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else
#line 828
    if (! writable) {
      {
#line 829
      (cinfo->err)->msg_code = 22;
#line 829
      (*((cinfo->err)->error_exit))(cinfo);
      }
    }
  }
#line 833
  if (writable) {
#line 834
    ptr->dirty = 1;
  }
#line 836
  return (ptr->mem_buffer + (start_row - ptr->cur_start_row));
}
}
#line 840 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmemmgr.c"
static JBLOCKARRAY access_virt_barray(j_common_ptr cinfo , jvirt_barray_ptr ptr ,
                                      JDIMENSION start_row , JDIMENSION num_rows ,
                                      boolean writable ) 
{ 
  JDIMENSION end_row ;
  JDIMENSION undef_row ;
  long ltemp ;
  size_t bytesperrow ;

  {
#line 848
  end_row = start_row + num_rows;
#line 852
  if (end_row > ptr->rows_in_array) {
    {
#line 854
    (cinfo->err)->msg_code = 22;
#line 854
    (*((cinfo->err)->error_exit))(cinfo);
    }
  } else
#line 852
  if (num_rows > ptr->maxaccess) {
    {
#line 854
    (cinfo->err)->msg_code = 22;
#line 854
    (*((cinfo->err)->error_exit))(cinfo);
    }
  } else
#line 852
  if ((unsigned long )ptr->mem_buffer == (unsigned long )((void *)0)) {
    {
#line 854
    (cinfo->err)->msg_code = 22;
#line 854
    (*((cinfo->err)->error_exit))(cinfo);
    }
  }
#line 857
  if (start_row < ptr->cur_start_row) {
#line 857
    goto _L;
  } else
#line 857
  if (end_row > ptr->cur_start_row + ptr->rows_in_mem) {
    _L: /* CIL Label */ 
#line 859
    if (! ptr->b_s_open) {
      {
#line 860
      (cinfo->err)->msg_code = 69;
#line 860
      (*((cinfo->err)->error_exit))(cinfo);
      }
    }
#line 862
    if (ptr->dirty) {
      {
#line 863
      do_barray_io(cinfo, ptr, 1);
#line 864
      ptr->dirty = 0;
      }
    }
#line 873
    if (start_row > ptr->cur_start_row) {
#line 874
      ptr->cur_start_row = start_row;
    } else {
#line 879
      ltemp = (long )end_row - (long )ptr->rows_in_mem;
#line 880
      if (ltemp < 0L) {
#line 881
        ltemp = 0L;
      }
#line 882
      ptr->cur_start_row = (JDIMENSION )ltemp;
    }
    {
#line 888
    do_barray_io(cinfo, ptr, 0);
    }
  }
#line 894
  if (ptr->first_undef_row < end_row) {
#line 895
    if (ptr->first_undef_row < start_row) {
#line 896
      if (writable) {
        {
#line 897
        (cinfo->err)->msg_code = 22;
#line 897
        (*((cinfo->err)->error_exit))(cinfo);
        }
      }
#line 898
      undef_row = start_row;
    } else {
#line 900
      undef_row = ptr->first_undef_row;
    }
#line 902
    if (writable) {
#line 903
      ptr->first_undef_row = end_row;
    }
#line 904
    if (ptr->pre_zero) {
#line 905
      bytesperrow = (size_t )ptr->blocksperrow * sizeof(JBLOCK );
#line 906
      undef_row -= ptr->cur_start_row;
#line 907
      end_row -= ptr->cur_start_row;
      {
#line 908
      while (1) {
        while_continue: /* CIL Label */ ;
#line 908
        if (! (undef_row < end_row)) {
#line 908
          goto while_break;
        }
        {
#line 909
        jzero_far((void *)*(ptr->mem_buffer + undef_row), bytesperrow);
#line 910
        undef_row ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else
#line 913
    if (! writable) {
      {
#line 914
      (cinfo->err)->msg_code = 22;
#line 914
      (*((cinfo->err)->error_exit))(cinfo);
      }
    }
  }
#line 918
  if (writable) {
#line 919
    ptr->dirty = 1;
  }
#line 921
  return (ptr->mem_buffer + (start_row - ptr->cur_start_row));
}
}
#line 929 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmemmgr.c"
static void free_pool(j_common_ptr cinfo , int pool_id ) 
{ 
  my_mem_ptr mem ;
  small_pool_ptr shdr_ptr ;
  large_pool_ptr lhdr_ptr ;
  size_t space_freed ;
  jvirt_sarray_ptr sptr ;
  jvirt_barray_ptr bptr ;
  large_pool_ptr next_lhdr_ptr ;
  small_pool_ptr next_shdr_ptr ;

  {
#line 932
  mem = (my_mem_ptr )cinfo->mem;
#line 937
  if (pool_id < 0) {
    {
#line 938
    (cinfo->err)->msg_code = 14;
#line 938
    (cinfo->err)->msg_parm.i[0] = pool_id;
#line 938
    (*((cinfo->err)->error_exit))(cinfo);
    }
  } else
#line 937
  if (pool_id >= 2) {
    {
#line 938
    (cinfo->err)->msg_code = 14;
#line 938
    (cinfo->err)->msg_parm.i[0] = pool_id;
#line 938
    (*((cinfo->err)->error_exit))(cinfo);
    }
  }
#line 946
  if (pool_id == 1) {
#line 950
    sptr = mem->virt_sarray_list;
    {
#line 950
    while (1) {
      while_continue: /* CIL Label */ ;
#line 950
      if (! ((unsigned long )sptr != (unsigned long )((void *)0))) {
#line 950
        goto while_break;
      }
#line 951
      if (sptr->b_s_open) {
        {
#line 952
        sptr->b_s_open = 0;
#line 953
        (*(sptr->b_s_info.close_backing_store))(cinfo, & sptr->b_s_info);
        }
      }
#line 950
      sptr = sptr->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 956
    mem->virt_sarray_list = (jvirt_sarray_ptr )((void *)0);
#line 957
    bptr = mem->virt_barray_list;
    {
#line 957
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 957
      if (! ((unsigned long )bptr != (unsigned long )((void *)0))) {
#line 957
        goto while_break___0;
      }
#line 958
      if (bptr->b_s_open) {
        {
#line 959
        bptr->b_s_open = 0;
#line 960
        (*(bptr->b_s_info.close_backing_store))(cinfo, & bptr->b_s_info);
        }
      }
#line 957
      bptr = bptr->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 963
    mem->virt_barray_list = (jvirt_barray_ptr )((void *)0);
  }
#line 967
  lhdr_ptr = mem->large_list[pool_id];
#line 968
  mem->large_list[pool_id] = (large_pool_ptr )((void *)0);
  {
#line 970
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 970
    if (! ((unsigned long )lhdr_ptr != (unsigned long )((void *)0))) {
#line 970
      goto while_break___1;
    }
    {
#line 971
    next_lhdr_ptr = lhdr_ptr->hdr.next;
#line 972
    space_freed = (lhdr_ptr->hdr.bytes_used + lhdr_ptr->hdr.bytes_left) + sizeof(large_pool_hdr );
#line 975
    jpeg_free_large(cinfo, (void *)lhdr_ptr, space_freed);
#line 976
    mem->total_space_allocated = (long )((size_t )mem->total_space_allocated - space_freed);
#line 977
    lhdr_ptr = next_lhdr_ptr;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 981
  shdr_ptr = mem->small_list[pool_id];
#line 982
  mem->small_list[pool_id] = (small_pool_ptr )((void *)0);
  {
#line 984
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 984
    if (! ((unsigned long )shdr_ptr != (unsigned long )((void *)0))) {
#line 984
      goto while_break___2;
    }
    {
#line 985
    next_shdr_ptr = shdr_ptr->hdr.next;
#line 986
    space_freed = (shdr_ptr->hdr.bytes_used + shdr_ptr->hdr.bytes_left) + sizeof(small_pool_hdr );
#line 989
    jpeg_free_small(cinfo, (void *)shdr_ptr, space_freed);
#line 990
    mem->total_space_allocated = (long )((size_t )mem->total_space_allocated - space_freed);
#line 991
    shdr_ptr = next_shdr_ptr;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 993
  return;
}
}
#line 1001 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmemmgr.c"
static void self_destruct(j_common_ptr cinfo ) 
{ 
  int pool ;

  {
#line 1010
  pool = 1;
  {
#line 1010
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1010
    if (! (pool >= 0)) {
#line 1010
      goto while_break;
    }
    {
#line 1011
    free_pool(cinfo, pool);
#line 1010
    pool --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1015
  jpeg_free_small(cinfo, (void *)cinfo->mem, sizeof(my_memory_mgr ));
#line 1016
  cinfo->mem = (struct jpeg_memory_mgr *)((void *)0);
#line 1018
  jpeg_mem_term(cinfo);
  }
#line 1019
  return;
}
}
#line 1027 "/home/wheatley/newnew/temp/outguess-0.2/jpeg-6b-steg/jmemmgr.c"
void jinit_memory_mgr(j_common_ptr cinfo ) 
{ 
  my_mem_ptr mem ;
  long max_to_use ;
  int pool ;
  size_t test_mac ;
  void *tmp ;
  char *memenv ;
  char ch ;
  int tmp___0 ;

  {
#line 1035
  cinfo->mem = (struct jpeg_memory_mgr *)((void *)0);
#line 1044
  if ((sizeof(double ) & (sizeof(double ) - 1UL)) != 0UL) {
    {
#line 1045
    (cinfo->err)->msg_code = 2;
#line 1045
    (*((cinfo->err)->error_exit))(cinfo);
    }
  }
#line 1051
  test_mac = (size_t )1000000000L;
#line 1052
  if ((long )test_mac != 1000000000L) {
    {
#line 1054
    (cinfo->err)->msg_code = 3;
#line 1054
    (*((cinfo->err)->error_exit))(cinfo);
    }
  } else
#line 1052
  if (1000000000UL % sizeof(double ) != 0UL) {
    {
#line 1054
    (cinfo->err)->msg_code = 3;
#line 1054
    (*((cinfo->err)->error_exit))(cinfo);
    }
  }
  {
#line 1056
  max_to_use = jpeg_mem_init(cinfo);
#line 1059
  tmp = jpeg_get_small(cinfo, sizeof(my_memory_mgr ));
#line 1059
  mem = (my_mem_ptr )tmp;
  }
#line 1061
  if ((unsigned long )mem == (unsigned long )((void *)0)) {
    {
#line 1062
    jpeg_mem_term(cinfo);
#line 1063
    (cinfo->err)->msg_code = 54;
#line 1063
    (cinfo->err)->msg_parm.i[0] = 0;
#line 1063
    (*((cinfo->err)->error_exit))(cinfo);
    }
  }
#line 1067
  mem->pub.alloc_small = & alloc_small;
#line 1068
  mem->pub.alloc_large = & alloc_large;
#line 1069
  mem->pub.alloc_sarray = & alloc_sarray;
#line 1070
  mem->pub.alloc_barray = & alloc_barray;
#line 1071
  mem->pub.request_virt_sarray = & request_virt_sarray;
#line 1072
  mem->pub.request_virt_barray = & request_virt_barray;
#line 1073
  mem->pub.realize_virt_arrays = & realize_virt_arrays;
#line 1074
  mem->pub.access_virt_sarray = & access_virt_sarray;
#line 1075
  mem->pub.access_virt_barray = & access_virt_barray;
#line 1076
  mem->pub.free_pool = & free_pool;
#line 1077
  mem->pub.self_destruct = & self_destruct;
#line 1080
  mem->pub.max_alloc_chunk = 1000000000L;
#line 1083
  mem->pub.max_memory_to_use = max_to_use;
#line 1085
  pool = 1;
  {
#line 1085
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1085
    if (! (pool >= 0)) {
#line 1085
      goto while_break;
    }
#line 1086
    mem->small_list[pool] = (small_pool_ptr )((void *)0);
#line 1087
    mem->large_list[pool] = (large_pool_ptr )((void *)0);
#line 1085
    pool --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1089
  mem->virt_sarray_list = (jvirt_sarray_ptr )((void *)0);
#line 1090
  mem->virt_barray_list = (jvirt_barray_ptr )((void *)0);
#line 1092
  mem->total_space_allocated = (long )sizeof(my_memory_mgr );
#line 1095
  cinfo->mem = & mem->pub;
#line 1106
  memenv = getenv("JPEGMEM");
  }
#line 1106
  if ((unsigned long )memenv != (unsigned long )((void *)0)) {
    {
#line 1107
    ch = (char )'x';
#line 1109
    tmp___0 = sscanf((char const   */* __restrict  */)memenv, (char const   */* __restrict  */)"%ld%c",
                     & max_to_use, & ch);
    }
#line 1109
    if (tmp___0 > 0) {
#line 1110
      if ((int )ch == 109) {
#line 1111
        max_to_use *= 1000L;
      } else
#line 1110
      if ((int )ch == 77) {
#line 1111
        max_to_use *= 1000L;
      }
#line 1112
      mem->pub.max_memory_to_use = max_to_use * 1000L;
    }
  }
#line 1118
  return;
}
}
#line 38 "/home/wheatley/newnew/temp/outguess-0.2/missing/md5.c"
static uint32 getu32___0(unsigned char const   *addr ) 
{ 


  {
#line 42
  return (((((((unsigned long )*(addr + 3) << 8) | (unsigned long )*(addr + 2)) << 8) | (unsigned long )*(addr + 1)) << 8) | (unsigned long )*(addr + 0));
}
}
#line 46 "/home/wheatley/newnew/temp/outguess-0.2/missing/md5.c"
static void putu32___0(uint32 data___0 , unsigned char *addr ) 
{ 


  {
#line 51
  *(addr + 0) = (unsigned char )data___0;
#line 52
  *(addr + 1) = (unsigned char )(data___0 >> 8);
#line 53
  *(addr + 2) = (unsigned char )(data___0 >> 16);
#line 54
  *(addr + 3) = (unsigned char )(data___0 >> 24);
#line 55
  return;
}
}
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 45 "missing/err.h"
extern void err(int eval , char const   *fmt  , ...) ;
#line 10 "/home/wheatley/newnew/temp/outguess-0.2/histogram.c"
char *progname  ;
#line 12 "/home/wheatley/newnew/temp/outguess-0.2/histogram.c"
void usage(void) 
{ 


  {
  {
#line 16
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: <file>\n",
          progname);
  }
#line 17
  return;
}
}
#line 19 "/home/wheatley/newnew/temp/outguess-0.2/histogram.c"
void histogram_simple(u_char *data___0 , int bits ) 
{ 
  int i ;
  int one ;
  int zero ;

  {
#line 23
  one = 0;
#line 23
  zero = 0;
#line 25
  i = 0;
  {
#line 25
  while (1) {
    while_continue: /* CIL Label */ ;
#line 25
    if (! (i < bits)) {
#line 25
      goto while_break;
    }
#line 26
    if ((int )*(data___0 + i / 8) & (1 << (i & 7))) {
#line 27
      one ++;
    } else {
#line 29
      zero ++;
    }
#line 25
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 31
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Bits: %6d\n",
          bits);
#line 32
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"One:  %6d, %f\n",
          one, (double )((float )one / (float )bits));
#line 33
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Zero: %6d, %f\n",
          zero, (double )((float )zero / (float )bits));
  }
#line 34
  return;
}
}
#line 38 "/home/wheatley/newnew/temp/outguess-0.2/histogram.c"
void histogram_runlen(u_char *data___0 , int bits ) 
{ 
  int buckets[25] ;
  int what ;
  int count ;
  int i ;

  {
  {
#line 44
  memset((void *)(buckets), 0, sizeof(buckets));
#line 45
  what = (int )*(data___0 + 0) & 1;
#line 46
  count = 1;
#line 47
  i = 1;
  }
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (! (i < bits)) {
#line 47
      goto while_break;
    }
#line 48
    if (((int )*(data___0 + i / 8) & (1 << (i & 7))) != what) {
#line 49
      if (count >= 25) {
#line 50
        count = 24;
      }
#line 51
      (buckets[count]) ++;
#line 53
      what = (int )*(data___0 + i / 8) & (1 << (i & 7));
#line 54
      count = 1;
    } else {
#line 56
      count ++;
    }
#line 47
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 58
  if (count >= 25) {
#line 59
    count = 24;
  }
#line 60
  (buckets[count]) ++;
#line 62
  i = 1;
  {
#line 62
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 62
    if (! (i < 25)) {
#line 62
      goto while_break___0;
    }
    {
#line 63
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%3d:  %6d, %f\n",
            i, buckets[i], (double )((float )buckets[i] / (float )bits));
#line 62
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 66
  return;
}
}
