/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 16 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/option.h"
struct option {
   char flag ;
   char const   *val ;
};
#line 16 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/option.h"
typedef struct option option;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 485 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/jam.h"
struct globs {
   int noexec ;
   int jobs ;
   int quitquick ;
   int newestfirst ;
   char debug[15] ;
   FILE *cmdout ;
};
#line 47 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/lists.h"
struct _list;
#line 47 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/lists.h"
typedef struct _list LIST;
#line 49 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/lists.h"
struct _list {
   LIST *next ;
   LIST *tail ;
   char const   *string ;
};
#line 48 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char __domainname[65] ;
};
#line 59 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/lists.h"
struct _lol;
#line 59 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/lists.h"
typedef struct _lol LOL;
#line 63 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/lists.h"
struct _lol {
   int count ;
   LIST *list[9] ;
};
#line 25 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/pathsys.h"
struct _pathname;
#line 25 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/pathsys.h"
typedef struct _pathname PATHNAME;
#line 26
struct _pathpart;
#line 26 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/pathsys.h"
typedef struct _pathpart PATHPART;
#line 28 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/pathsys.h"
struct _pathpart {
   char const   *ptr ;
   int len ;
};
#line 33 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/pathsys.h"
struct _pathname {
   PATHPART part[6] ;
};
#line 39 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/expand.c"
struct __anonstruct_VAR_EDITS_50 {
   PATHNAME f ;
   char parent ;
   char filemods ;
   char downshift ;
   char upshift ;
   PATHPART empty ;
   PATHPART join ;
};
#line 39 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/expand.c"
typedef struct __anonstruct_VAR_EDITS_50 VAR_EDITS;
#line 18 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/parse.h"
struct _PARSE;
#line 18 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/parse.h"
typedef struct _PARSE PARSE;
#line 20 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/parse.h"
struct _PARSE {
   LIST *(*func)(PARSE *p , LOL *args , int *jmp ) ;
   PARSE *left ;
   PARSE *right ;
   PARSE *third ;
   char const   *string ;
   char const   *string1 ;
   int num ;
   int refs ;
};
#line 39 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/rules.h"
struct _rule;
#line 39 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/rules.h"
typedef struct _rule RULE;
#line 40
struct _target;
#line 40 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/rules.h"
typedef struct _target TARGET;
#line 41
struct _targets;
#line 41 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/rules.h"
typedef struct _targets TARGETS;
#line 42
struct _action;
#line 42 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/rules.h"
typedef struct _action ACTION;
#line 43
struct _actions;
#line 43 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/rules.h"
typedef struct _actions ACTIONS;
#line 44
struct _settings;
#line 44 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/rules.h"
typedef struct _settings SETTINGS;
#line 48 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/rules.h"
struct _rule {
   char const   *name ;
   PARSE *procedure ;
   char const   *actions ;
   LIST *bindlist ;
   LIST *params ;
   int flags ;
};
#line 68 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/rules.h"
struct _actions {
   ACTIONS *next ;
   ACTIONS *tail ;
   ACTION *action ;
};
#line 76 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/rules.h"
struct _action {
   RULE *rule ;
   TARGETS *targets ;
   TARGETS *sources ;
   char running ;
   char status ;
};
#line 86 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/rules.h"
struct _settings {
   SETTINGS *next ;
   char const   *symbol ;
   LIST *value ;
};
#line 94 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/rules.h"
struct _targets {
   TARGETS *next ;
   TARGETS *tail ;
   TARGET *target ;
};
#line 102 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/rules.h"
struct _target {
   char const   *name ;
   char const   *boundname ;
   ACTIONS *actions ;
   SETTINGS *settings ;
   char flags ;
   char binding ;
   TARGETS *depends ;
   TARGET *includes ;
   time_t time ;
   time_t leaf ;
   char fate ;
   char progress ;
   char status ;
   int asynccnt ;
   TARGETS *parents ;
   char *cmds ;
};
#line 70 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make.c"
struct __anonstruct_COUNTS_50 {
   int temp ;
   int updating ;
   int cantfind ;
   int cantmake ;
   int targets ;
   int made ;
};
#line 70 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make.c"
typedef struct __anonstruct_COUNTS_50 COUNTS;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 69 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/execunix.c"
struct __anonstruct_cmdtab_50 {
   int pid ;
   void (*func)(void *closure , int status ) ;
   void *closure ;
};
#line 34 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/scan.h"
struct _YYSTYPE {
   int type ;
   char const   *string ;
   PARSE *parse ;
   LIST *list ;
   int number ;
};
#line 34 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/scan.h"
typedef struct _YYSTYPE YYSYMBOL;
#line 264 "y.tab.c"
union yyalloc {
   short yyss ;
   YYSYMBOL yyvs ;
};
#line 316 "y.tab.c"
typedef signed char yysigned_char;
#line 13 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/hash.h"
struct hashdata;
#line 13 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/hash.h"
typedef struct hashdata HASHDATA;
#line 15
struct hash;
#line 33 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/newstr.c"
typedef char const   *STRING;
#line 11 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/regexp.h"
struct regexp {
   char const   *startp[10] ;
   char const   *endp[10] ;
   char regstart ;
   char reganch ;
   char *regmust ;
   int regmlen ;
   char program[1] ;
};
#line 11 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/regexp.h"
typedef struct regexp regexp;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 35 "/usr/include/ar.h"
struct ar_hdr {
   char ar_name[16] ;
   char ar_date[12] ;
   char ar_uid[6] ;
   char ar_gid[6] ;
   char ar_mode[8] ;
   char ar_size[10] ;
   char ar_fmag[2] ;
};
#line 38 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/command.h"
struct _cmd;
#line 38 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/command.h"
typedef struct _cmd CMD;
#line 40 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/command.h"
struct _cmd {
   CMD *next ;
   CMD *tail ;
   RULE *rule ;
   LIST *shell ;
   LOL args ;
   char buf[10240] ;
};
#line 30 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/hash.c"
struct item;
#line 30 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/hash.c"
struct hashhdr {
   struct item *next ;
   unsigned int keyval ;
};
#line 38 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/hash.c"
struct hashdata {
   char *key ;
};
#line 43 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/hash.c"
struct item {
   struct hashhdr hdr ;
   struct hashdata data ;
};
#line 43 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/hash.c"
typedef struct item ITEM;
#line 50 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/hash.c"
struct __anonstruct_tab_50 {
   int nel ;
   ITEM **base ;
};
#line 50 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/hash.c"
struct __anonstruct_lists_52 {
   int nel ;
   char *base ;
};
#line 50 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/hash.c"
struct __anonstruct_items_51 {
   int more ;
   char *next ;
   int datalen ;
   int size ;
   int nel ;
   int list ;
   struct __anonstruct_lists_52 lists[32] ;
};
#line 50 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/hash.c"
struct hash {
   struct __anonstruct_tab_50 tab ;
   int bloat ;
   int inel ;
   struct __anonstruct_items_51 items ;
   char const   *name ;
};
#line 217 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/builtins.c"
struct globbing {
   LIST *patterns ;
   LIST *results ;
};
#line 77 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make1.c"
struct __anonstruct_counts_50 {
   int failed ;
   int skipped ;
   int total ;
   int made ;
};
#line 30 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/scan.c"
struct keyword {
   char const   *word ;
   int type ;
};
#line 38 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/scan.c"
struct include {
   struct include *next ;
   char const   *string ;
   char **strings ;
   FILE *file ;
   char const   *fname ;
   int line ;
   char buf[512] ;
};
#line 47 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/variable.c"
struct _variable;
#line 47 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/variable.c"
typedef struct _variable VARIABLE;
#line 49 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/variable.c"
struct _variable {
   char const   *symbol ;
   LIST *value ;
};
#line 69 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/execunix.c"
struct __anonstruct_cmdtab_50___0 {
   int pid ;
   void (*func)(void *closure , int status ) ;
   void *closure ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/timestamp.c"
struct _binding;
#line 26 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/timestamp.c"
typedef struct _binding BINDING;
#line 28 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/timestamp.c"
struct _binding {
   char const   *name ;
   short flags ;
   short progress ;
   time_t time ;
};
#line 77 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make1.c"
struct __anonstruct_counts_50___0 {
   int failed ;
   int skipped ;
   int total ;
   int made ;
};
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/mkjambase.c"
int main(int argc , char **argv , char **envp ) 
{ 
  char buf___0[1024] ;
  FILE *fin ;
  FILE *fout ;
  char *p ;
  int doDotC ;
  int tmp ;
  char *p___0 ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 33
  doDotC = 0;
#line 35
  if (argc < 3) {
    {
#line 37
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: %s jambase.c Jambase ...\n",
            *(argv + 0));
    }
#line 38
    return (-1);
  }
  {
#line 41
  fout = fopen((char const   */* __restrict  */)*(argv + 1), (char const   */* __restrict  */)"w");
  }
#line 41
  if (! fout) {
    {
#line 43
    perror((char const   *)*(argv + 1));
    }
#line 44
    return (-1);
  }
  {
#line 49
  p = strrchr((char const   *)*(argv + 1), '.');
  }
#line 49
  if (p) {
    {
#line 49
    tmp = strcmp((char const   *)p, ".c");
    }
#line 49
    if (! tmp) {
#line 50
      doDotC ++;
    }
  }
#line 54
  argc -= 2;
#line 54
  argv += 2;
#line 56
  if (doDotC) {
    {
#line 58
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"/* Generated by mkjambase from Jambase */\n");
#line 59
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"const char *jambase[] = {\n");
    }
  }
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    tmp___1 = argc;
#line 62
    argc --;
#line 62
    if (! tmp___1) {
#line 62
      goto while_break;
    }
    {
#line 64
    fin = fopen((char const   */* __restrict  */)*argv, (char const   */* __restrict  */)"r");
    }
#line 64
    if (! fin) {
      {
#line 66
      perror((char const   *)*argv);
      }
#line 67
      return (-1);
    }
#line 70
    if (doDotC) {
      {
#line 72
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"/* %s */\n",
              *argv);
      }
    } else {
      {
#line 76
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"### %s ###\n",
              *argv);
      }
    }
    {
#line 79
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 79
      tmp___0 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fin);
      }
#line 79
      if (! tmp___0) {
#line 79
        goto while_break___0;
      }
#line 81
      if (doDotC) {
#line 83
        p___0 = buf___0;
        {
#line 87
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 87
          if (! ((int )*p___0 == 32)) {
#line 87
            if (! ((int )*p___0 == 9)) {
#line 87
              if (! ((int )*p___0 == 10)) {
#line 87
                goto while_break___1;
              }
            }
          }
#line 88
          p___0 ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 92
        if ((int )*p___0 == 35) {
#line 93
          goto while_continue___0;
        } else
#line 92
        if (! *p___0) {
#line 93
          goto while_continue___0;
        }
        {
#line 97
        _IO_putc('\"', fout);
        }
        {
#line 99
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 99
          if (*p___0) {
#line 99
            if (! ((int )*p___0 != 10)) {
#line 99
              goto while_break___2;
            }
          } else {
#line 99
            goto while_break___2;
          }
          {
#line 102
          if ((int )*p___0 == 92) {
#line 102
            goto case_92;
          }
#line 103
          if ((int )*p___0 == 34) {
#line 103
            goto case_34;
          }
#line 104
          goto switch_default;
          case_92: /* CIL Label */ 
          {
#line 102
          _IO_putc('\\', fout);
#line 102
          _IO_putc('\\', fout);
          }
#line 102
          goto switch_break;
          case_34: /* CIL Label */ 
          {
#line 103
          _IO_putc('\\', fout);
#line 103
          _IO_putc('\"', fout);
          }
#line 103
          goto switch_break;
          switch_default: /* CIL Label */ 
          {
#line 104
          _IO_putc((int )*p___0, fout);
          }
#line 104
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
#line 99
          p___0 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 107
        fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\\n\",\n");
        }
      } else {
        {
#line 111
        fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%s",
                buf___0);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 116
    fclose(fin);
#line 62
    argv ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  if (doDotC) {
    {
#line 120
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"0 };\n");
    }
  }
  {
#line 122
  fclose(fout);
  }
#line 124
  return (0);
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/option.h"
int getoptions(int argc , char **argv , char const   *opts , option *optv ) ;
#line 25
char const   *getoptval(option *optv , char opt , int subopt ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/option.c"
int getoptions(int argc , char **argv , char const   *opts , option *optv ) 
{ 
  int i ;
  int optc ;
  char *arg ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  char const   *f ;
  option *tmp___1 ;
  option *tmp___2 ;
  option *tmp___3 ;

  {
  {
#line 30
  optc = 256;
#line 32
  memset((void *)((char *)optv), '\000', sizeof(*optv) * 256UL);
#line 34
  i = 0;
  }
  {
#line 34
  while (1) {
    while_continue: /* CIL Label */ ;
#line 34
    if (! (i < argc)) {
#line 34
      goto while_break;
    }
#line 38
    if ((int )*(*(argv + i) + 0) != 45) {
#line 39
      goto while_break;
    } else {
      {
#line 38
      tmp = __ctype_b_loc();
      }
#line 38
      if (! ((int const   )*(*tmp + (int )*(*(argv + i) + 1)) & 1024)) {
#line 39
        goto while_break;
      }
    }
#line 41
    tmp___0 = optc;
#line 41
    optc --;
#line 41
    if (! tmp___0) {
      {
#line 43
      printf((char const   */* __restrict  */)"too many options (%d max)\n", 256);
      }
#line 44
      return (-1);
    }
#line 47
    arg = *(argv + i) + 1;
    {
#line 47
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 47
      if (! *arg) {
#line 47
        goto while_break___0;
      }
#line 51
      f = opts;
      {
#line 51
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 51
        if (! *f) {
#line 51
          goto while_break___1;
        }
#line 52
        if ((int const   )*f == (int const   )*arg) {
#line 53
          goto while_break___1;
        }
#line 51
        f ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 55
      if (! *f) {
        {
#line 57
        printf((char const   */* __restrict  */)"Invalid option: -%c\n", (int )*arg);
        }
#line 58
        return (-1);
      }
#line 61
      optv->flag = (char )*f;
#line 63
      if ((int const   )*(f + 1) != 58) {
#line 65
        tmp___1 = optv;
#line 65
        optv ++;
#line 65
        tmp___1->val = "true";
      } else
#line 67
      if (*(arg + 1)) {
#line 69
        tmp___2 = optv;
#line 69
        optv ++;
#line 69
        tmp___2->val = (char const   *)(arg + 1);
#line 70
        goto while_break___0;
      } else {
#line 72
        i ++;
#line 72
        if (i < argc) {
#line 74
          tmp___3 = optv;
#line 74
          optv ++;
#line 74
          tmp___3->val = (char const   *)*(argv + i);
#line 75
          goto while_break___0;
        } else {
          {
#line 79
          printf((char const   */* __restrict  */)"option: -%c needs argument\n",
                 (int const   )*f);
          }
#line 80
          return (-1);
        }
      }
#line 47
      arg ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 34
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  return (i);
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/option.c"
char const   *getoptval(option *optv , char opt , int subopt ) 
{ 
  int i ;
  int tmp ;

  {
#line 100
  i = 0;
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! (i < 256)) {
#line 100
      goto while_break;
    }
#line 101
    if ((int )optv->flag == (int )opt) {
#line 101
      tmp = subopt;
#line 101
      subopt --;
#line 101
      if (! tmp) {
#line 102
        return (optv->val);
      }
    }
#line 100
    i ++;
#line 100
    optv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  return ((char const   *)0);
}
}
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 264
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 494 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/jam.h"
struct globs globs ;
#line 71 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/lists.h"
LIST *list_new(LIST *head , char const   *string , int copy ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/parse.h"
void parse_file(char const   *f ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/variable.h"
void var_defines(char const   **e ) ;
#line 16
void var_set(char const   *symbol , LIST *value , int flag ) ;
#line 18
void var_done(void) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/builtins.h"
void load_builtins(void) ;
#line 170 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/rules.h"
void touchtarget(char const   *t ) ;
#line 180
void donerules(void) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/newstr.h"
void donestr(void) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/scan.h"
int yyanyerrors(void) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/timestamp.h"
void donestamps(void) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make.h"
int make(int n_targets , char const   **targets , int anyhow ) ;
#line 81 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) uname)(struct utsname *__name ) ;
#line 133 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/jam.c"
struct globs globs  =    {0, 1, 0, 0, {(char)0, (char)1}, (FILE *)0};
#line 148 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/jam.c"
static char const   *othersyms[5]  = {      "UNIX=true",      "OS=LINUX",      "",      "JAMVERSION=2.5", 
        (char const   *)0};
#line 165
extern char **environ ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 69 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/lists.h"
LIST *list_copy(LIST *l , LIST *nl ) ;
#line 70
void list_free(LIST *head ) ;
#line 72
void list_print(LIST *l ) ;
#line 83
LIST *lol_get(LOL *lol , int i ) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/variable.h"
LIST *var_get(char const   *symbol ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/expand.h"
LIST *var_expand(LIST *l , char const   *in , char const   *end , LOL *lol , int cancopyin ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/pathsys.h"
void path_build(PATHNAME *f , char *file , int binding ) ;
#line 49
void path_parse(char const   *file , PATHNAME *f ) ;
#line 50
void path_parent(PATHNAME *f ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/expand.c"
static void var_edit_parse(char const   *mods , VAR_EDITS *edits ) ;
#line 50
static void var_edit_file(char const   *in , char *out , VAR_EDITS *edits ) ;
#line 51
static void var_edit_shift(char *out , VAR_EDITS *edits ) ;
#line 69 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/expand.c"
LIST *var_expand(LIST *l , char const   *in , char const   *end , LOL *lol , int cancopyin ) 
{ 
  char out_buf[1024] ;
  char *out ;
  char const   *inp ;
  char *ov ;
  int depth ;
  LIST *tmp ;
  LIST *tmp___0 ;
  LIST *tmp___1 ;
  LIST *tmp___2 ;
  char *tmp___3 ;
  char tmp___4 ;
  char const   *tmp___5 ;
  LIST *tmp___6 ;
  LIST *tmp___7 ;
  char *tmp___8 ;
  char tmp___9 ;
  char const   *tmp___10 ;
  LIST *variables ;
  LIST *remainder ;
  LIST *vars ;
  LIST *value ;
  LIST *evalue ;
  char *colon ;
  char *bracket ;
  char varname[1024] ;
  int sub1 ;
  int sub2 ;
  VAR_EDITS edits ;
  char *dash ;
  int tmp___11 ;
  int tmp___12 ;
  LIST *rem ;
  char *out1 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;

  {
#line 78
  out = out_buf;
#line 79
  inp = in;
#line 83
  if (globs.debug[8]) {
    {
#line 84
    printf((char const   */* __restrict  */)"expand \'%.*s\'\n", end - in, in);
    }
  }
#line 88
  if (end - in == 4L) {
#line 88
    if ((int const   )*(in + 0) == 36) {
#line 88
      if ((int const   )*(in + 1) == 40) {
#line 88
        if ((int const   )*(in + 3) == 41) {
          {
#line 93
          if ((int const   )*(in + 2) == 60) {
#line 93
            goto case_60;
          }
#line 93
          if ((int const   )*(in + 2) == 49) {
#line 93
            goto case_60;
          }
#line 97
          if ((int const   )*(in + 2) == 62) {
#line 97
            goto case_62;
          }
#line 97
          if ((int const   )*(in + 2) == 50) {
#line 97
            goto case_62;
          }
#line 90
          goto switch_break;
          case_60: /* CIL Label */ 
          case_49: /* CIL Label */ 
          {
#line 94
          tmp = lol_get(lol, 0);
#line 94
          tmp___0 = list_copy(l, tmp);
          }
#line 94
          return (tmp___0);
          case_62: /* CIL Label */ 
          case_50: /* CIL Label */ 
          {
#line 98
          tmp___1 = lol_get(lol, 1);
#line 98
          tmp___2 = list_copy(l, tmp___1);
          }
#line 98
          return (tmp___2);
          switch_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (! ((unsigned long )in < (unsigned long )end)) {
#line 104
      goto while_break;
    }
#line 105
    tmp___3 = out;
#line 105
    out ++;
#line 105
    tmp___5 = in;
#line 105
    in ++;
#line 105
    tmp___4 = (char )*tmp___5;
#line 105
    *tmp___3 = tmp___4;
#line 105
    if ((int )tmp___4 == 36) {
#line 105
      if ((int const   )*in == 40) {
#line 106
        goto expand;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  *out = (char )'\000';
#line 116
  if (cancopyin) {
    {
#line 117
    tmp___6 = list_new(l, inp, 1);
    }
#line 117
    return (tmp___6);
  } else {
    {
#line 119
    tmp___7 = list_new(l, (char const   *)(out_buf), 0);
    }
#line 119
    return (tmp___7);
  }
  expand: 
#line 143
  depth = 1;
#line 144
  out --;
#line 144
  in ++;
#line 145
  ov = out;
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 147
    if ((unsigned long )in < (unsigned long )end) {
#line 147
      if (! depth) {
#line 147
        goto while_break___0;
      }
    } else {
#line 147
      goto while_break___0;
    }
#line 149
    tmp___8 = ov;
#line 149
    ov ++;
#line 149
    tmp___10 = in;
#line 149
    in ++;
#line 149
    tmp___9 = (char )*tmp___10;
#line 149
    *tmp___8 = tmp___9;
    {
#line 151
    if ((int )tmp___9 == 40) {
#line 151
      goto case_40;
    }
#line 152
    if ((int )tmp___9 == 41) {
#line 152
      goto case_41;
    }
#line 153
    if ((int )tmp___9 == 58) {
#line 153
      goto case_58;
    }
#line 154
    if ((int )tmp___9 == 91) {
#line 154
      goto case_91;
    }
#line 155
    if ((int )tmp___9 == 93) {
#line 155
      goto case_93;
    }
#line 149
    goto switch_break___0;
    case_40: /* CIL Label */ 
#line 151
    depth ++;
#line 151
    goto switch_break___0;
    case_41: /* CIL Label */ 
#line 152
    depth --;
#line 152
    goto switch_break___0;
    case_58: /* CIL Label */ 
#line 153
    *(ov + -1) = (char )'\001';
#line 153
    goto switch_break___0;
    case_91: /* CIL Label */ 
#line 154
    *(ov + -1) = (char )'\002';
#line 154
    goto switch_break___0;
    case_93: /* CIL Label */ 
#line 155
    *(ov + -1) = (char )'\003';
#line 155
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 161
  ov --;
#line 182
  variables = (LIST *)0;
#line 183
  remainder = (LIST *)0;
#line 188
  if ((unsigned long )out < (unsigned long )ov) {
    {
#line 189
    variables = var_expand((LIST *)0, (char const   *)out, (char const   *)ov, lol,
                           0);
    }
  }
#line 190
  if ((unsigned long )in < (unsigned long )end) {
    {
#line 191
    remainder = var_expand((LIST *)0, in, end, lol, 0);
    }
  }
#line 197
  vars = variables;
  {
#line 197
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 197
    if (! vars) {
#line 197
      goto while_break___1;
    }
    {
#line 199
    evalue = (LIST *)0;
#line 203
    sub1 = 0;
#line 203
    sub2 = -1;
#line 209
    strcpy((char */* __restrict  */)(varname), (char const   */* __restrict  */)vars->string);
#line 211
    colon = strchr((char const   *)(varname), '\001');
    }
#line 211
    if (colon) {
      {
#line 213
      *colon = (char )'\000';
#line 214
      var_edit_parse((char const   *)(colon + 1), & edits);
      }
    }
    {
#line 221
    bracket = strchr((char const   *)(varname), '\002');
    }
#line 221
    if (bracket) {
      {
#line 225
      dash = strchr((char const   *)(bracket + 1), '-');
      }
#line 225
      if (dash) {
#line 226
        *dash = (char )'\000';
      }
      {
#line 228
      tmp___11 = atoi((char const   *)(bracket + 1));
#line 228
      sub1 = tmp___11 - 1;
      }
#line 230
      if (! dash) {
#line 231
        sub2 = 1;
      } else
#line 232
      if (! *(dash + 1)) {
#line 233
        sub2 = -1;
      } else
#line 232
      if ((int )*(dash + 1) == 3) {
#line 233
        sub2 = -1;
      } else {
        {
#line 235
        tmp___12 = atoi((char const   *)(dash + 1));
#line 235
        sub2 = tmp___12 - sub1;
        }
      }
#line 237
      *bracket = (char )'\000';
    }
#line 242
    if ((int )varname[0] == 60) {
#line 242
      if (! varname[1]) {
        {
#line 243
        value = lol_get(lol, 0);
        }
      } else {
#line 242
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 244
    if ((int )varname[0] == 62) {
#line 244
      if (! varname[1]) {
        {
#line 245
        value = lol_get(lol, 1);
        }
      } else {
#line 244
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 246
    if ((int )varname[0] >= 49) {
#line 246
      if ((int )varname[0] <= 57) {
#line 246
        if (! varname[1]) {
          {
#line 247
          value = lol_get(lol, (int )varname[0] - 49);
          }
        } else {
          {
#line 249
          value = var_get((char const   *)(varname));
          }
        }
      } else {
        {
#line 249
        value = var_get((char const   *)(varname));
        }
      }
    } else {
      {
#line 249
      value = var_get((char const   *)(varname));
      }
    }
#line 254
    if ((unsigned long )out == (unsigned long )(out_buf)) {
#line 254
      if (! bracket) {
#line 254
        if (! colon) {
#line 254
          if ((unsigned long )in == (unsigned long )end) {
            {
#line 256
            l = list_copy(l, value);
            }
#line 257
            goto __Cont;
          }
        }
      }
    }
    {
#line 262
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 262
      if (sub1 > 0) {
#line 262
        if (! value) {
#line 262
          goto while_break___2;
        }
      } else {
#line 262
        goto while_break___2;
      }
#line 263
      sub1 --;
#line 263
      value = value->next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 267
    if (! value) {
#line 267
      if (colon) {
#line 267
        if (edits.empty.ptr) {
          {
#line 268
          value = list_new((LIST *)0, edits.empty.ptr, 0);
#line 268
          evalue = value;
          }
        }
      }
    }
    {
#line 272
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 272
      if (! value) {
#line 272
        goto while_break___3;
      }
#line 279
      if (sub2 >= 0) {
#line 279
        sub2 --;
#line 279
        if (sub2 < 0) {
#line 280
          goto while_break___3;
        }
      }
#line 284
      if (colon) {
#line 284
        if (edits.filemods) {
          {
#line 285
          var_edit_file(value->string, out, & edits);
          }
        } else {
          {
#line 287
          strcpy((char */* __restrict  */)out, (char const   */* __restrict  */)value->string);
          }
        }
      } else {
        {
#line 287
        strcpy((char */* __restrict  */)out, (char const   */* __restrict  */)value->string);
        }
      }
#line 289
      if (colon) {
#line 289
        if (edits.upshift) {
          {
#line 290
          var_edit_shift(out, & edits);
          }
        } else
#line 289
        if (edits.downshift) {
          {
#line 290
          var_edit_shift(out, & edits);
          }
        }
      }
#line 297
      if (colon) {
#line 297
        if (edits.join.ptr) {
#line 297
          if (value->next) {
#line 297
            goto _L___1;
          } else
#line 297
          if (vars->next) {
            _L___1: /* CIL Label */ 
            {
#line 300
            tmp___13 = strlen((char const   *)out);
#line 300
            out += tmp___13;
#line 301
            strcpy((char */* __restrict  */)out, (char const   */* __restrict  */)edits.join.ptr);
#line 302
            tmp___14 = strlen((char const   *)out);
#line 302
            out += tmp___14;
            }
#line 303
            goto __Cont___0;
          }
        }
      }
#line 308
      if ((unsigned long )in == (unsigned long )end) {
        {
#line 310
        l = list_new(l, (char const   *)(out_buf), 0);
        }
#line 311
        goto __Cont___0;
      }
      {
#line 319
      tmp___15 = strlen((char const   *)out);
#line 319
      out1 = out + tmp___15;
#line 321
      rem = remainder;
      }
      {
#line 321
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 321
        if (! rem) {
#line 321
          goto while_break___4;
        }
        {
#line 323
        strcpy((char */* __restrict  */)out1, (char const   */* __restrict  */)rem->string);
#line 324
        l = list_new(l, (char const   *)(out_buf), 0);
#line 321
        rem = rem->next;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      __Cont___0: /* CIL Label */ 
#line 272
      value = value->next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 330
    if (evalue) {
      {
#line 331
      list_free(evalue);
      }
    }
    __Cont: /* CIL Label */ 
#line 197
    vars = vars->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 337
  if (variables) {
    {
#line 338
    list_free(variables);
    }
  }
#line 339
  if (remainder) {
    {
#line 340
    list_free(remainder);
    }
  }
#line 342
  if (globs.debug[8]) {
    {
#line 344
    printf((char const   */* __restrict  */)"expanded to ");
#line 345
    list_print(l);
#line 346
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 349
  return (l);
}
}
#line 388 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/expand.c"
static void var_edit_parse(char const   *mods , VAR_EDITS *edits ) 
{ 
  int havezeroed ;
  char *p ;
  PATHPART *fp ;
  char const   *tmp ;
  char tmp___0 ;
  int i ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 393
  havezeroed = 0;
#line 394
  memset((void *)((char *)edits), 0, sizeof(*edits));
  }
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 396
    if (! *mods) {
#line 396
      goto while_break;
    }
#line 401
    tmp = mods;
#line 401
    mods ++;
    {
#line 403
    if ((int const   )*tmp == 76) {
#line 403
      goto case_76;
    }
#line 404
    if ((int const   )*tmp == 85) {
#line 404
      goto case_85;
    }
#line 405
    if ((int const   )*tmp == 80) {
#line 405
      goto case_80;
    }
#line 406
    if ((int const   )*tmp == 69) {
#line 406
      goto case_69;
    }
#line 407
    if ((int const   )*tmp == 74) {
#line 407
      goto case_74;
    }
#line 408
    if ((int const   )*tmp == 71) {
#line 408
      goto case_71;
    }
#line 409
    if ((int const   )*tmp == 82) {
#line 409
      goto case_82;
    }
#line 410
    if ((int const   )*tmp == 68) {
#line 410
      goto case_68;
    }
#line 411
    if ((int const   )*tmp == 66) {
#line 411
      goto case_66;
    }
#line 412
    if ((int const   )*tmp == 83) {
#line 412
      goto case_83;
    }
#line 413
    if ((int const   )*tmp == 77) {
#line 413
      goto case_77;
    }
#line 415
    goto switch_default;
    case_76: /* CIL Label */ 
#line 403
    edits->downshift = (char)1;
#line 403
    goto while_continue;
    case_85: /* CIL Label */ 
#line 404
    edits->upshift = (char)1;
#line 404
    goto while_continue;
    case_80: /* CIL Label */ 
#line 405
    tmp___0 = (char)1;
#line 405
    edits->filemods = tmp___0;
#line 405
    edits->parent = tmp___0;
#line 405
    goto while_continue;
    case_69: /* CIL Label */ 
#line 406
    fp = & edits->empty;
#line 406
    goto strval;
    case_74: /* CIL Label */ 
#line 407
    fp = & edits->join;
#line 407
    goto strval;
    case_71: /* CIL Label */ 
#line 408
    fp = & edits->f.part[0];
#line 408
    goto fileval;
    case_82: /* CIL Label */ 
#line 409
    fp = & edits->f.part[1];
#line 409
    goto fileval;
    case_68: /* CIL Label */ 
#line 410
    fp = & edits->f.part[2];
#line 410
    goto fileval;
    case_66: /* CIL Label */ 
#line 411
    fp = & edits->f.part[3];
#line 411
    goto fileval;
    case_83: /* CIL Label */ 
#line 412
    fp = & edits->f.part[4];
#line 412
    goto fileval;
    case_77: /* CIL Label */ 
#line 413
    fp = & edits->f.part[5];
#line 413
    goto fileval;
    switch_default: /* CIL Label */ 
#line 415
    return;
    switch_break: /* CIL Label */ ;
    }
    fileval: 
#line 425
    edits->filemods = (char)1;
#line 427
    if ((int const   )*mods != 61) {
#line 431
      tmp___1 = havezeroed;
#line 431
      havezeroed ++;
#line 431
      if (! tmp___1) {
#line 432
        i = 0;
        {
#line 432
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 432
          if (! (i < 6)) {
#line 432
            goto while_break___0;
          }
#line 434
          edits->f.part[i].len = 0;
#line 435
          edits->f.part[i].ptr = "";
#line 432
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 438
      fp->ptr = (char const   *)0;
#line 439
      goto while_continue;
    }
    strval: 
#line 446
    if ((int const   )*mods != 61) {
#line 448
      fp->ptr = "";
#line 449
      fp->len = 0;
    } else {
      {
#line 451
      p = strchr(mods, '\001');
      }
#line 451
      if (p) {
#line 453
        *p = (char)0;
#line 454
        mods ++;
#line 454
        fp->ptr = mods;
#line 455
        fp->len = (int )(p - (char *)mods);
#line 456
        mods = (char const   *)(p + 1);
      } else {
        {
#line 460
        mods ++;
#line 460
        fp->ptr = mods;
#line 461
        tmp___2 = strlen(mods);
#line 461
        fp->len = (int )tmp___2;
#line 462
        mods += fp->len;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 465
  return;
}
}
#line 471 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/expand.c"
static void var_edit_file(char const   *in , char *out , VAR_EDITS *edits ) 
{ 
  PATHNAME pathname ;

  {
  {
#line 481
  path_parse(in, & pathname);
  }
#line 485
  if (edits->f.part[0].ptr) {
#line 486
    pathname.part[0] = edits->f.part[0];
  }
#line 488
  if (edits->f.part[1].ptr) {
#line 489
    pathname.part[1] = edits->f.part[1];
  }
#line 491
  if (edits->f.part[2].ptr) {
#line 492
    pathname.part[2] = edits->f.part[2];
  }
#line 494
  if (edits->f.part[3].ptr) {
#line 495
    pathname.part[3] = edits->f.part[3];
  }
#line 497
  if (edits->f.part[4].ptr) {
#line 498
    pathname.part[4] = edits->f.part[4];
  }
#line 500
  if (edits->f.part[5].ptr) {
#line 501
    pathname.part[5] = edits->f.part[5];
  }
#line 505
  if (edits->parent) {
    {
#line 506
    path_parent(& pathname);
    }
  }
  {
#line 510
  path_build(& pathname, out, 0);
  }
#line 511
  return;
}
}
#line 517 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/expand.c"
static void var_edit_shift(char *out , VAR_EDITS *edits ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 524
  if (edits->upshift) {
    {
#line 526
    while (1) {
      while_continue: /* CIL Label */ ;
#line 526
      if (! *out) {
#line 526
        goto while_break;
      }
      {
#line 527
      tmp = toupper((int )*out);
#line 527
      *out = (char )tmp;
#line 526
      out ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 529
  if (edits->downshift) {
    {
#line 531
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 531
      if (! *out) {
#line 531
        goto while_break___0;
      }
      {
#line 532
      tmp___0 = tolower((int )*out);
#line 532
      *out = (char )tmp___0;
#line 531
      out ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 534
  return;
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/rules.h"
TARGET *bindtarget(char const   *targetname ) ;
#line 172
TARGETS *targetentry(TARGETS *chain , TARGET *target ) ;
#line 173
TARGETS *targetchain(TARGETS *chain , TARGETS *targets ) ;
#line 176
SETTINGS *copysettings(SETTINGS *from ) ;
#line 177
void pushsettings(SETTINGS *v ) ;
#line 178
void popsettings(SETTINGS *v ) ;
#line 179
void freesettings(SETTINGS *v ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/search.h"
char const   *search(char const   *target , time_t *time___0 ) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make.h"
int make1(TARGET *t ) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/headers.h"
void headers(TARGET *t ) ;
#line 79 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make.c"
static void make0(TARGET *t , TARGET *p , int depth , COUNTS *counts___1 , int anyhow ) ;
#line 82
static TARGETS *make0sort(TARGETS *chain ) ;
#line 84 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make.c"
static char const   *target_fate[12]  = 
#line 84
  {      "init",      "making",      "stable",      "newer", 
        "temp",      "touched",      "missing",      "needtmp", 
        "old",      "update",      "nofind",      "nomake"};
#line 100 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make.c"
static char const   *target_bind[4]  = {      "unbound",      "missing",      "parents",      "exists"};
#line 114 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make.c"
int make(int n_targets , char const   **targets , int anyhow ) 
{ 
  int i ;
  COUNTS counts___1[1] ;
  int status ;
  TARGET *t ;
  TARGET *tmp ;
  int tmp___0 ;
  TARGET *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 122
  status = 0;
#line 124
  memset((void *)((char *)(counts___1)), 0, sizeof(counts___1[0]));
#line 126
  i = 0;
  }
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if (! (i < n_targets)) {
#line 126
      goto while_break;
    }
    {
#line 128
    tmp = bindtarget(*(targets + i));
#line 128
    t = tmp;
#line 130
    make0(t, (TARGET *)0, 0, counts___1, anyhow);
#line 126
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  if (globs.debug[1]) {
#line 135
    if (counts___1[0].targets) {
      {
#line 136
      printf((char const   */* __restrict  */)"...found %d target(s)...\n", counts___1[0].targets);
      }
    }
#line 137
    if (counts___1[0].temp) {
      {
#line 138
      printf((char const   */* __restrict  */)"...using %d temp target(s)...\n", counts___1[0].temp);
      }
    }
#line 139
    if (counts___1[0].updating) {
      {
#line 140
      printf((char const   */* __restrict  */)"...updating %d target(s)...\n", counts___1[0].updating);
      }
    }
#line 141
    if (counts___1[0].cantfind) {
      {
#line 142
      printf((char const   */* __restrict  */)"...can\'t find %d target(s)...\n",
             counts___1[0].cantfind);
      }
    }
#line 143
    if (counts___1[0].cantmake) {
      {
#line 144
      printf((char const   */* __restrict  */)"...can\'t make %d target(s)...\n",
             counts___1[0].cantmake);
      }
    }
  }
#line 147
  if (counts___1[0].cantfind) {
#line 147
    tmp___0 = 1;
  } else
#line 147
  if (counts___1[0].cantmake) {
#line 147
    tmp___0 = 1;
  } else {
#line 147
    tmp___0 = 0;
  }
#line 147
  status = tmp___0;
#line 149
  i = 0;
  {
#line 149
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 149
    if (! (i < n_targets)) {
#line 149
      goto while_break___0;
    }
    {
#line 150
    tmp___1 = bindtarget(*(targets + i));
#line 150
    tmp___2 = make1(tmp___1);
#line 150
    status |= tmp___2;
#line 149
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 152
  return (status);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make.c"
static void make0(TARGET *t , TARGET *p , int depth , COUNTS *counts___1 , int anyhow ) 
{ 
  TARGETS *c ;
  TARGETS *incs ;
  TARGET *ptime ;
  time_t last ;
  time_t leaf ;
  time_t hlast ;
  int fate ;
  char const   *flag ;
  SETTINGS *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int internal ;
  char const   *tmp___5 ;
  int tmp___6 ;

  {
#line 171
  ptime = t;
#line 174
  flag = "";
#line 181
  if (globs.debug[3]) {
#line 182
    if (depth > 16) {
#line 182
      tmp = 16;
    } else {
#line 182
      tmp = depth;
    }
    {
#line 182
    printf((char const   */* __restrict  */)"make\t--\t%s%s\n", ("                " + 16) - tmp,
           t->name);
    }
  }
  {
#line 184
  t->fate = (char)1;
#line 193
  s = copysettings(t->settings);
#line 194
  pushsettings(s);
  }
#line 198
  if ((int )t->binding == 0) {
#line 198
    if (! ((int )t->flags & 4)) {
      {
#line 200
      t->boundname = search(t->name, & t->time);
      }
#line 201
      if (t->time) {
#line 201
        t->binding = (char)3;
      } else {
#line 201
        t->binding = (char)1;
      }
    }
  }
#line 206
  if (p) {
#line 206
    if ((int )t->flags & 64) {
#line 207
      ptime = p;
    }
  }
#line 211
  if (p) {
#line 211
    if ((int )t->flags & 1) {
#line 211
      if ((int )t->binding == 1) {
#line 211
        if ((int )p->binding != 1) {
#line 215
          t->binding = (char)2;
#line 216
          ptime = p;
        }
      }
    }
  }
#line 221
  if ((int )t->binding == 3) {
    {
#line 222
    headers(t);
    }
  }
  {
#line 226
  popsettings(s);
#line 227
  freesettings(s);
  }
#line 233
  if (globs.debug[3]) {
    {
#line 235
    tmp___1 = strcmp(t->name, t->boundname);
    }
#line 235
    if (tmp___1) {
#line 237
      if (depth > 16) {
#line 237
        tmp___0 = 16;
      } else {
#line 237
        tmp___0 = depth;
      }
      {
#line 237
      printf((char const   */* __restrict  */)"bind\t--\t%s%s: %s\n", ("                " + 16) - tmp___0,
             t->name, t->boundname);
      }
    }
    {
#line 245
    if ((int )t->binding == 2) {
#line 245
      goto case_2;
    }
#line 245
    if ((int )t->binding == 1) {
#line 245
      goto case_2;
    }
#line 245
    if ((int )t->binding == 0) {
#line 245
      goto case_2;
    }
#line 250
    if ((int )t->binding == 3) {
#line 250
      goto case_3;
    }
#line 241
    goto switch_break;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 246
    if (depth > 16) {
#line 246
      tmp___2 = 16;
    } else {
#line 246
      tmp___2 = depth;
    }
    {
#line 246
    printf((char const   */* __restrict  */)"time\t--\t%s%s: %s\n", ("                " + 16) - tmp___2,
           t->name, target_bind[t->binding]);
    }
#line 248
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 251
    tmp___3 = ctime((time_t const   *)(& t->time));
    }
#line 251
    if (depth > 16) {
#line 251
      tmp___4 = 16;
    } else {
#line 251
      tmp___4 = depth;
    }
    {
#line 251
    printf((char const   */* __restrict  */)"time\t--\t%s%s: %s", ("                " + 16) - tmp___4,
           t->name, tmp___3);
    }
#line 253
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 263
  c = t->depends;
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 263
    if (! c) {
#line 263
      goto while_break;
    }
#line 265
    internal = (int )t->flags & 64;
#line 267
    if (globs.debug[13]) {
#line 268
      if (internal) {
#line 268
        tmp___5 = "Includes";
      } else {
#line 268
        tmp___5 = "Depends";
      }
      {
#line 268
      printf((char const   */* __restrict  */)"%s \"%s\" : \"%s\" ;\n", tmp___5, t->name,
             (c->target)->name);
      }
    }
#line 275
    if ((int )(c->target)->fate == 0) {
      {
#line 276
      make0(c->target, ptime, depth + 1, counts___1, anyhow);
      }
    } else
#line 277
    if ((int )(c->target)->fate == 1) {
#line 277
      if (! internal) {
        {
#line 278
        printf((char const   */* __restrict  */)"warning: %s depends on itself\n",
               (c->target)->name);
        }
      }
    }
#line 263
    c = c->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 283
  if (t->includes) {
    {
#line 284
    make0(t->includes, p, depth + 1, counts___1, anyhow);
    }
  }
#line 288
  incs = (TARGETS *)0;
#line 290
  c = t->depends;
  {
#line 290
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 290
    if (! c) {
#line 290
      goto while_break___0;
    }
#line 291
    if ((c->target)->includes) {
      {
#line 292
      incs = targetentry(incs, (c->target)->includes);
      }
    }
#line 290
    c = c->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 294
  t->depends = targetchain(t->depends, incs);
#line 302
  last = (time_t )0;
#line 303
  leaf = (time_t )0;
#line 304
  fate = 2;
#line 306
  c = t->depends;
  }
  {
#line 306
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 306
    if (! c) {
#line 306
      goto while_break___1;
    }
#line 311
    if (leaf > (c->target)->leaf) {
#line 311
      leaf = leaf;
    } else {
#line 311
      leaf = (c->target)->leaf;
    }
#line 313
    if ((int )t->flags & 16) {
#line 315
      last = leaf;
#line 316
      goto __Cont;
    }
#line 319
    if (last > (c->target)->time) {
#line 319
      last = last;
    } else {
#line 319
      last = (c->target)->time;
    }
#line 320
    if (fate > (int )(c->target)->fate) {
#line 320
      fate = fate;
    } else {
#line 320
      fate = (int )(c->target)->fate;
    }
    __Cont: /* CIL Label */ 
#line 306
    c = c->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 330
  if (t->includes) {
#line 330
    hlast = (t->includes)->time;
  } else {
#line 330
    hlast = (time_t )0;
  }
#line 340
  if ((int )t->flags & 32) {
#line 342
    last = (time_t )0;
#line 343
    t->time = (time_t )0;
#line 344
    fate = 2;
  }
#line 367
  if (fate >= 10) {
#line 369
    fate = 11;
  } else
#line 371
  if (fate >= 4) {
#line 373
    fate = 9;
  } else
#line 375
  if ((int )t->binding == 1) {
#line 377
    fate = 6;
  } else
#line 379
  if ((int )t->binding == 3) {
#line 379
    if (last > t->time) {
#line 381
      fate = 8;
    } else {
#line 379
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 383
  if ((int )t->binding == 2) {
#line 383
    if (last > p->time) {
#line 385
      fate = 7;
    } else {
#line 383
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 387
  if ((int )t->binding == 2) {
#line 387
    if (hlast > p->time) {
#line 389
      fate = 7;
    } else {
#line 387
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 391
  if ((int )t->flags & 8) {
#line 393
    fate = 5;
  } else
#line 395
  if (anyhow) {
#line 395
    if (! ((int )t->flags & 32)) {
#line 397
      fate = 5;
    } else {
#line 395
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 399
  if ((int )t->binding == 3) {
#line 399
    if ((int )t->flags & 1) {
#line 401
      fate = 4;
    } else {
#line 399
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 403
  if ((int )t->binding == 3) {
#line 403
    if (p) {
#line 403
      if ((int )p->binding != 0) {
#line 403
        if (t->time > p->time) {
#line 406
          fate = 3;
        } else {
#line 410
          fate = 2;
        }
      } else {
#line 410
        fate = 2;
      }
    } else {
#line 410
      fate = 2;
    }
  } else {
#line 410
    fate = 2;
  }
#line 419
  if (fate == 6) {
#line 419
    if (! t->actions) {
#line 419
      if (! t->depends) {
#line 421
        if ((int )t->flags & 2) {
#line 423
          fate = 2;
        } else {
          {
#line 427
          printf((char const   */* __restrict  */)"don\'t know how to make %s\n",
                 t->name);
#line 429
          fate = 10;
          }
        }
      }
    }
  }
#line 436
  if (t->time > last) {
#line 436
    t->time = t->time;
  } else {
#line 436
    t->time = last;
  }
#line 437
  if (leaf) {
#line 437
    t->leaf = leaf;
  } else {
#line 437
    t->leaf = t->time;
  }
#line 438
  t->fate = (char )fate;
#line 444
  if (globs.newestfirst) {
    {
#line 445
    t->depends = make0sort(t->depends);
    }
  }
#line 453
  if ((int )t->flags & 64) {
#line 454
    return;
  }
#line 456
  (counts___1->targets) ++;
#line 456
  if (! (counts___1->targets % 1000)) {
#line 456
    if (globs.debug[1]) {
      {
#line 457
      printf((char const   */* __restrict  */)"...patience...\n");
      }
    }
  }
#line 459
  if (fate == 4) {
#line 460
    (counts___1->temp) ++;
  } else
#line 461
  if (fate == 10) {
#line 462
    (counts___1->cantfind) ++;
  } else
#line 463
  if (fate == 11) {
#line 463
    if (t->actions) {
#line 464
      (counts___1->cantmake) ++;
    } else {
#line 463
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 465
  if (fate >= 5) {
#line 465
    if (fate < 10) {
#line 465
      if (t->actions) {
#line 466
        (counts___1->updating) ++;
      }
    }
  }
#line 468
  if (! ((int )t->flags & 4)) {
#line 468
    if (fate >= 4) {
#line 469
      flag = "+";
    } else {
#line 468
      goto _L___5;
    }
  } else
  _L___5: /* CIL Label */ 
#line 470
  if ((int )t->binding == 3) {
#line 470
    if (p) {
#line 470
      if (t->time > p->time) {
#line 471
        flag = "*";
      }
    }
  }
#line 473
  if (globs.debug[3]) {
#line 474
    if (depth > 16) {
#line 474
      tmp___6 = 16;
    } else {
#line 474
      tmp___6 = depth;
    }
    {
#line 474
    printf((char const   */* __restrict  */)"made%s\t%s\t%s%s\n", flag, target_fate[t->fate],
           ("                " + 16) - tmp___6, t->name);
    }
  }
#line 478
  if (globs.debug[14]) {
#line 478
    if ((int )t->fate >= 3) {
#line 478
      if ((int )t->fate <= 6) {
        {
#line 481
        printf((char const   */* __restrict  */)"%s %s\n", target_fate[t->fate], t->name);
        }
      }
    }
  }
#line 482
  return;
}
}
#line 488 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make.c"
static TARGETS *make0sort(TARGETS *chain ) 
{ 
  TARGETS *result ;
  TARGETS *c ;
  TARGETS *s ;

  {
#line 491
  result = (TARGETS *)0;
  {
#line 502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 502
    if (! chain) {
#line 502
      goto while_break;
    }
#line 504
    c = chain;
#line 505
    s = result;
#line 507
    chain = chain->next;
    {
#line 511
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 511
      if (s) {
#line 511
        if (! ((s->target)->time > (c->target)->time)) {
#line 511
          goto while_break___0;
        }
      } else {
#line 511
        goto while_break___0;
      }
#line 512
      s = s->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 517
    c->next = s;
#line 518
    if ((unsigned long )result == (unsigned long )s) {
#line 518
      result = c;
    }
#line 519
    if (! s) {
#line 519
      s = result;
    }
#line 520
    if ((unsigned long )result != (unsigned long )c) {
#line 520
      (s->tail)->next = c;
    }
#line 521
    c->tail = s->tail;
#line 522
    s->tail = c;
  }
  while_break: /* CIL Label */ ;
  }
#line 525
  return (result);
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/execcmd.h"
void execcmd(char *string , void (*func)(void *closure , int status ) , void *closure ,
             LIST *shell ) ;
#line 19
int execwait(void) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 65 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/execunix.c"
static int intr  =    0;
#line 66 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/execunix.c"
static int cmdsrunning  =    0;
#line 67 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/execunix.c"
static void (*istat)(int  )  ;
#line 69 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/execunix.c"
static struct __anonstruct_cmdtab_50 cmdtab[64]  = {      {0, (void (*)(void *closure , int status ))0, (void *)0}};
#line 85 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/execunix.c"
void onintr(int disp ) 
{ 


  {
  {
#line 88
  intr ++;
#line 89
  printf((char const   */* __restrict  */)"...interrupted\n");
  }
#line 90
  return;
}
}
#line 234
extern int ( /* missing proto */  execvp)() ;
#line 235
extern int ( /* missing proto */  _exit)() ;
#line 232
extern int ( /* missing proto */  vfork)() ;
#line 96 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/execunix.c"
void execcmd(char *string , void (*func)(void *closure , int status ) , void *closure ,
             LIST *shell ) 
{ 
  int pid ;
  int slot ;
  char const   *argv[33] ;
  int i ;
  char jobno[4] ;
  int gotpercent ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 113
  slot = 0;
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! (slot < 64)) {
#line 113
      goto while_break;
    }
#line 114
    if (! cmdtab[slot].pid) {
#line 115
      goto while_break;
    }
#line 113
    slot ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 117
  if (slot == 64) {
    {
#line 119
    printf((char const   */* __restrict  */)"no slots for child!\n");
#line 120
    exit(1);
    }
  }
#line 173
  if (shell) {
    {
#line 177
    gotpercent = 0;
#line 179
    sprintf((char */* __restrict  */)(jobno), (char const   */* __restrict  */)"%d",
            slot + 1);
#line 181
    i = 0;
    }
    {
#line 181
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 181
      if (shell) {
#line 181
        if (! (i < 32)) {
#line 181
          goto while_break___0;
        }
      } else {
#line 181
        goto while_break___0;
      }
      {
#line 185
      if ((int const   )*(shell->string + 0) == 37) {
#line 185
        goto case_37;
      }
#line 186
      if ((int const   )*(shell->string + 0) == 33) {
#line 186
        goto case_33;
      }
#line 187
      goto switch_default;
      case_37: /* CIL Label */ 
#line 185
      argv[i] = (char const   *)string;
#line 185
      gotpercent ++;
#line 185
      goto switch_break;
      case_33: /* CIL Label */ 
#line 186
      argv[i] = (char const   *)(jobno);
#line 186
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 187
      argv[i] = shell->string;
      switch_break: /* CIL Label */ ;
      }
#line 189
      if (globs.debug[4]) {
        {
#line 190
        printf((char const   */* __restrict  */)"argv[%d] = \'%s\'\n", i, argv[i]);
        }
      }
#line 181
      i ++;
#line 181
      shell = shell->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 193
    if (! gotpercent) {
#line 194
      tmp = i;
#line 194
      i ++;
#line 194
      argv[tmp] = (char const   *)string;
    }
#line 196
    argv[i] = (char const   *)0;
  } else {
#line 204
    argv[0] = "/bin/sh";
#line 205
    argv[1] = "-c";
#line 207
    argv[2] = (char const   *)string;
#line 208
    argv[3] = (char const   *)0;
  }
#line 213
  tmp___0 = cmdsrunning;
#line 213
  cmdsrunning ++;
#line 213
  if (! tmp___0) {
    {
#line 214
    istat = signal(2, & onintr);
    }
  }
  {
#line 232
  pid = vfork();
  }
#line 232
  if (pid == 0) {
    {
#line 234
    execvp(argv[0], argv);
#line 235
    _exit(127);
    }
  }
#line 239
  if (pid == -1) {
    {
#line 241
    perror("vfork");
#line 242
    exit(1);
    }
  }
#line 247
  cmdtab[slot].pid = pid;
#line 248
  cmdtab[slot].func = func;
#line 249
  cmdtab[slot].closure = closure;
  {
#line 254
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 254
    if (! (cmdsrunning >= 64)) {
#line 254
      if (! (cmdsrunning >= globs.jobs)) {
#line 254
        goto while_break___1;
      }
    }
    {
#line 255
    tmp___1 = execwait();
    }
#line 255
    if (! tmp___1) {
#line 256
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 257
  return;
}
}
#line 277
extern int ( /* missing proto */  wait)() ;
#line 263 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/execunix.c"
int execwait(void) 
{ 
  int i ;
  int status ;
  int w ;
  int rstat ;
  int *tmp ;

  {
#line 272
  if (! cmdsrunning) {
#line 273
    return (0);
  }
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 277
    w = wait(& status);
    }
#line 277
    if (w == -1) {
      {
#line 277
      tmp = __errno_location();
      }
#line 277
      if (! (*tmp == 4)) {
#line 277
        goto while_break;
      }
    } else {
#line 277
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  if (w == -1) {
    {
#line 282
    printf((char const   */* __restrict  */)"child process(es) lost!\n");
#line 283
    perror("wait");
#line 284
    exit(1);
    }
  }
#line 289
  i = 0;
  {
#line 289
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 289
    if (! (i < 64)) {
#line 289
      goto while_break___0;
    }
#line 290
    if (w == cmdtab[i].pid) {
#line 291
      goto while_break___0;
    }
#line 289
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 293
  if (i == 64) {
    {
#line 295
    printf((char const   */* __restrict  */)"waif child found!\n");
#line 296
    exit(1);
    }
  }
#line 307
  cmdsrunning --;
#line 307
  if (! cmdsrunning) {
    {
#line 308
    signal(2, istat);
    }
  }
#line 310
  if (intr) {
#line 311
    rstat = 2;
  } else
#line 312
  if (w == -1) {
#line 313
    rstat = 1;
  } else
#line 312
  if (status != 0) {
#line 313
    rstat = 1;
  } else {
#line 315
    rstat = 0;
  }
  {
#line 317
  cmdtab[i].pid = 0;
#line 319
  (*(cmdtab[i].func))(cmdtab[i].closure, rstat);
  }
#line 321
  return (1);
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/glob.c"
static void globchars(char const   *s , char const   *e , char *b ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/glob.c"
int glob(char const   *c , char const   *s ) 
{ 
  char bitlist[16] ;
  char const   *here ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int r ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;

  {
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    tmp = c;
#line 49
    c ++;
    {
#line 51
    if ((int const   )*tmp == 0) {
#line 51
      goto case_0;
    }
#line 54
    if ((int const   )*tmp == 63) {
#line 54
      goto case_63;
    }
#line 59
    if ((int const   )*tmp == 91) {
#line 59
      goto case_91;
    }
#line 77
    if ((int const   )*tmp == 42) {
#line 77
      goto case_42;
    }
#line 103
    if ((int const   )*tmp == 92) {
#line 103
      goto case_92;
    }
#line 110
    goto switch_default;
    case_0: /* CIL Label */ 
#line 52
    if (*s) {
#line 52
      tmp___0 = -1;
    } else {
#line 52
      tmp___0 = 0;
    }
#line 52
    return (tmp___0);
    case_63: /* CIL Label */ 
#line 55
    tmp___1 = s;
#line 55
    s ++;
#line 55
    if (! *tmp___1) {
#line 56
      return (1);
    }
#line 57
    goto switch_break;
    case_91: /* CIL Label */ 
#line 62
    here = c;
    {
#line 63
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 63
      tmp___2 = c;
#line 63
      c ++;
#line 63
      if (! *tmp___2) {
#line 64
        return (1);
      }
#line 63
      if (! ((unsigned long )here == (unsigned long )c)) {
#line 63
        if (! ((int const   )*c != 93)) {
#line 63
          goto while_break___0;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 66
    c ++;
#line 70
    globchars(here, c, bitlist);
    }
#line 72
    if (! ((int )bitlist[(int )*((unsigned char *)s) / 8] & (1 << (int )*((unsigned char *)s) % 8))) {
#line 73
      return (1);
    }
#line 74
    s ++;
#line 75
    goto switch_break;
    case_42: /* CIL Label */ 
#line 78
    here = s;
    {
#line 80
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 80
      if (! *s) {
#line 80
        goto while_break___1;
      }
#line 81
      s ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 86
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 86
      if (! ((unsigned long )s != (unsigned long )here)) {
#line 86
        goto while_break___2;
      }
#line 92
      if (*c) {
        {
#line 92
        tmp___3 = glob(c, s);
#line 92
        r = tmp___3;
        }
      } else {
#line 92
        if (*s) {
#line 92
          tmp___4 = -1;
        } else {
#line 92
          tmp___4 = 0;
        }
#line 92
        r = tmp___4;
      }
#line 94
      if (! r) {
#line 95
        return (0);
      } else
#line 96
      if (r < 0) {
#line 97
        return (1);
      }
#line 99
      s --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 101
    goto switch_break;
    case_92: /* CIL Label */ 
#line 106
    if (! *c) {
#line 107
      return (1);
    } else {
#line 106
      tmp___5 = s;
#line 106
      s ++;
#line 106
      tmp___6 = c;
#line 106
      c ++;
#line 106
      if ((int const   )*tmp___5 != (int const   )*tmp___6) {
#line 107
        return (1);
      }
    }
#line 108
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 111
    tmp___7 = s;
#line 111
    s ++;
#line 111
    if ((int const   )*tmp___7 != (int const   )*(c + -1)) {
#line 112
      return (1);
    }
#line 113
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/glob.c"
static void globchars(char const   *s , char const   *e , char *b ) 
{ 
  int neg ;
  int c ;
  char const   *tmp ;
  int i ;

  {
  {
#line 127
  neg = 0;
#line 129
  memset((void *)b, '\000', (size_t )16);
  }
#line 131
  if ((int const   )*s == 94) {
#line 132
    neg ++;
#line 132
    s ++;
  }
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (! ((unsigned long )s < (unsigned long )e)) {
#line 134
      goto while_break;
    }
#line 138
    if ((unsigned long )(s + 2) < (unsigned long )e) {
#line 138
      if ((int const   )*(s + 1) == 45) {
#line 140
        c = (int )*(s + 0);
        {
#line 140
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 140
          if (! (c <= (int )*(s + 2))) {
#line 140
            goto while_break___0;
          }
#line 141
          *(b + c / 8) = (char )((int )*(b + c / 8) | (1 << c % 8));
#line 140
          c ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 142
        s += 3;
      } else {
#line 144
        tmp = s;
#line 144
        s ++;
#line 144
        c = (int )*tmp;
#line 145
        *(b + c / 8) = (char )((int )*(b + c / 8) | (1 << c % 8));
      }
    } else {
#line 144
      tmp = s;
#line 144
      s ++;
#line 144
      c = (int )*tmp;
#line 145
      *(b + c / 8) = (char )((int )*(b + c / 8) | (1 << c % 8));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  if (neg) {
#line 152
    i = 0;
    {
#line 152
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 152
      if (! (i < 16)) {
#line 152
        goto while_break___1;
      }
#line 153
      *(b + i) = (char )((int )*(b + i) ^ 255);
#line 152
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 158
  *(b + 0) = (char )((int )*(b + 0) & 254);
#line 159
  return;
}
}
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 32 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/parse.h"
void parse_save(PARSE *p ) ;
#line 34
PARSE *parse_make(LIST *(*func)(PARSE *p , LOL *args , int *jmp ) , PARSE *left ,
                  PARSE *right , PARSE *third , char const   *string , char const   *string1 ,
                  int num ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/scan.h"
YYSYMBOL yylval  ;
#line 44
void yymode(int n ) ;
#line 45
void yyerror(char const   *s ) ;
#line 49
int yylex(void) ;
#line 50
int yyparse(void) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/compile.h"
LIST *compile_append(PARSE *parse , LOL *args , int *jmp ) ;
#line 21
LIST *compile_break(PARSE *parse , LOL *args , int *jmp ) ;
#line 22
LIST *compile_foreach(PARSE *p , LOL *args , int *jmp ) ;
#line 23
LIST *compile_if(PARSE *p , LOL *args , int *jmp ) ;
#line 24
LIST *compile_eval(PARSE *parse , LOL *args , int *jmp ) ;
#line 25
LIST *compile_include(PARSE *parse , LOL *args , int *jmp ) ;
#line 26
LIST *compile_list(PARSE *parse , LOL *args , int *jmp ) ;
#line 27
LIST *compile_local(PARSE *parse , LOL *args , int *jmp ) ;
#line 28
LIST *compile_null(PARSE *parse , LOL *args , int *jmp ) ;
#line 29
LIST *compile_on(PARSE *parse , LOL *args , int *jmp ) ;
#line 30
LIST *compile_rule(PARSE *parse , LOL *args , int *jmp ) ;
#line 31
LIST *compile_rules(PARSE *parse , LOL *args , int *jmp ) ;
#line 32
LIST *compile_set(PARSE *parse , LOL *args , int *jmp ) ;
#line 33
LIST *compile_setcomp(PARSE *parse , LOL *args , int *jmp ) ;
#line 34
LIST *compile_setexec(PARSE *parse , LOL *args , int *jmp ) ;
#line 35
LIST *compile_settings(PARSE *parse , LOL *args , int *jmp ) ;
#line 36
LIST *compile_switch(PARSE *parse , LOL *args , int *jmp ) ;
#line 37
LIST *compile_while(PARSE *p , LOL *args , int *jmp ) ;
#line 343 "y.tab.c"
static unsigned char const   yytranslate[305]  = 
#line 343 "y.tab.c"
  {      (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )3,      (unsigned char const   )4, 
        (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )7,      (unsigned char const   )8, 
        (unsigned char const   )9,      (unsigned char const   )10,      (unsigned char const   )11,      (unsigned char const   )12, 
        (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )15,      (unsigned char const   )16, 
        (unsigned char const   )17,      (unsigned char const   )18,      (unsigned char const   )19,      (unsigned char const   )20, 
        (unsigned char const   )21,      (unsigned char const   )22,      (unsigned char const   )23,      (unsigned char const   )24, 
        (unsigned char const   )25,      (unsigned char const   )26,      (unsigned char const   )27,      (unsigned char const   )28, 
        (unsigned char const   )29,      (unsigned char const   )30,      (unsigned char const   )31,      (unsigned char const   )32, 
        (unsigned char const   )33,      (unsigned char const   )34,      (unsigned char const   )35,      (unsigned char const   )36, 
        (unsigned char const   )37,      (unsigned char const   )38,      (unsigned char const   )39,      (unsigned char const   )40, 
        (unsigned char const   )41,      (unsigned char const   )42,      (unsigned char const   )43,      (unsigned char const   )44, 
        (unsigned char const   )45,      (unsigned char const   )46,      (unsigned char const   )47,      (unsigned char const   )48, 
        (unsigned char const   )49};
#line 473 "y.tab.c"
static unsigned char const   yyr1[74]  = 
#line 473
  {      (unsigned char const   )0,      (unsigned char const   )50,      (unsigned char const   )51,      (unsigned char const   )51, 
        (unsigned char const   )52,      (unsigned char const   )52,      (unsigned char const   )53,      (unsigned char const   )53, 
        (unsigned char const   )53,      (unsigned char const   )53,      (unsigned char const   )54,      (unsigned char const   )54, 
        (unsigned char const   )54,      (unsigned char const   )54,      (unsigned char const   )54,      (unsigned char const   )54, 
        (unsigned char const   )54,      (unsigned char const   )54,      (unsigned char const   )54,      (unsigned char const   )54, 
        (unsigned char const   )54,      (unsigned char const   )54,      (unsigned char const   )54,      (unsigned char const   )54, 
        (unsigned char const   )54,      (unsigned char const   )55,      (unsigned char const   )56,      (unsigned char const   )54, 
        (unsigned char const   )57,      (unsigned char const   )57,      (unsigned char const   )57,      (unsigned char const   )57, 
        (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )58, 
        (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )58, 
        (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )58, 
        (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )59,      (unsigned char const   )59, 
        (unsigned char const   )60,      (unsigned char const   )61,      (unsigned char const   )61,      (unsigned char const   )61, 
        (unsigned char const   )62,      (unsigned char const   )62,      (unsigned char const   )63,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )65,      (unsigned char const   )66,      (unsigned char const   )65, 
        (unsigned char const   )67,      (unsigned char const   )67,      (unsigned char const   )67,      (unsigned char const   )68, 
        (unsigned char const   )68,      (unsigned char const   )69,      (unsigned char const   )69,      (unsigned char const   )69, 
        (unsigned char const   )69,      (unsigned char const   )69,      (unsigned char const   )69,      (unsigned char const   )69, 
        (unsigned char const   )70,      (unsigned char const   )70};
#line 486 "y.tab.c"
static unsigned char const   yyr2[74]  = 
#line 486
  {      (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )2, 
        (unsigned char const   )4,      (unsigned char const   )6,      (unsigned char const   )3,      (unsigned char const   )3, 
        (unsigned char const   )3,      (unsigned char const   )4,      (unsigned char const   )6,      (unsigned char const   )3, 
        (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )7,      (unsigned char const   )5, 
        (unsigned char const   )5,      (unsigned char const   )7,      (unsigned char const   )5,      (unsigned char const   )6, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )9, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )2, 
        (unsigned char const   )1,      (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3, 
        (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3, 
        (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3, 
        (unsigned char const   )2,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )2, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )3,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )3,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )4, 
        (unsigned char const   )2,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )2, 
        (unsigned char const   )0,      (unsigned char const   )2};
#line 501 "y.tab.c"
static unsigned char const   yydefact[154]  = 
#line 501
  {      (unsigned char const   )2,      (unsigned char const   )58,      (unsigned char const   )4,      (unsigned char const   )63, 
        (unsigned char const   )55,      (unsigned char const   )55,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )55,      (unsigned char const   )55,      (unsigned char const   )0,      (unsigned char const   )55, 
        (unsigned char const   )0,      (unsigned char const   )55,      (unsigned char const   )0,      (unsigned char const   )57, 
        (unsigned char const   )0,      (unsigned char const   )3,      (unsigned char const   )6,      (unsigned char const   )55, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )5,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )54,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )32, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )49,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1, 
        (unsigned char const   )7,      (unsigned char const   )28,      (unsigned char const   )30,      (unsigned char const   )29, 
        (unsigned char const   )0,      (unsigned char const   )55,      (unsigned char const   )55,      (unsigned char const   )0, 
        (unsigned char const   )52,      (unsigned char const   )0,      (unsigned char const   )55,      (unsigned char const   )0, 
        (unsigned char const   )10,      (unsigned char const   )70,      (unsigned char const   )67,      (unsigned char const   )0, 
        (unsigned char const   )69,      (unsigned char const   )68,      (unsigned char const   )66,      (unsigned char const   )65, 
        (unsigned char const   )72,      (unsigned char const   )64,      (unsigned char const   )15,      (unsigned char const   )56, 
        (unsigned char const   )16,      (unsigned char const   )55,      (unsigned char const   )44,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )55, 
        (unsigned char const   )11,      (unsigned char const   )55,      (unsigned char const   )4,      (unsigned char const   )24, 
        (unsigned char const   )17,      (unsigned char const   )51,      (unsigned char const   )0,      (unsigned char const   )46, 
        (unsigned char const   )4,      (unsigned char const   )31,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )55,      (unsigned char const   )0,      (unsigned char const   )60, 
        (unsigned char const   )59,      (unsigned char const   )71,      (unsigned char const   )55,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )45,      (unsigned char const   )35,      (unsigned char const   )36, 
        (unsigned char const   )33,      (unsigned char const   )37,      (unsigned char const   )38,      (unsigned char const   )41, 
        (unsigned char const   )42,      (unsigned char const   )34,      (unsigned char const   )0,      (unsigned char const   )39, 
        (unsigned char const   )40,      (unsigned char const   )43,      (unsigned char const   )0,      (unsigned char const   )8, 
        (unsigned char const   )49,      (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )46,      (unsigned char const   )0,      (unsigned char const   )55,      (unsigned char const   )13, 
        (unsigned char const   )53,      (unsigned char const   )55,      (unsigned char const   )55,      (unsigned char const   )73, 
        (unsigned char const   )25,      (unsigned char const   )4,      (unsigned char const   )20,      (unsigned char const   )4, 
        (unsigned char const   )50,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )19, 
        (unsigned char const   )47,      (unsigned char const   )22,      (unsigned char const   )0,      (unsigned char const   )62, 
        (unsigned char const   )61,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )9,      (unsigned char const   )23,      (unsigned char const   )4,      (unsigned char const   )14, 
        (unsigned char const   )26,      (unsigned char const   )18,      (unsigned char const   )21,      (unsigned char const   )48, 
        (unsigned char const   )0,      (unsigned char const   )27};
#line 522 "y.tab.c"
static short const   yydefgoto[21]  = 
#line 522
  {      (short const   )-1,      (short const   )16,      (short const   )21,      (short const   )22, 
        (short const   )18,      (short const   )141,      (short const   )152,      (short const   )46, 
        (short const   )30,      (short const   )119,      (short const   )120,      (short const   )86, 
        (short const   )47,      (short const   )48,      (short const   )25,      (short const   )31, 
        (short const   )20,      (short const   )51,      (short const   )23,      (short const   )61, 
        (short const   )99};
#line 532 "y.tab.c"
static short const   yypact[154]  = 
#line 532
  {      (short const   )130,      (short const   )-48,      (short const   )130,      (short const   )-48, 
        (short const   )-48,      (short const   )-48,      (short const   )-43,      (short const   )-8, 
        (short const   )-48,      (short const   )-48,      (short const   )7,      (short const   )-48, 
        (short const   )-17,      (short const   )-48,      (short const   )-8,      (short const   )-48, 
        (short const   )15,      (short const   )-48,      (short const   )130,      (short const   )9, 
        (short const   )-11,      (short const   )23,      (short const   )-48,      (short const   )151, 
        (short const   )31,      (short const   )7,      (short const   )35,      (short const   )12, 
        (short const   )-8,      (short const   )-8,      (short const   )53,      (short const   )16, 
        (short const   )42,      (short const   )17,      (short const   )162,      (short const   )59, 
        (short const   )22,      (short const   )44,      (short const   )208,      (short const   )-48, 
        (short const   )-48,      (short const   )-48,      (short const   )-48,      (short const   )-48, 
        (short const   )72,      (short const   )-48,      (short const   )-48,      (short const   )68, 
        (short const   )69,      (short const   )7,      (short const   )-48,      (short const   )66, 
        (short const   )-48,      (short const   )-48,      (short const   )-48,      (short const   )38, 
        (short const   )-48,      (short const   )-48,      (short const   )-48,      (short const   )-48, 
        (short const   )65,      (short const   )-48,      (short const   )-48,      (short const   )-48, 
        (short const   )-48,      (short const   )-48,      (short const   )-48,      (short const   )228, 
        (short const   )-8,      (short const   )-8,      (short const   )-8,      (short const   )-8, 
        (short const   )-8,      (short const   )-8,      (short const   )-8,      (short const   )-8, 
        (short const   )130,      (short const   )-8,      (short const   )-8,      (short const   )-48, 
        (short const   )-48,      (short const   )-48,      (short const   )130,      (short const   )-48, 
        (short const   )-48,      (short const   )80,      (short const   )73,      (short const   )70, 
        (short const   )130,      (short const   )-48,      (short const   )21,      (short const   )83, 
        (short const   )-48,      (short const   )-48,      (short const   )-9,      (short const   )-48, 
        (short const   )-48,      (short const   )-48,      (short const   )-48,      (short const   )79, 
        (short const   )88,      (short const   )-48,      (short const   )-48,      (short const   )-48, 
        (short const   )61,      (short const   )-48,      (short const   )-48,      (short const   )98, 
        (short const   )98,      (short const   )61,      (short const   )89,      (short const   )109, 
        (short const   )109,      (short const   )-48,      (short const   )108,      (short const   )-48, 
        (short const   )22,      (short const   )130,      (short const   )51,      (short const   )101, 
        (short const   )70,      (short const   )103,      (short const   )-48,      (short const   )-48, 
        (short const   )-48,      (short const   )-48,      (short const   )-48,      (short const   )-48, 
        (short const   )-48,      (short const   )130,      (short const   )78,      (short const   )130, 
        (short const   )-48,      (short const   )104,      (short const   )114,      (short const   )-48, 
        (short const   )-48,      (short const   )-48,      (short const   )116,      (short const   )-48, 
        (short const   )-48,      (short const   )85,      (short const   )107,      (short const   )162, 
        (short const   )-48,      (short const   )-48,      (short const   )130,      (short const   )-48, 
        (short const   )-48,      (short const   )-48,      (short const   )-48,      (short const   )-48, 
        (short const   )112,      (short const   )-48};
#line 553 "y.tab.c"
static yysigned_char const   yypgoto[21]  = 
#line 553
  {      (yysigned_char const   )-48,      (yysigned_char const   )-48,      (yysigned_char const   )-46,      (yysigned_char const   )11, 
        (yysigned_char const   )-33,      (yysigned_char const   )-48,      (yysigned_char const   )-48,      (yysigned_char const   )58, 
        (yysigned_char const   )67,      (yysigned_char const   )30,      (yysigned_char const   )-48,      (yysigned_char const   )36, 
        (yysigned_char const   )-47,      (yysigned_char const   )8,      (yysigned_char const   )-48,      (yysigned_char const   )0, 
        (yysigned_char const   )-48,      (yysigned_char const   )-48,      (yysigned_char const   )-48,      (yysigned_char const   )-48, 
        (yysigned_char const   )-48};
#line 565 "y.tab.c"
static unsigned char const   yytable[251]  = 
#line 565
  {      (unsigned char const   )19,      (unsigned char const   )83,      (unsigned char const   )19,      (unsigned char const   )95, 
        (unsigned char const   )28,      (unsigned char const   )27,      (unsigned char const   )1,      (unsigned char const   )29, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )34,      (unsigned char const   )17, 
        (unsigned char const   )24,      (unsigned char const   )26,      (unsigned char const   )41,      (unsigned char const   )39, 
        (unsigned char const   )32,      (unsigned char const   )33,      (unsigned char const   )19,      (unsigned char const   )35, 
        (unsigned char const   )50,      (unsigned char const   )37,      (unsigned char const   )81,      (unsigned char const   )42, 
        (unsigned char const   )1,      (unsigned char const   )63,      (unsigned char const   )41,      (unsigned char const   )82, 
        (unsigned char const   )49,      (unsigned char const   )40,      (unsigned char const   )110,      (unsigned char const   )36, 
        (unsigned char const   )43,      (unsigned char const   )125,      (unsigned char const   )19,      (unsigned char const   )42, 
        (unsigned char const   )115,      (unsigned char const   )15,      (unsigned char const   )44,      (unsigned char const   )15, 
        (unsigned char const   )15,      (unsigned char const   )62,      (unsigned char const   )121,      (unsigned char const   )52, 
        (unsigned char const   )43,      (unsigned char const   )64,      (unsigned char const   )124,      (unsigned char const   )65, 
        (unsigned char const   )45,      (unsigned char const   )94,      (unsigned char const   )44,      (unsigned char const   )79, 
        (unsigned char const   )80,      (unsigned char const   )90,      (unsigned char const   )91,      (unsigned char const   )15, 
        (unsigned char const   )68,      (unsigned char const   )69,      (unsigned char const   )70,      (unsigned char const   )71, 
        (unsigned char const   )72,      (unsigned char const   )73,      (unsigned char const   )74,      (unsigned char const   )87, 
        (unsigned char const   )68,      (unsigned char const   )69,      (unsigned char const   )75,      (unsigned char const   )71, 
        (unsigned char const   )72,      (unsigned char const   )84,      (unsigned char const   )85,      (unsigned char const   )133, 
        (unsigned char const   )76,      (unsigned char const   )100,      (unsigned char const   )77,      (unsigned char const   )78, 
        (unsigned char const   )19,      (unsigned char const   )89,      (unsigned char const   )92,      (unsigned char const   )140, 
        (unsigned char const   )93,      (unsigned char const   )38,      (unsigned char const   )19,      (unsigned char const   )142, 
        (unsigned char const   )96,      (unsigned char const   )144,      (unsigned char const   )97,      (unsigned char const   )113, 
        (unsigned char const   )19,      (unsigned char const   )114,      (unsigned char const   )98,      (unsigned char const   )116, 
        (unsigned char const   )117,      (unsigned char const   )123,      (unsigned char const   )126,      (unsigned char const   )66, 
        (unsigned char const   )67,      (unsigned char const   )118,      (unsigned char const   )128,      (unsigned char const   )134, 
        (unsigned char const   )151,      (unsigned char const   )68,      (unsigned char const   )69,      (unsigned char const   )70, 
        (unsigned char const   )71,      (unsigned char const   )72,      (unsigned char const   )127,      (unsigned char const   )129, 
        (unsigned char const   )143,      (unsigned char const   )130,      (unsigned char const   )150,      (unsigned char const   )75, 
        (unsigned char const   )68,      (unsigned char const   )69,      (unsigned char const   )70,      (unsigned char const   )71, 
        (unsigned char const   )72,      (unsigned char const   )19,      (unsigned char const   )131,      (unsigned char const   )77, 
        (unsigned char const   )78,      (unsigned char const   )135,      (unsigned char const   )75,      (unsigned char const   )137, 
        (unsigned char const   )145,      (unsigned char const   )146,      (unsigned char const   )147,      (unsigned char const   )149, 
        (unsigned char const   )0,      (unsigned char const   )19,      (unsigned char const   )138,      (unsigned char const   )19, 
        (unsigned char const   )153,      (unsigned char const   )139,      (unsigned char const   )148,      (unsigned char const   )102, 
        (unsigned char const   )103,      (unsigned char const   )104,      (unsigned char const   )105,      (unsigned char const   )106, 
        (unsigned char const   )107,      (unsigned char const   )108,      (unsigned char const   )109,      (unsigned char const   )19, 
        (unsigned char const   )111,      (unsigned char const   )112,      (unsigned char const   )19,      (unsigned char const   )1, 
        (unsigned char const   )122,      (unsigned char const   )2,      (unsigned char const   )136,      (unsigned char const   )0, 
        (unsigned char const   )132,      (unsigned char const   )0,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )5,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )6,      (unsigned char const   )7, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )8,      (unsigned char const   )9, 
        (unsigned char const   )0,      (unsigned char const   )10,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )11,      (unsigned char const   )12,      (unsigned char const   )13,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )14,      (unsigned char const   )15,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )53,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )54,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )4,      (unsigned char const   )55,      (unsigned char const   )5,      (unsigned char const   )56, 
        (unsigned char const   )57,      (unsigned char const   )0,      (unsigned char const   )6,      (unsigned char const   )7, 
        (unsigned char const   )58,      (unsigned char const   )59,      (unsigned char const   )8,      (unsigned char const   )60, 
        (unsigned char const   )0,      (unsigned char const   )10,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )11,      (unsigned char const   )12,      (unsigned char const   )13,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )14,      (unsigned char const   )15,      (unsigned char const   )68, 
        (unsigned char const   )69,      (unsigned char const   )70,      (unsigned char const   )71,      (unsigned char const   )72, 
        (unsigned char const   )73,      (unsigned char const   )74,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )75,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )88, 
        (unsigned char const   )0,      (unsigned char const   )77,      (unsigned char const   )78,      (unsigned char const   )68, 
        (unsigned char const   )69,      (unsigned char const   )70,      (unsigned char const   )71,      (unsigned char const   )72, 
        (unsigned char const   )73,      (unsigned char const   )74,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )75,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )101,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )77,      (unsigned char const   )78};
#line 595 "y.tab.c"
static short const   yycheck[251]  = 
#line 595
  {      (short const   )0,      (short const   )34,      (short const   )2,      (short const   )50, 
        (short const   )12,      (short const   )48,      (short const   )17,      (short const   )15, 
        (short const   )17,      (short const   )17,      (short const   )10,      (short const   )0, 
        (short const   )4,      (short const   )5,      (short const   )5,      (short const   )0, 
        (short const   )8,      (short const   )9,      (short const   )18,      (short const   )11, 
        (short const   )20,      (short const   )13,      (short const   )5,      (short const   )14, 
        (short const   )17,      (short const   )25,      (short const   )5,      (short const   )10, 
        (short const   )39,      (short const   )18,      (short const   )76,      (short const   )48, 
        (short const   )23,      (short const   )42,      (short const   )34,      (short const   )14, 
        (short const   )82,      (short const   )48,      (short const   )29,      (short const   )48, 
        (short const   )48,      (short const   )10,      (short const   )88,      (short const   )20, 
        (short const   )23,      (short const   )10,      (short const   )93,      (short const   )35, 
        (short const   )39,      (short const   )49,      (short const   )29,      (short const   )35, 
        (short const   )10,      (short const   )45,      (short const   )46,      (short const   )48, 
        (short const   )3,      (short const   )4,      (short const   )5,      (short const   )6, 
        (short const   )7,      (short const   )8,      (short const   )9,      (short const   )19, 
        (short const   )3,      (short const   )4,      (short const   )13,      (short const   )6, 
        (short const   )7,      (short const   )10,      (short const   )48,      (short const   )117, 
        (short const   )19,      (short const   )65,      (short const   )21,      (short const   )22, 
        (short const   )76,      (short const   )5,      (short const   )10,      (short const   )126, 
        (short const   )11,      (short const   )14,      (short const   )82,      (short const   )129, 
        (short const   )18,      (short const   )131,      (short const   )48,      (short const   )79, 
        (short const   )88,      (short const   )81,      (short const   )25,      (short const   )11, 
        (short const   )19,      (short const   )10,      (short const   )94,      (short const   )28, 
        (short const   )29,      (short const   )27,      (short const   )19,      (short const   )48, 
        (short const   )146,      (short const   )3,      (short const   )4,      (short const   )5, 
        (short const   )6,      (short const   )7,      (short const   )98,      (short const   )19, 
        (short const   )30,      (short const   )20,      (short const   )143,      (short const   )13, 
        (short const   )3,      (short const   )4,      (short const   )5,      (short const   )6, 
        (short const   )7,      (short const   )117,      (short const   )10,      (short const   )21, 
        (short const   )22,      (short const   )20,      (short const   )13,      (short const   )20, 
        (short const   )20,      (short const   )11,      (short const   )10,      (short const   )20, 
        (short const   )-1,      (short const   )129,      (short const   )122,      (short const   )131, 
        (short const   )20,      (short const   )125,      (short const   )49,      (short const   )68, 
        (short const   )69,      (short const   )70,      (short const   )71,      (short const   )72, 
        (short const   )73,      (short const   )74,      (short const   )75,      (short const   )143, 
        (short const   )77,      (short const   )78,      (short const   )146,      (short const   )17, 
        (short const   )90,      (short const   )19,      (short const   )120,      (short const   )-1, 
        (short const   )116,      (short const   )-1,      (short const   )24,      (short const   )-1, 
        (short const   )26,      (short const   )-1,      (short const   )28,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )32,      (short const   )33, 
        (short const   )-1,      (short const   )-1,      (short const   )36,      (short const   )37, 
        (short const   )-1,      (short const   )39,      (short const   )-1,      (short const   )-1, 
        (short const   )42,      (short const   )43,      (short const   )44,      (short const   )-1, 
        (short const   )-1,      (short const   )47,      (short const   )48,      (short const   )17, 
        (short const   )-1,      (short const   )19,      (short const   )31,      (short const   )-1, 
        (short const   )-1,      (short const   )34,      (short const   )24,      (short const   )-1, 
        (short const   )26,      (short const   )38,      (short const   )28,      (short const   )40, 
        (short const   )41,      (short const   )-1,      (short const   )32,      (short const   )33, 
        (short const   )45,      (short const   )46,      (short const   )36,      (short const   )48, 
        (short const   )-1,      (short const   )39,      (short const   )-1,      (short const   )-1, 
        (short const   )42,      (short const   )43,      (short const   )44,      (short const   )-1, 
        (short const   )-1,      (short const   )47,      (short const   )48,      (short const   )3, 
        (short const   )4,      (short const   )5,      (short const   )6,      (short const   )7, 
        (short const   )8,      (short const   )9,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )13,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )19, 
        (short const   )-1,      (short const   )21,      (short const   )22,      (short const   )3, 
        (short const   )4,      (short const   )5,      (short const   )6,      (short const   )7, 
        (short const   )8,      (short const   )9,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )13,      (short const   )-1,      (short const   )-1, 
        (short const   )16,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )21,      (short const   )22};
#line 627 "y.tab.c"
static unsigned char const   yystos[154]  = 
#line 627
  {      (unsigned char const   )0,      (unsigned char const   )17,      (unsigned char const   )19,      (unsigned char const   )24, 
        (unsigned char const   )26,      (unsigned char const   )28,      (unsigned char const   )32,      (unsigned char const   )33, 
        (unsigned char const   )36,      (unsigned char const   )37,      (unsigned char const   )39,      (unsigned char const   )42, 
        (unsigned char const   )43,      (unsigned char const   )44,      (unsigned char const   )47,      (unsigned char const   )48, 
        (unsigned char const   )51,      (unsigned char const   )53,      (unsigned char const   )54,      (unsigned char const   )65, 
        (unsigned char const   )66,      (unsigned char const   )52,      (unsigned char const   )53,      (unsigned char const   )68, 
        (unsigned char const   )63,      (unsigned char const   )64,      (unsigned char const   )63,      (unsigned char const   )48, 
        (unsigned char const   )12,      (unsigned char const   )15,      (unsigned char const   )58,      (unsigned char const   )65, 
        (unsigned char const   )63,      (unsigned char const   )63,      (unsigned char const   )65,      (unsigned char const   )63, 
        (unsigned char const   )48,      (unsigned char const   )63,      (unsigned char const   )58,      (unsigned char const   )0, 
        (unsigned char const   )53,      (unsigned char const   )5,      (unsigned char const   )14,      (unsigned char const   )23, 
        (unsigned char const   )29,      (unsigned char const   )39,      (unsigned char const   )57,      (unsigned char const   )62, 
        (unsigned char const   )63,      (unsigned char const   )39,      (unsigned char const   )65,      (unsigned char const   )67, 
        (unsigned char const   )20,      (unsigned char const   )31,      (unsigned char const   )34,      (unsigned char const   )38, 
        (unsigned char const   )40,      (unsigned char const   )41,      (unsigned char const   )45,      (unsigned char const   )46, 
        (unsigned char const   )48,      (unsigned char const   )69,      (unsigned char const   )10,      (unsigned char const   )65, 
        (unsigned char const   )10,      (unsigned char const   )35,      (unsigned char const   )58,      (unsigned char const   )58, 
        (unsigned char const   )3,      (unsigned char const   )4,      (unsigned char const   )5,      (unsigned char const   )6, 
        (unsigned char const   )7,      (unsigned char const   )8,      (unsigned char const   )9,      (unsigned char const   )13, 
        (unsigned char const   )19,      (unsigned char const   )21,      (unsigned char const   )22,      (unsigned char const   )35, 
        (unsigned char const   )10,      (unsigned char const   )5,      (unsigned char const   )10,      (unsigned char const   )54, 
        (unsigned char const   )10,      (unsigned char const   )48,      (unsigned char const   )61,      (unsigned char const   )19, 
        (unsigned char const   )19,      (unsigned char const   )5,      (unsigned char const   )63,      (unsigned char const   )63, 
        (unsigned char const   )10,      (unsigned char const   )11,      (unsigned char const   )65,      (unsigned char const   )62, 
        (unsigned char const   )18,      (unsigned char const   )48,      (unsigned char const   )25,      (unsigned char const   )70, 
        (unsigned char const   )63,      (unsigned char const   )16,      (unsigned char const   )58,      (unsigned char const   )58, 
        (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )58, 
        (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )52,      (unsigned char const   )58, 
        (unsigned char const   )58,      (unsigned char const   )63,      (unsigned char const   )63,      (unsigned char const   )52, 
        (unsigned char const   )11,      (unsigned char const   )19,      (unsigned char const   )27,      (unsigned char const   )59, 
        (unsigned char const   )60,      (unsigned char const   )52,      (unsigned char const   )57,      (unsigned char const   )10, 
        (unsigned char const   )62,      (unsigned char const   )42,      (unsigned char const   )65,      (unsigned char const   )63, 
        (unsigned char const   )19,      (unsigned char const   )19,      (unsigned char const   )20,      (unsigned char const   )10, 
        (unsigned char const   )61,      (unsigned char const   )52,      (unsigned char const   )48,      (unsigned char const   )20, 
        (unsigned char const   )59,      (unsigned char const   )20,      (unsigned char const   )63,      (unsigned char const   )63, 
        (unsigned char const   )62,      (unsigned char const   )55,      (unsigned char const   )52,      (unsigned char const   )30, 
        (unsigned char const   )52,      (unsigned char const   )20,      (unsigned char const   )11,      (unsigned char const   )10, 
        (unsigned char const   )49,      (unsigned char const   )20,      (unsigned char const   )54,      (unsigned char const   )52, 
        (unsigned char const   )56,      (unsigned char const   )20};
#line 940 "y.tab.c"
static void yydestruct(int yytype , YYSYMBOL *yyvaluep ) 
{ 


  {
  {
#line 955
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 956
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 958
  return;
}
}
#line 980 "y.tab.c"
int yychar  ;
#line 986 "y.tab.c"
int yynerrs  ;
#line 1003 "y.tab.c"
int yyparse(void) 
{ 
  register int yystate ;
  register int yyn ;
  int yyresult ;
  int yyerrstatus ;
  int yytoken ;
  short yyssa[200] ;
  short *yyss ;
  register short *yyssp ;
  YYSYMBOL yyvsa[200] ;
  YYSYMBOL *yyvs ;
  register YYSYMBOL *yyvsp ;
  unsigned long yystacksize ;
  YYSYMBOL yyval ;
  int yylen ;
  unsigned long yysize ;
  short *yyss1 ;
  union yyalloc *yyptr ;
  void *tmp ;
  unsigned long yynewbytes ;
  unsigned long yynewbytes___0 ;
  PARSE *tmp___0 ;
  PARSE *tmp___1 ;
  PARSE *tmp___2 ;
  PARSE *tmp___3 ;
  PARSE *tmp___4 ;
  int tmp___5 ;

  {
#line 1019
  yytoken = 0;
#line 1031
  yyss = yyssa;
#line 1036
  yyvs = yyvsa;
#line 1043
  yystacksize = 200UL;
#line 1056
  yystate = 0;
#line 1057
  yyerrstatus = 0;
#line 1058
  yynerrs = 0;
#line 1059
  yychar = -2;
#line 1066
  yyssp = yyss;
#line 1067
  yyvsp = yyvs;
#line 1069
  goto yysetstate;
  yynewstate: 
#line 1078
  yyssp ++;
  yysetstate: 
#line 1081
  *yyssp = (short )yystate;
#line 1083
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1086
    yysize = (unsigned long )((yyssp - yyss) + 1L);
#line 1115
    if (10000UL <= yystacksize) {
#line 1116
      goto yyoverflowlab;
    }
#line 1117
    yystacksize *= 2UL;
#line 1118
    if (10000UL < yystacksize) {
#line 1119
      yystacksize = 10000UL;
    }
    {
#line 1122
    yyss1 = yyss;
#line 1123
    tmp = __builtin_alloca(yystacksize * (sizeof(short ) + sizeof(YYSYMBOL )) + (sizeof(union yyalloc ) - 1UL));
#line 1123
    yyptr = (union yyalloc *)tmp;
    }
#line 1125
    if (! yyptr) {
#line 1126
      goto yyoverflowlab;
    }
    {
#line 1127
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1127
      __builtin_memcpy((void *)(& yyptr->yyss), (void const   *)yyss, yysize * sizeof(*yyss));
#line 1127
      yyss = & yyptr->yyss;
#line 1127
      yynewbytes = yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1UL);
#line 1127
      yyptr += yynewbytes / sizeof(*yyptr);
      }
#line 1127
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1128
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1128
      __builtin_memcpy((void *)(& yyptr->yyvs), (void const   *)yyvs, yysize * sizeof(*yyvs));
#line 1128
      yyvs = & yyptr->yyvs;
#line 1128
      yynewbytes___0 = yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1UL);
#line 1128
      yyptr += yynewbytes___0 / sizeof(*yyptr);
      }
#line 1128
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1131
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
#line 1132
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1132
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 1137
    yyssp = (yyss + yysize) - 1;
#line 1138
    yyvsp = (yyvs + yysize) - 1;
#line 1144
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1145
      goto yyabortlab;
    }
  }
#line 1150
  goto yybackup;
  yybackup: 
#line 1163
  yyn = (int )yypact[yystate];
#line 1164
  if (yyn == -48) {
#line 1165
    goto yydefault;
  }
#line 1170
  if (yychar == -2) {
    {
#line 1173
    yychar = yylex();
    }
  }
#line 1176
  if (yychar <= 0) {
#line 1178
    yytoken = 0;
#line 1178
    yychar = yytoken;
  } else
#line 1183
  if ((unsigned int )yychar <= 304U) {
#line 1183
    yytoken = (int )yytranslate[yychar];
  } else {
#line 1183
    yytoken = 2;
  }
#line 1189
  yyn += yytoken;
#line 1190
  if (yyn < 0) {
#line 1191
    goto yydefault;
  } else
#line 1190
  if (250 < yyn) {
#line 1191
    goto yydefault;
  } else
#line 1190
  if ((int const   )yycheck[yyn] != (int const   )yytoken) {
#line 1191
    goto yydefault;
  }
#line 1192
  yyn = (int )yytable[yyn];
#line 1193
  if (yyn <= 0) {
#line 1195
    if (yyn == 0) {
#line 1196
      goto yyerrlab;
    } else
#line 1195
    if (yyn == -1) {
#line 1196
      goto yyerrlab;
    }
#line 1197
    yyn = - yyn;
#line 1198
    goto yyreduce;
  }
#line 1201
  if (yyn == 39) {
#line 1202
    goto yyacceptlab;
  }
#line 1208
  if (yychar != 0) {
#line 1209
    yychar = -2;
  }
#line 1211
  yyvsp ++;
#line 1211
  *yyvsp = yylval;
#line 1216
  if (yyerrstatus) {
#line 1217
    yyerrstatus --;
  }
#line 1219
  yystate = yyn;
#line 1220
  goto yynewstate;
  yydefault: 
#line 1227
  yyn = (int )yydefact[yystate];
#line 1228
  if (yyn == 0) {
#line 1229
    goto yyerrlab;
  }
#line 1230
  goto yyreduce;
  yyreduce: 
#line 1238
  yylen = (int )yyr2[yyn];
#line 1248
  yyval = *(yyvsp + (1 - yylen));
  {
#line 1254
  if (yyn == 3) {
#line 1254
    goto case_3;
  }
#line 133
  if (yyn == 4) {
#line 133 "jamgram.y"
    goto case_4;
  }
#line 144
  if (yyn == 5) {
#line 144
    goto case_5;
  }
#line 146
  if (yyn == 6) {
#line 146
    goto case_6;
  }
#line 150
  if (yyn == 7) {
#line 150
    goto case_7;
  }
#line 152
  if (yyn == 8) {
#line 152
    goto case_8;
  }
#line 154
  if (yyn == 9) {
#line 154
    goto case_9;
  }
#line 156
  if (yyn == 10) {
#line 156
    goto case_10;
  }
#line 160
  if (yyn == 11) {
#line 160
    goto case_11;
  }
#line 162
  if (yyn == 12) {
#line 162
    goto case_12;
  }
#line 164
  if (yyn == 13) {
#line 164
    goto case_13;
  }
#line 166
  if (yyn == 14) {
#line 166
    goto case_14;
  }
#line 168
  if (yyn == 15) {
#line 168
    goto case_15;
  }
#line 170
  if (yyn == 16) {
#line 170
    goto case_16;
  }
#line 172
  if (yyn == 17) {
#line 172
    goto case_17;
  }
#line 174
  if (yyn == 18) {
#line 174
    goto case_18;
  }
#line 176
  if (yyn == 19) {
#line 176
    goto case_19;
  }
#line 178
  if (yyn == 20) {
#line 178
    goto case_20;
  }
#line 180
  if (yyn == 21) {
#line 180
    goto case_21;
  }
#line 182
  if (yyn == 22) {
#line 182
    goto case_22;
  }
#line 184
  if (yyn == 23) {
#line 184
    goto case_23;
  }
#line 186
  if (yyn == 24) {
#line 186
    goto case_24;
  }
#line 188
  if (yyn == 25) {
#line 188
    goto case_25;
  }
#line 190
  if (yyn == 26) {
#line 190
    goto case_26;
  }
#line 192
  if (yyn == 27) {
#line 192
    goto case_27;
  }
#line 194
  if (yyn == 28) {
#line 194
    goto case_28;
  }
#line 202
  if (yyn == 29) {
#line 202
    goto case_29;
  }
#line 204
  if (yyn == 30) {
#line 204
    goto case_30;
  }
#line 206
  if (yyn == 31) {
#line 206
    goto case_31;
  }
#line 208
  if (yyn == 32) {
#line 208
    goto case_32;
  }
#line 216
  if (yyn == 33) {
#line 216
    goto case_33;
  }
#line 218
  if (yyn == 34) {
#line 218
    goto case_34;
  }
#line 220
  if (yyn == 35) {
#line 220
    goto case_35;
  }
#line 222
  if (yyn == 36) {
#line 222
    goto case_36;
  }
#line 224
  if (yyn == 37) {
#line 224
    goto case_37;
  }
#line 226
  if (yyn == 38) {
#line 226
    goto case_38;
  }
#line 228
  if (yyn == 39) {
#line 228
    goto case_39;
  }
#line 230
  if (yyn == 40) {
#line 230
    goto case_40;
  }
#line 232
  if (yyn == 41) {
#line 232
    goto case_41;
  }
#line 234
  if (yyn == 42) {
#line 234
    goto case_42;
  }
#line 236
  if (yyn == 43) {
#line 236
    goto case_43;
  }
#line 238
  if (yyn == 44) {
#line 238
    goto case_44;
  }
#line 240
  if (yyn == 45) {
#line 240
    goto case_45;
  }
#line 242
  if (yyn == 46) {
#line 242
    goto case_46;
  }
#line 252
  if (yyn == 47) {
#line 252
    goto case_47;
  }
#line 254
  if (yyn == 48) {
#line 254
    goto case_48;
  }
#line 258
  if (yyn == 49) {
#line 258
    goto case_49;
  }
#line 267
  if (yyn == 50) {
#line 267
    goto case_50;
  }
#line 269
  if (yyn == 51) {
#line 269
    goto case_51;
  }
#line 271
  if (yyn == 52) {
#line 271
    goto case_52;
  }
#line 280
  if (yyn == 53) {
#line 280
    goto case_53;
  }
#line 282
  if (yyn == 54) {
#line 282
    goto case_54;
  }
#line 292
  if (yyn == 55) {
#line 292
    goto case_55;
  }
#line 296
  if (yyn == 56) {
#line 296
    goto case_56;
  }
#line 298
  if (yyn == 57) {
#line 298
    goto case_57;
  }
#line 302
  if (yyn == 58) {
#line 302
    goto case_58;
  }
#line 303
  if (yyn == 59) {
#line 303
    goto case_59;
  }
#line 304
  if (yyn == 60) {
#line 304
    goto case_60;
  }
#line 313
  if (yyn == 61) {
#line 313
    goto case_61;
  }
#line 315
  if (yyn == 62) {
#line 315
    goto case_62;
  }
#line 317
  if (yyn == 63) {
#line 317
    goto case_63;
  }
#line 326
  if (yyn == 64) {
#line 326
    goto case_64;
  }
#line 328
  if (yyn == 65) {
#line 328
    goto case_65;
  }
#line 332
  if (yyn == 66) {
#line 332
    goto case_66;
  }
#line 334
  if (yyn == 67) {
#line 334
    goto case_67;
  }
#line 336
  if (yyn == 68) {
#line 336
    goto case_68;
  }
#line 338
  if (yyn == 69) {
#line 338
    goto case_69;
  }
#line 340
  if (yyn == 70) {
#line 340
    goto case_70;
  }
#line 342
  if (yyn == 71) {
#line 342
    goto case_71;
  }
#line 344
  if (yyn == 72) {
#line 344
    goto case_72;
  }
#line 353
  if (yyn == 73) {
#line 353
    goto case_73;
  }
#line 1252 "y.tab.c"
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 130 "jamgram.y"
  parse_save((yyvsp + 0)->parse);
  }
#line 131
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 141
  yyval.parse = parse_make(& compile_null, (PARSE *)0, (PARSE *)0, (PARSE *)0, (char const   *)((char *)0),
                           (char const   *)((char *)0), 0);
  }
#line 142
  goto switch_break;
  case_5: /* CIL Label */ 
#line 143
  yyval.parse = (yyvsp + 0)->parse;
#line 144
  goto switch_break;
  case_6: /* CIL Label */ 
#line 147
  yyval.parse = (yyvsp + 0)->parse;
#line 148
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 149
  yyval.parse = parse_make(& compile_rules, (yyvsp + -1)->parse, (yyvsp + 0)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           0);
  }
#line 150
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 151
  tmp___0 = parse_make(& compile_null, (PARSE *)0, (PARSE *)0, (PARSE *)0, (char const   *)((char *)0),
                       (char const   *)((char *)0), 0);
#line 151
  yyval.parse = parse_make(& compile_local, (yyvsp + -2)->parse, tmp___0, (yyvsp + 0)->parse,
                           (char const   *)((char *)0), (char const   *)((char *)0),
                           0);
  }
#line 152
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 153
  yyval.parse = parse_make(& compile_local, (yyvsp + -4)->parse, (yyvsp + -2)->parse,
                           (yyvsp + 0)->parse, (char const   *)((char *)0), (char const   *)((char *)0),
                           0);
  }
#line 154
  goto switch_break;
  case_10: /* CIL Label */ 
#line 157
  yyval.parse = (yyvsp + -1)->parse;
#line 158
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 159
  yyval.parse = parse_make(& compile_include, (yyvsp + -1)->parse, (PARSE *)0, (PARSE *)0,
                           (char const   *)((char *)0), (char const   *)((char *)0),
                           0);
  }
#line 160
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 161
  yyval.parse = parse_make(& compile_rule, (yyvsp + -2)->parse, (yyvsp + -1)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           0);
  }
#line 162
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 163
  yyval.parse = parse_make(& compile_set, (yyvsp + -3)->parse, (yyvsp + -1)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           (yyvsp + -2)->number);
  }
#line 164
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 165
  yyval.parse = parse_make(& compile_settings, (yyvsp + -5)->parse, (yyvsp + -3)->parse,
                           (yyvsp + -1)->parse, (char const   *)((char *)0), (char const   *)((char *)0),
                           (yyvsp + -2)->number);
  }
#line 166
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 167
  yyval.parse = parse_make(& compile_break, (yyvsp + -1)->parse, (PARSE *)0, (PARSE *)0,
                           (char const   *)((char *)0), (char const   *)((char *)0),
                           1);
  }
#line 168
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 169
  yyval.parse = parse_make(& compile_break, (yyvsp + -1)->parse, (PARSE *)0, (PARSE *)0,
                           (char const   *)((char *)0), (char const   *)((char *)0),
                           2);
  }
#line 170
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 171
  yyval.parse = parse_make(& compile_break, (yyvsp + -1)->parse, (PARSE *)0, (PARSE *)0,
                           (char const   *)((char *)0), (char const   *)((char *)0),
                           3);
  }
#line 172
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 173
  yyval.parse = parse_make(& compile_foreach, (yyvsp + -3)->parse, (yyvsp + -1)->parse,
                           (PARSE *)0, (yyvsp + -5)->string, (char const   *)((char *)0),
                           0);
  }
#line 174
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 175
  yyval.parse = parse_make(& compile_switch, (yyvsp + -3)->parse, (yyvsp + -1)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           0);
  }
#line 176
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 177
  tmp___1 = parse_make(& compile_null, (PARSE *)0, (PARSE *)0, (PARSE *)0, (char const   *)((char *)0),
                       (char const   *)((char *)0), 0);
#line 177
  yyval.parse = parse_make(& compile_if, (yyvsp + -3)->parse, (yyvsp + -1)->parse,
                           tmp___1, (char const   *)((char *)0), (char const   *)((char *)0),
                           0);
  }
#line 178
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 179
  yyval.parse = parse_make(& compile_if, (yyvsp + -5)->parse, (yyvsp + -3)->parse,
                           (yyvsp + 0)->parse, (char const   *)((char *)0), (char const   *)((char *)0),
                           0);
  }
#line 180
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 181
  yyval.parse = parse_make(& compile_while, (yyvsp + -3)->parse, (yyvsp + -1)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           0);
  }
#line 182
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 183
  yyval.parse = parse_make(& compile_setcomp, (yyvsp + -3)->parse, (yyvsp + -1)->parse,
                           (PARSE *)0, (yyvsp + -4)->string, (char const   *)((char *)0),
                           0);
  }
#line 184
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 185
  yyval.parse = parse_make(& compile_on, (yyvsp + -1)->parse, (yyvsp + 0)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           0);
  }
#line 186
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 187
  yymode(1);
  }
#line 188
  goto switch_break;
  case_26: /* CIL Label */ 
  {
#line 189
  yymode(0);
  }
#line 190
  goto switch_break;
  case_27: /* CIL Label */ 
  {
#line 191
  yyval.parse = parse_make(& compile_setexec, (yyvsp + -5)->parse, (PARSE *)0, (PARSE *)0,
                           (yyvsp + -6)->string, (yyvsp + -2)->string, (yyvsp + -7)->number);
  }
#line 192
  goto switch_break;
  case_28: /* CIL Label */ 
#line 199
  yyval.number = 0;
#line 200
  goto switch_break;
  case_29: /* CIL Label */ 
#line 201
  yyval.number = 1;
#line 202
  goto switch_break;
  case_30: /* CIL Label */ 
#line 203
  yyval.number = 2;
#line 204
  goto switch_break;
  case_31: /* CIL Label */ 
#line 205
  yyval.number = 2;
#line 206
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 213
  tmp___2 = parse_make(& compile_null, (PARSE *)0, (PARSE *)0, (PARSE *)0, (char const   *)((char *)0),
                       (char const   *)((char *)0), 0);
#line 213
  yyval.parse = parse_make(& compile_eval, (yyvsp + 0)->parse, tmp___2, (PARSE *)0,
                           (char const   *)((char *)0), (char const   *)((char *)0),
                           3);
  }
#line 214
  goto switch_break;
  case_33: /* CIL Label */ 
  {
#line 215
  yyval.parse = parse_make(& compile_eval, (yyvsp + -2)->parse, (yyvsp + 0)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           4);
  }
#line 216
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 217
  yyval.parse = parse_make(& compile_eval, (yyvsp + -2)->parse, (yyvsp + 0)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           5);
  }
#line 218
  goto switch_break;
  case_35: /* CIL Label */ 
  {
#line 219
  yyval.parse = parse_make(& compile_eval, (yyvsp + -2)->parse, (yyvsp + 0)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           6);
  }
#line 220
  goto switch_break;
  case_36: /* CIL Label */ 
  {
#line 221
  yyval.parse = parse_make(& compile_eval, (yyvsp + -2)->parse, (yyvsp + 0)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           7);
  }
#line 222
  goto switch_break;
  case_37: /* CIL Label */ 
  {
#line 223
  yyval.parse = parse_make(& compile_eval, (yyvsp + -2)->parse, (yyvsp + 0)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           8);
  }
#line 224
  goto switch_break;
  case_38: /* CIL Label */ 
  {
#line 225
  yyval.parse = parse_make(& compile_eval, (yyvsp + -2)->parse, (yyvsp + 0)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           9);
  }
#line 226
  goto switch_break;
  case_39: /* CIL Label */ 
  {
#line 227
  yyval.parse = parse_make(& compile_eval, (yyvsp + -2)->parse, (yyvsp + 0)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           1);
  }
#line 228
  goto switch_break;
  case_40: /* CIL Label */ 
  {
#line 229
  yyval.parse = parse_make(& compile_eval, (yyvsp + -2)->parse, (yyvsp + 0)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           1);
  }
#line 230
  goto switch_break;
  case_41: /* CIL Label */ 
  {
#line 231
  yyval.parse = parse_make(& compile_eval, (yyvsp + -2)->parse, (yyvsp + 0)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           2);
  }
#line 232
  goto switch_break;
  case_42: /* CIL Label */ 
  {
#line 233
  yyval.parse = parse_make(& compile_eval, (yyvsp + -2)->parse, (yyvsp + 0)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           2);
  }
#line 234
  goto switch_break;
  case_43: /* CIL Label */ 
  {
#line 235
  yyval.parse = parse_make(& compile_eval, (yyvsp + -2)->parse, (yyvsp + 0)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           10);
  }
#line 236
  goto switch_break;
  case_44: /* CIL Label */ 
  {
#line 237
  tmp___3 = parse_make(& compile_null, (PARSE *)0, (PARSE *)0, (PARSE *)0, (char const   *)((char *)0),
                       (char const   *)((char *)0), 0);
#line 237
  yyval.parse = parse_make(& compile_eval, (yyvsp + 0)->parse, tmp___3, (PARSE *)0,
                           (char const   *)((char *)0), (char const   *)((char *)0),
                           0);
  }
#line 238
  goto switch_break;
  case_45: /* CIL Label */ 
#line 239
  yyval.parse = (yyvsp + -1)->parse;
#line 240
  goto switch_break;
  case_46: /* CIL Label */ 
#line 249
  yyval.parse = (PARSE *)0;
#line 250
  goto switch_break;
  case_47: /* CIL Label */ 
  {
#line 251
  yyval.parse = parse_make((LIST *(*)(PARSE * , LOL * , int * ))0, (yyvsp + -1)->parse,
                           (yyvsp + 0)->parse, (PARSE *)0, (char const   *)((char *)0),
                           (char const   *)((char *)0), 0);
  }
#line 252
  goto switch_break;
  case_48: /* CIL Label */ 
  {
#line 255
  yyval.parse = parse_make((LIST *(*)(PARSE * , LOL * , int * ))0, (yyvsp + 0)->parse,
                           (PARSE *)0, (PARSE *)0, (yyvsp + -2)->string, (char const   *)((char *)0),
                           0);
  }
#line 256
  goto switch_break;
  case_49: /* CIL Label */ 
#line 264
  yyval.parse = (PARSE *)0;
#line 265
  goto switch_break;
  case_50: /* CIL Label */ 
  {
#line 266
  yyval.parse = parse_make((LIST *(*)(PARSE * , LOL * , int * ))0, (yyvsp + 0)->parse,
                           (PARSE *)0, (PARSE *)0, (yyvsp + -2)->string, (char const   *)((char *)0),
                           0);
  }
#line 267
  goto switch_break;
  case_51: /* CIL Label */ 
  {
#line 268
  yyval.parse = parse_make((LIST *(*)(PARSE * , LOL * , int * ))0, (PARSE *)0, (PARSE *)0,
                           (PARSE *)0, (yyvsp + 0)->string, (char const   *)((char *)0),
                           0);
  }
#line 269
  goto switch_break;
  case_52: /* CIL Label */ 
  {
#line 277
  yyval.parse = parse_make((LIST *(*)(PARSE * , LOL * , int * ))0, (PARSE *)0, (yyvsp + 0)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           0);
  }
#line 278
  goto switch_break;
  case_53: /* CIL Label */ 
  {
#line 279
  yyval.parse = parse_make((LIST *(*)(PARSE * , LOL * , int * ))0, (yyvsp + 0)->parse,
                           (yyvsp + -2)->parse, (PARSE *)0, (char const   *)((char *)0),
                           (char const   *)((char *)0), 0);
  }
#line 280
  goto switch_break;
  case_54: /* CIL Label */ 
  {
#line 289
  yyval.parse = (yyvsp + 0)->parse;
#line 289
  yymode(0);
  }
#line 290
  goto switch_break;
  case_55: /* CIL Label */ 
  {
#line 293
  yyval.parse = parse_make(& compile_null, (PARSE *)0, (PARSE *)0, (PARSE *)0, (char const   *)((char *)0),
                           (char const   *)((char *)0), 0);
#line 293
  yymode(2);
  }
#line 294
  goto switch_break;
  case_56: /* CIL Label */ 
  {
#line 295
  yyval.parse = parse_make(& compile_append, (yyvsp + -1)->parse, (yyvsp + 0)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           0);
  }
#line 296
  goto switch_break;
  case_57: /* CIL Label */ 
  {
#line 299
  yyval.parse = parse_make(& compile_list, (PARSE *)0, (PARSE *)0, (PARSE *)0, (yyvsp + 0)->string,
                           (char const   *)((char *)0), 0);
  }
#line 300
  goto switch_break;
  case_58: /* CIL Label */ 
  {
#line 300
  yymode(0);
  }
#line 301
  goto switch_break;
  case_59: /* CIL Label */ 
#line 301
  yyval.parse = (yyvsp + -1)->parse;
#line 302
  goto switch_break;
  case_60: /* CIL Label */ 
  {
#line 310
  yyval.parse = parse_make(& compile_rule, (yyvsp + -1)->parse, (yyvsp + 0)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           0);
  }
#line 311
  goto switch_break;
  case_61: /* CIL Label */ 
  {
#line 312
  tmp___4 = parse_make(& compile_rule, (yyvsp + -1)->parse, (yyvsp + 0)->parse, (PARSE *)0,
                       (char const   *)((char *)0), (char const   *)((char *)0), 0);
#line 312
  yyval.parse = parse_make(& compile_on, (yyvsp + -2)->parse, tmp___4, (PARSE *)0,
                           (char const   *)((char *)0), (char const   *)((char *)0),
                           0);
  }
#line 313
  goto switch_break;
  case_62: /* CIL Label */ 
  {
#line 314
  yyval.parse = parse_make(& compile_on, (yyvsp + -2)->parse, (yyvsp + 0)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           0);
  }
#line 315
  goto switch_break;
  case_63: /* CIL Label */ 
#line 323
  yyval.number = 0;
#line 324
  goto switch_break;
  case_64: /* CIL Label */ 
#line 325
  yyval.number = (yyvsp + -1)->number | (yyvsp + 0)->number;
#line 326
  goto switch_break;
  case_65: /* CIL Label */ 
#line 329
  yyval.number = 1;
#line 330
  goto switch_break;
  case_66: /* CIL Label */ 
#line 331
  yyval.number = 2;
#line 332
  goto switch_break;
  case_67: /* CIL Label */ 
#line 333
  yyval.number = 4;
#line 334
  goto switch_break;
  case_68: /* CIL Label */ 
#line 335
  yyval.number = 8;
#line 336
  goto switch_break;
  case_69: /* CIL Label */ 
#line 337
  yyval.number = 16;
#line 338
  goto switch_break;
  case_70: /* CIL Label */ 
#line 339
  yyval.number = 32;
#line 340
  goto switch_break;
  case_71: /* CIL Label */ 
  {
#line 341
  tmp___5 = atoi((yyvsp + 0)->string);
#line 341
  yyval.number = tmp___5 * 64;
  }
#line 342
  goto switch_break;
  case_72: /* CIL Label */ 
  {
#line 350
  yyval.parse = parse_make(& compile_null, (PARSE *)0, (PARSE *)0, (PARSE *)0, (char const   *)((char *)0),
                           (char const   *)((char *)0), 0);
  }
#line 351
  goto switch_break;
  case_73: /* CIL Label */ 
#line 352
  yyval.parse = (yyvsp + 0)->parse;
#line 353
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1615 "y.tab.c"
  yyvsp -= yylen;
#line 1616
  yyssp -= yylen;
#line 1621
  yyvsp ++;
#line 1621
  *yyvsp = yyval;
#line 1628
  yyn = (int )yyr1[yyn];
#line 1630
  yystate = (int )((int const   )yypgoto[yyn - 50] + (int const   )*yyssp);
#line 1631
  if (0 <= yystate) {
#line 1631
    if (yystate <= 250) {
#line 1631
      if ((int const   )yycheck[yystate] == (int const   )*yyssp) {
#line 1632
        yystate = (int )yytable[yystate];
      } else {
#line 1634
        yystate = (int )yydefgoto[yyn - 50];
      }
    } else {
#line 1634
      yystate = (int )yydefgoto[yyn - 50];
    }
  } else {
#line 1634
    yystate = (int )yydefgoto[yyn - 50];
  }
#line 1636
  goto yynewstate;
  yyerrlab: 
#line 1644
  if (! yyerrstatus) {
    {
#line 1646
    yynerrs ++;
#line 1694
    yyerror("syntax error");
    }
  }
#line 1699
  if (yyerrstatus == 3) {
#line 1705
    if (yychar == 0) {
#line 1708
      yyvsp --;
#line 1708
      yyssp --;
      {
#line 1710
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1710
        if (! ((unsigned long )yyss < (unsigned long )yyssp)) {
#line 1710
          goto while_break___2;
        }
        {
#line 1713
        yydestruct((int )yystos[*yyssp], yyvsp);
#line 1714
        yyvsp --;
#line 1714
        yyssp --;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1716
      goto yyabortlab;
    }
    {
#line 1720
    yydestruct(yytoken, & yylval);
#line 1721
    yychar = -2;
    }
  }
#line 1727
  goto yyerrlab1;
  yyerrlab1: 
#line 1734
  yyerrstatus = 3;
  {
#line 1736
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1738
    yyn = (int )yypact[yystate];
#line 1739
    if (yyn != -48) {
#line 1741
      yyn ++;
#line 1742
      if (0 <= yyn) {
#line 1742
        if (yyn <= 250) {
#line 1742
          if ((int const   )yycheck[yyn] == 1) {
#line 1744
            yyn = (int )yytable[yyn];
#line 1745
            if (0 < yyn) {
#line 1746
              goto while_break___3;
            }
          }
        }
      }
    }
#line 1751
    if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 1752
      goto yyabortlab;
    }
    {
#line 1755
    yydestruct((int )yystos[yystate], yyvsp);
#line 1756
    yyvsp --;
#line 1757
    yyssp --;
#line 1757
    yystate = (int )*yyssp;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1762
  if (yyn == 39) {
#line 1763
    goto yyacceptlab;
  }
#line 1767
  yyvsp ++;
#line 1767
  *yyvsp = yylval;
#line 1770
  yystate = yyn;
#line 1771
  goto yynewstate;
  yyacceptlab: 
#line 1778
  yyresult = 0;
#line 1779
  goto yyreturn;
  yyabortlab: 
#line 1785
  yyresult = 1;
#line 1786
  goto yyreturn;
  yyoverflowlab: 
  {
#line 1793
  yyerror("parser stack overflow");
#line 1794
  yyresult = 2;
  }
  yyreturn: 
#line 1800
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
#line 1801
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1801
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 1803
  return (yyresult);
}
}
#line 573 "/usr/include/stdio.h"
extern int fputc(int __c , FILE *__stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 96 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/newstr.h"
char const   *newstr(char const   *string ) ;
#line 14
char const   *copystr(char const   *s ) ;
#line 15
void freestr(char const   *s ) ;
#line 68 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/lists.h"
LIST *list_append(LIST *l , LIST *nl ) ;
#line 73
int list_length(LIST *l ) ;
#line 74
LIST *list_sublist(LIST *l , int start , int count ) ;
#line 80
void lol_add(LOL *lol , LIST *l ) ;
#line 81
void lol_init(LOL *lol ) ;
#line 82
void lol_free(LOL *lol ) ;
#line 84
void lol_print(LOL *lol ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/lists.c"
static LIST *freelist  =    (LIST *)0;
#line 37 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/lists.c"
LIST *list_append(LIST *l , LIST *nl ) 
{ 


  {
#line 42
  if (! (! nl)) {
#line 46
    if (! l) {
#line 48
      l = nl;
    } else {
#line 53
      (l->tail)->next = nl;
#line 54
      l->tail = nl->tail;
    }
  }
#line 57
  return (l);
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/lists.c"
LIST *list_new(LIST *head , char const   *string , int copy ) 
{ 
  LIST *l ;
  char const   *tmp ;
  char const   *tmp___0 ;
  void *tmp___1 ;

  {
#line 72
  if (globs.debug[9]) {
    {
#line 73
    printf((char const   */* __restrict  */)"list > %s <\n", string);
    }
  }
#line 77
  if (copy) {
    {
#line 77
    tmp = copystr(string);
#line 77
    string = tmp;
    }
  } else {
    {
#line 77
    tmp___0 = newstr(string);
#line 77
    string = tmp___0;
    }
  }
#line 83
  if (freelist) {
    {
#line 85
    l = freelist;
#line 86
    freestr(l->string);
#line 87
    freelist = freelist->next;
    }
  } else {
    {
#line 91
    tmp___1 = malloc(sizeof(*l));
#line 91
    l = (LIST *)tmp___1;
    }
  }
#line 98
  if (! head) {
#line 98
    head = l;
  } else {
#line 99
    (head->tail)->next = l;
  }
#line 100
  head->tail = l;
#line 101
  l->next = (LIST *)0;
#line 103
  l->string = string;
#line 105
  return (head);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/lists.c"
LIST *list_copy(LIST *l , LIST *nl ) 
{ 


  {
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! nl) {
#line 117
      goto while_break;
    }
    {
#line 118
    l = list_new(l, nl->string, 1);
#line 117
    nl = nl->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  return (l);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/lists.c"
LIST *list_sublist(LIST *l , int start , int count ) 
{ 
  LIST *nl ;
  int tmp ;
  int tmp___0 ;

  {
#line 133
  nl = (LIST *)0;
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (l) {
#line 135
      tmp = start;
#line 135
      start --;
#line 135
      if (! tmp) {
#line 135
        goto while_break;
      }
    } else {
#line 135
      goto while_break;
    }
#line 135
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 138
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 138
    if (l) {
#line 138
      tmp___0 = count;
#line 138
      count --;
#line 138
      if (! tmp___0) {
#line 138
        goto while_break___0;
      }
    } else {
#line 138
      goto while_break___0;
    }
    {
#line 139
    nl = list_new(nl, l->string, 1);
#line 138
    l = l->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 141
  return (nl);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/lists.c"
void list_free(LIST *head ) 
{ 


  {
#line 153
  if (head) {
#line 155
    (head->tail)->next = freelist;
#line 156
    freelist = head;
  }
#line 158
  return;
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/lists.c"
void list_print(LIST *l ) 
{ 


  {
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! l) {
#line 167
      goto while_break;
    }
    {
#line 168
    printf((char const   */* __restrict  */)"%s ", l->string);
#line 167
    l = l->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 169
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/lists.c"
void list_printq(FILE *out , LIST *l ) 
{ 
  char const   *p ;
  char const   *ep ;
  size_t tmp ;
  char const   *op ;
  void *tmp___0 ;

  {
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (! l) {
#line 181
      goto while_break;
    }
    {
#line 183
    p = l->string;
#line 184
    tmp = strlen(p);
#line 184
    ep = p + tmp;
#line 185
    op = p;
#line 187
    fputc('\n', out);
#line 188
    fputc('\t', out);
#line 189
    fputc('\"', out);
    }
    {
#line 193
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 193
      tmp___0 = memchr((void const   *)op, '\"', (size_t )(ep - op));
#line 193
      p = (char const   *)((char *)tmp___0);
      }
#line 193
      if (! p) {
#line 193
        goto while_break___0;
      }
      {
#line 195
      fwrite((void const   */* __restrict  */)op, (size_t )(p - op), (size_t )1, (FILE */* __restrict  */)out);
#line 196
      fputc('\\', out);
#line 197
      fputc('\"', out);
#line 198
      op = p + 1;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 203
    fwrite((void const   */* __restrict  */)op, (size_t )(ep - op), (size_t )1, (FILE */* __restrict  */)out);
#line 204
    fputc('\"', out);
#line 205
    fputc(' ', out);
#line 181
    l = l->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 207
  return;
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/lists.c"
int list_length(LIST *l ) 
{ 
  int n ;

  {
#line 216
  n = 0;
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 218
    if (! l) {
#line 218
      goto while_break;
    }
#line 218
    l = l->next;
#line 218
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 221
  return (n);
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/lists.c"
void lol_init(LOL *lol ) 
{ 


  {
#line 231
  lol->count = 0;
#line 232
  return;
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/lists.c"
void lol_add(LOL *lol , LIST *l ) 
{ 
  int tmp ;

  {
#line 243
  if (lol->count < 9) {
#line 244
    tmp = lol->count;
#line 244
    (lol->count) ++;
#line 244
    lol->list[tmp] = l;
  }
#line 245
  return;
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/lists.c"
void lol_free(LOL *lol ) 
{ 
  int i ;

  {
#line 256
  i = 0;
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 256
    if (! (i < lol->count)) {
#line 256
      goto while_break;
    }
    {
#line 257
    list_free(lol->list[i]);
#line 256
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 259
  lol->count = 0;
#line 260
  return;
}
}
#line 266 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/lists.c"
LIST *lol_get(LOL *lol , int i ) 
{ 
  LIST *tmp ;

  {
#line 271
  if (i < lol->count) {
#line 271
    tmp = lol->list[i];
  } else {
#line 271
    tmp = (LIST *)0;
  }
#line 271
  return (tmp);
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/lists.c"
void lol_print(LOL *lol ) 
{ 
  int i ;

  {
#line 283
  i = 0;
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    if (! (i < lol->count)) {
#line 283
      goto while_break;
    }
#line 285
    if (i) {
      {
#line 286
      printf((char const   */* __restrict  */)" : ");
      }
    }
    {
#line 287
    list_print(lol->list[i]);
#line 283
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 289
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/parse.h"
void parse_refer(PARSE *p ) ;
#line 44
void parse_free(PARSE *p ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/compile.h"
LIST *evaluate_rule(char const   *rulename , LOL *args , LIST *result ) ;
#line 167 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/rules.h"
RULE *bindrule(char const   *rulename ) ;
#line 171
TARGETS *targetlist(TARGETS *chain , LIST *targets ) ;
#line 174
ACTIONS *actionlist(ACTIONS *chain , ACTION *action ) ;
#line 175
SETTINGS *addsettings(SETTINGS *head , int setflag , char const   *symbol , LIST *value ) ;
#line 82 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/compile.c"
static char const   *set_names[3]  = {      "=",      "+=",      "?="};
#line 83
static void debug_compile(int which , char const   *s ) ;
#line 95 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/compile.c"
LIST *compile_append(PARSE *parse , LOL *args , int *jmp ) 
{ 
  LIST *tmp ;
  LIST *tmp___0 ;
  LIST *tmp___1 ;

  {
  {
#line 103
  tmp = (*((parse->right)->func))(parse->right, args, jmp);
#line 103
  tmp___0 = (*((parse->left)->func))(parse->left, args, jmp);
#line 103
  tmp___1 = list_append(tmp___0, tmp);
  }
#line 103
  return (tmp___1);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/compile.c"
LIST *compile_break(PARSE *parse , LOL *args , int *jmp ) 
{ 
  LIST *lv ;
  LIST *tmp ;

  {
  {
#line 121
  tmp = (*((parse->left)->func))(parse->left, args, jmp);
#line 121
  lv = tmp;
#line 122
  *jmp = parse->num;
  }
#line 123
  return (lv);
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/compile.c"
static int lcmp(LIST *t , LIST *s ) 
{ 
  int status ;
  char const   *st ;
  char const   *tmp ;
  char const   *ss ;
  char const   *tmp___0 ;

  {
#line 137
  status = 0;
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    if (! status) {
#line 139
      if (! t) {
#line 139
        if (! s) {
#line 139
          goto while_break;
        }
      }
    } else {
#line 139
      goto while_break;
    }
#line 141
    if (t) {
#line 141
      tmp = t->string;
    } else {
#line 141
      tmp = "";
    }
#line 141
    st = tmp;
#line 142
    if (s) {
#line 142
      tmp___0 = s->string;
    } else {
#line 142
      tmp___0 = "";
    }
    {
#line 142
    ss = tmp___0;
#line 144
    status = strcmp(st, ss);
    }
#line 146
    if (t) {
#line 146
      t = t->next;
    } else {
#line 146
      t = t;
    }
#line 147
    if (s) {
#line 147
      s = s->next;
    } else {
#line 147
      s = s;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 150
  return (status);
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/compile.c"
LIST *compile_eval(PARSE *parse , LOL *args , int *jmp ) 
{ 
  LIST *ll ;
  LIST *lr ;
  LIST *s ;
  LIST *t ;
  int status ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 160
  status = 0;
#line 164
  ll = (*((parse->left)->func))(parse->left, args, jmp);
#line 165
  lr = (LIST *)0;
  }
  {
#line 170
  if (parse->num == 10) {
#line 170
    goto case_10;
  }
#line 170
  if (parse->num == 1) {
#line 170
    goto case_10;
  }
#line 171
  if (parse->num == 2) {
#line 171
    goto case_2;
  }
#line 172
  goto eval;
  case_10: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 170
  if (ll) {
#line 170
    goto eval;
  }
#line 170
  goto switch_break;
  case_2: /* CIL Label */ 
#line 171
  if (! ll) {
#line 171
    goto eval;
  }
#line 171
  goto switch_break;
  eval: 
  switch_default: /* CIL Label */ 
  {
#line 172
  lr = (*((parse->right)->func))(parse->right, args, jmp);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 179
  if (parse->num == 0) {
#line 179
    goto case_0;
  }
#line 183
  if (parse->num == 1) {
#line 183
    goto case_1___0;
  }
#line 187
  if (parse->num == 2) {
#line 187
    goto case_2___0;
  }
#line 191
  if (parse->num == 10) {
#line 191
    goto case_10___0;
  }
#line 209
  if (parse->num == 3) {
#line 209
    goto case_3;
  }
#line 210
  if (parse->num == 4) {
#line 210
    goto case_4;
  }
#line 211
  if (parse->num == 5) {
#line 211
    goto case_5;
  }
#line 212
  if (parse->num == 6) {
#line 212
    goto case_6;
  }
#line 213
  if (parse->num == 7) {
#line 213
    goto case_7;
  }
#line 214
  if (parse->num == 8) {
#line 214
    goto case_8;
  }
#line 215
  if (parse->num == 9) {
#line 215
    goto case_9;
  }
#line 177
  goto switch_break___0;
  case_0: /* CIL Label */ 
#line 180
  if (! ll) {
#line 180
    status = 1;
  }
#line 181
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 184
  if (ll) {
#line 184
    if (lr) {
#line 184
      status = 1;
    }
  }
#line 185
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 188
  if (ll) {
#line 188
    status = 1;
  } else
#line 188
  if (lr) {
#line 188
    status = 1;
  }
#line 189
  goto switch_break___0;
  case_10___0: /* CIL Label */ 
#line 195
  t = ll;
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if (! t) {
#line 195
      goto while_break;
    }
#line 197
    s = lr;
    {
#line 197
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 197
      if (! s) {
#line 197
        goto while_break___0;
      }
      {
#line 198
      tmp = strcmp(t->string, s->string);
      }
#line 198
      if (! tmp) {
#line 199
        goto while_break___0;
      }
#line 197
      s = s->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 200
    if (! s) {
#line 200
      goto while_break;
    }
#line 195
    t = t->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  if (! t) {
#line 205
    status = 1;
  }
#line 207
  goto switch_break___0;
  case_3: /* CIL Label */ 
  {
#line 209
  tmp___0 = lcmp(ll, (LIST *)0);
  }
#line 209
  if (tmp___0 != 0) {
#line 209
    status = 1;
  }
#line 209
  goto switch_break___0;
  case_4: /* CIL Label */ 
  {
#line 210
  tmp___1 = lcmp(ll, lr);
  }
#line 210
  if (tmp___1 == 0) {
#line 210
    status = 1;
  }
#line 210
  goto switch_break___0;
  case_5: /* CIL Label */ 
  {
#line 211
  tmp___2 = lcmp(ll, lr);
  }
#line 211
  if (tmp___2 != 0) {
#line 211
    status = 1;
  }
#line 211
  goto switch_break___0;
  case_6: /* CIL Label */ 
  {
#line 212
  tmp___3 = lcmp(ll, lr);
  }
#line 212
  if (tmp___3 < 0) {
#line 212
    status = 1;
  }
#line 212
  goto switch_break___0;
  case_7: /* CIL Label */ 
  {
#line 213
  tmp___4 = lcmp(ll, lr);
  }
#line 213
  if (tmp___4 <= 0) {
#line 213
    status = 1;
  }
#line 213
  goto switch_break___0;
  case_8: /* CIL Label */ 
  {
#line 214
  tmp___5 = lcmp(ll, lr);
  }
#line 214
  if (tmp___5 > 0) {
#line 214
    status = 1;
  }
#line 214
  goto switch_break___0;
  case_9: /* CIL Label */ 
  {
#line 215
  tmp___6 = lcmp(ll, lr);
  }
#line 215
  if (tmp___6 >= 0) {
#line 215
    status = 1;
  }
#line 215
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 219
  if (globs.debug[8]) {
    {
#line 221
    debug_compile(0, "if");
#line 222
    list_print(ll);
#line 223
    printf((char const   */* __restrict  */)"(%d) ", status);
#line 224
    list_print(lr);
#line 225
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 232
  if (! status) {
#line 232
    t = (LIST *)0;
  } else
#line 233
  if (ll) {
#line 233
    t = ll;
#line 233
    ll = (LIST *)0;
  } else
#line 234
  if (lr) {
#line 234
    t = lr;
#line 234
    lr = (LIST *)0;
  } else {
    {
#line 235
    t = list_new((LIST *)0, "1", 0);
    }
  }
#line 237
  if (ll) {
    {
#line 237
    list_free(ll);
    }
  }
#line 238
  if (lr) {
    {
#line 238
    list_free(lr);
    }
  }
#line 239
  return (t);
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/compile.c"
LIST *compile_foreach(PARSE *p , LOL *args , int *jmp ) 
{ 
  LIST *nv ;
  LIST *tmp ;
  LIST *result ;
  LIST *l ;
  LIST *tmp___0 ;

  {
  {
#line 259
  tmp = (*((p->left)->func))(p->left, args, jmp);
#line 259
  nv = tmp;
#line 260
  result = (LIST *)0;
#line 265
  l = nv;
  }
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 265
    if (l) {
#line 265
      if (! (*jmp == 0)) {
#line 265
        goto while_break;
      }
    } else {
#line 265
      goto while_break;
    }
    {
#line 269
    tmp___0 = list_new((LIST *)0, l->string, 1);
#line 269
    var_set(p->string, tmp___0, 0);
#line 273
    list_free(result);
#line 274
    result = (*((p->right)->func))(p->right, args, jmp);
    }
#line 278
    if (*jmp == 2) {
#line 279
      *jmp = 0;
    }
#line 265
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 284
  if (*jmp == 1) {
#line 285
    *jmp = 0;
  } else
#line 284
  if (*jmp == 2) {
#line 285
    *jmp = 0;
  }
  {
#line 287
  list_free(nv);
  }
#line 291
  return (result);
}
}
#line 302 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/compile.c"
LIST *compile_if(PARSE *p , LOL *args , int *jmp ) 
{ 
  LIST *l ;
  LIST *tmp ;
  LIST *tmp___0 ;

  {
  {
#line 308
  tmp = (*((p->left)->func))(p->left, args, jmp);
#line 308
  l = tmp;
  }
#line 310
  if (l) {
#line 310
    p = p->right;
  } else {
#line 310
    p = p->third;
  }
  {
#line 312
  list_free(l);
#line 314
  tmp___0 = (*(p->func))(p, args, jmp);
  }
#line 314
  return (tmp___0);
}
}
#line 323 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/compile.c"
LIST *compile_include(PARSE *parse , LOL *args , int *jmp ) 
{ 
  LIST *nt ;
  LIST *tmp ;
  TARGET *t ;
  TARGET *tmp___0 ;

  {
  {
#line 329
  tmp = (*((parse->left)->func))(parse->left, args, jmp);
#line 329
  nt = tmp;
  }
#line 331
  if (globs.debug[5]) {
    {
#line 333
    debug_compile(0, "include");
#line 334
    list_print(nt);
#line 335
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 338
  if (nt) {
    {
#line 340
    tmp___0 = bindtarget(nt->string);
#line 340
    t = tmp___0;
#line 347
    pushsettings(t->settings);
#line 348
    t->boundname = search(t->name, & t->time);
#line 349
    popsettings(t->settings);
    }
#line 353
    if (t->time) {
      {
#line 354
      parse_file(t->boundname);
      }
    } else
#line 353
    if (! ((int )t->flags & 2)) {
      {
#line 354
      parse_file(t->boundname);
      }
    }
  }
  {
#line 357
  list_free(nt);
  }
#line 359
  return ((LIST *)0);
}
}
#line 368 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/compile.c"
LIST *compile_list(PARSE *parse , LOL *args , int *jmp ) 
{ 
  char const   *s ;
  size_t tmp ;
  LIST *tmp___0 ;

  {
  {
#line 375
  s = parse->string;
#line 376
  tmp = strlen(s);
#line 376
  tmp___0 = var_expand((LIST *)0, s, s + tmp, args, 1);
  }
#line 376
  return (tmp___0);
}
}
#line 387 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/compile.c"
LIST *compile_local(PARSE *parse , LOL *args , int *jmp ) 
{ 
  LIST *l ;
  SETTINGS *s ;
  LIST *nt ;
  LIST *tmp ;
  LIST *ns ;
  LIST *tmp___0 ;
  LIST *result ;
  LIST *tmp___1 ;

  {
  {
#line 394
  s = (SETTINGS *)0;
#line 395
  tmp = (*((parse->left)->func))(parse->left, args, jmp);
#line 395
  nt = tmp;
#line 396
  tmp___0 = (*((parse->right)->func))(parse->right, args, jmp);
#line 396
  ns = tmp___0;
  }
#line 399
  if (globs.debug[5]) {
    {
#line 401
    debug_compile(0, "local");
#line 402
    list_print(nt);
#line 403
    printf((char const   */* __restrict  */)" = ");
#line 404
    list_print(ns);
#line 405
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 410
  l = nt;
  {
#line 410
  while (1) {
    while_continue: /* CIL Label */ ;
#line 410
    if (! l) {
#line 410
      goto while_break;
    }
    {
#line 411
    tmp___1 = list_copy((LIST *)0, ns);
#line 411
    s = addsettings(s, 0, l->string, tmp___1);
#line 410
    l = l->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 413
  list_free(ns);
#line 414
  list_free(nt);
#line 419
  pushsettings(s);
#line 420
  result = (*((parse->third)->func))(parse->third, args, jmp);
#line 421
  popsettings(s);
#line 422
  freesettings(s);
  }
#line 424
  return (result);
}
}
#line 431 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/compile.c"
LIST *compile_null(PARSE *parse , LOL *args , int *jmp ) 
{ 


  {
#line 437
  return ((LIST *)0);
}
}
#line 447 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/compile.c"
LIST *compile_on(PARSE *parse , LOL *args , int *jmp ) 
{ 
  LIST *nt ;
  LIST *tmp ;
  LIST *result ;
  TARGET *t ;
  TARGET *tmp___0 ;
  SETTINGS *s ;
  SETTINGS *tmp___1 ;

  {
  {
#line 453
  tmp = (*((parse->left)->func))(parse->left, args, jmp);
#line 453
  nt = tmp;
#line 454
  result = (LIST *)0;
  }
#line 456
  if (globs.debug[5]) {
    {
#line 458
    debug_compile(0, "on");
#line 459
    list_print(nt);
#line 460
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 468
  if (nt) {
    {
#line 470
    tmp___0 = bindtarget(nt->string);
#line 470
    t = tmp___0;
#line 471
    tmp___1 = copysettings(t->settings);
#line 471
    s = tmp___1;
#line 473
    pushsettings(s);
#line 474
    result = (*((parse->right)->func))(parse->right, args, jmp);
#line 475
    popsettings(s);
#line 476
    freesettings(s);
    }
  }
  {
#line 479
  list_free(nt);
  }
#line 481
  return (result);
}
}
#line 493 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/compile.c"
LIST *compile_rule(PARSE *parse , LOL *args , int *jmp ) 
{ 
  LOL nargs[1] ;
  LIST *result ;
  LIST *ll ;
  LIST *l ;
  PARSE *p ;
  LIST *tmp ;

  {
  {
#line 500
  result = (LIST *)0;
#line 506
  ll = (*((parse->left)->func))(parse->left, args, jmp);
#line 510
  lol_init(nargs);
#line 512
  p = parse->right;
  }
  {
#line 512
  while (1) {
    while_continue: /* CIL Label */ ;
#line 512
    if (! p) {
#line 512
      goto while_break;
    }
    {
#line 513
    tmp = (*((p->right)->func))(p->right, args, jmp);
#line 513
    lol_add(nargs, tmp);
#line 512
    p = p->left;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 517
  l = ll;
  {
#line 517
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 517
    if (! l) {
#line 517
      goto while_break___0;
    }
    {
#line 518
    result = evaluate_rule(l->string, nargs, result);
#line 517
    l = l->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 520
  list_free(ll);
#line 521
  lol_free(nargs);
  }
#line 523
  return (result);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/compile.c"
LIST *evaluate_rule(char const   *rulename , LOL *args , LIST *result ) 
{ 
  RULE *rule ;
  RULE *tmp ;
  TARGETS *t ;
  ACTION *action ;
  void *tmp___0 ;
  LIST *tmp___1 ;
  LIST *tmp___2 ;
  PARSE *parse ;
  SETTINGS *s ;
  int jmp ;
  LIST *l ;
  int i ;
  LIST *tmp___3 ;
  LIST *tmp___4 ;
  LIST *tmp___5 ;

  {
  {
#line 536
  tmp = bindrule(rulename);
#line 536
  rule = tmp;
  }
#line 538
  if (globs.debug[5]) {
    {
#line 540
    debug_compile(1, rulename);
#line 541
    lol_print(args);
#line 542
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 547
  if (! rule->actions) {
#line 547
    if (! rule->procedure) {
      {
#line 548
      printf((char const   */* __restrict  */)"warning: unknown rule %s\n", rule->name);
      }
    }
  }
#line 553
  if (rule->actions) {
    {
#line 560
    tmp___0 = malloc(sizeof(ACTION ));
#line 560
    action = (ACTION *)tmp___0;
#line 561
    memset((void *)((char *)action), '\000', sizeof(*action));
#line 563
    action->rule = rule;
#line 564
    tmp___1 = lol_get(args, 0);
#line 564
    action->targets = targetlist((TARGETS *)0, tmp___1);
#line 565
    tmp___2 = lol_get(args, 1);
#line 565
    action->sources = targetlist((TARGETS *)0, tmp___2);
#line 569
    t = action->targets;
    }
    {
#line 569
    while (1) {
      while_continue: /* CIL Label */ ;
#line 569
      if (! t) {
#line 569
        goto while_break;
      }
      {
#line 570
      (t->target)->actions = actionlist((t->target)->actions, action);
#line 569
      t = t->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 575
  if (rule->procedure) {
#line 577
    parse = rule->procedure;
#line 578
    s = (SETTINGS *)0;
#line 579
    jmp = 0;
#line 585
    l = rule->params;
#line 585
    i = 0;
    {
#line 585
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 585
      if (! l) {
#line 585
        goto while_break___0;
      }
      {
#line 586
      tmp___3 = lol_get(args, i);
#line 586
      tmp___4 = list_copy((LIST *)0, tmp___3);
#line 586
      s = addsettings(s, 0, l->string, tmp___4);
#line 585
      l = l->next;
#line 585
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 593
    parse_refer(parse);
#line 595
    pushsettings(s);
#line 596
    tmp___5 = (*(parse->func))(parse, args, & jmp);
#line 596
    result = list_append(result, tmp___5);
#line 597
    popsettings(s);
#line 598
    freesettings(s);
#line 600
    parse_free(parse);
    }
  }
#line 603
  if (globs.debug[5]) {
    {
#line 604
    debug_compile(-1, (char const   *)0);
    }
  }
#line 606
  return (result);
}
}
#line 616 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/compile.c"
LIST *compile_rules(PARSE *parse , LOL *args , int *jmp ) 
{ 
  LIST *result ;

  {
#line 625
  result = (LIST *)0;
  {
#line 627
  while (1) {
    while_continue: /* CIL Label */ ;
#line 627
    if (*jmp == 0) {
#line 627
      if (! ((unsigned long )parse->func == (unsigned long )(& compile_rules))) {
#line 627
        goto while_break;
      }
    } else {
#line 627
      goto while_break;
    }
    {
#line 629
    list_free(result);
#line 630
    result = (*((parse->left)->func))(parse->left, args, jmp);
#line 631
    parse = parse->right;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 634
  if (*jmp == 0) {
    {
#line 636
    list_free(result);
#line 637
    result = (*(parse->func))(parse, args, jmp);
    }
  }
#line 640
  return (result);
}
}
#line 651 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/compile.c"
LIST *compile_set(PARSE *parse , LOL *args , int *jmp ) 
{ 
  LIST *nt ;
  LIST *tmp ;
  LIST *ns ;
  LIST *tmp___0 ;
  LIST *l ;
  LIST *tmp___1 ;

  {
  {
#line 657
  tmp = (*((parse->left)->func))(parse->left, args, jmp);
#line 657
  nt = tmp;
#line 658
  tmp___0 = (*((parse->right)->func))(parse->right, args, jmp);
#line 658
  ns = tmp___0;
  }
#line 661
  if (globs.debug[5]) {
    {
#line 663
    debug_compile(0, "set");
#line 664
    list_print(nt);
#line 665
    printf((char const   */* __restrict  */)" %s ", set_names[parse->num]);
#line 666
    list_print(ns);
#line 667
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 673
  l = nt;
  {
#line 673
  while (1) {
    while_continue: /* CIL Label */ ;
#line 673
    if (! l) {
#line 673
      goto while_break;
    }
    {
#line 674
    tmp___1 = list_copy((LIST *)0, ns);
#line 674
    var_set(l->string, tmp___1, parse->num);
#line 673
    l = l->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 676
  list_free(nt);
  }
#line 678
  return (ns);
}
}
#line 689 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/compile.c"
LIST *compile_setcomp(PARSE *parse , LOL *args , int *jmp ) 
{ 
  RULE *rule ;
  RULE *tmp ;
  LIST *params ;
  PARSE *p ;

  {
  {
#line 695
  tmp = bindrule(parse->string);
#line 695
  rule = tmp;
#line 696
  params = (LIST *)0;
#line 701
  p = parse->left;
  }
  {
#line 701
  while (1) {
    while_continue: /* CIL Label */ ;
#line 701
    if (! p) {
#line 701
      goto while_break;
    }
    {
#line 702
    params = list_new(params, p->string, 1);
#line 701
    p = p->left;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 704
  if (globs.debug[5]) {
    {
#line 706
    debug_compile(0, "rule");
#line 707
    printf((char const   */* __restrict  */)"%s ", parse->string);
#line 708
    list_print(params);
#line 709
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 714
  if (rule->procedure) {
    {
#line 715
    parse_free(rule->procedure);
    }
  }
#line 717
  if (rule->params) {
    {
#line 718
    list_free(rule->params);
    }
  }
  {
#line 720
  rule->procedure = parse->right;
#line 721
  rule->params = params;
#line 726
  parse_refer(parse->right);
  }
#line 728
  return ((LIST *)0);
}
}
#line 743 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/compile.c"
LIST *compile_setexec(PARSE *parse , LOL *args , int *jmp ) 
{ 
  RULE *rule ;
  RULE *tmp ;
  LIST *bindlist ;
  LIST *tmp___0 ;

  {
  {
#line 749
  tmp = bindrule(parse->string);
#line 749
  rule = tmp;
#line 750
  tmp___0 = (*((parse->left)->func))(parse->left, args, jmp);
#line 750
  bindlist = tmp___0;
  }
#line 754
  if (rule->actions) {
    {
#line 756
    freestr(rule->actions);
#line 757
    list_free(rule->bindlist);
    }
  }
  {
#line 760
  rule->actions = copystr(parse->string1);
#line 761
  rule->bindlist = bindlist;
#line 762
  rule->flags = parse->num;
  }
#line 764
  return ((LIST *)0);
}
}
#line 776 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/compile.c"
LIST *compile_settings(PARSE *parse , LOL *args , int *jmp ) 
{ 
  LIST *nt ;
  LIST *tmp ;
  LIST *ns ;
  LIST *tmp___0 ;
  LIST *targets ;
  LIST *tmp___1 ;
  LIST *ts ;
  TARGET *t ;
  TARGET *tmp___2 ;
  LIST *l ;
  LIST *tmp___3 ;

  {
  {
#line 782
  tmp = (*((parse->left)->func))(parse->left, args, jmp);
#line 782
  nt = tmp;
#line 783
  tmp___0 = (*((parse->third)->func))(parse->third, args, jmp);
#line 783
  ns = tmp___0;
#line 784
  tmp___1 = (*((parse->right)->func))(parse->right, args, jmp);
#line 784
  targets = tmp___1;
  }
#line 787
  if (globs.debug[5]) {
    {
#line 789
    debug_compile(0, "set");
#line 790
    list_print(nt);
#line 791
    printf((char const   */* __restrict  */)"on ");
#line 792
    list_print(targets);
#line 793
    printf((char const   */* __restrict  */)" %s ", set_names[parse->num]);
#line 794
    list_print(ns);
#line 795
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 802
  ts = targets;
  {
#line 802
  while (1) {
    while_continue: /* CIL Label */ ;
#line 802
    if (! ts) {
#line 802
      goto while_break;
    }
    {
#line 804
    tmp___2 = bindtarget(ts->string);
#line 804
    t = tmp___2;
#line 807
    l = nt;
    }
    {
#line 807
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 807
      if (! l) {
#line 807
        goto while_break___0;
      }
      {
#line 808
      tmp___3 = list_copy((LIST *)0, ns);
#line 808
      t->settings = addsettings(t->settings, parse->num, l->string, tmp___3);
#line 807
      l = l->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 802
    ts = ts->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 812
  list_free(nt);
#line 813
  list_free(targets);
  }
#line 815
  return (ns);
}
}
#line 831 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/compile.c"
LIST *compile_switch(PARSE *parse , LOL *args , int *jmp ) 
{ 
  LIST *nt ;
  LIST *tmp ;
  LIST *result ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 837
  tmp = (*((parse->left)->func))(parse->left, args, jmp);
#line 837
  nt = tmp;
#line 838
  result = (LIST *)0;
  }
#line 840
  if (globs.debug[5]) {
    {
#line 842
    debug_compile(0, "switch");
#line 843
    list_print(nt);
#line 844
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 849
  parse = parse->right;
  {
#line 849
  while (1) {
    while_continue: /* CIL Label */ ;
#line 849
    if (! parse) {
#line 849
      goto while_break;
    }
#line 851
    if (nt) {
#line 851
      tmp___0 = nt->string;
    } else {
#line 851
      tmp___0 = "";
    }
    {
#line 851
    tmp___1 = glob((parse->left)->string, tmp___0);
    }
#line 851
    if (! tmp___1) {
      {
#line 854
      parse = (parse->left)->left;
#line 855
      result = (*(parse->func))(parse, args, jmp);
      }
#line 856
      goto while_break;
    }
#line 849
    parse = parse->right;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 860
  list_free(nt);
  }
#line 862
  return (result);
}
}
#line 872 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/compile.c"
LIST *compile_while(PARSE *p , LOL *args , int *jmp ) 
{ 
  LIST *result ;
  LIST *l ;

  {
#line 878
  result = (LIST *)0;
  {
#line 883
  while (1) {
    while_continue: /* CIL Label */ ;
#line 883
    if (*jmp == 0) {
      {
#line 883
      l = (*((p->left)->func))(p->left, args, jmp);
      }
#line 883
      if (! l) {
#line 883
        goto while_break;
      }
    } else {
#line 883
      goto while_break;
    }
    {
#line 888
    list_free(l);
#line 892
    list_free(result);
#line 893
    result = (*((p->right)->func))(p->right, args, jmp);
    }
#line 897
    if (*jmp == 2) {
#line 898
      *jmp = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 903
  if (*jmp == 1) {
#line 904
    *jmp = 0;
  } else
#line 903
  if (*jmp == 2) {
#line 904
    *jmp = 0;
  }
#line 908
  return (result);
}
}
#line 918 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/compile.c"
static int level  =    0;
#line 919 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/compile.c"
static char indent[36]  = 
#line 919
  {      (char )'>',      (char )'>',      (char )'>',      (char )'>', 
        (char )'|',      (char )'>',      (char )'>',      (char )'>', 
        (char )'>',      (char )'|',      (char )'>',      (char )'>', 
        (char )'>',      (char )'>',      (char )'|',      (char )'>', 
        (char )'>',      (char )'>',      (char )'>',      (char )'|', 
        (char )'>',      (char )'>',      (char )'>',      (char )'>', 
        (char )'|',      (char )'>',      (char )'>',      (char )'>', 
        (char )'>',      (char )'|',      (char )'>',      (char )'>', 
        (char )'>',      (char )'>',      (char )'|',      (char )'\000'};
#line 915 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/compile.c"
static void debug_compile(int which , char const   *s ) 
{ 
  int i ;

  {
#line 920
  i = ((1 + level) * 2) % 35;
#line 922
  if (which >= 0) {
    {
#line 923
    printf((char const   */* __restrict  */)"%*.*s ", i, i, indent);
    }
  }
#line 925
  if (s) {
    {
#line 926
    printf((char const   */* __restrict  */)"%s ", s);
    }
  }
#line 928
  level += which;
#line 929
  return;
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/hash.h"
struct hash *hashinit(int datalen , char const   *name ) ;
#line 16
int hashitem(struct hash *hp , HASHDATA **data , int enter ) ;
#line 17
void hashdone(struct hash *hp ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/newstr.c"
static struct hash *strhash  =    (struct hash *)0;
#line 36 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/newstr.c"
static int strtotal  =    0;
#line 42 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/newstr.c"
char const   *newstr(char const   *string ) 
{ 
  STRING str ;
  STRING *s ;
  int l ;
  size_t tmp ;
  char *m ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 45
  s = & str;
#line 47
  if (! strhash) {
    {
#line 48
    strhash = hashinit((int )sizeof(STRING ), "strings");
    }
  }
  {
#line 50
  *s = string;
#line 52
  tmp___1 = hashitem(strhash, (HASHDATA **)(& s), 1);
  }
#line 52
  if (! tmp___1) {
    {
#line 54
    tmp = strlen(string);
#line 54
    l = (int )tmp;
#line 55
    tmp___0 = malloc((size_t )(l + 1));
#line 55
    m = (char *)tmp___0;
    }
#line 57
    if (globs.debug[9]) {
      {
#line 58
      printf((char const   */* __restrict  */)"newstr: allocating %d bytes\n", l + 1);
      }
    }
    {
#line 60
    strtotal += l + 1;
#line 61
    memcpy((void */* __restrict  */)m, (void const   */* __restrict  */)string, (size_t )(l + 1));
#line 62
    *s = (STRING )m;
    }
  }
#line 65
  return (*s);
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/newstr.c"
char const   *copystr(char const   *s ) 
{ 


  {
#line 75
  return (s);
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/newstr.c"
void freestr(char const   *s ) 
{ 


  {
#line 85
  return;
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/newstr.c"
void donestr(void) 
{ 


  {
  {
#line 94
  hashdone(strhash);
  }
#line 96
  if (globs.debug[9]) {
    {
#line 97
    printf((char const   */* __restrict  */)"%dK in strings\n", strtotal / 1024);
    }
  }
#line 98
  return;
}
}
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/regexp.h"
regexp *regcomp(char const   *exp ) ;
#line 22
int regexec(regexp *prog , char const   *string ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/headers.c"
static LIST *headers1(char const   *file , LIST *hdrscan ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/headers.c"
void headers(TARGET *t ) 
{ 
  LIST *hdrscan ;
  LIST *hdrrule ;
  LOL lol ;
  LIST *tmp ;
  LIST *tmp___0 ;
  LIST *tmp___1 ;
  LIST *tmp___2 ;

  {
  {
#line 58
  hdrscan = var_get("HDRSCAN");
  }
#line 58
  if (hdrscan) {
    {
#line 58
    hdrrule = var_get("HDRRULE");
    }
#line 58
    if (! hdrrule) {
#line 60
      return;
    }
  } else {
#line 60
    return;
  }
#line 65
  if (globs.debug[6]) {
    {
#line 66
    printf((char const   */* __restrict  */)"header scan %s\n", t->name);
    }
  }
  {
#line 68
  lol_init(& lol);
#line 70
  tmp = list_new((LIST *)0, t->name, 1);
#line 70
  lol_add(& lol, tmp);
#line 71
  tmp___0 = headers1(t->boundname, hdrscan);
#line 71
  lol_add(& lol, tmp___0);
#line 73
  tmp___2 = lol_get(& lol, 1);
  }
#line 73
  if (tmp___2) {
    {
#line 74
    tmp___1 = evaluate_rule(hdrrule->string, & lol, (LIST *)0);
#line 74
    list_free(tmp___1);
    }
  }
  {
#line 78
  lol_free(& lol);
  }
#line 79
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/headers.c"
static LIST *headers1(char const   *file , LIST *hdrscan ) 
{ 
  FILE *f ;
  int i ;
  int rec ;
  LIST *result ;
  regexp *re[10] ;
  char buf___0[1024] ;
  int tmp ;
  char buf2[1024] ;
  int l ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 92
  rec = 0;
#line 93
  result = (LIST *)0;
#line 97
  f = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
  }
#line 97
  if (! f) {
#line 98
    return (result);
  }
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (rec < 10) {
#line 100
      if (! hdrscan) {
#line 100
        goto while_break;
      }
    } else {
#line 100
      goto while_break;
    }
    {
#line 102
    tmp = rec;
#line 102
    rec ++;
#line 102
    re[tmp] = regcomp(hdrscan->string);
#line 103
    hdrscan = hdrscan->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 106
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 106
    tmp___1 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)f);
    }
#line 106
    if (! tmp___1) {
#line 106
      goto while_break___0;
    }
#line 108
    i = 0;
    {
#line 108
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 108
      if (! (i < rec)) {
#line 108
        goto while_break___1;
      }
      {
#line 109
      tmp___0 = regexec(re[i], (char const   *)(buf___0));
      }
#line 109
      if (tmp___0) {
#line 109
        if ((re[i])->startp[1]) {
          {
#line 114
          l = (int )((re[i])->endp[1] - (re[i])->startp[1]);
#line 115
          memcpy((void */* __restrict  */)(buf2), (void const   */* __restrict  */)(re[i])->startp[1],
                 (size_t )l);
#line 116
          buf2[l] = (char)0;
#line 117
          result = list_new(result, (char const   *)(buf2), 0);
          }
#line 119
          if (globs.debug[6]) {
            {
#line 120
            printf((char const   */* __restrict  */)"header found: %s\n", buf2);
            }
          }
        }
      }
#line 108
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 124
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 124
    if (! rec) {
#line 124
      goto while_break___2;
    }
    {
#line 125
    rec --;
#line 125
    free((void *)((char *)re[rec]));
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 127
  fclose(f);
  }
#line 129
  return (result);
}
}
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/filesys.h"
void file_dirscan(char const   *dir , void (*func)(void *closure , char const   *file ,
                                                   int found , time_t t ) , void *closure ) ;
#line 16
void file_archscan(char const   *archive , void (*func)(void *closure , char const   *file ,
                                                        int found , time_t t ) , void *closure ) ;
#line 18
int file_time(char const   *filename , time_t *time___0 ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 106 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/fileunix.c"
void file_dirscan(char const   *dir , void (*func)(void *closure , char const   *file ,
                                                   int found , time_t t ) , void *closure ) 
{ 
  PATHNAME f ;
  DIR *d ;
  struct dirent *dirent ;
  char filename[1024] ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 119
  memset((void *)((char *)(& f)), '\000', sizeof(f));
#line 121
  f.part[2].ptr = dir;
#line 122
  tmp = strlen(dir);
#line 122
  f.part[2].len = (int )tmp;
  }
#line 124
  if (*dir) {
#line 124
    dir = dir;
  } else {
#line 124
    dir = ".";
  }
#line 128
  if (f.part[2].len == 1) {
#line 128
    if ((int const   )*(f.part[2].ptr + 0) == 47) {
      {
#line 129
      (*func)(closure, dir, 0, (time_t )0);
      }
    }
  }
  {
#line 133
  d = opendir(dir);
  }
#line 133
  if (! d) {
#line 134
    return;
  }
#line 136
  if (globs.debug[6]) {
    {
#line 137
    printf((char const   */* __restrict  */)"scan directory %s\n", dir);
    }
  }
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 139
    dirent = readdir(d);
    }
#line 139
    if (! dirent) {
#line 139
      goto while_break;
    }
    {
#line 145
    f.part[3].ptr = (char const   *)(dirent->d_name);
#line 147
    tmp___0 = strlen(f.part[3].ptr);
#line 147
    f.part[3].len = (int )tmp___0;
#line 149
    path_build(& f, filename, 0);
#line 151
    (*func)(closure, (char const   *)(filename), 0, (time_t )0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 154
  closedir(d);
  }
#line 155
  return;
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/fileunix.c"
int file_time(char const   *filename , time_t *time___0 ) 
{ 
  struct stat statbuf ;
  int tmp ;

  {
  {
#line 168
  tmp = stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& statbuf));
  }
#line 168
  if (tmp < 0) {
#line 169
    return (-1);
  }
#line 171
  *time___0 = statbuf.st_mtim.tv_sec;
#line 172
  return (0);
}
}
#line 203
extern int ( /* missing proto */  close)() ;
#line 200
extern int ( /* missing proto */  read)() ;
#line 255
extern int ( /* missing proto */  lseek)() ;
#line 184 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/fileunix.c"
void file_archscan(char const   *archive , void (*func)(void *closure , char const   *file ,
                                                        int found , time_t t ) , void *closure ) 
{ 
  struct ar_hdr ar_hdr ;
  char buf___0[1024] ;
  long offset ;
  char *string_table ;
  int fd ;
  int tmp ;
  int tmp___0 ;
  long lar_date ;
  long lar_size ;
  char lar_name[256] ;
  char *dst ;
  char *src ;
  char const   *e ;
  char *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char *src___0 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int len ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  {
#line 194
  string_table = (char *)0;
#line 197
  fd = open(archive, 0, 0);
  }
#line 197
  if (fd < 0) {
#line 198
    return;
  }
  {
#line 200
  tmp = read(fd, buf___0, 8);
  }
#line 200
  if (tmp != 8) {
    {
#line 203
    close(fd);
    }
#line 204
    return;
  } else {
    {
#line 200
    tmp___0 = strncmp("!<arch>\n", (char const   *)(buf___0), (size_t )8);
    }
#line 200
    if (tmp___0) {
      {
#line 203
      close(fd);
      }
#line 204
      return;
    }
  }
#line 207
  offset = 8L;
#line 209
  if (globs.debug[6]) {
    {
#line 210
    printf((char const   */* __restrict  */)"scan archive %s\n", archive);
    }
  }
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 212
    tmp___11 = read(fd, & ar_hdr, sizeof(struct ar_hdr ));
    }
#line 212
    if ((unsigned long )tmp___11 == sizeof(struct ar_hdr )) {
      {
#line 212
      tmp___12 = memcmp((void const   *)(ar_hdr.ar_fmag), (void const   *)"`\n", (size_t )2);
      }
#line 212
      if (tmp___12) {
#line 212
        goto while_break;
      }
    } else {
#line 212
      goto while_break;
    }
    {
#line 218
    dst = lar_name;
#line 222
    ar_hdr.ar_fmag[0] = (char)0;
#line 226
    sscanf((char const   */* __restrict  */)(ar_hdr.ar_date), (char const   */* __restrict  */)"%ld",
           & lar_date);
#line 227
    sscanf((char const   */* __restrict  */)(ar_hdr.ar_size), (char const   */* __restrict  */)"%ld",
           & lar_size);
    }
#line 234
    if ((int )ar_hdr.ar_name[0] != 47) {
#line 240
      src = ar_hdr.ar_name;
#line 241
      e = (char const   *)(src + sizeof(ar_hdr.ar_name));
      {
#line 243
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 243
        if ((unsigned long )src < (unsigned long )e) {
#line 243
          if (*src) {
#line 243
            if ((int )*src != 32) {
#line 243
              if (! ((int )*src != 47)) {
#line 243
                goto while_break___0;
              }
            } else {
#line 243
              goto while_break___0;
            }
          } else {
#line 243
            goto while_break___0;
          }
        } else {
#line 243
          goto while_break___0;
        }
#line 244
        tmp___1 = dst;
#line 244
        dst ++;
#line 244
        tmp___2 = src;
#line 244
        src ++;
#line 244
        *tmp___1 = *tmp___2;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 246
    if ((int )ar_hdr.ar_name[1] == 47) {
      {
#line 253
      tmp___3 = malloc((size_t )lar_size);
#line 253
      string_table = (char *)tmp___3;
#line 255
      lseek(fd, (unsigned long )offset + sizeof(struct ar_hdr ), 0);
#line 256
      tmp___4 = read(fd, string_table, lar_size);
      }
#line 256
      if ((long )tmp___4 != lar_size) {
        {
#line 257
        printf((char const   */* __restrict  */)"error reading string table\n");
        }
      }
    } else
#line 259
    if (string_table) {
#line 259
      if ((int )ar_hdr.ar_name[1] != 32) {
        {
#line 266
        tmp___5 = atoi((char const   *)(ar_hdr.ar_name + 1));
#line 266
        src___0 = string_table + tmp___5;
        }
        {
#line 268
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 268
          if (! ((int )*src___0 != 47)) {
#line 268
            goto while_break___1;
          }
#line 269
          tmp___6 = dst;
#line 269
          dst ++;
#line 269
          tmp___7 = src___0;
#line 269
          src___0 ++;
#line 269
          *tmp___6 = *tmp___7;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
    {
#line 274
    *dst = (char)0;
#line 280
    tmp___10 = strcmp((char const   *)(lar_name), "#1");
    }
#line 280
    if (! tmp___10) {
      {
#line 282
      tmp___8 = atoi((char const   *)(ar_hdr.ar_name + 3));
#line 282
      len = tmp___8;
#line 283
      tmp___9 = read(fd, lar_name, len);
      }
#line 283
      if (tmp___9 != len) {
        {
#line 284
        printf((char const   */* __restrict  */)"error reading archive entry\n");
        }
      }
#line 285
      lar_name[len] = (char)0;
    }
#line 290
    if (lar_name[0]) {
#line 292
      if (globs.debug[6]) {
        {
#line 293
        printf((char const   */* __restrict  */)"archive name %s found\n", lar_name);
        }
      }
      {
#line 295
      sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%s(%s)",
              archive, lar_name);
#line 297
      (*func)(closure, (char const   *)(buf___0), 1, lar_date);
      }
    }
    {
#line 302
    offset = (long )((unsigned long )offset + (sizeof(struct ar_hdr ) + (unsigned long )((lar_size + 1L) & -2L)));
#line 303
    lseek(fd, offset, 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  if (string_table) {
    {
#line 307
    free((void *)string_table);
    }
  }
  {
#line 309
  close(fd);
  }
#line 313
  return;
}
}
#line 14 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/variable.h"
int var_string(char const   *in , char *out , int outsize , LOL *lol ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/command.h"
CMD *cmd_new(RULE *rule , LIST *targets , LIST *sources , LIST *shell , int maxline ) ;
#line 57
void cmd_free(CMD *cmd ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/command.c"
CMD *cmd_new(RULE *rule , LIST *targets , LIST *sources , LIST *shell , int maxline ) 
{ 
  CMD *cmd ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 35
  tmp = malloc(sizeof(CMD ));
#line 35
  cmd = (CMD *)tmp;
#line 37
  cmd->rule = rule;
#line 38
  cmd->shell = shell;
#line 39
  cmd->next = (CMD *)0;
#line 41
  lol_init(& cmd->args);
#line 42
  lol_add(& cmd->args, targets);
#line 43
  lol_add(& cmd->args, sources);
#line 48
  tmp___0 = var_string(rule->actions, cmd->buf, maxline, & cmd->args);
  }
#line 48
  if (tmp___0 < 0) {
    {
#line 50
    cmd_free(cmd);
    }
#line 51
    return ((CMD *)0);
  }
#line 54
  return (cmd);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/command.c"
void cmd_free(CMD *cmd ) 
{ 


  {
  {
#line 64
  lol_free(& cmd->args);
#line 65
  list_free(cmd->shell);
#line 66
  free((void *)((char *)cmd));
  }
#line 67
  return;
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/hash.c"
static void hashrehash(struct hash *hp ) ;
#line 85
static void hashstat(struct hash *hp ) ;
#line 91 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/hash.c"
int hashitem(struct hash *hp , HASHDATA **data , int enter ) 
{ 
  ITEM **base ;
  register ITEM *i ;
  unsigned char *b ;
  unsigned int keyval ;
  unsigned char *tmp ;
  int tmp___0 ;

  {
#line 99
  b = (unsigned char *)(*data)->key;
#line 102
  if (enter) {
#line 102
    if (! hp->items.more) {
      {
#line 103
      hashrehash(hp);
      }
    }
  }
#line 105
  if (! enter) {
#line 105
    if (! hp->items.nel) {
#line 106
      return (0);
    }
  }
#line 108
  keyval = (unsigned int )*b;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (! *b) {
#line 110
      goto while_break;
    }
#line 111
    tmp = b;
#line 111
    b ++;
#line 111
    keyval = keyval * 2147059363U + (unsigned int )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  base = hp->tab.base + keyval % (unsigned int )hp->tab.nel;
#line 115
  i = *base;
  {
#line 115
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 115
    if (! i) {
#line 115
      goto while_break___0;
    }
#line 116
    if (keyval == i->hdr.keyval) {
      {
#line 116
      tmp___0 = strcmp((char const   *)i->data.key, (char const   *)(*data)->key);
      }
#line 116
      if (! tmp___0) {
#line 119
        *data = & i->data;
#line 120
        return (1);
      }
    }
#line 115
    i = i->hdr.next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 123
  if (enter) {
    {
#line 125
    i = (ITEM *)hp->items.next;
#line 126
    hp->items.next += hp->items.size;
#line 127
    (hp->items.more) --;
#line 128
    memcpy((void */* __restrict  */)((char *)(& i->data)), (void const   */* __restrict  */)((char *)*data),
           (size_t )hp->items.datalen);
#line 129
    i->hdr.keyval = keyval;
#line 130
    i->hdr.next = *base;
#line 131
    *base = i;
#line 132
    *data = & i->data;
    }
  }
#line 135
  return (0);
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/hash.c"
static void hashrehash(struct hash *hp ) 
{ 
  int i ;
  void *tmp ;
  void *tmp___0 ;
  int nel ;
  char *next ;
  register ITEM *i___0 ;
  ITEM **ip ;
  int tmp___1 ;

  {
#line 144
  (hp->items.list) ++;
#line 144
  i = hp->items.list;
#line 146
  if (i) {
#line 146
    hp->items.more = 2 * hp->items.nel;
  } else {
#line 146
    hp->items.more = hp->inel;
  }
  {
#line 147
  tmp = malloc((size_t )(hp->items.more * hp->items.size));
#line 147
  hp->items.next = (char *)tmp;
#line 149
  hp->items.lists[i].nel = hp->items.more;
#line 150
  hp->items.lists[i].base = hp->items.next;
#line 151
  hp->items.nel += hp->items.more;
  }
#line 153
  if (hp->tab.base) {
    {
#line 154
    free((void *)((char *)hp->tab.base));
    }
  }
  {
#line 156
  hp->tab.nel = hp->items.nel * hp->bloat;
#line 157
  tmp___0 = malloc((unsigned long )hp->tab.nel * sizeof(ITEM **));
#line 157
  hp->tab.base = (ITEM **)tmp___0;
#line 159
  memset((void *)((char *)hp->tab.base), '\000', (unsigned long )hp->tab.nel * sizeof(ITEM *));
#line 161
  i = 0;
  }
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (! (i < hp->items.list)) {
#line 161
      goto while_break;
    }
#line 163
    nel = hp->items.lists[i].nel;
#line 164
    next = hp->items.lists[i].base;
    {
#line 166
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 166
      tmp___1 = nel;
#line 166
      nel --;
#line 166
      if (! tmp___1) {
#line 166
        goto while_break___0;
      }
#line 168
      i___0 = (ITEM *)next;
#line 169
      ip = hp->tab.base + i___0->hdr.keyval % (unsigned int )hp->tab.nel;
#line 171
      i___0->hdr.next = *ip;
#line 172
      *ip = i___0;
#line 166
      next += hp->items.size;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 161
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  return;
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/hash.c"
struct hash *hashinit(int datalen , char const   *name ) 
{ 
  struct hash *hp ;
  void *tmp ;

  {
  {
#line 190
  tmp = malloc(sizeof(*hp));
#line 190
  hp = (struct hash *)tmp;
#line 192
  hp->bloat = 3;
#line 193
  hp->tab.nel = 0;
#line 194
  hp->tab.base = (ITEM **)0;
#line 195
  hp->items.more = 0;
#line 196
  hp->items.datalen = datalen;
#line 197
  hp->items.size = (int )(sizeof(struct hashhdr ) + ((((unsigned long )datalen + sizeof(ITEM )) - 1UL) & ~ (sizeof(ITEM ) - 1UL)));
#line 198
  hp->items.list = -1;
#line 199
  hp->items.nel = 0;
#line 200
  hp->inel = 11;
#line 201
  hp->name = name;
  }
#line 203
  return (hp);
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/hash.c"
void hashdone(struct hash *hp ) 
{ 
  int i ;

  {
#line 215
  if (! hp) {
#line 216
    return;
  }
#line 218
  if (globs.debug[9]) {
    {
#line 219
    hashstat(hp);
    }
  }
#line 221
  if (hp->tab.base) {
    {
#line 222
    free((void *)((char *)hp->tab.base));
    }
  }
#line 223
  i = 0;
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 223
    if (! (i <= hp->items.list)) {
#line 223
      goto while_break;
    }
    {
#line 224
    free((void *)hp->items.lists[i].base);
#line 223
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 225
  free((void *)((char *)hp));
  }
#line 226
  return;
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/hash.c"
static void hashstat(struct hash *hp ) 
{ 
  ITEM **tab ;
  int nel ;
  int count ;
  int sets ;
  int run ;
  int i ;
  int here ;
  ITEM **tmp ;

  {
#line 233
  tab = hp->tab.base;
#line 234
  nel = hp->tab.nel;
#line 235
  count = 0;
#line 236
  sets = 0;
#line 237
  run = (unsigned long )*(tab + (nel - 1)) != (unsigned long )((ITEM *)0);
#line 240
  i = nel;
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 240
    if (! (i > 0)) {
#line 240
      goto while_break;
    }
#line 242
    tmp = tab;
#line 242
    tab ++;
#line 242
    here = (unsigned long )*tmp != (unsigned long )((ITEM *)0);
#line 242
    if (here) {
#line 243
      count ++;
    }
#line 244
    if (here) {
#line 244
      if (! run) {
#line 245
        sets ++;
      }
    }
#line 246
    run = here;
#line 240
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 249
  printf((char const   */* __restrict  */)"%s table: %d+%d+%d (%dK+%dK) items+table+hash, %f density\n",
         hp->name, count, hp->items.nel, hp->tab.nel, (hp->items.nel * hp->items.size) / 1024,
         ((unsigned long )hp->tab.nel * sizeof(ITEM **)) / 1024UL, (double )((float )count / (float )sets));
  }
#line 257
  return;
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/rules.h"
TARGET *copytarget(TARGET const   *ot ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/builtins.c"
LIST *builtin_depends(PARSE *parse , LOL *args , int *jmp ) ;
#line 53
LIST *builtin_echo(PARSE *parse , LOL *args , int *jmp ) ;
#line 54
LIST *builtin_exit(PARSE *parse , LOL *args , int *jmp ) ;
#line 55
LIST *builtin_flags(PARSE *parse , LOL *args , int *jmp ) ;
#line 56
LIST *builtin_glob(PARSE *parse , LOL *args , int *jmp ) ;
#line 57
LIST *builtin_match(PARSE *parse , LOL *args , int *jmp ) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/builtins.c"
void load_builtins(void) 
{ 
  RULE *tmp ;
  RULE *tmp___0 ;
  PARSE *tmp___1 ;
  RULE *tmp___2 ;
  RULE *tmp___3 ;
  PARSE *tmp___4 ;
  RULE *tmp___5 ;
  RULE *tmp___6 ;
  PARSE *tmp___7 ;
  RULE *tmp___8 ;
  PARSE *tmp___9 ;
  RULE *tmp___10 ;
  RULE *tmp___11 ;
  PARSE *tmp___12 ;
  RULE *tmp___13 ;
  PARSE *tmp___14 ;
  RULE *tmp___15 ;
  RULE *tmp___16 ;
  PARSE *tmp___17 ;
  RULE *tmp___18 ;
  RULE *tmp___19 ;
  PARSE *tmp___20 ;
  RULE *tmp___21 ;
  RULE *tmp___22 ;
  PARSE *tmp___23 ;
  RULE *tmp___24 ;
  RULE *tmp___25 ;
  PARSE *tmp___26 ;
  RULE *tmp___27 ;
  RULE *tmp___28 ;
  PARSE *tmp___29 ;
  RULE *tmp___30 ;
  RULE *tmp___31 ;
  PARSE *tmp___32 ;
  RULE *tmp___33 ;
  PARSE *tmp___34 ;
  RULE *tmp___35 ;
  RULE *tmp___36 ;
  PARSE *tmp___37 ;
  RULE *tmp___38 ;
  RULE *tmp___39 ;
  PARSE *tmp___40 ;

  {
  {
#line 64
  tmp = bindrule("Always");
#line 64
  tmp___0 = bindrule("ALWAYS");
#line 64
  tmp___1 = parse_make(& builtin_flags, (PARSE *)0, (PARSE *)0, (PARSE *)0, (char const   *)((char *)0),
                       (char const   *)((char *)0), 8);
#line 64
  tmp___0->procedure = tmp___1;
#line 64
  tmp->procedure = tmp___1;
#line 68
  tmp___2 = bindrule("Depends");
#line 68
  tmp___3 = bindrule("DEPENDS");
#line 68
  tmp___4 = parse_make(& builtin_depends, (PARSE *)0, (PARSE *)0, (PARSE *)0, (char const   *)((char *)0),
                       (char const   *)((char *)0), 0);
#line 68
  tmp___3->procedure = tmp___4;
#line 68
  tmp___2->procedure = tmp___4;
#line 72
  tmp___5 = bindrule("echo");
#line 72
  tmp___6 = bindrule("Echo");
#line 72
  tmp___8 = bindrule("ECHO");
#line 72
  tmp___9 = parse_make(& builtin_echo, (PARSE *)0, (PARSE *)0, (PARSE *)0, (char const   *)((char *)0),
                       (char const   *)((char *)0), 0);
#line 72
  tmp___8->procedure = tmp___9;
#line 72
  tmp___7 = tmp___9;
#line 72
  tmp___6->procedure = tmp___7;
#line 72
  tmp___5->procedure = tmp___7;
#line 77
  tmp___10 = bindrule("exit");
#line 77
  tmp___11 = bindrule("Exit");
#line 77
  tmp___13 = bindrule("EXIT");
#line 77
  tmp___14 = parse_make(& builtin_exit, (PARSE *)0, (PARSE *)0, (PARSE *)0, (char const   *)((char *)0),
                        (char const   *)((char *)0), 0);
#line 77
  tmp___13->procedure = tmp___14;
#line 77
  tmp___12 = tmp___14;
#line 77
  tmp___11->procedure = tmp___12;
#line 77
  tmp___10->procedure = tmp___12;
#line 82
  tmp___15 = bindrule("Glob");
#line 82
  tmp___16 = bindrule("GLOB");
#line 82
  tmp___17 = parse_make(& builtin_glob, (PARSE *)0, (PARSE *)0, (PARSE *)0, (char const   *)((char *)0),
                        (char const   *)((char *)0), 0);
#line 82
  tmp___16->procedure = tmp___17;
#line 82
  tmp___15->procedure = tmp___17;
#line 86
  tmp___18 = bindrule("Includes");
#line 86
  tmp___19 = bindrule("INCLUDES");
#line 86
  tmp___20 = parse_make(& builtin_depends, (PARSE *)0, (PARSE *)0, (PARSE *)0, (char const   *)((char *)0),
                        (char const   *)((char *)0), 1);
#line 86
  tmp___19->procedure = tmp___20;
#line 86
  tmp___18->procedure = tmp___20;
#line 90
  tmp___21 = bindrule("Leaves");
#line 90
  tmp___22 = bindrule("LEAVES");
#line 90
  tmp___23 = parse_make(& builtin_flags, (PARSE *)0, (PARSE *)0, (PARSE *)0, (char const   *)((char *)0),
                        (char const   *)((char *)0), 16);
#line 90
  tmp___22->procedure = tmp___23;
#line 90
  tmp___21->procedure = tmp___23;
#line 94
  tmp___24 = bindrule("Match");
#line 94
  tmp___25 = bindrule("MATCH");
#line 94
  tmp___26 = parse_make(& builtin_match, (PARSE *)0, (PARSE *)0, (PARSE *)0, (char const   *)((char *)0),
                        (char const   *)((char *)0), 0);
#line 94
  tmp___25->procedure = tmp___26;
#line 94
  tmp___24->procedure = tmp___26;
#line 98
  tmp___27 = bindrule("NoCare");
#line 98
  tmp___28 = bindrule("NOCARE");
#line 98
  tmp___29 = parse_make(& builtin_flags, (PARSE *)0, (PARSE *)0, (PARSE *)0, (char const   *)((char *)0),
                        (char const   *)((char *)0), 2);
#line 98
  tmp___28->procedure = tmp___29;
#line 98
  tmp___27->procedure = tmp___29;
#line 102
  tmp___30 = bindrule("NOTIME");
#line 102
  tmp___31 = bindrule("NotFile");
#line 102
  tmp___33 = bindrule("NOTFILE");
#line 102
  tmp___34 = parse_make(& builtin_flags, (PARSE *)0, (PARSE *)0, (PARSE *)0, (char const   *)((char *)0),
                        (char const   *)((char *)0), 4);
#line 102
  tmp___33->procedure = tmp___34;
#line 102
  tmp___32 = tmp___34;
#line 102
  tmp___31->procedure = tmp___32;
#line 102
  tmp___30->procedure = tmp___32;
#line 107
  tmp___35 = bindrule("NoUpdate");
#line 107
  tmp___36 = bindrule("NOUPDATE");
#line 107
  tmp___37 = parse_make(& builtin_flags, (PARSE *)0, (PARSE *)0, (PARSE *)0, (char const   *)((char *)0),
                        (char const   *)((char *)0), 32);
#line 107
  tmp___36->procedure = tmp___37;
#line 107
  tmp___35->procedure = tmp___37;
#line 111
  tmp___38 = bindrule("Temporary");
#line 111
  tmp___39 = bindrule("TEMPORARY");
#line 111
  tmp___40 = parse_make(& builtin_flags, (PARSE *)0, (PARSE *)0, (PARSE *)0, (char const   *)((char *)0),
                        (char const   *)((char *)0), 1);
#line 111
  tmp___39->procedure = tmp___40;
#line 111
  tmp___38->procedure = tmp___40;
  }
#line 114
  return;
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/builtins.c"
LIST *builtin_depends(PARSE *parse , LOL *args , int *jmp ) 
{ 
  LIST *targets ;
  LIST *tmp ;
  LIST *sources ;
  LIST *tmp___0 ;
  LIST *l ;
  TARGET *t ;
  TARGET *tmp___1 ;

  {
  {
#line 130
  tmp = lol_get(args, 0);
#line 130
  targets = tmp;
#line 131
  tmp___0 = lol_get(args, 1);
#line 131
  sources = tmp___0;
#line 134
  l = targets;
  }
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (! l) {
#line 134
      goto while_break;
    }
    {
#line 136
    tmp___1 = bindtarget(l->string);
#line 136
    t = tmp___1;
    }
#line 142
    if (parse->num) {
#line 144
      if (! t->includes) {
        {
#line 145
        t->includes = copytarget((TARGET const   *)t);
        }
      }
#line 146
      t = t->includes;
    }
    {
#line 149
    t->depends = targetlist(t->depends, sources);
#line 134
    l = l->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  return ((LIST *)0);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/builtins.c"
LIST *builtin_echo(PARSE *parse , LOL *args , int *jmp ) 
{ 
  LIST *tmp ;

  {
  {
#line 168
  tmp = lol_get(args, 0);
#line 168
  list_print(tmp);
#line 169
  printf((char const   */* __restrict  */)"\n");
  }
#line 170
  return ((LIST *)0);
}
}
#line 180 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/builtins.c"
LIST *builtin_exit(PARSE *parse , LOL *args , int *jmp ) 
{ 
  LIST *tmp ;

  {
  {
#line 186
  tmp = lol_get(args, 0);
#line 186
  list_print(tmp);
#line 187
  printf((char const   */* __restrict  */)"\n");
#line 188
  exit(1);
  }
#line 189
  return ((LIST *)0);
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/builtins.c"
LIST *builtin_flags(PARSE *parse , LOL *args , int *jmp ) 
{ 
  LIST *l ;
  LIST *tmp ;
  TARGET *tmp___0 ;

  {
  {
#line 205
  tmp = lol_get(args, 0);
#line 205
  l = tmp;
  }
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (! l) {
#line 207
      goto while_break;
    }
    {
#line 208
    tmp___0 = bindtarget(l->string);
#line 208
    tmp___0->flags = (char )((int )tmp___0->flags | parse->num);
#line 207
    l = l->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 210
  return ((LIST *)0);
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/builtins.c"
static void builtin_glob_back(void *closure , char const   *file , int status , time_t time___0 ) 
{ 
  struct globbing *globbing ;
  LIST *l ;
  PATHNAME f ;
  char buf___0[1024] ;
  int tmp ;

  {
  {
#line 229
  globbing = (struct globbing *)closure;
#line 237
  path_parse(file, & f);
#line 238
  f.part[2].len = 0;
#line 239
  path_build(& f, buf___0, 0);
#line 241
  l = globbing->patterns;
  }
  {
#line 241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 241
    if (! l) {
#line 241
      goto while_break;
    }
    {
#line 242
    tmp = glob(l->string, (char const   *)(buf___0));
    }
#line 242
    if (! tmp) {
      {
#line 244
      globbing->results = list_new(globbing->results, file, 0);
      }
#line 245
      goto while_break;
    }
#line 241
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 247
  return;
}
}
#line 249 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/builtins.c"
LIST *builtin_glob(PARSE *parse , LOL *args , int *jmp ) 
{ 
  LIST *l ;
  LIST *tmp ;
  LIST *r ;
  LIST *tmp___0 ;
  struct globbing globbing ;

  {
  {
#line 255
  tmp = lol_get(args, 0);
#line 255
  l = tmp;
#line 256
  tmp___0 = lol_get(args, 1);
#line 256
  r = tmp___0;
#line 260
  globbing.results = (LIST *)0;
#line 261
  globbing.patterns = r;
  }
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 263
    if (! l) {
#line 263
      goto while_break;
    }
    {
#line 264
    file_dirscan(l->string, & builtin_glob_back, (void *)(& globbing));
#line 263
    l = l->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 266
  return (globbing.results);
}
}
#line 273 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/builtins.c"
LIST *builtin_match(PARSE *parse , LOL *args , int *jmp ) 
{ 
  LIST *l ;
  LIST *r ;
  LIST *result ;
  regexp *re ;
  regexp *tmp ;
  int i ;
  int top ;
  int tmp___0 ;
  char buf___0[1024] ;
  int l___0 ;
  int tmp___1 ;

  {
  {
#line 280
  result = (LIST *)0;
#line 284
  l = lol_get(args, 0);
  }
  {
#line 284
  while (1) {
    while_continue: /* CIL Label */ ;
#line 284
    if (! l) {
#line 284
      goto while_break;
    }
    {
#line 286
    tmp = regcomp(l->string);
#line 286
    re = tmp;
#line 290
    r = lol_get(args, 1);
    }
    {
#line 290
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 290
      if (! r) {
#line 290
        goto while_break___0;
      }
      {
#line 291
      tmp___1 = regexec(re, r->string);
      }
#line 291
      if (tmp___1) {
#line 297
        top = 10;
        {
#line 297
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 297
          tmp___0 = top;
#line 297
          top --;
#line 297
          if (! (tmp___0 > 1)) {
#line 297
            goto while_break___1;
          }
#line 298
          if (re->startp[top]) {
#line 299
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 304
        i = 1;
        {
#line 304
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 304
          if (! (i <= top)) {
#line 304
            goto while_break___2;
          }
          {
#line 307
          l___0 = (int )(re->endp[i] - re->startp[i]);
#line 308
          memcpy((void */* __restrict  */)(buf___0), (void const   */* __restrict  */)re->startp[i],
                 (size_t )l___0);
#line 309
          buf___0[l___0] = (char)0;
#line 310
          result = list_new(result, (char const   *)(buf___0), 0);
#line 304
          i ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 290
      r = r->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 314
    free((void *)((char *)re));
#line 284
    l = l->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 317
  return (result);
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 65 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make1.c"
static void make1a(TARGET *t , TARGET *parent ) ;
#line 66
static void make1b(TARGET *t ) ;
#line 67
static void make1c(TARGET *t ) ;
#line 68
static void make1d(void *closure , int status ) ;
#line 70
static CMD *make1cmds(ACTIONS *a0 ) ;
#line 71
static LIST *make1list(LIST *l , TARGETS *targets , int flags ) ;
#line 72
static SETTINGS *make1settings(LIST *vars ) ;
#line 73
static void make1bind(TARGET *t , int warn ) ;
#line 77 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make1.c"
static struct __anonstruct_counts_50 counts[1]  ;
#line 88 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make1.c"
static int intr___0  =    0;
#line 90 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make1.c"
int make1(TARGET *t ) 
{ 
  int tmp ;

  {
  {
#line 93
  memset((void *)((char *)(counts)), 0, sizeof(counts[0]));
#line 97
  make1a(t, (TARGET *)0);
  }
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 101
    tmp = execwait();
    }
#line 101
    if (! tmp) {
#line 101
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  if (globs.debug[1]) {
#line 106
    if (counts[0].failed) {
      {
#line 107
      printf((char const   */* __restrict  */)"...failed updating %d target(s)...\n",
             counts[0].failed);
      }
    }
  }
#line 109
  if (globs.debug[1]) {
#line 109
    if (counts[0].skipped) {
      {
#line 110
      printf((char const   */* __restrict  */)"...skipped %d target(s)...\n", counts[0].skipped);
      }
    }
  }
#line 112
  if (globs.debug[1]) {
#line 112
    if (counts[0].made) {
      {
#line 113
      printf((char const   */* __restrict  */)"...updated %d target(s)...\n", counts[0].made);
      }
    }
  }
#line 115
  return (counts[0].total != counts[0].made);
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make1.c"
static void make1a(TARGET *t , TARGET *parent ) 
{ 
  TARGETS *c ;

  {
#line 133
  if (parent) {
    {
#line 138
    if ((int )t->progress == 3) {
#line 138
      goto case_3;
    }
#line 138
    if ((int )t->progress == 2) {
#line 138
      goto case_3;
    }
#line 138
    if ((int )t->progress == 0) {
#line 138
      goto case_3;
    }
#line 134
    goto switch_break;
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
#line 139
    t->parents = targetentry(t->parents, parent);
#line 140
    (parent->asynccnt) ++;
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 143
  if ((int )t->progress != 0) {
#line 144
    return;
  }
#line 152
  t->asynccnt = 1;
#line 157
  t->progress = (char)1;
#line 159
  c = t->depends;
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 159
    if (c) {
#line 159
      if (! (! intr___0)) {
#line 159
        goto while_break;
      }
    } else {
#line 159
      goto while_break;
    }
    {
#line 160
    make1a(c->target, t);
#line 159
    c = c->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 162
  t->progress = (char)2;
#line 167
  make1b(t);
  }
#line 168
  return;
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make1.c"
static void make1b(TARGET *t ) 
{ 
  TARGETS *c ;
  char const   *failed ;
  CMD *tmp ;

  {
#line 178
  failed = "dependents";
#line 183
  (t->asynccnt) --;
#line 183
  if (t->asynccnt) {
#line 184
    return;
  }
#line 190
  c = t->depends;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! c) {
#line 190
      goto while_break;
    }
#line 191
    if ((int )(c->target)->status > (int )t->status) {
#line 193
      failed = (c->target)->name;
#line 194
      t->status = (c->target)->status;
    }
#line 190
    c = c->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 200
  if ((int )t->status == 1) {
#line 200
    if (t->actions) {
      {
#line 202
      (counts[0].skipped) ++;
#line 203
      printf((char const   */* __restrict  */)"...skipped %s for lack of %s...\n",
             t->name, failed);
      }
    }
  }
#line 206
  if ((int )t->status == 0) {
    {
#line 214
    if ((int )t->fate == 3) {
#line 214
      goto case_3;
    }
#line 214
    if ((int )t->fate == 2) {
#line 214
      goto case_3;
    }
#line 214
    if ((int )t->fate == 1) {
#line 214
      goto case_3;
    }
#line 214
    if ((int )t->fate == 0) {
#line 214
      goto case_3;
    }
#line 218
    if ((int )t->fate == 11) {
#line 218
      goto case_11;
    }
#line 218
    if ((int )t->fate == 10) {
#line 218
      goto case_11;
    }
#line 222
    if ((int )t->fate == 4) {
#line 222
      goto case_4;
    }
#line 231
    if ((int )t->fate == 9) {
#line 231
      goto case_9;
    }
#line 231
    if ((int )t->fate == 8) {
#line 231
      goto case_9;
    }
#line 231
    if ((int )t->fate == 7) {
#line 231
      goto case_9;
    }
#line 231
    if ((int )t->fate == 6) {
#line 231
      goto case_9;
    }
#line 231
    if ((int )t->fate == 5) {
#line 231
      goto case_9;
    }
#line 207
    goto switch_break;
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 215
    goto switch_break;
    case_11: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 219
    t->status = (char)1;
#line 220
    goto switch_break;
    case_4: /* CIL Label */ 
#line 223
    if (globs.debug[11]) {
      {
#line 224
      printf((char const   */* __restrict  */)"...using %s...\n", t->name);
      }
    }
#line 225
    goto switch_break;
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
    case_5: /* CIL Label */ 
#line 236
    if (t->actions) {
#line 238
      (counts[0].total) ++;
#line 240
      if (globs.debug[1]) {
#line 240
        if (! (counts[0].total % 100)) {
          {
#line 241
          printf((char const   */* __restrict  */)"...on %dth target...\n", counts[0].total);
          }
        }
      }
      {
#line 243
      pushsettings(t->settings);
#line 244
      tmp = make1cmds(t->actions);
#line 244
      t->cmds = (char *)tmp;
#line 245
      popsettings(t->settings);
#line 247
      t->progress = (char)3;
      }
    }
#line 250
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 259
  make1c(t);
  }
#line 260
  return;
}
}
#line 266 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make1.c"
static void make1c(TARGET *t ) 
{ 
  CMD *cmd ;
  LIST *tmp ;
  TARGETS *c ;
  ACTIONS *actions ;

  {
#line 269
  cmd = (CMD *)t->cmds;
#line 279
  if (cmd) {
#line 279
    if ((int )t->status == 0) {
#line 281
      if (globs.debug[1]) {
#line 282
        if (globs.debug[11]) {
          {
#line 284
          printf((char const   */* __restrict  */)"%s ", (cmd->rule)->name);
#line 285
          tmp = lol_get(& cmd->args, 0);
#line 285
          list_print(tmp);
#line 286
          printf((char const   */* __restrict  */)"\n");
          }
        } else
#line 282
        if (! ((cmd->rule)->flags & 8)) {
          {
#line 284
          printf((char const   */* __restrict  */)"%s ", (cmd->rule)->name);
#line 285
          tmp = lol_get(& cmd->args, 0);
#line 285
          list_print(tmp);
#line 286
          printf((char const   */* __restrict  */)"\n");
          }
        }
      }
#line 289
      if (globs.debug[12]) {
        {
#line 290
        printf((char const   */* __restrict  */)"%s\n", cmd->buf);
        }
      }
#line 292
      if (globs.cmdout) {
        {
#line 293
        fprintf((FILE */* __restrict  */)globs.cmdout, (char const   */* __restrict  */)"%s",
                cmd->buf);
        }
      }
#line 295
      if (globs.noexec) {
        {
#line 297
        make1d((void *)t, 0);
        }
      } else {
        {
#line 301
        fflush(stdout);
#line 302
        execcmd(cmd->buf, & make1d, (void *)t, cmd->shell);
        }
      }
    } else {
#line 279
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 312
    actions = t->actions;
    {
#line 312
    while (1) {
      while_continue: /* CIL Label */ ;
#line 312
      if (! actions) {
#line 312
        goto while_break;
      }
#line 313
      if ((int )(actions->action)->status > (int )t->status) {
#line 314
        t->status = (actions->action)->status;
      }
#line 312
      actions = actions->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 316
    actions = t->actions;
    {
#line 316
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 316
      if (! actions) {
#line 316
        goto while_break___0;
      }
#line 317
      if ((int )t->status > (int )(actions->action)->status) {
#line 318
        (actions->action)->status = t->status;
      }
#line 316
      actions = actions->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 322
    if ((int )t->progress == 3) {
      {
#line 325
      if ((int )t->status == 0) {
#line 325
        goto case_0;
      }
#line 328
      if ((int )t->status == 1) {
#line 328
        goto case_1;
      }
#line 323
      goto switch_break;
      case_0: /* CIL Label */ 
#line 326
      (counts[0].made) ++;
#line 327
      goto switch_break;
      case_1: /* CIL Label */ 
#line 329
      (counts[0].failed) ++;
#line 330
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 335
    t->progress = (char)4;
#line 337
    c = t->parents;
    {
#line 337
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 337
      if (! c) {
#line 337
        goto while_break___1;
      }
      {
#line 338
      make1b(c->target);
#line 337
      c = c->next;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 340
  return;
}
}
#line 389
extern int ( /* missing proto */  unlink)() ;
#line 346 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make1.c"
static void make1d(void *closure , int status ) 
{ 
  TARGET *t ;
  CMD *cmd ;
  LIST *tmp ;
  LIST *targets ;
  LIST *tmp___0 ;
  int tmp___1 ;

  {
#line 351
  t = (TARGET *)closure;
#line 352
  cmd = (CMD *)t->cmds;
#line 358
  if (status == 1) {
#line 358
    if ((cmd->rule)->flags & 4) {
#line 359
      status = 0;
    }
  }
#line 363
  if (status == 2) {
#line 364
    intr___0 ++;
  }
#line 366
  if (status == 1) {
#line 366
    if (globs.debug[1]) {
#line 370
      if (! globs.debug[12]) {
        {
#line 371
        printf((char const   */* __restrict  */)"%s\n", cmd->buf);
        }
      }
      {
#line 373
      printf((char const   */* __restrict  */)"...failed %s ", (cmd->rule)->name);
#line 374
      tmp = lol_get(& cmd->args, 0);
#line 374
      list_print(tmp);
#line 375
      printf((char const   */* __restrict  */)"...\n");
      }
#line 377
      if (globs.quitquick) {
#line 377
        intr___0 ++;
      }
    }
  }
#line 384
  if (status != 0) {
#line 384
    if (! ((cmd->rule)->flags & 1)) {
      {
#line 386
      tmp___0 = lol_get(& cmd->args, 0);
#line 386
      targets = tmp___0;
      }
      {
#line 388
      while (1) {
        while_continue: /* CIL Label */ ;
#line 388
        if (! targets) {
#line 388
          goto while_break;
        }
        {
#line 389
        tmp___1 = unlink(targets->string);
        }
#line 389
        if (! tmp___1) {
          {
#line 390
          printf((char const   */* __restrict  */)"...removing %s\n", targets->string);
          }
        }
#line 388
        targets = targets->next;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 395
  t->status = (char )status;
#line 396
  t->cmds = (char *)cmd->next;
#line 398
  cmd_free(cmd);
#line 400
  make1c(t);
  }
#line 401
  return;
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make1.c"
static CMD *make1cmds(ACTIONS *a0 ) 
{ 
  CMD *cmds ;
  LIST *shell ;
  LIST *tmp ;
  RULE *rule ;
  SETTINGS *boundvars ;
  LIST *nt ;
  LIST *ns ;
  ACTIONS *a1 ;
  int start ;
  int chunk ;
  int length ;
  int maxline ;
  CMD *cmd___0 ;
  LIST *tmp___0 ;
  LIST *tmp___1 ;
  LIST *tmp___2 ;
  CMD *tmp___3 ;

  {
  {
#line 416
  cmds = (CMD *)0;
#line 417
  tmp = var_get("JAMSHELL");
#line 417
  shell = tmp;
  }
  {
#line 423
  while (1) {
    while_continue: /* CIL Label */ ;
#line 423
    if (! a0) {
#line 423
      goto while_break;
    }
#line 425
    rule = (a0->action)->rule;
#line 435
    if (! rule->actions) {
#line 436
      goto __Cont;
    } else
#line 435
    if ((a0->action)->running) {
#line 436
      goto __Cont;
    }
    {
#line 438
    (a0->action)->running = (char)1;
#line 444
    nt = make1list((LIST *)0, (a0->action)->targets, 0);
#line 445
    ns = make1list((LIST *)0, (a0->action)->sources, rule->flags);
    }
#line 447
    if (rule->flags & 2) {
#line 448
      a1 = a0->next;
      {
#line 448
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 448
        if (! a1) {
#line 448
          goto while_break___0;
        }
#line 449
        if ((unsigned long )(a1->action)->rule == (unsigned long )rule) {
#line 449
          if (! (a1->action)->running) {
            {
#line 451
            ns = make1list(ns, (a1->action)->sources, rule->flags);
#line 452
            (a1->action)->running = (char)1;
            }
          }
        }
#line 448
        a1 = a1->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 458
    if (! ns) {
#line 458
      if (rule->flags & 33) {
        {
#line 460
        list_free(nt);
        }
#line 461
        goto __Cont;
      }
    }
    {
#line 466
    boundvars = make1settings(rule->bindlist);
#line 467
    pushsettings(boundvars);
#line 489
    start = 0;
#line 490
    length = list_length(ns);
#line 490
    chunk = length;
#line 491
    maxline = rule->flags / 64;
    }
#line 492
    if (maxline) {
#line 492
      if (maxline < 10240) {
#line 492
        maxline = maxline;
      } else {
#line 492
        maxline = 10240;
      }
    } else {
#line 492
      maxline = 10240;
    }
    {
#line 494
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 498
      tmp___0 = list_copy((LIST *)0, shell);
#line 498
      tmp___1 = list_sublist(ns, start, chunk);
#line 498
      tmp___2 = list_copy((LIST *)0, nt);
#line 498
      tmp___3 = cmd_new(rule, tmp___2, tmp___1, tmp___0, maxline);
#line 498
      cmd___0 = tmp___3;
      }
#line 504
      if (cmd___0) {
#line 508
        if (! cmds) {
#line 508
          cmds = cmd___0;
        } else {
#line 509
          (cmds->tail)->next = cmd___0;
        }
#line 510
        cmds->tail = cmd___0;
#line 511
        start += chunk;
      } else
#line 513
      if (rule->flags & 16) {
#line 513
        if (chunk > 1) {
#line 517
          chunk = (chunk * 9) / 10;
        } else {
          {
#line 523
          printf((char const   */* __restrict  */)"%s actions too long (max %d)!\n",
                 rule->name, maxline);
#line 525
          exit(1);
          }
        }
      } else {
        {
#line 523
        printf((char const   */* __restrict  */)"%s actions too long (max %d)!\n",
               rule->name, maxline);
#line 525
        exit(1);
        }
      }
#line 494
      if (! (start < length)) {
#line 494
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 532
    list_free(nt);
#line 533
    list_free(ns);
#line 538
    popsettings(boundvars);
#line 539
    freesettings(boundvars);
    }
    __Cont: /* CIL Label */ 
#line 423
    a0 = a0->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 542
  return (cmds);
}
}
#line 549 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make1.c"
static LIST *make1list(LIST *l , TARGETS *targets , int flags ) 
{ 
  TARGET *t ;
  LIST *m ;
  int tmp ;

  {
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    if (! targets) {
#line 555
      goto while_break;
    }
#line 557
    t = targets->target;
#line 564
    if ((int )t->binding == 0) {
      {
#line 565
      make1bind(t, ! (flags & 32));
      }
    }
#line 567
    if (flags & 32) {
#line 567
      if ((int )t->binding != 3) {
#line 568
        goto __Cont;
      }
    }
#line 570
    if (flags & 1) {
#line 570
      if ((int )t->fate <= 2) {
#line 571
        goto __Cont;
      }
    }
#line 575
    if (flags & 2) {
#line 579
      m = l;
      {
#line 579
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 579
        if (! m) {
#line 579
          goto while_break___0;
        }
        {
#line 580
        tmp = strcmp(m->string, t->boundname);
        }
#line 580
        if (! tmp) {
#line 581
          goto while_break___0;
        }
#line 579
        m = m->next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 583
      if (m) {
#line 584
        goto __Cont;
      }
    }
    {
#line 589
    l = list_new(l, t->boundname, 1);
    }
    __Cont: /* CIL Label */ 
#line 555
    targets = targets->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 592
  return (l);
}
}
#line 599 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make1.c"
static SETTINGS *make1settings(LIST *vars ) 
{ 
  SETTINGS *settings ;
  LIST *l ;
  LIST *tmp ;
  LIST *nl ;
  TARGET *t ;
  TARGET *tmp___0 ;

  {
#line 602
  settings = (SETTINGS *)0;
  {
#line 604
  while (1) {
    while_continue: /* CIL Label */ ;
#line 604
    if (! vars) {
#line 604
      goto while_break;
    }
    {
#line 606
    tmp = var_get(vars->string);
#line 606
    l = tmp;
#line 607
    nl = (LIST *)0;
    }
    {
#line 609
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 609
      if (! l) {
#line 609
        goto while_break___0;
      }
      {
#line 611
      tmp___0 = bindtarget(l->string);
#line 611
      t = tmp___0;
      }
#line 616
      if ((int )t->binding == 0) {
        {
#line 617
        make1bind(t, 1);
        }
      }
      {
#line 621
      nl = list_new(nl, t->boundname, 1);
#line 609
      l = l->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 626
    settings = addsettings(settings, 0, vars->string, nl);
#line 604
    vars = vars->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 629
  return (settings);
}
}
#line 639 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make1.c"
static void make1bind(TARGET *t , int warn ) 
{ 


  {
#line 644
  if ((int )t->flags & 4) {
#line 645
    return;
  }
#line 652
  if (warn) {
    {
#line 653
    printf((char const   */* __restrict  */)"warning: using independent target %s\n",
           t->name);
    }
  }
  {
#line 655
  pushsettings(t->settings);
#line 656
  t->boundname = search(t->name, & t->time);
  }
#line 657
  if (t->time) {
#line 657
    t->binding = (char)3;
  } else {
#line 657
    t->binding = (char)1;
  }
  {
#line 658
  popsettings(t->settings);
  }
#line 659
  return;
}
}
#line 2 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/jambase.c"
char const   *jambase[1289]  = 
#line 2 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/jambase.c"
  {      "JAMBASEDATE = 2002.05.09 ;\n",      "if $(NT)\n",      "{\n",      "MV\t\t?= move /y ;\n", 
        "CP\t\t?= copy ;\n",      "RM\t\t?= del /f/q ;\n",      "RMDIR\t\t?= rmdir /s/q ;\n",      "SLASH\t\t?= \\\\ ;\n", 
        "SUFLIB\t\t?= .lib ;\n",      "SUFOBJ\t\t?= .obj ;\n",      "SUFEXE\t\t?= .exe ;\n",      "if $(BCCROOT)\n", 
        "{\n",      "AR\t\t?= tlib /C /P64 ;\n",      "CC\t\t?= bcc32 ;\n",      "CCFLAGS\t\t?= -v -w- -q -DWIN -tWR -tWM -tWC ;\n", 
        "C++\t\t?= $(CC) ;\n",      "C++FLAGS\t?= $(CCFLAGS) -P ;\n",      "LINK\t\t?= $(CC) ;\n",      "LINKFLAGS\t?= $(CCFLAGS) ;\n", 
        "STDLIBPATH\t?= $(BCCROOT)\\\\lib ;\n",      "STDHDRS\t\t?= $(BCCROOT)\\\\include ;\n",      "NOARSCAN\t?= true ;\n",      "}\n", 
        "else if $(MSVC)\n",      "{\n",      "AR\t\t?= lib /nologo ;\n",      "CC\t\t?= cl /nologo ;\n", 
        "CCFLAGS\t\t?= /D \\\"WIN\\\" ;\n",      "C++\t\t?= $(CC) ;\n",      "C++FLAGS\t?= $(CCFLAGS) ;\n",      "LINK\t\t?= $(CC) ;\n", 
        "LINKFLAGS\t?= $(CCFLAGS) ;\n",      "LINKLIBS\t?= \n",      "$(MSVC)\\\\lib\\\\mlibce.lib\n",      "$(MSVC)\\\\lib\\\\oldnames.lib\n", 
        ";\n",      "LINKLIBS\t?= ;\n",      "NOARSCAN\t?= true ;\n",      "OPTIM\t\t?=  ;\n", 
        "STDHDRS\t\t?= $(MSVC)\\\\include ;\n",      "UNDEFFLAG\t?= \"/u _\" ;\n",      "}\n",      "else if $(MSVCNT) || $(MSVCDIR)\n", 
        "{\n",      "MSVCNT\t\t?= $(MSVCDIR) ;\t\n",      "local I ; if $(OSPLAT) = IA64 { I = ia64\\\\ ; } else { I = \"\" ; }\n",      "AR\t\t?= lib ;\n", 
        "AS\t\t?= masm386 ;\n",      "CC\t\t?= cl /nologo ;\n",      "CCFLAGS\t\t?= \"\" ;\n",      "C++\t\t?= $(CC) ;\n", 
        "C++FLAGS\t?= $(CCFLAGS) ;\n",      "LINK\t\t?= link /nologo ;\n",      "LINKFLAGS\t?= \"\" ;\n",      "LINKLIBS\t?= \n", 
        "$(MSVCNT)\\\\lib\\\\$(I)libc.lib\n",      "$(MSVCNT)\\\\lib\\\\$(I)oldnames.lib\n",      "$(MSVCNT)\\\\lib\\\\$(I)kernel32.lib ;\n",      "OPTIM\t\t?= \"\" ;\n", 
        "STDHDRS\t\t?= $(MSVCNT)\\\\include ;\n",      "UNDEFFLAG\t?= \"/u _\" ;\n",      "}\n",      "else\n", 
        "{\n",      "EXIT On NT, set BCCROOT, MSVCDIR, MSVCNT, or MSVC to the root\n",      "of the Borland or Microsoft directories. ;\n",      "}\n", 
        "}\n",      "else if $(MINGW)\n",      "{\n",      "Echo\t\t\"MingW32\" ;\n", 
        "CC\t\t?= gcc ;\n",      "C++\t\t?= g++ ;\n",      "CCFLAGS \t+= -DMINGW ;\n",      "RANLIB\t\t?= \"ranlib\" ;\n", 
        "SUFEXE\t\t?= .exe ;\n",      "}\n",      "else if $(OS2)\n",      "{\n", 
        "WATCOM\t\t?= $(watcom) ;\n",      "if ! $(WATCOM)\n",      "{\n",      "Exit On OS2, set WATCOM to the root of the Watcom directory. ;\n", 
        "}\n",      "AR\t\t?= wlib ;\n",      "BINDIR\t\t?= \\\\os2\\\\apps ;\n",      "CC\t\t?= wcc386 ;\n", 
        "CCFLAGS\t\t?= /zq /DOS2 /I$(WATCOM)\\\\h ; # zq=quiet\n",      "C++\t\t?= wpp386 ;\n",      "C++FLAGS\t?= $(CCFLAGS) ;\n",      "CP\t\t?= copy ;\n", 
        "DOT\t\t?= . ;\n",      "DOTDOT\t\t?= .. ;\n",      "LINK\t\t?= wcl386 ;\n",      "LINKFLAGS\t?= /zq ; # zq=quiet\n", 
        "LINKLIBS\t?= ;\n",      "MV\t\t?= move ;\n",      "NOARSCAN\t?= true ;\n",      "OPTIM\t\t?= ;\n", 
        "RM\t\t?= del /f ;\n",      "SLASH\t\t?= \\\\ ;\n",      "STDHDRS\t\t?= $(WATCOM)\\\\h ;\n",      "SUFEXE\t\t?= .exe ;\n", 
        "SUFLIB\t\t?= .lib ;\n",      "SUFOBJ\t\t?= .obj ;\n",      "UNDEFFLAG\t?= \"/u _\" ;\n",      "}\n", 
        "else if $(VMS)\n",      "{\n",      "C++\t\t?= cxx ;\n",      "C++FLAGS\t?= ;\n", 
        "CC\t\t?= cc ;\n",      "CCFLAGS\t\t?= ;\n",      "CHMOD\t\t?= set file/prot= ;\n",      "CP\t\t?= copy/replace ;\n", 
        "CRELIB\t\t?= true ;\n",      "DOT\t\t?= [] ;\n",      "DOTDOT\t\t?= [-] ;\n",      "EXEMODE\t\t?= (w:e) ;\n", 
        "FILEMODE\t?= (w:r) ;\n",      "HDRS\t\t?= ;\n",      "LINK\t\t?= link ;\n",      "LINKFLAGS\t?= \"\" ;\n", 
        "LINKLIBS\t?= ;\n",      "MKDIR\t\t?= create/dir ;\n",      "MV\t\t?= rename ;\n",      "OPTIM\t\t?= \"\" ;\n", 
        "RM\t\t?= delete ;\n",      "RUNVMS\t\t?= mcr ;\n",      "SHELLMODE\t?= (w:er) ;\n",      "SLASH\t\t?= . ;\n", 
        "STDHDRS\t\t?= decc$library_include ;\n",      "SUFEXE\t\t?= .exe ;\n",      "SUFLIB\t\t?= .olb ;\n",      "SUFOBJ\t\t?= .obj ;\n", 
        "switch $(OS) \n",      "{\n",      "case OPENVMS : CCFLAGS ?= /stand=vaxc ;\n",      "case VMS     : LINKLIBS ?= sys$library:vaxcrtl.olb/lib ;\n", 
        "}\n",      "}\n",      "else if $(MAC)\n",      "{\n", 
        "local OPT ;\n",      "CW\t?= \"{CW}\" ;\n",      "MACHDRS ?=\n",      "\"$(UMACHDRS):Universal:Interfaces:CIncludes\"\n", 
        "\"$(CW):MSL:MSL_C:MSL_Common:Include\"\n",      "\"$(CW):MSL:MSL_C:MSL_MacOS:Include\" ;\n",      "MACLIBS ?=\n",      "\"$(CW):MacOS Support:Universal:Libraries:StubLibraries:Interfacelib\"\n", 
        "\"$(CW):MacOS Support:Universal:Libraries:StubLibraries:Mathlib\" ;\n",      "MPWLIBS ?= \n",      "\"$(CW):MacOS Support:Libraries:Runtime:Libs:MSL_MPWCRuntime_PPC.lib\"\n",      "\"$(CW):MSL:MSL_C:MSL_MacOS:Lib:PPC:MSL_C_PPC_MPW.Lib\" ;\n", 
        "MPWNLLIBS ?= \n",      "\"$(CW):MacOS Support:Libraries:Runtime:Libs:MSL_MPWCRuntime_PPC.lib\"\n",      "\"$(CW):MSL:MSL_C:MSL_MacOS:Lib:PPC:MSL_C_PPC_MPW(NL).Lib\" ;\n",      "SIOUXHDRS ?= ;\n", 
        "SIOUXLIBS ?= \n",      "\"$(CW):MacOS Support:Libraries:Runtime:Libs:MSL_Runtime_PPC.lib\"\n",      "\"$(CW):MSL:MSL_C:MSL_MacOS:Lib:PPC:MSL_SIOUX_PPC.Lib\" \n",      "\"$(CW):MSL:MSL_C:MSL_MacOS:Lib:PPC:MSL_C_PPC.Lib\" ;\n", 
        "C++\t\t?= mwcppc ;\n",      "C++FLAGS\t?= -w off ;\n",      "CC\t\t?= mwcppc ;\n",      "CCFLAGS\t\t?= -w off ;\n", 
        "CP\t\t?= duplicate -y ;\n",      "DOT\t\t?= \":\" ;\n",      "DOTDOT\t\t?= \"::\" ;\n",      "HDRS \t\t?= $(MACHDRS) $(MPWHDRS) ;\n", 
        "LINK\t\t?= mwlinkppc ;\n",      "LINKFLAGS\t?= -mpwtool -warn ;\t\t\t\t\n",      "LINKLIBS \t?= $(MACLIBS) $(MPWLIBS) ;\t\t\t\t\n",      "MKDIR\t\t?= newfolder ;\n", 
        "MV\t\t?= rename -y ;\n",      "NOARSCAN\t?= true ;\n",      "OPTIM\t\t?= ;\n",      "RM\t\t?= delete -y ;\n", 
        "SLASH\t\t?= \":\" ;\n",      "STDHDRS\t\t?= ; \n",      "SUFLIB\t\t?= .lib ;\n",      "SUFOBJ\t\t?= .o ;\n", 
        "}\n",      "else if $(OS) = BEOS && $(OSPLAT) = PPC\n",      "{\n",      "AR\t\t?= mwld -xml -o ;\n", 
        "BINDIR\t\t?= /boot/home/config/bin ;\n",      "CC\t\t?= mwcc ;\n",      "CCFLAGS\t\t?= -nosyspath ;\n",      "C++\t\t?= $(CC) ;\n", 
        "C++FLAGS\t?= -nosyspath ;\n",      "CHMOD\t\t?= chmod ;\n",      "CHGRP\t\t?= chgrp ;\n",      "CHOWN\t\t?= chown ;\n", 
        "FORTRAN\t\t?= \"\" ;\n",      "LEX\t\t?= flex ;\n",      "LIBDIR\t\t?= /boot/home/config/lib ;\n",      "LINK\t\t?= mwld ;\n", 
        "LINKFLAGS\t?= \"\" ;\n",      "MANDIR\t\t?= /boot/home/config/man ;\n",      "NOARSCAN\t?= true ;\n",      "RANLIB\t\t?= ranlib ;\n", 
        "STDHDRS\t\t?= /boot/develop/headers/posix ;\n",      "YACC\t\t?= bison -y ;\n",      "YACCGEN\t\t?= .c ;\n",      "YACCFILES\t?= y.tab ;\n", 
        "YACCFLAGS\t?= -d ;\n",      "}\n",      "else if $(OS) = BEOS \n",      "{\n", 
        "BINDIR\t\t?= /boot/home/config/bin ;\n",      "CC\t\t?= gcc ;\n",      "C++\t\t?= $(CC) ;\n",      "CHMOD\t\t?= chmod ;\n", 
        "CHGRP\t\t?= chgrp ;\n",      "CHOWN\t\t?= chown ;\n",      "FORTRAN\t\t?= \"\" ;\n",      "LEX\t\t?= flex ;\n", 
        "LIBDIR\t\t?= /boot/home/config/lib ;\n",      "LINK\t\t?= gcc ;\n",      "MANDIR\t\t?= /boot/home/config/man ;\n",      "NOARSCAN\t?= true ;\n", 
        "RANLIB\t\t?= ranlib ;\n",      "STDHDRS\t\t?= /boot/develop/headers/posix ;\n",      "YACC\t\t?= bison -y ;\n",      "YACCGEN\t\t?= .c ;\n", 
        "YACCFILES\t?= y.tab ;\n",      "YACCFLAGS\t?= -d ;\n",      "}\n",      "else if $(UNIX)\n", 
        "{\n",      "switch $(OS)\n",      "{\n",      "case AIX :\n", 
        "LINKLIBS\t?= -lbsd ;\n",      "case AMIGA :\n",      "CC\t\t?= gcc ;\n",      "YACC\t\t?= bison -y ;\n", 
        "case CYGWIN :\t\n",      "CC\t\t?= gcc ;\n",      "CCFLAGS \t+= -D__cygwin__ ;\n",      "LEX\t\t?= flex ;\n", 
        "JAMSHELL\t?= sh -c ;\n",      "RANLIB\t\t?= \"\" ;\n",      "SUFEXE\t\t?= .exe ;\n",      "YACC\t\t?= bison -y ;\n", 
        "case DGUX :\n",      "RANLIB\t\t?= \"\" ;\n",      "RELOCATE \t?= true ;\n",      "case HPUX :\n", 
        "RANLIB\t\t?= \"\" ;\n",      "case INTERIX :\n",      "CC\t\t?= gcc ;\n",      "JAMSHELL\t?= sh -c ;\n", 
        "RANLIB\t\t?= \"\" ;\n",      "case IRIX :\n",      "RANLIB\t\t?= \"\" ;\n",      "case MPEIX :\n", 
        "CC\t\t?= gcc ;\n",      "C++\t\t?= gcc ;\n",      "CCFLAGS\t\t+= -D_POSIX_SOURCE ;\n",      "HDRS\t\t+= /usr/include ;\n", 
        "RANLIB\t\t?= \"\" ; \n",      "NOARSCAN\t?= true ;\n",      "NOARUPDATE\t?= true ;\n",      "case MVS :\n", 
        "RANLIB\t\t?= \"\" ; \n",      "case NEXT :\n",      "AR\t\t?= libtool -o ;\n",      "RANLIB\t\t?= \"\" ;\n", 
        "case MACOSX :\n",      "C++\t\t?= c++ ;\n",      "MANDIR\t\t?= /usr/local/share/man ;\n",      "case NCR :\n", 
        "RANLIB\t\t?= \"\" ;\n",      "case PTX :\n",      "RANLIB\t\t?= \"\" ;\n",      "case QNX :\n", 
        "AR\t\t?= wlib ;\n",      "CC\t\t?= cc ;\n",      "CCFLAGS\t\t?= -Q ;\t# quiet\n",      "C++\t\t?= $(CC) ;\n", 
        "C++FLAGS\t?= -Q ;\t# quiet\n",      "LINK\t\t?= $(CC) ;\n",      "LINKFLAGS\t?= -Q ;\t# quiet\n",      "NOARSCAN\t?= true ;\n", 
        "RANLIB\t\t?= \"\" ;\n",      "case SCO :\n",      "RANLIB\t\t?= \"\" ;\n",      "RELOCATE \t?= true ;\n", 
        "case SINIX :\n",      "RANLIB\t\t?= \"\" ;\n",      "case SOLARIS :\n",      "RANLIB\t\t?= \"\" ;\n", 
        "AR\t\t?= \"/usr/ccs/bin/ar ru\" ;\n",      "case UNICOS :\n",      "NOARSCAN \t?= true ;\n",      "OPTIM \t\t?= -O0 ;\n", 
        "case UNIXWARE :\n",      "RANLIB\t\t?= \"\" ;\n",      "RELOCATE \t?= true ;\n",      "}\n", 
        "CCFLAGS\t\t?= ;\n",      "C++FLAGS\t?= $(CCFLAGS) ;\n",      "CHMOD\t\t?= chmod ;\n",      "CHGRP\t\t?= chgrp ;\n", 
        "CHOWN\t\t?= chown ;\n",      "LEX\t\t?= lex ;\n",      "LINKFLAGS\t?= $(CCFLAGS) ;\n",      "LINKLIBS\t?= ;\n", 
        "OPTIM\t\t?= -O ;\n",      "RANLIB\t\t?= ranlib ;\n",      "YACC\t\t?= yacc ;\n",      "YACCGEN\t\t?= .c ;\n", 
        "YACCFILES\t?= y.tab ;\n",      "YACCFLAGS\t?= -d ;\n",      "}\n",      "AR\t\t?= ar ru ;\n", 
        "AS\t\t?= as ;\n",      "ASFLAGS\t\t?= ;\n",      "AWK\t\t?= awk ;\n",      "BINDIR\t\t?= /usr/local/bin ;\n", 
        "C++\t\t?= cc ;\n",      "C++FLAGS\t?= ;\n",      "CC\t\t?= cc ;\n",      "CCFLAGS\t\t?= ;\n", 
        "CP\t\t?= cp -f ;\n",      "CRELIB\t\t?= ;\n",      "DOT\t\t?= . ;\n",      "DOTDOT\t\t?= .. ;\n", 
        "EXEMODE\t\t?= 755 ;\n",      "FILEMODE\t?= 644 ;\n",      "FORTRAN\t\t?= f77 ;\n",      "FORTRANFLAGS\t?= ;\n", 
        "HDRS\t\t?= ;\n",      "INSTALLGRIST\t?= installed ;\n",      "JAMFILE\t\t?= Jamfile ;\n",      "JAMRULES\t?= Jamrules ;\n", 
        "LEX\t\t?= ;\n",      "LIBDIR\t\t?= /usr/local/lib ;\n",      "LINK\t\t?= $(CC) ;\n",      "LINKFLAGS\t?= ;\n", 
        "LINKLIBS\t?= ;\n",      "LN\t\t?= ln ;\n",      "MANDIR\t\t?= /usr/local/man ;\n",      "MKDIR\t\t?= mkdir ;\n", 
        "MV\t\t?= mv -f ;\n",      "OPTIM\t\t?= ;\n",      "RCP\t\t?= rcp ;\n",      "RM\t\t?= rm -f ;\n", 
        "RMDIR\t\t?= $(RM) ;\n",      "RSH\t\t?= rsh ;\n",      "SED\t\t?= sed ;\n",      "SHELLHEADER\t?= \"#!/bin/sh\" ;\n", 
        "SHELLMODE\t?= 755 ;\n",      "SLASH\t\t?= / ;\n",      "STDHDRS\t\t?= /usr/include ;\n",      "SUBDIRRULES \t?= ;\n", 
        "SUBDIRRESET \t?= ASFLAGS HDRS C++FLAGS CCFLAGS ;\n",      "SUFEXE\t\t?= \"\" ;\n",      "SUFLIB\t\t?= .a ;\n",      "SUFOBJ\t\t?= .o ;\n", 
        "UNDEFFLAG\t?= \"-u _\" ;\n",      "YACC\t\t?= ;\n",      "YACCGEN\t\t?= ;\n",      "YACCFILES\t?= ;\n", 
        "YACCFLAGS\t?= ;\n",      "HDRPATTERN = \n",      "\"^[ \t]*#[ \t]*include[ \t]*[<\\\"]([^\\\">]*)[\\\">].*$\" ;\n",      "OSFULL = $(OS)$(OSVER)$(OSPLAT) $(OS)$(OSPLAT) $(OS)$(OSVER) $(OS) ;\n", 
        "Depends all : shell files lib exe obj ;\n",      "Depends all shell files lib exe obj : first ;\n",      "NotFile all first shell files lib exe obj dirs clean uninstall ;\n",      "Always clean uninstall ;\n", 
        "rule As\n",      "{\n",      "Depends $(<) : $(>) ;\n",      "ASFLAGS on $(<) += $(ASFLAGS) $(SUBDIRASFLAGS) ;\n", 
        "ASHDRS on $(<) = [ FIncludes $(SEARCH_SOURCE) $(SUBDIRHDRS) $(HDRS) ] ;\n",      "}\n",      "rule Bulk\n",      "{\n", 
        "local i ;\n",      "for i in $(>)\n",      "{\n",      "File $(i:D=$(<)) : $(i) ;\n", 
        "}\n",      "}\n",      "rule Cc\n",      "{\n", 
        "Depends $(<) : $(>) ;\n",      "if $(RELOCATE)\n",      "{\n",      "CcMv $(<) : $(>) ;\n", 
        "}\n",      "CCFLAGS on $(<) += $(CCFLAGS) $(SUBDIRCCFLAGS) $(OPTIM) ;\n",      "CCHDRS on $(<) = [ on $(<) FIncludes $(HDRS) ] ;\n",      "CCDEFS on $(<) = [ on $(<) FDefines $(DEFINES) ] ;\n", 
        "}\n",      "rule C++\n",      "{\n",      "Depends $(<) : $(>) ;\n", 
        "if $(RELOCATE)\n",      "{\n",      "CcMv $(<) : $(>) ;\n",      "}\n", 
        "C++FLAGS on $(<) += $(C++FLAGS) $(SUBDIRC++FLAGS) $(OPTIM) ;\n",      "CCHDRS on $(<) = [ on $(<) FIncludes $(HDRS) ] ;\n",      "CCDEFS on $(<) = [ on $(<) FDefines $(DEFINES) ] ;\n",      "}\n", 
        "rule Chmod\n",      "{\n",      "if $(CHMOD) { Chmod1 $(<) ; }\n",      "}\n", 
        "rule File\n",      "{\n",      "Depends files : $(<) ;\n",      "Depends $(<) : $(>) ;\n", 
        "SEARCH on $(>) = $(SEARCH_SOURCE) ;\n",      "MODE on $(<) = $(FILEMODE) ;\n",      "Chmod $(<) ;\n",      "}\n", 
        "rule Fortran\n",      "{\n",      "Depends $(<) : $(>) ;\n",      "}\n", 
        "rule GenFile \n",      "{\n",      "local _t = [ FGristSourceFiles $(<) ] ;\n",      "local _s = [ FAppendSuffix $(>[1]) : $(SUFEXE) ] ;\n", 
        "Depends $(_t) : $(_s) $(>[2-]) ;\n",      "GenFile1 $(_t) : $(_s) $(>[2-]) ;\n",      "Clean clean : $(_t) ;\n",      "}\n", 
        "rule GenFile1\n",      "{\n",      "MakeLocate $(<) : $(LOCATE_SOURCE) ;\n",      "SEARCH on $(>) = $(SEARCH_SOURCE) ;\n", 
        "}\n",      "rule HardLink\n",      "{\n",      "Depends files : $(<) ;\n", 
        "Depends $(<) : $(>) ;\n",      "SEARCH on $(>) = $(SEARCH_SOURCE) ;\n",      "}\n",      "rule HdrRule\n", 
        "{\n",      "local s = $(>:G=$(HDRGRIST:E)) ;\n",      "Includes $(<) : $(s) ;\n",      "SEARCH on $(s) = $(HDRSEARCH) ;\n", 
        "NoCare $(s) ;\n",      "HDRSEARCH on $(s) = $(HDRSEARCH) ;\n",      "HDRSCAN on $(s) = $(HDRSCAN) ;\n",      "HDRRULE on $(s) = $(HDRRULE) ;\n", 
        "HDRGRIST on $(s) = $(HDRGRIST) ;\n",      "}\n",      "rule InstallInto\n",      "{\n", 
        "local i t ;\n",      "t = $(>:G=$(INSTALLGRIST)) ;\n",      "Depends install : $(t) ;\n",      "Clean uninstall : $(t) ;\n", 
        "SEARCH on $(>) = $(SEARCH_SOURCE) ;\n",      "MakeLocate $(t) : $(<) ;\n",      "for i in $(>)\n",      "{\n", 
        "local tt = $(i:G=$(INSTALLGRIST)) ;\n",      "Depends $(tt) : $(i) ;\n",      "Install $(tt) : $(i) ;\n",      "Chmod $(tt) ;\n", 
        "if $(OWNER) && $(CHOWN) \n",      "{ \n",      "Chown $(tt) ;\n",      "OWNER on $(tt) = $(OWNER) ;\n", 
        "}\n",      "if $(GROUP) && $(CHGRP) \n",      "{ \n",      "Chgrp $(tt) ;\n", 
        "GROUP on $(tt) = $(GROUP) ;\n",      "}\n",      "}\n",      "}\n", 
        "rule InstallBin\n",      "{\n",      "local _t = [ FAppendSuffix $(>) : $(SUFEXE) ] ;\n",      "InstallInto $(<) : $(_t) ;\n", 
        "MODE on $(_t:G=$(INSTALLGRIST)) = $(EXEMODE) ;\n",      "}\n",      "rule InstallFile\n",      "{\n", 
        "InstallInto $(<) : $(>) ;\n",      "MODE on $(>:G=$(INSTALLGRIST)) = $(FILEMODE) ;\n",      "}\n",      "rule InstallLib\n", 
        "{\n",      "InstallInto $(<) : $(>) ;\n",      "MODE on $(>:G=$(INSTALLGRIST)) = $(FILEMODE) ;\n",      "}\n", 
        "rule InstallMan\n",      "{\n",      "local i s d ;\n",      "for i in $(>)\n", 
        "{\n",      "switch $(i:S)\n",      "{\n",      "case .1 : s = 1 ; case .2 : s = 2 ; case .3 : s = 3 ;\n", 
        "case .4 : s = 4 ; case .5 : s = 5 ; case .6 : s = 6 ;\n",      "case .7 : s = 7 ; case .8 : s = 8 ; case .l : s = l ;\n",      "case .n : s = n ; case .man : s = 1 ;\n",      "}\n", 
        "d = man$(s) ;\n",      "InstallInto $(d:R=$(<)) : $(i) ;\n",      "}\n",      "MODE on $(>:G=$(INSTALLGRIST)) = $(FILEMODE) ;\n", 
        "}\n",      "rule InstallShell\n",      "{\n",      "InstallInto $(<) : $(>) ;\n", 
        "MODE on $(>:G=$(INSTALLGRIST)) = $(SHELLMODE) ;\n",      "}\n",      "rule Lex\n",      "{\n", 
        "LexMv $(<) : $(>) ;\n",      "Depends $(<) : $(>) ;\n",      "MakeLocate $(<) : $(LOCATE_SOURCE) ;\n",      "Clean clean : $(<) ;\n", 
        "}\n",      "rule Library\n",      "{\n",      "LibraryFromObjects $(<) : $(>:S=$(SUFOBJ)) ;\n", 
        "Objects $(>) ;\n",      "}\n",      "rule LibraryFromObjects\n",      "{\n", 
        "local _i _l _s ;\n",      "_s = [ FGristFiles $(>) ] ;\n",      "_l = $(<:S=$(SUFLIB)) ;\n",      "if $(KEEPOBJS)\n", 
        "{\n",      "Depends obj : $(_s) ;\n",      "}\n",      "else\n", 
        "{\n",      "Depends lib : $(_l) ;\n",      "}\n",      "if ! $(_l:D)\n", 
        "{\n",      "MakeLocate $(_l) $(_l)($(_s:BS)) : $(LOCATE_TARGET) ;\n",      "}\n",      "if $(NOARSCAN) \n", 
        "{ \n",      "Depends $(_l) : $(_s) ;\n",      "}\n",      "else\n", 
        "{\n",      "Depends $(_l) : $(_l)($(_s:BS)) ;\n",      "for _i in $(_s)\n",      "{\n", 
        "Depends $(_l)($(_i:BS)) : $(_i) ;\n",      "}\n",      "}\n",      "Clean clean : $(_l) ;\n", 
        "if $(CRELIB) { CreLib $(_l) : $(_s[1]) ; }\n",      "Archive $(_l) : $(_s) ;\n",      "if $(RANLIB) { Ranlib $(_l) ; }\n",      "if ! ( $(NOARSCAN) || $(NOARUPDATE) ) { RmTemps $(_l) : $(_s) ; }\n", 
        "}\n",      "rule Link\n",      "{\n",      "MODE on $(<) = $(EXEMODE) ;\n", 
        "Chmod $(<) ;\n",      "}\n",      "rule LinkLibraries\n",      "{\n", 
        "local _t = [ FAppendSuffix $(<) : $(SUFEXE) ] ;\n",      "Depends $(_t) : $(>:S=$(SUFLIB)) ;\n",      "NEEDLIBS on $(_t) += $(>:S=$(SUFLIB)) ;\n",      "}\n", 
        "rule Main\n",      "{\n",      "MainFromObjects $(<) : $(>:S=$(SUFOBJ)) ;\n",      "Objects $(>) ;\n", 
        "}\n",      "rule MainFromObjects\n",      "{\n",      "local _s _t ;\n", 
        "_s = [ FGristFiles $(>) ] ;\n",      "_t = [ FAppendSuffix $(<) : $(SUFEXE) ] ;\n",      "if $(_t) != $(<)\n",      "{\n", 
        "Depends $(<) : $(_t) ;\n",      "NotFile $(<) ;\n",      "}\n",      "Depends exe : $(_t) ;\n", 
        "Depends $(_t) : $(_s) ;\n",      "MakeLocate $(_t) : $(LOCATE_TARGET) ;\n",      "Clean clean : $(_t) ;\n",      "Link $(_t) : $(_s) ;\n", 
        "}\n",      "rule MakeLocate\n",      "{\n",      "if $(>)\n", 
        "{\n",      "LOCATE on $(<) = $(>) ;\n",      "Depends $(<) : $(>[1]:G=dir) ;\n",      "MkDir $(>[1]:G=dir) ;\n", 
        "}\n",      "}\n",      "rule MkDir\n",      "{\n", 
        "NoUpdate $(<) ;\n",      "if $(<:G=) != $(DOT) && ! $($(<)-mkdir) \n",      "{\n",      "$(<)-mkdir = true ;\n", 
        "Depends dirs : $(<) ;\n",      "MkDir1 $(<) ;\n",      "local s = $(<:P) ;\n",      "if $(NT)\n", 
        "{\n",      "switch $(s)\n",      "{\n",      "case *:   : s = ;\n", 
        "case *:\\\\ : s = ;\n",      "}\n",      "}\n",      "if $(s) = $(<)\n", 
        "{\n",      "NotFile $(s) ;\n",      "}\n",      "else if $(s:G=)\n", 
        "{\n",      "Depends $(<) : $(s) ;\n",      "MkDir $(s) ;\n",      "}\n", 
        "}\n",      "}\n",      "rule Object\n",      "{\n", 
        "Clean clean : $(<) ;\n",      "MakeLocate $(<) : $(LOCATE_TARGET) ;\n",      "SEARCH on $(>) = $(SEARCH_SOURCE) ;\n",      "HDRS on $(<) = $(SEARCH_SOURCE) $(SUBDIRHDRS) $(HDRS) ;\n", 
        "HDRRULE on $(>) = HdrRule ;\n",      "HDRSCAN on $(>) = $(HDRPATTERN) ;\n",      "HDRSEARCH on $(>) = \n",      "$(SEARCH_SOURCE:E) $(SUBDIRHDRS) $(HDRS) $(STDHDRS) ;\n", 
        "HDRGRIST on $(>) = $(HDRGRIST) ;\n",      "DEFINES on $(<) += $(DEFINES) ;\n",      "switch $(>:S)\n",      "{\n", 
        "case .asm : As $(<) : $(>) ;\n",      "case .c :\tCc $(<) : $(>) ;\n",      "case .C :\tC++ $(<) : $(>) ;\n",      "case .cc :\tC++ $(<) : $(>) ;\n", 
        "case .cpp : C++ $(<) : $(>) ;\n",      "case .f :\tFortran $(<) : $(>) ;\n",      "case .l :\tCc $(<) : $(<:S=.c) ;\n",      "Lex $(<:S=.c) : $(>) ;\n", 
        "case .s :\tAs $(<) : $(>) ;\n",      "case .y :\tCc $(<) : $(<:S=$(YACCGEN)) ;\n",      "Yacc $(<:S=$(YACCGEN)) : $(>) ;\n",      "case * :\tUserObject $(<) : $(>) ;\n", 
        "}\n",      "}\n",      "rule ObjectCcFlags\n",      "{\n", 
        "CCFLAGS on [ FGristFiles $(<:S=$(SUFOBJ)) ] += $(>) ;\n",      "}\n",      "rule ObjectC++Flags\n",      "{\n", 
        "C++FLAGS on [ FGristFiles $(<:S=$(SUFOBJ)) ] += $(>) ;\n",      "}\n",      "rule ObjectDefines\n",      "{\n", 
        "local s = [ FGristFiles $(<:S=$(SUFOBJ)) ] ;\n",      "DEFINES on $(s) += $(>) ;\n",      "CCDEFS on $(s) = [ on $(s) FDefines $(DEFINES) ] ;\n",      "}\n", 
        "rule ObjectHdrs\n",      "{\n",      "local s = [ FGristFiles $(<:S=$(SUFOBJ)) ] ;\n",      "HDRS on $(s) += $(>) ;\n", 
        "CCHDRS on $(s) = [ on $(s) FIncludes $(HDRS) ] ;\n",      "}\n",      "rule Objects\n",      "{\n", 
        "local _i ;\n",      "for _i in [ FGristFiles $(<) ]\n",      "{\n",      "Object $(_i:S=$(SUFOBJ)) : $(_i) ;\n", 
        "Depends obj : $(_i:S=$(SUFOBJ)) ;\n",      "}\n",      "}\n",      "rule RmTemps\n", 
        "{\n",      "Temporary $(>) ;\n",      "}\n",      "rule Setuid\n", 
        "{\n",      "MODE on [ FAppendSuffix $(<) : $(SUFEXE) ] = 4755 ;\n",      "}\n",      "rule Shell\n", 
        "{\n",      "Depends shell : $(<) ;\n",      "Depends $(<) : $(>) ;\n",      "SEARCH on $(>) = $(SEARCH_SOURCE) ;\n", 
        "MODE on $(<) = $(SHELLMODE) ;\n",      "Clean clean : $(<) ;\n",      "Chmod $(<) ;\n",      "}\n", 
        "rule SoftLink\n",      "{\n",      "Depends files : $(<) ;\n",      "Depends $(<) : $(>) ;\n", 
        "SEARCH on $(>) = $(SEARCH_SOURCE) ;\n",      "Clean clean : $(<) ;\n",      "}\n",      "rule SubDir\n", 
        "{\n",      "local _top = $(<[1]) ;\n",      "local _tokens = $(<[2-]) ;\n",      "if ! $(_top)\n", 
        "{\n",      "Exit SubDir syntax error ;\n",      "}\n",      "if ! $($(_top)-SET)\n", 
        "{\n",      "$(_top)-SET = true ;\n",      "if $($(_top))\n",      "{\n", 
        "$(_top)-UP = ;\n",      "$(_top)-DOWN = ;\n",      "$(_top)-ROOT = $($(_top)) ;\n",      "}\n", 
        "else\n",      "{\n",      "_tokens = [ FReverse $(_tokens) ] ;\n",      "SUBDIR_DOWN = [ FReverse $(SUBDIR_DOWN) ] ;\n", 
        "FStripCommon _tokens : SUBDIR_DOWN ;\n",      "SUBDIR_DOWN = [ FReverse $(SUBDIR_DOWN) ] ;\n",      "_tokens = [ FReverse $(_tokens) ] ;\n",      "if $(SUBDIR_DOWN) && $(_tokens) \n", 
        "{ \n",      "Echo Warning: SubDir $(<) misplaced! ; \n",      "}\n",      "$(_top)-UP = $(SUBDIR_UP) $(_tokens) ;\n", 
        "$(_top)-DOWN = $(SUBDIR_DOWN) ;\n",      "$(_top)-ROOT = $(SUBDIR_ROOT:E=\"\") ;\n",      "$(_top) = [ FSubDirPath $(_top) ] ;\n",      "}\n", 
        "SUBDIR_UP = $($(_top)-UP) ;\n",      "SUBDIR_DOWN = ;\n",      "SUBDIR_ROOT = $($(_top)-ROOT) ;\n",      "if $($(_top)RULES) { \n", 
        "include $($(_top)RULES) ;\n",      "} else { \n",      "NoCare $(JAMRULES:R=$($(_top)):G=$(_top)) ;\n",      "include $(JAMRULES:R=$($(_top)):G=$(_top)) ;\n", 
        "}\n",      "}\n",      "SUBDIR_UP = $($(_top)-UP) ;\n",      "SUBDIR_DOWN = $($(_top)-DOWN) $(_tokens) ;\n", 
        "SUBDIR_ROOT = $($(_top)-ROOT) ;\n",      "SUBDIR_TOKENS = $(SUBDIR_DOWN) ;\n",      "SUBDIR = [ FSubDirPath $(<) ] ;\n",      "SEARCH_SOURCE = $(SUBDIR) ;\n", 
        "LOCATE_SOURCE = $(ALL_LOCATE_TARGET) $(SUBDIR) ;\n",      "LOCATE_TARGET = $(ALL_LOCATE_TARGET) $(SUBDIR) ;\n",      "SOURCE_GRIST = [ FGrist $(SUBDIR_TOKENS) ] ;\n",      "SUBDIR$(SUBDIRRESET) = ;\n", 
        "$(SUBDIRRULES) $(<) ;\n",      "}\n",      "rule FSubDirPath\n",      "{\n", 
        "local _r = [ FRelPath $($(<[1])-UP) : $($(<[1])-DOWN) $(<[2-]) ] ;\n",      "return $(_r:R=$($(<[1])-ROOT)) ;\n",      "}\n",      "rule SubDirCcFlags\n", 
        "{\n",      "SUBDIRCCFLAGS += $(<) ;\n",      "}\n",      "rule SubDirC++Flags\n", 
        "{\n",      "SUBDIRC++FLAGS += $(<) ;\n",      "}\n",      "rule SubDirHdrs\n", 
        "{\n",      "SUBDIRHDRS += [ FDirName $(<) ] ;\n",      "}\n",      "rule SubInclude\n", 
        "{\n",      "if ! $($(<[1]))\n",      "{\n",      "Exit SubInclude $(<[1]) without prior SubDir $(<[1]) ;\n", 
        "}\n",      "SubDir $(<) ;\n",      "include $(JAMFILE:D=$(SUBDIR)) ;\n",      "}\n", 
        "rule SubRules\n",      "{\n",      "if ! $($(<[1]))\n",      "{\n", 
        "Exit SubRules $(<[1]) without prior SubDir $(<[1]) ;\n",      "}\n",      "SubDir $(<) ;\n",      "SubDir $(>) ;\n", 
        "}\n",      "rule Undefines\n",      "{\n",      "UNDEFS on [ FAppendSuffix $(<) : $(SUFEXE) ] += $(UNDEFFLAG)$(>) ;\n", 
        "}\n",      "rule UserObject\n",      "{\n",      "Exit \"Unknown suffix on\" $(>) \"- see UserObject rule in /usr/share/doc/jam/Jamfile.html.\" ;\n", 
        "}\n",      "rule Yacc\n",      "{\n",      "local _h ;\n", 
        "_h = $(<:BS=.h) ;\n",      "MakeLocate $(<) $(_h) : $(LOCATE_SOURCE) ;\n",      "if $(YACC)\n",      "{\n", 
        "Depends $(<) $(_h) : $(>) ;\n",      "Yacc1 $(<) $(_h) : $(>) ;\n",      "YaccMv $(<) $(_h) : $(>) ;\n",      "Clean clean : $(<) $(_h) ;\n", 
        "}\n",      "Includes $(<) : $(_h) ;\n",      "}\n",      "rule FGrist\n", 
        "{\n",      "return $(<:J=!) ;\n",      "}\n",      "rule FGristFiles \n", 
        "{\n",      "return $(<:G=$(SOURCE_GRIST:E)) ;\n",      "}\n",      "rule FGristSourceFiles\n", 
        "{\n",      "if ! $(SOURCE_GRIST)\n",      "{\n",      "return $(<) ;\n", 
        "}\n",      "else \n",      "{\n",      "local _i _o ;\n", 
        "for _i in $(<)\n",      "{\n",      "switch $(_i)\n",      "{\n", 
        "case *.h :\t_o += $(_i) ;\n",      "case * : \t_o += $(_i:G=$(SOURCE_GRIST)) ;\n",      "}\n",      "}\n", 
        "return $(_o) ;\n",      "}\n",      "}\n",      "rule FReverse \n", 
        "{\n",      "if $(1) { return [ FReverse $(1[2-]) ] $(1[1]) ; }\n",      "}\n",      "rule FSubDir\n", 
        "{\n",      "if ! $(<[1]) \n",      "{\n",      "return $(DOT) ;\n", 
        "} \n",      "else\n",      "{\n",      "local _i _d ;\n", 
        "_d = $(DOTDOT) ;\n",      "for _i in $(<[2-])\n",      "{\n",      "_d = $(_d:R=$(DOTDOT)) ;\n", 
        "}\n",      "return $(_d) ;\n",      "}\n",      "}\n", 
        "rule FStripCommon\n",      "{\n",      "if $($(<)[1]) && $($(<)[1]) = $($(>)[1])\n",      "{\n", 
        "$(<) = $($(<)[2-]) ;\n",      "$(>) = $($(>)[2-]) ;\n",      "FStripCommon $(<) : $(>) ;\n",      "}\n", 
        "}\n",      "rule FRelPath\n",      "{\n",      "local _l _r ;\n", 
        "_l = $(<) ;\n",      "_r = $(>) ;\n",      "FStripCommon _l : _r ;\n",      "_l = [ FSubDir $(_l) ] ;\n", 
        "_r = [ FDirName $(_r) ] ;\n",      "if $(_r) = $(DOT) {\n",      "return $(_l) ;\n",      "} else {\n", 
        "return $(_r:R=$(_l)) ;\n",      "}\n",      "}\n",      "rule FAppendSuffix\n", 
        "{\n",      "if $(>)\n",      "{\n",      "local _i _o ;\n", 
        "for _i in $(<)\n",      "{\n",      "if $(_i:S)\n",      "{\n", 
        "_o += $(_i) ;\n",      "}\n",      "else\n",      "{\n", 
        "_o += $(_i:S=$(>)) ;\n",      "}\n",      "}\n",      "return $(_o) ;\n", 
        "}\n",      "else\n",      "{\n",      "return $(<) ;\n", 
        "}\n",      "}\n",      "rule FQuote { return \\\\\\\"$(<)\\\\\\\" ; }\n",      "rule FDefines { return -D$(<) ; }\n", 
        "rule FIncludes { return -I$(<) ; }\n",      "rule FDirName\n",      "{\n",      "local _i ;\n", 
        "local _s = $(DOT) ;\n",      "for _i in $(<)\n",      "{\n",      "_s = $(_i:R=$(_s)) ;\n", 
        "}\n",      "return $(_s) ;\n",      "}\n",      "if $(OS2)\n", 
        "{\n",      "rule FQuote { return \\\"$(<)\\\" ; }\n",      "rule FIncludes { return /I$(<) ; }\n",      "}\n", 
        "else if $(NT)\n",      "{\n",      "rule FDefines { return /D$(<) ; }\n",      "rule FIncludes { return /I$(<) ; }\n", 
        "}\n",      "else if $(MAC)\n",      "{\n",      "rule FQuote { return \\\"$(<)\\\" ; }\n", 
        "rule FDefines { return \"-define \'$(<)\'\" ; }\n",      "rule FIncludes { return \\\"$(<:J=,)\\\" ; }\n",      "}\n",      "else if $(VMS)\n", 
        "{\n",      "rule FQuote { return \\\"\\\"\\\"$(<)\\\"\\\"\\\" ; }\n",      "rule FDefines { return \"/define=( $(<:J=,) )\" ; }\n",      "rule FIncludes { return \"/inc=( $(<:J=,) )\" ; }\n", 
        "rule FDirName\n",      "{\n",      "local _s _i ;\n",      "if ! $(<)\n", 
        "{\n",      "_s = $(DOT) ;\n",      "}\n",      "else \n", 
        "{\n",      "switch $(<[1])\n",      "{\n",      "case *:* : _s = $(<[1]) ;\n", 
        "case \\\\[*\\\\] : _s = $(<[1]) ;\n",      "case * : _s = [.$(<[1])] ;\n",      "}\n",      "for _i in [.$(<[2-])]\n", 
        "{\n",      "_s = $(_i:R=$(_s)) ;\n",      "}\n",      "}\n", 
        "return $(_s) ;\n",      "}\n",      "}\n",      "actions updated together piecemeal Archive\n", 
        "{\n",      "$(AR) $(<) $(>)\n",      "}\n",      "actions As\n", 
        "{\n",      "$(AS) $(ASFLAGS) $(ASHDRS) -o $(<) $(>)\n",      "}\n",      "actions C++\n", 
        "{\n",      "$(C++) -c -o $(<) $(C++FLAGS) $(CCDEFS) $(CCHDRS) $(>)\n",      "}\n",      "actions Cc\n", 
        "{\n",      "$(CC) -c -o $(<) $(CCFLAGS) $(CCDEFS) $(CCHDRS) $(>)\n",      "}\n",      "actions Chgrp\n", 
        "{\n",      "$(CHGRP) $(GROUP) $(<)\n",      "}\n",      "actions Chmod1\n", 
        "{\n",      "$(CHMOD) $(MODE) $(<)\n",      "}\n",      "actions Chown\n", 
        "{\n",      "$(CHOWN) $(OWNER) $(<)\n",      "}\n",      "actions piecemeal together existing Clean\n", 
        "{\n",      "$(RM) $(>)\n",      "}\n",      "actions File\n", 
        "{\n",      "$(CP) $(>) $(<)\n",      "}\n",      "actions GenFile1\n", 
        "{\n",      "$(>[1]) $(<) $(>[2-])\n",      "}\n",      "actions Fortran\n", 
        "{\n",      "$(FORTRAN) $(FORTRANFLAGS) -o $(<) $(>)\n",      "}\n",      "actions HardLink\n", 
        "{\n",      "$(RM) $(<) && $(LN) $(>) $(<)\n",      "}\n",      "actions Install\n", 
        "{\n",      "$(CP) $(>) $(<) \n",      "}\n",      "actions Lex\n", 
        "{\n",      "$(LEX) $(>)\n",      "}\n",      "actions LexMv\n", 
        "{\n",      "$(MV) lex.yy.c $(<)\n",      "}\n",      "actions Link bind NEEDLIBS\n", 
        "{\n",      "$(LINK) $(LINKFLAGS) -o $(<) $(UNDEFS) $(>) $(NEEDLIBS) $(LINKLIBS) \n",      "}\n",      "actions MkDir1\n", 
        "{\n",      "$(MKDIR) $(<)\n",      "}\n",      "actions together Ranlib\n", 
        "{\n",      "$(RANLIB) $(<)\n",      "}\n",      "actions quietly updated piecemeal together RmTemps\n", 
        "{\n",      "$(RM) $(>)\n",      "}\n",      "actions Shell\n", 
        "{\n",      "$(AWK) \'\n",      "NR == 1 { print \"$(SHELLHEADER)\" }\n",      "NR == 1 && /^[#:]/ { next }\n", 
        "/^##/ { next }\n",      "{ print }\n",      "\' < $(>) > $(<)\n",      "}\n", 
        "actions SoftLink\n",      "{\n",      "$(RM) $(<) && $(LN) -s $(>) $(<)\n",      "}\n", 
        "actions Yacc1\n",      "{\n",      "$(YACC) $(YACCFLAGS) $(>)\n",      "}\n", 
        "actions YaccMv\n",      "{\n",      "$(MV) $(YACCFILES).c $(<[1])\n",      "$(MV) $(YACCFILES).h $(<[2])\n", 
        "}\n",      "if $(RELOCATE)\n",      "{\n",      "actions C++\n", 
        "{\n",      "$(C++) -c $(C++FLAGS) $(CCDEFS) $(CCHDRS) $(>)\n",      "}\n",      "actions Cc\n", 
        "{\n",      "$(CC) -c $(CCFLAGS) $(CCDEFS) $(CCHDRS) $(>)\n",      "}\n",      "actions ignore CcMv\n", 
        "{\n",      "[ $(<) != $(>:BS=$(SUFOBJ)) ] && $(MV) $(>:BS=$(SUFOBJ)) $(<)\n",      "}\n",      "}\n", 
        "if $(NOARUPDATE)\n",      "{\n",      "actions Archive\n",      "{\n", 
        "$(AR) $(<) $(>)\n",      "}\n",      "}\n",      "if $(UNIX)\n", 
        "{\n",      "actions GenFile1\n",      "{\n",      "PATH=\"$PATH:.\"\n", 
        "$(>[1]) $(<) $(>[2-])\n",      "}\n",      "}\n",      "if $(NT) && $(MSVCNT)\n", 
        "{\n",      "actions updated together piecemeal Archive\n",      "{\n",      "if exist $(<) set _$(<:B)_=$(<)\n", 
        "$(AR) /out:$(<) %_$(<:B)_% $(>)\n",      "}\n",      "actions As\n",      "{\n", 
        "$(AS) /Ml /p /v /w2 $(>) $(<) ,nul,nul;\n",      "}\n",      "actions Cc\n",      "{\n", 
        "$(CC) /c /Fo$(<) $(CCFLAGS) $(CCDEFS) $(CCHDRS) /I$(STDHDRS) $(>)\n",      "}\n",      "actions C++\n",      "{\n", 
        "$(C++) /c /Fo$(<) $(C++FLAGS) $(CCDEFS) $(CCHDRS) /I$(STDHDRS) /Tp$(>)\n",      "}\n",      "actions Link bind NEEDLIBS\n",      "{\n", 
        "$(LINK) $(LINKFLAGS) /out:$(<) $(UNDEFS) $(>) $(NEEDLIBS) $(LINKLIBS)\n",      "}\n",      "}\n",      "else if $(NT) && $(MSVC)\n", 
        "{\n",      "actions updated together piecemeal Archive\n",      "{\n",      "$(AR) $(<) -+$(>)\n", 
        "}\n",      "actions Cc\n",      "{\n",      "$(CC) /c /Fo$(<) $(CCFLAGS) $(CCDEFS) $(CCHDRS) $(>)\n", 
        "}\n",      "actions C++\n",      "{\n",      "$(C++) /c /Fo$(<) $(C++FLAGS) $(CCDEFS) $(CCHDRS) /Tp$(>)\n", 
        "}\n",      "actions Link bind NEEDLIBS\n",      "{\n",      "$(LINK) $(LINKFLAGS) /out:$(<) $(UNDEFS) $(>) $(NEEDLIBS) $(LINKLIBS)\n", 
        "}\n",      "}\n",      "else if $(NT) && $(BCCROOT)\n",      "{\n", 
        "actions updated together piecemeal Archive\n",      "{\n",      "$(AR) $(<) -+$(>)\n",      "}\n", 
        "actions Link bind NEEDLIBS\n",      "{\n",      "$(LINK) -e$(<) $(LINKFLAGS) $(UNDEFS) -L$(LINKLIBS) $(NEEDLIBS) $(>)\n",      "}\n", 
        "actions C++\n",      "{\n",      "$(C++) -c -o$(<) $(C++FLAGS) $(CCDEFS) $(CCHDRS) $(>)\n",      "}\n", 
        "actions Cc\n",      "{\n",      "$(CC) -c -o$(<) $(CCFLAGS) $(CCDEFS) $(CCHDRS) $(>)\n",      "}\n", 
        "}\n",      "else if $(OS2) && $(WATCOM)\n",      "{\n",      "actions together piecemeal Archive\n", 
        "{\n",      "$(AR) $(<) +-$(>) \n",      "}\n",      "actions Cc\n", 
        "{\n",      "$(CC) /Fo=$(<) $(CCFLAGS) $(CCDEFS) $(CCHDRS) $(>)\n",      "}\n",      "actions C++\n", 
        "{\n",      "$(C++) /Fo=$(<) $(C++FLAGS) $(CCDEFS) $(CCHDRS) $(>)\n",      "}\n",      "actions Link bind NEEDLIBS\n", 
        "{\n",      "$(LINK) $(LINKFLAGS) /Fe=$(<) $(UNDEFS) $(>) $(NEEDLIBS) $(LINKLIBS)\n",      "}\n",      "actions Shell\n", 
        "{\n",      "$(CP) $(>) $(<)\n",      "}\n",      "}\n", 
        "else if $(VMS)\n",      "{\n",      "actions updated together piecemeal Archive \n",      "{\n", 
        "lib/replace $(<) $(>[1]) ,$(>[2-])\n",      "}\n",      "actions Cc\n",      "{ \n", 
        "$(CC)/obj=$(<) $(CCFLAGS) $(CCDEFS) $(CCHDRS) $(>) \n",      "}\n",      "actions C++\n",      "{ \n", 
        "$(C++)/obj=$(<) $(C++FLAGS) $(CCDEFS) $(CCHDRS) $(>) \n",      "}\n",      "actions piecemeal together existing Clean\n",      "{\n", 
        "$(RM) $(>[1]);* ,$(>[2-]);*\n",      "}\n",      "actions together quietly CreLib\n",      "{\n", 
        "if f$search(\"$(<)\") .eqs. \"\" then lib/create $(<)\n",      "}\n",      "actions GenFile1\n",      "{\n", 
        "mcr $(>[1]) $(<) $(>[2-])\n",      "}\n",      "actions Link bind NEEDLIBS\n",      "{\n", 
        "$(LINK)/exe=$(<) $(LINKFLAGS) $(>:J=,) ,$(NEEDLIBS)/lib ,$(LINKLIBS)\n",      "}\n",      "actions quietly updated piecemeal together RmTemps\n",      "{\n", 
        "$(RM) $(>[1]);* ,$(>[2-]);*\n",      "}\n",      "actions Shell\n",      "{\n", 
        "$(CP) $(>) $(<)\n",      "}\n",      "}\n",      "else if $(MAC)\n", 
        "{\n",      "actions together Archive \n",      "{\n",      "$(LINK) -library -o $(<) $(>)\n", 
        "}\n",      "actions Cc\n",      "{\n",      "set -e MWCincludes $(CCHDRS)\n", 
        "$(CC) -o $(<) $(CCFLAGS) $(CCDEFS) $(>) \n",      "}\n",      "actions C++\n",      "{\n", 
        "set -e MWCincludes $(CCHDRS)\n",      "$(CC) -o $(<) $(C++FLAGS) $(CCDEFS) $(>) \n",      "}\n",      "actions Link bind NEEDLIBS\n", 
        "{\n",      "$(LINK) -o $(<) $(LINKFLAGS) $(>) $(NEEDLIBS) \"$(LINKLIBS)\"\n",      "}\n",      "}\n", 
        "if $(WIN98)\n",      "{\n",      "actions existing Clean\n",      "{\n", 
        "del $(>)\n",      "}\n",      "}\n",      "rule BULK { Bulk $(<) : $(>) ; }\n", 
        "rule FILE { File $(<) : $(>) ; }\n",      "rule HDRRULE { HdrRule $(<) : $(>) ; }\n",      "rule INSTALL { Install $(<) : $(>) ; }\n",      "rule LIBRARY { Library $(<) : $(>) ; }\n", 
        "rule LIBS { LinkLibraries $(<) : $(>) ; }\n",      "rule LINK { Link $(<) : $(>) ; }\n",      "rule MAIN { Main $(<) : $(>) ; }\n",      "rule SETUID { Setuid $(<) ; }\n", 
        "rule SHELL { Shell $(<) : $(>) ; }\n",      "rule UNDEFINES { Undefines $(<) : $(>) ; }\n",      "rule INSTALLBIN { InstallBin $(BINDIR) : $(<) ; }\n",      "rule INSTALLLIB { InstallLib $(LIBDIR) : $(<) ; }\n", 
        "rule INSTALLMAN { InstallMan $(MANDIR) : $(<) ; }\n",      "rule addDirName { $(<) += [ FDirName $(>) ] ; }\n",      "rule makeCommon { FStripCommon $(<) : $(>) ; }\n",      "rule _makeCommon { FStripCommon $(<) : $(>) ; }\n", 
        "rule makeDirName { $(<) = [ FDirName $(>) ] ; }\n",      "rule makeGrist { $(<) = [ FGrist $(>) ] ; }\n",      "rule makeGristedName { $(<) = [ FGristSourceFiles $(>) ] ; }\n",      "rule makeRelPath { $(<[1]) = [ FRelPath $(<[2-]) : $(>) ] ; }\n", 
        "rule makeString { $(<) = $(>:J) ; }\n",      "rule makeSubDir { $(<) = [ FSubDir $(>) ] ; }\n",      "rule makeSuffixed { $(<[1]) = [ FAppendSuffix $(>) : $(<[2]) ] ; }\n",      "include $(JAMFILE) ;\n", 
        (char const   *)0};
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 47 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/scan.h"
void yyfparse(char const   *s ) ;
#line 48
int yyline(void) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/scan.c"
struct keyword keywords[46]  = 
#line 30 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/scan.c"
  {      {"<", 258}, 
        {"<=", 259}, 
        {"=", 260}, 
        {">", 261}, 
        {">=", 262}, 
        {"|", 263}, 
        {"||", 264}, 
        {";", 265}, 
        {":", 266}, 
        {"!", 267}, 
        {"!=", 268}, 
        {"?=", 269}, 
        {"(", 270}, 
        {")", 271}, 
        {"[", 272}, 
        {"]", 273}, 
        {"{", 274}, 
        {"}", 275}, 
        {"&", 276}, 
        {"&&", 277}, 
        {"+=", 278}, 
        {"actions", 279}, 
        {"bind", 280}, 
        {"break", 281}, 
        {"case", 282}, 
        {"continue", 283}, 
        {"default", 284}, 
        {"else", 285}, 
        {"existing", 286}, 
        {"for", 287}, 
        {"if", 288}, 
        {"ignore", 289}, 
        {"in", 290}, 
        {"include", 291}, 
        {"local", 292}, 
        {"maxline", 293}, 
        {"on", 294}, 
        {"piecemeal", 295}, 
        {"quietly", 296}, 
        {"return", 297}, 
        {"rule", 298}, 
        {"switch", 299}, 
        {"together", 300}, 
        {"updated", 301}, 
        {"while", 302}, 
        {(char const   *)0, 0}};
#line 48 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/scan.c"
static struct include *incp  =    (struct include *)0;
#line 50 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/scan.c"
static int scanmode  =    0;
#line 51 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/scan.c"
static int anyerrors  =    0;
#line 52
static char *symdump(YYSYMBOL *s ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/scan.c"
void yymode(int n ) 
{ 


  {
#line 63
  scanmode = n;
#line 64
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/scan.c"
void yyerror(char const   *s ) 
{ 
  char *tmp ;

  {
#line 69
  if (incp) {
    {
#line 70
    printf((char const   */* __restrict  */)"%s: line %d: ", incp->fname, incp->line);
    }
  }
  {
#line 72
  tmp = symdump(& yylval);
#line 72
  printf((char const   */* __restrict  */)"%s at %s\n", s, tmp);
#line 74
  anyerrors ++;
  }
#line 75
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/scan.c"
int yyanyerrors(void) 
{ 


  {
#line 80
  return (anyerrors != 0);
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/scan.c"
void yyfparse(char const   *s ) 
{ 
  struct include *i ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 86
  tmp = malloc(sizeof(*i));
#line 86
  i = (struct include *)tmp;
#line 90
  i->string = "";
#line 91
  i->strings = (char **)0;
#line 92
  i->file = (FILE *)0;
#line 93
  i->fname = copystr(s);
#line 94
  i->line = 0;
#line 95
  i->next = incp;
#line 96
  incp = i;
#line 100
  tmp___0 = strcmp(s, "+");
  }
#line 100
  if (! tmp___0) {
#line 101
    i->strings = jambase;
  }
#line 102
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/scan.c"
int yyline(void) 
{ 
  struct include *i ;
  char const   *tmp ;
  char **tmp___0 ;
  char const   *tmp___1 ;
  FILE *f ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;

  {
#line 114
  i = incp;
#line 116
  if (! incp) {
#line 117
    return (-1);
  }
#line 125
  if (*(i->string)) {
#line 126
    tmp = i->string;
#line 126
    (i->string) ++;
#line 126
    return ((int )*tmp);
  }
#line 131
  if (i->strings) {
#line 133
    if (! *(i->strings)) {
#line 134
      goto next;
    }
#line 136
    (i->line) ++;
#line 137
    tmp___0 = i->strings;
#line 137
    (i->strings) ++;
#line 137
    i->string = (char const   *)*tmp___0;
#line 138
    tmp___1 = i->string;
#line 138
    (i->string) ++;
#line 138
    return ((int )*tmp___1);
  }
#line 143
  if (! i->file) {
    {
#line 145
    f = stdin;
#line 147
    tmp___2 = strcmp(i->fname, "-");
    }
#line 147
    if (tmp___2) {
      {
#line 147
      f = fopen((char const   */* __restrict  */)i->fname, (char const   */* __restrict  */)"r");
      }
#line 147
      if (! f) {
        {
#line 148
        perror(i->fname);
        }
      }
    }
#line 150
    i->file = f;
  }
#line 155
  if (i->file) {
    {
#line 155
    tmp___4 = fgets((char */* __restrict  */)(i->buf), (int )sizeof(i->buf), (FILE */* __restrict  */)i->file);
    }
#line 155
    if (tmp___4) {
#line 157
      (i->line) ++;
#line 158
      i->string = (char const   *)(i->buf);
#line 159
      tmp___3 = i->string;
#line 159
      (i->string) ++;
#line 159
      return ((int )*tmp___3);
    }
  }
  next: 
#line 166
  incp = i->next;
#line 170
  if (i->file) {
#line 170
    if ((unsigned long )i->file != (unsigned long )stdin) {
      {
#line 171
      fclose(i->file);
      }
    }
  }
  {
#line 172
  freestr(i->fname);
#line 173
  free((void *)((char *)i));
  }
#line 175
  return (-1);
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/scan.c"
int yylex(void) 
{ 
  int c ;
  char buf___0[10240] ;
  char *b ;
  char const   *tmp ;
  int tmp___0 ;
  int nest ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char *b___0 ;
  struct keyword *k ;
  int inquote ;
  int notkeyword ;
  char const   *tmp___4 ;
  int tmp___5 ;
  unsigned short const   **tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  char const   *tmp___13 ;
  int tmp___14 ;
  unsigned short const   **tmp___15 ;
  int tmp___16 ;
  unsigned short const   **tmp___17 ;
  char *tmp___18 ;

  {
#line 198
  b = buf___0;
#line 200
  if (! incp) {
#line 201
    goto eof;
  }
#line 205
  if (*(incp->string)) {
#line 205
    tmp = incp->string;
#line 205
    (incp->string) ++;
#line 205
    c = (int )*tmp;
  } else {
    {
#line 205
    tmp___0 = yyline();
#line 205
    c = tmp___0;
    }
  }
#line 207
  if (scanmode == 1) {
#line 212
    nest = 1;
    {
#line 214
    while (1) {
      while_continue: /* CIL Label */ ;
#line 214
      if (c != -1) {
#line 214
        if (! ((unsigned long )b < (unsigned long )(buf___0 + sizeof(buf___0)))) {
#line 214
          goto while_break;
        }
      } else {
#line 214
        goto while_break;
      }
#line 216
      if (c == 123) {
#line 217
        nest ++;
      }
#line 219
      if (c == 125) {
#line 219
        nest --;
#line 219
        if (! nest) {
#line 220
          goto while_break;
        }
      }
#line 222
      tmp___1 = b;
#line 222
      b ++;
#line 222
      *tmp___1 = (char )c;
#line 224
      if (*(incp->string)) {
#line 224
        tmp___2 = incp->string;
#line 224
        (incp->string) ++;
#line 224
        c = (int )*tmp___2;
      } else {
        {
#line 224
        tmp___3 = yyline();
#line 224
        c = tmp___3;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 229
    if (c != -1) {
#line 230
      (incp->string) --;
    }
#line 234
    if ((unsigned long )b == (unsigned long )(buf___0 + sizeof(buf___0))) {
      {
#line 236
      yyerror("action block too big");
      }
#line 237
      goto eof;
    }
#line 240
    if (nest) {
      {
#line 242
      yyerror("unmatched {} in action block");
      }
#line 243
      goto eof;
    }
    {
#line 246
    *b = (char)0;
#line 247
    yylval.type = 304;
#line 248
    yylval.string = newstr((char const   *)(buf___0));
    }
  } else {
#line 253
    b___0 = buf___0;
#line 255
    inquote = 0;
    {
#line 260
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 264
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 264
        if (c != -1) {
          {
#line 264
          tmp___6 = __ctype_b_loc();
          }
#line 264
          if (! ((int const   )*(*tmp___6 + c) & 8192)) {
#line 264
            goto while_break___1;
          }
        } else {
#line 264
          goto while_break___1;
        }
#line 265
        if (*(incp->string)) {
#line 265
          tmp___4 = incp->string;
#line 265
          (incp->string) ++;
#line 265
          c = (int )*tmp___4;
        } else {
          {
#line 265
          tmp___5 = yyline();
#line 265
          c = tmp___5;
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 269
      if (c != 35) {
#line 270
        goto while_break___0;
      }
      {
#line 271
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 271
        if (*(incp->string)) {
#line 271
          tmp___7 = incp->string;
#line 271
          (incp->string) ++;
#line 271
          c = (int )*tmp___7;
        } else {
          {
#line 271
          tmp___8 = yyline();
#line 271
          c = tmp___8;
          }
        }
#line 271
        if (c != -1) {
#line 271
          if (! (c != 10)) {
#line 271
            goto while_break___2;
          }
        } else {
#line 271
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 277
    if (c == -1) {
#line 278
      goto eof;
    }
#line 283
    notkeyword = c == 36;
    {
#line 289
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 289
      if (c != -1) {
#line 289
        if ((unsigned long )b___0 < (unsigned long )(buf___0 + sizeof(buf___0))) {
#line 289
          if (! inquote) {
            {
#line 289
            tmp___15 = __ctype_b_loc();
            }
#line 289
            if ((int const   )*(*tmp___15 + c) & 8192) {
#line 289
              goto while_break___3;
            }
          }
        } else {
#line 289
          goto while_break___3;
        }
      } else {
#line 289
        goto while_break___3;
      }
#line 294
      if (c == 34) {
#line 297
        inquote = ! inquote;
#line 298
        notkeyword = 1;
      } else
#line 300
      if (c != 92) {
#line 303
        tmp___9 = b___0;
#line 303
        b___0 ++;
#line 303
        *tmp___9 = (char )c;
      } else {
#line 305
        if (*(incp->string)) {
#line 305
          tmp___11 = incp->string;
#line 305
          (incp->string) ++;
#line 305
          c = (int )*tmp___11;
        } else {
          {
#line 305
          tmp___12 = yyline();
#line 305
          c = tmp___12;
          }
        }
#line 305
        if (c != -1) {
#line 308
          tmp___10 = b___0;
#line 308
          b___0 ++;
#line 308
          *tmp___10 = (char )c;
#line 309
          notkeyword = 1;
        } else {
#line 314
          goto while_break___3;
        }
      }
#line 317
      if (*(incp->string)) {
#line 317
        tmp___13 = incp->string;
#line 317
        (incp->string) ++;
#line 317
        c = (int )*tmp___13;
      } else {
        {
#line 317
        tmp___14 = yyline();
#line 317
        c = tmp___14;
        }
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 322
    if ((unsigned long )b___0 == (unsigned long )(buf___0 + sizeof(buf___0))) {
      {
#line 324
      yyerror("string too big");
      }
#line 325
      goto eof;
    }
#line 328
    if (inquote) {
      {
#line 330
      yyerror("unmatched \" in string");
      }
#line 331
      goto eof;
    }
#line 336
    if (c != -1) {
#line 337
      (incp->string) --;
    }
#line 343
    *b___0 = (char)0;
#line 344
    yylval.type = 303;
#line 346
    if (! notkeyword) {
      {
#line 346
      tmp___17 = __ctype_b_loc();
      }
#line 346
      if ((int const   )*(*tmp___17 + (int )buf___0[0]) & 1024) {
#line 346
        if (! (scanmode == 2)) {
#line 346
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 348
        k = keywords;
        {
#line 348
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 348
          if (! k->word) {
#line 348
            goto while_break___4;
          }
#line 349
          if ((int )buf___0[0] == (int )*(k->word)) {
            {
#line 349
            tmp___16 = strcmp(k->word, (char const   *)(buf___0));
            }
#line 349
            if (! tmp___16) {
#line 351
              yylval.type = k->type;
#line 352
              yylval.string = k->word;
#line 353
              goto while_break___4;
            }
          }
#line 348
          k ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    }
#line 357
    if (yylval.type == 303) {
      {
#line 358
      yylval.string = newstr((char const   *)(buf___0));
      }
    }
  }
#line 361
  if (globs.debug[9]) {
    {
#line 362
    tmp___18 = symdump(& yylval);
#line 362
    printf((char const   */* __restrict  */)"scan %s\n", tmp___18);
    }
  }
#line 364
  return (yylval.type);
  eof: 
#line 367
  yylval.type = -1;
#line 368
  return (yylval.type);
}
}
#line 374 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/scan.c"
static char buf[10260]  ;
#line 371 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/scan.c"
static char *symdump(YYSYMBOL *s ) 
{ 


  {
  {
#line 378
  if (s->type == -1) {
#line 378
    goto case_neg_1;
  }
#line 381
  if (s->type == 0) {
#line 381
    goto case_0;
  }
#line 384
  if (s->type == 303) {
#line 384
    goto case_303;
  }
#line 387
  if (s->type == 304) {
#line 387
    goto case_304;
  }
#line 390
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 379
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"EOF");
  }
#line 380
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 382
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"unknown symbol %s",
          s->string);
  }
#line 383
  goto switch_break;
  case_303: /* CIL Label */ 
  {
#line 385
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"argument %s",
          s->string);
  }
#line 386
  goto switch_break;
  case_304: /* CIL Label */ 
  {
#line 388
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"string \"%s\"",
          s->string);
  }
#line 389
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 391
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"keyword %s",
          s->string);
  }
#line 392
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 394
  return (buf);
}
}
#line 11 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/timestamp.h"
void timestamp(char *target , time_t *time___0 ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/search.c"
char const   *search(char const   *target , time_t *time___0 ) 
{ 
  PATHNAME f[1] ;
  LIST *varlist ;
  char buf___0[1024] ;
  size_t tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
  {
#line 32
  path_parse(target, f);
#line 34
  f[0].part[0].ptr = (char const   *)0;
#line 35
  f[0].part[0].len = 0;
#line 37
  varlist = var_get("LOCATE");
  }
#line 37
  if (varlist) {
    {
#line 39
    f[0].part[1].ptr = varlist->string;
#line 40
    tmp = strlen(varlist->string);
#line 40
    f[0].part[1].len = (int )tmp;
#line 42
    path_build(f, buf___0, 1);
    }
#line 44
    if (globs.debug[6]) {
      {
#line 45
      printf((char const   */* __restrict  */)"locate %s: %s\n", target, buf___0);
      }
    }
    {
#line 47
    timestamp(buf___0, time___0);
#line 49
    tmp___0 = newstr((char const   *)(buf___0));
    }
#line 49
    return (tmp___0);
  } else {
    {
#line 51
    varlist = var_get("SEARCH");
    }
#line 51
    if (varlist) {
      {
#line 53
      while (1) {
        while_continue: /* CIL Label */ ;
#line 53
        if (! varlist) {
#line 53
          goto while_break;
        }
        {
#line 55
        f[0].part[1].ptr = varlist->string;
#line 56
        tmp___1 = strlen(varlist->string);
#line 56
        f[0].part[1].len = (int )tmp___1;
#line 58
        path_build(f, buf___0, 1);
        }
#line 60
        if (globs.debug[6]) {
          {
#line 61
          printf((char const   */* __restrict  */)"search %s: %s\n", target, buf___0);
          }
        }
        {
#line 63
        timestamp(buf___0, time___0);
        }
#line 65
        if (*time___0) {
          {
#line 66
          tmp___2 = newstr((char const   *)(buf___0));
          }
#line 66
          return (tmp___2);
        }
#line 68
        varlist = varlist->next;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 76
  f[0].part[1].ptr = (char const   *)0;
#line 77
  f[0].part[1].len = 0;
#line 79
  path_build(f, buf___0, 1);
  }
#line 81
  if (globs.debug[6]) {
    {
#line 82
    printf((char const   */* __restrict  */)"search %s: %s\n", target, buf___0);
    }
  }
  {
#line 84
  timestamp(buf___0, time___0);
#line 86
  tmp___3 = newstr((char const   *)(buf___0));
  }
#line 86
  return (tmp___3);
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/pathunix.c"
void path_parse(char const   *file , PATHNAME *f ) 
{ 
  char const   *p ;
  char const   *q ;
  char const   *end ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 53
  memset((void *)((char *)f), 0, sizeof(*f));
  }
#line 57
  if ((int const   )*(file + 0) == 60) {
    {
#line 57
    tmp = strchr(file, '>');
#line 57
    p = (char const   *)tmp;
    }
#line 57
    if (p) {
#line 59
      f->part[0].ptr = file;
#line 60
      f->part[0].len = (int )(p - file);
#line 61
      file = p + 1;
    }
  }
  {
#line 66
  tmp___0 = strrchr(file, '/');
#line 66
  p = (char const   *)tmp___0;
  }
#line 76
  if (p) {
#line 78
    f->part[2].ptr = file;
#line 79
    f->part[2].len = (int )(p - file);
#line 83
    if (! f->part[2].len) {
#line 84
      f->part[2].len = 1;
    }
#line 93
    file = p + 1;
  }
  {
#line 96
  tmp___1 = strlen(file);
#line 96
  end = file + tmp___1;
#line 100
  tmp___2 = strchr(file, '(');
#line 100
  p = (char const   *)tmp___2;
  }
#line 100
  if (p) {
#line 100
    if ((int const   )*(end + -1) == 41) {
#line 102
      f->part[5].ptr = p + 1;
#line 103
      f->part[5].len = (int )((end - p) - 2L);
#line 104
      end = p;
    }
  }
#line 110
  p = (char const   *)0;
#line 111
  q = file;
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 113
    tmp___4 = memchr((void const   *)q, '.', (size_t )(end - q));
#line 113
    q = (char const   *)((char *)tmp___4);
    }
#line 113
    if (! q) {
#line 113
      goto while_break;
    }
#line 114
    tmp___3 = q;
#line 114
    q ++;
#line 114
    p = tmp___3;
  }
  while_break: /* CIL Label */ ;
  }
#line 116
  if (p) {
#line 118
    f->part[4].ptr = p;
#line 119
    f->part[4].len = (int )(end - p);
#line 120
    end = p;
  }
#line 125
  f->part[3].ptr = file;
#line 126
  f->part[3].len = (int )(end - file);
#line 127
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/pathunix.c"
void path_build(PATHNAME *f , char *file , int binding ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 142
  if (f->part[0].len) {
#line 144
    if ((int const   )*(f->part[0].ptr + 0) != 60) {
#line 144
      tmp = file;
#line 144
      file ++;
#line 144
      *tmp = (char )'<';
    }
    {
#line 145
    memcpy((void */* __restrict  */)file, (void const   */* __restrict  */)f->part[0].ptr,
           (size_t )f->part[0].len);
#line 146
    file += f->part[0].len;
    }
#line 147
    if ((int )*(file + -1) != 62) {
#line 147
      tmp___0 = file;
#line 147
      file ++;
#line 147
      *tmp___0 = (char )'>';
    }
  }
#line 154
  if (f->part[1].len) {
#line 154
    if (f->part[1].len == 1) {
#line 154
      if (! ((int const   )*(f->part[1].ptr + 0) == 46)) {
#line 154
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 154
    if (f->part[2].len) {
#line 154
      if (! ((int const   )*(f->part[2].ptr + 0) == 47)) {
        {
#line 169
        memcpy((void */* __restrict  */)file, (void const   */* __restrict  */)f->part[1].ptr,
               (size_t )f->part[1].len);
#line 170
        file += f->part[1].len;
#line 171
        tmp___1 = file;
#line 171
        file ++;
#line 171
        *tmp___1 = (char )'/';
        }
      }
    } else {
      {
#line 169
      memcpy((void */* __restrict  */)file, (void const   */* __restrict  */)f->part[1].ptr,
             (size_t )f->part[1].len);
#line 170
      file += f->part[1].len;
#line 171
      tmp___1 = file;
#line 171
      file ++;
#line 171
      *tmp___1 = (char )'/';
      }
    }
  }
#line 174
  if (f->part[2].len) {
    {
#line 176
    memcpy((void */* __restrict  */)file, (void const   */* __restrict  */)f->part[2].ptr,
           (size_t )f->part[2].len);
#line 177
    file += f->part[2].len;
    }
  }
#line 183
  if (f->part[2].len) {
#line 183
    if (f->part[3].len) {
#line 183
      goto _L___0;
    } else
#line 183
    if (f->part[4].len) {
      _L___0: /* CIL Label */ 
#line 191
      if (f->part[2].len == 1) {
#line 191
        if (! ((int const   )*(f->part[2].ptr + 0) == 47)) {
#line 192
          tmp___2 = file;
#line 192
          file ++;
#line 192
          *tmp___2 = (char )'/';
        }
      } else {
#line 192
        tmp___2 = file;
#line 192
        file ++;
#line 192
        *tmp___2 = (char )'/';
      }
    }
  }
#line 195
  if (f->part[3].len) {
    {
#line 197
    memcpy((void */* __restrict  */)file, (void const   */* __restrict  */)f->part[3].ptr,
           (size_t )f->part[3].len);
#line 198
    file += f->part[3].len;
    }
  }
#line 201
  if (f->part[4].len) {
    {
#line 203
    memcpy((void */* __restrict  */)file, (void const   */* __restrict  */)f->part[4].ptr,
           (size_t )f->part[4].len);
#line 204
    file += f->part[4].len;
    }
  }
#line 207
  if (f->part[5].len) {
    {
#line 209
    tmp___3 = file;
#line 209
    file ++;
#line 209
    *tmp___3 = (char )'(';
#line 210
    memcpy((void */* __restrict  */)file, (void const   */* __restrict  */)f->part[5].ptr,
           (size_t )f->part[5].len);
#line 211
    file += f->part[5].len;
#line 212
    tmp___4 = file;
#line 212
    file ++;
#line 212
    *tmp___4 = (char )')';
    }
  }
#line 214
  *file = (char)0;
#line 215
  return;
}
}
#line 221 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/pathunix.c"
void path_parent(PATHNAME *f ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 226
  tmp___0 = "";
#line 226
  f->part[5].ptr = tmp___0;
#line 226
  tmp = tmp___0;
#line 226
  f->part[4].ptr = tmp;
#line 226
  f->part[3].ptr = tmp;
#line 230
  tmp___2 = 0;
#line 230
  f->part[5].len = tmp___2;
#line 230
  tmp___1 = tmp___2;
#line 230
  f->part[4].len = tmp___1;
#line 230
  f->part[3].len = tmp___1;
#line 233
  return;
}
}
#line 17 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/variable.h"
LIST *var_swap(char const   *symbol , LIST *value ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/rules.c"
static struct hash *rulehash  =    (struct hash *)0;
#line 45 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/rules.c"
static struct hash *targethash  =    (struct hash *)0;
#line 52 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/rules.c"
RULE *bindrule(char const   *rulename ) 
{ 
  RULE rule ;
  RULE *r ;
  int tmp ;

  {
#line 55
  r = & rule;
#line 57
  if (! rulehash) {
    {
#line 58
    rulehash = hashinit((int )sizeof(RULE ), "rules");
    }
  }
  {
#line 60
  r->name = rulename;
#line 62
  tmp = hashitem(rulehash, (HASHDATA **)(& r), 1);
  }
#line 62
  if (! tmp) {
    {
#line 64
    r->name = newstr(rulename);
#line 65
    r->procedure = (PARSE *)0;
#line 66
    r->actions = (char const   *)((char *)0);
#line 67
    r->bindlist = (LIST *)0;
#line 68
    r->params = (LIST *)0;
#line 69
    r->flags = 0;
    }
  }
#line 72
  return (r);
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/rules.c"
TARGET *bindtarget(char const   *targetname ) 
{ 
  TARGET target ;
  TARGET *t ;
  int tmp ;

  {
#line 82
  t = & target;
#line 84
  if (! targethash) {
    {
#line 85
    targethash = hashinit((int )sizeof(TARGET ), "targets");
    }
  }
  {
#line 87
  t->name = targetname;
#line 89
  tmp = hashitem(targethash, (HASHDATA **)(& t), 1);
  }
#line 89
  if (! tmp) {
    {
#line 91
    memset((void *)((char *)t), '\000', sizeof(*t));
#line 92
    t->name = newstr(targetname);
#line 93
    t->boundname = t->name;
    }
  }
#line 96
  return (t);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/rules.c"
TARGET *copytarget(TARGET const   *ot ) 
{ 
  TARGET *t ;
  void *tmp ;

  {
  {
#line 110
  tmp = malloc(sizeof(*t));
#line 110
  t = (TARGET *)tmp;
#line 111
  memset((void *)((char *)t), '\000', sizeof(*t));
#line 112
  t->name = copystr((char const   *)ot->name);
#line 113
  t->boundname = t->name;
#line 115
  t->flags = (char )((int )t->flags | 68);
  }
#line 117
  return (t);
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/rules.c"
void touchtarget(char const   *t ) 
{ 
  TARGET *tmp ;

  {
  {
#line 127
  tmp = bindtarget(t);
#line 127
  tmp->flags = (char )((int )tmp->flags | 8);
  }
#line 128
  return;
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/rules.c"
TARGETS *targetlist(TARGETS *chain , LIST *targets ) 
{ 
  TARGET *tmp ;

  {
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! targets) {
#line 143
      goto while_break;
    }
    {
#line 144
    tmp = bindtarget(targets->string);
#line 144
    chain = targetentry(chain, tmp);
#line 143
    targets = targets->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  return (chain);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/rules.c"
TARGETS *targetentry(TARGETS *chain , TARGET *target ) 
{ 
  TARGETS *c ;
  void *tmp ;

  {
  {
#line 164
  tmp = malloc(sizeof(TARGETS ));
#line 164
  c = (TARGETS *)tmp;
#line 165
  c->target = target;
  }
#line 167
  if (! chain) {
#line 167
    chain = c;
  } else {
#line 168
    (chain->tail)->next = c;
  }
#line 169
  chain->tail = c;
#line 170
  c->next = (TARGETS *)0;
#line 172
  return (chain);
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/rules.c"
TARGETS *targetchain(TARGETS *chain , TARGETS *targets ) 
{ 


  {
#line 190
  if (! targets) {
#line 191
    return (chain);
  } else
#line 192
  if (! chain) {
#line 193
    return (targets);
  }
#line 195
  (chain->tail)->next = targets;
#line 196
  chain->tail = targets->tail;
#line 198
  return (chain);
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/rules.c"
ACTIONS *actionlist(ACTIONS *chain , ACTION *action ) 
{ 
  ACTIONS *actions ;
  void *tmp ;

  {
  {
#line 210
  tmp = malloc(sizeof(ACTIONS ));
#line 210
  actions = (ACTIONS *)tmp;
#line 212
  actions->action = action;
  }
#line 214
  if (! chain) {
#line 214
    chain = actions;
  } else {
#line 215
    (chain->tail)->next = actions;
  }
#line 216
  chain->tail = actions;
#line 217
  actions->next = (ACTIONS *)0;
#line 219
  return (chain);
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/rules.c"
SETTINGS *addsettings(SETTINGS *head , int setflag , char const   *symbol , LIST *value ) 
{ 
  SETTINGS *v ;
  int tmp ;
  void *tmp___0 ;

  {
#line 242
  v = head;
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    if (! v) {
#line 242
      goto while_break;
    }
    {
#line 243
    tmp = strcmp(v->symbol, symbol);
    }
#line 243
    if (! tmp) {
#line 244
      goto while_break;
    }
#line 242
    v = v->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 250
  if (! v) {
    {
#line 252
    tmp___0 = malloc(sizeof(*v));
#line 252
    v = (SETTINGS *)tmp___0;
#line 253
    v->symbol = newstr(symbol);
#line 254
    v->value = value;
#line 255
    v->next = head;
#line 256
    head = v;
    }
  } else {
    {
#line 260
    if (setflag == 0) {
#line 260
      goto case_0;
    }
#line 266
    if (setflag == 1) {
#line 266
      goto case_1;
    }
#line 271
    if (setflag == 2) {
#line 271
      goto case_2;
    }
#line 258
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 262
    list_free(v->value);
#line 263
    v->value = value;
    }
#line 264
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 268
    v->value = list_append(v->value, value);
    }
#line 269
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 273
    list_free(value);
    }
#line 274
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 279
  return (head);
}
}
#line 297 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/rules.c"
SETTINGS *copysettings(SETTINGS *from ) 
{ 
  SETTINGS *head ;
  SETTINGS *v___0 ;
  void *tmp ;

  {
#line 300
  head = (SETTINGS *)0;
  {
#line 302
  while (1) {
    while_continue: /* CIL Label */ ;
#line 302
    if (! from) {
#line 302
      goto while_break;
    }
    {
#line 304
    tmp = malloc(sizeof(*v___0));
#line 304
    v___0 = (SETTINGS *)tmp;
#line 305
    v___0->symbol = copystr(from->symbol);
#line 306
    v___0->value = list_copy((LIST *)0, from->value);
#line 307
    v___0->next = head;
#line 308
    head = v___0;
#line 302
    from = from->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 311
  return (head);
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/rules.c"
void pushsettings(SETTINGS *v ) 
{ 


  {
  {
#line 321
  while (1) {
    while_continue: /* CIL Label */ ;
#line 321
    if (! v) {
#line 321
      goto while_break;
    }
    {
#line 322
    v->value = var_swap(v->symbol, v->value);
#line 321
    v = v->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 323
  return;
}
}
#line 329 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/rules.c"
void popsettings(SETTINGS *v ) 
{ 


  {
  {
#line 332
  pushsettings(v);
  }
#line 333
  return;
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/rules.c"
void freesettings(SETTINGS *v ) 
{ 
  SETTINGS *n ;

  {
  {
#line 342
  while (1) {
    while_continue: /* CIL Label */ ;
#line 342
    if (! v) {
#line 342
      goto while_break;
    }
    {
#line 344
    n = v->next;
#line 346
    freestr(v->symbol);
#line 347
    list_free(v->value);
#line 348
    free((void *)((char *)v));
#line 350
    v = n;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 352
  return;
}
}
#line 358 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/rules.c"
void donerules(void) 
{ 


  {
  {
#line 361
  hashdone(rulehash);
#line 362
  hashdone(targethash);
  }
#line 363
  return;
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/glob.c"
static void globchars___0(char const   *s , char const   *e , char *b ) ;
#line 121 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/glob.c"
static void globchars___0(char const   *s , char const   *e , char *b ) 
{ 
  int neg ;
  int c ;
  char const   *tmp ;
  int i ;

  {
  {
#line 127
  neg = 0;
#line 129
  memset((void *)b, '\000', (size_t )16);
  }
#line 131
  if ((int const   )*s == 94) {
#line 132
    neg ++;
#line 132
    s ++;
  }
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (! ((unsigned long )s < (unsigned long )e)) {
#line 134
      goto while_break;
    }
#line 138
    if ((unsigned long )(s + 2) < (unsigned long )e) {
#line 138
      if ((int const   )*(s + 1) == 45) {
#line 140
        c = (int )*(s + 0);
        {
#line 140
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 140
          if (! (c <= (int )*(s + 2))) {
#line 140
            goto while_break___0;
          }
#line 141
          *(b + c / 8) = (char )((int )*(b + c / 8) | (1 << c % 8));
#line 140
          c ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 142
        s += 3;
      } else {
#line 144
        tmp = s;
#line 144
        s ++;
#line 144
        c = (int )*tmp;
#line 145
        *(b + c / 8) = (char )((int )*(b + c / 8) | (1 << c % 8));
      }
    } else {
#line 144
      tmp = s;
#line 144
      s ++;
#line 144
      c = (int )*tmp;
#line 145
      *(b + c / 8) = (char )((int )*(b + c / 8) | (1 << c % 8));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  if (neg) {
#line 152
    i = 0;
    {
#line 152
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 152
      if (! (i < 16)) {
#line 152
        goto while_break___1;
      }
#line 153
      *(b + i) = (char )((int )*(b + i) ^ 255);
#line 152
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 158
  *(b + 0) = (char )((int )*(b + 0) & 254);
#line 159
  return;
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/compile.c"
static char const   *set_names___0[3]  = {      "=",      "+=",      "?="};
#line 83
static void debug_compile___0(int which , char const   *s ) ;
#line 134 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/compile.c"
static int lcmp___0(LIST *t , LIST *s ) 
{ 
  int status ;
  char const   *st ;
  char const   *tmp ;
  char const   *ss ;
  char const   *tmp___0 ;

  {
#line 137
  status = 0;
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    if (! status) {
#line 139
      if (! t) {
#line 139
        if (! s) {
#line 139
          goto while_break;
        }
      }
    } else {
#line 139
      goto while_break;
    }
#line 141
    if (t) {
#line 141
      tmp = t->string;
    } else {
#line 141
      tmp = "";
    }
#line 141
    st = tmp;
#line 142
    if (s) {
#line 142
      tmp___0 = s->string;
    } else {
#line 142
      tmp___0 = "";
    }
    {
#line 142
    ss = tmp___0;
#line 144
    status = strcmp(st, ss);
    }
#line 146
    if (t) {
#line 146
      t = t->next;
    } else {
#line 146
      t = t;
    }
#line 147
    if (s) {
#line 147
      s = s->next;
    } else {
#line 147
      s = s;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 150
  return (status);
}
}
#line 918 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/compile.c"
static int level___0  =    0;
#line 919 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/compile.c"
static char indent___0[36]  = 
#line 919
  {      (char )'>',      (char )'>',      (char )'>',      (char )'>', 
        (char )'|',      (char )'>',      (char )'>',      (char )'>', 
        (char )'>',      (char )'|',      (char )'>',      (char )'>', 
        (char )'>',      (char )'>',      (char )'|',      (char )'>', 
        (char )'>',      (char )'>',      (char )'>',      (char )'|', 
        (char )'>',      (char )'>',      (char )'>',      (char )'>', 
        (char )'|',      (char )'>',      (char )'>',      (char )'>', 
        (char )'>',      (char )'|',      (char )'>',      (char )'>', 
        (char )'>',      (char )'>',      (char )'|',      (char )'\000'};
#line 915 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/compile.c"
static void debug_compile___0(int which , char const   *s ) 
{ 
  int i ;

  {
#line 920
  i = ((1 + level___0) * 2) % 35;
#line 922
  if (which >= 0) {
    {
#line 923
    printf((char const   */* __restrict  */)"%*.*s ", i, i, indent___0);
    }
  }
#line 925
  if (s) {
    {
#line 926
    printf((char const   */* __restrict  */)"%s ", s);
    }
  }
#line 928
  level___0 += which;
#line 929
  return;
}
}
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/variable.c"
static struct hash *varhash  =    (struct hash *)0;
#line 54
static VARIABLE *var_enter(char const   *symbol ) ;
#line 55
static void var_dump(char const   *symbol , LIST *value , char const   *what ) ;
#line 66 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/variable.c"
void var_defines(char const   **e ) 
{ 
  char const   *val ;
  int tmp ;
  LIST *l ;
  char const   *pp ;
  char const   *p ;
  char split ;
  char buf___0[1024] ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (! *e) {
#line 69
      goto while_break;
    }
    {
#line 76
    tmp = strcmp(*e, "OS=Windows_NT");
    }
#line 76
    if (! tmp) {
#line 77
      goto __Cont;
    }
    {
#line 85
    tmp___4 = strchr(*e, '=');
#line 85
    val = (char const   *)tmp___4;
    }
#line 85
    if (val) {
#line 88
      l = (LIST *)0;
#line 93
      split = (char )' ';
#line 99
      if ((unsigned long )(val - 4) >= (unsigned long )*e) {
        {
#line 101
        tmp___0 = strncmp(val - 4, "PATH", (size_t )4);
        }
#line 101
        if (tmp___0) {
          {
#line 101
          tmp___1 = strncmp(val - 4, "Path", (size_t )4);
          }
#line 101
          if (tmp___1) {
            {
#line 101
            tmp___2 = strncmp(val - 4, "path", (size_t )4);
            }
#line 101
            if (! tmp___2) {
#line 104
              split = (char )':';
            }
          } else {
#line 104
            split = (char )':';
          }
        } else {
#line 104
          split = (char )':';
        }
      }
#line 109
      pp = val + 1;
      {
#line 109
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 109
        tmp___3 = strchr(pp, (int )split);
#line 109
        p = (char const   *)tmp___3;
        }
#line 109
        if (! p) {
#line 109
          goto while_break___0;
        }
        {
#line 111
        strncpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)pp,
                (size_t )(p - pp));
#line 112
        buf___0[p - pp] = (char )'\000';
#line 113
        l = list_new(l, (char const   *)(buf___0), 0);
#line 109
        pp = p + 1;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 116
      l = list_new(l, pp, 0);
#line 120
      strncpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)*e,
              (size_t )(val - *e));
#line 121
      buf___0[val - *e] = (char )'\000';
#line 123
      var_set((char const   *)(buf___0), l, 0);
      }
    }
    __Cont: /* CIL Label */ 
#line 69
    e ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 126
  return;
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/variable.c"
int var_string(char const   *in , char *out , int outsize , LOL *lol ) 
{ 
  char *out0 ;
  char *oute ;
  char *lastword ;
  int dollar ;
  char *tmp ;
  char const   *tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  unsigned short const   **tmp___4 ;
  LIST *l ;
  LIST *tmp___5 ;
  int so ;
  size_t tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 141
  out0 = out;
#line 142
  oute = (out + outsize) - 1;
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (! *in) {
#line 144
      goto while_break;
    }
#line 147
    dollar = 0;
    {
#line 151
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 151
      tmp___1 = __ctype_b_loc();
      }
#line 151
      if (! ((int const   )*(*tmp___1 + (int )*in) & 8192)) {
#line 151
        goto while_break___0;
      }
#line 153
      if ((unsigned long )out >= (unsigned long )oute) {
#line 154
        return (-1);
      }
#line 156
      tmp = out;
#line 156
      out ++;
#line 156
      tmp___0 = in;
#line 156
      in ++;
#line 156
      *tmp = (char )*tmp___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 159
    lastword = out;
    {
#line 163
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 163
      if (*in) {
        {
#line 163
        tmp___4 = __ctype_b_loc();
        }
#line 163
        if ((int const   )*(*tmp___4 + (int )*in) & 8192) {
#line 163
          goto while_break___1;
        }
      } else {
#line 163
        goto while_break___1;
      }
#line 165
      if ((unsigned long )out >= (unsigned long )oute) {
#line 166
        return (-1);
      }
#line 168
      if ((int const   )*(in + 0) == 36) {
#line 168
        if ((int const   )*(in + 1) == 40) {
#line 169
          dollar ++;
        }
      }
#line 171
      tmp___2 = out;
#line 171
      out ++;
#line 171
      tmp___3 = in;
#line 171
      in ++;
#line 171
      *tmp___2 = (char )*tmp___3;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 177
    if (dollar) {
      {
#line 179
      tmp___5 = var_expand((LIST *)0, (char const   *)lastword, (char const   *)out,
                           lol, 0);
#line 179
      l = tmp___5;
#line 181
      out = lastword;
      }
      {
#line 183
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 183
        if (! l) {
#line 183
          goto while_break___2;
        }
        {
#line 185
        tmp___6 = strlen(l->string);
#line 185
        so = (int )tmp___6;
        }
#line 187
        if ((unsigned long )(out + so) >= (unsigned long )oute) {
#line 188
          return (-1);
        }
        {
#line 190
        strcpy((char */* __restrict  */)out, (char const   */* __restrict  */)l->string);
#line 191
        out += so;
#line 195
        l = l->next;
        }
#line 195
        if (l) {
#line 196
          tmp___7 = out;
#line 196
          out ++;
#line 196
          *tmp___7 = (char )' ';
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 199
      list_free(l);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 203
  if ((unsigned long )out >= (unsigned long )oute) {
#line 204
    return (-1);
  }
#line 206
  tmp___8 = out;
#line 206
  out ++;
#line 206
  *tmp___8 = (char )'\000';
#line 208
  return ((int )(out - out0));
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/variable.c"
LIST *var_get(char const   *symbol ) 
{ 
  VARIABLE var ;
  VARIABLE *v ;
  int tmp ;

  {
#line 220
  v = & var;
#line 222
  v->symbol = symbol;
#line 224
  if (varhash) {
    {
#line 224
    tmp = hashitem(varhash, (HASHDATA **)(& v), 0);
    }
#line 224
    if (tmp) {
#line 226
      if (globs.debug[8]) {
        {
#line 227
        var_dump(v->symbol, v->value, "get");
        }
      }
#line 228
      return (v->value);
    }
  }
#line 231
  return ((LIST *)0);
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/variable.c"
void var_set(char const   *symbol , LIST *value , int flag ) 
{ 
  VARIABLE *v ;
  VARIABLE *tmp ;

  {
  {
#line 251
  tmp = var_enter(symbol);
#line 251
  v = tmp;
  }
#line 253
  if (globs.debug[7]) {
    {
#line 254
    var_dump(symbol, value, "set");
    }
  }
  {
#line 258
  if (flag == 0) {
#line 258
    goto case_0;
  }
#line 264
  if (flag == 1) {
#line 264
    goto case_1;
  }
#line 269
  if (flag == 2) {
#line 269
    goto case_2;
  }
#line 256
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 260
  list_free(v->value);
#line 261
  v->value = value;
  }
#line 262
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 266
  v->value = list_append(v->value, value);
  }
#line 267
  goto switch_break;
  case_2: /* CIL Label */ 
#line 271
  if (! v->value) {
#line 272
    v->value = value;
  } else {
    {
#line 274
    list_free(value);
    }
  }
#line 275
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 277
  return;
}
}
#line 283 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/variable.c"
LIST *var_swap(char const   *symbol , LIST *value ) 
{ 
  VARIABLE *v ;
  VARIABLE *tmp ;
  LIST *oldvalue ;

  {
  {
#line 288
  tmp = var_enter(symbol);
#line 288
  v = tmp;
#line 289
  oldvalue = v->value;
  }
#line 291
  if (globs.debug[7]) {
    {
#line 292
    var_dump(symbol, value, "set");
    }
  }
#line 294
  v->value = value;
#line 296
  return (oldvalue);
}
}
#line 305 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/variable.c"
static VARIABLE *var_enter(char const   *symbol ) 
{ 
  VARIABLE var ;
  VARIABLE *v ;
  int tmp ;

  {
#line 308
  v = & var;
#line 310
  if (! varhash) {
    {
#line 311
    varhash = hashinit((int )sizeof(VARIABLE ), "variables");
    }
  }
  {
#line 313
  v->symbol = symbol;
#line 314
  v->value = (LIST *)0;
#line 316
  tmp = hashitem(varhash, (HASHDATA **)(& v), 1);
  }
#line 316
  if (! tmp) {
    {
#line 317
    v->symbol = newstr(symbol);
    }
  }
#line 319
  return (v);
}
}
#line 326 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/variable.c"
static void var_dump(char const   *symbol , LIST *value , char const   *what ) 
{ 


  {
  {
#line 332
  printf((char const   */* __restrict  */)"%s %s = ", what, symbol);
#line 333
  list_print(value);
#line 334
  printf((char const   */* __restrict  */)"\n");
  }
#line 335
  return;
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/variable.c"
void var_done(void) 
{ 


  {
  {
#line 344
  hashdone(varhash);
  }
#line 345
  return;
}
}
#line 343 "y.tab.c"
static unsigned char const   yytranslate___0[305]  = 
#line 343 "y.tab.c"
  {      (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )3,      (unsigned char const   )4, 
        (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )7,      (unsigned char const   )8, 
        (unsigned char const   )9,      (unsigned char const   )10,      (unsigned char const   )11,      (unsigned char const   )12, 
        (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )15,      (unsigned char const   )16, 
        (unsigned char const   )17,      (unsigned char const   )18,      (unsigned char const   )19,      (unsigned char const   )20, 
        (unsigned char const   )21,      (unsigned char const   )22,      (unsigned char const   )23,      (unsigned char const   )24, 
        (unsigned char const   )25,      (unsigned char const   )26,      (unsigned char const   )27,      (unsigned char const   )28, 
        (unsigned char const   )29,      (unsigned char const   )30,      (unsigned char const   )31,      (unsigned char const   )32, 
        (unsigned char const   )33,      (unsigned char const   )34,      (unsigned char const   )35,      (unsigned char const   )36, 
        (unsigned char const   )37,      (unsigned char const   )38,      (unsigned char const   )39,      (unsigned char const   )40, 
        (unsigned char const   )41,      (unsigned char const   )42,      (unsigned char const   )43,      (unsigned char const   )44, 
        (unsigned char const   )45,      (unsigned char const   )46,      (unsigned char const   )47,      (unsigned char const   )48, 
        (unsigned char const   )49};
#line 473 "y.tab.c"
static unsigned char const   yyr1___0[74]  = 
#line 473
  {      (unsigned char const   )0,      (unsigned char const   )50,      (unsigned char const   )51,      (unsigned char const   )51, 
        (unsigned char const   )52,      (unsigned char const   )52,      (unsigned char const   )53,      (unsigned char const   )53, 
        (unsigned char const   )53,      (unsigned char const   )53,      (unsigned char const   )54,      (unsigned char const   )54, 
        (unsigned char const   )54,      (unsigned char const   )54,      (unsigned char const   )54,      (unsigned char const   )54, 
        (unsigned char const   )54,      (unsigned char const   )54,      (unsigned char const   )54,      (unsigned char const   )54, 
        (unsigned char const   )54,      (unsigned char const   )54,      (unsigned char const   )54,      (unsigned char const   )54, 
        (unsigned char const   )54,      (unsigned char const   )55,      (unsigned char const   )56,      (unsigned char const   )54, 
        (unsigned char const   )57,      (unsigned char const   )57,      (unsigned char const   )57,      (unsigned char const   )57, 
        (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )58, 
        (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )58, 
        (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )58, 
        (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )59,      (unsigned char const   )59, 
        (unsigned char const   )60,      (unsigned char const   )61,      (unsigned char const   )61,      (unsigned char const   )61, 
        (unsigned char const   )62,      (unsigned char const   )62,      (unsigned char const   )63,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )65,      (unsigned char const   )66,      (unsigned char const   )65, 
        (unsigned char const   )67,      (unsigned char const   )67,      (unsigned char const   )67,      (unsigned char const   )68, 
        (unsigned char const   )68,      (unsigned char const   )69,      (unsigned char const   )69,      (unsigned char const   )69, 
        (unsigned char const   )69,      (unsigned char const   )69,      (unsigned char const   )69,      (unsigned char const   )69, 
        (unsigned char const   )70,      (unsigned char const   )70};
#line 486 "y.tab.c"
static unsigned char const   yyr2___0[74]  = 
#line 486
  {      (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )2, 
        (unsigned char const   )4,      (unsigned char const   )6,      (unsigned char const   )3,      (unsigned char const   )3, 
        (unsigned char const   )3,      (unsigned char const   )4,      (unsigned char const   )6,      (unsigned char const   )3, 
        (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )7,      (unsigned char const   )5, 
        (unsigned char const   )5,      (unsigned char const   )7,      (unsigned char const   )5,      (unsigned char const   )6, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )9, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )2, 
        (unsigned char const   )1,      (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3, 
        (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3, 
        (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3, 
        (unsigned char const   )2,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )2, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )3,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )3,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )4, 
        (unsigned char const   )2,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )2, 
        (unsigned char const   )0,      (unsigned char const   )2};
#line 501 "y.tab.c"
static unsigned char const   yydefact___0[154]  = 
#line 501
  {      (unsigned char const   )2,      (unsigned char const   )58,      (unsigned char const   )4,      (unsigned char const   )63, 
        (unsigned char const   )55,      (unsigned char const   )55,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )55,      (unsigned char const   )55,      (unsigned char const   )0,      (unsigned char const   )55, 
        (unsigned char const   )0,      (unsigned char const   )55,      (unsigned char const   )0,      (unsigned char const   )57, 
        (unsigned char const   )0,      (unsigned char const   )3,      (unsigned char const   )6,      (unsigned char const   )55, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )5,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )54,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )32, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )49,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1, 
        (unsigned char const   )7,      (unsigned char const   )28,      (unsigned char const   )30,      (unsigned char const   )29, 
        (unsigned char const   )0,      (unsigned char const   )55,      (unsigned char const   )55,      (unsigned char const   )0, 
        (unsigned char const   )52,      (unsigned char const   )0,      (unsigned char const   )55,      (unsigned char const   )0, 
        (unsigned char const   )10,      (unsigned char const   )70,      (unsigned char const   )67,      (unsigned char const   )0, 
        (unsigned char const   )69,      (unsigned char const   )68,      (unsigned char const   )66,      (unsigned char const   )65, 
        (unsigned char const   )72,      (unsigned char const   )64,      (unsigned char const   )15,      (unsigned char const   )56, 
        (unsigned char const   )16,      (unsigned char const   )55,      (unsigned char const   )44,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )55, 
        (unsigned char const   )11,      (unsigned char const   )55,      (unsigned char const   )4,      (unsigned char const   )24, 
        (unsigned char const   )17,      (unsigned char const   )51,      (unsigned char const   )0,      (unsigned char const   )46, 
        (unsigned char const   )4,      (unsigned char const   )31,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )55,      (unsigned char const   )0,      (unsigned char const   )60, 
        (unsigned char const   )59,      (unsigned char const   )71,      (unsigned char const   )55,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )45,      (unsigned char const   )35,      (unsigned char const   )36, 
        (unsigned char const   )33,      (unsigned char const   )37,      (unsigned char const   )38,      (unsigned char const   )41, 
        (unsigned char const   )42,      (unsigned char const   )34,      (unsigned char const   )0,      (unsigned char const   )39, 
        (unsigned char const   )40,      (unsigned char const   )43,      (unsigned char const   )0,      (unsigned char const   )8, 
        (unsigned char const   )49,      (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )46,      (unsigned char const   )0,      (unsigned char const   )55,      (unsigned char const   )13, 
        (unsigned char const   )53,      (unsigned char const   )55,      (unsigned char const   )55,      (unsigned char const   )73, 
        (unsigned char const   )25,      (unsigned char const   )4,      (unsigned char const   )20,      (unsigned char const   )4, 
        (unsigned char const   )50,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )19, 
        (unsigned char const   )47,      (unsigned char const   )22,      (unsigned char const   )0,      (unsigned char const   )62, 
        (unsigned char const   )61,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )9,      (unsigned char const   )23,      (unsigned char const   )4,      (unsigned char const   )14, 
        (unsigned char const   )26,      (unsigned char const   )18,      (unsigned char const   )21,      (unsigned char const   )48, 
        (unsigned char const   )0,      (unsigned char const   )27};
#line 522 "y.tab.c"
static short const   yydefgoto___0[21]  = 
#line 522
  {      (short const   )-1,      (short const   )16,      (short const   )21,      (short const   )22, 
        (short const   )18,      (short const   )141,      (short const   )152,      (short const   )46, 
        (short const   )30,      (short const   )119,      (short const   )120,      (short const   )86, 
        (short const   )47,      (short const   )48,      (short const   )25,      (short const   )31, 
        (short const   )20,      (short const   )51,      (short const   )23,      (short const   )61, 
        (short const   )99};
#line 532 "y.tab.c"
static short const   yypact___0[154]  = 
#line 532
  {      (short const   )130,      (short const   )-48,      (short const   )130,      (short const   )-48, 
        (short const   )-48,      (short const   )-48,      (short const   )-43,      (short const   )-8, 
        (short const   )-48,      (short const   )-48,      (short const   )7,      (short const   )-48, 
        (short const   )-17,      (short const   )-48,      (short const   )-8,      (short const   )-48, 
        (short const   )15,      (short const   )-48,      (short const   )130,      (short const   )9, 
        (short const   )-11,      (short const   )23,      (short const   )-48,      (short const   )151, 
        (short const   )31,      (short const   )7,      (short const   )35,      (short const   )12, 
        (short const   )-8,      (short const   )-8,      (short const   )53,      (short const   )16, 
        (short const   )42,      (short const   )17,      (short const   )162,      (short const   )59, 
        (short const   )22,      (short const   )44,      (short const   )208,      (short const   )-48, 
        (short const   )-48,      (short const   )-48,      (short const   )-48,      (short const   )-48, 
        (short const   )72,      (short const   )-48,      (short const   )-48,      (short const   )68, 
        (short const   )69,      (short const   )7,      (short const   )-48,      (short const   )66, 
        (short const   )-48,      (short const   )-48,      (short const   )-48,      (short const   )38, 
        (short const   )-48,      (short const   )-48,      (short const   )-48,      (short const   )-48, 
        (short const   )65,      (short const   )-48,      (short const   )-48,      (short const   )-48, 
        (short const   )-48,      (short const   )-48,      (short const   )-48,      (short const   )228, 
        (short const   )-8,      (short const   )-8,      (short const   )-8,      (short const   )-8, 
        (short const   )-8,      (short const   )-8,      (short const   )-8,      (short const   )-8, 
        (short const   )130,      (short const   )-8,      (short const   )-8,      (short const   )-48, 
        (short const   )-48,      (short const   )-48,      (short const   )130,      (short const   )-48, 
        (short const   )-48,      (short const   )80,      (short const   )73,      (short const   )70, 
        (short const   )130,      (short const   )-48,      (short const   )21,      (short const   )83, 
        (short const   )-48,      (short const   )-48,      (short const   )-9,      (short const   )-48, 
        (short const   )-48,      (short const   )-48,      (short const   )-48,      (short const   )79, 
        (short const   )88,      (short const   )-48,      (short const   )-48,      (short const   )-48, 
        (short const   )61,      (short const   )-48,      (short const   )-48,      (short const   )98, 
        (short const   )98,      (short const   )61,      (short const   )89,      (short const   )109, 
        (short const   )109,      (short const   )-48,      (short const   )108,      (short const   )-48, 
        (short const   )22,      (short const   )130,      (short const   )51,      (short const   )101, 
        (short const   )70,      (short const   )103,      (short const   )-48,      (short const   )-48, 
        (short const   )-48,      (short const   )-48,      (short const   )-48,      (short const   )-48, 
        (short const   )-48,      (short const   )130,      (short const   )78,      (short const   )130, 
        (short const   )-48,      (short const   )104,      (short const   )114,      (short const   )-48, 
        (short const   )-48,      (short const   )-48,      (short const   )116,      (short const   )-48, 
        (short const   )-48,      (short const   )85,      (short const   )107,      (short const   )162, 
        (short const   )-48,      (short const   )-48,      (short const   )130,      (short const   )-48, 
        (short const   )-48,      (short const   )-48,      (short const   )-48,      (short const   )-48, 
        (short const   )112,      (short const   )-48};
#line 553 "y.tab.c"
static yysigned_char const   yypgoto___0[21]  = 
#line 553
  {      (yysigned_char const   )-48,      (yysigned_char const   )-48,      (yysigned_char const   )-46,      (yysigned_char const   )11, 
        (yysigned_char const   )-33,      (yysigned_char const   )-48,      (yysigned_char const   )-48,      (yysigned_char const   )58, 
        (yysigned_char const   )67,      (yysigned_char const   )30,      (yysigned_char const   )-48,      (yysigned_char const   )36, 
        (yysigned_char const   )-47,      (yysigned_char const   )8,      (yysigned_char const   )-48,      (yysigned_char const   )0, 
        (yysigned_char const   )-48,      (yysigned_char const   )-48,      (yysigned_char const   )-48,      (yysigned_char const   )-48, 
        (yysigned_char const   )-48};
#line 565 "y.tab.c"
static unsigned char const   yytable___0[251]  = 
#line 565
  {      (unsigned char const   )19,      (unsigned char const   )83,      (unsigned char const   )19,      (unsigned char const   )95, 
        (unsigned char const   )28,      (unsigned char const   )27,      (unsigned char const   )1,      (unsigned char const   )29, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )34,      (unsigned char const   )17, 
        (unsigned char const   )24,      (unsigned char const   )26,      (unsigned char const   )41,      (unsigned char const   )39, 
        (unsigned char const   )32,      (unsigned char const   )33,      (unsigned char const   )19,      (unsigned char const   )35, 
        (unsigned char const   )50,      (unsigned char const   )37,      (unsigned char const   )81,      (unsigned char const   )42, 
        (unsigned char const   )1,      (unsigned char const   )63,      (unsigned char const   )41,      (unsigned char const   )82, 
        (unsigned char const   )49,      (unsigned char const   )40,      (unsigned char const   )110,      (unsigned char const   )36, 
        (unsigned char const   )43,      (unsigned char const   )125,      (unsigned char const   )19,      (unsigned char const   )42, 
        (unsigned char const   )115,      (unsigned char const   )15,      (unsigned char const   )44,      (unsigned char const   )15, 
        (unsigned char const   )15,      (unsigned char const   )62,      (unsigned char const   )121,      (unsigned char const   )52, 
        (unsigned char const   )43,      (unsigned char const   )64,      (unsigned char const   )124,      (unsigned char const   )65, 
        (unsigned char const   )45,      (unsigned char const   )94,      (unsigned char const   )44,      (unsigned char const   )79, 
        (unsigned char const   )80,      (unsigned char const   )90,      (unsigned char const   )91,      (unsigned char const   )15, 
        (unsigned char const   )68,      (unsigned char const   )69,      (unsigned char const   )70,      (unsigned char const   )71, 
        (unsigned char const   )72,      (unsigned char const   )73,      (unsigned char const   )74,      (unsigned char const   )87, 
        (unsigned char const   )68,      (unsigned char const   )69,      (unsigned char const   )75,      (unsigned char const   )71, 
        (unsigned char const   )72,      (unsigned char const   )84,      (unsigned char const   )85,      (unsigned char const   )133, 
        (unsigned char const   )76,      (unsigned char const   )100,      (unsigned char const   )77,      (unsigned char const   )78, 
        (unsigned char const   )19,      (unsigned char const   )89,      (unsigned char const   )92,      (unsigned char const   )140, 
        (unsigned char const   )93,      (unsigned char const   )38,      (unsigned char const   )19,      (unsigned char const   )142, 
        (unsigned char const   )96,      (unsigned char const   )144,      (unsigned char const   )97,      (unsigned char const   )113, 
        (unsigned char const   )19,      (unsigned char const   )114,      (unsigned char const   )98,      (unsigned char const   )116, 
        (unsigned char const   )117,      (unsigned char const   )123,      (unsigned char const   )126,      (unsigned char const   )66, 
        (unsigned char const   )67,      (unsigned char const   )118,      (unsigned char const   )128,      (unsigned char const   )134, 
        (unsigned char const   )151,      (unsigned char const   )68,      (unsigned char const   )69,      (unsigned char const   )70, 
        (unsigned char const   )71,      (unsigned char const   )72,      (unsigned char const   )127,      (unsigned char const   )129, 
        (unsigned char const   )143,      (unsigned char const   )130,      (unsigned char const   )150,      (unsigned char const   )75, 
        (unsigned char const   )68,      (unsigned char const   )69,      (unsigned char const   )70,      (unsigned char const   )71, 
        (unsigned char const   )72,      (unsigned char const   )19,      (unsigned char const   )131,      (unsigned char const   )77, 
        (unsigned char const   )78,      (unsigned char const   )135,      (unsigned char const   )75,      (unsigned char const   )137, 
        (unsigned char const   )145,      (unsigned char const   )146,      (unsigned char const   )147,      (unsigned char const   )149, 
        (unsigned char const   )0,      (unsigned char const   )19,      (unsigned char const   )138,      (unsigned char const   )19, 
        (unsigned char const   )153,      (unsigned char const   )139,      (unsigned char const   )148,      (unsigned char const   )102, 
        (unsigned char const   )103,      (unsigned char const   )104,      (unsigned char const   )105,      (unsigned char const   )106, 
        (unsigned char const   )107,      (unsigned char const   )108,      (unsigned char const   )109,      (unsigned char const   )19, 
        (unsigned char const   )111,      (unsigned char const   )112,      (unsigned char const   )19,      (unsigned char const   )1, 
        (unsigned char const   )122,      (unsigned char const   )2,      (unsigned char const   )136,      (unsigned char const   )0, 
        (unsigned char const   )132,      (unsigned char const   )0,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )5,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )6,      (unsigned char const   )7, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )8,      (unsigned char const   )9, 
        (unsigned char const   )0,      (unsigned char const   )10,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )11,      (unsigned char const   )12,      (unsigned char const   )13,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )14,      (unsigned char const   )15,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )53,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )54,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )4,      (unsigned char const   )55,      (unsigned char const   )5,      (unsigned char const   )56, 
        (unsigned char const   )57,      (unsigned char const   )0,      (unsigned char const   )6,      (unsigned char const   )7, 
        (unsigned char const   )58,      (unsigned char const   )59,      (unsigned char const   )8,      (unsigned char const   )60, 
        (unsigned char const   )0,      (unsigned char const   )10,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )11,      (unsigned char const   )12,      (unsigned char const   )13,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )14,      (unsigned char const   )15,      (unsigned char const   )68, 
        (unsigned char const   )69,      (unsigned char const   )70,      (unsigned char const   )71,      (unsigned char const   )72, 
        (unsigned char const   )73,      (unsigned char const   )74,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )75,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )88, 
        (unsigned char const   )0,      (unsigned char const   )77,      (unsigned char const   )78,      (unsigned char const   )68, 
        (unsigned char const   )69,      (unsigned char const   )70,      (unsigned char const   )71,      (unsigned char const   )72, 
        (unsigned char const   )73,      (unsigned char const   )74,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )75,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )101,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )77,      (unsigned char const   )78};
#line 595 "y.tab.c"
static short const   yycheck___0[251]  = 
#line 595
  {      (short const   )0,      (short const   )34,      (short const   )2,      (short const   )50, 
        (short const   )12,      (short const   )48,      (short const   )17,      (short const   )15, 
        (short const   )17,      (short const   )17,      (short const   )10,      (short const   )0, 
        (short const   )4,      (short const   )5,      (short const   )5,      (short const   )0, 
        (short const   )8,      (short const   )9,      (short const   )18,      (short const   )11, 
        (short const   )20,      (short const   )13,      (short const   )5,      (short const   )14, 
        (short const   )17,      (short const   )25,      (short const   )5,      (short const   )10, 
        (short const   )39,      (short const   )18,      (short const   )76,      (short const   )48, 
        (short const   )23,      (short const   )42,      (short const   )34,      (short const   )14, 
        (short const   )82,      (short const   )48,      (short const   )29,      (short const   )48, 
        (short const   )48,      (short const   )10,      (short const   )88,      (short const   )20, 
        (short const   )23,      (short const   )10,      (short const   )93,      (short const   )35, 
        (short const   )39,      (short const   )49,      (short const   )29,      (short const   )35, 
        (short const   )10,      (short const   )45,      (short const   )46,      (short const   )48, 
        (short const   )3,      (short const   )4,      (short const   )5,      (short const   )6, 
        (short const   )7,      (short const   )8,      (short const   )9,      (short const   )19, 
        (short const   )3,      (short const   )4,      (short const   )13,      (short const   )6, 
        (short const   )7,      (short const   )10,      (short const   )48,      (short const   )117, 
        (short const   )19,      (short const   )65,      (short const   )21,      (short const   )22, 
        (short const   )76,      (short const   )5,      (short const   )10,      (short const   )126, 
        (short const   )11,      (short const   )14,      (short const   )82,      (short const   )129, 
        (short const   )18,      (short const   )131,      (short const   )48,      (short const   )79, 
        (short const   )88,      (short const   )81,      (short const   )25,      (short const   )11, 
        (short const   )19,      (short const   )10,      (short const   )94,      (short const   )28, 
        (short const   )29,      (short const   )27,      (short const   )19,      (short const   )48, 
        (short const   )146,      (short const   )3,      (short const   )4,      (short const   )5, 
        (short const   )6,      (short const   )7,      (short const   )98,      (short const   )19, 
        (short const   )30,      (short const   )20,      (short const   )143,      (short const   )13, 
        (short const   )3,      (short const   )4,      (short const   )5,      (short const   )6, 
        (short const   )7,      (short const   )117,      (short const   )10,      (short const   )21, 
        (short const   )22,      (short const   )20,      (short const   )13,      (short const   )20, 
        (short const   )20,      (short const   )11,      (short const   )10,      (short const   )20, 
        (short const   )-1,      (short const   )129,      (short const   )122,      (short const   )131, 
        (short const   )20,      (short const   )125,      (short const   )49,      (short const   )68, 
        (short const   )69,      (short const   )70,      (short const   )71,      (short const   )72, 
        (short const   )73,      (short const   )74,      (short const   )75,      (short const   )143, 
        (short const   )77,      (short const   )78,      (short const   )146,      (short const   )17, 
        (short const   )90,      (short const   )19,      (short const   )120,      (short const   )-1, 
        (short const   )116,      (short const   )-1,      (short const   )24,      (short const   )-1, 
        (short const   )26,      (short const   )-1,      (short const   )28,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )32,      (short const   )33, 
        (short const   )-1,      (short const   )-1,      (short const   )36,      (short const   )37, 
        (short const   )-1,      (short const   )39,      (short const   )-1,      (short const   )-1, 
        (short const   )42,      (short const   )43,      (short const   )44,      (short const   )-1, 
        (short const   )-1,      (short const   )47,      (short const   )48,      (short const   )17, 
        (short const   )-1,      (short const   )19,      (short const   )31,      (short const   )-1, 
        (short const   )-1,      (short const   )34,      (short const   )24,      (short const   )-1, 
        (short const   )26,      (short const   )38,      (short const   )28,      (short const   )40, 
        (short const   )41,      (short const   )-1,      (short const   )32,      (short const   )33, 
        (short const   )45,      (short const   )46,      (short const   )36,      (short const   )48, 
        (short const   )-1,      (short const   )39,      (short const   )-1,      (short const   )-1, 
        (short const   )42,      (short const   )43,      (short const   )44,      (short const   )-1, 
        (short const   )-1,      (short const   )47,      (short const   )48,      (short const   )3, 
        (short const   )4,      (short const   )5,      (short const   )6,      (short const   )7, 
        (short const   )8,      (short const   )9,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )13,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )19, 
        (short const   )-1,      (short const   )21,      (short const   )22,      (short const   )3, 
        (short const   )4,      (short const   )5,      (short const   )6,      (short const   )7, 
        (short const   )8,      (short const   )9,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )13,      (short const   )-1,      (short const   )-1, 
        (short const   )16,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )21,      (short const   )22};
#line 627 "y.tab.c"
static unsigned char const   yystos___0[154]  = 
#line 627
  {      (unsigned char const   )0,      (unsigned char const   )17,      (unsigned char const   )19,      (unsigned char const   )24, 
        (unsigned char const   )26,      (unsigned char const   )28,      (unsigned char const   )32,      (unsigned char const   )33, 
        (unsigned char const   )36,      (unsigned char const   )37,      (unsigned char const   )39,      (unsigned char const   )42, 
        (unsigned char const   )43,      (unsigned char const   )44,      (unsigned char const   )47,      (unsigned char const   )48, 
        (unsigned char const   )51,      (unsigned char const   )53,      (unsigned char const   )54,      (unsigned char const   )65, 
        (unsigned char const   )66,      (unsigned char const   )52,      (unsigned char const   )53,      (unsigned char const   )68, 
        (unsigned char const   )63,      (unsigned char const   )64,      (unsigned char const   )63,      (unsigned char const   )48, 
        (unsigned char const   )12,      (unsigned char const   )15,      (unsigned char const   )58,      (unsigned char const   )65, 
        (unsigned char const   )63,      (unsigned char const   )63,      (unsigned char const   )65,      (unsigned char const   )63, 
        (unsigned char const   )48,      (unsigned char const   )63,      (unsigned char const   )58,      (unsigned char const   )0, 
        (unsigned char const   )53,      (unsigned char const   )5,      (unsigned char const   )14,      (unsigned char const   )23, 
        (unsigned char const   )29,      (unsigned char const   )39,      (unsigned char const   )57,      (unsigned char const   )62, 
        (unsigned char const   )63,      (unsigned char const   )39,      (unsigned char const   )65,      (unsigned char const   )67, 
        (unsigned char const   )20,      (unsigned char const   )31,      (unsigned char const   )34,      (unsigned char const   )38, 
        (unsigned char const   )40,      (unsigned char const   )41,      (unsigned char const   )45,      (unsigned char const   )46, 
        (unsigned char const   )48,      (unsigned char const   )69,      (unsigned char const   )10,      (unsigned char const   )65, 
        (unsigned char const   )10,      (unsigned char const   )35,      (unsigned char const   )58,      (unsigned char const   )58, 
        (unsigned char const   )3,      (unsigned char const   )4,      (unsigned char const   )5,      (unsigned char const   )6, 
        (unsigned char const   )7,      (unsigned char const   )8,      (unsigned char const   )9,      (unsigned char const   )13, 
        (unsigned char const   )19,      (unsigned char const   )21,      (unsigned char const   )22,      (unsigned char const   )35, 
        (unsigned char const   )10,      (unsigned char const   )5,      (unsigned char const   )10,      (unsigned char const   )54, 
        (unsigned char const   )10,      (unsigned char const   )48,      (unsigned char const   )61,      (unsigned char const   )19, 
        (unsigned char const   )19,      (unsigned char const   )5,      (unsigned char const   )63,      (unsigned char const   )63, 
        (unsigned char const   )10,      (unsigned char const   )11,      (unsigned char const   )65,      (unsigned char const   )62, 
        (unsigned char const   )18,      (unsigned char const   )48,      (unsigned char const   )25,      (unsigned char const   )70, 
        (unsigned char const   )63,      (unsigned char const   )16,      (unsigned char const   )58,      (unsigned char const   )58, 
        (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )58, 
        (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )52,      (unsigned char const   )58, 
        (unsigned char const   )58,      (unsigned char const   )63,      (unsigned char const   )63,      (unsigned char const   )52, 
        (unsigned char const   )11,      (unsigned char const   )19,      (unsigned char const   )27,      (unsigned char const   )59, 
        (unsigned char const   )60,      (unsigned char const   )52,      (unsigned char const   )57,      (unsigned char const   )10, 
        (unsigned char const   )62,      (unsigned char const   )42,      (unsigned char const   )65,      (unsigned char const   )63, 
        (unsigned char const   )19,      (unsigned char const   )19,      (unsigned char const   )20,      (unsigned char const   )10, 
        (unsigned char const   )61,      (unsigned char const   )52,      (unsigned char const   )48,      (unsigned char const   )20, 
        (unsigned char const   )59,      (unsigned char const   )20,      (unsigned char const   )63,      (unsigned char const   )63, 
        (unsigned char const   )62,      (unsigned char const   )55,      (unsigned char const   )52,      (unsigned char const   )30, 
        (unsigned char const   )52,      (unsigned char const   )20,      (unsigned char const   )11,      (unsigned char const   )10, 
        (unsigned char const   )49,      (unsigned char const   )20,      (unsigned char const   )54,      (unsigned char const   )52, 
        (unsigned char const   )56,      (unsigned char const   )20};
#line 940 "y.tab.c"
static void yydestruct___0(int yytype , YYSYMBOL *yyvaluep ) 
{ 


  {
  {
#line 955
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 956
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 958
  return;
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/builtins.c"
static void builtin_glob_back___0(void *closure , char const   *file , int status ,
                                  time_t time___0 ) 
{ 
  struct globbing *globbing ;
  LIST *l ;
  PATHNAME f ;
  char buf___0[1024] ;
  int tmp ;

  {
  {
#line 229
  globbing = (struct globbing *)closure;
#line 237
  path_parse(file, & f);
#line 238
  f.part[2].len = 0;
#line 239
  path_build(& f, buf___0, 0);
#line 241
  l = globbing->patterns;
  }
  {
#line 241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 241
    if (! l) {
#line 241
      goto while_break;
    }
    {
#line 242
    tmp = glob(l->string, (char const   *)(buf___0));
    }
#line 242
    if (! tmp) {
      {
#line 244
      globbing->results = list_new(globbing->results, file, 0);
      }
#line 245
      goto while_break;
    }
#line 241
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 247
  return;
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/newstr.c"
static struct hash *strhash___0  =    (struct hash *)0;
#line 36 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/newstr.c"
static int strtotal___0  =    0;
#line 31 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/lists.c"
static LIST *freelist___0  =    (LIST *)0;
#line 65 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/execunix.c"
static int intr___1  =    0;
#line 66 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/execunix.c"
static int cmdsrunning___0  =    0;
#line 67 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/execunix.c"
static void (*istat___0)(int  )  ;
#line 69 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/execunix.c"
static struct __anonstruct_cmdtab_50___0 cmdtab___0[64]  = {      {0, (void (*)(void *closure , int status ))0, (void *)0}};
#line 84 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/hash.c"
static void hashrehash___0(struct hash *hp ) ;
#line 85
static void hashstat___0(struct hash *hp ) ;
#line 142 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/hash.c"
static void hashrehash___0(struct hash *hp ) 
{ 
  int i ;
  void *tmp ;
  void *tmp___0 ;
  int nel ;
  char *next ;
  register ITEM *i___0 ;
  ITEM **ip ;
  int tmp___1 ;

  {
#line 144
  (hp->items.list) ++;
#line 144
  i = hp->items.list;
#line 146
  if (i) {
#line 146
    hp->items.more = 2 * hp->items.nel;
  } else {
#line 146
    hp->items.more = hp->inel;
  }
  {
#line 147
  tmp = malloc((size_t )(hp->items.more * hp->items.size));
#line 147
  hp->items.next = (char *)tmp;
#line 149
  hp->items.lists[i].nel = hp->items.more;
#line 150
  hp->items.lists[i].base = hp->items.next;
#line 151
  hp->items.nel += hp->items.more;
  }
#line 153
  if (hp->tab.base) {
    {
#line 154
    free((void *)((char *)hp->tab.base));
    }
  }
  {
#line 156
  hp->tab.nel = hp->items.nel * hp->bloat;
#line 157
  tmp___0 = malloc((unsigned long )hp->tab.nel * sizeof(ITEM **));
#line 157
  hp->tab.base = (ITEM **)tmp___0;
#line 159
  memset((void *)((char *)hp->tab.base), '\000', (unsigned long )hp->tab.nel * sizeof(ITEM *));
#line 161
  i = 0;
  }
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (! (i < hp->items.list)) {
#line 161
      goto while_break;
    }
#line 163
    nel = hp->items.lists[i].nel;
#line 164
    next = hp->items.lists[i].base;
    {
#line 166
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 166
      tmp___1 = nel;
#line 166
      nel --;
#line 166
      if (! tmp___1) {
#line 166
        goto while_break___0;
      }
#line 168
      i___0 = (ITEM *)next;
#line 169
      ip = hp->tab.base + i___0->hdr.keyval % (unsigned int )hp->tab.nel;
#line 171
      i___0->hdr.next = *ip;
#line 172
      *ip = i___0;
#line 166
      next += hp->items.size;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 161
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  return;
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/hash.c"
static void hashstat___0(struct hash *hp ) 
{ 
  ITEM **tab ;
  int nel ;
  int count ;
  int sets ;
  int run ;
  int i ;
  int here ;
  ITEM **tmp ;

  {
#line 233
  tab = hp->tab.base;
#line 234
  nel = hp->tab.nel;
#line 235
  count = 0;
#line 236
  sets = 0;
#line 237
  run = (unsigned long )*(tab + (nel - 1)) != (unsigned long )((ITEM *)0);
#line 240
  i = nel;
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 240
    if (! (i > 0)) {
#line 240
      goto while_break;
    }
#line 242
    tmp = tab;
#line 242
    tab ++;
#line 242
    here = (unsigned long )*tmp != (unsigned long )((ITEM *)0);
#line 242
    if (here) {
#line 243
      count ++;
    }
#line 244
    if (here) {
#line 244
      if (! run) {
#line 245
        sets ++;
      }
    }
#line 246
    run = here;
#line 240
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 249
  printf((char const   */* __restrict  */)"%s table: %d+%d+%d (%dK+%dK) items+table+hash, %f density\n",
         hp->name, count, hp->items.nel, hp->tab.nel, (hp->items.nel * hp->items.size) / 1024,
         ((unsigned long )hp->tab.nel * sizeof(ITEM **)) / 1024UL, (double )((float )count / (float )sets));
  }
#line 257
  return;
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/headers.c"
static LIST *headers1___0(char const   *file , LIST *hdrscan ) ;
#line 85 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/headers.c"
static LIST *headers1___0(char const   *file , LIST *hdrscan ) 
{ 
  FILE *f ;
  int i ;
  int rec ;
  LIST *result ;
  regexp *re[10] ;
  char buf___0[1024] ;
  int tmp ;
  char buf2[1024] ;
  int l ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 92
  rec = 0;
#line 93
  result = (LIST *)0;
#line 97
  f = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
  }
#line 97
  if (! f) {
#line 98
    return (result);
  }
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (rec < 10) {
#line 100
      if (! hdrscan) {
#line 100
        goto while_break;
      }
    } else {
#line 100
      goto while_break;
    }
    {
#line 102
    tmp = rec;
#line 102
    rec ++;
#line 102
    re[tmp] = regcomp(hdrscan->string);
#line 103
    hdrscan = hdrscan->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 106
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 106
    tmp___1 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)f);
    }
#line 106
    if (! tmp___1) {
#line 106
      goto while_break___0;
    }
#line 108
    i = 0;
    {
#line 108
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 108
      if (! (i < rec)) {
#line 108
        goto while_break___1;
      }
      {
#line 109
      tmp___0 = regexec(re[i], (char const   *)(buf___0));
      }
#line 109
      if (tmp___0) {
#line 109
        if ((re[i])->startp[1]) {
          {
#line 114
          l = (int )((re[i])->endp[1] - (re[i])->startp[1]);
#line 115
          memcpy((void */* __restrict  */)(buf2), (void const   */* __restrict  */)(re[i])->startp[1],
                 (size_t )l);
#line 116
          buf2[l] = (char)0;
#line 117
          result = list_new(result, (char const   *)(buf2), 0);
          }
#line 119
          if (globs.debug[6]) {
            {
#line 120
            printf((char const   */* __restrict  */)"header found: %s\n", buf2);
            }
          }
        }
      }
#line 108
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 124
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 124
    if (! rec) {
#line 124
      goto while_break___2;
    }
    {
#line 125
    rec --;
#line 125
    free((void *)((char *)re[rec]));
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 127
  fclose(f);
  }
#line 129
  return (result);
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make.c"
static void make0___0(TARGET *t , TARGET *p , int depth , COUNTS *counts___1 , int anyhow ) ;
#line 82
static TARGETS *make0sort___0(TARGETS *chain ) ;
#line 84 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make.c"
static char const   *target_fate___0[12]  = 
#line 84
  {      "init",      "making",      "stable",      "newer", 
        "temp",      "touched",      "missing",      "needtmp", 
        "old",      "update",      "nofind",      "nomake"};
#line 100 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make.c"
static char const   *target_bind___0[4]  = {      "unbound",      "missing",      "parents",      "exists"};
#line 162 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make.c"
static void make0___0(TARGET *t , TARGET *p , int depth , COUNTS *counts___1 , int anyhow ) 
{ 
  TARGETS *c ;
  TARGETS *incs ;
  TARGET *ptime ;
  time_t last ;
  time_t leaf ;
  time_t hlast ;
  int fate ;
  char const   *flag ;
  SETTINGS *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int internal ;
  char const   *tmp___5 ;
  int tmp___6 ;

  {
#line 171
  ptime = t;
#line 174
  flag = "";
#line 181
  if (globs.debug[3]) {
#line 182
    if (depth > 16) {
#line 182
      tmp = 16;
    } else {
#line 182
      tmp = depth;
    }
    {
#line 182
    printf((char const   */* __restrict  */)"make\t--\t%s%s\n", ("                " + 16) - tmp,
           t->name);
    }
  }
  {
#line 184
  t->fate = (char)1;
#line 193
  s = copysettings(t->settings);
#line 194
  pushsettings(s);
  }
#line 198
  if ((int )t->binding == 0) {
#line 198
    if (! ((int )t->flags & 4)) {
      {
#line 200
      t->boundname = search(t->name, & t->time);
      }
#line 201
      if (t->time) {
#line 201
        t->binding = (char)3;
      } else {
#line 201
        t->binding = (char)1;
      }
    }
  }
#line 206
  if (p) {
#line 206
    if ((int )t->flags & 64) {
#line 207
      ptime = p;
    }
  }
#line 211
  if (p) {
#line 211
    if ((int )t->flags & 1) {
#line 211
      if ((int )t->binding == 1) {
#line 211
        if ((int )p->binding != 1) {
#line 215
          t->binding = (char)2;
#line 216
          ptime = p;
        }
      }
    }
  }
#line 221
  if ((int )t->binding == 3) {
    {
#line 222
    headers(t);
    }
  }
  {
#line 226
  popsettings(s);
#line 227
  freesettings(s);
  }
#line 233
  if (globs.debug[3]) {
    {
#line 235
    tmp___1 = strcmp(t->name, t->boundname);
    }
#line 235
    if (tmp___1) {
#line 237
      if (depth > 16) {
#line 237
        tmp___0 = 16;
      } else {
#line 237
        tmp___0 = depth;
      }
      {
#line 237
      printf((char const   */* __restrict  */)"bind\t--\t%s%s: %s\n", ("                " + 16) - tmp___0,
             t->name, t->boundname);
      }
    }
    {
#line 245
    if ((int )t->binding == 2) {
#line 245
      goto case_2;
    }
#line 245
    if ((int )t->binding == 1) {
#line 245
      goto case_2;
    }
#line 245
    if ((int )t->binding == 0) {
#line 245
      goto case_2;
    }
#line 250
    if ((int )t->binding == 3) {
#line 250
      goto case_3;
    }
#line 241
    goto switch_break;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 246
    if (depth > 16) {
#line 246
      tmp___2 = 16;
    } else {
#line 246
      tmp___2 = depth;
    }
    {
#line 246
    printf((char const   */* __restrict  */)"time\t--\t%s%s: %s\n", ("                " + 16) - tmp___2,
           t->name, target_bind___0[t->binding]);
    }
#line 248
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 251
    tmp___3 = ctime((time_t const   *)(& t->time));
    }
#line 251
    if (depth > 16) {
#line 251
      tmp___4 = 16;
    } else {
#line 251
      tmp___4 = depth;
    }
    {
#line 251
    printf((char const   */* __restrict  */)"time\t--\t%s%s: %s", ("                " + 16) - tmp___4,
           t->name, tmp___3);
    }
#line 253
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 263
  c = t->depends;
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 263
    if (! c) {
#line 263
      goto while_break;
    }
#line 265
    internal = (int )t->flags & 64;
#line 267
    if (globs.debug[13]) {
#line 268
      if (internal) {
#line 268
        tmp___5 = "Includes";
      } else {
#line 268
        tmp___5 = "Depends";
      }
      {
#line 268
      printf((char const   */* __restrict  */)"%s \"%s\" : \"%s\" ;\n", tmp___5, t->name,
             (c->target)->name);
      }
    }
#line 275
    if ((int )(c->target)->fate == 0) {
      {
#line 276
      make0___0(c->target, ptime, depth + 1, counts___1, anyhow);
      }
    } else
#line 277
    if ((int )(c->target)->fate == 1) {
#line 277
      if (! internal) {
        {
#line 278
        printf((char const   */* __restrict  */)"warning: %s depends on itself\n",
               (c->target)->name);
        }
      }
    }
#line 263
    c = c->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 283
  if (t->includes) {
    {
#line 284
    make0___0(t->includes, p, depth + 1, counts___1, anyhow);
    }
  }
#line 288
  incs = (TARGETS *)0;
#line 290
  c = t->depends;
  {
#line 290
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 290
    if (! c) {
#line 290
      goto while_break___0;
    }
#line 291
    if ((c->target)->includes) {
      {
#line 292
      incs = targetentry(incs, (c->target)->includes);
      }
    }
#line 290
    c = c->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 294
  t->depends = targetchain(t->depends, incs);
#line 302
  last = (time_t )0;
#line 303
  leaf = (time_t )0;
#line 304
  fate = 2;
#line 306
  c = t->depends;
  }
  {
#line 306
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 306
    if (! c) {
#line 306
      goto while_break___1;
    }
#line 311
    if (leaf > (c->target)->leaf) {
#line 311
      leaf = leaf;
    } else {
#line 311
      leaf = (c->target)->leaf;
    }
#line 313
    if ((int )t->flags & 16) {
#line 315
      last = leaf;
#line 316
      goto __Cont;
    }
#line 319
    if (last > (c->target)->time) {
#line 319
      last = last;
    } else {
#line 319
      last = (c->target)->time;
    }
#line 320
    if (fate > (int )(c->target)->fate) {
#line 320
      fate = fate;
    } else {
#line 320
      fate = (int )(c->target)->fate;
    }
    __Cont: /* CIL Label */ 
#line 306
    c = c->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 330
  if (t->includes) {
#line 330
    hlast = (t->includes)->time;
  } else {
#line 330
    hlast = (time_t )0;
  }
#line 340
  if ((int )t->flags & 32) {
#line 342
    last = (time_t )0;
#line 343
    t->time = (time_t )0;
#line 344
    fate = 2;
  }
#line 367
  if (fate >= 10) {
#line 369
    fate = 11;
  } else
#line 371
  if (fate >= 4) {
#line 373
    fate = 9;
  } else
#line 375
  if ((int )t->binding == 1) {
#line 377
    fate = 6;
  } else
#line 379
  if ((int )t->binding == 3) {
#line 379
    if (last > t->time) {
#line 381
      fate = 8;
    } else {
#line 379
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 383
  if ((int )t->binding == 2) {
#line 383
    if (last > p->time) {
#line 385
      fate = 7;
    } else {
#line 383
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 387
  if ((int )t->binding == 2) {
#line 387
    if (hlast > p->time) {
#line 389
      fate = 7;
    } else {
#line 387
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 391
  if ((int )t->flags & 8) {
#line 393
    fate = 5;
  } else
#line 395
  if (anyhow) {
#line 395
    if (! ((int )t->flags & 32)) {
#line 397
      fate = 5;
    } else {
#line 395
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 399
  if ((int )t->binding == 3) {
#line 399
    if ((int )t->flags & 1) {
#line 401
      fate = 4;
    } else {
#line 399
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 403
  if ((int )t->binding == 3) {
#line 403
    if (p) {
#line 403
      if ((int )p->binding != 0) {
#line 403
        if (t->time > p->time) {
#line 406
          fate = 3;
        } else {
#line 410
          fate = 2;
        }
      } else {
#line 410
        fate = 2;
      }
    } else {
#line 410
      fate = 2;
    }
  } else {
#line 410
    fate = 2;
  }
#line 419
  if (fate == 6) {
#line 419
    if (! t->actions) {
#line 419
      if (! t->depends) {
#line 421
        if ((int )t->flags & 2) {
#line 423
          fate = 2;
        } else {
          {
#line 427
          printf((char const   */* __restrict  */)"don\'t know how to make %s\n",
                 t->name);
#line 429
          fate = 10;
          }
        }
      }
    }
  }
#line 436
  if (t->time > last) {
#line 436
    t->time = t->time;
  } else {
#line 436
    t->time = last;
  }
#line 437
  if (leaf) {
#line 437
    t->leaf = leaf;
  } else {
#line 437
    t->leaf = t->time;
  }
#line 438
  t->fate = (char )fate;
#line 444
  if (globs.newestfirst) {
    {
#line 445
    t->depends = make0sort___0(t->depends);
    }
  }
#line 453
  if ((int )t->flags & 64) {
#line 454
    return;
  }
#line 456
  (counts___1->targets) ++;
#line 456
  if (! (counts___1->targets % 1000)) {
#line 456
    if (globs.debug[1]) {
      {
#line 457
      printf((char const   */* __restrict  */)"...patience...\n");
      }
    }
  }
#line 459
  if (fate == 4) {
#line 460
    (counts___1->temp) ++;
  } else
#line 461
  if (fate == 10) {
#line 462
    (counts___1->cantfind) ++;
  } else
#line 463
  if (fate == 11) {
#line 463
    if (t->actions) {
#line 464
      (counts___1->cantmake) ++;
    } else {
#line 463
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 465
  if (fate >= 5) {
#line 465
    if (fate < 10) {
#line 465
      if (t->actions) {
#line 466
        (counts___1->updating) ++;
      }
    }
  }
#line 468
  if (! ((int )t->flags & 4)) {
#line 468
    if (fate >= 4) {
#line 469
      flag = "+";
    } else {
#line 468
      goto _L___5;
    }
  } else
  _L___5: /* CIL Label */ 
#line 470
  if ((int )t->binding == 3) {
#line 470
    if (p) {
#line 470
      if (t->time > p->time) {
#line 471
        flag = "*";
      }
    }
  }
#line 473
  if (globs.debug[3]) {
#line 474
    if (depth > 16) {
#line 474
      tmp___6 = 16;
    } else {
#line 474
      tmp___6 = depth;
    }
    {
#line 474
    printf((char const   */* __restrict  */)"made%s\t%s\t%s%s\n", flag, target_fate___0[t->fate],
           ("                " + 16) - tmp___6, t->name);
    }
  }
#line 478
  if (globs.debug[14]) {
#line 478
    if ((int )t->fate >= 3) {
#line 478
      if ((int )t->fate <= 6) {
        {
#line 481
        printf((char const   */* __restrict  */)"%s %s\n", target_fate___0[t->fate],
               t->name);
        }
      }
    }
  }
#line 482
  return;
}
}
#line 488 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make.c"
static TARGETS *make0sort___0(TARGETS *chain ) 
{ 
  TARGETS *result ;
  TARGETS *c ;
  TARGETS *s ;

  {
#line 491
  result = (TARGETS *)0;
  {
#line 502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 502
    if (! chain) {
#line 502
      goto while_break;
    }
#line 504
    c = chain;
#line 505
    s = result;
#line 507
    chain = chain->next;
    {
#line 511
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 511
      if (s) {
#line 511
        if (! ((s->target)->time > (c->target)->time)) {
#line 511
          goto while_break___0;
        }
      } else {
#line 511
        goto while_break___0;
      }
#line 512
      s = s->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 517
    c->next = s;
#line 518
    if ((unsigned long )result == (unsigned long )s) {
#line 518
      result = c;
    }
#line 519
    if (! s) {
#line 519
      s = result;
    }
#line 520
    if ((unsigned long )result != (unsigned long )c) {
#line 520
      (s->tail)->next = c;
    }
#line 521
    c->tail = s->tail;
#line 522
    s->tail = c;
  }
  while_break: /* CIL Label */ ;
  }
#line 525
  return (result);
}
}
#line 23 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/regexp.h"
void regerror(char const   *s ) ;
#line 173 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/regexp.c"
static char *regparse  ;
#line 174 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/regexp.c"
static int regnpar  ;
#line 175 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/regexp.c"
static char regdummy  ;
#line 176 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/regexp.c"
static char *regcode  ;
#line 177 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/regexp.c"
static long regsize  ;
#line 185
static char *reg(int paren , int *flagp ) ;
#line 186
static char *regbranch(int *flagp ) ;
#line 187
static char *regpiece(int *flagp ) ;
#line 188
static char *regatom(int *flagp ) ;
#line 189
static char *regnode(int op ) ;
#line 190
static char *regnext(char *p ) ;
#line 191
static void regc(int b ) ;
#line 192
static void reginsert(char op , char *opnd ) ;
#line 193
static void regtail(char *p , char *val ) ;
#line 194
static void regoptail(char *p , char *val ) ;
#line 214 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/regexp.c"
regexp *regcomp(char const   *exp ) 
{ 
  register regexp *r ;
  register char *scan ;
  register char *longest ;
  register unsigned int len ;
  int flags ;
  char *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;

  {
#line 223
  if ((unsigned long )exp == (unsigned long )((void *)0)) {
    {
#line 224
    regerror("NULL argument");
    }
#line 224
    return ((regexp *)((void *)0));
  }
  {
#line 230
  regparse = (char *)exp;
#line 231
  regnpar = 1;
#line 232
  regsize = 0L;
#line 233
  regcode = & regdummy;
#line 234
  regc(156);
#line 235
  tmp = reg(0, & flags);
  }
#line 235
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 236
    return ((regexp *)((void *)0));
  }
#line 239
  if (regsize >= 32767L) {
    {
#line 240
    regerror("regexp too big");
    }
#line 240
    return ((regexp *)((void *)0));
  }
  {
#line 243
  tmp___0 = malloc(sizeof(regexp ) + (unsigned long )((unsigned int )regsize));
#line 243
  r = (regexp *)tmp___0;
  }
#line 244
  if ((unsigned long )r == (unsigned long )((void *)0)) {
    {
#line 245
    regerror("out of space");
    }
#line 245
    return ((regexp *)((void *)0));
  }
  {
#line 248
  regparse = (char *)exp;
#line 249
  regnpar = 1;
#line 250
  regcode = r->program;
#line 251
  regc(156);
#line 252
  tmp___1 = reg(0, & flags);
  }
#line 252
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 253
    return ((regexp *)((void *)0));
  }
  {
#line 256
  r->regstart = (char )'\000';
#line 257
  r->reganch = (char)0;
#line 258
  r->regmust = (char *)((void *)0);
#line 259
  r->regmlen = 0;
#line 260
  scan = r->program + 1;
#line 261
  tmp___4 = regnext(scan);
  }
#line 261
  if ((int )*tmp___4 == 0) {
#line 262
    scan += 3;
#line 265
    if ((int )*scan == 8) {
#line 266
      r->regstart = *(scan + 3);
    } else
#line 267
    if ((int )*scan == 1) {
#line 268
      r->reganch = (char )((int )r->reganch + 1);
    }
#line 278
    if (flags & 4) {
#line 279
      longest = (char *)((void *)0);
#line 280
      len = 0U;
      {
#line 281
      while (1) {
        while_continue: /* CIL Label */ ;
#line 281
        if (! ((unsigned long )scan != (unsigned long )((void *)0))) {
#line 281
          goto while_break;
        }
#line 282
        if ((int )*scan == 8) {
          {
#line 282
          tmp___3 = strlen((char const   *)(scan + 3));
          }
#line 282
          if (tmp___3 >= (size_t )len) {
            {
#line 283
            longest = scan + 3;
#line 284
            tmp___2 = strlen((char const   *)(scan + 3));
#line 284
            len = (unsigned int )tmp___2;
            }
          }
        }
        {
#line 281
        scan = regnext(scan);
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 286
      r->regmust = longest;
#line 287
      r->regmlen = (int )len;
    }
  }
#line 291
  return (r);
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/regexp.c"
static char *reg(int paren , int *flagp ) 
{ 
  register char *ret ;
  register char *br ;
  register char *ender ;
  register int parno ;
  int flags ;
  int tmp ;
  char *tmp___0 ;

  {
#line 314
  *flagp = 1;
#line 317
  if (paren) {
#line 318
    if (regnpar >= 10) {
      {
#line 319
      regerror("too many ()");
      }
#line 319
      return ((char *)((void *)0));
    }
    {
#line 320
    parno = regnpar;
#line 321
    regnpar ++;
#line 322
    ret = regnode(20 + parno);
    }
  } else {
#line 324
    ret = (char *)((void *)0);
  }
  {
#line 327
  br = regbranch(& flags);
  }
#line 328
  if ((unsigned long )br == (unsigned long )((void *)0)) {
#line 329
    return ((char *)((void *)0));
  }
#line 330
  if ((unsigned long )ret != (unsigned long )((void *)0)) {
    {
#line 331
    regtail(ret, br);
    }
  } else {
#line 333
    ret = br;
  }
#line 334
  if (! (flags & 1)) {
#line 335
    *flagp &= -2;
  }
#line 336
  *flagp |= flags & 4;
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    if (! ((int )*regparse == 124)) {
#line 337
      if (! ((int )*regparse == 10)) {
#line 337
        goto while_break;
      }
    }
    {
#line 338
    regparse ++;
#line 339
    br = regbranch(& flags);
    }
#line 340
    if ((unsigned long )br == (unsigned long )((void *)0)) {
#line 341
      return ((char *)((void *)0));
    }
    {
#line 342
    regtail(ret, br);
    }
#line 343
    if (! (flags & 1)) {
#line 344
      *flagp &= -2;
    }
#line 345
    *flagp |= flags & 4;
  }
  while_break: /* CIL Label */ ;
  }
#line 349
  if (paren) {
#line 349
    tmp = 30 + parno;
  } else {
#line 349
    tmp = 0;
  }
  {
#line 349
  ender = regnode(tmp);
#line 350
  regtail(ret, ender);
#line 353
  br = ret;
  }
  {
#line 353
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 353
    if (! ((unsigned long )br != (unsigned long )((void *)0))) {
#line 353
      goto while_break___0;
    }
    {
#line 354
    regoptail(br, ender);
#line 353
    br = regnext(br);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 357
  if (paren) {
#line 357
    tmp___0 = regparse;
#line 357
    regparse ++;
#line 357
    if ((int )*tmp___0 != 41) {
      {
#line 358
      regerror("unmatched ()");
      }
#line 358
      return ((char *)((void *)0));
    } else {
#line 357
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 359
  if (! paren) {
#line 359
    if ((int )*regparse != 0) {
#line 360
      if ((int )*regparse == 41) {
        {
#line 361
        regerror("unmatched ()");
        }
#line 361
        return ((char *)((void *)0));
      } else {
        {
#line 363
        regerror("junk on end");
        }
#line 363
        return ((char *)((void *)0));
      }
    }
  }
#line 367
  return (ret);
}
}
#line 375 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/regexp.c"
static char *regbranch(int *flagp ) 
{ 
  register char *ret ;
  register char *chain ;
  register char *latest ;
  int flags ;

  {
  {
#line 383
  *flagp = 0;
#line 385
  ret = regnode(6);
#line 386
  chain = (char *)((void *)0);
  }
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;
#line 387
    if ((int )*regparse != 0) {
#line 387
      if ((int )*regparse != 41) {
#line 387
        if ((int )*regparse != 10) {
#line 387
          if (! ((int )*regparse != 124)) {
#line 387
            goto while_break;
          }
        } else {
#line 387
          goto while_break;
        }
      } else {
#line 387
        goto while_break;
      }
    } else {
#line 387
      goto while_break;
    }
    {
#line 389
    latest = regpiece(& flags);
    }
#line 390
    if ((unsigned long )latest == (unsigned long )((void *)0)) {
#line 391
      return ((char *)((void *)0));
    }
#line 392
    *flagp |= flags & 1;
#line 393
    if ((unsigned long )chain == (unsigned long )((void *)0)) {
#line 394
      *flagp |= flags & 4;
    } else {
      {
#line 396
      regtail(chain, latest);
      }
    }
#line 397
    chain = latest;
  }
  while_break: /* CIL Label */ ;
  }
#line 399
  if ((unsigned long )chain == (unsigned long )((void *)0)) {
    {
#line 400
    regnode(9);
    }
  }
#line 402
  return (ret);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/regexp.c"
static char *regpiece(int *flagp ) 
{ 
  register char *ret ;
  register char op ;
  register char *next ;
  int flags ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 422
  ret = regatom(& flags);
  }
#line 423
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 424
    return ((char *)((void *)0));
  }
#line 426
  op = *regparse;
#line 427
  if (! ((int )op == 42)) {
#line 427
    if (! ((int )op == 43)) {
#line 427
      if (! ((int )op == 63)) {
#line 428
        *flagp = flags;
#line 429
        return (ret);
      }
    }
  }
#line 432
  if (! (flags & 1)) {
#line 432
    if ((int )op != 63) {
      {
#line 433
      regerror("*+ operand could be empty");
      }
#line 433
      return ((char *)((void *)0));
    }
  }
#line 434
  if ((int )op != 43) {
#line 434
    *flagp = 4;
  } else {
#line 434
    *flagp = 1;
  }
#line 436
  if ((int )op == 42) {
#line 436
    if (flags & 2) {
      {
#line 437
      reginsert((char)10, ret);
      }
    } else {
#line 436
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 438
  if ((int )op == 42) {
    {
#line 440
    reginsert((char)6, ret);
#line 441
    tmp = regnode(7);
#line 441
    regoptail(ret, tmp);
#line 442
    regoptail(ret, ret);
#line 443
    tmp___0 = regnode(6);
#line 443
    regtail(ret, tmp___0);
#line 444
    tmp___1 = regnode(9);
#line 444
    regtail(ret, tmp___1);
    }
  } else
#line 445
  if ((int )op == 43) {
#line 445
    if (flags & 2) {
      {
#line 446
      reginsert((char)11, ret);
      }
    } else {
#line 445
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 447
  if ((int )op == 43) {
    {
#line 449
    next = regnode(6);
#line 450
    regtail(ret, next);
#line 451
    tmp___2 = regnode(7);
#line 451
    regtail(tmp___2, ret);
#line 452
    tmp___3 = regnode(6);
#line 452
    regtail(next, tmp___3);
#line 453
    tmp___4 = regnode(9);
#line 453
    regtail(ret, tmp___4);
    }
  } else
#line 454
  if ((int )op == 63) {
    {
#line 456
    reginsert((char)6, ret);
#line 457
    tmp___5 = regnode(6);
#line 457
    regtail(ret, tmp___5);
#line 458
    next = regnode(9);
#line 459
    regtail(ret, next);
#line 460
    regoptail(ret, next);
    }
  }
#line 462
  regparse ++;
#line 463
  if ((int )*regparse == 42) {
    {
#line 464
    regerror("nested *?+");
    }
#line 464
    return ((char *)((void *)0));
  } else
#line 463
  if ((int )*regparse == 43) {
    {
#line 464
    regerror("nested *?+");
    }
#line 464
    return ((char *)((void *)0));
  } else
#line 463
  if ((int )*regparse == 63) {
    {
#line 464
    regerror("nested *?+");
    }
#line 464
    return ((char *)((void *)0));
  }
#line 466
  return (ret);
}
}
#line 477 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/regexp.c"
static char *regatom(int *flagp ) 
{ 
  register char *ret ;
  int flags ;
  char *tmp ;
  register int classr ;
  register int classend ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *regprev ;
  register char ch ;
  char *tmp___3 ;

  {
#line 483
  *flagp = 0;
#line 485
  tmp = regparse;
#line 485
  regparse ++;
  {
#line 487
  if ((int )*tmp == 94) {
#line 487
    goto case_94;
  }
#line 490
  if ((int )*tmp == 36) {
#line 490
    goto case_36;
  }
#line 493
  if ((int )*tmp == 46) {
#line 493
    goto case_46;
  }
#line 497
  if ((int )*tmp == 91) {
#line 497
    goto case_91;
  }
#line 532
  if ((int )*tmp == 40) {
#line 532
    goto case_40;
  }
#line 541
  if ((int )*tmp == 41) {
#line 541
    goto case_41;
  }
#line 541
  if ((int )*tmp == 10) {
#line 541
    goto case_41;
  }
#line 541
  if ((int )*tmp == 124) {
#line 541
    goto case_41;
  }
#line 541
  if ((int )*tmp == 0) {
#line 541
    goto case_41;
  }
#line 546
  if ((int )*tmp == 42) {
#line 546
    goto case_42;
  }
#line 546
  if ((int )*tmp == 43) {
#line 546
    goto case_42;
  }
#line 546
  if ((int )*tmp == 63) {
#line 546
    goto case_42;
  }
#line 549
  if ((int )*tmp == 92) {
#line 549
    goto case_92;
  }
#line 567
  goto de_fault;
  case_94: /* CIL Label */ 
  {
#line 488
  ret = regnode(1);
  }
#line 489
  goto switch_break;
  case_36: /* CIL Label */ 
  {
#line 491
  ret = regnode(2);
  }
#line 492
  goto switch_break;
  case_46: /* CIL Label */ 
  {
#line 494
  ret = regnode(3);
#line 495
  *flagp |= 3;
  }
#line 496
  goto switch_break;
  case_91: /* CIL Label */ 
#line 501
  if ((int )*regparse == 94) {
    {
#line 502
    ret = regnode(5);
#line 503
    regparse ++;
    }
  } else {
    {
#line 505
    ret = regnode(4);
    }
  }
#line 506
  if ((int )*regparse == 93) {
    {
#line 507
    tmp___0 = regparse;
#line 507
    regparse ++;
#line 507
    regc((int )*tmp___0);
    }
  } else
#line 506
  if ((int )*regparse == 45) {
    {
#line 507
    tmp___0 = regparse;
#line 507
    regparse ++;
#line 507
    regc((int )*tmp___0);
    }
  }
  {
#line 508
  while (1) {
    while_continue: /* CIL Label */ ;
#line 508
    if ((int )*regparse != 0) {
#line 508
      if (! ((int )*regparse != 93)) {
#line 508
        goto while_break;
      }
    } else {
#line 508
      goto while_break;
    }
#line 509
    if ((int )*regparse == 45) {
#line 510
      regparse ++;
#line 511
      if ((int )*regparse == 93) {
        {
#line 512
        regc('-');
        }
      } else
#line 511
      if ((int )*regparse == 0) {
        {
#line 512
        regc('-');
        }
      } else {
#line 514
        classr = (int )*((unsigned char *)(regparse - 2)) + 1;
#line 515
        classend = (int )*((unsigned char *)regparse);
#line 516
        if (classr > classend + 1) {
          {
#line 517
          regerror("invalid [] range");
          }
#line 517
          return ((char *)((void *)0));
        }
        {
#line 518
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 518
          if (! (classr <= classend)) {
#line 518
            goto while_break___0;
          }
          {
#line 519
          regc(classr);
#line 518
          classr ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 520
        regparse ++;
      }
    } else {
      {
#line 523
      tmp___1 = regparse;
#line 523
      regparse ++;
#line 523
      regc((int )*tmp___1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 525
  regc('\000');
  }
#line 526
  if ((int )*regparse != 93) {
    {
#line 527
    regerror("unmatched []");
    }
#line 527
    return ((char *)((void *)0));
  }
#line 528
  regparse ++;
#line 529
  *flagp |= 3;
#line 531
  goto switch_break;
  case_40: /* CIL Label */ 
  {
#line 533
  ret = reg(1, & flags);
  }
#line 534
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 535
    return ((char *)((void *)0));
  }
#line 536
  *flagp |= flags & 5;
#line 537
  goto switch_break;
  case_41: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_124: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 542
  regerror("internal urp");
  }
#line 542
  return ((char *)((void *)0));
#line 543
  goto switch_break;
  case_42: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_63: /* CIL Label */ 
  {
#line 547
  regerror("?+* follows nothing");
  }
#line 547
  return ((char *)((void *)0));
#line 548
  goto switch_break;
  case_92: /* CIL Label */ 
#line 550
  tmp___2 = regparse;
#line 550
  regparse ++;
  {
#line 551
  if ((int )*tmp___2 == 0) {
#line 551
    goto case_0___0;
  }
#line 554
  if ((int )*tmp___2 == 60) {
#line 554
    goto case_60;
  }
#line 557
  if ((int )*tmp___2 == 62) {
#line 557
    goto case_62;
  }
#line 561
  goto switch_default;
  case_0___0: /* CIL Label */ 
  {
#line 552
  regerror("trailing \\");
  }
#line 552
  return ((char *)((void *)0));
#line 553
  goto switch_break___0;
  case_60: /* CIL Label */ 
  {
#line 555
  ret = regnode(12);
  }
#line 556
  goto switch_break___0;
  case_62: /* CIL Label */ 
  {
#line 558
  ret = regnode(13);
  }
#line 559
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 563
  goto de_fault;
  switch_break___0: /* CIL Label */ ;
  }
#line 565
  goto switch_break;
  de_fault: 
  switch_default___0: /* CIL Label */ 
  {
#line 596
  regparse --;
#line 597
  ret = regnode(8);
#line 598
  regprev = (char *)0;
  }
  {
#line 598
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 599
    tmp___3 = regparse;
#line 599
    regparse ++;
#line 599
    ch = *tmp___3;
    {
#line 609
    if ((int )*regparse == 0) {
#line 609
      goto magic;
    }
#line 609
    if ((int )*regparse == 94) {
#line 609
      goto magic;
    }
#line 609
    if ((int )*regparse == 36) {
#line 609
      goto magic;
    }
#line 609
    if ((int )*regparse == 10) {
#line 609
      goto magic;
    }
#line 609
    if ((int )*regparse == 124) {
#line 609
      goto magic;
    }
#line 609
    if ((int )*regparse == 41) {
#line 609
      goto magic;
    }
#line 609
    if ((int )*regparse == 40) {
#line 609
      goto magic;
    }
#line 609
    if ((int )*regparse == 91) {
#line 609
      goto magic;
    }
#line 609
    if ((int )*regparse == 46) {
#line 609
      goto magic;
    }
#line 615
    if ((int )*regparse == 42) {
#line 615
      goto case_42___0;
    }
#line 615
    if ((int )*regparse == 43) {
#line 615
      goto case_42___0;
    }
#line 615
    if ((int )*regparse == 63) {
#line 615
      goto case_42___0;
    }
#line 622
    if ((int )*regparse == 92) {
#line 622
      goto case_92___0;
    }
#line 602
    goto switch_default___1;
    switch_default___1: /* CIL Label */ 
    {
#line 603
    regc((int )ch);
    }
#line 604
    goto switch_break___1;
    magic: 
    case_0___1: /* CIL Label */ 
    case_94___0: /* CIL Label */ 
    case_36___0: /* CIL Label */ 
    case_10___0: /* CIL Label */ 
    case_124___0: /* CIL Label */ 
    case_41___0: /* CIL Label */ 
    case_40___0: /* CIL Label */ 
    case_91___0: /* CIL Label */ 
    case_46___0: /* CIL Label */ 
    {
#line 612
    regc((int )ch);
    }
#line 613
    goto done;
    case_42___0: /* CIL Label */ 
    case_43___0: /* CIL Label */ 
    case_63___0: /* CIL Label */ 
#line 616
    if (! regprev) {
#line 617
      goto magic;
    }
#line 619
    regparse = regprev;
#line 620
    goto done;
    case_92___0: /* CIL Label */ 
    {
#line 623
    regc((int )ch);
    }
    {
#line 627
    if ((int )*(regparse + 1) == 62) {
#line 627
      goto case_62___0;
    }
#line 627
    if ((int )*(regparse + 1) == 60) {
#line 627
      goto case_62___0;
    }
#line 627
    if ((int )*(regparse + 1) == 0) {
#line 627
      goto case_62___0;
    }
#line 630
    goto switch_default___2;
    case_62___0: /* CIL Label */ 
    case_60___0: /* CIL Label */ 
    case_0___2: /* CIL Label */ 
#line 629
    goto done;
    switch_default___2: /* CIL Label */ 
#line 632
    regprev = regparse;
#line 633
    regparse ++;
#line 634
    goto __Cont;
    switch_break___2: /* CIL Label */ ;
    }
    switch_break___1: /* CIL Label */ ;
    }
#line 637
    regprev = regparse;
    __Cont: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  done: 
  {
#line 640
  regc('\000');
#line 641
  *flagp |= 1;
  }
#line 642
  if (! regprev) {
#line 643
    *flagp |= 2;
  }
#line 645
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 648
  return (ret);
}
}
#line 654 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/regexp.c"
static char *regnode(int op ) 
{ 
  register char *ret ;
  register char *ptr ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 660
  ret = regcode;
#line 661
  if ((unsigned long )ret == (unsigned long )(& regdummy)) {
#line 662
    regsize += 3L;
#line 663
    return (ret);
  }
#line 666
  ptr = ret;
#line 667
  tmp = ptr;
#line 667
  ptr ++;
#line 667
  *tmp = (char )op;
#line 668
  tmp___0 = ptr;
#line 668
  ptr ++;
#line 668
  *tmp___0 = (char )'\000';
#line 669
  tmp___1 = ptr;
#line 669
  ptr ++;
#line 669
  *tmp___1 = (char )'\000';
#line 670
  regcode = ptr;
#line 672
  return (ret);
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/regexp.c"
static void regc(int b ) 
{ 
  char *tmp ;

  {
#line 681
  if ((unsigned long )regcode != (unsigned long )(& regdummy)) {
#line 682
    tmp = regcode;
#line 682
    regcode ++;
#line 682
    *tmp = (char )b;
  } else {
#line 684
    regsize ++;
  }
#line 685
  return;
}
}
#line 692 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/regexp.c"
static void reginsert(char op , char *opnd ) 
{ 
  register char *src ;
  register char *dst ;
  register char *place ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 701
  if ((unsigned long )regcode == (unsigned long )(& regdummy)) {
#line 702
    regsize += 3L;
#line 703
    return;
  }
#line 706
  src = regcode;
#line 707
  regcode += 3;
#line 708
  dst = regcode;
  {
#line 709
  while (1) {
    while_continue: /* CIL Label */ ;
#line 709
    if (! ((unsigned long )src > (unsigned long )opnd)) {
#line 709
      goto while_break;
    }
#line 710
    dst --;
#line 710
    src --;
#line 710
    *dst = *src;
  }
  while_break: /* CIL Label */ ;
  }
#line 712
  place = opnd;
#line 713
  tmp = place;
#line 713
  place ++;
#line 713
  *tmp = op;
#line 714
  tmp___0 = place;
#line 714
  place ++;
#line 714
  *tmp___0 = (char )'\000';
#line 715
  tmp___1 = place;
#line 715
  place ++;
#line 715
  *tmp___1 = (char )'\000';
#line 716
  return;
}
}
#line 721 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/regexp.c"
static void regtail(char *p , char *val ) 
{ 
  register char *scan ;
  register char *temp ;
  register int offset ;

  {
#line 730
  if ((unsigned long )p == (unsigned long )(& regdummy)) {
#line 731
    return;
  }
#line 734
  scan = p;
  {
#line 735
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 736
    temp = regnext(scan);
    }
#line 737
    if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 738
      goto while_break;
    }
#line 739
    scan = temp;
  }
  while_break: /* CIL Label */ ;
  }
#line 742
  if ((int )*scan == 7) {
#line 743
    offset = (int )(scan - val);
  } else {
#line 745
    offset = (int )(val - scan);
  }
#line 746
  *(scan + 1) = (char )((offset >> 8) & 255);
#line 747
  *(scan + 2) = (char )(offset & 255);
#line 748
  return;
}
}
#line 754 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/regexp.c"
static void regoptail(char *p , char *val ) 
{ 


  {
#line 760
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 761
    return;
  } else
#line 760
  if ((unsigned long )p == (unsigned long )(& regdummy)) {
#line 761
    return;
  } else
#line 760
  if ((int )*p != 6) {
#line 761
    return;
  }
  {
#line 762
  regtail(p + 3, val);
  }
#line 763
  return;
}
}
#line 772 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/regexp.c"
static char const   *reginput  ;
#line 773 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/regexp.c"
static char *regbol  ;
#line 774 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/regexp.c"
static char const   **regstartp  ;
#line 775 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/regexp.c"
static char const   **regendp  ;
#line 780
static int regtry(regexp *prog , char const   *string ) ;
#line 781
static int regmatch(char *prog ) ;
#line 782
static int regrepeat(char *p ) ;
#line 793 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/regexp.c"
int regexec(regexp *prog , char const   *string ) 
{ 
  register char *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 801
  if ((unsigned long )prog == (unsigned long )((void *)0)) {
    {
#line 802
    regerror("NULL parameter");
    }
#line 803
    return (0);
  } else
#line 801
  if ((unsigned long )string == (unsigned long )((void *)0)) {
    {
#line 802
    regerror("NULL parameter");
    }
#line 803
    return (0);
  }
#line 807
  if ((int )*((unsigned char *)(prog->program)) != 156) {
    {
#line 808
    regerror("corrupted program");
    }
#line 809
    return (0);
  }
#line 813
  if ((unsigned long )prog->regmust != (unsigned long )((void *)0)) {
#line 814
    s = (char *)string;
    {
#line 815
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 815
      s = strchr((char const   *)s, (int )*(prog->regmust + 0));
      }
#line 815
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 815
        goto while_break;
      }
      {
#line 816
      tmp = strncmp((char const   *)s, (char const   *)prog->regmust, (size_t )prog->regmlen);
      }
#line 816
      if (tmp == 0) {
#line 817
        goto while_break;
      }
#line 818
      s ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 820
    if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 821
      return (0);
    }
  }
#line 825
  regbol = (char *)string;
#line 828
  if (prog->reganch) {
    {
#line 829
    tmp___0 = regtry(prog, string);
    }
#line 829
    return (tmp___0);
  }
#line 832
  s = (char *)string;
#line 833
  if ((int )prog->regstart != 0) {
    {
#line 835
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 835
      s = strchr((char const   *)s, (int )prog->regstart);
      }
#line 835
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 835
        goto while_break___0;
      }
      {
#line 836
      tmp___1 = regtry(prog, (char const   *)s);
      }
#line 836
      if (tmp___1) {
#line 837
        return (1);
      }
#line 838
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 842
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 843
      tmp___2 = regtry(prog, (char const   *)s);
      }
#line 843
      if (tmp___2) {
#line 844
        return (1);
      }
#line 842
      tmp___3 = s;
#line 842
      s ++;
#line 842
      if (! ((int )*tmp___3 != 0)) {
#line 842
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 848
  return (0);
}
}
#line 854 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/regexp.c"
static int regtry(regexp *prog , char const   *string ) 
{ 
  register int i ;
  register char const   **sp ;
  register char const   **ep ;
  char const   **tmp ;
  char const   **tmp___0 ;
  int tmp___1 ;

  {
#line 863
  reginput = string;
#line 864
  regstartp = prog->startp;
#line 865
  regendp = prog->endp;
#line 867
  sp = prog->startp;
#line 868
  ep = prog->endp;
#line 869
  i = 10;
  {
#line 869
  while (1) {
    while_continue: /* CIL Label */ ;
#line 869
    if (! (i > 0)) {
#line 869
      goto while_break;
    }
#line 870
    tmp = sp;
#line 870
    sp ++;
#line 870
    *tmp = (char const   *)((void *)0);
#line 871
    tmp___0 = ep;
#line 871
    ep ++;
#line 871
    *tmp___0 = (char const   *)((void *)0);
#line 869
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 873
  tmp___1 = regmatch(prog->program + 1);
  }
#line 873
  if (tmp___1) {
#line 874
    prog->startp[0] = string;
#line 875
    prog->endp[0] = reginput;
#line 876
    return (1);
  } else {
#line 878
    return (0);
  }
}
}
#line 891 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/regexp.c"
static int regmatch(char *prog ) 
{ 
  register char *scan ;
  char *next ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  register int len ;
  register char *opnd ;
  size_t tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  register int no ;
  register char const   *save ;
  int tmp___6 ;
  register int no___0 ;
  register char const   *save___0 ;
  int tmp___7 ;
  register char const   *save___1 ;
  int tmp___8 ;
  register char nextch ;
  register int no___1 ;
  register char const   *save___2 ;
  register int min ;
  int tmp___9 ;

  {
#line 897
  scan = prog;
  {
#line 902
  while (1) {
    while_continue: /* CIL Label */ ;
#line 902
    if (! ((unsigned long )scan != (unsigned long )((void *)0))) {
#line 902
      goto while_break;
    }
    {
#line 907
    next = regnext(scan);
    }
    {
#line 910
    if ((int )*scan == 1) {
#line 910
      goto case_1;
    }
#line 914
    if ((int )*scan == 2) {
#line 914
      goto case_2;
    }
#line 918
    if ((int )*scan == 12) {
#line 918
      goto case_12;
    }
#line 927
    if ((int )*scan == 13) {
#line 927
      goto case_13;
    }
#line 933
    if ((int )*scan == 3) {
#line 933
      goto case_3;
    }
#line 938
    if ((int )*scan == 8) {
#line 938
      goto case_8;
    }
#line 952
    if ((int )*scan == 4) {
#line 952
      goto case_4;
    }
#line 957
    if ((int )*scan == 5) {
#line 957
      goto case_5;
    }
#line 962
    if ((int )*scan == 9) {
#line 962
      goto case_9;
    }
#line 964
    if ((int )*scan == 7) {
#line 964
      goto case_7;
    }
#line 974
    if ((int )*scan == 29) {
#line 974
      goto case_29;
    }
#line 974
    if ((int )*scan == 28) {
#line 974
      goto case_29;
    }
#line 974
    if ((int )*scan == 27) {
#line 974
      goto case_29;
    }
#line 974
    if ((int )*scan == 26) {
#line 974
      goto case_29;
    }
#line 974
    if ((int )*scan == 25) {
#line 974
      goto case_29;
    }
#line 974
    if ((int )*scan == 24) {
#line 974
      goto case_29;
    }
#line 974
    if ((int )*scan == 23) {
#line 974
      goto case_29;
    }
#line 974
    if ((int )*scan == 22) {
#line 974
      goto case_29;
    }
#line 974
    if ((int )*scan == 21) {
#line 974
      goto case_29;
    }
#line 1002
    if ((int )*scan == 39) {
#line 1002
      goto case_39;
    }
#line 1002
    if ((int )*scan == 38) {
#line 1002
      goto case_39;
    }
#line 1002
    if ((int )*scan == 37) {
#line 1002
      goto case_39;
    }
#line 1002
    if ((int )*scan == 36) {
#line 1002
      goto case_39;
    }
#line 1002
    if ((int )*scan == 35) {
#line 1002
      goto case_39;
    }
#line 1002
    if ((int )*scan == 34) {
#line 1002
      goto case_39;
    }
#line 1002
    if ((int )*scan == 33) {
#line 1002
      goto case_39;
    }
#line 1002
    if ((int )*scan == 32) {
#line 1002
      goto case_39;
    }
#line 1002
    if ((int )*scan == 31) {
#line 1002
      goto case_39;
    }
#line 1022
    if ((int )*scan == 6) {
#line 1022
      goto case_6;
    }
#line 1041
    if ((int )*scan == 11) {
#line 1041
      goto case_11;
    }
#line 1041
    if ((int )*scan == 10) {
#line 1041
      goto case_11;
    }
#line 1069
    if ((int )*scan == 0) {
#line 1069
      goto case_0;
    }
#line 1072
    goto switch_default;
    case_1: /* CIL Label */ 
#line 911
    if ((unsigned long )reginput != (unsigned long )regbol) {
#line 912
      return (0);
    }
#line 913
    goto switch_break;
    case_2: /* CIL Label */ 
#line 915
    if ((int const   )*reginput != 0) {
#line 916
      return (0);
    }
#line 917
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 920
    tmp = __ctype_b_loc();
    }
#line 920
    if (! ((int const   )*(*tmp + (int )*reginput) & 8)) {
#line 920
      if ((int const   )*reginput != 95) {
#line 921
        return (0);
      }
    }
#line 923
    if ((unsigned long )reginput > (unsigned long )regbol) {
      {
#line 923
      tmp___0 = __ctype_b_loc();
      }
#line 923
      if ((int const   )*(*tmp___0 + (int )*(reginput + -1)) & 8) {
#line 925
        return (0);
      } else
#line 923
      if ((int const   )*(reginput + -1) == 95) {
#line 925
        return (0);
      }
    }
#line 926
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 929
    tmp___1 = __ctype_b_loc();
    }
#line 929
    if ((int const   )*(*tmp___1 + (int )*reginput) & 8) {
#line 930
      return (0);
    } else
#line 929
    if ((int const   )*reginput == 95) {
#line 930
      return (0);
    }
#line 932
    goto switch_break;
    case_3: /* CIL Label */ 
#line 934
    if ((int const   )*reginput == 0) {
#line 935
      return (0);
    }
#line 936
    reginput ++;
#line 937
    goto switch_break;
    case_8: /* CIL Label */ 
#line 942
    opnd = scan + 3;
#line 944
    if ((int )*opnd != (int )*reginput) {
#line 945
      return (0);
    }
    {
#line 946
    tmp___2 = strlen((char const   *)opnd);
#line 946
    len = (int )tmp___2;
    }
#line 947
    if (len > 1) {
      {
#line 947
      tmp___3 = strncmp((char const   *)opnd, reginput, (size_t )len);
      }
#line 947
      if (tmp___3 != 0) {
#line 948
        return (0);
      }
    }
#line 949
    reginput += len;
#line 951
    goto switch_break;
    case_4: /* CIL Label */ 
#line 953
    if ((int const   )*reginput == 0) {
#line 954
      return (0);
    } else {
      {
#line 953
      tmp___4 = strchr((char const   *)(scan + 3), (int )*reginput);
      }
#line 953
      if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
#line 954
        return (0);
      }
    }
#line 955
    reginput ++;
#line 956
    goto switch_break;
    case_5: /* CIL Label */ 
#line 958
    if ((int const   )*reginput == 0) {
#line 959
      return (0);
    } else {
      {
#line 958
      tmp___5 = strchr((char const   *)(scan + 3), (int )*reginput);
      }
#line 958
      if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 959
        return (0);
      }
    }
#line 960
    reginput ++;
#line 961
    goto switch_break;
    case_9: /* CIL Label */ 
#line 963
    goto switch_break;
    case_7: /* CIL Label */ 
#line 965
    goto switch_break;
    case_29: /* CIL Label */ 
    case_28: /* CIL Label */ 
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_23: /* CIL Label */ 
    case_22: /* CIL Label */ 
    case_21: /* CIL Label */ 
    {
#line 978
    no = (int )*scan - 20;
#line 979
    save = reginput;
#line 981
    tmp___6 = regmatch(next);
    }
#line 981
    if (tmp___6) {
#line 987
      if ((unsigned long )*(regstartp + no) == (unsigned long )((void *)0)) {
#line 988
        *(regstartp + no) = save;
      }
#line 989
      return (1);
    } else {
#line 991
      return (0);
    }
#line 993
    goto switch_break;
    case_39: /* CIL Label */ 
    case_38: /* CIL Label */ 
    case_37: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_35: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_33: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_31: /* CIL Label */ 
    {
#line 1006
    no___0 = (int )*scan - 30;
#line 1007
    save___0 = reginput;
#line 1009
    tmp___7 = regmatch(next);
    }
#line 1009
    if (tmp___7) {
#line 1015
      if ((unsigned long )*(regendp + no___0) == (unsigned long )((void *)0)) {
#line 1016
        *(regendp + no___0) = save___0;
      }
#line 1017
      return (1);
    } else {
#line 1019
      return (0);
    }
#line 1021
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1025
    if ((int )*next != 6) {
#line 1026
      next = scan + 3;
    } else {
      {
#line 1028
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1029
        save___1 = reginput;
#line 1030
        tmp___8 = regmatch(scan + 3);
        }
#line 1030
        if (tmp___8) {
#line 1031
          return (1);
        }
        {
#line 1032
        reginput = save___1;
#line 1033
        scan = regnext(scan);
        }
#line 1028
        if ((unsigned long )scan != (unsigned long )((void *)0)) {
#line 1028
          if (! ((int )*scan == 6)) {
#line 1028
            goto while_break___0;
          }
        } else {
#line 1028
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1035
      return (0);
    }
#line 1039
    goto switch_break;
    case_11: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 1051
    nextch = (char )'\000';
#line 1052
    if ((int )*next == 8) {
#line 1053
      nextch = *(next + 3);
    }
#line 1054
    if ((int )*scan == 10) {
#line 1054
      min = 0;
    } else {
#line 1054
      min = 1;
    }
    {
#line 1055
    save___2 = reginput;
#line 1056
    no___1 = regrepeat(scan + 3);
    }
    {
#line 1057
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1057
      if (! (no___1 >= min)) {
#line 1057
        goto while_break___1;
      }
#line 1059
      if ((int )nextch == 0) {
#line 1059
        goto _L;
      } else
#line 1059
      if ((int const   )*reginput == (int const   )nextch) {
        _L: /* CIL Label */ 
        {
#line 1060
        tmp___9 = regmatch(next);
        }
#line 1060
        if (tmp___9) {
#line 1061
          return (1);
        }
      }
#line 1063
      no___1 --;
#line 1064
      reginput = save___2 + no___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1066
    return (0);
#line 1068
    goto switch_break;
    case_0: /* CIL Label */ 
#line 1070
    return (1);
#line 1071
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1073
    regerror("memory corruption");
    }
#line 1074
    return (0);
#line 1075
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1078
    scan = next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1085
  regerror("corrupted pointers");
  }
#line 1086
  return (0);
}
}
#line 1092 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/regexp.c"
static int regrepeat(char *p ) 
{ 
  register int count ;
  register char const   *scan ;
  register char *opnd ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 1095
  count = 0;
#line 1099
  scan = reginput;
#line 1100
  opnd = p + 3;
  {
#line 1102
  if ((int )*p == 3) {
#line 1102
    goto case_3;
  }
#line 1106
  if ((int )*p == 8) {
#line 1106
    goto case_8;
  }
#line 1112
  if ((int )*p == 4) {
#line 1112
    goto case_4;
  }
#line 1118
  if ((int )*p == 5) {
#line 1118
    goto case_5;
  }
#line 1124
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 1103
  tmp = strlen(scan);
#line 1103
  count = (int )tmp;
#line 1104
  scan += count;
  }
#line 1105
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 1107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1107
    if (! ((int )*opnd == (int )*scan)) {
#line 1107
      goto while_break;
    }
#line 1108
    count ++;
#line 1109
    scan ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1111
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 1113
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1113
    if ((int const   )*scan != 0) {
      {
#line 1113
      tmp___0 = strchr((char const   *)opnd, (int )*scan);
      }
#line 1113
      if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 1113
        goto while_break___0;
      }
    } else {
#line 1113
      goto while_break___0;
    }
#line 1114
    count ++;
#line 1115
    scan ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1117
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 1119
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1119
    if ((int const   )*scan != 0) {
      {
#line 1119
      tmp___1 = strchr((char const   *)opnd, (int )*scan);
      }
#line 1119
      if (! ((unsigned long )tmp___1 == (unsigned long )((void *)0))) {
#line 1119
        goto while_break___1;
      }
    } else {
#line 1119
      goto while_break___1;
    }
#line 1120
    count ++;
#line 1121
    scan ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1123
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1125
  regerror("internal foulup");
#line 1126
  count = 0;
  }
#line 1127
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1129
  reginput = scan;
#line 1131
  return (count);
}
}
#line 1137 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/regexp.c"
static char *regnext(char *p ) 
{ 
  register int offset ;

  {
#line 1142
  if ((unsigned long )p == (unsigned long )(& regdummy)) {
#line 1143
    return ((char *)((void *)0));
  }
#line 1145
  offset = (((int )*(p + 1) & 255) << 8) + ((int )*(p + 2) & 255);
#line 1146
  if (offset == 0) {
#line 1147
    return ((char *)((void *)0));
  }
#line 1149
  if ((int )*p == 7) {
#line 1150
    return (p - offset);
  } else {
#line 1152
    return (p + offset);
  }
}
}
#line 1321 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/regexp.c"
void regerror(char const   *s ) 
{ 


  {
  {
#line 1324
  printf((char const   */* __restrict  */)"re error %s\n", s);
  }
#line 1325
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/timestamp.c"
static struct hash *bindhash  =    (struct hash *)0;
#line 46
static void time_enter(void *closure , char const   *target , int found , time_t time___0 ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/timestamp.c"
static char const   *time_progress[5]  = {      "INIT",      "NOENTRY",      "SPOTTED",      "MISSING", 
        "FOUND"};
#line 62 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/timestamp.c"
void timestamp(char *target , time_t *time___0 ) 
{ 
  PATHNAME f1 ;
  PATHNAME f2 ;
  BINDING binding ;
  BINDING *b ;
  char buf___0[1024] ;
  short tmp ;
  int tmp___0 ;
  BINDING binding___0 ;
  BINDING *b___0 ;
  short tmp___1 ;
  int tmp___2 ;
  BINDING binding___1 ;
  BINDING *b___1 ;
  short tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 68
  b = & binding;
#line 81
  if (! bindhash) {
    {
#line 82
    bindhash = hashinit((int )sizeof(BINDING ), "bindings");
    }
  }
  {
#line 86
  b->name = (char const   *)target;
#line 87
  tmp = (short)0;
#line 87
  b->flags = tmp;
#line 87
  b->time = (time_t )tmp;
#line 88
  b->progress = (short)0;
#line 90
  tmp___0 = hashitem(bindhash, (HASHDATA **)(& b), 1);
  }
#line 90
  if (! tmp___0) {
    {
#line 91
    b->name = newstr((char const   *)target);
    }
  }
#line 93
  if ((int )b->progress != 0) {
#line 94
    goto afterscanning;
  }
  {
#line 96
  b->progress = (short)1;
#line 100
  path_parse((char const   *)target, & f1);
#line 105
  b___0 = & binding___0;
#line 107
  f2 = f1;
#line 108
  f2.part[0].len = 0;
#line 109
  path_parent(& f2);
#line 110
  path_build(& f2, buf___0, 0);
#line 112
  b___0->name = (char const   *)(buf___0);
#line 113
  tmp___1 = (short)0;
#line 113
  b___0->flags = tmp___1;
#line 113
  b___0->time = (time_t )tmp___1;
#line 114
  b___0->progress = (short)0;
#line 116
  tmp___2 = hashitem(bindhash, (HASHDATA **)(& b___0), 1);
  }
#line 116
  if (! tmp___2) {
    {
#line 117
    b___0->name = newstr((char const   *)(buf___0));
    }
  }
#line 119
  if (! ((int )b___0->flags & 1)) {
    {
#line 121
    file_dirscan((char const   *)(buf___0), & time_enter, (void *)bindhash);
#line 122
    b___0->flags = (short )((int )b___0->flags | 1);
    }
  }
#line 128
  if (f1.part[5].len) {
    {
#line 130
    b___1 = & binding___1;
#line 132
    f2 = f1;
#line 133
    f2.part[0].len = 0;
#line 134
    f2.part[5].len = 0;
#line 135
    path_build(& f2, buf___0, 0);
#line 137
    b___1->name = (char const   *)(buf___0);
#line 138
    tmp___3 = (short)0;
#line 138
    b___1->flags = tmp___3;
#line 138
    b___1->time = (time_t )tmp___3;
#line 139
    b___1->progress = (short)0;
#line 141
    tmp___4 = hashitem(bindhash, (HASHDATA **)(& b___1), 1);
    }
#line 141
    if (! tmp___4) {
      {
#line 142
      b___1->name = newstr((char const   *)(buf___0));
      }
    }
#line 144
    if (! ((int )b___1->flags & 1)) {
      {
#line 146
      file_archscan((char const   *)(buf___0), & time_enter, (void *)bindhash);
#line 147
      b___1->flags = (short )((int )b___1->flags | 1);
      }
    }
  }
  afterscanning: 
#line 153
  if ((int )b->progress == 2) {
    {
#line 155
    tmp___5 = file_time(b->name, & b->time);
    }
#line 155
    if (tmp___5 < 0) {
#line 156
      b->progress = (short)3;
    } else {
#line 158
      b->progress = (short)4;
    }
  }
#line 161
  if ((int )b->progress == 4) {
#line 161
    *time___0 = b->time;
  } else {
#line 161
    *time___0 = (time_t )0;
  }
#line 162
  return;
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/timestamp.c"
static void time_enter(void *closure , char const   *target , int found , time_t time___0 ) 
{ 
  BINDING binding ;
  BINDING *b ;
  struct hash *bindhash___0 ;
  int tmp ;

  {
  {
#line 171
  b = & binding;
#line 172
  bindhash___0 = (struct hash *)closure;
#line 184
  b->name = target;
#line 185
  b->flags = (short)0;
#line 187
  tmp = hashitem(bindhash___0, (HASHDATA **)(& b), 1);
  }
#line 187
  if (! tmp) {
    {
#line 188
    b->name = newstr(target);
    }
  }
#line 190
  b->time = time___0;
#line 191
  if (found) {
#line 191
    b->progress = (short)4;
  } else {
#line 191
    b->progress = (short)2;
  }
#line 193
  if (globs.debug[6]) {
    {
#line 194
    printf((char const   */* __restrict  */)"time ( %s ) : %s\n", target, time_progress[b->progress]);
    }
  }
#line 195
  return;
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/timestamp.c"
void donestamps(void) 
{ 


  {
  {
#line 204
  hashdone(bindhash);
  }
#line 205
  return;
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/expand.c"
static void var_edit_parse___0(char const   *mods , VAR_EDITS *edits ) ;
#line 50
static void var_edit_file___0(char const   *in , char *out , VAR_EDITS *edits ) ;
#line 51
static void var_edit_shift___0(char *out , VAR_EDITS *edits ) ;
#line 388 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/expand.c"
static void var_edit_parse___0(char const   *mods , VAR_EDITS *edits ) 
{ 
  int havezeroed ;
  char *p ;
  PATHPART *fp ;
  char const   *tmp ;
  char tmp___0 ;
  int i ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 393
  havezeroed = 0;
#line 394
  memset((void *)((char *)edits), 0, sizeof(*edits));
  }
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 396
    if (! *mods) {
#line 396
      goto while_break;
    }
#line 401
    tmp = mods;
#line 401
    mods ++;
    {
#line 403
    if ((int const   )*tmp == 76) {
#line 403
      goto case_76;
    }
#line 404
    if ((int const   )*tmp == 85) {
#line 404
      goto case_85;
    }
#line 405
    if ((int const   )*tmp == 80) {
#line 405
      goto case_80;
    }
#line 406
    if ((int const   )*tmp == 69) {
#line 406
      goto case_69;
    }
#line 407
    if ((int const   )*tmp == 74) {
#line 407
      goto case_74;
    }
#line 408
    if ((int const   )*tmp == 71) {
#line 408
      goto case_71;
    }
#line 409
    if ((int const   )*tmp == 82) {
#line 409
      goto case_82;
    }
#line 410
    if ((int const   )*tmp == 68) {
#line 410
      goto case_68;
    }
#line 411
    if ((int const   )*tmp == 66) {
#line 411
      goto case_66;
    }
#line 412
    if ((int const   )*tmp == 83) {
#line 412
      goto case_83;
    }
#line 413
    if ((int const   )*tmp == 77) {
#line 413
      goto case_77;
    }
#line 415
    goto switch_default;
    case_76: /* CIL Label */ 
#line 403
    edits->downshift = (char)1;
#line 403
    goto while_continue;
    case_85: /* CIL Label */ 
#line 404
    edits->upshift = (char)1;
#line 404
    goto while_continue;
    case_80: /* CIL Label */ 
#line 405
    tmp___0 = (char)1;
#line 405
    edits->filemods = tmp___0;
#line 405
    edits->parent = tmp___0;
#line 405
    goto while_continue;
    case_69: /* CIL Label */ 
#line 406
    fp = & edits->empty;
#line 406
    goto strval;
    case_74: /* CIL Label */ 
#line 407
    fp = & edits->join;
#line 407
    goto strval;
    case_71: /* CIL Label */ 
#line 408
    fp = & edits->f.part[0];
#line 408
    goto fileval;
    case_82: /* CIL Label */ 
#line 409
    fp = & edits->f.part[1];
#line 409
    goto fileval;
    case_68: /* CIL Label */ 
#line 410
    fp = & edits->f.part[2];
#line 410
    goto fileval;
    case_66: /* CIL Label */ 
#line 411
    fp = & edits->f.part[3];
#line 411
    goto fileval;
    case_83: /* CIL Label */ 
#line 412
    fp = & edits->f.part[4];
#line 412
    goto fileval;
    case_77: /* CIL Label */ 
#line 413
    fp = & edits->f.part[5];
#line 413
    goto fileval;
    switch_default: /* CIL Label */ 
#line 415
    return;
    switch_break: /* CIL Label */ ;
    }
    fileval: 
#line 425
    edits->filemods = (char)1;
#line 427
    if ((int const   )*mods != 61) {
#line 431
      tmp___1 = havezeroed;
#line 431
      havezeroed ++;
#line 431
      if (! tmp___1) {
#line 432
        i = 0;
        {
#line 432
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 432
          if (! (i < 6)) {
#line 432
            goto while_break___0;
          }
#line 434
          edits->f.part[i].len = 0;
#line 435
          edits->f.part[i].ptr = "";
#line 432
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 438
      fp->ptr = (char const   *)0;
#line 439
      goto while_continue;
    }
    strval: 
#line 446
    if ((int const   )*mods != 61) {
#line 448
      fp->ptr = "";
#line 449
      fp->len = 0;
    } else {
      {
#line 451
      p = strchr(mods, '\001');
      }
#line 451
      if (p) {
#line 453
        *p = (char)0;
#line 454
        mods ++;
#line 454
        fp->ptr = mods;
#line 455
        fp->len = (int )(p - (char *)mods);
#line 456
        mods = (char const   *)(p + 1);
      } else {
        {
#line 460
        mods ++;
#line 460
        fp->ptr = mods;
#line 461
        tmp___2 = strlen(mods);
#line 461
        fp->len = (int )tmp___2;
#line 462
        mods += fp->len;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 465
  return;
}
}
#line 471 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/expand.c"
static void var_edit_file___0(char const   *in , char *out , VAR_EDITS *edits ) 
{ 
  PATHNAME pathname ;

  {
  {
#line 481
  path_parse(in, & pathname);
  }
#line 485
  if (edits->f.part[0].ptr) {
#line 486
    pathname.part[0] = edits->f.part[0];
  }
#line 488
  if (edits->f.part[1].ptr) {
#line 489
    pathname.part[1] = edits->f.part[1];
  }
#line 491
  if (edits->f.part[2].ptr) {
#line 492
    pathname.part[2] = edits->f.part[2];
  }
#line 494
  if (edits->f.part[3].ptr) {
#line 495
    pathname.part[3] = edits->f.part[3];
  }
#line 497
  if (edits->f.part[4].ptr) {
#line 498
    pathname.part[4] = edits->f.part[4];
  }
#line 500
  if (edits->f.part[5].ptr) {
#line 501
    pathname.part[5] = edits->f.part[5];
  }
#line 505
  if (edits->parent) {
    {
#line 506
    path_parent(& pathname);
    }
  }
  {
#line 510
  path_build(& pathname, out, 0);
  }
#line 511
  return;
}
}
#line 517 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/expand.c"
static void var_edit_shift___0(char *out , VAR_EDITS *edits ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 524
  if (edits->upshift) {
    {
#line 526
    while (1) {
      while_continue: /* CIL Label */ ;
#line 526
      if (! *out) {
#line 526
        goto while_break;
      }
      {
#line 527
      tmp = toupper((int )*out);
#line 527
      *out = (char )tmp;
#line 526
      out ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 529
  if (edits->downshift) {
    {
#line 531
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 531
      if (! *out) {
#line 531
        goto while_break___0;
      }
      {
#line 532
      tmp___0 = tolower((int )*out);
#line 532
      *out = (char )tmp___0;
#line 531
      out ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 534
  return;
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/parse.c"
static PARSE *yypsave  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/parse.c"
void parse_file(char const   *f ) 
{ 
  LOL l ;
  PARSE *p ;
  int jmp ;
  int tmp ;
  LIST *tmp___0 ;

  {
  {
#line 32
  yyfparse(f);
  }
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 42
    jmp = 0;
#line 46
    lol_init(& l);
#line 50
    yypsave = (PARSE *)0;
#line 54
    tmp = yyparse();
    }
#line 54
    if (tmp) {
#line 55
      goto while_break;
    } else {
#line 54
      p = yypsave;
#line 54
      if (! p) {
#line 55
        goto while_break;
      }
    }
    {
#line 59
    tmp___0 = (*(p->func))(p, & l, & jmp);
#line 59
    list_free(tmp___0);
#line 61
    parse_free(p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/parse.c"
void parse_save(PARSE *p ) 
{ 


  {
#line 68
  yypsave = p;
#line 69
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/parse.c"
PARSE *parse_make(LIST *(*func)(PARSE *p , LOL *args , int *jmp ) , PARSE *left ,
                  PARSE *right , PARSE *third , char const   *string , char const   *string1 ,
                  int num ) 
{ 
  PARSE *p ;
  void *tmp ;

  {
  {
#line 81
  tmp = malloc(sizeof(PARSE ));
#line 81
  p = (PARSE *)tmp;
#line 83
  p->func = func;
#line 84
  p->left = left;
#line 85
  p->right = right;
#line 86
  p->third = third;
#line 87
  p->string = string;
#line 88
  p->string1 = string1;
#line 89
  p->num = num;
#line 90
  p->refs = 1;
  }
#line 92
  return (p);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/parse.c"
void parse_refer(PARSE *p ) 
{ 


  {
#line 98
  (p->refs) ++;
#line 99
  return;
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/parse.c"
void parse_free(PARSE *p ) 
{ 


  {
#line 104
  (p->refs) --;
#line 104
  if (p->refs) {
#line 105
    return;
  }
#line 107
  if (p->string) {
    {
#line 108
    freestr(p->string);
    }
  }
#line 109
  if (p->string1) {
    {
#line 110
    freestr(p->string1);
    }
  }
#line 111
  if (p->left) {
    {
#line 112
    parse_free(p->left);
    }
  }
#line 113
  if (p->right) {
    {
#line 114
    parse_free(p->right);
    }
  }
#line 115
  if (p->third) {
    {
#line 116
    parse_free(p->third);
    }
  }
  {
#line 118
  free((void *)((char *)p));
  }
#line 119
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make1.c"
static void make1a___0(TARGET *t , TARGET *parent ) ;
#line 66
static void make1b___0(TARGET *t ) ;
#line 67
static void make1c___0(TARGET *t ) ;
#line 68
static void make1d___0(void *closure , int status ) ;
#line 70
static CMD *make1cmds___0(ACTIONS *a0 ) ;
#line 71
static LIST *make1list___0(LIST *l , TARGETS *targets , int flags ) ;
#line 72
static SETTINGS *make1settings___0(LIST *vars ) ;
#line 73
static void make1bind___0(TARGET *t , int warn ) ;
#line 77 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make1.c"
static struct __anonstruct_counts_50___0 counts___0[1]  ;
#line 88 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make1.c"
static int intr___2  =    0;
#line 122 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make1.c"
static void make1a___0(TARGET *t , TARGET *parent ) 
{ 
  TARGETS *c ;

  {
#line 133
  if (parent) {
    {
#line 138
    if ((int )t->progress == 3) {
#line 138
      goto case_3;
    }
#line 138
    if ((int )t->progress == 2) {
#line 138
      goto case_3;
    }
#line 138
    if ((int )t->progress == 0) {
#line 138
      goto case_3;
    }
#line 134
    goto switch_break;
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
#line 139
    t->parents = targetentry(t->parents, parent);
#line 140
    (parent->asynccnt) ++;
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 143
  if ((int )t->progress != 0) {
#line 144
    return;
  }
#line 152
  t->asynccnt = 1;
#line 157
  t->progress = (char)1;
#line 159
  c = t->depends;
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 159
    if (c) {
#line 159
      if (! (! intr___2)) {
#line 159
        goto while_break;
      }
    } else {
#line 159
      goto while_break;
    }
    {
#line 160
    make1a___0(c->target, t);
#line 159
    c = c->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 162
  t->progress = (char)2;
#line 167
  make1b___0(t);
  }
#line 168
  return;
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make1.c"
static void make1b___0(TARGET *t ) 
{ 
  TARGETS *c ;
  char const   *failed ;
  CMD *tmp ;

  {
#line 178
  failed = "dependents";
#line 183
  (t->asynccnt) --;
#line 183
  if (t->asynccnt) {
#line 184
    return;
  }
#line 190
  c = t->depends;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! c) {
#line 190
      goto while_break;
    }
#line 191
    if ((int )(c->target)->status > (int )t->status) {
#line 193
      failed = (c->target)->name;
#line 194
      t->status = (c->target)->status;
    }
#line 190
    c = c->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 200
  if ((int )t->status == 1) {
#line 200
    if (t->actions) {
      {
#line 202
      (counts___0[0].skipped) ++;
#line 203
      printf((char const   */* __restrict  */)"...skipped %s for lack of %s...\n",
             t->name, failed);
      }
    }
  }
#line 206
  if ((int )t->status == 0) {
    {
#line 214
    if ((int )t->fate == 3) {
#line 214
      goto case_3;
    }
#line 214
    if ((int )t->fate == 2) {
#line 214
      goto case_3;
    }
#line 214
    if ((int )t->fate == 1) {
#line 214
      goto case_3;
    }
#line 214
    if ((int )t->fate == 0) {
#line 214
      goto case_3;
    }
#line 218
    if ((int )t->fate == 11) {
#line 218
      goto case_11;
    }
#line 218
    if ((int )t->fate == 10) {
#line 218
      goto case_11;
    }
#line 222
    if ((int )t->fate == 4) {
#line 222
      goto case_4;
    }
#line 231
    if ((int )t->fate == 9) {
#line 231
      goto case_9;
    }
#line 231
    if ((int )t->fate == 8) {
#line 231
      goto case_9;
    }
#line 231
    if ((int )t->fate == 7) {
#line 231
      goto case_9;
    }
#line 231
    if ((int )t->fate == 6) {
#line 231
      goto case_9;
    }
#line 231
    if ((int )t->fate == 5) {
#line 231
      goto case_9;
    }
#line 207
    goto switch_break;
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 215
    goto switch_break;
    case_11: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 219
    t->status = (char)1;
#line 220
    goto switch_break;
    case_4: /* CIL Label */ 
#line 223
    if (globs.debug[11]) {
      {
#line 224
      printf((char const   */* __restrict  */)"...using %s...\n", t->name);
      }
    }
#line 225
    goto switch_break;
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
    case_5: /* CIL Label */ 
#line 236
    if (t->actions) {
#line 238
      (counts___0[0].total) ++;
#line 240
      if (globs.debug[1]) {
#line 240
        if (! (counts___0[0].total % 100)) {
          {
#line 241
          printf((char const   */* __restrict  */)"...on %dth target...\n", counts___0[0].total);
          }
        }
      }
      {
#line 243
      pushsettings(t->settings);
#line 244
      tmp = make1cmds___0(t->actions);
#line 244
      t->cmds = (char *)tmp;
#line 245
      popsettings(t->settings);
#line 247
      t->progress = (char)3;
      }
    }
#line 250
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 259
  make1c___0(t);
  }
#line 260
  return;
}
}
#line 266 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make1.c"
static void make1c___0(TARGET *t ) 
{ 
  CMD *cmd ;
  LIST *tmp ;
  TARGETS *c ;
  ACTIONS *actions ;

  {
#line 269
  cmd = (CMD *)t->cmds;
#line 279
  if (cmd) {
#line 279
    if ((int )t->status == 0) {
#line 281
      if (globs.debug[1]) {
#line 282
        if (globs.debug[11]) {
          {
#line 284
          printf((char const   */* __restrict  */)"%s ", (cmd->rule)->name);
#line 285
          tmp = lol_get(& cmd->args, 0);
#line 285
          list_print(tmp);
#line 286
          printf((char const   */* __restrict  */)"\n");
          }
        } else
#line 282
        if (! ((cmd->rule)->flags & 8)) {
          {
#line 284
          printf((char const   */* __restrict  */)"%s ", (cmd->rule)->name);
#line 285
          tmp = lol_get(& cmd->args, 0);
#line 285
          list_print(tmp);
#line 286
          printf((char const   */* __restrict  */)"\n");
          }
        }
      }
#line 289
      if (globs.debug[12]) {
        {
#line 290
        printf((char const   */* __restrict  */)"%s\n", cmd->buf);
        }
      }
#line 292
      if (globs.cmdout) {
        {
#line 293
        fprintf((FILE */* __restrict  */)globs.cmdout, (char const   */* __restrict  */)"%s",
                cmd->buf);
        }
      }
#line 295
      if (globs.noexec) {
        {
#line 297
        make1d___0((void *)t, 0);
        }
      } else {
        {
#line 301
        fflush(stdout);
#line 302
        execcmd(cmd->buf, & make1d___0, (void *)t, cmd->shell);
        }
      }
    } else {
#line 279
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 312
    actions = t->actions;
    {
#line 312
    while (1) {
      while_continue: /* CIL Label */ ;
#line 312
      if (! actions) {
#line 312
        goto while_break;
      }
#line 313
      if ((int )(actions->action)->status > (int )t->status) {
#line 314
        t->status = (actions->action)->status;
      }
#line 312
      actions = actions->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 316
    actions = t->actions;
    {
#line 316
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 316
      if (! actions) {
#line 316
        goto while_break___0;
      }
#line 317
      if ((int )t->status > (int )(actions->action)->status) {
#line 318
        (actions->action)->status = t->status;
      }
#line 316
      actions = actions->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 322
    if ((int )t->progress == 3) {
      {
#line 325
      if ((int )t->status == 0) {
#line 325
        goto case_0;
      }
#line 328
      if ((int )t->status == 1) {
#line 328
        goto case_1;
      }
#line 323
      goto switch_break;
      case_0: /* CIL Label */ 
#line 326
      (counts___0[0].made) ++;
#line 327
      goto switch_break;
      case_1: /* CIL Label */ 
#line 329
      (counts___0[0].failed) ++;
#line 330
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 335
    t->progress = (char)4;
#line 337
    c = t->parents;
    {
#line 337
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 337
      if (! c) {
#line 337
        goto while_break___1;
      }
      {
#line 338
      make1b___0(c->target);
#line 337
      c = c->next;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 340
  return;
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make1.c"
static void make1d___0(void *closure , int status ) 
{ 
  TARGET *t ;
  CMD *cmd ;
  LIST *tmp ;
  LIST *targets ;
  LIST *tmp___0 ;
  int tmp___1 ;

  {
#line 351
  t = (TARGET *)closure;
#line 352
  cmd = (CMD *)t->cmds;
#line 358
  if (status == 1) {
#line 358
    if ((cmd->rule)->flags & 4) {
#line 359
      status = 0;
    }
  }
#line 363
  if (status == 2) {
#line 364
    intr___2 ++;
  }
#line 366
  if (status == 1) {
#line 366
    if (globs.debug[1]) {
#line 370
      if (! globs.debug[12]) {
        {
#line 371
        printf((char const   */* __restrict  */)"%s\n", cmd->buf);
        }
      }
      {
#line 373
      printf((char const   */* __restrict  */)"...failed %s ", (cmd->rule)->name);
#line 374
      tmp = lol_get(& cmd->args, 0);
#line 374
      list_print(tmp);
#line 375
      printf((char const   */* __restrict  */)"...\n");
      }
#line 377
      if (globs.quitquick) {
#line 377
        intr___2 ++;
      }
    }
  }
#line 384
  if (status != 0) {
#line 384
    if (! ((cmd->rule)->flags & 1)) {
      {
#line 386
      tmp___0 = lol_get(& cmd->args, 0);
#line 386
      targets = tmp___0;
      }
      {
#line 388
      while (1) {
        while_continue: /* CIL Label */ ;
#line 388
        if (! targets) {
#line 388
          goto while_break;
        }
        {
#line 389
        tmp___1 = unlink(targets->string);
        }
#line 389
        if (! tmp___1) {
          {
#line 390
          printf((char const   */* __restrict  */)"...removing %s\n", targets->string);
          }
        }
#line 388
        targets = targets->next;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 395
  t->status = (char )status;
#line 396
  t->cmds = (char *)cmd->next;
#line 398
  cmd_free(cmd);
#line 400
  make1c___0(t);
  }
#line 401
  return;
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make1.c"
static CMD *make1cmds___0(ACTIONS *a0 ) 
{ 
  CMD *cmds ;
  LIST *shell ;
  LIST *tmp ;
  RULE *rule ;
  SETTINGS *boundvars ;
  LIST *nt ;
  LIST *ns ;
  ACTIONS *a1 ;
  int start ;
  int chunk ;
  int length ;
  int maxline ;
  CMD *cmd___0 ;
  LIST *tmp___0 ;
  LIST *tmp___1 ;
  LIST *tmp___2 ;
  CMD *tmp___3 ;

  {
  {
#line 416
  cmds = (CMD *)0;
#line 417
  tmp = var_get("JAMSHELL");
#line 417
  shell = tmp;
  }
  {
#line 423
  while (1) {
    while_continue: /* CIL Label */ ;
#line 423
    if (! a0) {
#line 423
      goto while_break;
    }
#line 425
    rule = (a0->action)->rule;
#line 435
    if (! rule->actions) {
#line 436
      goto __Cont;
    } else
#line 435
    if ((a0->action)->running) {
#line 436
      goto __Cont;
    }
    {
#line 438
    (a0->action)->running = (char)1;
#line 444
    nt = make1list___0((LIST *)0, (a0->action)->targets, 0);
#line 445
    ns = make1list___0((LIST *)0, (a0->action)->sources, rule->flags);
    }
#line 447
    if (rule->flags & 2) {
#line 448
      a1 = a0->next;
      {
#line 448
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 448
        if (! a1) {
#line 448
          goto while_break___0;
        }
#line 449
        if ((unsigned long )(a1->action)->rule == (unsigned long )rule) {
#line 449
          if (! (a1->action)->running) {
            {
#line 451
            ns = make1list___0(ns, (a1->action)->sources, rule->flags);
#line 452
            (a1->action)->running = (char)1;
            }
          }
        }
#line 448
        a1 = a1->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 458
    if (! ns) {
#line 458
      if (rule->flags & 33) {
        {
#line 460
        list_free(nt);
        }
#line 461
        goto __Cont;
      }
    }
    {
#line 466
    boundvars = make1settings___0(rule->bindlist);
#line 467
    pushsettings(boundvars);
#line 489
    start = 0;
#line 490
    length = list_length(ns);
#line 490
    chunk = length;
#line 491
    maxline = rule->flags / 64;
    }
#line 492
    if (maxline) {
#line 492
      if (maxline < 10240) {
#line 492
        maxline = maxline;
      } else {
#line 492
        maxline = 10240;
      }
    } else {
#line 492
      maxline = 10240;
    }
    {
#line 494
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 498
      tmp___0 = list_copy((LIST *)0, shell);
#line 498
      tmp___1 = list_sublist(ns, start, chunk);
#line 498
      tmp___2 = list_copy((LIST *)0, nt);
#line 498
      tmp___3 = cmd_new(rule, tmp___2, tmp___1, tmp___0, maxline);
#line 498
      cmd___0 = tmp___3;
      }
#line 504
      if (cmd___0) {
#line 508
        if (! cmds) {
#line 508
          cmds = cmd___0;
        } else {
#line 509
          (cmds->tail)->next = cmd___0;
        }
#line 510
        cmds->tail = cmd___0;
#line 511
        start += chunk;
      } else
#line 513
      if (rule->flags & 16) {
#line 513
        if (chunk > 1) {
#line 517
          chunk = (chunk * 9) / 10;
        } else {
          {
#line 523
          printf((char const   */* __restrict  */)"%s actions too long (max %d)!\n",
                 rule->name, maxline);
#line 525
          exit(1);
          }
        }
      } else {
        {
#line 523
        printf((char const   */* __restrict  */)"%s actions too long (max %d)!\n",
               rule->name, maxline);
#line 525
        exit(1);
        }
      }
#line 494
      if (! (start < length)) {
#line 494
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 532
    list_free(nt);
#line 533
    list_free(ns);
#line 538
    popsettings(boundvars);
#line 539
    freesettings(boundvars);
    }
    __Cont: /* CIL Label */ 
#line 423
    a0 = a0->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 542
  return (cmds);
}
}
#line 549 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make1.c"
static LIST *make1list___0(LIST *l , TARGETS *targets , int flags ) 
{ 
  TARGET *t ;
  LIST *m ;
  int tmp ;

  {
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    if (! targets) {
#line 555
      goto while_break;
    }
#line 557
    t = targets->target;
#line 564
    if ((int )t->binding == 0) {
      {
#line 565
      make1bind___0(t, ! (flags & 32));
      }
    }
#line 567
    if (flags & 32) {
#line 567
      if ((int )t->binding != 3) {
#line 568
        goto __Cont;
      }
    }
#line 570
    if (flags & 1) {
#line 570
      if ((int )t->fate <= 2) {
#line 571
        goto __Cont;
      }
    }
#line 575
    if (flags & 2) {
#line 579
      m = l;
      {
#line 579
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 579
        if (! m) {
#line 579
          goto while_break___0;
        }
        {
#line 580
        tmp = strcmp(m->string, t->boundname);
        }
#line 580
        if (! tmp) {
#line 581
          goto while_break___0;
        }
#line 579
        m = m->next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 583
      if (m) {
#line 584
        goto __Cont;
      }
    }
    {
#line 589
    l = list_new(l, t->boundname, 1);
    }
    __Cont: /* CIL Label */ 
#line 555
    targets = targets->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 592
  return (l);
}
}
#line 599 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make1.c"
static SETTINGS *make1settings___0(LIST *vars ) 
{ 
  SETTINGS *settings ;
  LIST *l ;
  LIST *tmp ;
  LIST *nl ;
  TARGET *t ;
  TARGET *tmp___0 ;

  {
#line 602
  settings = (SETTINGS *)0;
  {
#line 604
  while (1) {
    while_continue: /* CIL Label */ ;
#line 604
    if (! vars) {
#line 604
      goto while_break;
    }
    {
#line 606
    tmp = var_get(vars->string);
#line 606
    l = tmp;
#line 607
    nl = (LIST *)0;
    }
    {
#line 609
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 609
      if (! l) {
#line 609
        goto while_break___0;
      }
      {
#line 611
      tmp___0 = bindtarget(l->string);
#line 611
      t = tmp___0;
      }
#line 616
      if ((int )t->binding == 0) {
        {
#line 617
        make1bind___0(t, 1);
        }
      }
      {
#line 621
      nl = list_new(nl, t->boundname, 1);
#line 609
      l = l->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 626
    settings = addsettings(settings, 0, vars->string, nl);
#line 604
    vars = vars->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 629
  return (settings);
}
}
#line 639 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/make1.c"
static void make1bind___0(TARGET *t , int warn ) 
{ 


  {
#line 644
  if ((int )t->flags & 4) {
#line 645
    return;
  }
#line 652
  if (warn) {
    {
#line 653
    printf((char const   */* __restrict  */)"warning: using independent target %s\n",
           t->name);
    }
  }
  {
#line 655
  pushsettings(t->settings);
#line 656
  t->boundname = search(t->name, & t->time);
  }
#line 657
  if (t->time) {
#line 657
    t->binding = (char)3;
  } else {
#line 657
    t->binding = (char)1;
  }
  {
#line 658
  popsettings(t->settings);
  }
#line 659
  return;
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/jam-2.5rel/jam.c"
static char const   *othersyms___0[5]  = {      "UNIX=true",      "OS=LINUX",      "",      "JAMVERSION=2.5", 
        (char const   *)0};
