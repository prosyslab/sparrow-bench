/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 194 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef signed char int8_t;
#line 195 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef short int16_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned char u_int8_t;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 32 "/usr/include/net/ethernet.h"
struct ether_addr {
   u_int8_t ether_addr_octet[6] ;
} __attribute__((__packed__)) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/ftypes.h"
struct __anonstruct_type_t_34 {
   uint8_t type_name[16] ;
   int16_t type_size ;
   int8_t (*parser)(uint8_t *text , void *buf ) ;
   void (*printer)(void *buf ) ;
};
#line 42 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/ftypes.h"
typedef struct __anonstruct_type_t_34 type_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 26 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/crunchfc.h"
struct config_data {
   int fd ;
   int offset ;
   uint32_t maxlen ;
   uint32_t reallen ;
   uint8_t swab ;
   uint8_t *buf ;
};
#line 81 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/crunchfc.c"
struct fconfig_key {
   uint8_t type ;
   uint8_t namelen ;
   uint8_t ensense ;
   uint8_t enlen ;
   uint8_t *keyname ;
   uint8_t *enkey ;
   uint8_t *dataval ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 177 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __syscall_ulong_t;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   __time_t st_atime ;
   __syscall_ulong_t st_atimensec ;
   __time_t st_mtime ;
   __syscall_ulong_t st_mtimensec ;
   __time_t st_ctime ;
   __syscall_ulong_t st_ctimensec ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 140 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fis/fis.c"
struct fis_image_desc {
   unsigned char name[16] ;
   uint32_t flash_base ;
   uint32_t mem_base ;
   uint32_t size ;
   uint32_t entry_point ;
   uint32_t data_length ;
   uint32_t skips[53] ;
   uint32_t desc_cksum ;
   uint32_t file_cksum ;
};
#line 175 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fis/fis.c"
struct dirnode {
   struct fis_image_desc *entry ;
   struct dirnode *prev ;
   struct dirnode *next ;
};
#line 196 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fis/fis.c"
typedef struct dirnode *dir_t;
#line 197 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fis/fis.c"
typedef struct dirnode *iter_t;
#line 53 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 73
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_aton)(char const   *__cp ,
                                                                                struct in_addr *__inp ) ;
#line 35 "/usr/include/netinet/ether.h"
extern  __attribute__((__nothrow__)) struct ether_addr *( __attribute__((__leaf__)) ether_aton)(char const   *__asc ) ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/ftypes.h"
type_t types[8] ;
#line 85
int8_t verify_ftype(uint8_t type ) ;
#line 87
int8_t parse_bool(uint8_t *text , void *buf ) ;
#line 88
int8_t parse_int(uint8_t *text , void *buf ) ;
#line 89
int8_t parse_script(uint8_t *text , void *buf ) ;
#line 90
int8_t parse_string(uint8_t *text , void *buf ) ;
#line 91
int8_t parse_ip(uint8_t *text , void *buf ) ;
#line 92
int8_t parse_esa(uint8_t *text , void *buf ) ;
#line 93
int8_t parse_netport(uint8_t *text , void *buf ) ;
#line 95
void print_bool(void *buf ) ;
#line 96
void print_int(void *buf ) ;
#line 97
void print_string(void *buf ) ;
#line 98
void print_script(void *buf ) ;
#line 99
void print_ip(void *buf ) ;
#line 100
void print_esa(void *buf ) ;
#line 101
void print_netport(void *buf ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/ftypes.c"
type_t types[8]  = 
#line 40 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/ftypes.c"
  {      {{(uint8_t )'e', (uint8_t )'m', (uint8_t )'p', (uint8_t )'t', (uint8_t )'y',
       (uint8_t )'\000'}, (int16_t )0, (int8_t (*)(uint8_t *text , void *buf ))((void *)0),
      (void (*)(void *buf ))((void *)0)}, 
        {{(uint8_t )'b', (uint8_t )'o', (uint8_t )'o', (uint8_t )'l', (uint8_t )'\000'},
      (int16_t )4, & parse_bool, & print_bool}, 
        {{(uint8_t )'i', (uint8_t )'n', (uint8_t )'t', (uint8_t )'\000'}, (int16_t )4,
      & parse_int, & print_int}, 
        {{(uint8_t )'s', (uint8_t )'t', (uint8_t )'r', (uint8_t )'i', (uint8_t )'n',
       (uint8_t )'g', (uint8_t )'\000'}, (int16_t )128, & parse_string, & print_string}, 
        {{(uint8_t )'s',
       (uint8_t )'c', (uint8_t )'r', (uint8_t )'i', (uint8_t )'p', (uint8_t )'t',
       (uint8_t )'\000'}, (int16_t )512, & parse_script, & print_script}, 
        {{(uint8_t )'i', (uint8_t )'p', (uint8_t )'\000'}, (int16_t )4, & parse_ip, & print_ip}, 
        {{(uint8_t )'e',
       (uint8_t )'s', (uint8_t )'a', (uint8_t )'\000'}, (int16_t )8, & parse_esa,
      & print_esa}, 
        {{(uint8_t )'n', (uint8_t )'e', (uint8_t )'t', (uint8_t )'p', (uint8_t )'o',
       (uint8_t )'r', (uint8_t )'t', (uint8_t )'\000'}, (int16_t )128, & parse_netport,
      & print_netport}};
#line 51 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/ftypes.c"
int8_t verify_ftype(uint8_t type ) 
{ 


  {
#line 53
  return ((int8_t )((int )type < 8));
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/ftypes.c"
int8_t parse_bool(uint8_t *text , void *buf ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 64
  tmp___0 = strcasecmp((char const   *)text, "TRUE");
  }
#line 64
  if (tmp___0 == 0) {
#line 65
    *((uint32_t *)buf) = (uint32_t )1;
#line 66
    return ((int8_t )0);
  } else {
    {
#line 67
    tmp = strcasecmp((char const   *)text, "FALSE");
    }
#line 67
    if (tmp == 0) {
#line 68
      *((uint32_t *)buf) = (uint32_t )0;
#line 69
      return ((int8_t )0);
    } else {
#line 71
      return ((int8_t )-1);
    }
  }
#line 73
  return ((int8_t )0);
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/ftypes.c"
void print_bool(void *buf ) 
{ 
  uint32_t val ;

  {
  {
#line 82
  memcpy((void */* __restrict  */)(& val), (void const   */* __restrict  */)buf, sizeof(val));
  }
#line 84
  if (val) {
    {
#line 85
    printf((char const   */* __restrict  */)"TRUE");
    }
  } else {
    {
#line 87
    printf((char const   */* __restrict  */)"FALSE");
    }
  }
#line 89
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/ftypes.c"
int8_t parse_int(uint8_t *text , void *buf ) 
{ 
  int *tmp ;
  unsigned long tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 97
  tmp = __errno_location();
#line 97
  *tmp = 0;
#line 98
  tmp___0 = strtoul((char const   */* __restrict  */)text, (char **/* __restrict  */)((char **)((void *)0)),
                    0);
#line 98
  *((uint32_t *)buf) = (uint32_t )tmp___0;
#line 99
  tmp___1 = __errno_location();
  }
#line 99
  return ((int8_t )*tmp___1);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/ftypes.c"
void print_int(void *buf ) 
{ 
  uint32_t val ;

  {
  {
#line 109
  memcpy((void */* __restrict  */)(& val), (void const   */* __restrict  */)buf, sizeof(val));
#line 110
  printf((char const   */* __restrict  */)"%d", val);
  }
#line 111
  return;
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/ftypes.c"
int8_t parse_string(uint8_t *text , void *buf ) 
{ 
  uint8_t *dest ;

  {
  {
#line 119
  dest = (uint8_t *)buf;
#line 120
  *(dest + 127) = (uint8_t )'\000';
#line 121
  strncpy((char */* __restrict  */)dest, (char const   */* __restrict  */)text, (size_t )128);
  }
#line 122
  if ((int )*(dest + 127) != 0) {
#line 123
    *(dest + 127) = (uint8_t )'\000';
#line 124
    return ((int8_t )-1);
  }
#line 126
  return ((int8_t )0);
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/ftypes.c"
void print_string(void *buf ) 
{ 
  uint8_t *str ;

  {
  {
#line 134
  str = (uint8_t *)buf;
#line 135
  printf((char const   */* __restrict  */)"%s", str);
  }
#line 136
  return;
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/ftypes.c"
int8_t parse_script(uint8_t *text , void *buf ) 
{ 
  uint8_t *dest ;

  {
  {
#line 146
  dest = (uint8_t *)buf;
#line 147
  *(dest + 511) = (uint8_t )'\000';
#line 148
  strncpy((char */* __restrict  */)dest, (char const   */* __restrict  */)text, (size_t )512);
  }
#line 149
  if ((int )*(dest + 511) != 0) {
#line 150
    *(dest + 511) = (uint8_t )'\000';
#line 151
    return ((int8_t )-1);
  }
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if (! ((int )*dest != 0)) {
#line 153
      goto while_break;
    }
#line 154
    if ((int )*dest == 92) {
#line 155
      *dest = (uint8_t )'\n';
    }
#line 157
    dest ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 159
  return ((int8_t )0);
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/ftypes.c"
void print_script(void *buf ) 
{ 
  uint8_t *str ;

  {
  {
#line 167
  str = (uint8_t *)buf;
#line 168
  printf((char const   */* __restrict  */)"%s", str);
  }
#line 169
  return;
}
}
#line 176 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/ftypes.c"
int8_t parse_ip(uint8_t *text , void *buf ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 178
  tmp = inet_aton((char const   *)text, (struct in_addr *)buf);
  }
#line 178
  if (tmp) {
#line 178
    tmp___0 = 0;
  } else {
#line 178
    tmp___0 = 1;
  }
#line 178
  return ((int8_t )tmp___0);
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/ftypes.c"
void print_ip(void *buf ) 
{ 
  struct in_addr addr ;
  char *tmp ;

  {
  {
#line 187
  memcpy((void */* __restrict  */)(& addr), (void const   */* __restrict  */)buf,
         sizeof(addr));
#line 188
  tmp = inet_ntoa(addr);
#line 188
  printf((char const   */* __restrict  */)"%s", tmp);
  }
#line 189
  return;
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/ftypes.c"
int8_t parse_esa(uint8_t *text , void *buf ) 
{ 
  struct ether_addr *addr ;
  struct ether_addr *tmp ;

  {
  {
#line 198
  tmp = ether_aton((char const   *)text);
#line 198
  addr = tmp;
  }
#line 199
  if ((unsigned long )addr == (unsigned long )((void *)0)) {
#line 200
    return ((int8_t )-1);
  }
  {
#line 202
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)addr, sizeof(struct ether_addr ));
  }
#line 203
  return ((int8_t )0);
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/ftypes.c"
void print_esa(void *buf ) 
{ 
  uint8_t *e ;

  {
  {
#line 212
  e = (uint8_t *)buf;
#line 213
  printf((char const   */* __restrict  */)"%02x:%02x:%02x:%02x:%02x:%02x", (int )*(e + 0),
         (int )*(e + 1), (int )*(e + 2), (int )*(e + 3), (int )*(e + 4), (int )*(e + 5));
  }
#line 215
  return;
}
}
#line 221 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/ftypes.c"
int8_t parse_netport(uint8_t *text , void *buf ) 
{ 
  int8_t tmp ;

  {
  {
#line 223
  tmp = parse_string(text, buf);
  }
#line 223
  return (tmp);
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/ftypes.c"
void print_netport(void *buf ) 
{ 


  {
  {
#line 232
  print_string(buf);
  }
#line 233
  return;
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/debug.h"
uint8_t verbosity ;
#line 29
void hex_dump(void *buf , uint16_t len ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/debug.c"
uint8_t verbosity  =    (uint8_t )1;
#line 23 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/debug.c"
void hex_dump(void *buf , uint16_t len ) 
{ 
  uint16_t i ;

  {
#line 26
  i = (uint16_t )0;
  {
#line 26
  while (1) {
    while_continue: /* CIL Label */ ;
#line 26
    if (! ((int )i < (int )len)) {
#line 26
      goto while_break;
    }
    {
#line 27
    printf((char const   */* __restrict  */)"%02x", (int )*((uint8_t *)buf + i));
    }
#line 28
    if ((int )i % 2) {
      {
#line 29
      printf((char const   */* __restrict  */)" ");
      }
    }
#line 31
    if (15 == (int )i % 16) {
      {
#line 32
      printf((char const   */* __restrict  */)"\n");
      }
    }
#line 26
    i = (uint16_t )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 35
  printf((char const   */* __restrict  */)"\n");
  }
#line 36
  return;
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/crc.h"
uint32_t crc32(uint8_t *s , uint32_t len ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/crc.c"
static uint32_t const   crc32_tab[256]  = 
#line 24 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/crc.c"
  {      (uint32_t const   )0L,      (uint32_t const   )1996959894L,      (uint32_t const   )3993919788L,      (uint32_t const   )2567524794L, 
        (uint32_t const   )124634137L,      (uint32_t const   )1886057615L,      (uint32_t const   )3915621685L,      (uint32_t const   )2657392035L, 
        (uint32_t const   )249268274L,      (uint32_t const   )2044508324L,      (uint32_t const   )3772115230L,      (uint32_t const   )2547177864L, 
        (uint32_t const   )162941995L,      (uint32_t const   )2125561021L,      (uint32_t const   )3887607047L,      (uint32_t const   )2428444049L, 
        (uint32_t const   )498536548L,      (uint32_t const   )1789927666L,      (uint32_t const   )4089016648L,      (uint32_t const   )2227061214L, 
        (uint32_t const   )450548861L,      (uint32_t const   )1843258603L,      (uint32_t const   )4107580753L,      (uint32_t const   )2211677639L, 
        (uint32_t const   )325883990L,      (uint32_t const   )1684777152L,      (uint32_t const   )4251122042L,      (uint32_t const   )2321926636L, 
        (uint32_t const   )335633487L,      (uint32_t const   )1661365465L,      (uint32_t const   )4195302755L,      (uint32_t const   )2366115317L, 
        (uint32_t const   )997073096L,      (uint32_t const   )1281953886L,      (uint32_t const   )3579855332L,      (uint32_t const   )2724688242L, 
        (uint32_t const   )1006888145L,      (uint32_t const   )1258607687L,      (uint32_t const   )3524101629L,      (uint32_t const   )2768942443L, 
        (uint32_t const   )901097722L,      (uint32_t const   )1119000684L,      (uint32_t const   )3686517206L,      (uint32_t const   )2898065728L, 
        (uint32_t const   )853044451L,      (uint32_t const   )1172266101L,      (uint32_t const   )3705015759L,      (uint32_t const   )2882616665L, 
        (uint32_t const   )651767980L,      (uint32_t const   )1373503546L,      (uint32_t const   )3369554304L,      (uint32_t const   )3218104598L, 
        (uint32_t const   )565507253L,      (uint32_t const   )1454621731L,      (uint32_t const   )3485111705L,      (uint32_t const   )3099436303L, 
        (uint32_t const   )671266974L,      (uint32_t const   )1594198024L,      (uint32_t const   )3322730930L,      (uint32_t const   )2970347812L, 
        (uint32_t const   )795835527L,      (uint32_t const   )1483230225L,      (uint32_t const   )3244367275L,      (uint32_t const   )3060149565L, 
        (uint32_t const   )1994146192L,      (uint32_t const   )31158534L,      (uint32_t const   )2563907772L,      (uint32_t const   )4023717930L, 
        (uint32_t const   )1907459465L,      (uint32_t const   )112637215L,      (uint32_t const   )2680153253L,      (uint32_t const   )3904427059L, 
        (uint32_t const   )2013776290L,      (uint32_t const   )251722036L,      (uint32_t const   )2517215374L,      (uint32_t const   )3775830040L, 
        (uint32_t const   )2137656763L,      (uint32_t const   )141376813L,      (uint32_t const   )2439277719L,      (uint32_t const   )3865271297L, 
        (uint32_t const   )1802195444L,      (uint32_t const   )476864866L,      (uint32_t const   )2238001368L,      (uint32_t const   )4066508878L, 
        (uint32_t const   )1812370925L,      (uint32_t const   )453092731L,      (uint32_t const   )2181625025L,      (uint32_t const   )4111451223L, 
        (uint32_t const   )1706088902L,      (uint32_t const   )314042704L,      (uint32_t const   )2344532202L,      (uint32_t const   )4240017532L, 
        (uint32_t const   )1658658271L,      (uint32_t const   )366619977L,      (uint32_t const   )2362670323L,      (uint32_t const   )4224994405L, 
        (uint32_t const   )1303535960L,      (uint32_t const   )984961486L,      (uint32_t const   )2747007092L,      (uint32_t const   )3569037538L, 
        (uint32_t const   )1256170817L,      (uint32_t const   )1037604311L,      (uint32_t const   )2765210733L,      (uint32_t const   )3554079995L, 
        (uint32_t const   )1131014506L,      (uint32_t const   )879679996L,      (uint32_t const   )2909243462L,      (uint32_t const   )3663771856L, 
        (uint32_t const   )1141124467L,      (uint32_t const   )855842277L,      (uint32_t const   )2852801631L,      (uint32_t const   )3708648649L, 
        (uint32_t const   )1342533948L,      (uint32_t const   )654459306L,      (uint32_t const   )3188396048L,      (uint32_t const   )3373015174L, 
        (uint32_t const   )1466479909L,      (uint32_t const   )544179635L,      (uint32_t const   )3110523913L,      (uint32_t const   )3462522015L, 
        (uint32_t const   )1591671054L,      (uint32_t const   )702138776L,      (uint32_t const   )2966460450L,      (uint32_t const   )3352799412L, 
        (uint32_t const   )1504918807L,      (uint32_t const   )783551873L,      (uint32_t const   )3082640443L,      (uint32_t const   )3233442989L, 
        (uint32_t const   )3988292384L,      (uint32_t const   )2596254646L,      (uint32_t const   )62317068L,      (uint32_t const   )1957810842L, 
        (uint32_t const   )3939845945L,      (uint32_t const   )2647816111L,      (uint32_t const   )81470997L,      (uint32_t const   )1943803523L, 
        (uint32_t const   )3814918930L,      (uint32_t const   )2489596804L,      (uint32_t const   )225274430L,      (uint32_t const   )2053790376L, 
        (uint32_t const   )3826175755L,      (uint32_t const   )2466906013L,      (uint32_t const   )167816743L,      (uint32_t const   )2097651377L, 
        (uint32_t const   )4027552580L,      (uint32_t const   )2265490386L,      (uint32_t const   )503444072L,      (uint32_t const   )1762050814L, 
        (uint32_t const   )4150417245L,      (uint32_t const   )2154129355L,      (uint32_t const   )426522225L,      (uint32_t const   )1852507879L, 
        (uint32_t const   )4275313526L,      (uint32_t const   )2312317920L,      (uint32_t const   )282753626L,      (uint32_t const   )1742555852L, 
        (uint32_t const   )4189708143L,      (uint32_t const   )2394877945L,      (uint32_t const   )397917763L,      (uint32_t const   )1622183637L, 
        (uint32_t const   )3604390888L,      (uint32_t const   )2714866558L,      (uint32_t const   )953729732L,      (uint32_t const   )1340076626L, 
        (uint32_t const   )3518719985L,      (uint32_t const   )2797360999L,      (uint32_t const   )1068828381L,      (uint32_t const   )1219638859L, 
        (uint32_t const   )3624741850L,      (uint32_t const   )2936675148L,      (uint32_t const   )906185462L,      (uint32_t const   )1090812512L, 
        (uint32_t const   )3747672003L,      (uint32_t const   )2825379669L,      (uint32_t const   )829329135L,      (uint32_t const   )1181335161L, 
        (uint32_t const   )3412177804L,      (uint32_t const   )3160834842L,      (uint32_t const   )628085408L,      (uint32_t const   )1382605366L, 
        (uint32_t const   )3423369109L,      (uint32_t const   )3138078467L,      (uint32_t const   )570562233L,      (uint32_t const   )1426400815L, 
        (uint32_t const   )3317316542L,      (uint32_t const   )2998733608L,      (uint32_t const   )733239954L,      (uint32_t const   )1555261956L, 
        (uint32_t const   )3268935591L,      (uint32_t const   )3050360625L,      (uint32_t const   )752459403L,      (uint32_t const   )1541320221L, 
        (uint32_t const   )2607071920L,      (uint32_t const   )3965973030L,      (uint32_t const   )1969922972L,      (uint32_t const   )40735498L, 
        (uint32_t const   )2617837225L,      (uint32_t const   )3943577151L,      (uint32_t const   )1913087877L,      (uint32_t const   )83908371L, 
        (uint32_t const   )2512341634L,      (uint32_t const   )3803740692L,      (uint32_t const   )2075208622L,      (uint32_t const   )213261112L, 
        (uint32_t const   )2463272603L,      (uint32_t const   )3855990285L,      (uint32_t const   )2094854071L,      (uint32_t const   )198958881L, 
        (uint32_t const   )2262029012L,      (uint32_t const   )4057260610L,      (uint32_t const   )1759359992L,      (uint32_t const   )534414190L, 
        (uint32_t const   )2176718541L,      (uint32_t const   )4139329115L,      (uint32_t const   )1873836001L,      (uint32_t const   )414664567L, 
        (uint32_t const   )2282248934L,      (uint32_t const   )4279200368L,      (uint32_t const   )1711684554L,      (uint32_t const   )285281116L, 
        (uint32_t const   )2405801727L,      (uint32_t const   )4167216745L,      (uint32_t const   )1634467795L,      (uint32_t const   )376229701L, 
        (uint32_t const   )2685067896L,      (uint32_t const   )3608007406L,      (uint32_t const   )1308918612L,      (uint32_t const   )956543938L, 
        (uint32_t const   )2808555105L,      (uint32_t const   )3495958263L,      (uint32_t const   )1231636301L,      (uint32_t const   )1047427035L, 
        (uint32_t const   )2932959818L,      (uint32_t const   )3654703836L,      (uint32_t const   )1088359270L,      (uint32_t const   )936918000L, 
        (uint32_t const   )2847714899L,      (uint32_t const   )3736837829L,      (uint32_t const   )1202900863L,      (uint32_t const   )817233897L, 
        (uint32_t const   )3183342108L,      (uint32_t const   )3401237130L,      (uint32_t const   )1404277552L,      (uint32_t const   )615818150L, 
        (uint32_t const   )3134207493L,      (uint32_t const   )3453421203L,      (uint32_t const   )1423857449L,      (uint32_t const   )601450431L, 
        (uint32_t const   )3009837614L,      (uint32_t const   )3294710456L,      (uint32_t const   )1567103746L,      (uint32_t const   )711928724L, 
        (uint32_t const   )3020668471L,      (uint32_t const   )3272380065L,      (uint32_t const   )1510334235L,      (uint32_t const   )755167117L};
#line 79 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/crc.c"
uint32_t crc32(uint8_t *s , uint32_t len ) 
{ 
  uint32_t i ;
  uint32_t val ;

  {
#line 81
  val = (uint32_t )0;
#line 83
  i = (uint32_t )0;
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    if (! (i < len)) {
#line 83
      goto while_break;
    }
#line 84
    val = (uint32_t )(crc32_tab[(val ^ (unsigned int )*(s + i)) & 255U] ^ (unsigned int const   )(val >> 8));
#line 83
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  return (val);
}
}
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/crunchfc.h"
int8_t verify_fconfig(struct config_data *data ) ;
#line 36
int8_t get_key_value(struct config_data *data , uint8_t *nickname ) ;
#line 37
int8_t set_key_value(struct config_data *data , uint8_t *nickname , void *value ) ;
#line 38
int8_t list_keys(struct config_data *data ) ;
#line 39
void recalculate_crc(struct config_data *data ) ;
#line 63 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/crunchfc.c"
__inline static void fix_endian32(void *vptr , uint8_t swab ) 
{ 
  uint8_t *ptr ;
  uint8_t tmp ;

  {
#line 65
  ptr = (uint8_t *)vptr;
#line 67
  if (! swab) {
#line 68
    return;
  }
#line 70
  tmp = *ptr;
#line 71
  *ptr = *(ptr + 3);
#line 72
  *(ptr + 3) = tmp;
#line 73
  tmp = *(ptr + 1);
#line 74
  *(ptr + 1) = *(ptr + 2);
#line 75
  *(ptr + 2) = tmp;
#line 76
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/crunchfc.c"
static uint8_t *get_key(uint8_t *ptr , struct fconfig_key *key ) 
{ 
  uint8_t *tmp ;
  uint8_t *tmp___0 ;
  uint8_t *tmp___1 ;
  uint8_t *tmp___2 ;
  int8_t tmp___3 ;

  {
  {
#line 97
  tmp = ptr;
#line 97
  ptr ++;
#line 97
  key->type = *tmp;
#line 98
  tmp___0 = ptr;
#line 98
  ptr ++;
#line 98
  key->namelen = *tmp___0;
#line 99
  tmp___1 = ptr;
#line 99
  ptr ++;
#line 99
  key->ensense = *tmp___1;
#line 100
  tmp___2 = ptr;
#line 100
  ptr ++;
#line 100
  key->enlen = *tmp___2;
#line 101
  key->keyname = ptr;
#line 102
  ptr += (int )key->namelen;
#line 103
  key->enkey = ptr;
#line 104
  ptr += (int )key->enlen;
#line 111
  key->dataval = ptr;
#line 113
  tmp___3 = verify_ftype(key->type);
  }
#line 113
  if (! tmp___3) {
    {
#line 114
    while (1) {
      while_continue: /* CIL Label */ ;
#line 114
      if (1 <= (int )verbosity) {
        {
#line 114
        printf((char const   */* __restrict  */)"Unsupported type: %d\n", (int )key->type);
        }
      }
#line 114
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 115
    return ((uint8_t *)((void *)0));
  }
#line 118
  ptr += (int )types[key->type].type_size;
#line 120
  return (ptr);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/crunchfc.c"
static void print_key(struct fconfig_key *key , uint8_t verb , uint8_t swab ) 
{ 
  uint8_t buf[4096] ;
  void (*printer)(void *buf ) ;

  {
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 132
    if ((int )verb <= (int )verbosity) {
      {
#line 132
      printf((char const   */* __restrict  */)"\n");
      }
    }
#line 132
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 133
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 133
    if ((int )verb <= (int )verbosity) {
      {
#line 133
      printf((char const   */* __restrict  */)"Name length: %d\n", (int )key->namelen);
      }
    }
#line 133
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 134
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 134
    if ((int )verb <= (int )verbosity) {
      {
#line 134
      printf((char const   */* __restrict  */)"Enable sense: %d\n", (int )key->ensense);
      }
    }
#line 134
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 135
  if ((int )key->ensense == 0) {
    {
#line 136
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 136
      if ((int )verb <= (int )verbosity) {
        {
#line 136
        printf((char const   */* __restrict  */)"Enable key length: %d\n", (int )key->enlen);
        }
      }
#line 136
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 137
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 137
      if ((int )verb <= (int )verbosity) {
        {
#line 137
        printf((char const   */* __restrict  */)"Enable key: %s\n", key->enkey);
        }
      }
#line 137
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  {
#line 139
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 139
    if ((int )verb <= (int )verbosity) {
      {
#line 139
      printf((char const   */* __restrict  */)"Key name: %s\n", key->keyname);
      }
    }
#line 139
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 140
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 140
    if ((int )verb <= (int )verbosity) {
      {
#line 140
      printf((char const   */* __restrict  */)"Value: ");
      }
    }
#line 140
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 141
  if ((int )verb <= (int )verbosity) {
    {
#line 142
    memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)key->dataval,
           (size_t )types[key->type].type_size);
    }
    {
#line 145
    if ((int )key->type == 2) {
#line 145
      goto case_2;
    }
#line 145
    if ((int )key->type == 1) {
#line 145
      goto case_2;
    }
#line 148
    goto switch_default;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
    {
#line 146
    fix_endian32((void *)(buf), swab);
    }
#line 147
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 149
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 151
    printer = types[key->type].printer;
#line 152
    if (printer) {
      {
#line 153
      (*printer)((void *)(buf));
      }
    }
  }
  {
#line 156
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 156
    if ((int )verb <= (int )verbosity) {
      {
#line 156
      printf((char const   */* __restrict  */)"\n");
      }
    }
#line 156
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 157
  return;
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/crunchfc.c"
static uint8_t *locate_key(struct config_data *data , uint8_t *nickname ) 
{ 
  struct fconfig_key key ;
  uint32_t len ;
  uint8_t *keyptr ;
  uint8_t *ptr ;
  uint8_t *ptrend ;
  int tmp ;

  {
#line 166
  len = data->reallen;
#line 167
  keyptr = (uint8_t *)((void *)0);
#line 168
  ptr = data->buf + 8;
#line 169
  ptrend = (data->buf + len) - 9;
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 171
    if (! ((unsigned long )ptr < (unsigned long )(ptrend - 4))) {
#line 171
      goto while_break;
    }
    {
#line 172
    keyptr = ptr;
#line 173
    ptr = get_key(ptr, & key);
    }
#line 174
    if ((unsigned long )ptr == (unsigned long )((void *)0)) {
      {
#line 175
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 175
        if (1 <= (int )verbosity) {
          {
#line 175
          printf((char const   */* __restrict  */)"Error in structure\n");
          }
        }
#line 175
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 176
      return ((uint8_t *)((void *)0));
    }
#line 178
    if ((unsigned long )ptr > (unsigned long )ptrend) {
      {
#line 179
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 179
        if (1 <= (int )verbosity) {
          {
#line 179
          printf((char const   */* __restrict  */)"Parser went out of struct!\n");
          }
        }
#line 179
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 180
      return ((uint8_t *)((void *)0));
    }
#line 183
    if ((int )key.type == 0) {
#line 183
      if ((int )key.namelen == 0) {
        {
#line 184
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 184
          if (2 <= (int )verbosity) {
            {
#line 184
            printf((char const   */* __restrict  */)"EOF reached - key not found\n");
            }
          }
#line 184
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 185
        return ((uint8_t *)((void *)0));
      }
    }
    {
#line 188
    tmp = strncmp((char const   *)nickname, (char const   *)key.keyname, (size_t )key.namelen);
    }
#line 188
    if (tmp == 0) {
#line 189
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  return (keyptr);
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/crunchfc.c"
static int8_t buf_check(struct config_data *data ) 
{ 
  struct fconfig_key key ;
  uint32_t len ;
  uint8_t *ptr ;
  uint8_t *ptrend ;

  {
#line 201
  len = data->reallen;
#line 202
  ptr = data->buf + 8;
#line 203
  ptrend = (data->buf + len) - 9;
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 205
    if (! ((unsigned long )ptr < (unsigned long )(ptrend - 4))) {
#line 205
      goto while_break;
    }
    {
#line 206
    ptr = get_key(ptr, & key);
    }
#line 207
    if ((unsigned long )ptr == (unsigned long )((void *)0)) {
      {
#line 208
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 208
        if (1 <= (int )verbosity) {
          {
#line 208
          printf((char const   */* __restrict  */)"Error in structure\n");
          }
        }
#line 208
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 209
      return ((int8_t )-1);
    }
#line 211
    if ((unsigned long )ptr > (unsigned long )ptrend) {
      {
#line 212
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 212
        if (1 <= (int )verbosity) {
          {
#line 212
          printf((char const   */* __restrict  */)"Parser went out of struct!\n");
          }
        }
#line 212
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 213
      return ((int8_t )-1);
    }
#line 216
    if ((int )key.type == 0) {
#line 216
      if ((int )key.namelen == 0) {
        {
#line 217
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 217
          if (3 <= (int )verbosity) {
            {
#line 217
            printf((char const   */* __restrict  */)"EOF reached - structure OK\n");
            }
          }
#line 217
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 218
        return ((int8_t )0);
      }
    }
    {
#line 220
    print_key(& key, (uint8_t )3, data->swab);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return ((int8_t )0);
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/crunchfc.c"
int8_t verify_fconfig(struct config_data *data ) 
{ 
  uint32_t len ;
  uint32_t key ;
  uint32_t crc ;
  uint32_t maxlen ;
  uint8_t *buf ;
  uint8_t swab ;
  uint32_t tmp ;
  int8_t tmp___0 ;

  {
#line 240
  buf = data->buf;
#line 241
  maxlen = data->maxlen;
#line 243
  swab = (uint8_t )0;
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    if (! ((int )swab < 2)) {
#line 243
      goto while_break;
    }
    {
#line 244
    memcpy((void */* __restrict  */)(& key), (void const   */* __restrict  */)(buf + 4),
           sizeof(key));
#line 245
    fix_endian32((void *)(& key), swab);
    }
#line 246
    if (key == 195951310U) {
#line 247
      goto while_break;
    }
#line 243
    swab = (uint8_t )((int )swab + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 250
  if ((int )swab == 0) {
    {
#line 251
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 251
      if (3 <= (int )verbosity) {
        {
#line 251
        printf((char const   */* __restrict  */)"Using native endianness\n");
        }
      }
#line 251
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 252
  if ((int )swab == 1) {
    {
#line 253
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 253
      if (3 <= (int )verbosity) {
        {
#line 253
        printf((char const   */* __restrict  */)"Using non-native endianness\n");
        }
      }
#line 253
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 255
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 255
      if (2 <= (int )verbosity) {
        {
#line 255
        printf((char const   */* __restrict  */)"Key1 is not valid, terminating\n");
        }
      }
#line 255
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 256
    return ((int8_t )-1);
  }
  {
#line 259
  memcpy((void */* __restrict  */)(& len), (void const   */* __restrict  */)buf, sizeof(len));
#line 260
  fix_endian32((void *)(& len), swab);
  }
  {
#line 262
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 262
    if (2 <= (int )verbosity) {
      {
#line 262
      printf((char const   */* __restrict  */)"Data length is %d, maxlen is %d\n",
             len, maxlen);
      }
    }
#line 262
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 264
  if (len > maxlen) {
    {
#line 265
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 265
      if (2 <= (int )verbosity) {
        {
#line 265
        printf((char const   */* __restrict  */)"This is too long.\n");
        }
      }
#line 265
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 266
    return ((int8_t )-1);
  }
  {
#line 269
  memcpy((void */* __restrict  */)(& key), (void const   */* __restrict  */)((buf + len) - 8),
         sizeof(key));
#line 270
  fix_endian32((void *)(& key), swab);
  }
#line 271
  if (key != 3735936685U) {
    {
#line 272
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 272
      if (2 <= (int )verbosity) {
        {
#line 272
        printf((char const   */* __restrict  */)"Key2 is not valid, terminating\n");
        }
      }
#line 272
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 273
    return ((int8_t )-1);
  }
  {
#line 277
  memcpy((void */* __restrict  */)(& crc), (void const   */* __restrict  */)((buf + len) - 4),
         sizeof(crc));
#line 278
  fix_endian32((void *)(& crc), swab);
#line 279
  tmp = crc32(buf, len - 4U);
  }
#line 279
  if (crc != tmp) {
    {
#line 280
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 280
      if (2 <= (int )verbosity) {
        {
#line 280
        printf((char const   */* __restrict  */)"CRC verification failed.\n");
        }
      }
#line 280
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 281
    return ((int8_t )-1);
  }
  {
#line 283
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 283
    if (2 <= (int )verbosity) {
      {
#line 283
      printf((char const   */* __restrict  */)"CRC is valid.\n");
      }
    }
#line 283
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 285
  data->swab = swab;
#line 286
  data->reallen = len;
#line 288
  tmp___0 = buf_check(data);
  }
#line 288
  if (tmp___0) {
    {
#line 289
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 289
      if (2 <= (int )verbosity) {
        {
#line 289
        printf((char const   */* __restrict  */)"Configuration structure is broken.\n");
        }
      }
#line 289
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 290
    return ((int8_t )-1);
  }
#line 293
  return ((int8_t )0);
}
}
#line 300 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/crunchfc.c"
int8_t get_key_value(struct config_data *data , uint8_t *nickname ) 
{ 
  void (*printer)(void *buf ) ;
  struct fconfig_key key ;
  uint8_t *ptr ;
  uint8_t *tmp ;

  {
  {
#line 306
  ptr = locate_key(data, nickname);
  }
#line 307
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
#line 308
    while (1) {
      while_continue: /* CIL Label */ ;
#line 308
      if (1 <= (int )verbosity) {
        {
#line 308
        printf((char const   */* __restrict  */)"Unknown key.\n");
        }
      }
#line 308
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 309
    return ((int8_t )-1);
  }
  {
#line 311
  tmp = get_key(ptr, & key);
  }
#line 311
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 312
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 312
      if (1 <= (int )verbosity) {
        {
#line 312
        printf((char const   */* __restrict  */)"Erroneous key.\n");
        }
      }
#line 312
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 313
    return ((int8_t )-1);
  }
  {
#line 315
  print_key(& key, (uint8_t )3, data->swab);
#line 317
  printer = types[key.type].printer;
  }
#line 318
  if ((unsigned long )printer == (unsigned long )((void *)0)) {
    {
#line 319
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 319
      if (1 <= (int )verbosity) {
        {
#line 319
        printf((char const   */* __restrict  */)"Printer missing for type %d\n", (int )key.type);
        }
      }
#line 319
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 320
    return ((int8_t )-1);
  }
  {
#line 322
  (*printer)((void *)key.dataval);
  }
#line 323
  return ((int8_t )0);
}
}
#line 329 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/crunchfc.c"
int8_t list_keys(struct config_data *data ) 
{ 
  void (*printer)(void *buf ) ;
  struct fconfig_key key ;
  uint32_t len ;
  uint8_t *keyptr ;
  uint8_t *ptr ;
  uint8_t *ptrend ;

  {
#line 333
  len = data->reallen;
#line 334
  keyptr = (uint8_t *)((void *)0);
#line 335
  ptr = data->buf + 8;
#line 336
  ptrend = (data->buf + len) - 9;
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    if (! ((unsigned long )ptr < (unsigned long )(ptrend - 4))) {
#line 338
      goto while_break;
    }
    {
#line 339
    keyptr = ptr;
#line 340
    ptr = get_key(ptr, & key);
    }
#line 341
    if ((unsigned long )ptr == (unsigned long )((void *)0)) {
      {
#line 342
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 342
        if (1 <= (int )verbosity) {
          {
#line 342
          printf((char const   */* __restrict  */)"Error in structure\n");
          }
        }
#line 342
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 343
      return ((int8_t )-1);
    }
#line 345
    if ((unsigned long )ptr > (unsigned long )ptrend) {
      {
#line 346
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 346
        if (1 <= (int )verbosity) {
          {
#line 346
          printf((char const   */* __restrict  */)"Parser went out of struct!\n");
          }
        }
#line 346
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 347
      return ((int8_t )-1);
    }
#line 350
    if ((int )key.type == 0) {
#line 350
      if ((int )key.namelen == 0) {
        {
#line 351
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 351
          if (2 <= (int )verbosity) {
            {
#line 351
            printf((char const   */* __restrict  */)"EOF reached\n");
            }
          }
#line 351
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 352
        return ((int8_t )-1);
      }
    }
    {
#line 355
    print_key(& key, (uint8_t )3, data->swab);
#line 357
    printf((char const   */* __restrict  */)"%s: ", key.keyname);
#line 358
    printer = types[key.type].printer;
    }
#line 359
    if ((unsigned long )printer == (unsigned long )((void *)0)) {
      {
#line 360
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 360
        if (1 <= (int )verbosity) {
          {
#line 360
          printf((char const   */* __restrict  */)"Printer missing for type %d\n",
                 (int )key.type);
          }
        }
#line 360
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 362
      return ((int8_t )-1);
    }
    {
#line 364
    (*printer)((void *)key.dataval);
#line 365
    printf((char const   */* __restrict  */)"\n");
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 367
  return ((signed char)0);
}
}
#line 373 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/crunchfc.c"
int8_t set_key_value(struct config_data *data , uint8_t *nickname , void *value ) 
{ 
  uint32_t offset ;
  uint8_t buf[4096] ;
  int8_t (*parser)(uint8_t *text , void *buf ) ;
  struct fconfig_key key ;
  uint8_t *ptr ;
  uint8_t *tmp ;
  int8_t tmp___0 ;
  __off_t tmp___1 ;
  ssize_t tmp___2 ;

  {
  {
#line 381
  ptr = locate_key(data, nickname);
  }
#line 382
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
#line 383
    while (1) {
      while_continue: /* CIL Label */ ;
#line 383
      if (1 <= (int )verbosity) {
        {
#line 383
        printf((char const   */* __restrict  */)"Unknown key.\n");
        }
      }
#line 383
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 384
    return ((int8_t )-1);
  }
  {
#line 386
  tmp = get_key(ptr, & key);
  }
#line 386
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 387
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 387
      if (1 <= (int )verbosity) {
        {
#line 387
        printf((char const   */* __restrict  */)"Erroneous key.\n");
        }
      }
#line 387
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 388
    return ((int8_t )-1);
  }
  {
#line 391
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 391
    if (2 <= (int )verbosity) {
      {
#line 391
      printf((char const   */* __restrict  */)"\nBefore change:");
      }
    }
#line 391
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 392
  print_key(& key, (uint8_t )2, data->swab);
#line 394
  parser = types[key.type].parser;
  }
#line 395
  if ((unsigned long )parser == (unsigned long )((void *)0)) {
    {
#line 396
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 396
      if (1 <= (int )verbosity) {
        {
#line 396
        printf((char const   */* __restrict  */)"Parser missing for type %d\n", (int )key.type);
        }
      }
#line 396
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 397
    return ((int8_t )-1);
  }
  {
#line 400
  memset((void *)(buf), 0, (size_t )4096);
#line 401
  tmp___0 = (*parser)((uint8_t *)value, (void *)(buf));
  }
#line 401
  if (tmp___0) {
    {
#line 402
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 402
      if (1 <= (int )verbosity) {
        {
#line 402
        printf((char const   */* __restrict  */)"Bad value.\n");
        }
      }
#line 402
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 403
    return ((int8_t )-1);
  }
#line 406
  offset = (uint32_t )(key.dataval - data->buf);
  {
#line 407
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 407
    if (3 <= (int )verbosity) {
      {
#line 407
      printf((char const   */* __restrict  */)"Writing %d bytes at offset %d\n", (int )types[key.type].type_size,
             offset);
      }
    }
#line 407
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 411
  tmp___1 = lseek(data->fd, (__off_t )((uint32_t )data->offset + offset), 0);
  }
#line 411
  if (tmp___1 == -1L) {
    {
#line 412
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 412
      if (1 <= (int )verbosity) {
        {
#line 412
        printf((char const   */* __restrict  */)"lseek() failed\n");
        }
      }
#line 412
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 413
    return ((int8_t )-1);
  }
  {
#line 415
  tmp___2 = write(data->fd, (void const   *)(buf), (size_t )types[key.type].type_size);
  }
#line 415
  if (tmp___2 == -1L) {
    {
#line 416
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 416
      if (1 <= (int )verbosity) {
        {
#line 416
        printf((char const   */* __restrict  */)"write() failed\n");
        }
      }
#line 416
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 417
    return ((int8_t )-1);
  }
  {
#line 420
  memcpy((void */* __restrict  */)key.dataval, (void const   */* __restrict  */)(buf),
         (size_t )types[key.type].type_size);
  }
  {
#line 422
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 422
    if (2 <= (int )verbosity) {
      {
#line 422
      printf((char const   */* __restrict  */)"\nAfter change:");
      }
    }
#line 422
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 423
  print_key(& key, (uint8_t )2, data->swab);
  }
#line 425
  return ((int8_t )0);
}
}
#line 432 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/crunchfc.c"
void recalculate_crc(struct config_data *data ) 
{ 
  uint32_t len ;
  uint32_t crc ;
  uint8_t *buf ;
  uint8_t swab ;
  __off_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 439
  len = data->reallen;
#line 440
  buf = data->buf;
#line 441
  swab = data->swab;
#line 444
  memcpy((void */* __restrict  */)(& crc), (void const   */* __restrict  */)((buf + len) - 4),
         sizeof(crc));
#line 445
  fix_endian32((void *)(& crc), swab);
  }
  {
#line 446
  while (1) {
    while_continue: /* CIL Label */ ;
#line 446
    if (2 <= (int )verbosity) {
      {
#line 446
      printf((char const   */* __restrict  */)"Old CRC: %04x\n", crc);
      }
    }
#line 446
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 449
  crc = crc32(buf, len - 4U);
#line 450
  fix_endian32((void *)(& crc), swab);
  }
  {
#line 452
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 452
    if (3 <= (int )verbosity) {
      {
#line 452
      printf((char const   */* __restrict  */)"Writing CRC at offset %d\n", len - 4U);
      }
    }
#line 452
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 455
  tmp = lseek(data->fd, (__off_t )(((uint32_t )data->offset + len) - 4U), 0);
  }
#line 455
  if (tmp == -1L) {
    {
#line 456
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 456
      if (1 <= (int )verbosity) {
        {
#line 456
        printf((char const   */* __restrict  */)"CRC: lseek() failed\n");
        }
      }
#line 456
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 457
    return;
  }
  {
#line 459
  tmp___0 = write(data->fd, (void const   *)(& crc), sizeof(crc));
  }
#line 459
  if (tmp___0 == -1L) {
    {
#line 460
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 460
      if (1 <= (int )verbosity) {
        {
#line 460
        printf((char const   */* __restrict  */)"CRC: write() failed\n");
        }
      }
#line 460
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 461
    return;
  }
  {
#line 464
  memcpy((void */* __restrict  */)((buf + len) - 4), (void const   */* __restrict  */)(& crc),
         sizeof(crc));
#line 467
  memcpy((void */* __restrict  */)(& crc), (void const   */* __restrict  */)((buf + len) - 4),
         sizeof(crc));
#line 468
  fix_endian32((void *)(& crc), swab);
  }
  {
#line 469
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 469
    if (2 <= (int )verbosity) {
      {
#line 469
      printf((char const   */* __restrict  */)"New CRC: %04x\n", crc);
      }
    }
#line 469
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 470
  return;
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 72 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/fconfig.c"
static void usage(void) 
{ 
  uint8_t i ;

  {
#line 75
  if ((int )verbosity == 0) {
#line 76
    return;
  }
  {
#line 79
  fputs((char const   */* __restrict  */)"Read, write or list Redboot configuration\n",
        (FILE */* __restrict  */)stdout);
#line 80
  fputs((char const   */* __restrict  */)"usage: fconfig [-r|-w|-l] -d dev -o offset -n nickname -x value\n",
        (FILE */* __restrict  */)stdout);
#line 82
  fputs((char const   */* __restrict  */)"\'dev\' may be a char device, block device or a file\n",
        (FILE */* __restrict  */)stdout);
#line 83
  fputs((char const   */* __restrict  */)"\'offset\' is the offset in bytes on the device\n",
        (FILE */* __restrict  */)stdout);
#line 84
  fputs((char const   */* __restrict  */)"Supported types: \n", (FILE */* __restrict  */)stdout);
#line 85
  i = (uint8_t )0;
  }
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! ((int )i < 8)) {
#line 85
      goto while_break;
    }
    {
#line 86
    printf((char const   */* __restrict  */)" - %s\n", types[i].type_name);
#line 85
    i = (uint8_t )((int )i + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 88
  fputs((char const   */* __restrict  */)"Additional switches: \n", (FILE */* __restrict  */)stdout);
#line 89
  fputs((char const   */* __restrict  */)" -v:\tVerbose mode, use more to increase verbosity\n",
        (FILE */* __restrict  */)stdout);
#line 90
  fputs((char const   */* __restrict  */)" -s:\tSilent mode, absolutely no messages printed\n",
        (FILE */* __restrict  */)stdout);
  }
#line 91
  return;
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/fconfig.c"
static uint8_t buffer[4096]  ;
#line 103 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/fconfig.c"
struct config_data *get_fconfig_handle(struct config_data *data , uint8_t *dev , int offset ,
                                       mode_t mode ) 
{ 
  uint16_t count ;
  int tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 108
  tmp = open((char const   *)dev, (int )mode);
#line 108
  data->fd = tmp;
  }
#line 108
  if (tmp < 0) {
    {
#line 109
    while (1) {
      while_continue: /* CIL Label */ ;
#line 109
      if (1 <= (int )verbosity) {
        {
#line 109
        printf((char const   */* __restrict  */)"Failed to open device or file %s!\n",
               dev);
        }
      }
#line 109
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 110
    return ((struct config_data *)((void *)0));
  }
#line 113
  data->offset = offset;
#line 114
  if (data->offset > 0) {
    {
#line 115
    lseek(data->fd, (__off_t )data->offset, 0);
    }
  }
  {
#line 117
  tmp___0 = read(data->fd, (void *)(buffer), (size_t )4096);
#line 117
  count = (uint16_t )tmp___0;
  }
#line 118
  if ((int )count <= 0) {
    {
#line 119
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 119
      if (1 <= (int )verbosity) {
        {
#line 119
        printf((char const   */* __restrict  */)"Nothing read!\n");
        }
      }
#line 119
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 120
    close(data->fd);
    }
#line 121
    return ((struct config_data *)((void *)0));
  }
  {
#line 123
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 123
    if (2 <= (int )verbosity) {
      {
#line 123
      printf((char const   */* __restrict  */)"Read %d bytes\n", (int )count);
      }
    }
#line 123
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 125
  data->buf = buffer;
#line 126
  data->maxlen = (uint32_t )count;
#line 127
  return (data);
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/fconfig.c"
void close_fconfig_handle(struct config_data *data ) 
{ 


  {
  {
#line 136
  close(data->fd);
  }
#line 137
  return;
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/fconfig.c"
static int write_mode(uint8_t *device , int offset , uint8_t *nickname , uint8_t *value ) 
{ 
  struct config_data data ;
  struct config_data *tmp ;
  int8_t tmp___0 ;
  int8_t tmp___1 ;

  {
#line 146
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    {
#line 147
    while (1) {
      while_continue: /* CIL Label */ ;
#line 147
      if (1 <= (int )verbosity) {
        {
#line 147
        printf((char const   */* __restrict  */)"You must provide a value in WRITE mode\n");
        }
      }
#line 147
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 148
    return (1);
  }
  {
#line 151
  tmp = get_fconfig_handle(& data, device, offset, (mode_t )2);
  }
#line 151
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 152
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 152
      if (1 <= (int )verbosity) {
        {
#line 152
        printf((char const   */* __restrict  */)"Could not get a config data handle!\n");
        }
      }
#line 152
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 153
    return (1);
  }
  {
#line 155
  tmp___0 = verify_fconfig(& data);
  }
#line 155
  if (tmp___0) {
    {
#line 156
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 156
      if (1 <= (int )verbosity) {
        {
#line 156
        printf((char const   */* __restrict  */)"Config verification failed!\n");
        }
      }
#line 156
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 157
    goto exit_fail;
  }
  {
#line 160
  tmp___1 = set_key_value(& data, nickname, (void *)value);
  }
#line 160
  if (tmp___1) {
#line 161
    goto exit_fail;
  }
  {
#line 164
  recalculate_crc(& data);
#line 166
  close_fconfig_handle(& data);
  }
#line 167
  return (0);
  exit_fail: 
  {
#line 170
  close_fconfig_handle(& data);
  }
#line 171
  return (1);
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/fconfig.c"
static int read_mode(uint8_t *device , int offset , uint8_t *nickname ) 
{ 
  struct config_data data ;
  struct config_data *tmp ;
  int8_t tmp___0 ;
  int8_t tmp___1 ;

  {
  {
#line 180
  tmp = get_fconfig_handle(& data, device, offset, (mode_t )0);
  }
#line 180
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 181
    while (1) {
      while_continue: /* CIL Label */ ;
#line 181
      if (1 <= (int )verbosity) {
        {
#line 181
        printf((char const   */* __restrict  */)"Could not get a config data handle!\n");
        }
      }
#line 181
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 182
    return (1);
  }
  {
#line 184
  tmp___0 = verify_fconfig(& data);
  }
#line 184
  if (tmp___0) {
    {
#line 185
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 185
      if (1 <= (int )verbosity) {
        {
#line 185
        printf((char const   */* __restrict  */)"Config verification failed!\n");
        }
      }
#line 185
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 186
    goto exit_fail;
  }
  {
#line 189
  tmp___1 = get_key_value(& data, nickname);
  }
#line 189
  if (tmp___1) {
#line 190
    goto exit_fail;
  }
  {
#line 193
  close_fconfig_handle(& data);
  }
#line 194
  return (0);
  exit_fail: 
  {
#line 197
  close_fconfig_handle(& data);
  }
#line 198
  return (1);
}
}
#line 204 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/fconfig.c"
static int list_mode(uint8_t *device , int offset ) 
{ 
  struct config_data data ;
  struct config_data *tmp ;
  int8_t tmp___0 ;
  int8_t tmp___1 ;

  {
  {
#line 207
  tmp = get_fconfig_handle(& data, device, offset, (mode_t )0);
  }
#line 207
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 208
    while (1) {
      while_continue: /* CIL Label */ ;
#line 208
      if (1 <= (int )verbosity) {
        {
#line 208
        printf((char const   */* __restrict  */)"Could not get a config data handle!\n");
        }
      }
#line 208
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 209
    return (1);
  }
  {
#line 211
  tmp___0 = verify_fconfig(& data);
  }
#line 211
  if (tmp___0) {
    {
#line 212
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 212
      if (1 <= (int )verbosity) {
        {
#line 212
        printf((char const   */* __restrict  */)"Config verification failed!\n");
        }
      }
#line 212
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 213
    goto exit_fail;
  }
  {
#line 216
  tmp___1 = list_keys(& data);
  }
#line 216
  if (tmp___1) {
#line 217
    goto exit_fail;
  }
  {
#line 220
  close_fconfig_handle(& data);
  }
#line 221
  return (0);
  exit_fail: 
  {
#line 224
  close_fconfig_handle(& data);
  }
#line 225
  return (1);
}
}
#line 236 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fconfig/fconfig.c"
int main(int argc , char **argv ) 
{ 
  int c ;
  int ret ;
  uint8_t mode ;
  uint8_t *nickname ;
  uint8_t *value ;
  uint8_t *device ;
  int offset ;

  {
#line 239
  mode = (uint8_t )0;
#line 240
  nickname = (uint8_t *)((void *)0);
#line 241
  value = (uint8_t *)((void *)0);
#line 242
  device = (uint8_t *)((void *)0);
#line 243
  offset = 0;
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 245
    c = getopt(argc, (char * const  *)argv, "hrwlvsd:n:o:x:");
    }
#line 245
    if (! (c != -1)) {
#line 245
      goto while_break;
    }
    {
#line 247
    if (c == 114) {
#line 247
      goto case_114;
    }
#line 250
    if (c == 119) {
#line 250
      goto case_119;
    }
#line 253
    if (c == 108) {
#line 253
      goto case_108;
    }
#line 256
    if (c == 110) {
#line 256
      goto case_110;
    }
#line 259
    if (c == 111) {
#line 259
      goto case_111;
    }
#line 262
    if (c == 120) {
#line 262
      goto case_120;
    }
#line 265
    if (c == 118) {
#line 265
      goto case_118;
    }
#line 268
    if (c == 115) {
#line 268
      goto case_115;
    }
#line 271
    if (c == 100) {
#line 271
      goto case_100;
    }
#line 274
    if (c == 104) {
#line 274
      goto case_104;
    }
#line 278
    goto switch_default;
    case_114: /* CIL Label */ 
#line 248
    mode = (uint8_t )2;
#line 249
    goto switch_break;
    case_119: /* CIL Label */ 
#line 251
    mode = (uint8_t )1;
#line 252
    goto switch_break;
    case_108: /* CIL Label */ 
#line 254
    mode = (uint8_t )3;
#line 255
    goto switch_break;
    case_110: /* CIL Label */ 
#line 257
    nickname = (uint8_t *)optarg;
#line 258
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 260
    sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%i",
           & offset);
    }
#line 261
    goto switch_break;
    case_120: /* CIL Label */ 
#line 263
    value = (uint8_t *)optarg;
#line 264
    goto switch_break;
    case_118: /* CIL Label */ 
#line 266
    verbosity = (uint8_t )((int )verbosity + 1);
#line 267
    goto switch_break;
    case_115: /* CIL Label */ 
#line 269
    verbosity = (uint8_t )0;
#line 270
    goto switch_break;
    case_100: /* CIL Label */ 
#line 272
    device = (uint8_t *)optarg;
#line 273
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 275
    usage();
    }
#line 276
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 279
    usage();
#line 280
    exit(1);
    }
#line 281
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 285
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 285
    if (1 <= (int )verbosity) {
      {
#line 285
      printf((char const   */* __restrict  */)"Low verbosity messages are printed.\n");
      }
    }
#line 285
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 286
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 286
    if (2 <= (int )verbosity) {
      {
#line 286
      printf((char const   */* __restrict  */)"Normal verbosity messages are printed.\n");
      }
    }
#line 286
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 287
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 287
    if (3 <= (int )verbosity) {
      {
#line 287
      printf((char const   */* __restrict  */)"High verbosity messages are printed.\n");
      }
    }
#line 287
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 289
  if ((unsigned long )nickname == (unsigned long )((void *)0)) {
#line 289
    if ((int )mode != 3) {
      {
#line 290
      usage();
#line 291
      exit(1);
      }
    }
  }
#line 294
  if ((unsigned long )device == (unsigned long )((void *)0)) {
    {
#line 295
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 295
      if (1 <= (int )verbosity) {
        {
#line 295
        printf((char const   */* __restrict  */)"You must provide a device name.\n");
        }
      }
#line 295
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 296
    exit(1);
    }
  }
  {
#line 300
  if ((int )mode == 1) {
#line 300
    goto case_1;
  }
#line 303
  if ((int )mode == 2) {
#line 303
    goto case_2;
  }
#line 306
  if ((int )mode == 3) {
#line 306
    goto case_3;
  }
#line 309
  goto switch_default___0;
  case_1: /* CIL Label */ 
  {
#line 301
  ret = write_mode(device, offset, nickname, value);
  }
#line 302
  goto switch_break___0;
  case_2: /* CIL Label */ 
  {
#line 304
  ret = read_mode(device, offset, nickname);
  }
#line 305
  goto switch_break___0;
  case_3: /* CIL Label */ 
  {
#line 307
  ret = list_mode(device, offset);
  }
#line 308
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 310
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 310
    if (1 <= (int )verbosity) {
      {
#line 310
      printf((char const   */* __restrict  */)"Unknown mode of operation\n");
      }
    }
#line 310
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 311
  usage();
#line 312
  ret = 1;
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 315
  return (ret);
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off_t __offset ) ;
#line 76
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fis/fis.c"
static void fatal(char const   *msg ) 
{ 


  {
  {
#line 40
  fputs((char const   */* __restrict  */)msg, (FILE */* __restrict  */)stderr);
#line 41
  fputc('\n', stderr);
#line 42
  exit(1);
  }
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fis/fis.c"
static void warning(char const   *msg ) 
{ 


  {
  {
#line 49
  fputs((char const   */* __restrict  */)msg, (FILE */* __restrict  */)stderr);
#line 50
  fputc('\n', stderr);
  }
#line 51
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fis/fis.c"
static void *chk_malloc(size_t size ) 
{ 
  void *ptr ;
  void *tmp ;

  {
  {
#line 66
  tmp = malloc(size);
#line 66
  ptr = tmp;
  }
#line 67
  if (! ptr) {
    {
#line 68
    perror("malloc");
#line 69
    exit(1);
    }
  }
#line 71
  return (ptr);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fis/fis.c"
static void chk_read(int fd , void *buf , size_t count ) 
{ 
  size_t rc ;
  ssize_t tmp ;

  {
  {
#line 79
  tmp = read(fd, buf, count);
#line 79
  rc = (size_t )tmp;
  }
#line 80
  if (rc != count) {
#line 81
    if ((int )rc == -1) {
      {
#line 82
      perror("read");
#line 83
      exit(1);
      }
    } else {
      {
#line 85
      fatal("short read");
      }
    }
  }
#line 88
  return;
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fis/fis.c"
static void chk_write(int fd , void const   *buf , size_t count ) 
{ 
  size_t rc ;
  ssize_t tmp ;

  {
  {
#line 92
  tmp = write(fd, buf, count);
#line 92
  rc = (size_t )tmp;
  }
#line 93
  if (rc != count) {
#line 94
    if ((int )rc == -1) {
      {
#line 95
      perror("write");
#line 96
      exit(1);
      }
    } else {
      {
#line 98
      fatal("short write");
      }
    }
  }
#line 101
  return;
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fis/fis.c"
unsigned int filesize(int fd ) 
{ 
  __off_t tmp ;

  {
  {
#line 108
  tmp = lseek(fd, (__off_t )0, 2);
  }
#line 108
  return ((unsigned int )tmp);
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fis/fis.c"
static uint32_t swap_end_32(uint32_t data ) 
{ 
  uint32_t r ;

  {
#line 115
  r = data >> 24;
#line 116
  r |= (data >> 8) & 65280U;
#line 117
  r |= (data << 8) & 16711680U;
#line 118
  r |= data << 24;
#line 119
  return (r);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fis/fis.c"
static unsigned int str_to_int_maybe_hex(char const   *s ) 
{ 
  char *endptr ;
  unsigned int i ;
  unsigned long tmp ;

  {
  {
#line 130
  tmp = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& endptr),
                0);
#line 130
  i = (unsigned int )tmp;
  }
#line 131
  if ((int const   )*s != 0) {
#line 131
    if ((int )*endptr == 0) {
#line 132
      return (i);
    }
  }
  {
#line 134
  fatal("junk after number");
  }
#line 135
  return (0U);
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fis/fis.c"
static void dump_desc(FILE *f , struct fis_image_desc  const  *d ) 
{ 
  unsigned int i ;
  uint32_t offset ;
  uint32_t length ;

  {
  {
#line 154
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%16s: addr = 0x%08x, size = 0x%08x, entry = 0x%08x, length = 0x%08x, cksum = 0x%08x\n",
          d->name, d->flash_base, d->size, d->entry_point, d->data_length, d->file_cksum);
#line 157
  i = 0U;
  }
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (! ((unsigned long )i < sizeof(d->skips) / 4UL)) {
#line 157
      goto while_break;
    }
#line 158
    if (d->skips[i] == 1936419184U) {
      {
#line 159
      offset = d->skips[i + 1U];
#line 160
      length = d->skips[i + 2U];
#line 161
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                    skip: %08x + %08x\n",
              offset, length);
#line 163
      i += 2U;
      }
    } else
#line 158
    if (d->skips[i] == 1885956979U) {
      {
#line 159
      offset = d->skips[i + 1U];
#line 160
      length = d->skips[i + 2U];
#line 161
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                    skip: %08x + %08x\n",
              offset, length);
#line 163
      i += 2U;
      }
    }
#line 157
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 166
  return;
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fis/fis.c"
static unsigned int dir_size_tail(dir_t d , struct dirnode *n ) 
{ 
  unsigned int tmp ;

  {
#line 202
  if ((unsigned long )n == (unsigned long )d) {
#line 203
    return (0U);
  } else {
    {
#line 205
    tmp = dir_size_tail(d, n->next);
    }
#line 205
    return (1U + tmp);
  }
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fis/fis.c"
static unsigned int dir_size(dir_t d ) 
{ 
  unsigned int tmp ;

  {
#line 214
  if (! d) {
#line 215
    return (0U);
  } else {
    {
#line 217
    tmp = dir_size_tail(d, d->next);
    }
#line 217
    return (1U + tmp);
  }
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fis/fis.c"
static void dir_create(dir_t *dir ) 
{ 


  {
#line 226
  *dir = (dir_t )((void *)0);
#line 227
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fis/fis.c"
static void dir_append(dir_t *dir , struct fis_image_desc *d ) 
{ 
  struct dirnode *n ;
  void *tmp ;

  {
  {
#line 235
  tmp = chk_malloc(sizeof(struct dirnode ));
#line 235
  n = (struct dirnode *)tmp;
#line 236
  n->entry = d;
  }
#line 238
  if (*dir) {
#line 239
    n->next = *dir;
#line 240
    n->prev = (*dir)->prev;
#line 241
    ((*dir)->prev)->next = n;
#line 242
    (*dir)->prev = n;
  } else {
#line 244
    n->next = n;
#line 245
    n->prev = n;
#line 246
    *dir = n;
  }
#line 248
  return;
}
}
#line 255 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fis/fis.c"
static void dir_insert(dir_t *dir , iter_t after , struct fis_image_desc *d ) 
{ 
  struct dirnode *n ;
  void *tmp ;

  {
#line 258
  if (! *dir) {
    {
#line 259
    dir_append(dir, d);
    }
#line 260
    return;
  }
  {
#line 263
  tmp = chk_malloc(sizeof(struct dirnode ));
#line 263
  n = (struct dirnode *)tmp;
#line 264
  n->entry = d;
  }
#line 266
  if (! after) {
#line 267
    after = (*dir)->prev;
#line 268
    *dir = n;
  }
#line 271
  n->prev = after;
#line 272
  n->next = after->next;
#line 273
  (after->next)->prev = n;
#line 274
  after->next = n;
#line 275
  return;
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fis/fis.c"
static void dir_erase(dir_t *dir , iter_t i ) 
{ 


  {
#line 284
  if ((unsigned long )i == (unsigned long )*dir) {
#line 286
    if ((unsigned long )i->next == (unsigned long )i) {
#line 287
      *dir = (dir_t )((void *)0);
    } else {
#line 289
      *dir = i->next;
    }
  }
  {
#line 293
  (i->next)->prev = i->prev;
#line 294
  (i->prev)->next = i->next;
#line 296
  free((void *)i->entry);
#line 297
  free((void *)i);
  }
#line 298
  return;
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fis/fis.c"
static void check_dev(char const   *device ) 
{ 


  {
#line 320
  if (! *(device + 0)) {
    {
#line 321
    fatal("You must specify a device using -d");
    }
  }
#line 323
  return;
}
}
#line 326 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fis/fis.c"
void check_checksum(struct fis_image_desc  const  *d ) 
{ 


  {
#line 331
  return;
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fis/fis.c"
void compute_checksum(struct fis_image_desc *d ) 
{ 


  {
#line 336
  return;
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fis/fis.c"
static void swap_entry_endianness(struct fis_image_desc *d ) 
{ 
  unsigned int i ;

  {
  {
#line 341
  d->flash_base = swap_end_32(d->flash_base);
#line 342
  d->mem_base = swap_end_32(d->mem_base);
#line 343
  d->size = swap_end_32(d->size);
#line 344
  d->entry_point = swap_end_32(d->entry_point);
#line 345
  d->data_length = swap_end_32(d->data_length);
#line 346
  i = 0U;
  }
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 346
    if (! ((unsigned long )i < sizeof(d->skips) / 4UL)) {
#line 346
      goto while_break;
    }
    {
#line 347
    d->skips[i] = swap_end_32(d->skips[i]);
#line 346
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 349
  return;
}
}
#line 352 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fis/fis.c"
static void load_dir(int fd , int offset , int *size_p , _Bool swap_endianness , dir_t *dir ) 
{ 
  unsigned int tmp ;
  __off_t tmp___0 ;
  int num_entries ;
  int i ;
  struct fis_image_desc *d ;
  void *tmp___1 ;

  {
  {
#line 355
  dir_create(dir);
  }
#line 356
  if (*size_p == -1) {
    {
#line 357
    tmp = filesize(fd);
#line 357
    *size_p = (int )(tmp - (unsigned int )offset);
    }
  }
  {
#line 359
  tmp___0 = lseek(fd, (__off_t )offset, 0);
  }
#line 359
  if (tmp___0 == -1L) {
    {
#line 359
    perror("lseek(fd,offset,SEEK_SET)");
#line 359
    exit(1);
    }
  }
#line 360
  num_entries = (int )((unsigned long )*size_p / sizeof(struct fis_image_desc ));
#line 361
  i = 0;
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! (i < num_entries)) {
#line 361
      goto while_break;
    }
    {
#line 362
    tmp___1 = chk_malloc(sizeof(struct fis_image_desc ));
#line 362
    d = (struct fis_image_desc *)tmp___1;
#line 363
    chk_read(fd, (void *)d, sizeof(struct fis_image_desc ));
    }
#line 364
    if ((int )d->name[0] != 255) {
      {
#line 365
      check_checksum((struct fis_image_desc  const  *)d);
      }
#line 366
      if (swap_endianness) {
        {
#line 367
        swap_entry_endianness(d);
        }
      }
      {
#line 369
      dir_append(dir, d);
      }
    } else
#line 371
    if ((int )d->name[1] == 255) {
#line 371
      goto while_break;
    }
#line 361
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  return;
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fis/fis.c"
static void write_blank_entries(int fd , int n ) 
{ 
  char dummy[sizeof(struct fis_image_desc )] ;
  unsigned int i ;
  int i___0 ;

  {
#line 380
  i = 0U;
  {
#line 380
  while (1) {
    while_continue: /* CIL Label */ ;
#line 380
    if (! ((unsigned long )i < sizeof(struct fis_image_desc ))) {
#line 380
      goto while_break;
    }
#line 381
    dummy[i] = (char)-1;
#line 380
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 383
  i___0 = 0;
  {
#line 383
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 383
    if (! (i___0 < n)) {
#line 383
      goto while_break___0;
    }
    {
#line 384
    chk_write(fd, (void const   *)(dummy), sizeof(struct fis_image_desc ));
#line 383
    i___0 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 386
  return;
}
}
#line 389 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fis/fis.c"
static void save_dir(int fd , int offset , int size , _Bool swap_endianness , dir_t const   dir ) 
{ 
  __off_t tmp ;
  unsigned int num_entries ;
  unsigned int tmp___0 ;
  iter_t i ;
  unsigned int tmp___1 ;

  {
  {
#line 392
  tmp = lseek(fd, (__off_t )offset, 0);
  }
#line 392
  if (tmp == -1L) {
    {
#line 392
    perror("lseek(fd,offset,SEEK_SET)");
#line 392
    exit(1);
    }
  }
  {
#line 393
  num_entries = (unsigned int )((unsigned long )size / sizeof(struct fis_image_desc ));
#line 394
  tmp___0 = dir_size((dir_t )dir);
  }
#line 394
  if (num_entries < tmp___0) {
    {
#line 395
    fatal("Too many entries for directory");
    }
  }
#line 397
  i = (iter_t )dir;
  {
#line 397
  while (1) {
    while_continue: /* CIL Label */ ;
#line 397
    if (! i) {
#line 397
      goto while_break;
    }
    {
#line 398
    compute_checksum(i->entry);
    }
#line 399
    if (swap_endianness) {
      {
#line 400
      swap_entry_endianness(i->entry);
      }
    }
    {
#line 402
    chk_write(fd, (void const   *)i->entry, sizeof(struct fis_image_desc ));
    }
#line 397
    if ((unsigned long )i->next == (unsigned long )dir) {
#line 397
      i = (iter_t )((void *)0);
    } else {
#line 397
      i = i->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 404
  tmp___1 = dir_size((dir_t )dir);
#line 404
  write_blank_entries(fd, (int )(num_entries - tmp___1));
  }
#line 405
  return;
}
}
#line 408 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fis/fis.c"
static void fis_list(char const   *device , int offset , int size , _Bool swap_endianness ) 
{ 
  int fd ;
  dir_t dir ;
  iter_t i ;

  {
  {
#line 411
  fd = open(device, 0);
  }
#line 411
  if (fd == -1) {
    {
#line 411
    perror("fd=open(device,O_RDONLY)");
#line 411
    exit(1);
    }
  }
  {
#line 413
  load_dir(fd, offset, & size, swap_endianness, & dir);
#line 414
  i = dir;
  }
  {
#line 414
  while (1) {
    while_continue: /* CIL Label */ ;
#line 414
    if (! i) {
#line 414
      goto while_break;
    }
    {
#line 415
    dump_desc(stdout, (struct fis_image_desc  const  *)i->entry);
    }
#line 414
    if ((unsigned long )i->next == (unsigned long )dir) {
#line 414
      i = (iter_t )((void *)0);
    } else {
#line 414
      i = i->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 417
  return;
}
}
#line 420 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fis/fis.c"
static void fis_init(char const   *device , int offset , int size ) 
{ 
  int fd ;
  __off_t tmp ;
  int num_entries ;

  {
#line 422
  if (size == -1) {
    {
#line 423
    fatal("size must be specified using -s");
    }
  }
  {
#line 426
  fd = open(device, 66, 438);
  }
#line 426
  if (fd == -1) {
    {
#line 426
    perror("fd=open(device,O_CREAT|O_RDWR,0666)");
#line 426
    exit(1);
    }
  }
  {
#line 427
  tmp = lseek(fd, (__off_t )offset, 0);
  }
#line 427
  if (tmp == -1L) {
    {
#line 427
    perror("lseek(fd,offset,SEEK_SET)");
#line 427
    exit(1);
    }
  }
  {
#line 428
  num_entries = (int )((unsigned long )size / sizeof(struct fis_image_desc ));
#line 429
  write_blank_entries(fd, num_entries);
  }
#line 430
  return;
}
}
#line 433 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fis/fis.c"
static void check_overlap(dir_t const   dir , uint32_t addr , uint32_t size ) 
{ 
  uint32_t end_addr ;
  iter_t i ;

  {
#line 435
  end_addr = addr + size;
#line 436
  i = (iter_t )dir;
  {
#line 436
  while (1) {
    while_continue: /* CIL Label */ ;
#line 436
    if (! i) {
#line 436
      goto while_break;
    }
#line 437
    if (addr < (i->entry)->flash_base + (i->entry)->size) {
#line 437
      if (end_addr > (i->entry)->flash_base) {
        {
#line 439
        warning("New partition overlaps existing partitions");
        }
      }
    }
#line 436
    if ((unsigned long )i->next == (unsigned long )dir) {
#line 436
      i = (iter_t )((void *)0);
    } else {
#line 436
      i = i->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 442
  return;
}
}
#line 445 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fis/fis.c"
static void fis_create(char const   *device , int offset , int size , _Bool swap_endianness ,
                       char *name , int argc , char **argv ) 
{ 
  struct fis_image_desc *existing ;
  struct fis_image_desc *d ;
  int fd ;
  dir_t dir ;
  iter_t i ;
  char *this_name ;
  int tmp ;
  void *tmp___0 ;
  int j ;
  char c ;
  unsigned int i___0 ;
  int i___1 ;
  char *arg ;
  char *file ;
  int fd___0 ;
  struct stat file_stat ;
  int tmp___1 ;
  uint8_t *data ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  iter_t after ;
  iter_t i___2 ;

  {
  {
#line 448
  existing = (struct fis_image_desc *)((void *)0);
#line 449
  d = (struct fis_image_desc *)((void *)0);
#line 452
  fd = open(device, 2);
  }
#line 452
  if (fd == -1) {
    {
#line 452
    perror("fd=open(device,O_RDWR)");
#line 452
    exit(1);
    }
  }
  {
#line 454
  load_dir(fd, offset, & size, swap_endianness, & dir);
#line 457
  i = dir;
  }
  {
#line 457
  while (1) {
    while_continue: /* CIL Label */ ;
#line 457
    if (! i) {
#line 457
      goto while_break;
    }
    {
#line 458
    this_name = (char *)((i->entry)->name);
#line 459
    tmp = strcmp((char const   *)this_name, (char const   *)name);
    }
#line 459
    if (tmp == 0) {
#line 460
      existing = i->entry;
#line 461
      goto while_break;
    }
#line 457
    if ((unsigned long )i->next == (unsigned long )dir) {
#line 457
      i = (iter_t )((void *)0);
    } else {
#line 457
      i = i->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 466
  if ((unsigned long )existing == (unsigned long )((void *)0)) {
    {
#line 467
    tmp___0 = chk_malloc(sizeof(struct fis_image_desc ));
#line 467
    d = (struct fis_image_desc *)tmp___0;
#line 469
    j = 0;
    }
    {
#line 469
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 469
      if (! (j < 16)) {
#line 469
        goto while_break___0;
      }
#line 470
      c = *(name + j);
#line 471
      d->name[j] = (unsigned char )c;
#line 472
      if (! c) {
        {
#line 473
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 473
          if (! (j < 16)) {
#line 473
            goto while_break___1;
          }
#line 474
          d->name[j] = (unsigned char)0;
#line 473
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 476
        goto while_break___0;
      }
#line 469
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 480
    d->mem_base = (uint32_t )0;
#line 481
    d->entry_point = (uint32_t )0;
#line 482
    d->data_length = (uint32_t )0;
#line 483
    i___0 = 0U;
    {
#line 483
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 483
      if (! ((unsigned long )i___0 < sizeof(d->skips) / 4UL)) {
#line 483
        goto while_break___2;
      }
#line 484
      d->skips[i___0] = (uint32_t )0;
#line 483
      i___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 486
    d->desc_cksum = (uint32_t )0;
#line 487
    d->file_cksum = (uint32_t )0;
  } else {
#line 490
    d = existing;
  }
#line 493
  i___1 = 0;
  {
#line 493
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 493
    if (! (i___1 < argc)) {
#line 493
      goto while_break___3;
    }
    {
#line 494
    arg = *(argv + i___1);
#line 495
    tmp___7 = strcmp((char const   *)arg, "-l");
    }
#line 495
    if (tmp___7 == 0) {
#line 496
      if (i___1 == argc - 1) {
        {
#line 497
        fatal("argumnet missing for -l");
        }
      }
      {
#line 499
      i___1 ++;
#line 500
      d->size = str_to_int_maybe_hex((char const   *)*(argv + i___1));
      }
    } else {
      {
#line 501
      tmp___6 = strcmp((char const   *)arg, "-f");
      }
#line 501
      if (tmp___6 == 0) {
#line 502
        if (i___1 == argc - 1) {
          {
#line 503
          fatal("argumnet missing for -f");
          }
        }
        {
#line 505
        i___1 ++;
#line 506
        d->flash_base = str_to_int_maybe_hex((char const   *)*(argv + i___1));
        }
      } else {
        {
#line 507
        tmp___5 = strcmp((char const   *)arg, "-e");
        }
#line 507
        if (tmp___5 == 0) {
#line 508
          if (i___1 == argc - 1) {
            {
#line 509
            fatal("argumnet missing for -e");
            }
          }
          {
#line 511
          i___1 ++;
#line 512
          d->entry_point = str_to_int_maybe_hex((char const   *)*(argv + i___1));
          }
        } else {
          {
#line 513
          tmp___4 = strcmp((char const   *)arg, "-r");
          }
#line 513
          if (tmp___4 == 0) {
#line 514
            if (i___1 == argc - 1) {
              {
#line 515
              fatal("argumnet missing for -r");
              }
            }
            {
#line 517
            i___1 ++;
#line 518
            d->mem_base = str_to_int_maybe_hex((char const   *)*(argv + i___1));
            }
          } else {
            {
#line 519
            tmp___3 = strcmp((char const   *)arg, "-c");
            }
#line 519
            if (tmp___3 == 0) {
#line 520
              if (i___1 == argc - 1) {
                {
#line 521
                fatal("argumnet missing for -c");
                }
              }
              {
#line 523
              i___1 ++;
#line 524
              file = *(argv + i___1);
#line 527
              fd___0 = open((char const   *)file, 0);
              }
#line 527
              if (fd___0 == -1) {
                {
#line 527
                perror("fd=open(file,O_RDONLY)");
#line 527
                exit(1);
                }
              }
              {
#line 528
              tmp___1 = fstat(fd___0, & file_stat);
              }
#line 528
              if (tmp___1 == -1) {
                {
#line 528
                perror("fstat(fd,&file_stat)");
#line 528
                exit(1);
                }
              }
              {
#line 529
              d->data_length = (uint32_t )file_stat.st_size;
#line 531
              tmp___2 = mmap((void *)0, (size_t )d->data_length, 1, 2, fd___0, (__off_t )0);
#line 531
              data = (uint8_t *)tmp___2;
              }
#line 531
              if ((unsigned long )data == (unsigned long )((void *)-1)) {
                {
#line 531
                perror("data=mmap(0,d->data_length,PROT_READ,MAP_PRIVATE,fd,0)");
#line 531
                exit(1);
                }
              }
              {
#line 532
              d->file_cksum = crc32(data, d->data_length);
#line 533
              munmap((void *)data, (size_t )d->data_length);
              }
            } else {
              {
#line 535
              fputs((char const   */* __restrict  */)"Unrecognised option \'", (FILE */* __restrict  */)stderr);
#line 536
              fputs((char const   */* __restrict  */)arg, (FILE */* __restrict  */)stderr);
#line 537
              fputs((char const   */* __restrict  */)"\'\n", (FILE */* __restrict  */)stderr);
#line 538
              exit(1);
              }
            }
          }
        }
      }
    }
#line 493
    i___1 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 543
  if ((unsigned long )existing == (unsigned long )((void *)0)) {
    {
#line 544
    check_overlap((dir_t const   )dir, d->flash_base, d->size);
#line 545
    after = (iter_t )((void *)0);
#line 546
    i___2 = dir;
    }
    {
#line 546
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 546
      if (! i___2) {
#line 546
        goto while_break___4;
      }
#line 547
      if ((i___2->entry)->flash_base > d->flash_base) {
#line 548
        goto while_break___4;
      }
#line 550
      after = i___2;
#line 546
      if ((unsigned long )i___2->next == (unsigned long )dir) {
#line 546
        i___2 = (iter_t )((void *)0);
      } else {
#line 546
        i___2 = i___2->next;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 552
    dir_insert(& dir, after, d);
    }
  }
  {
#line 555
  save_dir(fd, offset, size, swap_endianness, (dir_t const   )dir);
  }
#line 556
  return;
}
}
#line 559 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fis/fis.c"
static void fis_delete(char const   *device , int offset , int size , _Bool swap_endianness ,
                       char *name ) 
{ 
  int fd ;
  dir_t dir ;
  iter_t i ;
  char *this_name ;
  int tmp ;

  {
  {
#line 563
  fd = open(device, 2);
  }
#line 563
  if (fd == -1) {
    {
#line 563
    perror("fd=open(device,O_RDWR)");
#line 563
    exit(1);
    }
  }
  {
#line 565
  load_dir(fd, offset, & size, swap_endianness, & dir);
#line 567
  i = dir;
  }
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    if (! i) {
#line 567
      goto while_break;
    }
    {
#line 568
    this_name = (char *)((i->entry)->name);
#line 569
    tmp = strcmp((char const   *)this_name, (char const   *)name);
    }
#line 569
    if (tmp == 0) {
      {
#line 570
      dir_erase(& dir, i);
#line 571
      save_dir(fd, offset, size, swap_endianness, (dir_t const   )dir);
      }
#line 572
      return;
    }
#line 567
    if ((unsigned long )i->next == (unsigned long )dir) {
#line 567
      i = (iter_t )((void *)0);
    } else {
#line 567
      i = i->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 576
  fatal("No partition found with specified name");
  }
#line 577
  return;
}
}
#line 580 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fis/fis.c"
static void usage___0(void) 
{ 


  {
  {
#line 582
  fputs((char const   */* __restrict  */)"Usage:\n  fis [options] list\n  fis [options] init\n  fis [options] create name [-f address] [-l size] [-e entry] [-r ram-addr] [-c contents]\n  fis [options] delete name\nOptions:\n  -d device    specify /dev/mtd* device containing directory\n  -o offset    specify offset into device of start of directory\n               (in decimal; prefix with 0x for hex)\n  -s size      specify size of directory in bytes\n  -e           swap endianness\n",
        (FILE */* __restrict  */)stderr);
  }
#line 593
  return;
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fis/crc.c"
static uint32_t const   crc32_tab___0[256]  = 
#line 24 "/home/june/repo/benchmarks/collector/temp/redboot-tools-0.7build2/fis/crc.c"
  {      (uint32_t const   )0L,      (uint32_t const   )1996959894L,      (uint32_t const   )3993919788L,      (uint32_t const   )2567524794L, 
        (uint32_t const   )124634137L,      (uint32_t const   )1886057615L,      (uint32_t const   )3915621685L,      (uint32_t const   )2657392035L, 
        (uint32_t const   )249268274L,      (uint32_t const   )2044508324L,      (uint32_t const   )3772115230L,      (uint32_t const   )2547177864L, 
        (uint32_t const   )162941995L,      (uint32_t const   )2125561021L,      (uint32_t const   )3887607047L,      (uint32_t const   )2428444049L, 
        (uint32_t const   )498536548L,      (uint32_t const   )1789927666L,      (uint32_t const   )4089016648L,      (uint32_t const   )2227061214L, 
        (uint32_t const   )450548861L,      (uint32_t const   )1843258603L,      (uint32_t const   )4107580753L,      (uint32_t const   )2211677639L, 
        (uint32_t const   )325883990L,      (uint32_t const   )1684777152L,      (uint32_t const   )4251122042L,      (uint32_t const   )2321926636L, 
        (uint32_t const   )335633487L,      (uint32_t const   )1661365465L,      (uint32_t const   )4195302755L,      (uint32_t const   )2366115317L, 
        (uint32_t const   )997073096L,      (uint32_t const   )1281953886L,      (uint32_t const   )3579855332L,      (uint32_t const   )2724688242L, 
        (uint32_t const   )1006888145L,      (uint32_t const   )1258607687L,      (uint32_t const   )3524101629L,      (uint32_t const   )2768942443L, 
        (uint32_t const   )901097722L,      (uint32_t const   )1119000684L,      (uint32_t const   )3686517206L,      (uint32_t const   )2898065728L, 
        (uint32_t const   )853044451L,      (uint32_t const   )1172266101L,      (uint32_t const   )3705015759L,      (uint32_t const   )2882616665L, 
        (uint32_t const   )651767980L,      (uint32_t const   )1373503546L,      (uint32_t const   )3369554304L,      (uint32_t const   )3218104598L, 
        (uint32_t const   )565507253L,      (uint32_t const   )1454621731L,      (uint32_t const   )3485111705L,      (uint32_t const   )3099436303L, 
        (uint32_t const   )671266974L,      (uint32_t const   )1594198024L,      (uint32_t const   )3322730930L,      (uint32_t const   )2970347812L, 
        (uint32_t const   )795835527L,      (uint32_t const   )1483230225L,      (uint32_t const   )3244367275L,      (uint32_t const   )3060149565L, 
        (uint32_t const   )1994146192L,      (uint32_t const   )31158534L,      (uint32_t const   )2563907772L,      (uint32_t const   )4023717930L, 
        (uint32_t const   )1907459465L,      (uint32_t const   )112637215L,      (uint32_t const   )2680153253L,      (uint32_t const   )3904427059L, 
        (uint32_t const   )2013776290L,      (uint32_t const   )251722036L,      (uint32_t const   )2517215374L,      (uint32_t const   )3775830040L, 
        (uint32_t const   )2137656763L,      (uint32_t const   )141376813L,      (uint32_t const   )2439277719L,      (uint32_t const   )3865271297L, 
        (uint32_t const   )1802195444L,      (uint32_t const   )476864866L,      (uint32_t const   )2238001368L,      (uint32_t const   )4066508878L, 
        (uint32_t const   )1812370925L,      (uint32_t const   )453092731L,      (uint32_t const   )2181625025L,      (uint32_t const   )4111451223L, 
        (uint32_t const   )1706088902L,      (uint32_t const   )314042704L,      (uint32_t const   )2344532202L,      (uint32_t const   )4240017532L, 
        (uint32_t const   )1658658271L,      (uint32_t const   )366619977L,      (uint32_t const   )2362670323L,      (uint32_t const   )4224994405L, 
        (uint32_t const   )1303535960L,      (uint32_t const   )984961486L,      (uint32_t const   )2747007092L,      (uint32_t const   )3569037538L, 
        (uint32_t const   )1256170817L,      (uint32_t const   )1037604311L,      (uint32_t const   )2765210733L,      (uint32_t const   )3554079995L, 
        (uint32_t const   )1131014506L,      (uint32_t const   )879679996L,      (uint32_t const   )2909243462L,      (uint32_t const   )3663771856L, 
        (uint32_t const   )1141124467L,      (uint32_t const   )855842277L,      (uint32_t const   )2852801631L,      (uint32_t const   )3708648649L, 
        (uint32_t const   )1342533948L,      (uint32_t const   )654459306L,      (uint32_t const   )3188396048L,      (uint32_t const   )3373015174L, 
        (uint32_t const   )1466479909L,      (uint32_t const   )544179635L,      (uint32_t const   )3110523913L,      (uint32_t const   )3462522015L, 
        (uint32_t const   )1591671054L,      (uint32_t const   )702138776L,      (uint32_t const   )2966460450L,      (uint32_t const   )3352799412L, 
        (uint32_t const   )1504918807L,      (uint32_t const   )783551873L,      (uint32_t const   )3082640443L,      (uint32_t const   )3233442989L, 
        (uint32_t const   )3988292384L,      (uint32_t const   )2596254646L,      (uint32_t const   )62317068L,      (uint32_t const   )1957810842L, 
        (uint32_t const   )3939845945L,      (uint32_t const   )2647816111L,      (uint32_t const   )81470997L,      (uint32_t const   )1943803523L, 
        (uint32_t const   )3814918930L,      (uint32_t const   )2489596804L,      (uint32_t const   )225274430L,      (uint32_t const   )2053790376L, 
        (uint32_t const   )3826175755L,      (uint32_t const   )2466906013L,      (uint32_t const   )167816743L,      (uint32_t const   )2097651377L, 
        (uint32_t const   )4027552580L,      (uint32_t const   )2265490386L,      (uint32_t const   )503444072L,      (uint32_t const   )1762050814L, 
        (uint32_t const   )4150417245L,      (uint32_t const   )2154129355L,      (uint32_t const   )426522225L,      (uint32_t const   )1852507879L, 
        (uint32_t const   )4275313526L,      (uint32_t const   )2312317920L,      (uint32_t const   )282753626L,      (uint32_t const   )1742555852L, 
        (uint32_t const   )4189708143L,      (uint32_t const   )2394877945L,      (uint32_t const   )397917763L,      (uint32_t const   )1622183637L, 
        (uint32_t const   )3604390888L,      (uint32_t const   )2714866558L,      (uint32_t const   )953729732L,      (uint32_t const   )1340076626L, 
        (uint32_t const   )3518719985L,      (uint32_t const   )2797360999L,      (uint32_t const   )1068828381L,      (uint32_t const   )1219638859L, 
        (uint32_t const   )3624741850L,      (uint32_t const   )2936675148L,      (uint32_t const   )906185462L,      (uint32_t const   )1090812512L, 
        (uint32_t const   )3747672003L,      (uint32_t const   )2825379669L,      (uint32_t const   )829329135L,      (uint32_t const   )1181335161L, 
        (uint32_t const   )3412177804L,      (uint32_t const   )3160834842L,      (uint32_t const   )628085408L,      (uint32_t const   )1382605366L, 
        (uint32_t const   )3423369109L,      (uint32_t const   )3138078467L,      (uint32_t const   )570562233L,      (uint32_t const   )1426400815L, 
        (uint32_t const   )3317316542L,      (uint32_t const   )2998733608L,      (uint32_t const   )733239954L,      (uint32_t const   )1555261956L, 
        (uint32_t const   )3268935591L,      (uint32_t const   )3050360625L,      (uint32_t const   )752459403L,      (uint32_t const   )1541320221L, 
        (uint32_t const   )2607071920L,      (uint32_t const   )3965973030L,      (uint32_t const   )1969922972L,      (uint32_t const   )40735498L, 
        (uint32_t const   )2617837225L,      (uint32_t const   )3943577151L,      (uint32_t const   )1913087877L,      (uint32_t const   )83908371L, 
        (uint32_t const   )2512341634L,      (uint32_t const   )3803740692L,      (uint32_t const   )2075208622L,      (uint32_t const   )213261112L, 
        (uint32_t const   )2463272603L,      (uint32_t const   )3855990285L,      (uint32_t const   )2094854071L,      (uint32_t const   )198958881L, 
        (uint32_t const   )2262029012L,      (uint32_t const   )4057260610L,      (uint32_t const   )1759359992L,      (uint32_t const   )534414190L, 
        (uint32_t const   )2176718541L,      (uint32_t const   )4139329115L,      (uint32_t const   )1873836001L,      (uint32_t const   )414664567L, 
        (uint32_t const   )2282248934L,      (uint32_t const   )4279200368L,      (uint32_t const   )1711684554L,      (uint32_t const   )285281116L, 
        (uint32_t const   )2405801727L,      (uint32_t const   )4167216745L,      (uint32_t const   )1634467795L,      (uint32_t const   )376229701L, 
        (uint32_t const   )2685067896L,      (uint32_t const   )3608007406L,      (uint32_t const   )1308918612L,      (uint32_t const   )956543938L, 
        (uint32_t const   )2808555105L,      (uint32_t const   )3495958263L,      (uint32_t const   )1231636301L,      (uint32_t const   )1047427035L, 
        (uint32_t const   )2932959818L,      (uint32_t const   )3654703836L,      (uint32_t const   )1088359270L,      (uint32_t const   )936918000L, 
        (uint32_t const   )2847714899L,      (uint32_t const   )3736837829L,      (uint32_t const   )1202900863L,      (uint32_t const   )817233897L, 
        (uint32_t const   )3183342108L,      (uint32_t const   )3401237130L,      (uint32_t const   )1404277552L,      (uint32_t const   )615818150L, 
        (uint32_t const   )3134207493L,      (uint32_t const   )3453421203L,      (uint32_t const   )1423857449L,      (uint32_t const   )601450431L, 
        (uint32_t const   )3009837614L,      (uint32_t const   )3294710456L,      (uint32_t const   )1567103746L,      (uint32_t const   )711928724L, 
        (uint32_t const   )3020668471L,      (uint32_t const   )3272380065L,      (uint32_t const   )1510334235L,      (uint32_t const   )755167117L};
