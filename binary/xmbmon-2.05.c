/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 30 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 10 "/home/wheatley/newnew/temp/xmbmon-2.05/smbuses.h"
struct smbus_io {
   int (*ReadB)(int  , int  , int  ) ;
   int (*ReadW)(int  , int  , int  ) ;
   int (*WriteB)(int  , int  , int  , int  ) ;
   int (*WriteW)(int  , int  , int  , int  ) ;
};
#line 14 "/home/wheatley/newnew/temp/xmbmon-2.05/methods.h"
struct lm_methods {
   int (*Open)() ;
   void (*Close)() ;
   int (*Read)(int  ) ;
   void (*Write)(int  , int  ) ;
   int (*ReadW)(int  ) ;
   void (*WriteW)(int  , int  ) ;
   int (*ReadTemp1)() ;
   int (*ReadTemp2)() ;
};
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 25 "/home/wheatley/newnew/temp/xmbmon-2.05/methods.h"
typedef struct lm_methods LM_METHODS;
#line 6 "/home/wheatley/newnew/temp/xmbmon-2.05/sensors.h"
struct hwm_access {
   char *Name ;
   int (*Probe)(LM_METHODS *pMethods ) ;
   float (*Temp)(LM_METHODS *pMethods , int no ) ;
   float (*Volt)(LM_METHODS *pMethods , int no ) ;
   int (*FanRPM)(LM_METHODS *pMethods , int no ) ;
};
#line 14 "/home/wheatley/newnew/temp/xmbmon-2.05/sensors.h"
typedef struct hwm_access SENSOR;
#line 17 "/home/wheatley/newnew/temp/xmbmon-2.05/smbuses.h"
typedef struct smbus_io SMBUS_IO;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 45 "/home/wheatley/newnew/temp/xmbmon-2.05/io_cpu.h"
__inline static unsigned short my_inw(unsigned short port ) 
{ 
  unsigned short ret ;

  {
#line 49
  __asm__  volatile   ("inw %1,%0": "=a" (ret): "d" (port));
#line 50
  return (ret);
}
}
#line 61 "/home/wheatley/newnew/temp/xmbmon-2.05/io_cpu.h"
__inline static void my_outb(unsigned short port , unsigned char val ) 
{ 


  {
#line 64
  __asm__  volatile   ("outb %0,%1": : "a" (val), "d" (port));
#line 65
  return;
}
}
#line 67 "/home/wheatley/newnew/temp/xmbmon-2.05/io_cpu.h"
__inline static void my_outw(unsigned short port , unsigned short val ) 
{ 


  {
#line 70
  __asm__  volatile   ("outw %0,%1": : "a" (val), "d" (port));
#line 71
  return;
}
}
#line 69 "/home/wheatley/newnew/temp/xmbmon-2.05/smbus_amd.c"
static int readbyte(int smb_base___0 , int addr , int cmd ) 
{ 
  u_char saddr ;
  u_short dat ;
  int i ;

  {
#line 71
  saddr = (u_char )(2 * (addr / 2));
  top: 
  {
#line 76
  my_outw((u_short )smb_base___0, (unsigned short)55);
#line 76
  my_outb((unsigned short)235, (unsigned char)0);
#line 76
  my_outb((unsigned short)235, (unsigned char)0);
#line 77
  i = 0;
  }
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (i < 8192)) {
#line 77
      goto while_break;
    }
    {
#line 78
    dat = my_inw((u_short )smb_base___0);
#line 78
    my_outb((unsigned short)235, (unsigned char)0);
#line 78
    my_outb((unsigned short)235, (unsigned char)0);
#line 79
    my_outw((u_short )smb_base___0, dat);
#line 79
    my_outb((unsigned short)235, (unsigned char)0);
#line 79
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 80
    if (! ((int )dat & 10)) {
#line 81
      goto step;
    }
#line 82
    if (! ((int )dat & 8)) {
#line 83
      goto while_break;
    }
#line 77
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 85
  my_outw((u_short )(smb_base___0 + 2), (unsigned short)32);
#line 85
  my_outb((unsigned short)235, (unsigned char)0);
#line 85
  my_outb((unsigned short)235, (unsigned char)0);
  }
  step: 
  {
#line 88
  my_outw((u_short )(smb_base___0 + 4), (unsigned short )((int )saddr | 1));
#line 88
  my_outb((unsigned short)235, (unsigned char)0);
#line 88
  my_outb((unsigned short)235, (unsigned char)0);
#line 89
  my_outb((u_short )(smb_base___0 + 8), (u_char )cmd);
#line 89
  my_outb((unsigned short)235, (unsigned char)0);
#line 89
  my_outb((unsigned short)235, (unsigned char)0);
#line 90
  my_outw((u_short )(smb_base___0 + 2), (unsigned short)10);
#line 91
  my_outb((unsigned short)235, (unsigned char)0);
#line 91
  my_outb((unsigned short)235, (unsigned char)0);
#line 93
  i = 0;
  }
  {
#line 93
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 93
    if (! (i < 8192)) {
#line 93
      goto while_break___0;
    }
    {
#line 94
    dat = my_inw((u_short )smb_base___0);
#line 94
    my_outb((unsigned short)235, (unsigned char)0);
#line 94
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 95
    if ((int )dat & 2) {
#line 100
      goto top;
    }
#line 102
    if (! ((int )dat & 8)) {
#line 102
      if ((int )dat & 20) {
#line 103
        goto while_break___0;
      }
    }
#line 93
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 109
  if ((int )dat & 16) {
    {
#line 110
    dat = my_inw((u_short )(smb_base___0 + 6));
#line 110
    my_outb((unsigned short)235, (unsigned char)0);
#line 110
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 111
    return ((int )dat & 255);
  } else {
#line 113
    return (-1);
  }
}
}
#line 116 "/home/wheatley/newnew/temp/xmbmon-2.05/smbus_amd.c"
static int readword(int smb_base___0 , int addr , int cmd ) 
{ 
  u_char saddr ;
  u_short dat ;
  int i ;

  {
#line 118
  saddr = (u_char )(2 * (addr / 2));
  top: 
  {
#line 123
  my_outw((u_short )smb_base___0, (unsigned short)55);
#line 123
  my_outb((unsigned short)235, (unsigned char)0);
#line 123
  my_outb((unsigned short)235, (unsigned char)0);
#line 124
  i = 0;
  }
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (i < 8192)) {
#line 124
      goto while_break;
    }
    {
#line 125
    dat = my_inw((u_short )smb_base___0);
#line 125
    my_outb((unsigned short)235, (unsigned char)0);
#line 125
    my_outb((unsigned short)235, (unsigned char)0);
#line 126
    my_outw((u_short )smb_base___0, dat);
#line 126
    my_outb((unsigned short)235, (unsigned char)0);
#line 126
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 127
    if (! ((int )dat & 10)) {
#line 128
      goto step;
    }
#line 129
    if (! ((int )dat & 8)) {
#line 130
      goto while_break;
    }
#line 124
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 132
  my_outw((u_short )(smb_base___0 + 2), (unsigned short)32);
#line 132
  my_outb((unsigned short)235, (unsigned char)0);
#line 132
  my_outb((unsigned short)235, (unsigned char)0);
  }
  step: 
  {
#line 135
  my_outw((u_short )(smb_base___0 + 4), (unsigned short )((int )saddr | 1));
#line 135
  my_outb((unsigned short)235, (unsigned char)0);
#line 135
  my_outb((unsigned short)235, (unsigned char)0);
#line 136
  my_outb((u_short )(smb_base___0 + 8), (u_char )cmd);
#line 136
  my_outb((unsigned short)235, (unsigned char)0);
#line 136
  my_outb((unsigned short)235, (unsigned char)0);
#line 137
  my_outw((u_short )(smb_base___0 + 2), (unsigned short)11);
#line 138
  my_outb((unsigned short)235, (unsigned char)0);
#line 138
  my_outb((unsigned short)235, (unsigned char)0);
#line 140
  i = 0;
  }
  {
#line 140
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 140
    if (! (i < 8192)) {
#line 140
      goto while_break___0;
    }
    {
#line 141
    dat = my_inw((u_short )smb_base___0);
#line 141
    my_outb((unsigned short)235, (unsigned char)0);
#line 141
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 142
    if ((int )dat & 2) {
#line 143
      goto top;
    }
#line 144
    if (! ((int )dat & 8)) {
#line 144
      if ((int )dat & 20) {
#line 145
        goto while_break___0;
      }
    }
#line 140
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 147
  if ((int )dat & 16) {
    {
#line 148
    dat = my_inw((u_short )(smb_base___0 + 6));
#line 148
    my_outb((unsigned short)235, (unsigned char)0);
#line 148
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 149
    return ((int )dat & 65535);
  } else {
#line 151
    return (-1);
  }
}
}
#line 154 "/home/wheatley/newnew/temp/xmbmon-2.05/smbus_amd.c"
static int writebyte(int smb_base___0 , int addr , int cmd , int value ) 
{ 
  u_char saddr ;
  u_short dat ;
  int i ;

  {
  {
#line 156
  saddr = (u_char )(2 * (addr / 2));
#line 160
  my_outw((u_short )smb_base___0, (unsigned short)55);
#line 160
  my_outb((unsigned short)235, (unsigned char)0);
#line 160
  my_outb((unsigned short)235, (unsigned char)0);
#line 161
  i = 0;
  }
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (! (i < 8192)) {
#line 161
      goto while_break;
    }
    {
#line 162
    dat = my_inw((u_short )smb_base___0);
#line 162
    my_outb((unsigned short)235, (unsigned char)0);
#line 162
    my_outb((unsigned short)235, (unsigned char)0);
#line 163
    my_outw((u_short )smb_base___0, dat);
#line 163
    my_outb((unsigned short)235, (unsigned char)0);
#line 163
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 164
    if (! ((int )dat & 10)) {
#line 165
      goto step;
    }
#line 166
    if (! ((int )dat & 8)) {
#line 167
      goto while_break;
    }
#line 161
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 169
  my_outw((u_short )(smb_base___0 + 2), (unsigned short)32);
#line 169
  my_outb((unsigned short)235, (unsigned char)0);
#line 169
  my_outb((unsigned short)235, (unsigned char)0);
  }
  step: 
  {
#line 172
  my_outw((u_short )(smb_base___0 + 4), (unsigned short )saddr);
#line 172
  my_outb((unsigned short)235, (unsigned char)0);
#line 172
  my_outb((unsigned short)235, (unsigned char)0);
#line 173
  my_outb((u_short )(smb_base___0 + 8), (u_char )cmd);
#line 173
  my_outb((unsigned short)235, (unsigned char)0);
#line 173
  my_outb((unsigned short)235, (unsigned char)0);
#line 174
  my_outw((u_short )(smb_base___0 + 6), (unsigned short )((u_char )value));
#line 174
  my_outb((unsigned short)235, (unsigned char)0);
#line 174
  my_outb((unsigned short)235, (unsigned char)0);
#line 175
  my_outw((u_short )(smb_base___0 + 2), (unsigned short)10);
#line 176
  my_outb((unsigned short)235, (unsigned char)0);
#line 176
  my_outb((unsigned short)235, (unsigned char)0);
#line 178
  i = 0;
  }
  {
#line 178
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 178
    if (! (i < 8192)) {
#line 178
      goto while_break___0;
    }
    {
#line 179
    dat = my_inw((u_short )smb_base___0);
#line 179
    my_outb((unsigned short)235, (unsigned char)0);
#line 179
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 180
    if (! ((int )dat & 8)) {
#line 180
      if ((int )dat & 20) {
#line 181
        goto while_break___0;
      }
    }
#line 178
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 183
  if ((int )dat & 16) {
#line 184
    return (0);
  } else {
#line 186
    return (-1);
  }
}
}
#line 189 "/home/wheatley/newnew/temp/xmbmon-2.05/smbus_amd.c"
static int writeword(int smb_base___0 , int addr , int cmd , int value ) 
{ 
  u_char saddr ;
  u_short dat ;
  int i ;

  {
  {
#line 191
  saddr = (u_char )(2 * (addr / 2));
#line 195
  my_outw((u_short )smb_base___0, (unsigned short)55);
#line 195
  my_outb((unsigned short)235, (unsigned char)0);
#line 195
  my_outb((unsigned short)235, (unsigned char)0);
#line 196
  i = 0;
  }
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    if (! (i < 8192)) {
#line 196
      goto while_break;
    }
    {
#line 197
    dat = my_inw((u_short )smb_base___0);
#line 197
    my_outb((unsigned short)235, (unsigned char)0);
#line 197
    my_outb((unsigned short)235, (unsigned char)0);
#line 198
    my_outw((u_short )smb_base___0, dat);
#line 198
    my_outb((unsigned short)235, (unsigned char)0);
#line 198
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 199
    if (! ((int )dat & 10)) {
#line 200
      goto step;
    }
#line 201
    if (! ((int )dat & 8)) {
#line 202
      goto while_break;
    }
#line 196
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 204
  my_outw((u_short )(smb_base___0 + 2), (unsigned short)32);
#line 204
  my_outb((unsigned short)235, (unsigned char)0);
#line 204
  my_outb((unsigned short)235, (unsigned char)0);
  }
  step: 
  {
#line 207
  my_outw((u_short )(smb_base___0 + 4), (unsigned short )saddr);
#line 207
  my_outb((unsigned short)235, (unsigned char)0);
#line 207
  my_outb((unsigned short)235, (unsigned char)0);
#line 208
  my_outb((u_short )(smb_base___0 + 8), (u_char )cmd);
#line 208
  my_outb((unsigned short)235, (unsigned char)0);
#line 208
  my_outb((unsigned short)235, (unsigned char)0);
#line 209
  my_outw((u_short )(smb_base___0 + 6), (u_short )value);
#line 209
  my_outb((unsigned short)235, (unsigned char)0);
#line 209
  my_outb((unsigned short)235, (unsigned char)0);
#line 210
  my_outw((u_short )(smb_base___0 + 2), (unsigned short)11);
#line 211
  my_outb((unsigned short)235, (unsigned char)0);
#line 211
  my_outb((unsigned short)235, (unsigned char)0);
#line 213
  i = 0;
  }
  {
#line 213
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 213
    if (! (i < 8192)) {
#line 213
      goto while_break___0;
    }
    {
#line 214
    dat = my_inw((u_short )smb_base___0);
#line 214
    my_outb((unsigned short)235, (unsigned char)0);
#line 214
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 215
    if (! ((int )dat & 8)) {
#line 215
      if ((int )dat & 20) {
#line 216
        goto while_break___0;
      }
    }
#line 213
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 218
  if ((int )dat & 16) {
#line 219
    return (0);
  } else {
#line 221
    return (-1);
  }
}
}
#line 224 "/home/wheatley/newnew/temp/xmbmon-2.05/smbus_amd.c"
struct smbus_io smbus_amd  =    {& readbyte, & readword, & writebyte, & writeword};
#line 11 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-via.c"
int viahwm_base  =    -1;
#line 38 "/usr/include/x86_64-linux-gnu/sys/io.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iopl)(int __level ) ;
#line 31 "/home/wheatley/newnew/temp/xmbmon-2.05/io_cpu.h"
int iopl_counter ;
#line 37 "/home/wheatley/newnew/temp/xmbmon-2.05/io_cpu.h"
__inline static unsigned char my_inb(unsigned short port ) 
{ 
  unsigned char ret ;

  {
#line 41
  __asm__  volatile   ("inb %1,%0": "=a" (ret): "d" (port));
#line 42
  return (ret);
}
}
#line 5 "/home/wheatley/newnew/temp/xmbmon-2.05/io_static.c"
static int OpenIO(void) 
{ 
  int tmp ;

  {
#line 7
  if (iopl_counter == 0) {
    {
#line 8
    tmp = iopl(3);
    }
#line 8
    if (tmp < 0) {
#line 9
      return (-1);
    }
  }
#line 11
  iopl_counter ++;
#line 12
  return (0);
}
}
#line 15 "/home/wheatley/newnew/temp/xmbmon-2.05/io_static.c"
static void CloseIO(void) 
{ 


  {
#line 17
  if (iopl_counter == 1) {
    {
#line 18
    iopl(0);
    }
  }
#line 19
  if (iopl_counter > 0) {
#line 20
    iopl_counter --;
  }
#line 21
  return;
}
}
#line 20 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-via.c"
static int ReadByte(int addr ) 
{ 
  int ret ;
  unsigned char tmp ;

  {
  {
#line 23
  tmp = my_inb((unsigned short )(viahwm_base + addr));
#line 23
  ret = (int )tmp;
#line 23
  my_outb((unsigned short)235, (unsigned char)0);
  }
#line 24
  return (ret & 255);
}
}
#line 27 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-via.c"
static void WriteByte(int addr , int value ) 
{ 


  {
  {
#line 29
  my_outb((unsigned short )(viahwm_base + addr), (unsigned char )value);
#line 29
  my_outb((unsigned short)235, (unsigned char)0);
  }
#line 30
  return;
}
}
#line 32 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-via.c"
static int ReadWord(int addr ) 
{ 
  int ret ;
  unsigned short tmp ;

  {
  {
#line 35
  tmp = my_inw((unsigned short )(viahwm_base + addr));
#line 35
  ret = (int )tmp;
#line 35
  my_outb((unsigned short)235, (unsigned char)0);
  }
#line 36
  return (ret & 65535);
}
}
#line 39 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-via.c"
static void WriteWord(int addr , int value ) 
{ 


  {
  {
#line 41
  my_outw((unsigned short )(viahwm_base + addr), (unsigned short )value);
#line 41
  my_outb((unsigned short)235, (unsigned char)0);
  }
#line 42
  return;
}
}
#line 44 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-via.c"
static int ReadTemp1(void) 
{ 
  int tmp ;

  {
  {
#line 46
  tmp = ReadByte(viahwm_base + 33);
  }
#line 46
  return (tmp);
}
}
#line 49 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-via.c"
static int ReadTemp2(void) 
{ 
  int tmp ;

  {
  {
#line 51
  tmp = ReadByte(viahwm_base + 31);
  }
#line 51
  return (tmp);
}
}
#line 54 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-via.c"
struct lm_methods method_via  = 
#line 54
     {& OpenIO, & CloseIO, & ReadByte, & WriteByte, & ReadWord, & WriteWord, & ReadTemp1,
    & ReadTemp2};
#line 11 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-isa.c"
int isa_port_base  =    656;
#line 5 "/home/wheatley/newnew/temp/xmbmon-2.05/io_static.c"
static int OpenIO___0(void) 
{ 
  int tmp ;

  {
#line 7
  if (iopl_counter == 0) {
    {
#line 8
    tmp = iopl(3);
    }
#line 8
    if (tmp < 0) {
#line 9
      return (-1);
    }
  }
#line 11
  iopl_counter ++;
#line 12
  return (0);
}
}
#line 15 "/home/wheatley/newnew/temp/xmbmon-2.05/io_static.c"
static void CloseIO___0(void) 
{ 


  {
#line 17
  if (iopl_counter == 1) {
    {
#line 18
    iopl(0);
    }
  }
#line 19
  if (iopl_counter > 0) {
#line 20
    iopl_counter --;
  }
#line 21
  return;
}
}
#line 22 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-isa.c"
static int ReadByte___0(int addr ) 
{ 
  int ret ;
  unsigned char tmp ;

  {
  {
#line 25
  my_outb((unsigned short )(isa_port_base + 5), (unsigned char )addr);
#line 25
  my_outb((unsigned short)235, (unsigned char)0);
#line 26
  tmp = my_inb((unsigned short )(isa_port_base + 6));
#line 26
  ret = (int )tmp;
#line 26
  my_outb((unsigned short)235, (unsigned char)0);
  }
#line 27
  return (ret & 255);
}
}
#line 30 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-isa.c"
static void WriteByte___0(int addr , int value ) 
{ 


  {
  {
#line 32
  my_outb((unsigned short )(isa_port_base + 5), (unsigned char )addr);
#line 32
  my_outb((unsigned short)235, (unsigned char)0);
#line 33
  my_outb((unsigned short )(isa_port_base + 6), (unsigned char )value);
#line 33
  my_outb((unsigned short)235, (unsigned char)0);
  }
#line 34
  return;
}
}
#line 36 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-isa.c"
static int ReadWord___0(int addr ) 
{ 
  int ret ;
  unsigned short tmp ;

  {
  {
#line 39
  my_outb((unsigned short )(isa_port_base + 5), (unsigned char )addr);
#line 39
  my_outb((unsigned short)235, (unsigned char)0);
#line 40
  tmp = my_inw((unsigned short )(isa_port_base + 6));
#line 40
  ret = (int )tmp;
#line 40
  my_outb((unsigned short)235, (unsigned char)0);
  }
#line 41
  return (ret & 65535);
}
}
#line 44 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-isa.c"
static void WriteWord___0(int addr , int value ) 
{ 


  {
  {
#line 46
  my_outb((unsigned short )(isa_port_base + 5), (unsigned char )addr);
#line 46
  my_outb((unsigned short)235, (unsigned char)0);
#line 47
  my_outw((unsigned short )(isa_port_base + 6), (unsigned short )value);
#line 47
  my_outb((unsigned short)235, (unsigned char)0);
  }
#line 48
  return;
}
}
#line 50 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-isa.c"
static int ReadTemp1___0(void) 
{ 
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 53
  WriteByte___0(78, 1);
#line 54
  tmp = ReadByte___0(80);
#line 54
  tmp___0 = ReadByte___0(81);
#line 54
  ret = tmp | (tmp___0 << 8);
#line 55
  WriteByte___0(78, 0);
  }
#line 56
  return (ret);
}
}
#line 59 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-isa.c"
static int ReadTemp2___0(void) 
{ 
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 62
  WriteByte___0(78, 2);
#line 63
  tmp = ReadByte___0(80);
#line 63
  tmp___0 = ReadByte___0(81);
#line 63
  ret = tmp | (tmp___0 << 8);
#line 64
  WriteByte___0(78, 0);
  }
#line 65
  return (ret);
}
}
#line 68 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-isa.c"
struct lm_methods method_isa  = 
#line 68
     {& OpenIO___0, & CloseIO___0, & ReadByte___0, & WriteByte___0, & ReadWord___0,
    & WriteWord___0, & ReadTemp1___0, & ReadTemp2___0};
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 16 "/home/wheatley/newnew/temp/xmbmon-2.05/sensors.h"
SENSOR winbond ;
#line 17
SENSOR wl784 ;
#line 18
SENSOR via686 ;
#line 19
SENSOR it87 ;
#line 20
SENSOR gl52 ;
#line 21
SENSOR lm85 ;
#line 22
SENSOR lm80 ;
#line 23
SENSOR lm90 ;
#line 24
SENSOR lm75 ;
#line 50 "/home/wheatley/newnew/temp/xmbmon-2.05/sensors.h"
SENSOR *HWM_module[10]  = 
#line 50
  {      & winbond,      & wl784,      & via686,      & it87, 
        & gl52,      & lm85,      & lm80,      & lm90, 
        & lm75,      (SENSOR *)((void *)0)};
#line 63 "/home/wheatley/newnew/temp/xmbmon-2.05/sensors.h"
char *HWM_name[10]  = 
#line 63
  {      (char *)"winbond",      (char *)"wl784",      (char *)"via686",      (char *)"it87", 
        (char *)"gl52",      (char *)"lm85",      (char *)"lm80",      (char *)"lm90", 
        (char *)"lm75",      (char *)((void *)0)};
#line 76 "/home/wheatley/newnew/temp/xmbmon-2.05/sensors.h"
int HWM_VIA  =    0;
#line 79 "/home/wheatley/newnew/temp/xmbmon-2.05/sensors.h"
int HWM_SMB  =    0;
#line 82 "/home/wheatley/newnew/temp/xmbmon-2.05/sensors.h"
int HWM_SMBchip[10]  = 
#line 82
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0};
#line 95 "/home/wheatley/newnew/temp/xmbmon-2.05/sensors.h"
int HWM_smbslave[10]  = 
#line 95
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0};
#line 108 "/home/wheatley/newnew/temp/xmbmon-2.05/sensors.h"
int HWM_ISA  =    0;
#line 111 "/home/wheatley/newnew/temp/xmbmon-2.05/sensors.h"
int HWM_ISAchip[10]  = 
#line 111
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0};
#line 127
int chkReg_Probe(int slave , char *comment , int *Reg , LM_METHODS *method___1 ) ;
#line 129
int scan_smbus(int addr_start , int addr_end , int *result ) ;
#line 130
int find_smb_dev(void) ;
#line 131
void kill_smb_slave(int slave ) ;
#line 132
int get_smb_slave(int start , int end ) ;
#line 133
int set_smb_Extemp(int start , int end , int *temp1 , int *temp2 ) ;
#line 134
void info_Extemp(LM_METHODS *method___1 , int temp1 , int temp2 ) ;
#line 17 "/home/wheatley/newnew/temp/xmbmon-2.05/sensors.c"
extern int debug_flag ;
#line 18
int smb_base ;
#line 19
int smb_slave ;
#line 20
int smb_wbtemp1 ;
#line 20
int smb_wbtemp2 ;
#line 21
struct lm_methods method_smb ;
#line 24 "/home/wheatley/newnew/temp/xmbmon-2.05/sensors.c"
int numSMBSlave  =    0;
#line 25 "/home/wheatley/newnew/temp/xmbmon-2.05/sensors.c"
int canSMBSlave[128]  ;
#line 28 "/home/wheatley/newnew/temp/xmbmon-2.05/sensors.c"
int chkReg_Probe(int slave , char *comment , int *Reg , LM_METHODS *method___1 ) 
{ 
  int i ;
  int n ;
  int r ;
  int ret ;

  {
#line 30
  ret = 0;
#line 32
  if (slave > 0) {
#line 32
    if (debug_flag > 1) {
      {
#line 33
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Set SMBus slave address: 0x%02X\n",
              slave);
      }
    }
  }
#line 34
  if (debug_flag > 1) {
    {
#line 35
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            comment);
    }
  }
#line 36
  i = 0;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    r = *(Reg + i);
#line 36
    if (! (r != -1)) {
#line 36
      goto while_break;
    }
    {
#line 37
    n = (*(method___1->Read))(r);
    }
#line 38
    if (n != 255) {
#line 39
      ret ++;
    }
#line 40
    if (debug_flag > 1) {
#line 41
      if ((i + 1) % 4 == 0) {
        {
#line 42
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  CR%02X:0x%02X\n",
                r, n);
        }
      } else {
        {
#line 44
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  CR%02X:0x%02X,",
                r, n);
        }
      }
    }
#line 36
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  if (debug_flag > 1) {
#line 48
    if ((i & 3) != 0) {
      {
#line 49
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
  }
#line 56
  return (ret);
}
}
#line 59 "/home/wheatley/newnew/temp/xmbmon-2.05/sensors.c"
int chkReg_Probe_strict(int *Reg , LM_METHODS *method___1 ) 
{ 
  int i ;
  int r ;
  int tmp ;

  {
#line 63
  i = 0;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    r = *(Reg + i);
#line 63
    if (! (r != -1)) {
#line 63
      goto while_break;
    }
    {
#line 64
    tmp = (*(method___1->Read))(r);
    }
#line 64
    if (tmp == 255) {
#line 65
      return (0);
    }
#line 63
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 67
  return (1);
}
}
#line 72 "/home/wheatley/newnew/temp/xmbmon-2.05/sensors.c"
static int smb_scanReg[6]  = {      0,      1,      32,      64, 
        72,      -1};
#line 77 "/home/wheatley/newnew/temp/xmbmon-2.05/sensors.c"
static int blacklist[2]  = {      210,      -1};
#line 81 "/home/wheatley/newnew/temp/xmbmon-2.05/sensors.c"
int scan_smbus(int addr_start , int addr_end , int *result ) 
{ 
  int i ;
  int j ;
  int n ;
  int r ;
  int save ;
  int reg ;
  int ret ;
  LM_METHODS *method___1 ;
  int tmp ;

  {
#line 83
  ret = 0;
#line 84
  method___1 = & method_smb;
#line 88
  if (smb_base <= 0) {
#line 89
    return (ret);
  }
#line 92
  addr_start = 2 * (addr_start / 2);
#line 93
  if (addr_start <= 0) {
#line 94
    addr_start = 2;
  }
#line 95
  if (addr_end > 254) {
#line 96
    addr_end = 254;
  }
  {
#line 98
  save = smb_slave;
#line 99
  (*(method___1->Open))();
#line 100
  j = addr_start;
#line 100
  ret = 0;
  }
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! (j <= addr_end)) {
#line 100
      goto while_break;
    }
#line 101
    smb_slave = j;
#line 102
    i = 0;
    {
#line 102
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 102
      if (! (blacklist[i] != -1)) {
#line 102
        goto while_break___0;
      }
#line 103
      if (j == blacklist[i]) {
#line 104
        goto skip;
      }
#line 102
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 109
    i = 0;
#line 109
    n = 0;
    {
#line 109
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 109
      r = smb_scanReg[i];
#line 109
      if (! (r != -1)) {
#line 109
        goto while_break___1;
      }
      {
#line 111
      reg = (*(method___1->Read))(r);
      }
#line 111
      if ((reg & 255) != 255) {
#line 112
        n ++;
      }
#line 109
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 118
    if (n) {
#line 119
      tmp = ret;
#line 119
      ret ++;
#line 119
      *(result + tmp) = j;
#line 120
      if (debug_flag > 1) {
        {
#line 121
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" SMBus slave 0x%02X(0x%02X) found...\n",
                j, j / 2);
        }
      }
    }
    skip: 
#line 125
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 100
    j += 2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 127
  (*(method___1->Close))();
#line 128
  smb_slave = save;
  }
#line 129
  return (ret);
}
}
#line 132 "/home/wheatley/newnew/temp/xmbmon-2.05/sensors.c"
int find_smb_dev(void) 
{ 


  {
  {
#line 134
  numSMBSlave = scan_smbus(0, 254, canSMBSlave);
  }
#line 134
  return (numSMBSlave);
}
}
#line 137 "/home/wheatley/newnew/temp/xmbmon-2.05/sensors.c"
int get_smb_slave(int start , int end ) 
{ 
  int i ;

  {
#line 140
  i = 0;
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! (i < numSMBSlave)) {
#line 140
      goto while_break;
    }
#line 141
    if (start <= canSMBSlave[i]) {
#line 141
      if (canSMBSlave[i] <= end) {
#line 142
        goto while_break;
      }
    }
#line 140
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  if (i >= numSMBSlave) {
#line 145
    return (0);
  } else {
#line 147
    return (canSMBSlave[i]);
  }
}
}
#line 150 "/home/wheatley/newnew/temp/xmbmon-2.05/sensors.c"
void kill_smb_slave(int slave ) 
{ 
  int i ;

  {
#line 153
  i = 0;
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if (! (i < numSMBSlave)) {
#line 153
      goto while_break;
    }
#line 154
    if (slave == canSMBSlave[i]) {
#line 155
      canSMBSlave[i] = 255;
#line 156
      goto while_break;
    }
#line 153
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 159
  return;
}
}
#line 161 "/home/wheatley/newnew/temp/xmbmon-2.05/sensors.c"
int set_smb_Extemp(int start , int end , int *temp1 , int *temp2 ) 
{ 
  int i ;
  int temp1_flag___5 ;
  int temp2_flag___5 ;

  {
#line 163
  temp1_flag___5 = 1;
#line 163
  temp2_flag___5 = 1;
#line 165
  i = 0;
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! (i < numSMBSlave)) {
#line 165
      goto while_break;
    }
#line 166
    if (start <= canSMBSlave[i]) {
#line 166
      if (canSMBSlave[i] <= end) {
#line 167
        if (temp1_flag___5) {
#line 168
          temp1_flag___5 = 0;
#line 169
          *temp1 = canSMBSlave[i];
        } else
#line 170
        if (temp2_flag___5) {
#line 171
          temp2_flag___5 = 0;
#line 172
          *temp2 = canSMBSlave[i];
        }
      }
    }
#line 165
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 176
  return ((temp1_flag___5 << 1) + temp2_flag___5);
}
}
#line 179 "/home/wheatley/newnew/temp/xmbmon-2.05/sensors.c"
void info_Extemp(LM_METHODS *method___1 , int temp1 , int temp2 ) 
{ 


  {
#line 181
  if (! temp1) {
#line 182
    if (debug_flag > 1) {
#line 183
      if ((unsigned long )method___1 == (unsigned long )(& method_smb)) {
        {
#line 184
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"* Temp1 exists at 0x%02X,",
                smb_wbtemp1);
        }
      } else {
        {
#line 186
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"* Temp1 exists at Bank 1,");
        }
      }
    }
  } else
#line 189
  if (debug_flag > 1) {
    {
#line 190
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"* NO Temp1,");
    }
  }
#line 192
  if (! temp2) {
#line 193
    if (debug_flag > 1) {
#line 194
      if ((unsigned long )method___1 == (unsigned long )(& method_smb)) {
        {
#line 195
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" Temp2 exists at 0x%02X.\n",
                smb_wbtemp2);
        }
      } else {
        {
#line 197
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" Temp2 exists at Bank 2.\n");
        }
      }
    }
  } else
#line 200
  if (debug_flag > 1) {
    {
#line 201
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" NO Temp2.\n");
    }
  }
#line 203
  return;
}
}
#line 17 "/home/wheatley/newnew/temp/xmbmon-2.05/smb_extemp.h"
float smb_ExtraTemp(void) ;
#line 16 "/home/wheatley/newnew/temp/xmbmon-2.05/smb_extemp.c"
int num_extemp_chip  =    0;
#line 17 "/home/wheatley/newnew/temp/xmbmon-2.05/smb_extemp.c"
int smb_extemp_chip[10]  ;
#line 18 "/home/wheatley/newnew/temp/xmbmon-2.05/smb_extemp.c"
int smb_extemp_slave[10]  ;
#line 28
SMBUS_IO *smbus ;
#line 43 "/home/wheatley/newnew/temp/xmbmon-2.05/smb_extemp.c"
float smb_ExtraTemp(void) 
{ 
  int slave ;
  int chipid ;
  int chip ;
  int n ;
  int k ;
  float f ;
  float offset ;
  int (*readB)(int  , int  , int  ) ;
  int (*readW)(int  , int  , int  ) ;

  {
#line 46
  n = 0;
#line 46
  k = 0;
#line 47
  f = (float )0.0;
#line 47
  offset = (float )0.0;
#line 55
  readB = smbus->ReadB;
#line 56
  readW = smbus->ReadW;
#line 59
  chip = num_extemp_chip - 1;
#line 60
  if (chip < 0) {
#line 61
    return ((float )65535);
  }
#line 63
  chipid = smb_extemp_chip[chip];
#line 64
  slave = smb_extemp_slave[chip];
#line 65
  if (chipid == 1) {
    {
#line 66
    n = (*readB)(smb_base, slave, 39);
#line 67
    f = (float )n;
    }
  } else
#line 68
  if (chipid == 2) {
    {
#line 69
    n = (*readB)(smb_base, slave, 17);
    }
#line 69
    if (n == 255) {
#line 70
      n = 0;
    }
    {
#line 71
    k = (*readB)(smb_base, slave, 18);
    }
#line 71
    if (k == 255) {
#line 72
      k = 0;
    } else {
#line 74
      k >>= 5;
    }
    {
#line 75
    offset = (float )((double )((float )n) + 0.125 * (double )((float )k));
#line 76
    n = (*readB)(smb_base, slave, 1);
#line 77
    k = (*readB)(smb_base, slave, 16);
    }
#line 77
    if (k == 255) {
#line 78
      k = 0;
    } else {
#line 80
      k >>= 5;
    }
#line 81
    if (n >= 128) {
#line 82
      k = 0;
#line 82
      n = k;
    }
#line 83
    f = (float )((double )((float )n) + 0.125 * (double )((float )k));
  } else
#line 84
  if (chipid == 3) {
    {
#line 85
    n = (*readW)(smb_base, slave, 0);
    }
#line 86
    if ((n & 255) >= 128) {
#line 87
      n = 0;
    }
#line 88
    f = (float )((double )((float )(n & 255)) + 0.5 * (double )((n & 65280) >> 15));
  }
#line 90
  return (f);
}
}
#line 101 "/home/wheatley/newnew/temp/xmbmon-2.05/pci_pm.h"
int pci_pm_smb_prob(int *hwm_base , int *smb_base___0 ) ;
#line 19 "/home/wheatley/newnew/temp/xmbmon-2.05/smbuses.h"
int set_smbus_io(int *viahwm_base___0 , int *smb_base___0 ) ;
#line 20
int chk_smbus_io(int smb_chipset , int smb_base___0 ) ;
#line 14 "/home/wheatley/newnew/temp/xmbmon-2.05/smbuses.c"
SMBUS_IO *smbus  ;
#line 15
struct smbus_io smbus_piix4 ;
#line 17
struct smbus_io smbus_ali ;
#line 18
struct smbus_io smbus_amd8 ;
#line 21 "/home/wheatley/newnew/temp/xmbmon-2.05/smbuses.c"
int set_smbus_io(int *viahwm_base___0 , int *smb_base___0 ) 
{ 
  int n ;

  {
  {
#line 25
  n = pci_pm_smb_prob(viahwm_base___0, smb_base___0);
  }
#line 29
  if (n <= 0) {
#line 30
    return (n);
  }
#line 32
  if (n / 10 == 5) {
#line 33
    smbus = & smbus_amd;
  } else
#line 34
  if (n / 10 == 6) {
#line 35
    smbus = & smbus_ali;
  } else
#line 36
  if (n / 10 == 7) {
#line 37
    smbus = & smbus_amd8;
  } else {
#line 39
    smbus = & smbus_piix4;
  }
#line 41
  return (n);
}
}
#line 55 "/home/wheatley/newnew/temp/xmbmon-2.05/smbuses.c"
int chk_smbus_io(int smb_chipset , int smb_base___0 ) 
{ 
  int n ;
  int i ;
  int j ;
  int blacklist___1[2] ;
  int (*readB)(int  , int  , int  ) ;
  int tmp ;

  {
#line 58
  blacklist___1[0] = 210;
#line 58
  blacklist___1[1] = -1;
#line 61
  if (smb_chipset <= 0) {
#line 62
    return (0);
  }
#line 67
  if (smb_chipset / 10 == 5) {
#line 68
    smbus = & smbus_amd;
  } else
#line 69
  if (smb_chipset / 10 == 6) {
#line 70
    smbus = & smbus_ali;
  } else
#line 71
  if (smb_chipset / 10 == 7) {
#line 72
    smbus = & smbus_amd8;
  } else {
#line 74
    smbus = & smbus_piix4;
  }
#line 76
  readB = smbus->ReadB;
#line 79
  n = 0;
#line 80
  i = 0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (! (i < 255)) {
#line 80
      goto while_break;
    }
#line 81
    j = 0;
    {
#line 81
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 81
      if (! (blacklist___1[j] != -1)) {
#line 81
        goto while_break___0;
      }
#line 82
      if (i != blacklist___1[j]) {
        {
#line 82
        tmp = (*readB)(smb_base___0, i, 0);
        }
#line 82
        if (tmp != -1) {
#line 83
          n ++;
        }
      }
#line 81
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 80
    i += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  return (n);
}
}
#line 5 "/home/wheatley/newnew/temp/xmbmon-2.05/io_static.c"
static int OpenIO___1(void) 
{ 
  int tmp ;

  {
#line 7
  if (iopl_counter == 0) {
    {
#line 8
    tmp = iopl(3);
    }
#line 8
    if (tmp < 0) {
#line 9
      return (-1);
    }
  }
#line 11
  iopl_counter ++;
#line 12
  return (0);
}
}
#line 15 "/home/wheatley/newnew/temp/xmbmon-2.05/io_static.c"
static void CloseIO___1(void) 
{ 


  {
#line 17
  if (iopl_counter == 1) {
    {
#line 18
    iopl(0);
    }
  }
#line 19
  if (iopl_counter > 0) {
#line 20
    iopl_counter --;
  }
#line 21
  return;
}
}
#line 32 "/home/wheatley/newnew/temp/xmbmon-2.05/tyan_tiger.c"
static int readbyte___0(int addr ) 
{ 
  int ret ;
  unsigned char tmp ;

  {
  {
#line 35
  my_outb((unsigned short )(isa_port_base + 5), (unsigned char )addr);
#line 35
  my_outb((unsigned short)235, (unsigned char)0);
#line 36
  tmp = my_inb((unsigned short )(isa_port_base + 6));
#line 36
  ret = (int )tmp;
#line 36
  my_outb((unsigned short)235, (unsigned char)0);
  }
#line 37
  return (ret & 255);
}
}
#line 40 "/home/wheatley/newnew/temp/xmbmon-2.05/tyan_tiger.c"
static void writebyte___0(int addr , int value ) 
{ 


  {
  {
#line 42
  my_outb((unsigned short )(isa_port_base + 5), (unsigned char )addr);
#line 42
  my_outb((unsigned short)235, (unsigned char)0);
#line 43
  my_outb((unsigned short )(isa_port_base + 6), (unsigned char )value);
#line 43
  my_outb((unsigned short)235, (unsigned char)0);
  }
#line 44
  return;
}
}
#line 46 "/home/wheatley/newnew/temp/xmbmon-2.05/tyan_tiger.c"
static int vendercheck(void) 
{ 
  int nv ;
  int save ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 50
  ret = 0;
#line 51
  save = isa_port_base;
#line 52
  isa_port_base = 3072;
#line 53
  tmp = readbyte___0(79);
#line 53
  nv = tmp & 255;
  }
#line 54
  if (nv == 163) {
    {
#line 55
    writebyte___0(78, 128);
#line 56
    tmp___0 = readbyte___0(79);
#line 56
    nv = tmp___0 & 255;
    }
#line 57
    if (nv == 92) {
#line 58
      ret = 1;
    }
  }
#line 60
  isa_port_base = save;
#line 61
  return (ret);
}
}
#line 65 "/home/wheatley/newnew/temp/xmbmon-2.05/tyan_tiger.c"
void TyanTigerMPinit(void) 
{ 
  unsigned char c ;
  int tmp ;

  {
  {
#line 69
  OpenIO___1();
#line 70
  tmp = vendercheck();
  }
#line 70
  if (tmp) {
    {
#line 71
    CloseIO___1();
#line 73
    isa_port_base = 3072;
    }
#line 74
    return;
  }
  {
#line 77
  my_outb((unsigned short)46, (unsigned char)135);
#line 78
  my_outb((unsigned short)46, (unsigned char)135);
#line 80
  my_outb((unsigned short)46, (unsigned char)7);
#line 81
  my_outb((unsigned short)47, (unsigned char)11);
#line 83
  my_outb((unsigned short)46, (unsigned char)96);
#line 84
  c = (unsigned char )(3072 >> 8);
#line 85
  my_outb((unsigned short)47, c);
#line 86
  my_outb((unsigned short)46, (unsigned char)97);
#line 87
  c = (unsigned char)0;
#line 88
  my_outb((unsigned short)47, c);
#line 91
  isa_port_base = 3072;
#line 93
  my_outb((unsigned short)46, (unsigned char)48);
#line 94
  my_outb((unsigned short)47, (unsigned char)1);
#line 106
  writebyte___0(64, 128);
#line 107
  writebyte___0(64, 1);
#line 109
  CloseIO___1();
  }
#line 111
  return;
}
}
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 61 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm85.c"
static int lm85chipid  =    0;
#line 63 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm85.c"
static float Vfac  ;
#line 65
static int lm85_probe(LM_METHODS *method___1 ) ;
#line 66
static int lm85_chk(LM_METHODS *method___1 ) ;
#line 67
static float lm85_temp(LM_METHODS *method___1 , int no ) ;
#line 68
static int lm85_fanrpm(LM_METHODS *method___1 , int no ) ;
#line 69
static float lm85_volt(LM_METHODS *method___1 , int no ) ;
#line 76 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm85.c"
static char buff[128]  ;
#line 78 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm85.c"
static int adm_24fan[2]  = {      0,      0};
#line 80 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm85.c"
SENSOR lm85  =    {buff, & lm85_probe, & lm85_temp, & lm85_volt, & lm85_fanrpm};
#line 99 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm85.c"
static char *lm85chip[8]  = 
#line 99
  {      (char *)"No Sensor",      (char *)"Nat.Semi.Con. Chip LM85",      (char *)"SMSC Chip EMC6D10X",      (char *)"Analog Dev. Chip ADM1024", 
        (char *)"Analog Dev. Chip ADM1025",      (char *)"Analog Dev. Chip ADM1027",      (char *)"Analog Dev. Chip ADT7463",      (char *)((void *)0)};
#line 113 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm85.c"
static int chkReg[45]  = 
#line 113
  {      32,      33,      34,      35, 
        36,      37,      38,      39, 
        40,      41,      42,      43, 
        44,      45,      46,      47, 
        48,      49,      50,      51, 
        52,      53,      54,      55, 
        56,      57,      58,      59, 
        60,      61,      62,      63, 
        64,      65,      66,      67, 
        112,      113,      114,      115, 
        118,      119,      120,      123, 
        -1};
#line 131 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm85.c"
static int lm85_probe(LM_METHODS *method___1 ) 
{ 
  int n ;
  int save ;
  int tmp ;
  int tmp___0 ;

  {
#line 135
  if ((unsigned long )method___1 != (unsigned long )(& method_smb)) {
#line 136
    return (0);
  }
#line 138
  save = smb_slave;
#line 140
  n = 88;
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! (n <= 92)) {
#line 140
      goto while_break;
    }
    {
#line 141
    smb_slave = get_smb_slave(n, 92);
    }
#line 141
    if (smb_slave) {
      {
#line 144
      tmp = lm85_chk(method___1);
      }
#line 144
      if (tmp) {
        {
#line 144
        tmp___0 = chkReg_Probe(smb_slave, (char *)"Probing LM85/compatible chip:\n",
                               chkReg, method___1);
        }
#line 144
        if (tmp___0 >= 20) {
#line 148
          goto ret1;
        } else {
#line 150
          n = smb_slave + 2;
        }
      } else {
#line 150
        n = smb_slave + 2;
      }
    } else {
#line 142
      goto ret0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  ret0: 
#line 155
  smb_slave = save;
#line 156
  return (0);
  ret1: 
  {
#line 158
  kill_smb_slave(smb_slave);
  }
#line 159
  if (lm85chipid == 3) {
    {
#line 160
    n = (*(method___1->Read))(22);
#line 161
    adm_24fan[0] = n & 1;
#line 162
    adm_24fan[1] = n & 2;
    }
  }
#line 164
  if (lm85chipid < 5) {
#line 165
    Vfac = (float )(1. / (double )((float )255));
  } else {
#line 167
    Vfac = (float )(1. / (double )((float )1023));
  }
#line 168
  return (lm85chipid);
}
}
#line 171 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm85.c"
static int lm85_chk(LM_METHODS *method___1 ) 
{ 
  int vendor ;
  int verstep ;

  {
  {
#line 175
  vendor = (*(method___1->Read))(62);
#line 176
  verstep = (*(method___1->Read))(63);
  }
#line 178
  if (vendor == 1) {
#line 179
    if ((verstep & 240) == 96) {
#line 180
      lm85chipid = 1;
    } else {
#line 182
      goto ret0;
    }
  } else
#line 183
  if (vendor == 65) {
#line 184
    if ((verstep & 240) == 16) {
#line 185
      lm85chipid = 3;
    } else
#line 186
    if ((verstep & 240) == 32) {
#line 187
      lm85chipid = 4;
    } else
#line 188
    if (verstep == 96) {
#line 189
      lm85chipid = 5;
    } else
#line 190
    if (verstep == 98) {
#line 191
      lm85chipid = 6;
    } else {
#line 193
      goto ret0;
    }
  } else
#line 194
  if (vendor == 92) {
#line 195
    if ((verstep & 240) == 96) {
#line 196
      lm85chipid = 2;
    } else {
#line 198
      goto ret0;
    }
  } else {
#line 200
    goto ret0;
  }
  {
#line 202
  strcpy((char */* __restrict  */)(buff), (char const   */* __restrict  */)lm85chip[lm85chipid]);
  }
#line 203
  return (lm85chipid);
  ret0: 
#line 205
  return (0);
}
}
#line 213 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm85.c"
static float lm85_temp(LM_METHODS *method___1 , int no ) 
{ 
  int n ;
  int ne ;
  float ext ;
  float offset ;

  {
#line 216
  ext = (float )0.0;
#line 216
  offset = (float )0.0;
#line 218
  if (no < 0) {
#line 219
    return ((float )65535);
  } else
#line 218
  if (2 < no) {
#line 219
    return ((float )65535);
  }
#line 221
  if (lm85chipid == 3) {
#line 221
    goto _L;
  } else
#line 221
  if (lm85chipid == 4) {
    _L: /* CIL Label */ 
#line 222
    if (no == 2) {
#line 223
      return ((float )65535);
    } else {
#line 225
      no ++;
    }
  } else
#line 226
  if (lm85chipid >= 5) {
    {
#line 227
    ne = (*(method___1->Read))(119);
#line 228
    ext = (float )(0.25 * (double )((ne >> (no + 1) * 2) & 3));
#line 229
    n = (*(method___1->Read))(112 + no);
    }
#line 230
    if (n > 128) {
#line 231
      n -= 255;
    }
#line 232
    offset = (float )n;
  }
  {
#line 234
  n = (*(method___1->Read))(37 + no);
  }
#line 235
  if (n == 128) {
#line 236
    return ((float )65535);
  } else
#line 237
  if (n > 128) {
#line 238
    return (((float )(n - 255) + ext) - offset);
  } else {
#line 240
    return (((float )n + ext) - offset);
  }
}
}
#line 249 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm85.c"
static float Vtab[5]  = {      (float )((2.5 * 4.) / 3.),      (float )((2.25 * 4.) / 3.),      (float )((3.3 * 4.) / 3.),      (float )((5.0 * 4.) / 3.), 
        (float )((12.0 * 4.) / 3.)};
#line 257 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm85.c"
static float lm85_volt(LM_METHODS *method___1 , int no ) 
{ 
  int n ;
  int ne ;
  int tmp ;
  int tmp___0 ;

  {
#line 259
  ne = 0;
#line 261
  if (no < 0) {
#line 262
    return ((float )65535);
  } else
#line 261
  if (4 < no) {
#line 262
    return ((float )65535);
  }
#line 264
  if (lm85chipid >= 5) {
#line 265
    if (no == 4) {
      {
#line 266
      tmp = (*(method___1->Read))(119);
#line 266
      ne = tmp & 3;
      }
    } else {
      {
#line 268
      tmp___0 = (*(method___1->Read))(118);
#line 268
      ne = (tmp___0 >> no * 2) & 3;
      }
    }
  }
  {
#line 270
  n = (*(method___1->Read))(32 + no);
  }
#line 271
  if (lm85chipid >= 5) {
#line 272
    n = (n << 2) | ne;
  }
#line 274
  return ((Vtab[no] * Vfac) * (float )n);
}
}
#line 288 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm85.c"
static int ppr[4]  = {      2,      2,      2,      2};
#line 288 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm85.c"
static int div[2]  = {      1,      1};
#line 284 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm85.c"
static int lm85_fanrpm(LM_METHODS *method___1 , int no ) 
{ 
  int lsb ;
  int msb ;
  int r ;
  int n ;
  int p ;
  int tmp ;

  {
#line 287
  p = 2;
#line 290
  if (no < 0) {
#line 291
    return (65535);
  } else
#line 290
  if (3 < no) {
#line 291
    return (65535);
  } else
#line 290
  if (lm85chipid == 4) {
#line 291
    return (65535);
  }
#line 293
  if (lm85chipid == 3) {
#line 294
    if (no > 1) {
#line 295
      return (65535);
    } else
#line 294
    if (adm_24fan[no]) {
#line 295
      return (65535);
    }
    {
#line 296
    n = (*(method___1->Read))(71);
#line 297
    div[0] = (n >> 4) & 3;
#line 298
    div[1] = n >> 6;
#line 299
    r = (*(method___1->Read))(40 + no);
    }
#line 300
    if (r == 0) {
#line 301
      return (65535);
    } else
#line 302
    if (r == 255) {
#line 304
      if (div[no] < 3) {
#line 305
        (div[no]) ++;
      } else {
#line 307
        div[no] = 0;
      }
      {
#line 308
      r = ((n & 15) | (div[0] << 4)) | (div[1] << 6);
#line 309
      (*(method___1->Write))(71, r);
      }
#line 310
      return (65535);
    } else {
#line 312
      return (1350000 / (r * (1 << div[no])));
    }
  }
#line 315
  if (lm85chipid >= 5) {
    {
#line 316
    tmp = (*(method___1->Read))(123);
#line 316
    p = ((tmp >> no * 2) & 3) + 1;
    }
  }
  {
#line 317
  ppr[no] = p;
#line 319
  lsb = (*(method___1->Read))(40 + no * 2);
#line 320
  msb = (*(method___1->Read))(41 + no * 2);
  }
#line 321
  if (lsb == 255) {
#line 321
    if (msb == 255) {
#line 322
      return (65535);
    } else {
#line 321
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 321
  if (lsb == 0) {
#line 321
    if (msb == 0) {
#line 322
      return (65535);
    } else {
#line 324
      return (5400000 / (p * ((msb << 8) | lsb)));
    }
  } else {
#line 324
    return (5400000 / (p * ((msb << 8) | lsb)));
  }
}
}
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 460 "/usr/include/unistd.h"
extern int usleep(__useconds_t __useconds ) ;
#line 23 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.h"
static char *winbchip[16]  = 
#line 23 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.h"
  {      (char *)"No Sensor",      (char *)"Winbond Chip W83781D",      (char *)"Winbond Chip W83782D",      (char *)"Winbond Chip W83783S", 
        (char *)"Winbond Chip W83791D",      (char *)"Winbond Chip W83627HF/THF/THF-A",      (char *)"Winbond Chip W83697HF",      (char *)"Winbond unknown Chip", 
        (char *)"Asus Chip AS99127F",      (char *)"Asus Chip ASB100(Bach)",      (char *)"Asus Chip ASM58(Mozart-2)",      (char *)"Nat.Semi.Con. Chip LM78", 
        (char *)"Nat.Semi.Con. Chip LM79",      (char *)"Analog Dev. Chip ADM9240",      (char *)"Unknown Chip assuming LM78",      (char *)((void *)0)};
#line 59 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.c"
extern int pm_smb_detected ;
#line 62
int smb_wbtemp1_flag ;
#line 62
int smb_wbtemp2_flag ;
#line 65
extern int TyanTigerMP_flag ;
#line 96
static int winbond_probe(LM_METHODS *method___1 ) ;
#line 97
static int winbond_probe_act(LM_METHODS *method___1 , int slave ) ;
#line 98
static float winbond_temp(LM_METHODS *method___1 , int no ) ;
#line 99
static int winbond_fanrpm(LM_METHODS *method___1 , int no ) ;
#line 100
static float winbond_volt(LM_METHODS *method___1 , int no ) ;
#line 103 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.c"
static char buff___0[128]  ;
#line 105 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.c"
SENSOR winbond  =    {buff___0, & winbond_probe, & winbond_temp, & winbond_volt, & winbond_fanrpm};
#line 114 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.c"
static int wbdchipid  =    0;
#line 115 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.c"
static int wbdlmid  =    0;
#line 118 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.c"
static int temp1_flag  =    0;
#line 119 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.c"
static int temp2_flag  =    0;
#line 120 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.c"
static int temp1_addr  =    0;
#line 121 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.c"
static int temp2_addr  =    0;
#line 124 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.c"
static int fan12div_reg  =    71;
#line 129 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.c"
static int chkReg___0[33]  = 
#line 129
  {      64,      65,      66,      67, 
        68,      69,      70,      71, 
        72,      73,      74,      75, 
        76,      77,      78,      79, 
        86,      88,      89,      93, 
        62,      19,      23,      161, 
        32,      34,      35,      36, 
        39,      41,      42,      43, 
        -1};
#line 141 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.c"
static void Temp_Bipolar(LM_METHODS *method___1 ) 
{ 
  int n ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 145
  tmp = (*(method___1->Read))(89);
#line 145
  n = tmp & 143;
#line 146
  (*(method___1->Write))(89, n);
#line 147
  tmp___0 = (*(method___1->Read))(93);
#line 147
  n = tmp___0 | 14;
#line 148
  (*(method___1->Write))(93, n);
  }
#line 149
  return;
}
}
#line 151 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.c"
static void Init_FanDiv(LM_METHODS *method___1 ) 
{ 
  int n ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 155
  tmp = (*(method___1->Read))(71);
#line 155
  n = (tmp & 15) | 160;
#line 156
  (*(method___1->Write))(71, n);
#line 157
  tmp___0 = (*(method___1->Read))(75);
#line 157
  n = (tmp___0 & 63) | 128;
#line 158
  (*(method___1->Write))(75, n);
  }
#line 159
  return;
}
}
#line 164 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.c"
static int winbond_probe(LM_METHODS *method___1 ) 
{ 
  int n ;
  int save ;
  int slave ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 166
  slave = 0;
#line 168
  if ((unsigned long )method___1 != (unsigned long )(& method_isa)) {
#line 168
    if ((unsigned long )method___1 != (unsigned long )(& method_smb)) {
#line 169
      return (0);
    }
  }
#line 171
  save = smb_slave;
#line 173
  if ((unsigned long )method___1 == (unsigned long )(& method_smb)) {
    {
#line 175
    slave = get_smb_slave(238, 238);
    }
#line 175
    if (slave) {
      {
#line 176
      tmp = winbond_probe_act(method___1, slave);
      }
#line 176
      if (tmp) {
#line 177
        goto ret1;
      }
    }
#line 179
    n = 80;
    {
#line 179
    while (1) {
      while_continue: /* CIL Label */ ;
#line 179
      if (! (n <= 94)) {
#line 179
        goto while_break;
      }
      {
#line 180
      slave = get_smb_slave(n, 94);
      }
#line 180
      if (slave) {
        {
#line 183
        tmp___0 = winbond_probe_act(method___1, slave);
        }
#line 183
        if (tmp___0) {
#line 184
          goto ret1;
        } else {
#line 186
          n = slave + 2;
        }
      } else {
#line 181
        goto ret0;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 189
    goto ret0;
  } else {
    {
#line 191
    tmp___1 = winbond_probe_act(method___1, slave);
    }
#line 191
    if (tmp___1) {
#line 192
      goto ret1;
    }
  }
  ret0: 
#line 196
  smb_slave = save;
#line 197
  return (0);
  ret1: 
#line 200
  if (TyanTigerMP_flag) {
    {
#line 201
    Temp_Bipolar(method___1);
#line 202
    usleep((__useconds_t )30000);
#line 203
    Init_FanDiv(method___1);
    }
  }
#line 205
  if ((unsigned long )method___1 == (unsigned long )(& method_smb)) {
    {
#line 206
    kill_smb_slave(slave);
    }
#line 207
    if (! smb_wbtemp1_flag) {
      {
#line 208
      kill_smb_slave(smb_wbtemp1);
      }
    }
#line 209
    if (! smb_wbtemp2_flag) {
      {
#line 210
      kill_smb_slave(smb_wbtemp2);
      }
    }
  }
#line 212
  return (wbdchipid);
}
}
#line 215 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.c"
static int winbond_probe_act(LM_METHODS *method___1 , int slave ) 
{ 
  int i ;
  int n ;
  int nd ;
  int nc ;
  int nvl ;
  int nvu ;
  int nvx ;
  int nva ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 219
  if ((unsigned long )method___1 == (unsigned long )(& method_smb)) {
#line 220
    smb_slave = slave;
  } else {
#line 222
    slave = 0;
  }
  {
#line 224
  tmp = chkReg_Probe(slave, (char *)"Probing Winbond/Asus/LM78/79 chip:\n", chkReg___0,
                     method___1);
  }
#line 224
  if (tmp < 8) {
#line 226
    goto ret0;
  }
  {
#line 228
  tmp___0 = (*(method___1->Read))(73);
#line 228
  nd = tmp___0 & 254;
#line 229
  nc = (*(method___1->Read))(88);
#line 230
  nvx = (*(method___1->Read))(78);
#line 231
  (*(method___1->Write))(78, 0);
#line 232
  nvl = (*(method___1->Read))(79);
#line 233
  (*(method___1->Write))(78, 128);
#line 234
  nvu = (*(method___1->Read))(79);
#line 235
  nva = (*(method___1->Read))(62);
  }
#line 240
  if (nvl == 163) {
#line 240
    if (nvu == 92) {
      {
#line 242
      if ((nc & 254) == 16) {
#line 242
        goto case_16;
      }
#line 247
      if ((nc & 254) == 26) {
#line 247
        goto case_26;
      }
#line 247
      if ((nc & 254) == 144) {
#line 247
        goto case_26;
      }
#line 247
      if ((nc & 254) == 32) {
#line 247
        goto case_26;
      }
#line 250
      if ((nc & 254) == 48) {
#line 250
        goto case_48;
      }
#line 255
      if ((nc & 254) == 64) {
#line 255
        goto case_64;
      }
#line 258
      if ((nc & 254) == 96) {
#line 258
        goto case_96;
      }
#line 261
      if ((nc & 254) == 112) {
#line 261
        goto case_112;
      }
#line 264
      goto switch_default;
      case_16: /* CIL Label */ 
#line 243
      wbdchipid = 1;
#line 244
      goto switch_break;
      case_26: /* CIL Label */ 
      case_144: /* CIL Label */ 
      case_32: /* CIL Label */ 
#line 248
      wbdchipid = 5;
#line 249
      goto switch_break;
      case_48: /* CIL Label */ 
#line 251
      wbdchipid = 2;
#line 252
      if (nc == 49) {
#line 253
        wbdchipid = 8;
      }
#line 254
      goto switch_break;
      case_64: /* CIL Label */ 
#line 256
      wbdchipid = 3;
#line 257
      goto switch_break;
      case_96: /* CIL Label */ 
#line 259
      wbdchipid = 6;
#line 260
      goto switch_break;
      case_112: /* CIL Label */ 
#line 262
      wbdchipid = 4;
#line 263
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 268
      goto ret0;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 240
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 271
  if (nvl == 195) {
#line 271
    if (nvu == 18) {
#line 271
      if (nc == 49) {
#line 272
        wbdchipid = 8;
      } else {
#line 271
        goto _L___7;
      }
    } else {
#line 271
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
#line 273
  if (nvl == 148) {
#line 273
    if (nvu == 6) {
#line 273
      if (nc == 49) {
#line 274
        wbdchipid = 9;
      } else {
#line 273
        goto _L___5;
      }
    } else {
#line 273
      goto _L___5;
    }
  } else
  _L___5: /* CIL Label */ 
#line 275
  if (smb_slave == 238) {
#line 275
    if (nvx == 148) {
#line 275
      if (nvl == 54) {
#line 275
        if (nc == 86) {
#line 279
          wbdchipid = 10;
        } else {
#line 275
          goto _L___3;
        }
      } else {
#line 275
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 275
    if (nvx == 148) {
#line 275
      if (nvl == 6) {
#line 275
        if (nc == 86) {
#line 279
          wbdchipid = 10;
        } else {
#line 275
          goto _L___1;
        }
      } else {
#line 275
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 275
    if (nvx == 92) {
#line 275
      if (nvl == 163) {
#line 275
        if (nc == 16) {
#line 279
          wbdchipid = 10;
        } else {
#line 275
          goto _L;
        }
      } else {
#line 275
        goto _L;
      }
    } else {
#line 275
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 280
  if (nd == 32) {
#line 281
    wbdchipid = 11;
  } else
#line 280
  if (nd == 64) {
#line 281
    wbdchipid = 11;
  } else
#line 282
  if (nd == 192) {
#line 283
    wbdchipid = 12;
  } else
#line 284
  if (nva == 35) {
#line 285
    wbdchipid = 13;
  } else {
#line 290
    goto ret0;
  }
  {
#line 293
  strcpy((char */* __restrict  */)(buff___0), (char const   */* __restrict  */)winbchip[wbdchipid]);
#line 295
  wbdlmid = wbdchipid;
  }
#line 296
  if (wbdchipid == 7) {
#line 297
    wbdlmid = 1;
  } else
#line 296
  if (wbdchipid >= 11) {
#line 297
    wbdlmid = 1;
  }
#line 299
  if (wbdchipid == 9) {
#line 300
    wbdlmid = 1;
  }
#line 302
  if (wbdchipid == 10) {
    {
#line 303
    wbdlmid = 1;
#line 304
    temp2_flag = 1;
#line 304
    temp1_flag = temp2_flag;
#line 305
    fan12div_reg = 161;
#line 306
    (*(method___1->Write))(64, 1);
    }
#line 307
    goto ret1;
  }
#line 310
  if (wbdchipid == 13) {
    {
#line 311
    temp2_flag = 1;
#line 311
    temp1_flag = temp2_flag;
#line 312
    (*(method___1->Write))(64, 1);
    }
#line 313
    goto ret1;
  }
#line 316
  if ((unsigned long )method___1 == (unsigned long )(& method_isa)) {
#line 316
    if (wbdchipid >= 11) {
#line 317
      temp2_flag = 1;
#line 317
      temp1_flag = temp2_flag;
#line 318
      goto ret1;
    }
  }
#line 323
  if (wbdchipid >= 11) {
    {
#line 324
    i = set_smb_Extemp(144, 158, & smb_wbtemp2, & smb_wbtemp1);
#line 326
    temp2_flag = i >> 1;
#line 327
    temp1_flag = i & 1;
#line 328
    info_Extemp(method___1, temp1_flag, temp2_flag);
    }
#line 329
    if (! temp1_flag) {
      {
#line 330
      strcat((char */* __restrict  */)winbond.Name, (char const   */* __restrict  */)"+LM75");
      }
    } else
#line 329
    if (! temp2_flag) {
      {
#line 330
      strcat((char */* __restrict  */)winbond.Name, (char const   */* __restrict  */)"+LM75");
      }
    }
#line 331
    goto ret1;
  }
  {
#line 334
  n = (*(method___1->Read))(74);
#line 335
  temp1_flag = (n & 8) >> 3;
  }
#line 335
  if (! temp1_flag) {
    {
#line 336
    temp1_addr = smb_wbtemp1;
#line 337
    smb_wbtemp1 = 2 * (72 + (n & 7));
#line 338
    tmp___1 = (*(method___1->ReadTemp1))();
    }
#line 338
    if (tmp___1 == 65535) {
#line 339
      temp1_flag = 1;
#line 340
      smb_wbtemp1 = temp1_addr;
    }
  }
#line 344
  temp2_flag = (n & 128) >> 7;
#line 344
  if (! temp2_flag) {
    {
#line 345
    temp2_addr = smb_wbtemp2;
#line 346
    smb_wbtemp2 = 2 * (72 + ((n & 112) >> 4));
#line 347
    tmp___2 = (*(method___1->ReadTemp2))();
    }
#line 347
    if (tmp___2 == 65535) {
#line 348
      temp2_flag = 1;
#line 349
      smb_wbtemp2 = temp2_addr;
    }
  }
  {
#line 352
  info_Extemp(method___1, temp1_flag, temp2_flag);
  }
  ret1: 
#line 355
  if ((unsigned long )method___1 == (unsigned long )(& method_smb)) {
#line 356
    smb_wbtemp1_flag = temp1_flag;
#line 357
    smb_wbtemp2_flag = temp2_flag;
  }
#line 359
  return (wbdchipid);
  ret0: 
#line 361
  return (0);
}
}
#line 370 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.c"
static float winbond_temp(LM_METHODS *method___1 , int no ) 
{ 
  int n ;
  float f ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 372
  n = 0;
#line 375
  if (no < 0) {
#line 376
    return ((float )65535);
  } else
#line 375
  if (2 < no) {
#line 376
    return ((float )65535);
  }
#line 377
  if (no == 2) {
#line 377
    if (wbdchipid == 3) {
#line 379
      return ((float )65535);
    } else
#line 377
    if (wbdchipid == 6) {
#line 379
      return ((float )65535);
    } else
#line 377
    if (wbdchipid == 10) {
#line 379
      return ((float )65535);
    }
  }
#line 381
  if (no == 0) {
    {
#line 382
    tmp = (*(method___1->Read))(39);
#line 382
    f = (float )tmp;
    }
#line 383
    if (wbdchipid == 13) {
      {
#line 384
      n = (*(method___1->Read))(75);
      }
#line 385
      if (n & 128) {
#line 386
        f = (float )((double )f + 0.5);
      }
    }
#line 388
    return (f);
  } else
#line 389
  if (no == 1) {
#line 390
    if (wbdchipid == 9) {
      {
#line 391
      tmp___0 = (*(method___1->Read))(23);
      }
#line 391
      return ((float )tmp___0);
    }
#line 392
    if (wbdchipid == 10) {
      {
#line 393
      tmp___1 = (*(method___1->Read))(19);
      }
#line 393
      return ((float )tmp___1);
    } else
#line 394
    if (! temp1_flag) {
      {
#line 395
      n = (*(method___1->ReadTemp1))();
      }
    }
  } else
#line 399
  if (no == 2) {
#line 400
    if (wbdchipid == 9) {
#line 401
      if (! temp1_flag) {
        {
#line 402
        n = (*(method___1->ReadTemp1))();
        }
      }
    } else
#line 403
    if (! temp2_flag) {
      {
#line 405
      n = (*(method___1->ReadTemp2))();
      }
    }
  }
#line 408
  if ((n & 255) >= 128) {
#line 409
    n = 0;
  }
#line 411
  f = (float )((double )((float )(n & 255)) + 0.5 * (double )((n & 65280) >> 15));
#line 413
  if (wbdchipid == 8) {
#line 413
    if (pm_smb_detected == 41) {
#line 415
      if (no == 1) {
#line 415
        if (- 32.0 < (double )f) {
#line 415
          if ((double )f <= 105.0) {
#line 416
            f = (float )((double )f * 0.697);
#line 417
            f = (float )((double )f + 25.0);
          }
        }
      }
    }
  }
#line 420
  return (f);
}
}
#line 428 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.c"
static float winbond_volt(LM_METHODS *method___1 , int no ) 
{ 
  int n ;
  float f ;

  {
#line 431
  f = (float )0.0;
#line 433
  if (no < 0) {
#line 434
    return ((float )65535);
  } else
#line 433
  if (6 < no) {
#line 434
    return ((float )65535);
  }
#line 435
  if (wbdchipid == 10) {
#line 435
    if (no == 1) {
#line 436
      return ((float )65535);
    } else
#line 435
    if (no > 4) {
#line 436
      return ((float )65535);
    }
  }
#line 437
  if (wbdchipid == 13) {
#line 437
    if (no > 5) {
#line 438
      return ((float )65535);
    }
  }
  {
#line 440
  n = (*(method___1->Read))(32 + no);
  }
  {
#line 444
  if (no == 2) {
#line 444
    goto case_2;
  }
#line 444
  if (no == 1) {
#line 444
    goto case_2;
  }
#line 444
  if (no == 0) {
#line 444
    goto case_2;
  }
#line 447
  if (no == 3) {
#line 447
    goto case_3;
  }
#line 450
  if (no == 4) {
#line 450
    goto case_4;
  }
#line 453
  if (no == 5) {
#line 453
    goto case_5;
  }
#line 461
  if (no == 6) {
#line 461
    goto case_6;
  }
#line 441
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 445
  f = (float )((double )n * 0.016);
#line 446
  goto switch_break;
  case_3: /* CIL Label */ 
#line 448
  f = (float )(((double )n * 0.016) * 1.68);
#line 449
  goto switch_break;
  case_4: /* CIL Label */ 
#line 451
  f = (float )(((double )n * 0.016) * 3.800);
#line 452
  goto switch_break;
  case_5: /* CIL Label */ 
#line 454
  if (wbdlmid == 8) {
#line 455
    f = (float )(((double )(- n) * 0.016) * 3.968);
  } else
#line 456
  if (wbdlmid == 1) {
#line 457
    f = (float )(((double )(- n) * 0.016) * 3.477);
  } else {
#line 459
    f = (float )(((double )n * 0.016 - 3.6 * 0.8056) / 0.1944);
  }
#line 460
  goto switch_break;
  case_6: /* CIL Label */ 
#line 462
  if (wbdlmid == 1) {
#line 463
    f = (float )(((double )(- n) * 0.016) * 1.500);
  } else
#line 462
  if (wbdlmid == 8) {
#line 463
    f = (float )(((double )(- n) * 0.016) * 1.500);
  } else {
#line 465
    f = (float )(((double )n * 0.016 - 3.6 * 0.6818) / 0.3182);
  }
  switch_break: /* CIL Label */ ;
  }
#line 468
  return (f);
}
}
#line 508 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.c"
static int div___0[3]  = {      1,      1,      1};
#line 505 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.c"
static int winbond_fanrpm(LM_METHODS *method___1 , int no ) 
{ 
  int r ;
  int n1 ;
  int n2 ;
  int n3 ;

  {
#line 507
  n1 = 80;
#line 507
  n2 = 64;
#line 507
  n3 = 0;
#line 510
  if (no < 0) {
#line 511
    return (65535);
  } else
#line 510
  if (2 < no) {
#line 511
    return (65535);
  }
#line 512
  if (no == 2) {
#line 512
    if (wbdchipid == 6) {
#line 515
      return (65535);
    } else
#line 512
    if (wbdchipid == 10) {
#line 515
      return (65535);
    } else
#line 512
    if (wbdchipid == 13) {
#line 515
      return (65535);
    }
  }
#line 517
  if (2 <= wbdchipid) {
#line 517
    if (wbdchipid <= 6) {
      {
#line 518
      n3 = (*(method___1->Read))(93);
      }
    }
  }
#line 519
  if (no != 2) {
    {
#line 520
    n1 = (*(method___1->Read))(fan12div_reg);
#line 521
    div___0[0] = ((n1 >> 4) & 3) | ((n3 & 32) >> 3);
#line 522
    div___0[1] = (n1 >> 6) | ((n3 & 64) >> 4);
    }
  } else
#line 523
  if (wbdchipid < 11) {
    {
#line 524
    n2 = (*(method___1->Read))(75);
#line 525
    div___0[2] = (n2 >> 6) | ((n3 & 128) >> 5);
    }
  }
  {
#line 528
  r = (*(method___1->Read))(40 + no);
  }
#line 529
  if (r == 255) {
#line 531
    if (no != 2) {
#line 532
      if (div___0[no] < 3) {
#line 533
        (div___0[no]) ++;
      } else {
#line 535
        div___0[no] = 0;
      }
      {
#line 536
      r = ((n1 & 15) | ((div___0[0] & 3) << 4)) | ((div___0[1] & 3) << 6);
#line 537
      (*(method___1->Write))(fan12div_reg, r);
      }
    } else
#line 538
    if (wbdchipid < 11) {
#line 539
      if (div___0[no] < 3) {
#line 540
        (div___0[no]) ++;
      } else {
#line 542
        div___0[no] = 0;
      }
      {
#line 543
      r = (n2 & 63) | ((div___0[2] & 3) << 6);
#line 544
      (*(method___1->Write))(75, r);
      }
    }
#line 546
    if (2 <= wbdchipid) {
#line 546
      if (wbdchipid <= 6) {
        {
#line 547
        r = (((n3 & 31) | ((div___0[0] & 4) << 3)) | ((div___0[1] & 4) << 4)) | ((div___0[2] & 4) << 5);
#line 549
        (*(method___1->Write))(93, r);
        }
      }
    }
#line 551
    return (65535);
  } else
#line 552
  if (r == 0) {
#line 553
    return (65535);
  }
#line 556
  return (1350000 / (r * (1 << div___0[no])));
}
}
#line 45 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm90.c"
static int lm90chipid  =    0;
#line 47
static int lm90_probe(LM_METHODS *method___1 ) ;
#line 48
static int lm90_ident(LM_METHODS *method___1 ) ;
#line 49
static float lm90_temp(LM_METHODS *method___1 , int no ) ;
#line 50
static int lm90_fanrpm(LM_METHODS *method___1 , int no ) ;
#line 51
static float lm90_volt(LM_METHODS *method___1 , int no ) ;
#line 54 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm90.c"
static char buff___1[128]  ;
#line 56 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm90.c"
SENSOR lm90  =    {buff___1, & lm90_probe, & lm90_temp, & lm90_volt, & lm90_fanrpm};
#line 71 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm90.c"
static char *lm90chip[5]  = {      (char *)"No Sensor",      (char *)"Nat.Semi.Con. Chip LM90",      (char *)"Analog Dev. Chip ADM1020",      (char *)"Analog Dev. Chip ADM1021/1023", 
        (char *)((void *)0)};
#line 82 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm90.c"
static int chkReg___1[21]  = 
#line 82
  {      0,      1,      2,      3, 
        4,      5,      6,      7, 
        8,      16,      17,      18, 
        19,      20,      25,      32, 
        33,      191,      254,      255, 
        -1};
#line 94 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm90.c"
static int lm90_probe(LM_METHODS *method___1 ) 
{ 
  int n ;
  int save ;
  int tmp ;
  int tmp___0 ;

  {
#line 98
  if ((unsigned long )method___1 != (unsigned long )(& method_smb)) {
#line 99
    return (0);
  }
#line 101
  save = smb_slave;
#line 103
  n = 144;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! (n <= 158)) {
#line 103
      goto while_break;
    }
    {
#line 104
    smb_slave = get_smb_slave(n, 158);
    }
#line 104
    if (smb_slave) {
      {
#line 107
      tmp = lm90_ident(method___1);
      }
#line 107
      if (tmp) {
        {
#line 107
        tmp___0 = chkReg_Probe(smb_slave, (char *)"Probing LM90 chip:\n", chkReg___1,
                               method___1);
        }
#line 107
        if (tmp___0 >= 8) {
#line 110
          goto ret1;
        } else {
#line 112
          n = smb_slave + 2;
        }
      } else {
#line 112
        n = smb_slave + 2;
      }
    } else {
#line 105
      goto ret0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  ret0: 
#line 117
  smb_slave = save;
#line 118
  return (0);
  ret1: 
  {
#line 120
  kill_smb_slave(smb_slave);
#line 121
  strcpy((char */* __restrict  */)(buff___1), (char const   */* __restrict  */)lm90chip[lm90chipid]);
  }
#line 122
  return (lm90chipid);
}
}
#line 125 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm90.c"
static int lm90_ident(LM_METHODS *method___1 ) 
{ 
  int vend ;
  int revd ;
  int tmp ;

  {
  {
#line 129
  vend = (*(method___1->Read))(254);
#line 130
  revd = (*(method___1->Read))(255);
  }
#line 131
  if (vend == 1) {
#line 131
    if (revd == 33) {
#line 132
      lm90chipid = 1;
    } else {
#line 131
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 133
  if (vend == 65) {
#line 134
    if (revd) {
#line 134
      tmp = 1;
    } else {
#line 134
      tmp = 0;
    }
#line 134
    if (tmp == 48) {
#line 135
      lm90chipid = 3;
    } else {
#line 137
      lm90chipid = 2;
    }
  }
#line 140
  return (lm90chipid);
}
}
#line 148 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm90.c"
static float lm90_temp(LM_METHODS *method___1 , int no ) 
{ 
  int n ;
  int k ;
  float offset ;

  {
#line 150
  n = 0;
#line 150
  k = 0;
#line 151
  offset = (float )0.0;
#line 153
  if (no < 0) {
#line 154
    return ((float )65535);
  } else
#line 153
  if (2 < no) {
#line 154
    return ((float )65535);
  }
#line 156
  if (no == 0) {
    {
#line 157
    n = (*(method___1->Read))(0);
    }
  } else
#line 158
  if (no == 1) {
#line 159
    if (lm90chipid != 2) {
      {
#line 160
      n = (*(method___1->Read))(17);
      }
#line 160
      if (n == 255) {
#line 161
        n = 0;
      }
      {
#line 162
      k = (*(method___1->Read))(18);
      }
#line 162
      if (k == 255) {
#line 163
        k = 0;
      } else {
#line 165
        k >>= 5;
      }
#line 166
      offset = (float )((double )((float )n) + 0.125 * (double )((float )k));
    }
    {
#line 168
    n = (*(method___1->Read))(1);
#line 169
    k = (*(method___1->Read))(16);
    }
#line 169
    if (k == 255) {
#line 170
      k = 0;
    } else {
#line 172
      k >>= 5;
    }
  }
#line 174
  if (n >= 128) {
#line 175
    k = 0;
#line 175
    n = k;
  }
#line 177
  return ((float )(((double )((float )n) + 0.125 * (double )((float )k)) - (double )offset));
}
}
#line 182 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm90.c"
static float lm90_volt(LM_METHODS *method___1 , int no ) 
{ 


  {
#line 184
  return ((float )65535);
}
}
#line 187 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm90.c"
static int lm90_fanrpm(LM_METHODS *method___1 , int no ) 
{ 


  {
#line 189
  return (65535);
}
}
#line 39 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm75.c"
static int lm75_probe(LM_METHODS *method___1 ) ;
#line 40
static float lm75_temp(LM_METHODS *method___1 , int no ) ;
#line 41
static int lm75_fanrpm(LM_METHODS *method___1 , int no ) ;
#line 42
static float lm75_volt(LM_METHODS *method___1 , int no ) ;
#line 44 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm75.c"
SENSOR lm75  =    {(char *)"Nat.Semi.Con. Chip LM75", & lm75_probe, & lm75_temp, & lm75_volt, & lm75_fanrpm};
#line 54 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm75.c"
static int temp1_flag___0  =    0;
#line 55 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm75.c"
static int temp2_flag___0  =    0;
#line 60 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm75.c"
static int lm75_probe(LM_METHODS *method___1 ) 
{ 
  int i ;
  int j ;
  int k ;
  int save ;

  {
#line 64
  if ((unsigned long )method___1 != (unsigned long )(& method_smb)) {
#line 65
    return (0);
  }
  {
#line 67
  i = set_smb_Extemp(144, 158, & smb_wbtemp1, & smb_wbtemp2);
#line 69
  temp1_flag___0 = i >> 1;
#line 70
  temp2_flag___0 = i & 1;
  }
#line 72
  if (temp1_flag___0) {
#line 72
    if (temp2_flag___0) {
#line 73
      return (0);
    }
  }
  {
#line 75
  save = smb_slave;
#line 76
  smb_slave = smb_wbtemp1;
#line 77
  i = (*(method___1->Read))(1);
  }
#line 78
  if (i > 31) {
#line 79
    goto ret0;
  }
  {
#line 80
  i = (*(method___1->Read))(0);
#line 81
  j = (*(method___1->Read))(2);
#line 82
  k = (*(method___1->Read))(3);
  }
#line 83
  if (j == 255) {
#line 85
    goto ret0;
  } else
#line 83
  if (j == 0) {
#line 85
    goto ret0;
  } else
#line 83
  if (k == 255) {
#line 85
    goto ret0;
  } else
#line 83
  if (k == 0) {
#line 85
    goto ret0;
  } else
#line 83
  if (i == j) {
#line 83
    if (i == k) {
#line 85
      goto ret0;
    }
  }
#line 90
  if (j < 40) {
#line 91
    goto ret0;
  } else
#line 90
  if (k < 20) {
#line 91
    goto ret0;
  }
  {
#line 93
  info_Extemp(method___1, temp1_flag___0, temp2_flag___0);
#line 95
  kill_smb_slave(smb_slave);
  }
#line 96
  return (1);
  ret0: 
#line 98
  smb_slave = save;
#line 99
  return (0);
}
}
#line 108 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm75.c"
static float lm75_temp(LM_METHODS *method___1 , int no ) 
{ 
  int n ;

  {
#line 110
  n = 0;
#line 112
  if (no < 0) {
#line 113
    return ((float )65535);
  } else
#line 112
  if (1 < no) {
#line 113
    return ((float )65535);
  }
#line 115
  if (no == 0) {
#line 115
    if (! temp1_flag___0) {
      {
#line 116
      n = (*(method___1->ReadTemp1))();
      }
    } else {
#line 115
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 117
  if (no == 1) {
#line 117
    if (! temp2_flag___0) {
      {
#line 118
      n = (*(method___1->ReadTemp2))();
      }
    }
  }
#line 119
  if ((n & 255) >= 128) {
#line 120
    n = 0;
  }
#line 121
  return ((float )((double )((float )(n & 255)) + 0.5 * (double )((n & 65280) >> 15)));
}
}
#line 126 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm75.c"
static float lm75_volt(LM_METHODS *method___1 , int no ) 
{ 


  {
#line 128
  return ((float )65535);
}
}
#line 131 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm75.c"
static int lm75_fanrpm(LM_METHODS *method___1 , int no ) 
{ 


  {
#line 133
  return (65535);
}
}
#line 53 "/home/wheatley/newnew/temp/xmbmon-2.05/io_cpu.h"
__inline static unsigned int my_inl(unsigned short port ) 
{ 
  unsigned int ret ;

  {
#line 57
  __asm__  volatile   ("inl %1,%0": "=a" (ret): "d" (port));
#line 58
  return (ret);
}
}
#line 73 "/home/wheatley/newnew/temp/xmbmon-2.05/io_cpu.h"
__inline static void my_outl(unsigned short port , unsigned int val ) 
{ 


  {
#line 76
  __asm__  volatile   ("outl %0,%1": : "a" (val), "d" (port));
#line 77
  return;
}
}
#line 99 "/home/wheatley/newnew/temp/xmbmon-2.05/pci_pm.h"
int chk_port_byte(int addr ) ;
#line 100
char *chk_smb_chip(int chip ) ;
#line 103
int is_ALI1535(void) ;
#line 104
u_char pci_conf_readb(u_char bus , u_char dev , u_char fun , u_char reg ) ;
#line 105
u_short pci_conf_readw(u_char bus , u_char dev , u_char fun , u_char reg ) ;
#line 106
u_int pci_conf_read(u_char bus , u_char dev , u_char fun , u_char reg ) ;
#line 5 "/home/wheatley/newnew/temp/xmbmon-2.05/io_static.c"
static int OpenIO___2(void) 
{ 
  int tmp ;

  {
#line 7
  if (iopl_counter == 0) {
    {
#line 8
    tmp = iopl(3);
    }
#line 8
    if (tmp < 0) {
#line 9
      return (-1);
    }
  }
#line 11
  iopl_counter ++;
#line 12
  return (0);
}
}
#line 15 "/home/wheatley/newnew/temp/xmbmon-2.05/io_static.c"
static void CloseIO___2(void) 
{ 


  {
#line 17
  if (iopl_counter == 1) {
    {
#line 18
    iopl(0);
    }
  }
#line 19
  if (iopl_counter > 0) {
#line 20
    iopl_counter --;
  }
#line 21
  return;
}
}
#line 28 "/home/wheatley/newnew/temp/xmbmon-2.05/pci_pm.c"
int iopl_counter  =    0;
#line 31 "/home/wheatley/newnew/temp/xmbmon-2.05/pci_pm.c"
int iofl  ;
#line 34 "/home/wheatley/newnew/temp/xmbmon-2.05/pci_pm.c"
char *chk_smb_chip(int chip ) 
{ 
  char *comt ;

  {
  {
#line 40
  if (chip == 1) {
#line 40
    goto case_1;
  }
#line 40
  if (chip == 2) {
#line 40
    goto case_1;
  }
#line 43
  if (chip == 11) {
#line 43
    goto case_11;
  }
#line 51
  if (chip == 21) {
#line 51
    goto case_21;
  }
#line 54
  if (chip == 22) {
#line 54
    goto case_22;
  }
#line 57
  if (chip == 31) {
#line 57
    goto case_31;
  }
#line 60
  if (chip == 12) {
#line 60
    goto case_12;
  }
#line 63
  if (chip == 41) {
#line 63
    goto case_41;
  }
#line 66
  if (chip == 51) {
#line 66
    goto case_51;
  }
#line 69
  if (chip == 52) {
#line 69
    goto case_52;
  }
#line 72
  if (chip == 61) {
#line 72
    goto case_61;
  }
#line 75
  if (chip == 62) {
#line 75
    goto case_62;
  }
#line 78
  if (chip == 71) {
#line 78
    goto case_71;
  }
#line 81
  if (chip == 72) {
#line 81
    goto case_72;
  }
#line 84
  goto switch_default;
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 41
  comt = (char *)"VIA82C686(KT133/A)";
#line 42
  goto switch_break;
  case_11: /* CIL Label */ 
#line 44
  comt = (char *)"VIA596";
#line 45
  goto switch_break;
  case_21: /* CIL Label */ 
#line 52
  comt = (char *)"IntelPIIX4(440BX/MX)";
#line 53
  goto switch_break;
  case_22: /* CIL Label */ 
#line 55
  comt = (char *)"ServerWorks(ServerSet Chipset)";
#line 56
  goto switch_break;
  case_31: /* CIL Label */ 
#line 58
  comt = (char *)"VT8233/A/8235/8237(KT266/333/400/600/880)";
#line 59
  goto switch_break;
  case_12: /* CIL Label */ 
#line 61
  comt = (char *)"VIA8231/8235PM";
#line 62
  goto switch_break;
  case_41: /* CIL Label */ 
#line 64
  comt = (char *)"Intel8XX(ICH/ICH2/ICH3/ICH4/ICH5/ICH6)";
#line 65
  goto switch_break;
  case_51: /* CIL Label */ 
#line 67
  comt = (char *)"AMD756/766/768";
#line 68
  goto switch_break;
  case_52: /* CIL Label */ 
#line 70
  comt = (char *)"NVidia nForce";
#line 71
  goto switch_break;
  case_61: /* CIL Label */ 
#line 73
  comt = (char *)"ALi M1535";
#line 74
  goto switch_break;
  case_62: /* CIL Label */ 
#line 76
  comt = (char *)"ALi M1533/1543C";
#line 77
  goto switch_break;
  case_71: /* CIL Label */ 
#line 79
  comt = (char *)"AMD8111";
#line 80
  goto switch_break;
  case_72: /* CIL Label */ 
#line 82
  comt = (char *)"NVidia nForce2";
#line 83
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 85
  comt = (char *)((void *)0);
#line 86
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 88
  return (comt);
}
}
#line 91 "/home/wheatley/newnew/temp/xmbmon-2.05/pci_pm.c"
int chk_port_byte(int addr ) 
{ 
  int ret ;
  int tmp ;
  unsigned char tmp___0 ;

  {
  {
#line 94
  tmp = OpenIO___2();
  }
#line 94
  if (tmp == -1) {
#line 94
    return (-1);
  }
  {
#line 95
  tmp___0 = my_inb((u_short )addr);
#line 95
  ret = (int )tmp___0;
#line 96
  CloseIO___2();
  }
#line 97
  return (ret);
}
}
#line 100 "/home/wheatley/newnew/temp/xmbmon-2.05/pci_pm.c"
int pci_pm_smb_prob(int *hwm_base , int *smb_base___0 ) 
{ 
  u_int dat ;
  u_char dev ;
  u_char fun ;
  int ret ;
  int inq_smbba ;
  int tmp ;
  int tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  int tmp___3 ;
  u_short tmp___4 ;
  u_short tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 104
  ret = 0;
#line 104
  inq_smbba = 0;
#line 106
  tmp = OpenIO___2();
  }
#line 106
  if (tmp == -1) {
#line 106
    return (-1);
  }
#line 107
  tmp___0 = 0;
#line 107
  *smb_base___0 = tmp___0;
#line 107
  *hwm_base = tmp___0;
#line 108
  dev = (u_char )0;
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    if (! ((int )dev < 32)) {
#line 108
      goto while_break;
    }
#line 109
    fun = (u_char )0;
    {
#line 109
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 109
      if (! ((int )fun < 8)) {
#line 109
        goto while_break___0;
      }
      {
#line 110
      tmp___1 = pci_conf_read((u_char )0, dev, fun, (u_char )0);
      }
      {
#line 111
      if (tmp___1 == 811012358U) {
#line 111
        goto case_811012358;
      }
#line 123
      if (tmp___1 == 810619142U) {
#line 123
        goto case_810619142;
      }
#line 123
      if (tmp___1 == 810553606U) {
#line 123
        goto case_810619142;
      }
#line 132
      if (tmp___1 == 2184515846U) {
#line 132
        goto case_2184515846;
      }
#line 138
      if (tmp___1 == 2489520213U) {
#line 138
        goto case_2489520213;
      }
#line 138
      if (tmp___1 == 1906016390U) {
#line 138
        goto case_2489520213;
      }
#line 138
      if (tmp___1 == 1897103494U) {
#line 138
        goto case_2489520213;
      }
#line 143
      if (tmp___1 == 33624422U) {
#line 143
        goto case_33624422;
      }
#line 143
      if (tmp___1 == 33558886U) {
#line 143
        goto case_33624422;
      }
#line 151
      if (tmp___1 == 841421062U) {
#line 151
        goto case_841421062;
      }
#line 151
      if (tmp___1 == 829886726U) {
#line 151
        goto case_841421062;
      }
#line 151
      if (tmp___1 == 822677766U) {
#line 151
        goto case_841421062;
      }
#line 151
      if (tmp___1 == 826740998U) {
#line 151
        goto case_841421062;
      }
#line 151
      if (tmp___1 == 812912902U) {
#line 151
        goto case_841421062;
      }
#line 162
      if (tmp___1 == 644513926U) {
#line 162
        goto case_644513926;
      }
#line 162
      if (tmp___1 == 631537798U) {
#line 162
        goto case_644513926;
      }
#line 162
      if (tmp___1 == 617840774U) {
#line 162
        goto case_644513926;
      }
#line 162
      if (tmp___1 == 616792198U) {
#line 162
        goto case_644513926;
      }
#line 162
      if (tmp___1 == 612597894U) {
#line 162
        goto case_644513926;
      }
#line 162
      if (tmp___1 == 608403590U) {
#line 162
        goto case_644513926;
      }
#line 162
      if (tmp___1 == 606306438U) {
#line 162
        goto case_644513926;
      }
#line 162
      if (tmp___1 == 605257862U) {
#line 162
        goto case_644513926;
      }
#line 168
      if (tmp___1 == 1950552098U) {
#line 168
        goto case_1950552098;
      }
#line 168
      if (tmp___1 == 1947406370U) {
#line 168
        goto case_1950552098;
      }
#line 168
      if (tmp___1 == 1946882082U) {
#line 168
        goto case_1950552098;
      }
#line 172
      if (tmp___1 == 28578014U) {
#line 172
        goto case_28578014;
      }
#line 176
      if (tmp___1 == 1895895225U) {
#line 176
        goto case_1895895225;
      }
#line 185
      if (tmp___1 == 1953108002U) {
#line 185
        goto case_1953108002;
      }
#line 189
      if (tmp___1 == 6557918U) {
#line 189
        goto case_6557918;
      }
#line 193
      goto switch_default;
      case_811012358: /* CIL Label */ 
      {
#line 112
      dat = pci_conf_read((u_char )0, dev, fun, (u_char )116);
      }
#line 113
      if (dat) {
        {
#line 114
        tmp___2 = pci_conf_read((u_char )0, dev, fun, (u_char )112);
#line 114
        *hwm_base = (int )(65534U & tmp___2);
#line 116
        ret = 2;
        }
      } else {
#line 118
        ret = 1;
      }
#line 120
      inq_smbba = 144;
#line 121
      goto switch_break;
      case_810619142: /* CIL Label */ 
      case_810553606: /* CIL Label */ 
#line 124
      ret = 11;
#line 125
      inq_smbba = 144;
#line 126
      goto switch_break;
      case_2184515846: /* CIL Label */ 
#line 133
      ret = 12;
#line 134
      inq_smbba = 144;
#line 135
      goto switch_break;
      case_2489520213: /* CIL Label */ 
      case_1906016390: /* CIL Label */ 
      case_1897103494: /* CIL Label */ 
#line 139
      ret = 21;
#line 140
      inq_smbba = 144;
#line 141
      goto switch_break;
      case_33624422: /* CIL Label */ 
      case_33558886: /* CIL Label */ 
#line 144
      ret = 22;
#line 145
      inq_smbba = 144;
#line 146
      goto switch_break;
      case_841421062: /* CIL Label */ 
      case_829886726: /* CIL Label */ 
      case_822677766: /* CIL Label */ 
      case_826740998: /* CIL Label */ 
      case_812912902: /* CIL Label */ 
#line 152
      ret = 31;
#line 153
      inq_smbba = 208;
#line 154
      goto switch_break;
      case_644513926: /* CIL Label */ 
      case_631537798: /* CIL Label */ 
      case_617840774: /* CIL Label */ 
      case_616792198: /* CIL Label */ 
      case_612597894: /* CIL Label */ 
      case_608403590: /* CIL Label */ 
      case_606306438: /* CIL Label */ 
      case_605257862: /* CIL Label */ 
#line 163
      ret = 41;
#line 164
      inq_smbba = 32;
#line 165
      goto switch_break;
      case_1950552098: /* CIL Label */ 
      case_1947406370: /* CIL Label */ 
      case_1946882082: /* CIL Label */ 
#line 169
      ret = 51;
#line 170
      inq_smbba = 88;
#line 171
      goto switch_break;
      case_28578014: /* CIL Label */ 
#line 173
      ret = 52;
#line 174
      inq_smbba = 20;
#line 175
      goto switch_break;
      case_1895895225: /* CIL Label */ 
      {
#line 177
      tmp___3 = is_ALI1535();
      }
#line 177
      if (tmp___3) {
#line 178
        ret = 61;
#line 179
        inq_smbba = 226;
      } else {
#line 181
        ret = 62;
#line 182
        inq_smbba = 20;
      }
#line 184
      goto switch_break;
      case_1953108002: /* CIL Label */ 
#line 186
      ret = 71;
#line 187
      inq_smbba = 16;
#line 188
      goto switch_break;
      case_6557918: /* CIL Label */ 
#line 190
      ret = 72;
#line 191
      inq_smbba = 84;
#line 192
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 194
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 200
      if (ret) {
        {
#line 201
        tmp___4 = pci_conf_readw((u_char )0, dev, fun, (u_char )inq_smbba);
#line 201
        *smb_base___0 = (int )tmp___4;
        }
#line 202
        if (ret / 10 == 7) {
#line 203
          *smb_base___0 &= 65534;
#line 204
          if (ret == 72) {
            {
#line 209
            tmp___7 = chk_smbus_io(72, *smb_base___0);
            }
#line 209
            if (! tmp___7) {
              {
#line 210
              tmp___5 = pci_conf_readw((u_char )0, dev, fun, (u_char )80);
#line 210
              *smb_base___0 = (int )tmp___5 & 65534;
#line 216
              tmp___6 = chk_smbus_io(72, *smb_base___0);
              }
#line 216
              if (! tmp___6) {
#line 217
                *smb_base___0 = 0;
              }
            }
          }
        } else
#line 220
        if (ret / 10 == 5) {
#line 221
          *smb_base___0 &= 65280;
#line 222
          if (ret == 51) {
#line 223
            *smb_base___0 += 224;
          }
        } else
#line 224
        if (ret == 61) {
#line 225
          *smb_base___0 &= 65504;
        } else
#line 224
        if (ret == 62) {
#line 225
          *smb_base___0 &= 65504;
        } else {
#line 227
          *smb_base___0 &= 65520;
        }
#line 229
        goto ending;
      }
#line 109
      fun = (u_char )((int )fun + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 108
    dev = (u_char )((int )dev + 1);
  }
  while_break: /* CIL Label */ ;
  }
  ending: 
#line 237
  if (*smb_base___0 < 256) {
#line 238
    ret = 0;
  }
  {
#line 241
  CloseIO___2();
  }
#line 242
  return (ret);
}
}
#line 247 "/home/wheatley/newnew/temp/xmbmon-2.05/pci_pm.c"
int is_ALI1535(void) 
{ 
  u_char dev ;
  u_char fun ;
  int ret ;
  u_int id ;
  int tmp ;

  {
  {
#line 250
  ret = 0;
#line 253
  tmp = OpenIO___2();
  }
#line 253
  if (tmp == -1) {
#line 253
    return (-1);
  }
#line 254
  dev = (u_char )0;
  {
#line 254
  while (1) {
    while_continue: /* CIL Label */ ;
#line 254
    if (! ((int )dev < 32)) {
#line 254
      goto while_break;
    }
#line 255
    fun = (u_char )0;
    {
#line 255
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 255
      if (! ((int )fun < 8)) {
#line 255
        goto while_break___0;
      }
      {
#line 256
      id = pci_conf_read((u_char )0, dev, fun, (u_char )0);
      }
#line 257
      if (id == 355799225U) {
#line 258
        ret = 1;
#line 259
        goto while_break___0;
      } else
#line 257
      if (id == 373756089U) {
#line 258
        ret = 1;
#line 259
        goto while_break___0;
      }
#line 255
      fun = (u_char )((int )fun + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 262
    if (ret) {
#line 263
      goto while_break;
    }
#line 254
    dev = (u_char )((int )dev + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 265
  CloseIO___2();
  }
#line 266
  return (ret);
}
}
#line 273 "/home/wheatley/newnew/temp/xmbmon-2.05/pci_pm.c"
u_char pci_conf_readb(u_char bus , u_char dev , u_char fun , u_char reg ) 
{ 
  u_int dat ;
  u_int n ;

  {
  {
#line 277
  n = (u_int )((int )reg % 4);
#line 278
  dat = pci_conf_read(bus, dev, fun, (u_char )((int )reg & 252));
  }
#line 279
  if (n == 0U) {
#line 280
    return ((u_char )(dat & 255U));
  } else {
#line 282
    return ((u_char )((dat >> 8U * n) & 255U));
  }
}
}
#line 286 "/home/wheatley/newnew/temp/xmbmon-2.05/pci_pm.c"
u_short pci_conf_readw(u_char bus , u_char dev , u_char fun , u_char reg ) 
{ 
  u_int dat ;
  u_int n ;

  {
  {
#line 290
  n = (u_int )((int )reg % 4);
#line 291
  dat = pci_conf_read(bus, dev, fun, (u_char )((int )reg & 252));
  }
#line 292
  if (n == 0U) {
#line 293
    return ((u_short )(dat & 65535U));
  } else
#line 294
  if (n != 3U) {
#line 295
    return ((u_short )((dat >> 8U * n) & 65535U));
  } else {
    {
#line 297
    n = pci_conf_read(bus, dev, fun, (u_char )(((int )reg & 252) + 4));
    }
#line 298
    return ((u_short )((((dat >> 24) & 255U) & (n << 8)) & 65535U));
  }
}
}
#line 311 "/home/wheatley/newnew/temp/xmbmon-2.05/pci_pm.c"
u_int pci_conf_read(u_char bus , u_char dev , u_char fun , u_char reg ) 
{ 
  u_int pix ;
  u_int dat ;

  {
  {
#line 320
  pix = (u_int )0;
#line 321
  pix |= (unsigned int )reg;
#line 322
  pix |= (unsigned int )((int )fun << 8);
#line 323
  pix |= (unsigned int )((int )dev << 11);
#line 324
  pix |= (unsigned int )((int )bus << 16);
#line 325
  pix |= 2147483648U;
#line 326
  my_outl((unsigned short)3320, pix);
#line 326
  my_outb((unsigned short)235, (unsigned char)0);
#line 327
  dat = my_inl((unsigned short)3324);
#line 327
  my_outb((unsigned short)235, (unsigned char)0);
#line 328
  pix &= 2147483647U;
#line 329
  my_outl((unsigned short)3320, pix);
#line 329
  my_outb((unsigned short)235, (unsigned char)0);
  }
#line 330
  return (dat);
}
}
#line 10 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_wl784.h"
static char *wlchip[5]  = {      (char *)"No Sensor",      (char *)"Winbond Chip W83L784R",      (char *)"Winbond Chip W83L785R",      (char *)"Winbond Chip W83L785TS-S", 
        (char *)((void *)0)};
#line 59 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_wl784.c"
static int wl784_probe(LM_METHODS *method___1 ) ;
#line 60
static int wl784_probe_act(LM_METHODS *method___1 , int slave ) ;
#line 61
static float wl784_temp(LM_METHODS *method___1 , int no ) ;
#line 62
static int wl784_fanrpm(LM_METHODS *method___1 , int no ) ;
#line 63
static float wl784_volt(LM_METHODS *method___1 , int no ) ;
#line 66 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_wl784.c"
static char buff___2[128]  ;
#line 68 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_wl784.c"
SENSOR wl784  =    {buff___2, & wl784_probe, & wl784_temp, & wl784_volt, & wl784_fanrpm};
#line 77 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_wl784.c"
static int wbdchipid___0  =    0;
#line 80 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_wl784.c"
static int temp1_flag___1  =    0;
#line 81 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_wl784.c"
static int temp2_flag___1  =    0;
#line 82 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_wl784.c"
static int temp1_addr___0  =    0;
#line 83 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_wl784.c"
static int temp2_addr___0  =    0;
#line 88 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_wl784.c"
static int chkReg___2[29]  = 
#line 88
  {      64,      65,      66,      67, 
        68,      69,      70,      71, 
        72,      73,      74,      75, 
        76,      77,      78,      79, 
        32,      33,      34,      35, 
        38,      39,      40,      41, 
        43,      44,      45,      46, 
        -1};
#line 102 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_wl784.c"
static int wl784_probe(LM_METHODS *method___1 ) 
{ 
  int n ;
  int save ;
  int slave ;
  int tmp ;

  {
#line 106
  if ((unsigned long )method___1 != (unsigned long )(& method_smb)) {
#line 107
    return (0);
  }
#line 109
  save = smb_slave;
#line 111
  n = 80;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! (n <= 94)) {
#line 111
      goto while_break;
    }
    {
#line 112
    slave = get_smb_slave(n, 94);
    }
#line 112
    if (slave) {
      {
#line 115
      tmp = wl784_probe_act(method___1, slave);
      }
#line 115
      if (tmp) {
#line 116
        goto ret1;
      } else {
#line 118
        n = slave + 2;
      }
    } else {
#line 113
      goto ret0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  ret0: 
#line 123
  smb_slave = save;
#line 124
  return (0);
  ret1: 
  {
#line 126
  kill_smb_slave(slave);
  }
#line 127
  if (! smb_wbtemp1_flag) {
    {
#line 128
    kill_smb_slave(smb_wbtemp1);
    }
  }
#line 129
  if (! smb_wbtemp2_flag) {
    {
#line 130
    kill_smb_slave(smb_wbtemp2);
    }
  }
#line 131
  return (wbdchipid___0);
}
}
#line 134 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_wl784.c"
static int wl784_probe_act(LM_METHODS *method___1 , int slave ) 
{ 
  int n ;
  int nc ;
  int nvl ;
  int nvh ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 138
  smb_slave = slave;
#line 140
  tmp = chkReg_Probe(slave, (char *)"Probing Winbond W83L78x chip:\n", chkReg___2,
                     method___1);
  }
#line 140
  if (tmp < 8) {
#line 142
    goto ret0;
  }
  {
#line 145
  nvl = (*(method___1->Read))(76);
#line 146
  nvh = (*(method___1->Read))(77);
#line 147
  nc = (*(method___1->Read))(78);
  }
#line 152
  if (nvl == 163) {
#line 152
    if (nvh == 92) {
      {
#line 154
      if ((nc & 254) == 80) {
#line 154
        goto case_80;
      }
#line 157
      if ((nc & 254) == 96) {
#line 157
        goto case_96;
      }
#line 160
      if ((nc & 254) == 112) {
#line 160
        goto case_112;
      }
#line 163
      goto switch_default;
      case_80: /* CIL Label */ 
#line 155
      wbdchipid___0 = 1;
#line 156
      goto switch_break;
      case_96: /* CIL Label */ 
#line 158
      wbdchipid___0 = 2;
#line 159
      goto switch_break;
      case_112: /* CIL Label */ 
#line 161
      wbdchipid___0 = 3;
#line 162
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 164
      goto ret0;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 167
      goto ret0;
    }
  } else {
#line 167
    goto ret0;
  }
  {
#line 169
  strcpy((char */* __restrict  */)wl784.Name, (char const   */* __restrict  */)wlchip[wbdchipid___0]);
  }
#line 173
  if (wbdchipid___0 != 1) {
#line 174
    goto ret1;
  }
  {
#line 176
  n = (*(method___1->Read))(75);
#line 177
  temp1_flag___1 = (n & 8) >> 3;
  }
#line 177
  if (! temp1_flag___1) {
    {
#line 178
    temp1_addr___0 = smb_wbtemp1;
#line 179
    smb_wbtemp1 = 2 * (72 + (n & 7));
#line 180
    tmp___0 = (*(method___1->ReadTemp1))();
    }
#line 180
    if (tmp___0 == 65535) {
#line 181
      temp1_flag___1 = 1;
#line 182
      smb_wbtemp1 = temp1_addr___0;
    }
  }
#line 186
  temp2_flag___1 = (n & 128) >> 7;
#line 186
  if (! temp2_flag___1) {
    {
#line 187
    temp2_addr___0 = smb_wbtemp2;
#line 188
    smb_wbtemp2 = 2 * (72 + ((n & 112) >> 4));
#line 189
    tmp___1 = (*(method___1->ReadTemp2))();
    }
#line 189
    if (tmp___1 == 65535) {
#line 190
      temp2_flag___1 = 1;
#line 191
      smb_wbtemp2 = temp2_addr___0;
    }
  }
  {
#line 194
  info_Extemp(method___1, temp1_flag___1, temp2_flag___1);
  }
  ret1: 
#line 197
  smb_wbtemp1_flag = temp1_flag___1;
#line 198
  smb_wbtemp2_flag = temp2_flag___1;
#line 199
  return (wbdchipid___0);
  ret0: 
#line 201
  return (0);
}
}
#line 210 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_wl784.c"
static float wl784_temp(LM_METHODS *method___1 , int no ) 
{ 
  int n ;
  float f ;
  int tmp ;
  int tmp___0 ;

  {
#line 212
  n = 0;
#line 215
  if (no < 0) {
#line 216
    return ((float )65535);
  } else
#line 215
  if (2 < no) {
#line 216
    return ((float )65535);
  }
#line 217
  if (no == 2) {
#line 217
    if (wbdchipid___0 == 2) {
#line 218
      return ((float )65535);
    }
  }
#line 219
  if (no >= 1) {
#line 219
    if (wbdchipid___0 == 3) {
#line 220
      return ((float )65535);
    }
  }
#line 222
  if (no == 0) {
    {
#line 223
    tmp = (*(method___1->Read))(39);
    }
#line 223
    return ((float )tmp);
  } else
#line 224
  if (no == 1) {
#line 225
    if (wbdchipid___0 == 2) {
      {
#line 226
      tmp___0 = (*(method___1->Read))(38);
      }
#line 226
      return ((float )tmp___0);
    } else {
      {
#line 228
      n = (*(method___1->ReadTemp1))();
      }
    }
  } else
#line 229
  if (no == 2) {
    {
#line 230
    n = (*(method___1->ReadTemp2))();
    }
  }
#line 233
  if ((n & 255) >= 128) {
#line 234
    n = 0;
  }
#line 236
  f = (float )((double )((float )(n & 255)) + 0.5 * (double )((n & 65280) >> 15));
#line 238
  return (f);
}
}
#line 246 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_wl784.c"
static float wl784_volt(LM_METHODS *method___1 , int no ) 
{ 
  int n ;
  float f ;

  {
#line 249
  f = (float )0.0;
#line 251
  if (wbdchipid___0 == 3) {
#line 252
    return ((float )65535);
  }
#line 253
  if (no < 0) {
#line 254
    return ((float )65535);
  } else
#line 253
  if (3 < no) {
#line 254
    return ((float )65535);
  }
  {
#line 256
  n = (*(method___1->Read))(32 + no);
  }
  {
#line 258
  if (no == 0) {
#line 258
    goto case_0;
  }
#line 260
  if (no == 1) {
#line 260
    goto case_1;
  }
#line 265
  if (no == 2) {
#line 265
    goto case_2;
  }
#line 268
  if (no == 3) {
#line 268
    goto case_3;
  }
#line 257
  goto switch_break;
  case_0: /* CIL Label */ 
#line 259
  f = (float )((double )n * 0.016);
  case_1: /* CIL Label */ 
#line 261
  if (wbdchipid___0 == 1) {
#line 262
    f = (float )(((double )n * 0.016) * 3.3434);
  } else {
#line 264
    f = (float )(((double )n * 0.016) * (double )2);
  }
  case_2: /* CIL Label */ 
#line 266
  f = (float )((double )n * 0.016);
#line 267
  goto switch_break;
  case_3: /* CIL Label */ 
#line 269
  if (wbdchipid___0 == 1) {
#line 270
    f = (float )(((double )n * 0.016) * 1.68);
  } else {
#line 272
    f = (float )(((double )n * 0.016) * (double )3);
  }
#line 273
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 276
  return (f);
}
}
#line 300 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_wl784.c"
static int div___1[2]  = {      1,      1};
#line 297 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_wl784.c"
static int wl784_fanrpm(LM_METHODS *method___1 , int no ) 
{ 
  int r ;
  int n1 ;

  {
#line 299
  n1 = 17;
#line 302
  if (wbdchipid___0 == 3) {
#line 303
    return (65535);
  }
#line 304
  if (no < 0) {
#line 305
    return (65535);
  } else
#line 304
  if (1 < no) {
#line 305
    return (65535);
  }
  {
#line 307
  n1 = (*(method___1->Read))(73);
#line 308
  div___1[0] = n1 & 7;
#line 309
  div___1[1] = (n1 >> 4) & 7;
#line 311
  r = (*(method___1->Read))(40 + no);
  }
#line 312
  if (r == 255) {
#line 314
    if (div___1[no] < 7) {
#line 315
      (div___1[no]) ++;
    } else {
#line 317
      div___1[no] = 0;
    }
    {
#line 318
    r = ((n1 & 136) | div___1[0]) | (div___1[1] << 4);
#line 319
    (*(method___1->Write))(73, r);
    }
#line 320
    return (65535);
  } else
#line 321
  if (r == 0) {
#line 322
    return (65535);
  }
#line 325
  return (1350000 / (r * (1 << div___1[no])));
}
}
#line 70 "/home/wheatley/newnew/temp/xmbmon-2.05/smbus_piix4.c"
static int readbyte___1(int smb_base___0 , int addr , int cmd ) 
{ 
  u_char dat ;
  u_char saddr ;
  int i ;

  {
#line 72
  saddr = (u_char )(2 * (addr / 2));
  top: 
  {
#line 76
  my_outb((u_short )smb_base___0, (unsigned char)30);
#line 76
  my_outb((unsigned short)235, (unsigned char)0);
#line 76
  my_outb((unsigned short)235, (unsigned char)0);
#line 77
  i = 0;
  }
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (i < 8192)) {
#line 77
      goto while_break;
    }
    {
#line 78
    dat = my_inb((u_short )smb_base___0);
#line 78
    my_outb((unsigned short)235, (unsigned char)0);
#line 78
    my_outb((unsigned short)235, (unsigned char)0);
#line 79
    my_outb((u_short )smb_base___0, dat);
#line 79
    my_outb((unsigned short)235, (unsigned char)0);
#line 79
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 80
    if (! ((int )dat & 9)) {
#line 81
      goto step;
    }
#line 82
    if (! ((int )dat & 1)) {
#line 83
      goto while_break;
    }
#line 77
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 85
  my_outb((u_short )(smb_base___0 + 2), (unsigned char)2);
#line 85
  my_outb((unsigned short)235, (unsigned char)0);
#line 85
  my_outb((unsigned short)235, (unsigned char)0);
  }
  step: 
  {
#line 88
  my_outb((u_short )(smb_base___0 + 4), (unsigned char )((int )saddr | 1));
#line 88
  my_outb((unsigned short)235, (unsigned char)0);
#line 88
  my_outb((unsigned short)235, (unsigned char)0);
#line 89
  my_outb((u_short )(smb_base___0 + 3), (u_char )cmd);
#line 89
  my_outb((unsigned short)235, (unsigned char)0);
#line 89
  my_outb((unsigned short)235, (unsigned char)0);
#line 90
  my_outb((u_short )(smb_base___0 + 2), (unsigned char)72);
#line 91
  my_outb((unsigned short)235, (unsigned char)0);
#line 91
  my_outb((unsigned short)235, (unsigned char)0);
#line 93
  i = 0;
  }
  {
#line 93
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 93
    if (! (i < 8192)) {
#line 93
      goto while_break___0;
    }
    {
#line 94
    dat = my_inb((u_short )smb_base___0);
#line 94
    my_outb((unsigned short)235, (unsigned char)0);
#line 94
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 95
    if ((int )dat & 8) {
#line 100
      goto top;
    }
#line 102
    if (! ((int )dat & 1)) {
#line 102
      if ((int )dat & 6) {
#line 103
        goto while_break___0;
      }
    }
#line 93
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 109
  if ((int )dat & 2) {
    {
#line 110
    dat = my_inb((u_short )(smb_base___0 + 5));
#line 110
    my_outb((unsigned short)235, (unsigned char)0);
#line 110
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 111
    return ((int )dat & 255);
  } else {
#line 113
    return (-1);
  }
}
}
#line 116 "/home/wheatley/newnew/temp/xmbmon-2.05/smbus_piix4.c"
static int readword___0(int smb_base___0 , int addr , int cmd ) 
{ 
  u_char dat ;
  u_char saddr ;
  int i ;
  unsigned char tmp ;

  {
#line 118
  saddr = (u_char )(2 * (addr / 2));
  top: 
  {
#line 122
  my_outb((u_short )smb_base___0, (unsigned char)30);
#line 122
  my_outb((unsigned short)235, (unsigned char)0);
#line 122
  my_outb((unsigned short)235, (unsigned char)0);
#line 123
  i = 0;
  }
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    if (! (i < 8192)) {
#line 123
      goto while_break;
    }
    {
#line 124
    dat = my_inb((u_short )smb_base___0);
#line 124
    my_outb((unsigned short)235, (unsigned char)0);
#line 124
    my_outb((unsigned short)235, (unsigned char)0);
#line 125
    my_outb((u_short )smb_base___0, dat);
#line 125
    my_outb((unsigned short)235, (unsigned char)0);
#line 125
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 126
    if (! ((int )dat & 9)) {
#line 127
      goto step;
    }
#line 128
    if (! ((int )dat & 1)) {
#line 129
      goto while_break;
    }
#line 123
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 131
  my_outb((u_short )(smb_base___0 + 2), (unsigned char)2);
#line 131
  my_outb((unsigned short)235, (unsigned char)0);
#line 131
  my_outb((unsigned short)235, (unsigned char)0);
  }
  step: 
  {
#line 134
  my_outb((u_short )(smb_base___0 + 4), (unsigned char )((int )saddr | 1));
#line 134
  my_outb((unsigned short)235, (unsigned char)0);
#line 134
  my_outb((unsigned short)235, (unsigned char)0);
#line 135
  my_outb((u_short )(smb_base___0 + 3), (u_char )cmd);
#line 135
  my_outb((unsigned short)235, (unsigned char)0);
#line 135
  my_outb((unsigned short)235, (unsigned char)0);
#line 136
  my_outb((u_short )(smb_base___0 + 2), (unsigned char)76);
#line 137
  my_outb((unsigned short)235, (unsigned char)0);
#line 137
  my_outb((unsigned short)235, (unsigned char)0);
#line 139
  i = 0;
  }
  {
#line 139
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 139
    if (! (i < 8192)) {
#line 139
      goto while_break___0;
    }
    {
#line 140
    dat = my_inb((u_short )smb_base___0);
#line 140
    my_outb((unsigned short)235, (unsigned char)0);
#line 140
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 141
    if ((int )dat & 8) {
#line 142
      goto top;
    }
#line 143
    if (! ((int )dat & 1)) {
#line 143
      if ((int )dat & 6) {
#line 144
        goto while_break___0;
      }
    }
#line 139
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 146
  if ((int )dat & 2) {
    {
#line 147
    tmp = my_inb((u_short )(smb_base___0 + 6));
#line 147
    i = (int )tmp;
#line 147
    my_outb((unsigned short)235, (unsigned char)0);
#line 147
    my_outb((unsigned short)235, (unsigned char)0);
#line 148
    dat = my_inb((u_short )(smb_base___0 + 5));
#line 148
    my_outb((unsigned short)235, (unsigned char)0);
#line 148
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 149
    return (((i << 8) + (int )dat) & 65535);
  } else {
#line 151
    return (-1);
  }
}
}
#line 154 "/home/wheatley/newnew/temp/xmbmon-2.05/smbus_piix4.c"
static int writebyte___1(int smb_base___0 , int addr , int cmd , int value ) 
{ 
  u_char dat ;
  u_char saddr ;
  int i ;

  {
  {
#line 156
  saddr = (u_char )(2 * (addr / 2));
#line 159
  my_outb((u_short )smb_base___0, (unsigned char)30);
#line 159
  my_outb((unsigned short)235, (unsigned char)0);
#line 159
  my_outb((unsigned short)235, (unsigned char)0);
#line 160
  i = 0;
  }
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    if (! (i < 8192)) {
#line 160
      goto while_break;
    }
    {
#line 161
    dat = my_inb((u_short )smb_base___0);
#line 161
    my_outb((unsigned short)235, (unsigned char)0);
#line 161
    my_outb((unsigned short)235, (unsigned char)0);
#line 162
    my_outb((u_short )smb_base___0, dat);
#line 162
    my_outb((unsigned short)235, (unsigned char)0);
#line 162
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 163
    if (! ((int )dat & 9)) {
#line 164
      goto step;
    }
#line 165
    if (! ((int )dat & 1)) {
#line 166
      goto while_break;
    }
#line 160
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 168
  my_outb((u_short )(smb_base___0 + 2), (unsigned char)2);
#line 168
  my_outb((unsigned short)235, (unsigned char)0);
#line 168
  my_outb((unsigned short)235, (unsigned char)0);
  }
  step: 
  {
#line 171
  my_outb((u_short )(smb_base___0 + 4), saddr);
#line 171
  my_outb((unsigned short)235, (unsigned char)0);
#line 171
  my_outb((unsigned short)235, (unsigned char)0);
#line 172
  my_outb((u_short )(smb_base___0 + 3), (u_char )cmd);
#line 172
  my_outb((unsigned short)235, (unsigned char)0);
#line 172
  my_outb((unsigned short)235, (unsigned char)0);
#line 173
  my_outb((u_short )(smb_base___0 + 5), (u_char )value);
#line 173
  my_outb((unsigned short)235, (unsigned char)0);
#line 173
  my_outb((unsigned short)235, (unsigned char)0);
#line 174
  my_outb((u_short )(smb_base___0 + 2), (unsigned char)72);
#line 175
  my_outb((unsigned short)235, (unsigned char)0);
#line 175
  my_outb((unsigned short)235, (unsigned char)0);
#line 177
  i = 0;
  }
  {
#line 177
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 177
    if (! (i < 8192)) {
#line 177
      goto while_break___0;
    }
    {
#line 178
    dat = my_inb((u_short )smb_base___0);
#line 178
    my_outb((unsigned short)235, (unsigned char)0);
#line 178
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 179
    if (! ((int )dat & 1)) {
#line 179
      if ((int )dat & 6) {
#line 180
        goto while_break___0;
      }
    }
#line 177
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 182
  if ((int )dat & 2) {
#line 183
    return (0);
  } else {
#line 185
    return (-1);
  }
}
}
#line 188 "/home/wheatley/newnew/temp/xmbmon-2.05/smbus_piix4.c"
static int writeword___0(int smb_base___0 , int addr , int cmd , int value ) 
{ 
  u_char dat ;
  u_char saddr ;
  int i ;

  {
  {
#line 190
  saddr = (u_char )(2 * (addr / 2));
#line 193
  my_outb((u_short )smb_base___0, (unsigned char)30);
#line 193
  my_outb((unsigned short)235, (unsigned char)0);
#line 193
  my_outb((unsigned short)235, (unsigned char)0);
#line 194
  i = 0;
  }
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 194
    if (! (i < 8192)) {
#line 194
      goto while_break;
    }
    {
#line 195
    dat = my_inb((u_short )smb_base___0);
#line 195
    my_outb((unsigned short)235, (unsigned char)0);
#line 195
    my_outb((unsigned short)235, (unsigned char)0);
#line 196
    my_outb((u_short )smb_base___0, dat);
#line 196
    my_outb((unsigned short)235, (unsigned char)0);
#line 196
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 197
    if (! ((int )dat & 9)) {
#line 198
      goto step;
    }
#line 199
    if (! ((int )dat & 1)) {
#line 200
      goto while_break;
    }
#line 194
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 202
  my_outb((u_short )(smb_base___0 + 2), (unsigned char)2);
#line 202
  my_outb((unsigned short)235, (unsigned char)0);
#line 202
  my_outb((unsigned short)235, (unsigned char)0);
  }
  step: 
  {
#line 205
  my_outb((u_short )(smb_base___0 + 4), saddr);
#line 205
  my_outb((unsigned short)235, (unsigned char)0);
#line 205
  my_outb((unsigned short)235, (unsigned char)0);
#line 206
  my_outb((u_short )(smb_base___0 + 3), (u_char )cmd);
#line 206
  my_outb((unsigned short)235, (unsigned char)0);
#line 206
  my_outb((unsigned short)235, (unsigned char)0);
#line 207
  my_outb((u_short )(smb_base___0 + 5), (u_char )(value & 255));
#line 207
  my_outb((unsigned short)235, (unsigned char)0);
#line 207
  my_outb((unsigned short)235, (unsigned char)0);
#line 208
  my_outb((u_short )(smb_base___0 + 6), (u_char )(value >> 8));
#line 208
  my_outb((unsigned short)235, (unsigned char)0);
#line 208
  my_outb((unsigned short)235, (unsigned char)0);
#line 209
  my_outb((u_short )(smb_base___0 + 2), (unsigned char)76);
#line 210
  my_outb((unsigned short)235, (unsigned char)0);
#line 210
  my_outb((unsigned short)235, (unsigned char)0);
#line 212
  i = 0;
  }
  {
#line 212
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 212
    if (! (i < 8192)) {
#line 212
      goto while_break___0;
    }
    {
#line 213
    dat = my_inb((u_short )smb_base___0);
#line 213
    my_outb((unsigned short)235, (unsigned char)0);
#line 213
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 214
    if (! ((int )dat & 1)) {
#line 214
      if ((int )dat & 6) {
#line 215
        goto while_break___0;
      }
    }
#line 212
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 217
  if ((int )dat & 2) {
#line 218
    return (0);
  } else {
#line 220
    return (-1);
  }
}
}
#line 223 "/home/wheatley/newnew/temp/xmbmon-2.05/smbus_piix4.c"
struct smbus_io smbus_piix4  =    {& readbyte___1, & readword___0, & writebyte___1, & writeword___0};
#line 47 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_gl52.c"
static int gl52chipid  =    0;
#line 48 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_gl52.c"
static int gl52_mode  =    1;
#line 49 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_gl52.c"
static int temp_offset  =    130;
#line 51
static int gl52_probe(LM_METHODS *method___1 ) ;
#line 52
static float gl52_temp(LM_METHODS *method___1 , int no ) ;
#line 53
static int gl52_fanrpm(LM_METHODS *method___1 , int no ) ;
#line 54
static float gl52_volt(LM_METHODS *method___1 , int no ) ;
#line 57 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_gl52.c"
static char buff___3[128]  ;
#line 59 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_gl52.c"
SENSOR gl52  =    {buff___3, & gl52_probe, & gl52_temp, & gl52_volt, & gl52_fanrpm};
#line 75 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_gl52.c"
static char *gl52chip[5]  = {      (char *)"No Sensor",      (char *)"GL518SM_rev00",      (char *)"GL518SM_rev80",      (char *)"GL520SM", 
        (char *)((void *)0)};
#line 86 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_gl52.c"
static int chkReg___3[25]  = 
#line 86
  {      0,      1,      2,      3, 
        4,      5,      6,      7, 
        8,      9,      10,      11, 
        12,      13,      14,      15, 
        16,      17,      18,      19, 
        20,      21,      22,      23, 
        -1};
#line 99 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_gl52.c"
static int gl52_probe(LM_METHODS *method___1 ) 
{ 
  int n ;
  int id ;
  int save ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 103
  if ((unsigned long )method___1 != (unsigned long )(& method_smb)) {
#line 104
    return (0);
  }
#line 106
  save = smb_slave;
#line 108
  n = 88;
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    if (! (n <= 90)) {
#line 108
      goto while_break;
    }
    {
#line 109
    smb_slave = get_smb_slave(n, 90);
    }
#line 109
    if (smb_slave) {
      {
#line 112
      id = (*(method___1->Read))(0);
      }
#line 113
      if (id == 32) {
#line 113
        goto _L;
      } else
#line 113
      if (id == 128) {
        _L: /* CIL Label */ 
        {
#line 113
        tmp = chkReg_Probe(smb_slave, (char *)"Probing GL518SM/GL520SM chip:\n", chkReg___3,
                           method___1);
        }
#line 113
        if (tmp >= 10) {
#line 117
          goto ret1;
        } else {
#line 119
          n = smb_slave + 2;
        }
      } else {
#line 119
        n = smb_slave + 2;
      }
    } else {
#line 110
      goto ret0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  ret0: 
#line 124
  smb_slave = save;
#line 125
  return (0);
  ret1: 
  {
#line 127
  kill_smb_slave(smb_slave);
#line 128
  strcpy((char */* __restrict  */)(buff___3), (char const   */* __restrict  */)"Genesys Logic ");
  }
#line 129
  if (id == 32) {
    {
#line 130
    gl52chipid = 3;
#line 131
    temp_offset = 130;
#line 132
    tmp___0 = (*(method___1->Read))(3);
    }
#line 132
    if (tmp___0 & 16) {
#line 133
      gl52_mode = 2;
    }
  } else {
    {
#line 135
    tmp___1 = (*(method___1->Read))(1);
    }
#line 135
    if (tmp___1 == 128) {
#line 136
      gl52chipid = 2;
    } else {
#line 138
      gl52chipid = 1;
    }
#line 139
    temp_offset = 119;
  }
  {
#line 141
  strcat((char */* __restrict  */)(buff___3), (char const   */* __restrict  */)gl52chip[gl52chipid]);
  }
#line 143
  return (gl52chipid);
}
}
#line 152 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_gl52.c"
static float gl52_temp(LM_METHODS *method___1 , int no ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 154
  if (no < 0) {
#line 155
    return ((float )65535);
  } else
#line 154
  if (2 < no) {
#line 155
    return ((float )65535);
  }
#line 157
  if (no == 0) {
    {
#line 158
    tmp = (*(method___1->Read))(4);
    }
#line 158
    return ((float )(tmp - temp_offset));
  } else
#line 159
  if (no == 1) {
#line 159
    if (gl52chipid == 3) {
#line 159
      if (gl52_mode == 1) {
        {
#line 160
        tmp___0 = (*(method___1->Read))(14);
        }
#line 160
        return ((float )(tmp___0 - temp_offset));
      } else {
#line 162
        return ((float )65535);
      }
    } else {
#line 162
      return ((float )65535);
    }
  } else {
#line 162
    return ((float )65535);
  }
}
}
#line 170 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_gl52.c"
static float gl52_volt(LM_METHODS *method___1 , int no ) 
{ 
  float facp12 ;
  float facn12 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 172
  facp12 = (float )(1200. / 286.);
#line 173
  facn12 = (float )(- 1200. / 160.);
#line 175
  if (no < 0) {
#line 176
    return ((float )65535);
  } else
#line 175
  if (6 < no) {
#line 176
    return ((float )65535);
  }
#line 178
  if (no > 0) {
#line 178
    if (gl52chipid == 1) {
#line 180
      return ((float )65535);
    } else {
#line 178
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 178
  if (no > 4) {
#line 178
    if (gl52chipid == 2) {
#line 180
      return ((float )65535);
    }
  }
  {
#line 183
  if (no == 0) {
#line 183
    goto case_0;
  }
#line 185
  if (no == 1) {
#line 185
    goto case_1;
  }
#line 187
  if (no == 2) {
#line 187
    goto case_2;
  }
#line 189
  if (no == 3) {
#line 189
    goto case_3;
  }
#line 191
  if (no == 4) {
#line 191
    goto case_4;
  }
#line 193
  if (no == 5) {
#line 193
    goto case_5;
  }
#line 198
  if (no == 6) {
#line 198
    goto case_6;
  }
#line 200
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 184
  tmp = (*(method___1->Read))(13);
  }
#line 184
  return ((float )((double )((float )tmp) * 0.019));
  case_1: /* CIL Label */ 
#line 186
  return ((float )0.0);
  case_2: /* CIL Label */ 
  {
#line 188
  tmp___0 = (*(method___1->Read))(20);
  }
#line 188
  return ((float )((double )((float )tmp___0) * 0.019));
  case_3: /* CIL Label */ 
  {
#line 190
  tmp___1 = (*(method___1->Read))(21);
  }
#line 190
  return ((float )((double )((float )tmp___1) * 0.023));
  case_4: /* CIL Label */ 
  {
#line 192
  tmp___2 = (*(method___1->Read))(19);
  }
#line 192
  return ((float )(((double )((float )tmp___2) * 0.019) * (double )facp12));
  case_5: /* CIL Label */ 
#line 194
  if (gl52_mode == 2) {
    {
#line 195
    tmp___3 = (*(method___1->Read))(14);
    }
#line 195
    return ((float )(((double )((float )tmp___3) * 0.019) * (double )facn12));
  } else {
#line 197
    return ((float )0.0);
  }
  case_6: /* CIL Label */ 
#line 199
  return ((float )0.0);
  switch_default: /* CIL Label */ 
#line 201
  return ((float )65535);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 229 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_gl52.c"
static int div___2[2]  = {      3,      3};
#line 225 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_gl52.c"
static int gl52_fanrpm(LM_METHODS *method___1 , int no ) 
{ 
  int p ;
  int r ;
  int n ;

  {
#line 227
  p = 2;
#line 231
  if (no < 0) {
#line 232
    return (65535);
  } else
#line 231
  if (1 < no) {
#line 232
    return (65535);
  }
  {
#line 234
  n = (*(method___1->Read))(15);
#line 235
  div___2[0] = n >> 6;
#line 236
  div___2[1] = (n >> 4) & 3;
#line 238
  r = (*(method___1->ReadW))(7);
  }
#line 239
  if (no == 0) {
#line 240
    r &= 255;
  } else {
#line 242
    r >>= 8;
  }
#line 244
  if (r == 255) {
#line 246
    if (div___2[no] < 3) {
#line 247
      (div___2[no]) ++;
    } else {
#line 249
      div___2[no] = 0;
    }
    {
#line 250
    r = ((n & 15) | (div___2[0] << 6)) | (div___2[1] << 4);
#line 251
    (*(method___1->Write))(15, r);
    }
#line 252
    return (65535);
  } else
#line 253
  if (r == 0) {
#line 254
    return (65535);
  }
#line 257
  return (960000 / ((r * (1 << div___2[no])) * p));
}
}
#line 56 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm80.c"
static int lm80_probe(LM_METHODS *method___1 ) ;
#line 57
static float lm80_temp(LM_METHODS *method___1 , int no ) ;
#line 58
static int lm80_fanrpm(LM_METHODS *method___1 , int no ) ;
#line 59
static float lm80_volt(LM_METHODS *method___1 , int no ) ;
#line 65 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm80.c"
SENSOR lm80  =    {(char *)"Nat.Semi.Con. Chip LM80", & lm80_probe, & lm80_temp, & lm80_volt, & lm80_fanrpm};
#line 77 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm80.c"
static int chkReg___4[27]  = 
#line 77
  {      0,      1,      2,      4, 
        5,      6,      32,      33, 
        34,      36,      37,      38, 
        39,      40,      41,      43, 
        45,      47,      49,      51, 
        53,      55,      57,      59, 
        60,      61,      -1};
#line 91 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm80.c"
static int lm80_probe(LM_METHODS *method___1 ) 
{ 
  int n ;
  int dat ;
  int reg ;
  int save ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 95
  if ((unsigned long )method___1 != (unsigned long )(& method_smb)) {
#line 96
    return (0);
  }
#line 98
  save = smb_slave;
#line 100
  n = 80;
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! (n <= 94)) {
#line 100
      goto while_break;
    }
    {
#line 101
    smb_slave = get_smb_slave(n, 94);
    }
#line 101
    if (smb_slave) {
      {
#line 104
      tmp = (*(method___1->Read))(2);
      }
#line 104
      if (tmp & 192) {
#line 105
        n = smb_slave + 2;
#line 106
        goto __Cont;
      }
#line 108
      reg = 42;
      {
#line 108
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 108
        if (! (reg <= 61)) {
#line 108
          goto while_break___0;
        }
        {
#line 109
        dat = (*(method___1->Read))(reg);
#line 110
        tmp___0 = (*(method___1->Read))(reg + 64);
        }
#line 110
        if (tmp___0 != dat) {
#line 113
          goto while_break___0;
        } else {
          {
#line 110
          tmp___1 = (*(method___1->Read))(reg + 128);
          }
#line 110
          if (tmp___1 != dat) {
#line 113
            goto while_break___0;
          } else {
            {
#line 110
            tmp___2 = (*(method___1->Read))(reg + 192);
            }
#line 110
            if (tmp___2 != dat) {
#line 113
              goto while_break___0;
            }
          }
        }
#line 108
        reg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 115
      if (reg > 61) {
        {
#line 115
        tmp___3 = chkReg_Probe(smb_slave, (char *)"Probing LM80 chip:\n", chkReg___4,
                               method___1);
        }
#line 115
        if (tmp___3 >= 20) {
#line 118
          goto ret1;
        } else {
#line 120
          n = smb_slave + 2;
        }
      } else {
#line 120
        n = smb_slave + 2;
      }
    } else {
#line 102
      goto ret0;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  ret0: 
#line 125
  smb_slave = save;
#line 126
  return (0);
  ret1: 
  {
#line 128
  tmp___4 = (*(method___1->Read))(0);
  }
#line 128
  if ((tmp___4 & 1) == 0) {
    {
#line 129
    (*(method___1->Write))(0, 16);
#line 130
    (*(method___1->Write))(0, 1);
    }
  }
  {
#line 133
  tmp___5 = (*(method___1->Read))(5);
#line 133
  (*(method___1->Write))(5, (tmp___5 & 60) | 64);
#line 135
  (*(method___1->Write))(6, 10);
#line 142
  kill_smb_slave(smb_slave);
  }
#line 143
  return (1);
}
}
#line 152 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm80.c"
static float lm80_temp(LM_METHODS *method___1 , int no ) 
{ 
  int reg ;
  int val ;
  int sft ;
  float ret ;

  {
#line 157
  if (no != 0) {
#line 158
    return ((float )65535);
  }
  {
#line 160
  reg = (*(method___1->Read))(6);
#line 161
  val = (*(method___1->Read))(39);
#line 163
  sft = ((reg & 8) >> 3) * 3 + 1;
#line 165
  val <<= sft;
#line 166
  val |= reg >> (8 - sft);
#line 168
  ret = (float )val;
  }
#line 169
  if (reg & 8) {
#line 170
    ret = (float )((double )ret * 0.0625);
  } else {
#line 172
    ret = (float )((double )ret * 0.5);
  }
#line 174
  return (ret);
}
}
#line 183 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm80.c"
static float lm80_volt(LM_METHODS *method___1 , int no ) 
{ 
  float r1[7] ;
  float r2[7] ;
  float vout ;
  float val ;
  int tmp ;

  {
#line 185
  r1[0] = (float )23.7;
#line 185
  r1[1] = (float )23.7;
#line 185
  r1[2] = (float )22.1;
#line 185
  r1[3] = (float )24;
#line 185
  r1[4] = (float )160;
#line 185
  r1[5] = (float )27;
#line 185
  r1[6] = (float )180;
#line 186
  r2[0] = (float )75;
#line 186
  r2[1] = (float )75;
#line 186
  r2[2] = (float )30;
#line 186
  r2[3] = (float )14.7;
#line 186
  r2[4] = (float )30.1;
#line 186
  r2[5] = (float )3.4;
#line 186
  r2[6] = (float )42.2;
#line 189
  if (no < 0) {
#line 190
    return ((float )65535);
  } else
#line 189
  if (6 < no) {
#line 190
    return ((float )65535);
  }
  {
#line 192
  tmp = (*(method___1->Read))(32 + no);
#line 192
  vout = (float )tmp;
#line 193
  vout = (float )((double )vout * 0.01);
#line 199
  val = (vout * (r1[no] + r2[no])) / r2[no];
  }
#line 200
  if (no >= 5) {
#line 201
    val = (val - (float )5) * (float )-1;
  }
#line 206
  return (val);
}
}
#line 217 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm80.c"
static int lm80_fanrpm(LM_METHODS *method___1 , int no ) 
{ 
  int reg ;
  int val ;
  int div___11 ;
  int sft ;
  long rpm ;

  {
#line 226
  if (no < 0) {
#line 227
    return (65535);
  } else
#line 226
  if (1 < no) {
#line 227
    return (65535);
  }
  {
#line 229
  reg = (*(method___1->Read))(5);
#line 230
  val = (*(method___1->Read))(40 + no);
#line 234
  sft = (no + 1) * 2;
#line 235
  div___11 = (reg >> sft) & 3;
  }
#line 240
  if (val == 255) {
#line 241
    if (div___11 < 3) {
      {
#line 242
      reg += 1 << sft;
#line 243
      (*(method___1->Write))(5, reg);
      }
    }
#line 248
    return (65536);
  }
#line 254
  rpm = (long )(1350000 / (val * (1 << div___11)));
#line 255
  return ((int )rpm);
}
}
#line 38 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_via686.c"
static int via686_probe(LM_METHODS *method___1 ) ;
#line 39
static float via686_temp(LM_METHODS *method___1 , int no ) ;
#line 40
static int via686_fanrpm(LM_METHODS *method___1 , int no ) ;
#line 41
static float via686_volt(LM_METHODS *method___1 , int no ) ;
#line 43 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_via686.c"
SENSOR via686  =    {(char *)"VIA Chip VT82C686A/B", & via686_probe, & via686_temp, & via686_volt,
    & via686_fanrpm};
#line 55 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_via686.c"
static int chkReg___5[21]  = 
#line 55
  {      64,      65,      66,      67, 
        68,      71,      73,      75, 
        63,      20,      31,      32, 
        33,      34,      35,      36, 
        37,      38,      41,      43, 
        -1};
#line 67 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_via686.c"
static int via686_probe(LM_METHODS *method___1 ) 
{ 
  int n ;
  int save ;
  int tmp ;
  int tmp___0 ;

  {
#line 71
  if ((unsigned long )method___1 != (unsigned long )(& method_via)) {
#line 71
    if ((unsigned long )method___1 != (unsigned long )(& method_smb)) {
#line 72
      return (0);
    }
  }
#line 74
  if (pm_smb_detected != 2) {
#line 74
    if (pm_smb_detected != 1) {
#line 75
      return (0);
    }
  }
#line 77
  save = smb_slave;
#line 79
  if ((unsigned long )method___1 == (unsigned long )(& method_smb)) {
#line 80
    n = 80;
    {
#line 80
    while (1) {
      while_continue: /* CIL Label */ ;
#line 80
      if (! (n <= 94)) {
#line 80
        goto while_break;
      }
      {
#line 81
      smb_slave = get_smb_slave(n, 94);
      }
#line 81
      if (smb_slave) {
        {
#line 84
        tmp = chkReg_Probe(smb_slave, (char *)"Probing VIA686A/B chip:\n", chkReg___5,
                           method___1);
        }
#line 84
        if (tmp >= 5) {
#line 86
          goto ret1;
        } else {
#line 88
          n = smb_slave + 2;
        }
      } else {
#line 82
        goto ret0;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 92
    tmp___0 = chkReg_Probe(0, (char *)"Probing VIA686A/B chip:\n", chkReg___5, method___1);
    }
#line 92
    if (tmp___0 >= 5) {
#line 94
      goto ret1;
    }
  }
  ret0: 
#line 98
  smb_slave = save;
#line 99
  return (0);
  ret1: 
#line 101
  if ((unsigned long )method___1 == (unsigned long )(& method_smb)) {
    {
#line 102
    kill_smb_slave(smb_slave);
    }
  }
#line 103
  return (1);
}
}
#line 107 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_via686.c"
static float const   via686temp_tab[256]  = 
#line 107
  {      (float const   ).00,      (float const   ).00,      (float const   ).00,      (float const   ).00, 
        (float const   ).00,      (float const   ).00,      (float const   ).00,      (float const   ).00, 
        (float const   ).00,      (float const   ).00,      (float const   ).00,      (float const   ).00, 
        (float const   ).00,      (float const   ).00,      (float const   ).00,      (float const   )(- 50.00), 
        (float const   )(- 48.00),      (float const   )(- 46.09),      (float const   )(- 44.26),      (float const   )(- 42.52), 
        (float const   )(- 40.86),      (float const   )(- 39.28),      (float const   )(- 37.78),      (float const   )(- 36.35), 
        (float const   )(- 34.99),      (float const   )(- 33.70),      (float const   )(- 32.47),      (float const   )(- 31.31), 
        (float const   )(- 30.20),      (float const   )(- 29.15),      (float const   )(- 28.14),      (float const   )(- 27.18), 
        (float const   )(- 26.27),      (float const   )(- 25.39),      (float const   )(- 24.55),      (float const   )(- 23.73), 
        (float const   )(- 22.95),      (float const   )(- 22.18),      (float const   )(- 21.44),      (float const   )(- 20.70), 
        (float const   )(- 19.98),      (float const   )(- 19.27),      (float const   )(- 18.57),      (float const   )(- 17.87), 
        (float const   )(- 17.19),      (float const   )(- 16.51),      (float const   )(- 15.85),      (float const   )(- 15.20), 
        (float const   )(- 14.56),      (float const   )(- 13.93),      (float const   )(- 13.32),      (float const   )(- 12.72), 
        (float const   )(- 12.14),      (float const   )(- 11.58),      (float const   )(- 11.03),      (float const   )(- 10.50), 
        (float const   )(- 9.99),      (float const   )(- 9.50),      (float const   )(- 9.03),      (float const   )(- 8.57), 
        (float const   )(- 8.11),      (float const   )(- 7.67),      (float const   )(- 7.22),      (float const   )(- 6.77), 
        (float const   )(- 6.31),      (float const   )(- 5.85),      (float const   )(- 5.37),      (float const   )(- 4.87), 
        (float const   )(- 4.36),      (float const   )(- 3.81),      (float const   )(- 3.24),      (float const   )(- 2.64), 
        (float const   )(- 2.00),      (float const   )(- 1.33),      (float const   )(- .65),      (float const   ).00, 
        (float const   ).59,      (float const   )1.12,      (float const   )1.60,      (float const   )2.03, 
        (float const   )2.42,      (float const   )2.79,      (float const   )3.12,      (float const   )3.44, 
        (float const   )3.75,      (float const   )4.05,      (float const   )4.35,      (float const   )4.67, 
        (float const   )4.99,      (float const   )5.34,      (float const   )5.71,      (float const   )6.09, 
        (float const   )6.49,      (float const   )6.91,      (float const   )7.34,      (float const   )7.78, 
        (float const   )8.23,      (float const   )8.69,      (float const   )9.15,      (float const   )9.62, 
        (float const   )10.09,      (float const   )10.57,      (float const   )11.04,      (float const   )11.51, 
        (float const   )11.98,      (float const   )12.44,      (float const   )12.90,      (float const   )13.35, 
        (float const   )13.80,      (float const   )14.24,      (float const   )14.68,      (float const   )15.12, 
        (float const   )15.55,      (float const   )15.99,      (float const   )16.42,      (float const   )16.85, 
        (float const   )17.27,      (float const   )17.70,      (float const   )18.13,      (float const   )18.56, 
        (float const   )18.99,      (float const   )19.42,      (float const   )19.85,      (float const   )20.29, 
        (float const   )20.72,      (float const   )21.15,      (float const   )21.59,      (float const   )22.03, 
        (float const   )22.47,      (float const   )22.90,      (float const   )23.34,      (float const   )23.78, 
        (float const   )24.22,      (float const   )24.66,      (float const   )25.10,      (float const   )25.54, 
        (float const   )25.99,      (float const   )26.43,      (float const   )26.87,      (float const   )27.31, 
        (float const   )27.75,      (float const   )28.19,      (float const   )28.63,      (float const   )29.07, 
        (float const   )29.51,      (float const   )29.95,      (float const   )30.38,      (float const   )30.82, 
        (float const   )31.25,      (float const   )31.68,      (float const   )32.11,      (float const   )32.53, 
        (float const   )32.96,      (float const   )33.38,      (float const   )33.80,      (float const   )34.22, 
        (float const   )34.63,      (float const   )35.05,      (float const   )35.48,      (float const   )35.90, 
        (float const   )36.33,      (float const   )36.76,      (float const   )37.20,      (float const   )37.64, 
        (float const   )38.09,      (float const   )38.55,      (float const   )39.02,      (float const   )39.50, 
        (float const   )39.99,      (float const   )40.49,      (float const   )41.00,      (float const   )41.52, 
        (float const   )42.06,      (float const   )42.60,      (float const   )43.15,      (float const   )43.70, 
        (float const   )44.27,      (float const   )44.84,      (float const   )45.41,      (float const   )45.99, 
        (float const   )46.57,      (float const   )47.16,      (float const   )47.75,      (float const   )48.35, 
        (float const   )48.94,      (float const   )49.54,      (float const   )50.13,      (float const   )50.73, 
        (float const   )51.33,      (float const   )51.94,      (float const   )52.55,      (float const   )53.16, 
        (float const   )53.78,      (float const   )54.41,      (float const   )55.04,      (float const   )55.68, 
        (float const   )56.32,      (float const   )56.98,      (float const   )57.64,      (float const   )58.32, 
        (float const   )59.00,      (float const   )59.69,      (float const   )60.40,      (float const   )61.12, 
        (float const   )61.85,      (float const   )62.60,      (float const   )63.36,      (float const   )64.13, 
        (float const   )64.93,      (float const   )65.73,      (float const   )66.56,      (float const   )67.40, 
        (float const   )68.26,      (float const   )69.14,      (float const   )70.05,      (float const   )70.97, 
        (float const   )71.91,      (float const   )72.88,      (float const   )73.86,      (float const   )74.88, 
        (float const   )75.92,      (float const   )76.98,      (float const   )78.08,      (float const   )79.21, 
        (float const   )80.36,      (float const   )81.55,      (float const   )82.78,      (float const   )84.03, 
        (float const   )85.33,      (float const   )86.66,      (float const   )88.04,      (float const   )89.45, 
        (float const   )90.90,      (float const   )92.40,      (float const   )93.94,      (float const   )95.53, 
        (float const   )97.16,      (float const   )98.85,      (float const   )100.58,      (float const   )102.36, 
        (float const   )104.19,      (float const   )106.07,      (float const   )108.01,      (float const   )110.00, 
        (float const   ).00,      (float const   ).00,      (float const   ).00,      (float const   ).00, 
        (float const   ).00,      (float const   ).00,      (float const   ).00,      (float const   ).00, 
        (float const   ).00,      (float const   ).00,      (float const   ).00,      (float const   ).00};
#line 147 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_via686.c"
static float via686_temp(LM_METHODS *method___1 , int no ) 
{ 
  int tmp ;

  {
#line 149
  if (no < 0) {
#line 150
    return ((float )65535);
  } else
#line 149
  if (2 < no) {
#line 150
    return ((float )65535);
  }
  {
#line 152
  tmp = (*(method___1->Read))(31 + no);
  }
#line 152
  return ((float )via686temp_tab[tmp]);
}
}
#line 160 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_via686.c"
static float via686_volt(LM_METHODS *method___1 , int no ) 
{ 
  int n ;
  float fac ;

  {
#line 165
  if (no < 0) {
#line 166
    return ((float )65535);
  } else
#line 165
  if (4 < no) {
#line 166
    return ((float )65535);
  }
  {
#line 170
  if (no == 1) {
#line 170
    goto case_1;
  }
#line 170
  if (no == 0) {
#line 170
    goto case_1;
  }
#line 173
  if (no == 2) {
#line 173
    goto case_2;
  }
#line 176
  if (no == 3) {
#line 176
    goto case_3;
  }
#line 179
  if (no == 4) {
#line 179
    goto case_4;
  }
#line 168
  goto switch_break;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 171
  fac = (float )(5. / 10512.);
#line 172
  goto switch_break;
  case_2: /* CIL Label */ 
#line 174
  fac = (float )(5. / 7884.);
#line 175
  goto switch_break;
  case_3: /* CIL Label */ 
#line 177
  fac = (float )(26. / 26280.);
#line 178
  goto switch_break;
  case_4: /* CIL Label */ 
#line 180
  fac = (float )(63. / 26280.);
  switch_break: /* CIL Label */ ;
  }
  {
#line 183
  n = (*(method___1->Read))(34 + no);
  }
#line 183
  if (n <= 64) {
#line 184
    n |= 256;
  }
#line 186
  return ((float )(n * 25 + 133) * fac);
}
}
#line 210 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_via686.c"
static int div___3[2]  = {      1,      1};
#line 207 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_via686.c"
static int via686_fanrpm(LM_METHODS *method___1 , int no ) 
{ 
  int r ;
  int n ;

  {
#line 212
  if (no < 0) {
#line 213
    return (65535);
  } else
#line 212
  if (1 < no) {
#line 213
    return (65535);
  }
  {
#line 215
  n = (*(method___1->Read))(71);
#line 216
  div___3[0] = (n >> 4) & 3;
#line 217
  div___3[1] = n >> 6;
#line 219
  r = (*(method___1->Read))(41 + no);
  }
#line 220
  if (r == 255) {
#line 222
    if (div___3[no] < 3) {
#line 223
      (div___3[no]) ++;
    } else {
#line 225
      div___3[no] = 0;
    }
    {
#line 226
    r = ((n & 15) | (div___3[0] << 4)) | (div___3[1] << 6);
#line 227
    (*(method___1->Write))(71, r);
    }
#line 228
    return (65535);
  } else
#line 229
  if (r == 0) {
#line 230
    return (65535);
  }
#line 233
  return (1350000 / (r * (1 << div___3[no])));
}
}
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 35 "/home/wheatley/newnew/temp/xmbmon-2.05/getMBinfo.c"
extern int fahrn_flag ;
#line 41
extern char *probe_request ;
#line 53
extern int extra_tempNO ;
#line 59 "/home/wheatley/newnew/temp/xmbmon-2.05/getMBinfo.c"
static LM_METHODS *this_method  =    (LM_METHODS *)((void *)0);
#line 60 "/home/wheatley/newnew/temp/xmbmon-2.05/getMBinfo.c"
static SENSOR *this_sensor  =    (SENSOR *)((void *)0);
#line 61 "/home/wheatley/newnew/temp/xmbmon-2.05/getMBinfo.c"
static int probe_flag  =    2002;
#line 62 "/home/wheatley/newnew/temp/xmbmon-2.05/getMBinfo.c"
static int HWM_firstSMB_flag  =    0;
#line 63 "/home/wheatley/newnew/temp/xmbmon-2.05/getMBinfo.c"
static char method  ;
#line 67
int Probe_method(void) ;
#line 68
int HWM_detection(int chip ) ;
#line 69
void HWM_set_firstSMB(SENSOR *module , int slave ) ;
#line 70
int probe_HWMChip(LM_METHODS *methodp , int probe ) ;
#line 71
int via_set(void) ;
#line 72
int smb_set(int probe , int chip ) ;
#line 73
int isa_set(int probe ) ;
#line 74
int InitMBInfo(char method_inp ) ;
#line 75
int getTemp(float *t1 , float *t2 , float *t3 ) ;
#line 76
int getVolt(float *vc0 , float *vc1 , float *v33 , float *v50p , float *v50n , float *v12p ,
            float *v12n ) ;
#line 77
int getFanSp(int *r1 , int *r2 , int *r3 ) ;
#line 84 "/home/wheatley/newnew/temp/xmbmon-2.05/getMBinfo.c"
int Probe_method(void) 
{ 
  int n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 88
  if ((int )method != 73) {
    {
#line 89
    pm_smb_detected = set_smbus_io(& viahwm_base, & smb_base);
    }
  }
#line 91
  if ((int )method == 86) {
#line 92
    n = pm_smb_detected;
#line 92
    if (n == 2) {
      {
#line 94
      tmp = via_set();
      }
#line 94
      return (tmp);
    } else
#line 95
    if (n != -1) {
      {
#line 96
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No VIA686 HWM available!!\n");
      }
#line 97
      return (1);
    }
  } else
#line 99
  if ((int )method == 83) {
#line 100
    n = pm_smb_detected;
#line 100
    if (n > 0) {
      {
#line 102
      tmp___0 = smb_set(probe_flag, n);
      }
#line 102
      return (tmp___0);
    } else
#line 103
    if (n != -1) {
      {
#line 104
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No SMBus HWM available!!\n");
      }
#line 105
      return (1);
    }
  } else
#line 107
  if ((int )method == 73) {
    {
#line 109
    n = isa_set(probe_flag);
    }
#line 109
    if (n == 0) {
#line 110
      return (0);
    } else
#line 111
    if (n != -1) {
      {
#line 112
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No ISA-IO HWM available!!\n");
      }
#line 113
      return (1);
    }
  } else
#line 117
  if (probe_flag == 2002) {
#line 117
    goto _L___2;
  } else
#line 117
  if (probe_flag == 2) {
    _L___2: /* CIL Label */ 
#line 117
    n = pm_smb_detected;
#line 117
    if (n == 2) {
      {
#line 119
      tmp___1 = via_set();
      }
#line 119
      if (tmp___1 == 0) {
#line 119
        if ((int )method != 65) {
#line 120
          return (0);
        } else {
#line 119
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 121
      if (n > 0) {
#line 122
        goto smb_chk;
      }
    } else {
#line 117
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 123
    n = pm_smb_detected;
#line 123
    if (n > 0) {
      smb_chk: 
      {
#line 124
      tmp___2 = smb_set(probe_flag, n);
      }
#line 124
      if (tmp___2 == 0) {
#line 124
        if ((int )method != 65) {
#line 125
          return (0);
        }
      }
#line 126
      goto isa_chk;
    } else {
      isa_chk: 
      {
#line 128
      n = isa_set(probe_flag);
      }
#line 128
      if (n == 0) {
#line 128
        if ((int )method != 65) {
#line 129
          return (0);
        } else {
#line 128
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 130
      if (n != -1) {
#line 130
        if ((int )method != 65) {
          {
#line 131
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No Hardware Monitor found!!\n");
          }
#line 132
          return (1);
        }
      }
    }
  }
#line 137
  if ((int )method == 65) {
    {
#line 138
    tmp___3 = HWM_detection(pm_smb_detected);
    }
#line 138
    return (tmp___3);
  }
#line 141
  return (-1);
}
}
#line 144 "/home/wheatley/newnew/temp/xmbmon-2.05/getMBinfo.c"
int HWM_detection(int chip ) 
{ 
  int n ;
  int j ;
  int k ;
  int ext ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 148
  if (debug_flag) {
    {
#line 149
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Summary of Detection:\n");
    }
  }
#line 151
  if ((HWM_VIA + HWM_SMB) + HWM_ISA <= 0) {
#line 152
    if (debug_flag) {
      {
#line 153
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" * No monitors found.\n");
      }
    }
#line 154
    return (-1);
  }
#line 157
  if (HWM_VIA > 0) {
#line 158
    this_method = & method_via;
#line 159
    if (debug_flag) {
      {
#line 160
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" * VIA686A/B monitor found.\n");
      }
    }
  }
#line 162
  n = 0;
#line 162
  k = 0;
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (! ((unsigned long )HWM_module[n] != (unsigned long )((void *)0))) {
#line 162
      goto while_break;
    }
#line 163
    if (HWM_SMBchip[n] != 0) {
#line 164
      if (debug_flag) {
#line 165
        if (! k) {
          {
#line 169
          tmp = chk_smb_chip(chip);
#line 169
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" * SMB monitor(s)[%s]:\n",
                  tmp);
          }
        }
        {
#line 172
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  ** %s found at slave address: 0x%02X.\n",
                (HWM_module[n])->Name, HWM_smbslave[n]);
        }
      }
      {
#line 175
      k ++;
#line 176
      ext = 0;
#line 177
      j = num_extemp_chip;
#line 178
      tmp___2 = strcmp((char const   *)HWM_name[n], "lm75");
      }
#line 178
      if (tmp___2) {
        {
#line 181
        tmp___1 = strcmp((char const   *)HWM_name[n], "lm90");
        }
#line 181
        if (tmp___1) {
          {
#line 184
          tmp___0 = strcmp((char const   *)HWM_name[n], "wl784");
          }
#line 184
          if (! tmp___0) {
#line 184
            if (HWM_SMBchip[n] == 3) {
#line 186
              smb_extemp_chip[j] = 1;
#line 187
              ext = 1;
            }
          }
        } else {
#line 182
          smb_extemp_chip[j] = 2;
#line 183
          ext = 1;
        }
      } else {
#line 179
        smb_extemp_chip[j] = 3;
#line 180
        ext = 1;
      }
#line 189
      if (ext) {
#line 190
        smb_extemp_slave[j] = HWM_smbslave[n];
#line 191
        num_extemp_chip ++;
      }
#line 194
      if (! ext) {
#line 194
        if (! HWM_firstSMB_flag) {
#line 194
          if (HWM_SMB > 1) {
            {
#line 195
            HWM_set_firstSMB(HWM_module[n], HWM_smbslave[n]);
            }
          }
        }
      }
    }
#line 162
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 198
  n = 0;
#line 198
  k = 0;
  {
#line 198
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 198
    if (! ((unsigned long )HWM_module[n] != (unsigned long )((void *)0))) {
#line 198
      goto while_break___0;
    }
#line 199
    if (HWM_ISAchip[n] != 0) {
#line 200
      if (debug_flag) {
#line 201
        if (! k) {
          {
#line 202
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" * ISA monitor(s):\n");
          }
        }
        {
#line 203
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  ** %s found.\n",
                (HWM_module[n])->Name);
        }
      }
#line 205
      k ++;
    }
#line 198
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 211
  if ((HWM_VIA + HWM_SMB) + HWM_ISA == num_extemp_chip) {
#line 212
    num_extemp_chip = 0;
  }
#line 214
  return (0);
}
}
#line 217 "/home/wheatley/newnew/temp/xmbmon-2.05/getMBinfo.c"
void HWM_set_firstSMB(SENSOR *module , int slave ) 
{ 
  int n ;

  {
#line 221
  n = 0;
  {
#line 221
  while (1) {
    while_continue: /* CIL Label */ ;
#line 221
    if (! (n < numSMBSlave)) {
#line 221
      goto while_break;
    }
#line 222
    if (canSMBSlave[n] == 255) {
#line 223
      canSMBSlave[n] = slave;
#line 224
      goto while_break;
    }
#line 221
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 228
  this_method = & method_smb;
#line 229
  this_sensor = module;
#line 231
  n = debug_flag;
#line 232
  debug_flag = 0;
#line 234
  (*(this_method->Open))();
#line 235
  (*(this_sensor->Probe))(this_method);
#line 236
  (*(this_method->Close))();
#line 238
  debug_flag = n;
#line 239
  HWM_firstSMB_flag = 1;
  }
#line 240
  return;
}
}
#line 242 "/home/wheatley/newnew/temp/xmbmon-2.05/getMBinfo.c"
int probe_HWMChip(LM_METHODS *methodp , int probe ) 
{ 
  int i ;
  int n ;
  int n0 ;
  int num ;
  int tmp ;

  {
  {
#line 244
  n0 = 0;
#line 244
  num = 0;
#line 246
  tmp = (*(methodp->Open))();
  }
#line 246
  if (tmp != 0) {
#line 247
    return (-1);
  }
#line 250
  n = 0;
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if (! ((unsigned long )HWM_module[n] != (unsigned long )((void *)0))) {
#line 250
      goto while_break;
    }
#line 251
    if (probe == 2002) {
#line 251
      goto _L;
    } else
#line 251
    if (probe == n) {
      _L: /* CIL Label */ 
      {
#line 251
      i = (*((HWM_module[n])->Probe))(methodp);
      }
#line 251
      if (i != 0) {
#line 253
        if ((unsigned long )methodp == (unsigned long )(& method_smb)) {
#line 254
          HWM_SMBchip[n] = i;
#line 255
          HWM_smbslave[n] = smb_slave;
#line 256
          HWM_SMB ++;
        } else
#line 257
        if ((unsigned long )methodp == (unsigned long )(& method_isa)) {
#line 258
          HWM_ISAchip[n] = i;
#line 259
          HWM_ISA ++;
        } else {
#line 261
          HWM_VIA ++;
        }
#line 263
        num ++;
#line 264
        if (n0 == 0) {
#line 265
          n0 = n;
        }
#line 266
        if ((int )method != 65) {
#line 267
          goto while_break;
        }
      }
    }
#line 250
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 270
  if (num) {
#line 271
    this_sensor = HWM_module[n0];
  }
  {
#line 273
  (*(methodp->Close))();
  }
#line 274
  return (num);
}
}
#line 277 "/home/wheatley/newnew/temp/xmbmon-2.05/getMBinfo.c"
int via_set(void) 
{ 
  int tmp ;

  {
#line 279
  if (debug_flag > 1) {
    {
#line 280
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">>> Testing Reg\'s at VIA686 HWM <<<\n");
    }
  }
  {
#line 282
  tmp = probe_HWMChip(& method_via, 2);
  }
#line 282
  if (tmp > 0) {
#line 283
    this_method = & method_via;
#line 284
    if (debug_flag) {
#line 284
      if ((int )method != 65) {
        {
#line 285
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Using VIA686 HWM directly!!\n");
        }
      }
    }
#line 286
    return (0);
  } else {
    {
#line 288
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Something Wrong in detected VIA686 HWM!!\n");
    }
#line 289
    return (1);
  }
}
}
#line 293 "/home/wheatley/newnew/temp/xmbmon-2.05/getMBinfo.c"
int smb_set(int probe , int chip ) 
{ 
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 295
  if (debug_flag > 1) {
    {
#line 299
    tmp = chk_smb_chip(chip);
#line 299
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">>> Testing Reg\'s at SMBus <<<\n[%s, IO-Base:0x%0X]\n",
            tmp, smb_base);
    }
  }
  {
#line 303
  tmp___0 = find_smb_dev();
  }
#line 303
  if (tmp___0 <= 0) {
#line 304
    goto ret1;
  }
  {
#line 306
  tmp___3 = probe_HWMChip(& method_smb, probe);
  }
#line 306
  if (tmp___3 > 0) {
#line 307
    this_method = & method_smb;
#line 308
    if (debug_flag) {
#line 308
      if ((int )method != 65) {
        {
#line 312
        tmp___1 = chk_smb_chip(chip);
#line 312
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Using SMBus access method[%s]!!\n",
                tmp___1);
        }
      }
    }
#line 316
    return (0);
  } else {
    ret1: 
#line 318
    if (debug_flag) {
      {
#line 319
      tmp___2 = chk_smb_chip(chip);
#line 319
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SMBus[%s] found, but No HWM available on it!!\n",
              tmp___2);
      }
    }
#line 322
    return (1);
  }
}
}
#line 326 "/home/wheatley/newnew/temp/xmbmon-2.05/getMBinfo.c"
int isa_set(int probe ) 
{ 
  int n ;

  {
#line 330
  if (debug_flag > 1) {
    {
#line 331
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">>> Testing Reg\'s at ISA-IO <<<\n[ISA Port IO-Base:0x%0X]\n",
            isa_port_base);
    }
  }
  {
#line 334
  n = probe_HWMChip(& method_isa, probe);
  }
#line 334
  if (n > 0) {
#line 335
    this_method = & method_isa;
#line 336
    if (debug_flag) {
#line 336
      if ((int )method != 65) {
        {
#line 337
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Using ISA-IO access method!!\n");
        }
      }
    }
#line 338
    return (0);
  } else
#line 339
  if (n == 0) {
#line 340
    n = 1;
  }
#line 342
  return (n);
}
}
#line 345 "/home/wheatley/newnew/temp/xmbmon-2.05/getMBinfo.c"
int InitMBInfo(char method_inp ) 
{ 
  int n ;
  int tmp ;

  {
#line 350
  if (TyanTigerMP_flag) {
    {
#line 351
    TyanTigerMPinit();
    }
  }
#line 353
  if (debug_flag > 1) {
    {
#line 354
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Probe Request: %s\n",
            probe_request);
    }
  }
#line 356
  n = 0;
  {
#line 356
  while (1) {
    while_continue: /* CIL Label */ ;
#line 356
    if (! ((unsigned long )HWM_name[n] != (unsigned long )((void *)0))) {
#line 356
      goto while_break;
    }
    {
#line 357
    tmp = strcmp((char const   *)probe_request, (char const   *)HWM_name[n]);
    }
#line 357
    if (tmp == 0) {
#line 358
      probe_flag = n;
#line 359
      goto while_break;
    }
#line 356
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 363
  method = method_inp;
#line 364
  n = Probe_method();
  }
#line 364
  if (n != 0) {
#line 365
    return (n);
  }
#line 368
  if (this_method) {
#line 368
    if (this_sensor) {
#line 369
      if (debug_flag) {
#line 369
        if ((int )method != 65) {
          {
#line 370
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"* %s found.\n",
                  this_sensor->Name);
          }
        }
      }
#line 371
      return (0);
    } else {
#line 373
      return (-1);
    }
  } else {
#line 373
    return (-1);
  }
}
}
#line 384 "/home/wheatley/newnew/temp/xmbmon-2.05/getMBinfo.c"
int getTemp(float *t1 , float *t2 , float *t3 ) 
{ 
  int n ;
  float f ;
  float t[3] ;
  int tmp ;

  {
  {
#line 387
  t[0] = (float )0.0;
#line 387
  t[1] = (float )0.0;
#line 387
  t[2] = (float )0.0;
#line 389
  tmp = (*(this_method->Open))();
  }
#line 389
  if (tmp != 0) {
#line 390
    return (-1);
  }
#line 392
  if (this_sensor) {
#line 393
    n = 0;
    {
#line 393
    while (1) {
      while_continue: /* CIL Label */ ;
#line 393
      if (! (n < 3)) {
#line 393
        goto while_break;
      }
      {
#line 394
      f = (*(this_sensor->Temp))(this_method, n);
      }
#line 394
      if (f != (float )65535) {
#line 398
        t[n] = f;
      }
#line 393
      n ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 402
  if ((unsigned long )this_sensor == (unsigned long )(& it87)) {
#line 404
    f = t[0];
#line 405
    t[0] = t[1];
#line 406
    t[1] = t[2];
#line 407
    t[2] = f;
  } else
#line 402
  if ((unsigned long )this_sensor == (unsigned long )(& via686)) {
#line 404
    f = t[0];
#line 405
    t[0] = t[1];
#line 406
    t[1] = t[2];
#line 407
    t[2] = f;
  } else
#line 408
  if ((unsigned long )this_sensor == (unsigned long )(& lm85)) {
#line 410
    f = t[0];
#line 411
    t[0] = t[1];
#line 412
    t[1] = f;
  }
#line 415
  if (num_extemp_chip > 0) {
    {
#line 416
    f = smb_ExtraTemp();
    }
#line 416
    if (f != (float )65535) {
#line 417
      t[extra_tempNO] = f;
    }
  }
#line 420
  if (fahrn_flag) {
#line 421
    n = 0;
    {
#line 421
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 421
      if (! (n <= 2)) {
#line 421
        goto while_break___0;
      }
#line 422
      if ((double )t[n] != 0.0) {
#line 423
        t[n] = (float )((double )t[n] * 1.8 + 32.0);
      }
#line 421
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 427
  *t1 = t[0];
#line 427
  *t2 = t[1];
#line 427
  *t3 = t[2];
#line 429
  (*(this_method->Close))();
  }
#line 430
  return (0);
}
}
#line 437 "/home/wheatley/newnew/temp/xmbmon-2.05/getMBinfo.c"
int getVolt(float *vc0 , float *vc1 , float *v33 , float *v50p , float *v50n , float *v12p ,
            float *v12n ) 
{ 
  int n ;
  float f ;
  float v[7] ;
  int tmp ;

  {
  {
#line 442
  v[0] = (float )0.0;
#line 442
  v[1] = (float )0.0;
#line 442
  v[2] = (float )0.0;
#line 442
  v[3] = (float )0.0;
#line 442
  v[4] = (float )0.0;
#line 442
  v[5] = (float )0.0;
#line 442
  v[6] = (float )0.0;
#line 444
  tmp = (*(this_method->Open))();
  }
#line 444
  if (tmp != 0) {
#line 445
    return (-1);
  }
#line 447
  if (this_sensor) {
#line 448
    n = 0;
    {
#line 448
    while (1) {
      while_continue: /* CIL Label */ ;
#line 448
      if (! (n < 7)) {
#line 448
        goto while_break;
      }
      {
#line 449
      f = (*(this_sensor->Volt))(this_method, n);
      }
#line 449
      if (f != (float )65535) {
#line 450
        v[n] = f;
      }
#line 448
      n ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 453
  if ((unsigned long )this_sensor == (unsigned long )(& lm85)) {
#line 455
    f = v[0];
#line 456
    v[0] = v[1];
#line 457
    v[1] = f;
  }
  {
#line 460
  *vc0 = v[0];
#line 460
  *vc1 = v[1];
#line 461
  *v33 = v[2];
#line 461
  *v50p = v[3];
#line 461
  *v12p = v[4];
#line 462
  *v12n = v[5];
#line 462
  *v50n = v[6];
#line 464
  (*(this_method->Close))();
  }
#line 465
  return (0);
}
}
#line 472 "/home/wheatley/newnew/temp/xmbmon-2.05/getMBinfo.c"
int getFanSp(int *r1 , int *r2 , int *r3 ) 
{ 
  int n ;
  int i ;
  int r[3] ;
  int tmp ;

  {
  {
#line 475
  r[0] = 0;
#line 475
  r[1] = 0;
#line 475
  r[2] = 0;
#line 477
  tmp = (*(this_method->Open))();
  }
#line 477
  if (tmp != 0) {
#line 478
    return (-1);
  }
#line 480
  if (this_sensor) {
#line 481
    n = 0;
    {
#line 481
    while (1) {
      while_continue: /* CIL Label */ ;
#line 481
      if (! (n < 3)) {
#line 481
        goto while_break;
      }
      {
#line 482
      i = (*(this_sensor->FanRPM))(this_method, n);
      }
#line 482
      if (i != 65535) {
#line 483
        r[n] = i;
      }
#line 481
      n ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 486
  if ((unsigned long )this_sensor == (unsigned long )(& lm85)) {
#line 488
    i = r[0];
#line 489
    r[0] = r[1];
#line 490
    r[1] = i;
  }
  {
#line 492
  *r1 = r[0];
#line 492
  *r2 = r[1];
#line 492
  *r3 = r[2];
#line 494
  (*(this_method->Close))();
  }
#line 495
  return (0);
}
}
#line 78 "/home/wheatley/newnew/temp/xmbmon-2.05/smbus_amd8.c"
static int readbyte___2(int smb_base___0 , int addr , int cmd ) 
{ 
  u_char dat ;
  u_char saddr ;
  int i ;

  {
#line 80
  dat = (u_char )0;
#line 80
  saddr = (u_char )(2 * (addr / 2) + 1);
  top: 
  {
#line 84
  my_outb((u_short )(smb_base___0 + 2), saddr);
#line 84
  my_outb((unsigned short)235, (unsigned char)0);
#line 84
  my_outb((unsigned short)235, (unsigned char)0);
#line 85
  my_outb((u_short )(smb_base___0 + 3), (u_char )cmd);
#line 85
  my_outb((unsigned short)235, (unsigned char)0);
#line 85
  my_outb((unsigned short)235, (unsigned char)0);
#line 86
  my_outb((u_short )smb_base___0, (unsigned char)7);
#line 86
  my_outb((unsigned short)235, (unsigned char)0);
#line 86
  my_outb((unsigned short)235, (unsigned char)0);
#line 88
  i = 0;
  }
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! (i < 32)) {
#line 88
      goto while_break;
    }
    {
#line 89
    my_outb((unsigned short)235, (unsigned char)0);
#line 88
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  i = 0;
  {
#line 91
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 91
    if (! (i < 8192)) {
#line 91
      goto while_break___0;
    }
    {
#line 92
    dat = my_inb((u_short )(smb_base___0 + 1));
#line 92
    my_outb((unsigned short)235, (unsigned char)0);
#line 92
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 96
    if ((int )dat == 26) {
#line 97
      goto top;
    } else
#line 96
    if ((int )dat == 24) {
#line 97
      goto top;
    }
#line 98
    if ((int )dat & 159) {
#line 99
      goto while_break___0;
    }
#line 91
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 107
  if ((int )dat == 128) {
    {
#line 108
    dat = my_inb((u_short )(smb_base___0 + 4));
#line 108
    my_outb((unsigned short)235, (unsigned char)0);
#line 108
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 113
    return ((int )dat & 255);
  } else {
#line 115
    return (-1);
  }
}
}
#line 118 "/home/wheatley/newnew/temp/xmbmon-2.05/smbus_amd8.c"
static int readword___1(int smb_base___0 , int addr , int cmd ) 
{ 
  u_char dat ;
  u_char saddr ;
  int i ;
  unsigned char tmp ;

  {
#line 120
  dat = (u_char )0;
#line 120
  saddr = (u_char )(2 * (addr / 2) + 1);
  top: 
  {
#line 124
  my_outb((u_short )(smb_base___0 + 2), saddr);
#line 124
  my_outb((unsigned short)235, (unsigned char)0);
#line 124
  my_outb((unsigned short)235, (unsigned char)0);
#line 125
  my_outb((u_short )(smb_base___0 + 3), (u_char )cmd);
#line 125
  my_outb((unsigned short)235, (unsigned char)0);
#line 125
  my_outb((unsigned short)235, (unsigned char)0);
#line 126
  my_outb((u_short )smb_base___0, (unsigned char)9);
#line 126
  my_outb((unsigned short)235, (unsigned char)0);
#line 126
  my_outb((unsigned short)235, (unsigned char)0);
#line 128
  i = 0;
  }
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    if (! (i < 32)) {
#line 128
      goto while_break;
    }
    {
#line 129
    my_outb((unsigned short)235, (unsigned char)0);
#line 128
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  i = 0;
  {
#line 131
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 131
    if (! (i < 8192)) {
#line 131
      goto while_break___0;
    }
    {
#line 132
    dat = my_inb((u_short )(smb_base___0 + 1));
#line 132
    my_outb((unsigned short)235, (unsigned char)0);
#line 132
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 133
    if ((int )dat == 26) {
#line 134
      goto top;
    } else
#line 133
    if ((int )dat == 24) {
#line 134
      goto top;
    }
#line 135
    if ((int )dat & 159) {
#line 136
      goto while_break___0;
    }
#line 131
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 144
  if ((int )dat == 128) {
    {
#line 145
    tmp = my_inb((u_short )(smb_base___0 + 5));
#line 145
    i = (int )tmp;
#line 145
    my_outb((unsigned short)235, (unsigned char)0);
#line 145
    my_outb((unsigned short)235, (unsigned char)0);
#line 146
    dat = my_inb((u_short )(smb_base___0 + 4));
#line 146
    my_outb((unsigned short)235, (unsigned char)0);
#line 146
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 151
    return (((i << 8) + (int )dat) & 65535);
  } else {
#line 153
    return (-1);
  }
}
}
#line 156 "/home/wheatley/newnew/temp/xmbmon-2.05/smbus_amd8.c"
static int writebyte___2(int smb_base___0 , int addr , int cmd , int value ) 
{ 
  u_char dat ;
  u_char saddr ;
  int i ;

  {
#line 158
  dat = (u_char )0;
#line 158
  saddr = (u_char )(2 * (addr / 2) + 1);
  top: 
  {
#line 162
  my_outb((u_short )(smb_base___0 + 2), saddr);
#line 162
  my_outb((unsigned short)235, (unsigned char)0);
#line 162
  my_outb((unsigned short)235, (unsigned char)0);
#line 163
  my_outb((u_short )(smb_base___0 + 3), (u_char )cmd);
#line 163
  my_outb((unsigned short)235, (unsigned char)0);
#line 163
  my_outb((unsigned short)235, (unsigned char)0);
#line 164
  my_outb((u_short )(smb_base___0 + 4), (u_char )value);
#line 164
  my_outb((unsigned short)235, (unsigned char)0);
#line 164
  my_outb((unsigned short)235, (unsigned char)0);
#line 165
  my_outb((u_short )smb_base___0, (unsigned char)6);
#line 165
  my_outb((unsigned short)235, (unsigned char)0);
#line 165
  my_outb((unsigned short)235, (unsigned char)0);
#line 167
  i = 0;
  }
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! (i < 32)) {
#line 167
      goto while_break;
    }
    {
#line 168
    my_outb((unsigned short)235, (unsigned char)0);
#line 167
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  i = 0;
  {
#line 170
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 170
    if (! (i < 8192)) {
#line 170
      goto while_break___0;
    }
    {
#line 171
    dat = my_inb((u_short )(smb_base___0 + 1));
#line 171
    my_outb((unsigned short)235, (unsigned char)0);
#line 171
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 175
    if ((int )dat == 26) {
#line 176
      goto top;
    } else
#line 175
    if ((int )dat == 24) {
#line 176
      goto top;
    }
#line 177
    if ((int )dat & 159) {
#line 178
      goto while_break___0;
    }
#line 170
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 186
  if ((int )dat == 128) {
#line 187
    return (0);
  } else {
#line 189
    return (-1);
  }
}
}
#line 192 "/home/wheatley/newnew/temp/xmbmon-2.05/smbus_amd8.c"
static int writeword___1(int smb_base___0 , int addr , int cmd , int value ) 
{ 
  u_char dat ;
  u_char saddr ;
  int i ;

  {
#line 194
  dat = (u_char )0;
#line 194
  saddr = (u_char )(2 * (addr / 2) + 1);
  top: 
  {
#line 198
  my_outb((u_short )(smb_base___0 + 2), saddr);
#line 198
  my_outb((unsigned short)235, (unsigned char)0);
#line 198
  my_outb((unsigned short)235, (unsigned char)0);
#line 199
  my_outb((u_short )(smb_base___0 + 3), (u_char )cmd);
#line 199
  my_outb((unsigned short)235, (unsigned char)0);
#line 199
  my_outb((unsigned short)235, (unsigned char)0);
#line 200
  my_outb((u_short )(smb_base___0 + 4), (u_char )(value & 255));
#line 200
  my_outb((unsigned short)235, (unsigned char)0);
#line 200
  my_outb((unsigned short)235, (unsigned char)0);
#line 201
  my_outb((u_short )(smb_base___0 + 5), (u_char )(value >> 8));
#line 201
  my_outb((unsigned short)235, (unsigned char)0);
#line 201
  my_outb((unsigned short)235, (unsigned char)0);
#line 202
  my_outb((u_short )smb_base___0, (unsigned char)8);
#line 202
  my_outb((unsigned short)235, (unsigned char)0);
#line 202
  my_outb((unsigned short)235, (unsigned char)0);
#line 204
  i = 0;
  }
  {
#line 204
  while (1) {
    while_continue: /* CIL Label */ ;
#line 204
    if (! (i < 32)) {
#line 204
      goto while_break;
    }
    {
#line 205
    my_outb((unsigned short)235, (unsigned char)0);
#line 204
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 207
  i = 0;
  {
#line 207
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 207
    if (! (i < 8192)) {
#line 207
      goto while_break___0;
    }
    {
#line 208
    dat = my_inb((u_short )(smb_base___0 + 1));
#line 208
    my_outb((unsigned short)235, (unsigned char)0);
#line 208
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 209
    if ((int )dat == 26) {
#line 210
      goto top;
    } else
#line 209
    if ((int )dat == 24) {
#line 210
      goto top;
    }
#line 211
    if ((int )dat & 159) {
#line 212
      goto while_break___0;
    }
#line 207
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 220
  if ((int )dat == 128) {
#line 221
    return (0);
  } else {
#line 223
    return (-1);
  }
}
}
#line 226 "/home/wheatley/newnew/temp/xmbmon-2.05/smbus_amd8.c"
struct smbus_io smbus_amd8  =    {& readbyte___2, & readword___1, & writebyte___2, & writeword___1};
#line 46 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_it87.c"
static int it87_probe(LM_METHODS *method___1 ) ;
#line 47
static float it87_temp(LM_METHODS *method___1 , int no ) ;
#line 48
static int it87_fanrpm(LM_METHODS *method___1 , int no ) ;
#line 49
static float it87_volt(LM_METHODS *method___1 , int no ) ;
#line 51 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_it87.c"
SENSOR it87  =    {(char *)"Int.Tec.Exp. Chip IT8705F/IT8712F or SIS950", & it87_probe, & it87_temp,
    & it87_volt, & it87_fanrpm};
#line 63 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_it87.c"
static int chkReg___6[25]  = 
#line 63
  {      0,      1,      2,      3, 
        10,      72,      80,      81, 
        32,      33,      34,      35, 
        36,      37,      38,      39, 
        40,      41,      42,      43, 
        11,      13,      14,      15, 
        -1};
#line 76 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_it87.c"
static int it87_probe(LM_METHODS *method___1 ) 
{ 
  int n ;
  int save ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 80
  if ((unsigned long )method___1 != (unsigned long )(& method_isa)) {
#line 80
    if ((unsigned long )method___1 != (unsigned long )(& method_smb)) {
#line 81
      return (0);
    }
  }
#line 83
  save = smb_slave;
#line 85
  if ((unsigned long )method___1 == (unsigned long )(& method_smb)) {
#line 86
    n = 80;
    {
#line 86
    while (1) {
      while_continue: /* CIL Label */ ;
#line 86
      if (! (n <= 94)) {
#line 86
        goto while_break;
      }
      {
#line 87
      smb_slave = get_smb_slave(n, 94);
      }
#line 87
      if (smb_slave) {
        {
#line 89
        tmp___1 = (*(method___1->Read))(72);
        }
#line 89
        if (smb_slave != 2 * tmp___1) {
#line 90
          goto ret0;
        } else {
          {
#line 92
          tmp = (*(method___1->Read))(88);
          }
#line 92
          if (tmp == 144) {
            {
#line 92
            tmp___0 = chkReg_Probe(smb_slave, (char *)"Probing ITE7805/7812/SIS950 chip:\n",
                                   chkReg___6, method___1);
            }
#line 92
            if (tmp___0 >= 8) {
#line 96
              goto ret1;
            } else {
#line 98
              n = smb_slave + 2;
            }
          } else {
#line 98
            n = smb_slave + 2;
          }
        }
      } else {
#line 88
        goto ret0;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 101
    goto ret0;
  } else {
    {
#line 103
    tmp___2 = (*(method___1->Read))(88);
    }
#line 103
    if (tmp___2 == 144) {
      {
#line 103
      tmp___3 = chkReg_Probe(0, (char *)"Probing ITE7805/7812/SIS950 chip:\n", chkReg___6,
                             method___1);
      }
#line 103
      if (tmp___3 >= 8) {
#line 106
        goto ret1;
      }
    }
  }
  ret0: 
#line 110
  smb_slave = save;
#line 111
  return (0);
  ret1: 
#line 113
  if ((unsigned long )method___1 == (unsigned long )(& method_smb)) {
    {
#line 114
    kill_smb_slave(smb_slave);
    }
  }
#line 115
  return (1);
}
}
#line 124 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_it87.c"
static float it87_temp(LM_METHODS *method___1 , int no ) 
{ 
  int tmp ;

  {
#line 126
  if (no < 0) {
#line 127
    return ((float )65535);
  } else
#line 126
  if (2 < no) {
#line 127
    return ((float )65535);
  }
  {
#line 129
  tmp = (*(method___1->Read))(41 + no);
  }
#line 129
  return ((float )tmp);
}
}
#line 137 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_it87.c"
static float it87_volt(LM_METHODS *method___1 , int no ) 
{ 
  float fac ;
  int tmp ;

  {
#line 141
  if (no < 0) {
#line 142
    return ((float )65535);
  } else
#line 141
  if (6 < no) {
#line 142
    return ((float )65535);
  }
  {
#line 147
  if (no == 2) {
#line 147
    goto case_2;
  }
#line 147
  if (no == 1) {
#line 147
    goto case_2;
  }
#line 147
  if (no == 0) {
#line 147
    goto case_2;
  }
#line 150
  if (no == 3) {
#line 150
    goto case_3;
  }
#line 153
  if (no == 4) {
#line 153
    goto case_4;
  }
#line 156
  if (no == 5) {
#line 156
    goto case_5;
  }
#line 159
  if (no == 6) {
#line 159
    goto case_6;
  }
#line 144
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 148
  fac = (float )0.016;
#line 149
  goto switch_break;
  case_3: /* CIL Label */ 
#line 151
  fac = (float )(0.016 * 1.68);
#line 152
  goto switch_break;
  case_4: /* CIL Label */ 
#line 154
  fac = (float )(0.016 * 3.80);
#line 155
  goto switch_break;
  case_5: /* CIL Label */ 
#line 157
  fac = (float )(- 0.016 * 3.477);
#line 158
  goto switch_break;
  case_6: /* CIL Label */ 
#line 160
  fac = (float )(- 0.016 * 1.505);
  switch_break: /* CIL Label */ ;
  }
  {
#line 163
  tmp = (*(method___1->Read))(32 + no);
  }
#line 163
  return ((float )tmp * fac);
}
}
#line 189 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_it87.c"
static int div___4[3]  = {      1,      1,      1};
#line 186 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_it87.c"
static int it87_fanrpm(LM_METHODS *method___1 , int no ) 
{ 
  int r ;
  int n ;

  {
#line 191
  if (no < 0) {
#line 192
    return (65535);
  } else
#line 191
  if (2 < no) {
#line 192
    return (65535);
  }
  {
#line 194
  n = (*(method___1->Read))(11);
#line 195
  div___4[0] = n & 7;
#line 196
  div___4[1] = (n >> 3) & 7;
#line 198
  r = (*(method___1->Read))(13 + no);
  }
#line 199
  if (r == 255) {
#line 201
    if (no != 2) {
#line 202
      if (div___4[no] < 7) {
#line 203
        (div___4[no]) ++;
      } else {
#line 205
        div___4[no] = 0;
      }
      {
#line 206
      r = ((n & 63) | div___4[0]) | (div___4[1] << 3);
#line 207
      (*(method___1->Write))(11, r);
      }
    }
#line 209
    return (65535);
  } else
#line 210
  if (r == 0) {
#line 211
    return (65535);
  }
#line 214
  return (1350000 / (r * (1 << div___4[no])));
}
}
#line 22 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-smb.c"
int smb_base  =    -1;
#line 23 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-smb.c"
int smb_slave  =    90;
#line 24 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-smb.c"
int smb_wbtemp1_flag  =    1;
#line 25 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-smb.c"
int smb_wbtemp2_flag  =    1;
#line 26 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-smb.c"
int smb_wbtemp1  =    146;
#line 27 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-smb.c"
int smb_wbtemp2  =    144;
#line 28 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-smb.c"
int smb_wbt1reg  =    0;
#line 29 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-smb.c"
int smb_wbt2reg  =    0;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 846 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 5 "/home/wheatley/newnew/temp/xmbmon-2.05/io_static.c"
static int OpenIO___3(void) 
{ 
  int tmp ;

  {
#line 7
  if (iopl_counter == 0) {
    {
#line 8
    tmp = iopl(3);
    }
#line 8
    if (tmp < 0) {
#line 9
      return (-1);
    }
  }
#line 11
  iopl_counter ++;
#line 12
  return (0);
}
}
#line 15 "/home/wheatley/newnew/temp/xmbmon-2.05/io_static.c"
static void CloseIO___3(void) 
{ 


  {
#line 17
  if (iopl_counter == 1) {
    {
#line 18
    iopl(0);
    }
  }
#line 19
  if (iopl_counter > 0) {
#line 20
    iopl_counter --;
  }
#line 21
  return;
}
}
#line 40 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-smb.c"
static int ReadByte___1(int addr ) 
{ 
  int ret ;

  {
  {
#line 43
  ret = (*(smbus->ReadB))(smb_base, smb_slave, addr);
  }
#line 44
  if (ret == -1) {
#line 47
    ret = 255;
  }
#line 49
  return (ret & 255);
}
}
#line 52 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-smb.c"
static void WriteByte___1(int addr , int value ) 
{ 
  int tmp ;

  {
  {
#line 54
  tmp = (*(smbus->WriteB))(smb_base, smb_slave, addr, value);
  }
#line 54
  if (tmp == -1) {
    {
#line 55
    perror("SMBus WriteB");
#line 56
    exit(-1);
    }
  }
#line 58
  return;
}
}
#line 60 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-smb.c"
static int ReadWord___1(int addr ) 
{ 
  int ret ;

  {
  {
#line 63
  ret = (*(smbus->ReadW))(smb_base, smb_slave, addr);
  }
#line 64
  if (ret == -1) {
#line 67
    ret = 65535;
  }
#line 69
  return (ret & 65535);
}
}
#line 72 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-smb.c"
static void WriteWord___1(int addr , int value ) 
{ 
  int tmp ;

  {
  {
#line 74
  tmp = (*(smbus->WriteW))(smb_base, smb_slave, addr, value);
  }
#line 74
  if (tmp == -1) {
    {
#line 75
    perror("SMBus WriteW");
#line 76
    exit(-1);
    }
  }
#line 78
  return;
}
}
#line 80 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-smb.c"
static int ReadTemp1___1(void) 
{ 
  int ret ;

  {
  {
#line 83
  ret = (*(smbus->ReadW))(smb_base, smb_wbtemp1, smb_wbt1reg);
  }
#line 84
  if (ret == -1) {
#line 87
    ret = 65535;
  }
#line 89
  return (ret & 65535);
}
}
#line 91 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-smb.c"
static int ReadTemp2___1(void) 
{ 
  int ret ;

  {
  {
#line 94
  ret = (*(smbus->ReadW))(smb_base, smb_wbtemp2, smb_wbt2reg);
  }
#line 95
  if (ret == -1) {
#line 98
    ret = 65535;
  }
#line 100
  return (ret & 65535);
}
}
#line 103 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-smb.c"
struct lm_methods method_smb  = 
#line 103
     {& OpenIO___3, & CloseIO___3, & ReadByte___1, & WriteByte___1, & ReadWord___1,
    & WriteWord___1, & ReadTemp1___1, & ReadTemp2___1};
#line 72 "/home/wheatley/newnew/temp/xmbmon-2.05/smbus_ali.c"
static int readbyte___3(int smb_base___0 , int addr , int cmd ) 
{ 
  u_char dat ;
  u_char saddr ;
  int i ;

  {
#line 74
  saddr = (u_char )(2 * (addr / 2));
  top: 
#line 78
  i = 0;
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! (i < 8192)) {
#line 78
      goto while_break;
    }
    {
#line 79
    my_outb((u_short )smb_base___0, (unsigned char)255);
#line 79
    my_outb((unsigned short)235, (unsigned char)0);
#line 79
    my_outb((unsigned short)235, (unsigned char)0);
#line 80
    dat = my_inb((u_short )smb_base___0);
#line 80
    my_outb((unsigned short)235, (unsigned char)0);
#line 80
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 81
    if ((int )dat & 4) {
#line 82
      goto step;
    }
#line 78
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 84
  my_outb((u_short )(smb_base___0 + 1), (unsigned char)12);
#line 84
  my_outb((unsigned short)235, (unsigned char)0);
#line 84
  my_outb((unsigned short)235, (unsigned char)0);
  }
  step: 
  {
#line 87
  my_outb((u_short )(smb_base___0 + 3), (unsigned char )((int )saddr | 1));
#line 87
  my_outb((unsigned short)235, (unsigned char)0);
#line 87
  my_outb((unsigned short)235, (unsigned char)0);
#line 88
  my_outb((u_short )(smb_base___0 + 7), (u_char )cmd);
#line 88
  my_outb((unsigned short)235, (unsigned char)0);
#line 88
  my_outb((unsigned short)235, (unsigned char)0);
#line 89
  my_outb((u_short )(smb_base___0 + 1), (unsigned char)32);
#line 89
  my_outb((unsigned short)235, (unsigned char)0);
#line 89
  my_outb((unsigned short)235, (unsigned char)0);
#line 90
  my_outb((u_short )(smb_base___0 + 2), (unsigned char)255);
#line 90
  my_outb((unsigned short)235, (unsigned char)0);
#line 90
  my_outb((unsigned short)235, (unsigned char)0);
#line 92
  i = 0;
  }
  {
#line 92
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 92
    if (! (i < 8192)) {
#line 92
      goto while_break___0;
    }
    {
#line 93
    dat = my_inb((u_short )smb_base___0);
#line 93
    my_outb((unsigned short)235, (unsigned char)0);
#line 93
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 94
    if (! ((int )dat & 8)) {
#line 95
      goto while_break___0;
    }
#line 92
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 101
  if ((int )dat == 0) {
    {
#line 102
    my_outb((u_short )(smb_base___0 + 1), (unsigned char)12);
#line 102
    my_outb((unsigned short)235, (unsigned char)0);
#line 102
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 107
    goto top;
  } else
#line 108
  if ((int )dat & 16) {
    {
#line 109
    dat = my_inb((u_short )(smb_base___0 + 4));
#line 109
    my_outb((unsigned short)235, (unsigned char)0);
#line 109
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 110
    return ((int )dat & 255);
  } else {
#line 112
    return (-1);
  }
}
}
#line 115 "/home/wheatley/newnew/temp/xmbmon-2.05/smbus_ali.c"
static int readword___2(int smb_base___0 , int addr , int cmd ) 
{ 
  u_char dat ;
  u_char saddr ;
  int i ;
  unsigned char tmp ;

  {
#line 117
  saddr = (u_char )(2 * (addr / 2));
  top: 
#line 121
  i = 0;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! (i < 8192)) {
#line 121
      goto while_break;
    }
    {
#line 122
    my_outb((u_short )smb_base___0, (unsigned char)255);
#line 122
    my_outb((unsigned short)235, (unsigned char)0);
#line 122
    my_outb((unsigned short)235, (unsigned char)0);
#line 123
    dat = my_inb((u_short )smb_base___0);
#line 123
    my_outb((unsigned short)235, (unsigned char)0);
#line 123
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 124
    if ((int )dat & 4) {
#line 125
      goto step;
    }
#line 121
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 127
  my_outb((u_short )(smb_base___0 + 1), (unsigned char)12);
#line 127
  my_outb((unsigned short)235, (unsigned char)0);
#line 127
  my_outb((unsigned short)235, (unsigned char)0);
  }
  step: 
  {
#line 130
  my_outb((u_short )(smb_base___0 + 3), (unsigned char )((int )saddr | 1));
#line 130
  my_outb((unsigned short)235, (unsigned char)0);
#line 130
  my_outb((unsigned short)235, (unsigned char)0);
#line 131
  my_outb((u_short )(smb_base___0 + 7), (u_char )cmd);
#line 131
  my_outb((unsigned short)235, (unsigned char)0);
#line 131
  my_outb((unsigned short)235, (unsigned char)0);
#line 132
  my_outb((u_short )(smb_base___0 + 1), (unsigned char)48);
#line 132
  my_outb((unsigned short)235, (unsigned char)0);
#line 132
  my_outb((unsigned short)235, (unsigned char)0);
#line 133
  my_outb((u_short )(smb_base___0 + 2), (unsigned char)255);
#line 133
  my_outb((unsigned short)235, (unsigned char)0);
#line 133
  my_outb((unsigned short)235, (unsigned char)0);
#line 135
  i = 0;
  }
  {
#line 135
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 135
    if (! (i < 8192)) {
#line 135
      goto while_break___0;
    }
    {
#line 136
    dat = my_inb((u_short )smb_base___0);
#line 136
    my_outb((unsigned short)235, (unsigned char)0);
#line 136
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 137
    if (! ((int )dat & 8)) {
#line 138
      goto while_break___0;
    }
#line 135
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 140
  if ((int )dat == 0) {
    {
#line 141
    my_outb((u_short )(smb_base___0 + 1), (unsigned char)12);
#line 141
    my_outb((unsigned short)235, (unsigned char)0);
#line 141
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 142
    goto top;
  } else
#line 143
  if ((int )dat & 16) {
    {
#line 144
    tmp = my_inb((u_short )(smb_base___0 + 5));
#line 144
    i = (int )tmp;
#line 144
    my_outb((unsigned short)235, (unsigned char)0);
#line 144
    my_outb((unsigned short)235, (unsigned char)0);
#line 145
    dat = my_inb((u_short )(smb_base___0 + 4));
#line 145
    my_outb((unsigned short)235, (unsigned char)0);
#line 145
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 146
    return (((i << 8) + (int )dat) & 65535);
  } else {
#line 148
    return (-1);
  }
}
}
#line 151 "/home/wheatley/newnew/temp/xmbmon-2.05/smbus_ali.c"
static int writebyte___3(int smb_base___0 , int addr , int cmd , int value ) 
{ 
  u_char dat ;
  u_char saddr ;
  int i ;

  {
#line 153
  saddr = (u_char )(2 * (addr / 2));
#line 156
  i = 0;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! (i < 8192)) {
#line 156
      goto while_break;
    }
    {
#line 157
    my_outb((u_short )smb_base___0, (unsigned char)255);
#line 157
    my_outb((unsigned short)235, (unsigned char)0);
#line 157
    my_outb((unsigned short)235, (unsigned char)0);
#line 158
    dat = my_inb((u_short )smb_base___0);
#line 158
    my_outb((unsigned short)235, (unsigned char)0);
#line 158
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 159
    if ((int )dat & 4) {
#line 160
      goto step;
    }
#line 156
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 162
  my_outb((u_short )(smb_base___0 + 1), (unsigned char)12);
#line 162
  my_outb((unsigned short)235, (unsigned char)0);
#line 162
  my_outb((unsigned short)235, (unsigned char)0);
  }
  step: 
  {
#line 165
  my_outb((u_short )(smb_base___0 + 3), saddr);
#line 165
  my_outb((unsigned short)235, (unsigned char)0);
#line 165
  my_outb((unsigned short)235, (unsigned char)0);
#line 166
  my_outb((u_short )(smb_base___0 + 7), (u_char )cmd);
#line 166
  my_outb((unsigned short)235, (unsigned char)0);
#line 166
  my_outb((unsigned short)235, (unsigned char)0);
#line 167
  my_outb((u_short )(smb_base___0 + 4), (u_char )value);
#line 167
  my_outb((unsigned short)235, (unsigned char)0);
#line 167
  my_outb((unsigned short)235, (unsigned char)0);
#line 168
  my_outb((u_short )(smb_base___0 + 1), (unsigned char)32);
#line 168
  my_outb((unsigned short)235, (unsigned char)0);
#line 168
  my_outb((unsigned short)235, (unsigned char)0);
#line 169
  my_outb((u_short )(smb_base___0 + 2), (unsigned char)255);
#line 169
  my_outb((unsigned short)235, (unsigned char)0);
#line 169
  my_outb((unsigned short)235, (unsigned char)0);
#line 171
  i = 0;
  }
  {
#line 171
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 171
    if (! (i < 8192)) {
#line 171
      goto while_break___0;
    }
    {
#line 172
    dat = my_inb((u_short )smb_base___0);
#line 172
    my_outb((unsigned short)235, (unsigned char)0);
#line 172
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 173
    if (! ((int )dat & 8)) {
#line 174
      goto while_break___0;
    }
#line 171
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 176
  if ((int )dat & 16) {
#line 177
    return (0);
  } else {
#line 179
    return (-1);
  }
}
}
#line 182 "/home/wheatley/newnew/temp/xmbmon-2.05/smbus_ali.c"
static int writeword___2(int smb_base___0 , int addr , int cmd , int value ) 
{ 
  u_char dat ;
  u_char saddr ;
  int i ;

  {
#line 184
  saddr = (u_char )(2 * (addr / 2));
#line 187
  i = 0;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! (i < 8192)) {
#line 187
      goto while_break;
    }
    {
#line 188
    my_outb((u_short )smb_base___0, (unsigned char)255);
#line 188
    my_outb((unsigned short)235, (unsigned char)0);
#line 188
    my_outb((unsigned short)235, (unsigned char)0);
#line 189
    dat = my_inb((u_short )smb_base___0);
#line 189
    my_outb((unsigned short)235, (unsigned char)0);
#line 189
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 190
    if ((int )dat & 4) {
#line 191
      goto step;
    }
#line 187
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 193
  my_outb((u_short )(smb_base___0 + 1), (unsigned char)12);
#line 193
  my_outb((unsigned short)235, (unsigned char)0);
#line 193
  my_outb((unsigned short)235, (unsigned char)0);
  }
  step: 
  {
#line 196
  my_outb((u_short )(smb_base___0 + 3), saddr);
#line 196
  my_outb((unsigned short)235, (unsigned char)0);
#line 196
  my_outb((unsigned short)235, (unsigned char)0);
#line 197
  my_outb((u_short )(smb_base___0 + 7), (u_char )cmd);
#line 197
  my_outb((unsigned short)235, (unsigned char)0);
#line 197
  my_outb((unsigned short)235, (unsigned char)0);
#line 198
  my_outb((u_short )(smb_base___0 + 4), (u_char )(value & 255));
#line 198
  my_outb((unsigned short)235, (unsigned char)0);
#line 198
  my_outb((unsigned short)235, (unsigned char)0);
#line 199
  my_outb((u_short )(smb_base___0 + 5), (u_char )(value >> 8));
#line 199
  my_outb((unsigned short)235, (unsigned char)0);
#line 199
  my_outb((unsigned short)235, (unsigned char)0);
#line 200
  my_outb((u_short )(smb_base___0 + 1), (unsigned char)48);
#line 200
  my_outb((unsigned short)235, (unsigned char)0);
#line 200
  my_outb((unsigned short)235, (unsigned char)0);
#line 201
  my_outb((u_short )(smb_base___0 + 2), (unsigned char)255);
#line 201
  my_outb((unsigned short)235, (unsigned char)0);
#line 201
  my_outb((unsigned short)235, (unsigned char)0);
#line 203
  i = 0;
  }
  {
#line 203
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 203
    if (! (i < 8192)) {
#line 203
      goto while_break___0;
    }
    {
#line 204
    dat = my_inb((u_short )smb_base___0);
#line 204
    my_outb((unsigned short)235, (unsigned char)0);
#line 204
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 205
    if (! ((int )dat & 8)) {
#line 206
      goto while_break___0;
    }
#line 203
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 208
  if ((int )dat & 16) {
#line 209
    return (0);
  } else {
#line 211
    return (-1);
  }
}
}
#line 214 "/home/wheatley/newnew/temp/xmbmon-2.05/smbus_ali.c"
struct smbus_io smbus_ali  =    {& readbyte___3, & readword___2, & writebyte___3, & writeword___2};
#line 56 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm80.c"
static int lm80_probe___0(LM_METHODS *method___1 ) ;
#line 57
static float lm80_temp___0(LM_METHODS *method___1 , int no ) ;
#line 58
static int lm80_fanrpm___0(LM_METHODS *method___1 , int no ) ;
#line 59
static float lm80_volt___0(LM_METHODS *method___1 , int no ) ;
#line 77 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm80.c"
static int chkReg___7[27]  = 
#line 77
  {      0,      1,      2,      4, 
        5,      6,      32,      33, 
        34,      36,      37,      38, 
        39,      40,      41,      43, 
        45,      47,      49,      51, 
        53,      55,      57,      59, 
        60,      61,      -1};
#line 91 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm80.c"
static int lm80_probe___0(LM_METHODS *method___1 ) 
{ 
  int n ;
  int dat ;
  int reg ;
  int save ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 95
  if ((unsigned long )method___1 != (unsigned long )(& method_smb)) {
#line 96
    return (0);
  }
#line 98
  save = smb_slave;
#line 100
  n = 80;
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! (n <= 94)) {
#line 100
      goto while_break;
    }
    {
#line 101
    smb_slave = get_smb_slave(n, 94);
    }
#line 101
    if (smb_slave) {
      {
#line 104
      tmp = (*(method___1->Read))(2);
      }
#line 104
      if (tmp & 192) {
#line 105
        n = smb_slave + 2;
#line 106
        goto __Cont;
      }
#line 108
      reg = 42;
      {
#line 108
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 108
        if (! (reg <= 61)) {
#line 108
          goto while_break___0;
        }
        {
#line 109
        dat = (*(method___1->Read))(reg);
#line 110
        tmp___0 = (*(method___1->Read))(reg + 64);
        }
#line 110
        if (tmp___0 != dat) {
#line 113
          goto while_break___0;
        } else {
          {
#line 110
          tmp___1 = (*(method___1->Read))(reg + 128);
          }
#line 110
          if (tmp___1 != dat) {
#line 113
            goto while_break___0;
          } else {
            {
#line 110
            tmp___2 = (*(method___1->Read))(reg + 192);
            }
#line 110
            if (tmp___2 != dat) {
#line 113
              goto while_break___0;
            }
          }
        }
#line 108
        reg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 115
      if (reg > 61) {
        {
#line 115
        tmp___3 = chkReg_Probe(smb_slave, (char *)"Probing LM80 chip:\n", chkReg___7,
                               method___1);
        }
#line 115
        if (tmp___3 >= 20) {
#line 118
          goto ret1;
        } else {
#line 120
          n = smb_slave + 2;
        }
      } else {
#line 120
        n = smb_slave + 2;
      }
    } else {
#line 102
      goto ret0;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  ret0: 
#line 125
  smb_slave = save;
#line 126
  return (0);
  ret1: 
  {
#line 128
  tmp___4 = (*(method___1->Read))(0);
  }
#line 128
  if ((tmp___4 & 1) == 0) {
    {
#line 129
    (*(method___1->Write))(0, 16);
#line 130
    (*(method___1->Write))(0, 1);
    }
  }
  {
#line 133
  tmp___5 = (*(method___1->Read))(5);
#line 133
  (*(method___1->Write))(5, (tmp___5 & 60) | 64);
#line 135
  (*(method___1->Write))(6, 10);
#line 142
  kill_smb_slave(smb_slave);
  }
#line 143
  return (1);
}
}
#line 152 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm80.c"
static float lm80_temp___0(LM_METHODS *method___1 , int no ) 
{ 
  int reg ;
  int val ;
  int sft ;
  float ret ;

  {
#line 157
  if (no != 0) {
#line 158
    return ((float )65535);
  }
  {
#line 160
  reg = (*(method___1->Read))(6);
#line 161
  val = (*(method___1->Read))(39);
#line 163
  sft = ((reg & 8) >> 3) * 3 + 1;
#line 165
  val <<= sft;
#line 166
  val |= reg >> (8 - sft);
#line 168
  ret = (float )val;
  }
#line 169
  if (reg & 8) {
#line 170
    ret = (float )((double )ret * 0.0625);
  } else {
#line 172
    ret = (float )((double )ret * 0.5);
  }
#line 174
  return (ret);
}
}
#line 183 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm80.c"
static float lm80_volt___0(LM_METHODS *method___1 , int no ) 
{ 
  float r1[7] ;
  float r2[7] ;
  float vout ;
  float val ;
  int tmp ;

  {
#line 185
  r1[0] = (float )23.7;
#line 185
  r1[1] = (float )23.7;
#line 185
  r1[2] = (float )22.1;
#line 185
  r1[3] = (float )24;
#line 185
  r1[4] = (float )160;
#line 185
  r1[5] = (float )27;
#line 185
  r1[6] = (float )180;
#line 186
  r2[0] = (float )75;
#line 186
  r2[1] = (float )75;
#line 186
  r2[2] = (float )30;
#line 186
  r2[3] = (float )14.7;
#line 186
  r2[4] = (float )30.1;
#line 186
  r2[5] = (float )3.4;
#line 186
  r2[6] = (float )42.2;
#line 189
  if (no < 0) {
#line 190
    return ((float )65535);
  } else
#line 189
  if (6 < no) {
#line 190
    return ((float )65535);
  }
  {
#line 192
  tmp = (*(method___1->Read))(32 + no);
#line 192
  vout = (float )tmp;
#line 193
  vout = (float )((double )vout * 0.01);
#line 199
  val = (vout * (r1[no] + r2[no])) / r2[no];
  }
#line 200
  if (no >= 5) {
#line 201
    val = (val - (float )5) * (float )-1;
  }
#line 206
  return (val);
}
}
#line 217 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm80.c"
static int lm80_fanrpm___0(LM_METHODS *method___1 , int no ) 
{ 
  int reg ;
  int val ;
  int div___11 ;
  int sft ;
  long rpm ;

  {
#line 226
  if (no < 0) {
#line 227
    return (65535);
  } else
#line 226
  if (1 < no) {
#line 227
    return (65535);
  }
  {
#line 229
  reg = (*(method___1->Read))(5);
#line 230
  val = (*(method___1->Read))(40 + no);
#line 234
  sft = (no + 1) * 2;
#line 235
  div___11 = (reg >> sft) & 3;
  }
#line 240
  if (val == 255) {
#line 241
    if (div___11 < 3) {
      {
#line 242
      reg += 1 << sft;
#line 243
      (*(method___1->Write))(5, reg);
      }
    }
#line 248
    return (65536);
  }
#line 254
  rpm = (long )(1350000 / (val * (1 << div___11)));
#line 255
  return ((int )rpm);
}
}
#line 69 "/home/wheatley/newnew/temp/xmbmon-2.05/smbus_amd.c"
static int readbyte___4(int smb_base___0 , int addr , int cmd ) 
{ 
  u_char saddr ;
  u_short dat ;
  int i ;

  {
#line 71
  saddr = (u_char )(2 * (addr / 2));
  top: 
  {
#line 76
  my_outw((u_short )smb_base___0, (unsigned short)55);
#line 76
  my_outb((unsigned short)235, (unsigned char)0);
#line 76
  my_outb((unsigned short)235, (unsigned char)0);
#line 77
  i = 0;
  }
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (i < 8192)) {
#line 77
      goto while_break;
    }
    {
#line 78
    dat = my_inw((u_short )smb_base___0);
#line 78
    my_outb((unsigned short)235, (unsigned char)0);
#line 78
    my_outb((unsigned short)235, (unsigned char)0);
#line 79
    my_outw((u_short )smb_base___0, dat);
#line 79
    my_outb((unsigned short)235, (unsigned char)0);
#line 79
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 80
    if (! ((int )dat & 10)) {
#line 81
      goto step;
    }
#line 82
    if (! ((int )dat & 8)) {
#line 83
      goto while_break;
    }
#line 77
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 85
  my_outw((u_short )(smb_base___0 + 2), (unsigned short)32);
#line 85
  my_outb((unsigned short)235, (unsigned char)0);
#line 85
  my_outb((unsigned short)235, (unsigned char)0);
  }
  step: 
  {
#line 88
  my_outw((u_short )(smb_base___0 + 4), (unsigned short )((int )saddr | 1));
#line 88
  my_outb((unsigned short)235, (unsigned char)0);
#line 88
  my_outb((unsigned short)235, (unsigned char)0);
#line 89
  my_outb((u_short )(smb_base___0 + 8), (u_char )cmd);
#line 89
  my_outb((unsigned short)235, (unsigned char)0);
#line 89
  my_outb((unsigned short)235, (unsigned char)0);
#line 90
  my_outw((u_short )(smb_base___0 + 2), (unsigned short)10);
#line 91
  my_outb((unsigned short)235, (unsigned char)0);
#line 91
  my_outb((unsigned short)235, (unsigned char)0);
#line 93
  i = 0;
  }
  {
#line 93
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 93
    if (! (i < 8192)) {
#line 93
      goto while_break___0;
    }
    {
#line 94
    dat = my_inw((u_short )smb_base___0);
#line 94
    my_outb((unsigned short)235, (unsigned char)0);
#line 94
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 95
    if ((int )dat & 2) {
#line 100
      goto top;
    }
#line 102
    if (! ((int )dat & 8)) {
#line 102
      if ((int )dat & 20) {
#line 103
        goto while_break___0;
      }
    }
#line 93
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 109
  if ((int )dat & 16) {
    {
#line 110
    dat = my_inw((u_short )(smb_base___0 + 6));
#line 110
    my_outb((unsigned short)235, (unsigned char)0);
#line 110
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 111
    return ((int )dat & 255);
  } else {
#line 113
    return (-1);
  }
}
}
#line 116 "/home/wheatley/newnew/temp/xmbmon-2.05/smbus_amd.c"
static int readword___3(int smb_base___0 , int addr , int cmd ) 
{ 
  u_char saddr ;
  u_short dat ;
  int i ;

  {
#line 118
  saddr = (u_char )(2 * (addr / 2));
  top: 
  {
#line 123
  my_outw((u_short )smb_base___0, (unsigned short)55);
#line 123
  my_outb((unsigned short)235, (unsigned char)0);
#line 123
  my_outb((unsigned short)235, (unsigned char)0);
#line 124
  i = 0;
  }
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (i < 8192)) {
#line 124
      goto while_break;
    }
    {
#line 125
    dat = my_inw((u_short )smb_base___0);
#line 125
    my_outb((unsigned short)235, (unsigned char)0);
#line 125
    my_outb((unsigned short)235, (unsigned char)0);
#line 126
    my_outw((u_short )smb_base___0, dat);
#line 126
    my_outb((unsigned short)235, (unsigned char)0);
#line 126
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 127
    if (! ((int )dat & 10)) {
#line 128
      goto step;
    }
#line 129
    if (! ((int )dat & 8)) {
#line 130
      goto while_break;
    }
#line 124
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 132
  my_outw((u_short )(smb_base___0 + 2), (unsigned short)32);
#line 132
  my_outb((unsigned short)235, (unsigned char)0);
#line 132
  my_outb((unsigned short)235, (unsigned char)0);
  }
  step: 
  {
#line 135
  my_outw((u_short )(smb_base___0 + 4), (unsigned short )((int )saddr | 1));
#line 135
  my_outb((unsigned short)235, (unsigned char)0);
#line 135
  my_outb((unsigned short)235, (unsigned char)0);
#line 136
  my_outb((u_short )(smb_base___0 + 8), (u_char )cmd);
#line 136
  my_outb((unsigned short)235, (unsigned char)0);
#line 136
  my_outb((unsigned short)235, (unsigned char)0);
#line 137
  my_outw((u_short )(smb_base___0 + 2), (unsigned short)11);
#line 138
  my_outb((unsigned short)235, (unsigned char)0);
#line 138
  my_outb((unsigned short)235, (unsigned char)0);
#line 140
  i = 0;
  }
  {
#line 140
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 140
    if (! (i < 8192)) {
#line 140
      goto while_break___0;
    }
    {
#line 141
    dat = my_inw((u_short )smb_base___0);
#line 141
    my_outb((unsigned short)235, (unsigned char)0);
#line 141
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 142
    if ((int )dat & 2) {
#line 143
      goto top;
    }
#line 144
    if (! ((int )dat & 8)) {
#line 144
      if ((int )dat & 20) {
#line 145
        goto while_break___0;
      }
    }
#line 140
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 147
  if ((int )dat & 16) {
    {
#line 148
    dat = my_inw((u_short )(smb_base___0 + 6));
#line 148
    my_outb((unsigned short)235, (unsigned char)0);
#line 148
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 149
    return ((int )dat & 65535);
  } else {
#line 151
    return (-1);
  }
}
}
#line 154 "/home/wheatley/newnew/temp/xmbmon-2.05/smbus_amd.c"
static int writebyte___4(int smb_base___0 , int addr , int cmd , int value ) 
{ 
  u_char saddr ;
  u_short dat ;
  int i ;

  {
  {
#line 156
  saddr = (u_char )(2 * (addr / 2));
#line 160
  my_outw((u_short )smb_base___0, (unsigned short)55);
#line 160
  my_outb((unsigned short)235, (unsigned char)0);
#line 160
  my_outb((unsigned short)235, (unsigned char)0);
#line 161
  i = 0;
  }
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (! (i < 8192)) {
#line 161
      goto while_break;
    }
    {
#line 162
    dat = my_inw((u_short )smb_base___0);
#line 162
    my_outb((unsigned short)235, (unsigned char)0);
#line 162
    my_outb((unsigned short)235, (unsigned char)0);
#line 163
    my_outw((u_short )smb_base___0, dat);
#line 163
    my_outb((unsigned short)235, (unsigned char)0);
#line 163
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 164
    if (! ((int )dat & 10)) {
#line 165
      goto step;
    }
#line 166
    if (! ((int )dat & 8)) {
#line 167
      goto while_break;
    }
#line 161
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 169
  my_outw((u_short )(smb_base___0 + 2), (unsigned short)32);
#line 169
  my_outb((unsigned short)235, (unsigned char)0);
#line 169
  my_outb((unsigned short)235, (unsigned char)0);
  }
  step: 
  {
#line 172
  my_outw((u_short )(smb_base___0 + 4), (unsigned short )saddr);
#line 172
  my_outb((unsigned short)235, (unsigned char)0);
#line 172
  my_outb((unsigned short)235, (unsigned char)0);
#line 173
  my_outb((u_short )(smb_base___0 + 8), (u_char )cmd);
#line 173
  my_outb((unsigned short)235, (unsigned char)0);
#line 173
  my_outb((unsigned short)235, (unsigned char)0);
#line 174
  my_outw((u_short )(smb_base___0 + 6), (unsigned short )((u_char )value));
#line 174
  my_outb((unsigned short)235, (unsigned char)0);
#line 174
  my_outb((unsigned short)235, (unsigned char)0);
#line 175
  my_outw((u_short )(smb_base___0 + 2), (unsigned short)10);
#line 176
  my_outb((unsigned short)235, (unsigned char)0);
#line 176
  my_outb((unsigned short)235, (unsigned char)0);
#line 178
  i = 0;
  }
  {
#line 178
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 178
    if (! (i < 8192)) {
#line 178
      goto while_break___0;
    }
    {
#line 179
    dat = my_inw((u_short )smb_base___0);
#line 179
    my_outb((unsigned short)235, (unsigned char)0);
#line 179
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 180
    if (! ((int )dat & 8)) {
#line 180
      if ((int )dat & 20) {
#line 181
        goto while_break___0;
      }
    }
#line 178
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 183
  if ((int )dat & 16) {
#line 184
    return (0);
  } else {
#line 186
    return (-1);
  }
}
}
#line 189 "/home/wheatley/newnew/temp/xmbmon-2.05/smbus_amd.c"
static int writeword___3(int smb_base___0 , int addr , int cmd , int value ) 
{ 
  u_char saddr ;
  u_short dat ;
  int i ;

  {
  {
#line 191
  saddr = (u_char )(2 * (addr / 2));
#line 195
  my_outw((u_short )smb_base___0, (unsigned short)55);
#line 195
  my_outb((unsigned short)235, (unsigned char)0);
#line 195
  my_outb((unsigned short)235, (unsigned char)0);
#line 196
  i = 0;
  }
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    if (! (i < 8192)) {
#line 196
      goto while_break;
    }
    {
#line 197
    dat = my_inw((u_short )smb_base___0);
#line 197
    my_outb((unsigned short)235, (unsigned char)0);
#line 197
    my_outb((unsigned short)235, (unsigned char)0);
#line 198
    my_outw((u_short )smb_base___0, dat);
#line 198
    my_outb((unsigned short)235, (unsigned char)0);
#line 198
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 199
    if (! ((int )dat & 10)) {
#line 200
      goto step;
    }
#line 201
    if (! ((int )dat & 8)) {
#line 202
      goto while_break;
    }
#line 196
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 204
  my_outw((u_short )(smb_base___0 + 2), (unsigned short)32);
#line 204
  my_outb((unsigned short)235, (unsigned char)0);
#line 204
  my_outb((unsigned short)235, (unsigned char)0);
  }
  step: 
  {
#line 207
  my_outw((u_short )(smb_base___0 + 4), (unsigned short )saddr);
#line 207
  my_outb((unsigned short)235, (unsigned char)0);
#line 207
  my_outb((unsigned short)235, (unsigned char)0);
#line 208
  my_outb((u_short )(smb_base___0 + 8), (u_char )cmd);
#line 208
  my_outb((unsigned short)235, (unsigned char)0);
#line 208
  my_outb((unsigned short)235, (unsigned char)0);
#line 209
  my_outw((u_short )(smb_base___0 + 6), (u_short )value);
#line 209
  my_outb((unsigned short)235, (unsigned char)0);
#line 209
  my_outb((unsigned short)235, (unsigned char)0);
#line 210
  my_outw((u_short )(smb_base___0 + 2), (unsigned short)11);
#line 211
  my_outb((unsigned short)235, (unsigned char)0);
#line 211
  my_outb((unsigned short)235, (unsigned char)0);
#line 213
  i = 0;
  }
  {
#line 213
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 213
    if (! (i < 8192)) {
#line 213
      goto while_break___0;
    }
    {
#line 214
    dat = my_inw((u_short )smb_base___0);
#line 214
    my_outb((unsigned short)235, (unsigned char)0);
#line 214
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 215
    if (! ((int )dat & 8)) {
#line 215
      if ((int )dat & 20) {
#line 216
        goto while_break___0;
      }
    }
#line 213
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 218
  if ((int )dat & 16) {
#line 219
    return (0);
  } else {
#line 221
    return (-1);
  }
}
}
#line 5 "/home/wheatley/newnew/temp/xmbmon-2.05/io_static.c"
static int OpenIO___4(void) 
{ 
  int tmp ;

  {
#line 7
  if (iopl_counter == 0) {
    {
#line 8
    tmp = iopl(3);
    }
#line 8
    if (tmp < 0) {
#line 9
      return (-1);
    }
  }
#line 11
  iopl_counter ++;
#line 12
  return (0);
}
}
#line 15 "/home/wheatley/newnew/temp/xmbmon-2.05/io_static.c"
static void CloseIO___4(void) 
{ 


  {
#line 17
  if (iopl_counter == 1) {
    {
#line 18
    iopl(0);
    }
  }
#line 19
  if (iopl_counter > 0) {
#line 20
    iopl_counter --;
  }
#line 21
  return;
}
}
#line 20 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-via.c"
static int ReadByte___2(int addr ) 
{ 
  int ret ;
  unsigned char tmp ;

  {
  {
#line 23
  tmp = my_inb((unsigned short )(viahwm_base + addr));
#line 23
  ret = (int )tmp;
#line 23
  my_outb((unsigned short)235, (unsigned char)0);
  }
#line 24
  return (ret & 255);
}
}
#line 27 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-via.c"
static void WriteByte___2(int addr , int value ) 
{ 


  {
  {
#line 29
  my_outb((unsigned short )(viahwm_base + addr), (unsigned char )value);
#line 29
  my_outb((unsigned short)235, (unsigned char)0);
  }
#line 30
  return;
}
}
#line 32 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-via.c"
static int ReadWord___2(int addr ) 
{ 
  int ret ;
  unsigned short tmp ;

  {
  {
#line 35
  tmp = my_inw((unsigned short )(viahwm_base + addr));
#line 35
  ret = (int )tmp;
#line 35
  my_outb((unsigned short)235, (unsigned char)0);
  }
#line 36
  return (ret & 65535);
}
}
#line 39 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-via.c"
static void WriteWord___2(int addr , int value ) 
{ 


  {
  {
#line 41
  my_outw((unsigned short )(viahwm_base + addr), (unsigned short )value);
#line 41
  my_outb((unsigned short)235, (unsigned char)0);
  }
#line 42
  return;
}
}
#line 44 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-via.c"
static int ReadTemp1___2(void) 
{ 
  int tmp ;

  {
  {
#line 46
  tmp = ReadByte___2(viahwm_base + 33);
  }
#line 46
  return (tmp);
}
}
#line 49 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-via.c"
static int ReadTemp2___2(void) 
{ 
  int tmp ;

  {
  {
#line 51
  tmp = ReadByte___2(viahwm_base + 31);
  }
#line 51
  return (tmp);
}
}
#line 5 "/home/wheatley/newnew/temp/xmbmon-2.05/io_static.c"
static int OpenIO___5(void) 
{ 
  int tmp ;

  {
#line 7
  if (iopl_counter == 0) {
    {
#line 8
    tmp = iopl(3);
    }
#line 8
    if (tmp < 0) {
#line 9
      return (-1);
    }
  }
#line 11
  iopl_counter ++;
#line 12
  return (0);
}
}
#line 15 "/home/wheatley/newnew/temp/xmbmon-2.05/io_static.c"
static void CloseIO___5(void) 
{ 


  {
#line 17
  if (iopl_counter == 1) {
    {
#line 18
    iopl(0);
    }
  }
#line 19
  if (iopl_counter > 0) {
#line 20
    iopl_counter --;
  }
#line 21
  return;
}
}
#line 22 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-isa.c"
static int ReadByte___3(int addr ) 
{ 
  int ret ;
  unsigned char tmp ;

  {
  {
#line 25
  my_outb((unsigned short )(isa_port_base + 5), (unsigned char )addr);
#line 25
  my_outb((unsigned short)235, (unsigned char)0);
#line 26
  tmp = my_inb((unsigned short )(isa_port_base + 6));
#line 26
  ret = (int )tmp;
#line 26
  my_outb((unsigned short)235, (unsigned char)0);
  }
#line 27
  return (ret & 255);
}
}
#line 30 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-isa.c"
static void WriteByte___3(int addr , int value ) 
{ 


  {
  {
#line 32
  my_outb((unsigned short )(isa_port_base + 5), (unsigned char )addr);
#line 32
  my_outb((unsigned short)235, (unsigned char)0);
#line 33
  my_outb((unsigned short )(isa_port_base + 6), (unsigned char )value);
#line 33
  my_outb((unsigned short)235, (unsigned char)0);
  }
#line 34
  return;
}
}
#line 36 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-isa.c"
static int ReadWord___3(int addr ) 
{ 
  int ret ;
  unsigned short tmp ;

  {
  {
#line 39
  my_outb((unsigned short )(isa_port_base + 5), (unsigned char )addr);
#line 39
  my_outb((unsigned short)235, (unsigned char)0);
#line 40
  tmp = my_inw((unsigned short )(isa_port_base + 6));
#line 40
  ret = (int )tmp;
#line 40
  my_outb((unsigned short)235, (unsigned char)0);
  }
#line 41
  return (ret & 65535);
}
}
#line 44 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-isa.c"
static void WriteWord___3(int addr , int value ) 
{ 


  {
  {
#line 46
  my_outb((unsigned short )(isa_port_base + 5), (unsigned char )addr);
#line 46
  my_outb((unsigned short)235, (unsigned char)0);
#line 47
  my_outw((unsigned short )(isa_port_base + 6), (unsigned short )value);
#line 47
  my_outb((unsigned short)235, (unsigned char)0);
  }
#line 48
  return;
}
}
#line 50 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-isa.c"
static int ReadTemp1___3(void) 
{ 
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 53
  WriteByte___3(78, 1);
#line 54
  tmp = ReadByte___3(80);
#line 54
  tmp___0 = ReadByte___3(81);
#line 54
  ret = tmp | (tmp___0 << 8);
#line 55
  WriteByte___3(78, 0);
  }
#line 56
  return (ret);
}
}
#line 59 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-isa.c"
static int ReadTemp2___3(void) 
{ 
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 62
  WriteByte___3(78, 2);
#line 63
  tmp = ReadByte___3(80);
#line 63
  tmp___0 = ReadByte___3(81);
#line 63
  ret = tmp | (tmp___0 << 8);
#line 64
  WriteByte___3(78, 0);
  }
#line 65
  return (ret);
}
}
#line 72 "/home/wheatley/newnew/temp/xmbmon-2.05/sensors.c"
static int smb_scanReg___0[6]  = {      0,      1,      32,      64, 
        72,      -1};
#line 77 "/home/wheatley/newnew/temp/xmbmon-2.05/sensors.c"
static int blacklist___0[2]  = {      210,      -1};
#line 5 "/home/wheatley/newnew/temp/xmbmon-2.05/io_static.c"
static int OpenIO___6(void) 
{ 
  int tmp ;

  {
#line 7
  if (iopl_counter == 0) {
    {
#line 8
    tmp = iopl(3);
    }
#line 8
    if (tmp < 0) {
#line 9
      return (-1);
    }
  }
#line 11
  iopl_counter ++;
#line 12
  return (0);
}
}
#line 15 "/home/wheatley/newnew/temp/xmbmon-2.05/io_static.c"
static void CloseIO___6(void) 
{ 


  {
#line 17
  if (iopl_counter == 1) {
    {
#line 18
    iopl(0);
    }
  }
#line 19
  if (iopl_counter > 0) {
#line 20
    iopl_counter --;
  }
#line 21
  return;
}
}
#line 32 "/home/wheatley/newnew/temp/xmbmon-2.05/tyan_tiger.c"
static int readbyte___5(int addr ) 
{ 
  int ret ;
  unsigned char tmp ;

  {
  {
#line 35
  my_outb((unsigned short )(isa_port_base + 5), (unsigned char )addr);
#line 35
  my_outb((unsigned short)235, (unsigned char)0);
#line 36
  tmp = my_inb((unsigned short )(isa_port_base + 6));
#line 36
  ret = (int )tmp;
#line 36
  my_outb((unsigned short)235, (unsigned char)0);
  }
#line 37
  return (ret & 255);
}
}
#line 40 "/home/wheatley/newnew/temp/xmbmon-2.05/tyan_tiger.c"
static void writebyte___5(int addr , int value ) 
{ 


  {
  {
#line 42
  my_outb((unsigned short )(isa_port_base + 5), (unsigned char )addr);
#line 42
  my_outb((unsigned short)235, (unsigned char)0);
#line 43
  my_outb((unsigned short )(isa_port_base + 6), (unsigned char )value);
#line 43
  my_outb((unsigned short)235, (unsigned char)0);
  }
#line 44
  return;
}
}
#line 46 "/home/wheatley/newnew/temp/xmbmon-2.05/tyan_tiger.c"
static int vendercheck___0(void) 
{ 
  int nv ;
  int save ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 50
  ret = 0;
#line 51
  save = isa_port_base;
#line 52
  isa_port_base = 3072;
#line 53
  tmp = readbyte___5(79);
#line 53
  nv = tmp & 255;
  }
#line 54
  if (nv == 163) {
    {
#line 55
    writebyte___5(78, 128);
#line 56
    tmp___0 = readbyte___5(79);
#line 56
    nv = tmp___0 & 255;
    }
#line 57
    if (nv == 92) {
#line 58
      ret = 1;
    }
  }
#line 60
  isa_port_base = save;
#line 61
  return (ret);
}
}
#line 61 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm85.c"
static int lm85chipid___0  =    0;
#line 63 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm85.c"
static float Vfac___0  ;
#line 65
static int lm85_probe___0(LM_METHODS *method___1 ) ;
#line 66
static int lm85_chk___0(LM_METHODS *method___1 ) ;
#line 67
static float lm85_temp___0(LM_METHODS *method___1 , int no ) ;
#line 68
static int lm85_fanrpm___0(LM_METHODS *method___1 , int no ) ;
#line 69
static float lm85_volt___0(LM_METHODS *method___1 , int no ) ;
#line 76 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm85.c"
static char buff___4[128]  ;
#line 78 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm85.c"
static int adm_24fan___0[2]  = {      0,      0};
#line 99 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm85.c"
static char *lm85chip___0[8]  = 
#line 99
  {      (char *)"No Sensor",      (char *)"Nat.Semi.Con. Chip LM85",      (char *)"SMSC Chip EMC6D10X",      (char *)"Analog Dev. Chip ADM1024", 
        (char *)"Analog Dev. Chip ADM1025",      (char *)"Analog Dev. Chip ADM1027",      (char *)"Analog Dev. Chip ADT7463",      (char *)((void *)0)};
#line 113 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm85.c"
static int chkReg___8[45]  = 
#line 113
  {      32,      33,      34,      35, 
        36,      37,      38,      39, 
        40,      41,      42,      43, 
        44,      45,      46,      47, 
        48,      49,      50,      51, 
        52,      53,      54,      55, 
        56,      57,      58,      59, 
        60,      61,      62,      63, 
        64,      65,      66,      67, 
        112,      113,      114,      115, 
        118,      119,      120,      123, 
        -1};
#line 131 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm85.c"
static int lm85_probe___0(LM_METHODS *method___1 ) 
{ 
  int n ;
  int save ;
  int tmp ;
  int tmp___0 ;

  {
#line 135
  if ((unsigned long )method___1 != (unsigned long )(& method_smb)) {
#line 136
    return (0);
  }
#line 138
  save = smb_slave;
#line 140
  n = 88;
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! (n <= 92)) {
#line 140
      goto while_break;
    }
    {
#line 141
    smb_slave = get_smb_slave(n, 92);
    }
#line 141
    if (smb_slave) {
      {
#line 144
      tmp = lm85_chk___0(method___1);
      }
#line 144
      if (tmp) {
        {
#line 144
        tmp___0 = chkReg_Probe(smb_slave, (char *)"Probing LM85/compatible chip:\n",
                               chkReg___8, method___1);
        }
#line 144
        if (tmp___0 >= 20) {
#line 148
          goto ret1;
        } else {
#line 150
          n = smb_slave + 2;
        }
      } else {
#line 150
        n = smb_slave + 2;
      }
    } else {
#line 142
      goto ret0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  ret0: 
#line 155
  smb_slave = save;
#line 156
  return (0);
  ret1: 
  {
#line 158
  kill_smb_slave(smb_slave);
  }
#line 159
  if (lm85chipid___0 == 3) {
    {
#line 160
    n = (*(method___1->Read))(22);
#line 161
    adm_24fan___0[0] = n & 1;
#line 162
    adm_24fan___0[1] = n & 2;
    }
  }
#line 164
  if (lm85chipid___0 < 5) {
#line 165
    Vfac___0 = (float )(1. / (double )((float )255));
  } else {
#line 167
    Vfac___0 = (float )(1. / (double )((float )1023));
  }
#line 168
  return (lm85chipid___0);
}
}
#line 171 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm85.c"
static int lm85_chk___0(LM_METHODS *method___1 ) 
{ 
  int vendor ;
  int verstep ;

  {
  {
#line 175
  vendor = (*(method___1->Read))(62);
#line 176
  verstep = (*(method___1->Read))(63);
  }
#line 178
  if (vendor == 1) {
#line 179
    if ((verstep & 240) == 96) {
#line 180
      lm85chipid___0 = 1;
    } else {
#line 182
      goto ret0;
    }
  } else
#line 183
  if (vendor == 65) {
#line 184
    if ((verstep & 240) == 16) {
#line 185
      lm85chipid___0 = 3;
    } else
#line 186
    if ((verstep & 240) == 32) {
#line 187
      lm85chipid___0 = 4;
    } else
#line 188
    if (verstep == 96) {
#line 189
      lm85chipid___0 = 5;
    } else
#line 190
    if (verstep == 98) {
#line 191
      lm85chipid___0 = 6;
    } else {
#line 193
      goto ret0;
    }
  } else
#line 194
  if (vendor == 92) {
#line 195
    if ((verstep & 240) == 96) {
#line 196
      lm85chipid___0 = 2;
    } else {
#line 198
      goto ret0;
    }
  } else {
#line 200
    goto ret0;
  }
  {
#line 202
  strcpy((char */* __restrict  */)(buff___4), (char const   */* __restrict  */)lm85chip___0[lm85chipid___0]);
  }
#line 203
  return (lm85chipid___0);
  ret0: 
#line 205
  return (0);
}
}
#line 213 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm85.c"
static float lm85_temp___0(LM_METHODS *method___1 , int no ) 
{ 
  int n ;
  int ne ;
  float ext ;
  float offset ;

  {
#line 216
  ext = (float )0.0;
#line 216
  offset = (float )0.0;
#line 218
  if (no < 0) {
#line 219
    return ((float )65535);
  } else
#line 218
  if (2 < no) {
#line 219
    return ((float )65535);
  }
#line 221
  if (lm85chipid___0 == 3) {
#line 221
    goto _L;
  } else
#line 221
  if (lm85chipid___0 == 4) {
    _L: /* CIL Label */ 
#line 222
    if (no == 2) {
#line 223
      return ((float )65535);
    } else {
#line 225
      no ++;
    }
  } else
#line 226
  if (lm85chipid___0 >= 5) {
    {
#line 227
    ne = (*(method___1->Read))(119);
#line 228
    ext = (float )(0.25 * (double )((ne >> (no + 1) * 2) & 3));
#line 229
    n = (*(method___1->Read))(112 + no);
    }
#line 230
    if (n > 128) {
#line 231
      n -= 255;
    }
#line 232
    offset = (float )n;
  }
  {
#line 234
  n = (*(method___1->Read))(37 + no);
  }
#line 235
  if (n == 128) {
#line 236
    return ((float )65535);
  } else
#line 237
  if (n > 128) {
#line 238
    return (((float )(n - 255) + ext) - offset);
  } else {
#line 240
    return (((float )n + ext) - offset);
  }
}
}
#line 249 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm85.c"
static float Vtab___0[5]  = {      (float )((2.5 * 4.) / 3.),      (float )((2.25 * 4.) / 3.),      (float )((3.3 * 4.) / 3.),      (float )((5.0 * 4.) / 3.), 
        (float )((12.0 * 4.) / 3.)};
#line 257 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm85.c"
static float lm85_volt___0(LM_METHODS *method___1 , int no ) 
{ 
  int n ;
  int ne ;
  int tmp ;
  int tmp___0 ;

  {
#line 259
  ne = 0;
#line 261
  if (no < 0) {
#line 262
    return ((float )65535);
  } else
#line 261
  if (4 < no) {
#line 262
    return ((float )65535);
  }
#line 264
  if (lm85chipid___0 >= 5) {
#line 265
    if (no == 4) {
      {
#line 266
      tmp = (*(method___1->Read))(119);
#line 266
      ne = tmp & 3;
      }
    } else {
      {
#line 268
      tmp___0 = (*(method___1->Read))(118);
#line 268
      ne = (tmp___0 >> no * 2) & 3;
      }
    }
  }
  {
#line 270
  n = (*(method___1->Read))(32 + no);
  }
#line 271
  if (lm85chipid___0 >= 5) {
#line 272
    n = (n << 2) | ne;
  }
#line 274
  return ((Vtab___0[no] * Vfac___0) * (float )n);
}
}
#line 288 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm85.c"
static int ppr___0[4]  = {      2,      2,      2,      2};
#line 288 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm85.c"
static int div___5[2]  = {      1,      1};
#line 284 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm85.c"
static int lm85_fanrpm___0(LM_METHODS *method___1 , int no ) 
{ 
  int lsb ;
  int msb ;
  int r ;
  int n ;
  int p ;
  int tmp ;

  {
#line 287
  p = 2;
#line 290
  if (no < 0) {
#line 291
    return (65535);
  } else
#line 290
  if (3 < no) {
#line 291
    return (65535);
  } else
#line 290
  if (lm85chipid___0 == 4) {
#line 291
    return (65535);
  }
#line 293
  if (lm85chipid___0 == 3) {
#line 294
    if (no > 1) {
#line 295
      return (65535);
    } else
#line 294
    if (adm_24fan___0[no]) {
#line 295
      return (65535);
    }
    {
#line 296
    n = (*(method___1->Read))(71);
#line 297
    div___5[0] = (n >> 4) & 3;
#line 298
    div___5[1] = n >> 6;
#line 299
    r = (*(method___1->Read))(40 + no);
    }
#line 300
    if (r == 0) {
#line 301
      return (65535);
    } else
#line 302
    if (r == 255) {
#line 304
      if (div___5[no] < 3) {
#line 305
        (div___5[no]) ++;
      } else {
#line 307
        div___5[no] = 0;
      }
      {
#line 308
      r = ((n & 15) | (div___5[0] << 4)) | (div___5[1] << 6);
#line 309
      (*(method___1->Write))(71, r);
      }
#line 310
      return (65535);
    } else {
#line 312
      return (1350000 / (r * (1 << div___5[no])));
    }
  }
#line 315
  if (lm85chipid___0 >= 5) {
    {
#line 316
    tmp = (*(method___1->Read))(123);
#line 316
    p = ((tmp >> no * 2) & 3) + 1;
    }
  }
  {
#line 317
  ppr___0[no] = p;
#line 319
  lsb = (*(method___1->Read))(40 + no * 2);
#line 320
  msb = (*(method___1->Read))(41 + no * 2);
  }
#line 321
  if (lsb == 255) {
#line 321
    if (msb == 255) {
#line 322
      return (65535);
    } else {
#line 321
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 321
  if (lsb == 0) {
#line 321
    if (msb == 0) {
#line 322
      return (65535);
    } else {
#line 324
      return (5400000 / (p * ((msb << 8) | lsb)));
    }
  } else {
#line 324
    return (5400000 / (p * ((msb << 8) | lsb)));
  }
}
}
#line 23 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.h"
static char *winbchip___0[16]  = 
#line 23 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.h"
  {      (char *)"No Sensor",      (char *)"Winbond Chip W83781D",      (char *)"Winbond Chip W83782D",      (char *)"Winbond Chip W83783S", 
        (char *)"Winbond Chip W83791D",      (char *)"Winbond Chip W83627HF/THF/THF-A",      (char *)"Winbond Chip W83697HF",      (char *)"Winbond unknown Chip", 
        (char *)"Asus Chip AS99127F",      (char *)"Asus Chip ASB100(Bach)",      (char *)"Asus Chip ASM58(Mozart-2)",      (char *)"Nat.Semi.Con. Chip LM78", 
        (char *)"Nat.Semi.Con. Chip LM79",      (char *)"Analog Dev. Chip ADM9240",      (char *)"Unknown Chip assuming LM78",      (char *)((void *)0)};
#line 96 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.c"
static int winbond_probe___0(LM_METHODS *method___1 ) ;
#line 97
static int winbond_probe_act___0(LM_METHODS *method___1 , int slave ) ;
#line 98
static float winbond_temp___0(LM_METHODS *method___1 , int no ) ;
#line 99
static int winbond_fanrpm___0(LM_METHODS *method___1 , int no ) ;
#line 100
static float winbond_volt___0(LM_METHODS *method___1 , int no ) ;
#line 103 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.c"
static char buff___5[128]  ;
#line 114 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.c"
static int wbdchipid___1  =    0;
#line 115 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.c"
static int wbdlmid___0  =    0;
#line 118 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.c"
static int temp1_flag___2  =    0;
#line 119 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.c"
static int temp2_flag___2  =    0;
#line 120 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.c"
static int temp1_addr___1  =    0;
#line 121 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.c"
static int temp2_addr___1  =    0;
#line 124 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.c"
static int fan12div_reg___0  =    71;
#line 129 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.c"
static int chkReg___9[33]  = 
#line 129
  {      64,      65,      66,      67, 
        68,      69,      70,      71, 
        72,      73,      74,      75, 
        76,      77,      78,      79, 
        86,      88,      89,      93, 
        62,      19,      23,      161, 
        32,      34,      35,      36, 
        39,      41,      42,      43, 
        -1};
#line 141 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.c"
static void Temp_Bipolar___0(LM_METHODS *method___1 ) 
{ 
  int n ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 145
  tmp = (*(method___1->Read))(89);
#line 145
  n = tmp & 143;
#line 146
  (*(method___1->Write))(89, n);
#line 147
  tmp___0 = (*(method___1->Read))(93);
#line 147
  n = tmp___0 | 14;
#line 148
  (*(method___1->Write))(93, n);
  }
#line 149
  return;
}
}
#line 151 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.c"
static void Init_FanDiv___0(LM_METHODS *method___1 ) 
{ 
  int n ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 155
  tmp = (*(method___1->Read))(71);
#line 155
  n = (tmp & 15) | 160;
#line 156
  (*(method___1->Write))(71, n);
#line 157
  tmp___0 = (*(method___1->Read))(75);
#line 157
  n = (tmp___0 & 63) | 128;
#line 158
  (*(method___1->Write))(75, n);
  }
#line 159
  return;
}
}
#line 164 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.c"
static int winbond_probe___0(LM_METHODS *method___1 ) 
{ 
  int n ;
  int save ;
  int slave ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 166
  slave = 0;
#line 168
  if ((unsigned long )method___1 != (unsigned long )(& method_isa)) {
#line 168
    if ((unsigned long )method___1 != (unsigned long )(& method_smb)) {
#line 169
      return (0);
    }
  }
#line 171
  save = smb_slave;
#line 173
  if ((unsigned long )method___1 == (unsigned long )(& method_smb)) {
    {
#line 175
    slave = get_smb_slave(238, 238);
    }
#line 175
    if (slave) {
      {
#line 176
      tmp = winbond_probe_act___0(method___1, slave);
      }
#line 176
      if (tmp) {
#line 177
        goto ret1;
      }
    }
#line 179
    n = 80;
    {
#line 179
    while (1) {
      while_continue: /* CIL Label */ ;
#line 179
      if (! (n <= 94)) {
#line 179
        goto while_break;
      }
      {
#line 180
      slave = get_smb_slave(n, 94);
      }
#line 180
      if (slave) {
        {
#line 183
        tmp___0 = winbond_probe_act___0(method___1, slave);
        }
#line 183
        if (tmp___0) {
#line 184
          goto ret1;
        } else {
#line 186
          n = slave + 2;
        }
      } else {
#line 181
        goto ret0;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 189
    goto ret0;
  } else {
    {
#line 191
    tmp___1 = winbond_probe_act___0(method___1, slave);
    }
#line 191
    if (tmp___1) {
#line 192
      goto ret1;
    }
  }
  ret0: 
#line 196
  smb_slave = save;
#line 197
  return (0);
  ret1: 
#line 200
  if (TyanTigerMP_flag) {
    {
#line 201
    Temp_Bipolar___0(method___1);
#line 202
    usleep((__useconds_t )30000);
#line 203
    Init_FanDiv___0(method___1);
    }
  }
#line 205
  if ((unsigned long )method___1 == (unsigned long )(& method_smb)) {
    {
#line 206
    kill_smb_slave(slave);
    }
#line 207
    if (! smb_wbtemp1_flag) {
      {
#line 208
      kill_smb_slave(smb_wbtemp1);
      }
    }
#line 209
    if (! smb_wbtemp2_flag) {
      {
#line 210
      kill_smb_slave(smb_wbtemp2);
      }
    }
  }
#line 212
  return (wbdchipid___1);
}
}
#line 215 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.c"
static int winbond_probe_act___0(LM_METHODS *method___1 , int slave ) 
{ 
  int i ;
  int n ;
  int nd ;
  int nc ;
  int nvl ;
  int nvu ;
  int nvx ;
  int nva ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 219
  if ((unsigned long )method___1 == (unsigned long )(& method_smb)) {
#line 220
    smb_slave = slave;
  } else {
#line 222
    slave = 0;
  }
  {
#line 224
  tmp = chkReg_Probe(slave, (char *)"Probing Winbond/Asus/LM78/79 chip:\n", chkReg___9,
                     method___1);
  }
#line 224
  if (tmp < 8) {
#line 226
    goto ret0;
  }
  {
#line 228
  tmp___0 = (*(method___1->Read))(73);
#line 228
  nd = tmp___0 & 254;
#line 229
  nc = (*(method___1->Read))(88);
#line 230
  nvx = (*(method___1->Read))(78);
#line 231
  (*(method___1->Write))(78, 0);
#line 232
  nvl = (*(method___1->Read))(79);
#line 233
  (*(method___1->Write))(78, 128);
#line 234
  nvu = (*(method___1->Read))(79);
#line 235
  nva = (*(method___1->Read))(62);
  }
#line 240
  if (nvl == 163) {
#line 240
    if (nvu == 92) {
      {
#line 242
      if ((nc & 254) == 16) {
#line 242
        goto case_16;
      }
#line 247
      if ((nc & 254) == 26) {
#line 247
        goto case_26;
      }
#line 247
      if ((nc & 254) == 144) {
#line 247
        goto case_26;
      }
#line 247
      if ((nc & 254) == 32) {
#line 247
        goto case_26;
      }
#line 250
      if ((nc & 254) == 48) {
#line 250
        goto case_48;
      }
#line 255
      if ((nc & 254) == 64) {
#line 255
        goto case_64;
      }
#line 258
      if ((nc & 254) == 96) {
#line 258
        goto case_96;
      }
#line 261
      if ((nc & 254) == 112) {
#line 261
        goto case_112;
      }
#line 264
      goto switch_default;
      case_16: /* CIL Label */ 
#line 243
      wbdchipid___1 = 1;
#line 244
      goto switch_break;
      case_26: /* CIL Label */ 
      case_144: /* CIL Label */ 
      case_32: /* CIL Label */ 
#line 248
      wbdchipid___1 = 5;
#line 249
      goto switch_break;
      case_48: /* CIL Label */ 
#line 251
      wbdchipid___1 = 2;
#line 252
      if (nc == 49) {
#line 253
        wbdchipid___1 = 8;
      }
#line 254
      goto switch_break;
      case_64: /* CIL Label */ 
#line 256
      wbdchipid___1 = 3;
#line 257
      goto switch_break;
      case_96: /* CIL Label */ 
#line 259
      wbdchipid___1 = 6;
#line 260
      goto switch_break;
      case_112: /* CIL Label */ 
#line 262
      wbdchipid___1 = 4;
#line 263
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 268
      goto ret0;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 240
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 271
  if (nvl == 195) {
#line 271
    if (nvu == 18) {
#line 271
      if (nc == 49) {
#line 272
        wbdchipid___1 = 8;
      } else {
#line 271
        goto _L___7;
      }
    } else {
#line 271
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
#line 273
  if (nvl == 148) {
#line 273
    if (nvu == 6) {
#line 273
      if (nc == 49) {
#line 274
        wbdchipid___1 = 9;
      } else {
#line 273
        goto _L___5;
      }
    } else {
#line 273
      goto _L___5;
    }
  } else
  _L___5: /* CIL Label */ 
#line 275
  if (smb_slave == 238) {
#line 275
    if (nvx == 148) {
#line 275
      if (nvl == 54) {
#line 275
        if (nc == 86) {
#line 279
          wbdchipid___1 = 10;
        } else {
#line 275
          goto _L___3;
        }
      } else {
#line 275
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 275
    if (nvx == 148) {
#line 275
      if (nvl == 6) {
#line 275
        if (nc == 86) {
#line 279
          wbdchipid___1 = 10;
        } else {
#line 275
          goto _L___1;
        }
      } else {
#line 275
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 275
    if (nvx == 92) {
#line 275
      if (nvl == 163) {
#line 275
        if (nc == 16) {
#line 279
          wbdchipid___1 = 10;
        } else {
#line 275
          goto _L;
        }
      } else {
#line 275
        goto _L;
      }
    } else {
#line 275
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 280
  if (nd == 32) {
#line 281
    wbdchipid___1 = 11;
  } else
#line 280
  if (nd == 64) {
#line 281
    wbdchipid___1 = 11;
  } else
#line 282
  if (nd == 192) {
#line 283
    wbdchipid___1 = 12;
  } else
#line 284
  if (nva == 35) {
#line 285
    wbdchipid___1 = 13;
  } else {
#line 290
    goto ret0;
  }
  {
#line 293
  strcpy((char */* __restrict  */)(buff___5), (char const   */* __restrict  */)winbchip___0[wbdchipid___1]);
#line 295
  wbdlmid___0 = wbdchipid___1;
  }
#line 296
  if (wbdchipid___1 == 7) {
#line 297
    wbdlmid___0 = 1;
  } else
#line 296
  if (wbdchipid___1 >= 11) {
#line 297
    wbdlmid___0 = 1;
  }
#line 299
  if (wbdchipid___1 == 9) {
#line 300
    wbdlmid___0 = 1;
  }
#line 302
  if (wbdchipid___1 == 10) {
    {
#line 303
    wbdlmid___0 = 1;
#line 304
    temp2_flag___2 = 1;
#line 304
    temp1_flag___2 = temp2_flag___2;
#line 305
    fan12div_reg___0 = 161;
#line 306
    (*(method___1->Write))(64, 1);
    }
#line 307
    goto ret1;
  }
#line 310
  if (wbdchipid___1 == 13) {
    {
#line 311
    temp2_flag___2 = 1;
#line 311
    temp1_flag___2 = temp2_flag___2;
#line 312
    (*(method___1->Write))(64, 1);
    }
#line 313
    goto ret1;
  }
#line 316
  if ((unsigned long )method___1 == (unsigned long )(& method_isa)) {
#line 316
    if (wbdchipid___1 >= 11) {
#line 317
      temp2_flag___2 = 1;
#line 317
      temp1_flag___2 = temp2_flag___2;
#line 318
      goto ret1;
    }
  }
#line 323
  if (wbdchipid___1 >= 11) {
    {
#line 324
    i = set_smb_Extemp(144, 158, & smb_wbtemp2, & smb_wbtemp1);
#line 326
    temp2_flag___2 = i >> 1;
#line 327
    temp1_flag___2 = i & 1;
#line 328
    info_Extemp(method___1, temp1_flag___2, temp2_flag___2);
    }
#line 329
    if (! temp1_flag___2) {
      {
#line 330
      strcat((char */* __restrict  */)winbond.Name, (char const   */* __restrict  */)"+LM75");
      }
    } else
#line 329
    if (! temp2_flag___2) {
      {
#line 330
      strcat((char */* __restrict  */)winbond.Name, (char const   */* __restrict  */)"+LM75");
      }
    }
#line 331
    goto ret1;
  }
  {
#line 334
  n = (*(method___1->Read))(74);
#line 335
  temp1_flag___2 = (n & 8) >> 3;
  }
#line 335
  if (! temp1_flag___2) {
    {
#line 336
    temp1_addr___1 = smb_wbtemp1;
#line 337
    smb_wbtemp1 = 2 * (72 + (n & 7));
#line 338
    tmp___1 = (*(method___1->ReadTemp1))();
    }
#line 338
    if (tmp___1 == 65535) {
#line 339
      temp1_flag___2 = 1;
#line 340
      smb_wbtemp1 = temp1_addr___1;
    }
  }
#line 344
  temp2_flag___2 = (n & 128) >> 7;
#line 344
  if (! temp2_flag___2) {
    {
#line 345
    temp2_addr___1 = smb_wbtemp2;
#line 346
    smb_wbtemp2 = 2 * (72 + ((n & 112) >> 4));
#line 347
    tmp___2 = (*(method___1->ReadTemp2))();
    }
#line 347
    if (tmp___2 == 65535) {
#line 348
      temp2_flag___2 = 1;
#line 349
      smb_wbtemp2 = temp2_addr___1;
    }
  }
  {
#line 352
  info_Extemp(method___1, temp1_flag___2, temp2_flag___2);
  }
  ret1: 
#line 355
  if ((unsigned long )method___1 == (unsigned long )(& method_smb)) {
#line 356
    smb_wbtemp1_flag = temp1_flag___2;
#line 357
    smb_wbtemp2_flag = temp2_flag___2;
  }
#line 359
  return (wbdchipid___1);
  ret0: 
#line 361
  return (0);
}
}
#line 370 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.c"
static float winbond_temp___0(LM_METHODS *method___1 , int no ) 
{ 
  int n ;
  float f ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 372
  n = 0;
#line 375
  if (no < 0) {
#line 376
    return ((float )65535);
  } else
#line 375
  if (2 < no) {
#line 376
    return ((float )65535);
  }
#line 377
  if (no == 2) {
#line 377
    if (wbdchipid___1 == 3) {
#line 379
      return ((float )65535);
    } else
#line 377
    if (wbdchipid___1 == 6) {
#line 379
      return ((float )65535);
    } else
#line 377
    if (wbdchipid___1 == 10) {
#line 379
      return ((float )65535);
    }
  }
#line 381
  if (no == 0) {
    {
#line 382
    tmp = (*(method___1->Read))(39);
#line 382
    f = (float )tmp;
    }
#line 383
    if (wbdchipid___1 == 13) {
      {
#line 384
      n = (*(method___1->Read))(75);
      }
#line 385
      if (n & 128) {
#line 386
        f = (float )((double )f + 0.5);
      }
    }
#line 388
    return (f);
  } else
#line 389
  if (no == 1) {
#line 390
    if (wbdchipid___1 == 9) {
      {
#line 391
      tmp___0 = (*(method___1->Read))(23);
      }
#line 391
      return ((float )tmp___0);
    }
#line 392
    if (wbdchipid___1 == 10) {
      {
#line 393
      tmp___1 = (*(method___1->Read))(19);
      }
#line 393
      return ((float )tmp___1);
    } else
#line 394
    if (! temp1_flag___2) {
      {
#line 395
      n = (*(method___1->ReadTemp1))();
      }
    }
  } else
#line 399
  if (no == 2) {
#line 400
    if (wbdchipid___1 == 9) {
#line 401
      if (! temp1_flag___2) {
        {
#line 402
        n = (*(method___1->ReadTemp1))();
        }
      }
    } else
#line 403
    if (! temp2_flag___2) {
      {
#line 405
      n = (*(method___1->ReadTemp2))();
      }
    }
  }
#line 408
  if ((n & 255) >= 128) {
#line 409
    n = 0;
  }
#line 411
  f = (float )((double )((float )(n & 255)) + 0.5 * (double )((n & 65280) >> 15));
#line 413
  if (wbdchipid___1 == 8) {
#line 413
    if (pm_smb_detected == 41) {
#line 415
      if (no == 1) {
#line 415
        if (- 32.0 < (double )f) {
#line 415
          if ((double )f <= 105.0) {
#line 416
            f = (float )((double )f * 0.697);
#line 417
            f = (float )((double )f + 25.0);
          }
        }
      }
    }
  }
#line 420
  return (f);
}
}
#line 428 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.c"
static float winbond_volt___0(LM_METHODS *method___1 , int no ) 
{ 
  int n ;
  float f ;

  {
#line 431
  f = (float )0.0;
#line 433
  if (no < 0) {
#line 434
    return ((float )65535);
  } else
#line 433
  if (6 < no) {
#line 434
    return ((float )65535);
  }
#line 435
  if (wbdchipid___1 == 10) {
#line 435
    if (no == 1) {
#line 436
      return ((float )65535);
    } else
#line 435
    if (no > 4) {
#line 436
      return ((float )65535);
    }
  }
#line 437
  if (wbdchipid___1 == 13) {
#line 437
    if (no > 5) {
#line 438
      return ((float )65535);
    }
  }
  {
#line 440
  n = (*(method___1->Read))(32 + no);
  }
  {
#line 444
  if (no == 2) {
#line 444
    goto case_2;
  }
#line 444
  if (no == 1) {
#line 444
    goto case_2;
  }
#line 444
  if (no == 0) {
#line 444
    goto case_2;
  }
#line 447
  if (no == 3) {
#line 447
    goto case_3;
  }
#line 450
  if (no == 4) {
#line 450
    goto case_4;
  }
#line 453
  if (no == 5) {
#line 453
    goto case_5;
  }
#line 461
  if (no == 6) {
#line 461
    goto case_6;
  }
#line 441
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 445
  f = (float )((double )n * 0.016);
#line 446
  goto switch_break;
  case_3: /* CIL Label */ 
#line 448
  f = (float )(((double )n * 0.016) * 1.68);
#line 449
  goto switch_break;
  case_4: /* CIL Label */ 
#line 451
  f = (float )(((double )n * 0.016) * 3.800);
#line 452
  goto switch_break;
  case_5: /* CIL Label */ 
#line 454
  if (wbdlmid___0 == 8) {
#line 455
    f = (float )(((double )(- n) * 0.016) * 3.968);
  } else
#line 456
  if (wbdlmid___0 == 1) {
#line 457
    f = (float )(((double )(- n) * 0.016) * 3.477);
  } else {
#line 459
    f = (float )(((double )n * 0.016 - 3.6 * 0.8056) / 0.1944);
  }
#line 460
  goto switch_break;
  case_6: /* CIL Label */ 
#line 462
  if (wbdlmid___0 == 1) {
#line 463
    f = (float )(((double )(- n) * 0.016) * 1.500);
  } else
#line 462
  if (wbdlmid___0 == 8) {
#line 463
    f = (float )(((double )(- n) * 0.016) * 1.500);
  } else {
#line 465
    f = (float )(((double )n * 0.016 - 3.6 * 0.6818) / 0.3182);
  }
  switch_break: /* CIL Label */ ;
  }
#line 468
  return (f);
}
}
#line 508 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.c"
static int div___6[3]  = {      1,      1,      1};
#line 505 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_winbond.c"
static int winbond_fanrpm___0(LM_METHODS *method___1 , int no ) 
{ 
  int r ;
  int n1 ;
  int n2 ;
  int n3 ;

  {
#line 507
  n1 = 80;
#line 507
  n2 = 64;
#line 507
  n3 = 0;
#line 510
  if (no < 0) {
#line 511
    return (65535);
  } else
#line 510
  if (2 < no) {
#line 511
    return (65535);
  }
#line 512
  if (no == 2) {
#line 512
    if (wbdchipid___1 == 6) {
#line 515
      return (65535);
    } else
#line 512
    if (wbdchipid___1 == 10) {
#line 515
      return (65535);
    } else
#line 512
    if (wbdchipid___1 == 13) {
#line 515
      return (65535);
    }
  }
#line 517
  if (2 <= wbdchipid___1) {
#line 517
    if (wbdchipid___1 <= 6) {
      {
#line 518
      n3 = (*(method___1->Read))(93);
      }
    }
  }
#line 519
  if (no != 2) {
    {
#line 520
    n1 = (*(method___1->Read))(fan12div_reg___0);
#line 521
    div___6[0] = ((n1 >> 4) & 3) | ((n3 & 32) >> 3);
#line 522
    div___6[1] = (n1 >> 6) | ((n3 & 64) >> 4);
    }
  } else
#line 523
  if (wbdchipid___1 < 11) {
    {
#line 524
    n2 = (*(method___1->Read))(75);
#line 525
    div___6[2] = (n2 >> 6) | ((n3 & 128) >> 5);
    }
  }
  {
#line 528
  r = (*(method___1->Read))(40 + no);
  }
#line 529
  if (r == 255) {
#line 531
    if (no != 2) {
#line 532
      if (div___6[no] < 3) {
#line 533
        (div___6[no]) ++;
      } else {
#line 535
        div___6[no] = 0;
      }
      {
#line 536
      r = ((n1 & 15) | ((div___6[0] & 3) << 4)) | ((div___6[1] & 3) << 6);
#line 537
      (*(method___1->Write))(fan12div_reg___0, r);
      }
    } else
#line 538
    if (wbdchipid___1 < 11) {
#line 539
      if (div___6[no] < 3) {
#line 540
        (div___6[no]) ++;
      } else {
#line 542
        div___6[no] = 0;
      }
      {
#line 543
      r = (n2 & 63) | ((div___6[2] & 3) << 6);
#line 544
      (*(method___1->Write))(75, r);
      }
    }
#line 546
    if (2 <= wbdchipid___1) {
#line 546
      if (wbdchipid___1 <= 6) {
        {
#line 547
        r = (((n3 & 31) | ((div___6[0] & 4) << 3)) | ((div___6[1] & 4) << 4)) | ((div___6[2] & 4) << 5);
#line 549
        (*(method___1->Write))(93, r);
        }
      }
    }
#line 551
    return (65535);
  } else
#line 552
  if (r == 0) {
#line 553
    return (65535);
  }
#line 556
  return (1350000 / (r * (1 << div___6[no])));
}
}
#line 45 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm90.c"
static int lm90chipid___0  =    0;
#line 47
static int lm90_probe___0(LM_METHODS *method___1 ) ;
#line 48
static int lm90_ident___0(LM_METHODS *method___1 ) ;
#line 49
static float lm90_temp___0(LM_METHODS *method___1 , int no ) ;
#line 50
static int lm90_fanrpm___0(LM_METHODS *method___1 , int no ) ;
#line 51
static float lm90_volt___0(LM_METHODS *method___1 , int no ) ;
#line 54 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm90.c"
static char buff___6[128]  ;
#line 71 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm90.c"
static char *lm90chip___0[5]  = {      (char *)"No Sensor",      (char *)"Nat.Semi.Con. Chip LM90",      (char *)"Analog Dev. Chip ADM1020",      (char *)"Analog Dev. Chip ADM1021/1023", 
        (char *)((void *)0)};
#line 82 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm90.c"
static int chkReg___10[21]  = 
#line 82
  {      0,      1,      2,      3, 
        4,      5,      6,      7, 
        8,      16,      17,      18, 
        19,      20,      25,      32, 
        33,      191,      254,      255, 
        -1};
#line 94 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm90.c"
static int lm90_probe___0(LM_METHODS *method___1 ) 
{ 
  int n ;
  int save ;
  int tmp ;
  int tmp___0 ;

  {
#line 98
  if ((unsigned long )method___1 != (unsigned long )(& method_smb)) {
#line 99
    return (0);
  }
#line 101
  save = smb_slave;
#line 103
  n = 144;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! (n <= 158)) {
#line 103
      goto while_break;
    }
    {
#line 104
    smb_slave = get_smb_slave(n, 158);
    }
#line 104
    if (smb_slave) {
      {
#line 107
      tmp = lm90_ident___0(method___1);
      }
#line 107
      if (tmp) {
        {
#line 107
        tmp___0 = chkReg_Probe(smb_slave, (char *)"Probing LM90 chip:\n", chkReg___10,
                               method___1);
        }
#line 107
        if (tmp___0 >= 8) {
#line 110
          goto ret1;
        } else {
#line 112
          n = smb_slave + 2;
        }
      } else {
#line 112
        n = smb_slave + 2;
      }
    } else {
#line 105
      goto ret0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  ret0: 
#line 117
  smb_slave = save;
#line 118
  return (0);
  ret1: 
  {
#line 120
  kill_smb_slave(smb_slave);
#line 121
  strcpy((char */* __restrict  */)(buff___6), (char const   */* __restrict  */)lm90chip___0[lm90chipid___0]);
  }
#line 122
  return (lm90chipid___0);
}
}
#line 125 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm90.c"
static int lm90_ident___0(LM_METHODS *method___1 ) 
{ 
  int vend ;
  int revd ;
  int tmp ;

  {
  {
#line 129
  vend = (*(method___1->Read))(254);
#line 130
  revd = (*(method___1->Read))(255);
  }
#line 131
  if (vend == 1) {
#line 131
    if (revd == 33) {
#line 132
      lm90chipid___0 = 1;
    } else {
#line 131
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 133
  if (vend == 65) {
#line 134
    if (revd) {
#line 134
      tmp = 1;
    } else {
#line 134
      tmp = 0;
    }
#line 134
    if (tmp == 48) {
#line 135
      lm90chipid___0 = 3;
    } else {
#line 137
      lm90chipid___0 = 2;
    }
  }
#line 140
  return (lm90chipid___0);
}
}
#line 148 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm90.c"
static float lm90_temp___0(LM_METHODS *method___1 , int no ) 
{ 
  int n ;
  int k ;
  float offset ;

  {
#line 150
  n = 0;
#line 150
  k = 0;
#line 151
  offset = (float )0.0;
#line 153
  if (no < 0) {
#line 154
    return ((float )65535);
  } else
#line 153
  if (2 < no) {
#line 154
    return ((float )65535);
  }
#line 156
  if (no == 0) {
    {
#line 157
    n = (*(method___1->Read))(0);
    }
  } else
#line 158
  if (no == 1) {
#line 159
    if (lm90chipid___0 != 2) {
      {
#line 160
      n = (*(method___1->Read))(17);
      }
#line 160
      if (n == 255) {
#line 161
        n = 0;
      }
      {
#line 162
      k = (*(method___1->Read))(18);
      }
#line 162
      if (k == 255) {
#line 163
        k = 0;
      } else {
#line 165
        k >>= 5;
      }
#line 166
      offset = (float )((double )((float )n) + 0.125 * (double )((float )k));
    }
    {
#line 168
    n = (*(method___1->Read))(1);
#line 169
    k = (*(method___1->Read))(16);
    }
#line 169
    if (k == 255) {
#line 170
      k = 0;
    } else {
#line 172
      k >>= 5;
    }
  }
#line 174
  if (n >= 128) {
#line 175
    k = 0;
#line 175
    n = k;
  }
#line 177
  return ((float )(((double )((float )n) + 0.125 * (double )((float )k)) - (double )offset));
}
}
#line 182 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm90.c"
static float lm90_volt___0(LM_METHODS *method___1 , int no ) 
{ 


  {
#line 184
  return ((float )65535);
}
}
#line 187 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm90.c"
static int lm90_fanrpm___0(LM_METHODS *method___1 , int no ) 
{ 


  {
#line 189
  return (65535);
}
}
#line 39 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm75.c"
static int lm75_probe___0(LM_METHODS *method___1 ) ;
#line 40
static float lm75_temp___0(LM_METHODS *method___1 , int no ) ;
#line 41
static int lm75_fanrpm___0(LM_METHODS *method___1 , int no ) ;
#line 42
static float lm75_volt___0(LM_METHODS *method___1 , int no ) ;
#line 54 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm75.c"
static int temp1_flag___3  =    0;
#line 55 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm75.c"
static int temp2_flag___3  =    0;
#line 60 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm75.c"
static int lm75_probe___0(LM_METHODS *method___1 ) 
{ 
  int i ;
  int j ;
  int k ;
  int save ;

  {
#line 64
  if ((unsigned long )method___1 != (unsigned long )(& method_smb)) {
#line 65
    return (0);
  }
  {
#line 67
  i = set_smb_Extemp(144, 158, & smb_wbtemp1, & smb_wbtemp2);
#line 69
  temp1_flag___3 = i >> 1;
#line 70
  temp2_flag___3 = i & 1;
  }
#line 72
  if (temp1_flag___3) {
#line 72
    if (temp2_flag___3) {
#line 73
      return (0);
    }
  }
  {
#line 75
  save = smb_slave;
#line 76
  smb_slave = smb_wbtemp1;
#line 77
  i = (*(method___1->Read))(1);
  }
#line 78
  if (i > 31) {
#line 79
    goto ret0;
  }
  {
#line 80
  i = (*(method___1->Read))(0);
#line 81
  j = (*(method___1->Read))(2);
#line 82
  k = (*(method___1->Read))(3);
  }
#line 83
  if (j == 255) {
#line 85
    goto ret0;
  } else
#line 83
  if (j == 0) {
#line 85
    goto ret0;
  } else
#line 83
  if (k == 255) {
#line 85
    goto ret0;
  } else
#line 83
  if (k == 0) {
#line 85
    goto ret0;
  } else
#line 83
  if (i == j) {
#line 83
    if (i == k) {
#line 85
      goto ret0;
    }
  }
#line 90
  if (j < 40) {
#line 91
    goto ret0;
  } else
#line 90
  if (k < 20) {
#line 91
    goto ret0;
  }
  {
#line 93
  info_Extemp(method___1, temp1_flag___3, temp2_flag___3);
#line 95
  kill_smb_slave(smb_slave);
  }
#line 96
  return (1);
  ret0: 
#line 98
  smb_slave = save;
#line 99
  return (0);
}
}
#line 108 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm75.c"
static float lm75_temp___0(LM_METHODS *method___1 , int no ) 
{ 
  int n ;

  {
#line 110
  n = 0;
#line 112
  if (no < 0) {
#line 113
    return ((float )65535);
  } else
#line 112
  if (1 < no) {
#line 113
    return ((float )65535);
  }
#line 115
  if (no == 0) {
#line 115
    if (! temp1_flag___3) {
      {
#line 116
      n = (*(method___1->ReadTemp1))();
      }
    } else {
#line 115
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 117
  if (no == 1) {
#line 117
    if (! temp2_flag___3) {
      {
#line 118
      n = (*(method___1->ReadTemp2))();
      }
    }
  }
#line 119
  if ((n & 255) >= 128) {
#line 120
    n = 0;
  }
#line 121
  return ((float )((double )((float )(n & 255)) + 0.5 * (double )((n & 65280) >> 15)));
}
}
#line 126 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm75.c"
static float lm75_volt___0(LM_METHODS *method___1 , int no ) 
{ 


  {
#line 128
  return ((float )65535);
}
}
#line 131 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm75.c"
static int lm75_fanrpm___0(LM_METHODS *method___1 , int no ) 
{ 


  {
#line 133
  return (65535);
}
}
#line 5 "/home/wheatley/newnew/temp/xmbmon-2.05/io_static.c"
static int OpenIO___7(void) 
{ 
  int tmp ;

  {
#line 7
  if (iopl_counter == 0) {
    {
#line 8
    tmp = iopl(3);
    }
#line 8
    if (tmp < 0) {
#line 9
      return (-1);
    }
  }
#line 11
  iopl_counter ++;
#line 12
  return (0);
}
}
#line 15 "/home/wheatley/newnew/temp/xmbmon-2.05/io_static.c"
static void CloseIO___7(void) 
{ 


  {
#line 17
  if (iopl_counter == 1) {
    {
#line 18
    iopl(0);
    }
  }
#line 19
  if (iopl_counter > 0) {
#line 20
    iopl_counter --;
  }
#line 21
  return;
}
}
#line 10 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_wl784.h"
static char *wlchip___0[5]  = {      (char *)"No Sensor",      (char *)"Winbond Chip W83L784R",      (char *)"Winbond Chip W83L785R",      (char *)"Winbond Chip W83L785TS-S", 
        (char *)((void *)0)};
#line 59 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_wl784.c"
static int wl784_probe___0(LM_METHODS *method___1 ) ;
#line 60
static int wl784_probe_act___0(LM_METHODS *method___1 , int slave ) ;
#line 61
static float wl784_temp___0(LM_METHODS *method___1 , int no ) ;
#line 62
static int wl784_fanrpm___0(LM_METHODS *method___1 , int no ) ;
#line 63
static float wl784_volt___0(LM_METHODS *method___1 , int no ) ;
#line 66 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_wl784.c"
static char buff___7[128]  ;
#line 77 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_wl784.c"
static int wbdchipid___2  =    0;
#line 80 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_wl784.c"
static int temp1_flag___4  =    0;
#line 81 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_wl784.c"
static int temp2_flag___4  =    0;
#line 82 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_wl784.c"
static int temp1_addr___2  =    0;
#line 83 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_wl784.c"
static int temp2_addr___2  =    0;
#line 88 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_wl784.c"
static int chkReg___11[29]  = 
#line 88
  {      64,      65,      66,      67, 
        68,      69,      70,      71, 
        72,      73,      74,      75, 
        76,      77,      78,      79, 
        32,      33,      34,      35, 
        38,      39,      40,      41, 
        43,      44,      45,      46, 
        -1};
#line 102 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_wl784.c"
static int wl784_probe___0(LM_METHODS *method___1 ) 
{ 
  int n ;
  int save ;
  int slave ;
  int tmp ;

  {
#line 106
  if ((unsigned long )method___1 != (unsigned long )(& method_smb)) {
#line 107
    return (0);
  }
#line 109
  save = smb_slave;
#line 111
  n = 80;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! (n <= 94)) {
#line 111
      goto while_break;
    }
    {
#line 112
    slave = get_smb_slave(n, 94);
    }
#line 112
    if (slave) {
      {
#line 115
      tmp = wl784_probe_act___0(method___1, slave);
      }
#line 115
      if (tmp) {
#line 116
        goto ret1;
      } else {
#line 118
        n = slave + 2;
      }
    } else {
#line 113
      goto ret0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  ret0: 
#line 123
  smb_slave = save;
#line 124
  return (0);
  ret1: 
  {
#line 126
  kill_smb_slave(slave);
  }
#line 127
  if (! smb_wbtemp1_flag) {
    {
#line 128
    kill_smb_slave(smb_wbtemp1);
    }
  }
#line 129
  if (! smb_wbtemp2_flag) {
    {
#line 130
    kill_smb_slave(smb_wbtemp2);
    }
  }
#line 131
  return (wbdchipid___2);
}
}
#line 134 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_wl784.c"
static int wl784_probe_act___0(LM_METHODS *method___1 , int slave ) 
{ 
  int n ;
  int nc ;
  int nvl ;
  int nvh ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 138
  smb_slave = slave;
#line 140
  tmp = chkReg_Probe(slave, (char *)"Probing Winbond W83L78x chip:\n", chkReg___11,
                     method___1);
  }
#line 140
  if (tmp < 8) {
#line 142
    goto ret0;
  }
  {
#line 145
  nvl = (*(method___1->Read))(76);
#line 146
  nvh = (*(method___1->Read))(77);
#line 147
  nc = (*(method___1->Read))(78);
  }
#line 152
  if (nvl == 163) {
#line 152
    if (nvh == 92) {
      {
#line 154
      if ((nc & 254) == 80) {
#line 154
        goto case_80;
      }
#line 157
      if ((nc & 254) == 96) {
#line 157
        goto case_96;
      }
#line 160
      if ((nc & 254) == 112) {
#line 160
        goto case_112;
      }
#line 163
      goto switch_default;
      case_80: /* CIL Label */ 
#line 155
      wbdchipid___2 = 1;
#line 156
      goto switch_break;
      case_96: /* CIL Label */ 
#line 158
      wbdchipid___2 = 2;
#line 159
      goto switch_break;
      case_112: /* CIL Label */ 
#line 161
      wbdchipid___2 = 3;
#line 162
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 164
      goto ret0;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 167
      goto ret0;
    }
  } else {
#line 167
    goto ret0;
  }
  {
#line 169
  strcpy((char */* __restrict  */)wl784.Name, (char const   */* __restrict  */)wlchip___0[wbdchipid___2]);
  }
#line 173
  if (wbdchipid___2 != 1) {
#line 174
    goto ret1;
  }
  {
#line 176
  n = (*(method___1->Read))(75);
#line 177
  temp1_flag___4 = (n & 8) >> 3;
  }
#line 177
  if (! temp1_flag___4) {
    {
#line 178
    temp1_addr___2 = smb_wbtemp1;
#line 179
    smb_wbtemp1 = 2 * (72 + (n & 7));
#line 180
    tmp___0 = (*(method___1->ReadTemp1))();
    }
#line 180
    if (tmp___0 == 65535) {
#line 181
      temp1_flag___4 = 1;
#line 182
      smb_wbtemp1 = temp1_addr___2;
    }
  }
#line 186
  temp2_flag___4 = (n & 128) >> 7;
#line 186
  if (! temp2_flag___4) {
    {
#line 187
    temp2_addr___2 = smb_wbtemp2;
#line 188
    smb_wbtemp2 = 2 * (72 + ((n & 112) >> 4));
#line 189
    tmp___1 = (*(method___1->ReadTemp2))();
    }
#line 189
    if (tmp___1 == 65535) {
#line 190
      temp2_flag___4 = 1;
#line 191
      smb_wbtemp2 = temp2_addr___2;
    }
  }
  {
#line 194
  info_Extemp(method___1, temp1_flag___4, temp2_flag___4);
  }
  ret1: 
#line 197
  smb_wbtemp1_flag = temp1_flag___4;
#line 198
  smb_wbtemp2_flag = temp2_flag___4;
#line 199
  return (wbdchipid___2);
  ret0: 
#line 201
  return (0);
}
}
#line 210 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_wl784.c"
static float wl784_temp___0(LM_METHODS *method___1 , int no ) 
{ 
  int n ;
  float f ;
  int tmp ;
  int tmp___0 ;

  {
#line 212
  n = 0;
#line 215
  if (no < 0) {
#line 216
    return ((float )65535);
  } else
#line 215
  if (2 < no) {
#line 216
    return ((float )65535);
  }
#line 217
  if (no == 2) {
#line 217
    if (wbdchipid___2 == 2) {
#line 218
      return ((float )65535);
    }
  }
#line 219
  if (no >= 1) {
#line 219
    if (wbdchipid___2 == 3) {
#line 220
      return ((float )65535);
    }
  }
#line 222
  if (no == 0) {
    {
#line 223
    tmp = (*(method___1->Read))(39);
    }
#line 223
    return ((float )tmp);
  } else
#line 224
  if (no == 1) {
#line 225
    if (wbdchipid___2 == 2) {
      {
#line 226
      tmp___0 = (*(method___1->Read))(38);
      }
#line 226
      return ((float )tmp___0);
    } else {
      {
#line 228
      n = (*(method___1->ReadTemp1))();
      }
    }
  } else
#line 229
  if (no == 2) {
    {
#line 230
    n = (*(method___1->ReadTemp2))();
    }
  }
#line 233
  if ((n & 255) >= 128) {
#line 234
    n = 0;
  }
#line 236
  f = (float )((double )((float )(n & 255)) + 0.5 * (double )((n & 65280) >> 15));
#line 238
  return (f);
}
}
#line 246 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_wl784.c"
static float wl784_volt___0(LM_METHODS *method___1 , int no ) 
{ 
  int n ;
  float f ;

  {
#line 249
  f = (float )0.0;
#line 251
  if (wbdchipid___2 == 3) {
#line 252
    return ((float )65535);
  }
#line 253
  if (no < 0) {
#line 254
    return ((float )65535);
  } else
#line 253
  if (3 < no) {
#line 254
    return ((float )65535);
  }
  {
#line 256
  n = (*(method___1->Read))(32 + no);
  }
  {
#line 258
  if (no == 0) {
#line 258
    goto case_0;
  }
#line 260
  if (no == 1) {
#line 260
    goto case_1;
  }
#line 265
  if (no == 2) {
#line 265
    goto case_2;
  }
#line 268
  if (no == 3) {
#line 268
    goto case_3;
  }
#line 257
  goto switch_break;
  case_0: /* CIL Label */ 
#line 259
  f = (float )((double )n * 0.016);
  case_1: /* CIL Label */ 
#line 261
  if (wbdchipid___2 == 1) {
#line 262
    f = (float )(((double )n * 0.016) * 3.3434);
  } else {
#line 264
    f = (float )(((double )n * 0.016) * (double )2);
  }
  case_2: /* CIL Label */ 
#line 266
  f = (float )((double )n * 0.016);
#line 267
  goto switch_break;
  case_3: /* CIL Label */ 
#line 269
  if (wbdchipid___2 == 1) {
#line 270
    f = (float )(((double )n * 0.016) * 1.68);
  } else {
#line 272
    f = (float )(((double )n * 0.016) * (double )3);
  }
#line 273
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 276
  return (f);
}
}
#line 300 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_wl784.c"
static int div___7[2]  = {      1,      1};
#line 297 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_wl784.c"
static int wl784_fanrpm___0(LM_METHODS *method___1 , int no ) 
{ 
  int r ;
  int n1 ;

  {
#line 299
  n1 = 17;
#line 302
  if (wbdchipid___2 == 3) {
#line 303
    return (65535);
  }
#line 304
  if (no < 0) {
#line 305
    return (65535);
  } else
#line 304
  if (1 < no) {
#line 305
    return (65535);
  }
  {
#line 307
  n1 = (*(method___1->Read))(73);
#line 308
  div___7[0] = n1 & 7;
#line 309
  div___7[1] = (n1 >> 4) & 7;
#line 311
  r = (*(method___1->Read))(40 + no);
  }
#line 312
  if (r == 255) {
#line 314
    if (div___7[no] < 7) {
#line 315
      (div___7[no]) ++;
    } else {
#line 317
      div___7[no] = 0;
    }
    {
#line 318
    r = ((n1 & 136) | div___7[0]) | (div___7[1] << 4);
#line 319
    (*(method___1->Write))(73, r);
    }
#line 320
    return (65535);
  } else
#line 321
  if (r == 0) {
#line 322
    return (65535);
  }
#line 325
  return (1350000 / (r * (1 << div___7[no])));
}
}
#line 70 "/home/wheatley/newnew/temp/xmbmon-2.05/smbus_piix4.c"
static int readbyte___6(int smb_base___0 , int addr , int cmd ) 
{ 
  u_char dat ;
  u_char saddr ;
  int i ;

  {
#line 72
  saddr = (u_char )(2 * (addr / 2));
  top: 
  {
#line 76
  my_outb((u_short )smb_base___0, (unsigned char)30);
#line 76
  my_outb((unsigned short)235, (unsigned char)0);
#line 76
  my_outb((unsigned short)235, (unsigned char)0);
#line 77
  i = 0;
  }
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (i < 8192)) {
#line 77
      goto while_break;
    }
    {
#line 78
    dat = my_inb((u_short )smb_base___0);
#line 78
    my_outb((unsigned short)235, (unsigned char)0);
#line 78
    my_outb((unsigned short)235, (unsigned char)0);
#line 79
    my_outb((u_short )smb_base___0, dat);
#line 79
    my_outb((unsigned short)235, (unsigned char)0);
#line 79
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 80
    if (! ((int )dat & 9)) {
#line 81
      goto step;
    }
#line 82
    if (! ((int )dat & 1)) {
#line 83
      goto while_break;
    }
#line 77
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 85
  my_outb((u_short )(smb_base___0 + 2), (unsigned char)2);
#line 85
  my_outb((unsigned short)235, (unsigned char)0);
#line 85
  my_outb((unsigned short)235, (unsigned char)0);
  }
  step: 
  {
#line 88
  my_outb((u_short )(smb_base___0 + 4), (unsigned char )((int )saddr | 1));
#line 88
  my_outb((unsigned short)235, (unsigned char)0);
#line 88
  my_outb((unsigned short)235, (unsigned char)0);
#line 89
  my_outb((u_short )(smb_base___0 + 3), (u_char )cmd);
#line 89
  my_outb((unsigned short)235, (unsigned char)0);
#line 89
  my_outb((unsigned short)235, (unsigned char)0);
#line 90
  my_outb((u_short )(smb_base___0 + 2), (unsigned char)72);
#line 91
  my_outb((unsigned short)235, (unsigned char)0);
#line 91
  my_outb((unsigned short)235, (unsigned char)0);
#line 93
  i = 0;
  }
  {
#line 93
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 93
    if (! (i < 8192)) {
#line 93
      goto while_break___0;
    }
    {
#line 94
    dat = my_inb((u_short )smb_base___0);
#line 94
    my_outb((unsigned short)235, (unsigned char)0);
#line 94
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 95
    if ((int )dat & 8) {
#line 100
      goto top;
    }
#line 102
    if (! ((int )dat & 1)) {
#line 102
      if ((int )dat & 6) {
#line 103
        goto while_break___0;
      }
    }
#line 93
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 109
  if ((int )dat & 2) {
    {
#line 110
    dat = my_inb((u_short )(smb_base___0 + 5));
#line 110
    my_outb((unsigned short)235, (unsigned char)0);
#line 110
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 111
    return ((int )dat & 255);
  } else {
#line 113
    return (-1);
  }
}
}
#line 116 "/home/wheatley/newnew/temp/xmbmon-2.05/smbus_piix4.c"
static int readword___4(int smb_base___0 , int addr , int cmd ) 
{ 
  u_char dat ;
  u_char saddr ;
  int i ;
  unsigned char tmp ;

  {
#line 118
  saddr = (u_char )(2 * (addr / 2));
  top: 
  {
#line 122
  my_outb((u_short )smb_base___0, (unsigned char)30);
#line 122
  my_outb((unsigned short)235, (unsigned char)0);
#line 122
  my_outb((unsigned short)235, (unsigned char)0);
#line 123
  i = 0;
  }
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    if (! (i < 8192)) {
#line 123
      goto while_break;
    }
    {
#line 124
    dat = my_inb((u_short )smb_base___0);
#line 124
    my_outb((unsigned short)235, (unsigned char)0);
#line 124
    my_outb((unsigned short)235, (unsigned char)0);
#line 125
    my_outb((u_short )smb_base___0, dat);
#line 125
    my_outb((unsigned short)235, (unsigned char)0);
#line 125
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 126
    if (! ((int )dat & 9)) {
#line 127
      goto step;
    }
#line 128
    if (! ((int )dat & 1)) {
#line 129
      goto while_break;
    }
#line 123
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 131
  my_outb((u_short )(smb_base___0 + 2), (unsigned char)2);
#line 131
  my_outb((unsigned short)235, (unsigned char)0);
#line 131
  my_outb((unsigned short)235, (unsigned char)0);
  }
  step: 
  {
#line 134
  my_outb((u_short )(smb_base___0 + 4), (unsigned char )((int )saddr | 1));
#line 134
  my_outb((unsigned short)235, (unsigned char)0);
#line 134
  my_outb((unsigned short)235, (unsigned char)0);
#line 135
  my_outb((u_short )(smb_base___0 + 3), (u_char )cmd);
#line 135
  my_outb((unsigned short)235, (unsigned char)0);
#line 135
  my_outb((unsigned short)235, (unsigned char)0);
#line 136
  my_outb((u_short )(smb_base___0 + 2), (unsigned char)76);
#line 137
  my_outb((unsigned short)235, (unsigned char)0);
#line 137
  my_outb((unsigned short)235, (unsigned char)0);
#line 139
  i = 0;
  }
  {
#line 139
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 139
    if (! (i < 8192)) {
#line 139
      goto while_break___0;
    }
    {
#line 140
    dat = my_inb((u_short )smb_base___0);
#line 140
    my_outb((unsigned short)235, (unsigned char)0);
#line 140
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 141
    if ((int )dat & 8) {
#line 142
      goto top;
    }
#line 143
    if (! ((int )dat & 1)) {
#line 143
      if ((int )dat & 6) {
#line 144
        goto while_break___0;
      }
    }
#line 139
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 146
  if ((int )dat & 2) {
    {
#line 147
    tmp = my_inb((u_short )(smb_base___0 + 6));
#line 147
    i = (int )tmp;
#line 147
    my_outb((unsigned short)235, (unsigned char)0);
#line 147
    my_outb((unsigned short)235, (unsigned char)0);
#line 148
    dat = my_inb((u_short )(smb_base___0 + 5));
#line 148
    my_outb((unsigned short)235, (unsigned char)0);
#line 148
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 149
    return (((i << 8) + (int )dat) & 65535);
  } else {
#line 151
    return (-1);
  }
}
}
#line 154 "/home/wheatley/newnew/temp/xmbmon-2.05/smbus_piix4.c"
static int writebyte___6(int smb_base___0 , int addr , int cmd , int value ) 
{ 
  u_char dat ;
  u_char saddr ;
  int i ;

  {
  {
#line 156
  saddr = (u_char )(2 * (addr / 2));
#line 159
  my_outb((u_short )smb_base___0, (unsigned char)30);
#line 159
  my_outb((unsigned short)235, (unsigned char)0);
#line 159
  my_outb((unsigned short)235, (unsigned char)0);
#line 160
  i = 0;
  }
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    if (! (i < 8192)) {
#line 160
      goto while_break;
    }
    {
#line 161
    dat = my_inb((u_short )smb_base___0);
#line 161
    my_outb((unsigned short)235, (unsigned char)0);
#line 161
    my_outb((unsigned short)235, (unsigned char)0);
#line 162
    my_outb((u_short )smb_base___0, dat);
#line 162
    my_outb((unsigned short)235, (unsigned char)0);
#line 162
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 163
    if (! ((int )dat & 9)) {
#line 164
      goto step;
    }
#line 165
    if (! ((int )dat & 1)) {
#line 166
      goto while_break;
    }
#line 160
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 168
  my_outb((u_short )(smb_base___0 + 2), (unsigned char)2);
#line 168
  my_outb((unsigned short)235, (unsigned char)0);
#line 168
  my_outb((unsigned short)235, (unsigned char)0);
  }
  step: 
  {
#line 171
  my_outb((u_short )(smb_base___0 + 4), saddr);
#line 171
  my_outb((unsigned short)235, (unsigned char)0);
#line 171
  my_outb((unsigned short)235, (unsigned char)0);
#line 172
  my_outb((u_short )(smb_base___0 + 3), (u_char )cmd);
#line 172
  my_outb((unsigned short)235, (unsigned char)0);
#line 172
  my_outb((unsigned short)235, (unsigned char)0);
#line 173
  my_outb((u_short )(smb_base___0 + 5), (u_char )value);
#line 173
  my_outb((unsigned short)235, (unsigned char)0);
#line 173
  my_outb((unsigned short)235, (unsigned char)0);
#line 174
  my_outb((u_short )(smb_base___0 + 2), (unsigned char)72);
#line 175
  my_outb((unsigned short)235, (unsigned char)0);
#line 175
  my_outb((unsigned short)235, (unsigned char)0);
#line 177
  i = 0;
  }
  {
#line 177
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 177
    if (! (i < 8192)) {
#line 177
      goto while_break___0;
    }
    {
#line 178
    dat = my_inb((u_short )smb_base___0);
#line 178
    my_outb((unsigned short)235, (unsigned char)0);
#line 178
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 179
    if (! ((int )dat & 1)) {
#line 179
      if ((int )dat & 6) {
#line 180
        goto while_break___0;
      }
    }
#line 177
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 182
  if ((int )dat & 2) {
#line 183
    return (0);
  } else {
#line 185
    return (-1);
  }
}
}
#line 188 "/home/wheatley/newnew/temp/xmbmon-2.05/smbus_piix4.c"
static int writeword___4(int smb_base___0 , int addr , int cmd , int value ) 
{ 
  u_char dat ;
  u_char saddr ;
  int i ;

  {
  {
#line 190
  saddr = (u_char )(2 * (addr / 2));
#line 193
  my_outb((u_short )smb_base___0, (unsigned char)30);
#line 193
  my_outb((unsigned short)235, (unsigned char)0);
#line 193
  my_outb((unsigned short)235, (unsigned char)0);
#line 194
  i = 0;
  }
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 194
    if (! (i < 8192)) {
#line 194
      goto while_break;
    }
    {
#line 195
    dat = my_inb((u_short )smb_base___0);
#line 195
    my_outb((unsigned short)235, (unsigned char)0);
#line 195
    my_outb((unsigned short)235, (unsigned char)0);
#line 196
    my_outb((u_short )smb_base___0, dat);
#line 196
    my_outb((unsigned short)235, (unsigned char)0);
#line 196
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 197
    if (! ((int )dat & 9)) {
#line 198
      goto step;
    }
#line 199
    if (! ((int )dat & 1)) {
#line 200
      goto while_break;
    }
#line 194
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 202
  my_outb((u_short )(smb_base___0 + 2), (unsigned char)2);
#line 202
  my_outb((unsigned short)235, (unsigned char)0);
#line 202
  my_outb((unsigned short)235, (unsigned char)0);
  }
  step: 
  {
#line 205
  my_outb((u_short )(smb_base___0 + 4), saddr);
#line 205
  my_outb((unsigned short)235, (unsigned char)0);
#line 205
  my_outb((unsigned short)235, (unsigned char)0);
#line 206
  my_outb((u_short )(smb_base___0 + 3), (u_char )cmd);
#line 206
  my_outb((unsigned short)235, (unsigned char)0);
#line 206
  my_outb((unsigned short)235, (unsigned char)0);
#line 207
  my_outb((u_short )(smb_base___0 + 5), (u_char )(value & 255));
#line 207
  my_outb((unsigned short)235, (unsigned char)0);
#line 207
  my_outb((unsigned short)235, (unsigned char)0);
#line 208
  my_outb((u_short )(smb_base___0 + 6), (u_char )(value >> 8));
#line 208
  my_outb((unsigned short)235, (unsigned char)0);
#line 208
  my_outb((unsigned short)235, (unsigned char)0);
#line 209
  my_outb((u_short )(smb_base___0 + 2), (unsigned char)76);
#line 210
  my_outb((unsigned short)235, (unsigned char)0);
#line 210
  my_outb((unsigned short)235, (unsigned char)0);
#line 212
  i = 0;
  }
  {
#line 212
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 212
    if (! (i < 8192)) {
#line 212
      goto while_break___0;
    }
    {
#line 213
    dat = my_inb((u_short )smb_base___0);
#line 213
    my_outb((unsigned short)235, (unsigned char)0);
#line 213
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 214
    if (! ((int )dat & 1)) {
#line 214
      if ((int )dat & 6) {
#line 215
        goto while_break___0;
      }
    }
#line 212
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 217
  if ((int )dat & 2) {
#line 218
    return (0);
  } else {
#line 220
    return (-1);
  }
}
}
#line 47 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_gl52.c"
static int gl52chipid___0  =    0;
#line 48 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_gl52.c"
static int gl52_mode___0  =    1;
#line 49 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_gl52.c"
static int temp_offset___0  =    130;
#line 51
static int gl52_probe___0(LM_METHODS *method___1 ) ;
#line 52
static float gl52_temp___0(LM_METHODS *method___1 , int no ) ;
#line 53
static int gl52_fanrpm___0(LM_METHODS *method___1 , int no ) ;
#line 54
static float gl52_volt___0(LM_METHODS *method___1 , int no ) ;
#line 57 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_gl52.c"
static char buff___8[128]  ;
#line 75 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_gl52.c"
static char *gl52chip___0[5]  = {      (char *)"No Sensor",      (char *)"GL518SM_rev00",      (char *)"GL518SM_rev80",      (char *)"GL520SM", 
        (char *)((void *)0)};
#line 86 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_gl52.c"
static int chkReg___12[25]  = 
#line 86
  {      0,      1,      2,      3, 
        4,      5,      6,      7, 
        8,      9,      10,      11, 
        12,      13,      14,      15, 
        16,      17,      18,      19, 
        20,      21,      22,      23, 
        -1};
#line 99 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_gl52.c"
static int gl52_probe___0(LM_METHODS *method___1 ) 
{ 
  int n ;
  int id ;
  int save ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 103
  if ((unsigned long )method___1 != (unsigned long )(& method_smb)) {
#line 104
    return (0);
  }
#line 106
  save = smb_slave;
#line 108
  n = 88;
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    if (! (n <= 90)) {
#line 108
      goto while_break;
    }
    {
#line 109
    smb_slave = get_smb_slave(n, 90);
    }
#line 109
    if (smb_slave) {
      {
#line 112
      id = (*(method___1->Read))(0);
      }
#line 113
      if (id == 32) {
#line 113
        goto _L;
      } else
#line 113
      if (id == 128) {
        _L: /* CIL Label */ 
        {
#line 113
        tmp = chkReg_Probe(smb_slave, (char *)"Probing GL518SM/GL520SM chip:\n", chkReg___12,
                           method___1);
        }
#line 113
        if (tmp >= 10) {
#line 117
          goto ret1;
        } else {
#line 119
          n = smb_slave + 2;
        }
      } else {
#line 119
        n = smb_slave + 2;
      }
    } else {
#line 110
      goto ret0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  ret0: 
#line 124
  smb_slave = save;
#line 125
  return (0);
  ret1: 
  {
#line 127
  kill_smb_slave(smb_slave);
#line 128
  strcpy((char */* __restrict  */)(buff___8), (char const   */* __restrict  */)"Genesys Logic ");
  }
#line 129
  if (id == 32) {
    {
#line 130
    gl52chipid___0 = 3;
#line 131
    temp_offset___0 = 130;
#line 132
    tmp___0 = (*(method___1->Read))(3);
    }
#line 132
    if (tmp___0 & 16) {
#line 133
      gl52_mode___0 = 2;
    }
  } else {
    {
#line 135
    tmp___1 = (*(method___1->Read))(1);
    }
#line 135
    if (tmp___1 == 128) {
#line 136
      gl52chipid___0 = 2;
    } else {
#line 138
      gl52chipid___0 = 1;
    }
#line 139
    temp_offset___0 = 119;
  }
  {
#line 141
  strcat((char */* __restrict  */)(buff___8), (char const   */* __restrict  */)gl52chip___0[gl52chipid___0]);
  }
#line 143
  return (gl52chipid___0);
}
}
#line 152 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_gl52.c"
static float gl52_temp___0(LM_METHODS *method___1 , int no ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 154
  if (no < 0) {
#line 155
    return ((float )65535);
  } else
#line 154
  if (2 < no) {
#line 155
    return ((float )65535);
  }
#line 157
  if (no == 0) {
    {
#line 158
    tmp = (*(method___1->Read))(4);
    }
#line 158
    return ((float )(tmp - temp_offset___0));
  } else
#line 159
  if (no == 1) {
#line 159
    if (gl52chipid___0 == 3) {
#line 159
      if (gl52_mode___0 == 1) {
        {
#line 160
        tmp___0 = (*(method___1->Read))(14);
        }
#line 160
        return ((float )(tmp___0 - temp_offset___0));
      } else {
#line 162
        return ((float )65535);
      }
    } else {
#line 162
      return ((float )65535);
    }
  } else {
#line 162
    return ((float )65535);
  }
}
}
#line 170 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_gl52.c"
static float gl52_volt___0(LM_METHODS *method___1 , int no ) 
{ 
  float facp12 ;
  float facn12 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 172
  facp12 = (float )(1200. / 286.);
#line 173
  facn12 = (float )(- 1200. / 160.);
#line 175
  if (no < 0) {
#line 176
    return ((float )65535);
  } else
#line 175
  if (6 < no) {
#line 176
    return ((float )65535);
  }
#line 178
  if (no > 0) {
#line 178
    if (gl52chipid___0 == 1) {
#line 180
      return ((float )65535);
    } else {
#line 178
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 178
  if (no > 4) {
#line 178
    if (gl52chipid___0 == 2) {
#line 180
      return ((float )65535);
    }
  }
  {
#line 183
  if (no == 0) {
#line 183
    goto case_0;
  }
#line 185
  if (no == 1) {
#line 185
    goto case_1;
  }
#line 187
  if (no == 2) {
#line 187
    goto case_2;
  }
#line 189
  if (no == 3) {
#line 189
    goto case_3;
  }
#line 191
  if (no == 4) {
#line 191
    goto case_4;
  }
#line 193
  if (no == 5) {
#line 193
    goto case_5;
  }
#line 198
  if (no == 6) {
#line 198
    goto case_6;
  }
#line 200
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 184
  tmp = (*(method___1->Read))(13);
  }
#line 184
  return ((float )((double )((float )tmp) * 0.019));
  case_1: /* CIL Label */ 
#line 186
  return ((float )0.0);
  case_2: /* CIL Label */ 
  {
#line 188
  tmp___0 = (*(method___1->Read))(20);
  }
#line 188
  return ((float )((double )((float )tmp___0) * 0.019));
  case_3: /* CIL Label */ 
  {
#line 190
  tmp___1 = (*(method___1->Read))(21);
  }
#line 190
  return ((float )((double )((float )tmp___1) * 0.023));
  case_4: /* CIL Label */ 
  {
#line 192
  tmp___2 = (*(method___1->Read))(19);
  }
#line 192
  return ((float )(((double )((float )tmp___2) * 0.019) * (double )facp12));
  case_5: /* CIL Label */ 
#line 194
  if (gl52_mode___0 == 2) {
    {
#line 195
    tmp___3 = (*(method___1->Read))(14);
    }
#line 195
    return ((float )(((double )((float )tmp___3) * 0.019) * (double )facn12));
  } else {
#line 197
    return ((float )0.0);
  }
  case_6: /* CIL Label */ 
#line 199
  return ((float )0.0);
  switch_default: /* CIL Label */ 
#line 201
  return ((float )65535);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 229 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_gl52.c"
static int div___8[2]  = {      3,      3};
#line 225 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_gl52.c"
static int gl52_fanrpm___0(LM_METHODS *method___1 , int no ) 
{ 
  int p ;
  int r ;
  int n ;

  {
#line 227
  p = 2;
#line 231
  if (no < 0) {
#line 232
    return (65535);
  } else
#line 231
  if (1 < no) {
#line 232
    return (65535);
  }
  {
#line 234
  n = (*(method___1->Read))(15);
#line 235
  div___8[0] = n >> 6;
#line 236
  div___8[1] = (n >> 4) & 3;
#line 238
  r = (*(method___1->ReadW))(7);
  }
#line 239
  if (no == 0) {
#line 240
    r &= 255;
  } else {
#line 242
    r >>= 8;
  }
#line 244
  if (r == 255) {
#line 246
    if (div___8[no] < 3) {
#line 247
      (div___8[no]) ++;
    } else {
#line 249
      div___8[no] = 0;
    }
    {
#line 250
    r = ((n & 15) | (div___8[0] << 6)) | (div___8[1] << 4);
#line 251
    (*(method___1->Write))(15, r);
    }
#line 252
    return (65535);
  } else
#line 253
  if (r == 0) {
#line 254
    return (65535);
  }
#line 257
  return (960000 / ((r * (1 << div___8[no])) * p));
}
}
#line 56 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm80.c"
static int lm80_probe___1(LM_METHODS *method___1 ) ;
#line 57
static float lm80_temp___1(LM_METHODS *method___1 , int no ) ;
#line 58
static int lm80_fanrpm___1(LM_METHODS *method___1 , int no ) ;
#line 59
static float lm80_volt___1(LM_METHODS *method___1 , int no ) ;
#line 77 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm80.c"
static int chkReg___13[27]  = 
#line 77
  {      0,      1,      2,      4, 
        5,      6,      32,      33, 
        34,      36,      37,      38, 
        39,      40,      41,      43, 
        45,      47,      49,      51, 
        53,      55,      57,      59, 
        60,      61,      -1};
#line 91 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm80.c"
static int lm80_probe___1(LM_METHODS *method___1 ) 
{ 
  int n ;
  int dat ;
  int reg ;
  int save ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 95
  if ((unsigned long )method___1 != (unsigned long )(& method_smb)) {
#line 96
    return (0);
  }
#line 98
  save = smb_slave;
#line 100
  n = 80;
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! (n <= 94)) {
#line 100
      goto while_break;
    }
    {
#line 101
    smb_slave = get_smb_slave(n, 94);
    }
#line 101
    if (smb_slave) {
      {
#line 104
      tmp = (*(method___1->Read))(2);
      }
#line 104
      if (tmp & 192) {
#line 105
        n = smb_slave + 2;
#line 106
        goto __Cont;
      }
#line 108
      reg = 42;
      {
#line 108
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 108
        if (! (reg <= 61)) {
#line 108
          goto while_break___0;
        }
        {
#line 109
        dat = (*(method___1->Read))(reg);
#line 110
        tmp___0 = (*(method___1->Read))(reg + 64);
        }
#line 110
        if (tmp___0 != dat) {
#line 113
          goto while_break___0;
        } else {
          {
#line 110
          tmp___1 = (*(method___1->Read))(reg + 128);
          }
#line 110
          if (tmp___1 != dat) {
#line 113
            goto while_break___0;
          } else {
            {
#line 110
            tmp___2 = (*(method___1->Read))(reg + 192);
            }
#line 110
            if (tmp___2 != dat) {
#line 113
              goto while_break___0;
            }
          }
        }
#line 108
        reg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 115
      if (reg > 61) {
        {
#line 115
        tmp___3 = chkReg_Probe(smb_slave, (char *)"Probing LM80 chip:\n", chkReg___13,
                               method___1);
        }
#line 115
        if (tmp___3 >= 20) {
#line 118
          goto ret1;
        } else {
#line 120
          n = smb_slave + 2;
        }
      } else {
#line 120
        n = smb_slave + 2;
      }
    } else {
#line 102
      goto ret0;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  ret0: 
#line 125
  smb_slave = save;
#line 126
  return (0);
  ret1: 
  {
#line 128
  tmp___4 = (*(method___1->Read))(0);
  }
#line 128
  if ((tmp___4 & 1) == 0) {
    {
#line 129
    (*(method___1->Write))(0, 16);
#line 130
    (*(method___1->Write))(0, 1);
    }
  }
  {
#line 133
  tmp___5 = (*(method___1->Read))(5);
#line 133
  (*(method___1->Write))(5, (tmp___5 & 60) | 64);
#line 135
  (*(method___1->Write))(6, 10);
#line 142
  kill_smb_slave(smb_slave);
  }
#line 143
  return (1);
}
}
#line 152 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm80.c"
static float lm80_temp___1(LM_METHODS *method___1 , int no ) 
{ 
  int reg ;
  int val ;
  int sft ;
  float ret ;

  {
#line 157
  if (no != 0) {
#line 158
    return ((float )65535);
  }
  {
#line 160
  reg = (*(method___1->Read))(6);
#line 161
  val = (*(method___1->Read))(39);
#line 163
  sft = ((reg & 8) >> 3) * 3 + 1;
#line 165
  val <<= sft;
#line 166
  val |= reg >> (8 - sft);
#line 168
  ret = (float )val;
  }
#line 169
  if (reg & 8) {
#line 170
    ret = (float )((double )ret * 0.0625);
  } else {
#line 172
    ret = (float )((double )ret * 0.5);
  }
#line 174
  return (ret);
}
}
#line 183 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm80.c"
static float lm80_volt___1(LM_METHODS *method___1 , int no ) 
{ 
  float r1[7] ;
  float r2[7] ;
  float vout ;
  float val ;
  int tmp ;

  {
#line 185
  r1[0] = (float )23.7;
#line 185
  r1[1] = (float )23.7;
#line 185
  r1[2] = (float )22.1;
#line 185
  r1[3] = (float )24;
#line 185
  r1[4] = (float )160;
#line 185
  r1[5] = (float )27;
#line 185
  r1[6] = (float )180;
#line 186
  r2[0] = (float )75;
#line 186
  r2[1] = (float )75;
#line 186
  r2[2] = (float )30;
#line 186
  r2[3] = (float )14.7;
#line 186
  r2[4] = (float )30.1;
#line 186
  r2[5] = (float )3.4;
#line 186
  r2[6] = (float )42.2;
#line 189
  if (no < 0) {
#line 190
    return ((float )65535);
  } else
#line 189
  if (6 < no) {
#line 190
    return ((float )65535);
  }
  {
#line 192
  tmp = (*(method___1->Read))(32 + no);
#line 192
  vout = (float )tmp;
#line 193
  vout = (float )((double )vout * 0.01);
#line 199
  val = (vout * (r1[no] + r2[no])) / r2[no];
  }
#line 200
  if (no >= 5) {
#line 201
    val = (val - (float )5) * (float )-1;
  }
#line 206
  return (val);
}
}
#line 217 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm80.c"
static int lm80_fanrpm___1(LM_METHODS *method___1 , int no ) 
{ 
  int reg ;
  int val ;
  int div___11 ;
  int sft ;
  long rpm ;

  {
#line 226
  if (no < 0) {
#line 227
    return (65535);
  } else
#line 226
  if (1 < no) {
#line 227
    return (65535);
  }
  {
#line 229
  reg = (*(method___1->Read))(5);
#line 230
  val = (*(method___1->Read))(40 + no);
#line 234
  sft = (no + 1) * 2;
#line 235
  div___11 = (reg >> sft) & 3;
  }
#line 240
  if (val == 255) {
#line 241
    if (div___11 < 3) {
      {
#line 242
      reg += 1 << sft;
#line 243
      (*(method___1->Write))(5, reg);
      }
    }
#line 248
    return (65536);
  }
#line 254
  rpm = (long )(1350000 / (val * (1 << div___11)));
#line 255
  return ((int )rpm);
}
}
#line 38 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_via686.c"
static int via686_probe___0(LM_METHODS *method___1 ) ;
#line 39
static float via686_temp___0(LM_METHODS *method___1 , int no ) ;
#line 40
static int via686_fanrpm___0(LM_METHODS *method___1 , int no ) ;
#line 41
static float via686_volt___0(LM_METHODS *method___1 , int no ) ;
#line 55 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_via686.c"
static int chkReg___14[21]  = 
#line 55
  {      64,      65,      66,      67, 
        68,      71,      73,      75, 
        63,      20,      31,      32, 
        33,      34,      35,      36, 
        37,      38,      41,      43, 
        -1};
#line 67 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_via686.c"
static int via686_probe___0(LM_METHODS *method___1 ) 
{ 
  int n ;
  int save ;
  int tmp ;
  int tmp___0 ;

  {
#line 71
  if ((unsigned long )method___1 != (unsigned long )(& method_via)) {
#line 71
    if ((unsigned long )method___1 != (unsigned long )(& method_smb)) {
#line 72
      return (0);
    }
  }
#line 74
  if (pm_smb_detected != 2) {
#line 74
    if (pm_smb_detected != 1) {
#line 75
      return (0);
    }
  }
#line 77
  save = smb_slave;
#line 79
  if ((unsigned long )method___1 == (unsigned long )(& method_smb)) {
#line 80
    n = 80;
    {
#line 80
    while (1) {
      while_continue: /* CIL Label */ ;
#line 80
      if (! (n <= 94)) {
#line 80
        goto while_break;
      }
      {
#line 81
      smb_slave = get_smb_slave(n, 94);
      }
#line 81
      if (smb_slave) {
        {
#line 84
        tmp = chkReg_Probe(smb_slave, (char *)"Probing VIA686A/B chip:\n", chkReg___14,
                           method___1);
        }
#line 84
        if (tmp >= 5) {
#line 86
          goto ret1;
        } else {
#line 88
          n = smb_slave + 2;
        }
      } else {
#line 82
        goto ret0;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 92
    tmp___0 = chkReg_Probe(0, (char *)"Probing VIA686A/B chip:\n", chkReg___14, method___1);
    }
#line 92
    if (tmp___0 >= 5) {
#line 94
      goto ret1;
    }
  }
  ret0: 
#line 98
  smb_slave = save;
#line 99
  return (0);
  ret1: 
#line 101
  if ((unsigned long )method___1 == (unsigned long )(& method_smb)) {
    {
#line 102
    kill_smb_slave(smb_slave);
    }
  }
#line 103
  return (1);
}
}
#line 107 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_via686.c"
static float const   via686temp_tab___0[256]  = 
#line 107
  {      (float const   ).00,      (float const   ).00,      (float const   ).00,      (float const   ).00, 
        (float const   ).00,      (float const   ).00,      (float const   ).00,      (float const   ).00, 
        (float const   ).00,      (float const   ).00,      (float const   ).00,      (float const   ).00, 
        (float const   ).00,      (float const   ).00,      (float const   ).00,      (float const   )(- 50.00), 
        (float const   )(- 48.00),      (float const   )(- 46.09),      (float const   )(- 44.26),      (float const   )(- 42.52), 
        (float const   )(- 40.86),      (float const   )(- 39.28),      (float const   )(- 37.78),      (float const   )(- 36.35), 
        (float const   )(- 34.99),      (float const   )(- 33.70),      (float const   )(- 32.47),      (float const   )(- 31.31), 
        (float const   )(- 30.20),      (float const   )(- 29.15),      (float const   )(- 28.14),      (float const   )(- 27.18), 
        (float const   )(- 26.27),      (float const   )(- 25.39),      (float const   )(- 24.55),      (float const   )(- 23.73), 
        (float const   )(- 22.95),      (float const   )(- 22.18),      (float const   )(- 21.44),      (float const   )(- 20.70), 
        (float const   )(- 19.98),      (float const   )(- 19.27),      (float const   )(- 18.57),      (float const   )(- 17.87), 
        (float const   )(- 17.19),      (float const   )(- 16.51),      (float const   )(- 15.85),      (float const   )(- 15.20), 
        (float const   )(- 14.56),      (float const   )(- 13.93),      (float const   )(- 13.32),      (float const   )(- 12.72), 
        (float const   )(- 12.14),      (float const   )(- 11.58),      (float const   )(- 11.03),      (float const   )(- 10.50), 
        (float const   )(- 9.99),      (float const   )(- 9.50),      (float const   )(- 9.03),      (float const   )(- 8.57), 
        (float const   )(- 8.11),      (float const   )(- 7.67),      (float const   )(- 7.22),      (float const   )(- 6.77), 
        (float const   )(- 6.31),      (float const   )(- 5.85),      (float const   )(- 5.37),      (float const   )(- 4.87), 
        (float const   )(- 4.36),      (float const   )(- 3.81),      (float const   )(- 3.24),      (float const   )(- 2.64), 
        (float const   )(- 2.00),      (float const   )(- 1.33),      (float const   )(- .65),      (float const   ).00, 
        (float const   ).59,      (float const   )1.12,      (float const   )1.60,      (float const   )2.03, 
        (float const   )2.42,      (float const   )2.79,      (float const   )3.12,      (float const   )3.44, 
        (float const   )3.75,      (float const   )4.05,      (float const   )4.35,      (float const   )4.67, 
        (float const   )4.99,      (float const   )5.34,      (float const   )5.71,      (float const   )6.09, 
        (float const   )6.49,      (float const   )6.91,      (float const   )7.34,      (float const   )7.78, 
        (float const   )8.23,      (float const   )8.69,      (float const   )9.15,      (float const   )9.62, 
        (float const   )10.09,      (float const   )10.57,      (float const   )11.04,      (float const   )11.51, 
        (float const   )11.98,      (float const   )12.44,      (float const   )12.90,      (float const   )13.35, 
        (float const   )13.80,      (float const   )14.24,      (float const   )14.68,      (float const   )15.12, 
        (float const   )15.55,      (float const   )15.99,      (float const   )16.42,      (float const   )16.85, 
        (float const   )17.27,      (float const   )17.70,      (float const   )18.13,      (float const   )18.56, 
        (float const   )18.99,      (float const   )19.42,      (float const   )19.85,      (float const   )20.29, 
        (float const   )20.72,      (float const   )21.15,      (float const   )21.59,      (float const   )22.03, 
        (float const   )22.47,      (float const   )22.90,      (float const   )23.34,      (float const   )23.78, 
        (float const   )24.22,      (float const   )24.66,      (float const   )25.10,      (float const   )25.54, 
        (float const   )25.99,      (float const   )26.43,      (float const   )26.87,      (float const   )27.31, 
        (float const   )27.75,      (float const   )28.19,      (float const   )28.63,      (float const   )29.07, 
        (float const   )29.51,      (float const   )29.95,      (float const   )30.38,      (float const   )30.82, 
        (float const   )31.25,      (float const   )31.68,      (float const   )32.11,      (float const   )32.53, 
        (float const   )32.96,      (float const   )33.38,      (float const   )33.80,      (float const   )34.22, 
        (float const   )34.63,      (float const   )35.05,      (float const   )35.48,      (float const   )35.90, 
        (float const   )36.33,      (float const   )36.76,      (float const   )37.20,      (float const   )37.64, 
        (float const   )38.09,      (float const   )38.55,      (float const   )39.02,      (float const   )39.50, 
        (float const   )39.99,      (float const   )40.49,      (float const   )41.00,      (float const   )41.52, 
        (float const   )42.06,      (float const   )42.60,      (float const   )43.15,      (float const   )43.70, 
        (float const   )44.27,      (float const   )44.84,      (float const   )45.41,      (float const   )45.99, 
        (float const   )46.57,      (float const   )47.16,      (float const   )47.75,      (float const   )48.35, 
        (float const   )48.94,      (float const   )49.54,      (float const   )50.13,      (float const   )50.73, 
        (float const   )51.33,      (float const   )51.94,      (float const   )52.55,      (float const   )53.16, 
        (float const   )53.78,      (float const   )54.41,      (float const   )55.04,      (float const   )55.68, 
        (float const   )56.32,      (float const   )56.98,      (float const   )57.64,      (float const   )58.32, 
        (float const   )59.00,      (float const   )59.69,      (float const   )60.40,      (float const   )61.12, 
        (float const   )61.85,      (float const   )62.60,      (float const   )63.36,      (float const   )64.13, 
        (float const   )64.93,      (float const   )65.73,      (float const   )66.56,      (float const   )67.40, 
        (float const   )68.26,      (float const   )69.14,      (float const   )70.05,      (float const   )70.97, 
        (float const   )71.91,      (float const   )72.88,      (float const   )73.86,      (float const   )74.88, 
        (float const   )75.92,      (float const   )76.98,      (float const   )78.08,      (float const   )79.21, 
        (float const   )80.36,      (float const   )81.55,      (float const   )82.78,      (float const   )84.03, 
        (float const   )85.33,      (float const   )86.66,      (float const   )88.04,      (float const   )89.45, 
        (float const   )90.90,      (float const   )92.40,      (float const   )93.94,      (float const   )95.53, 
        (float const   )97.16,      (float const   )98.85,      (float const   )100.58,      (float const   )102.36, 
        (float const   )104.19,      (float const   )106.07,      (float const   )108.01,      (float const   )110.00, 
        (float const   ).00,      (float const   ).00,      (float const   ).00,      (float const   ).00, 
        (float const   ).00,      (float const   ).00,      (float const   ).00,      (float const   ).00, 
        (float const   ).00,      (float const   ).00,      (float const   ).00,      (float const   ).00};
#line 147 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_via686.c"
static float via686_temp___0(LM_METHODS *method___1 , int no ) 
{ 
  int tmp ;

  {
#line 149
  if (no < 0) {
#line 150
    return ((float )65535);
  } else
#line 149
  if (2 < no) {
#line 150
    return ((float )65535);
  }
  {
#line 152
  tmp = (*(method___1->Read))(31 + no);
  }
#line 152
  return ((float )via686temp_tab___0[tmp]);
}
}
#line 160 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_via686.c"
static float via686_volt___0(LM_METHODS *method___1 , int no ) 
{ 
  int n ;
  float fac ;

  {
#line 165
  if (no < 0) {
#line 166
    return ((float )65535);
  } else
#line 165
  if (4 < no) {
#line 166
    return ((float )65535);
  }
  {
#line 170
  if (no == 1) {
#line 170
    goto case_1;
  }
#line 170
  if (no == 0) {
#line 170
    goto case_1;
  }
#line 173
  if (no == 2) {
#line 173
    goto case_2;
  }
#line 176
  if (no == 3) {
#line 176
    goto case_3;
  }
#line 179
  if (no == 4) {
#line 179
    goto case_4;
  }
#line 168
  goto switch_break;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 171
  fac = (float )(5. / 10512.);
#line 172
  goto switch_break;
  case_2: /* CIL Label */ 
#line 174
  fac = (float )(5. / 7884.);
#line 175
  goto switch_break;
  case_3: /* CIL Label */ 
#line 177
  fac = (float )(26. / 26280.);
#line 178
  goto switch_break;
  case_4: /* CIL Label */ 
#line 180
  fac = (float )(63. / 26280.);
  switch_break: /* CIL Label */ ;
  }
  {
#line 183
  n = (*(method___1->Read))(34 + no);
  }
#line 183
  if (n <= 64) {
#line 184
    n |= 256;
  }
#line 186
  return ((float )(n * 25 + 133) * fac);
}
}
#line 210 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_via686.c"
static int div___9[2]  = {      1,      1};
#line 207 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_via686.c"
static int via686_fanrpm___0(LM_METHODS *method___1 , int no ) 
{ 
  int r ;
  int n ;

  {
#line 212
  if (no < 0) {
#line 213
    return (65535);
  } else
#line 212
  if (1 < no) {
#line 213
    return (65535);
  }
  {
#line 215
  n = (*(method___1->Read))(71);
#line 216
  div___9[0] = (n >> 4) & 3;
#line 217
  div___9[1] = n >> 6;
#line 219
  r = (*(method___1->Read))(41 + no);
  }
#line 220
  if (r == 255) {
#line 222
    if (div___9[no] < 3) {
#line 223
      (div___9[no]) ++;
    } else {
#line 225
      div___9[no] = 0;
    }
    {
#line 226
    r = ((n & 15) | (div___9[0] << 4)) | (div___9[1] << 6);
#line 227
    (*(method___1->Write))(71, r);
    }
#line 228
    return (65535);
  } else
#line 229
  if (r == 0) {
#line 230
    return (65535);
  }
#line 233
  return (1350000 / (r * (1 << div___9[no])));
}
}
#line 59 "/home/wheatley/newnew/temp/xmbmon-2.05/getMBinfo.c"
static LM_METHODS *this_method___0  =    (LM_METHODS *)((void *)0);
#line 60 "/home/wheatley/newnew/temp/xmbmon-2.05/getMBinfo.c"
static SENSOR *this_sensor___0  =    (SENSOR *)((void *)0);
#line 61 "/home/wheatley/newnew/temp/xmbmon-2.05/getMBinfo.c"
static int probe_flag___0  =    2002;
#line 62 "/home/wheatley/newnew/temp/xmbmon-2.05/getMBinfo.c"
static int HWM_firstSMB_flag___0  =    0;
#line 63 "/home/wheatley/newnew/temp/xmbmon-2.05/getMBinfo.c"
static char method___0  ;
#line 78 "/home/wheatley/newnew/temp/xmbmon-2.05/smbus_amd8.c"
static int readbyte___7(int smb_base___0 , int addr , int cmd ) 
{ 
  u_char dat ;
  u_char saddr ;
  int i ;

  {
#line 80
  dat = (u_char )0;
#line 80
  saddr = (u_char )(2 * (addr / 2) + 1);
  top: 
  {
#line 84
  my_outb((u_short )(smb_base___0 + 2), saddr);
#line 84
  my_outb((unsigned short)235, (unsigned char)0);
#line 84
  my_outb((unsigned short)235, (unsigned char)0);
#line 85
  my_outb((u_short )(smb_base___0 + 3), (u_char )cmd);
#line 85
  my_outb((unsigned short)235, (unsigned char)0);
#line 85
  my_outb((unsigned short)235, (unsigned char)0);
#line 86
  my_outb((u_short )smb_base___0, (unsigned char)7);
#line 86
  my_outb((unsigned short)235, (unsigned char)0);
#line 86
  my_outb((unsigned short)235, (unsigned char)0);
#line 88
  i = 0;
  }
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! (i < 32)) {
#line 88
      goto while_break;
    }
    {
#line 89
    my_outb((unsigned short)235, (unsigned char)0);
#line 88
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  i = 0;
  {
#line 91
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 91
    if (! (i < 8192)) {
#line 91
      goto while_break___0;
    }
    {
#line 92
    dat = my_inb((u_short )(smb_base___0 + 1));
#line 92
    my_outb((unsigned short)235, (unsigned char)0);
#line 92
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 96
    if ((int )dat == 26) {
#line 97
      goto top;
    } else
#line 96
    if ((int )dat == 24) {
#line 97
      goto top;
    }
#line 98
    if ((int )dat & 159) {
#line 99
      goto while_break___0;
    }
#line 91
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 107
  if ((int )dat == 128) {
    {
#line 108
    dat = my_inb((u_short )(smb_base___0 + 4));
#line 108
    my_outb((unsigned short)235, (unsigned char)0);
#line 108
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 113
    return ((int )dat & 255);
  } else {
#line 115
    return (-1);
  }
}
}
#line 118 "/home/wheatley/newnew/temp/xmbmon-2.05/smbus_amd8.c"
static int readword___5(int smb_base___0 , int addr , int cmd ) 
{ 
  u_char dat ;
  u_char saddr ;
  int i ;
  unsigned char tmp ;

  {
#line 120
  dat = (u_char )0;
#line 120
  saddr = (u_char )(2 * (addr / 2) + 1);
  top: 
  {
#line 124
  my_outb((u_short )(smb_base___0 + 2), saddr);
#line 124
  my_outb((unsigned short)235, (unsigned char)0);
#line 124
  my_outb((unsigned short)235, (unsigned char)0);
#line 125
  my_outb((u_short )(smb_base___0 + 3), (u_char )cmd);
#line 125
  my_outb((unsigned short)235, (unsigned char)0);
#line 125
  my_outb((unsigned short)235, (unsigned char)0);
#line 126
  my_outb((u_short )smb_base___0, (unsigned char)9);
#line 126
  my_outb((unsigned short)235, (unsigned char)0);
#line 126
  my_outb((unsigned short)235, (unsigned char)0);
#line 128
  i = 0;
  }
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    if (! (i < 32)) {
#line 128
      goto while_break;
    }
    {
#line 129
    my_outb((unsigned short)235, (unsigned char)0);
#line 128
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  i = 0;
  {
#line 131
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 131
    if (! (i < 8192)) {
#line 131
      goto while_break___0;
    }
    {
#line 132
    dat = my_inb((u_short )(smb_base___0 + 1));
#line 132
    my_outb((unsigned short)235, (unsigned char)0);
#line 132
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 133
    if ((int )dat == 26) {
#line 134
      goto top;
    } else
#line 133
    if ((int )dat == 24) {
#line 134
      goto top;
    }
#line 135
    if ((int )dat & 159) {
#line 136
      goto while_break___0;
    }
#line 131
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 144
  if ((int )dat == 128) {
    {
#line 145
    tmp = my_inb((u_short )(smb_base___0 + 5));
#line 145
    i = (int )tmp;
#line 145
    my_outb((unsigned short)235, (unsigned char)0);
#line 145
    my_outb((unsigned short)235, (unsigned char)0);
#line 146
    dat = my_inb((u_short )(smb_base___0 + 4));
#line 146
    my_outb((unsigned short)235, (unsigned char)0);
#line 146
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 151
    return (((i << 8) + (int )dat) & 65535);
  } else {
#line 153
    return (-1);
  }
}
}
#line 156 "/home/wheatley/newnew/temp/xmbmon-2.05/smbus_amd8.c"
static int writebyte___7(int smb_base___0 , int addr , int cmd , int value ) 
{ 
  u_char dat ;
  u_char saddr ;
  int i ;

  {
#line 158
  dat = (u_char )0;
#line 158
  saddr = (u_char )(2 * (addr / 2) + 1);
  top: 
  {
#line 162
  my_outb((u_short )(smb_base___0 + 2), saddr);
#line 162
  my_outb((unsigned short)235, (unsigned char)0);
#line 162
  my_outb((unsigned short)235, (unsigned char)0);
#line 163
  my_outb((u_short )(smb_base___0 + 3), (u_char )cmd);
#line 163
  my_outb((unsigned short)235, (unsigned char)0);
#line 163
  my_outb((unsigned short)235, (unsigned char)0);
#line 164
  my_outb((u_short )(smb_base___0 + 4), (u_char )value);
#line 164
  my_outb((unsigned short)235, (unsigned char)0);
#line 164
  my_outb((unsigned short)235, (unsigned char)0);
#line 165
  my_outb((u_short )smb_base___0, (unsigned char)6);
#line 165
  my_outb((unsigned short)235, (unsigned char)0);
#line 165
  my_outb((unsigned short)235, (unsigned char)0);
#line 167
  i = 0;
  }
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! (i < 32)) {
#line 167
      goto while_break;
    }
    {
#line 168
    my_outb((unsigned short)235, (unsigned char)0);
#line 167
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  i = 0;
  {
#line 170
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 170
    if (! (i < 8192)) {
#line 170
      goto while_break___0;
    }
    {
#line 171
    dat = my_inb((u_short )(smb_base___0 + 1));
#line 171
    my_outb((unsigned short)235, (unsigned char)0);
#line 171
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 175
    if ((int )dat == 26) {
#line 176
      goto top;
    } else
#line 175
    if ((int )dat == 24) {
#line 176
      goto top;
    }
#line 177
    if ((int )dat & 159) {
#line 178
      goto while_break___0;
    }
#line 170
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 186
  if ((int )dat == 128) {
#line 187
    return (0);
  } else {
#line 189
    return (-1);
  }
}
}
#line 192 "/home/wheatley/newnew/temp/xmbmon-2.05/smbus_amd8.c"
static int writeword___5(int smb_base___0 , int addr , int cmd , int value ) 
{ 
  u_char dat ;
  u_char saddr ;
  int i ;

  {
#line 194
  dat = (u_char )0;
#line 194
  saddr = (u_char )(2 * (addr / 2) + 1);
  top: 
  {
#line 198
  my_outb((u_short )(smb_base___0 + 2), saddr);
#line 198
  my_outb((unsigned short)235, (unsigned char)0);
#line 198
  my_outb((unsigned short)235, (unsigned char)0);
#line 199
  my_outb((u_short )(smb_base___0 + 3), (u_char )cmd);
#line 199
  my_outb((unsigned short)235, (unsigned char)0);
#line 199
  my_outb((unsigned short)235, (unsigned char)0);
#line 200
  my_outb((u_short )(smb_base___0 + 4), (u_char )(value & 255));
#line 200
  my_outb((unsigned short)235, (unsigned char)0);
#line 200
  my_outb((unsigned short)235, (unsigned char)0);
#line 201
  my_outb((u_short )(smb_base___0 + 5), (u_char )(value >> 8));
#line 201
  my_outb((unsigned short)235, (unsigned char)0);
#line 201
  my_outb((unsigned short)235, (unsigned char)0);
#line 202
  my_outb((u_short )smb_base___0, (unsigned char)8);
#line 202
  my_outb((unsigned short)235, (unsigned char)0);
#line 202
  my_outb((unsigned short)235, (unsigned char)0);
#line 204
  i = 0;
  }
  {
#line 204
  while (1) {
    while_continue: /* CIL Label */ ;
#line 204
    if (! (i < 32)) {
#line 204
      goto while_break;
    }
    {
#line 205
    my_outb((unsigned short)235, (unsigned char)0);
#line 204
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 207
  i = 0;
  {
#line 207
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 207
    if (! (i < 8192)) {
#line 207
      goto while_break___0;
    }
    {
#line 208
    dat = my_inb((u_short )(smb_base___0 + 1));
#line 208
    my_outb((unsigned short)235, (unsigned char)0);
#line 208
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 209
    if ((int )dat == 26) {
#line 210
      goto top;
    } else
#line 209
    if ((int )dat == 24) {
#line 210
      goto top;
    }
#line 211
    if ((int )dat & 159) {
#line 212
      goto while_break___0;
    }
#line 207
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 220
  if ((int )dat == 128) {
#line 221
    return (0);
  } else {
#line 223
    return (-1);
  }
}
}
#line 46 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_it87.c"
static int it87_probe___0(LM_METHODS *method___1 ) ;
#line 47
static float it87_temp___0(LM_METHODS *method___1 , int no ) ;
#line 48
static int it87_fanrpm___0(LM_METHODS *method___1 , int no ) ;
#line 49
static float it87_volt___0(LM_METHODS *method___1 , int no ) ;
#line 63 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_it87.c"
static int chkReg___15[25]  = 
#line 63
  {      0,      1,      2,      3, 
        10,      72,      80,      81, 
        32,      33,      34,      35, 
        36,      37,      38,      39, 
        40,      41,      42,      43, 
        11,      13,      14,      15, 
        -1};
#line 76 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_it87.c"
static int it87_probe___0(LM_METHODS *method___1 ) 
{ 
  int n ;
  int save ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 80
  if ((unsigned long )method___1 != (unsigned long )(& method_isa)) {
#line 80
    if ((unsigned long )method___1 != (unsigned long )(& method_smb)) {
#line 81
      return (0);
    }
  }
#line 83
  save = smb_slave;
#line 85
  if ((unsigned long )method___1 == (unsigned long )(& method_smb)) {
#line 86
    n = 80;
    {
#line 86
    while (1) {
      while_continue: /* CIL Label */ ;
#line 86
      if (! (n <= 94)) {
#line 86
        goto while_break;
      }
      {
#line 87
      smb_slave = get_smb_slave(n, 94);
      }
#line 87
      if (smb_slave) {
        {
#line 89
        tmp___1 = (*(method___1->Read))(72);
        }
#line 89
        if (smb_slave != 2 * tmp___1) {
#line 90
          goto ret0;
        } else {
          {
#line 92
          tmp = (*(method___1->Read))(88);
          }
#line 92
          if (tmp == 144) {
            {
#line 92
            tmp___0 = chkReg_Probe(smb_slave, (char *)"Probing ITE7805/7812/SIS950 chip:\n",
                                   chkReg___15, method___1);
            }
#line 92
            if (tmp___0 >= 8) {
#line 96
              goto ret1;
            } else {
#line 98
              n = smb_slave + 2;
            }
          } else {
#line 98
            n = smb_slave + 2;
          }
        }
      } else {
#line 88
        goto ret0;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 101
    goto ret0;
  } else {
    {
#line 103
    tmp___2 = (*(method___1->Read))(88);
    }
#line 103
    if (tmp___2 == 144) {
      {
#line 103
      tmp___3 = chkReg_Probe(0, (char *)"Probing ITE7805/7812/SIS950 chip:\n", chkReg___15,
                             method___1);
      }
#line 103
      if (tmp___3 >= 8) {
#line 106
        goto ret1;
      }
    }
  }
  ret0: 
#line 110
  smb_slave = save;
#line 111
  return (0);
  ret1: 
#line 113
  if ((unsigned long )method___1 == (unsigned long )(& method_smb)) {
    {
#line 114
    kill_smb_slave(smb_slave);
    }
  }
#line 115
  return (1);
}
}
#line 124 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_it87.c"
static float it87_temp___0(LM_METHODS *method___1 , int no ) 
{ 
  int tmp ;

  {
#line 126
  if (no < 0) {
#line 127
    return ((float )65535);
  } else
#line 126
  if (2 < no) {
#line 127
    return ((float )65535);
  }
  {
#line 129
  tmp = (*(method___1->Read))(41 + no);
  }
#line 129
  return ((float )tmp);
}
}
#line 137 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_it87.c"
static float it87_volt___0(LM_METHODS *method___1 , int no ) 
{ 
  float fac ;
  int tmp ;

  {
#line 141
  if (no < 0) {
#line 142
    return ((float )65535);
  } else
#line 141
  if (6 < no) {
#line 142
    return ((float )65535);
  }
  {
#line 147
  if (no == 2) {
#line 147
    goto case_2;
  }
#line 147
  if (no == 1) {
#line 147
    goto case_2;
  }
#line 147
  if (no == 0) {
#line 147
    goto case_2;
  }
#line 150
  if (no == 3) {
#line 150
    goto case_3;
  }
#line 153
  if (no == 4) {
#line 153
    goto case_4;
  }
#line 156
  if (no == 5) {
#line 156
    goto case_5;
  }
#line 159
  if (no == 6) {
#line 159
    goto case_6;
  }
#line 144
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 148
  fac = (float )0.016;
#line 149
  goto switch_break;
  case_3: /* CIL Label */ 
#line 151
  fac = (float )(0.016 * 1.68);
#line 152
  goto switch_break;
  case_4: /* CIL Label */ 
#line 154
  fac = (float )(0.016 * 3.80);
#line 155
  goto switch_break;
  case_5: /* CIL Label */ 
#line 157
  fac = (float )(- 0.016 * 3.477);
#line 158
  goto switch_break;
  case_6: /* CIL Label */ 
#line 160
  fac = (float )(- 0.016 * 1.505);
  switch_break: /* CIL Label */ ;
  }
  {
#line 163
  tmp = (*(method___1->Read))(32 + no);
  }
#line 163
  return ((float )tmp * fac);
}
}
#line 189 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_it87.c"
static int div___10[3]  = {      1,      1,      1};
#line 186 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_it87.c"
static int it87_fanrpm___0(LM_METHODS *method___1 , int no ) 
{ 
  int r ;
  int n ;

  {
#line 191
  if (no < 0) {
#line 192
    return (65535);
  } else
#line 191
  if (2 < no) {
#line 192
    return (65535);
  }
  {
#line 194
  n = (*(method___1->Read))(11);
#line 195
  div___10[0] = n & 7;
#line 196
  div___10[1] = (n >> 3) & 7;
#line 198
  r = (*(method___1->Read))(13 + no);
  }
#line 199
  if (r == 255) {
#line 201
    if (no != 2) {
#line 202
      if (div___10[no] < 7) {
#line 203
        (div___10[no]) ++;
      } else {
#line 205
        div___10[no] = 0;
      }
      {
#line 206
      r = ((n & 63) | div___10[0]) | (div___10[1] << 3);
#line 207
      (*(method___1->Write))(11, r);
      }
    }
#line 209
    return (65535);
  } else
#line 210
  if (r == 0) {
#line 211
    return (65535);
  }
#line 214
  return (1350000 / (r * (1 << div___10[no])));
}
}
#line 5 "/home/wheatley/newnew/temp/xmbmon-2.05/io_static.c"
static int OpenIO___8(void) 
{ 
  int tmp ;

  {
#line 7
  if (iopl_counter == 0) {
    {
#line 8
    tmp = iopl(3);
    }
#line 8
    if (tmp < 0) {
#line 9
      return (-1);
    }
  }
#line 11
  iopl_counter ++;
#line 12
  return (0);
}
}
#line 15 "/home/wheatley/newnew/temp/xmbmon-2.05/io_static.c"
static void CloseIO___8(void) 
{ 


  {
#line 17
  if (iopl_counter == 1) {
    {
#line 18
    iopl(0);
    }
  }
#line 19
  if (iopl_counter > 0) {
#line 20
    iopl_counter --;
  }
#line 21
  return;
}
}
#line 40 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-smb.c"
static int ReadByte___4(int addr ) 
{ 
  int ret ;

  {
  {
#line 43
  ret = (*(smbus->ReadB))(smb_base, smb_slave, addr);
  }
#line 44
  if (ret == -1) {
#line 47
    ret = 255;
  }
#line 49
  return (ret & 255);
}
}
#line 52 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-smb.c"
static void WriteByte___4(int addr , int value ) 
{ 
  int tmp ;

  {
  {
#line 54
  tmp = (*(smbus->WriteB))(smb_base, smb_slave, addr, value);
  }
#line 54
  if (tmp == -1) {
    {
#line 55
    perror("SMBus WriteB");
#line 56
    exit(-1);
    }
  }
#line 58
  return;
}
}
#line 60 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-smb.c"
static int ReadWord___4(int addr ) 
{ 
  int ret ;

  {
  {
#line 63
  ret = (*(smbus->ReadW))(smb_base, smb_slave, addr);
  }
#line 64
  if (ret == -1) {
#line 67
    ret = 65535;
  }
#line 69
  return (ret & 65535);
}
}
#line 72 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-smb.c"
static void WriteWord___4(int addr , int value ) 
{ 
  int tmp ;

  {
  {
#line 74
  tmp = (*(smbus->WriteW))(smb_base, smb_slave, addr, value);
  }
#line 74
  if (tmp == -1) {
    {
#line 75
    perror("SMBus WriteW");
#line 76
    exit(-1);
    }
  }
#line 78
  return;
}
}
#line 80 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-smb.c"
static int ReadTemp1___4(void) 
{ 
  int ret ;

  {
  {
#line 83
  ret = (*(smbus->ReadW))(smb_base, smb_wbtemp1, smb_wbt1reg);
  }
#line 84
  if (ret == -1) {
#line 87
    ret = 65535;
  }
#line 89
  return (ret & 65535);
}
}
#line 91 "/home/wheatley/newnew/temp/xmbmon-2.05/getMB-smb.c"
static int ReadTemp2___4(void) 
{ 
  int ret ;

  {
  {
#line 94
  ret = (*(smbus->ReadW))(smb_base, smb_wbtemp2, smb_wbt2reg);
  }
#line 95
  if (ret == -1) {
#line 98
    ret = 65535;
  }
#line 100
  return (ret & 65535);
}
}
#line 72 "/home/wheatley/newnew/temp/xmbmon-2.05/smbus_ali.c"
static int readbyte___8(int smb_base___0 , int addr , int cmd ) 
{ 
  u_char dat ;
  u_char saddr ;
  int i ;

  {
#line 74
  saddr = (u_char )(2 * (addr / 2));
  top: 
#line 78
  i = 0;
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! (i < 8192)) {
#line 78
      goto while_break;
    }
    {
#line 79
    my_outb((u_short )smb_base___0, (unsigned char)255);
#line 79
    my_outb((unsigned short)235, (unsigned char)0);
#line 79
    my_outb((unsigned short)235, (unsigned char)0);
#line 80
    dat = my_inb((u_short )smb_base___0);
#line 80
    my_outb((unsigned short)235, (unsigned char)0);
#line 80
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 81
    if ((int )dat & 4) {
#line 82
      goto step;
    }
#line 78
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 84
  my_outb((u_short )(smb_base___0 + 1), (unsigned char)12);
#line 84
  my_outb((unsigned short)235, (unsigned char)0);
#line 84
  my_outb((unsigned short)235, (unsigned char)0);
  }
  step: 
  {
#line 87
  my_outb((u_short )(smb_base___0 + 3), (unsigned char )((int )saddr | 1));
#line 87
  my_outb((unsigned short)235, (unsigned char)0);
#line 87
  my_outb((unsigned short)235, (unsigned char)0);
#line 88
  my_outb((u_short )(smb_base___0 + 7), (u_char )cmd);
#line 88
  my_outb((unsigned short)235, (unsigned char)0);
#line 88
  my_outb((unsigned short)235, (unsigned char)0);
#line 89
  my_outb((u_short )(smb_base___0 + 1), (unsigned char)32);
#line 89
  my_outb((unsigned short)235, (unsigned char)0);
#line 89
  my_outb((unsigned short)235, (unsigned char)0);
#line 90
  my_outb((u_short )(smb_base___0 + 2), (unsigned char)255);
#line 90
  my_outb((unsigned short)235, (unsigned char)0);
#line 90
  my_outb((unsigned short)235, (unsigned char)0);
#line 92
  i = 0;
  }
  {
#line 92
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 92
    if (! (i < 8192)) {
#line 92
      goto while_break___0;
    }
    {
#line 93
    dat = my_inb((u_short )smb_base___0);
#line 93
    my_outb((unsigned short)235, (unsigned char)0);
#line 93
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 94
    if (! ((int )dat & 8)) {
#line 95
      goto while_break___0;
    }
#line 92
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 101
  if ((int )dat == 0) {
    {
#line 102
    my_outb((u_short )(smb_base___0 + 1), (unsigned char)12);
#line 102
    my_outb((unsigned short)235, (unsigned char)0);
#line 102
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 107
    goto top;
  } else
#line 108
  if ((int )dat & 16) {
    {
#line 109
    dat = my_inb((u_short )(smb_base___0 + 4));
#line 109
    my_outb((unsigned short)235, (unsigned char)0);
#line 109
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 110
    return ((int )dat & 255);
  } else {
#line 112
    return (-1);
  }
}
}
#line 115 "/home/wheatley/newnew/temp/xmbmon-2.05/smbus_ali.c"
static int readword___6(int smb_base___0 , int addr , int cmd ) 
{ 
  u_char dat ;
  u_char saddr ;
  int i ;
  unsigned char tmp ;

  {
#line 117
  saddr = (u_char )(2 * (addr / 2));
  top: 
#line 121
  i = 0;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! (i < 8192)) {
#line 121
      goto while_break;
    }
    {
#line 122
    my_outb((u_short )smb_base___0, (unsigned char)255);
#line 122
    my_outb((unsigned short)235, (unsigned char)0);
#line 122
    my_outb((unsigned short)235, (unsigned char)0);
#line 123
    dat = my_inb((u_short )smb_base___0);
#line 123
    my_outb((unsigned short)235, (unsigned char)0);
#line 123
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 124
    if ((int )dat & 4) {
#line 125
      goto step;
    }
#line 121
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 127
  my_outb((u_short )(smb_base___0 + 1), (unsigned char)12);
#line 127
  my_outb((unsigned short)235, (unsigned char)0);
#line 127
  my_outb((unsigned short)235, (unsigned char)0);
  }
  step: 
  {
#line 130
  my_outb((u_short )(smb_base___0 + 3), (unsigned char )((int )saddr | 1));
#line 130
  my_outb((unsigned short)235, (unsigned char)0);
#line 130
  my_outb((unsigned short)235, (unsigned char)0);
#line 131
  my_outb((u_short )(smb_base___0 + 7), (u_char )cmd);
#line 131
  my_outb((unsigned short)235, (unsigned char)0);
#line 131
  my_outb((unsigned short)235, (unsigned char)0);
#line 132
  my_outb((u_short )(smb_base___0 + 1), (unsigned char)48);
#line 132
  my_outb((unsigned short)235, (unsigned char)0);
#line 132
  my_outb((unsigned short)235, (unsigned char)0);
#line 133
  my_outb((u_short )(smb_base___0 + 2), (unsigned char)255);
#line 133
  my_outb((unsigned short)235, (unsigned char)0);
#line 133
  my_outb((unsigned short)235, (unsigned char)0);
#line 135
  i = 0;
  }
  {
#line 135
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 135
    if (! (i < 8192)) {
#line 135
      goto while_break___0;
    }
    {
#line 136
    dat = my_inb((u_short )smb_base___0);
#line 136
    my_outb((unsigned short)235, (unsigned char)0);
#line 136
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 137
    if (! ((int )dat & 8)) {
#line 138
      goto while_break___0;
    }
#line 135
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 140
  if ((int )dat == 0) {
    {
#line 141
    my_outb((u_short )(smb_base___0 + 1), (unsigned char)12);
#line 141
    my_outb((unsigned short)235, (unsigned char)0);
#line 141
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 142
    goto top;
  } else
#line 143
  if ((int )dat & 16) {
    {
#line 144
    tmp = my_inb((u_short )(smb_base___0 + 5));
#line 144
    i = (int )tmp;
#line 144
    my_outb((unsigned short)235, (unsigned char)0);
#line 144
    my_outb((unsigned short)235, (unsigned char)0);
#line 145
    dat = my_inb((u_short )(smb_base___0 + 4));
#line 145
    my_outb((unsigned short)235, (unsigned char)0);
#line 145
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 146
    return (((i << 8) + (int )dat) & 65535);
  } else {
#line 148
    return (-1);
  }
}
}
#line 151 "/home/wheatley/newnew/temp/xmbmon-2.05/smbus_ali.c"
static int writebyte___8(int smb_base___0 , int addr , int cmd , int value ) 
{ 
  u_char dat ;
  u_char saddr ;
  int i ;

  {
#line 153
  saddr = (u_char )(2 * (addr / 2));
#line 156
  i = 0;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! (i < 8192)) {
#line 156
      goto while_break;
    }
    {
#line 157
    my_outb((u_short )smb_base___0, (unsigned char)255);
#line 157
    my_outb((unsigned short)235, (unsigned char)0);
#line 157
    my_outb((unsigned short)235, (unsigned char)0);
#line 158
    dat = my_inb((u_short )smb_base___0);
#line 158
    my_outb((unsigned short)235, (unsigned char)0);
#line 158
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 159
    if ((int )dat & 4) {
#line 160
      goto step;
    }
#line 156
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 162
  my_outb((u_short )(smb_base___0 + 1), (unsigned char)12);
#line 162
  my_outb((unsigned short)235, (unsigned char)0);
#line 162
  my_outb((unsigned short)235, (unsigned char)0);
  }
  step: 
  {
#line 165
  my_outb((u_short )(smb_base___0 + 3), saddr);
#line 165
  my_outb((unsigned short)235, (unsigned char)0);
#line 165
  my_outb((unsigned short)235, (unsigned char)0);
#line 166
  my_outb((u_short )(smb_base___0 + 7), (u_char )cmd);
#line 166
  my_outb((unsigned short)235, (unsigned char)0);
#line 166
  my_outb((unsigned short)235, (unsigned char)0);
#line 167
  my_outb((u_short )(smb_base___0 + 4), (u_char )value);
#line 167
  my_outb((unsigned short)235, (unsigned char)0);
#line 167
  my_outb((unsigned short)235, (unsigned char)0);
#line 168
  my_outb((u_short )(smb_base___0 + 1), (unsigned char)32);
#line 168
  my_outb((unsigned short)235, (unsigned char)0);
#line 168
  my_outb((unsigned short)235, (unsigned char)0);
#line 169
  my_outb((u_short )(smb_base___0 + 2), (unsigned char)255);
#line 169
  my_outb((unsigned short)235, (unsigned char)0);
#line 169
  my_outb((unsigned short)235, (unsigned char)0);
#line 171
  i = 0;
  }
  {
#line 171
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 171
    if (! (i < 8192)) {
#line 171
      goto while_break___0;
    }
    {
#line 172
    dat = my_inb((u_short )smb_base___0);
#line 172
    my_outb((unsigned short)235, (unsigned char)0);
#line 172
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 173
    if (! ((int )dat & 8)) {
#line 174
      goto while_break___0;
    }
#line 171
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 176
  if ((int )dat & 16) {
#line 177
    return (0);
  } else {
#line 179
    return (-1);
  }
}
}
#line 182 "/home/wheatley/newnew/temp/xmbmon-2.05/smbus_ali.c"
static int writeword___6(int smb_base___0 , int addr , int cmd , int value ) 
{ 
  u_char dat ;
  u_char saddr ;
  int i ;

  {
#line 184
  saddr = (u_char )(2 * (addr / 2));
#line 187
  i = 0;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! (i < 8192)) {
#line 187
      goto while_break;
    }
    {
#line 188
    my_outb((u_short )smb_base___0, (unsigned char)255);
#line 188
    my_outb((unsigned short)235, (unsigned char)0);
#line 188
    my_outb((unsigned short)235, (unsigned char)0);
#line 189
    dat = my_inb((u_short )smb_base___0);
#line 189
    my_outb((unsigned short)235, (unsigned char)0);
#line 189
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 190
    if ((int )dat & 4) {
#line 191
      goto step;
    }
#line 187
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 193
  my_outb((u_short )(smb_base___0 + 1), (unsigned char)12);
#line 193
  my_outb((unsigned short)235, (unsigned char)0);
#line 193
  my_outb((unsigned short)235, (unsigned char)0);
  }
  step: 
  {
#line 196
  my_outb((u_short )(smb_base___0 + 3), saddr);
#line 196
  my_outb((unsigned short)235, (unsigned char)0);
#line 196
  my_outb((unsigned short)235, (unsigned char)0);
#line 197
  my_outb((u_short )(smb_base___0 + 7), (u_char )cmd);
#line 197
  my_outb((unsigned short)235, (unsigned char)0);
#line 197
  my_outb((unsigned short)235, (unsigned char)0);
#line 198
  my_outb((u_short )(smb_base___0 + 4), (u_char )(value & 255));
#line 198
  my_outb((unsigned short)235, (unsigned char)0);
#line 198
  my_outb((unsigned short)235, (unsigned char)0);
#line 199
  my_outb((u_short )(smb_base___0 + 5), (u_char )(value >> 8));
#line 199
  my_outb((unsigned short)235, (unsigned char)0);
#line 199
  my_outb((unsigned short)235, (unsigned char)0);
#line 200
  my_outb((u_short )(smb_base___0 + 1), (unsigned char)48);
#line 200
  my_outb((unsigned short)235, (unsigned char)0);
#line 200
  my_outb((unsigned short)235, (unsigned char)0);
#line 201
  my_outb((u_short )(smb_base___0 + 2), (unsigned char)255);
#line 201
  my_outb((unsigned short)235, (unsigned char)0);
#line 201
  my_outb((unsigned short)235, (unsigned char)0);
#line 203
  i = 0;
  }
  {
#line 203
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 203
    if (! (i < 8192)) {
#line 203
      goto while_break___0;
    }
    {
#line 204
    dat = my_inb((u_short )smb_base___0);
#line 204
    my_outb((unsigned short)235, (unsigned char)0);
#line 204
    my_outb((unsigned short)235, (unsigned char)0);
    }
#line 205
    if (! ((int )dat & 8)) {
#line 206
      goto while_break___0;
    }
#line 203
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 208
  if ((int )dat & 16) {
#line 209
    return (0);
  } else {
#line 211
    return (-1);
  }
}
}
#line 45 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm90.c"
static int lm90chipid___1  =    0;
#line 47
static int lm90_probe___1(LM_METHODS *method___1 ) ;
#line 48
static int lm90_ident___1(LM_METHODS *method___1 ) ;
#line 49
static float lm90_temp___1(LM_METHODS *method___1 , int no ) ;
#line 50
static int lm90_fanrpm___1(LM_METHODS *method___1 , int no ) ;
#line 51
static float lm90_volt___1(LM_METHODS *method___1 , int no ) ;
#line 54 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm90.c"
static char buff___9[128]  ;
#line 71 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm90.c"
static char *lm90chip___1[5]  = {      (char *)"No Sensor",      (char *)"Nat.Semi.Con. Chip LM90",      (char *)"Analog Dev. Chip ADM1020",      (char *)"Analog Dev. Chip ADM1021/1023", 
        (char *)((void *)0)};
#line 82 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm90.c"
static int chkReg___16[21]  = 
#line 82
  {      0,      1,      2,      3, 
        4,      5,      6,      7, 
        8,      16,      17,      18, 
        19,      20,      25,      32, 
        33,      191,      254,      255, 
        -1};
#line 94 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm90.c"
static int lm90_probe___1(LM_METHODS *method___1 ) 
{ 
  int n ;
  int save ;
  int tmp ;
  int tmp___0 ;

  {
#line 98
  if ((unsigned long )method___1 != (unsigned long )(& method_smb)) {
#line 99
    return (0);
  }
#line 101
  save = smb_slave;
#line 103
  n = 144;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! (n <= 158)) {
#line 103
      goto while_break;
    }
    {
#line 104
    smb_slave = get_smb_slave(n, 158);
    }
#line 104
    if (smb_slave) {
      {
#line 107
      tmp = lm90_ident___1(method___1);
      }
#line 107
      if (tmp) {
        {
#line 107
        tmp___0 = chkReg_Probe(smb_slave, (char *)"Probing LM90 chip:\n", chkReg___16,
                               method___1);
        }
#line 107
        if (tmp___0 >= 8) {
#line 110
          goto ret1;
        } else {
#line 112
          n = smb_slave + 2;
        }
      } else {
#line 112
        n = smb_slave + 2;
      }
    } else {
#line 105
      goto ret0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  ret0: 
#line 117
  smb_slave = save;
#line 118
  return (0);
  ret1: 
  {
#line 120
  kill_smb_slave(smb_slave);
#line 121
  strcpy((char */* __restrict  */)(buff___9), (char const   */* __restrict  */)lm90chip___1[lm90chipid___1]);
  }
#line 122
  return (lm90chipid___1);
}
}
#line 125 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm90.c"
static int lm90_ident___1(LM_METHODS *method___1 ) 
{ 
  int vend ;
  int revd ;
  int tmp ;

  {
  {
#line 129
  vend = (*(method___1->Read))(254);
#line 130
  revd = (*(method___1->Read))(255);
  }
#line 131
  if (vend == 1) {
#line 131
    if (revd == 33) {
#line 132
      lm90chipid___1 = 1;
    } else {
#line 131
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 133
  if (vend == 65) {
#line 134
    if (revd) {
#line 134
      tmp = 1;
    } else {
#line 134
      tmp = 0;
    }
#line 134
    if (tmp == 48) {
#line 135
      lm90chipid___1 = 3;
    } else {
#line 137
      lm90chipid___1 = 2;
    }
  }
#line 140
  return (lm90chipid___1);
}
}
#line 148 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm90.c"
static float lm90_temp___1(LM_METHODS *method___1 , int no ) 
{ 
  int n ;
  int k ;
  float offset ;

  {
#line 150
  n = 0;
#line 150
  k = 0;
#line 151
  offset = (float )0.0;
#line 153
  if (no < 0) {
#line 154
    return ((float )65535);
  } else
#line 153
  if (2 < no) {
#line 154
    return ((float )65535);
  }
#line 156
  if (no == 0) {
    {
#line 157
    n = (*(method___1->Read))(0);
    }
  } else
#line 158
  if (no == 1) {
#line 159
    if (lm90chipid___1 != 2) {
      {
#line 160
      n = (*(method___1->Read))(17);
      }
#line 160
      if (n == 255) {
#line 161
        n = 0;
      }
      {
#line 162
      k = (*(method___1->Read))(18);
      }
#line 162
      if (k == 255) {
#line 163
        k = 0;
      } else {
#line 165
        k >>= 5;
      }
#line 166
      offset = (float )((double )((float )n) + 0.125 * (double )((float )k));
    }
    {
#line 168
    n = (*(method___1->Read))(1);
#line 169
    k = (*(method___1->Read))(16);
    }
#line 169
    if (k == 255) {
#line 170
      k = 0;
    } else {
#line 172
      k >>= 5;
    }
  }
#line 174
  if (n >= 128) {
#line 175
    k = 0;
#line 175
    n = k;
  }
#line 177
  return ((float )(((double )((float )n) + 0.125 * (double )((float )k)) - (double )offset));
}
}
#line 182 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm90.c"
static float lm90_volt___1(LM_METHODS *method___1 , int no ) 
{ 


  {
#line 184
  return ((float )65535);
}
}
#line 187 "/home/wheatley/newnew/temp/xmbmon-2.05/sens_lm90.c"
static int lm90_fanrpm___1(LM_METHODS *method___1 , int no ) 
{ 


  {
#line 189
  return (65535);
}
}
