/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 11 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/wordbuf.h"
struct _wordbuf_t;
#line 11 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/wordbuf.h"
typedef struct _wordbuf_t wordbuf_t;
#line 11 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/wordbuf.h"
typedef struct _wordbuf_t *wordbuf_p;
#line 12 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/wordbuf.h"
struct _wordbuf_t {
   int len ;
   unsigned char *buf ;
   int last ;
};
#line 12 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/rxgen.h"
struct _rxgen;
#line 12 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/rxgen.h"
typedef struct _rxgen rxgen;
#line 36 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/rxgen.c"
struct _rnode;
#line 36 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/rxgen.c"
typedef struct _rnode rnode;
#line 38 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/rxgen.c"
struct _rxgen {
   rnode *node ;
   int (*char2int)(unsigned char const   * , unsigned int * ) ;
   int (*int2char)(unsigned int  , unsigned char * ) ;
   unsigned char op_or[16] ;
   unsigned char op_nest_in[16] ;
   unsigned char op_nest_out[16] ;
   unsigned char op_select_in[16] ;
   unsigned char op_select_out[16] ;
   unsigned char op_newline[16] ;
};
#line 55 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/rxgen.c"
struct _rnode {
   unsigned int code ;
   rnode *child ;
   rnode *next ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 19 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/charset.h"
typedef int (*charset_proc_char2int)(unsigned char const   * , unsigned int * );
#line 20 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/charset.h"
typedef int (*charset_proc_int2char)(unsigned int  , unsigned char * );
#line 12 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/romaji.h"
struct _romaji;
#line 12 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/romaji.h"
typedef struct _romaji romaji;
#line 43 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/romaji.c"
struct _romanode;
#line 43 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/romaji.c"
typedef struct _romanode romanode;
#line 44 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/romaji.c"
struct _romanode {
   unsigned char key ;
   unsigned char *value ;
   romanode *next ;
   romanode *child ;
};
#line 196 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/romaji.c"
struct _romaji {
   int verbose ;
   romanode *node ;
   unsigned char *fixvalue_xn ;
   unsigned char *fixvalue_xtu ;
   int (*char2int)(unsigned char const   * , unsigned int * ) ;
};
#line 12 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/wordlist.h"
struct _wordlist_t;
#line 12 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/wordlist.h"
typedef struct _wordlist_t *wordlist_p;
#line 13 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/wordlist.h"
struct _wordlist_t {
   unsigned char *ptr ;
   wordlist_p next ;
};
#line 16 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/mnode.h"
struct _mnode;
#line 16 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/mnode.h"
typedef struct _mnode mnode;
#line 17 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/mnode.h"
struct _mnode {
   unsigned int attr ;
   mnode *next ;
   mnode *child ;
   wordlist_p list ;
};
#line 28
struct _mtree_t;
#line 28 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/mnode.h"
typedef struct _mtree_t *mtree_p;
#line 20 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/mnode.c"
struct _mtree_t {
   mtree_p active ;
   int used ;
   mnode nodes[1024] ;
   mtree_p next ;
};
#line 42 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.h"
struct _migemo;
#line 42 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.h"
typedef struct _migemo migemo;
#line 39 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.c"
struct _migemo {
   int enable ;
   mtree_p mtree ;
   int charset ;
   romaji *roma2hira ;
   romaji *hira2kata ;
   romaji *han2zen ;
   romaji *zen2han ;
   rxgen *rx ;
   int (*addword)(void *data , unsigned char *word ) ;
   int (*char2int)(unsigned char const   * , unsigned int * ) ;
};
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 59 "/usr/include/time.h"
typedef __clock_t clock_t;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 30 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/wordbuf.h"
wordbuf_p wordbuf_open(void) ;
#line 31
void wordbuf_close(wordbuf_p p ) ;
#line 35
int wordbuf_cat(wordbuf_p p , unsigned char const   *sz ) ;
#line 26 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/rxgen.h"
int n_rnode_new ;
#line 27
int n_rnode_delete ;
#line 33
rxgen *rxgen_open(void) ;
#line 34
void rxgen_close(rxgen *object ) ;
#line 35
int rxgen_add(rxgen *object , unsigned char const   *word ) ;
#line 36
unsigned char *rxgen_generate(rxgen *object ) ;
#line 37
void rxgen_release(rxgen *object , unsigned char *string ) ;
#line 38
void rxgen_reset(rxgen *object ) ;
#line 40
void rxgen_setproc_char2int(rxgen *object , int (*proc)(unsigned char const   * ,
                                                        unsigned int * ) ) ;
#line 41
void rxgen_setproc_int2char(rxgen *object , int (*proc)(unsigned int  , unsigned char * ) ) ;
#line 42
int rxgen_set_operator(rxgen *object , int index___0 , unsigned char const   *op ) ;
#line 43
unsigned char const   *rxgen_get_operator(rxgen *object , int index___0 ) ;
#line 33 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/rxgen.c"
int n_rnode_new  =    0;
#line 34 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/rxgen.c"
int n_rnode_delete  =    0;
#line 62 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/rxgen.c"
static rnode *rnode_new(void) 
{ 
  void *tmp ;

  {
  {
#line 65
  n_rnode_new ++;
#line 66
  tmp = calloc((size_t )1, sizeof(rnode ));
  }
#line 66
  return ((rnode *)tmp);
}
}
#line 69 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/rxgen.c"
static void rnode_delete(rnode *node ) 
{ 
  rnode *child ;

  {
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 72
    if (! node) {
#line 72
      goto while_break;
    }
#line 74
    child = node->child;
#line 75
    if (node->next) {
      {
#line 76
      rnode_delete(node->next);
      }
    }
    {
#line 77
    free((void *)node);
#line 78
    node = child;
#line 79
    n_rnode_delete ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  return;
}
}
#line 87 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/rxgen.c"
static int default_char2int(unsigned char const   *in , unsigned int *out ) 
{ 


  {
#line 90
  if (out) {
#line 91
    *out = (unsigned int )*in;
  }
#line 92
  return (1);
}
}
#line 95 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/rxgen.c"
static int default_int2char(unsigned int in , unsigned char *out ) 
{ 
  int len ;

  {
#line 98
  len = 0;
  {
#line 103
  if (in == 47U) {
#line 103
    goto case_47;
  }
#line 103
  if (in == 36U) {
#line 103
    goto case_47;
  }
#line 103
  if (in == 94U) {
#line 103
    goto case_47;
  }
#line 103
  if (in == 42U) {
#line 103
    goto case_47;
  }
#line 103
  if (in == 46U) {
#line 103
    goto case_47;
  }
#line 103
  if (in == 92U) {
#line 103
    goto case_47;
  }
#line 110
  goto switch_default;
  case_47: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_94: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_92: /* CIL Label */ 
#line 107
  if (out) {
#line 108
    *(out + len) = (unsigned char )'\\';
  }
#line 109
  len ++;
  switch_default: /* CIL Label */ 
#line 111
  if (out) {
#line 112
    *(out + len) = (unsigned char )(in & 255U);
  }
#line 113
  len ++;
#line 114
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 116
  return (len);
}
}
#line 119 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/rxgen.c"
void rxgen_setproc_char2int(rxgen *object , int (*proc)(unsigned char const   * ,
                                                        unsigned int * ) ) 
{ 


  {
#line 122
  if (object) {
#line 123
    if (proc) {
#line 123
      object->char2int = proc;
    } else {
#line 123
      object->char2int = & default_char2int;
    }
  }
#line 124
  return;
}
}
#line 126 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/rxgen.c"
void rxgen_setproc_int2char(rxgen *object , int (*proc)(unsigned int  , unsigned char * ) ) 
{ 


  {
#line 129
  if (object) {
#line 130
    if (proc) {
#line 130
      object->int2char = proc;
    } else {
#line 130
      object->int2char = & default_int2char;
    }
  }
#line 131
  return;
}
}
#line 133 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/rxgen.c"
static int rxgen_call_char2int(rxgen *object , unsigned char const   *pch , unsigned int *code ) 
{ 
  int len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 137
  tmp = (*(object->char2int))(pch, code);
#line 137
  len = tmp;
  }
#line 138
  if (len) {
#line 138
    tmp___1 = len;
  } else {
    {
#line 138
    tmp___0 = default_char2int(pch, code);
#line 138
    tmp___1 = tmp___0;
    }
  }
#line 138
  return (tmp___1);
}
}
#line 141 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/rxgen.c"
static int rxgen_call_int2char(rxgen *object , unsigned int code , unsigned char *buf___1 ) 
{ 
  int len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 144
  tmp = (*(object->int2char))(code, buf___1);
#line 144
  len = tmp;
  }
#line 145
  if (len) {
#line 145
    tmp___1 = len;
  } else {
    {
#line 145
    tmp___0 = default_int2char(code, buf___1);
#line 145
    tmp___1 = tmp___0;
    }
  }
#line 145
  return (tmp___1);
}
}
#line 148 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/rxgen.c"
rxgen *rxgen_open(void) 
{ 
  rxgen *object ;
  void *tmp ;

  {
  {
#line 151
  tmp = calloc((size_t )1, sizeof(rxgen ));
#line 151
  object = (rxgen *)tmp;
  }
#line 152
  if (object) {
    {
#line 154
    rxgen_setproc_char2int(object, (int (*)(unsigned char const   * , unsigned int * ))((void *)0));
#line 155
    rxgen_setproc_int2char(object, (int (*)(unsigned int  , unsigned char * ))((void *)0));
#line 156
    strcpy((char */* __restrict  */)(object->op_or), (char const   */* __restrict  */)"|");
#line 157
    strcpy((char */* __restrict  */)(object->op_nest_in), (char const   */* __restrict  */)"(");
#line 158
    strcpy((char */* __restrict  */)(object->op_nest_out), (char const   */* __restrict  */)")");
#line 159
    strcpy((char */* __restrict  */)(object->op_select_in), (char const   */* __restrict  */)"[");
#line 160
    strcpy((char */* __restrict  */)(object->op_select_out), (char const   */* __restrict  */)"]");
#line 161
    strcpy((char */* __restrict  */)(object->op_newline), (char const   */* __restrict  */)"");
    }
  }
#line 163
  return (object);
}
}
#line 166 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/rxgen.c"
void rxgen_close(rxgen *object ) 
{ 


  {
#line 169
  if (object) {
    {
#line 171
    rnode_delete(object->node);
#line 172
    free((void *)object);
    }
  }
#line 174
  return;
}
}
#line 176 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/rxgen.c"
static rnode *search_rnode(rnode *node , unsigned int code ) 
{ 


  {
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (node) {
#line 179
      if (! (node->code != code)) {
#line 179
        goto while_break;
      }
    } else {
#line 179
      goto while_break;
    }
#line 180
    node = node->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 181
  return (node);
}
}
#line 184 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/rxgen.c"
int rxgen_add(rxgen *object , unsigned char const   *word ) 
{ 
  rnode **ppnode ;
  rnode *pnode ;
  unsigned int code ;
  int len ;
  int tmp ;

  {
#line 190
  if (! object) {
#line 191
    return (0);
  } else
#line 190
  if (! word) {
#line 191
    return (0);
  }
#line 193
  ppnode = & object->node;
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 197
    tmp = rxgen_call_char2int(object, word, & code);
#line 197
    len = tmp;
    }
#line 201
    if (code == 0U) {
#line 204
      if (*ppnode) {
        {
#line 206
        rnode_delete(*ppnode);
#line 207
        *ppnode = (rnode *)((void *)0);
        }
      }
#line 209
      goto while_break;
    }
    {
#line 211
    pnode = search_rnode(*ppnode, code);
    }
#line 212
    if ((unsigned long )pnode == (unsigned long )((void *)0)) {
      {
#line 215
      pnode = rnode_new();
#line 216
      pnode->code = code;
#line 217
      pnode->next = *ppnode;
#line 218
      *ppnode = pnode;
      }
    } else
#line 220
    if ((unsigned long )pnode->child == (unsigned long )((void *)0)) {
#line 228
      goto while_break;
    }
#line 231
    ppnode = & pnode->child;
#line 232
    word += len;
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  return (1);
}
}
#line 237 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/rxgen.c"
static void rxgen_generate_stub(rxgen *object , wordbuf_t *buf___1 , rnode *node ) 
{ 
  unsigned char ch[16] ;
  int chlen ;
  int nochild ;
  int haschild ;
  int brother ;
  rnode *tmp ;

  {
#line 241
  haschild = 0;
#line 241
  brother = 1;
#line 245
  tmp = node;
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 245
    if (! tmp) {
#line 245
      goto while_break;
    }
#line 247
    if (tmp->next) {
#line 248
      brother ++;
    }
#line 249
    if (tmp->child) {
#line 250
      haschild ++;
    }
#line 245
    tmp = tmp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 252
  nochild = brother - haschild;
#line 258
  if (brother > 1) {
#line 258
    if (haschild > 0) {
      {
#line 259
      wordbuf_cat(buf___1, (unsigned char const   *)(object->op_nest_in));
      }
    }
  }
#line 262
  if (nochild > 0) {
#line 264
    if (nochild > 1) {
      {
#line 265
      wordbuf_cat(buf___1, (unsigned char const   *)(object->op_select_in));
      }
    }
#line 266
    tmp = node;
    {
#line 266
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 266
      if (! tmp) {
#line 266
        goto while_break___0;
      }
#line 268
      if (tmp->child) {
#line 269
        goto __Cont;
      }
      {
#line 270
      chlen = rxgen_call_int2char(object, tmp->code, ch);
#line 271
      ch[chlen] = (unsigned char )'\000';
#line 273
      wordbuf_cat(buf___1, (unsigned char const   *)(ch));
      }
      __Cont: /* CIL Label */ 
#line 266
      tmp = tmp->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 275
    if (nochild > 1) {
      {
#line 276
      wordbuf_cat(buf___1, (unsigned char const   *)(object->op_select_out));
      }
    }
  }
#line 281
  if (haschild > 0) {
#line 284
    if (nochild > 0) {
      {
#line 285
      wordbuf_cat(buf___1, (unsigned char const   *)(object->op_or));
      }
    }
#line 286
    tmp = node;
    {
#line 286
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 286
      if (! (! tmp->child)) {
#line 286
        goto while_break___1;
      }
#line 286
      tmp = tmp->next;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 288
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 290
      chlen = rxgen_call_int2char(object, tmp->code, ch);
#line 292
      ch[chlen] = (unsigned char )'\000';
#line 293
      wordbuf_cat(buf___1, (unsigned char const   *)(ch));
      }
#line 295
      if (object->op_newline[0]) {
        {
#line 296
        wordbuf_cat(buf___1, (unsigned char const   *)(object->op_newline));
        }
      }
      {
#line 297
      rxgen_generate_stub(object, buf___1, tmp->child);
#line 298
      tmp = tmp->next;
      }
      {
#line 298
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 298
        if (tmp) {
#line 298
          if (! (! tmp->child)) {
#line 298
            goto while_break___3;
          }
        } else {
#line 298
          goto while_break___3;
        }
#line 298
        tmp = tmp->next;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 300
      if (! tmp) {
#line 301
        goto while_break___2;
      }
#line 302
      if (haschild > 1) {
        {
#line 303
        wordbuf_cat(buf___1, (unsigned char const   *)(object->op_or));
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 308
  if (brother > 1) {
#line 308
    if (haschild > 0) {
      {
#line 309
      wordbuf_cat(buf___1, (unsigned char const   *)(object->op_nest_out));
      }
    }
  }
#line 310
  return;
}
}
#line 312 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/rxgen.c"
unsigned char *rxgen_generate(rxgen *object ) 
{ 
  unsigned char *answer ;
  wordbuf_t *buf___1 ;
  char *tmp ;

  {
#line 315
  answer = (unsigned char *)((void *)0);
#line 318
  if (object) {
    {
#line 318
    buf___1 = wordbuf_open();
    }
#line 318
    if (buf___1) {
#line 320
      if (object->node) {
        {
#line 321
        rxgen_generate_stub(object, buf___1, object->node);
        }
      }
      {
#line 322
      tmp = strdup((char const   *)buf___1->buf);
#line 322
      answer = (unsigned char *)tmp;
#line 323
      wordbuf_close(buf___1);
      }
    }
  }
#line 325
  return (answer);
}
}
#line 328 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/rxgen.c"
void rxgen_release(rxgen *object , unsigned char *string ) 
{ 


  {
  {
#line 331
  free((void *)string);
  }
#line 332
  return;
}
}
#line 337 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/rxgen.c"
void rxgen_reset(rxgen *object ) 
{ 


  {
#line 340
  if (object) {
    {
#line 342
    rnode_delete(object->node);
#line 343
    object->node = (rnode *)((void *)0);
    }
  }
#line 345
  return;
}
}
#line 347 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/rxgen.c"
static unsigned char *rxgen_get_operator_stub(rxgen *object , int index___0 ) 
{ 


  {
  {
#line 352
  if (index___0 == 0) {
#line 352
    goto case_0;
  }
#line 354
  if (index___0 == 1) {
#line 354
    goto case_1;
  }
#line 356
  if (index___0 == 2) {
#line 356
    goto case_2;
  }
#line 358
  if (index___0 == 3) {
#line 358
    goto case_3;
  }
#line 360
  if (index___0 == 4) {
#line 360
    goto case_4;
  }
#line 362
  if (index___0 == 5) {
#line 362
    goto case_5;
  }
#line 364
  goto switch_default;
  case_0: /* CIL Label */ 
#line 353
  return (object->op_or);
  case_1: /* CIL Label */ 
#line 355
  return (object->op_nest_in);
  case_2: /* CIL Label */ 
#line 357
  return (object->op_nest_out);
  case_3: /* CIL Label */ 
#line 359
  return (object->op_select_in);
  case_4: /* CIL Label */ 
#line 361
  return (object->op_select_out);
  case_5: /* CIL Label */ 
#line 363
  return (object->op_newline);
  switch_default: /* CIL Label */ 
#line 365
  return ((unsigned char *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 369 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/rxgen.c"
unsigned char const   *rxgen_get_operator(rxgen *object , int index___0 ) 
{ 
  unsigned char *tmp ;
  unsigned char *tmp___0 ;

  {
#line 372
  if (object) {
    {
#line 372
    tmp = rxgen_get_operator_stub(object, index___0);
#line 372
    tmp___0 = tmp;
    }
  } else {
#line 372
    tmp___0 = (unsigned char *)((void *)0);
  }
#line 372
  return ((unsigned char const   *)tmp___0);
}
}
#line 376 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/rxgen.c"
int rxgen_set_operator(rxgen *object , int index___0 , unsigned char const   *op ) 
{ 
  unsigned char *dest ;
  size_t tmp ;

  {
#line 381
  if (! object) {
#line 382
    return (1);
  }
  {
#line 383
  tmp = strlen((char const   *)op);
  }
#line 383
  if (tmp >= 16UL) {
#line 384
    return (2);
  }
  {
#line 385
  dest = rxgen_get_operator_stub(object, index___0);
  }
#line 385
  if (! dest) {
#line 386
    return (3);
  }
  {
#line 387
  strcpy((char */* __restrict  */)dest, (char const   */* __restrict  */)op);
  }
#line 389
  return (0);
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 702
extern int ungetc(int __c , FILE *__stream ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 32 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/wordbuf.h"
void wordbuf_reset(wordbuf_p p ) ;
#line 34
int wordbuf_add(wordbuf_p p , unsigned char ch ) ;
#line 35 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/charset.h"
int charset_detect_file(char const   *path ) ;
#line 37
void charset_getproc(int charset , charset_proc_char2int *char2int , charset_proc_int2char *int2char ) ;
#line 20 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/romaji.h"
romaji *romaji_open(void) ;
#line 21
void romaji_close(romaji *object ) ;
#line 22
int romaji_add_table(romaji *object , unsigned char const   *key , unsigned char const   *value ) ;
#line 24
int romaji_load(romaji *object , unsigned char const   *filename ) ;
#line 25
unsigned char *romaji_convert(romaji *object , unsigned char const   *string , unsigned char **ppstop ) ;
#line 27
unsigned char *romaji_convert2(romaji *object , unsigned char const   *string , unsigned char **ppstop ,
                               int ignorecase ) ;
#line 29
void romaji_release(romaji *object , unsigned char *string ) ;
#line 31
void romaji_setproc_char2int(romaji *object , int (*proc)(unsigned char const   * ,
                                                          unsigned int * ) ) ;
#line 32
void romaji_set_verbose(romaji *object , int level ) ;
#line 52 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/romaji.c"
int n_romanode_new  =    0;
#line 53 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/romaji.c"
int n_romanode_delete  =    0;
#line 55 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/romaji.c"
__inline static romanode *romanode_new(void) 
{ 
  void *tmp ;

  {
  {
#line 58
  n_romanode_new ++;
#line 59
  tmp = calloc((size_t )1, sizeof(romanode ));
  }
#line 59
  return ((romanode *)tmp);
}
}
#line 62 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/romaji.c"
static void romanode_delete(romanode *node ) 
{ 
  romanode *child ;

  {
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! node) {
#line 65
      goto while_break;
    }
#line 67
    child = node->child;
#line 68
    if (node->next) {
      {
#line 69
      romanode_delete(node->next);
      }
    }
    {
#line 70
    free((void *)node->value);
#line 71
    free((void *)node);
#line 72
    node = child;
#line 73
    n_romanode_delete ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  return;
}
}
#line 77 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/romaji.c"
static romanode **romanode_dig(romanode **ref_node , unsigned char const   *key ) 
{ 
  romanode *tmp ;

  {
#line 80
  if (! ref_node) {
#line 81
    return ((romanode **)((void *)0));
  } else
#line 80
  if (! key) {
#line 81
    return ((romanode **)((void *)0));
  } else
#line 80
  if ((int const   )*(key + 0) == 0) {
#line 81
    return ((romanode **)((void *)0));
  }
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! *ref_node) {
      {
#line 87
      tmp = romanode_new();
#line 87
      *ref_node = tmp;
      }
#line 87
      if (! tmp) {
#line 88
        return ((romanode **)((void *)0));
      }
#line 89
      (*ref_node)->key = (unsigned char )*key;
    }
#line 92
    if ((int )(*ref_node)->key == (int )*key) {
#line 94
      (*ref_node)->value = (unsigned char *)((void *)0);
#line 95
      key ++;
#line 95
      if (! *key) {
#line 96
        goto while_break;
      }
#line 97
      ref_node = & (*ref_node)->child;
    } else {
#line 100
      ref_node = & (*ref_node)->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  if ((*ref_node)->child) {
    {
#line 105
    romanode_delete((*ref_node)->child);
#line 106
    (*ref_node)->child = (romanode *)0;
    }
  }
#line 108
  return (ref_node);
}
}
#line 118 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/romaji.c"
static romanode *romanode_query(romanode *node , unsigned char const   *key , int *skip ,
                                int (*char2int)(unsigned char const   * , unsigned int * ) ) 
{ 
  int nskip ;
  unsigned char const   *key_start ;

  {
#line 122
  nskip = 0;
#line 123
  key_start = key;
#line 126
  if (node) {
#line 126
    if (key) {
#line 126
      if (*key) {
        {
#line 128
        while (1) {
          while_continue: /* CIL Label */ ;
#line 130
          if ((int const   )*key != (int const   )node->key) {
#line 131
            node = node->next;
          } else {
#line 134
            nskip ++;
#line 135
            if (node->value) {
#line 138
              goto while_break;
            }
#line 140
            key ++;
#line 140
            if (! *key) {
#line 142
              nskip = 0;
#line 144
              goto while_break;
            }
#line 146
            node = node->child;
          }
#line 149
          if (! node) {
#line 152
            if (! char2int) {
#line 153
              nskip = 1;
            } else {
              {
#line 152
              nskip = (*char2int)(key_start, (unsigned int *)((void *)0));
              }
#line 152
              if (nskip < 1) {
#line 153
                nskip = 1;
              }
            }
#line 155
            goto while_break;
          }
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 160
  if (skip) {
#line 161
    *skip = nskip;
  }
#line 162
  return (node);
}
}
#line 205 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/romaji.c"
static unsigned char *strdup_lower(unsigned char const   *string ) 
{ 
  unsigned char *out ;
  char *tmp ;
  unsigned char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 208
  tmp = strdup((char const   *)string);
#line 208
  out = (unsigned char *)tmp;
  }
#line 210
  if (out) {
#line 211
    tmp___0 = out;
    {
#line 211
    while (1) {
      while_continue: /* CIL Label */ ;
#line 211
      if (! *tmp___0) {
#line 211
        goto while_break;
      }
      {
#line 212
      tmp___1 = tolower((int )*tmp___0);
#line 212
      *tmp___0 = (unsigned char )tmp___1;
#line 211
      tmp___0 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 213
  return (out);
}
}
#line 216 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/romaji.c"
romaji *romaji_open(void) 
{ 
  void *tmp ;

  {
  {
#line 219
  tmp = calloc((size_t )1, sizeof(romaji ));
  }
#line 219
  return ((romaji *)tmp);
}
}
#line 222 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/romaji.c"
void romaji_close(romaji *object ) 
{ 


  {
#line 225
  if (object) {
#line 227
    if (object->node) {
      {
#line 228
      romanode_delete(object->node);
      }
    }
    {
#line 229
    free((void *)object->fixvalue_xn);
#line 230
    free((void *)object->fixvalue_xtu);
#line 231
    free((void *)object);
    }
  }
#line 233
  return;
}
}
#line 235 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/romaji.c"
int romaji_add_table(romaji *object , unsigned char const   *key , unsigned char const   *value ) 
{ 
  int value_length ;
  romanode **ref_node ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 242
  if (! object) {
#line 243
    return (1);
  } else
#line 242
  if (! key) {
#line 243
    return (1);
  } else
#line 242
  if (! value) {
#line 243
    return (1);
  }
  {
#line 245
  tmp = strlen((char const   *)value);
#line 245
  value_length = (int )tmp;
  }
#line 246
  if (value_length == 0) {
#line 247
    return (2);
  }
  {
#line 249
  ref_node = romanode_dig(& object->node, key);
  }
#line 249
  if (! ref_node) {
#line 251
    return (4);
  }
  {
#line 255
  tmp___0 = strdup((char const   *)value);
#line 255
  (*ref_node)->value = (unsigned char *)tmp___0;
  }
#line 258
  if ((unsigned long )object->fixvalue_xn == (unsigned long )((void *)0)) {
#line 258
    if (value_length > 0) {
      {
#line 258
      tmp___2 = strcmp((char const   *)key, "xn");
      }
#line 258
      if (! tmp___2) {
        {
#line 262
        tmp___1 = strdup((char const   *)value);
#line 262
        object->fixvalue_xn = (unsigned char *)tmp___1;
        }
      }
    }
  }
#line 264
  if ((unsigned long )object->fixvalue_xtu == (unsigned long )((void *)0)) {
#line 264
    if (value_length > 0) {
      {
#line 264
      tmp___4 = strcmp((char const   *)key, "xtu");
      }
#line 264
      if (! tmp___4) {
        {
#line 268
        tmp___3 = strdup((char const   *)value);
#line 268
        object->fixvalue_xtu = (unsigned char *)tmp___3;
        }
      }
    }
  }
#line 271
  return (0);
}
}
#line 274 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/romaji.c"
int romaji_load_stub(romaji *object , FILE *fp ) 
{ 
  int mode ;
  int ch ;
  wordbuf_p buf_key ;
  wordbuf_p buf_value ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned char *key ;
  unsigned char *value ;
  unsigned short const   **tmp___2 ;

  {
  {
#line 281
  buf_key = wordbuf_open();
#line 282
  buf_value = wordbuf_open();
  }
#line 283
  if (! buf_key) {
    {
#line 285
    wordbuf_close(buf_key);
#line 286
    wordbuf_close(buf_value);
    }
#line 287
    return (-1);
  } else
#line 283
  if (! buf_value) {
    {
#line 285
    wordbuf_close(buf_key);
#line 286
    wordbuf_close(buf_value);
    }
#line 287
    return (-1);
  }
#line 290
  mode = 0;
  {
#line 291
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 293
    ch = fgetc(fp);
    }
    {
#line 296
    if (mode == 0) {
#line 296
      goto case_0;
    }
#line 317
    if (mode == 1) {
#line 317
      goto case_1;
    }
#line 323
    if (mode == 2) {
#line 323
      goto case_2;
    }
#line 331
    if (mode == 3) {
#line 331
      goto case_3;
    }
#line 341
    if (mode == 4) {
#line 341
      goto case_4;
    }
#line 294
    goto switch_break;
    case_0: /* CIL Label */ 
#line 298
    if (ch == 35) {
      {
#line 301
      ch = fgetc(fp);
      }
#line 302
      if (ch != 35) {
        {
#line 304
        ungetc(ch, fp);
#line 305
        mode = 1;
        }
#line 306
        goto switch_break;
      }
    }
#line 309
    if (ch != -1) {
      {
#line 309
      tmp = __ctype_b_loc();
      }
#line 309
      if (! ((int const   )*(*tmp + ch) & 8192)) {
        {
#line 311
        wordbuf_reset(buf_key);
#line 312
        wordbuf_add(buf_key, (unsigned char )ch);
#line 313
        mode = 2;
        }
      }
    }
#line 315
    goto switch_break;
    case_1: /* CIL Label */ 
#line 319
    if (ch == 10) {
#line 320
      mode = 0;
    }
#line 321
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 325
    tmp___0 = __ctype_b_loc();
    }
#line 325
    if ((int const   )*(*tmp___0 + ch) & 8192) {
#line 328
      mode = 3;
    } else {
      {
#line 326
      wordbuf_add(buf_key, (unsigned char )ch);
      }
    }
#line 329
    goto switch_break;
    case_3: /* CIL Label */ 
#line 333
    if (ch != -1) {
      {
#line 333
      tmp___1 = __ctype_b_loc();
      }
#line 333
      if (! ((int const   )*(*tmp___1 + ch) & 8192)) {
        {
#line 335
        wordbuf_reset(buf_value);
#line 336
        wordbuf_add(buf_value, (unsigned char )ch);
#line 337
        mode = 4;
        }
      }
    }
#line 339
    goto switch_break;
    case_4: /* CIL Label */ 
#line 343
    if (ch != -1) {
      {
#line 343
      tmp___2 = __ctype_b_loc();
      }
#line 343
      if ((int const   )*(*tmp___2 + ch) & 8192) {
        {
#line 347
        key = buf_key->buf;
#line 348
        value = buf_value->buf;
#line 349
        romaji_add_table(object, (unsigned char const   *)key, (unsigned char const   *)value);
#line 350
        mode = 0;
        }
      } else {
        {
#line 344
        wordbuf_add(buf_value, (unsigned char )ch);
        }
      }
    } else {
      {
#line 347
      key = buf_key->buf;
#line 348
      value = buf_value->buf;
#line 349
      romaji_add_table(object, (unsigned char const   *)key, (unsigned char const   *)value);
#line 350
      mode = 0;
      }
    }
#line 352
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 291
    if (! (ch != -1)) {
#line 291
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 357
  wordbuf_close(buf_key);
#line 358
  wordbuf_close(buf_value);
  }
#line 359
  return (0);
}
}
#line 368 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/romaji.c"
int romaji_load(romaji *object , unsigned char const   *filename ) 
{ 
  FILE *fp ;
  int charset ;
  int result ;

  {
#line 373
  if (! object) {
#line 374
    return (-1);
  } else
#line 373
  if (! filename) {
#line 374
    return (-1);
  }
  {
#line 376
  charset = charset_detect_file((char const   *)filename);
#line 377
  charset_getproc(charset, & object->char2int, (charset_proc_int2char *)((void *)0));
#line 379
  fp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"rt");
  }
#line 379
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 381
    result = romaji_load_stub(object, fp);
#line 381
    result = result;
#line 382
    fclose(fp);
    }
#line 383
    return (result);
  } else {
#line 386
    return (-1);
  }
}
}
#line 389 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/romaji.c"
unsigned char *romaji_convert2(romaji *object , unsigned char const   *string , unsigned char **ppstop ,
                               int ignorecase ) 
{ 
  wordbuf_p buf___1 ;
  unsigned char *lower ;
  unsigned char *answer ;
  unsigned char const   *input ;
  int stop ;
  int i ;
  romanode *node ;
  int skip ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 394
  buf___1 = (wordbuf_p )((void *)0);
#line 395
  lower = (unsigned char *)((void *)0);
#line 396
  answer = (unsigned char *)((void *)0);
#line 397
  input = string;
#line 398
  stop = -1;
#line 400
  if (ignorecase) {
    {
#line 402
    lower = strdup_lower(string);
#line 403
    input = (unsigned char const   *)lower;
    }
  }
#line 406
  if (object) {
#line 406
    if (string) {
#line 406
      if (input) {
        {
#line 406
        buf___1 = wordbuf_open();
        }
#line 406
        if (buf___1) {
#line 410
          i = 0;
          {
#line 410
          while (1) {
            while_continue: /* CIL Label */ ;
#line 410
            if (! *(string + i)) {
#line 410
              goto while_break;
            }
#line 416
            if (object->fixvalue_xtu) {
#line 416
              if ((int const   )*(input + i) == (int const   )*(input + (i + 1))) {
                {
#line 416
                tmp = strchr("aiueon", (int )*(input + i));
                }
#line 416
                if (! tmp) {
                  {
#line 419
                  i ++;
#line 420
                  wordbuf_cat(buf___1, (unsigned char const   *)object->fixvalue_xtu);
                  }
#line 421
                  goto __Cont;
                }
              }
            }
            {
#line 424
            node = romanode_query(object->node, input + i, & skip, object->char2int);
            }
#line 426
            if (skip == 0) {
#line 428
              if (*(string + i)) {
                {
#line 430
                stop = buf___1->last;
#line 431
                wordbuf_cat(buf___1, string + i);
                }
              }
#line 433
              goto while_break;
            } else
#line 435
            if (! node) {
#line 438
              if (skip == 1) {
#line 438
                if ((int const   )*(input + i) == 110) {
#line 438
                  if (object->fixvalue_xn) {
                    {
#line 441
                    i ++;
#line 442
                    wordbuf_cat(buf___1, (unsigned char const   *)object->fixvalue_xn);
                    }
                  } else {
#line 438
                    goto _L___0;
                  }
                } else {
#line 438
                  goto _L___0;
                }
              } else {
                _L___0: /* CIL Label */ 
                {
#line 445
                while (1) {
                  while_continue___0: /* CIL Label */ ;
#line 445
                  tmp___1 = skip;
#line 445
                  skip --;
#line 445
                  if (! tmp___1) {
#line 445
                    goto while_break___0;
                  }
                  {
#line 446
                  tmp___0 = i;
#line 446
                  i ++;
#line 446
                  wordbuf_add(buf___1, (unsigned char )*(string + tmp___0));
                  }
                }
                while_break___0: /* CIL Label */ ;
                }
              }
            } else {
              {
#line 450
              i += skip;
#line 451
              wordbuf_cat(buf___1, (unsigned char const   *)node->value);
              }
            }
            __Cont: /* CIL Label */ ;
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 454
          tmp___2 = strdup((char const   *)buf___1->buf);
#line 454
          answer = (unsigned char *)tmp___2;
          }
        }
      }
    }
  }
#line 456
  if (ppstop) {
#line 457
    if (stop >= 0) {
#line 457
      *ppstop = answer + stop;
    } else {
#line 457
      *ppstop = (unsigned char *)((void *)0);
    }
  }
#line 459
  if (lower) {
    {
#line 460
    free((void *)lower);
    }
  }
#line 461
  if (buf___1) {
    {
#line 462
    wordbuf_close(buf___1);
    }
  }
#line 463
  return (answer);
}
}
#line 466 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/romaji.c"
unsigned char *romaji_convert(romaji *object , unsigned char const   *string , unsigned char **ppstop ) 
{ 
  unsigned char *tmp ;

  {
  {
#line 470
  tmp = romaji_convert2(object, string, ppstop, 1);
  }
#line 470
  return (tmp);
}
}
#line 473 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/romaji.c"
void romaji_release(romaji *object , unsigned char *string ) 
{ 


  {
  {
#line 476
  free((void *)string);
  }
#line 477
  return;
}
}
#line 479 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/romaji.c"
void romaji_setproc_char2int(romaji *object , int (*proc)(unsigned char const   * ,
                                                          unsigned int * ) ) 
{ 


  {
#line 482
  if (object) {
#line 483
    object->char2int = proc;
  }
#line 484
  return;
}
}
#line 486 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/romaji.c"
void romaji_set_verbose(romaji *object , int level ) 
{ 


  {
#line 489
  if (object) {
#line 490
    object->verbose = level;
  }
#line 491
  return;
}
}
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 12 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/filename.c"
static int my_strlen(char const   *s ) 
{ 
  size_t len ;
  int tmp ;

  {
  {
#line 17
  len = strlen(s);
  }
#line 18
  if (len <= 2147483647UL) {
#line 18
    tmp = (int )len;
  } else {
#line 18
    tmp = 2147483647;
  }
#line 18
  return (tmp);
}
}
#line 25 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/filename.c"
int filename_base(char *base , char const   *path ) 
{ 
  int i ;
  int len ;
  int tmp ;
  int end ;

  {
  {
#line 29
  tmp = my_strlen(path);
#line 29
  len = tmp - 1;
#line 32
  i = len;
  }
  {
#line 32
  while (1) {
    while_continue: /* CIL Label */ ;
#line 32
    if (! (i >= 0)) {
#line 32
      goto while_break;
    }
#line 33
    if ((int const   )*(path + i) == 46) {
#line 34
      goto while_break;
    }
#line 32
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 35
  if (i <= 0) {
#line 36
    end = len;
  } else {
#line 38
    end = i - 1;
  }
#line 39
  i = end;
  {
#line 39
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 39
    if (! (i >= 0)) {
#line 39
      goto while_break___0;
    }
#line 40
    if ((int const   )*(path + i) == 92) {
#line 42
      i ++;
#line 43
      goto while_break___0;
    } else
#line 40
    if ((int const   )*(path + i) == 47) {
#line 42
      i ++;
#line 43
      goto while_break___0;
    }
#line 39
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 45
  if (i < 0) {
#line 46
    i ++;
  }
#line 47
  len = (end - i) + 1;
#line 48
  if (base) {
    {
#line 50
    strncpy((char */* __restrict  */)base, (char const   */* __restrict  */)(path + i),
            (size_t )len);
#line 51
    *(base + len) = (char )'\000';
    }
  }
#line 53
  return (len);
}
}
#line 60 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/filename.c"
int filename_directory(char *dir , char const   *path ) 
{ 
  int i ;
  int tmp ;

  {
  {
#line 65
  tmp = my_strlen(path);
#line 65
  i = tmp - 1;
  }
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! (i >= 0)) {
#line 65
      goto while_break;
    }
#line 66
    if ((int const   )*(path + i) == 92) {
#line 67
      goto while_break;
    } else
#line 66
    if ((int const   )*(path + i) == 47) {
#line 67
      goto while_break;
    }
#line 65
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 68
  if (i <= 0) {
#line 70
    if (dir) {
#line 71
      *(dir + 0) = (char )'\000';
    }
#line 72
    return (0);
  }
#line 74
  if (dir) {
    {
#line 76
    strncpy((char */* __restrict  */)dir, (char const   */* __restrict  */)path, (size_t )(i + 1));
#line 77
    *(dir + i) = (char )'\000';
    }
  }
#line 79
  return (i);
}
}
#line 86 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/filename.c"
int filename_extension(char *ext , char const   *path ) 
{ 
  int i ;
  int len ;
  int tmp ;

  {
  {
#line 90
  tmp = my_strlen(path);
#line 90
  len = tmp;
#line 92
  i = len - 1;
  }
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! (i >= 0)) {
#line 92
      goto while_break;
    }
#line 93
    if ((int const   )*(path + i) == 46) {
#line 94
      goto while_break;
    }
#line 92
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  if (i < 0) {
#line 97
    *(ext + 0) = (char )'\000';
#line 98
    return (0);
  } else
#line 95
  if (i == len - 1) {
#line 97
    *(ext + 0) = (char )'\000';
#line 98
    return (0);
  }
#line 100
  i ++;
#line 100
  len -= i;
#line 101
  if (ext) {
    {
#line 102
    strcpy((char */* __restrict  */)ext, (char const   */* __restrict  */)(path + i));
    }
  }
#line 103
  return (len);
}
}
#line 110 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/filename.c"
int filename_filename(char *name , char const   *path ) 
{ 
  int i ;
  int len ;
  int tmp ;

  {
  {
#line 114
  tmp = my_strlen(path);
#line 114
  len = tmp;
#line 116
  i = len - 1;
  }
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! (i >= 0)) {
#line 116
      goto while_break;
    }
#line 117
    if ((int const   )*(path + i) == 92) {
#line 118
      goto while_break;
    } else
#line 117
    if ((int const   )*(path + i) == 47) {
#line 118
      goto while_break;
    }
#line 116
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  i ++;
#line 120
  len -= i;
#line 121
  if (name) {
    {
#line 123
    strncpy((char */* __restrict  */)name, (char const   */* __restrict  */)(path + i),
            (size_t )len);
#line 124
    *(name + len) = (char )'\000';
    }
  }
#line 126
  return (len);
}
}
#line 132 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/filename.c"
int filename_generate(char *filepath , char const   *dir , char const   *base , char const   *ext ) 
{ 
  int len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 136
  len = 0;
#line 138
  if (filepath) {
#line 139
    *(filepath + 0) = (char )'\000';
  }
#line 140
  if (dir) {
#line 142
    if (filepath) {
      {
#line 144
      strcat((char */* __restrict  */)filepath, (char const   */* __restrict  */)dir);
#line 145
      strcat((char */* __restrict  */)filepath, (char const   */* __restrict  */)"/");
      }
    }
    {
#line 147
    tmp = my_strlen(dir);
#line 147
    len += tmp + 1;
    }
  }
#line 149
  if (base) {
#line 151
    if (filepath) {
      {
#line 152
      strcat((char */* __restrict  */)filepath, (char const   */* __restrict  */)base);
      }
    }
    {
#line 153
    tmp___0 = my_strlen(base);
#line 153
    len += tmp___0;
    }
  }
#line 155
  if (ext) {
#line 157
    if (filepath) {
      {
#line 159
      strcat((char */* __restrict  */)filepath, (char const   */* __restrict  */)".");
#line 160
      strcat((char */* __restrict  */)filepath, (char const   */* __restrict  */)ext);
      }
    }
    {
#line 162
    tmp___1 = my_strlen(ext);
#line 162
    len += 1 + tmp___1;
    }
  }
#line 164
  return (len);
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 28 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/wordlist.h"
wordlist_p wordlist_open_len(unsigned char const   *ptr , int len ) ;
#line 29
void wordlist_close(wordlist_p p ) ;
#line 34 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/mnode.h"
int n_mnode_new ;
#line 35
int n_mnode_delete ;
#line 41
mtree_p mnode_open(FILE *fp ) ;
#line 42
mtree_p mnode_load(mtree_p mtree , FILE *fp ) ;
#line 43
void mnode_close(mtree_p mtree ) ;
#line 44
mnode *mnode_query(mtree_p mtree , unsigned char const   *query ) ;
#line 45
void mnode_traverse(mnode *node , void (*proc)(mnode *node , void *data ) , void *data ) ;
#line 48
void mnode_print(mtree_p mtree , unsigned char *p ) ;
#line 36 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/mnode.c"
int n_mnode_new  =    0;
#line 37 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/mnode.c"
int n_mnode_delete  =    0;
#line 39 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/mnode.c"
__inline static mnode *mnode_new(mtree_p mtree ) 
{ 
  mtree_p active ;
  void *tmp ;
  int tmp___0 ;

  {
#line 42
  active = mtree->active;
#line 44
  if (active->used >= 1024) {
    {
#line 46
    tmp = calloc((size_t )1, sizeof(*(active->next)));
#line 46
    active->next = (mtree_p )tmp;
#line 48
    mtree->active = active->next;
#line 49
    active = active->next;
    }
  }
#line 51
  n_mnode_new ++;
#line 52
  tmp___0 = active->used;
#line 52
  (active->used) ++;
#line 52
  return (& active->nodes[tmp___0]);
}
}
#line 55 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/mnode.c"
static void mnode_delete(mnode *p ) 
{ 
  mnode *child ;

  {
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! p) {
#line 58
      goto while_break;
    }
#line 60
    child = p->child;
#line 62
    if (p->list) {
      {
#line 63
      wordlist_close(p->list);
      }
    }
#line 64
    if (p->next) {
      {
#line 65
      mnode_delete(p->next);
      }
    }
#line 67
    p = child;
#line 68
    n_mnode_delete ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return;
}
}
#line 76 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/mnode.c"
static unsigned char buf[256]  ;
#line 73 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/mnode.c"
void mnode_print_stub(mnode *vp , unsigned char *p ) 
{ 


  {
#line 78
  if (! vp) {
#line 79
    return;
  }
#line 80
  if (! p) {
#line 81
    p = & buf[0];
  }
#line 82
  *(p + 0) = (unsigned char )vp->attr;
#line 83
  *(p + 1) = (unsigned char )'\000';
#line 84
  if (vp->list) {
    {
#line 85
    printf((char const   */* __restrict  */)"%s (list=%p)\n", buf, vp->list);
    }
  }
#line 86
  if (vp->child) {
    {
#line 87
    mnode_print_stub(vp->child, p + 1);
    }
  }
#line 88
  if (vp->next) {
    {
#line 89
    mnode_print_stub(vp->next, p);
    }
  }
#line 90
  return;
}
}
#line 92 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/mnode.c"
void mnode_print(mtree_p mtree , unsigned char *p ) 
{ 


  {
#line 95
  if (mtree) {
#line 95
    if (mtree->used > 0) {
      {
#line 96
      mnode_print_stub(& mtree->nodes[0], p);
      }
    }
  }
#line 97
  return;
}
}
#line 99 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/mnode.c"
void mnode_close(mtree_p mtree ) 
{ 
  mtree_p next ;

  {
#line 102
  if (mtree) {
#line 106
    if (mtree->used > 0) {
      {
#line 107
      mnode_delete(& mtree->nodes[0]);
      }
    }
    {
#line 109
    while (1) {
      while_continue: /* CIL Label */ ;
#line 109
      if (! mtree) {
#line 109
        goto while_break;
      }
      {
#line 111
      next = mtree->next;
#line 112
      free((void *)mtree);
#line 113
      mtree = next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 116
  return;
}
}
#line 118 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/mnode.c"
__inline static mnode *search_or_new_mnode(mtree_p mtree , wordbuf_p buf___1 ) 
{ 
  int ch ;
  unsigned char *word ;
  mnode **ppnext ;
  mnode **res ;
  mnode *root ;

  {
#line 125
  res = (mnode **)((void *)0);
#line 128
  word = buf___1->buf;
#line 129
  if (mtree->used > 0) {
#line 129
    root = & mtree->nodes[0];
  } else {
#line 129
    root = (mnode *)((void *)0);
  }
#line 130
  ppnext = & root;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    ch = (int )*word;
#line 131
    if (! (ch != 0)) {
#line 131
      goto while_break;
    }
#line 133
    res = ppnext;
#line 134
    if (! *res) {
      {
#line 136
      *res = mnode_new(mtree);
#line 137
      (*res)->attr = (unsigned int )ch;
      }
    } else
#line 139
    if ((int )((unsigned char )(*res)->attr) != ch) {
#line 141
      ppnext = & (*res)->next;
#line 142
      goto while_continue;
    }
#line 144
    ppnext = & (*res)->child;
#line 145
    word ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  return (*res);
}
}
#line 155 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/mnode.c"
mtree_p mnode_load(mtree_p mtree , FILE *fp ) 
{ 
  mnode *pp ;
  int mode ;
  int ch ;
  wordbuf_p buf___1 ;
  wordbuf_p prevlabel ;
  wordlist_p *ppword ;
  unsigned char cache[16384] ;
  unsigned char *cache_ptr ;
  unsigned char *cache_tail ;
  size_t tmp ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  {
#line 158
  pp = (mnode *)((void *)0);
#line 159
  mode = 0;
#line 163
  ppword = (wordlist_p *)((void *)0);
#line 166
  cache_ptr = cache;
#line 167
  cache_tail = cache;
#line 169
  buf___1 = wordbuf_open();
#line 170
  prevlabel = wordbuf_open();
  }
#line 171
  if (! fp) {
#line 173
    goto END_MNODE_LOAD;
  } else
#line 171
  if (! buf___1) {
#line 173
    goto END_MNODE_LOAD;
  } else
#line 171
  if (! prevlabel) {
#line 173
    goto END_MNODE_LOAD;
  }
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if ((unsigned long )cache_ptr >= (unsigned long )cache_tail) {
      {
#line 185
      cache_ptr = cache;
#line 186
      tmp = fread((void */* __restrict  */)(cache), (size_t )1, (size_t )16384, (FILE */* __restrict  */)fp);
#line 186
      cache_tail = cache + tmp;
      }
#line 187
      if ((unsigned long )cache_tail <= (unsigned long )(cache)) {
        {
#line 187
        tmp___1 = feof(fp);
        }
#line 187
        if (tmp___1) {
#line 187
          ch = -1;
        } else {
#line 187
          ch = (int )*cache_ptr;
        }
      } else {
#line 187
        ch = (int )*cache_ptr;
      }
    } else {
#line 190
      ch = (int )*cache_ptr;
    }
#line 191
    cache_ptr ++;
    {
#line 196
    if (mode == 0) {
#line 196
      goto case_0;
    }
#line 214
    if (mode == 1) {
#line 214
      goto case_1;
    }
#line 229
    if (mode == 2) {
#line 229
      goto case_2;
    }
#line 237
    if (mode == 3) {
#line 237
      goto case_3;
    }
#line 256
    if (mode == 4) {
#line 256
      goto case_4;
    }
#line 194
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 198
    tmp___2 = __ctype_b_loc();
    }
#line 198
    if ((int const   )*(*tmp___2 + ch) & 8192) {
#line 199
      goto __Cont;
    } else
#line 198
    if (ch == -1) {
#line 199
      goto __Cont;
    } else
#line 201
    if (ch == 59) {
#line 203
      mode = 2;
#line 204
      goto __Cont;
    } else {
      {
#line 208
      mode = 1;
#line 209
      wordbuf_reset(buf___1);
#line 210
      wordbuf_add(buf___1, (unsigned char )ch);
      }
    }
#line 212
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 221
    if (ch == 9) {
#line 221
      goto case_9;
    }
#line 218
    goto switch_default;
    switch_default: /* CIL Label */ 
    {
#line 219
    wordbuf_add(buf___1, (unsigned char )ch);
    }
#line 220
    goto switch_break___0;
    case_9: /* CIL Label */ 
    {
#line 222
    pp = search_or_new_mnode(mtree, buf___1);
#line 223
    wordbuf_reset(buf___1);
#line 224
    mode = 3;
    }
#line 225
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 227
    goto switch_break;
    case_2: /* CIL Label */ 
#line 230
    if (ch == 10) {
      {
#line 232
      wordbuf_reset(buf___1);
#line 233
      mode = 0;
      }
    }
#line 235
    goto switch_break;
    case_3: /* CIL Label */ 
#line 238
    if (ch == 10) {
      {
#line 240
      wordbuf_reset(buf___1);
#line 241
      mode = 0;
      }
    } else
#line 243
    if (ch != 9) {
      {
#line 246
      wordbuf_reset(buf___1);
#line 247
      wordbuf_add(buf___1, (unsigned char )ch);
#line 249
      ppword = & pp->list;
      }
      {
#line 250
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 250
        if (! *ppword) {
#line 250
          goto while_break___0;
        }
#line 251
        ppword = & (*ppword)->next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 252
      mode = 4;
    }
#line 254
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 260
    if (ch == 10) {
#line 260
      goto case_10;
    }
#line 260
    if (ch == 9) {
#line 260
      goto case_10;
    }
#line 277
    goto switch_default___0;
    case_10: /* CIL Label */ 
    case_9___0: /* CIL Label */ 
    {
#line 262
    *ppword = wordlist_open_len((unsigned char const   *)buf___1->buf, buf___1->last);
#line 264
    wordbuf_reset(buf___1);
    }
#line 266
    if (ch == 9) {
#line 268
      ppword = & (*ppword)->next;
#line 269
      mode = 3;
    } else {
#line 273
      ppword = (wordlist_p *)((void *)0);
#line 274
      mode = 0;
    }
#line 276
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
    {
#line 278
    wordbuf_add(buf___1, (unsigned char )ch);
    }
#line 279
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 281
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 181
    if (! (ch != -1)) {
#line 181
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  END_MNODE_LOAD: 
  {
#line 287
  wordbuf_close(buf___1);
#line 288
  wordbuf_close(prevlabel);
  }
#line 289
  return (mtree);
}
}
#line 292 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/mnode.c"
mtree_p mnode_open(FILE *fp ) 
{ 
  mtree_p mtree ;
  void *tmp ;

  {
  {
#line 297
  tmp = calloc((size_t )1, sizeof(*mtree));
#line 297
  mtree = (mtree_p )tmp;
#line 298
  mtree->active = mtree;
  }
#line 299
  if (mtree) {
#line 299
    if (fp) {
      {
#line 300
      mnode_load(mtree, fp);
      }
    }
  }
#line 302
  return (mtree);
}
}
#line 313 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/mnode.c"
static mnode *mnode_query_stub(mnode *node , unsigned char const   *query ) 
{ 
  mnode *tmp ;
  mnode *tmp___0 ;
  mnode *tmp___1 ;

  {
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 318
    if ((int const   )*query == (int const   )((unsigned char )node->attr)) {
#line 319
      query ++;
#line 319
      if ((int const   )*query == 0) {
#line 319
        tmp___1 = node;
      } else {
#line 319
        if (node->child) {
          {
#line 319
          tmp = mnode_query_stub(node->child, query);
#line 319
          tmp___0 = tmp;
          }
        } else {
#line 319
          tmp___0 = (mnode *)((void *)0);
        }
#line 319
        tmp___1 = tmp___0;
      }
#line 319
      return (tmp___1);
    }
#line 321
    node = node->next;
#line 321
    if (! node) {
#line 322
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 324
  return ((mnode *)((void *)0));
}
}
#line 327 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/mnode.c"
mnode *mnode_query(mtree_p mtree , unsigned char const   *query ) 
{ 
  mnode *tmp ;
  mnode *tmp___0 ;

  {
#line 330
  if (query) {
#line 330
    if ((int const   )*query != 0) {
#line 330
      if (mtree) {
        {
#line 330
        tmp = mnode_query_stub(& mtree->nodes[0], query);
#line 330
        tmp___0 = tmp;
        }
      } else {
#line 330
        tmp___0 = (mnode *)0;
      }
    } else {
#line 330
      tmp___0 = (mnode *)0;
    }
  } else {
#line 330
    tmp___0 = (mnode *)0;
  }
#line 330
  return (tmp___0);
}
}
#line 334 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/mnode.c"
static void mnode_traverse_stub(mnode *node , void (*proc)(mnode *node , void *data ) ,
                                void *data ) 
{ 


  {
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 339
    if (node->child) {
      {
#line 340
      mnode_traverse_stub(node->child, proc, data);
      }
    }
    {
#line 341
    (*proc)(node, data);
#line 342
    node = node->next;
    }
#line 342
    if (! node) {
#line 343
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 345
  return;
}
}
#line 347 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/mnode.c"
void mnode_traverse(mnode *node , void (*proc)(mnode *node , void *data ) , void *data ) 
{ 


  {
#line 350
  if (node) {
#line 350
    if (proc) {
      {
#line 352
      (*proc)(node, data);
      }
#line 353
      if (node->child) {
        {
#line 354
        mnode_traverse_stub(node->child, proc, data);
        }
      }
    }
  }
#line 356
  return;
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 48 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.h"
migemo *migemo_open(char const   *dict ) ;
#line 49
void migemo_close(migemo *obj ) ;
#line 50
unsigned char *migemo_query(migemo *object , unsigned char const   *query ) ;
#line 52
void migemo_release(migemo *p , unsigned char *string ) ;
#line 55
int migemo_set_operator(migemo *object , int index___0 , unsigned char const   *op ) ;
#line 57
unsigned char const   *migemo_get_operator(migemo *object , int index___0 ) ;
#line 59
void migemo_setproc_char2int(migemo *object , int (*proc)(unsigned char const   * ,
                                                          unsigned int * ) ) ;
#line 61
void migemo_setproc_int2char(migemo *object , int (*proc)(unsigned int  , unsigned char * ) ) ;
#line 64
int migemo_load(migemo *obj , int dict_id , char const   *dict_file ) ;
#line 66
int migemo_is_enable(migemo *obj ) ;
#line 53 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.c"
static unsigned char const   VOWEL_CHARS[6]  = {      (unsigned char const   )'a',      (unsigned char const   )'i',      (unsigned char const   )'u',      (unsigned char const   )'e', 
        (unsigned char const   )'o',      (unsigned char const   )'\000'};
#line 55 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.c"
static int my_strlen___0(char const   *s ) 
{ 
  size_t len ;
  int tmp ;

  {
  {
#line 60
  len = strlen(s);
  }
#line 61
  if (len <= 2147483647UL) {
#line 61
    tmp = (int )len;
  } else {
#line 61
    tmp = 2147483647;
  }
#line 61
  return (tmp);
}
}
#line 64 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.c"
static mtree_p load_mtree_dictionary(mtree_p mtree , char const   *dict_file ) 
{ 
  FILE *fp ;

  {
  {
#line 69
  fp = fopen((char const   */* __restrict  */)dict_file, (char const   */* __restrict  */)"rt");
  }
#line 69
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 70
    return ((mtree_p )((void *)0));
  }
  {
#line 71
  mtree = mnode_load(mtree, fp);
#line 72
  fclose(fp);
  }
#line 73
  return (mtree);
}
}
#line 76 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.c"
static mtree_p load_mtree_dictionary2(migemo *obj , char const   *dict_file ) 
{ 
  int (*char2int)(unsigned char const   * , unsigned int * ) ;
  int (*int2char)(unsigned int  , unsigned char * ) ;
  mtree_p tmp ;

  {
#line 79
  if (obj->charset == 0) {
    {
#line 82
    char2int = (int (*)(unsigned char const   * , unsigned int * ))((void *)0);
#line 83
    int2char = (int (*)(unsigned int  , unsigned char * ))((void *)0);
#line 84
    obj->charset = charset_detect_file(dict_file);
#line 85
    charset_getproc(obj->charset, & char2int, & int2char);
    }
#line 86
    if (char2int) {
      {
#line 88
      migemo_setproc_char2int(obj, char2int);
#line 89
      obj->char2int = char2int;
      }
    }
#line 91
    if (int2char) {
      {
#line 92
      migemo_setproc_int2char(obj, int2char);
      }
    }
  }
  {
#line 94
  tmp = load_mtree_dictionary(obj->mtree, dict_file);
  }
#line 94
  return (tmp);
}
}
#line 97 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.c"
static void dircat(char *buf___1 , char const   *dir , char const   *file ) 
{ 


  {
  {
#line 100
  strcpy((char */* __restrict  */)buf___1, (char const   */* __restrict  */)dir);
#line 101
  strcat((char */* __restrict  */)buf___1, (char const   */* __restrict  */)"/");
#line 102
  strcat((char */* __restrict  */)buf___1, (char const   */* __restrict  */)file);
  }
#line 103
  return;
}
}
#line 135 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.c"
int migemo_load(migemo *obj , int dict_id , char const   *dict_file ) 
{ 
  mtree_p mtree ;
  romaji *dict ;
  int tmp ;

  {
#line 138
  if (! obj) {
#line 138
    if (dict_file) {
#line 139
      return (0);
    }
  }
#line 141
  if (dict_id == 1) {
    {
#line 146
    mtree = load_mtree_dictionary2(obj, dict_file);
    }
#line 146
    if ((unsigned long )mtree == (unsigned long )((void *)0)) {
#line 147
      return (0);
    }
#line 148
    obj->mtree = mtree;
#line 149
    obj->enable = 1;
#line 150
    return (dict_id);
  } else {
    {
#line 158
    if (dict_id == 2) {
#line 158
      goto case_2;
    }
#line 162
    if (dict_id == 3) {
#line 162
      goto case_3;
    }
#line 166
    if (dict_id == 4) {
#line 166
      goto case_4;
    }
#line 170
    if (dict_id == 5) {
#line 170
      goto case_5;
    }
#line 174
    goto switch_default;
    case_2: /* CIL Label */ 
#line 160
    dict = obj->roma2hira;
#line 161
    goto switch_break;
    case_3: /* CIL Label */ 
#line 164
    dict = obj->hira2kata;
#line 165
    goto switch_break;
    case_4: /* CIL Label */ 
#line 168
    dict = obj->han2zen;
#line 169
    goto switch_break;
    case_5: /* CIL Label */ 
#line 172
    dict = obj->zen2han;
#line 173
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 175
    dict = (romaji *)((void *)0);
#line 176
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 178
    if (dict) {
      {
#line 178
      tmp = romaji_load(dict, (unsigned char const   *)dict_file);
      }
#line 178
      if (tmp == 0) {
#line 179
        return (dict_id);
      } else {
#line 181
        return (0);
      }
    } else {
#line 181
      return (0);
    }
  }
}
}
#line 206 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.c"
migemo *migemo_open(char const   *dict ) 
{ 
  migemo *obj ;
  void *tmp ;
  char dir[1024] ;
  char roma_dict[1024] ;
  char kata_dict[1024] ;
  char h2z_dict[1024] ;
  char z2h_dict[1024] ;
  char const   *tmp___0 ;
  mtree_p mtree ;
  size_t tmp___2 ;

  {
  {
#line 212
  tmp = calloc((size_t )1, sizeof(migemo ));
#line 212
  obj = (migemo *)tmp;
  }
#line 212
  if (! obj) {
#line 213
    return (obj);
  }
  {
#line 214
  obj->enable = 0;
#line 215
  obj->mtree = mnode_open((FILE *)((void *)0));
#line 216
  obj->charset = 0;
#line 217
  obj->rx = rxgen_open();
#line 218
  obj->roma2hira = romaji_open();
#line 219
  obj->hira2kata = romaji_open();
#line 220
  obj->han2zen = romaji_open();
#line 221
  obj->zen2han = romaji_open();
  }
#line 222
  if (! obj->rx) {
    {
#line 225
    migemo_close(obj);
#line 226
    obj = (migemo *)((void *)0);
    }
#line 226
    return (obj);
  } else
#line 222
  if (! obj->roma2hira) {
    {
#line 225
    migemo_close(obj);
#line 226
    obj = (migemo *)((void *)0);
    }
#line 226
    return (obj);
  } else
#line 222
  if (! obj->hira2kata) {
    {
#line 225
    migemo_close(obj);
#line 226
    obj = (migemo *)((void *)0);
    }
#line 226
    return (obj);
  } else
#line 222
  if (! obj->han2zen) {
    {
#line 225
    migemo_close(obj);
#line 226
    obj = (migemo *)((void *)0);
    }
#line 226
    return (obj);
  } else
#line 222
  if (! obj->zen2han) {
    {
#line 225
    migemo_close(obj);
#line 226
    obj = (migemo *)((void *)0);
    }
#line 226
    return (obj);
  }
#line 230
  if (dict) {
    {
#line 243
    filename_directory(dir, dict);
#line 244
    tmp___2 = strlen((char const   *)(dir));
    }
#line 244
    if (tmp___2) {
#line 244
      tmp___0 = (char const   *)(dir);
    } else {
#line 244
      tmp___0 = ".";
    }
    {
#line 245
    dircat(roma_dict, tmp___0, "roma2hira.dat");
#line 246
    dircat(kata_dict, tmp___0, "hira2kata.dat");
#line 247
    dircat(h2z_dict, tmp___0, "han2zen.dat");
#line 248
    dircat(z2h_dict, tmp___0, "zen2han.dat");
#line 250
    mtree = load_mtree_dictionary2(obj, dict);
    }
#line 251
    if (mtree) {
      {
#line 253
      obj->mtree = mtree;
#line 254
      obj->enable = 1;
#line 255
      romaji_load(obj->roma2hira, (unsigned char const   *)(roma_dict));
#line 256
      romaji_load(obj->hira2kata, (unsigned char const   *)(kata_dict));
#line 257
      romaji_load(obj->han2zen, (unsigned char const   *)(h2z_dict));
#line 258
      romaji_load(obj->zen2han, (unsigned char const   *)(z2h_dict));
      }
    }
  }
#line 261
  return (obj);
}
}
#line 268 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.c"
void migemo_close(migemo *obj ) 
{ 


  {
#line 271
  if (obj) {
#line 273
    if (obj->zen2han) {
      {
#line 274
      romaji_close(obj->zen2han);
      }
    }
#line 275
    if (obj->han2zen) {
      {
#line 276
      romaji_close(obj->han2zen);
      }
    }
#line 277
    if (obj->hira2kata) {
      {
#line 278
      romaji_close(obj->hira2kata);
      }
    }
#line 279
    if (obj->roma2hira) {
      {
#line 280
      romaji_close(obj->roma2hira);
      }
    }
#line 281
    if (obj->rx) {
      {
#line 282
      rxgen_close(obj->rx);
      }
    }
#line 283
    if (obj->mtree) {
      {
#line 284
      mnode_close(obj->mtree);
      }
    }
    {
#line 285
    free((void *)obj);
    }
  }
#line 287
  return;
}
}
#line 296 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.c"
static void migemo_query_proc(mnode *p , void *data ) 
{ 
  migemo *object ;
  wordlist_p list ;

  {
#line 299
  object = (migemo *)data;
#line 300
  list = p->list;
  {
#line 302
  while (1) {
    while_continue: /* CIL Label */ ;
#line 302
    if (! list) {
#line 302
      goto while_break;
    }
    {
#line 303
    (*(object->addword))((void *)object, list->ptr);
#line 302
    list = list->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 304
  return;
}
}
#line 309 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.c"
static void add_mnode_query(migemo *object , unsigned char *query ) 
{ 
  mnode *pnode ;

  {
  {
#line 314
  pnode = mnode_query(object->mtree, (unsigned char const   *)query);
  }
#line 314
  if ((unsigned long )pnode != (unsigned long )((void *)0)) {
    {
#line 315
    mnode_traverse(pnode, & migemo_query_proc, (void *)object);
    }
  }
#line 316
  return;
}
}
#line 321 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.c"
static int add_roma(migemo *object , unsigned char *query ) 
{ 
  unsigned char *stop ;
  unsigned char *hira ;
  unsigned char *kata ;
  unsigned char *han ;
  int tmp ;

  {
  {
#line 326
  hira = romaji_convert(object->roma2hira, (unsigned char const   *)query, & stop);
  }
#line 327
  if (! stop) {
    {
#line 329
    (*(object->addword))((void *)object, hira);
#line 331
    add_mnode_query(object, hira);
#line 333
    kata = romaji_convert2(object->hira2kata, (unsigned char const   *)hira, (unsigned char **)((void *)0),
                           0);
#line 334
    (*(object->addword))((void *)object, kata);
#line 337
    han = romaji_convert2(object->zen2han, (unsigned char const   *)kata, (unsigned char **)((void *)0),
                          0);
#line 338
    (*(object->addword))((void *)object, han);
#line 340
    romaji_release(object->zen2han, han);
#line 343
    add_mnode_query(object, kata);
#line 344
    romaji_release(object->hira2kata, kata);
    }
  }
  {
#line 346
  romaji_release(object->roma2hira, hira);
  }
#line 348
  if (stop) {
#line 348
    tmp = 1;
  } else {
#line 348
    tmp = 0;
  }
#line 348
  return (tmp);
}
}
#line 354 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.c"
static void add_dubious_vowels(migemo *object , unsigned char *buf___1 , int index___0 ) 
{ 
  unsigned char const   *ptr ;

  {
#line 358
  ptr = VOWEL_CHARS;
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 358
    if (! *ptr) {
#line 358
      goto while_break;
    }
    {
#line 360
    *(buf___1 + index___0) = (unsigned char )*ptr;
#line 361
    add_roma(object, buf___1);
#line 358
    ptr ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 363
  return;
}
}
#line 369 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.c"
static void add_dubious_roma(migemo *object , rxgen *rx , unsigned char *query ) 
{ 
  int max ;
  int len ;
  char *buf___1 ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 376
  len = my_strlen___0((char const   *)query);
  }
#line 376
  if (! len) {
#line 377
    return;
  }
  {
#line 382
  max = ((len + 1) + 3) + 1;
#line 383
  tmp = malloc((size_t )max);
#line 383
  buf___1 = (char *)tmp;
  }
#line 384
  if ((unsigned long )buf___1 == (unsigned long )((void *)0)) {
#line 385
    return;
  }
  {
#line 386
  memcpy((void */* __restrict  */)buf___1, (void const   */* __restrict  */)query,
         (size_t )len);
#line 387
  memset((void *)(buf___1 + len), 0, (size_t )(max - len));
#line 389
  tmp___1 = strchr((char const   *)(VOWEL_CHARS), (int )*(buf___1 + (len - 1)));
  }
#line 389
  if (! tmp___1) {
    {
#line 391
    add_dubious_vowels(object, (unsigned char *)buf___1, len);
    }
#line 393
    if (len < 2) {
#line 393
      goto _L;
    } else {
      {
#line 393
      tmp___0 = strchr((char const   *)(VOWEL_CHARS), (int )*(buf___1 + (len - 2)));
      }
#line 393
      if (tmp___0) {
        _L: /* CIL Label */ 
#line 395
        if ((int )*(buf___1 + (len - 1)) == 110) {
          {
#line 398
          memcpy((void */* __restrict  */)(buf___1 + (len - 1)), (void const   */* __restrict  */)"xn",
                 (size_t )2);
#line 399
          add_roma(object, (unsigned char *)buf___1);
          }
        } else {
          {
#line 404
          *(buf___1 + (len + 2)) = *(buf___1 + (len - 1));
#line 405
          memcpy((void */* __restrict  */)(buf___1 + (len - 1)), (void const   */* __restrict  */)"xtu",
                 (size_t )3);
#line 406
          add_dubious_vowels(object, (unsigned char *)buf___1, len + 3);
          }
        }
      }
    }
  }
  {
#line 411
  free((void *)buf___1);
  }
#line 412
  return;
}
}
#line 418 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.c"
static wordlist_p parse_query(migemo *object , unsigned char const   *query ) 
{ 
  unsigned char const   *curr ;
  unsigned char const   *start ;
  wordlist_p querylist ;
  wordlist_p *pp ;
  int len ;
  int upper ;
  int sum ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 421
  curr = query;
#line 422
  start = (unsigned char const   *)((void *)0);
#line 423
  querylist = (wordlist_p )((void *)0);
#line 423
  pp = & querylist;
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 428
    sum = 0;
#line 430
    if (! object->char2int) {
#line 431
      len = 1;
    } else {
      {
#line 430
      len = (*(object->char2int))(curr, (unsigned int *)((void *)0));
      }
#line 430
      if (len < 1) {
#line 431
        len = 1;
      }
    }
#line 432
    start = curr;
#line 433
    if (len == 1) {
      {
#line 433
      tmp = __ctype_b_loc();
      }
#line 433
      if ((int const   )*(*tmp + (int )*curr) & 256) {
        {
#line 433
        tmp___0 = __ctype_b_loc();
        }
#line 433
        if ((int const   )*(*tmp___0 + (int )*(curr + 1)) & 256) {
#line 433
          tmp___1 = 1;
        } else {
#line 433
          tmp___1 = 0;
        }
      } else {
#line 433
        tmp___1 = 0;
      }
    } else {
#line 433
      tmp___1 = 0;
    }
#line 433
    upper = tmp___1;
#line 434
    curr += len;
#line 435
    sum += len;
    {
#line 436
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 438
      if (! object->char2int) {
#line 439
        len = 1;
      } else {
        {
#line 438
        len = (*(object->char2int))(curr, (unsigned int *)((void *)0));
        }
#line 438
        if (len < 1) {
#line 439
          len = 1;
        }
      }
#line 440
      if ((int const   )*curr == 0) {
#line 441
        goto while_break___0;
      } else
#line 440
      if (len == 1) {
        {
#line 440
        tmp___2 = __ctype_b_loc();
        }
#line 440
        if ((((int const   )*(*tmp___2 + (int )*curr) & 256) != 0) != upper) {
#line 441
          goto while_break___0;
        }
      }
#line 442
      curr += len;
#line 443
      sum += len;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 446
    if (start) {
#line 446
      if ((unsigned long )start < (unsigned long )curr) {
        {
#line 448
        *pp = wordlist_open_len(start, sum);
#line 449
        pp = & (*pp)->next;
        }
      }
    }
#line 451
    if ((int const   )*curr == 0) {
#line 452
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 454
  return (querylist);
}
}
#line 460 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.c"
static int query_a_word(migemo *object , unsigned char *query ) 
{ 
  unsigned char *zen ;
  unsigned char *han ;
  unsigned char *lower ;
  int len ;
  int tmp ;
  void *tmp___0 ;
  int i ;
  int step ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;

  {
  {
#line 466
  tmp = my_strlen___0((char const   *)query);
#line 466
  len = tmp;
#line 469
  (*(object->addword))((void *)object, query);
#line 471
  tmp___0 = malloc((size_t )(len + 1));
#line 471
  lower = (unsigned char *)tmp___0;
  }
#line 472
  if (! lower) {
    {
#line 473
    add_mnode_query(object, query);
    }
  } else {
#line 476
    i = 0;
    {
#line 479
    while (1) {
      while_continue: /* CIL Label */ ;
#line 479
      if (! (i <= len)) {
#line 479
        goto while_break;
      }
#line 481
      if (! object->char2int) {
#line 483
        step = 1;
      } else {
        {
#line 481
        step = (*(object->char2int))((unsigned char const   *)(query + i), (unsigned int *)((void *)0));
        }
#line 481
        if (step < 1) {
#line 483
          step = 1;
        }
      }
#line 484
      if (step == 1) {
        {
#line 484
        tmp___2 = __ctype_b_loc();
        }
#line 484
        if ((int const   )*(*tmp___2 + (int )*(query + i)) & 256) {
          {
#line 485
          tmp___1 = tolower((int )*(query + i));
#line 485
          *(lower + i) = (unsigned char )tmp___1;
          }
        } else {
          {
#line 487
          memcpy((void */* __restrict  */)(lower + i), (void const   */* __restrict  */)(query + i),
                 (size_t )step);
          }
        }
      } else {
        {
#line 487
        memcpy((void */* __restrict  */)(lower + i), (void const   */* __restrict  */)(query + i),
               (size_t )step);
        }
      }
#line 488
      i += step;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 490
    add_mnode_query(object, lower);
#line 491
    free((void *)lower);
    }
  }
  {
#line 495
  zen = romaji_convert2(object->han2zen, (unsigned char const   *)query, (unsigned char **)((void *)0),
                        0);
  }
#line 496
  if ((unsigned long )zen != (unsigned long )((void *)0)) {
    {
#line 498
    (*(object->addword))((void *)object, zen);
#line 499
    romaji_release(object->han2zen, zen);
    }
  }
  {
#line 503
  han = romaji_convert2(object->zen2han, (unsigned char const   *)query, (unsigned char **)((void *)0),
                        0);
  }
#line 504
  if ((unsigned long )han != (unsigned long )((void *)0)) {
    {
#line 506
    (*(object->addword))((void *)object, han);
#line 507
    romaji_release(object->zen2han, han);
    }
  }
  {
#line 511
  tmp___3 = add_roma(object, query);
  }
#line 511
  if (tmp___3) {
    {
#line 512
    add_dubious_roma(object, object->rx, query);
    }
  }
#line 514
  return (1);
}
}
#line 517 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.c"
static int addword_rxgen(migemo *object , unsigned char *word ) 
{ 
  int tmp ;

  {
  {
#line 522
  tmp = rxgen_add(object->rx, (unsigned char const   *)word);
  }
#line 522
  return (tmp);
}
}
#line 533 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.c"
unsigned char *migemo_query(migemo *object , unsigned char const   *query ) 
{ 
  unsigned char *retval ;
  wordlist_p querylist ;
  wordbuf_p outbuf ;
  wordlist_p p ;
  unsigned char *answer ;

  {
#line 536
  retval = (unsigned char *)((void *)0);
#line 537
  querylist = (wordlist_p )((void *)0);
#line 538
  outbuf = (wordbuf_p )((void *)0);
#line 540
  if (object) {
#line 540
    if (object->rx) {
#line 540
      if (query) {
        {
#line 544
        querylist = parse_query(object, query);
        }
#line 545
        if ((unsigned long )querylist == (unsigned long )((void *)0)) {
#line 546
          goto MIGEMO_QUERY_END;
        }
        {
#line 547
        outbuf = wordbuf_open();
        }
#line 548
        if ((unsigned long )outbuf == (unsigned long )((void *)0)) {
#line 549
          goto MIGEMO_QUERY_END;
        }
        {
#line 552
        object->addword = (int (*)(void *data , unsigned char *word ))(& addword_rxgen);
#line 553
        rxgen_reset(object->rx);
#line 554
        p = querylist;
        }
        {
#line 554
        while (1) {
          while_continue: /* CIL Label */ ;
#line 554
          if (! p) {
#line 554
            goto while_break;
          }
          {
#line 559
          query_a_word(object, p->ptr);
#line 561
          answer = rxgen_generate(object->rx);
#line 562
          rxgen_reset(object->rx);
#line 563
          wordbuf_cat(outbuf, (unsigned char const   *)answer);
#line 564
          rxgen_release(object->rx, answer);
#line 554
          p = p->next;
          }
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
  MIGEMO_QUERY_END: 
#line 569
  if (outbuf) {
    {
#line 571
    retval = outbuf->buf;
#line 572
    outbuf->buf = (unsigned char *)((void *)0);
#line 573
    wordbuf_close(outbuf);
    }
  }
#line 575
  if (querylist) {
    {
#line 576
    wordlist_close(querylist);
    }
  }
#line 578
  return (retval);
}
}
#line 586 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.c"
void migemo_release(migemo *p , unsigned char *string ) 
{ 


  {
  {
#line 589
  free((void *)string);
  }
#line 590
  return;
}
}
#line 624 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.c"
int migemo_set_operator(migemo *object , int index___0 , unsigned char const   *op ) 
{ 
  int retval ;
  int tmp ;
  int tmp___0 ;

  {
#line 627
  if (object) {
    {
#line 629
    tmp = rxgen_set_operator(object->rx, index___0, op);
#line 629
    retval = tmp;
    }
#line 630
    if (retval) {
#line 630
      tmp___0 = 0;
    } else {
#line 630
      tmp___0 = 1;
    }
#line 630
    return (tmp___0);
  } else {
#line 633
    return (0);
  }
}
}
#line 645 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.c"
unsigned char const   *migemo_get_operator(migemo *object , int index___0 ) 
{ 
  unsigned char const   *tmp ;
  unsigned char const   *tmp___0 ;

  {
#line 648
  if (object) {
    {
#line 648
    tmp = rxgen_get_operator(object->rx, index___0);
#line 648
    tmp___0 = tmp;
    }
  } else {
#line 648
    tmp___0 = (unsigned char const   *)((void *)0);
  }
#line 648
  return (tmp___0);
}
}
#line 657 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.c"
void migemo_setproc_char2int(migemo *object , int (*proc)(unsigned char const   * ,
                                                          unsigned int * ) ) 
{ 


  {
#line 660
  if (object) {
    {
#line 661
    rxgen_setproc_char2int(object->rx, proc);
    }
  }
#line 662
  return;
}
}
#line 670 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.c"
void migemo_setproc_int2char(migemo *object , int (*proc)(unsigned int  , unsigned char * ) ) 
{ 


  {
#line 673
  if (object) {
    {
#line 674
    rxgen_setproc_int2char(object->rx, proc);
    }
  }
#line 675
  return;
}
}
#line 684 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.c"
int migemo_is_enable(migemo *obj ) 
{ 
  int tmp ;

  {
#line 687
  if (obj) {
#line 687
    tmp = obj->enable;
  } else {
#line 687
    tmp = 0;
  }
#line 687
  return (tmp);
}
}
#line 694 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.c"
void migemo_print(migemo *object ) 
{ 


  {
#line 697
  if (object) {
    {
#line 698
    mnode_print(object->mtree, (unsigned char *)((void *)0));
    }
  }
#line 699
  return;
}
}
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 19 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/wordbuf.h"
int n_wordbuf_open ;
#line 20
int n_wordbuf_close ;
#line 33
int wordbuf_last(wordbuf_p p ) ;
#line 36
unsigned char *wordbuf_get(wordbuf_p p ) ;
#line 17 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/wordbuf.c"
int n_wordbuf_open  =    0;
#line 18 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/wordbuf.c"
int n_wordbuf_close  =    0;
#line 21
static int wordbuf_extend(wordbuf_p p , int req_len ) ;
#line 23 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/wordbuf.c"
wordbuf_p wordbuf_open(void) 
{ 
  wordbuf_p p ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 26
  tmp = malloc(sizeof(wordbuf_t ));
#line 26
  p = (wordbuf_p )tmp;
  }
#line 28
  if (p) {
    {
#line 30
    n_wordbuf_open ++;
#line 31
    p->len = 64;
#line 32
    tmp___0 = malloc((size_t )p->len);
#line 32
    p->buf = (unsigned char *)tmp___0;
#line 33
    p->last = 0;
#line 34
    *(p->buf + 0) = (unsigned char )'\000';
    }
  }
#line 36
  return (p);
}
}
#line 39 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/wordbuf.c"
void wordbuf_close(wordbuf_p p ) 
{ 


  {
#line 42
  if (p) {
    {
#line 44
    n_wordbuf_close ++;
#line 45
    free((void *)p->buf);
#line 46
    free((void *)p);
    }
  }
#line 48
  return;
}
}
#line 50 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/wordbuf.c"
void wordbuf_reset(wordbuf_p p ) 
{ 


  {
#line 53
  p->last = 0;
#line 54
  *(p->buf + 0) = (unsigned char )'\000';
#line 55
  return;
}
}
#line 62 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/wordbuf.c"
static int wordbuf_extend(wordbuf_p p , int req_len ) 
{ 
  int newlen ;
  unsigned char *newbuf ;
  void *tmp ;

  {
#line 65
  newlen = p->len * 2;
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! (req_len > newlen)) {
#line 68
      goto while_break;
    }
#line 69
    newlen *= 2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 70
  tmp = realloc((void *)p->buf, (size_t )newlen);
#line 70
  newbuf = (unsigned char *)tmp;
  }
#line 70
  if (newbuf) {
#line 77
    p->len = newlen;
#line 78
    p->buf = newbuf;
#line 79
    return (req_len);
  } else {
#line 73
    return (0);
  }
}
}
#line 83 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/wordbuf.c"
int wordbuf_last(wordbuf_p p ) 
{ 


  {
#line 86
  return (p->last);
}
}
#line 89 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/wordbuf.c"
int wordbuf_add(wordbuf_p p , unsigned char ch ) 
{ 
  int newlen ;
  unsigned char *buf___1 ;
  int tmp ;

  {
#line 92
  newlen = p->last + 2;
#line 94
  if (newlen > p->len) {
    {
#line 94
    tmp = wordbuf_extend(p, newlen);
    }
#line 94
    if (tmp) {
#line 99
      buf___1 = p->buf + p->last;
#line 101
      *(buf___1 + 0) = ch;
#line 102
      *(buf___1 + 1) = (unsigned char )'\000';
#line 107
      (p->last) ++;
#line 107
      return (p->last);
    } else {
#line 95
      return (0);
    }
  } else {
#line 99
    buf___1 = p->buf + p->last;
#line 101
    *(buf___1 + 0) = ch;
#line 102
    *(buf___1 + 1) = (unsigned char )'\000';
#line 107
    (p->last) ++;
#line 107
    return (p->last);
  }
}
}
#line 111 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/wordbuf.c"
int wordbuf_cat(wordbuf_p p , unsigned char const   *sz ) 
{ 
  int len ;
  size_t l ;
  size_t tmp ;
  int newlen ;
  int tmp___0 ;

  {
#line 114
  len = 0;
#line 116
  if ((unsigned long )sz != (unsigned long )((void *)0)) {
    {
#line 118
    tmp = strlen((char const   *)sz);
#line 118
    l = tmp;
    }
#line 119
    if (l < 2147483647UL) {
#line 119
      len = (int )l;
    } else {
#line 119
      len = 2147483647;
    }
  }
#line 122
  if (len > 0) {
#line 124
    newlen = (p->last + len) + 1;
#line 126
    if (newlen > p->len) {
      {
#line 126
      tmp___0 = wordbuf_extend(p, newlen);
      }
#line 126
      if (! tmp___0) {
#line 127
        return (0);
      }
    }
    {
#line 128
    memcpy((void */* __restrict  */)(p->buf + p->last), (void const   */* __restrict  */)sz,
           (size_t )(len + 1));
#line 129
    p->last += len;
    }
  }
#line 131
  return (p->last);
}
}
#line 134 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/wordbuf.c"
unsigned char *wordbuf_get(wordbuf_p p ) 
{ 


  {
#line 137
  return (p->buf);
}
}
#line 28 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/charset.h"
int cp932_char2int(unsigned char const   *in , unsigned int *out ) ;
#line 29
int cp932_int2char(unsigned int in , unsigned char *out ) ;
#line 30
int eucjp_char2int(unsigned char const   *in , unsigned int *out ) ;
#line 31
int eucjp_int2char(unsigned int in , unsigned char *out ) ;
#line 32
int utf8_char2int(unsigned char const   *in , unsigned int *out ) ;
#line 33
int utf8_int2char(unsigned int in , unsigned char *out ) ;
#line 36
int charset_detect_buf(unsigned char const   *buf___1 , int len ) ;
#line 15 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/charset.c"
int cp932_char2int(unsigned char const   *in , unsigned int *out ) 
{ 


  {
#line 18
  if (129 <= (int )*(in + 0)) {
#line 18
    if ((int const   )*(in + 0) <= 159) {
#line 18
      goto _L___2;
    } else {
#line 18
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 18
  if (224 <= (int )*(in + 0)) {
#line 18
    if ((int const   )*(in + 0) <= 240) {
      _L___2: /* CIL Label */ 
#line 18
      if (64 <= (int )*(in + 1)) {
#line 18
        if ((int const   )*(in + 1) <= 126) {
#line 18
          goto _L___0;
        } else {
#line 18
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 18
      if (128 <= (int )*(in + 1)) {
#line 18
        if ((int const   )*(in + 1) <= 252) {
          _L___0: /* CIL Label */ 
#line 23
          if (out) {
#line 24
            *out = ((unsigned int )*(in + 0) << 8) | (unsigned int )*(in + 1);
          }
#line 25
          return (2);
        } else {
#line 18
          goto _L___3;
        }
      } else {
#line 18
        goto _L___3;
      }
    } else {
#line 18
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
#line 29
    if (out) {
#line 30
      *out = (unsigned int )*(in + 0);
    }
#line 31
    return (1);
  }
}
}
#line 35 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/charset.c"
int cp932_int2char(unsigned int in , unsigned char *out ) 
{ 


  {
#line 38
  if (in >= 256U) {
#line 40
    if (out) {
#line 42
      *(out + 0) = (unsigned char )((in >> 8) & 255U);
#line 43
      *(out + 1) = (unsigned char )(in & 255U);
    }
#line 45
    return (2);
  } else {
#line 48
    return (0);
  }
}
}
#line 53 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/charset.c"
int eucjp_char2int(unsigned char const   *in , unsigned int *out ) 
{ 


  {
#line 56
  if ((int const   )*(in + 0) == 142) {
#line 56
    if (160 <= (int )*(in + 1)) {
#line 56
      if ((int const   )*(in + 1) <= 223) {
#line 56
        goto _L;
      } else {
#line 56
        goto _L___3;
      }
    } else {
#line 56
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 56
  if (161 <= (int )*(in + 0)) {
#line 56
    if ((int const   )*(in + 0) <= 254) {
#line 56
      if (161 <= (int )*(in + 1)) {
#line 56
        if ((int const   )*(in + 1) <= 254) {
          _L: /* CIL Label */ 
#line 59
          if (out) {
#line 60
            *out = ((unsigned int )*(in + 0) << 8) | (unsigned int )*(in + 1);
          }
#line 61
          return (2);
        } else {
#line 56
          goto _L___1;
        }
      } else {
#line 56
        goto _L___1;
      }
    } else {
#line 56
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 65
    if (out) {
#line 66
      *out = (unsigned int )*(in + 0);
    }
#line 67
    return (1);
  }
}
}
#line 71 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/charset.c"
int eucjp_int2char(unsigned int in , unsigned char *out ) 
{ 


  {
#line 75
  if (in >= 256U) {
#line 77
    if (out) {
#line 79
      *(out + 0) = (unsigned char )((in >> 8) & 255U);
#line 80
      *(out + 1) = (unsigned char )(in & 255U);
    }
#line 82
    return (2);
  } else {
#line 85
    return (0);
  }
}
}
#line 88 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/charset.c"
static int utf8_char2int_noascii(unsigned char const   *in , unsigned int *out ) 
{ 
  int len ;
  int i ;
  unsigned int ch ;

  {
#line 91
  len = 0;
#line 95
  ch = (unsigned int )*(in + 0);
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! (ch & 128U)) {
#line 95
      goto while_break;
    }
#line 96
    len ++;
#line 95
    ch <<= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  if (len < 2) {
#line 99
    return (0);
  }
#line 100
  ch = (ch & 255U) >> len;
#line 101
  i = 1;
  {
#line 101
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 101
    if (! (i < len)) {
#line 101
      goto while_break___0;
    }
#line 103
    if (((int const   )*(in + i) & 192) != 128) {
#line 104
      return (0);
    }
#line 105
    ch <<= 6;
#line 106
    ch += (unsigned int )((int const   )*(in + i) & 63);
#line 101
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 109
  if (out) {
#line 110
    *out = ch;
  }
#line 111
  return (len);
}
}
#line 114 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/charset.c"
int utf8_char2int(unsigned char const   *in , unsigned int *out ) 
{ 
  int retval ;
  int tmp ;

  {
  {
#line 117
  tmp = utf8_char2int_noascii(in, out);
#line 117
  retval = tmp;
  }
#line 118
  if (retval) {
#line 119
    return (retval);
  } else {
#line 122
    if (out) {
#line 123
      *out = (unsigned int )*(in + 0);
    }
#line 124
    return (1);
  }
}
}
#line 128 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/charset.c"
int utf8_int2char(unsigned int in , unsigned char *out ) 
{ 


  {
#line 131
  if (in < 128U) {
#line 132
    return (0);
  }
#line 133
  if (in < 2048U) {
#line 135
    if (out) {
#line 137
      *(out + 0) = (unsigned char )(192U + (in >> 6));
#line 138
      *(out + 1) = (unsigned char )(128U + (in & 63U));
    }
#line 140
    return (2);
  }
#line 142
  if (in < 65536U) {
#line 144
    if (out) {
#line 146
      *(out + 0) = (unsigned char )(224U + (in >> 12));
#line 147
      *(out + 1) = (unsigned char )(128U + ((in >> 6) & 63U));
#line 148
      *(out + 2) = (unsigned char )(128U + (in & 63U));
    }
#line 150
    return (3);
  }
#line 152
  if (in < 2097152U) {
#line 154
    if (out) {
#line 156
      *(out + 0) = (unsigned char )(240U + (in >> 18));
#line 157
      *(out + 1) = (unsigned char )(128U + ((in >> 12) & 63U));
#line 158
      *(out + 2) = (unsigned char )(128U + ((in >> 6) & 63U));
#line 159
      *(out + 3) = (unsigned char )(128U + (in & 63U));
    }
#line 161
    return (4);
  }
#line 163
  if (in < 67108864U) {
#line 165
    if (out) {
#line 167
      *(out + 0) = (unsigned char )(248U + (in >> 24));
#line 168
      *(out + 1) = (unsigned char )(128U + ((in >> 18) & 63U));
#line 169
      *(out + 2) = (unsigned char )(128U + ((in >> 12) & 63U));
#line 170
      *(out + 3) = (unsigned char )(128U + ((in >> 6) & 63U));
#line 171
      *(out + 4) = (unsigned char )(128U + (in & 63U));
    }
#line 173
    return (5);
  } else {
#line 177
    if (out) {
#line 179
      *(out + 0) = (unsigned char )(248U + (in >> 30));
#line 180
      *(out + 1) = (unsigned char )(128U + ((in >> 24) & 63U));
#line 181
      *(out + 2) = (unsigned char )(128U + ((in >> 18) & 63U));
#line 182
      *(out + 3) = (unsigned char )(128U + ((in >> 12) & 63U));
#line 183
      *(out + 4) = (unsigned char )(128U + ((in >> 6) & 63U));
#line 184
      *(out + 5) = (unsigned char )(128U + (in & 63U));
    }
#line 186
    return (6);
  }
}
}
#line 190 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/charset.c"
int charset_detect_buf(unsigned char const   *buf___1 , int len ) 
{ 
  int sjis ;
  int smode ;
  int euc ;
  int emode ;
  int eflag ;
  int utf8 ;
  int umode ;
  int ufailed ;
  int i ;
  unsigned char c ;
  int tmp ;

  {
#line 193
  sjis = 0;
#line 193
  smode = 0;
#line 194
  euc = 0;
#line 194
  emode = 0;
#line 194
  eflag = 0;
#line 195
  utf8 = 0;
#line 195
  umode = 0;
#line 195
  ufailed = 0;
#line 197
  i = 0;
  {
#line 197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 197
    if (! (i < len)) {
#line 197
      goto while_break;
    }
#line 199
    c = (unsigned char )*(buf___1 + i);
#line 201
    if (smode) {
#line 203
      if (64 <= (int )c) {
#line 203
        if ((int )c <= 126) {
#line 204
          sjis ++;
        } else {
#line 203
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 203
      if (128 <= (int )c) {
#line 203
        if ((int )c <= 252) {
#line 204
          sjis ++;
        }
      }
#line 205
      smode = 0;
    } else
#line 207
    if (129 <= (int )c) {
#line 207
      if ((int )c <= 159) {
#line 208
        smode = 1;
      } else {
#line 207
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 207
    if (224 <= (int )c) {
#line 207
      if ((int )c <= 240) {
#line 208
        smode = 1;
      }
    }
#line 210
    if (161 <= (int )c) {
#line 210
      if ((int )c <= 254) {
#line 210
        tmp = 1;
      } else {
#line 210
        tmp = 0;
      }
    } else {
#line 210
      tmp = 0;
    }
#line 210
    eflag = tmp;
#line 211
    if (emode) {
#line 213
      if (eflag) {
#line 214
        euc ++;
      }
#line 215
      emode = 0;
    } else
#line 217
    if (eflag) {
#line 218
      emode = 1;
    }
#line 220
    if (! ufailed) {
#line 222
      if (umode < 1) {
#line 224
        if (((int )c & 128) != 0) {
#line 226
          if (((int )c & 224) == 192) {
#line 227
            umode = 1;
          } else
#line 228
          if (((int )c & 240) == 224) {
#line 229
            umode = 2;
          } else
#line 230
          if (((int )c & 248) == 240) {
#line 231
            umode = 3;
          } else
#line 232
          if (((int )c & 252) == 248) {
#line 233
            umode = 4;
          } else
#line 234
          if (((int )c & 254) == 252) {
#line 235
            umode = 5;
          } else {
#line 238
            ufailed = 1;
#line 239
            utf8 --;
          }
        }
      } else
#line 245
      if (((int )c & 192) == 128) {
#line 247
        utf8 ++;
#line 248
        umode --;
      } else {
#line 252
        utf8 --;
#line 253
        umode = 0;
#line 254
        ufailed = 1;
      }
#line 257
      if (utf8 < 0) {
#line 258
        utf8 = 0;
      }
    }
#line 197
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  if (euc > sjis) {
#line 262
    if (euc > utf8) {
#line 263
      return (2);
    } else {
#line 262
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 264
  if (! ufailed) {
#line 264
    if (utf8 > euc) {
#line 264
      if (utf8 > sjis) {
#line 265
        return (3);
      } else {
#line 264
        goto _L___2;
      }
    } else {
#line 264
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 266
  if (sjis > euc) {
#line 266
    if (sjis > utf8) {
#line 267
      return (1);
    } else {
#line 269
      return (0);
    }
  } else {
#line 269
    return (0);
  }
}
}
#line 272 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/charset.c"
void charset_getproc(int charset , charset_proc_char2int *char2int , charset_proc_int2char *int2char ) 
{ 
  int (*c2i)(unsigned char const   * , unsigned int * ) ;
  int (*i2c)(unsigned int  , unsigned char * ) ;

  {
#line 276
  c2i = (int (*)(unsigned char const   * , unsigned int * ))((void *)0);
#line 277
  i2c = (int (*)(unsigned int  , unsigned char * ))((void *)0);
  {
#line 280
  if (charset == 1) {
#line 280
    goto case_1;
  }
#line 284
  if (charset == 2) {
#line 284
    goto case_2;
  }
#line 288
  if (charset == 3) {
#line 288
    goto case_3;
  }
#line 292
  goto switch_default;
  case_1: /* CIL Label */ 
#line 281
  c2i = & cp932_char2int;
#line 282
  i2c = & cp932_int2char;
#line 283
  goto switch_break;
  case_2: /* CIL Label */ 
#line 285
  c2i = & eucjp_char2int;
#line 286
  i2c = & eucjp_int2char;
#line 287
  goto switch_break;
  case_3: /* CIL Label */ 
#line 289
  c2i = & utf8_char2int;
#line 290
  i2c = & utf8_int2char;
#line 291
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 293
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 295
  if (char2int) {
#line 296
    *char2int = c2i;
  }
#line 297
  if (int2char) {
#line 298
    *int2char = i2c;
  }
#line 299
  return;
}
}
#line 301 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/charset.c"
int charset_detect_file(char const   *path ) 
{ 
  int charset ;
  FILE *fp ;
  unsigned char buf___1[4096] ;
  size_t len ;
  size_t tmp ;

  {
  {
#line 304
  charset = 0;
#line 306
  fp = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"rt");
  }
#line 306
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 309
    tmp = fread((void */* __restrict  */)(buf___1), sizeof(buf___1[0]), sizeof(buf___1),
                (FILE */* __restrict  */)fp);
#line 309
    len = tmp;
#line 310
    fclose(fp);
    }
#line 311
    if (len > 0UL) {
#line 311
      if (len <= 2147483647UL) {
        {
#line 312
        charset = charset_detect_buf((unsigned char const   *)(buf___1), (int )len);
        }
      }
    }
  }
#line 314
  return (charset);
}
}
#line 19 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/wordlist.h"
int n_wordlist_open ;
#line 20
int n_wordlist_close ;
#line 21
int n_wordlist_total ;
#line 27
wordlist_p wordlist_open(unsigned char const   *ptr ) ;
#line 14 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/wordlist.c"
int n_wordlist_open  =    0;
#line 15 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/wordlist.c"
int n_wordlist_close  =    0;
#line 16 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/wordlist.c"
int n_wordlist_total  =    0;
#line 18 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/wordlist.c"
wordlist_p wordlist_open_len(unsigned char const   *ptr , int len ) 
{ 
  wordlist_p p ;
  void *tmp ;

  {
#line 21
  if (ptr) {
#line 21
    if (len >= 0) {
      {
#line 25
      tmp = malloc((sizeof(*p) + (unsigned long )len) + 1UL);
#line 25
      p = (wordlist_p )tmp;
      }
#line 25
      if ((unsigned long )p != (unsigned long )((void *)0)) {
        {
#line 27
        p->ptr = (unsigned char *)((char *)(p + 1));
#line 28
        p->next = (wordlist_p )((void *)0);
#line 33
        memcpy((void */* __restrict  */)p->ptr, (void const   */* __restrict  */)ptr,
               (size_t )len);
#line 34
        *(p->ptr + len) = (unsigned char )'\000';
#line 36
        n_wordlist_open ++;
#line 37
        n_wordlist_total += len;
        }
      }
#line 39
      return (p);
    }
  }
#line 41
  return ((wordlist_p )((void *)0));
}
}
#line 44 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/wordlist.c"
wordlist_p wordlist_open(unsigned char const   *ptr ) 
{ 
  wordlist_p p ;
  size_t len ;
  int tmp ;

  {
#line 47
  p = (wordlist_p )((void *)0);
#line 48
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
    {
#line 51
    len = strlen((char const   *)ptr);
    }
#line 52
    if (len < 2147483647UL) {
#line 52
      tmp = (int )len;
    } else {
#line 52
      tmp = 2147483647;
    }
    {
#line 52
    p = wordlist_open_len(ptr, tmp);
    }
  }
#line 54
  return (p);
}
}
#line 57 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/wordlist.c"
void wordlist_close(wordlist_p p ) 
{ 
  wordlist_p next ;

  {
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! p) {
#line 60
      goto while_break;
    }
    {
#line 62
    next = p->next;
#line 64
    n_wordlist_close ++;
#line 65
    free((void *)p);
#line 66
    p = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 68
  return;
}
}
#line 21 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/wordbuf.c"
static int wordbuf_extend___0(wordbuf_p p , int req_len ) ;
#line 62 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/wordbuf.c"
static int wordbuf_extend___0(wordbuf_p p , int req_len ) 
{ 
  int newlen ;
  unsigned char *newbuf ;
  void *tmp ;

  {
#line 65
  newlen = p->len * 2;
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! (req_len > newlen)) {
#line 68
      goto while_break;
    }
#line 69
    newlen *= 2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 70
  tmp = realloc((void *)p->buf, (size_t )newlen);
#line 70
  newbuf = (unsigned char *)tmp;
  }
#line 70
  if (newbuf) {
#line 77
    p->len = newlen;
#line 78
    p->buf = newbuf;
#line 79
    return (req_len);
  } else {
#line 73
    return (0);
  }
}
}
#line 53 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.c"
static unsigned char const   VOWEL_CHARS___0[6]  = {      (unsigned char const   )'a',      (unsigned char const   )'i',      (unsigned char const   )'u',      (unsigned char const   )'e', 
        (unsigned char const   )'o',      (unsigned char const   )'\000'};
#line 55 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.c"
static int my_strlen___1(char const   *s ) 
{ 
  size_t len ;
  int tmp ;

  {
  {
#line 60
  len = strlen(s);
  }
#line 61
  if (len <= 2147483647UL) {
#line 61
    tmp = (int )len;
  } else {
#line 61
    tmp = 2147483647;
  }
#line 61
  return (tmp);
}
}
#line 64 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.c"
static mtree_p load_mtree_dictionary___0(mtree_p mtree , char const   *dict_file ) 
{ 
  FILE *fp ;

  {
  {
#line 69
  fp = fopen((char const   */* __restrict  */)dict_file, (char const   */* __restrict  */)"rt");
  }
#line 69
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 70
    return ((mtree_p )((void *)0));
  }
  {
#line 71
  mtree = mnode_load(mtree, fp);
#line 72
  fclose(fp);
  }
#line 73
  return (mtree);
}
}
#line 76 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.c"
static mtree_p load_mtree_dictionary2___0(migemo *obj , char const   *dict_file ) 
{ 
  int (*char2int)(unsigned char const   * , unsigned int * ) ;
  int (*int2char)(unsigned int  , unsigned char * ) ;
  mtree_p tmp ;

  {
#line 79
  if (obj->charset == 0) {
    {
#line 82
    char2int = (int (*)(unsigned char const   * , unsigned int * ))((void *)0);
#line 83
    int2char = (int (*)(unsigned int  , unsigned char * ))((void *)0);
#line 84
    obj->charset = charset_detect_file(dict_file);
#line 85
    charset_getproc(obj->charset, & char2int, & int2char);
    }
#line 86
    if (char2int) {
      {
#line 88
      migemo_setproc_char2int(obj, char2int);
#line 89
      obj->char2int = char2int;
      }
    }
#line 91
    if (int2char) {
      {
#line 92
      migemo_setproc_int2char(obj, int2char);
      }
    }
  }
  {
#line 94
  tmp = load_mtree_dictionary___0(obj->mtree, dict_file);
  }
#line 94
  return (tmp);
}
}
#line 97 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.c"
static void dircat___0(char *buf___1 , char const   *dir , char const   *file ) 
{ 


  {
  {
#line 100
  strcpy((char */* __restrict  */)buf___1, (char const   */* __restrict  */)dir);
#line 101
  strcat((char */* __restrict  */)buf___1, (char const   */* __restrict  */)"/");
#line 102
  strcat((char */* __restrict  */)buf___1, (char const   */* __restrict  */)file);
  }
#line 103
  return;
}
}
#line 296 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.c"
static void migemo_query_proc___0(mnode *p , void *data ) 
{ 
  migemo *object ;
  wordlist_p list ;

  {
#line 299
  object = (migemo *)data;
#line 300
  list = p->list;
  {
#line 302
  while (1) {
    while_continue: /* CIL Label */ ;
#line 302
    if (! list) {
#line 302
      goto while_break;
    }
    {
#line 303
    (*(object->addword))((void *)object, list->ptr);
#line 302
    list = list->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 304
  return;
}
}
#line 309 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.c"
static void add_mnode_query___0(migemo *object , unsigned char *query ) 
{ 
  mnode *pnode ;

  {
  {
#line 314
  pnode = mnode_query(object->mtree, (unsigned char const   *)query);
  }
#line 314
  if ((unsigned long )pnode != (unsigned long )((void *)0)) {
    {
#line 315
    mnode_traverse(pnode, & migemo_query_proc___0, (void *)object);
    }
  }
#line 316
  return;
}
}
#line 321 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.c"
static int add_roma___0(migemo *object , unsigned char *query ) 
{ 
  unsigned char *stop ;
  unsigned char *hira ;
  unsigned char *kata ;
  unsigned char *han ;
  int tmp ;

  {
  {
#line 326
  hira = romaji_convert(object->roma2hira, (unsigned char const   *)query, & stop);
  }
#line 327
  if (! stop) {
    {
#line 329
    (*(object->addword))((void *)object, hira);
#line 331
    add_mnode_query___0(object, hira);
#line 333
    kata = romaji_convert2(object->hira2kata, (unsigned char const   *)hira, (unsigned char **)((void *)0),
                           0);
#line 334
    (*(object->addword))((void *)object, kata);
#line 337
    han = romaji_convert2(object->zen2han, (unsigned char const   *)kata, (unsigned char **)((void *)0),
                          0);
#line 338
    (*(object->addword))((void *)object, han);
#line 340
    romaji_release(object->zen2han, han);
#line 343
    add_mnode_query___0(object, kata);
#line 344
    romaji_release(object->hira2kata, kata);
    }
  }
  {
#line 346
  romaji_release(object->roma2hira, hira);
  }
#line 348
  if (stop) {
#line 348
    tmp = 1;
  } else {
#line 348
    tmp = 0;
  }
#line 348
  return (tmp);
}
}
#line 354 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.c"
static void add_dubious_vowels___0(migemo *object , unsigned char *buf___1 , int index___0 ) 
{ 
  unsigned char const   *ptr ;

  {
#line 358
  ptr = VOWEL_CHARS___0;
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 358
    if (! *ptr) {
#line 358
      goto while_break;
    }
    {
#line 360
    *(buf___1 + index___0) = (unsigned char )*ptr;
#line 361
    add_roma___0(object, buf___1);
#line 358
    ptr ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 363
  return;
}
}
#line 369 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.c"
static void add_dubious_roma___0(migemo *object , rxgen *rx , unsigned char *query ) 
{ 
  int max ;
  int len ;
  char *buf___1 ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 376
  len = my_strlen___1((char const   *)query);
  }
#line 376
  if (! len) {
#line 377
    return;
  }
  {
#line 382
  max = ((len + 1) + 3) + 1;
#line 383
  tmp = malloc((size_t )max);
#line 383
  buf___1 = (char *)tmp;
  }
#line 384
  if ((unsigned long )buf___1 == (unsigned long )((void *)0)) {
#line 385
    return;
  }
  {
#line 386
  memcpy((void */* __restrict  */)buf___1, (void const   */* __restrict  */)query,
         (size_t )len);
#line 387
  memset((void *)(buf___1 + len), 0, (size_t )(max - len));
#line 389
  tmp___1 = strchr((char const   *)(VOWEL_CHARS___0), (int )*(buf___1 + (len - 1)));
  }
#line 389
  if (! tmp___1) {
    {
#line 391
    add_dubious_vowels___0(object, (unsigned char *)buf___1, len);
    }
#line 393
    if (len < 2) {
#line 393
      goto _L;
    } else {
      {
#line 393
      tmp___0 = strchr((char const   *)(VOWEL_CHARS___0), (int )*(buf___1 + (len - 2)));
      }
#line 393
      if (tmp___0) {
        _L: /* CIL Label */ 
#line 395
        if ((int )*(buf___1 + (len - 1)) == 110) {
          {
#line 398
          memcpy((void */* __restrict  */)(buf___1 + (len - 1)), (void const   */* __restrict  */)"xn",
                 (size_t )2);
#line 399
          add_roma___0(object, (unsigned char *)buf___1);
          }
        } else {
          {
#line 404
          *(buf___1 + (len + 2)) = *(buf___1 + (len - 1));
#line 405
          memcpy((void */* __restrict  */)(buf___1 + (len - 1)), (void const   */* __restrict  */)"xtu",
                 (size_t )3);
#line 406
          add_dubious_vowels___0(object, (unsigned char *)buf___1, len + 3);
          }
        }
      }
    }
  }
  {
#line 411
  free((void *)buf___1);
  }
#line 412
  return;
}
}
#line 418 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.c"
static wordlist_p parse_query___0(migemo *object , unsigned char const   *query ) 
{ 
  unsigned char const   *curr ;
  unsigned char const   *start ;
  wordlist_p querylist ;
  wordlist_p *pp ;
  int len ;
  int upper ;
  int sum ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 421
  curr = query;
#line 422
  start = (unsigned char const   *)((void *)0);
#line 423
  querylist = (wordlist_p )((void *)0);
#line 423
  pp = & querylist;
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 428
    sum = 0;
#line 430
    if (! object->char2int) {
#line 431
      len = 1;
    } else {
      {
#line 430
      len = (*(object->char2int))(curr, (unsigned int *)((void *)0));
      }
#line 430
      if (len < 1) {
#line 431
        len = 1;
      }
    }
#line 432
    start = curr;
#line 433
    if (len == 1) {
      {
#line 433
      tmp = __ctype_b_loc();
      }
#line 433
      if ((int const   )*(*tmp + (int )*curr) & 256) {
        {
#line 433
        tmp___0 = __ctype_b_loc();
        }
#line 433
        if ((int const   )*(*tmp___0 + (int )*(curr + 1)) & 256) {
#line 433
          tmp___1 = 1;
        } else {
#line 433
          tmp___1 = 0;
        }
      } else {
#line 433
        tmp___1 = 0;
      }
    } else {
#line 433
      tmp___1 = 0;
    }
#line 433
    upper = tmp___1;
#line 434
    curr += len;
#line 435
    sum += len;
    {
#line 436
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 438
      if (! object->char2int) {
#line 439
        len = 1;
      } else {
        {
#line 438
        len = (*(object->char2int))(curr, (unsigned int *)((void *)0));
        }
#line 438
        if (len < 1) {
#line 439
          len = 1;
        }
      }
#line 440
      if ((int const   )*curr == 0) {
#line 441
        goto while_break___0;
      } else
#line 440
      if (len == 1) {
        {
#line 440
        tmp___2 = __ctype_b_loc();
        }
#line 440
        if ((((int const   )*(*tmp___2 + (int )*curr) & 256) != 0) != upper) {
#line 441
          goto while_break___0;
        }
      }
#line 442
      curr += len;
#line 443
      sum += len;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 446
    if (start) {
#line 446
      if ((unsigned long )start < (unsigned long )curr) {
        {
#line 448
        *pp = wordlist_open_len(start, sum);
#line 449
        pp = & (*pp)->next;
        }
      }
    }
#line 451
    if ((int const   )*curr == 0) {
#line 452
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 454
  return (querylist);
}
}
#line 460 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.c"
static int query_a_word___0(migemo *object , unsigned char *query ) 
{ 
  unsigned char *zen ;
  unsigned char *han ;
  unsigned char *lower ;
  int len ;
  int tmp ;
  void *tmp___0 ;
  int i ;
  int step ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;

  {
  {
#line 466
  tmp = my_strlen___1((char const   *)query);
#line 466
  len = tmp;
#line 469
  (*(object->addword))((void *)object, query);
#line 471
  tmp___0 = malloc((size_t )(len + 1));
#line 471
  lower = (unsigned char *)tmp___0;
  }
#line 472
  if (! lower) {
    {
#line 473
    add_mnode_query___0(object, query);
    }
  } else {
#line 476
    i = 0;
    {
#line 479
    while (1) {
      while_continue: /* CIL Label */ ;
#line 479
      if (! (i <= len)) {
#line 479
        goto while_break;
      }
#line 481
      if (! object->char2int) {
#line 483
        step = 1;
      } else {
        {
#line 481
        step = (*(object->char2int))((unsigned char const   *)(query + i), (unsigned int *)((void *)0));
        }
#line 481
        if (step < 1) {
#line 483
          step = 1;
        }
      }
#line 484
      if (step == 1) {
        {
#line 484
        tmp___2 = __ctype_b_loc();
        }
#line 484
        if ((int const   )*(*tmp___2 + (int )*(query + i)) & 256) {
          {
#line 485
          tmp___1 = tolower((int )*(query + i));
#line 485
          *(lower + i) = (unsigned char )tmp___1;
          }
        } else {
          {
#line 487
          memcpy((void */* __restrict  */)(lower + i), (void const   */* __restrict  */)(query + i),
                 (size_t )step);
          }
        }
      } else {
        {
#line 487
        memcpy((void */* __restrict  */)(lower + i), (void const   */* __restrict  */)(query + i),
               (size_t )step);
        }
      }
#line 488
      i += step;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 490
    add_mnode_query___0(object, lower);
#line 491
    free((void *)lower);
    }
  }
  {
#line 495
  zen = romaji_convert2(object->han2zen, (unsigned char const   *)query, (unsigned char **)((void *)0),
                        0);
  }
#line 496
  if ((unsigned long )zen != (unsigned long )((void *)0)) {
    {
#line 498
    (*(object->addword))((void *)object, zen);
#line 499
    romaji_release(object->han2zen, zen);
    }
  }
  {
#line 503
  han = romaji_convert2(object->zen2han, (unsigned char const   *)query, (unsigned char **)((void *)0),
                        0);
  }
#line 504
  if ((unsigned long )han != (unsigned long )((void *)0)) {
    {
#line 506
    (*(object->addword))((void *)object, han);
#line 507
    romaji_release(object->zen2han, han);
    }
  }
  {
#line 511
  tmp___3 = add_roma___0(object, query);
  }
#line 511
  if (tmp___3) {
    {
#line 512
    add_dubious_roma___0(object, object->rx, query);
    }
  }
#line 514
  return (1);
}
}
#line 517 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/migemo.c"
static int addword_rxgen___0(migemo *object , unsigned char *word ) 
{ 
  int tmp ;

  {
  {
#line 522
  tmp = rxgen_add(object->rx, (unsigned char const   *)word);
  }
#line 522
  return (tmp);
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 189 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) clock_t ( __attribute__((__leaf__)) clock)(void) ;
#line 24 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/main.c"
int query_loop(migemo *p , int quiet ) 
{ 
  unsigned char buf___1[256] ;
  unsigned char *ans ;
  char *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 27
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 27
    tmp___2 = feof(stdin);
    }
#line 27
    if (tmp___2) {
#line 27
      goto while_break;
    }
#line 31
    if (! quiet) {
      {
#line 32
      printf((char const   */* __restrict  */)"QUERY: ");
      }
    }
    {
#line 34
    tmp = fgets((char */* __restrict  */)(buf___1), (int )sizeof(buf___1), (FILE */* __restrict  */)stdin);
    }
#line 34
    if (! tmp) {
#line 36
      if (! quiet) {
        {
#line 37
        printf((char const   */* __restrict  */)"\n");
        }
      }
#line 38
      goto while_break;
    }
    {
#line 41
    tmp___0 = strchr((char const   *)(buf___1), '\n');
#line 41
    ans = (unsigned char *)tmp___0;
    }
#line 41
    if ((unsigned long )ans != (unsigned long )((void *)0)) {
#line 42
      *ans = (unsigned char )'\000';
    }
    {
#line 44
    ans = migemo_query(p, (unsigned char const   *)(buf___1));
    }
#line 45
    if (ans) {
#line 46
      if (quiet) {
#line 46
        tmp___1 = "%s\n";
      } else {
#line 46
        tmp___1 = "PATTERN: %s\n";
      }
      {
#line 46
      printf((char const   */* __restrict  */)tmp___1, ans);
      }
    }
    {
#line 47
    fflush(stdout);
#line 48
    migemo_release(p, ans);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return (0);
}
}
#line 53 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/main.c"
static void help(char *prgname ) 
{ 


  {
  {
#line 56
  printf((char const   */* __restrict  */)"%s \n\nUSAGE: %s [OPTIONS]\n\nOPTIONS:\n  -d --dict <dict>\tUse a file <dict> for dictionary.\n  -s --subdict <dict>\tSub dictionary files. (MAX %d times)\n  -q --quiet\t\tShow no message except results.\n  -v --vim\t\tUse vim style regexp.\n  -e --emacs\t\tUse emacs style regexp.\n  -n --nonewline\tDon\'t use newline match.\n  -w --word <word>\tExpand a <word> and soon exit.\n  -h --help\t\tShow this message.\n",
         "cmigemo - C/Migemo Library 1.3 Driver", prgname, 8);
#line 72
  exit(0);
  }
}
}
#line 75 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/main.c"
int main(int argc , char **argv ) 
{ 
  int mode_vim ;
  int mode_emacs ;
  int mode_nonewline ;
  int mode_quiet ;
  char *dict ;
  char *subdict[8] ;
  int subdict_count ;
  migemo *pmigemo ;
  FILE *fplog ;
  char *word ;
  char *prgname ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int i ;
  int result ;
  unsigned char *ans ;
  char const   *tmp___17 ;
  clock_t tmp___18 ;

  {
  {
#line 78
  mode_vim = 0;
#line 79
  mode_emacs = 0;
#line 80
  mode_nonewline = 0;
#line 81
  mode_quiet = 0;
#line 82
  dict = (char *)((void *)0);
#line 84
  subdict_count = 0;
#line 86
  fplog = stdout;
#line 87
  word = (char *)((void *)0);
#line 88
  prgname = *(argv + 0);
#line 90
  memset((void *)(subdict), 0, sizeof(subdict));
  }
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    argv ++;
#line 91
    if (! *argv) {
#line 91
      goto while_break;
    }
    {
#line 95
    tmp___14 = strcmp("--vim", (char const   *)*argv);
    }
#line 95
    if (tmp___14) {
      {
#line 95
      tmp___15 = strcmp("-v", (char const   *)*argv);
      }
#line 95
      if (tmp___15) {
        {
#line 97
        tmp___12 = strcmp("--emacs", (char const   *)*argv);
        }
#line 97
        if (tmp___12) {
          {
#line 97
          tmp___13 = strcmp("-e", (char const   *)*argv);
          }
#line 97
          if (tmp___13) {
            {
#line 99
            tmp___10 = strcmp("--nonewline", (char const   *)*argv);
            }
#line 99
            if (tmp___10) {
              {
#line 99
              tmp___11 = strcmp("-n", (char const   *)*argv);
              }
#line 99
              if (tmp___11) {
#line 101
                if (*(argv + 1)) {
                  {
#line 101
                  tmp___8 = strcmp("--dict", (char const   *)*argv);
                  }
#line 101
                  if (tmp___8) {
                    {
#line 101
                    tmp___9 = strcmp("-d", (char const   *)*argv);
                    }
#line 101
                    if (tmp___9) {
#line 101
                      goto _L___3;
                    } else {
#line 102
                      argv ++;
#line 102
                      dict = *argv;
                    }
                  } else {
#line 102
                    argv ++;
#line 102
                    dict = *argv;
                  }
                } else
                _L___3: /* CIL Label */ 
#line 103
                if (*(argv + 1)) {
                  {
#line 103
                  tmp___6 = strcmp("--subdict", (char const   *)*argv);
                  }
#line 103
                  if (tmp___6) {
                    {
#line 103
                    tmp___7 = strcmp("-s", (char const   *)*argv);
                    }
#line 103
                    if (tmp___7) {
#line 103
                      goto _L___1;
                    } else
                    _L___2: /* CIL Label */ 
#line 103
                    if (subdict_count < 8) {
#line 106
                      tmp = subdict_count;
#line 106
                      subdict_count ++;
#line 106
                      argv ++;
#line 106
                      subdict[tmp] = *argv;
                    } else {
#line 103
                      goto _L___1;
                    }
                  } else {
#line 103
                    goto _L___2;
                  }
                } else
                _L___1: /* CIL Label */ 
#line 107
                if (*(argv + 1)) {
                  {
#line 107
                  tmp___4 = strcmp("--word", (char const   *)*argv);
                  }
#line 107
                  if (tmp___4) {
                    {
#line 107
                    tmp___5 = strcmp("-w", (char const   *)*argv);
                    }
#line 107
                    if (tmp___5) {
#line 107
                      goto _L;
                    } else {
#line 108
                      argv ++;
#line 108
                      word = *argv;
                    }
                  } else {
#line 108
                    argv ++;
#line 108
                    word = *argv;
                  }
                } else {
                  _L: /* CIL Label */ 
                  {
#line 109
                  tmp___2 = strcmp("--quiet", (char const   *)*argv);
                  }
#line 109
                  if (tmp___2) {
                    {
#line 109
                    tmp___3 = strcmp("-q", (char const   *)*argv);
                    }
#line 109
                    if (tmp___3) {
                      {
#line 111
                      tmp___0 = strcmp("--help", (char const   *)*argv);
                      }
#line 111
                      if (tmp___0) {
                        {
#line 111
                        tmp___1 = strcmp("-h", (char const   *)*argv);
                        }
#line 111
                        if (! tmp___1) {
                          {
#line 112
                          help(prgname);
                          }
                        }
                      } else {
                        {
#line 112
                        help(prgname);
                        }
                      }
                    } else {
#line 110
                      mode_quiet = 1;
                    }
                  } else {
#line 110
                    mode_quiet = 1;
                  }
                }
              } else {
#line 100
                mode_nonewline = 1;
              }
            } else {
#line 100
              mode_nonewline = 1;
            }
          } else {
#line 98
            mode_emacs = 1;
          }
        } else {
#line 98
          mode_emacs = 1;
        }
      } else {
#line 96
        mode_vim = 1;
      }
    } else {
#line 96
      mode_vim = 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  if (! dict) {
    {
#line 122
    pmigemo = migemo_open("./dict/migemo-dict");
    }
#line 123
    if (! word) {
#line 123
      if (! mode_quiet) {
        {
#line 125
        fprintf((FILE */* __restrict  */)fplog, (char const   */* __restrict  */)"migemo_open(\"%s\")=%p\n",
                "./dict/migemo-dict", pmigemo);
        }
      }
    }
#line 128
    if (! pmigemo) {
#line 128
      goto _L___4;
    } else {
      {
#line 128
      tmp___16 = migemo_is_enable(pmigemo);
      }
#line 128
      if (! tmp___16) {
        _L___4: /* CIL Label */ 
        {
#line 130
        migemo_close(pmigemo);
#line 131
        pmigemo = migemo_open("../dict/migemo-dict");
        }
#line 132
        if (! word) {
#line 132
          if (! mode_quiet) {
            {
#line 134
            fprintf((FILE */* __restrict  */)fplog, (char const   */* __restrict  */)"migemo_open(\"%s\")=%p\n",
                    "../dict/migemo-dict", pmigemo);
            }
          }
        }
      }
    }
  } else {
    {
#line 141
    pmigemo = migemo_open((char const   *)dict);
    }
#line 142
    if (! word) {
#line 142
      if (! mode_quiet) {
        {
#line 143
        fprintf((FILE */* __restrict  */)fplog, (char const   */* __restrict  */)"migemo_open(\"%s\")=%p\n",
                dict, pmigemo);
        }
      }
    }
  }
#line 146
  if (subdict_count > 0) {
#line 150
    i = 0;
    {
#line 150
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 150
      if (! (i < subdict_count)) {
#line 150
        goto while_break___0;
      }
#line 154
      if ((unsigned long )subdict[i] == (unsigned long )((void *)0)) {
#line 155
        goto __Cont;
      } else
#line 154
      if ((int )*(subdict[i] + 0) == 0) {
#line 155
        goto __Cont;
      }
      {
#line 156
      result = migemo_load(pmigemo, 1, (char const   *)subdict[i]);
      }
#line 157
      if (! word) {
#line 157
        if (! mode_quiet) {
          {
#line 158
          fprintf((FILE */* __restrict  */)fplog, (char const   */* __restrict  */)"migemo_load(%p, %d, \"%s\")=%d\n",
                  pmigemo, 1, subdict[i], result);
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 150
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 163
  if (! pmigemo) {
#line 164
    return (1);
  } else {
#line 167
    if (mode_vim) {
      {
#line 169
      migemo_set_operator(pmigemo, 0, (unsigned char const   *)"\\|");
#line 170
      migemo_set_operator(pmigemo, 1, (unsigned char const   *)"\\%(");
#line 171
      migemo_set_operator(pmigemo, 2, (unsigned char const   *)"\\)");
      }
#line 172
      if (! mode_nonewline) {
        {
#line 173
        migemo_set_operator(pmigemo, 5, (unsigned char const   *)"\\_s*");
        }
      }
    } else
#line 175
    if (mode_emacs) {
      {
#line 177
      migemo_set_operator(pmigemo, 0, (unsigned char const   *)"\\|");
#line 178
      migemo_set_operator(pmigemo, 1, (unsigned char const   *)"\\(");
#line 179
      migemo_set_operator(pmigemo, 2, (unsigned char const   *)"\\)");
      }
#line 180
      if (! mode_nonewline) {
        {
#line 181
        migemo_set_operator(pmigemo, 5, (unsigned char const   *)"[[:space:]\r\n]*");
        }
      }
    }
#line 184
    if (word) {
      {
#line 188
      ans = migemo_query(pmigemo, (unsigned char const   *)word);
      }
#line 189
      if (ans) {
#line 190
        if (mode_vim) {
#line 190
          tmp___17 = "%s";
        } else {
#line 190
          tmp___17 = "%s\n";
        }
        {
#line 190
        fprintf((FILE */* __restrict  */)fplog, (char const   */* __restrict  */)tmp___17,
                ans);
        }
      }
      {
#line 191
      migemo_release(pmigemo, ans);
      }
    } else {
#line 195
      if (! mode_quiet) {
        {
#line 196
        tmp___18 = clock();
#line 196
        printf((char const   */* __restrict  */)"clock()=%f\n", (double )((float )tmp___18 / (float )1000000L));
        }
      }
      {
#line 197
      query_loop(pmigemo, mode_quiet);
      }
    }
    {
#line 215
    migemo_close(pmigemo);
    }
  }
#line 218
  if ((unsigned long )fplog != (unsigned long )stdout) {
    {
#line 219
    fclose(fplog);
    }
  }
#line 220
  return (0);
}
}
#line 88 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/charset.c"
static int utf8_char2int_noascii___0(unsigned char const   *in , unsigned int *out ) 
{ 
  int len ;
  int i ;
  unsigned int ch ;

  {
#line 91
  len = 0;
#line 95
  ch = (unsigned int )*(in + 0);
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! (ch & 128U)) {
#line 95
      goto while_break;
    }
#line 96
    len ++;
#line 95
    ch <<= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  if (len < 2) {
#line 99
    return (0);
  }
#line 100
  ch = (ch & 255U) >> len;
#line 101
  i = 1;
  {
#line 101
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 101
    if (! (i < len)) {
#line 101
      goto while_break___0;
    }
#line 103
    if (((int const   )*(in + i) & 192) != 128) {
#line 104
      return (0);
    }
#line 105
    ch <<= 6;
#line 106
    ch += (unsigned int )((int const   )*(in + i) & 63);
#line 101
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 109
  if (out) {
#line 110
    *out = ch;
  }
#line 111
  return (len);
}
}
#line 62 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/romaji.c"
static void romanode_delete___0(romanode *node ) 
{ 
  romanode *child ;

  {
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! node) {
#line 65
      goto while_break;
    }
#line 67
    child = node->child;
#line 68
    if (node->next) {
      {
#line 69
      romanode_delete___0(node->next);
      }
    }
    {
#line 70
    free((void *)node->value);
#line 71
    free((void *)node);
#line 72
    node = child;
#line 73
    n_romanode_delete ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  return;
}
}
#line 77 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/romaji.c"
static romanode **romanode_dig___0(romanode **ref_node , unsigned char const   *key ) 
{ 
  romanode *tmp ;

  {
#line 80
  if (! ref_node) {
#line 81
    return ((romanode **)((void *)0));
  } else
#line 80
  if (! key) {
#line 81
    return ((romanode **)((void *)0));
  } else
#line 80
  if ((int const   )*(key + 0) == 0) {
#line 81
    return ((romanode **)((void *)0));
  }
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! *ref_node) {
      {
#line 87
      tmp = romanode_new();
#line 87
      *ref_node = tmp;
      }
#line 87
      if (! tmp) {
#line 88
        return ((romanode **)((void *)0));
      }
#line 89
      (*ref_node)->key = (unsigned char )*key;
    }
#line 92
    if ((int )(*ref_node)->key == (int )*key) {
#line 94
      (*ref_node)->value = (unsigned char *)((void *)0);
#line 95
      key ++;
#line 95
      if (! *key) {
#line 96
        goto while_break;
      }
#line 97
      ref_node = & (*ref_node)->child;
    } else {
#line 100
      ref_node = & (*ref_node)->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  if ((*ref_node)->child) {
    {
#line 105
    romanode_delete___0((*ref_node)->child);
#line 106
    (*ref_node)->child = (romanode *)0;
    }
  }
#line 108
  return (ref_node);
}
}
#line 118 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/romaji.c"
static romanode *romanode_query___0(romanode *node , unsigned char const   *key ,
                                    int *skip , int (*char2int)(unsigned char const   * ,
                                                                unsigned int * ) ) 
{ 
  int nskip ;
  unsigned char const   *key_start ;

  {
#line 122
  nskip = 0;
#line 123
  key_start = key;
#line 126
  if (node) {
#line 126
    if (key) {
#line 126
      if (*key) {
        {
#line 128
        while (1) {
          while_continue: /* CIL Label */ ;
#line 130
          if ((int const   )*key != (int const   )node->key) {
#line 131
            node = node->next;
          } else {
#line 134
            nskip ++;
#line 135
            if (node->value) {
#line 138
              goto while_break;
            }
#line 140
            key ++;
#line 140
            if (! *key) {
#line 142
              nskip = 0;
#line 144
              goto while_break;
            }
#line 146
            node = node->child;
          }
#line 149
          if (! node) {
#line 152
            if (! char2int) {
#line 153
              nskip = 1;
            } else {
              {
#line 152
              nskip = (*char2int)(key_start, (unsigned int *)((void *)0));
              }
#line 152
              if (nskip < 1) {
#line 153
                nskip = 1;
              }
            }
#line 155
            goto while_break;
          }
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 160
  if (skip) {
#line 161
    *skip = nskip;
  }
#line 162
  return (node);
}
}
#line 205 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/romaji.c"
static unsigned char *strdup_lower___0(unsigned char const   *string ) 
{ 
  unsigned char *out ;
  char *tmp ;
  unsigned char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 208
  tmp = strdup((char const   *)string);
#line 208
  out = (unsigned char *)tmp;
  }
#line 210
  if (out) {
#line 211
    tmp___0 = out;
    {
#line 211
    while (1) {
      while_continue: /* CIL Label */ ;
#line 211
      if (! *tmp___0) {
#line 211
        goto while_break;
      }
      {
#line 212
      tmp___1 = tolower((int )*tmp___0);
#line 212
      *tmp___0 = (unsigned char )tmp___1;
#line 211
      tmp___0 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 213
  return (out);
}
}
#line 55 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/mnode.c"
static void mnode_delete___0(mnode *p ) 
{ 
  mnode *child ;

  {
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! p) {
#line 58
      goto while_break;
    }
#line 60
    child = p->child;
#line 62
    if (p->list) {
      {
#line 63
      wordlist_close(p->list);
      }
    }
#line 64
    if (p->next) {
      {
#line 65
      mnode_delete___0(p->next);
      }
    }
#line 67
    p = child;
#line 68
    n_mnode_delete ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return;
}
}
#line 76 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/mnode.c"
static unsigned char buf___0[256]  ;
#line 313 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/mnode.c"
static mnode *mnode_query_stub___0(mnode *node , unsigned char const   *query ) 
{ 
  mnode *tmp ;
  mnode *tmp___0 ;
  mnode *tmp___1 ;

  {
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 318
    if ((int const   )*query == (int const   )((unsigned char )node->attr)) {
#line 319
      query ++;
#line 319
      if ((int const   )*query == 0) {
#line 319
        tmp___1 = node;
      } else {
#line 319
        if (node->child) {
          {
#line 319
          tmp = mnode_query_stub___0(node->child, query);
#line 319
          tmp___0 = tmp;
          }
        } else {
#line 319
          tmp___0 = (mnode *)((void *)0);
        }
#line 319
        tmp___1 = tmp___0;
      }
#line 319
      return (tmp___1);
    }
#line 321
    node = node->next;
#line 321
    if (! node) {
#line 322
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 324
  return ((mnode *)((void *)0));
}
}
#line 334 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/mnode.c"
static void mnode_traverse_stub___0(mnode *node , void (*proc)(mnode *node , void *data ) ,
                                    void *data ) 
{ 


  {
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 339
    if (node->child) {
      {
#line 340
      mnode_traverse_stub___0(node->child, proc, data);
      }
    }
    {
#line 341
    (*proc)(node, data);
#line 342
    node = node->next;
    }
#line 342
    if (! node) {
#line 343
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 345
  return;
}
}
#line 62 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/rxgen.c"
static rnode *rnode_new___0(void) 
{ 
  void *tmp ;

  {
  {
#line 65
  n_rnode_new ++;
#line 66
  tmp = calloc((size_t )1, sizeof(rnode ));
  }
#line 66
  return ((rnode *)tmp);
}
}
#line 69 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/rxgen.c"
static void rnode_delete___0(rnode *node ) 
{ 
  rnode *child ;

  {
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 72
    if (! node) {
#line 72
      goto while_break;
    }
#line 74
    child = node->child;
#line 75
    if (node->next) {
      {
#line 76
      rnode_delete___0(node->next);
      }
    }
    {
#line 77
    free((void *)node);
#line 78
    node = child;
#line 79
    n_rnode_delete ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  return;
}
}
#line 87 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/rxgen.c"
static int default_char2int___0(unsigned char const   *in , unsigned int *out ) 
{ 


  {
#line 90
  if (out) {
#line 91
    *out = (unsigned int )*in;
  }
#line 92
  return (1);
}
}
#line 95 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/rxgen.c"
static int default_int2char___0(unsigned int in , unsigned char *out ) 
{ 
  int len ;

  {
#line 98
  len = 0;
  {
#line 103
  if (in == 47U) {
#line 103
    goto case_47;
  }
#line 103
  if (in == 36U) {
#line 103
    goto case_47;
  }
#line 103
  if (in == 94U) {
#line 103
    goto case_47;
  }
#line 103
  if (in == 42U) {
#line 103
    goto case_47;
  }
#line 103
  if (in == 46U) {
#line 103
    goto case_47;
  }
#line 103
  if (in == 92U) {
#line 103
    goto case_47;
  }
#line 110
  goto switch_default;
  case_47: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_94: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_92: /* CIL Label */ 
#line 107
  if (out) {
#line 108
    *(out + len) = (unsigned char )'\\';
  }
#line 109
  len ++;
  switch_default: /* CIL Label */ 
#line 111
  if (out) {
#line 112
    *(out + len) = (unsigned char )(in & 255U);
  }
#line 113
  len ++;
#line 114
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 116
  return (len);
}
}
#line 133 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/rxgen.c"
static int rxgen_call_char2int___0(rxgen *object , unsigned char const   *pch , unsigned int *code ) 
{ 
  int len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 137
  tmp = (*(object->char2int))(pch, code);
#line 137
  len = tmp;
  }
#line 138
  if (len) {
#line 138
    tmp___1 = len;
  } else {
    {
#line 138
    tmp___0 = default_char2int___0(pch, code);
#line 138
    tmp___1 = tmp___0;
    }
  }
#line 138
  return (tmp___1);
}
}
#line 141 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/rxgen.c"
static int rxgen_call_int2char___0(rxgen *object , unsigned int code , unsigned char *buf___1 ) 
{ 
  int len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 144
  tmp = (*(object->int2char))(code, buf___1);
#line 144
  len = tmp;
  }
#line 145
  if (len) {
#line 145
    tmp___1 = len;
  } else {
    {
#line 145
    tmp___0 = default_int2char___0(code, buf___1);
#line 145
    tmp___1 = tmp___0;
    }
  }
#line 145
  return (tmp___1);
}
}
#line 176 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/rxgen.c"
static rnode *search_rnode___0(rnode *node , unsigned int code ) 
{ 


  {
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (node) {
#line 179
      if (! (node->code != code)) {
#line 179
        goto while_break;
      }
    } else {
#line 179
      goto while_break;
    }
#line 180
    node = node->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 181
  return (node);
}
}
#line 237 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/rxgen.c"
static void rxgen_generate_stub___0(rxgen *object , wordbuf_t *buf___1 , rnode *node ) 
{ 
  unsigned char ch[16] ;
  int chlen ;
  int nochild ;
  int haschild ;
  int brother ;
  rnode *tmp ;

  {
#line 241
  haschild = 0;
#line 241
  brother = 1;
#line 245
  tmp = node;
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 245
    if (! tmp) {
#line 245
      goto while_break;
    }
#line 247
    if (tmp->next) {
#line 248
      brother ++;
    }
#line 249
    if (tmp->child) {
#line 250
      haschild ++;
    }
#line 245
    tmp = tmp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 252
  nochild = brother - haschild;
#line 258
  if (brother > 1) {
#line 258
    if (haschild > 0) {
      {
#line 259
      wordbuf_cat(buf___1, (unsigned char const   *)(object->op_nest_in));
      }
    }
  }
#line 262
  if (nochild > 0) {
#line 264
    if (nochild > 1) {
      {
#line 265
      wordbuf_cat(buf___1, (unsigned char const   *)(object->op_select_in));
      }
    }
#line 266
    tmp = node;
    {
#line 266
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 266
      if (! tmp) {
#line 266
        goto while_break___0;
      }
#line 268
      if (tmp->child) {
#line 269
        goto __Cont;
      }
      {
#line 270
      chlen = rxgen_call_int2char___0(object, tmp->code, ch);
#line 271
      ch[chlen] = (unsigned char )'\000';
#line 273
      wordbuf_cat(buf___1, (unsigned char const   *)(ch));
      }
      __Cont: /* CIL Label */ 
#line 266
      tmp = tmp->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 275
    if (nochild > 1) {
      {
#line 276
      wordbuf_cat(buf___1, (unsigned char const   *)(object->op_select_out));
      }
    }
  }
#line 281
  if (haschild > 0) {
#line 284
    if (nochild > 0) {
      {
#line 285
      wordbuf_cat(buf___1, (unsigned char const   *)(object->op_or));
      }
    }
#line 286
    tmp = node;
    {
#line 286
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 286
      if (! (! tmp->child)) {
#line 286
        goto while_break___1;
      }
#line 286
      tmp = tmp->next;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 288
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 290
      chlen = rxgen_call_int2char___0(object, tmp->code, ch);
#line 292
      ch[chlen] = (unsigned char )'\000';
#line 293
      wordbuf_cat(buf___1, (unsigned char const   *)(ch));
      }
#line 295
      if (object->op_newline[0]) {
        {
#line 296
        wordbuf_cat(buf___1, (unsigned char const   *)(object->op_newline));
        }
      }
      {
#line 297
      rxgen_generate_stub___0(object, buf___1, tmp->child);
#line 298
      tmp = tmp->next;
      }
      {
#line 298
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 298
        if (tmp) {
#line 298
          if (! (! tmp->child)) {
#line 298
            goto while_break___3;
          }
        } else {
#line 298
          goto while_break___3;
        }
#line 298
        tmp = tmp->next;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 300
      if (! tmp) {
#line 301
        goto while_break___2;
      }
#line 302
      if (haschild > 1) {
        {
#line 303
        wordbuf_cat(buf___1, (unsigned char const   *)(object->op_or));
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 308
  if (brother > 1) {
#line 308
    if (haschild > 0) {
      {
#line 309
      wordbuf_cat(buf___1, (unsigned char const   *)(object->op_nest_out));
      }
    }
  }
#line 310
  return;
}
}
#line 347 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/rxgen.c"
static unsigned char *rxgen_get_operator_stub___0(rxgen *object , int index___0 ) 
{ 


  {
  {
#line 352
  if (index___0 == 0) {
#line 352
    goto case_0;
  }
#line 354
  if (index___0 == 1) {
#line 354
    goto case_1;
  }
#line 356
  if (index___0 == 2) {
#line 356
    goto case_2;
  }
#line 358
  if (index___0 == 3) {
#line 358
    goto case_3;
  }
#line 360
  if (index___0 == 4) {
#line 360
    goto case_4;
  }
#line 362
  if (index___0 == 5) {
#line 362
    goto case_5;
  }
#line 364
  goto switch_default;
  case_0: /* CIL Label */ 
#line 353
  return (object->op_or);
  case_1: /* CIL Label */ 
#line 355
  return (object->op_nest_in);
  case_2: /* CIL Label */ 
#line 357
  return (object->op_nest_out);
  case_3: /* CIL Label */ 
#line 359
  return (object->op_select_in);
  case_4: /* CIL Label */ 
#line 361
  return (object->op_select_out);
  case_5: /* CIL Label */ 
#line 363
  return (object->op_newline);
  switch_default: /* CIL Label */ 
#line 365
  return ((unsigned char *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 12 "/home/wheatley/newnew/temp/cmigemo-1.2+gh0.20140306/src/filename.c"
static int my_strlen___2(char const   *s ) 
{ 
  size_t len ;
  int tmp ;

  {
  {
#line 17
  len = strlen(s);
  }
#line 18
  if (len <= 2147483647UL) {
#line 18
    tmp = (int )len;
  } else {
#line 18
    tmp = 2147483647;
  }
#line 18
  return (tmp);
}
}
