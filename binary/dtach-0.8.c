/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 60 "/usr/include/fcntl.h"
typedef __pid_t pid_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_48 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_48 fd_set;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 29 "/usr/include/x86_64-linux-gnu/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 107 "/home/june/repo/benchmarks/collector/temp/dtach-0.8/dtach.h"
union __anonunion_u_71 {
   unsigned char buf[sizeof(struct winsize )] ;
   struct winsize ws ;
};
#line 107 "/home/june/repo/benchmarks/collector/temp/dtach-0.8/dtach.h"
struct packet {
   unsigned char type ;
   unsigned char len ;
   union __anonunion_u_71 u ;
};
#line 22 "/home/june/repo/benchmarks/collector/temp/dtach-0.8/master.c"
struct pty {
   int fd ;
   pid_t pid ;
   struct termios term ;
   struct winsize ws ;
};
#line 40 "/home/june/repo/benchmarks/collector/temp/dtach-0.8/master.c"
struct client {
   struct client *next ;
   struct client **pprev ;
   int fd ;
   int attached ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 66 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 826 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 84 "/home/june/repo/benchmarks/collector/temp/dtach-0.8/dtach.h"
char *progname  ;
#line 84 "/home/june/repo/benchmarks/collector/temp/dtach-0.8/dtach.h"
char *sockname  ;
#line 85
int detach_char ;
#line 85 "/home/june/repo/benchmarks/collector/temp/dtach-0.8/dtach.h"
int no_suspend  ;
#line 85
int redraw_method ;
#line 86 "/home/june/repo/benchmarks/collector/temp/dtach-0.8/dtach.h"
struct termios orig_term  ;
#line 87 "/home/june/repo/benchmarks/collector/temp/dtach-0.8/dtach.h"
int dont_have_tty  ;
#line 130
int attach_main(int noerror ) ;
#line 131
int master_main(char **argv , int waitattach ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/dtach-0.8/main.c"
char const   copyright[57]  = 
#line 28 "/home/june/repo/benchmarks/collector/temp/dtach-0.8/main.c"
  {      (char const   )'d',      (char const   )'t',      (char const   )'a',      (char const   )'c', 
        (char const   )'h',      (char const   )' ',      (char const   )'-',      (char const   )' ', 
        (char const   )'v',      (char const   )'e',      (char const   )'r',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )' ', 
        (char const   )'0',      (char const   )'.',      (char const   )'8',      (char const   )'(', 
        (char const   )'C',      (char const   )')',      (char const   )'C',      (char const   )'o', 
        (char const   )'p',      (char const   )'y',      (char const   )'r',      (char const   )'i', 
        (char const   )'g',      (char const   )'h',      (char const   )'t',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'4', 
        (char const   )'-',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'8',      (char const   )' ',      (char const   )'N',      (char const   )'e', 
        (char const   )'d',      (char const   )' ',      (char const   )'T',      (char const   )'.', 
        (char const   )' ',      (char const   )'C',      (char const   )'r',      (char const   )'i', 
        (char const   )'g',      (char const   )'l',      (char const   )'e',      (char const   )'r', 
        (char const   )'\000'};
#line 35 "/home/june/repo/benchmarks/collector/temp/dtach-0.8/main.c"
int detach_char  =    28;
#line 39 "/home/june/repo/benchmarks/collector/temp/dtach-0.8/main.c"
int redraw_method  =    0;
#line 49 "/home/june/repo/benchmarks/collector/temp/dtach-0.8/main.c"
static void usage(void) 
{ 


  {
  {
#line 52
  printf((char const   */* __restrict  */)"dtach - version %s, compiled on %s at %s.\nUsage: dtach -a <socket> <options>\n       dtach -A <socket> <options> <command...>\n       dtach -c <socket> <options> <command...>\n       dtach -n <socket> <options> <command...>\nModes:\n  -a\t\tAttach to the specified socket.\n  -A\t\tAttach to the specified socket, or create it if it\n\t\t  does not exist, running the specified command.\n  -c\t\tCreate a new socket and run the specified command.\n  -n\t\tCreate a new socket and run the specified command detached.\nOptions:\n  -e <char>\tSet the detach character to <char>, defaults to ^\\.\n  -E\t\tDisable the detach character.\n  -r <method>\tSet the redraw method to <method>. The valid methods are:\n\t\t     none: Don\'t redraw at all.\n\t\t   ctrl_l: Send a Ctrl L character to the program.\n\t\t    winch: Send a WINCH signal to the program.\n  -z\t\tDisable processing of the suspend key.\n\nReport any bugs to <crigler@users.sourceforge.net>.\n",
         "0.8", "Mar  3 2016", "04:27:46");
#line 77
  exit(0);
  }
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/dtach-0.8/main.c"
int main(int argc , char **argv ) 
{ 
  int mode ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *p ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  int *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 83
  mode = 0;
#line 86
  progname = *(argv + 0);
#line 87
  argv ++;
#line 87
  argc --;
#line 90
  if (argc >= 1) {
#line 90
    if ((int )*(*argv) == 45) {
      {
#line 92
      tmp___1 = strlen((char const   *)*argv);
#line 92
      tmp___2 = strncmp((char const   *)*argv, "--help", tmp___1);
      }
#line 92
      if (tmp___2 == 0) {
        {
#line 93
        usage();
        }
      } else {
        {
#line 94
        tmp = strlen((char const   *)*argv);
#line 94
        tmp___0 = strncmp((char const   *)*argv, "--version", tmp);
        }
#line 94
        if (tmp___0 == 0) {
          {
#line 96
          printf((char const   */* __restrict  */)"dtach - version %s, compiled on %s at %s.\n",
                 "0.8", "Mar  3 2016", "04:27:46");
          }
#line 98
          return (0);
        }
      }
#line 101
      mode = (int )*(*(argv + 0) + 1);
#line 102
      if (mode == 63) {
        {
#line 103
        usage();
        }
      } else
#line 104
      if (mode != 97) {
#line 104
        if (mode != 99) {
#line 104
          if (mode != 110) {
#line 104
            if (mode != 65) {
              {
#line 107
              printf((char const   */* __restrict  */)"%s: Invalid mode \'-%c\'\n",
                     progname, mode);
#line 108
              printf((char const   */* __restrict  */)"Try \'%s --help\' for more information.\n",
                     progname);
              }
#line 110
              return (1);
            }
          }
        }
      }
    }
  }
#line 113
  if (! mode) {
    {
#line 115
    printf((char const   */* __restrict  */)"%s: No mode was specified.\n", progname);
#line 116
    printf((char const   */* __restrict  */)"Try \'%s --help\' for more information.\n",
           progname);
    }
#line 118
    return (1);
  }
#line 120
  argv ++;
#line 120
  argc --;
#line 122
  if (argc < 1) {
    {
#line 124
    printf((char const   */* __restrict  */)"%s: No socket was specified.\n", progname);
#line 125
    printf((char const   */* __restrict  */)"Try \'%s --help\' for more information.\n",
           progname);
    }
#line 127
    return (1);
  }
#line 129
  sockname = *argv;
#line 130
  argv ++;
#line 130
  argc --;
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 132
    if (argc >= 1) {
#line 132
      if (! ((int )*(*argv) == 45)) {
#line 132
        goto while_break;
      }
    } else {
#line 132
      goto while_break;
    }
#line 136
    p = *(argv + 0) + 1;
    {
#line 136
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 136
      if (! *p) {
#line 136
        goto while_break___0;
      }
#line 138
      if ((int )*p == 69) {
#line 139
        detach_char = -1;
      } else
#line 140
      if ((int )*p == 122) {
#line 141
        no_suspend = 1;
      } else
#line 142
      if ((int )*p == 101) {
#line 144
        argv ++;
#line 144
        argc --;
#line 145
        if (argc < 1) {
          {
#line 147
          printf((char const   */* __restrict  */)"%s: No escape character specified.\n",
                 progname);
#line 149
          printf((char const   */* __restrict  */)"Try \'%s --help\' for more information.\n",
                 progname);
          }
#line 151
          return (1);
        }
#line 153
        if ((int )*(*(argv + 0) + 0) == 94) {
#line 153
          if (*(*(argv + 0) + 1)) {
#line 155
            if ((int )*(*(argv + 0) + 1) == 63) {
#line 156
              detach_char = '\177';
            } else {
#line 158
              detach_char = (int )*(*(argv + 0) + 1) & 31;
            }
          } else {
#line 161
            detach_char = (int )*(*(argv + 0) + 0);
          }
        } else {
#line 161
          detach_char = (int )*(*(argv + 0) + 0);
        }
#line 162
        goto while_break___0;
      } else
#line 164
      if ((int )*p == 114) {
#line 166
        argv ++;
#line 166
        argc --;
#line 167
        if (argc < 1) {
          {
#line 169
          printf((char const   */* __restrict  */)"%s: No redraw method specified.\n",
                 progname);
#line 171
          printf((char const   */* __restrict  */)"Try \'%s --help\' for more information.\n",
                 progname);
          }
#line 173
          return (1);
        }
        {
#line 175
        tmp___5 = strcmp((char const   *)*(argv + 0), "none");
        }
#line 175
        if (tmp___5 == 0) {
#line 176
          redraw_method = 1;
        } else {
          {
#line 177
          tmp___4 = strcmp((char const   *)*(argv + 0), "ctrl_l");
          }
#line 177
          if (tmp___4 == 0) {
#line 178
            redraw_method = 2;
          } else {
            {
#line 179
            tmp___3 = strcmp((char const   *)*(argv + 0), "winch");
            }
#line 179
            if (tmp___3 == 0) {
#line 180
              redraw_method = 3;
            } else {
              {
#line 183
              printf((char const   */* __restrict  */)"%s: Invalid redraw method specified.\n",
                     progname);
#line 185
              printf((char const   */* __restrict  */)"Try \'%s --help\' for more information.\n",
                     progname);
              }
#line 187
              return (1);
            }
          }
        }
#line 189
        goto while_break___0;
      } else {
        {
#line 193
        printf((char const   */* __restrict  */)"%s: Invalid option \'-%c\'\n", progname,
               (int )*p);
#line 195
        printf((char const   */* __restrict  */)"Try \'%s --help\' for more information.\n",
               progname);
        }
#line 197
        return (1);
      }
#line 136
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 200
    argv ++;
#line 200
    argc --;
  }
  while_break: /* CIL Label */ ;
  }
#line 203
  if (mode != 97) {
#line 203
    if (argc < 1) {
      {
#line 205
      printf((char const   */* __restrict  */)"%s: No command was specified.\n", progname);
#line 206
      printf((char const   */* __restrict  */)"Try \'%s --help\' for more information.\n",
             progname);
      }
#line 208
      return (1);
    }
  }
  {
#line 212
  tmp___6 = tcgetattr(0, & orig_term);
  }
#line 212
  if (tmp___6 < 0) {
    {
#line 214
    memset((void *)(& orig_term), 0, sizeof(struct termios ));
#line 215
    dont_have_tty = 1;
    }
  }
#line 218
  if (dont_have_tty) {
#line 218
    if (mode != 110) {
      {
#line 220
      printf((char const   */* __restrict  */)"%s: Attaching to a session requires a terminal.\n",
             progname);
      }
#line 222
      return (1);
    }
  }
#line 225
  if (mode == 97) {
#line 227
    if (argc > 0) {
      {
#line 229
      printf((char const   */* __restrict  */)"%s: Invalid number of arguments.\n",
             progname);
#line 231
      printf((char const   */* __restrict  */)"Try \'%s --help\' for more information.\n",
             progname);
      }
#line 233
      return (1);
    }
    {
#line 235
    tmp___7 = attach_main(0);
    }
#line 235
    return (tmp___7);
  } else
#line 237
  if (mode == 110) {
    {
#line 238
    tmp___8 = master_main(argv, 0);
    }
#line 238
    return (tmp___8);
  } else
#line 239
  if (mode == 99) {
    {
#line 241
    tmp___9 = master_main(argv, 1);
    }
#line 241
    if (tmp___9 != 0) {
#line 242
      return (1);
    }
    {
#line 243
    tmp___10 = attach_main(0);
    }
#line 243
    return (tmp___10);
  } else
#line 245
  if (mode == 65) {
    {
#line 249
    tmp___16 = attach_main(1);
    }
#line 249
    if (tmp___16 != 0) {
      {
#line 251
      tmp___13 = __errno_location();
      }
#line 251
      if (*tmp___13 == 111) {
#line 251
        goto _L;
      } else {
        {
#line 251
        tmp___14 = __errno_location();
        }
#line 251
        if (*tmp___14 == 2) {
          _L: /* CIL Label */ 
          {
#line 253
          tmp___11 = __errno_location();
          }
#line 253
          if (*tmp___11 == 111) {
            {
#line 254
            unlink((char const   *)sockname);
            }
          }
          {
#line 255
          tmp___12 = master_main(argv, 1);
          }
#line 255
          if (tmp___12 != 0) {
#line 256
            return (1);
          }
        }
      }
      {
#line 258
      tmp___15 = attach_main(0);
      }
#line 258
      return (tmp___15);
    }
  }
#line 261
  return (0);
}
}
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 146
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 519
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 39 "/usr/include/pty.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) forkpty)(int *__amaster ,
                                                                              char *__name ,
                                                                              struct termios  const  *__termp ,
                                                                              struct winsize  const  *__winp ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 603
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 284 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/dtach-0.8/master.c"
static struct client *clients  ;
#line 55 "/home/june/repo/benchmarks/collector/temp/dtach-0.8/master.c"
static struct pty the_pty  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/dtach-0.8/master.c"
static void unlink_socket(void) 
{ 


  {
  {
#line 66
  unlink((char const   *)sockname);
  }
#line 67
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/dtach-0.8/master.c"
static void die(int sig ) 
{ 


  {
#line 74
  if (sig == 17) {
#line 80
    return;
  }
  {
#line 82
  exit(1);
  }
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/dtach-0.8/master.c"
static int setnonblocking(int fd ) 
{ 
  int flags ;
  int tmp ;

  {
  {
#line 92
  flags = fcntl(fd, 3);
  }
#line 93
  if (flags < 0) {
#line 94
    return (-1);
  } else {
    {
#line 93
    tmp = fcntl(fd, 4, flags | 2048);
    }
#line 93
    if (tmp < 0) {
#line 94
      return (-1);
    }
  }
#line 95
  return (0);
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/dtach-0.8/master.c"
static int init_pty(char **argv , int statusfd ) 
{ 
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 113
  the_pty.term = orig_term;
#line 114
  memset((void *)(& the_pty.ws), 0, sizeof(struct winsize ));
  }
#line 117
  if (! dont_have_tty) {
    {
#line 118
    the_pty.pid = forkpty(& the_pty.fd, (char *)((void *)0), (struct termios  const  *)(& the_pty.term),
                          (struct winsize  const  *)((void *)0));
    }
  } else {
    {
#line 120
    the_pty.pid = forkpty(& the_pty.fd, (char *)((void *)0), (struct termios  const  *)((void *)0),
                          (struct winsize  const  *)((void *)0));
    }
  }
#line 121
  if (the_pty.pid < 0) {
#line 122
    return (-1);
  } else
#line 123
  if (the_pty.pid == 0) {
    {
#line 126
    execvp((char const   *)*argv, (char * const  *)argv);
    }
#line 130
    if (statusfd != -1) {
      {
#line 131
      dup2(statusfd, 1);
      }
    } else {
      {
#line 133
      printf((char const   */* __restrict  */)"\033[999H\r\n");
      }
    }
    {
#line 135
    tmp = __errno_location();
#line 135
    tmp___0 = strerror(*tmp);
#line 135
    printf((char const   */* __restrict  */)"%s: could not execute %s: %s\r\n", progname,
           *argv, tmp___0);
#line 137
    fflush(stdout);
#line 138
    _exit(127);
    }
  }
#line 149
  return (0);
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/dtach-0.8/master.c"
static void killpty(struct pty *pty , int sig ) 
{ 
  pid_t pgrp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 156
  pgrp = -1;
#line 163
  tmp = ioctl(pty->fd, (unsigned long )(((1U << 30) | (unsigned int )(84 << 8)) | 54U) | (sizeof(int ) << 16),
              sig);
  }
#line 163
  if (tmp >= 0) {
#line 164
    return;
  }
  {
#line 172
  tmp___0 = ioctl(pty->fd, 21519UL, & pgrp);
  }
#line 172
  if (tmp___0 >= 0) {
#line 172
    if (pgrp != -1) {
      {
#line 172
      tmp___1 = kill(- pgrp, sig);
      }
#line 172
      if (tmp___1 >= 0) {
#line 174
        return;
      }
    }
  }
  {
#line 178
  kill(- pty->pid, sig);
  }
#line 179
  return;
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/dtach-0.8/master.c"
static int create_socket(char *name ) 
{ 
  int s ;
  struct sockaddr_un sockun ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 188
  s = socket(1, 1, 0);
  }
#line 189
  if (s < 0) {
#line 190
    return (-1);
  }
  {
#line 191
  sockun.sun_family = (sa_family_t )1;
#line 192
  strcpy((char */* __restrict  */)(sockun.sun_path), (char const   */* __restrict  */)name);
#line 193
  tmp = bind(s, (struct sockaddr  const  *)((struct sockaddr *)(& sockun)), (socklen_t )sizeof(sockun));
  }
#line 193
  if (tmp < 0) {
    {
#line 195
    close(s);
    }
#line 196
    return (-1);
  }
  {
#line 198
  tmp___0 = listen(s, 128);
  }
#line 198
  if (tmp___0 < 0) {
    {
#line 200
    close(s);
    }
#line 201
    return (-1);
  }
  {
#line 203
  tmp___1 = setnonblocking(s);
  }
#line 203
  if (tmp___1 < 0) {
    {
#line 205
    close(s);
    }
#line 206
    return (-1);
  }
  {
#line 209
  tmp___2 = chmod((char const   *)name, (__mode_t )384);
  }
#line 209
  if (tmp___2 < 0) {
    {
#line 211
    close(s);
    }
#line 212
    return (-1);
  }
#line 214
  return (s);
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/dtach-0.8/master.c"
static void pty_activity(int s ) 
{ 
  unsigned char buf[4096] ;
  int len ;
  struct client *p ;
  fd_set readfds ;
  fd_set writefds ;
  int highest_fd ;
  int nclients ;
  ssize_t tmp ;
  int tmp___0 ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int tmp___1 ;
  int written ;
  int n ;
  ssize_t tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 229
  tmp = read(the_pty.fd, (void *)(buf), sizeof(buf));
#line 229
  len = (int )tmp;
  }
#line 232
  if (len <= 0) {
    {
#line 233
    exit(1);
    }
  }
  {
#line 241
  tmp___0 = tcgetattr(the_pty.fd, & the_pty.term);
  }
#line 241
  if (tmp___0 < 0) {
    {
#line 242
    exit(1);
    }
  }
  top: 
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& readfds.__fds_bits[0]): "memory");
#line 250
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 251
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 251
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& writefds.__fds_bits[0]): "memory");
#line 251
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 252
  readfds.__fds_bits[s / (8 * (int )sizeof(__fd_mask ))] |= 1L << s % (8 * (int )sizeof(__fd_mask ));
#line 253
  highest_fd = s;
#line 254
  p = clients;
#line 254
  nclients = 0;
  {
#line 254
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 254
    if (! p) {
#line 254
      goto while_break___1;
    }
#line 256
    if (! p->attached) {
#line 257
      goto __Cont;
    }
#line 258
    writefds.__fds_bits[p->fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << p->fd % (8 * (int )sizeof(__fd_mask ));
#line 259
    if (p->fd > highest_fd) {
#line 260
      highest_fd = p->fd;
    }
#line 261
    nclients ++;
    __Cont: /* CIL Label */ 
#line 254
    p = p->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 263
  if (nclients == 0) {
#line 264
    return;
  }
  {
#line 265
  tmp___1 = select(highest_fd + 1, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)(& writefds),
                   (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
  }
#line 265
  if (tmp___1 < 0) {
#line 266
    return;
  }
#line 269
  p = clients;
#line 269
  nclients = 0;
  {
#line 269
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 269
    if (! p) {
#line 269
      goto while_break___2;
    }
#line 273
    if (! ((writefds.__fds_bits[p->fd / (8 * (int )sizeof(__fd_mask ))] & (1L << p->fd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
#line 274
      goto __Cont___0;
    }
#line 276
    written = 0;
    {
#line 277
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 277
      if (! (written < len)) {
#line 277
        goto while_break___3;
      }
      {
#line 279
      tmp___2 = write(p->fd, (void const   *)(buf + written), (size_t )(len - written));
#line 279
      n = (int )tmp___2;
      }
#line 281
      if (n > 0) {
#line 283
        written += n;
#line 284
        goto while_continue___3;
      } else
#line 286
      if (n < 0) {
        {
#line 286
        tmp___4 = __errno_location();
        }
#line 286
        if (*tmp___4 == 4) {
#line 287
          goto while_continue___3;
        } else {
#line 286
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 288
      if (n < 0) {
        {
#line 288
        tmp___3 = __errno_location();
        }
#line 288
        if (*tmp___3 != 11) {
#line 289
          nclients = -1;
        }
      }
#line 290
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 292
    if (nclients != -1) {
#line 292
      if (written == len) {
#line 293
        nclients ++;
      }
    }
    __Cont___0: /* CIL Label */ 
#line 269
    p = p->next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 297
  if (! ((readfds.__fds_bits[s / (8 * (int )sizeof(__fd_mask ))] & (1L << s % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
#line 297
    if (nclients == 0) {
#line 298
      goto top;
    }
  }
#line 299
  return;
}
}
#line 302 "/home/june/repo/benchmarks/collector/temp/dtach-0.8/master.c"
static void control_activity(int s ) 
{ 
  int fd ;
  struct client *p ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 309
  fd = accept(s, (struct sockaddr */* __restrict  */)((void *)0), (socklen_t */* __restrict  */)((void *)0));
  }
#line 310
  if (fd < 0) {
#line 311
    return;
  } else {
    {
#line 312
    tmp = setnonblocking(fd);
    }
#line 312
    if (tmp < 0) {
      {
#line 314
      close(fd);
      }
#line 315
      return;
    }
  }
  {
#line 319
  tmp___0 = malloc(sizeof(struct client ));
#line 319
  p = (struct client *)tmp___0;
#line 320
  p->fd = fd;
#line 321
  p->attached = 0;
#line 322
  p->pprev = & clients;
#line 323
  p->next = *(p->pprev);
  }
#line 324
  if (p->next) {
#line 325
    (p->next)->pprev = & p->next;
  }
#line 326
  *(p->pprev) = p;
#line 327
  return;
}
}
#line 330 "/home/june/repo/benchmarks/collector/temp/dtach-0.8/master.c"
static void client_activity(struct client *p ) 
{ 
  int len ;
  struct packet pkt ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int method ;
  char c ;

  {
  {
#line 337
  tmp = read(p->fd, (void *)(& pkt), sizeof(struct packet ));
#line 337
  len = (int )tmp;
  }
#line 338
  if (len < 0) {
    {
#line 338
    tmp___0 = __errno_location();
    }
#line 338
    if (*tmp___0 == 11) {
#line 339
      return;
    } else {
      {
#line 338
      tmp___1 = __errno_location();
      }
#line 338
      if (*tmp___1 == 4) {
#line 339
        return;
      }
    }
  }
#line 342
  if (len <= 0) {
    {
#line 344
    close(p->fd);
    }
#line 345
    if (p->next) {
#line 346
      (p->next)->pprev = p->pprev;
    }
    {
#line 347
    *(p->pprev) = p->next;
#line 348
    free((void *)p);
    }
#line 349
    return;
  }
#line 353
  if ((int )pkt.type == 0) {
    {
#line 354
    write(the_pty.fd, (void const   *)(pkt.u.buf), (size_t )pkt.len);
    }
  } else
#line 357
  if ((int )pkt.type == 1) {
#line 358
    p->attached = 1;
  } else
#line 359
  if ((int )pkt.type == 2) {
#line 360
    p->attached = 0;
  } else
#line 363
  if ((int )pkt.type == 3) {
    {
#line 365
    the_pty.ws = pkt.u.ws;
#line 366
    ioctl(the_pty.fd, 21524UL, & the_pty.ws);
    }
  } else
#line 370
  if ((int )pkt.type == 4) {
#line 372
    method = (int )pkt.len;
#line 376
    if (method == 0) {
#line 377
      method = redraw_method;
    }
#line 378
    if (method == 1) {
#line 379
      return;
    }
    {
#line 382
    the_pty.ws = pkt.u.ws;
#line 383
    ioctl(the_pty.fd, 21524UL, & the_pty.ws);
    }
#line 387
    if (method == 2) {
#line 389
      c = (char )'\f';
#line 391
      if ((the_pty.term.c_lflag & 10U) == 0U) {
#line 391
        if ((int )the_pty.term.c_cc[6] == 1) {
          {
#line 394
          write(the_pty.fd, (void const   *)(& c), (size_t )1);
          }
        }
      }
    } else
#line 398
    if (method == 3) {
      {
#line 400
      killpty(& the_pty, 28);
      }
    }
  }
#line 403
  return;
}
}
#line 407 "/home/june/repo/benchmarks/collector/temp/dtach-0.8/master.c"
static void master_process(int s , char **argv , int waitattach , int statusfd ) 
{ 
  struct client *p ;
  struct client *next ;
  fd_set readfds ;
  int highest_fd ;
  int nullfd ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int __d0 ;
  int __d1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 417
  setsid();
#line 420
  atexit(& unlink_socket);
#line 423
  signal(13, (void (*)(int  ))1);
#line 424
  signal(25, (void (*)(int  ))1);
#line 425
  signal(1, (void (*)(int  ))1);
#line 426
  signal(21, (void (*)(int  ))1);
#line 427
  signal(22, (void (*)(int  ))1);
#line 428
  signal(2, & die);
#line 429
  signal(15, & die);
#line 430
  signal(17, & die);
#line 433
  tmp___1 = init_pty(argv, statusfd);
  }
#line 433
  if (tmp___1 < 0) {
#line 435
    if (statusfd != -1) {
      {
#line 436
      dup2(statusfd, 1);
      }
    }
    {
#line 437
    tmp = __errno_location();
#line 437
    tmp___0 = strerror(*tmp);
#line 437
    printf((char const   */* __restrict  */)"%s: init_pty: %s\n", progname, tmp___0);
#line 438
    exit(1);
    }
  }
#line 442
  if (statusfd != -1) {
    {
#line 443
    close(statusfd);
    }
  }
  {
#line 447
  nullfd = open("/dev/null", 2);
#line 448
  dup2(nullfd, 0);
#line 449
  dup2(nullfd, 1);
#line 450
  dup2(nullfd, 2);
  }
#line 451
  if (nullfd > 2) {
    {
#line 452
    close(nullfd);
    }
  }
  {
#line 455
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 458
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 458
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& readfds.__fds_bits[0]): "memory");
#line 458
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 459
    readfds.__fds_bits[s / (8 * (int )sizeof(__fd_mask ))] |= 1L << s % (8 * (int )sizeof(__fd_mask ));
#line 460
    highest_fd = s;
#line 466
    if (waitattach) {
#line 468
      if (clients) {
#line 468
        if (clients->attached) {
#line 469
          waitattach = 0;
        }
      }
    } else {
#line 473
      readfds.__fds_bits[the_pty.fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << the_pty.fd % (8 * (int )sizeof(__fd_mask ));
#line 474
      if (the_pty.fd > highest_fd) {
#line 475
        highest_fd = the_pty.fd;
      }
    }
#line 478
    p = clients;
    {
#line 478
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 478
      if (! p) {
#line 478
        goto while_break___1;
      }
#line 480
      readfds.__fds_bits[p->fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << p->fd % (8 * (int )sizeof(__fd_mask ));
#line 481
      if (p->fd > highest_fd) {
#line 482
        highest_fd = p->fd;
      }
#line 478
      p = p->next;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 486
    tmp___4 = select(highest_fd + 1, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)((void *)0),
                     (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
    }
#line 486
    if (tmp___4 < 0) {
      {
#line 488
      tmp___2 = __errno_location();
      }
#line 488
      if (*tmp___2 == 4) {
#line 489
        goto while_continue;
      } else {
        {
#line 488
        tmp___3 = __errno_location();
        }
#line 488
        if (*tmp___3 == 11) {
#line 489
          goto while_continue;
        }
      }
      {
#line 490
      exit(1);
      }
    }
#line 494
    if ((readfds.__fds_bits[s / (8 * (int )sizeof(__fd_mask ))] & (1L << s % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 495
      control_activity(s);
      }
    }
#line 497
    p = clients;
    {
#line 497
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 497
      if (! p) {
#line 497
        goto while_break___2;
      }
#line 499
      next = p->next;
#line 500
      if ((readfds.__fds_bits[p->fd / (8 * (int )sizeof(__fd_mask ))] & (1L << p->fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 501
        client_activity(p);
        }
      }
#line 497
      p = next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 504
    if ((readfds.__fds_bits[the_pty.fd / (8 * (int )sizeof(__fd_mask ))] & (1L << the_pty.fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 505
      pty_activity(s);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 509 "/home/june/repo/benchmarks/collector/temp/dtach-0.8/master.c"
int master_main(char **argv , int waitattach ) 
{ 
  int fd[2] ;
  int s ;
  pid_t pid ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char buf[1024] ;
  int len ;
  ssize_t tmp___6 ;

  {
#line 512
  fd[0] = -1;
#line 512
  fd[1] = -1;
#line 517
  if (redraw_method == 0) {
#line 518
    redraw_method = 2;
  }
  {
#line 521
  s = create_socket(sockname);
  }
#line 522
  if (s < 0) {
    {
#line 524
    tmp = __errno_location();
#line 524
    tmp___0 = strerror(*tmp);
#line 524
    printf((char const   */* __restrict  */)"%s: %s: %s\n", progname, sockname, tmp___0);
    }
#line 525
    return (1);
  }
  {
#line 529
  fcntl(s, 2, 1);
#line 533
  tmp___3 = pipe((int *)(fd));
  }
#line 533
  if (tmp___3 >= 0) {
    {
#line 535
    tmp___1 = fcntl(fd[0], 2, 1);
    }
#line 535
    if (tmp___1 < 0) {
      {
#line 538
      close(fd[0]);
#line 539
      close(fd[1]);
#line 540
      fd[1] = -1;
#line 540
      fd[0] = fd[1];
      }
    } else {
      {
#line 535
      tmp___2 = fcntl(fd[1], 2, 1);
      }
#line 535
      if (tmp___2 < 0) {
        {
#line 538
        close(fd[0]);
#line 539
        close(fd[1]);
#line 540
        fd[1] = -1;
#line 540
        fd[0] = fd[1];
        }
      }
    }
  }
  {
#line 546
  pid = fork();
  }
#line 547
  if (pid < 0) {
    {
#line 549
    tmp___4 = __errno_location();
#line 549
    tmp___5 = strerror(*tmp___4);
#line 549
    printf((char const   */* __restrict  */)"%s: fork: %s\n", progname, tmp___5);
#line 550
    unlink_socket();
    }
#line 551
    return (1);
  } else
#line 553
  if (pid == 0) {
#line 556
    if (fd[0] != -1) {
      {
#line 557
      close(fd[0]);
      }
    }
    {
#line 558
    master_process(s, argv, waitattach, fd[1]);
    }
#line 559
    return (0);
  }
#line 565
  if (fd[0] != -1) {
    {
#line 570
    close(fd[1]);
#line 571
    tmp___6 = read(fd[0], (void *)(buf), sizeof(buf));
#line 571
    len = (int )tmp___6;
    }
#line 572
    if (len > 0) {
      {
#line 574
      write(2, (void const   *)(buf), (size_t )len);
#line 575
      kill(pid, 15);
      }
#line 576
      return (1);
    }
    {
#line 578
    close(fd[0]);
    }
  }
  {
#line 581
  close(s);
  }
#line 582
  return (0);
}
}
#line 70 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 137 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/dtach-0.8/attach.c"
static struct termios cur_term  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/dtach-0.8/attach.c"
static int win_changed  ;
#line 38 "/home/june/repo/benchmarks/collector/temp/dtach-0.8/attach.c"
static void restore_term(void) 
{ 


  {
  {
#line 41
  tcsetattr(0, 1, (struct termios  const  *)(& orig_term));
#line 44
  printf((char const   */* __restrict  */)"\033[?25h");
#line 45
  fflush(stdout);
  }
#line 46
  return;
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/dtach-0.8/attach.c"
static int connect_socket(char *name ) 
{ 
  int s ;
  struct sockaddr_un sockun ;
  struct stat st ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 55
  s = socket(1, 1, 0);
  }
#line 56
  if (s < 0) {
#line 57
    return (-1);
  }
  {
#line 58
  sockun.sun_family = (sa_family_t )1;
#line 59
  strcpy((char */* __restrict  */)(sockun.sun_path), (char const   */* __restrict  */)name);
#line 60
  tmp___2 = connect(s, (struct sockaddr  const  *)((struct sockaddr *)(& sockun)),
                    (socklen_t )sizeof(sockun));
  }
#line 60
  if (tmp___2 < 0) {
    {
#line 62
    close(s);
#line 66
    tmp___1 = __errno_location();
    }
#line 66
    if (*tmp___1 == 111) {
      {
#line 70
      tmp___0 = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& st));
      }
#line 70
      if (tmp___0 < 0) {
#line 71
        return (-1);
      } else
#line 72
      if (! ((st.st_mode & 61440U) == 49152U)) {
        {
#line 73
        tmp = __errno_location();
#line 73
        *tmp = 88;
        }
      } else
#line 72
      if ((st.st_mode & 61440U) == 32768U) {
        {
#line 73
        tmp = __errno_location();
#line 73
        *tmp = 88;
        }
      }
    }
#line 75
    return (-1);
  }
#line 77
  return (s);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/dtach-0.8/attach.c"
static void die___0(int sig ) 
{ 


  {
#line 85
  if (sig == 1) {
    {
#line 86
    printf((char const   */* __restrict  */)"\033[999H\r\n[detached]\r\n");
    }
  } else
#line 85
  if (sig == 2) {
    {
#line 86
    printf((char const   */* __restrict  */)"\033[999H\r\n[detached]\r\n");
    }
  } else {
    {
#line 88
    printf((char const   */* __restrict  */)"\033[999H\r\n[got signal %d - dying]\r\n",
           sig);
    }
  }
  {
#line 89
  exit(1);
  }
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/dtach-0.8/attach.c"
static void win_change(void) 
{ 


  {
  {
#line 96
  signal(28, (void (*)(int  ))(& win_change));
#line 97
  win_changed = 1;
  }
#line 98
  return;
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/dtach-0.8/attach.c"
static void process_kbd(int s , struct packet *pkt ) 
{ 
  __pid_t tmp ;

  {
#line 105
  if (! no_suspend) {
#line 105
    if ((int )pkt->u.buf[0] == (int )cur_term.c_cc[10]) {
      {
#line 108
      pkt->type = (unsigned char)2;
#line 109
      write(s, (void const   *)pkt, sizeof(struct packet ));
#line 112
      tcsetattr(0, 1, (struct termios  const  *)(& orig_term));
#line 113
      printf((char const   */* __restrict  */)"\033[999H\r\n");
#line 114
      tmp = getpid();
#line 114
      kill(tmp, 20);
#line 115
      tcsetattr(0, 1, (struct termios  const  *)(& cur_term));
#line 118
      pkt->type = (unsigned char)1;
#line 119
      write(s, (void const   *)pkt, sizeof(struct packet ));
#line 122
      pkt->type = (unsigned char)4;
#line 123
      pkt->len = (unsigned char )redraw_method;
#line 124
      ioctl(0, 21523UL, & pkt->u.ws);
#line 125
      write(s, (void const   *)pkt, sizeof(struct packet ));
      }
#line 126
      return;
    } else {
#line 105
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 129
  if ((int )pkt->u.buf[0] == detach_char) {
    {
#line 131
    printf((char const   */* __restrict  */)"\033[999H\r\n[detached]\r\n");
#line 132
    exit(0);
    }
  } else
#line 135
  if ((int )pkt->u.buf[0] == 12) {
#line 136
    win_changed = 1;
  }
  {
#line 139
  write(s, (void const   *)pkt, sizeof(struct packet ));
  }
#line 140
  return;
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/dtach-0.8/attach.c"
int attach_main(int noerror ) 
{ 
  struct packet pkt ;
  unsigned char buf[4096] ;
  fd_set readfds ;
  int s ;
  int *tmp ;
  char *tmp___0 ;
  int n ;
  int __d0 ;
  int __d1 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int len ;
  ssize_t tmp___3 ;
  ssize_t l ;

  {
  {
#line 152
  s = connect_socket(sockname);
  }
#line 153
  if (s < 0) {
#line 155
    if (! noerror) {
      {
#line 156
      tmp = __errno_location();
#line 156
      tmp___0 = strerror(*tmp);
#line 156
      printf((char const   */* __restrict  */)"%s: %s: %s\n", progname, sockname,
             tmp___0);
      }
    }
#line 158
    return (1);
  }
  {
#line 163
  cur_term = orig_term;
#line 166
  atexit(& restore_term);
#line 169
  signal(13, (void (*)(int  ))1);
#line 170
  signal(25, (void (*)(int  ))1);
#line 171
  signal(1, & die___0);
#line 172
  signal(15, & die___0);
#line 173
  signal(2, & die___0);
#line 174
  signal(3, & die___0);
#line 175
  signal(28, (void (*)(int  ))(& win_change));
#line 178
  cur_term.c_iflag &= 4294966804U;
#line 179
  cur_term.c_iflag &= 4294962175U;
#line 180
  cur_term.c_oflag &= 4294967294U;
#line 181
  cur_term.c_lflag &= 4294934452U;
#line 182
  cur_term.c_cflag &= 4294966991U;
#line 183
  cur_term.c_cflag |= 48U;
#line 184
  cur_term.c_cc[15] = (cc_t )'\000';
#line 185
  cur_term.c_cc[6] = (cc_t )1;
#line 186
  cur_term.c_cc[5] = (cc_t )0;
#line 187
  tcsetattr(0, 1, (struct termios  const  *)(& cur_term));
#line 190
  write(1, (void const   *)"\033[H\033[J", (size_t )6);
#line 193
  pkt.type = (unsigned char)1;
#line 194
  write(s, (void const   *)(& pkt), sizeof(struct packet ));
#line 197
  pkt.type = (unsigned char)4;
#line 198
  pkt.len = (unsigned char )redraw_method;
#line 199
  ioctl(0, 21523UL, & pkt.u.ws);
#line 200
  write(s, (void const   *)(& pkt), sizeof(struct packet ));
  }
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 207
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 207
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& readfds.__fds_bits[0]): "memory");
#line 207
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 208
    readfds.__fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << 0 % (8 * (int )sizeof(__fd_mask ));
#line 209
    readfds.__fds_bits[s / (8 * (int )sizeof(__fd_mask ))] |= 1L << s % (8 * (int )sizeof(__fd_mask ));
#line 210
    n = select(s + 1, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)((void *)0),
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
    }
#line 211
    if (n < 0) {
      {
#line 211
      tmp___1 = __errno_location();
      }
#line 211
      if (*tmp___1 != 4) {
        {
#line 211
        tmp___2 = __errno_location();
        }
#line 211
        if (*tmp___2 != 11) {
          {
#line 213
          printf((char const   */* __restrict  */)"\033[999H\r\n[select failed]\r\n");
#line 214
          exit(1);
          }
        }
      }
    }
#line 218
    if (n > 0) {
#line 218
      if ((readfds.__fds_bits[s / (8 * (int )sizeof(__fd_mask ))] & (1L << s % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 220
        tmp___3 = read(s, (void *)(buf), sizeof(buf));
#line 220
        len = (int )tmp___3;
        }
#line 222
        if (len == 0) {
          {
#line 224
          printf((char const   */* __restrict  */)"\033[999H\r\n[EOF - dtach terminating]\r\n");
#line 226
          exit(0);
          }
        } else
#line 228
        if (len < 0) {
          {
#line 230
          printf((char const   */* __restrict  */)"\033[999H\r\n[read returned an error]\r\n");
#line 231
          exit(1);
          }
        }
        {
#line 234
        write(1, (void const   *)(buf), (size_t )len);
#line 235
        n --;
        }
      }
    }
#line 238
    if (n > 0) {
#line 238
      if ((readfds.__fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] & (1L << 0 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 242
        pkt.type = (unsigned char)0;
#line 243
        memset((void *)(pkt.u.buf), 0, sizeof(pkt.u.buf));
#line 244
        l = read(0, (void *)(pkt.u.buf), sizeof(pkt.u.buf));
        }
#line 246
        if (l <= 0L) {
          {
#line 247
          exit(1);
          }
        }
        {
#line 249
        pkt.len = (unsigned char )l;
#line 250
        process_kbd(s, & pkt);
#line 251
        n --;
        }
      }
    }
#line 255
    if (win_changed) {
      {
#line 257
      win_changed = 0;
#line 259
      pkt.type = (unsigned char)3;
#line 260
      ioctl(0, 21523UL, & pkt.u.ws);
#line 261
      write(s, (void const   *)(& pkt), sizeof(pkt));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 264
  return (0);
}
}
