/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 214 "/usr/lib/gcc/i486-linux-gnu/4.1.2/include/stddef.h"
typedef unsigned int size_t;
#line 59 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 143 "/usr/include/bits/types.h"
typedef long __off_t;
#line 144 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 145 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 151 "/usr/include/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 193 "/usr/include/sys/types.h"
typedef int int32_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 46 "/usr/include/stdio.h"
struct _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 176 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 182 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 267 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   int _mode ;
   char _unused2[15UL * sizeof(int ) - 2UL * sizeof(void *)] ;
};
#line 331 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 25 "/usr/include/bits/termios.h"
typedef unsigned char cc_t;
#line 26 "/usr/include/bits/termios.h"
typedef unsigned int speed_t;
#line 27 "/usr/include/bits/termios.h"
typedef unsigned int tcflag_t;
#line 30 "/usr/include/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 257 "/home/pronto/abs/test-suite/screen-4.0.2/os.h"
typedef char *slot_t;
#line 52 "/usr/include/bits/utmp.h"
struct exit_status {
   short e_termination ;
   short e_exit ;
};
#line 60 "/usr/include/bits/utmp.h"
struct utmp {
   short ut_type ;
   pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct exit_status ut_exit ;
   long ut_session ;
   struct timeval ut_tv ;
   int32_t ut_addr_v6[4] ;
   char __unused[20] ;
};
#line 58 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.h"
enum state_t {
    LIT = 0,
    ESC = 1,
    ASTR = 2,
    STRESC = 3,
    CSI = 4,
    PRIN = 5,
    PRINESC = 6,
    PRINCSI = 7,
    PRIN4 = 8
} ;
#line 72
enum string_t {
    NONE = 0,
    DCS = 1,
    OSC = 2,
    APC = 3,
    PM = 4,
    AKA = 5,
    GM = 6,
    STATUS = 7
} ;
#line 25 "/home/pronto/abs/test-suite/screen-4.0.2/sched.h"
struct event {
   struct event *next ;
   void (*handler)(struct event * , char * ) ;
   char *data ;
   int fd ;
   int type ;
   int pri ;
   struct timeval timeout ;
   int queued ;
   int active ;
   int *condpos ;
   int *condneg ;
};
#line 39 "/home/pronto/abs/test-suite/screen-4.0.2/acls.h"
typedef unsigned char *AclBits;
#line 45
struct acluser;
#line 45 "/home/pronto/abs/test-suite/screen-4.0.2/acls.h"
struct aclusergroup {
   struct acluser *u ;
   struct aclusergroup *next ;
};
#line 59 "/home/pronto/abs/test-suite/screen-4.0.2/acls.h"
struct plop {
   char *buf ;
   int len ;
   int enc ;
};
#line 73 "/home/pronto/abs/test-suite/screen-4.0.2/acls.h"
struct acluser {
   struct acluser *u_next ;
   char u_name[21] ;
   char *u_password ;
   int u_checkpassword ;
   int u_detachwin ;
   int u_detachotherwin ;
   int u_Esc ;
   int u_MetaEsc ;
   struct plop u_plop ;
   int u_id ;
   AclBits u_umask_w_bits[3] ;
   struct aclusergroup *u_group ;
};
#line 42 "/home/pronto/abs/test-suite/screen-4.0.2/comm.h"
struct action {
   int nr ;
   char **args ;
   int *argl ;
};
#line 30 "/home/pronto/abs/test-suite/screen-4.0.2/layer.h"
struct mchar;
#line 32 "/home/pronto/abs/test-suite/screen-4.0.2/layer.h"
struct LayFuncs {
   void (*lf_LayProcess)(char ** , int * ) ;
   void (*lf_LayAbort)(void) ;
   void (*lf_LayRedisplayLine)(int  , int  , int  , int  ) ;
   void (*lf_LayClearLine)(int  , int  , int  , int  ) ;
   int (*lf_LayRewrite)(int  , int  , int  , struct mchar * , int  ) ;
   int (*lf_LayResize)(int  , int  ) ;
   void (*lf_LayRestore)(void) ;
};
#line 43
struct canvas;
#line 43 "/home/pronto/abs/test-suite/screen-4.0.2/layer.h"
struct layer {
   struct canvas *l_cvlist ;
   int l_width ;
   int l_height ;
   int l_x ;
   int l_y ;
   int l_encoding ;
   struct LayFuncs *l_layfn ;
   char *l_data ;
   struct layer *l_next ;
   struct layer *l_bottom ;
   int l_blocking ;
};
#line 15 "/home/pronto/abs/test-suite/screen-4.0.2/term.h"
union tcu {
   int flg ;
   int num ;
   char *str ;
};
#line 112 "/home/pronto/abs/test-suite/screen-4.0.2/screen.h"
struct mode {
   struct termios tio ;
};
#line 53 "/home/pronto/abs/test-suite/screen-4.0.2/image.h"
struct mchar {
   unsigned char image ;
   unsigned char attr ;
   unsigned char font ;
   unsigned char color ;
   unsigned char mbcs ;
};
#line 62 "/home/pronto/abs/test-suite/screen-4.0.2/image.h"
struct mline {
   unsigned char *image ;
   unsigned char *attr ;
   unsigned char *font ;
   unsigned char *color ;
};
#line 44 "/home/pronto/abs/test-suite/screen-4.0.2/display.h"
struct win;
#line 46
struct display;
#line 46
struct viewport;
#line 46 "/home/pronto/abs/test-suite/screen-4.0.2/display.h"
struct canvas {
   struct canvas *c_next ;
   struct display *c_display ;
   struct viewport *c_vplist ;
   struct layer *c_layer ;
   struct canvas *c_lnext ;
   struct layer c_blank ;
   int c_xoff ;
   int c_yoff ;
   int c_xs ;
   int c_xe ;
   int c_ys ;
   int c_ye ;
   struct event c_captev ;
};
#line 63 "/home/pronto/abs/test-suite/screen-4.0.2/display.h"
struct viewport {
   struct viewport *v_next ;
   struct canvas *v_canvas ;
   int v_xoff ;
   int v_yoff ;
   int v_xs ;
   int v_xe ;
   int v_ys ;
   int v_ye ;
};
#line 75 "/home/pronto/abs/test-suite/screen-4.0.2/display.h"
struct display {
   struct display *d_next ;
   struct acluser *d_user ;
   struct canvas *d_cvlist ;
   struct canvas *d_forecv ;
   void (*d_processinput)(char * , int  ) ;
   char *d_processinputdata ;
   int d_vpxmin ;
   int d_vpxmax ;
   struct win *d_fore ;
   struct win *d_other ;
   int d_nonblock ;
   char d_termname[21] ;
   char *d_tentry ;
   char d_tcinited ;
   int d_width ;
   int d_height ;
   int d_defwidth ;
   int d_defheight ;
   int d_top ;
   int d_bot ;
   int d_x ;
   int d_y ;
   struct mchar d_rend ;
   int d_col16change ;
   char d_atyp ;
   int d_mbcs ;
   int d_encoding ;
   int d_decodestate ;
   int d_realfont ;
   int d_insert ;
   int d_keypad ;
   int d_cursorkeys ;
   int d_revvid ;
   int d_curvis ;
   int d_has_hstatus ;
   int d_hstatus ;
   int d_lp_missing ;
   int d_mouse ;
   struct mchar d_lpchar ;
   struct timeval d_status_time ;
   int d_status ;
   char d_status_bell ;
   int d_status_len ;
   char *d_status_lastmsg ;
   int d_status_buflen ;
   int d_status_lastx ;
   int d_status_lasty ;
   int d_status_obuflen ;
   int d_status_obuffree ;
   struct event d_statusev ;
   struct event d_hstatusev ;
   int d_kaablamm ;
   struct action *d_ESCseen ;
   int d_userpid ;
   char d_usertty[4096] ;
   int d_userfd ;
   struct event d_readev ;
   struct event d_writeev ;
   struct event d_blockedev ;
   struct mode d_OldMode ;
   struct mode d_NewMode ;
   int d_flow ;
   int d_intrc ;
   char *d_obuf ;
   int d_obuflen ;
   int d_obufmax ;
   int d_obuflenmax ;
   char *d_obufp ;
   int d_obuffree ;
   int d_auto_nuke ;
   int d_nseqs ;
   int d_aseqs ;
   unsigned char *d_kmaps ;
   unsigned char *d_seqp ;
   int d_seql ;
   unsigned char *d_seqh ;
   struct event d_mapev ;
   int d_dontmap ;
   int d_mapdefault ;
   union tcu d_tcs[196] ;
   char *d_attrtab[6] ;
   char d_attrtyp[6] ;
   int d_hascolor ;
   short d_dospeed ;
   char d_c0_tab[256] ;
   char ***d_xtable ;
   int d_UPcost ;
   int d_DOcost ;
   int d_LEcost ;
   int d_NDcost ;
   int d_CRcost ;
   int d_IMcost ;
   int d_EIcost ;
   int d_NLcost ;
   int d_printfd ;
   slot_t d_loginslot ;
   struct utmp d_utmp_logintty ;
   int d_loginttymode ;
   int d_blocked ;
   int d_blocked_fuzz ;
   struct event d_idleev ;
   int d_blankerpid ;
   struct event d_blankerev ;
};
#line 54 "/home/pronto/abs/test-suite/screen-4.0.2/window.h"
struct pseudowin {
   int p_fdpat ;
   int p_pid ;
   int p_ptyfd ;
   struct event p_readev ;
   struct event p_writeev ;
   char p_cmd[256] ;
   char p_tty[256] ;
   char p_inbuf[4096] ;
   int p_inlen ;
};
#line 114 "/home/pronto/abs/test-suite/screen-4.0.2/window.h"
struct paster {
   char *pa_pastebuf ;
   char *pa_pasteptr ;
   int pa_pastelen ;
   struct layer *pa_pastelayer ;
   struct event pa_slowev ;
};
#line 126
struct logfile;
#line 126 "/home/pronto/abs/test-suite/screen-4.0.2/window.h"
struct win {
   struct win *w_next ;
   int w_type ;
   void *w_data ;
   struct layer w_layer ;
   struct layer *w_savelayer ;
   int w_blocked ;
   struct pseudowin *w_pwin ;
   struct display *w_pdisplay ;
   struct display *w_lastdisp ;
   int w_number ;
   struct event w_readev ;
   struct event w_writeev ;
   struct event w_silenceev ;
   int w_ptyfd ;
   char w_inbuf[4096] ;
   int w_inlen ;
   char w_outbuf[4096] ;
   int w_outlen ;
   int w_aflag ;
   char *w_title ;
   char *w_akachange ;
   char w_akabuf[256] ;
   int w_autoaka ;
   int w_intermediate ;
   int w_args[64] ;
   int w_NumArgs ;
   int w_wlock ;
   struct acluser *w_wlockuser ;
   AclBits w_userbits[3] ;
   AclBits w_lio_notify ;
   AclBits w_mon_notify ;
   enum state_t w_state ;
   enum string_t w_StringType ;
   struct mline *w_mlines ;
   struct mchar w_rend ;
   char w_FontL ;
   char w_FontR ;
   char w_FontE ;
   int w_Charset ;
   int w_CharsetR ;
   int w_charsets[4] ;
   int w_ss ;
   int w_saved ;
   int w_Saved_x ;
   int w_Saved_y ;
   struct mchar w_SavedRend ;
   int w_SavedCharset ;
   int w_SavedCharsetR ;
   int w_SavedCharsets[4] ;
   int w_top ;
   int w_bot ;
   int w_wrap ;
   int w_origin ;
   int w_insert ;
   int w_keypad ;
   int w_cursorkeys ;
   int w_revvid ;
   int w_curinv ;
   int w_curvvis ;
   int w_autolf ;
   char *w_hstatus ;
   int w_gr ;
   int w_c1 ;
   int w_bce ;
   int w_decodestate ;
   int w_mbcs ;
   char w_string[256] ;
   char *w_stringp ;
   char *w_tabs ;
   int w_bell ;
   int w_flow ;
   struct logfile *w_log ;
   int w_logsilence ;
   int w_monitor ;
   int w_silencewait ;
   int w_silence ;
   char w_vbwait ;
   char w_norefresh ;
   int w_mouse ;
   int w_slowpaste ;
   int w_histheight ;
   int w_histidx ;
   struct mline *w_hlines ;
   struct paster w_paster ;
   int w_pid ;
   char *w_cmdargs[64] ;
   char *w_dir ;
   char *w_term ;
   int w_lflag ;
   slot_t w_slot ;
   struct utmp w_savut ;
   char w_tty[256] ;
   int w_zauto ;
   struct display *w_zdisplay ;
   struct mline *w_alt_mlines ;
   int w_alt_width ;
   int w_alt_height ;
   int w_alt_histheight ;
   int w_alt_x ;
   int w_alt_y ;
   struct mline *w_alt_hlines ;
   int w_alt_histidx ;
};
#line 49 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
struct encoding {
   char *name ;
   char *charsets ;
   int deffont ;
   int usegr ;
   int noc1 ;
   char *fontlist ;
};
#line 277 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
struct recodetab {
   unsigned short (*tab)[2] ;
   int flags ;
};
#line 630 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
struct combchar {
   unsigned short c1 ;
   unsigned short c2 ;
   unsigned short next ;
   unsigned short prev ;
};
#line 872 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
struct __anonstruct_combining_50 {
   unsigned short first ;
   unsigned short last ;
};
#line 31 "/home/pronto/abs/test-suite/screen-4.0.2/nethack.c"
struct nlstrans {
   char *from ;
   char *to ;
};
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024UL / (8UL * sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 56 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 62 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 43 "/usr/lib/gcc/i486-linux-gnu/4.1.2/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 105 "/usr/lib/gcc/i486-linux-gnu/4.1.2/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 60 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 136 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 141 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 166 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 171 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 118 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 25 "/home/pronto/abs/test-suite/screen-4.0.2/logfile.h"
struct logfile {
   struct logfile *next ;
   FILE *fp ;
   char *name ;
   int opencount ;
   int writecount ;
   int flushcount ;
   struct stat *st ;
};
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 40 "/usr/include/shadow.h"
struct spwd {
   char *sp_namp ;
   char *sp_pwdp ;
   long sp_lstchg ;
   long sp_min ;
   long sp_max ;
   long sp_warn ;
   long sp_inact ;
   long sp_expire ;
   unsigned long sp_flag ;
};
#line 5 "/home/pronto/abs/test-suite/screen-4.0.2/comm.h"
struct comm {
   char *name ;
   int flags ;
   AclBits userbits[1] ;
};
#line 182 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 28 "/usr/include/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 88 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.h"
enum move_t {
    M_NONE = 0,
    M_UP = 1,
    M_CUP = 2,
    M_DO = 3,
    M_CDO = 4,
    M_LE = 5,
    M_CLE = 6,
    M_RI = 7,
    M_CRI = 8,
    M_RW = 9,
    M_CR = 10
} ;
#line 27 "/home/pronto/abs/test-suite/screen-4.0.2/window.h"
struct NewWindow {
   int StartAt ;
   char *aka ;
   char **args ;
   char *dir ;
   char *term ;
   int aflag ;
   int flowflag ;
   int lflag ;
   int histheight ;
   int monitor ;
   int wlock ;
   int silence ;
   int wrap ;
   int Lflag ;
   int slow ;
   int gr ;
   int c1 ;
   int bce ;
   int encoding ;
   char *hstatus ;
   char *charset ;
};
#line 284 "/home/pronto/abs/test-suite/screen-4.0.2/screen.h"
struct baud_values {
   int idx ;
   int bps ;
   int sym ;
};
#line 76 "/usr/include/time.h"
typedef __time_t time_t;
#line 9 "/home/pronto/abs/test-suite/screen-4.0.2/term.h"
struct term {
   char *tcname ;
   int type ;
};
#line 33 "/home/pronto/abs/test-suite/screen-4.0.2/display.h"
struct kmap_ext {
   char *str ;
   int fl ;
   struct action um ;
   struct action dm ;
   struct action mm ;
};
#line 201 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
struct kclass {
   struct kclass *next ;
   char *name ;
   struct action ktab[256] ;
};
#line 5476 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
struct inputsu {
   struct acluser **up ;
   char name[24] ;
   char pw1[130] ;
   char pw2[130] ;
};
#line 62 "/usr/include/sys/wait.h"
union wait;
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_terminated_42 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_stopped_43 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_42 __wait_terminated ;
   struct __anonstruct___wait_stopped_43 __wait_stopped ;
};
#line 177 "/home/pronto/abs/test-suite/screen-4.0.2/screen.h"
struct __anonstruct_create_46 {
   int lflag ;
   int aflag ;
   int flowflag ;
   int hheight ;
   int nargs ;
   char line[4096] ;
   char dir[4096] ;
   char screenterm[20] ;
};
#line 177 "/home/pronto/abs/test-suite/screen-4.0.2/screen.h"
struct __anonstruct_attach_47 {
   char auser[21] ;
   int apid ;
   int adaptflag ;
   int lines ;
   int columns ;
   char preselect[20] ;
   int esc ;
   int meta_esc ;
   char envterm[21] ;
   int encoding ;
};
#line 177 "/home/pronto/abs/test-suite/screen-4.0.2/screen.h"
struct __anonstruct_detach_48 {
   char duser[21] ;
   int dpid ;
};
#line 177 "/home/pronto/abs/test-suite/screen-4.0.2/screen.h"
struct __anonstruct_command_49 {
   char auser[21] ;
   int nargs ;
   char cmd[4096] ;
   int apid ;
   char preselect[20] ;
};
#line 177 "/home/pronto/abs/test-suite/screen-4.0.2/screen.h"
union __anonunion_m_45 {
   struct __anonstruct_create_46 create ;
   struct __anonstruct_attach_47 attach ;
   struct __anonstruct_detach_48 detach ;
   struct __anonstruct_command_49 command ;
   char message[8192] ;
};
#line 177 "/home/pronto/abs/test-suite/screen-4.0.2/screen.h"
struct msg {
   int protocol_revision ;
   int type ;
   char m_tty[4096] ;
   union __anonunion_m_45 m ;
};
#line 710 "/home/pronto/abs/test-suite/screen-4.0.2/attacher.c"
union __anonunion___u_50 {
   int __in ;
   int __i ;
};
#line 710 "/home/pronto/abs/test-suite/screen-4.0.2/attacher.c"
union __anonunion___u_51 {
   int __in ;
   int __i ;
};
#line 710 "/home/pronto/abs/test-suite/screen-4.0.2/attacher.c"
union __anonunion___u_52 {
   int __in ;
   int __i ;
};
#line 713 "/home/pronto/abs/test-suite/screen-4.0.2/attacher.c"
union __anonunion___u_53 {
   int __in ;
   int __i ;
};
#line 707 "/home/pronto/abs/test-suite/screen-4.0.2/attacher.c"
union __anonunion___u_54 {
   int __in ;
   int __i ;
};
#line 39 "/home/pronto/abs/test-suite/screen-4.0.2/input.c"
struct inpline {
   char buf[101] ;
   int len ;
   int pos ;
};
#line 49 "/home/pronto/abs/test-suite/screen-4.0.2/input.c"
struct inpdata {
   struct inpline inp ;
   int inpmaxlen ;
   char *inpstring ;
   int inpstringlen ;
   int inpmode ;
   void (*inpfinfunc)(char *buf , int len , char *priv ) ;
   char *priv ;
};
#line 112 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
struct helpdata {
   char *class ;
   struct action *ktabp ;
   int maxrow ;
   int grow ;
   int numcols ;
   int numrows ;
   int num_names ;
   int numskip ;
   int numpages ;
   int command_search ;
   int command_bindings ;
   int refgrow ;
   int refcommand_search ;
   int inter ;
   int mcom ;
   int mkey ;
   int nact[175] ;
};
#line 465 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
struct copydata {
   char *cps ;
   char *savedcps ;
   char *refcps ;
   char *refsavedcps ;
};
#line 675 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
struct displaysdata {
   int dummy_element_for_solaris ;
};
#line 846
struct wlistdata;
#line 859 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
struct wlistdata {
   int pos ;
   int ypos ;
   int npos ;
   int numwin ;
   int first ;
   int last ;
   int start ;
   int order ;
};
#line 1363 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
struct bindkeydata {
   char *title ;
   struct action *tab ;
   int pos ;
   int last ;
   int page ;
   int pages ;
};
#line 25 "/home/pronto/abs/test-suite/screen-4.0.2/mark.h"
struct markdata {
   struct win *md_window ;
   struct acluser *md_user ;
   int cx ;
   int cy ;
   int x1 ;
   int y1 ;
   int second ;
   int left_mar ;
   int right_mar ;
   int nonl ;
   int rep_cnt ;
   int append_mode ;
   int write_buffer ;
   int hist_offset ;
   char isstr[100] ;
   int isstrl ;
   char isistr[200] ;
   int isistrl ;
   int isdir ;
   int isstartpos ;
   int isstartdir ;
};
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 121 "/home/pronto/abs/test-suite/screen-4.0.2/socket.c"
struct sent {
   struct sent *next ;
   int mode ;
   char *name ;
};
#line 1249 "/home/pronto/abs/test-suite/screen-4.0.2/socket.c"
struct pwdata {
   int l ;
   char buf[21] ;
   struct msg m ;
};
#line 147 "/usr/include/bits/types.h"
typedef long __clock_t;
#line 28 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 28 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 38 "/usr/include/sys/select.h"
typedef __sigset_t sigset_t;
#line 33 "/usr/include/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 33 "/usr/include/bits/siginfo.h"
typedef union sigval sigval_t;
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__kill_9 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__timer_10 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__rt_11 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigchld_12 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigfault_13 {
   void *si_addr ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigpoll_14 {
   long si_band ;
   int si_fd ;
};
#line 51 "/usr/include/bits/siginfo.h"
union __anonunion__sifields_8 {
   int _pad[128UL / sizeof(int ) - 3UL] ;
   struct __anonstruct__kill_9 _kill ;
   struct __anonstruct__timer_10 _timer ;
   struct __anonstruct__rt_11 _rt ;
   struct __anonstruct__sigchld_12 _sigchld ;
   struct __anonstruct__sigfault_13 _sigfault ;
   struct __anonstruct__sigpoll_14 _sigpoll ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_8 _sifields ;
};
#line 51 "/usr/include/bits/siginfo.h"
typedef struct siginfo siginfo_t;
#line 25 "/usr/include/bits/sigaction.h"
union __anonunion___sigaction_handler_26 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 25 "/usr/include/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_26 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 37 "/usr/include/nl_types.h"
typedef int nl_item;
#line 131 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 133 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
struct backtick;
#line 1565 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
union __anonunion___u_53___0 {
   int __in ;
   int __i ;
};
#line 1572 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
union __anonunion___u_54___0 {
   int __in ;
   int __i ;
};
#line 1561 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
union __anonunion___u_55 {
   int __in ;
   int __i ;
};
#line 2070 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
struct backtick {
   struct backtick *next ;
   int num ;
   int tick ;
   int lifespan ;
   time_t bestbefore ;
   char result[256] ;
   char **cmdv ;
   struct event ev ;
   char *buf ;
   int bufi ;
};
#line 30 "/usr/include/sys/sysmacros.h"
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_major(unsigned long long __dev ) ;
#line 33
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_minor(unsigned long long __dev ) ;
#line 36
__inline extern  __attribute__((__nothrow__)) unsigned long long gnu_dev_makedev(unsigned int __major ,
                                                                                 unsigned int __minor ) ;
#line 41
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_major(unsigned long long __dev ) ;
#line 41 "/usr/include/sys/sysmacros.h"
__inline extern unsigned int gnu_dev_major(unsigned long long __dev ) 
{ 


  {
#line 44
  return ((unsigned int )(((__dev >> 8) & 4095ULL) | (unsigned long long )((unsigned int )(__dev >> 32) & 4294963200U)));
}
}
#line 47
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_minor(unsigned long long __dev ) ;
#line 47 "/usr/include/sys/sysmacros.h"
__inline extern unsigned int gnu_dev_minor(unsigned long long __dev ) 
{ 


  {
#line 50
  return ((unsigned int )((__dev & 255ULL) | (unsigned long long )((unsigned int )(__dev >> 12) & 4294967040U)));
}
}
#line 53
__inline extern  __attribute__((__nothrow__)) unsigned long long gnu_dev_makedev(unsigned int __major ,
                                                                                 unsigned int __minor ) ;
#line 53 "/usr/include/sys/sysmacros.h"
__inline extern unsigned long long gnu_dev_makedev(unsigned int __major , unsigned int __minor ) 
{ 


  {
#line 56
  return (((unsigned long long )((__minor & 255U) | ((__major & 4095U) << 8)) | ((unsigned long long )(__minor & 4294967040U) << 12)) | ((unsigned long long )(__major & 4294963200U) << 32));
}
}
#line 444 "/usr/include/libio.h"
extern  __attribute__((__nothrow__)) int _IO_getc(_IO_FILE *__fp ) ;
#line 206 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 329
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 584 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 595
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size )  __attribute__((__malloc__)) ;
#line 597
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 242 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 296
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1))) bzero)(void *__s ,
                                                                                   size_t __n ) ;
#line 58 "/home/pronto/abs/test-suite/screen-4.0.2/extern.h"
void SetCharsets(struct win *p , char *s ) ;
#line 71
FILE *secfopen(char *name , char *mode ) ;
#line 286
void Resize_obuf(void) ;
#line 445
void ExitOverlayPage(void) ;
#line 466
void InitBuiltinTabs(void) ;
#line 467
struct mchar *recode_mchar(struct mchar *mc , int from , int to ) ;
#line 468
struct mline *recode_mline(struct mline *ml , int w , int from , int to ) ;
#line 469
int FromUtf8(int c , int *utf8charp ) ;
#line 470
void AddUtf8(int c ) ;
#line 471
int ToUtf8(char *p , int c ) ;
#line 472
int ToUtf8_comb(char *p , int c ) ;
#line 473
int utf8_isdouble(int c ) ;
#line 474
int utf8_iscomb(int c ) ;
#line 475
void utf8_handle_comb(int c , struct mchar *mc ) ;
#line 476
int ContainsSpecialDeffont(struct mline *ml , int xs , int xe , int encoding ) ;
#line 477
int LoadFontTranslation(int font , char *file ) ;
#line 478
void LoadFontTranslationsForEncoding(int encoding ) ;
#line 480
void WinSwitchEncoding(struct win *p , int encoding ) ;
#line 481
int FindEncoding(char *name ) ;
#line 482
char *EncodingName(int encoding ) ;
#line 483
int EncodingDefFont(int encoding ) ;
#line 484
void ResetEncoding(struct win *p ) ;
#line 485
int CanEncodeFont(int encoding , int f ) ;
#line 486
int DecodeChar(int c , int encoding , int *statep ) ;
#line 487
int RecodeBuf(unsigned char *fbuf , int flen , int fenc , int tenc , unsigned char *tbuf ) ;
#line 489
int PrepareEncodedChar(int c ) ;
#line 492
int EncodeChar(char *bp , int c , int encoding , int *fontp ) ;
#line 32 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
unsigned char *null ;
#line 33
struct display *display ;
#line 33
struct display *displays ;
#line 34
struct layer *flayer ;
#line 36
char *screenencodings ;
#line 38
static int encmatch(char *s1 , char *s2 ) ;
#line 40
static int recode_char(int c , int to_utf , int font ) ;
#line 41
static int recode_char_to_encoding(int c , int encoding ) ;
#line 42
static void comb_tofront(int root , int i ) ;
#line 44
static int recode_char_dw(int c , int *c2p , int to_utf , int font ) ;
#line 45
static int recode_char_dw_to_encoding(int c , int *c2p , int encoding ) ;
#line 62 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
struct encoding encodings[21]  = 
#line 62
  {      {(char *)"C", (char *)0, 0, 0, 0, (char *)0}, 
        {(char *)"eucJP", (char *)"B\002I\00401", 0, 1, 0, (char *)"\002\004I"}, 
        {(char *)"SJIS", (char *)"BIBB01", 0, 1, 1, (char *)"\002I"}, 
        {(char *)"eucKR", (char *)"B\003BB01", 0, 1, 0, (char *)"\003"}, 
        {(char *)"eucCN", (char *)"B\001BB01", 0, 1, 0, (char *)"\001"}, 
        {(char *)"Big5", (char *)"B\030BB01", 0, 1, 0, (char *)"\030"}, 
        {(char *)"KOI8-R", (char *)0, 161, 0, 1, (char *)0}, 
        {(char *)"CP1251", (char *)0, 191, 0, 1, (char *)0}, 
        {(char *)"UTF-8", (char *)0, -1, 0, 0, (char *)0}, 
        {(char *)"ISO8859-2", (char *)0, 194, 0, 0, (char *)0}, 
        {(char *)"ISO8859-3", (char *)0, 195, 0, 0, (char *)0}, 
        {(char *)"ISO8859-4", (char *)0, 196, 0, 0, (char *)0}, 
        {(char *)"ISO8859-5", (char *)0, 204, 0, 0, (char *)0}, 
        {(char *)"ISO8859-6", (char *)0, 199, 0, 0, (char *)0}, 
        {(char *)"ISO8859-7", (char *)0, 198, 0, 0, (char *)0}, 
        {(char *)"ISO8859-8", (char *)0, 200, 0, 0, (char *)0}, 
        {(char *)"ISO8859-9", (char *)0, 205, 0, 0, (char *)0}, 
        {(char *)"ISO8859-10", (char *)0, 214, 0, 0, (char *)0}, 
        {(char *)"ISO8859-15", (char *)0, 226, 0, 0, (char *)0}, 
        {(char *)"jis", (char *)0, 0, 0, 0, (char *)"\002\004I"}, 
        {(char *)"GBK", (char *)"B\031BB01", 226, 1, 1, (char *)"\031"}};
#line 88 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
static unsigned short builtin_tabs[171][2]  = 
#line 88
  { {        (unsigned short)48,        (unsigned short)0}, 
   {        (unsigned short)95,        (unsigned short)9646}, 
   {        (unsigned short)96,        (unsigned short)9670}, 
   {        (unsigned short)97,        (unsigned short)9618}, 
   {        (unsigned short)98,        (unsigned short)9225}, 
   {        (unsigned short)99,        (unsigned short)9228}, 
   {        (unsigned short)100,        (unsigned short)9229}, 
   {        (unsigned short)101,        (unsigned short)9226}, 
   {        (unsigned short)102,        (unsigned short)176}, 
   {        (unsigned short)103,        (unsigned short)177}, 
   {        (unsigned short)104,        (unsigned short)9252}, 
   {        (unsigned short)105,        (unsigned short)9227}, 
   {        (unsigned short)106,        (unsigned short)9496}, 
   {        (unsigned short)107,        (unsigned short)9488}, 
   {        (unsigned short)108,        (unsigned short)9484}, 
   {        (unsigned short)109,        (unsigned short)9492}, 
   {        (unsigned short)110,        (unsigned short)9532}, 
   {        (unsigned short)111,        (unsigned short)9146}, 
   {        (unsigned short)112,        (unsigned short)9147}, 
   {        (unsigned short)113,        (unsigned short)9472}, 
   {        (unsigned short)114,        (unsigned short)9148}, 
   {        (unsigned short)115,        (unsigned short)9149}, 
   {        (unsigned short)116,        (unsigned short)9500}, 
   {        (unsigned short)117,        (unsigned short)9508}, 
   {        (unsigned short)118,        (unsigned short)9524}, 
   {        (unsigned short)119,        (unsigned short)9516}, 
   {        (unsigned short)120,        (unsigned short)9474}, 
   {        (unsigned short)121,        (unsigned short)8804}, 
   {        (unsigned short)122,        (unsigned short)8805}, 
   {        (unsigned short)123,        (unsigned short)960}, 
   {        (unsigned short)124,        (unsigned short)8800}, 
   {        (unsigned short)125,        (unsigned short)163}, 
   {        (unsigned short)126,        (unsigned short)183}, 
   {        (unsigned short)0,        (unsigned short)0}, 
   {        (unsigned short)52,        (unsigned short)0}, 
   {        (unsigned short)35,        (unsigned short)163}, 
   {        (unsigned short)64,        (unsigned short)190}, 
   {        (unsigned short)91,        (unsigned short)255}, 
   {        (unsigned short)92,        (unsigned short)189}, 
   {        (unsigned short)93,        (unsigned short)124}, 
   {        (unsigned short)123,        (unsigned short)168}, 
   {        (unsigned short)124,        (unsigned short)102}, 
   {        (unsigned short)125,        (unsigned short)188}, 
   {        (unsigned short)126,        (unsigned short)180}, 
   {        (unsigned short)0,        (unsigned short)0}, 
   {        (unsigned short)53,        (unsigned short)0}, 
   {        (unsigned short)91,        (unsigned short)196}, 
   {        (unsigned short)92,        (unsigned short)214}, 
   {        (unsigned short)93,        (unsigned short)197}, 
   {        (unsigned short)94,        (unsigned short)220}, 
   {        (unsigned short)96,        (unsigned short)233}, 
   {        (unsigned short)123,        (unsigned short)228}, 
   {        (unsigned short)124,        (unsigned short)246}, 
   {        (unsigned short)125,        (unsigned short)229}, 
   {        (unsigned short)126,        (unsigned short)252}, 
   {        (unsigned short)0,        (unsigned short)0}, 
   {        (unsigned short)54,        (unsigned short)0}, 
   {        (unsigned short)64,        (unsigned short)196}, 
   {        (unsigned short)91,        (unsigned short)198}, 
   {        (unsigned short)92,        (unsigned short)216}, 
   {        (unsigned short)93,        (unsigned short)197}, 
   {        (unsigned short)94,        (unsigned short)220}, 
   {        (unsigned short)96,        (unsigned short)228}, 
   {        (unsigned short)123,        (unsigned short)230}, 
   {        (unsigned short)124,        (unsigned short)248}, 
   {        (unsigned short)125,        (unsigned short)229}, 
   {        (unsigned short)126,        (unsigned short)252}, 
   {        (unsigned short)0,        (unsigned short)0}, 
   {        (unsigned short)55,        (unsigned short)0}, 
   {        (unsigned short)64,        (unsigned short)201}, 
   {        (unsigned short)91,        (unsigned short)196}, 
   {        (unsigned short)92,        (unsigned short)214}, 
   {        (unsigned short)93,        (unsigned short)197}, 
   {        (unsigned short)94,        (unsigned short)220}, 
   {        (unsigned short)96,        (unsigned short)233}, 
   {        (unsigned short)123,        (unsigned short)228}, 
   {        (unsigned short)124,        (unsigned short)246}, 
   {        (unsigned short)125,        (unsigned short)229}, 
   {        (unsigned short)126,        (unsigned short)252}, 
   {        (unsigned short)0,        (unsigned short)0}, 
   {        (unsigned short)61,        (unsigned short)0}, 
   {        (unsigned short)35,        (unsigned short)249}, 
   {        (unsigned short)64,        (unsigned short)224}, 
   {        (unsigned short)91,        (unsigned short)233}, 
   {        (unsigned short)92,        (unsigned short)231}, 
   {        (unsigned short)93,        (unsigned short)234}, 
   {        (unsigned short)94,        (unsigned short)238}, 
   {        (unsigned short)95,        (unsigned short)232}, 
   {        (unsigned short)96,        (unsigned short)244}, 
   {        (unsigned short)123,        (unsigned short)228}, 
   {        (unsigned short)124,        (unsigned short)246}, 
   {        (unsigned short)125,        (unsigned short)252}, 
   {        (unsigned short)126,        (unsigned short)251}, 
   {        (unsigned short)0,        (unsigned short)0}, 
   {        (unsigned short)65,        (unsigned short)0}, 
   {        (unsigned short)35,        (unsigned short)163}, 
   {        (unsigned short)0,        (unsigned short)0}, 
   {        (unsigned short)75,        (unsigned short)0}, 
   {        (unsigned short)64,        (unsigned short)167}, 
   {        (unsigned short)91,        (unsigned short)196}, 
   {        (unsigned short)92,        (unsigned short)214}, 
   {        (unsigned short)93,        (unsigned short)220}, 
   {        (unsigned short)123,        (unsigned short)228}, 
   {        (unsigned short)124,        (unsigned short)246}, 
   {        (unsigned short)125,        (unsigned short)252}, 
   {        (unsigned short)126,        (unsigned short)223}, 
   {        (unsigned short)0,        (unsigned short)0}, 
   {        (unsigned short)81,        (unsigned short)0}, 
   {        (unsigned short)64,        (unsigned short)224}, 
   {        (unsigned short)91,        (unsigned short)226}, 
   {        (unsigned short)92,        (unsigned short)231}, 
   {        (unsigned short)93,        (unsigned short)234}, 
   {        (unsigned short)94,        (unsigned short)238}, 
   {        (unsigned short)96,        (unsigned short)244}, 
   {        (unsigned short)123,        (unsigned short)233}, 
   {        (unsigned short)124,        (unsigned short)249}, 
   {        (unsigned short)125,        (unsigned short)232}, 
   {        (unsigned short)126,        (unsigned short)251}, 
   {        (unsigned short)0,        (unsigned short)0}, 
   {        (unsigned short)82,        (unsigned short)0}, 
   {        (unsigned short)35,        (unsigned short)163}, 
   {        (unsigned short)64,        (unsigned short)224}, 
   {        (unsigned short)91,        (unsigned short)176}, 
   {        (unsigned short)92,        (unsigned short)231}, 
   {        (unsigned short)93,        (unsigned short)167}, 
   {        (unsigned short)123,        (unsigned short)233}, 
   {        (unsigned short)124,        (unsigned short)249}, 
   {        (unsigned short)125,        (unsigned short)232}, 
   {        (unsigned short)126,        (unsigned short)168}, 
   {        (unsigned short)0,        (unsigned short)0}, 
   {        (unsigned short)89,        (unsigned short)0}, 
   {        (unsigned short)35,        (unsigned short)163}, 
   {        (unsigned short)64,        (unsigned short)167}, 
   {        (unsigned short)91,        (unsigned short)176}, 
   {        (unsigned short)92,        (unsigned short)231}, 
   {        (unsigned short)93,        (unsigned short)233}, 
   {        (unsigned short)96,        (unsigned short)249}, 
   {        (unsigned short)123,        (unsigned short)224}, 
   {        (unsigned short)124,        (unsigned short)242}, 
   {        (unsigned short)125,        (unsigned short)232}, 
   {        (unsigned short)126,        (unsigned short)236}, 
   {        (unsigned short)0,        (unsigned short)0}, 
   {        (unsigned short)90,        (unsigned short)0}, 
   {        (unsigned short)35,        (unsigned short)163}, 
   {        (unsigned short)64,        (unsigned short)167}, 
   {        (unsigned short)91,        (unsigned short)161}, 
   {        (unsigned short)92,        (unsigned short)209}, 
   {        (unsigned short)93,        (unsigned short)191}, 
   {        (unsigned short)123,        (unsigned short)176}, 
   {        (unsigned short)124,        (unsigned short)241}, 
   {        (unsigned short)125,        (unsigned short)231}, 
   {        (unsigned short)0,        (unsigned short)0}, 
   {        (unsigned short)226,        (unsigned short)0}, 
   {        (unsigned short)164,        (unsigned short)8364}, 
   {        (unsigned short)166,        (unsigned short)352}, 
   {        (unsigned short)168,        (unsigned short)353}, 
   {        (unsigned short)180,        (unsigned short)381}, 
   {        (unsigned short)184,        (unsigned short)382}, 
   {        (unsigned short)188,        (unsigned short)338}, 
   {        (unsigned short)189,        (unsigned short)339}, 
   {        (unsigned short)190,        (unsigned short)376}, 
   {        (unsigned short)0,        (unsigned short)0}, 
   {        (unsigned short)74,        (unsigned short)0}, 
   {        (unsigned short)92,        (unsigned short)165}, 
   {        (unsigned short)126,        (unsigned short)8254}, 
   {        (unsigned short)0,        (unsigned short)0}, 
   {        (unsigned short)73,        (unsigned short)0}, 
   {        (unsigned short)33,        (unsigned short)65377}, 
   {        (unsigned short)32863,        (unsigned short)65439}, 
   {        (unsigned short)0,        (unsigned short)0}, 
   {        (unsigned short)0,        (unsigned short)0}};
#line 287 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
static struct recodetab recodetabs[256]  ;
#line 289 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
void InitBuiltinTabs(void) 
{ 
  unsigned short (*p)[2] ;

  {
#line 293
  p = builtin_tabs;
  {
#line 293
  while (1) {
    while_continue: /* CIL Label */ ;
#line 293
    if (! (*p)[0]) {
#line 293
      goto while_break;
    }
#line 295
    recodetabs[(*p)[0]].flags = 2;
#line 296
    recodetabs[(*p)[0]].tab = p + 1;
#line 297
    p ++;
    {
#line 298
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 298
      if (! (*p)[0]) {
#line 298
        goto while_break___0;
      }
#line 299
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 293
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  return;
}
}
#line 303 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
static int recode_char(int c , int to_utf , int font ) 
{ 
  int f ;
  unsigned short (*p)[2] ;
  int tmp ;
  int tmp___0 ;

  {
#line 310
  if (to_utf) {
#line 312
    if (c < 256) {
#line 313
      return (c);
    }
#line 314
    f = (c >> 8) & 255;
#line 315
    c &= 255;
    {
#line 319
    if (f == 67) {
#line 319
      goto case_67;
    }
#line 322
    if (f == 69) {
#line 322
      goto case_69;
    }
#line 325
    if (f == 72) {
#line 325
      goto case_72;
    }
#line 328
    goto switch_default;
    case_67: /* CIL Label */ 
#line 320
    f ^= 118;
#line 321
    goto switch_break;
    case_69: /* CIL Label */ 
#line 323
    f ^= 115;
#line 324
    goto switch_break;
    case_72: /* CIL Label */ 
#line 326
    f ^= 127;
#line 327
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 329
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 331
    p = recodetabs[f].tab;
#line 332
    if ((unsigned long )p == (unsigned long )((unsigned short (*)[2])0)) {
#line 332
      if (recodetabs[f].flags == 0) {
        {
#line 334
        LoadFontTranslation(f, (char *)0);
#line 335
        p = recodetabs[f].tab;
        }
      }
    }
#line 337
    if (p) {
      {
#line 338
      while (1) {
        while_continue: /* CIL Label */ ;
#line 338
        if (! (*p)[0]) {
#line 338
          goto while_break;
        }
#line 340
        if ((int )(*(p + 0))[0] & 32768) {
#line 340
          if (c <= ((int )(*(p + 0))[0] & 32767)) {
#line 340
            if (c >= (int )(*(p + -1))[0]) {
#line 341
              return ((c - (int )(*(p + -1))[0]) + (int )(*(p + -1))[1]);
            }
          }
        }
#line 342
        if ((int )(*p)[0] == c) {
#line 343
          return ((int )(*p)[1]);
        }
#line 338
        p ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 345
    return (c & 255);
  }
#line 347
  if (font == -1) {
#line 349
    if (c < 256) {
#line 350
      return (c);
    }
#line 351
    font = 32;
    {
#line 351
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 351
      if (! (font < 128)) {
#line 351
        goto while_break___0;
      }
#line 353
      p = recodetabs[font].tab;
#line 354
      if (p) {
        {
#line 355
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 355
          if (! (*p)[1]) {
#line 355
            goto while_break___1;
          }
#line 357
          if ((int )(*(p + 0))[0] & 32768) {
#line 357
            if (c <= (int )(*(p + 0))[1]) {
#line 357
              if (c >= (int )(*(p + -1))[1]) {
#line 358
                return (((c - (int )(*(p + -1))[1]) + (int )(*(p + -1))[0]) | (font << 8));
              }
            }
          }
#line 359
          if ((int )(*p)[1] == c) {
#line 360
            return ((int )(*p)[0] | (font << 8));
          }
#line 355
          p ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 351
      font ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 363
    return ('?');
  }
#line 365
  if (c < 128) {
#line 365
    if ((font & 128) != 0) {
#line 366
      return (c);
    }
  }
#line 367
  if (font >= 32) {
#line 369
    p = recodetabs[font].tab;
#line 370
    if ((unsigned long )p == (unsigned long )((unsigned short (*)[2])0)) {
#line 370
      if (recodetabs[font].flags == 0) {
        {
#line 372
        LoadFontTranslation(font, (char *)0);
#line 373
        p = recodetabs[font].tab;
        }
      }
    }
#line 375
    if (p) {
      {
#line 376
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 376
        if (! (*p)[1]) {
#line 376
          goto while_break___2;
        }
#line 378
        if ((int )(*(p + 0))[0] & 32768) {
#line 378
          if (c <= (int )(*(p + 0))[1]) {
#line 378
            if (c >= (int )(*(p + -1))[1]) {
#line 379
              if (font & 128) {
#line 379
                tmp = 0;
              } else {
#line 379
                tmp = font << 8;
              }
#line 379
              return (((c - (int )(*(p + -1))[1]) + (int )(*(p + -1))[0]) | tmp);
            }
          }
        }
#line 380
        if ((int )(*p)[1] == c) {
#line 381
          if (font & 128) {
#line 381
            tmp___0 = 0;
          } else {
#line 381
            tmp___0 = font << 8;
          }
#line 381
          return ((int )(*p)[0] | tmp___0);
        }
#line 376
        p ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
#line 384
  return (-1);
}
}
#line 389 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
static int recode_char_dw(int c , int *c2p , int to_utf , int font ) 
{ 
  int f ;
  unsigned short (*p)[2] ;
  int tmp ;

  {
#line 396
  if (to_utf) {
#line 398
    f = (c >> 8) & 255;
#line 399
    c = ((c & 255) << 8) | (*c2p & 255);
#line 400
    *c2p = 65535;
#line 401
    p = recodetabs[f].tab;
#line 402
    if ((unsigned long )p == (unsigned long )((unsigned short (*)[2])0)) {
#line 402
      if (recodetabs[f].flags == 0) {
        {
#line 404
        LoadFontTranslation(f, (char *)0);
#line 405
        p = recodetabs[f].tab;
        }
      }
    }
#line 407
    if (p) {
      {
#line 408
      while (1) {
        while_continue: /* CIL Label */ ;
#line 408
        if (! (*p)[0]) {
#line 408
          goto while_break;
        }
#line 409
        if ((int )(*p)[0] == c) {
          {
#line 412
          tmp = utf8_isdouble((int )(*p)[1]);
          }
#line 412
          if (! tmp) {
#line 413
            *c2p = ' ';
          }
#line 415
          return ((int )(*p)[1]);
        }
#line 408
        p ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 417
    return (65311);
  }
#line 419
  if (font == -1) {
#line 421
    font = 0;
    {
#line 421
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 421
      if (! (font < 24)) {
#line 421
        goto while_break___0;
      }
#line 423
      p = recodetabs[font].tab;
#line 424
      if (p) {
        {
#line 425
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 425
          if (! (*p)[1]) {
#line 425
            goto while_break___1;
          }
#line 426
          if ((int )(*p)[1] == c) {
#line 428
            *c2p = (((int )(*p)[0] & 255) | (font << 8)) | 32768;
#line 429
            return (((int )(*p)[0] >> 8) | (font << 8));
          }
#line 425
          p ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 421
      font ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 432
    *c2p = '?';
#line 433
    return ('?');
  }
#line 435
  if (font < 32) {
#line 437
    p = recodetabs[font].tab;
#line 438
    if ((unsigned long )p == (unsigned long )((unsigned short (*)[2])0)) {
#line 438
      if (recodetabs[font].flags == 0) {
        {
#line 440
        LoadFontTranslation(font, (char *)0);
#line 441
        p = recodetabs[font].tab;
        }
      }
    }
#line 443
    if (p) {
      {
#line 444
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 444
        if (! (*p)[1]) {
#line 444
          goto while_break___2;
        }
#line 445
        if ((int )(*p)[1] == c) {
#line 447
          *c2p = (((int )(*p)[0] & 255) | (font << 8)) | 32768;
#line 448
          return (((int )(*p)[0] >> 8) | (font << 8));
        }
#line 444
        p ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
#line 451
  return (-1);
}
}
#line 455 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
static int recode_char_to_encoding(int c , int encoding ) 
{ 
  char *fp ;
  int x ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 462
  if (encoding == 8) {
    {
#line 463
    tmp = recode_char(c, 1, -1);
    }
#line 463
    return (tmp);
  }
#line 464
  fp = encodings[encoding].fontlist;
#line 464
  if ((unsigned long )fp != (unsigned long )((char *)0)) {
    {
#line 465
    while (1) {
      while_continue: /* CIL Label */ ;
#line 465
      if (! *fp) {
#line 465
        goto while_break;
      }
      {
#line 466
      tmp___0 = fp;
#line 466
      fp ++;
#line 466
      x = recode_char(c, 0, (int )((unsigned char )*tmp___0));
      }
#line 466
      if (x != -1) {
#line 467
        return (x);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 468
  if (encodings[encoding].deffont) {
    {
#line 469
    x = recode_char(c, 0, encodings[encoding].deffont);
    }
#line 469
    if (x != -1) {
#line 470
      return (x);
    }
  }
  {
#line 471
  tmp___1 = recode_char(c, 0, -1);
  }
#line 471
  return (tmp___1);
}
}
#line 475 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
static int recode_char_dw_to_encoding(int c , int *c2p , int encoding ) 
{ 
  char *fp ;
  int x ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 482
  if (encoding == 8) {
    {
#line 483
    tmp = recode_char_dw(c, c2p, 1, -1);
    }
#line 483
    return (tmp);
  }
#line 484
  fp = encodings[encoding].fontlist;
#line 484
  if ((unsigned long )fp != (unsigned long )((char *)0)) {
    {
#line 485
    while (1) {
      while_continue: /* CIL Label */ ;
#line 485
      if (! *fp) {
#line 485
        goto while_break;
      }
      {
#line 486
      tmp___0 = fp;
#line 486
      fp ++;
#line 486
      x = recode_char_dw(c, c2p, 0, (int )((unsigned char )*tmp___0));
      }
#line 486
      if (x != -1) {
#line 487
        return (x);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 488
  if (encodings[encoding].deffont) {
    {
#line 489
    x = recode_char_dw(c, c2p, 0, encodings[encoding].deffont);
    }
#line 489
    if (x != -1) {
#line 490
      return (x);
    }
  }
  {
#line 491
  tmp___1 = recode_char_dw(c, c2p, 0, -1);
  }
#line 491
  return (tmp___1);
}
}
#line 501 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
static struct mchar rmc  ;
#line 496 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
struct mchar *recode_mchar(struct mchar *mc , int from , int to ) 
{ 
  int c ;
  int c2 ;

  {
  {
#line 504
  while (1) {
    while_continue: /* CIL Label */ ;
#line 504
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 505
  if (from == to) {
#line 506
    return (mc);
  } else
#line 505
  if (from != 8) {
#line 505
    if (to != 8) {
#line 506
      return (mc);
    }
  }
#line 507
  rmc = *mc;
#line 508
  if ((int )rmc.font == 0) {
#line 508
    if (from != 8) {
#line 509
      rmc.font = (unsigned char )encodings[from].deffont;
    }
  }
#line 510
  if ((int )rmc.font == 0) {
#line 511
    return (mc);
  }
#line 512
  c = (int )rmc.image | ((int )rmc.font << 8);
#line 514
  if (rmc.mbcs) {
    {
#line 516
    c2 = (int )rmc.mbcs;
#line 517
    c = recode_char_dw_to_encoding(c, & c2, to);
#line 518
    rmc.mbcs = (unsigned char )c2;
    }
  } else {
    {
#line 522
    c = recode_char_to_encoding(c, to);
    }
  }
#line 523
  rmc.image = (unsigned char )(c & 255);
#line 524
  rmc.font = (unsigned char )((c >> 8) & 255);
#line 525
  return (& rmc);
}
}
#line 534 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
static int maxlen  ;
#line 535 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
static int last  ;
#line 536 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
static struct mline rml[2]  ;
#line 536 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
static struct mline *rl  ;
#line 528 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
struct mline *recode_mline(struct mline *ml , int w , int from , int to ) 
{ 
  int i ;
  int c ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int c2 ;
  int tmp___3 ;

  {
#line 539
  if (from == to) {
#line 540
    return (ml);
  } else
#line 539
  if (from != 8) {
#line 539
    if (to != 8) {
#line 540
      return (ml);
    } else {
#line 539
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 539
  if (w == 0) {
#line 540
    return (ml);
  }
#line 541
  if ((unsigned long )ml->font == (unsigned long )null) {
#line 541
    if (encodings[from].deffont == 0) {
#line 542
      return (ml);
    }
  }
#line 543
  if (w > maxlen) {
#line 545
    i = 0;
    {
#line 545
    while (1) {
      while_continue: /* CIL Label */ ;
#line 545
      if (! (i < 2)) {
#line 545
        goto while_break;
      }
#line 547
      if ((unsigned long )rml[i].image == (unsigned long )((unsigned char *)0)) {
        {
#line 548
        tmp = malloc((size_t )w);
#line 548
        rml[i].image = (unsigned char *)tmp;
        }
      } else {
        {
#line 550
        tmp___0 = realloc((void *)rml[i].image, (size_t )w);
#line 550
        rml[i].image = (unsigned char *)tmp___0;
        }
      }
#line 551
      if ((unsigned long )rml[i].font == (unsigned long )((unsigned char *)0)) {
        {
#line 552
        tmp___1 = malloc((size_t )w);
#line 552
        rml[i].font = (unsigned char *)tmp___1;
        }
      } else {
        {
#line 554
        tmp___2 = realloc((void *)rml[i].font, (size_t )w);
#line 554
        rml[i].font = (unsigned char *)tmp___2;
        }
      }
#line 555
      if ((unsigned long )rml[i].image == (unsigned long )((unsigned char *)0)) {
#line 557
        maxlen = 0;
#line 558
        return (ml);
      } else
#line 555
      if ((unsigned long )rml[i].font == (unsigned long )((unsigned char *)0)) {
#line 557
        maxlen = 0;
#line 558
        return (ml);
      }
#line 545
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 561
    maxlen = w;
  }
  {
#line 564
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 564
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 565
  i = 0;
  {
#line 565
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 565
    if (! (i < w)) {
#line 565
      goto while_break___1;
    }
    {
#line 566
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 566
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 565
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 567
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 567
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 568
  i = 0;
  {
#line 568
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 568
    if (! (i < w)) {
#line 568
      goto while_break___4;
    }
    {
#line 569
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 569
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 568
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 570
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 570
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 571
  i = 0;
  {
#line 571
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 571
    if (! (i < w)) {
#line 571
      goto while_break___7;
    }
    {
#line 572
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 572
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 571
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 573
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 573
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 574
  i = 0;
  {
#line 574
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 574
    if (! (i < w)) {
#line 574
      goto while_break___10;
    }
    {
#line 575
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 575
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 574
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 576
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 576
    goto while_break___12;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 578
  rl = rml + last;
#line 579
  rl->attr = ml->attr;
#line 581
  rl->color = ml->color;
#line 586
  i = 0;
  {
#line 586
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 586
    if (! (i < w)) {
#line 586
      goto while_break___13;
    }
#line 588
    c = (int )*(ml->image + i) | ((int )*(ml->font + i) << 8);
#line 589
    if (from != 8) {
#line 589
      if (c < 256) {
#line 590
        c |= encodings[from].deffont << 8;
      }
    }
#line 592
    if (from != 8) {
#line 592
      if ((c & 7936) != 0) {
#line 592
        if ((c & 57344) == 0) {
#line 592
          goto _L___0;
        } else {
#line 592
          goto _L___2;
        }
      } else {
#line 592
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 592
    if (from == 8) {
      {
#line 592
      tmp___3 = utf8_isdouble(c);
      }
#line 592
      if (tmp___3) {
        _L___0: /* CIL Label */ 
#line 594
        if (i + 1 == w) {
#line 595
          c = '?';
        } else {
          {
#line 599
          i ++;
#line 600
          c2 = (int )*(ml->image + i) | ((int )*(ml->font + i) << 8);
#line 601
          c = recode_char_dw_to_encoding(c, & c2, to);
#line 602
          *(rl->font + (i - 1)) = (unsigned char )((c >> 8) & 255);
#line 603
          *(rl->image + (i - 1)) = (unsigned char )(c & 255);
#line 604
          c = c2;
          }
        }
      } else {
        {
#line 609
        c = recode_char_to_encoding(c, to);
        }
      }
    } else {
      {
#line 609
      c = recode_char_to_encoding(c, to);
      }
    }
#line 610
    *(rl->image + i) = (unsigned char )(c & 255);
#line 611
    *(rl->font + i) = (unsigned char )((c >> 8) & 255);
#line 586
    i ++;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 613
  last ^= 1;
  {
#line 614
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 614
    goto while_break___14;
  }
  while_break___14: /* CIL Label */ ;
  }
#line 615
  i = 0;
  {
#line 615
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 615
    if (! (i < w)) {
#line 615
      goto while_break___15;
    }
    {
#line 616
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 616
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 615
    i ++;
  }
  while_break___15: /* CIL Label */ ;
  }
  {
#line 617
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 617
    goto while_break___17;
  }
  while_break___17: /* CIL Label */ ;
  }
#line 618
  i = 0;
  {
#line 618
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 618
    if (! (i < w)) {
#line 618
      goto while_break___18;
    }
    {
#line 619
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 619
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
#line 618
    i ++;
  }
  while_break___18: /* CIL Label */ ;
  }
  {
#line 620
  while (1) {
    while_continue___20: /* CIL Label */ ;
#line 620
    goto while_break___20;
  }
  while_break___20: /* CIL Label */ ;
  }
#line 621
  i = 0;
  {
#line 621
  while (1) {
    while_continue___21: /* CIL Label */ ;
#line 621
    if (! (i < w)) {
#line 621
      goto while_break___21;
    }
    {
#line 622
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 622
      goto while_break___22;
    }
    while_break___22: /* CIL Label */ ;
    }
#line 621
    i ++;
  }
  while_break___21: /* CIL Label */ ;
  }
  {
#line 623
  while (1) {
    while_continue___23: /* CIL Label */ ;
#line 623
    goto while_break___23;
  }
  while_break___23: /* CIL Label */ ;
  }
#line 624
  i = 0;
  {
#line 624
  while (1) {
    while_continue___24: /* CIL Label */ ;
#line 624
    if (! (i < w)) {
#line 624
      goto while_break___24;
    }
    {
#line 625
    while (1) {
      while_continue___25: /* CIL Label */ ;
#line 625
      goto while_break___25;
    }
    while_break___25: /* CIL Label */ ;
    }
#line 624
    i ++;
  }
  while_break___24: /* CIL Label */ ;
  }
  {
#line 626
  while (1) {
    while_continue___26: /* CIL Label */ ;
#line 626
    goto while_break___26;
  }
  while_break___26: /* CIL Label */ ;
  }
#line 627
  return (rl);
}
}
#line 636 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
struct combchar **combchars  ;
#line 638 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
void AddUtf8(int c ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 642
  while (1) {
    while_continue: /* CIL Label */ ;
#line 642
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 643
  if (c >= 55296) {
#line 643
    if (c < 57344) {
#line 643
      if (combchars) {
#line 643
        if (*(combchars + (c - 55296))) {
          {
#line 645
          AddUtf8((int )(*(combchars + (c - 55296)))->c1);
#line 646
          c = (int )(*(combchars + (c - 55296)))->c2;
          }
        }
      }
    }
  }
#line 648
  if (c >= 2048) {
    {
#line 650
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 650
      (display->d_obuffree) --;
#line 650
      if (display->d_obuffree <= 0) {
        {
#line 650
        Resize_obuf();
        }
      }
#line 650
      tmp = display->d_obufp;
#line 650
      (display->d_obufp) ++;
#line 650
      *tmp = (char )(((c & 61440) >> 12) | 224);
#line 650
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 651
    c = (c & 4095) | 4096;
  }
#line 653
  if (c >= 128) {
    {
#line 655
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 655
      (display->d_obuffree) --;
#line 655
      if (display->d_obuffree <= 0) {
        {
#line 655
        Resize_obuf();
        }
      }
#line 655
      tmp___0 = display->d_obufp;
#line 655
      (display->d_obufp) ++;
#line 655
      *tmp___0 = (char )(((c & 8128) >> 6) ^ 192);
#line 655
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 656
    c = (c & 63) | 128;
  }
  {
#line 658
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 658
    (display->d_obuffree) --;
#line 658
    if (display->d_obuffree <= 0) {
      {
#line 658
      Resize_obuf();
      }
    }
#line 658
    tmp___1 = display->d_obufp;
#line 658
    (display->d_obufp) ++;
#line 658
    *tmp___1 = (char )c;
#line 658
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 659
  return;
}
}
#line 661 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
int ToUtf8_comb(char *p , int c ) 
{ 
  int l ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 668
  if (c >= 55296) {
#line 668
    if (c < 57344) {
#line 668
      if (combchars) {
#line 668
        if (*(combchars + (c - 55296))) {
          {
#line 670
          l = ToUtf8_comb(p, (int )(*(combchars + (c - 55296)))->c1);
          }
#line 671
          if (p) {
#line 671
            tmp = p + l;
          } else {
#line 671
            tmp = (char *)0;
          }
          {
#line 671
          tmp___0 = ToUtf8(tmp, (int )(*(combchars + (c - 55296)))->c2);
          }
#line 671
          return (l + tmp___0);
        }
      }
    }
  }
  {
#line 673
  tmp___1 = ToUtf8(p, c);
  }
#line 673
  return (tmp___1);
}
}
#line 676 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
int ToUtf8(char *p , int c ) 
{ 
  int l ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 681
  l = 1;
#line 682
  if (c >= 2048) {
#line 684
    if (p) {
#line 685
      tmp = p;
#line 685
      p ++;
#line 685
      *tmp = (char )(((c & 61440) >> 12) | 224);
    }
#line 686
    l ++;
#line 687
    c = (c & 4095) | 4096;
  }
#line 689
  if (c >= 128) {
#line 691
    if (p) {
#line 692
      tmp___0 = p;
#line 692
      p ++;
#line 692
      *tmp___0 = (char )(((c & 8128) >> 6) ^ 192);
    }
#line 693
    l ++;
#line 694
    c = (c & 63) | 128;
  }
#line 696
  if (p) {
#line 697
    tmp___1 = p;
#line 697
    p ++;
#line 697
    *tmp___1 = (char )c;
  }
#line 698
  return (l);
}
}
#line 707 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
int FromUtf8(int c , int *utf8charp ) 
{ 
  int utf8char ;

  {
#line 711
  utf8char = *utf8charp;
#line 712
  if (utf8char) {
#line 714
    if ((c & 192) != 128) {
#line 716
      *utf8charp = 0;
#line 717
      return (-2);
    } else {
#line 720
      c = (c & 63) | (utf8char << 6);
    }
#line 721
    if (! (utf8char & 1073741824)) {
#line 724
      if (((unsigned int )c & 2181571552U) == 2147483648U) {
#line 725
        c = -33554433;
      } else
#line 726
      if ((c & 34087408) == 33554432) {
#line 727
        c = -524289;
      } else
#line 728
      if ((c & 532728) == 524288) {
#line 729
        c = -12288;
      } else
#line 730
      if ((c & 8316) == 8192) {
#line 731
        c = -144;
      }
    }
  } else
#line 737
  if (c >= 254) {
#line 738
    c = 65533;
  } else
#line 739
  if (c >= 252) {
#line 740
    c = (int )((unsigned int )(c & 1) | 3221225468U);
  } else
#line 741
  if (c >= 248) {
#line 742
    c = (int )((unsigned int )(c & 3) | 3221225216U);
  } else
#line 743
  if (c >= 240) {
#line 744
    c = (int )((unsigned int )(c & 7) | 3221209088U);
  } else
#line 745
  if (c >= 224) {
#line 746
    c = (int )((unsigned int )(c & 15) | 3220176896U);
  } else
#line 747
  if (c >= 194) {
#line 748
    c = (int )((unsigned int )(c & 31) | 4227858432U);
  } else
#line 749
  if (c >= 192) {
#line 750
    c = -33554433;
  } else
#line 751
  if (c >= 128) {
#line 752
    c = 65533;
  }
#line 754
  if ((unsigned int )c & 2147483648U) {
#line 754
    utf8char = c;
  } else {
#line 754
    utf8char = 0;
  }
#line 754
  *utf8charp = utf8char;
#line 755
  if (utf8char) {
#line 756
    return (-1);
  }
#line 757
  if ((unsigned int )c & 4294901760U) {
#line 758
    c = 65533;
  }
#line 759
  if (c >= 55296) {
#line 759
    if (c <= 57343) {
#line 760
      c = 65533;
    } else
#line 759
    if (c == 65534) {
#line 760
      c = 65533;
    } else
#line 759
    if (c == 65535) {
#line 760
      c = 65533;
    }
  }
#line 761
  return (c);
}
}
#line 765 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
void WinSwitchEncoding(struct win *p , int encoding ) 
{ 
  int i ;
  int j ;
  int c ;
  struct mline *ml ;
  struct display *d ;
  struct canvas *cv ;
  struct layer *oldflayer ;
  unsigned char *tmp ;
  void *tmp___0 ;
  int c2 ;
  int tmp___1 ;

  {
#line 776
  if ((p->w_layer.l_encoding == 8) == (encoding == 8)) {
#line 778
    p->w_layer.l_encoding = encoding;
#line 779
    return;
  }
#line 781
  oldflayer = flayer;
#line 782
  d = displays;
  {
#line 782
  while (1) {
    while_continue: /* CIL Label */ ;
#line 782
    if (! d) {
#line 782
      goto while_break;
    }
#line 783
    cv = d->d_cvlist;
    {
#line 783
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 783
      if (! cv) {
#line 783
        goto while_break___0;
      }
#line 784
      if ((unsigned long )p == (unsigned long )((struct win *)((cv->c_layer)->l_bottom)->l_data)) {
#line 786
        flayer = cv->c_layer;
        {
#line 787
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 787
          if (! flayer->l_next) {
#line 787
            goto while_break___1;
          }
#line 789
          if ((unsigned long )oldflayer == (unsigned long )flayer) {
#line 790
            oldflayer = flayer->l_next;
          }
          {
#line 791
          ExitOverlayPage();
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 783
      cv = cv->c_next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 782
    d = d->d_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 794
  flayer = oldflayer;
#line 795
  j = 0;
  {
#line 795
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 795
    if (! (j < p->w_layer.l_height + p->w_histheight)) {
#line 795
      goto while_break___2;
    }
#line 798
    if (j < p->w_layer.l_height) {
#line 798
      ml = p->w_mlines + j;
    } else {
#line 798
      ml = p->w_hlines + (j - p->w_layer.l_height);
    }
#line 802
    if ((unsigned long )ml->font == (unsigned long )null) {
#line 802
      if (encodings[p->w_layer.l_encoding].deffont == 0) {
#line 803
        goto __Cont;
      }
    }
#line 804
    i = 0;
    {
#line 804
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 804
      if (! (i < p->w_layer.l_width)) {
#line 804
        goto while_break___3;
      }
#line 806
      c = (int )*(ml->image + i) | ((int )*(ml->font + i) << 8);
#line 807
      if (p->w_layer.l_encoding != 8) {
#line 807
        if (c < 256) {
#line 808
          c |= encodings[p->w_layer.l_encoding].deffont << 8;
        }
      }
#line 809
      if (c < 256) {
#line 810
        goto __Cont___0;
      }
#line 811
      if ((unsigned long )ml->font == (unsigned long )null) {
        {
#line 813
        tmp___0 = malloc((size_t )(p->w_layer.l_width + 1));
#line 813
        tmp = (unsigned char *)tmp___0;
#line 813
        ml->font = tmp;
        }
#line 813
        if ((unsigned long )tmp == (unsigned long )((unsigned char *)0)) {
#line 815
          ml->font = null;
#line 816
          goto while_break___3;
        }
        {
#line 818
        bzero((void *)ml->font, (size_t )(p->w_layer.l_width + 1));
        }
      }
#line 821
      if (p->w_layer.l_encoding != 8) {
#line 821
        if ((c & 7936) != 0) {
#line 821
          if ((c & 57344) == 0) {
#line 821
            goto _L;
          } else {
#line 821
            goto _L___1;
          }
        } else {
#line 821
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 821
      if (p->w_layer.l_encoding == 8) {
        {
#line 821
        tmp___1 = utf8_isdouble(c);
        }
#line 821
        if (tmp___1) {
          _L: /* CIL Label */ 
#line 823
          if (i + 1 == p->w_layer.l_width) {
#line 824
            c = '?';
          } else {
            {
#line 828
            i ++;
#line 829
            c2 = (int )*(ml->image + i) | ((int )*(ml->font + i) << 8);
#line 830
            c = recode_char_dw_to_encoding(c, & c2, encoding);
#line 831
            *(ml->font + (i - 1)) = (unsigned char )((c >> 8) & 255);
#line 832
            *(ml->image + (i - 1)) = (unsigned char )(c & 255);
#line 833
            c = c2;
            }
          }
        } else {
          {
#line 838
          c = recode_char_to_encoding(c, encoding);
          }
        }
      } else {
        {
#line 838
        c = recode_char_to_encoding(c, encoding);
        }
      }
#line 839
      *(ml->image + i) = (unsigned char )(c & 255);
#line 840
      *(ml->font + i) = (unsigned char )((c >> 8) & 255);
      __Cont___0: /* CIL Label */ 
#line 804
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 795
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 843
  p->w_layer.l_encoding = encoding;
#line 844
  return;
}
}
#line 848 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
int utf8_isdouble(int c ) 
{ 
  int tmp ;

  {
#line 852
  if (c >= 4352) {
#line 852
    if (c <= 4447) {
#line 852
      tmp = 1;
    } else
#line 852
    if (c >= 11904) {
#line 852
      if (c <= 42191) {
#line 852
        if ((c & -18) != 12298) {
#line 852
          if (c != 12351) {
#line 852
            tmp = 1;
          } else {
#line 852
            goto _L___7;
          }
        } else {
#line 852
          goto _L___7;
        }
      } else {
#line 852
        goto _L___7;
      }
    } else
    _L___7: /* CIL Label */ 
#line 852
    if (c >= 44032) {
#line 852
      if (c <= 55203) {
#line 852
        tmp = 1;
      } else {
#line 852
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 852
    if (c >= 57088) {
#line 852
      if (c <= 57343) {
#line 852
        tmp = 1;
      } else {
#line 852
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 852
    if (c >= 63744) {
#line 852
      if (c <= 64255) {
#line 852
        tmp = 1;
      } else {
#line 852
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 852
    if (c >= 65072) {
#line 852
      if (c <= 65135) {
#line 852
        tmp = 1;
      } else {
#line 852
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 852
    if (c >= 65280) {
#line 852
      if (c <= 65375) {
#line 852
        tmp = 1;
      } else {
#line 852
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 852
    if (c >= 65504) {
#line 852
      if (c <= 65510) {
#line 852
        tmp = 1;
      } else {
#line 852
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 852
    if (c >= 131072) {
#line 852
      if (c <= 196607) {
#line 852
        tmp = 1;
      } else {
#line 852
        tmp = 0;
      }
    } else {
#line 852
      tmp = 0;
    }
  } else {
#line 852
    tmp = 0;
  }
#line 852
  return (tmp);
}
}
#line 872 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
static struct __anonstruct_combining_50 combining[106]  = 
#line 872
  {      {(unsigned short)768, (unsigned short)847}, 
        {(unsigned short)864, (unsigned short)879}, 
        {(unsigned short)1155, (unsigned short)1158}, 
        {(unsigned short)1160, (unsigned short)1161}, 
        {(unsigned short)1425, (unsigned short)1441}, 
        {(unsigned short)1443, (unsigned short)1465}, 
        {(unsigned short)1467, (unsigned short)1469}, 
        {(unsigned short)1471, (unsigned short)1471}, 
        {(unsigned short)1473, (unsigned short)1474}, 
        {(unsigned short)1476, (unsigned short)1476}, 
        {(unsigned short)1611, (unsigned short)1621}, 
        {(unsigned short)1648, (unsigned short)1648}, 
        {(unsigned short)1750, (unsigned short)1764}, 
        {(unsigned short)1767, (unsigned short)1768}, 
        {(unsigned short)1770, (unsigned short)1773}, 
        {(unsigned short)1807, (unsigned short)1807}, 
        {(unsigned short)1809, (unsigned short)1809}, 
        {(unsigned short)1840, (unsigned short)1866}, 
        {(unsigned short)1958, (unsigned short)1968}, 
        {(unsigned short)2305, (unsigned short)2306}, 
        {(unsigned short)2364, (unsigned short)2364}, 
        {(unsigned short)2369, (unsigned short)2376}, 
        {(unsigned short)2381, (unsigned short)2381}, 
        {(unsigned short)2385, (unsigned short)2388}, 
        {(unsigned short)2402, (unsigned short)2403}, 
        {(unsigned short)2433, (unsigned short)2433}, 
        {(unsigned short)2492, (unsigned short)2492}, 
        {(unsigned short)2497, (unsigned short)2500}, 
        {(unsigned short)2509, (unsigned short)2509}, 
        {(unsigned short)2530, (unsigned short)2531}, 
        {(unsigned short)2562, (unsigned short)2562}, 
        {(unsigned short)2620, (unsigned short)2620}, 
        {(unsigned short)2625, (unsigned short)2626}, 
        {(unsigned short)2631, (unsigned short)2632}, 
        {(unsigned short)2635, (unsigned short)2637}, 
        {(unsigned short)2672, (unsigned short)2673}, 
        {(unsigned short)2689, (unsigned short)2690}, 
        {(unsigned short)2748, (unsigned short)2748}, 
        {(unsigned short)2753, (unsigned short)2757}, 
        {(unsigned short)2759, (unsigned short)2760}, 
        {(unsigned short)2765, (unsigned short)2765}, 
        {(unsigned short)2817, (unsigned short)2817}, 
        {(unsigned short)2876, (unsigned short)2876}, 
        {(unsigned short)2879, (unsigned short)2879}, 
        {(unsigned short)2881, (unsigned short)2883}, 
        {(unsigned short)2893, (unsigned short)2893}, 
        {(unsigned short)2902, (unsigned short)2902}, 
        {(unsigned short)2946, (unsigned short)2946}, 
        {(unsigned short)3008, (unsigned short)3008}, 
        {(unsigned short)3021, (unsigned short)3021}, 
        {(unsigned short)3134, (unsigned short)3136}, 
        {(unsigned short)3142, (unsigned short)3144}, 
        {(unsigned short)3146, (unsigned short)3149}, 
        {(unsigned short)3157, (unsigned short)3158}, 
        {(unsigned short)3263, (unsigned short)3263}, 
        {(unsigned short)3270, (unsigned short)3270}, 
        {(unsigned short)3276, (unsigned short)3277}, 
        {(unsigned short)3393, (unsigned short)3395}, 
        {(unsigned short)3405, (unsigned short)3405}, 
        {(unsigned short)3530, (unsigned short)3530}, 
        {(unsigned short)3538, (unsigned short)3540}, 
        {(unsigned short)3542, (unsigned short)3542}, 
        {(unsigned short)3633, (unsigned short)3633}, 
        {(unsigned short)3636, (unsigned short)3642}, 
        {(unsigned short)3655, (unsigned short)3662}, 
        {(unsigned short)3761, (unsigned short)3761}, 
        {(unsigned short)3764, (unsigned short)3769}, 
        {(unsigned short)3771, (unsigned short)3772}, 
        {(unsigned short)3784, (unsigned short)3789}, 
        {(unsigned short)3864, (unsigned short)3865}, 
        {(unsigned short)3893, (unsigned short)3893}, 
        {(unsigned short)3895, (unsigned short)3895}, 
        {(unsigned short)3897, (unsigned short)3897}, 
        {(unsigned short)3953, (unsigned short)3966}, 
        {(unsigned short)3968, (unsigned short)3972}, 
        {(unsigned short)3974, (unsigned short)3975}, 
        {(unsigned short)3984, (unsigned short)3991}, 
        {(unsigned short)3993, (unsigned short)4028}, 
        {(unsigned short)4038, (unsigned short)4038}, 
        {(unsigned short)4141, (unsigned short)4144}, 
        {(unsigned short)4146, (unsigned short)4146}, 
        {(unsigned short)4150, (unsigned short)4151}, 
        {(unsigned short)4153, (unsigned short)4153}, 
        {(unsigned short)4184, (unsigned short)4185}, 
        {(unsigned short)4448, (unsigned short)4607}, 
        {(unsigned short)5906, (unsigned short)5908}, 
        {(unsigned short)5938, (unsigned short)5940}, 
        {(unsigned short)5970, (unsigned short)5971}, 
        {(unsigned short)6002, (unsigned short)6003}, 
        {(unsigned short)6071, (unsigned short)6077}, 
        {(unsigned short)6086, (unsigned short)6086}, 
        {(unsigned short)6089, (unsigned short)6099}, 
        {(unsigned short)6155, (unsigned short)6158}, 
        {(unsigned short)6313, (unsigned short)6313}, 
        {(unsigned short)8203, (unsigned short)8207}, 
        {(unsigned short)8234, (unsigned short)8238}, 
        {(unsigned short)8288, (unsigned short)8291}, 
        {(unsigned short)8298, (unsigned short)8303}, 
        {(unsigned short)8400, (unsigned short)8426}, 
        {(unsigned short)12330, (unsigned short)12335}, 
        {(unsigned short)12441, (unsigned short)12442}, 
        {(unsigned short)64286, (unsigned short)64286}, 
        {(unsigned short)65024, (unsigned short)65039}, 
        {(unsigned short)65056, (unsigned short)65059}, 
        {(unsigned short)65279, (unsigned short)65279}, 
        {(unsigned short)65529, (unsigned short)65531}};
#line 867 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
int utf8_iscomb(int c ) 
{ 
  int mid ;
  int min ;
  int max ;

  {
#line 913
  min = 0;
#line 913
  max = (int )(sizeof(combining) / sizeof(combining[0]) - 1UL);
#line 915
  if (c < 768) {
#line 916
    return (0);
  } else
#line 915
  if (c > 65531) {
#line 916
    return (0);
  }
  {
#line 917
  while (1) {
    while_continue: /* CIL Label */ ;
#line 917
    if (! (max >= min)) {
#line 917
      goto while_break;
    }
#line 919
    mid = (min + max) / 2;
#line 920
    if (c > (int )combining[mid].last) {
#line 921
      min = mid + 1;
    } else
#line 922
    if (c < (int )combining[mid].first) {
#line 923
      max = mid - 1;
    } else {
#line 925
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 927
  return (0);
}
}
#line 930 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
static void comb_tofront(int root , int i ) 
{ 


  {
  {
#line 934
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 936
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 936
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 937
    (*(combchars + (*(combchars + i))->prev))->next = (*(combchars + i))->next;
#line 938
    (*(combchars + (*(combchars + i))->next))->prev = (*(combchars + i))->prev;
#line 939
    (*(combchars + i))->next = (*(combchars + root))->next;
#line 940
    (*(combchars + i))->prev = (unsigned short )root;
#line 941
    (*(combchars + (*(combchars + root))->next))->prev = (unsigned short )i;
#line 942
    (*(combchars + root))->next = (unsigned short )i;
#line 943
    i = (int )(*(combchars + i))->c1;
#line 944
    if (i < 55296) {
#line 945
      return;
    } else
#line 944
    if (i >= 57344) {
#line 945
      return;
    }
#line 946
    i -= 55296;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 950 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
void utf8_handle_comb(int c , struct mchar *mc ) 
{ 
  int root ;
  int i ;
  int c1 ;
  int isdouble ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 958
  c1 = (int )mc->image | ((int )mc->font << 8);
#line 959
  if (c1 >= 4352) {
    {
#line 959
    tmp = utf8_isdouble(c1);
    }
#line 959
    if (tmp) {
#line 959
      tmp___0 = 1;
    } else {
#line 959
      tmp___0 = 0;
    }
  } else {
#line 959
    tmp___0 = 0;
  }
#line 959
  isdouble = tmp___0;
#line 960
  if (! combchars) {
    {
#line 962
    tmp___1 = malloc((size_t )(sizeof(struct combchar *) * 2050UL));
#line 962
    combchars = (struct combchar **)tmp___1;
    }
#line 963
    if (! combchars) {
#line 964
      return;
    }
    {
#line 965
    bzero((void *)((char *)combchars), (size_t )(sizeof(struct combchar *) * 2050UL));
#line 966
    tmp___2 = malloc((size_t )sizeof(struct combchar ));
#line 966
    *(combchars + 2048) = (struct combchar *)tmp___2;
#line 967
    tmp___3 = malloc((size_t )sizeof(struct combchar ));
#line 967
    *(combchars + 2049) = (struct combchar *)tmp___3;
    }
#line 968
    if (! *(combchars + 2048)) {
#line 968
      goto _L;
    } else
#line 968
    if (! *(combchars + 2049)) {
      _L: /* CIL Label */ 
#line 970
      if (*(combchars + 2048)) {
        {
#line 971
        free((void *)*(combchars + 2048));
        }
      }
#line 972
      if (*(combchars + 2049)) {
        {
#line 973
        free((void *)*(combchars + 2049));
        }
      }
      {
#line 974
      free((void *)combchars);
      }
#line 975
      return;
    }
#line 977
    (*(combchars + 2048))->c1 = (unsigned short)0;
#line 978
    (*(combchars + 2048))->c2 = (unsigned short)1792;
#line 979
    (*(combchars + 2048))->next = (unsigned short)2048;
#line 980
    (*(combchars + 2048))->prev = (unsigned short)2048;
#line 981
    (*(combchars + 2049))->c1 = (unsigned short)1792;
#line 982
    (*(combchars + 2049))->c2 = (unsigned short)2048;
#line 983
    (*(combchars + 2049))->next = (unsigned short)2049;
#line 984
    (*(combchars + 2049))->prev = (unsigned short)2049;
  }
#line 986
  if (isdouble) {
#line 986
    root = 2049;
  } else {
#line 986
    root = 2048;
  }
#line 987
  i = (int )(*(combchars + root))->c1;
  {
#line 987
  while (1) {
    while_continue: /* CIL Label */ ;
#line 987
    if (! (i < (int )(*(combchars + root))->c2)) {
#line 987
      goto while_break;
    }
#line 989
    if (! *(combchars + i)) {
#line 990
      goto while_break;
    }
#line 991
    if ((int )(*(combchars + i))->c1 == c1) {
#line 991
      if ((int )(*(combchars + i))->c2 == c) {
#line 992
        goto while_break;
      }
    }
#line 987
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 994
  if (i == (int )(*(combchars + root))->c2) {
#line 997
    if (c1 >= 55296) {
#line 997
      if (c1 < 57344) {
        {
#line 998
        comb_tofront(root, c1);
        }
      }
    }
#line 999
    i = (int )(*(combchars + root))->prev;
  } else
#line 1002
  if (! *(combchars + i)) {
    {
#line 1004
    tmp___4 = malloc((size_t )sizeof(struct combchar ));
#line 1004
    *(combchars + i) = (struct combchar *)tmp___4;
    }
#line 1005
    if (! *(combchars + i)) {
#line 1006
      return;
    }
#line 1007
    (*(combchars + i))->prev = (unsigned short )i;
#line 1008
    (*(combchars + i))->next = (unsigned short )i;
  }
#line 1010
  (*(combchars + i))->c1 = (unsigned short )c1;
#line 1011
  (*(combchars + i))->c2 = (unsigned short )c;
#line 1012
  mc->image = (unsigned char )(i & 255);
#line 1013
  mc->font = (unsigned char )((i >> 8) + 216);
  {
#line 1014
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1014
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1015
  comb_tofront(root, i);
  }
#line 1016
  return;
}
}
#line 1031 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
static int encmatch(char *s1 , char *s2 ) 
{ 
  int c1 ;
  int c2 ;

  {
  {
#line 1037
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1039
    c1 = (int )((unsigned char )*s1);
#line 1040
    if (c1 >= 65) {
#line 1040
      if (c1 <= 90) {
#line 1041
        c1 += 32;
      }
    }
#line 1042
    if (c1 >= 97) {
#line 1042
      if (! (c1 <= 122)) {
#line 1042
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1042
    if (c1 >= 48) {
#line 1042
      if (! (c1 <= 57)) {
#line 1044
        s1 ++;
#line 1045
        goto __Cont;
      }
    } else {
#line 1044
      s1 ++;
#line 1045
      goto __Cont;
    }
#line 1047
    c2 = (int )((unsigned char )*s2);
#line 1048
    if (c2 >= 65) {
#line 1048
      if (c2 <= 90) {
#line 1049
        c2 += 32;
      }
    }
#line 1050
    if (c2 >= 97) {
#line 1050
      if (! (c2 <= 122)) {
#line 1050
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1050
    if (c2 >= 48) {
#line 1050
      if (! (c2 <= 57)) {
#line 1052
        s2 ++;
#line 1053
        goto __Cont;
      }
    } else {
#line 1052
      s2 ++;
#line 1053
      goto __Cont;
    }
#line 1055
    if (c1 != c2) {
#line 1056
      return (0);
    }
#line 1057
    s1 ++;
#line 1058
    s2 ++;
    __Cont: /* CIL Label */ 
#line 1037
    if (! c1) {
#line 1037
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1061
  return (1);
}
}
#line 1064 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
int FindEncoding(char *name ) 
{ 
  int encoding ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1070
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1070
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1071
  if ((unsigned long )name == (unsigned long )((char *)0)) {
#line 1072
    return (0);
  } else
#line 1071
  if ((int )*name == 0) {
#line 1072
    return (0);
  }
  {
#line 1073
  tmp = encmatch(name, (char *)"euc");
  }
#line 1073
  if (tmp) {
#line 1074
    name = (char *)"eucJP";
  }
  {
#line 1075
  tmp___0 = encmatch(name, (char *)"off");
  }
#line 1075
  if (tmp___0) {
#line 1076
    return (0);
  } else {
    {
#line 1075
    tmp___1 = encmatch(name, (char *)"iso8859-1");
    }
#line 1075
    if (tmp___1) {
#line 1076
      return (0);
    }
  }
#line 1081
  encoding = 0;
  {
#line 1081
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1081
    if (! (encoding < (int )(sizeof(encodings) / sizeof(encodings[0])))) {
#line 1081
      goto while_break___0;
    }
    {
#line 1082
    tmp___2 = encmatch(name, encodings[encoding].name);
    }
#line 1082
    if (tmp___2) {
      {
#line 1085
      LoadFontTranslationsForEncoding(encoding);
      }
#line 1087
      return (encoding);
    }
#line 1081
    encoding ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1089
  return (-1);
}
}
#line 1092 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
char *EncodingName(int encoding ) 
{ 


  {
#line 1096
  if (encoding >= (int )(sizeof(encodings) / sizeof(encodings[0]))) {
#line 1097
    return ((char *)0);
  }
#line 1098
  return (encodings[encoding].name);
}
}
#line 1101 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
int EncodingDefFont(int encoding ) 
{ 


  {
#line 1105
  return (encodings[encoding].deffont);
}
}
#line 1108 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
void ResetEncoding(struct win *p ) 
{ 
  char *c ;
  int encoding ;

  {
#line 1113
  encoding = p->w_layer.l_encoding;
#line 1115
  c = encodings[encoding].charsets;
#line 1116
  if (c) {
    {
#line 1117
    SetCharsets(p, c);
    }
  }
  {
#line 1119
  LoadFontTranslationsForEncoding(encoding);
  }
#line 1121
  if (encodings[encoding].usegr) {
#line 1123
    p->w_gr = 2;
#line 1124
    p->w_FontE = *(encodings[encoding].charsets + 1);
  } else {
#line 1127
    p->w_FontE = (char)0;
  }
#line 1128
  if (encodings[encoding].noc1) {
#line 1129
    p->w_c1 = 0;
  }
#line 1130
  return;
}
}
#line 1132 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
int DecodeChar(int c , int encoding , int *statep ) 
{ 
  int t ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1140
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1142
  if (encoding == 8) {
    {
#line 1143
    tmp = FromUtf8(c, statep);
    }
#line 1143
    return (tmp);
  }
#line 1145
  if (encoding == 2) {
#line 1147
    if (! *statep) {
#line 1149
      if (129 <= c) {
#line 1149
        if (c <= 159) {
#line 1151
          *statep = c;
#line 1152
          return (-1);
        } else {
#line 1149
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1149
      if (224 <= c) {
#line 1149
        if (c <= 239) {
#line 1151
          *statep = c;
#line 1152
          return (-1);
        }
      }
#line 1154
      return (c | (73 << 16));
    }
#line 1156
    t = c;
#line 1157
    c = *statep;
#line 1158
    *statep = 0;
#line 1159
    if (64 <= t) {
#line 1159
      if (t <= 252) {
#line 1159
        if (t != 127) {
#line 1161
          if (c <= 159) {
#line 1161
            c = (c - 129) * 2 + 33;
          } else {
#line 1162
            c = (c - 193) * 2 + 33;
          }
#line 1163
          if (t <= 126) {
#line 1163
            t -= 31;
          } else
#line 1164
          if (t <= 158) {
#line 1164
            t -= 32;
          } else {
#line 1165
            t -= 126;
#line 1165
            c ++;
          }
#line 1166
          return (((c << 8) | t) | (2 << 16));
        }
      }
    }
#line 1168
    return (t);
  }
#line 1170
  if (encoding == 1) {
#line 1170
    goto _L___0;
  } else
#line 1170
  if (encoding == 3) {
#line 1170
    goto _L___0;
  } else
#line 1170
  if (encoding == 4) {
    _L___0: /* CIL Label */ 
#line 1172
    if (! *statep) {
#line 1174
      if (c & 128) {
#line 1176
        *statep = c;
#line 1177
        return (-1);
      }
#line 1179
      return (c);
    }
#line 1181
    t = c;
#line 1182
    c = *statep;
#line 1183
    *statep = 0;
#line 1184
    if (encoding == 1) {
#line 1186
      if (c == 142) {
#line 1187
        return (t | (73 << 16));
      }
#line 1188
      if (c == 143) {
#line 1190
        *statep = t | (4 << 8);
#line 1191
        return (-1);
      }
    }
#line 1194
    c &= 65407;
#line 1195
    t &= 127;
#line 1196
    c = (c << 8) | t;
#line 1197
    if (encoding == 3) {
#line 1198
      return (c | (3 << 16));
    }
#line 1199
    if (encoding == 4) {
#line 1200
      return (c | (1 << 16));
    }
#line 1201
    if (c & (4 << 16)) {
#line 1202
      return (c);
    } else {
#line 1204
      return (c | (2 << 16));
    }
  }
#line 1206
  if (encoding == 5) {
#line 1206
    goto _L___1;
  } else
#line 1206
  if (encoding == 20) {
    _L___1: /* CIL Label */ 
#line 1208
    if (! *statep) {
#line 1210
      if (c & 128) {
#line 1212
        if (encoding == 20) {
#line 1212
          if (c == 128) {
#line 1213
            return (164 | (226 << 16));
          }
        }
#line 1214
        *statep = c;
#line 1215
        return (-1);
      }
#line 1217
      return (c);
    }
#line 1219
    t = c;
#line 1220
    c = *statep;
#line 1221
    *statep = 0;
#line 1222
    c &= 127;
#line 1223
    if (encoding == 5) {
#line 1223
      tmp___0 = 24 << 16;
    } else {
#line 1223
      tmp___0 = 25 << 16;
    }
#line 1223
    return (((c << 8) | t) | tmp___0);
  }
#line 1225
  return (c | (encodings[encoding].deffont << 16));
}
}
#line 1228 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
int EncodeChar(char *bp , int c , int encoding , int *fontp ) 
{ 
  int t ;
  int f ;
  int l ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int c2 ;
  int tmp___2 ;
  int c2___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;

  {
  {
#line 1237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1237
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1238
  if (c == -1) {
#line 1238
    if (fontp) {
#line 1240
      if (*fontp == 0) {
#line 1241
        return (0);
      }
#line 1242
      if (bp) {
#line 1244
        tmp = bp;
#line 1244
        bp ++;
#line 1244
        *tmp = (char)27;
#line 1245
        tmp___0 = bp;
#line 1245
        bp ++;
#line 1245
        *tmp___0 = (char )'(';
#line 1246
        tmp___1 = bp;
#line 1246
        bp ++;
#line 1246
        *tmp___1 = (char )'B';
      }
#line 1248
      return (3);
    }
  }
#line 1250
  f = c >> 16;
#line 1253
  if (encoding == 8) {
#line 1255
    if (f) {
#line 1258
      if (f) {
#line 1258
        if ((f & 96) == 0) {
          {
#line 1260
          c2 = c & 255;
#line 1261
          c = ((c >> 8) & 255) | (f << 8);
#line 1262
          c = recode_char_dw_to_encoding(c, & c2, encoding);
          }
        } else {
          {
#line 1267
          c = (c & 255) | (f << 8);
#line 1268
          c = recode_char_to_encoding(c, encoding);
          }
        }
      } else {
        {
#line 1267
        c = (c & 255) | (f << 8);
#line 1268
        c = recode_char_to_encoding(c, encoding);
        }
      }
    }
    {
#line 1271
    tmp___2 = ToUtf8(bp, c);
    }
#line 1271
    return (tmp___2);
  }
#line 1273
  if (c & 65280) {
#line 1273
    if (f == 0) {
      {
#line 1276
      tmp___3 = utf8_isdouble(c);
      }
#line 1276
      if (tmp___3) {
        {
#line 1278
        c2___0 = 65535;
#line 1279
        c = recode_char_dw_to_encoding(c, & c2___0, encoding);
#line 1280
        c = (c << 8) | (c2___0 & 255);
        }
      } else {
        {
#line 1285
        c = recode_char_to_encoding(c, encoding);
#line 1286
        c = ((c & 65280) << 8) | (c & 255);
        }
      }
      {
#line 1288
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1288
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1289
      f = c >> 16;
    }
  }
#line 1292
  if (f & 128) {
#line 1293
    f = 0;
  }
#line 1295
  if (encoding == 2) {
#line 1297
    if (f == 73) {
#line 1298
      c = (c & 255) | 128;
    } else
#line 1299
    if (f == 2) {
#line 1301
      if (! bp) {
#line 1302
        return (2);
      }
#line 1303
      t = c & 255;
#line 1304
      c = (c >> 8) & 255;
#line 1305
      if (c & 1) {
#line 1305
        if (t <= 95) {
#line 1305
          tmp___4 = 31;
        } else {
#line 1305
          tmp___4 = 32;
        }
#line 1305
        tmp___5 = tmp___4;
      } else {
#line 1305
        tmp___5 = 126;
      }
#line 1305
      t += tmp___5;
#line 1306
      if (c < 95) {
#line 1306
        tmp___6 = 129;
      } else {
#line 1306
        tmp___6 = 193;
      }
#line 1306
      c = (c - 33) / 2 + tmp___6;
#line 1307
      tmp___7 = bp;
#line 1307
      bp ++;
#line 1307
      *tmp___7 = (char )c;
#line 1308
      tmp___8 = bp;
#line 1308
      bp ++;
#line 1308
      *tmp___8 = (char )t;
#line 1309
      return (2);
    }
  }
#line 1312
  if (encoding == 1) {
#line 1314
    if (f == 73) {
#line 1316
      if (bp) {
#line 1318
        tmp___9 = bp;
#line 1318
        bp ++;
#line 1318
        *tmp___9 = (char)-114;
#line 1319
        tmp___10 = bp;
#line 1319
        bp ++;
#line 1319
        *tmp___10 = (char )c;
      }
#line 1321
      return (2);
    }
#line 1323
    if (f == 2) {
#line 1325
      if (bp) {
#line 1327
        tmp___11 = bp;
#line 1327
        bp ++;
#line 1327
        *tmp___11 = (char )((c >> 8) | 128);
#line 1328
        tmp___12 = bp;
#line 1328
        bp ++;
#line 1328
        *tmp___12 = (char )(c | 128);
      }
#line 1330
      return (2);
    }
#line 1332
    if (f == 4) {
#line 1334
      if (bp) {
#line 1336
        tmp___13 = bp;
#line 1336
        bp ++;
#line 1336
        *tmp___13 = (char)-113;
#line 1337
        tmp___14 = bp;
#line 1337
        bp ++;
#line 1337
        *tmp___14 = (char )(c >> 8);
#line 1338
        tmp___15 = bp;
#line 1338
        bp ++;
#line 1338
        *tmp___15 = (char )c;
      }
#line 1340
      return (3);
    }
  }
#line 1343
  if (encoding == 3) {
#line 1343
    if (f == 3) {
#line 1343
      goto _L;
    } else {
#line 1343
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1343
  if (encoding == 4) {
#line 1343
    if (f == 1) {
      _L: /* CIL Label */ 
#line 1345
      if (bp) {
#line 1347
        tmp___16 = bp;
#line 1347
        bp ++;
#line 1347
        *tmp___16 = (char )((c >> 8) | 128);
#line 1348
        tmp___17 = bp;
#line 1348
        bp ++;
#line 1348
        *tmp___17 = (char )(c | 128);
      }
#line 1350
      return (2);
    }
  }
#line 1352
  if (encoding == 5) {
#line 1352
    if (f == 24) {
#line 1352
      goto _L___1;
    } else {
#line 1352
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 1352
  if (encoding == 20) {
#line 1352
    if (f == 25) {
      _L___1: /* CIL Label */ 
#line 1354
      if (bp) {
#line 1356
        tmp___18 = bp;
#line 1356
        bp ++;
#line 1356
        *tmp___18 = (char )((c >> 8) | 128);
#line 1357
        tmp___19 = bp;
#line 1357
        bp ++;
#line 1357
        *tmp___19 = (char )c;
      }
#line 1359
      return (2);
    }
  }
#line 1361
  if (encoding == 20) {
#line 1361
    if (f == 0) {
#line 1361
      if (c == 164) {
#line 1362
        c = 128;
      }
    }
  }
#line 1364
  l = 0;
#line 1365
  if (fontp) {
#line 1365
    if (f != *fontp) {
#line 1367
      *fontp = f;
#line 1368
      if (f) {
#line 1368
        if (f < 32) {
#line 1370
          if (bp) {
#line 1372
            tmp___20 = bp;
#line 1372
            bp ++;
#line 1372
            *tmp___20 = (char)27;
#line 1373
            tmp___21 = bp;
#line 1373
            bp ++;
#line 1373
            *tmp___21 = (char )'$';
#line 1374
            if (f > 2) {
#line 1375
              tmp___22 = bp;
#line 1375
              bp ++;
#line 1375
              *tmp___22 = (char )'(';
            }
#line 1376
            tmp___23 = bp;
#line 1376
            bp ++;
#line 1376
            *tmp___23 = (char )(64 + f);
          }
#line 1378
          if (f > 2) {
#line 1378
            tmp___24 = 4;
          } else {
#line 1378
            tmp___24 = 3;
          }
#line 1378
          l += tmp___24;
        } else {
#line 1368
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 1380
      if (f < 128) {
#line 1382
        if (f == 0) {
#line 1383
          f = 'B';
        }
#line 1384
        if (bp) {
#line 1386
          tmp___25 = bp;
#line 1386
          bp ++;
#line 1386
          *tmp___25 = (char)27;
#line 1387
          tmp___26 = bp;
#line 1387
          bp ++;
#line 1387
          *tmp___26 = (char )'(';
#line 1388
          tmp___27 = bp;
#line 1388
          bp ++;
#line 1388
          *tmp___27 = (char )f;
        }
#line 1390
        l += 3;
      }
    }
  }
#line 1393
  if (c & 65280) {
#line 1395
    if (bp) {
#line 1396
      tmp___28 = bp;
#line 1396
      bp ++;
#line 1396
      *tmp___28 = (char )(c >> 8);
    }
#line 1397
    l ++;
  }
#line 1399
  if (bp) {
#line 1400
    tmp___29 = bp;
#line 1400
    bp ++;
#line 1400
    *tmp___29 = (char )c;
  }
#line 1401
  return (l + 1);
}
}
#line 1404 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
int CanEncodeFont(int encoding , int f ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1411
  if (encoding == 8) {
#line 1411
    goto case_8;
  }
#line 1414
  if (encoding == 2) {
#line 1414
    goto case_2;
  }
#line 1416
  if (encoding == 1) {
#line 1416
    goto case_1;
  }
#line 1418
  if (encoding == 3) {
#line 1418
    goto case_3;
  }
#line 1420
  if (encoding == 4) {
#line 1420
    goto case_4;
  }
#line 1422
  if (encoding == 5) {
#line 1422
    goto case_5;
  }
#line 1424
  if (encoding == 20) {
#line 1424
    goto case_20;
  }
#line 1426
  goto switch_default;
  case_8: /* CIL Label */ 
#line 1412
  return (1);
  case_2: /* CIL Label */ 
#line 1415
  if (f == 2) {
#line 1415
    tmp = 1;
  } else
#line 1415
  if (f == 73) {
#line 1415
    tmp = 1;
  } else {
#line 1415
    tmp = 0;
  }
#line 1415
  return (tmp);
  case_1: /* CIL Label */ 
#line 1417
  if (f == 2) {
#line 1417
    tmp___0 = 1;
  } else
#line 1417
  if (f == 73) {
#line 1417
    tmp___0 = 1;
  } else
#line 1417
  if (f == 4) {
#line 1417
    tmp___0 = 1;
  } else {
#line 1417
    tmp___0 = 0;
  }
#line 1417
  return (tmp___0);
  case_3: /* CIL Label */ 
#line 1419
  return (f == 3);
  case_4: /* CIL Label */ 
#line 1421
  return (f == 1);
  case_5: /* CIL Label */ 
#line 1423
  return (f == 24);
  case_20: /* CIL Label */ 
#line 1425
  return (f == 25);
  switch_default: /* CIL Label */ 
#line 1427
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1429
  return (0);
}
}
#line 1433 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
int PrepareEncodedChar(int c ) 
{ 
  int encoding ;
  int t ;
  int f ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 1438
  t = 0;
#line 1441
  encoding = display->d_encoding;
#line 1442
  f = (int )display->d_rend.font;
#line 1443
  t = display->d_mbcs;
#line 1444
  if (encoding == 2) {
#line 1446
    if (f == 73) {
#line 1447
      return (c | 128);
    } else
#line 1448
    if (f == 2) {
#line 1450
      if (c & 1) {
#line 1450
        if (t <= 95) {
#line 1450
          tmp = 31;
        } else {
#line 1450
          tmp = 32;
        }
#line 1450
        tmp___0 = tmp;
      } else {
#line 1450
        tmp___0 = 126;
      }
#line 1450
      t += tmp___0;
#line 1451
      if (c < 95) {
#line 1451
        tmp___1 = 129;
      } else {
#line 1451
        tmp___1 = 193;
      }
#line 1451
      c = (c - 33) / 2 + tmp___1;
#line 1452
      display->d_mbcs = t;
    }
#line 1454
    return (c);
  }
#line 1456
  if (encoding == 1) {
#line 1458
    if (f == 73) {
      {
#line 1460
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1460
        (display->d_obuffree) --;
#line 1460
        if (display->d_obuffree <= 0) {
          {
#line 1460
          Resize_obuf();
          }
        }
#line 1460
        tmp___2 = display->d_obufp;
#line 1460
        (display->d_obufp) ++;
#line 1460
        *tmp___2 = (char)-114;
#line 1460
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 1461
      return (c | 128);
    }
#line 1463
    if (f == 2) {
#line 1465
      display->d_mbcs = t | 128;
#line 1466
      return (c | 128);
    }
#line 1468
    if (f == 4) {
      {
#line 1470
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1470
        (display->d_obuffree) --;
#line 1470
        if (display->d_obuffree <= 0) {
          {
#line 1470
          Resize_obuf();
          }
        }
#line 1470
        tmp___3 = display->d_obufp;
#line 1470
        (display->d_obufp) ++;
#line 1470
        *tmp___3 = (char)-113;
#line 1470
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1471
      display->d_mbcs = t | 128;
#line 1472
      return (c | 128);
    }
  }
#line 1475
  if (encoding == 3) {
#line 1475
    if (f == 3) {
#line 1477
      display->d_mbcs = t | 128;
#line 1478
      return (c | 128);
    } else {
#line 1475
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1475
  if (encoding == 4) {
#line 1475
    if (f == 1) {
#line 1477
      display->d_mbcs = t | 128;
#line 1478
      return (c | 128);
    }
  }
#line 1480
  if (encoding == 5) {
#line 1480
    if (f == 24) {
#line 1481
      return (c | 128);
    } else {
#line 1480
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1480
  if (encoding == 20) {
#line 1480
    if (f == 25) {
#line 1481
      return (c | 128);
    }
  }
#line 1482
  return (c);
}
}
#line 1486 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
int RecodeBuf(unsigned char *fbuf , int flen , int fenc , int tenc , unsigned char *tbuf ) 
{ 
  int c ;
  int i ;
  int j ;
  int decstate ;
  int font ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 1494
  decstate = 0;
#line 1494
  font = 0;
#line 1496
  j = 0;
#line 1496
  i = j;
  {
#line 1496
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1496
    if (! (i < flen)) {
#line 1496
      goto while_break;
    }
    {
#line 1498
    c = (int )*(fbuf + i);
#line 1499
    c = DecodeChar(c, fenc, & decstate);
    }
#line 1500
    if (c == -2) {
#line 1501
      i --;
    }
#line 1502
    if (c < 0) {
#line 1503
      goto __Cont;
    }
#line 1504
    if (tbuf) {
#line 1504
      tmp = (char *)tbuf + j;
    } else {
#line 1504
      tmp = (char *)0;
    }
    {
#line 1504
    tmp___0 = EncodeChar(tmp, c, tenc, & font);
#line 1504
    j += tmp___0;
    }
    __Cont: /* CIL Label */ 
#line 1496
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1506
  if (tbuf) {
#line 1506
    tmp___1 = (char *)tbuf + j;
  } else {
#line 1506
    tmp___1 = (char *)0;
  }
  {
#line 1506
  tmp___2 = EncodeChar(tmp___1, -1, tenc, & font);
#line 1506
  j += tmp___2;
  }
#line 1507
  return (j);
}
}
#line 1511 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
int ContainsSpecialDeffont(struct mline *ml , int xs , int xe , int encoding ) 
{ 
  unsigned char *f ;
  unsigned char *i ;
  int c ;
  int x ;
  int dx ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  int tmp___1 ;

  {
#line 1520
  if (encoding == 8) {
#line 1521
    return (0);
  } else
#line 1520
  if (encodings[encoding].deffont == 0) {
#line 1521
    return (0);
  }
#line 1522
  i = ml->image + xs;
#line 1523
  f = ml->font + xs;
#line 1524
  dx = (xe - xs) + 1;
  {
#line 1525
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1525
    tmp___1 = dx;
#line 1525
    dx --;
#line 1525
    if (! (tmp___1 > 0)) {
#line 1525
      goto while_break;
    }
#line 1527
    tmp = f;
#line 1527
    f ++;
#line 1527
    if (*tmp) {
#line 1528
      goto while_continue;
    }
    {
#line 1529
    tmp___0 = i;
#line 1529
    i ++;
#line 1529
    c = (int )*tmp___0;
#line 1530
    x = recode_char_to_encoding(c | (encodings[encoding].deffont << 8), 8);
    }
#line 1531
    if (c != x) {
      {
#line 1533
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1533
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1534
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1537
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1537
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1538
  return (0);
}
}
#line 1542 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
int LoadFontTranslation(int font , char *file ) 
{ 
  char buf___0[1024] ;
  char *myfile ;
  FILE *f ;
  int i ;
  int fo ;
  int x ;
  int u ;
  int c ;
  int ok ;
  unsigned short (*p)[2] ;
  unsigned short (*tab)[2] ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1554
  myfile = file;
#line 1555
  if ((unsigned long )myfile == (unsigned long )((char *)0)) {
#line 1557
    if (font == 0) {
#line 1558
      return (-1);
    } else
#line 1557
    if ((unsigned long )screenencodings == (unsigned long )((char *)0)) {
#line 1558
      return (-1);
    }
    {
#line 1559
    tmp = strlen((char const   *)screenencodings);
    }
#line 1559
    if ((unsigned long )tmp > sizeof(buf___0) - 10UL) {
#line 1560
      return (-1);
    }
    {
#line 1561
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%s/%02x",
            screenencodings, font & 255);
#line 1562
    myfile = buf___0;
    }
  }
  {
#line 1564
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1564
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1565
  f = secfopen(myfile, (char *)"r");
  }
#line 1565
  if ((unsigned long )f == (unsigned long )((FILE *)0)) {
#line 1566
    return (-1);
  }
#line 1567
  ok = 0;
#line 1567
  i = ok;
  {
#line 1568
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1570
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1570
      if (! (i < 12)) {
#line 1570
        goto while_break___1;
      }
      {
#line 1571
      tmp___0 = _IO_getc(f);
      }
#line 1571
      if (tmp___0 != (int )*("ScreenI2UTF8" + i)) {
#line 1572
        goto while_break___1;
      }
#line 1570
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1573
    tmp___1 = _IO_getc(f);
    }
#line 1573
    if (tmp___1 != 0) {
#line 1574
      goto while_break___0;
    }
    {
#line 1575
    fo = _IO_getc(f);
    }
#line 1576
    if (fo == -1) {
#line 1577
      goto while_break___0;
    }
#line 1578
    if (font != -1) {
#line 1578
      if (font != fo) {
#line 1579
        goto while_break___0;
      }
    }
    {
#line 1580
    i = _IO_getc(f);
#line 1581
    x = _IO_getc(f);
    }
#line 1582
    if (x == -1) {
#line 1583
      goto while_break___0;
    }
    {
#line 1584
    i = (i << 8) | x;
#line 1585
    _IO_getc(f);
    }
    {
#line 1586
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1586
      x = _IO_getc(f);
      }
#line 1586
      if (x) {
#line 1586
        if (! (x != -1)) {
#line 1586
          goto while_break___2;
        }
      } else {
#line 1586
        goto while_break___2;
      }
      {
#line 1587
      _IO_getc(f);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1588
    tmp___2 = malloc((size_t )(sizeof(*p) * (unsigned long )(i + 1)));
#line 1588
    p = (unsigned short (*)[2])tmp___2;
    }
#line 1588
    if ((unsigned long )p == (unsigned long )((unsigned short (*)[2])0)) {
#line 1589
      goto while_break___0;
    }
#line 1590
    tab = p;
    {
#line 1591
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1591
      if (! (i > 0)) {
#line 1591
        goto while_break___3;
      }
      {
#line 1593
      x = _IO_getc(f);
#line 1594
      tmp___3 = _IO_getc(f);
#line 1594
      x = (x << 8) | tmp___3;
#line 1595
      u = _IO_getc(f);
#line 1596
      c = _IO_getc(f);
#line 1597
      u = (u << 8) | c;
      }
#line 1598
      if (c == -1) {
#line 1599
        goto while_break___3;
      }
#line 1600
      (*p)[0] = (unsigned short )x;
#line 1601
      (*p)[1] = (unsigned short )u;
#line 1602
      p ++;
#line 1603
      i --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1605
    (*p)[0] = (unsigned short)0;
#line 1606
    (*p)[1] = (unsigned short)0;
#line 1607
    if (i) {
      {
#line 1609
      free((void *)tab);
      }
#line 1610
      goto while_break___0;
    } else
#line 1607
    if ((int )(*(tab + 0))[0] & 32768) {
      {
#line 1609
      free((void *)tab);
      }
#line 1610
      goto while_break___0;
    }
#line 1612
    if (recodetabs[fo].tab) {
#line 1612
      if ((recodetabs[fo].flags & 1) != 0) {
        {
#line 1613
        free((void *)recodetabs[fo].tab);
        }
      }
    }
#line 1614
    recodetabs[fo].tab = tab;
#line 1615
    recodetabs[fo].flags = 1;
    {
#line 1616
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1616
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 1617
    c = _IO_getc(f);
    }
#line 1618
    if (c == -1) {
#line 1620
      ok = 1;
#line 1621
      goto while_break___0;
    }
#line 1623
    if (c != 83) {
#line 1624
      goto while_break___0;
    }
#line 1625
    i = 1;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1627
  fclose(f);
  }
#line 1628
  if (font != -1) {
#line 1628
    if ((unsigned long )file == (unsigned long )((char *)0)) {
#line 1628
      if (recodetabs[font].flags == 0) {
#line 1629
        recodetabs[font].flags = 4;
      }
    }
  }
#line 1630
  if (ok) {
#line 1630
    tmp___4 = 0;
  } else {
#line 1630
    tmp___4 = -1;
  }
#line 1630
  return (tmp___4);
}
}
#line 1633 "/home/pronto/abs/test-suite/screen-4.0.2/encoding.c"
void LoadFontTranslationsForEncoding(int encoding ) 
{ 
  char *c ;
  int f ;
  char *tmp ;

  {
  {
#line 1640
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1640
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1641
  c = encodings[encoding].fontlist;
#line 1641
  if ((unsigned long )c != (unsigned long )((char *)0)) {
    {
#line 1642
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1642
      tmp = c;
#line 1642
      c ++;
#line 1642
      f = (int )((unsigned char )*tmp);
#line 1642
      if (! (f != 0)) {
#line 1642
        goto while_break___0;
      }
#line 1643
      if (recodetabs[f].flags == 0) {
        {
#line 1644
        LoadFontTranslation(f, (char *)0);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1645
  f = encodings[encoding].deffont;
#line 1646
  if (f > 0) {
#line 1646
    if (recodetabs[f].flags == 0) {
      {
#line 1647
      LoadFontTranslation(f, (char *)0);
      }
    }
  }
#line 1648
  return;
}
}
#line 99 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 28 "/home/pronto/abs/test-suite/screen-4.0.2/nethack.c"
int nethackflag ;
#line 37 "/home/pronto/abs/test-suite/screen-4.0.2/nethack.c"
static struct nlstrans nethacktrans[39]  = 
#line 37
  {      {(char *)"Cannot lock terminal - fork failed", (char *)"Cannot fork terminal - lock failed"}, 
        {(char *)"Got only %d bytes from %s",
      (char *)"You choke on your food: %d bytes from %s"}, 
        {(char *)"Copy mode - Column %d Line %d(+%d) (%d,%d)", (char *)"Welcome to hacker\'s treasure zoo - Column %d Line %d(+%d) (%d,%d)"}, 
        {(char *)"First mark set - Column %d Line %d",
      (char *)"You drop a magic marker - Column %d Line %d"}, 
        {(char *)"Copy mode aborted", (char *)"You escaped the dungeon."}, 
        {(char *)"Filter removed.", (char *)"You have a sad feeling for a moment..."}, 
        {(char *)"Window %d (%s) killed.",
      (char *)"You destroy poor window %d (%s)."}, 
        {(char *)"Window %d (%s) is now being monitored for all activity.", (char *)"You feel like someone is watching you..."}, 
        {(char *)"Window %d (%s) is no longer being monitored for activity.",
      (char *)"You no longer sense the watcher\'s presence."}, 
        {(char *)"empty buffer", (char *)"Nothing happens."}, 
        {(char *)"switched to audible bell.", (char *)"Suddenly you can\'t see your bell!"}, 
        {(char *)"switched to visual bell.",
      (char *)"Your bell is no longer invisible."}, 
        {(char *)"The window is now being monitored for %d sec. silence.", (char *)"You feel like someone is waiting for %d sec. silence..."}, 
        {(char *)"The window is no longer being monitored for silence.",
      (char *)"You no longer sense the watcher\'s silence."}, 
        {(char *)"No other window.", (char *)"You cannot escape from window %d!"}, 
        {(char *)"Logfile \"%s\" closed.", (char *)"You put away your scroll of logging named \"%s\"."}, 
        {(char *)"Error opening logfile \"%s\"",
      (char *)"You don\'t seem to have a scroll of logging named \"%s\"."}, 
        {(char *)"Creating logfile \"%s\".", (char *)"You start writing on your scroll of logging named \"%s\"."}, 
        {(char *)"Appending to logfile \"%s\".",
      (char *)"You add to your scroll of logging named \"%s\"."}, 
        {(char *)"Detach aborted.", (char *)"The blast of disintegration whizzes by you!"}, 
        {(char *)"Empty register.",
      (char *)"Nothing happens."}, 
        {(char *)"[ Passwords don\'t match - checking turned off ]", (char *)"[ Passwords don\'t match - your armor crumbles away ]"}, 
        {(char *)"Aborted because of window size change.",
      (char *)"KAABLAMM!!!  You triggered a land mine!"}, 
        {(char *)"Out of memory.", (char *)"Who was that Maude person anyway?"}, 
        {(char *)"getpwuid() can\'t identify your account!", (char *)"An alarm sounds through the dungeon...\nThe Keystone Kops are after you!"}, 
        {(char *)"Must be connected to a terminal.",
      (char *)"You must play from a terminal."}, 
        {(char *)"No Sockets found in %s.\n", (char *)"This room is empty (%s).\n"}, 
        {(char *)"New screen...", (char *)"Be careful!  New screen tonight."}, 
        {(char *)"Child has been stopped, restarting.", (char *)"You regain consciousness."}, 
        {(char *)"There are screens on:",
      (char *)"Your inventory:"}, 
        {(char *)"There is a screen on:", (char *)"Your inventory:"}, 
        {(char *)"There are several screens on:", (char *)"Prove thyself worthy or perish:"}, 
        {(char *)"There is a suitable screen on:",
      (char *)"You see here a good looking screen:"}, 
        {(char *)"There are several suitable screens on:", (char *)"You may wish for a screen, what do you want?"}, 
        {(char *)"%d socket%s wiped out.",
      (char *)"You hear %d distant explosion%s."}, 
        {(char *)"Remove dead screens with \'screen -wipe\'.", (char *)"The dead screen%s touch%s you. Try \'screen -wipe\'."}, 
        {(char *)"Illegal reattach attempt from terminal %s.",
      (char *)"\'%s\' tries to touch your session, but fails."}, 
        {(char *)"Could not write %s", (char *)"%s is too hard to dig in"}, 
        {(char *)0, (char *)0}};
#line 118 "/home/pronto/abs/test-suite/screen-4.0.2/nethack.c"
char *DoNLS(char *from ) 
{ 
  struct nlstrans *t ;
  int tmp ;

  {
#line 125
  if (nethackflag) {
#line 127
    t = nethacktrans;
    {
#line 127
    while (1) {
      while_continue: /* CIL Label */ ;
#line 127
      if (! t->from) {
#line 127
        goto while_break;
      }
      {
#line 128
      tmp = strcmp((char const   *)from, (char const   *)t->from);
      }
#line 128
      if (tmp == 0) {
#line 129
        return (t->to);
      }
#line 127
      t ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 132
  return (from);
}
}
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 72 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval * __restrict  __tv ,
                                                      __timezone_ptr_t __tz ) ;
#line 38 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 39 "/home/pronto/abs/test-suite/screen-4.0.2/extern.h"
void ( /* format attribute */  Panic)(int err , char *fmt  , ...) ;
#line 324
void evenq(struct event *ev ) ;
#line 325
void evdeq(struct event *ev ) ;
#line 326
void SetTimeout(struct event *ev , int timo ) ;
#line 327
void sched(void) ;
#line 34 "/home/pronto/abs/test-suite/screen-4.0.2/sched.c"
static struct event *evs  ;
#line 35 "/home/pronto/abs/test-suite/screen-4.0.2/sched.c"
static struct event *tevs  ;
#line 36 "/home/pronto/abs/test-suite/screen-4.0.2/sched.c"
static struct event *nextev  ;
#line 37 "/home/pronto/abs/test-suite/screen-4.0.2/sched.c"
static int calctimeout  ;
#line 39
static struct event *calctimo(void) ;
#line 44 "/home/pronto/abs/test-suite/screen-4.0.2/sched.c"
void evenq(struct event *ev ) 
{ 
  struct event *evp ;
  struct event **evpp ;

  {
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  if (ev->queued) {
#line 51
    return;
  }
#line 52
  evpp = & evs;
#line 53
  if (ev->type == 0) {
#line 55
    calctimeout = 1;
#line 56
    evpp = & tevs;
  }
  {
#line 58
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 58
    evp = *evpp;
#line 58
    if (! evp) {
#line 58
      goto while_break___0;
    }
#line 59
    if (ev->pri > evp->pri) {
#line 60
      goto while_break___0;
    }
#line 58
    evpp = & evp->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 61
  ev->next = evp;
#line 62
  *evpp = ev;
#line 63
  ev->queued = 1;
#line 64
  return;
}
}
#line 66 "/home/pronto/abs/test-suite/screen-4.0.2/sched.c"
void evdeq(struct event *ev ) 
{ 
  struct event *evp ;
  struct event **evpp ;

  {
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  if (! ev->queued) {
#line 73
    return;
  }
#line 74
  evpp = & evs;
#line 75
  if (ev->type == 0) {
#line 77
    calctimeout = 1;
#line 78
    evpp = & tevs;
  }
  {
#line 80
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 80
    evp = *evpp;
#line 80
    if (! evp) {
#line 80
      goto while_break___0;
    }
#line 81
    if ((unsigned long )evp == (unsigned long )ev) {
#line 82
      goto while_break___0;
    }
#line 80
    evpp = & evp->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 83
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 83
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 84
  *evpp = ev->next;
#line 85
  ev->queued = 0;
#line 86
  if ((unsigned long )ev == (unsigned long )nextev) {
#line 87
    nextev = nextev->next;
  }
#line 88
  return;
}
}
#line 90 "/home/pronto/abs/test-suite/screen-4.0.2/sched.c"
static struct event *calctimo(void) 
{ 
  struct event *ev ;
  struct event *min ;
  long mins ;

  {
#line 96
  min = tevs;
#line 96
  if ((unsigned long )min == (unsigned long )((struct event *)0)) {
#line 97
    return ((struct event *)0);
  }
#line 98
  mins = min->timeout.tv_sec;
#line 99
  ev = tevs->next;
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! ev) {
#line 99
      goto while_break;
    }
    {
#line 101
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 101
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 102
    if (mins < ev->timeout.tv_sec) {
#line 103
      goto __Cont;
    }
#line 104
    if (mins > ev->timeout.tv_sec) {
#line 106
      min = ev;
#line 107
      mins = ev->timeout.tv_sec;
    } else
#line 104
    if (min->timeout.tv_usec > ev->timeout.tv_usec) {
#line 106
      min = ev;
#line 107
      mins = ev->timeout.tv_sec;
    }
    __Cont: /* CIL Label */ 
#line 99
    ev = ev->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return (min);
}
}
#line 113 "/home/pronto/abs/test-suite/screen-4.0.2/sched.c"
void sched(void) 
{ 
  struct event *ev ;
  fd_set r ;
  fd_set w ;
  fd_set *set ;
  struct event *timeoutev ;
  struct timeval timeout ;
  int nsel ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int tmp ;
  struct timeval *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  register char __result ;
  int tmp___3 ;

  {
#line 118
  timeoutev = (struct event *)0;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (calctimeout) {
      {
#line 125
      timeoutev = calctimo();
      }
    }
#line 126
    if (timeoutev) {
      {
#line 128
      gettimeofday((struct timeval */* __restrict  */)(& timeout), (__timezone_ptr_t )((void *)0));
#line 130
      timeout.tv_sec = timeoutev->timeout.tv_sec - timeout.tv_sec;
#line 131
      timeout.tv_usec = timeoutev->timeout.tv_usec - timeout.tv_usec;
      }
#line 132
      if (timeout.tv_usec < 0L) {
#line 134
        timeout.tv_usec += 1000000L;
#line 135
        (timeout.tv_sec) --;
      }
#line 137
      if (timeout.tv_sec < 0L) {
#line 139
        timeout.tv_usec = (__suseconds_t )0;
#line 140
        timeout.tv_sec = (__time_t )0;
      }
    }
    {
#line 156
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 156
      __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& r.__fds_bits[0]): "memory");
#line 156
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 157
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 157
      __asm__  volatile   ("cld; rep; stosl": "=c" (__d0___0), "=D" (__d1___0): "a" (0),
                           "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& w.__fds_bits[0]): "memory");
#line 157
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 158
    ev = evs;
    {
#line 158
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 158
      if (! ev) {
#line 158
        goto while_break___2;
      }
#line 160
      if (ev->condpos) {
#line 160
        if (ev->condneg) {
#line 160
          tmp = *(ev->condneg);
        } else {
#line 160
          tmp = 0;
        }
#line 160
        if (*(ev->condpos) <= tmp) {
          {
#line 162
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 162
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 163
          goto __Cont;
        }
      }
#line 165
      if (ev->type == 1) {
#line 166
        __asm__  volatile   ("btsl %1,%0": "=m" (r.__fds_bits[(unsigned long )ev->fd / (8UL * sizeof(__fd_mask ))]): "r" ((unsigned long )ev->fd % (8UL * sizeof(__fd_mask ))): "cc",
                             "memory");
      } else
#line 167
      if (ev->type == 2) {
#line 168
        __asm__  volatile   ("btsl %1,%0": "=m" (w.__fds_bits[(unsigned long )ev->fd / (8UL * sizeof(__fd_mask ))]): "r" ((unsigned long )ev->fd % (8UL * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
      __Cont: /* CIL Label */ 
#line 158
      ev = ev->next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 184
    if (timeoutev) {
#line 184
      tmp___0 = & timeout;
    } else {
#line 184
      tmp___0 = (struct timeval *)0;
    }
    {
#line 184
    nsel = select(1024, (fd_set */* __restrict  */)(& r), (fd_set */* __restrict  */)(& w),
                  (fd_set */* __restrict  */)((fd_set *)0), (struct timeval */* __restrict  */)tmp___0);
    }
#line 185
    if (nsel < 0) {
      {
#line 187
      tmp___2 = __errno_location();
      }
#line 187
      if (*tmp___2 != 4) {
        {
#line 199
        tmp___1 = __errno_location();
#line 199
        Panic(*tmp___1, (char *)"select");
        }
      }
#line 201
      nsel = 0;
    } else
#line 203
    if (nsel == 0) {
      {
#line 205
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 205
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 206
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 206
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 207
      evdeq(timeoutev);
#line 208
      (*(timeoutev->handler))(timeoutev, timeoutev->data);
      }
    }
#line 219
    ev = evs;
    {
#line 219
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 219
      if (! ev) {
#line 219
        goto while_break___6;
      }
#line 221
      nextev = ev->next;
#line 222
      if (ev->type != 3) {
#line 224
        if (ev->type == 1) {
#line 224
          set = & r;
        } else {
#line 224
          set = & w;
        }
#line 225
        if (nsel == 0) {
#line 226
          goto __Cont___0;
        } else {
#line 225
          __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned long )ev->fd % (8UL * sizeof(__fd_mask ))),
                               "m" (set->__fds_bits[(unsigned long )ev->fd / (8UL * sizeof(__fd_mask ))]): "cc");
#line 225
          if (! __result) {
#line 226
            goto __Cont___0;
          }
        }
#line 227
        nsel --;
      }
#line 229
      if (ev->condpos) {
#line 229
        if (ev->condneg) {
#line 229
          tmp___3 = *(ev->condneg);
        } else {
#line 229
          tmp___3 = 0;
        }
#line 229
        if (*(ev->condpos) <= tmp___3) {
#line 230
          goto __Cont___0;
        }
      }
      {
#line 231
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 231
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 232
      (*(ev->handler))(ev, ev->data);
      }
      __Cont___0: /* CIL Label */ 
#line 219
      ev = nextev;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 237 "/home/pronto/abs/test-suite/screen-4.0.2/sched.c"
void SetTimeout(struct event *ev , int timo ) 
{ 


  {
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 243
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 243
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 244
  gettimeofday((struct timeval */* __restrict  */)(& ev->timeout), (__timezone_ptr_t )((void *)0));
#line 245
  ev->timeout.tv_sec += (__time_t )(timo / 1000);
#line 246
  ev->timeout.tv_usec += (__suseconds_t )((timo % 1000) * 1000);
  }
#line 247
  if (ev->timeout.tv_usec > 1000000L) {
#line 249
    ev->timeout.tv_usec -= 1000000L;
#line 250
    (ev->timeout.tv_sec) ++;
  }
#line 252
  if (ev->queued) {
#line 253
    calctimeout = 1;
  }
#line 254
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 355 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 586 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 87 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 256
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 38 "/home/pronto/abs/test-suite/screen-4.0.2/extern.h"
void ( /* format attribute */  Msg)(int err , char *fmt  , ...) ;
#line 48
int PutWinMsg(char *s , int start , int max ) ;
#line 87
void SetFlow(int on ) ;
#line 248
void PUTCHARLP(int c ) ;
#line 250
void ClearArea(int x1 , int y1 , int xs , int xe , int x2 , int y2 , int bce , int uselayfn ) ;
#line 251
void ClearLine(struct mline *oml , int y , int from , int to , int bce ) ;
#line 253
void RefreshArea(int xs , int ys , int xe , int ye , int isblank ) ;
#line 259
void DisplayLine(struct mline *oml , struct mline *ml , int y , int from , int to ) ;
#line 260
void GotoPos(int x2 , int y2 ) ;
#line 262
void ScrollH(int y , int xs , int xe , int n , int bce , struct mline *oml ) ;
#line 263
void ScrollV(int xs , int ys , int xe , int ye , int n , int bce ) ;
#line 264
void PutChar(struct mchar *c , int x , int y ) ;
#line 265
void InsChar(struct mchar *c , int x , int xe , int y , struct mline *oml ) ;
#line 266
void WrapChar(struct mchar *c , int x , int y , int xs , int ys , int xe , int ye ,
              int ins ) ;
#line 269
void KeypadMode(int on ) ;
#line 270
void CursorkeysMode(int on ) ;
#line 272
void CursorVisibility(int v ) ;
#line 273
void MouseMode(int mode ) ;
#line 277
void SetRendition(struct mchar *mc ) ;
#line 279
void MakeStatus(char *msg ) ;
#line 280
void RemoveStatus(void) ;
#line 418
void LGotoPos(struct layer *l , int x , int y ) ;
#line 419
void LPutChar(struct layer *l , struct mchar *c , int x , int y ) ;
#line 420
void LInsChar(struct layer *l , struct mchar *c , int x , int y , struct mline *ol ) ;
#line 421
void LPutStr(struct layer *l , char *s , int n , struct mchar *r , int x , int y ) ;
#line 422
void LPutWinMsg(struct layer *l , char *s , int n , struct mchar *r , int x , int y ) ;
#line 423
void LScrollH(struct layer *l , int n , int y , int xs , int xe , int bce , struct mline *ol ) ;
#line 424
void LScrollV(struct layer *l , int n , int ys , int ye , int bce ) ;
#line 425
void LClearAll(struct layer *l , int uself ) ;
#line 426
void LClearArea(struct layer *l , int xs , int ys , int xe , int ye , int bce , int uself ) ;
#line 427
void LClearLine(struct layer *l , int y , int xs , int xe , int bce , struct mline *ol ) ;
#line 428
void LRefreshAll(struct layer *l , int isblank ) ;
#line 429
void LCDisplayLine(struct layer *l , struct mline *ml , int y , int xs , int xe ,
                   int isblank ) ;
#line 430
void LCDisplayLineWrap(struct layer *l , struct mline *ml , int y , int from , int to ,
                       int isblank ) ;
#line 431
void LSetRendition(struct layer *l , struct mchar *r ) ;
#line 432
void LWrapChar(struct layer *l , struct mchar *c , int y , int top , int bot , int ins ) ;
#line 433
void LCursorVisibility(struct layer *l , int vis ) ;
#line 434
void LSetFlow(struct layer *l , int flow ) ;
#line 435
void LKeypadMode(struct layer *l , int on ) ;
#line 436
void LCursorkeysMode(struct layer *l , int on ) ;
#line 437
void LMouseMode(struct layer *l , int on ) ;
#line 439
void ( /* format attribute */  LMsg)(int err , char *fmt  , ...) ;
#line 443
void KillLayerChain(struct layer *lay ) ;
#line 444
int InitOverlayPage(int datasize , struct LayFuncs *lf , int block ) ;
#line 34 "/home/pronto/abs/test-suite/screen-4.0.2/layer.c"
struct mline mline_blank ;
#line 34
struct mline mline_null ;
#line 35
struct mchar mchar_blank ;
#line 38
struct LayFuncs WinLf ;
#line 39
struct LayFuncs BlankLf ;
#line 42
static struct mline *mloff(struct mline *ml , int off ) ;
#line 58 "/home/pronto/abs/test-suite/screen-4.0.2/layer.c"
static struct mline mml  ;
#line 53 "/home/pronto/abs/test-suite/screen-4.0.2/layer.c"
static struct mline *mloff(struct mline *ml , int off ) 
{ 


  {
#line 60
  if ((unsigned long )ml == (unsigned long )((struct mline *)0)) {
#line 61
    return ((struct mline *)0);
  }
#line 62
  mml.image = ml->image + off;
#line 63
  mml.attr = ml->attr + off;
#line 65
  mml.font = ml->font + off;
#line 68
  mml.color = ml->color + off;
#line 73
  return (& mml);
}
}
#line 85 "/home/pronto/abs/test-suite/screen-4.0.2/layer.c"
void LGotoPos(struct layer *l , int x , int y ) 
{ 
  struct canvas *cv ;
  struct viewport *vp ;
  int x2 ;
  int y2 ;

  {
#line 98
  cv = l->l_cvlist;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! cv) {
#line 98
      goto while_break;
    }
#line 100
    display = cv->c_display;
#line 101
    if (display->d_blocked) {
#line 102
      goto __Cont;
    }
#line 103
    if ((unsigned long )cv != (unsigned long )display->d_forecv) {
#line 104
      goto __Cont;
    }
#line 105
    x2 = x + cv->c_xoff;
#line 106
    y2 = y + cv->c_yoff;
    {
#line 107
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 107
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 108
    if (x2 < cv->c_xs) {
#line 109
      x2 = cv->c_xs;
    }
#line 110
    if (y2 < cv->c_ys) {
#line 111
      y2 = cv->c_ys;
    }
#line 112
    if (x2 > cv->c_xe) {
#line 113
      x2 = cv->c_xe;
    }
#line 114
    if (y2 > cv->c_ye) {
#line 115
      y2 = cv->c_ye;
    }
#line 116
    vp = cv->c_vplist;
    {
#line 116
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 116
      if (! vp) {
#line 116
        goto while_break___1;
      }
#line 118
      if (x2 < vp->v_xs) {
#line 119
        goto __Cont___0;
      } else
#line 118
      if (x2 > vp->v_xe) {
#line 119
        goto __Cont___0;
      }
#line 120
      if (y2 < vp->v_ys) {
#line 121
        goto __Cont___0;
      } else
#line 120
      if (y2 > vp->v_ye) {
#line 121
        goto __Cont___0;
      }
      {
#line 122
      GotoPos(x2, y2);
      }
#line 123
      goto while_break___1;
      __Cont___0: /* CIL Label */ 
#line 116
      vp = vp->v_next;
    }
    while_break___1: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 98
    cv = cv->c_lnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 126
  return;
}
}
#line 128 "/home/pronto/abs/test-suite/screen-4.0.2/layer.c"
void LScrollH(struct layer *l , int n , int y , int xs , int xe , int bce , struct mline *ol ) 
{ 
  struct canvas *cv ;
  struct viewport *vp ;
  int y2 ;
  int xs2 ;
  int xe2 ;
  struct mline *tmp ;
  struct mline *tmp___0 ;

  {
#line 139
  if (n == 0) {
#line 140
    return;
  }
#line 141
  cv = l->l_cvlist;
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! cv) {
#line 141
      goto while_break;
    }
#line 142
    vp = cv->c_vplist;
    {
#line 142
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 142
      if (! vp) {
#line 142
        goto while_break___0;
      }
#line 144
      y2 = y + vp->v_yoff;
#line 145
      if (y2 < vp->v_ys) {
#line 146
        goto __Cont;
      } else
#line 145
      if (y2 > vp->v_ye) {
#line 146
        goto __Cont;
      }
#line 147
      xs2 = xs + vp->v_xoff;
#line 148
      xe2 = xe + vp->v_xoff;
#line 149
      if (xs2 < vp->v_xs) {
#line 150
        xs2 = vp->v_xs;
      }
#line 151
      if (xe2 > vp->v_xe) {
#line 152
        xe2 = vp->v_xe;
      }
#line 153
      if (xs2 > xe2) {
#line 154
        goto __Cont;
      }
#line 155
      display = cv->c_display;
#line 156
      if (display->d_blocked) {
#line 157
        goto __Cont;
      }
#line 158
      if (ol) {
        {
#line 158
        tmp = mloff(ol, - vp->v_xoff);
#line 158
        tmp___0 = tmp;
        }
      } else {
#line 158
        tmp___0 = (struct mline *)0;
      }
      {
#line 158
      ScrollH(y2, xs2, xe2, n, bce, tmp___0);
      }
#line 159
      if (xe2 - xs2 == xe - xs) {
#line 160
        goto __Cont;
      }
#line 161
      if (n > 0) {
#line 163
        xs2 = (xe2 + 1) - n;
#line 164
        xe2 = (xe + vp->v_xoff) - n;
      } else {
#line 168
        xe2 = (xs2 - 1) - n;
#line 169
        xs2 = (xs + vp->v_xoff) - n;
      }
#line 171
      if (xs2 < vp->v_xs) {
#line 172
        xs2 = vp->v_xs;
      }
#line 173
      if (xe2 > vp->v_xe) {
#line 174
        xe2 = vp->v_xe;
      }
#line 175
      if (xs2 <= xe2) {
        {
#line 176
        RefreshArea(xs2, y2, xe2, y2, 1);
        }
      }
      __Cont: /* CIL Label */ 
#line 142
      vp = vp->v_next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 141
    cv = cv->c_lnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 178
  return;
}
}
#line 180 "/home/pronto/abs/test-suite/screen-4.0.2/layer.c"
void LScrollV(struct layer *l , int n , int ys , int ye , int bce ) 
{ 
  struct canvas *cv ;
  struct viewport *vp ;
  int ys2 ;
  int ye2 ;
  int xs2 ;
  int xe2 ;

  {
#line 190
  if (n == 0) {
#line 191
    return;
  }
#line 192
  cv = l->l_cvlist;
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 192
    if (! cv) {
#line 192
      goto while_break;
    }
#line 193
    vp = cv->c_vplist;
    {
#line 193
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 193
      if (! vp) {
#line 193
        goto while_break___0;
      }
#line 195
      xs2 = vp->v_xoff;
#line 196
      xe2 = (l->l_width - 1) + vp->v_xoff;
#line 197
      ys2 = ys + vp->v_yoff;
#line 198
      ye2 = ye + vp->v_yoff;
#line 199
      if (xs2 < vp->v_xs) {
#line 200
        xs2 = vp->v_xs;
      }
#line 201
      if (xe2 > vp->v_xe) {
#line 202
        xe2 = vp->v_xe;
      }
#line 203
      if (ys2 < vp->v_ys) {
#line 204
        ys2 = vp->v_ys;
      }
#line 205
      if (ye2 > vp->v_ye) {
#line 206
        ye2 = vp->v_ye;
      }
#line 207
      if (ys2 > ye2) {
#line 208
        goto __Cont;
      } else
#line 207
      if (xs2 > xe2) {
#line 208
        goto __Cont;
      }
#line 209
      display = cv->c_display;
#line 210
      if (display->d_blocked) {
#line 211
        goto __Cont;
      }
      {
#line 215
      ScrollV(vp->v_xs, ys2, vp->v_xe, ye2, n, bce);
      }
      {
#line 217
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 217
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 218
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 218
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 219
      if (ye2 - ys2 == ye - ys) {
#line 220
        goto __Cont;
      }
#line 221
      if (n > 0) {
#line 223
        ys2 = (ye2 + 1) - n;
#line 224
        ye2 = (ye + vp->v_yoff) - n;
      } else {
#line 228
        ye2 = (ys2 - 1) - n;
#line 229
        ys2 = (ys + vp->v_yoff) - n;
      }
      {
#line 231
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 231
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 232
      if (ys2 < vp->v_ys) {
#line 233
        ys2 = vp->v_ys;
      }
#line 234
      if (ye2 > vp->v_ye) {
#line 235
        ye2 = vp->v_ye;
      }
      {
#line 236
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 236
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 237
      if (ys2 <= ye2) {
        {
#line 238
        RefreshArea(xs2, ys2, xe2, ye2, 1);
        }
      }
      __Cont: /* CIL Label */ 
#line 193
      vp = vp->v_next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 192
    cv = cv->c_lnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 240
  return;
}
}
#line 242 "/home/pronto/abs/test-suite/screen-4.0.2/layer.c"
void LInsChar(struct layer *l , struct mchar *c , int x , int y , struct mline *ol ) 
{ 
  struct canvas *cv ;
  struct viewport *vp ;
  int xs2 ;
  int xe2 ;
  int y2 ;
  int f ;
  struct mchar *c2 ;
  struct mchar cc ;
  struct mline *rol ;
  int i ;
  struct mline *tmp ;
  struct mline *tmp___0 ;
  struct mchar *tmp___1 ;
  struct mchar *tmp___2 ;

  {
#line 255
  cv = l->l_cvlist;
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 255
    if (! cv) {
#line 255
      goto while_break;
    }
#line 256
    vp = cv->c_vplist;
    {
#line 256
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 256
      if (! vp) {
#line 256
        goto while_break___0;
      }
#line 258
      y2 = y + vp->v_yoff;
#line 259
      if (y2 < vp->v_ys) {
#line 260
        goto __Cont;
      } else
#line 259
      if (y2 > vp->v_ye) {
#line 260
        goto __Cont;
      }
#line 261
      xs2 = x + vp->v_xoff;
#line 262
      xe2 = (l->l_width - 1) + vp->v_xoff;
#line 263
      c2 = c;
#line 264
      f = 0;
#line 265
      if (xs2 < vp->v_xs) {
#line 267
        xs2 = vp->v_xs;
#line 268
        c2 = & mchar_blank;
#line 269
        if (ol) {
#line 272
          i = (xs2 - vp->v_xoff) - 1;
#line 273
          if (i >= 0) {
#line 273
            if (i < l->l_width) {
              {
#line 275
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 275
                cc.image = *(ol->image + i);
#line 275
                cc.attr = *(ol->attr + i);
#line 275
                cc.font = *(ol->font + i);
#line 275
                cc.color = *(ol->color + i);
#line 275
                cc.mbcs = (unsigned char)0;
#line 275
                goto while_break___1;
              }
              while_break___1: /* CIL Label */ ;
              }
#line 276
              c2 = & cc;
            }
          }
        } else {
#line 280
          f = 1;
        }
      }
#line 282
      if (xe2 > vp->v_xe) {
#line 283
        xe2 = vp->v_xe;
      }
#line 284
      if (xs2 > xe2) {
#line 285
        goto __Cont;
      }
#line 286
      display = cv->c_display;
#line 287
      if (display->d_blocked) {
#line 288
        goto __Cont;
      }
#line 289
      if ((l->l_encoding == 8) != (display->d_encoding == 8)) {
        {
#line 289
        tmp = recode_mline(ol, l->l_width, l->l_encoding, display->d_encoding);
#line 289
        rol = tmp;
        }
      } else {
#line 289
        rol = ol;
      }
      {
#line 290
      tmp___0 = mloff(rol, - vp->v_xoff);
      }
#line 290
      if ((l->l_encoding == 8) != (display->d_encoding == 8)) {
        {
#line 290
        tmp___1 = recode_mchar(c2, l->l_encoding, display->d_encoding);
#line 290
        tmp___2 = tmp___1;
        }
      } else {
#line 290
        tmp___2 = c2;
      }
      {
#line 290
      InsChar(tmp___2, xs2, xe2, y2, tmp___0);
      }
#line 291
      if (f) {
        {
#line 292
        RefreshArea(xs2, y2, xs2, y2, 1);
        }
      }
      __Cont: /* CIL Label */ 
#line 256
      vp = vp->v_next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 255
    cv = cv->c_lnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 294
  return;
}
}
#line 296 "/home/pronto/abs/test-suite/screen-4.0.2/layer.c"
void LPutChar(struct layer *l , struct mchar *c , int x , int y ) 
{ 
  struct canvas *cv ;
  struct viewport *vp ;
  int x2 ;
  int y2 ;
  struct mchar *tmp ;
  struct mchar *tmp___0 ;

  {
#line 312
  cv = l->l_cvlist;
  {
#line 312
  while (1) {
    while_continue: /* CIL Label */ ;
#line 312
    if (! cv) {
#line 312
      goto while_break;
    }
#line 314
    display = cv->c_display;
#line 315
    if (display->d_blocked) {
#line 316
      goto __Cont;
    }
#line 317
    vp = cv->c_vplist;
    {
#line 317
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 317
      if (! vp) {
#line 317
        goto while_break___0;
      }
#line 319
      y2 = y + vp->v_yoff;
#line 320
      if (y2 < vp->v_ys) {
#line 321
        goto __Cont___0;
      } else
#line 320
      if (y2 > vp->v_ye) {
#line 321
        goto __Cont___0;
      }
#line 322
      x2 = x + vp->v_xoff;
#line 323
      if (x2 < vp->v_xs) {
#line 324
        goto __Cont___0;
      } else
#line 323
      if (x2 > vp->v_xe) {
#line 324
        goto __Cont___0;
      }
#line 325
      if ((l->l_encoding == 8) != (display->d_encoding == 8)) {
        {
#line 325
        tmp = recode_mchar(c, l->l_encoding, display->d_encoding);
#line 325
        tmp___0 = tmp;
        }
      } else {
#line 325
        tmp___0 = c;
      }
      {
#line 325
      PutChar(tmp___0, x2, y2);
      }
#line 326
      goto while_break___0;
      __Cont___0: /* CIL Label */ 
#line 317
      vp = vp->v_next;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 312
    cv = cv->c_lnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 329
  return;
}
}
#line 331 "/home/pronto/abs/test-suite/screen-4.0.2/layer.c"
void LPutStr(struct layer *l , char *s , int n , struct mchar *r , int x , int y ) 
{ 
  struct canvas *cv ;
  struct viewport *vp ;
  char *s2 ;
  int xs2 ;
  int xe2 ;
  int y2 ;
  struct mchar mc ;
  char *tmp ;
  int tmp___0 ;
  struct mchar *tmp___1 ;
  struct mchar *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 344
  if (x + n > l->l_width) {
#line 345
    n = l->l_width - x;
  }
#line 353
  cv = l->l_cvlist;
  {
#line 353
  while (1) {
    while_continue: /* CIL Label */ ;
#line 353
    if (! cv) {
#line 353
      goto while_break;
    }
#line 354
    vp = cv->c_vplist;
    {
#line 354
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 354
      if (! vp) {
#line 354
        goto while_break___0;
      }
#line 356
      y2 = y + vp->v_yoff;
#line 357
      if (y2 < vp->v_ys) {
#line 358
        goto __Cont;
      } else
#line 357
      if (y2 > vp->v_ye) {
#line 358
        goto __Cont;
      }
#line 359
      xs2 = x + vp->v_xoff;
#line 360
      xe2 = (xs2 + n) - 1;
#line 361
      if (xs2 < vp->v_xs) {
#line 362
        xs2 = vp->v_xs;
      }
#line 363
      if (xe2 > vp->v_xe) {
#line 364
        xe2 = vp->v_xe;
      }
#line 365
      if (xs2 > xe2) {
#line 366
        goto __Cont;
      }
#line 367
      display = cv->c_display;
#line 368
      if (display->d_blocked) {
#line 369
        goto __Cont;
      }
      {
#line 370
      GotoPos(xs2, y2);
#line 371
      SetRendition(r);
#line 372
      s2 = ((s + xs2) - x) - vp->v_xoff;
      }
#line 374
      if (display->d_encoding == 8) {
#line 374
        if (l->l_encoding != 8) {
#line 374
          if (r->font) {
#line 374
            goto _L;
          } else
#line 374
          if (l->l_encoding) {
            _L: /* CIL Label */ 
#line 377
            mc = *r;
            {
#line 378
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 378
              if (! (xs2 <= xe2)) {
#line 378
                goto while_break___1;
              }
#line 380
              tmp = s2;
#line 380
              s2 ++;
#line 380
              mc.image = (unsigned char )*tmp;
#line 381
              tmp___0 = xs2;
#line 381
              xs2 ++;
#line 381
              if ((l->l_encoding == 8) != (display->d_encoding == 8)) {
                {
#line 381
                tmp___1 = recode_mchar(& mc, l->l_encoding, display->d_encoding);
#line 381
                tmp___2 = tmp___1;
                }
              } else {
#line 381
                tmp___2 = & mc;
              }
              {
#line 381
              PutChar(tmp___2, tmp___0, y2);
              }
            }
            while_break___1: /* CIL Label */ ;
            }
#line 383
            goto __Cont;
          }
        }
      }
      {
#line 386
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 386
        tmp___4 = xs2;
#line 386
        xs2 ++;
#line 386
        if (! (tmp___4 <= xe2)) {
#line 386
          goto while_break___2;
        }
        {
#line 387
        tmp___3 = s2;
#line 387
        s2 ++;
#line 387
        PUTCHARLP((int )*tmp___3);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      __Cont: /* CIL Label */ 
#line 354
      vp = vp->v_next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 353
    cv = cv->c_lnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 389
  return;
}
}
#line 391 "/home/pronto/abs/test-suite/screen-4.0.2/layer.c"
void LPutWinMsg(struct layer *l , char *s , int n , struct mchar *r , int x , int y ) 
{ 
  struct canvas *cv ;
  struct viewport *vp ;
  char *s2 ;
  int xs2 ;
  int xe2 ;
  int y2 ;
  int len ;
  int len2 ;
  struct mchar or ;
  size_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 405
  if (x + n > l->l_width) {
#line 406
    n = l->l_width - x;
  }
  {
#line 414
  tmp = strlen((char const   *)s);
#line 414
  len = (int )tmp;
  }
#line 415
  if (len > n) {
#line 416
    len = n;
  }
#line 417
  cv = l->l_cvlist;
  {
#line 417
  while (1) {
    while_continue: /* CIL Label */ ;
#line 417
    if (! cv) {
#line 417
      goto while_break;
    }
#line 418
    vp = cv->c_vplist;
    {
#line 418
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 418
      if (! vp) {
#line 418
        goto while_break___0;
      }
#line 420
      y2 = y + vp->v_yoff;
#line 421
      if (y2 < vp->v_ys) {
#line 422
        goto __Cont;
      } else
#line 421
      if (y2 > vp->v_ye) {
#line 422
        goto __Cont;
      }
#line 423
      xs2 = x + vp->v_xoff;
#line 424
      xe2 = (xs2 + n) - 1;
#line 425
      if (xs2 < vp->v_xs) {
#line 426
        xs2 = vp->v_xs;
      }
#line 427
      if (xe2 > vp->v_xe) {
#line 428
        xe2 = vp->v_xe;
      }
#line 429
      if (xs2 > xe2) {
#line 430
        goto __Cont;
      }
#line 431
      display = cv->c_display;
#line 432
      if (display->d_blocked) {
#line 433
        goto __Cont;
      }
      {
#line 434
      GotoPos(xs2, y2);
#line 435
      SetRendition(r);
#line 436
      len2 = (xe2 - (x + vp->v_xoff)) + 1;
      }
#line 437
      if (len2 > len) {
#line 438
        len2 = len;
      }
      {
#line 439
      tmp___2 = PutWinMsg(s, (xs2 - x) - vp->v_xoff, len2);
      }
#line 439
      if (tmp___2) {
#line 449
        xs2 = (x + vp->v_xoff) + len2;
      } else {
#line 441
        s2 = ((s + xs2) - x) - vp->v_xoff;
        {
#line 442
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 442
          tmp___1 = len2;
#line 442
          len2 --;
#line 442
          if (! (tmp___1 > 0)) {
#line 442
            goto while_break___1;
          }
          {
#line 444
          tmp___0 = s2;
#line 444
          s2 ++;
#line 444
          PUTCHARLP((int )*tmp___0);
#line 445
          xs2 ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 450
      if (xs2 < vp->v_xs) {
#line 451
        xs2 = vp->v_xs;
      }
      {
#line 452
      or = display->d_rend;
#line 453
      GotoPos(xs2, y2);
#line 454
      SetRendition(& or);
      }
      {
#line 455
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 455
        tmp___3 = xs2;
#line 455
        xs2 ++;
#line 455
        if (! (tmp___3 <= xe2)) {
#line 455
          goto while_break___2;
        }
        {
#line 456
        PUTCHARLP(' ');
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      __Cont: /* CIL Label */ 
#line 418
      vp = vp->v_next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 417
    cv = cv->c_lnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 458
  return;
}
}
#line 460 "/home/pronto/abs/test-suite/screen-4.0.2/layer.c"
void LClearLine(struct layer *l , int y , int xs , int xe , int bce , struct mline *ol ) 
{ 
  struct canvas *cv ;
  struct viewport *vp ;
  int y2 ;
  int xs2 ;
  int xe2 ;
  struct mline *tmp ;
  struct mline *tmp___0 ;
  struct mline *tmp___1 ;
  struct mline *tmp___2 ;

  {
#line 471
  if (xs >= l->l_width) {
#line 472
    xs = l->l_width - 1;
  }
#line 473
  if (xe >= l->l_width) {
#line 474
    xe = l->l_width - 1;
  }
#line 475
  cv = l->l_cvlist;
  {
#line 475
  while (1) {
    while_continue: /* CIL Label */ ;
#line 475
    if (! cv) {
#line 475
      goto while_break;
    }
#line 476
    vp = cv->c_vplist;
    {
#line 476
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 476
      if (! vp) {
#line 476
        goto while_break___0;
      }
#line 478
      xs2 = xs + vp->v_xoff;
#line 479
      xe2 = xe + vp->v_xoff;
#line 480
      y2 = y + vp->v_yoff;
#line 481
      if (y2 < vp->v_ys) {
#line 482
        goto __Cont;
      } else
#line 481
      if (y2 > vp->v_ye) {
#line 482
        goto __Cont;
      }
#line 483
      if (xs2 < vp->v_xs) {
#line 484
        xs2 = vp->v_xs;
      }
#line 485
      if (xe2 > vp->v_xe) {
#line 486
        xe2 = vp->v_xe;
      }
#line 487
      if (xs2 > xe2) {
#line 488
        goto __Cont;
      }
#line 489
      display = cv->c_display;
#line 490
      if (display->d_blocked) {
#line 491
        goto __Cont;
      }
#line 492
      if (ol) {
#line 492
        if ((l->l_encoding == 8) != (display->d_encoding == 8)) {
          {
#line 492
          tmp = recode_mline(ol, l->l_width, l->l_encoding, display->d_encoding);
#line 492
          tmp___0 = tmp;
          }
        } else {
#line 492
          tmp___0 = ol;
        }
        {
#line 492
        tmp___1 = mloff(tmp___0, - vp->v_xoff);
#line 492
        tmp___2 = tmp___1;
        }
      } else {
#line 492
        tmp___2 = (struct mline *)0;
      }
      {
#line 492
      ClearLine(tmp___2, y2, xs2, xe2, bce);
      }
      __Cont: /* CIL Label */ 
#line 476
      vp = vp->v_next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 475
    cv = cv->c_lnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 494
  return;
}
}
#line 496 "/home/pronto/abs/test-suite/screen-4.0.2/layer.c"
void LClearArea(struct layer *l , int xs , int ys , int xe , int ye , int bce , int uself ) 
{ 
  struct canvas *cv ;
  struct viewport *vp ;
  int xs2 ;
  int ys2 ;
  int xe2 ;
  int ye2 ;

  {
#line 511
  if (xs >= l->l_width) {
#line 512
    xs = l->l_width - 1;
  }
#line 513
  if (xe >= l->l_width) {
#line 514
    xe = l->l_width - 1;
  }
#line 515
  cv = l->l_cvlist;
  {
#line 515
  while (1) {
    while_continue: /* CIL Label */ ;
#line 515
    if (! cv) {
#line 515
      goto while_break;
    }
#line 517
    display = cv->c_display;
#line 518
    if (display->d_blocked) {
#line 519
      goto __Cont;
    }
#line 520
    vp = cv->c_vplist;
    {
#line 520
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 520
      if (! vp) {
#line 520
        goto while_break___0;
      }
#line 522
      xs2 = xs + vp->v_xoff;
#line 523
      xe2 = xe + vp->v_xoff;
#line 524
      ys2 = ys + vp->v_yoff;
#line 525
      ye2 = ye + vp->v_yoff;
#line 526
      if (xs2 < vp->v_xs) {
#line 527
        xs2 = vp->v_xs;
      }
#line 528
      if (xe2 > vp->v_xe) {
#line 529
        xe2 = vp->v_xe;
      }
#line 530
      if (xs2 > vp->v_xe) {
#line 531
        ys2 ++;
      }
#line 532
      if (xe2 < vp->v_xs) {
#line 533
        ye2 --;
      }
#line 534
      if (ys2 < vp->v_ys) {
#line 535
        ys2 = vp->v_ys;
      }
#line 536
      if (ye2 > vp->v_ye) {
#line 537
        ye2 = vp->v_ye;
      }
#line 538
      if (ys2 > ye2) {
#line 539
        goto __Cont___0;
      }
#line 556
      if (xs == 0) {
#line 557
        xs2 = vp->v_xs;
      } else
#line 556
      if (ys2 != ys + vp->v_yoff) {
#line 557
        xs2 = vp->v_xs;
      }
#line 558
      if (xe == l->l_width - 1) {
#line 559
        xe2 = vp->v_xe;
      } else
#line 558
      if (ye2 != ye + vp->v_yoff) {
#line 559
        xe2 = vp->v_xe;
      }
      {
#line 560
      display = cv->c_display;
#line 561
      ClearArea(xs2, ys2, vp->v_xs, vp->v_xe, xe2, ye2, bce, uself);
      }
      __Cont___0: /* CIL Label */ 
#line 520
      vp = vp->v_next;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 515
    cv = cv->c_lnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 565
  return;
}
}
#line 567 "/home/pronto/abs/test-suite/screen-4.0.2/layer.c"
void LCDisplayLine(struct layer *l , struct mline *ml , int y , int xs , int xe ,
                   int isblank ) 
{ 
  struct canvas *cv ;
  struct viewport *vp ;
  int xs2 ;
  int xe2 ;
  int y2 ;
  struct mline *tmp ;
  struct mline *tmp___0 ;
  struct mline *tmp___1 ;
  struct mline *tmp___2 ;

  {
#line 584
  cv = l->l_cvlist;
  {
#line 584
  while (1) {
    while_continue: /* CIL Label */ ;
#line 584
    if (! cv) {
#line 584
      goto while_break;
    }
#line 586
    display = cv->c_display;
#line 587
    if (display->d_blocked) {
#line 588
      goto __Cont;
    }
#line 589
    vp = cv->c_vplist;
    {
#line 589
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 589
      if (! vp) {
#line 589
        goto while_break___0;
      }
#line 591
      xs2 = xs + vp->v_xoff;
#line 592
      xe2 = xe + vp->v_xoff;
#line 593
      y2 = y + vp->v_yoff;
#line 594
      if (y2 < vp->v_ys) {
#line 595
        goto __Cont___0;
      } else
#line 594
      if (y2 > vp->v_ye) {
#line 595
        goto __Cont___0;
      }
#line 596
      if (xs2 < vp->v_xs) {
#line 597
        xs2 = vp->v_xs;
      }
#line 598
      if (xe2 > vp->v_xe) {
#line 599
        xe2 = vp->v_xe;
      }
#line 600
      if (xs2 > xe2) {
#line 601
        goto __Cont___0;
      }
#line 602
      display = cv->c_display;
      {
#line 603
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 603
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 604
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 604
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 605
      if ((l->l_encoding == 8) != (display->d_encoding == 8)) {
        {
#line 605
        tmp = recode_mline(ml, l->l_width, l->l_encoding, display->d_encoding);
#line 605
        tmp___0 = tmp;
        }
      } else {
#line 605
        tmp___0 = ml;
      }
      {
#line 605
      tmp___1 = mloff(tmp___0, - vp->v_xoff);
      }
#line 605
      if (isblank) {
#line 605
        tmp___2 = & mline_blank;
      } else {
#line 605
        tmp___2 = & mline_null;
      }
      {
#line 605
      DisplayLine(tmp___2, tmp___1, y2, xs2, xe2);
      }
      __Cont___0: /* CIL Label */ 
#line 589
      vp = vp->v_next;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 584
    cv = cv->c_lnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 608
  return;
}
}
#line 610 "/home/pronto/abs/test-suite/screen-4.0.2/layer.c"
void LCDisplayLineWrap(struct layer *l , struct mline *ml , int y , int from , int to ,
                       int isblank ) 
{ 
  struct mchar nc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 618
  while (1) {
    while_continue: /* CIL Label */ ;
#line 618
    nc.image = *(ml->image + 0);
#line 618
    nc.attr = *(ml->attr + 0);
#line 618
    nc.font = *(ml->font + 0);
#line 618
    nc.color = *(ml->color + 0);
#line 618
    nc.mbcs = (unsigned char)0;
#line 618
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 620
  if (l->l_encoding == 8) {
#line 620
    if ((int )*(ml->font + 1) == 255) {
#line 620
      if ((int )*(ml->image + 1) == 255) {
#line 620
        tmp = 1;
      } else {
#line 620
        tmp = 0;
      }
    } else {
#line 620
      tmp = 0;
    }
#line 620
    tmp___1 = tmp;
  } else {
#line 620
    if (((int )*(ml->font + 0) & 31) != 0) {
#line 620
      if (((int )*(ml->font + 0) & 224) == 0) {
#line 620
        tmp___0 = 1;
      } else {
#line 620
        tmp___0 = 0;
      }
    } else {
#line 620
      tmp___0 = 0;
    }
#line 620
    tmp___1 = tmp___0;
  }
#line 620
  if (tmp___1) {
#line 622
    nc.mbcs = *(ml->image + 1);
#line 623
    from ++;
  }
  {
#line 626
  LWrapChar(l, & nc, y - 1, -1, -1, 0);
#line 627
  from ++;
  }
#line 628
  if (from <= to) {
    {
#line 629
    LCDisplayLine(l, ml, y, from, to, isblank);
    }
  }
#line 630
  return;
}
}
#line 632 "/home/pronto/abs/test-suite/screen-4.0.2/layer.c"
void LSetRendition(struct layer *l , struct mchar *r ) 
{ 
  struct canvas *cv ;

  {
#line 639
  cv = l->l_cvlist;
  {
#line 639
  while (1) {
    while_continue: /* CIL Label */ ;
#line 639
    if (! cv) {
#line 639
      goto while_break;
    }
#line 641
    display = cv->c_display;
#line 642
    if (display->d_blocked) {
#line 643
      goto __Cont;
    }
    {
#line 644
    SetRendition(r);
    }
    __Cont: /* CIL Label */ 
#line 639
    cv = cv->c_lnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 646
  return;
}
}
#line 648 "/home/pronto/abs/test-suite/screen-4.0.2/layer.c"
void LWrapChar(struct layer *l , struct mchar *c , int y , int top , int bot , int ins ) 
{ 
  struct canvas *cv ;
  struct canvas *cvlist ;
  struct canvas *cvlnext ;
  struct viewport *vp ;
  struct viewport *evp ;
  struct viewport **vpp ;
  int yy ;
  int y2 ;
  int yy2 ;
  int top2 ;
  int bot2 ;
  int bce ;
  int tmp ;
  struct mchar *tmp___0 ;
  struct mchar *tmp___1 ;
  struct mchar *tmp___2 ;
  struct mchar *tmp___3 ;

  {
#line 661
  if ((int )c->attr & (1 << 7)) {
#line 661
    tmp = 256;
  } else {
#line 661
    tmp = 0;
  }
#line 661
  bce = (((int )c->color & 240) >> 4) | tmp;
#line 665
  if (y != bot) {
#line 670
    if (y == l->l_height - 1) {
#line 670
      yy = y;
    } else {
#line 670
      yy = y + 1;
    }
#line 672
    cv = l->l_cvlist;
    {
#line 672
    while (1) {
      while_continue: /* CIL Label */ ;
#line 672
      if (! cv) {
#line 672
        goto while_break;
      }
#line 674
      y2 = 0;
#line 675
      display = cv->c_display;
#line 676
      if (display->d_blocked) {
#line 677
        goto __Cont;
      }
#line 679
      vp = cv->c_vplist;
      {
#line 679
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 679
        if (! vp) {
#line 679
          goto while_break___0;
        }
#line 681
        y2 = y + vp->v_yoff;
#line 682
        yy2 = yy + vp->v_yoff;
#line 683
        if (yy2 >= vp->v_ys) {
#line 683
          if (yy2 <= vp->v_ye) {
#line 683
            if (vp->v_xoff >= vp->v_xs) {
#line 683
              if (vp->v_xoff <= vp->v_xe) {
#line 684
                goto while_break___0;
              }
            }
          }
        }
#line 679
        vp = vp->v_next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 686
      if ((unsigned long )vp == (unsigned long )((struct viewport *)0)) {
#line 687
        goto __Cont;
      }
#line 689
      evp = cv->c_vplist;
      {
#line 689
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 689
        if (! evp) {
#line 689
          goto while_break___1;
        }
#line 690
        if (y2 >= evp->v_ys) {
#line 690
          if (y2 <= evp->v_ye) {
#line 690
            if ((evp->v_xoff + l->l_width) - 1 >= evp->v_xs) {
#line 690
              if ((evp->v_xoff + l->l_width) - 1 <= evp->v_xe) {
#line 691
                goto while_break___1;
              }
            }
          }
        }
#line 689
        evp = evp->v_next;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 692
      if ((unsigned long )evp == (unsigned long )((struct viewport *)0)) {
#line 692
        goto _L;
      } else
#line 692
      if (ins) {
#line 692
        if ((vp->v_xoff + l->l_width) - 1 > vp->v_ye) {
          _L: /* CIL Label */ 
          {
#line 695
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 695
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 696
          cvlist = l->l_cvlist;
#line 697
          cvlnext = cv->c_lnext;
#line 698
          l->l_cvlist = cv;
#line 699
          cv->c_lnext = (struct canvas *)0;
#line 700
          if (ins) {
            {
#line 701
            LInsChar(l, c, 0, yy, (struct mline *)0);
            }
          } else {
            {
#line 703
            LPutChar(l, c, 0, yy);
            }
          }
#line 704
          l->l_cvlist = cvlist;
#line 705
          cv->c_lnext = cvlnext;
        } else {
#line 692
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 709
        if ((l->l_encoding == 8) != (display->d_encoding == 8)) {
          {
#line 709
          tmp___0 = recode_mchar(c, l->l_encoding, display->d_encoding);
#line 709
          tmp___1 = tmp___0;
          }
        } else {
#line 709
          tmp___1 = c;
        }
        {
#line 709
        WrapChar(tmp___1, vp->v_xoff + l->l_width, y2, vp->v_xoff, -1, (vp->v_xoff + l->l_width) - 1,
                 -1, ins);
        }
      }
      __Cont: /* CIL Label */ 
#line 672
      cv = cv->c_lnext;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 717
    cv = l->l_cvlist;
    {
#line 717
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 717
      if (! cv) {
#line 717
        goto while_break___3;
      }
#line 719
      display = cv->c_display;
#line 720
      if (display->d_blocked) {
#line 721
        goto __Cont___0;
      }
#line 723
      vpp = & cv->c_vplist;
      {
#line 723
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 723
        vp = *vpp;
#line 723
        if (! vp) {
#line 723
          goto while_break___4;
        }
#line 725
        yy2 = bot + vp->v_yoff;
#line 726
        if (yy2 >= vp->v_ys) {
#line 726
          if (yy2 <= vp->v_ye) {
#line 726
            if (vp->v_xoff >= vp->v_xs) {
#line 726
              if ((vp->v_xoff + l->l_width) - 1 <= vp->v_xe) {
#line 727
                goto while_break___4;
              }
            }
          }
        }
#line 723
        vpp = & vp->v_next;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 730
      if (vp) {
#line 734
        *vpp = vp->v_next;
      }
#line 736
      if (cv->c_vplist) {
        {
#line 739
        cvlist = l->l_cvlist;
#line 740
        cvlnext = cv->c_lnext;
#line 741
        l->l_cvlist = cv;
#line 742
        cv->c_lnext = (struct canvas *)0;
#line 743
        LScrollV(l, 1, top, bot, bce);
        }
#line 744
        if (! vp) {
#line 746
          if (ins) {
            {
#line 747
            LInsChar(l, c, 0, bot, (struct mline *)0);
            }
          } else {
            {
#line 749
            LPutChar(l, c, 0, bot);
            }
          }
        }
#line 751
        l->l_cvlist = cvlist;
#line 752
        cv->c_lnext = cvlnext;
      }
#line 754
      if (vp) {
#line 757
        *vpp = vp;
#line 758
        top2 = top + vp->v_yoff;
#line 759
        bot2 = bot + vp->v_yoff;
#line 760
        if (top2 < vp->v_ys) {
#line 761
          top2 = vp->v_ys;
        }
#line 762
        if ((l->l_encoding == 8) != (display->d_encoding == 8)) {
          {
#line 762
          tmp___2 = recode_mchar(c, l->l_encoding, display->d_encoding);
#line 762
          tmp___3 = tmp___2;
          }
        } else {
#line 762
          tmp___3 = c;
        }
        {
#line 762
        WrapChar(tmp___3, vp->v_xoff + l->l_width, bot2, vp->v_xoff, top2, (vp->v_xoff + l->l_width) - 1,
                 bot2, ins);
        }
      }
      __Cont___0: /* CIL Label */ 
#line 717
      cv = cv->c_lnext;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 766
  return;
}
}
#line 769 "/home/pronto/abs/test-suite/screen-4.0.2/layer.c"
void LCursorVisibility(struct layer *l , int vis ) 
{ 
  struct canvas *cv ;

  {
#line 775
  cv = l->l_cvlist;
  {
#line 775
  while (1) {
    while_continue: /* CIL Label */ ;
#line 775
    if (! cv) {
#line 775
      goto while_break;
    }
#line 777
    display = cv->c_display;
#line 778
    if (display->d_blocked) {
#line 779
      goto __Cont;
    }
#line 780
    if ((unsigned long )cv != (unsigned long )display->d_forecv) {
#line 781
      goto __Cont;
    }
    {
#line 782
    CursorVisibility(vis);
    }
    __Cont: /* CIL Label */ 
#line 775
    cv = cv->c_lnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 784
  return;
}
}
#line 786 "/home/pronto/abs/test-suite/screen-4.0.2/layer.c"
void LSetFlow(struct layer *l , int flow ) 
{ 
  struct canvas *cv ;

  {
#line 792
  cv = l->l_cvlist;
  {
#line 792
  while (1) {
    while_continue: /* CIL Label */ ;
#line 792
    if (! cv) {
#line 792
      goto while_break;
    }
#line 794
    display = cv->c_display;
#line 795
    if ((unsigned long )cv != (unsigned long )display->d_forecv) {
#line 796
      goto __Cont;
    }
    {
#line 797
    SetFlow(flow);
    }
    __Cont: /* CIL Label */ 
#line 792
    cv = cv->c_lnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 799
  return;
}
}
#line 801 "/home/pronto/abs/test-suite/screen-4.0.2/layer.c"
void LKeypadMode(struct layer *l , int on ) 
{ 
  struct canvas *cv ;

  {
#line 807
  cv = l->l_cvlist;
  {
#line 807
  while (1) {
    while_continue: /* CIL Label */ ;
#line 807
    if (! cv) {
#line 807
      goto while_break;
    }
#line 809
    display = cv->c_display;
#line 810
    if (display->d_blocked) {
#line 811
      goto __Cont;
    }
#line 812
    if ((unsigned long )cv != (unsigned long )display->d_forecv) {
#line 813
      goto __Cont;
    }
    {
#line 814
    KeypadMode(on);
    }
    __Cont: /* CIL Label */ 
#line 807
    cv = cv->c_lnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 816
  return;
}
}
#line 818 "/home/pronto/abs/test-suite/screen-4.0.2/layer.c"
void LCursorkeysMode(struct layer *l , int on ) 
{ 
  struct canvas *cv ;

  {
#line 824
  cv = l->l_cvlist;
  {
#line 824
  while (1) {
    while_continue: /* CIL Label */ ;
#line 824
    if (! cv) {
#line 824
      goto while_break;
    }
#line 826
    display = cv->c_display;
#line 827
    if (display->d_blocked) {
#line 828
      goto __Cont;
    }
#line 829
    if ((unsigned long )cv != (unsigned long )display->d_forecv) {
#line 830
      goto __Cont;
    }
    {
#line 831
    CursorkeysMode(on);
    }
    __Cont: /* CIL Label */ 
#line 824
    cv = cv->c_lnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 833
  return;
}
}
#line 835 "/home/pronto/abs/test-suite/screen-4.0.2/layer.c"
void LMouseMode(struct layer *l , int on ) 
{ 
  struct canvas *cv ;

  {
#line 841
  cv = l->l_cvlist;
  {
#line 841
  while (1) {
    while_continue: /* CIL Label */ ;
#line 841
    if (! cv) {
#line 841
      goto while_break;
    }
#line 843
    display = cv->c_display;
#line 844
    if (display->d_blocked) {
#line 845
      goto __Cont;
    }
#line 846
    if ((unsigned long )cv != (unsigned long )display->d_forecv) {
#line 847
      goto __Cont;
    }
    {
#line 848
    MouseMode(on);
    }
    __Cont: /* CIL Label */ 
#line 841
    cv = cv->c_lnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 850
  return;
}
}
#line 855 "/home/pronto/abs/test-suite/screen-4.0.2/layer.c"
void LClearAll(struct layer *l , int uself ) 
{ 


  {
  {
#line 860
  LClearArea(l, 0, 0, l->l_width - 1, l->l_height - 1, 0, uself);
  }
#line 861
  return;
}
}
#line 863 "/home/pronto/abs/test-suite/screen-4.0.2/layer.c"
void LRefreshAll(struct layer *l , int isblank ) 
{ 
  struct layer *oldflayer ;
  int y ;

  {
  {
#line 871
  while (1) {
    while_continue: /* CIL Label */ ;
#line 871
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 872
  oldflayer = flayer;
#line 873
  flayer = l;
#line 874
  if (! isblank) {
    {
#line 875
    LClearArea(l, 0, 0, l->l_width - 1, l->l_height - 1, 0, 0);
    }
  }
  {
#line 877
  (*((flayer->l_layfn)->lf_LayRedisplayLine))(-1, -1, -1, 1);
#line 878
  y = 0;
  }
  {
#line 878
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 878
    if (! (y < l->l_height)) {
#line 878
      goto while_break___0;
    }
    {
#line 879
    (*((flayer->l_layfn)->lf_LayRedisplayLine))(y, 0, l->l_width - 1, 1);
#line 878
    y ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 880
  flayer = oldflayer;
#line 881
  return;
}
}
#line 884 "/home/pronto/abs/test-suite/screen-4.0.2/layer.c"
void KillLayerChain(struct layer *lay ) 
{ 
  struct canvas *cv ;
  struct canvas *ncv ;
  struct layer *l ;
  struct layer *oldflayer ;

  {
#line 891
  oldflayer = flayer;
  {
#line 892
  while (1) {
    while_continue: /* CIL Label */ ;
#line 892
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 893
  l = lay;
  {
#line 893
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 893
    if (! l) {
#line 893
      goto while_break___0;
    }
#line 895
    if ((unsigned long )l->l_layfn == (unsigned long )(& WinLf)) {
#line 896
      goto while_break___0;
    } else
#line 895
    if ((unsigned long )l->l_layfn == (unsigned long )(& BlankLf)) {
#line 896
      goto while_break___0;
    }
    {
#line 897
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 897
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 898
    if ((unsigned long )oldflayer == (unsigned long )l) {
#line 899
      oldflayer = (struct layer *)0;
    }
#line 900
    cv = l->l_cvlist;
    {
#line 900
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 900
      if (! cv) {
#line 900
        goto while_break___2;
      }
#line 902
      ncv = cv->c_lnext;
#line 903
      cv->c_layer = (struct layer *)0;
#line 904
      cv->c_lnext = (struct canvas *)0;
#line 900
      cv = ncv;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 893
    l = l->l_next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 907
  flayer = lay;
  {
#line 908
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 908
    if (! ((unsigned long )flayer != (unsigned long )l)) {
#line 908
      goto while_break___3;
    }
    {
#line 909
    ExitOverlayPage();
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 910
  flayer = oldflayer;
#line 911
  return;
}
}
#line 921 "/home/pronto/abs/test-suite/screen-4.0.2/layer.c"
int InitOverlayPage(int datasize , struct LayFuncs *lf , int block ) 
{ 
  char *data ;
  struct layer *newlay ;
  struct canvas *cv ;
  struct canvas *cvp ;
  struct canvas **cvpp ;
  struct win *p ;
  void *tmp ;
  void *tmp___0 ;
  struct display *olddisplay ;
  struct display *olddisplay___0 ;
  struct canvas *cv___0 ;

  {
  {
#line 932
  while (1) {
    while_continue: /* CIL Label */ ;
#line 932
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 934
  cv = (struct canvas *)0;
#line 935
  if (display) {
#line 935
    if ((unsigned long )(display->d_forecv)->c_layer == (unsigned long )flayer) {
#line 936
      cv = display->d_forecv;
    }
  }
  {
#line 938
  tmp = calloc((size_t )1, (size_t )sizeof(struct layer ));
#line 938
  newlay = (struct layer *)tmp;
  }
#line 938
  if ((unsigned long )newlay == (unsigned long )((struct layer *)0)) {
    {
#line 940
    Msg(0, (char *)"No memory for layer struct");
    }
#line 941
    return (-1);
  }
  {
#line 943
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 943
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 944
  data = (char *)0;
#line 945
  if (datasize) {
    {
#line 947
    tmp___0 = malloc((size_t )datasize);
#line 947
    data = (char *)tmp___0;
    }
#line 947
    if ((unsigned long )data == (unsigned long )((char *)0)) {
      {
#line 949
      free((void *)((char *)newlay));
#line 950
      Msg(0, (char *)"No memory for layer data");
      }
#line 951
      return (-1);
    }
    {
#line 953
    bzero((void *)data, (size_t )datasize);
    }
  }
#line 956
  p = (struct win *)(flayer->l_bottom)->l_data;
#line 958
  if (p) {
#line 958
    if ((unsigned long )p->w_savelayer == (unsigned long )flayer) {
#line 958
      goto _L;
    } else
#line 958
    if (block) {
#line 958
      if ((unsigned long )flayer->l_next == (unsigned long )((struct layer *)0)) {
        _L: /* CIL Label */ 
#line 960
        if (p->w_savelayer) {
#line 960
          if ((unsigned long )p->w_savelayer != (unsigned long )flayer) {
#line 960
            if ((unsigned long )(p->w_savelayer)->l_cvlist == (unsigned long )((struct canvas *)0)) {
              {
#line 961
              KillLayerChain(p->w_savelayer);
              }
            }
          }
        }
#line 962
        p->w_savelayer = newlay;
      }
    }
  }
#line 965
  if (cv) {
#line 965
    if ((unsigned long )flayer->l_next == (unsigned long )((struct layer *)0)) {
#line 965
      if (! block) {
        {
#line 967
        olddisplay = display;
#line 968
        display = cv->c_display;
#line 969
        RemoveStatus();
#line 970
        display = olddisplay;
#line 973
        cvpp = & flayer->l_cvlist;
        }
        {
#line 973
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 973
          cvp = *cvpp;
#line 973
          if (! cvp) {
#line 973
            goto while_break___1;
          }
#line 974
          if ((unsigned long )cvp == (unsigned long )cv) {
#line 975
            goto while_break___1;
          }
#line 973
          cvpp = & cvp->c_lnext;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 976
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 976
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 977
        *cvpp = cv->c_lnext;
#line 978
        newlay->l_cvlist = cv;
#line 979
        cv->c_lnext = (struct canvas *)0;
#line 980
        cv->c_layer = newlay;
      } else {
#line 965
        goto _L___1;
      }
    } else {
#line 965
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    {
#line 984
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 984
      olddisplay___0 = display;
#line 984
      display = displays;
      {
#line 984
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 984
        if (! display) {
#line 984
          goto while_break___4;
        }
#line 984
        cv___0 = display->d_cvlist;
        {
#line 984
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 984
          if (! cv___0) {
#line 984
            goto while_break___5;
          }
#line 984
          if ((unsigned long )cv___0->c_layer == (unsigned long )flayer) {
#line 984
            goto while_break___5;
          }
#line 984
          cv___0 = cv___0->c_next;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 984
        if ((unsigned long )cv___0 == (unsigned long )((struct canvas *)0)) {
#line 984
          goto __Cont;
        }
        {
#line 984
        RemoveStatus();
        }
        __Cont: /* CIL Label */ 
#line 984
        display = display->d_next;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 984
      display = olddisplay___0;
#line 984
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 985
    if (block) {
      {
#line 986
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 986
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 987
    if (block) {
#line 987
      if ((unsigned long )flayer->l_layfn == (unsigned long )(& WinLf)) {
        {
#line 989
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 989
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 990
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 990
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 991
        (p->w_blocked) ++;
#line 992
        newlay->l_blocking = 1;
      }
    }
#line 995
    newlay->l_cvlist = flayer->l_cvlist;
#line 996
    cvp = newlay->l_cvlist;
    {
#line 996
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 996
      if (! cvp) {
#line 996
        goto while_break___9;
      }
#line 997
      cvp->c_layer = newlay;
#line 996
      cvp = cvp->c_lnext;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 998
    flayer->l_cvlist = (struct canvas *)0;
  }
  {
#line 1000
  newlay->l_width = flayer->l_width;
#line 1001
  newlay->l_height = flayer->l_height;
#line 1002
  newlay->l_encoding = 0;
#line 1003
  newlay->l_layfn = lf;
#line 1004
  newlay->l_data = data;
#line 1005
  newlay->l_next = flayer;
#line 1006
  newlay->l_bottom = flayer->l_bottom;
#line 1007
  flayer = newlay;
#line 1008
  (*((flayer->l_layfn)->lf_LayRestore))();
  }
#line 1009
  return (0);
}
}
#line 1012 "/home/pronto/abs/test-suite/screen-4.0.2/layer.c"
void ExitOverlayPage(void) 
{ 
  struct layer *oldlay ;
  struct win *p ;
  int doredisplay ;
  struct canvas *cv ;
  struct canvas *ocv ;

  {
#line 1017
  doredisplay = 0;
  {
#line 1020
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1020
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1021
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1021
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1022
  oldlay = flayer;
#line 1023
  if (oldlay->l_data) {
    {
#line 1024
    free((void *)oldlay->l_data);
    }
  }
#line 1026
  p = (struct win *)(flayer->l_bottom)->l_data;
#line 1028
  flayer = oldlay->l_next;
#line 1029
  if ((unsigned long )flayer->l_layfn == (unsigned long )(& WinLf)) {
#line 1031
    if (oldlay->l_blocking) {
      {
#line 1033
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1033
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1034
      (p->w_blocked) --;
      {
#line 1035
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1035
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1038
    if (p->w_blocked) {
#line 1038
      if (p->w_savelayer) {
#line 1038
        if ((unsigned long )p->w_savelayer != (unsigned long )flayer) {
#line 1038
          if (oldlay->l_cvlist) {
            {
#line 1040
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 1040
              goto while_break___3;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 1042
            flayer = p->w_savelayer;
#line 1043
            doredisplay = 1;
          }
        }
      }
    }
  }
#line 1046
  if (p) {
#line 1046
    if ((unsigned long )p->w_savelayer == (unsigned long )oldlay) {
#line 1047
      p->w_savelayer = flayer;
    }
  }
#line 1049
  if (p) {
#line 1049
    if ((unsigned long )oldlay == (unsigned long )p->w_paster.pa_pastelayer) {
#line 1050
      p->w_paster.pa_pastelayer = (struct layer *)0;
    }
  }
#line 1054
  ocv = (struct canvas *)0;
#line 1054
  cv = oldlay->l_cvlist;
  {
#line 1054
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1054
    if (! cv) {
#line 1054
      goto while_break___4;
    }
#line 1056
    cv->c_layer = flayer;
#line 1057
    ocv = cv;
#line 1054
    cv = cv->c_lnext;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1059
  if (ocv) {
#line 1061
    cv = flayer->l_cvlist;
#line 1062
    ocv->c_lnext = (struct canvas *)0;
#line 1063
    flayer->l_cvlist = oldlay->l_cvlist;
#line 1065
    if (doredisplay) {
      {
#line 1066
      LRefreshAll(flayer, 0);
      }
    }
#line 1067
    ocv->c_lnext = cv;
  }
  {
#line 1069
  oldlay->l_cvlist = (struct canvas *)0;
#line 1070
  free((void *)((char *)oldlay));
#line 1071
  (*((flayer->l_layfn)->lf_LayRestore))();
#line 1072
  LGotoPos(flayer, flayer->l_x, flayer->l_y);
  }
#line 1073
  return;
}
}
#line 1075 "/home/pronto/abs/test-suite/screen-4.0.2/layer.c"
void ( /* format attribute */  LMsg)(int err , char *fmt  , ...) 
{ 
  va_list ap ;
  char buf___0[8192] ;
  char *p ;
  struct canvas *cv ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1088
  p = buf___0;
#line 1091
  __builtin_va_start(ap, fmt);
#line 1092
  fmt = DoNLS(fmt);
#line 1093
  vsnprintf((char */* __restrict  */)p, (size_t )(sizeof(buf___0) - 100UL), (char const   */* __restrict  */)fmt,
            ap);
#line 1094
  __builtin_va_end(ap);
  }
#line 1095
  if (err) {
    {
#line 1097
    tmp = strlen((char const   *)p);
#line 1097
    p += tmp;
#line 1098
    tmp___0 = p;
#line 1098
    p ++;
#line 1098
    *tmp___0 = (char )':';
#line 1099
    tmp___1 = p;
#line 1099
    p ++;
#line 1099
    *tmp___1 = (char )' ';
#line 1100
    tmp___2 = strerror(err);
#line 1100
    strncpy((char */* __restrict  */)p, (char const   */* __restrict  */)tmp___2,
            (size_t )(((buf___0 + sizeof(buf___0)) - p) - 1L));
#line 1101
    buf___0[sizeof(buf___0) - 1UL] = (char)0;
    }
  }
  {
#line 1103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1103
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1104
  display = displays;
  {
#line 1104
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1104
    if (! display) {
#line 1104
      goto while_break___0;
    }
#line 1106
    cv = display->d_cvlist;
    {
#line 1106
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1106
      if (! cv) {
#line 1106
        goto while_break___1;
      }
#line 1107
      if ((unsigned long )cv->c_layer == (unsigned long )flayer) {
#line 1108
        goto while_break___1;
      }
#line 1106
      cv = cv->c_next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1109
    if ((unsigned long )cv == (unsigned long )((struct canvas *)0)) {
#line 1110
      goto __Cont;
    }
    {
#line 1111
    MakeStatus(buf___0);
    }
    __Cont: /* CIL Label */ 
#line 1104
    display = display->d_next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1113
  return;
}
}
#line 207 "/usr/include/sys/stat.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __path ,
                                                                                            struct stat * __restrict  __statbuf ) ;
#line 212
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) fstat)(int __fd ,
                                                                                           struct stat *__statbuf ) ;
#line 235
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) lstat)(char const   * __restrict  __path ,
                                                                                             struct stat * __restrict  __statbuf ) ;
#line 291
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) mknod)(char const   *__path ,
                                                                                           __mode_t __mode ,
                                                                                           __dev_t __dev ) ;
#line 324
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3))) __fxstat)(int __ver ,
                                                                                     int __fildes ,
                                                                                     struct stat *__stat_buf ) ;
#line 326
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __xstat)(int __ver ,
                                                                                      char const   *__filename ,
                                                                                      struct stat *__stat_buf ) ;
#line 328
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __lxstat)(int __ver ,
                                                                                       char const   *__filename ,
                                                                                       struct stat *__stat_buf ) ;
#line 357
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,4))) __xmknod)(int __ver ,
                                                                                       char const   *__path ,
                                                                                       __mode_t __mode ,
                                                                                       __dev_t *__dev ) ;
#line 363
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __path ,
                                                                                            struct stat * __restrict  __statbuf ) ;
#line 363 "/usr/include/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __path ,
                                                              struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  {
#line 366
  tmp = __xstat(3, (char const   *)__path, (struct stat *)__statbuf);
  }
#line 366
  return (tmp);
}
}
#line 370
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) lstat)(char const   * __restrict  __path ,
                                                                                             struct stat * __restrict  __statbuf ) ;
#line 370 "/usr/include/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1,2))) lstat)(char const   * __restrict  __path ,
                                                               struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  {
#line 373
  tmp = __lxstat(3, (char const   *)__path, (struct stat *)__statbuf);
  }
#line 373
  return (tmp);
}
}
#line 377
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) fstat)(int __fd ,
                                                                                           struct stat *__statbuf ) ;
#line 377 "/usr/include/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(2))) fstat)(int __fd , struct stat *__statbuf ) 
{ 
  int tmp ;

  {
  {
#line 380
  tmp = __fxstat(3, __fd, __statbuf);
  }
#line 380
  return (tmp);
}
}
#line 384
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) mknod)(char const   *__path ,
                                                                                           __mode_t __mode ,
                                                                                           __dev_t __dev ) ;
#line 384 "/usr/include/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1))) mknod)(char const   *__path ,
                                                             __mode_t __mode , __dev_t __dev ) 
{ 
  int tmp ;

  {
  {
#line 387
  tmp = __xmknod(1, __path, __mode, & __dev);
  }
#line 387
  return (tmp);
}
}
#line 72 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 211 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 609
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 752
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 305 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 466
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 622 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 340 "/home/pronto/abs/test-suite/screen-4.0.2/extern.h"
char *SaveStr(char const   *str ) ;
#line 42 "/home/pronto/abs/test-suite/screen-4.0.2/logfile.h"
struct logfile *logfopen(char *name , FILE *fp ) ;
#line 49
int islogfile(char *name ) ;
#line 54
int logfclose(struct logfile *l ) ;
#line 55
int logfwrite(struct logfile *l , char *buf___0 , int n ) ;
#line 62
int logfflush(struct logfile *l ) ;
#line 72
void logreopen_register(int (*fn)(char * , int  , struct logfile * ) ) ;
#line 82
int lf_move_fd(int fd , int need_fd ) ;
#line 34 "/home/pronto/abs/test-suite/screen-4.0.2/logfile.c"
static void changed_logfile(struct logfile *l ) ;
#line 35
static struct logfile *lookup_logfile(char *name ) ;
#line 36
static int stolen_logfile(struct logfile *l ) ;
#line 38 "/home/pronto/abs/test-suite/screen-4.0.2/logfile.c"
static struct logfile *logroot  =    (struct logfile *)((void *)0);
#line 40 "/home/pronto/abs/test-suite/screen-4.0.2/logfile.c"
static void changed_logfile(struct logfile *l ) 
{ 
  struct stat o ;
  struct stat *s ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 44
  s = l->st;
#line 46
  tmp = fileno(l->fp);
#line 46
  tmp___0 = fstat(tmp, & o);
  }
#line 46
  if (tmp___0 < 0) {
#line 47
    return;
  }
#line 48
  if (o.st_size > s->st_size) {
#line 50
    s->st_size = o.st_size;
#line 51
    s->st_mtim.tv_sec = o.st_mtim.tv_sec;
  }
#line 53
  return;
}
}
#line 63 "/home/pronto/abs/test-suite/screen-4.0.2/logfile.c"
int lf_move_fd(int fd , int need_fd ) 
{ 
  int r ;
  int tmp ;

  {
#line 67
  r = -1;
#line 69
  if (fd == need_fd) {
#line 70
    return (fd);
  }
#line 71
  if (fd >= 0) {
#line 71
    if (fd < need_fd) {
      {
#line 72
      tmp = dup(fd);
#line 72
      r = lf_move_fd(tmp, need_fd);
      }
    }
  }
  {
#line 73
  close(fd);
  }
#line 74
  return (r);
}
}
#line 77 "/home/pronto/abs/test-suite/screen-4.0.2/logfile.c"
static int logfile_reopen(char *name , int wantfd , struct logfile *l ) 
{ 
  int got_fd ;
  int tmp ;

  {
  {
#line 85
  close(wantfd);
#line 86
  got_fd = open((char const   *)name, 1089, 438);
  }
#line 86
  if (got_fd < 0) {
#line 86
    goto _L;
  } else {
    {
#line 86
    tmp = lf_move_fd(got_fd, wantfd);
    }
#line 86
    if (tmp < 0) {
      _L: /* CIL Label */ 
      {
#line 89
      logfclose(l);
      }
      {
#line 90
      while (1) {
        while_continue: /* CIL Label */ ;
#line 90
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 91
      return (-1);
    }
  }
  {
#line 93
  changed_logfile(l);
  }
  {
#line 94
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 94
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 95
  return (0);
}
}
#line 98 "/home/pronto/abs/test-suite/screen-4.0.2/logfile.c"
static int (*lf_reopen_fn)()  =    (int (*)())(& logfile_reopen);
#line 112 "/home/pronto/abs/test-suite/screen-4.0.2/logfile.c"
void logreopen_register(int (*fn)(char * , int  , struct logfile * ) ) 
{ 


  {
#line 116
  if (fn) {
#line 116
    lf_reopen_fn = (int (*)())fn;
  } else {
#line 116
    lf_reopen_fn = (int (*)())(& logfile_reopen);
  }
#line 117
  return;
}
}
#line 125 "/home/pronto/abs/test-suite/screen-4.0.2/logfile.c"
static int stolen_logfile(struct logfile *l ) 
{ 
  struct stat o ;
  struct stat *s ;
  __dev_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 129
  s = l->st;
#line 131
  o = *s;
#line 132
  tmp___0 = fileno(l->fp);
#line 132
  tmp___1 = fstat(tmp___0, s);
  }
#line 132
  if (tmp___1 < 0) {
#line 133
    tmp = (__dev_t )0;
#line 133
    s->st_dev = tmp;
#line 133
    s->st_ino = (__ino_t )tmp;
  }
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 135
  if (! o.st_dev) {
#line 135
    if (! o.st_ino) {
#line 136
      return (0);
    }
  }
#line 138
  if (! s->st_dev) {
#line 138
    if (! s->st_ino) {
#line 138
      goto _L___0;
    } else {
#line 138
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 138
  if (! s->st_nlink) {
#line 138
    goto _L___0;
  } else
#line 138
  if (s->st_size < o.st_size) {
#line 138
    goto _L___0;
  } else
#line 138
  if (s->st_mtim.tv_sec != o.st_mtim.tv_sec) {
#line 138
    goto _L___0;
  } else
#line 138
  if (s->st_ctim.tv_sec != o.st_ctim.tv_sec) {
#line 138
    if (s->st_mtim.tv_sec == s->st_ctim.tv_sec) {
#line 138
      if (! (o.st_ctim.tv_sec < s->st_ctim.tv_sec)) {
#line 138
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 146
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 146
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 147
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 147
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 149
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 149
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 150
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 150
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 152
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 152
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 154
      return (-1);
    }
  }
  {
#line 157
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 157
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 158
  return (0);
}
}
#line 161 "/home/pronto/abs/test-suite/screen-4.0.2/logfile.c"
static struct logfile *lookup_logfile(char *name ) 
{ 
  struct logfile *l ;
  int tmp ;

  {
#line 167
  l = logroot;
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! l) {
#line 167
      goto while_break;
    }
    {
#line 168
    tmp = strcmp((char const   *)name, (char const   *)l->name);
    }
#line 168
    if (! tmp) {
#line 169
      return (l);
    }
#line 167
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  return ((struct logfile *)((void *)0));
}
}
#line 173 "/home/pronto/abs/test-suite/screen-4.0.2/logfile.c"
struct logfile *logfopen(char *name , FILE *fp ) 
{ 
  struct logfile *l ;
  void *tmp ;
  struct stat *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;

  {
#line 180
  if (! fp) {
    {
#line 182
    l = lookup_logfile(name);
    }
#line 182
    if (! l) {
#line 183
      return ((struct logfile *)((void *)0));
    }
#line 184
    (l->opencount) ++;
#line 185
    return (l);
  }
  {
#line 188
  tmp = malloc((size_t )sizeof(struct logfile ));
#line 188
  l = (struct logfile *)tmp;
  }
#line 188
  if (! l) {
#line 189
    return ((struct logfile *)((void *)0));
  }
  {
#line 190
  tmp___1 = malloc((size_t )sizeof(struct stat ));
#line 190
  tmp___0 = (struct stat *)tmp___1;
#line 190
  l->st = tmp___0;
  }
#line 190
  if (! tmp___0) {
    {
#line 192
    free((void *)((char *)l));
    }
#line 193
    return ((struct logfile *)((void *)0));
  }
  {
#line 196
  tmp___2 = SaveStr((char const   *)name);
#line 196
  l->name = tmp___2;
  }
#line 196
  if (! tmp___2) {
    {
#line 198
    free((void *)((char *)l->st));
#line 199
    free((void *)((char *)l));
    }
#line 200
    return ((struct logfile *)((void *)0));
  }
  {
#line 202
  l->fp = fp;
#line 203
  l->opencount = 1;
#line 204
  l->writecount = 0;
#line 205
  l->flushcount = 0;
#line 206
  changed_logfile(l);
#line 208
  l->next = logroot;
#line 209
  logroot = l;
  }
#line 210
  return (l);
}
}
#line 213 "/home/pronto/abs/test-suite/screen-4.0.2/logfile.c"
int islogfile(char *name ) 
{ 
  int tmp ;
  int tmp___1 ;
  struct logfile *tmp___2 ;

  {
#line 217
  if (! name) {
#line 218
    if (logroot) {
#line 218
      tmp = 1;
    } else {
#line 218
      tmp = 0;
    }
#line 218
    return (tmp);
  }
  {
#line 219
  tmp___2 = lookup_logfile(name);
  }
#line 219
  if (tmp___2) {
#line 219
    tmp___1 = 1;
  } else {
#line 219
    tmp___1 = 0;
  }
#line 219
  return (tmp___1);
}
}
#line 222 "/home/pronto/abs/test-suite/screen-4.0.2/logfile.c"
int logfclose(struct logfile *l ) 
{ 
  struct logfile **lp ;

  {
#line 228
  lp = & logroot;
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    if (! *lp) {
#line 228
      goto while_break;
    }
#line 229
    if ((unsigned long )*lp == (unsigned long )l) {
#line 230
      goto while_break;
    }
#line 228
    lp = & (*lp)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 232
  if (! *lp) {
#line 233
    return (-1);
  }
#line 235
  (l->opencount) --;
#line 235
  if (l->opencount > 0) {
#line 236
    return (0);
  }
#line 237
  if (l->opencount < 0) {
    {
#line 238
    abort();
    }
  }
  {
#line 240
  *lp = l->next;
#line 241
  fclose(l->fp);
#line 242
  free((void *)l->name);
#line 243
  free((void *)((char *)l));
  }
#line 244
  return (0);
}
}
#line 252 "/home/pronto/abs/test-suite/screen-4.0.2/logfile.c"
int logfwrite(struct logfile *l , char *buf___0 , int n ) 
{ 
  int r ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 260
  tmp = stolen_logfile(l);
  }
#line 260
  if (tmp) {
    {
#line 260
    tmp___0 = fileno(l->fp);
#line 260
    tmp___1 = (*lf_reopen_fn)(l->name, tmp___0, l);
    }
#line 260
    if (tmp___1) {
#line 261
      return (-1);
    }
  }
  {
#line 262
  tmp___2 = fwrite((void const   */* __restrict  */)buf___0, (size_t )n, (size_t )1,
                   (FILE */* __restrict  */)l->fp);
#line 262
  r = (int )tmp___2;
#line 263
  l->writecount += l->flushcount + 1;
#line 264
  l->flushcount = 0;
#line 265
  changed_logfile(l);
  }
#line 266
  return (r);
}
}
#line 269 "/home/pronto/abs/test-suite/screen-4.0.2/logfile.c"
int logfflush(struct logfile *l ) 
{ 
  int r ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 273
  r = 0;
#line 275
  if (! l) {
#line 276
    l = logroot;
    {
#line 276
    while (1) {
      while_continue: /* CIL Label */ ;
#line 276
      if (! l) {
#line 276
        goto while_break;
      }
      {
#line 278
      tmp = stolen_logfile(l);
      }
#line 278
      if (tmp) {
        {
#line 278
        tmp___0 = fileno(l->fp);
#line 278
        tmp___1 = (*lf_reopen_fn)(l->name, tmp___0, l);
        }
#line 278
        if (tmp___1) {
#line 279
          return (-1);
        }
      }
      {
#line 280
      tmp___2 = fflush(l->fp);
#line 280
      r |= tmp___2;
#line 281
      (l->flushcount) ++;
#line 282
      changed_logfile(l);
#line 276
      l = l->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 286
    tmp___3 = stolen_logfile(l);
    }
#line 286
    if (tmp___3) {
      {
#line 286
      tmp___4 = fileno(l->fp);
#line 286
      tmp___5 = (*lf_reopen_fn)(l->name, tmp___4, l);
      }
#line 286
      if (tmp___5) {
#line 287
        return (-1);
      }
    }
    {
#line 288
    r = fflush(l->fp);
#line 289
    (l->flushcount) ++;
#line 290
    changed_logfile(l);
    }
  }
#line 292
  return (r);
}
}
#line 117 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 87 "/usr/include/shadow.h"
extern struct spwd *getspnam(char const   *__name ) ;
#line 175 "/usr/include/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 73 "/home/pronto/abs/test-suite/screen-4.0.2/osdef.h"
extern char *crypt(char * , char * ) ;
#line 92 "/home/pronto/abs/test-suite/screen-4.0.2/acls.h"
int DefaultEsc ;
#line 92
int DefaultMetaEsc ;
#line 34 "/home/pronto/abs/test-suite/screen-4.0.2/extern.h"
void Detach(int mode ) ;
#line 44
void Finit(int i ) ;
#line 108
void FreePaster(struct paster *pa ) ;
#line 188
int FindCommnr(char *str ) ;
#line 201
int WindowByNoN(char *str ) ;
#line 386
int AclCheckPermWin(struct acluser *u , int mode , struct win *w ) ;
#line 387
int AclCheckPermCmd(struct acluser *u , int mode , struct comm *c ) ;
#line 388
int AclSetPerm(struct acluser *uu , struct acluser *u , char *mode , char *s ) ;
#line 389
int AclUmask(struct acluser *u , char *str , char **errp ) ;
#line 390
int UsersAcl(struct acluser *uu , int argc , char **argv ) ;
#line 391
void AclWinSwap(int a , int b ) ;
#line 392
int NewWindowAcl(struct win *w , struct acluser *u ) ;
#line 393
void FreeWindowAcl(struct win *w ) ;
#line 394
char *DoSu(struct acluser **up , char *name , char *pw1 , char *pw2 ) ;
#line 395
int AclLinkUser(char *from , char *to ) ;
#line 397
int UserFreeCopyBuffer(struct acluser *u ) ;
#line 398
struct acluser **FindUserPtr(char *name ) ;
#line 399
int UserAdd(char *name , char *pass , struct acluser **up ) ;
#line 400
int UserDel(char *name , struct acluser **up ) ;
#line 53 "/home/pronto/abs/test-suite/screen-4.0.2/acls.c"
struct comm comms[175] ;
#line 54
struct win *windows ;
#line 54
struct win *wtab[40] ;
#line 55
char NullStr[1] ;
#line 56
char SockPath[4608] ;
#line 58 "/home/pronto/abs/test-suite/screen-4.0.2/acls.c"
struct acluser *users  ;
#line 61 "/home/pronto/abs/test-suite/screen-4.0.2/acls.c"
int maxusercount  =    0;
#line 64 "/home/pronto/abs/test-suite/screen-4.0.2/acls.c"
static AclBits userbits  ;
#line 70 "/home/pronto/abs/test-suite/screen-4.0.2/acls.c"
static char default_w_bit[3]  = {      (char)1,      (char)1,      (char)1};
#line 77 "/home/pronto/abs/test-suite/screen-4.0.2/acls.c"
static char default_c_bit[1]  = {      (char)0};
#line 89
static int GrowBitfield(AclBits *bfp , int len , int delta , int defaultbit ) ;
#line 90
static struct aclusergroup **FindGroupPtr(struct aclusergroup **gp , struct acluser *u ,
                                          int recursive ) ;
#line 91
static int AclSetPermCmd(struct acluser *u , char *mode , struct comm *cmd ) ;
#line 92
static int AclSetPermWin(struct acluser *uu , struct acluser *u , char *mode , struct win *win ) ;
#line 93
static int UserAcl(struct acluser *uu , struct acluser **u , int argc , char **argv ) ;
#line 94
static int UserAclCopy(struct acluser **to_up , struct acluser **from_up ) ;
#line 97 "/home/pronto/abs/test-suite/screen-4.0.2/acls.c"
static int GrowBitfield(AclBits *bfp , int len , int delta , int defaultbit ) 
{ 
  AclBits n ;
  AclBits o ;
  int i ;
  void *tmp ;

  {
  {
#line 102
  o = *bfp;
#line 105
  tmp = calloc((size_t )1, (size_t )((unsigned long )((char *)0 + (((len + delta) + 1) >> 3))));
#line 105
  n = (AclBits )tmp;
  }
#line 105
  if (! n) {
#line 106
    return (-1);
  }
#line 107
  i = 0;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! (i < len + delta)) {
#line 107
      goto while_break;
    }
#line 109
    if (i < len) {
#line 109
      if ((128 >> (i & 7)) & (int )*(o + (i >> 3))) {
#line 111
        *(n + (i >> 3)) = (unsigned char )((int )*(n + (i >> 3)) | (128 >> (i & 7)));
      } else {
#line 109
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 109
    if (i >= len) {
#line 109
      if (defaultbit) {
#line 111
        *(n + (i >> 3)) = (unsigned char )((int )*(n + (i >> 3)) | (128 >> (i & 7)));
      }
    }
#line 107
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  if (len) {
    {
#line 114
    free((void *)((char *)o));
    }
  }
#line 115
  *bfp = n;
#line 116
  return (0);
}
}
#line 125 "/home/pronto/abs/test-suite/screen-4.0.2/acls.c"
struct acluser **FindUserPtr(char *name ) 
{ 
  struct acluser **u ;
  int tmp ;

  {
#line 131
  u = & users;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! *u) {
#line 131
      goto while_break;
    }
    {
#line 132
    tmp = strcmp((char const   *)((*u)->u_name), (char const   *)name);
    }
#line 132
    if (! tmp) {
#line 133
      goto while_break;
    }
#line 131
    u = & (*u)->u_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 135
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 135
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 140
  return (u);
}
}
#line 143 "/home/pronto/abs/test-suite/screen-4.0.2/acls.c"
int DefaultEsc  =    -1;
#line 144 "/home/pronto/abs/test-suite/screen-4.0.2/acls.c"
int DefaultMetaEsc  =    -1;
#line 151 "/home/pronto/abs/test-suite/screen-4.0.2/acls.c"
int UserAdd(char *name , char *pass , struct acluser **up ) 
{ 
  int j ;
  void *tmp ;
  int tmp___0 ;
  int j___0 ;
  struct win *w ;
  struct acluser *u ;
  int tmp___1 ;
  int i ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 160
  if (! up) {
    {
#line 161
    up = FindUserPtr(name);
    }
  }
#line 162
  if (*up) {
#line 164
    if (pass) {
      {
#line 165
      (*up)->u_password = SaveStr((char const   *)pass);
      }
    }
#line 166
    return (1);
  }
  {
#line 168
  tmp___0 = strcmp("none", (char const   *)name);
  }
#line 168
  if (tmp___0) {
    {
#line 169
    tmp = calloc((size_t )1, (size_t )sizeof(struct acluser ));
#line 169
    *up = (struct acluser *)tmp;
    }
  }
#line 170
  if (! *up) {
#line 171
    return (-1);
  }
  {
#line 173
  (*up)->u_plop.buf = (char *)((void *)0);
#line 174
  (*up)->u_plop.len = 0;
#line 176
  (*up)->u_plop.enc = 0;
#line 179
  (*up)->u_Esc = DefaultEsc;
#line 180
  (*up)->u_MetaEsc = DefaultMetaEsc;
#line 181
  strncpy((char */* __restrict  */)((*up)->u_name), (char const   */* __restrict  */)name,
          (size_t )20);
#line 182
  (*up)->u_password = (char *)((void *)0);
  }
#line 183
  if (pass) {
    {
#line 184
    (*up)->u_password = SaveStr((char const   *)pass);
    }
  }
#line 185
  if (! (*up)->u_password) {
#line 186
    (*up)->u_password = NullStr;
  }
#line 187
  (*up)->u_detachwin = -1;
#line 188
  (*up)->u_detachotherwin = -1;
#line 191
  (*up)->u_group = (struct aclusergroup *)((void *)0);
#line 193
  (*up)->u_id = 0;
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 193
    if (! ((*up)->u_id < maxusercount)) {
#line 193
      goto while_break;
    }
#line 194
    if (! ((128 >> ((*up)->u_id & 7)) & (int )*(userbits + ((*up)->u_id >> 3)))) {
#line 195
      goto while_break;
    }
#line 193
    ((*up)->u_id) ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 196
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 196
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 197
  if ((*up)->u_id == maxusercount) {
    {
#line 203
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 203
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 206
    tmp___1 = GrowBitfield(& userbits, maxusercount, 8, 0);
    }
#line 206
    if (tmp___1) {
      {
#line 208
      free((void *)((char *)*up));
#line 208
      *up = (struct acluser *)((void *)0);
      }
#line 208
      return (-1);
    }
#line 221
    j___0 = 0;
    {
#line 221
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 221
      if (! (j___0 <= 174)) {
#line 221
        goto while_break___2;
      }
#line 225
      i = 0;
      {
#line 225
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 225
        if (! (i < 1)) {
#line 225
          goto while_break___3;
        }
        {
#line 226
        tmp___2 = GrowBitfield(& comms[j___0].userbits[i], maxusercount, 8, (int )default_c_bit[i]);
        }
#line 226
        if (tmp___2) {
          {
#line 229
          free((void *)((char *)*up));
#line 229
          *up = (struct acluser *)((void *)0);
          }
#line 229
          return (-1);
        }
#line 225
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 221
      j___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 233
    u = users;
    {
#line 233
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 233
      if (! ((unsigned long )u != (unsigned long )*up)) {
#line 233
        goto while_break___4;
      }
#line 235
      j___0 = 0;
      {
#line 235
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 235
        if (! (j___0 < 3)) {
#line 235
          goto while_break___5;
        }
        {
#line 237
        tmp___3 = GrowBitfield(& u->u_umask_w_bits[j___0], maxusercount, 8, (int )default_w_bit[j___0]);
        }
#line 237
        if (tmp___3) {
          {
#line 240
          free((void *)((char *)*up));
#line 240
          *up = (struct acluser *)((void *)0);
          }
#line 240
          return (-1);
        }
#line 235
        j___0 ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 233
      u = u->u_next;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 247
    w = windows;
    {
#line 247
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 247
      if (! w) {
#line 247
        goto while_break___6;
      }
#line 250
      j___0 = 0;
      {
#line 250
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 250
        if (! (j___0 < 3)) {
#line 250
          goto while_break___7;
        }
        {
#line 251
        tmp___4 = GrowBitfield(& w->w_userbits[j___0], maxusercount, 8, (int )default_w_bit[j___0]);
        }
#line 251
        if (tmp___4) {
          {
#line 254
          free((void *)((char *)*up));
#line 254
          *up = (struct acluser *)((void *)0);
          }
#line 254
          return (-1);
        }
#line 250
        j___0 ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 258
      tmp___5 = GrowBitfield(& w->w_mon_notify, maxusercount, 8, 0);
      }
#line 258
      if (tmp___5) {
        {
#line 261
        free((void *)((char *)*up));
#line 261
        *up = (struct acluser *)((void *)0);
        }
#line 261
        return (-1);
      } else {
        {
#line 258
        tmp___6 = GrowBitfield(& w->w_lio_notify, maxusercount, 8, 0);
        }
#line 258
        if (tmp___6) {
          {
#line 261
          free((void *)((char *)*up));
#line 261
          *up = (struct acluser *)((void *)0);
          }
#line 261
          return (-1);
        }
      }
#line 247
      w = w->w_next;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 264
    maxusercount += 8;
  }
#line 268
  *(userbits + ((*up)->u_id >> 3)) = (unsigned char )((int )*(userbits + ((*up)->u_id >> 3)) | (128 >> ((*up)->u_id & 7)));
#line 271
  if ((*up)->u_id == 0) {
    {
#line 272
    AclSetPerm((struct acluser *)((void *)0), *up, (char *)"+a", (char *)"#?");
    }
  }
  {
#line 275
  tmp___7 = strcmp((char const   *)((*up)->u_name), "nobody");
  }
#line 275
  if (! tmp___7) {
    {
#line 277
    AclSetPerm((struct acluser *)((void *)0), *up, (char *)"-rwx", (char *)"#?");
#line 278
    AclSetPerm((struct acluser *)((void *)0), *up, (char *)"+x", (char *)"su");
#line 279
    AclSetPerm((struct acluser *)((void *)0), *up, (char *)"+x", (char *)"detach");
#line 280
    AclSetPerm((struct acluser *)((void *)0), *up, (char *)"+x", (char *)"displays");
#line 281
    AclSetPerm((struct acluser *)((void *)0), *up, (char *)"+x", (char *)"version");
    }
  }
#line 289
  j = 0;
  {
#line 289
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 289
    if (! (j < 3)) {
#line 289
      goto while_break___8;
    }
    {
#line 291
    tmp___8 = GrowBitfield(& (*up)->u_umask_w_bits[j], 0, maxusercount, (int )default_w_bit[j]);
    }
#line 291
    if (tmp___8) {
      {
#line 294
      free((void *)((char *)*up));
#line 294
      *up = (struct acluser *)((void *)0);
      }
#line 294
      return (-1);
    }
#line 296
    *((*up)->u_umask_w_bits[j] + ((*up)->u_id >> 3)) = (unsigned char )((int )*((*up)->u_umask_w_bits[j] + ((*up)->u_id >> 3)) | (128 >> ((*up)->u_id & 7)));
#line 289
    j ++;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 301
  return (0);
}
}
#line 327 "/home/pronto/abs/test-suite/screen-4.0.2/acls.c"
int UserDel(char *name , struct acluser **up ) 
{ 
  struct acluser *u ;
  int i ;
  struct display *old ;
  struct display *next ;
  struct aclusergroup **g ;
  struct aclusergroup *next___0 ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 338
  if (! up) {
    {
#line 339
    up = FindUserPtr(name);
    }
  }
#line 340
  u = *up;
#line 340
  if (! u) {
#line 341
    return (-1);
  }
#line 342
  old = display;
#line 343
  display = displays;
  {
#line 343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 343
    if (! display) {
#line 343
      goto while_break;
    }
#line 345
    next = display->d_next;
#line 346
    if ((unsigned long )display->d_user != (unsigned long )u) {
#line 347
      goto __Cont;
    }
#line 348
    if ((unsigned long )display == (unsigned long )old) {
#line 349
      old = (struct display *)((void *)0);
    }
    {
#line 350
    Detach(2);
    }
    __Cont: /* CIL Label */ 
#line 343
    display = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 352
  display = old;
#line 353
  *up = u->u_next;
#line 356
  up = & users;
  {
#line 356
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 356
    if (! *up) {
#line 356
      goto while_break___0;
    }
#line 359
    g = & (*up)->u_group;
    {
#line 361
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 361
      if (! *g) {
#line 361
        goto while_break___1;
      }
#line 363
      if ((unsigned long )(*g)->u == (unsigned long )u) {
        {
#line 365
        next___0 = (*g)->next;
#line 367
        free((void *)((char *)*g));
#line 368
        *g = next___0;
        }
      } else {
#line 371
        g = & (*g)->next;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 356
    up = & (*up)->u_next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 374
  *(userbits + (u->u_id >> 3)) = (unsigned char )((int )*(userbits + (u->u_id >> 3)) & ~ (128 >> (u->u_id & 7)));
#line 376
  if (default_w_bit[2]) {
#line 376
    tmp = "+r";
  } else {
#line 376
    tmp = "-r";
  }
  {
#line 376
  AclSetPerm((struct acluser *)((void *)0), u, (char *)tmp, (char *)"#");
  }
#line 377
  if (default_w_bit[1]) {
#line 377
    tmp___0 = "+w";
  } else {
#line 377
    tmp___0 = "-w";
  }
  {
#line 377
  AclSetPerm((struct acluser *)((void *)0), u, (char *)tmp___0, (char *)"#");
  }
#line 378
  if (default_w_bit[0]) {
#line 378
    tmp___1 = "+x";
  } else {
#line 378
    tmp___1 = "-x";
  }
  {
#line 378
  AclSetPerm((struct acluser *)((void *)0), u, (char *)tmp___1, (char *)"#");
  }
#line 379
  if (default_c_bit[0]) {
#line 379
    tmp___2 = "+x";
  } else {
#line 379
    tmp___2 = "-x";
  }
  {
#line 379
  AclSetPerm((struct acluser *)((void *)0), u, (char *)tmp___2, (char *)"?");
#line 380
  i = 0;
  }
  {
#line 380
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 380
    if (! (i < 3)) {
#line 380
      goto while_break___2;
    }
    {
#line 381
    free((void *)((char *)u->u_umask_w_bits[i]));
#line 380
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 383
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 383
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 385
  UserFreeCopyBuffer(u);
#line 387
  free((void *)((char *)u));
  }
#line 388
  if (! users) {
    {
#line 390
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 390
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 391
    Finit(0);
    }
  }
#line 393
  return (0);
}
}
#line 403 "/home/pronto/abs/test-suite/screen-4.0.2/acls.c"
int UserFreeCopyBuffer(struct acluser *u ) 
{ 
  struct win *w ;
  struct paster *pa ;

  {
#line 410
  if (! u->u_plop.buf) {
#line 411
    return (1);
  }
#line 412
  w = windows;
  {
#line 412
  while (1) {
    while_continue: /* CIL Label */ ;
#line 412
    if (! w) {
#line 412
      goto while_break;
    }
#line 414
    pa = & w->w_paster;
#line 415
    if ((unsigned long )pa->pa_pasteptr >= (unsigned long )u->u_plop.buf) {
#line 415
      if (pa->pa_pasteptr - u->u_plop.buf < (long )u->u_plop.len) {
        {
#line 417
        FreePaster(pa);
        }
      }
    }
#line 412
    w = w->w_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 419
  free((void *)u->u_plop.buf);
#line 420
  u->u_plop.len = 0;
#line 421
  u->u_plop.buf = (char *)0;
  }
#line 422
  return (0);
}
}
#line 433 "/home/pronto/abs/test-suite/screen-4.0.2/acls.c"
static struct aclusergroup **FindGroupPtr(struct aclusergroup **gp , struct acluser *u ,
                                          int recursive ) 
{ 
  struct aclusergroup **g ;

  {
  {
#line 441
  while (1) {
    while_continue: /* CIL Label */ ;
#line 441
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 442
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 442
    if (! *gp) {
#line 442
      goto while_break___0;
    }
#line 444
    if ((unsigned long )(*gp)->u == (unsigned long )u) {
#line 445
      return (gp);
    }
#line 446
    if (recursive) {
      {
#line 446
      g = FindGroupPtr(& ((*gp)->u)->u_group, u, recursive + 1);
      }
#line 446
      if (*g) {
#line 448
        return (g);
      }
    }
#line 449
    gp = & (*gp)->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 451
  return (gp);
}
}
#line 459 "/home/pronto/abs/test-suite/screen-4.0.2/acls.c"
int AclLinkUser(char *from , char *to ) 
{ 
  struct acluser **u1 ;
  struct acluser **u2 ;
  struct aclusergroup **g ;
  int tmp ;
  int tmp___0 ;
  struct aclusergroup **tmp___1 ;
  struct aclusergroup *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 466
  u1 = FindUserPtr(from);
  }
#line 466
  if (! *u1) {
    {
#line 466
    tmp = UserAdd(from, (char *)((void *)0), u1);
    }
#line 466
    if (tmp) {
#line 467
      return (-1);
    }
  }
  {
#line 468
  u2 = FindUserPtr(to);
  }
#line 468
  if (! *u2) {
    {
#line 468
    tmp___0 = UserAdd(to, (char *)((void *)0), u2);
    }
#line 468
    if (tmp___0) {
#line 469
      return (-1);
    }
  }
  {
#line 471
  tmp___1 = FindGroupPtr(& (*u2)->u_group, *u1, 1);
  }
#line 471
  if (*tmp___1) {
#line 472
    return (1);
  }
  {
#line 473
  g = FindGroupPtr(& (*u1)->u_group, *u2, 0);
  }
#line 473
  if (*g) {
#line 474
    return (2);
  }
  {
#line 476
  tmp___3 = malloc((size_t )sizeof(struct aclusergroup ));
#line 476
  tmp___2 = (struct aclusergroup *)tmp___3;
#line 476
  *g = tmp___2;
  }
#line 476
  if (! tmp___2) {
#line 477
    return (-1);
  }
#line 478
  (*g)->u = *u2;
#line 479
  (*g)->next = (struct aclusergroup *)((void *)0);
#line 480
  return (0);
}
}
#line 488 "/home/pronto/abs/test-suite/screen-4.0.2/acls.c"
char *DoSu(struct acluser **up , char *name , char *pw1 , char *pw2 ) 
{ 
  struct acluser *u ;
  int sorry ;
  struct passwd *pp ;
  struct spwd *ss ;
  int t ;
  int c ;
  char *pass ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  struct acluser **tmp___3 ;
  char const   *tmp___4 ;

  {
  {
#line 494
  sorry = 0;
#line 496
  tmp___3 = FindUserPtr(name);
#line 496
  u = *tmp___3;
  }
#line 496
  if (u) {
    {
#line 506
    pass = (char *)"";
#line 508
    pp = getpwnam((char const   *)name);
    }
#line 508
    if (pp) {
#line 518
      pass = pp->pw_passwd;
    } else {
      {
#line 510
      while (1) {
        while_continue: /* CIL Label */ ;
#line 510
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 511
      if (pw1) {
#line 511
        if (*pw1) {
#line 511
          if (! ((int )*pw1 != -1)) {
#line 511
            goto _L___0;
          }
        } else {
#line 511
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 513
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 513
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 514
        sorry ++;
      }
    }
#line 520
    t = 0;
    {
#line 520
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 520
      if (! (t < 13)) {
#line 520
        goto while_break___1;
      }
#line 522
      c = (int )*(pass + t);
#line 523
      if (! (c == 46)) {
#line 523
        if (! (c == 47)) {
#line 523
          if (c >= 48) {
#line 523
            if (! (c <= 57)) {
#line 523
              goto _L___2;
            }
          } else
          _L___2: /* CIL Label */ 
#line 523
          if (c >= 97) {
#line 523
            if (! (c <= 122)) {
#line 523
              goto _L___1;
            }
          } else
          _L___1: /* CIL Label */ 
#line 523
          if (c >= 65) {
#line 523
            if (! (c <= 90)) {
#line 527
              goto while_break___1;
            }
          } else {
#line 527
            goto while_break___1;
          }
        }
      }
#line 520
      t ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 529
    if (t < 13) {
      {
#line 531
      ss = getspnam((char const   *)name);
      }
#line 531
      if (ss) {
#line 537
        pass = ss->sp_pwdp;
      } else {
        {
#line 533
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 533
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 534
        sorry ++;
      }
    }
#line 541
    if (pw2) {
#line 541
      if (*pw2) {
#line 541
        if ((int )*pw2 != -1) {
#line 543
          if (! *pass) {
#line 543
            goto _L___3;
          } else {
            {
#line 543
            tmp = crypt(pw2, pass);
#line 543
            tmp___0 = strcmp((char const   *)tmp, (char const   *)pass);
            }
#line 543
            if (tmp___0) {
              _L___3: /* CIL Label */ 
              {
#line 546
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 546
                goto while_break___3;
              }
              while_break___3: /* CIL Label */ ;
              }
#line 547
              sorry ++;
            }
          }
        } else {
#line 541
          goto _L___5;
        }
      } else {
#line 541
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 551
    if (*pass) {
#line 552
      sorry ++;
    }
#line 554
    if (pw1) {
#line 554
      if (*pw1) {
#line 554
        if ((int )*pw1 != -1) {
#line 556
          if (! *(u->u_password)) {
#line 556
            goto _L___6;
          } else {
            {
#line 556
            tmp___1 = crypt(pw1, u->u_password);
#line 556
            tmp___2 = strcmp((char const   *)tmp___1, (char const   *)u->u_password);
            }
#line 556
            if (tmp___2) {
              _L___6: /* CIL Label */ 
              {
#line 559
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 559
                goto while_break___4;
              }
              while_break___4: /* CIL Label */ ;
              }
#line 560
              sorry ++;
            }
          }
        } else {
#line 554
          goto _L___8;
        }
      } else {
#line 554
        goto _L___8;
      }
    } else
    _L___8: /* CIL Label */ 
#line 564
    if (*(u->u_password)) {
#line 565
      sorry ++;
    }
  } else {
#line 497
    sorry ++;
  }
  {
#line 568
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 568
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 569
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 569
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 574
  openlog("screen", 1, 4 << 3);
  }
#line 576
  if (sorry) {
#line 576
    tmp___4 = "failed";
  } else {
#line 576
    tmp___4 = "succeded";
  }
  {
#line 576
  syslog(5, "%s: \"su %s\" %s for \"%s\"", SockPath, name, tmp___4, (*up)->u_name);
#line 578
  closelog();
  }
#line 583
  if (sorry) {
#line 584
    return ((char *)"Sorry.");
  } else {
#line 586
    *up = u;
  }
#line 587
  return ((char *)((void *)0));
}
}
#line 599 "/home/pronto/abs/test-suite/screen-4.0.2/acls.c"
int NewWindowAcl(struct win *w , struct acluser *u ) 
{ 
  int i ;
  int j ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 606
  while (1) {
    while_continue: /* CIL Label */ ;
#line 606
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 610
  tmp = GrowBitfield(& w->w_mon_notify, 0, maxusercount, 0);
  }
#line 610
  if (tmp) {
#line 612
    return (-1);
  } else {
    {
#line 610
    tmp___0 = GrowBitfield(& w->w_lio_notify, 0, maxusercount, 0);
    }
#line 610
    if (tmp___0) {
#line 612
      return (-1);
    }
  }
#line 613
  j = 0;
  {
#line 613
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 613
    if (! (j < 3)) {
#line 613
      goto while_break___0;
    }
    {
#line 616
    tmp___1 = GrowBitfield(& w->w_userbits[j], 0, maxusercount, 0);
    }
#line 616
    if (tmp___1) {
      {
#line 618
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 618
        j --;
#line 618
        if (! (j >= 0)) {
#line 618
          goto while_break___1;
        }
        {
#line 619
        free((void *)((char *)w->w_userbits[j]));
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 620
      free((void *)((char *)w->w_mon_notify));
#line 621
      free((void *)((char *)w->w_lio_notify));
      }
#line 622
      return (-1);
    }
#line 624
    i = 0;
    {
#line 624
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 624
      if (! (i < maxusercount)) {
#line 624
        goto while_break___2;
      }
#line 625
      if (u) {
#line 625
        tmp___2 = (128 >> (i & 7)) & (int )*(u->u_umask_w_bits[j] + (i >> 3));
      } else {
#line 625
        tmp___2 = (int )default_w_bit[j];
      }
#line 625
      if (tmp___2) {
#line 627
        *(w->w_userbits[j] + (i >> 3)) = (unsigned char )((int )*(w->w_userbits[j] + (i >> 3)) | (128 >> (i & 7)));
      }
#line 624
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 613
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 629
  return (0);
}
}
#line 632 "/home/pronto/abs/test-suite/screen-4.0.2/acls.c"
void FreeWindowAcl(struct win *w ) 
{ 
  int i ;

  {
#line 638
  i = 0;
  {
#line 638
  while (1) {
    while_continue: /* CIL Label */ ;
#line 638
    if (! (i < 3)) {
#line 638
      goto while_break;
    }
    {
#line 639
    free((void *)((char *)w->w_userbits[i]));
#line 638
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 640
  free((void *)((char *)w->w_mon_notify));
#line 641
  free((void *)((char *)w->w_lio_notify));
  }
#line 642
  return;
}
}
#line 650 "/home/pronto/abs/test-suite/screen-4.0.2/acls.c"
static int AclSetPermCmd(struct acluser *u , char *mode , struct comm *cmd ) 
{ 
  int neg ;
  char *m___0 ;
  char *tmp ;

  {
#line 656
  neg = 0;
#line 657
  m___0 = mode;
  {
#line 659
  while (1) {
    while_continue: /* CIL Label */ ;
#line 659
    if (! *m___0) {
#line 659
      goto while_break;
    }
#line 661
    tmp = m___0;
#line 661
    m___0 ++;
    {
#line 663
    if ((int )*tmp == 45) {
#line 663
      goto case_45;
    }
#line 666
    if ((int )*tmp == 43) {
#line 666
      goto case_43;
    }
#line 671
    if ((int )*tmp == 120) {
#line 671
      goto case_120;
    }
#line 671
    if ((int )*tmp == 101) {
#line 671
      goto case_120;
    }
#line 671
    if ((int )*tmp == 97) {
#line 671
      goto case_120;
    }
#line 679
    if ((int )*tmp == 119) {
#line 679
      goto case_119;
    }
#line 679
    if ((int )*tmp == 114) {
#line 679
      goto case_119;
    }
#line 681
    goto switch_default;
    case_45: /* CIL Label */ 
#line 664
    neg = 1;
#line 665
    goto while_continue;
    case_43: /* CIL Label */ 
#line 667
    neg = 0;
#line 668
    goto while_continue;
    case_120: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_97: /* CIL Label */ 
#line 673
    if (neg) {
#line 674
      *(cmd->userbits[0] + (u->u_id >> 3)) = (unsigned char )((int )*(cmd->userbits[0] + (u->u_id >> 3)) & ~ (128 >> (u->u_id & 7)));
    } else {
#line 676
      *(cmd->userbits[0] + (u->u_id >> 3)) = (unsigned char )((int )*(cmd->userbits[0] + (u->u_id >> 3)) | (128 >> (u->u_id & 7)));
    }
#line 677
    goto switch_break;
    case_119: /* CIL Label */ 
    case_114: /* CIL Label */ 
#line 680
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 682
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 685
  return (0);
}
}
#line 695 "/home/pronto/abs/test-suite/screen-4.0.2/acls.c"
static int AclSetPermWin(struct acluser *uu , struct acluser *u , char *mode , struct win *win ) 
{ 
  int neg ;
  int bit ;
  int bits ;
  AclBits *bitarray ;
  char *m___0 ;
  char *tmp ;

  {
#line 701
  neg = 0;
#line 704
  m___0 = mode;
#line 706
  if (uu) {
    {
#line 708
    while (1) {
      while_continue: /* CIL Label */ ;
#line 708
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 709
    bitarray = uu->u_umask_w_bits;
  } else {
    {
#line 713
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 713
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 714
    bitarray = win->w_userbits;
    {
#line 715
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 715
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 718
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 718
    if (! *m___0) {
#line 718
      goto while_break___2;
    }
#line 720
    tmp = m___0;
#line 720
    m___0 ++;
    {
#line 722
    if ((int )*tmp == 45) {
#line 722
      goto case_45;
    }
#line 725
    if ((int )*tmp == 43) {
#line 725
      goto case_43;
    }
#line 728
    if ((int )*tmp == 114) {
#line 728
      goto case_114;
    }
#line 731
    if ((int )*tmp == 119) {
#line 731
      goto case_119;
    }
#line 734
    if ((int )*tmp == 120) {
#line 734
      goto case_120;
    }
#line 737
    if ((int )*tmp == 97) {
#line 737
      goto case_97;
    }
#line 740
    goto switch_default;
    case_45: /* CIL Label */ 
#line 723
    neg = 1;
#line 724
    goto while_continue___2;
    case_43: /* CIL Label */ 
#line 726
    neg = 0;
#line 727
    goto while_continue___2;
    case_114: /* CIL Label */ 
#line 729
    bits = 1 << 2;
#line 730
    goto switch_break;
    case_119: /* CIL Label */ 
#line 732
    bits = 1 << 1;
#line 733
    goto switch_break;
    case_120: /* CIL Label */ 
#line 735
    bits = 1;
#line 736
    goto switch_break;
    case_97: /* CIL Label */ 
#line 738
    bits = (1 << 3) - 1;
#line 739
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 741
    return (-1);
    switch_break: /* CIL Label */ ;
    }
#line 743
    bit = 0;
    {
#line 743
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 743
      if (! (bit < 3)) {
#line 743
        goto while_break___3;
      }
#line 745
      if (! (bits & (1 << bit))) {
#line 746
        goto __Cont;
      }
#line 747
      if (neg) {
#line 748
        *(*(bitarray + bit) + (u->u_id >> 3)) = (unsigned char )((int )*(*(bitarray + bit) + (u->u_id >> 3)) & ~ (128 >> (u->u_id & 7)));
      } else {
#line 750
        *(*(bitarray + bit) + (u->u_id >> 3)) = (unsigned char )((int )*(*(bitarray + bit) + (u->u_id >> 3)) | (128 >> (u->u_id & 7)));
      }
#line 751
      if (! uu) {
#line 751
        if ((unsigned long )win->w_wlockuser == (unsigned long )u) {
#line 751
          if (neg) {
#line 751
            if (bit == 1) {
              {
#line 753
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 753
                goto while_break___4;
              }
              while_break___4: /* CIL Label */ ;
              }
#line 754
              win->w_wlockuser = (struct acluser *)((void *)0);
#line 755
              if (win->w_wlock == 2) {
#line 756
                win->w_wlock = 1;
              }
            }
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 743
      bit ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 760
  if (uu) {
#line 760
    if ((int )u->u_name[0] == 63) {
#line 760
      if ((int )u->u_name[1] == 0) {
#line 766
        if (win) {
          {
#line 768
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 768
            goto while_break___5;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 769
          bit = 0;
          {
#line 769
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 769
            if (! (bit < 3)) {
#line 769
              goto while_break___6;
            }
#line 770
            if ((int )*(*(bitarray + bit) + (u->u_id >> 3)) & (128 >> (u->u_id & 7))) {
#line 770
              default_w_bit[bit] = (char)1;
            } else {
#line 770
              default_w_bit[bit] = (char)0;
            }
#line 769
            bit ++;
          }
          while_break___6: /* CIL Label */ ;
          }
        } else {
          {
#line 780
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 780
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
#line 781
          bit = 0;
          {
#line 781
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 781
            if (! (bit < 1)) {
#line 781
              goto while_break___8;
            }
#line 782
            if ((int )*(*(bitarray + bit) + (u->u_id >> 3)) & (128 >> (u->u_id & 7))) {
#line 782
              default_c_bit[bit] = (char)1;
            } else {
#line 782
              default_c_bit[bit] = (char)0;
            }
#line 781
            bit ++;
          }
          while_break___8: /* CIL Label */ ;
          }
        }
        {
#line 785
        UserDel(u->u_name, (struct acluser **)((void *)0));
        }
      }
    }
  }
#line 787
  return (0);
}
}
#line 795 "/home/pronto/abs/test-suite/screen-4.0.2/acls.c"
int AclSetPerm(struct acluser *uu , struct acluser *u , char *mode , char *s ) 
{ 
  struct win *w ;
  int i ;
  char *p ;
  char ch ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 804
  while (1) {
    while_continue: /* CIL Label */ ;
#line 804
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 806
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 806
    if (! *s) {
#line 806
      goto while_break___0;
    }
    {
#line 810
    if ((int )*s == 42) {
#line 810
      goto case_42;
    }
#line 812
    if ((int )*s == 35) {
#line 812
      goto case_35;
    }
#line 820
    if ((int )*s == 63) {
#line 820
      goto case_63;
    }
#line 828
    goto switch_default;
    case_42: /* CIL Label */ 
    {
#line 811
    tmp = AclSetPerm(uu, u, mode, (char *)"#?");
    }
#line 811
    return (tmp);
    case_35: /* CIL Label */ 
#line 813
    if (uu) {
      {
#line 814
      AclSetPermWin(uu, u, mode, (struct win *)1);
      }
    } else {
#line 816
      w = windows;
      {
#line 816
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 816
        if (! w) {
#line 816
          goto while_break___1;
        }
        {
#line 817
        AclSetPermWin((struct acluser *)0, u, mode, w);
#line 816
        w = w->w_next;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 818
    s ++;
#line 819
    goto switch_break;
    case_63: /* CIL Label */ 
#line 821
    if (uu) {
      {
#line 822
      AclSetPermWin(uu, u, mode, (struct win *)0);
      }
    } else {
#line 824
      i = 0;
      {
#line 824
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 824
        if (! (i <= 174)) {
#line 824
          goto while_break___2;
        }
        {
#line 825
        AclSetPermCmd(u, mode, & comms[i]);
#line 824
        i ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 826
    s ++;
#line 827
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 829
    p = s;
    {
#line 829
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 829
      if (*p) {
#line 829
        if ((int )*p != 32) {
#line 829
          if ((int )*p != 9) {
#line 829
            if (! ((int )*p != 44)) {
#line 829
              goto while_break___3;
            }
          } else {
#line 829
            goto while_break___3;
          }
        } else {
#line 829
          goto while_break___3;
        }
      } else {
#line 829
        goto while_break___3;
      }
#line 829
      p ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 831
    ch = *p;
#line 831
    if (ch) {
#line 832
      tmp___0 = p;
#line 832
      p ++;
#line 832
      *tmp___0 = (char )'\000';
    }
    {
#line 833
    i = FindCommnr(s);
    }
#line 833
    if (i != -1) {
      {
#line 834
      AclSetPermCmd(u, mode, & comms[i]);
      }
    } else {
      {
#line 835
      i = WindowByNoN(s);
      }
#line 835
      if (i >= 0) {
#line 835
        if (wtab[i]) {
          {
#line 836
          AclSetPermWin((struct acluser *)0, u, mode, wtab[i]);
          }
        } else {
#line 839
          return (-1);
        }
      } else {
#line 839
        return (-1);
      }
    }
#line 840
    if (ch) {
#line 841
      *(p + -1) = ch;
    }
#line 842
    s = p;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 845
  return (0);
}
}
#line 859 "/home/pronto/abs/test-suite/screen-4.0.2/acls.c"
static int UserAcl(struct acluser *uu , struct acluser **u , int argc , char **argv ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 865
  if (*u) {
    {
#line 865
    tmp = strcmp((char const   *)((*u)->u_name), "nobody");
    }
#line 865
    if (tmp) {
#line 865
      goto _L;
    } else {
#line 867
      return (-1);
    }
  } else
  _L: /* CIL Label */ 
#line 865
  if (argc > 1) {
    {
#line 865
    tmp___0 = strcmp((char const   *)*(argv + 0), "nobody");
    }
#line 865
    if (! tmp___0) {
#line 867
      return (-1);
    }
  }
  {
#line 871
  if (argc == 4) {
#line 871
    goto case_4;
  }
#line 875
  if (argc == 3) {
#line 875
    goto case_3;
  }
#line 879
  if (argc == 2) {
#line 879
    goto case_2;
  }
#line 882
  if (argc == 1) {
#line 882
    goto case_1;
  }
#line 886
  goto switch_default;
  case_4: /* CIL Label */ 
  {
#line 872
  while (1) {
    while_continue: /* CIL Label */ ;
#line 872
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 873
  tmp___1 = UserAdd(*(argv + 0), *(argv + 1), u);
  }
#line 873
  if (tmp___1 < 0) {
#line 873
    tmp___3 = 1;
  } else {
    {
#line 873
    tmp___2 = AclSetPerm(uu, *u, *(argv + 2), *(argv + 3));
    }
#line 873
    if (tmp___2) {
#line 873
      tmp___3 = 1;
    } else {
#line 873
      tmp___3 = 0;
    }
  }
#line 873
  return (tmp___3);
  case_3: /* CIL Label */ 
  {
#line 876
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 876
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 877
  tmp___4 = UserAdd(*(argv + 0), (char *)((void *)0), u);
  }
#line 877
  if (tmp___4 < 0) {
#line 877
    tmp___6 = 1;
  } else {
    {
#line 877
    tmp___5 = AclSetPerm(uu, *u, *(argv + 1), *(argv + 2));
    }
#line 877
    if (tmp___5) {
#line 877
      tmp___6 = 1;
    } else {
#line 877
      tmp___6 = 0;
    }
  }
#line 877
  return (tmp___6);
  case_2: /* CIL Label */ 
  {
#line 880
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 880
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 881
  tmp___7 = UserAdd(*(argv + 0), *(argv + 1), u);
  }
#line 881
  return (tmp___7 < 0);
  case_1: /* CIL Label */ 
  {
#line 883
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 883
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 884
  tmp___8 = UserAdd(*(argv + 0), (char *)((void *)0), u);
  }
#line 884
  if (tmp___8 < 0) {
#line 884
    tmp___10 = 1;
  } else {
    {
#line 884
    tmp___9 = AclSetPerm(uu, *u, (char *)"+a", (char *)"#?");
    }
#line 884
    if (tmp___9) {
#line 884
      tmp___10 = 1;
    } else {
#line 884
      tmp___10 = 0;
    }
  }
#line 884
  return (tmp___10);
  switch_default: /* CIL Label */ 
#line 887
  return (-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 891 "/home/pronto/abs/test-suite/screen-4.0.2/acls.c"
static int UserAclCopy(struct acluser **to_up , struct acluser **from_up ) 
{ 
  struct win *w ;
  int i ;
  int j ;
  int to_id ;
  int from_id ;

  {
#line 898
  if (! *to_up) {
#line 899
    return (-1);
  } else
#line 898
  if (! *from_up) {
#line 899
    return (-1);
  }
  {
#line 900
  while (1) {
    while_continue: /* CIL Label */ ;
#line 900
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 902
  to_id = (*to_up)->u_id;
#line 902
  from_id = (*from_up)->u_id;
#line 902
  if (to_id == from_id) {
#line 903
    return (-1);
  }
#line 904
  w = windows;
  {
#line 904
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 904
    if (! w) {
#line 904
      goto while_break___0;
    }
#line 906
    i = 0;
    {
#line 906
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 906
      if (! (i < 3)) {
#line 906
        goto while_break___1;
      }
#line 908
      if ((int )*(w->w_userbits[i] + (from_id >> 3)) & (128 >> (from_id & 7))) {
#line 909
        *(w->w_userbits[i] + (to_id >> 3)) = (unsigned char )((int )*(w->w_userbits[i] + (to_id >> 3)) | (128 >> (to_id & 7)));
      } else {
#line 912
        *(w->w_userbits[i] + (to_id >> 3)) = (unsigned char )((int )*(w->w_userbits[i] + (to_id >> 3)) & ~ (128 >> (to_id & 7)));
#line 913
        if ((unsigned long )w->w_wlockuser == (unsigned long )*to_up) {
#line 913
          if (i == 1) {
            {
#line 915
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 915
              goto while_break___2;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 917
            w->w_wlockuser = (struct acluser *)((void *)0);
#line 918
            if (w->w_wlock == 2) {
#line 919
              w->w_wlock = 1;
            }
          }
        }
      }
#line 906
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 904
    w = w->w_next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 924
  j = 0;
  {
#line 924
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 924
    if (! (j <= 174)) {
#line 924
      goto while_break___3;
    }
#line 926
    i = 0;
    {
#line 926
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 926
      if (! (i < 1)) {
#line 926
        goto while_break___4;
      }
#line 928
      if ((int )*(comms[j].userbits[i] + (from_id >> 3)) & (128 >> (from_id & 7))) {
#line 929
        *(comms[j].userbits[i] + (to_id >> 3)) = (unsigned char )((int )*(comms[j].userbits[i] + (to_id >> 3)) | (128 >> (to_id & 7)));
      } else {
#line 931
        *(comms[j].userbits[i] + (to_id >> 3)) = (unsigned char )((int )*(comms[j].userbits[i] + (to_id >> 3)) & ~ (128 >> (to_id & 7)));
      }
#line 926
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 924
    j ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 935
  return (0);
}
}
#line 946 "/home/pronto/abs/test-suite/screen-4.0.2/acls.c"
int UsersAcl(struct acluser *uu , int argc , char **argv ) 
{ 
  char *s ;
  int r ;
  struct acluser **cf_u ;
  char *p ;
  char *tmp ;
  struct acluser **u ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  struct acluser **tmp___3 ;
  struct acluser **tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
#line 954
  cf_u = (struct acluser **)((void *)0);
#line 956
  if (argc == 1) {
#line 958
    p = (char *)((void *)0);
#line 960
    s = *(argv + 0);
    {
#line 961
    while (1) {
      while_continue: /* CIL Label */ ;
#line 961
      if (! *s) {
#line 961
        goto while_break;
      }
#line 962
      tmp = s;
#line 962
      s ++;
#line 962
      if ((int )*tmp == 61) {
#line 962
        p = s;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 963
    if (p) {
      {
#line 965
      *(p + -1) = (char )'\000';
#line 966
      cf_u = FindUserPtr(p);
      }
    }
  }
#line 970
  if ((int )*(*(argv + 0) + 0) == 42) {
#line 970
    if ((int )*(*(argv + 0) + 1) == 0) {
      {
#line 974
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 974
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 975
      u = & users;
      {
#line 975
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 975
        if (! *u) {
#line 975
          goto while_break___1;
        }
        {
#line 976
        tmp___0 = strcmp("nobody", (char const   *)((*u)->u_name));
        }
#line 976
        if (tmp___0) {
#line 976
          if (cf_u) {
            {
#line 976
            r = UserAclCopy(u, cf_u);
#line 976
            tmp___1 = r < 0;
            }
          } else {
            {
#line 976
            r = UserAcl(uu, u, argc, argv);
#line 976
            tmp___1 = r < 0;
            }
          }
#line 976
          if (tmp___1) {
#line 980
            return (-1);
          }
        }
#line 975
        u = & (*u)->u_next;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 981
      return (0);
    }
  }
  {
#line 984
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 986
    s = *(argv + 0);
    {
#line 986
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 986
      if (*s) {
#line 986
        if ((int )*s != 32) {
#line 986
          if ((int )*s != 9) {
#line 986
            if ((int )*s != 44) {
#line 986
              if (! ((int )*s != 61)) {
#line 986
                goto while_break___3;
              }
            } else {
#line 986
              goto while_break___3;
            }
          } else {
#line 986
            goto while_break___3;
          }
        } else {
#line 986
          goto while_break___3;
        }
      } else {
#line 986
        goto while_break___3;
      }
#line 986
      s ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 988
    if (*s) {
#line 988
      tmp___2 = s;
#line 988
      s ++;
#line 988
      *tmp___2 = (char )'\000';
    } else {
#line 988
      *s = (char )'\000';
    }
    {
#line 989
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 989
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 990
    if (cf_u) {
      {
#line 990
      tmp___3 = FindUserPtr(*(argv + 0));
#line 990
      r = UserAclCopy(tmp___3, cf_u);
#line 990
      tmp___5 = r < 0;
      }
    } else {
      {
#line 990
      tmp___4 = FindUserPtr(*(argv + 0));
#line 990
      r = UserAcl(uu, tmp___4, argc, argv);
#line 990
      tmp___5 = r < 0;
      }
    }
#line 990
    if (tmp___5) {
#line 993
      return (-1);
    }
#line 984
    tmp___6 = s;
#line 984
    *(argv + 0) = tmp___6;
#line 984
    if (! *tmp___6) {
#line 984
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 995
  return (0);
}
}
#line 1007 "/home/pronto/abs/test-suite/screen-4.0.2/acls.c"
int AclUmask(struct acluser *u , char *str , char **errp ) 
{ 
  char mode[16] ;
  char *av[3] ;
  char *p ;
  char c ;
  int tmp ;
  int tmp___0 ;

  {
#line 1015
  c = (char )'\000';
#line 1018
  p = str;
  {
#line 1018
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1018
    if (! *p) {
#line 1018
      goto while_break;
    }
#line 1019
    c = *p;
#line 1019
    if ((int )c == 43) {
#line 1020
      goto while_break;
    } else
#line 1019
    if ((int )c == 45) {
#line 1020
      goto while_break;
    }
#line 1018
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1021
  if (! *p) {
#line 1023
    *errp = (char *)"Bad argument. Should be ``[user[,user...]{+|-}rwxn\'\'.";
#line 1024
    return (-1);
  }
  {
#line 1026
  strncpy((char */* __restrict  */)(mode), (char const   */* __restrict  */)p, (size_t )15);
#line 1027
  mode[15] = (char )'\000';
#line 1028
  *p = (char )'\000';
#line 1031
  tmp = strcmp("??", (char const   *)str);
  }
#line 1031
  if (tmp) {
#line 1037
    av[2] = (char *)"#";
  } else {
#line 1033
    str ++;
#line 1034
    av[2] = (char *)"?";
  }
#line 1038
  av[1] = mode;
#line 1039
  if (*str) {
#line 1039
    av[0] = str;
  } else {
#line 1039
    av[0] = (char *)"*";
  }
  {
#line 1041
  tmp___0 = UsersAcl(u, 3, av);
  }
#line 1041
  if (tmp___0) {
#line 1043
    *errp = (char *)"UsersAcl failed. Hmmm.";
#line 1044
    *p = c;
#line 1045
    return (-1);
  }
#line 1047
  *p = c;
#line 1048
  return (0);
}
}
#line 1051 "/home/pronto/abs/test-suite/screen-4.0.2/acls.c"
void AclWinSwap(int a , int b ) 
{ 


  {
  {
#line 1055
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1055
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1056
  return;
}
}
#line 1058 "/home/pronto/abs/test-suite/screen-4.0.2/acls.c"
struct acluser *EffectiveAclUser  =    (struct acluser *)((void *)0);
#line 1060 "/home/pronto/abs/test-suite/screen-4.0.2/acls.c"
int AclCheckPermWin(struct acluser *u , int mode , struct win *w ) 
{ 
  int ok ;
  struct aclusergroup **g ;
  struct acluser *saved_eff ;
  int tmp ;

  {
#line 1068
  if (mode < 0) {
#line 1069
    return (-1);
  } else
#line 1068
  if (mode >= 3) {
#line 1069
    return (-1);
  }
#line 1070
  if (EffectiveAclUser) {
    {
#line 1072
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1072
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1073
    u = EffectiveAclUser;
  }
#line 1075
  ok = (int )*(w->w_userbits[mode] + (u->u_id >> 3)) & (128 >> (u->u_id & 7));
  {
#line 1076
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1076
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1078
  if (! ok) {
#line 1080
    g = & u->u_group;
#line 1081
    saved_eff = EffectiveAclUser;
#line 1083
    EffectiveAclUser = (struct acluser *)((void *)0);
    {
#line 1084
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1084
      if (! *g) {
#line 1084
        goto while_break___1;
      }
      {
#line 1086
      tmp = AclCheckPermWin((*g)->u, mode, w);
      }
#line 1086
      if (! tmp) {
#line 1087
        goto while_break___1;
      }
#line 1088
      g = & (*g)->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1090
    EffectiveAclUser = saved_eff;
#line 1091
    if (*g) {
#line 1092
      ok = 1;
    }
  }
  {
#line 1094
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1094
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1095
  return (! ok);
}
}
#line 1098 "/home/pronto/abs/test-suite/screen-4.0.2/acls.c"
int AclCheckPermCmd(struct acluser *u , int mode , struct comm *c ) 
{ 
  int ok ;
  struct aclusergroup **g ;
  struct acluser *saved_eff ;
  int tmp ;

  {
#line 1106
  if (mode < 0) {
#line 1107
    return (-1);
  } else
#line 1106
  if (mode >= 1) {
#line 1107
    return (-1);
  }
#line 1108
  if (EffectiveAclUser) {
    {
#line 1110
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1110
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1111
    u = EffectiveAclUser;
  }
#line 1113
  ok = (int )*(c->userbits[mode] + (u->u_id >> 3)) & (128 >> (u->u_id & 7));
  {
#line 1114
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1114
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1115
  if (! ok) {
#line 1117
    g = & u->u_group;
#line 1118
    saved_eff = EffectiveAclUser;
#line 1120
    EffectiveAclUser = (struct acluser *)((void *)0);
    {
#line 1121
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1121
      if (! *g) {
#line 1121
        goto while_break___1;
      }
      {
#line 1123
      tmp = AclCheckPermCmd((*g)->u, mode, c);
      }
#line 1123
      if (! tmp) {
#line 1124
        goto while_break___1;
      }
#line 1125
      g = & (*g)->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1127
    EffectiveAclUser = saved_eff;
#line 1128
    if (*g) {
#line 1129
      ok = 1;
    }
  }
  {
#line 1131
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1131
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1132
  return (! ok);
}
}
#line 9 "/home/pronto/abs/test-suite/screen-4.0.2/kmapdef.c"
char *kmapdef[77]  = 
#line 9 "/home/pronto/abs/test-suite/screen-4.0.2/kmapdef.c"
  {      (char *)"\033[10~",      (char *)"\033OP",      (char *)"\033OQ",      (char *)"\033OR", 
        (char *)"\033OS",      (char *)"\033[15~",      (char *)"\033[17~",      (char *)"\033[18~", 
        (char *)"\033[19~",      (char *)"\033[20~",      (char *)"\033[21~",      (char *)"\033[23~", 
        (char *)"\033[24~",      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)"\033[1~", 
        (char *)0,      (char *)"\033[4~",      (char *)0,      (char *)"\033[6~", 
        (char *)"\033[5~",      (char *)"\033[2~",      (char *)"\033[3~",      (char *)"\033[A", 
        (char *)"\033[B",      (char *)"\033[C",      (char *)"\033[D",      (char *)"0", 
        (char *)"1",      (char *)"2",      (char *)"3",      (char *)"4", 
        (char *)"5",      (char *)"6",      (char *)"7",      (char *)"8", 
        (char *)"9",      (char *)"+",      (char *)"-",      (char *)"*", 
        (char *)"/",      (char *)"=",      (char *)".",      (char *)",", 
        (char *)"\r"};
#line 89 "/home/pronto/abs/test-suite/screen-4.0.2/kmapdef.c"
char *kmapadef[22]  = 
#line 89
  {      (char *)"\033OA",      (char *)"\033OB",      (char *)"\033OC",      (char *)"\033OD", 
        (char *)"\033Op",      (char *)"\033Oq",      (char *)"\033Or",      (char *)"\033Os", 
        (char *)"\033Ot",      (char *)"\033Ou",      (char *)"\033Ov",      (char *)"\033Ow", 
        (char *)"\033Ox",      (char *)"\033Oy",      (char *)"\033Ok",      (char *)"\033Om", 
        (char *)"\033Oj",      (char *)"\033Oo",      (char *)"\033OX",      (char *)"\033On", 
        (char *)"\033Ol",      (char *)"\033OM"};
#line 114 "/home/pronto/abs/test-suite/screen-4.0.2/kmapdef.c"
char *kmapmdef[27]  = 
#line 114
  {      (char *)"\004",      (char *)0,      (char *)0,      (char *)"\025", 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)"\201", 
        (char *)0,      (char *)"\205",      (char *)0,      (char *)"\006", 
        (char *)"\002",      (char *)0,      (char *)0,      (char *)"\220", 
        (char *)"\216",      (char *)"\206",      (char *)"\202"};
#line 41 "/home/pronto/abs/test-suite/screen-4.0.2/comm.c"
struct comm comms[175]  = 
#line 41 "/home/pronto/abs/test-suite/screen-4.0.2/comm.c"
  {      {(char *)"acladd", ((1 | (1 << 2)) | (1 << 3)) | (1 << 4), {(unsigned char *)0}}, 
        {(char *)"aclchg",
      2 | (1 << 2), {(unsigned char *)0}}, 
        {(char *)"acldel", 1, {(unsigned char *)0}}, 
        {(char *)"aclgrp", 1 | (1 << 2), {(unsigned char *)0}}, 
        {(char *)"aclumask", 1 | (1 << 5), {(unsigned char *)0}}, 
        {(char *)"activity", 1, {(unsigned char *)0}}, 
        {(char *)"addacl", ((1 | (1 << 2)) | (1 << 3)) | (1 << 4), {(unsigned char *)0}}, 
        {(char *)"allpartial",
      (1 << 7) | 1, {(unsigned char *)0}}, 
        {(char *)"altscreen", 1 << 2, {(unsigned char *)0}}, 
        {(char *)"at", ((1 << 7) | 2) | (1 << 5), {(unsigned char *)0}}, 
        {(char *)"attrcolor", 1 | (1 << 2), {(unsigned char *)0}}, 
        {(char *)"autodetach", 1, {(unsigned char *)0}}, 
        {(char *)"autonuke", (1 << 7) | 1, {(unsigned char *)0}}, 
        {(char *)"backtick", 1 | (1 << 5), {(unsigned char *)0}}, 
        {(char *)"bce", (1 << 6) | (1 << 2), {(unsigned char *)0}}, 
        {(char *)"bell", 1 << 2, {(unsigned char *)0}}, 
        {(char *)"bell_msg", 1 << 2, {(unsigned char *)0}}, 
        {(char *)"bind", 1 | (1 << 5), {(unsigned char *)0}}, 
        {(char *)"bindkey", 1 << 5, {(unsigned char *)0}}, 
        {(char *)"blanker", 1 << 7, {(unsigned char *)0}}, 
        {(char *)"blankerprg", 1 | (1 << 5), {(unsigned char *)0}}, 
        {(char *)"break", (1 << 6) | (1 << 2), {(unsigned char *)0}}, 
        {(char *)"breaktype", (1 << 6) | (1 << 2), {(unsigned char *)0}}, 
        {(char *)"bufferfile", 1 << 2, {(unsigned char *)0}}, 
        {(char *)"c1", (1 << 6) | (1 << 2), {(unsigned char *)0}}, 
        {(char *)"caption", 1 | (1 << 2), {(unsigned char *)0}}, 
        {(char *)"chacl", 2 | (1 << 2), {(unsigned char *)0}}, 
        {(char *)"charset", (1 << 6) | 1, {(unsigned char *)0}}, 
        {(char *)"chdir", 1 << 2, {(unsigned char *)0}}, 
        {(char *)"clear", 1 << 6, {(unsigned char *)0}}, 
        {(char *)"colon", (1 << 8) | (1 << 2), {(unsigned char *)0}}, 
        {(char *)"command", (1 << 7) | (1 << 3), {(unsigned char *)0}}, 
        {(char *)"compacthist", 1 << 2, {(unsigned char *)0}}, 
        {(char *)"console", (1 << 6) | (1 << 2), {(unsigned char *)0}}, 
        {(char *)"copy", 1 << 6, {(unsigned char *)0}}, 
        {(char *)"crlf", 1 << 2, {(unsigned char *)0}}, 
        {(char *)"debug", 1 << 2, {(unsigned char *)0}}, 
        {(char *)"defautonuke", 1, {(unsigned char *)0}}, 
        {(char *)"defbce", 1, {(unsigned char *)0}}, 
        {(char *)"defbreaktype", 1 << 2, {(unsigned char *)0}}, 
        {(char *)"defc1", 1, {(unsigned char *)0}}, 
        {(char *)"defcharset", 1 << 2, {(unsigned char *)0}}, 
        {(char *)"defencoding", 1, {(unsigned char *)0}}, 
        {(char *)"defescape", 1, {(unsigned char *)0}}, 
        {(char *)"defflow", 1 | (1 << 2), {(unsigned char *)0}}, 
        {(char *)"defgr", 1, {(unsigned char *)0}}, 
        {(char *)"defhstatus", 1 << 2, {(unsigned char *)0}}, 
        {(char *)"defkanji", 1, {(unsigned char *)0}}, 
        {(char *)"deflog", 1, {(unsigned char *)0}}, 
        {(char *)"deflogin", 1, {(unsigned char *)0}}, 
        {(char *)"defmode", 1, {(unsigned char *)0}}, 
        {(char *)"defmonitor", 1, {(unsigned char *)0}}, 
        {(char *)"defnonblock", 1, {(unsigned char *)0}}, 
        {(char *)"defobuflimit", 1, {(unsigned char *)0}}, 
        {(char *)"defscrollback", 1, {(unsigned char *)0}}, 
        {(char *)"defshell", 1, {(unsigned char *)0}}, 
        {(char *)"defsilence", 1, {(unsigned char *)0}}, 
        {(char *)"defslowpaste", 1, {(unsigned char *)0}}, 
        {(char *)"defutf8", 1, {(unsigned char *)0}}, 
        {(char *)"defwrap", 1, {(unsigned char *)0}}, 
        {(char *)"defwritelock", 1, {(unsigned char *)0}}, 
        {(char *)"detach", (1 << 7) | (1 << 2), {(unsigned char *)0}}, 
        {(char *)"digraph", (1 << 8) | (1 << 2), {(unsigned char *)0}}, 
        {(char *)"dinfo", 1 << 7, {(unsigned char *)0}}, 
        {(char *)"displays", 1 << 8, {(unsigned char *)0}}, 
        {(char *)"dumptermcap", 1 << 6, {(unsigned char *)0}}, 
        {(char *)"echo", 1 | (1 << 2), {(unsigned char *)0}}, 
        {(char *)"encoding", 1 | (1 << 2), {(unsigned char *)0}}, 
        {(char *)"escape", 1, {(unsigned char *)0}}, 
        {(char *)"eval", 1 | (1 << 5), {(unsigned char *)0}}, 
        {(char *)"exec", (1 << 6) | (1 << 5), {(unsigned char *)0}}, 
        {(char *)"fit", 1 << 7, {(unsigned char *)0}}, 
        {(char *)"flow", (1 << 6) | (1 << 2), {(unsigned char *)0}}, 
        {(char *)"focus", (1 << 7) | (1 << 2), {(unsigned char *)0}}, 
        {(char *)"gr", (1 << 6) | (1 << 2), {(unsigned char *)0}}, 
        {(char *)"hardcopy", (1 << 2) | (1 << 3), {(unsigned char *)0}}, 
        {(char *)"hardcopy_append", 1, {(unsigned char *)0}}, 
        {(char *)"hardcopydir", 1 << 2, {(unsigned char *)0}}, 
        {(char *)"hardstatus", (1 << 2) | (1 << 3), {(unsigned char *)0}}, 
        {(char *)"height", ((1 << 2) | (1 << 3)) | (1 << 4), {(unsigned char *)0}}, 
        {(char *)"help", (1 << 8) | (1 << 3), {(unsigned char *)0}}, 
        {(char *)"history", (1 << 7) | (1 << 6), {(unsigned char *)0}}, 
        {(char *)"hstatus", (1 << 6) | 1, {(unsigned char *)0}}, 
        {(char *)"idle", 1 << 5, {(unsigned char *)0}}, 
        {(char *)"ignorecase", 1 << 2, {(unsigned char *)0}}, 
        {(char *)"info", 1 << 8, {(unsigned char *)0}}, 
        {(char *)"kanji", (1 << 6) | (1 | (1 << 2)), {(unsigned char *)0}}, 
        {(char *)"kill", 1 << 6, {(unsigned char *)0}}, 
        {(char *)"lastmsg", 1 << 7, {(unsigned char *)0}}, 
        {(char *)"license", 1 << 8, {(unsigned char *)0}}, 
        {(char *)"lockscreen", 1 << 7, {(unsigned char *)0}}, 
        {(char *)"log", (1 << 6) | (1 << 2), {(unsigned char *)0}}, 
        {(char *)"logfile", (1 << 2) | (1 << 3), {(unsigned char *)0}}, 
        {(char *)"login", (1 << 6) | (1 << 2), {(unsigned char *)0}}, 
        {(char *)"logtstamp", (1 << 2) | (1 << 3), {(unsigned char *)0}}, 
        {(char *)"mapdefault", 1 << 7, {(unsigned char *)0}}, 
        {(char *)"mapnotnext", 1 << 7, {(unsigned char *)0}}, 
        {(char *)"maptimeout", 1 << 2, {(unsigned char *)0}}, 
        {(char *)"markkeys", 1, {(unsigned char *)0}}, 
        {(char *)"maxwin", 1, {(unsigned char *)0}}, 
        {(char *)"meta", 1 << 8, {(unsigned char *)0}}, 
        {(char *)"monitor", (1 << 6) | (1 << 2), {(unsigned char *)0}}, 
        {(char *)"msgminwait", 1, {(unsigned char *)0}}, 
        {(char *)"msgwait", 1, {(unsigned char *)0}}, 
        {(char *)"multiuser", 1, {(unsigned char *)0}}, 
        {(char *)"nethack", 1, {(unsigned char *)0}}, 
        {(char *)"next", 0, {(unsigned char *)0}}, 
        {(char *)"nonblock", (1 << 7) | (1 << 2), {(unsigned char *)0}}, 
        {(char *)"number", (1 << 6) | (1 << 2), {(unsigned char *)0}}, 
        {(char *)"obuflimit", (1 << 7) | (1 << 2), {(unsigned char *)0}}, 
        {(char *)"only", 1 << 7, {(unsigned char *)0}}, 
        {(char *)"other", 0, {(unsigned char *)0}}, 
        {(char *)"partial", (1 << 6) | (1 << 2), {(unsigned char *)0}}, 
        {(char *)"password", 1 << 2, {(unsigned char *)0}}, 
        {(char *)"paste", (1 << 8) | ((1 << 2) | (1 << 3)), {(unsigned char *)0}}, 
        {(char *)"pastefont", 1 << 2, {(unsigned char *)0}}, 
        {(char *)"pow_break", (1 << 6) | (1 << 2), {(unsigned char *)0}}, 
        {(char *)"pow_detach", 1 << 7, {(unsigned char *)0}}, 
        {(char *)"pow_detach_msg", 1 << 2, {(unsigned char *)0}}, 
        {(char *)"prev", 0, {(unsigned char *)0}}, 
        {(char *)"printcmd", 1 << 2, {(unsigned char *)0}}, 
        {(char *)"process", (1 << 7) | (1 << 2), {(unsigned char *)0}}, 
        {(char *)"quit", 0, {(unsigned char *)0}}, 
        {(char *)"readbuf", ((1 << 2) | (1 << 3)) | (1 << 4), {(unsigned char *)0}}, 
        {(char *)"readreg", 1 << 5, {(unsigned char *)0}}, 
        {(char *)"redisplay", 1 << 7, {(unsigned char *)0}}, 
        {(char *)"register", 2 | (1 << 3), {(unsigned char *)0}}, 
        {(char *)"remove", 1 << 7, {(unsigned char *)0}}, 
        {(char *)"removebuf", 0, {(unsigned char *)0}}, 
        {(char *)"reset", 1 << 6, {(unsigned char *)0}}, 
        {(char *)"resize", (1 << 7) | (1 << 2), {(unsigned char *)0}}, 
        {(char *)"screen", 1 << 5, {(unsigned char *)0}}, 
        {(char *)"scrollback", (1 << 6) | 1, {(unsigned char *)0}}, 
        {(char *)"select", 1 << 2, {(unsigned char *)0}}, 
        {(char *)"sessionname", 1 << 2, {(unsigned char *)0}}, 
        {(char *)"setenv", (1 << 2) | (1 << 3), {(unsigned char *)0}}, 
        {(char *)"setsid", 1, {(unsigned char *)0}}, 
        {(char *)"shell", 1, {(unsigned char *)0}}, 
        {(char *)"shelltitle", 1, {(unsigned char *)0}}, 
        {(char *)"silence", (1 << 6) | (1 << 2), {(unsigned char *)0}}, 
        {(char *)"silencewait", 1, {(unsigned char *)0}}, 
        {(char *)"sleep", 1, {(unsigned char *)0}}, 
        {(char *)"slowpaste", (1 << 6) | (1 << 2), {(unsigned char *)0}}, 
        {(char *)"sorendition", (1 << 2) | (1 << 3), {(unsigned char *)0}}, 
        {(char *)"source", 1, {(unsigned char *)0}}, 
        {(char *)"split", 1 << 7, {(unsigned char *)0}}, 
        {(char *)"startup_message", 1, {(unsigned char *)0}}, 
        {(char *)"stuff", (1 << 8) | (1 | (1 << 2)), {(unsigned char *)0}}, 
        {(char *)"su", (1 << 7) | ((1 << 2) | (1 << 3)), {(unsigned char *)0}}, 
        {(char *)"suspend", 1 << 7, {(unsigned char *)0}}, 
        {(char *)"term", 1, {(unsigned char *)0}}, 
        {(char *)"termcap", 2 | (1 << 2), {(unsigned char *)0}}, 
        {(char *)"termcapinfo", 2 | (1 << 2), {(unsigned char *)0}}, 
        {(char *)"terminfo", 2 | (1 << 2), {(unsigned char *)0}}, 
        {(char *)"time", 1 << 2, {(unsigned char *)0}}, 
        {(char *)"title", (1 << 6) | (1 << 2), {(unsigned char *)0}}, 
        {(char *)"umask", 1 | (1 << 5), {(unsigned char *)0}}, 
        {(char *)"unsetenv", 1, {(unsigned char *)0}}, 
        {(char *)"utf8", (1 << 6) | ((1 << 2) | (1 << 3)), {(unsigned char *)0}}, 
        {(char *)"vbell", 1 << 2, {(unsigned char *)0}}, 
        {(char *)"vbell_msg", 1 << 2, {(unsigned char *)0}}, 
        {(char *)"vbellwait", 1, {(unsigned char *)0}}, 
        {(char *)"verbose", 1 << 2, {(unsigned char *)0}}, 
        {(char *)"version", 0, {(unsigned char *)0}}, 
        {(char *)"wall", (1 << 7) | 1, {(unsigned char *)0}}, 
        {(char *)"width", ((1 << 2) | (1 << 3)) | (1 << 4), {(unsigned char *)0}}, 
        {(char *)"windowlist", (1 << 7) | ((1 << 2) | (1 << 3)), {(unsigned char *)0}}, 
        {(char *)"windows",
      1 << 7, {(unsigned char *)0}}, 
        {(char *)"wrap", (1 << 6) | (1 << 2), {(unsigned char *)0}}, 
        {(char *)"writebuf", ((1 << 2) | (1 << 3)) | (1 << 4), {(unsigned char *)0}}, 
        {(char *)"writelock",
      (1 << 6) | (1 << 2), {(unsigned char *)0}}, 
        {(char *)"xoff", 1 << 8, {(unsigned char *)0}}, 
        {(char *)"xon", 1 << 8, {(unsigned char *)0}}, 
        {(char *)"zmodem", (1 << 2) | (1 << 3), {(unsigned char *)0}}, 
        {(char *)"zombie", 1 << 2, {(unsigned char *)0}}};
#line 63 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 312 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 318
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 390
extern unsigned int sleep(unsigned int __seconds ) ;
#line 643
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 660
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 695
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 84 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 292
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1,2))) bcopy)(void const   *__src ,
                                                                                     void *__dest ,
                                                                                     size_t __n ) ;
#line 49 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) speed_t cfgetospeed(struct termios  const  *__termios_p ) ;
#line 91
extern  __attribute__((__nothrow__)) int tcflush(int __fd , int __queue_selector ) ;
#line 79 "/home/pronto/abs/test-suite/screen-4.0.2/osdef.h"
void xtputs(char *str , int affcnt , int (*outc)(int  ) ) ;
#line 80
extern char *tgoto(char * , int  , int  ) ;
#line 35 "/home/pronto/abs/test-suite/screen-4.0.2/extern.h"
void Hangup(void) ;
#line 36
void Kill(int pid , int sig ) ;
#line 47
char *MakeWinMsgEv(char *str , struct win *win , int esc , int padlen , struct event *ev ,
                   int rec ) ;
#line 64
void WindowChanged(struct win *p , int what ) ;
#line 78
void RunBlanker(char **cmdv ) ;
#line 85
void SetTTY(int fd , struct mode *mp ) ;
#line 94
int fgtty(int fd ) ;
#line 95
void brktty(int fd ) ;
#line 96
struct baud_values *lookup_baud(int baud ) ;
#line 147
void zmodem_abort(struct win *p , struct display *d ) ;
#line 149
void execvpe(char *prog , char **args , char **env ) ;
#line 177
int OpenPTY(char **ttyn ) ;
#line 178
void InitPTY(int f ) ;
#line 182
void ProcessInput(char *ibuf , int ilen ) ;
#line 184
void ProcessInput2(char *ibuf , int ilen ) ;
#line 187
void DoAction(struct action *act , int key ) ;
#line 190
void Activate(int norefresh ) ;
#line 213
void ApplyAttrColor(int i , struct mchar *mc ) ;
#line 215
int StuffKey(int i ) ;
#line 226
void FreeTransTable(void) ;
#line 235
struct display *MakeDisplay(char *uname , char *utty , char *term___0 , int fd , int pid ,
                            struct mode *Mode ) ;
#line 236
void FreeDisplay(void) ;
#line 237
void DefProcess(char **bufp , int *lenp ) ;
#line 238
void DefRedisplayLine(int y , int xs , int xe , int isblank ) ;
#line 239
void DefClearLine(int y , int xs , int xe , int bce ) ;
#line 240
int DefRewrite(int y , int xs , int xe , struct mchar *rend , int doit ) ;
#line 241
int DefResize(int wi , int he ) ;
#line 242
void DefRestore(void) ;
#line 243
void AddCStr(char *s ) ;
#line 244
void AddCStr2(char *s , int c ) ;
#line 245
void InitTerm(int adapt ) ;
#line 246
void FinitTerm(void) ;
#line 247
void PUTCHAR(int c ) ;
#line 249
void ClearAll(void) ;
#line 252
void RefreshAll(int isblank ) ;
#line 254
void RefreshLine(int y , int from , int to , int isblank ) ;
#line 255
void Redisplay(int cur_only ) ;
#line 256
void RedisplayDisplays(int cur_only ) ;
#line 257
void ShowHStatus(char *str ) ;
#line 258
void RefreshHStatus(void) ;
#line 261
int CalcCost(char *s ) ;
#line 267
void ChangeScrollRegion(int newtop , int newbot ) ;
#line 268
void InsertMode(int on ) ;
#line 271
void ReverseVideo(int on ) ;
#line 274
void SetFont(int new ) ;
#line 275
void SetAttr(int new ) ;
#line 276
void SetColor(int f , int b ) ;
#line 278
void SetRenditionMline(struct mline *ml , int x ) ;
#line 281
int ResizeDisplay(int wi , int he ) ;
#line 282
void AddStr(char *str ) ;
#line 283
void AddStrn(char *str , int n ) ;
#line 284
void Flush(void) ;
#line 285
void freetty(void) ;
#line 288
void NukePending(void) ;
#line 290
void SetCanvasWindow(struct canvas *cv , struct win *wi ) ;
#line 291
int MakeDefaultCanvas(void) ;
#line 292
int AddCanvas(void) ;
#line 293
void RemCanvas(void) ;
#line 294
void OneCanvas(void) ;
#line 295
int RethinkDisplayViewports(void) ;
#line 296
void RethinkViewportOffsets(struct canvas *cv ) ;
#line 302
int color256to16(int jj ) ;
#line 307
void ResetIdle(void) ;
#line 308
void KillBlanker(void) ;
#line 309
void DisplaySleep1000(int n , int eat ) ;
#line 313
void ChangeScreenSize(int wi , int he , int change_fore ) ;
#line 314
void CheckScreenSize(int change_flag ) ;
#line 316
void ResizeLayersToCanvases(void) ;
#line 354
void closeallfiles(int except ) ;
#line 359
void (*xsignal(int sig , void (*func)(int  ) ))(int  ) ;
#line 371
void sleep1000(int msec ) ;
#line 36 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
static int CountChars(int c ) ;
#line 37
static int DoAddChar(int c ) ;
#line 38
static int BlankResize(int wi , int he ) ;
#line 39
static int CallRewrite(int y , int xs , int xe , int doit ) ;
#line 40
static void FreeCanvas(struct canvas *cv ) ;
#line 41
static void disp_readev_fn(struct event *ev , char *data ) ;
#line 42
static void disp_writeev_fn(struct event *ev , char *data ) ;
#line 44
static void disp_writeev_eagain(struct event *ev , char *data ) ;
#line 46
static void disp_status_fn(struct event *ev , char *data ) ;
#line 47
static void disp_hstatus_fn(struct event *ev , char *data ) ;
#line 48
static void disp_blocked_fn(struct event *ev , char *data ) ;
#line 49
static void cv_winid_fn(struct event *ev , char *data ) ;
#line 51
static void disp_map_fn(struct event *ev , char *data ) ;
#line 53
static void disp_idle_fn(struct event *ev , char *data ) ;
#line 55
static void disp_blanker_fn(struct event *ev , char *data ) ;
#line 57
static void WriteLP(int x2 , int y2 ) ;
#line 58
static void INSERTCHAR(int c ) ;
#line 59
static void RAW_PUTCHAR(int c ) ;
#line 61
static void SetBackColor(int new ) ;
#line 66
struct win *fore ;
#line 69
int use_hardstatus ;
#line 70
int MsgWait ;
#line 70
int MsgMinWait ;
#line 71
int Z0width ;
#line 71
int Z1width ;
#line 73
struct mline mline_old ;
#line 74
struct mchar mchar_null ;
#line 74
struct mchar mchar_so ;
#line 75
struct NewWindow nwin_default ;
#line 76
struct action idleaction ;
#line 79
char *hstatusstring ;
#line 80
char *captionstring ;
#line 82
int pastefont ;
#line 83
int idletimo ;
#line 86
int pty_preopen ;
#line 88
struct winsize glwz ;
#line 90
char **NewEnv ;
#line 91
int real_uid ;
#line 91
int real_gid ;
#line 98
extern short ospeed ;
#line 103 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
struct display *display  ;
#line 103 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
struct display *displays  ;
#line 105 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
int attr2color[8][4]  ;
#line 106 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
int nattr2color  ;
#line 116 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
int defobuflimit  =    256;
#line 117 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
int defnonblock  =    -1;
#line 119 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
int defautonuke  =    0;
#line 121 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
int captionalways  ;
#line 122 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
int hardstatusemu  =    0;
#line 128 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void DefProcess(char **bufp , int *lenp ) 
{ 


  {
#line 133
  *bufp += *lenp;
#line 134
  *lenp = 0;
#line 135
  return;
}
}
#line 137 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void DefRedisplayLine(int y , int xs , int xe , int isblank ) 
{ 


  {
#line 141
  if (isblank == 0) {
#line 141
    if (y >= 0) {
      {
#line 142
      DefClearLine(y, xs, xe, 0);
      }
    }
  }
#line 143
  return;
}
}
#line 145 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void DefClearLine(int y , int xs , int xe , int bce ) 
{ 


  {
  {
#line 149
  LClearLine(flayer, y, xs, xe, bce, (struct mline *)0);
  }
#line 150
  return;
}
}
#line 153 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
int DefRewrite(int y , int xs , int xe , struct mchar *rend , int doit ) 
{ 


  {
#line 158
  return (1000);
}
}
#line 162 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
int DefResize(int wi , int he ) 
{ 


  {
#line 166
  return (-1);
}
}
#line 169 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void DefRestore(void) 
{ 
  struct display *olddisplay ;
  struct canvas *cv ;

  {
  {
#line 172
  while (1) {
    while_continue: /* CIL Label */ ;
#line 172
    olddisplay = display;
#line 172
    display = displays;
    {
#line 172
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 172
      if (! display) {
#line 172
        goto while_break___0;
      }
#line 172
      cv = display->d_cvlist;
      {
#line 172
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 172
        if (! cv) {
#line 172
          goto while_break___1;
        }
#line 172
        if ((unsigned long )cv->c_layer == (unsigned long )flayer) {
#line 172
          goto while_break___1;
        }
#line 172
        cv = cv->c_next;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 172
      if ((unsigned long )cv == (unsigned long )((struct canvas *)0)) {
#line 172
        goto __Cont;
      }
      {
#line 172
      InsertMode(0);
      }
      __Cont: /* CIL Label */ 
#line 172
      display = display->d_next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 172
    display = olddisplay;
#line 172
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 174
  LKeypadMode(flayer, 0);
#line 175
  LCursorkeysMode(flayer, 0);
#line 176
  LCursorVisibility(flayer, 0);
#line 177
  LMouseMode(flayer, 0);
#line 178
  LSetRendition(flayer, & mchar_null);
#line 179
  LSetFlow(flayer, nwin_default.flowflag & 1);
  }
#line 180
  return;
}
}
#line 186 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
struct LayFuncs BlankLf  =    {& DefProcess, (void (*)(void))0, & DefRedisplayLine, & DefClearLine, & DefRewrite,
    & BlankResize, & DefRestore};
#line 198 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
static int BlankResize(int wi , int he ) 
{ 


  {
#line 202
  flayer->l_width = wi;
#line 203
  flayer->l_height = he;
#line 204
  return (0);
}
}
#line 214 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
struct display *MakeDisplay(char *uname , char *utty , char *term___0 , int fd , int pid ,
                            struct mode *Mode ) 
{ 
  struct acluser **u ;
  struct baud_values *b ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  speed_t tmp___3 ;

  {
  {
#line 223
  u = FindUserPtr(uname);
  }
#line 223
  if (! *u) {
    {
#line 223
    tmp = UserAdd(uname, (char *)0, u);
    }
#line 223
    if (tmp) {
#line 224
      return ((struct display *)0);
    }
  }
  {
#line 227
  tmp___0 = calloc((size_t )1, (size_t )sizeof(*display));
#line 227
  display = (struct display *)tmp___0;
  }
#line 227
  if ((unsigned long )display == (unsigned long )((struct display *)0)) {
#line 228
    return ((struct display *)0);
  }
  {
#line 235
  display->d_next = displays;
#line 236
  displays = display;
#line 237
  display->d_flow = 1;
#line 238
  display->d_nonblock = defnonblock;
#line 239
  display->d_userfd = fd;
#line 240
  tmp___1 = fd;
#line 240
  display->d_writeev.fd = tmp___1;
#line 240
  display->d_readev.fd = tmp___1;
#line 241
  display->d_readev.type = 1;
#line 242
  display->d_writeev.type = 2;
#line 243
  tmp___2 = (char *)display;
#line 243
  display->d_writeev.data = tmp___2;
#line 243
  display->d_readev.data = tmp___2;
#line 244
  display->d_readev.handler = & disp_readev_fn;
#line 245
  display->d_writeev.handler = & disp_writeev_fn;
#line 246
  evenq(& display->d_readev);
#line 247
  display->d_writeev.condpos = & display->d_obuflen;
#line 248
  display->d_writeev.condneg = & display->d_obuffree;
#line 249
  evenq(& display->d_writeev);
#line 250
  display->d_statusev.type = 0;
#line 251
  display->d_statusev.data = (char *)display;
#line 252
  display->d_statusev.handler = & disp_status_fn;
#line 253
  display->d_hstatusev.type = 0;
#line 254
  display->d_hstatusev.data = (char *)display;
#line 255
  display->d_hstatusev.handler = & disp_hstatus_fn;
#line 256
  display->d_blockedev.type = 0;
#line 257
  display->d_blockedev.data = (char *)display;
#line 258
  display->d_blockedev.handler = & disp_blocked_fn;
#line 259
  display->d_blockedev.condpos = & display->d_obuffree;
#line 260
  display->d_blockedev.condneg = & display->d_obuflenmax;
#line 261
  display->d_hstatusev.handler = & disp_hstatus_fn;
#line 263
  display->d_mapev.type = 0;
#line 264
  display->d_mapev.data = (char *)display;
#line 265
  display->d_mapev.handler = & disp_map_fn;
#line 267
  display->d_idleev.type = 0;
#line 268
  display->d_idleev.data = (char *)display;
#line 269
  display->d_idleev.handler = & disp_idle_fn;
#line 271
  display->d_blankerev.type = 1;
#line 272
  display->d_blankerev.data = (char *)display;
#line 273
  display->d_blankerev.handler = & disp_blanker_fn;
#line 274
  display->d_blankerev.fd = -1;
#line 276
  display->d_OldMode = *Mode;
#line 277
  display->d_status_obuffree = -1;
#line 278
  Resize_obuf();
#line 279
  display->d_obufmax = defobuflimit;
#line 280
  display->d_obuflenmax = display->d_obuflen - display->d_obufmax;
#line 282
  display->d_auto_nuke = defautonuke;
#line 284
  display->d_obufp = display->d_obuf;
#line 285
  display->d_printfd = -1;
#line 286
  display->d_userpid = pid;
#line 289
  tmp___3 = cfgetospeed((struct termios  const  *)(& display->d_OldMode.tio));
#line 289
  b = lookup_baud((int )tmp___3);
  }
#line 289
  if (b) {
#line 290
    display->d_dospeed = (short )b->idx;
  }
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 299
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 301
  strncpy((char */* __restrict  */)(display->d_usertty), (char const   */* __restrict  */)utty,
          (size_t )(sizeof(display->d_usertty) - 1UL));
#line 302
  display->d_usertty[sizeof(display->d_usertty) - 1UL] = (char)0;
#line 303
  strncpy((char */* __restrict  */)(display->d_termname), (char const   */* __restrict  */)term___0,
          (size_t )(sizeof(display->d_termname) - 1UL));
#line 304
  display->d_termname[sizeof(display->d_termname) - 1UL] = (char)0;
#line 305
  display->d_user = *u;
#line 306
  display->d_processinput = & ProcessInput;
  }
#line 307
  return (display);
}
}
#line 311 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void FreeDisplay(void) 
{ 
  struct win *p ;
  struct canvas *cv ;
  struct canvas *cvp ;
  struct display *d ;
  struct display **dp ;
  int *tmp ;

  {
  {
#line 321
  FreeTransTable();
#line 324
  KillBlanker();
  }
#line 326
  if (display->d_userfd >= 0) {
    {
#line 328
    Flush();
    }
#line 329
    if (! display) {
#line 330
      return;
    }
    {
#line 331
    SetTTY(display->d_userfd, & display->d_OldMode);
#line 332
    fcntl(display->d_userfd, 4, 0);
    }
  }
  {
#line 334
  freetty();
  }
#line 335
  if (display->d_tentry) {
    {
#line 336
    free((void *)display->d_tentry);
    }
  }
#line 337
  display->d_tentry = (char *)0;
#line 338
  if (display->d_processinputdata) {
    {
#line 339
    free((void *)display->d_processinputdata);
    }
  }
  {
#line 340
  display->d_processinputdata = (char *)0;
#line 341
  display->d_tcinited = (char)0;
#line 342
  evdeq(& display->d_hstatusev);
#line 343
  evdeq(& display->d_statusev);
#line 344
  evdeq(& display->d_readev);
#line 345
  evdeq(& display->d_writeev);
#line 346
  evdeq(& display->d_blockedev);
#line 348
  evdeq(& display->d_mapev);
  }
#line 349
  if (display->d_kmaps) {
    {
#line 351
    free((void *)display->d_kmaps);
#line 352
    display->d_kmaps = (unsigned char *)0;
#line 353
    display->d_aseqs = 0;
#line 354
    display->d_nseqs = 0;
#line 355
    display->d_seqp = (unsigned char *)0;
#line 356
    display->d_seql = 0;
#line 357
    display->d_seqh = (unsigned char *)0;
    }
  }
  {
#line 360
  evdeq(& display->d_idleev);
#line 362
  evdeq(& display->d_blankerev);
#line 373
  dp = & displays;
  }
  {
#line 373
  while (1) {
    while_continue: /* CIL Label */ ;
#line 373
    d = *dp;
#line 373
    if (! d) {
#line 373
      goto while_break;
    }
#line 374
    if ((unsigned long )d == (unsigned long )display) {
#line 375
      goto while_break;
    }
#line 373
    dp = & d->d_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 376
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 376
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 377
  if (display->d_status_lastmsg) {
    {
#line 378
    free((void *)display->d_status_lastmsg);
    }
  }
#line 379
  if (display->d_obuf) {
    {
#line 380
    free((void *)display->d_obuf);
    }
  }
#line 381
  *dp = display->d_next;
#line 382
  cv = display->d_cvlist;
#line 391
  p = windows;
  {
#line 391
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 391
    if (! p) {
#line 391
      goto while_break___1;
    }
#line 393
    if ((unsigned long )p->w_pdisplay == (unsigned long )display) {
#line 394
      p->w_pdisplay = (struct display *)0;
    }
#line 395
    if ((unsigned long )p->w_lastdisp == (unsigned long )display) {
#line 396
      p->w_lastdisp = (struct display *)0;
    }
#line 397
    if ((unsigned long )p->w_readev.condneg == (unsigned long )(& display->d_status)) {
#line 398
      tmp = (int *)0;
#line 398
      p->w_readev.condneg = tmp;
#line 398
      p->w_readev.condpos = tmp;
    } else
#line 397
    if ((unsigned long )p->w_readev.condneg == (unsigned long )(& display->d_obuflenmax)) {
#line 398
      tmp = (int *)0;
#line 398
      p->w_readev.condneg = tmp;
#line 398
      p->w_readev.condpos = tmp;
    }
#line 391
    p = p->w_next;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 400
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 400
    if (! cv) {
#line 400
      goto while_break___2;
    }
    {
#line 402
    cvp = cv->c_next;
#line 403
    FreeCanvas(cv);
#line 400
    cv = cvp;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 406
  p = windows;
  {
#line 406
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 406
    if (! p) {
#line 406
      goto while_break___3;
    }
#line 407
    if ((unsigned long )p->w_zdisplay == (unsigned long )display) {
      {
#line 408
      zmodem_abort(p, (struct display *)0);
      }
    }
#line 406
    p = p->w_next;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 411
  free((void *)((char *)display));
#line 413
  display = (struct display *)0;
  }
#line 414
  return;
}
}
#line 416 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
int MakeDefaultCanvas(void) 
{ 
  struct canvas *cv ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 421
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 422
  tmp = calloc((size_t )1, (size_t )sizeof(*cv));
#line 422
  cv = (struct canvas *)tmp;
  }
#line 422
  if ((unsigned long )cv == (unsigned long )((struct canvas *)0)) {
#line 423
    return (-1);
  }
  {
#line 424
  cv->c_xs = 0;
#line 425
  cv->c_xe = display->d_width - 1;
#line 426
  cv->c_ys = 0;
#line 427
  cv->c_ye = ((display->d_height - 1) - (display->d_has_hstatus == 1)) - captionalways;
#line 428
  cv->c_xoff = 0;
#line 429
  cv->c_yoff = 0;
#line 430
  cv->c_next = (struct canvas *)0;
#line 431
  cv->c_display = display;
#line 432
  cv->c_vplist = (struct viewport *)0;
#line 433
  cv->c_captev.type = 0;
#line 434
  cv->c_captev.data = (char *)cv;
#line 435
  cv->c_captev.handler = & cv_winid_fn;
#line 437
  cv->c_blank.l_cvlist = cv;
#line 438
  cv->c_blank.l_width = (cv->c_xe - cv->c_xs) + 1;
#line 439
  cv->c_blank.l_height = (cv->c_ye - cv->c_ys) + 1;
#line 440
  tmp___0 = 0;
#line 440
  cv->c_blank.l_y = tmp___0;
#line 440
  cv->c_blank.l_x = tmp___0;
#line 441
  cv->c_blank.l_layfn = & BlankLf;
#line 442
  cv->c_blank.l_data = (char *)0;
#line 443
  cv->c_blank.l_next = (struct layer *)0;
#line 444
  cv->c_blank.l_bottom = & cv->c_blank;
#line 445
  cv->c_blank.l_blocking = 0;
#line 446
  cv->c_layer = & cv->c_blank;
#line 447
  cv->c_lnext = (struct canvas *)0;
#line 449
  display->d_cvlist = cv;
#line 450
  RethinkDisplayViewports();
#line 451
  display->d_forecv = cv;
  }
#line 452
  return (0);
}
}
#line 455 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
static void FreeCanvas(struct canvas *cv ) 
{ 
  struct viewport *vp ;
  struct viewport *nvp ;
  struct win *p ;

  {
  {
#line 462
  p = (struct win *)((cv->c_layer)->l_bottom)->l_data;
#line 463
  SetCanvasWindow(cv, (struct win *)0);
  }
#line 464
  if (p) {
    {
#line 465
    WindowChanged(p, 'u');
    }
  }
#line 466
  if ((unsigned long )flayer == (unsigned long )cv->c_layer) {
#line 467
    flayer = (struct layer *)0;
  }
#line 468
  vp = cv->c_vplist;
  {
#line 468
  while (1) {
    while_continue: /* CIL Label */ ;
#line 468
    if (! vp) {
#line 468
      goto while_break;
    }
    {
#line 470
    vp->v_canvas = (struct canvas *)0;
#line 471
    nvp = vp->v_next;
#line 472
    vp->v_next = (struct viewport *)0;
#line 473
    free((void *)vp);
#line 468
    vp = nvp;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 475
  evdeq(& cv->c_captev);
#line 476
  free((void *)cv);
  }
#line 477
  return;
}
}
#line 479 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
int AddCanvas(void) 
{ 
  int hh ;
  int h ;
  int i ;
  int j ;
  struct canvas *cv ;
  struct canvas **cvpp ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 485
  cv = display->d_cvlist;
#line 485
  j = 0;
  {
#line 485
  while (1) {
    while_continue: /* CIL Label */ ;
#line 485
    if (! cv) {
#line 485
      goto while_break;
    }
#line 486
    j ++;
#line 485
    cv = cv->c_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 487
  j ++;
#line 488
  h = display->d_height - (display->d_has_hstatus == 1);
#line 489
  if (h / j <= 1) {
#line 490
    return (-1);
  }
#line 492
  cv = display->d_cvlist;
  {
#line 492
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 492
    if (! cv) {
#line 492
      goto while_break___0;
    }
#line 493
    if ((unsigned long )cv == (unsigned long )display->d_forecv) {
#line 494
      goto while_break___0;
    }
#line 492
    cv = cv->c_next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 495
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 495
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 496
  cvpp = & cv->c_next;
#line 498
  tmp = calloc((size_t )1, (size_t )sizeof(*cv));
#line 498
  cv = (struct canvas *)tmp;
  }
#line 498
  if ((unsigned long )cv == (unsigned long )((struct canvas *)0)) {
#line 499
    return (-1);
  }
#line 501
  cv->c_xs = 0;
#line 502
  cv->c_xe = display->d_width - 1;
#line 503
  cv->c_ys = 0;
#line 504
  cv->c_ye = display->d_height - 1;
#line 505
  cv->c_xoff = 0;
#line 506
  cv->c_yoff = 0;
#line 507
  cv->c_display = display;
#line 508
  cv->c_vplist = (struct viewport *)0;
#line 509
  cv->c_captev.type = 0;
#line 510
  cv->c_captev.data = (char *)cv;
#line 511
  cv->c_captev.handler = & cv_winid_fn;
#line 513
  cv->c_blank.l_cvlist = cv;
#line 514
  cv->c_blank.l_width = (cv->c_xe - cv->c_xs) + 1;
#line 515
  cv->c_blank.l_height = (cv->c_ye - cv->c_ys) + 1;
#line 516
  tmp___0 = 0;
#line 516
  cv->c_blank.l_y = tmp___0;
#line 516
  cv->c_blank.l_x = tmp___0;
#line 517
  cv->c_blank.l_layfn = & BlankLf;
#line 518
  cv->c_blank.l_data = (char *)0;
#line 519
  cv->c_blank.l_next = (struct layer *)0;
#line 520
  cv->c_blank.l_bottom = & cv->c_blank;
#line 521
  cv->c_blank.l_blocking = 0;
#line 522
  cv->c_layer = & cv->c_blank;
#line 523
  cv->c_lnext = (struct canvas *)0;
#line 525
  cv->c_next = *cvpp;
#line 526
  *cvpp = cv;
#line 528
  i = 0;
#line 529
  cv = display->d_cvlist;
  {
#line 529
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 529
    if (! cv) {
#line 529
      goto while_break___2;
    }
#line 531
    tmp___1 = j;
#line 531
    j --;
#line 531
    hh = h / tmp___1 - 1;
#line 532
    cv->c_ys = i;
#line 533
    cv->c_ye = (i + hh) - 1;
#line 534
    cv->c_yoff = i;
#line 535
    i += hh + 1;
#line 536
    h -= hh + 1;
#line 529
    cv = cv->c_next;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 539
  RethinkDisplayViewports();
#line 540
  ResizeLayersToCanvases();
  }
#line 541
  return (0);
}
}
#line 544 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void RemCanvas(void) 
{ 
  int hh ;
  int h ;
  int i ;
  int j ;
  struct canvas *cv ;
  struct canvas **cvpp ;
  int did ;
  int tmp ;

  {
#line 549
  did = 0;
#line 551
  h = display->d_height - (display->d_has_hstatus == 1);
#line 552
  cv = display->d_cvlist;
#line 552
  j = 0;
  {
#line 552
  while (1) {
    while_continue: /* CIL Label */ ;
#line 552
    if (! cv) {
#line 552
      goto while_break;
    }
#line 553
    j ++;
#line 552
    cv = cv->c_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 554
  if (j == 1) {
#line 555
    return;
  }
#line 556
  i = 0;
#line 557
  j --;
#line 558
  cvpp = & display->d_cvlist;
  {
#line 558
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 558
    cv = *cvpp;
#line 558
    if (! cv) {
#line 558
      goto while_break___0;
    }
#line 560
    if ((unsigned long )cv == (unsigned long )display->d_forecv) {
#line 560
      if (! did) {
        {
#line 562
        *cvpp = cv->c_next;
#line 563
        FreeCanvas(cv);
#line 564
        cv = *cvpp;
        }
#line 565
        if (cv) {
#line 565
          display->d_forecv = cv;
        } else {
#line 565
          display->d_forecv = display->d_cvlist;
        }
#line 566
        display->d_fore = (struct win *)(((display->d_forecv)->c_layer)->l_bottom)->l_data;
#line 567
        flayer = (display->d_forecv)->c_layer;
#line 568
        if ((unsigned long )cv == (unsigned long )((struct canvas *)0)) {
#line 569
          goto while_break___0;
        }
#line 570
        did = 1;
      }
    }
#line 572
    tmp = j;
#line 572
    j --;
#line 572
    hh = h / tmp - 1;
#line 573
    if (! captionalways) {
#line 573
      if (i == 0) {
#line 573
        if (j == 0) {
#line 574
          hh ++;
        }
      }
    }
#line 575
    cv->c_ys = i;
#line 576
    cv->c_ye = (i + hh) - 1;
#line 577
    cv->c_yoff = i;
#line 578
    i += hh + 1;
#line 579
    h -= hh + 1;
#line 558
    cvpp = & cv->c_next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 581
  RethinkDisplayViewports();
#line 582
  ResizeLayersToCanvases();
  }
#line 583
  return;
}
}
#line 585 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void OneCanvas(void) 
{ 
  struct canvas *mycv ;
  struct canvas *cv ;
  struct canvas **cvpp ;

  {
#line 588
  mycv = display->d_forecv;
#line 591
  cvpp = & display->d_cvlist;
  {
#line 591
  while (1) {
    while_continue: /* CIL Label */ ;
#line 591
    cv = *cvpp;
#line 591
    if (! cv) {
#line 591
      goto while_break;
    }
#line 593
    if ((unsigned long )cv == (unsigned long )mycv) {
#line 595
      cv->c_ys = 0;
#line 596
      cv->c_ye = ((display->d_height - 1) - (display->d_has_hstatus == 1)) - captionalways;
#line 597
      cv->c_yoff = 0;
#line 598
      cvpp = & cv->c_next;
    } else {
      {
#line 602
      *cvpp = cv->c_next;
#line 603
      FreeCanvas(cv);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 606
  RethinkDisplayViewports();
#line 607
  ResizeLayersToCanvases();
  }
#line 608
  return;
}
}
#line 610 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
int RethinkDisplayViewports(void) 
{ 
  struct canvas *cv ;
  struct viewport *vp ;
  struct viewport *vpn ;
  void *tmp ;

  {
#line 617
  cv = display->d_cvlist;
  {
#line 617
  while (1) {
    while_continue: /* CIL Label */ ;
#line 617
    if (! cv) {
#line 617
      goto while_break;
    }
#line 619
    vp = cv->c_vplist;
    {
#line 619
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 619
      if (! vp) {
#line 619
        goto while_break___0;
      }
      {
#line 621
      vp->v_canvas = (struct canvas *)0;
#line 622
      vpn = vp->v_next;
#line 623
      bzero((void *)((char *)vp), (size_t )sizeof(*vp));
#line 624
      free((void *)vp);
#line 619
      vp = vpn;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 626
    cv->c_vplist = (struct viewport *)0;
#line 617
    cv = cv->c_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 628
  display->d_vpxmin = -1;
#line 629
  display->d_vpxmax = -1;
#line 631
  cv = display->d_cvlist;
  {
#line 631
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 631
    if (! cv) {
#line 631
      goto while_break___1;
    }
    {
#line 633
    tmp = malloc((size_t )sizeof(*vp));
#line 633
    vp = (struct viewport *)tmp;
    }
#line 633
    if ((unsigned long )vp == (unsigned long )((struct viewport *)0)) {
#line 634
      return (-1);
    }
#line 682
    vp->v_canvas = cv;
#line 683
    vp->v_xs = cv->c_xs;
#line 684
    vp->v_ys = cv->c_ys;
#line 685
    vp->v_xe = cv->c_xe;
#line 686
    vp->v_ye = cv->c_ye;
#line 687
    vp->v_xoff = cv->c_xoff;
#line 688
    vp->v_yoff = cv->c_yoff;
#line 689
    vp->v_next = cv->c_vplist;
#line 690
    cv->c_vplist = vp;
#line 693
    if (cv->c_xs < display->d_vpxmin) {
#line 694
      display->d_vpxmin = cv->c_xs;
    } else
#line 693
    if (display->d_vpxmin == -1) {
#line 694
      display->d_vpxmin = cv->c_xs;
    }
#line 695
    if (cv->c_xe > display->d_vpxmax) {
#line 696
      display->d_vpxmax = cv->c_xe;
    } else
#line 695
    if (display->d_vpxmax == -1) {
#line 696
      display->d_vpxmax = cv->c_xe;
    }
#line 631
    cv = cv->c_next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 698
  return (0);
}
}
#line 701 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void RethinkViewportOffsets(struct canvas *cv ) 
{ 
  struct viewport *vp ;

  {
#line 707
  vp = cv->c_vplist;
  {
#line 707
  while (1) {
    while_continue: /* CIL Label */ ;
#line 707
    if (! vp) {
#line 707
      goto while_break;
    }
#line 709
    vp->v_xoff = cv->c_xoff;
#line 710
    vp->v_yoff = cv->c_yoff;
#line 707
    vp = vp->v_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 712
  return;
}
}
#line 718 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void InitTerm(int adapt ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 722
  while (1) {
    while_continue: /* CIL Label */ ;
#line 722
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 723
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 723
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 724
  tmp = -1;
#line 724
  display->d_bot = tmp;
#line 724
  display->d_top = tmp;
#line 725
  AddCStr(display->d_tcs[40].str);
#line 726
  AddCStr(display->d_tcs[39].str);
  }
#line 728
  if (display->d_tcs[27].str) {
    {
#line 728
    tmp___0 = strcmp((char const   *)display->d_tcs[27].str, (char const   *)display->d_tcs[28].str);
    }
#line 728
    if (tmp___0) {
      {
#line 729
      AddCStr(display->d_tcs[28].str);
      }
    }
  }
  {
#line 730
  display->d_insert = 0;
#line 732
  AddCStr(display->d_tcs[69].str);
#line 733
  AddCStr(display->d_tcs[71].str);
#line 741
  display->d_keypad = 0;
#line 742
  display->d_cursorkeys = 0;
#line 743
  AddCStr(display->d_tcs[55].str);
#line 744
  AddCStr(display->d_tcs[104].str);
#line 745
  AddCStr(display->d_tcs[99].str);
#line 746
  display->d_rend = mchar_null;
#line 747
  display->d_atyp = (char)0;
  }
#line 748
  if (adapt == 0) {
    {
#line 749
    ResizeDisplay(display->d_defwidth, display->d_defheight);
    }
  }
  {
#line 750
  ChangeScrollRegion(0, display->d_height - 1);
#line 751
  tmp___1 = 0;
#line 751
  display->d_y = tmp___1;
#line 751
  display->d_x = tmp___1;
#line 752
  Flush();
#line 753
  ClearAll();
  }
  {
#line 754
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 754
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 757
  if (adapt) {
#line 757
    tmp___2 = 2;
  } else {
#line 757
    tmp___2 = 0;
  }
  {
#line 757
  CheckScreenSize(tmp___2);
  }
#line 758
  return;
}
}
#line 760 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void FinitTerm(void) 
{ 
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 763
  while (1) {
    while_continue: /* CIL Label */ ;
#line 763
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 765
  KillBlanker();
  }
#line 767
  if (display->d_tcinited) {
    {
#line 769
    ResizeDisplay(display->d_defwidth, display->d_defheight);
#line 770
    InsertMode(0);
#line 771
    ChangeScrollRegion(0, display->d_height - 1);
#line 772
    KeypadMode(0);
#line 773
    CursorkeysMode(0);
#line 774
    CursorVisibility(0);
#line 775
    MouseMode(0);
#line 776
    SetRendition(& mchar_null);
#line 777
    SetFlow(1);
#line 779
    AddCStr(display->d_tcs[70].str);
#line 780
    AddCStr(display->d_tcs[72].str);
    }
#line 782
    if (display->d_hstatus) {
      {
#line 783
      ShowHStatus((char *)0);
      }
    }
    {
#line 787
    tmp = -1;
#line 787
    display->d_y = tmp;
#line 787
    display->d_x = tmp;
#line 788
    GotoPos(0, display->d_height - 1);
    }
    {
#line 789
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 789
      (display->d_obuffree) --;
#line 789
      if (display->d_obuffree <= 0) {
        {
#line 789
        Resize_obuf();
        }
      }
#line 789
      tmp___0 = display->d_obufp;
#line 789
      (display->d_obufp) ++;
#line 789
      *tmp___0 = (char )'\r';
#line 789
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 790
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 790
      (display->d_obuffree) --;
#line 790
      if (display->d_obuffree <= 0) {
        {
#line 790
        Resize_obuf();
        }
      }
#line 790
      tmp___1 = display->d_obufp;
#line 790
      (display->d_obufp) ++;
#line 790
      *tmp___1 = (char )'\n';
#line 790
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 791
    AddCStr(display->d_tcs[41].str);
    }
  }
  {
#line 793
  Flush();
  }
#line 794
  return;
}
}
#line 797 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
static void INSERTCHAR(int c ) 
{ 


  {
  {
#line 801
  while (1) {
    while_continue: /* CIL Label */ ;
#line 801
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 802
  if (! display->d_insert) {
#line 802
    if (display->d_x < display->d_width - 1) {
#line 804
      if (display->d_tcs[29].str) {
#line 804
        goto _L;
      } else
#line 804
      if (display->d_tcs[30].str) {
        _L: /* CIL Label */ 
#line 806
        if (display->d_tcs[29].str) {
          {
#line 807
          AddCStr(display->d_tcs[29].str);
          }
        } else {
          {
#line 809
          AddCStr2(display->d_tcs[30].str, 1);
          }
        }
        {
#line 810
        RAW_PUTCHAR(c);
        }
#line 811
        return;
      }
      {
#line 813
      InsertMode(1);
      }
#line 814
      if (! display->d_insert) {
        {
#line 816
        RefreshLine(display->d_y, display->d_x, display->d_width - 1, 0);
        }
#line 817
        return;
      }
    }
  }
  {
#line 820
  RAW_PUTCHAR(c);
  }
#line 821
  return;
}
}
#line 823 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void PUTCHAR(int c ) 
{ 


  {
  {
#line 827
  while (1) {
    while_continue: /* CIL Label */ ;
#line 827
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 828
  if (display->d_insert) {
#line 828
    if (display->d_x < display->d_width - 1) {
      {
#line 829
      InsertMode(0);
      }
    }
  }
  {
#line 830
  RAW_PUTCHAR(c);
  }
#line 831
  return;
}
}
#line 833 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void PUTCHARLP(int c ) 
{ 
  int y ;

  {
#line 837
  if (display->d_x < display->d_width - 1) {
#line 839
    if (display->d_insert) {
      {
#line 840
      InsertMode(0);
      }
    }
    {
#line 841
    RAW_PUTCHAR(c);
    }
#line 842
    return;
  }
#line 844
  if (display->d_tcs[87].flg) {
#line 844
    goto _L;
  } else
#line 844
  if (display->d_y != display->d_bot) {
    _L: /* CIL Label */ 
    {
#line 846
    y = display->d_y;
#line 847
    RAW_PUTCHAR(c);
    }
#line 848
    if (display->d_tcs[83].flg) {
#line 848
      if (! display->d_tcs[87].flg) {
        {
#line 849
        GotoPos(display->d_width - 1, y);
        }
      }
    }
#line 850
    return;
  }
  {
#line 852
  while (1) {
    while_continue: /* CIL Label */ ;
#line 852
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 853
  display->d_lp_missing = 1;
#line 854
  display->d_rend.image = (unsigned char )c;
#line 855
  display->d_lpchar = display->d_rend;
#line 858
  if (display->d_mbcs) {
#line 860
    display->d_lpchar.mbcs = (unsigned char )c;
#line 861
    display->d_lpchar.image = (unsigned char )display->d_mbcs;
#line 862
    display->d_mbcs = 0;
#line 863
    (display->d_x) --;
  }
#line 866
  return;
}
}
#line 873 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
static void RAW_PUTCHAR(int c ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int t ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 877
  while (1) {
    while_continue: /* CIL Label */ ;
#line 877
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 881
  if (display->d_encoding == 8) {
#line 883
    c = (c & 255) | ((int )display->d_rend.font << 8);
#line 885
    if (display->d_mbcs) {
#line 887
      c = display->d_mbcs;
#line 888
      if (display->d_x == display->d_width) {
#line 889
        if (display->d_tcs[83].flg) {
#line 889
          tmp = 1;
        } else {
#line 889
          tmp = -1;
        }
#line 889
        display->d_x += tmp;
      }
#line 890
      display->d_mbcs = 0;
    } else {
      {
#line 892
      tmp___0 = utf8_isdouble(c);
      }
#line 892
      if (tmp___0) {
#line 894
        display->d_mbcs = c;
#line 895
        (display->d_x) ++;
#line 896
        return;
      }
    }
#line 899
    if (c < 32) {
      {
#line 901
      AddCStr2(display->d_tcs[98].str, '0');
      }
      {
#line 902
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 902
        (display->d_obuffree) --;
#line 902
        if (display->d_obuffree <= 0) {
          {
#line 902
          Resize_obuf();
          }
        }
#line 902
        tmp___1 = display->d_obufp;
#line 902
        (display->d_obufp) ++;
#line 902
        *tmp___1 = (char )(c + 95);
#line 902
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 903
      AddCStr(display->d_tcs[99].str);
      }
#line 904
      goto addedutf8;
    }
    {
#line 906
    AddUtf8(c);
    }
#line 907
    goto addedutf8;
  }
#line 911
  if (display->d_rend.font) {
#line 911
    if (((int )display->d_rend.font & 96) == 0) {
#line 913
      t = c;
#line 914
      if (display->d_mbcs == 0) {
#line 916
        display->d_mbcs = c;
#line 917
        (display->d_x) ++;
#line 918
        return;
      }
#line 920
      (display->d_x) --;
#line 921
      if (display->d_x == display->d_width - 1) {
#line 922
        if (display->d_tcs[83].flg) {
#line 922
          tmp___2 = 1;
        } else {
#line 922
          tmp___2 = -1;
        }
#line 922
        display->d_x += tmp___2;
      }
#line 923
      c = display->d_mbcs;
#line 924
      display->d_mbcs = t;
    }
  }
#line 928
  if (display->d_encoding) {
    {
#line 929
    c = PrepareEncodedChar(c);
    }
  }
  kanjiloop: 
#line 934
  if (display->d_xtable) {
#line 934
    if (*(display->d_xtable + (int )display->d_rend.font)) {
#line 934
      if (*(*(display->d_xtable + (int )display->d_rend.font) + (int )((unsigned char )c))) {
        {
#line 935
        AddStr(*(*(display->d_xtable + (int )display->d_rend.font) + (int )((unsigned char )c)));
        }
      } else {
#line 934
        goto _L___0;
      }
    } else {
#line 934
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 937
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 937
      (display->d_obuffree) --;
#line 937
      if (display->d_obuffree <= 0) {
        {
#line 937
        Resize_obuf();
        }
      }
#line 937
      tmp___3 = display->d_obufp;
#line 937
      (display->d_obufp) ++;
#line 937
      if ((int )display->d_rend.font != 48) {
#line 937
        *tmp___3 = (char )c;
      } else {
#line 937
        *tmp___3 = display->d_c0_tab[(int )((unsigned char )c)];
      }
#line 937
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  addedutf8: 
#line 945
  (display->d_x) ++;
#line 945
  if (display->d_x >= display->d_width) {
#line 947
    if (display->d_tcs[83].flg == 0) {
#line 948
      display->d_x = display->d_width - 1;
    } else
#line 949
    if (! display->d_tcs[87].flg) {
#line 949
      goto _L___1;
    } else
#line 949
    if (display->d_x > display->d_width) {
      _L___1: /* CIL Label */ 
#line 951
      display->d_x -= display->d_width;
#line 952
      if (display->d_y < display->d_height - 1) {
#line 952
        if (display->d_y != display->d_bot) {
#line 953
          (display->d_y) ++;
        }
      }
    }
  }
#line 957
  if (display->d_mbcs) {
#line 959
    c = display->d_mbcs;
#line 960
    display->d_mbcs = 0;
#line 961
    goto kanjiloop;
  }
#line 964
  return;
}
}
#line 966 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
static int DoAddChar(int c ) 
{ 
  char *tmp ;

  {
  {
#line 971
  while (1) {
    while_continue: /* CIL Label */ ;
#line 971
    (display->d_obuffree) --;
#line 971
    if (display->d_obuffree <= 0) {
      {
#line 971
      Resize_obuf();
      }
    }
#line 971
    tmp = display->d_obufp;
#line 971
    (display->d_obufp) ++;
#line 971
    *tmp = (char )c;
#line 971
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 972
  return (c);
}
}
#line 975 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void AddCStr(char *s ) 
{ 


  {
#line 979
  if (display) {
#line 979
    if (s) {
#line 979
      if (*s) {
        {
#line 981
        ospeed = display->d_dospeed;
#line 982
        xtputs(s, 1, & DoAddChar);
        }
      }
    }
  }
#line 984
  return;
}
}
#line 986 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void AddCStr2(char *s , int c ) 
{ 
  char *tmp ;

  {
#line 991
  if (display) {
#line 991
    if (s) {
#line 991
      if (*s) {
        {
#line 993
        ospeed = display->d_dospeed;
#line 994
        tmp = tgoto(s, 0, c);
#line 994
        xtputs(tmp, 1, & DoAddChar);
        }
      }
    }
  }
#line 996
  return;
}
}
#line 1001 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void InsertMode(int on ) 
{ 


  {
#line 1005
  if (display) {
#line 1005
    if (on != display->d_insert) {
#line 1005
      if (display->d_tcs[27].str) {
#line 1007
        display->d_insert = on;
#line 1008
        if (on) {
          {
#line 1009
          AddCStr(display->d_tcs[27].str);
          }
        } else {
          {
#line 1011
          AddCStr(display->d_tcs[28].str);
          }
        }
      }
    }
  }
#line 1013
  return;
}
}
#line 1017 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void KeypadMode(int on ) 
{ 


  {
#line 1022
  if (display) {
#line 1023
    display->d_keypad = on;
  }
#line 1034
  return;
}
}
#line 1036 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void CursorkeysMode(int on ) 
{ 


  {
#line 1041
  if (display) {
#line 1042
    display->d_cursorkeys = on;
  }
#line 1053
  return;
}
}
#line 1055 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void ReverseVideo(int on ) 
{ 


  {
#line 1059
  if (display) {
#line 1059
    if (display->d_revvid != on) {
#line 1059
      if (display->d_tcs[93].str) {
#line 1061
        display->d_revvid = on;
#line 1062
        if (display->d_revvid) {
          {
#line 1063
          AddCStr(display->d_tcs[93].str);
          }
        } else {
          {
#line 1065
          AddCStr(display->d_tcs[94].str);
          }
        }
      }
    }
  }
#line 1067
  return;
}
}
#line 1069 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void CursorVisibility(int v ) 
{ 


  {
#line 1073
  if (display) {
#line 1073
    if (display->d_curvis != v) {
#line 1075
      if (display->d_curvis) {
        {
#line 1076
        AddCStr(display->d_tcs[82].str);
        }
      }
#line 1077
      display->d_curvis = 0;
#line 1078
      if (v == -1) {
#line 1078
        if (display->d_tcs[80].str) {
          {
#line 1079
          AddCStr(display->d_tcs[80].str);
          }
        } else {
#line 1078
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1080
      if (v == 1) {
#line 1080
        if (display->d_tcs[81].str) {
          {
#line 1081
          AddCStr(display->d_tcs[81].str);
          }
        } else {
#line 1083
          return;
        }
      } else {
#line 1083
        return;
      }
#line 1084
      display->d_curvis = v;
    }
  }
#line 1086
  return;
}
}
#line 1088 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void MouseMode(int mode ) 
{ 
  char mousebuf[20] ;

  {
#line 1092
  if (display) {
#line 1092
    if (display->d_mouse != mode) {
#line 1095
      if (! display->d_tcs[96].flg) {
#line 1096
        return;
      }
#line 1097
      if (display->d_mouse) {
        {
#line 1099
        sprintf((char */* __restrict  */)(mousebuf), (char const   */* __restrict  */)"\033[?%dl",
                display->d_mouse);
#line 1100
        AddStr(mousebuf);
        }
      }
#line 1102
      if (mode) {
        {
#line 1104
        sprintf((char */* __restrict  */)(mousebuf), (char const   */* __restrict  */)"\033[?%dh",
                mode);
#line 1105
        AddStr(mousebuf);
        }
      }
#line 1107
      display->d_mouse = mode;
    }
  }
#line 1109
  return;
}
}
#line 1111 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
static int StrCost  ;
#line 1114 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
static int CountChars(int c ) 
{ 


  {
#line 1118
  StrCost ++;
#line 1119
  return (c);
}
}
#line 1122 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
int CalcCost(char *s ) 
{ 


  {
  {
#line 1126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1126
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1127
  if (s) {
    {
#line 1129
    StrCost = 0;
#line 1130
    ospeed = display->d_dospeed;
#line 1131
    xtputs(s, 1, & CountChars);
    }
#line 1132
    return (StrCost);
  } else {
#line 1135
    return (1000);
  }
}
}
#line 1138 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
static int CallRewrite(int y , int xs , int xe , int doit ) 
{ 
  struct canvas *cv ;
  struct canvas *cvlist ;
  struct canvas *cvlnext ;
  struct viewport *vp ;
  struct layer *oldflayer ;
  int cost ;

  {
  {
#line 1147
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1147
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1148
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1148
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1149
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1149
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1151
  vp = (struct viewport *)0;
#line 1152
  cv = display->d_cvlist;
  {
#line 1152
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1152
    if (! cv) {
#line 1152
      goto while_break___2;
    }
#line 1154
    if (y < cv->c_ys) {
#line 1155
      goto __Cont;
    } else
#line 1154
    if (y > cv->c_ye) {
#line 1155
      goto __Cont;
    } else
#line 1154
    if (xe < cv->c_xs) {
#line 1155
      goto __Cont;
    } else
#line 1154
    if (xs > cv->c_xe) {
#line 1155
      goto __Cont;
    }
#line 1156
    vp = cv->c_vplist;
    {
#line 1156
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1156
      if (! vp) {
#line 1156
        goto while_break___3;
      }
#line 1157
      if (y >= vp->v_ys) {
#line 1157
        if (y <= vp->v_ye) {
#line 1157
          if (xe >= vp->v_xs) {
#line 1157
            if (xs <= vp->v_xe) {
#line 1158
              goto while_break___3;
            }
          }
        }
      }
#line 1156
      vp = vp->v_next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1159
    if (vp) {
#line 1160
      goto while_break___2;
    }
    __Cont: /* CIL Label */ 
#line 1152
    cv = cv->c_next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1162
  if (doit) {
    {
#line 1164
    oldflayer = flayer;
#line 1165
    flayer = cv->c_layer;
#line 1166
    cvlist = flayer->l_cvlist;
#line 1167
    cvlnext = cv->c_lnext;
#line 1168
    flayer->l_cvlist = cv;
#line 1169
    cv->c_lnext = (struct canvas *)0;
#line 1170
    (*((flayer->l_layfn)->lf_LayRewrite))(y - vp->v_yoff, xs - vp->v_xoff, xe - vp->v_xoff,
                                          & display->d_rend, 1);
#line 1171
    flayer->l_cvlist = cvlist;
#line 1172
    cv->c_lnext = cvlnext;
#line 1173
    flayer = oldflayer;
    }
#line 1174
    return (0);
  }
#line 1176
  if ((unsigned long )cv == (unsigned long )((struct canvas *)0)) {
#line 1177
    return (1000);
  } else
#line 1176
  if ((unsigned long )cv->c_layer == (unsigned long )((struct layer *)0)) {
#line 1177
    return (1000);
  }
#line 1178
  if (xs < vp->v_xs) {
#line 1179
    return (1000);
  } else
#line 1178
  if (xe > vp->v_xe) {
#line 1179
    return (1000);
  }
#line 1180
  if (y - vp->v_yoff < 0) {
#line 1181
    return (1000);
  } else
#line 1180
  if (y - vp->v_yoff >= (cv->c_layer)->l_height) {
#line 1181
    return (1000);
  }
#line 1182
  if (xs - vp->v_xoff < 0) {
#line 1183
    return (1000);
  } else
#line 1182
  if (xe - vp->v_xoff >= (cv->c_layer)->l_width) {
#line 1183
    return (1000);
  }
#line 1185
  if (display->d_encoding == 8) {
#line 1186
    display->d_rend.font = (unsigned char)0;
  }
#line 1188
  oldflayer = flayer;
#line 1189
  flayer = cv->c_layer;
  {
#line 1190
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1190
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 1191
  cost = (*((flayer->l_layfn)->lf_LayRewrite))(y - vp->v_yoff, xs - vp->v_xoff, xe - vp->v_xoff,
                                               & display->d_rend, 0);
#line 1192
  flayer = oldflayer;
  }
#line 1193
  if (display->d_insert) {
#line 1194
    cost += display->d_EIcost + display->d_IMcost;
  }
#line 1195
  return (cost);
}
}
#line 1199 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void GotoPos(int x2 , int y2 ) 
{ 
  register int dy ;
  register int dx ;
  register int x1 ;
  register int y1 ;
  register int costx ;
  register int costy ;
  register int m___0 ;
  register char *s ;
  int CMcost ;
  enum move_t xm ;
  enum move_t ym ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 1208
  xm = (enum move_t )0;
#line 1208
  ym = (enum move_t )0;
#line 1210
  if (! display) {
#line 1211
    return;
  }
#line 1213
  x1 = display->d_x;
#line 1214
  y1 = display->d_y;
#line 1216
  if (x1 == display->d_width) {
#line 1218
    if (display->d_tcs[87].flg) {
#line 1218
      if (display->d_tcs[83].flg) {
#line 1219
        x1 = -1;
      } else {
#line 1221
        x1 --;
      }
    } else {
#line 1221
      x1 --;
    }
  }
#line 1223
  if (x2 == display->d_width) {
#line 1224
    x2 --;
  }
#line 1225
  dx = x2 - x1;
#line 1226
  dy = y2 - y1;
#line 1227
  if (dy == 0) {
#line 1227
    if (dx == 0) {
#line 1228
      return;
    }
  }
  {
#line 1229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1229
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1230
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1230
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1231
  if (! display->d_tcs[56].flg) {
    {
#line 1232
    SetRendition(& mchar_null);
    }
  }
#line 1233
  if (y1 < 0) {
#line 1233
    goto DoCM;
  } else
#line 1233
  if (y2 > display->d_bot) {
#line 1233
    if (y1 <= display->d_bot) {
#line 1233
      goto DoCM;
    } else {
#line 1233
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1233
  if (y2 < display->d_top) {
#line 1233
    if (y1 >= display->d_top) {
      DoCM: 
#line 1238
      if (display->d_tcs[6].str) {
#line 1238
        if (! x2) {
#line 1238
          if (! y2) {
            {
#line 1239
            AddCStr(display->d_tcs[6].str);
            }
          } else {
            {
#line 1241
            tmp = tgoto(display->d_tcs[5].str, x2, y2);
#line 1241
            AddCStr(tmp);
            }
          }
        } else {
          {
#line 1241
          tmp = tgoto(display->d_tcs[5].str, x2, y2);
#line 1241
          AddCStr(tmp);
          }
        }
      } else {
        {
#line 1241
        tmp = tgoto(display->d_tcs[5].str, x2, y2);
#line 1241
        AddCStr(tmp);
        }
      }
#line 1242
      display->d_x = x2;
#line 1243
      display->d_y = y2;
#line 1244
      return;
    }
  }
#line 1250
  if (y1 > display->d_bot) {
#line 1250
    if (y2 > y1) {
#line 1251
      goto DoCM;
    } else {
#line 1250
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1250
  if (y1 < display->d_top) {
#line 1250
    if (y2 < y1) {
#line 1251
      goto DoCM;
    }
  }
#line 1254
  if (display->d_tcs[6].str) {
#line 1254
    if (! x2) {
#line 1254
      if (! y2) {
#line 1255
        s = display->d_tcs[6].str;
      } else {
        {
#line 1257
        s = tgoto(display->d_tcs[5].str, x2, y2);
        }
      }
    } else {
      {
#line 1257
      s = tgoto(display->d_tcs[5].str, x2, y2);
      }
    }
  } else {
    {
#line 1257
    s = tgoto(display->d_tcs[5].str, x2, y2);
    }
  }
  {
#line 1258
  CMcost = CalcCost(s);
#line 1261
  costx = 1000;
  }
#line 1262
  if (x1 >= 0) {
#line 1264
    if (dx > 0) {
#line 1266
      if (display->d_tcs[17].str) {
#line 1266
        if (dx > 1) {
          {
#line 1268
          tmp___0 = tgoto(display->d_tcs[17].str, 0, dx);
#line 1268
          costx = CalcCost(tmp___0);
#line 1269
          xm = (enum move_t )8;
          }
        } else
#line 1266
        if (! display->d_tcs[16].str) {
          {
#line 1268
          tmp___0 = tgoto(display->d_tcs[17].str, 0, dx);
#line 1268
          costx = CalcCost(tmp___0);
#line 1269
          xm = (enum move_t )8;
          }
        }
      }
#line 1271
      m___0 = display->d_NDcost * dx;
#line 1271
      if (m___0 < costx) {
#line 1273
        costx = m___0;
#line 1274
        xm = (enum move_t )7;
      }
#line 1277
      if (dx < costx) {
        {
#line 1277
        m___0 = CallRewrite(y1, x1, x2 - 1, 0);
        }
#line 1277
        if (m___0 < costx) {
#line 1279
          costx = m___0;
#line 1280
          xm = (enum move_t )9;
        }
      }
    } else
#line 1283
    if (dx < 0) {
#line 1285
      if (display->d_tcs[15].str) {
#line 1285
        if (dx < -1) {
          {
#line 1287
          tmp___1 = tgoto(display->d_tcs[15].str, 0, - dx);
#line 1287
          costx = CalcCost(tmp___1);
#line 1288
          xm = (enum move_t )6;
          }
        } else
#line 1285
        if (! display->d_tcs[13].str) {
          {
#line 1287
          tmp___1 = tgoto(display->d_tcs[15].str, 0, - dx);
#line 1287
          costx = CalcCost(tmp___1);
#line 1288
          xm = (enum move_t )6;
          }
        }
      }
#line 1290
      m___0 = - dx * display->d_LEcost;
#line 1290
      if (m___0 < costx) {
#line 1292
        costx = m___0;
#line 1293
        xm = (enum move_t )5;
      }
    } else {
#line 1297
      costx = 0;
    }
  }
#line 1300
  if (x2 + display->d_CRcost < costx) {
#line 1300
    if (x2) {
      {
#line 1300
      tmp___2 = CallRewrite(y1, 0, x2 - 1, 0);
#line 1300
      tmp___3 = tmp___2;
      }
    } else {
#line 1300
      tmp___3 = 0;
    }
#line 1300
    m___0 = tmp___3 + display->d_CRcost;
#line 1300
    if (m___0 < costx) {
#line 1302
      costx = m___0;
#line 1303
      xm = (enum move_t )10;
    }
  }
#line 1307
  if (costx >= CMcost) {
#line 1308
    goto DoCM;
  }
#line 1311
  costy = 1000;
#line 1312
  if (dy > 0) {
#line 1314
    if (display->d_tcs[11].str) {
#line 1314
      if (dy > 1) {
        {
#line 1316
        tmp___4 = tgoto(display->d_tcs[11].str, 0, dy);
#line 1316
        costy = CalcCost(tmp___4);
#line 1317
        ym = (enum move_t )4;
        }
      }
    }
#line 1319
    if (x2 == 0) {
#line 1319
      tmp___5 = display->d_NLcost;
    } else {
#line 1319
      tmp___5 = display->d_DOcost;
    }
#line 1319
    m___0 = dy * tmp___5;
#line 1319
    if (m___0 < costy) {
#line 1321
      costy = m___0;
#line 1322
      ym = (enum move_t )3;
    }
  } else
#line 1325
  if (dy < 0) {
#line 1327
    if (display->d_tcs[9].str) {
#line 1327
      if (dy < -1) {
        {
#line 1329
        tmp___6 = tgoto(display->d_tcs[9].str, 0, - dy);
#line 1329
        costy = CalcCost(tmp___6);
#line 1330
        ym = (enum move_t )2;
        }
      } else
#line 1327
      if (! display->d_tcs[8].str) {
        {
#line 1329
        tmp___6 = tgoto(display->d_tcs[9].str, 0, - dy);
#line 1329
        costy = CalcCost(tmp___6);
#line 1330
        ym = (enum move_t )2;
        }
      }
    }
#line 1332
    m___0 = - dy * display->d_UPcost;
#line 1332
    if (m___0 < costy) {
#line 1334
      costy = m___0;
#line 1335
      ym = (enum move_t )1;
    }
  } else {
#line 1339
    costy = 0;
  }
#line 1342
  if (costx + costy >= CMcost) {
#line 1343
    goto DoCM;
  }
  {
#line 1347
  if ((unsigned int )xm == 5U) {
#line 1347
    goto case_5;
  }
#line 1351
  if ((unsigned int )xm == 6U) {
#line 1351
    goto case_6;
  }
#line 1354
  if ((unsigned int )xm == 7U) {
#line 1354
    goto case_7;
  }
#line 1358
  if ((unsigned int )xm == 8U) {
#line 1358
    goto case_8;
  }
#line 1361
  if ((unsigned int )xm == 10U) {
#line 1361
    goto case_10;
  }
#line 1366
  if ((unsigned int )xm == 9U) {
#line 1366
    goto case_9;
  }
#line 1370
  goto switch_default;
  case_5: /* CIL Label */ 
  {
#line 1348
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1348
    tmp___7 = dx;
#line 1348
    dx ++;
#line 1348
    if (! (tmp___7 < 0)) {
#line 1348
      goto while_break___1;
    }
    {
#line 1349
    AddCStr(display->d_tcs[13].str);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1350
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 1352
  AddCStr2(display->d_tcs[15].str, - dx);
  }
#line 1353
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 1355
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1355
    tmp___8 = dx;
#line 1355
    dx --;
#line 1355
    if (! (tmp___8 > 0)) {
#line 1355
      goto while_break___2;
    }
    {
#line 1356
    AddCStr(display->d_tcs[16].str);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1357
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 1359
  AddCStr2(display->d_tcs[17].str, dx);
  }
#line 1360
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 1362
  AddCStr(display->d_tcs[7].str);
#line 1363
  display->d_x = 0;
#line 1364
  x1 = 0;
  }
  case_9: /* CIL Label */ 
#line 1367
  if (x1 < x2) {
    {
#line 1368
    CallRewrite(y1, x1, x2 - 1, 1);
    }
  }
#line 1369
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1371
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1376
  if ((unsigned int )ym == 1U) {
#line 1376
    goto case_1;
  }
#line 1380
  if ((unsigned int )ym == 2U) {
#line 1380
    goto case_2;
  }
#line 1383
  if ((unsigned int )ym == 3U) {
#line 1383
    goto case_3;
  }
#line 1388
  if ((unsigned int )ym == 4U) {
#line 1388
    goto case_4;
  }
#line 1391
  goto switch_default___0;
  case_1: /* CIL Label */ 
  {
#line 1377
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1377
    tmp___9 = dy;
#line 1377
    dy ++;
#line 1377
    if (! (tmp___9 < 0)) {
#line 1377
      goto while_break___3;
    }
    {
#line 1378
    AddCStr(display->d_tcs[8].str);
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1379
  goto switch_break___0;
  case_2: /* CIL Label */ 
  {
#line 1381
  AddCStr2(display->d_tcs[9].str, - dy);
  }
#line 1382
  goto switch_break___0;
  case_3: /* CIL Label */ 
#line 1384
  if (x2 == 0) {
#line 1384
    s = display->d_tcs[19].str;
  } else {
#line 1384
    s = display->d_tcs[10].str;
  }
  {
#line 1385
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1385
    tmp___10 = dy;
#line 1385
    dy --;
#line 1385
    if (! (tmp___10 > 0)) {
#line 1385
      goto while_break___4;
    }
    {
#line 1386
    AddCStr(s);
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1387
  goto switch_break___0;
  case_4: /* CIL Label */ 
  {
#line 1389
  AddCStr2(display->d_tcs[11].str, dy);
  }
#line 1390
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 1392
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1394
  display->d_x = x2;
#line 1395
  display->d_y = y2;
#line 1396
  return;
}
}
#line 1398 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void ClearAll(void) 
{ 


  {
  {
#line 1401
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1401
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1402
  ClearArea(0, 0, 0, display->d_width - 1, display->d_width - 1, display->d_height - 1,
            0, 0);
  }
#line 1403
  return;
}
}
#line 1405 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void ClearArea(int x1 , int y1 , int xs , int xe , int x2 , int y2 , int bce , int uselayfn ) 
{ 
  int y ;
  int xxe ;
  struct canvas *cv ;
  struct viewport *vp ;
  int tmp ;
  struct layer *oldflayer ;
  struct canvas *cvlist ;
  struct canvas *cvlnext ;

  {
  {
#line 1413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1413
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1414
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1414
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1415
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1415
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1416
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1416
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1417
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1417
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1418
  if (x1 == display->d_width) {
#line 1419
    x1 --;
  }
#line 1420
  if (x2 == display->d_width) {
#line 1421
    x2 --;
  }
#line 1422
  if (xs == -1) {
#line 1423
    xs = x1;
  }
#line 1424
  if (xe == -1) {
#line 1425
    xe = x2;
  }
#line 1426
  if (display->d_tcs[33].flg) {
    {
#line 1427
    SetRendition(& mchar_null);
    }
  }
#line 1429
  if (display->d_tcs[66].flg) {
    {
#line 1430
    SetBackColor(bce);
    }
  }
#line 1432
  if (display->d_lp_missing) {
#line 1432
    if (y1 <= display->d_bot) {
#line 1432
      if (xe >= display->d_width - 1) {
#line 1434
        if (y2 > display->d_bot) {
#line 1435
          display->d_lp_missing = 0;
        } else
#line 1434
        if (y2 == display->d_bot) {
#line 1434
          if (x2 >= display->d_width - 1) {
#line 1435
            display->d_lp_missing = 0;
          }
        }
      }
    }
  }
#line 1437
  if (x2 == display->d_width - 1) {
#line 1437
    if (xs == 0) {
#line 1437
      goto _L___0;
    } else
#line 1437
    if (y1 == y2) {
      _L___0: /* CIL Label */ 
#line 1437
      if (xe == display->d_width - 1) {
#line 1437
        if (y2 == display->d_height - 1) {
#line 1437
          if (! bce) {
#line 1437
            goto _L;
          } else
#line 1437
          if (display->d_tcs[66].flg) {
            _L: /* CIL Label */ 
#line 1440
            if (x1 == 0) {
#line 1440
              if (y1 == 0) {
#line 1440
                if (display->d_auto_nuke) {
                  {
#line 1441
                  NukePending();
                  }
                }
              }
            }
#line 1443
            if (x1 == 0) {
#line 1443
              if (y1 == 0) {
#line 1443
                if (display->d_tcs[34].str) {
                  {
#line 1445
                  AddCStr(display->d_tcs[34].str);
#line 1446
                  tmp = 0;
#line 1446
                  display->d_x = tmp;
#line 1446
                  display->d_y = tmp;
                  }
#line 1447
                  return;
                }
              }
            }
#line 1453
            if (display->d_tcs[35].str) {
#line 1453
              if (y1 < y2) {
                {
#line 1455
                GotoPos(x1, y1);
#line 1456
                AddCStr(display->d_tcs[35].str);
                }
#line 1457
                return;
              } else
#line 1453
              if (! display->d_tcs[37].str) {
                {
#line 1455
                GotoPos(x1, y1);
#line 1456
                AddCStr(display->d_tcs[35].str);
                }
#line 1457
                return;
              }
            }
          }
        }
      }
    }
  }
#line 1460
  if (x1 == 0) {
#line 1460
    if (xs == 0) {
#line 1460
      if (xe == display->d_width - 1) {
#line 1460
        goto _L___1;
      } else
#line 1460
      if (y1 == y2) {
        _L___1: /* CIL Label */ 
#line 1460
        if (y1 == 0) {
#line 1460
          if (display->d_tcs[36].str) {
#line 1460
            if (! bce) {
              {
#line 1462
              GotoPos(x1, y1);
#line 1463
              AddCStr(display->d_tcs[36].str);
              }
#line 1464
              return;
            } else
#line 1460
            if (display->d_tcs[66].flg) {
              {
#line 1462
              GotoPos(x1, y1);
#line 1463
              AddCStr(display->d_tcs[36].str);
              }
#line 1464
              return;
            }
          }
        }
      }
    }
  }
#line 1466
  xxe = xe;
#line 1467
  y = y2;
  {
#line 1467
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1467
    if (! (y <= y2)) {
#line 1467
      goto while_break___4;
    }
#line 1469
    if (y == y2) {
#line 1470
      xxe = x2;
    }
#line 1471
    if (x1 == 0) {
#line 1471
      if (display->d_tcs[38].str) {
#line 1471
        if (xxe != display->d_width - 1) {
#line 1471
          goto _L___2;
        } else
#line 1471
        if (display->d_x == xxe) {
#line 1471
          if (display->d_y == y) {
            _L___2: /* CIL Label */ 
#line 1471
            if (! bce) {
              {
#line 1473
              GotoPos(xxe, y);
#line 1474
              AddCStr(display->d_tcs[38].str);
              }
#line 1475
              goto __Cont;
            } else
#line 1471
            if (display->d_tcs[66].flg) {
              {
#line 1473
              GotoPos(xxe, y);
#line 1474
              AddCStr(display->d_tcs[38].str);
              }
#line 1475
              goto __Cont;
            }
          }
        }
      }
    }
#line 1477
    if (xxe == display->d_width - 1) {
#line 1477
      if (display->d_tcs[37].str) {
#line 1477
        if (! bce) {
          {
#line 1479
          GotoPos(x1, y);
#line 1480
          AddCStr(display->d_tcs[37].str);
          }
#line 1481
          goto __Cont;
        } else
#line 1477
        if (display->d_tcs[66].flg) {
          {
#line 1479
          GotoPos(x1, y);
#line 1480
          AddCStr(display->d_tcs[37].str);
          }
#line 1481
          goto __Cont;
        }
      }
    }
#line 1483
    if (uselayfn) {
#line 1485
      vp = (struct viewport *)0;
#line 1486
      cv = display->d_cvlist;
      {
#line 1486
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1486
        if (! cv) {
#line 1486
          goto while_break___5;
        }
#line 1488
        if (y < cv->c_ys) {
#line 1489
          goto __Cont___0;
        } else
#line 1488
        if (y > cv->c_ye) {
#line 1489
          goto __Cont___0;
        } else
#line 1488
        if (xxe < cv->c_xs) {
#line 1489
          goto __Cont___0;
        } else
#line 1488
        if (x1 > cv->c_xe) {
#line 1489
          goto __Cont___0;
        }
#line 1490
        vp = cv->c_vplist;
        {
#line 1490
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1490
          if (! vp) {
#line 1490
            goto while_break___6;
          }
#line 1491
          if (y >= vp->v_ys) {
#line 1491
            if (y <= vp->v_ye) {
#line 1491
              if (xxe >= vp->v_xs) {
#line 1491
                if (x1 <= vp->v_xe) {
#line 1492
                  goto while_break___6;
                }
              }
            }
          }
#line 1490
          vp = vp->v_next;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 1493
        if (vp) {
#line 1494
          goto while_break___5;
        }
        __Cont___0: /* CIL Label */ 
#line 1486
        cv = cv->c_next;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1496
      if (cv) {
#line 1496
        if (cv->c_layer) {
#line 1496
          if (x1 >= vp->v_xs) {
#line 1496
            if (xxe <= vp->v_xe) {
#line 1496
              if (y - vp->v_yoff >= 0) {
#line 1496
                if (y - vp->v_yoff < (cv->c_layer)->l_height) {
#line 1496
                  if (xxe - vp->v_xoff >= 0) {
#line 1496
                    if (x1 - vp->v_xoff < (cv->c_layer)->l_width) {
                      {
#line 1500
                      oldflayer = flayer;
#line 1502
                      flayer = cv->c_layer;
#line 1503
                      cvlist = flayer->l_cvlist;
#line 1504
                      cvlnext = cv->c_lnext;
#line 1505
                      flayer->l_cvlist = cv;
#line 1506
                      cv->c_lnext = (struct canvas *)0;
#line 1507
                      (*((flayer->l_layfn)->lf_LayClearLine))(y - vp->v_yoff, x1 - vp->v_xoff,
                                                              xxe - vp->v_xoff, bce);
#line 1508
                      flayer->l_cvlist = cvlist;
#line 1509
                      cv->c_lnext = cvlnext;
#line 1510
                      flayer = oldflayer;
                      }
#line 1511
                      goto __Cont;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    {
#line 1514
    ClearLine((struct mline *)0, y, x1, xxe, bce);
    }
    __Cont: /* CIL Label */ 
#line 1467
    y ++;
#line 1467
    x1 = xs;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1516
  return;
}
}
#line 1523 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void Redisplay(int cur_only ) 
{ 
  struct display *olddisplay ;
  struct layer *oldflayer ;
  struct layer *l ;
  struct canvas *cvlist ;
  struct canvas *cvlnext ;

  {
  {
#line 1527
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1527
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1530
  InsertMode(0);
#line 1531
  ChangeScrollRegion(0, display->d_height - 1);
#line 1532
  KeypadMode(0);
#line 1533
  CursorkeysMode(0);
#line 1534
  CursorVisibility(0);
#line 1535
  MouseMode(0);
#line 1536
  SetRendition(& mchar_null);
#line 1537
  SetFlow(1);
#line 1539
  ClearAll();
  }
#line 1543
  if (cur_only > 0) {
#line 1543
    if (display->d_fore) {
      {
#line 1544
      RefreshArea(0, (display->d_fore)->w_layer.l_y, display->d_width - 1, (display->d_fore)->w_layer.l_y,
                  1);
      }
    } else {
      {
#line 1546
      RefreshAll(1);
      }
    }
  } else {
    {
#line 1546
    RefreshAll(1);
    }
  }
  {
#line 1547
  RefreshHStatus();
#line 1548
  olddisplay = display;
#line 1548
  oldflayer = flayer;
#line 1548
  l = (display->d_forecv)->c_layer;
#line 1548
  cvlist = l->l_cvlist;
#line 1548
  cvlnext = (display->d_forecv)->c_lnext;
#line 1548
  flayer = l;
#line 1548
  l->l_cvlist = display->d_forecv;
#line 1548
  (display->d_forecv)->c_lnext = (struct canvas *)0;
#line 1548
  (*((flayer->l_layfn)->lf_LayRestore))();
#line 1548
  LGotoPos(flayer, flayer->l_x, flayer->l_y);
#line 1548
  flayer = oldflayer;
#line 1548
  l->l_cvlist = cvlist;
#line 1548
  (display->d_forecv)->c_lnext = cvlnext;
#line 1548
  display = olddisplay;
  }
#line 1549
  return;
}
}
#line 1551 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void RedisplayDisplays(int cur_only ) 
{ 
  struct display *olddisplay ;

  {
#line 1555
  olddisplay = display;
#line 1556
  display = displays;
  {
#line 1556
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1556
    if (! display) {
#line 1556
      goto while_break;
    }
    {
#line 1557
    Redisplay(cur_only);
#line 1556
    display = display->d_next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1558
  display = olddisplay;
#line 1559
  return;
}
}
#line 1563 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void ScrollH(int y , int xs , int xe , int n , int bce , struct mline *oml ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1570
  if (n == 0) {
#line 1571
    return;
  }
#line 1572
  if (xe != display->d_width - 1) {
    {
#line 1574
    RefreshLine(y, xs, xe, 0);
    }
#line 1576
    return;
  }
  {
#line 1578
  GotoPos(xs, y);
  }
#line 1579
  if (display->d_tcs[33].flg) {
    {
#line 1580
    SetRendition(& mchar_null);
    }
  }
#line 1582
  if (display->d_tcs[66].flg) {
    {
#line 1583
    SetBackColor(bce);
    }
  }
#line 1585
  if (n > 0) {
#line 1587
    if (n >= (xe - xs) + 1) {
#line 1588
      n = (xe - xs) + 1;
    }
#line 1589
    if (display->d_tcs[32].str) {
#line 1589
      if (n == 1) {
#line 1589
        if (display->d_tcs[31].str) {
#line 1589
          goto _L;
        } else {
          {
#line 1590
          AddCStr2(display->d_tcs[32].str, n);
          }
        }
      } else {
        {
#line 1590
        AddCStr2(display->d_tcs[32].str, n);
        }
      }
    } else
    _L: /* CIL Label */ 
#line 1591
    if (display->d_tcs[31].str) {
#line 1593
      i = n;
      {
#line 1593
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1593
        tmp = i;
#line 1593
        i --;
#line 1593
        if (! tmp) {
#line 1593
          goto while_break;
        }
        {
#line 1594
        AddCStr(display->d_tcs[31].str);
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 1598
      RefreshLine(y, xs, xe, 0);
      }
#line 1600
      return;
    }
  } else {
#line 1605
    if (- n >= (xe - xs) + 1) {
#line 1606
      n = - ((xe - xs) + 1);
    }
#line 1607
    if (! display->d_insert) {
#line 1609
      if (display->d_tcs[30].str) {
#line 1609
        if (n == -1) {
#line 1609
          if (display->d_tcs[29].str) {
#line 1609
            goto _L___0;
          } else {
            {
#line 1610
            AddCStr2(display->d_tcs[30].str, - n);
            }
          }
        } else {
          {
#line 1610
          AddCStr2(display->d_tcs[30].str, - n);
          }
        }
      } else
      _L___0: /* CIL Label */ 
#line 1611
      if (display->d_tcs[29].str) {
#line 1613
        i = - n;
        {
#line 1613
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1613
          tmp___0 = i;
#line 1613
          i --;
#line 1613
          if (! tmp___0) {
#line 1613
            goto while_break___0;
          }
          {
#line 1614
          AddCStr(display->d_tcs[29].str);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      } else
#line 1616
      if (display->d_tcs[27].str) {
        {
#line 1618
        InsertMode(1);
#line 1619
        SetRendition(& mchar_null);
#line 1621
        SetBackColor(bce);
#line 1623
        i = - n;
        }
        {
#line 1623
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1623
          tmp___1 = i;
#line 1623
          i --;
#line 1623
          if (! tmp___1) {
#line 1623
            goto while_break___1;
          }
          {
#line 1624
          INSERTCHAR(' ');
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1625
        bce = 0;
      } else {
        {
#line 1630
        RefreshLine(y, xs, xe, 0);
        }
#line 1631
        return;
      }
    } else {
      {
#line 1636
      SetRendition(& mchar_null);
#line 1638
      SetBackColor(bce);
#line 1640
      i = - n;
      }
      {
#line 1640
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1640
        tmp___2 = i;
#line 1640
        i --;
#line 1640
        if (! tmp___2) {
#line 1640
          goto while_break___2;
        }
        {
#line 1641
        INSERTCHAR(' ');
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1642
      bce = 0;
    }
  }
#line 1645
  if (bce) {
#line 1645
    if (! display->d_tcs[66].flg) {
#line 1647
      if (n > 0) {
        {
#line 1648
        ClearLine((struct mline *)0, y, (xe - n) + 1, xe, bce);
        }
      } else {
        {
#line 1650
        ClearLine((struct mline *)0, y, xs, (xs - n) - 1, bce);
        }
      }
    }
  }
#line 1652
  if (display->d_lp_missing) {
#line 1652
    if (y == display->d_bot) {
#line 1654
      if (n > 0) {
        {
#line 1655
        WriteLP((display->d_width - 1) - n, y);
        }
      }
#line 1656
      display->d_lp_missing = 0;
    }
  }
#line 1658
  return;
}
}
#line 1660 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void ScrollV(int xs , int ys , int xe , int ye , int n , int bce ) 
{ 
  int i ;
  int up ;
  int oldtop ;
  int oldbot ;
  int alok ;
  int dlok ;
  int aldlfaster ;
  int missy ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 1668
  missy = 0;
  {
#line 1670
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1670
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1671
  if (n == 0) {
#line 1672
    return;
  }
#line 1673
  if (n >= (ye - ys) + 1) {
    {
#line 1675
    ClearArea(xs, ys, xs, xe, xe, ye, bce, 0);
    }
#line 1676
    return;
  } else
#line 1673
  if (- n >= (ye - ys) + 1) {
    {
#line 1675
    ClearArea(xs, ys, xs, xe, xe, ye, bce, 0);
    }
#line 1676
    return;
  }
#line 1678
  if (xs > display->d_vpxmin) {
    {
#line 1680
    RefreshArea(xs, ys, xe, ye, 0);
    }
#line 1681
    return;
  } else
#line 1678
  if (xe < display->d_vpxmax) {
    {
#line 1680
    RefreshArea(xs, ys, xe, ye, 0);
    }
#line 1681
    return;
  }
#line 1684
  if (display->d_lp_missing) {
#line 1686
    if (display->d_bot > ye) {
#line 1687
      missy = display->d_bot;
    } else
#line 1686
    if (display->d_bot < ys) {
#line 1687
      missy = display->d_bot;
    } else {
#line 1690
      missy = display->d_bot - n;
#line 1691
      if (missy > ye) {
#line 1692
        display->d_lp_missing = 0;
      } else
#line 1691
      if (missy < ys) {
#line 1692
        display->d_lp_missing = 0;
      }
    }
  }
#line 1696
  up = 1;
#line 1697
  if (n < 0) {
#line 1699
    up = 0;
#line 1700
    n = - n;
  }
#line 1702
  if (n >= (ye - ys) + 1) {
#line 1703
    n = (ye - ys) + 1;
  }
#line 1705
  oldtop = display->d_top;
#line 1706
  oldbot = display->d_bot;
#line 1707
  if (ys < display->d_top) {
    {
#line 1708
    ChangeScrollRegion(ys, ye);
    }
  } else
#line 1707
  if (display->d_bot != ye) {
    {
#line 1708
    ChangeScrollRegion(ys, ye);
    }
  }
#line 1709
  if (display->d_tcs[22].str) {
#line 1709
    tmp = 1;
  } else
#line 1709
  if (display->d_tcs[23].str) {
#line 1709
    tmp = 1;
  } else
#line 1709
  if (ys >= display->d_top) {
#line 1709
    if (ye == display->d_bot) {
#line 1709
      if (up) {
#line 1709
        tmp = 1;
      } else {
#line 1709
        tmp = 0;
      }
    } else {
#line 1709
      tmp = 0;
    }
  } else {
#line 1709
    tmp = 0;
  }
#line 1709
  alok = tmp;
#line 1710
  if (display->d_tcs[24].str) {
#line 1710
    tmp___0 = 1;
  } else
#line 1710
  if (display->d_tcs[25].str) {
#line 1710
    tmp___0 = 1;
  } else
#line 1710
  if (ys >= display->d_top) {
#line 1710
    if (ye == display->d_bot) {
#line 1710
      if (! up) {
#line 1710
        tmp___0 = 1;
      } else {
#line 1710
        tmp___0 = 0;
      }
    } else {
#line 1710
      tmp___0 = 0;
    }
  } else {
#line 1710
    tmp___0 = 0;
  }
#line 1710
  dlok = tmp___0;
#line 1711
  if (display->d_top != ys) {
#line 1711
    if (alok) {
#line 1711
      if (! dlok) {
        {
#line 1712
        ChangeScrollRegion(ys, ye);
        }
      }
    } else {
      {
#line 1712
      ChangeScrollRegion(ys, ye);
      }
    }
  }
#line 1714
  if (display->d_lp_missing) {
#line 1714
    if (oldbot != display->d_bot) {
#line 1714
      goto _L;
    } else
#line 1714
    if (oldbot == display->d_bot) {
#line 1714
      if (up) {
#line 1714
        if (display->d_top == ys) {
#line 1714
          if (display->d_bot == ye) {
            _L: /* CIL Label */ 
            {
#line 1718
            WriteLP(display->d_width - 1, oldbot);
            }
#line 1719
            if (oldbot == display->d_bot) {
#line 1721
              n --;
#line 1721
              if (n == 0) {
#line 1726
                if (bce) {
#line 1726
                  if (! display->d_tcs[66].flg) {
                    {
#line 1727
                    ClearLine((struct mline *)0, ye, xs, xe, bce);
                    }
                  }
                }
#line 1728
                return;
              }
            }
          }
        }
      }
    }
  }
#line 1733
  if (display->d_tcs[33].flg) {
    {
#line 1734
    SetRendition(& mchar_null);
    }
  }
#line 1736
  if (display->d_tcs[66].flg) {
    {
#line 1737
    SetBackColor(bce);
    }
  }
#line 1740
  if (n > 1) {
#line 1740
    if (ys >= display->d_top) {
#line 1740
      if (ye == display->d_bot) {
#line 1740
        if (up) {
#line 1740
          if (display->d_tcs[25].str) {
#line 1740
            tmp___1 = 1;
          } else {
#line 1740
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 1740
        if (! up) {
#line 1740
          if (display->d_tcs[23].str) {
#line 1740
            tmp___1 = 1;
          } else {
#line 1740
            tmp___1 = 0;
          }
        } else {
#line 1740
          tmp___1 = 0;
        }
      } else {
#line 1740
        tmp___1 = 0;
      }
    } else {
#line 1740
      tmp___1 = 0;
    }
  } else {
#line 1740
    tmp___1 = 0;
  }
#line 1740
  aldlfaster = tmp___1;
#line 1742
  if (up) {
#line 1742
    goto _L___8;
  } else
#line 1742
  if (display->d_tcs[21].str) {
    _L___8: /* CIL Label */ 
#line 1742
    if (display->d_top == ys) {
#line 1742
      if (display->d_bot == ye) {
#line 1742
        if (! aldlfaster) {
#line 1744
          if (up) {
            {
#line 1746
            GotoPos(0, ye);
#line 1747
            i = n;
            }
            {
#line 1747
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 1747
              tmp___2 = i;
#line 1747
              i --;
#line 1747
              if (! (tmp___2 > 0)) {
#line 1747
                goto while_break___0;
              }
              {
#line 1748
              AddCStr(display->d_tcs[19].str);
              }
            }
            while_break___0: /* CIL Label */ ;
            }
          } else {
            {
#line 1752
            GotoPos(0, ys);
#line 1753
            i = n;
            }
            {
#line 1753
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 1753
              tmp___3 = i;
#line 1753
              i --;
#line 1753
              if (! (tmp___3 > 0)) {
#line 1753
                goto while_break___1;
              }
              {
#line 1754
              AddCStr(display->d_tcs[21].str);
              }
            }
            while_break___1: /* CIL Label */ ;
            }
          }
        } else {
#line 1742
          goto _L___7;
        }
      } else {
#line 1742
        goto _L___7;
      }
    } else {
#line 1742
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
#line 1757
  if (alok) {
#line 1757
    if (dlok) {
#line 1759
      if (up) {
#line 1759
        goto _L___2;
      } else
#line 1759
      if (ye != display->d_bot) {
        _L___2: /* CIL Label */ 
#line 1761
        if (up) {
#line 1761
          tmp___4 = ys;
        } else {
#line 1761
          tmp___4 = (ye + 1) - n;
        }
        {
#line 1761
        GotoPos(0, tmp___4);
        }
#line 1762
        if (display->d_tcs[25].str) {
#line 1762
          if (n == 1) {
#line 1762
            if (display->d_tcs[24].str) {
#line 1762
              goto _L___1;
            } else {
              {
#line 1763
              AddCStr2(display->d_tcs[25].str, n);
              }
            }
          } else {
            {
#line 1763
            AddCStr2(display->d_tcs[25].str, n);
            }
          }
        } else {
          _L___1: /* CIL Label */ 
#line 1765
          i = n;
          {
#line 1765
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1765
            tmp___5 = i;
#line 1765
            i --;
#line 1765
            if (! tmp___5) {
#line 1765
              goto while_break___2;
            }
            {
#line 1766
            AddCStr(display->d_tcs[24].str);
            }
          }
          while_break___2: /* CIL Label */ ;
          }
        }
      }
#line 1768
      if (! up) {
#line 1768
        goto _L___4;
      } else
#line 1768
      if (ye != display->d_bot) {
        _L___4: /* CIL Label */ 
#line 1770
        if (up) {
#line 1770
          tmp___6 = (ye + 1) - n;
        } else {
#line 1770
          tmp___6 = ys;
        }
        {
#line 1770
        GotoPos(0, tmp___6);
        }
#line 1771
        if (display->d_tcs[23].str) {
#line 1771
          if (n == 1) {
#line 1771
            if (display->d_tcs[22].str) {
#line 1771
              goto _L___3;
            } else {
              {
#line 1772
              AddCStr2(display->d_tcs[23].str, n);
              }
            }
          } else {
            {
#line 1772
            AddCStr2(display->d_tcs[23].str, n);
            }
          }
        } else {
          _L___3: /* CIL Label */ 
#line 1774
          i = n;
          {
#line 1774
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1774
            tmp___7 = i;
#line 1774
            i --;
#line 1774
            if (! tmp___7) {
#line 1774
              goto while_break___3;
            }
            {
#line 1775
            AddCStr(display->d_tcs[22].str);
            }
          }
          while_break___3: /* CIL Label */ ;
          }
        }
      }
    } else {
      {
#line 1780
      RefreshArea(xs, ys, xe, ye, 0);
      }
#line 1781
      return;
    }
  } else {
    {
#line 1780
    RefreshArea(xs, ys, xe, ye, 0);
    }
#line 1781
    return;
  }
#line 1783
  if (bce) {
#line 1783
    if (! display->d_tcs[66].flg) {
#line 1785
      if (up) {
        {
#line 1786
        ClearArea(xs, (ye - n) + 1, xs, xe, xe, ye, bce, 0);
        }
      } else {
        {
#line 1788
        ClearArea(xs, ys, xs, xe, xe, (ys + n) - 1, bce, 0);
        }
      }
    }
  }
#line 1790
  if (display->d_lp_missing) {
#line 1790
    if (missy != display->d_bot) {
      {
#line 1791
      WriteLP(display->d_width - 1, missy);
      }
    }
  }
#line 1797
  return;
}
}
#line 1799 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void SetAttr(int new ) 
{ 
  register int i ;
  register int j ;
  register int old ;
  register int typ ;

  {
#line 1805
  if (! display) {
#line 1806
    return;
  } else {
#line 1805
    old = (int )display->d_rend.attr;
#line 1805
    if (old == new) {
#line 1806
      return;
    }
  }
#line 1808
  display->d_col16change = (old ^ new) & ((1 << 6) | (1 << 7));
#line 1809
  new ^= display->d_col16change;
#line 1810
  if (old == new) {
#line 1811
    return;
  }
#line 1831
  display->d_rend.attr = (unsigned char )new;
#line 1832
  typ = (int )display->d_atyp;
#line 1833
  if ((new & old) != old) {
#line 1835
    if (typ & (1 << 2)) {
      {
#line 1836
      AddCStr(display->d_tcs[53].str);
      }
    }
#line 1837
    if (typ & (1 << 1)) {
      {
#line 1838
      AddCStr(display->d_tcs[54].str);
      }
    }
#line 1839
    if (typ & 1) {
      {
#line 1841
      AddCStr(display->d_tcs[55].str);
      }
#line 1844
      if (display->d_hascolor) {
#line 1845
        display->d_rend.color = (unsigned char)0;
#line 1845
        display->d_rend.attr = (unsigned char )((int )display->d_rend.attr & ~ ((1 << 7) | (1 << 6)));
      }
#line 1848
      if (! display->d_tcs[97].flg) {
#line 1851
        display->d_rend.font = (unsigned char)0;
#line 1853
        display->d_realfont = 0;
      }
    }
#line 1858
    old = 0;
#line 1859
    typ = 0;
  }
#line 1861
  old ^= new;
#line 1862
  i = 0;
#line 1862
  j = 1;
  {
#line 1862
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1862
    if (old) {
#line 1862
      if (! (i < 6)) {
#line 1862
        goto while_break;
      }
    } else {
#line 1862
      goto while_break;
    }
#line 1864
    if ((old & j) == 0) {
#line 1865
      goto __Cont;
    }
#line 1866
    old ^= j;
#line 1867
    if (display->d_attrtab[i]) {
      {
#line 1869
      AddCStr(display->d_attrtab[i]);
#line 1870
      typ |= (int )display->d_attrtyp[i];
      }
    }
    __Cont: /* CIL Label */ 
#line 1862
    i ++;
#line 1862
    j <<= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 1873
  display->d_atyp = (char )typ;
#line 1874
  return;
}
}
#line 1877 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void SetFont(int new ) 
{ 
  int old ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 1881
  old = (int )display->d_rend.font;
#line 1882
  if (! display) {
#line 1883
    return;
  } else
#line 1882
  if (old == new) {
#line 1883
    return;
  }
#line 1884
  display->d_rend.font = (unsigned char )new;
#line 1886
  if (display->d_encoding) {
    {
#line 1886
    tmp = CanEncodeFont(display->d_encoding, new);
    }
#line 1886
    if (tmp) {
#line 1887
      return;
    }
  }
#line 1888
  if (new == display->d_realfont) {
#line 1889
    return;
  }
#line 1890
  display->d_realfont = new;
#line 1892
  if (display->d_xtable) {
#line 1892
    if (*(display->d_xtable + (int )((unsigned char )new))) {
#line 1892
      if (*(*(display->d_xtable + (int )((unsigned char )new)) + 256)) {
        {
#line 1895
        AddCStr(*(*(display->d_xtable + (int )((unsigned char )new)) + 256));
        }
#line 1896
        return;
      }
    }
  }
#line 1899
  if (! display->d_tcs[97].flg) {
#line 1899
    if (new != 48) {
#line 1901
      new = 0;
#line 1902
      if (old == new) {
#line 1903
        return;
      }
    }
  }
#line 1906
  if (new == 0) {
    {
#line 1907
    AddCStr(display->d_tcs[99].str);
    }
  } else
#line 1909
  if (new < 32) {
    {
#line 1911
    AddStr((char *)"\033$");
    }
#line 1912
    if (new > 2) {
      {
#line 1913
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1913
        (display->d_obuffree) --;
#line 1913
        if (display->d_obuffree <= 0) {
          {
#line 1913
          Resize_obuf();
          }
        }
#line 1913
        tmp___0 = display->d_obufp;
#line 1913
        (display->d_obufp) ++;
#line 1913
        *tmp___0 = (char )'(';
#line 1913
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 1914
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1914
      (display->d_obuffree) --;
#line 1914
      if (display->d_obuffree <= 0) {
        {
#line 1914
        Resize_obuf();
        }
      }
#line 1914
      tmp___1 = display->d_obufp;
#line 1914
      (display->d_obufp) ++;
#line 1914
      *tmp___1 = (char )(new + 64);
#line 1914
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 1918
    AddCStr2(display->d_tcs[98].str, new);
    }
  }
#line 1919
  return;
}
}
#line 1924 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
int color256to16(int jj ) 
{ 
  int min ;
  int max ;
  int r ;
  int g ;
  int b ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1931
  if (jj >= 232) {
#line 1933
    jj = (jj - 232) / 6;
#line 1934
    if (jj & 2) {
#line 1934
      tmp = 7;
    } else {
#line 1934
      tmp = 0;
    }
#line 1934
    jj = ((jj & 1) << 3) | tmp;
  } else
#line 1936
  if (jj >= 16) {
#line 1938
    jj -= 16;
#line 1939
    r = jj / 36;
#line 1940
    g = (jj / 6) % 6;
#line 1941
    b = jj % 6;
#line 1942
    if (r < g) {
#line 1942
      if (r < b) {
#line 1942
        tmp___0 = r;
      } else {
#line 1942
        tmp___0 = b;
      }
#line 1942
      min = tmp___0;
    } else {
#line 1942
      if (g < b) {
#line 1942
        tmp___1 = g;
      } else {
#line 1942
        tmp___1 = b;
      }
#line 1942
      min = tmp___1;
    }
#line 1943
    if (r > g) {
#line 1943
      if (r > b) {
#line 1943
        tmp___2 = r;
      } else {
#line 1943
        tmp___2 = b;
      }
#line 1943
      max = tmp___2;
    } else {
#line 1943
      if (g > b) {
#line 1943
        tmp___3 = g;
      } else {
#line 1943
        tmp___3 = b;
      }
#line 1943
      max = tmp___3;
    }
#line 1944
    if (min == max) {
#line 1945
      if ((max + 1) & 4) {
#line 1945
        tmp___4 = 7;
      } else {
#line 1945
        tmp___4 = 0;
      }
#line 1945
      jj = (((max + 1) & 2) << 2) | tmp___4;
    } else {
#line 1947
      if (max > 3) {
#line 1947
        tmp___5 = 8;
      } else {
#line 1947
        tmp___5 = 0;
      }
#line 1947
      jj = ((((b - min) / (max - min) << 2) | ((g - min) / (max - min) << 1)) | (r - min) / (max - min)) | tmp___5;
    }
  }
#line 1950
  return (jj);
}
}
#line 1979 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
static unsigned char sftrans[8]  = 
#line 1979
  {      (unsigned char)0,      (unsigned char)4,      (unsigned char)2,      (unsigned char)6, 
        (unsigned char)1,      (unsigned char)5,      (unsigned char)3,      (unsigned char)7};
#line 1974 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void SetColor(int f , int b ) 
{ 
  int of ;
  int ob ;
  int tmp ;
  int tmp___0 ;
  int oattr ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 1981
  if (! display) {
#line 1982
    return;
  }
#line 1984
  if ((int )display->d_rend.attr & (1 << 6)) {
#line 1984
    tmp = 256;
  } else {
#line 1984
    tmp = 0;
  }
#line 1984
  of = ((int )display->d_rend.color & 15) | tmp;
#line 1985
  if ((int )display->d_rend.attr & (1 << 7)) {
#line 1985
    tmp___0 = 256;
  } else {
#line 1985
    tmp___0 = 0;
  }
#line 1985
  ob = (((int )display->d_rend.color & 240) >> 4) | tmp___0;
#line 1989
  if (f == 256) {
#line 1990
    f = 0;
  }
#line 1991
  if (b == 256) {
#line 1992
    b = 0;
  }
  {
#line 1994
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1994
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1995
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1995
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1996
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1996
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1997
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1997
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1999
  if (! display->d_tcs[67].flg) {
#line 1999
    if (display->d_hascolor) {
#line 1999
      if (f == 0) {
#line 1999
        if (f != of) {
#line 1999
          goto _L;
        } else {
#line 1999
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 1999
      if (b == 0) {
#line 1999
        if (b != ob) {
          _L: /* CIL Label */ 
#line 2001
          if (display->d_tcs[64].str) {
            {
#line 2002
            AddCStr(display->d_tcs[64].str);
            }
          } else {
#line 2006
            oattr = (int )display->d_rend.attr;
#line 2007
            if (display->d_tcs[55].str) {
#line 2007
              tmp___1 = (char const   *)display->d_tcs[55].str;
            } else {
#line 2007
              tmp___1 = "\033[m";
            }
            {
#line 2007
            AddCStr((char *)tmp___1);
            }
#line 2009
            if (display->d_tcs[55].str) {
#line 2009
              if (! display->d_tcs[97].flg) {
#line 2012
                display->d_rend.font = (unsigned char)0;
#line 2014
                display->d_realfont = 0;
              }
            }
            {
#line 2018
            display->d_atyp = (char)0;
#line 2019
            display->d_rend.attr = (unsigned char)0;
#line 2020
            SetAttr(oattr);
            }
          }
#line 2022
          ob = 0;
#line 2022
          of = ob;
        }
      }
    }
  }
#line 2024
  display->d_rend.color = (unsigned char )(((int )display->d_rend.color & 240) | (f & 15));
#line 2024
  if (f & 256) {
#line 2024
    tmp___2 = 0;
  } else {
#line 2024
    tmp___2 = 1 << 6;
  }
#line 2024
  display->d_rend.attr = (unsigned char )(((int )display->d_rend.attr | (1 << 6)) ^ tmp___2);
#line 2025
  display->d_rend.color = (unsigned char )(((int )display->d_rend.color & 15) | ((b << 4) & 240));
#line 2025
  if (b & 256) {
#line 2025
    tmp___3 = 0;
  } else {
#line 2025
    tmp___3 = 1 << 7;
  }
#line 2025
  display->d_rend.attr = (unsigned char )(((int )display->d_rend.attr | (1 << 7)) ^ tmp___3);
#line 2027
  display->d_col16change = 0;
#line 2029
  if (! display->d_hascolor) {
#line 2030
    return;
  }
#line 2031
  if (f) {
#line 2031
    if ((f & 504) == 264) {
#line 2031
      tmp___4 = f ^ 264;
    } else {
#line 2031
      tmp___4 = f & 255;
    }
#line 2031
    f = tmp___4 ^ 9;
  } else {
#line 2031
    f = -1;
  }
#line 2032
  if (b) {
#line 2032
    if ((b & 504) == 264) {
#line 2032
      tmp___5 = b ^ 264;
    } else {
#line 2032
      tmp___5 = b & 255;
    }
#line 2032
    b = tmp___5 ^ 9;
  } else {
#line 2032
    b = -1;
  }
#line 2033
  if (of) {
#line 2033
    if ((of & 504) == 264) {
#line 2033
      tmp___6 = of ^ 264;
    } else {
#line 2033
      tmp___6 = of & 255;
    }
#line 2033
    of = tmp___6 ^ 9;
  } else {
#line 2033
    of = -1;
  }
#line 2034
  if (ob) {
#line 2034
    if ((ob & 504) == 264) {
#line 2034
      tmp___7 = ob ^ 264;
    } else {
#line 2034
      tmp___7 = ob & 255;
    }
#line 2034
    ob = tmp___7 ^ 9;
  } else {
#line 2034
    ob = -1;
  }
#line 2051
  if (f != of) {
#line 2051
    if (f != (of | 8)) {
#line 2053
      if (f == -1) {
        {
#line 2054
        AddCStr((char *)"\033[39m");
        }
      } else
#line 2055
      if (display->d_tcs[60].str) {
        {
#line 2056
        AddCStr2(display->d_tcs[60].str, f & 7);
        }
      } else
#line 2057
      if (display->d_tcs[62].str) {
        {
#line 2058
        AddCStr2(display->d_tcs[62].str, (int )sftrans[f & 7]);
        }
      }
    }
  }
#line 2060
  if (b != ob) {
#line 2060
    if (b != (ob | 8)) {
#line 2062
      if (b == -1) {
        {
#line 2063
        AddCStr((char *)"\033[49m");
        }
      } else
#line 2064
      if (display->d_tcs[61].str) {
        {
#line 2065
        AddCStr2(display->d_tcs[61].str, b & 7);
        }
      } else
#line 2066
      if (display->d_tcs[63].str) {
        {
#line 2067
        AddCStr2(display->d_tcs[63].str, (int )sftrans[b & 7]);
        }
      }
    }
  }
#line 2070
  if (f != of) {
#line 2070
    if (display->d_tcs[96].flg) {
#line 2070
      if ((f & 8) != 0) {
#line 2070
        if (f != -1) {
          {
#line 2073
          AddCStr2((char *)"\033[9%p1%dm", f & 7);
          }
        }
      }
    }
  }
#line 2078
  if (b != ob) {
#line 2078
    if (display->d_tcs[96].flg) {
#line 2078
      if ((b & 8) != 0) {
#line 2078
        if (b != -1) {
          {
#line 2081
          AddCStr2((char *)"\033[10%p1%dm", b & 7);
          }
        }
      }
    }
  }
#line 2087
  return;
}
}
#line 2089 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
static void SetBackColor(int new ) 
{ 
  int tmp ;

  {
#line 2093
  if (! display) {
#line 2094
    return;
  }
#line 2095
  if ((int )display->d_rend.attr & (1 << 6)) {
#line 2095
    tmp = 256;
  } else {
#line 2095
    tmp = 0;
  }
  {
#line 2095
  SetColor(((int )display->d_rend.color & 15) | tmp, new);
  }
#line 2096
  return;
}
}
#line 2107 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
static struct mchar mmc  ;
#line 2099 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void SetRendition(struct mchar *mc ) 
{ 
  int i ;
  int a ;
  int tmp ;
  int tmp___0 ;

  {
#line 2103
  if (! display) {
#line 2104
    return;
  }
#line 2105
  if (nattr2color) {
#line 2105
    if (display->d_hascolor) {
#line 2105
      if (((int )mc->attr & nattr2color) != 0) {
#line 2109
        mmc = *mc;
#line 2110
        i = 0;
        {
#line 2110
        while (1) {
          while_continue: /* CIL Label */ ;
#line 2110
          if (! (i < 8)) {
#line 2110
            goto while_break;
          }
#line 2111
          if (attr2color[i]) {
#line 2111
            if (((int )mc->attr & (1 << i)) != 0) {
#line 2113
              if ((int )mc->color == 0) {
#line 2113
                if (attr2color[i][3]) {
                  {
#line 2114
                  ApplyAttrColor(attr2color[i][3], & mmc);
                  }
                } else {
#line 2113
                  goto _L___0;
                }
              } else
              _L___0: /* CIL Label */ 
#line 2115
              if (((int )mc->color & 15) == 0) {
#line 2115
                if (attr2color[i][2]) {
                  {
#line 2116
                  ApplyAttrColor(attr2color[i][2], & mmc);
                  }
                } else {
#line 2115
                  goto _L;
                }
              } else
              _L: /* CIL Label */ 
#line 2117
              if (((int )mc->color & 240) == 0) {
#line 2117
                if (attr2color[i][1]) {
                  {
#line 2118
                  ApplyAttrColor(attr2color[i][1], & mmc);
                  }
                } else {
                  {
#line 2120
                  ApplyAttrColor(attr2color[i][0], & mmc);
                  }
                }
              } else {
                {
#line 2120
                ApplyAttrColor(attr2color[i][0], & mmc);
                }
              }
            }
          }
#line 2110
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 2122
        mc = & mmc;
        {
#line 2123
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2123
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
  }
#line 2125
  if (display->d_hascolor) {
#line 2125
    if (display->d_tcs[68].flg) {
#line 2125
      if ((int )mc->attr & ((1 << 6) | (1 << 7))) {
#line 2127
        a = (int )mc->attr;
#line 2128
        if ((int )mc->attr & (1 << 6)) {
#line 2128
          if (display->d_tcs[49].str) {
#line 2129
            a |= 1 << 2;
          }
        }
#line 2130
        if ((int )mc->attr & (1 << 7)) {
#line 2130
          if (display->d_tcs[52].str) {
#line 2131
            a |= 1 << 5;
          }
        }
#line 2132
        if ((int )display->d_rend.attr != a) {
          {
#line 2133
          SetAttr(a);
          }
        }
      } else {
#line 2125
        goto _L___2;
      }
    } else {
#line 2125
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 2135
  if ((int )display->d_rend.attr != (int )mc->attr) {
    {
#line 2136
    SetAttr((int )mc->attr);
    }
  }
#line 2138
  if ((int )display->d_rend.color != (int )mc->color) {
#line 2138
    goto _L___3;
  } else
#line 2138
  if (display->d_col16change) {
    _L___3: /* CIL Label */ 
#line 2146
    if ((int )mc->attr & (1 << 7)) {
#line 2146
      tmp = 256;
    } else {
#line 2146
      tmp = 0;
    }
#line 2146
    if ((int )mc->attr & (1 << 6)) {
#line 2146
      tmp___0 = 256;
    } else {
#line 2146
      tmp___0 = 0;
    }
    {
#line 2146
    SetColor(((int )mc->color & 15) | tmp___0, (((int )mc->color & 240) >> 4) | tmp);
    }
  }
#line 2149
  if ((int )display->d_rend.font != (int )mc->font) {
    {
#line 2150
    SetFont((int )mc->font);
    }
  }
#line 2152
  return;
}
}
#line 2154 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void SetRenditionMline(struct mline *ml , int x ) 
{ 
  struct mchar mc ;
  int a ;
  struct mchar mc___0 ;
  int tmp ;
  int tmp___0 ;

  {
#line 2159
  if (! display) {
#line 2160
    return;
  }
#line 2161
  if (nattr2color) {
#line 2161
    if (display->d_hascolor) {
#line 2161
      if (((int )*(ml->attr + x) & nattr2color) != 0) {
        {
#line 2164
        while (1) {
          while_continue: /* CIL Label */ ;
#line 2164
          mc.image = *(ml->image + x);
#line 2164
          mc.attr = *(ml->attr + x);
#line 2164
          mc.font = *(ml->font + x);
#line 2164
          mc.color = *(ml->color + x);
#line 2164
          mc.mbcs = (unsigned char)0;
#line 2164
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 2165
        SetRendition(& mc);
        }
#line 2166
        return;
      }
    }
  }
#line 2168
  if (display->d_hascolor) {
#line 2168
    if (display->d_tcs[68].flg) {
#line 2168
      if ((int )*(ml->attr + x) & ((1 << 6) | (1 << 7))) {
#line 2170
        a = (int )*(ml->attr + x);
#line 2171
        if ((int )*(ml->attr + x) & (1 << 6)) {
#line 2171
          if (display->d_tcs[49].str) {
#line 2172
            a |= 1 << 2;
          }
        }
#line 2173
        if ((int )*(ml->attr + x) & (1 << 7)) {
#line 2173
          if (display->d_tcs[52].str) {
#line 2174
            a |= 1 << 5;
          }
        }
#line 2175
        if ((int )display->d_rend.attr != a) {
          {
#line 2176
          SetAttr(a);
          }
        }
      } else {
#line 2168
        goto _L___0;
      }
    } else {
#line 2168
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 2178
  if ((int )display->d_rend.attr != (int )*(ml->attr + x)) {
    {
#line 2179
    SetAttr((int )*(ml->attr + x));
    }
  }
#line 2181
  if ((int )display->d_rend.color != (int )*(ml->color + x)) {
#line 2181
    goto _L___1;
  } else
#line 2181
  if (display->d_col16change) {
    _L___1: /* CIL Label */ 
    {
#line 2191
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2191
      mc___0.image = *(ml->image + x);
#line 2191
      mc___0.attr = *(ml->attr + x);
#line 2191
      mc___0.font = *(ml->font + x);
#line 2191
      mc___0.color = *(ml->color + x);
#line 2191
      mc___0.mbcs = (unsigned char)0;
#line 2191
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2192
    if ((int )mc___0.attr & (1 << 7)) {
#line 2192
      tmp = 256;
    } else {
#line 2192
      tmp = 0;
    }
#line 2192
    if ((int )mc___0.attr & (1 << 6)) {
#line 2192
      tmp___0 = 256;
    } else {
#line 2192
      tmp___0 = 0;
    }
    {
#line 2192
    SetColor(((int )mc___0.color & 15) | tmp___0, (((int )mc___0.color & 240) >> 4) | tmp);
    }
  }
#line 2196
  if ((int )display->d_rend.font != (int )*(ml->font + x)) {
    {
#line 2197
    SetFont((int )*(ml->font + x));
    }
  }
#line 2199
  return;
}
}
#line 2201 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void MakeStatus(char *msg ) 
{ 
  register char *s ;
  register char *t ;
  register int max ;
  int tmp ;
  struct timeval now ;
  int ti ;
  char *tmp___0 ;
  char *buf___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  struct display *olddisplay ;
  struct layer *oldflayer ;
  int tmp___7 ;

  {
#line 2208
  if (! display) {
#line 2209
    return;
  }
#line 2211
  if (display->d_blocked) {
#line 2212
    return;
  }
#line 2213
  if (! display->d_tcinited) {
    {
#line 2215
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2215
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 2216
    if (display->d_processinputdata) {
#line 2217
      return;
    }
    {
#line 2218
    AddStr(msg);
#line 2219
    AddStr((char *)"\r\n");
#line 2220
    Flush();
    }
#line 2221
    return;
  }
#line 2223
  if (! use_hardstatus) {
#line 2223
    goto _L;
  } else
#line 2223
  if (! display->d_tcs[75].flg) {
    _L: /* CIL Label */ 
#line 2225
    max = display->d_width;
#line 2226
    if (display->d_tcs[87].flg == 0) {
#line 2227
      max --;
    }
  } else
#line 2230
  if (display->d_tcs[76].num > 0) {
#line 2230
    max = display->d_tcs[76].num;
  } else {
#line 2230
    max = display->d_width - ! display->d_tcs[87].flg;
  }
#line 2231
  if (display->d_status) {
    {
#line 2234
    tmp = strcmp((char const   *)msg, (char const   *)display->d_status_lastmsg);
    }
#line 2234
    if (tmp == 0) {
      {
#line 2236
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2236
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 2237
      SetTimeout(& display->d_statusev, MsgWait);
      }
#line 2238
      return;
    }
#line 2240
    if (! display->d_status_bell) {
      {
#line 2244
      gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
#line 2245
      ti = (int )((now.tv_sec - display->d_status_time.tv_sec) * 1000L + (now.tv_usec - display->d_status_time.tv_usec) / 1000L);
      }
#line 2246
      if (ti < MsgMinWait) {
        {
#line 2247
        DisplaySleep1000(MsgMinWait - ti, 0);
        }
      }
    }
    {
#line 2249
    RemoveStatus();
    }
  }
#line 2251
  t = msg;
#line 2251
  s = t;
  {
#line 2251
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2251
    if (*s) {
#line 2251
      if (! (t - msg < (long )max)) {
#line 2251
        goto while_break___1;
      }
    } else {
#line 2251
      goto while_break___1;
    }
#line 2252
    if ((int )*s == 7) {
      {
#line 2253
      AddCStr(display->d_tcs[42].str);
      }
    } else
#line 2254
    if ((int )((unsigned char )*s) >= 32) {
#line 2254
      if ((int )*s != 127) {
#line 2255
        tmp___0 = t;
#line 2255
        t ++;
#line 2255
        *tmp___0 = *s;
      }
    }
#line 2251
    s ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2256
  *t = (char )'\000';
#line 2257
  if ((unsigned long )t == (unsigned long )msg) {
#line 2258
    return;
  }
#line 2259
  if (t - msg >= (long )display->d_status_buflen) {
#line 2262
    if (display->d_status_lastmsg) {
      {
#line 2263
      tmp___1 = realloc((void *)display->d_status_lastmsg, (size_t )((t - msg) + 1L));
#line 2263
      buf___0 = (char *)tmp___1;
      }
    } else {
      {
#line 2265
      tmp___2 = malloc((size_t )((t - msg) + 1L));
#line 2265
      buf___0 = (char *)tmp___2;
      }
    }
#line 2266
    if (buf___0) {
#line 2268
      display->d_status_lastmsg = buf___0;
#line 2269
      display->d_status_buflen = (int )((t - msg) + 1L);
    }
  }
#line 2272
  if (t - msg < (long )display->d_status_buflen) {
    {
#line 2273
    strcpy((char */* __restrict  */)display->d_status_lastmsg, (char const   */* __restrict  */)msg);
    }
  }
#line 2274
  display->d_status_len = (int )(t - msg);
#line 2275
  display->d_status_lastx = display->d_x;
#line 2276
  display->d_status_lasty = display->d_y;
#line 2277
  if (! use_hardstatus) {
#line 2277
    goto _L___0;
  } else
#line 2277
  if (display->d_has_hstatus == 0) {
#line 2277
    goto _L___0;
  } else
#line 2277
  if (display->d_has_hstatus == 2) {
    _L___0: /* CIL Label */ 
#line 2279
    display->d_status = 1;
    {
#line 2280
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2280
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 2281
    GotoPos(0, display->d_height - 1);
#line 2282
    SetRendition(& mchar_so);
#line 2283
    InsertMode(0);
#line 2284
    AddStr(msg);
    }
#line 2285
    if (display->d_status_len < max) {
      {
#line 2288
      (display->d_status_len) ++;
#line 2289
      SetRendition(& mchar_null);
      }
      {
#line 2290
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2290
        (display->d_obuffree) --;
#line 2290
        if (display->d_obuffree <= 0) {
          {
#line 2290
          Resize_obuf();
          }
        }
#line 2290
        tmp___3 = display->d_obufp;
#line 2290
        (display->d_obufp) ++;
#line 2290
        *tmp___3 = (char )' ';
#line 2290
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 2291
      if (display->d_status_len < max) {
#line 2293
        (display->d_status_len) ++;
        {
#line 2294
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 2294
          (display->d_obuffree) --;
#line 2294
          if (display->d_obuffree <= 0) {
            {
#line 2294
            Resize_obuf();
            }
          }
#line 2294
          tmp___4 = display->d_obufp;
#line 2294
          (display->d_obufp) ++;
#line 2294
          *tmp___4 = (char )' ';
#line 2294
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 2295
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 2295
          (display->d_obuffree) --;
#line 2295
          if (display->d_obuffree <= 0) {
            {
#line 2295
            Resize_obuf();
            }
          }
#line 2295
          tmp___5 = display->d_obufp;
#line 2295
          (display->d_obufp) ++;
#line 2295
          *tmp___5 = (char )'\b';
#line 2295
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
      {
#line 2297
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 2297
        (display->d_obuffree) --;
#line 2297
        if (display->d_obuffree <= 0) {
          {
#line 2297
          Resize_obuf();
          }
        }
#line 2297
        tmp___6 = display->d_obufp;
#line 2297
        (display->d_obufp) ++;
#line 2297
        *tmp___6 = (char )'\b';
#line 2297
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 2299
    display->d_x = -1;
  } else {
    {
#line 2303
    display->d_status = 2;
#line 2304
    ShowHStatus(msg);
    }
  }
  {
#line 2306
  Flush();
  }
#line 2307
  if (! display) {
#line 2308
    return;
  }
#line 2309
  if (display->d_status == 1) {
#line 2311
    olddisplay = display;
#line 2312
    oldflayer = flayer;
    {
#line 2314
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 2314
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 2316
    display->d_status = 0;
#line 2317
    GotoPos(0, display->d_height - 1);
#line 2318
    RefreshLine(display->d_height - 1, 0, display->d_status_len - 1, 0);
#line 2319
    GotoPos(display->d_status_lastx, display->d_status_lasty);
    }
#line 2320
    if (display->d_forecv) {
#line 2320
      flayer = (display->d_forecv)->c_layer;
    } else {
#line 2320
      flayer = (struct layer *)0;
    }
#line 2321
    if (flayer) {
      {
#line 2322
      LGotoPos(flayer, flayer->l_x, flayer->l_y);
      }
    }
#line 2323
    display = olddisplay;
#line 2324
    flayer = oldflayer;
#line 2325
    display->d_status_obuflen = display->d_obuflen;
#line 2326
    display->d_status_obuffree = display->d_obuffree;
#line 2327
    tmp___7 = 0;
#line 2327
    display->d_obuflen = tmp___7;
#line 2327
    display->d_obuffree = tmp___7;
#line 2328
    display->d_status = 1;
  }
  {
#line 2330
  gettimeofday((struct timeval */* __restrict  */)(& display->d_status_time), (__timezone_ptr_t )((void *)0));
#line 2331
  SetTimeout(& display->d_statusev, MsgWait);
#line 2332
  evenq(& display->d_statusev);
  }
#line 2336
  return;
}
}
#line 2338 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void RemoveStatus(void) 
{ 
  struct display *olddisplay ;
  struct layer *oldflayer ;
  int where ;

  {
#line 2345
  if (! display) {
#line 2346
    return;
  }
#line 2347
  where = display->d_status;
#line 2347
  if (! where) {
#line 2348
    return;
  }
  {
#line 2350
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2350
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2351
  if (display->d_status_obuffree >= 0) {
    {
#line 2353
    display->d_obuflen = display->d_status_obuflen;
#line 2354
    display->d_obuffree = display->d_status_obuffree;
#line 2355
    display->d_status_obuffree = -1;
#line 2356
    display->d_status = 0;
#line 2357
    display->d_status_bell = (char)0;
#line 2358
    evdeq(& display->d_statusev);
    }
#line 2359
    return;
  }
  {
#line 2361
  display->d_status = 0;
#line 2362
  display->d_status_bell = (char)0;
#line 2363
  evdeq(& display->d_statusev);
#line 2364
  olddisplay = display;
#line 2365
  oldflayer = flayer;
  }
#line 2366
  if (where == 1) {
    {
#line 2368
    GotoPos(0, display->d_height - 1);
#line 2369
    RefreshLine(display->d_height - 1, 0, display->d_status_len - 1, 0);
#line 2370
    GotoPos(display->d_status_lastx, display->d_status_lasty);
    }
  } else {
    {
#line 2373
    RefreshHStatus();
    }
  }
#line 2374
  if (display->d_forecv) {
#line 2374
    flayer = (display->d_forecv)->c_layer;
  } else {
#line 2374
    flayer = (struct layer *)0;
  }
#line 2375
  if (flayer) {
    {
#line 2376
    LGotoPos(flayer, flayer->l_x, flayer->l_y);
    }
  }
#line 2377
  display = olddisplay;
#line 2378
  flayer = oldflayer;
#line 2379
  return;
}
}
#line 2382 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void ShowHStatus(char *str ) 
{ 
  int l ;
  int i ;
  int ox ;
  int oy ;
  int max ;
  size_t tmp ;
  size_t tmp___0 ;
  struct mchar *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 2388
  if (display->d_status == 1) {
#line 2388
    if (display->d_has_hstatus == 1) {
#line 2388
      if (display->d_height - 1 == display->d_height - 1) {
#line 2389
        return;
      }
    }
  }
#line 2390
  if (display->d_blocked) {
#line 2391
    return;
  }
#line 2393
  if (display->d_tcs[75].flg) {
#line 2393
    if (display->d_has_hstatus == 3) {
#line 2395
      if (! display->d_hstatus) {
#line 2395
        if ((unsigned long )str == (unsigned long )((char *)0)) {
#line 2396
          return;
        } else
#line 2395
        if ((int )*str == 0) {
#line 2396
          return;
        }
      }
      {
#line 2397
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2397
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 2398
      SetRendition(& mchar_null);
#line 2399
      InsertMode(0);
      }
#line 2400
      if (display->d_hstatus) {
        {
#line 2401
        AddCStr(display->d_tcs[79].str);
        }
      }
#line 2402
      display->d_hstatus = 0;
#line 2403
      if ((unsigned long )str == (unsigned long )((char *)0)) {
#line 2404
        return;
      } else
#line 2403
      if ((int )*str == 0) {
#line 2404
        return;
      }
      {
#line 2405
      AddCStr2(display->d_tcs[77].str, 0);
      }
#line 2406
      if (display->d_tcs[76].num > 0) {
#line 2406
        max = display->d_tcs[76].num;
      } else {
#line 2406
        max = display->d_width - ! display->d_tcs[87].flg;
      }
      {
#line 2407
      tmp = strlen((char const   *)str);
      }
#line 2407
      if ((int )tmp > max) {
        {
#line 2408
        AddStrn(str, max);
        }
      } else {
        {
#line 2410
        AddStr(str);
        }
      }
      {
#line 2411
      AddCStr(display->d_tcs[78].str);
#line 2412
      display->d_hstatus = 1;
      }
    } else {
#line 2393
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2414
  if (display->d_has_hstatus == 1) {
    {
#line 2416
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2416
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2417
    ox = display->d_x;
#line 2418
    oy = display->d_y;
#line 2419
    if (str) {
#line 2419
      str = str;
    } else {
#line 2419
      str = (char *)"";
    }
    {
#line 2420
    tmp___0 = strlen((char const   *)str);
#line 2420
    l = (int )tmp___0;
    }
#line 2421
    if (l > display->d_width) {
#line 2422
      l = display->d_width;
    }
    {
#line 2423
    GotoPos(0, display->d_height - 1);
    }
#line 2424
    if (captionalways) {
#line 2424
      tmp___1 = & mchar_null;
    } else
#line 2424
    if ((unsigned long )display->d_cvlist == (unsigned long )((struct canvas *)0)) {
#line 2424
      tmp___1 = & mchar_null;
    } else
#line 2424
    if ((display->d_cvlist)->c_next) {
#line 2424
      tmp___1 = & mchar_null;
    } else {
#line 2424
      tmp___1 = & mchar_so;
    }
    {
#line 2424
    SetRendition(tmp___1);
#line 2425
    tmp___2 = PutWinMsg(str, 0, l);
    }
#line 2425
    if (! tmp___2) {
#line 2426
      i = 0;
      {
#line 2426
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2426
        if (! (i < l)) {
#line 2426
          goto while_break___1;
        }
        {
#line 2427
        PUTCHARLP((int )*(str + i));
#line 2426
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 2428
    if (! captionalways) {
#line 2428
      if (display->d_cvlist) {
#line 2428
        if (! (display->d_cvlist)->c_next) {
          {
#line 2429
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 2429
            tmp___3 = l;
#line 2429
            l ++;
#line 2429
            if (! (tmp___3 < display->d_width)) {
#line 2429
              goto while_break___2;
            }
            {
#line 2430
            PUTCHARLP(' ');
            }
          }
          while_break___2: /* CIL Label */ ;
          }
        }
      }
    }
#line 2431
    if (l < display->d_width) {
      {
#line 2432
      ClearArea(l, display->d_height - 1, l, display->d_width - 1, display->d_width - 1,
                display->d_height - 1, 0, 0);
      }
    }
#line 2433
    if (ox != -1) {
#line 2433
      if (oy != -1) {
        {
#line 2434
        GotoPos(ox, oy);
        }
      }
    }
#line 2435
    if (*str) {
#line 2435
      display->d_hstatus = 1;
    } else {
#line 2435
      display->d_hstatus = 0;
    }
    {
#line 2436
    SetRendition(& mchar_null);
    }
  } else
#line 2438
  if (str) {
#line 2438
    if (*str) {
#line 2438
      if (display->d_has_hstatus == 2) {
        {
#line 2440
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 2440
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 2441
        Msg(0, (char *)"%s", str);
        }
      }
    }
  }
#line 2443
  return;
}
}
#line 2449 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void RefreshHStatus(void) 
{ 
  char *buf___0 ;
  int tmp ;

  {
  {
#line 2454
  evdeq(& display->d_hstatusev);
  }
#line 2455
  if (display->d_status == 2) {
#line 2456
    return;
  }
#line 2457
  if (display->d_tcs[75].flg) {
#line 2457
    if (display->d_has_hstatus == 3) {
#line 2457
      if (display->d_tcs[76].num > 0) {
#line 2457
        tmp = display->d_tcs[76].num;
      } else {
#line 2457
        tmp = display->d_width - ! display->d_tcs[87].flg;
      }
    } else {
#line 2457
      tmp = display->d_width - ! display->d_tcs[87].flg;
    }
  } else {
#line 2457
    tmp = display->d_width - ! display->d_tcs[87].flg;
  }
  {
#line 2457
  buf___0 = MakeWinMsgEv(hstatusstring, display->d_fore, '%', tmp, & display->d_hstatusev,
                         0);
  }
#line 2458
  if (buf___0) {
#line 2458
    if (*buf___0) {
      {
#line 2460
      ShowHStatus(buf___0);
      }
#line 2461
      if (display->d_has_hstatus != 0) {
#line 2461
        if (display->d_hstatusev.timeout.tv_sec) {
          {
#line 2462
          evenq(& display->d_hstatusev);
          }
        }
      }
    } else {
      {
#line 2465
      ShowHStatus((char *)0);
      }
    }
  } else {
    {
#line 2465
    ShowHStatus((char *)0);
    }
  }
#line 2466
  return;
}
}
#line 2473 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void RefreshAll(int isblank ) 
{ 
  struct canvas *cv ;
  struct display *olddisplay ;
  struct layer *oldflayer ;
  struct layer *l ;
  struct canvas *cvlist ;
  struct canvas *cvlnext ;

  {
  {
#line 2479
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2479
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2480
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2480
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2481
  cv = display->d_cvlist;
  {
#line 2481
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2481
    if (! cv) {
#line 2481
      goto while_break___1;
    }
    {
#line 2483
    olddisplay = display;
#line 2483
    oldflayer = flayer;
#line 2483
    l = cv->c_layer;
#line 2483
    cvlist = l->l_cvlist;
#line 2483
    cvlnext = cv->c_lnext;
#line 2483
    flayer = l;
#line 2483
    l->l_cvlist = cv;
#line 2483
    cv->c_lnext = (struct canvas *)0;
#line 2483
    (*((flayer->l_layfn)->lf_LayRedisplayLine))(-1, -1, -1, isblank);
#line 2483
    flayer = oldflayer;
#line 2483
    l->l_cvlist = cvlist;
#line 2483
    cv->c_lnext = cvlnext;
#line 2483
    display = olddisplay;
#line 2484
    display = cv->c_display;
#line 2481
    cv = cv->c_next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2486
  RefreshArea(0, 0, display->d_width - 1, display->d_height - 1, isblank);
  }
#line 2487
  return;
}
}
#line 2489 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void RefreshArea(int xs , int ys , int xe , int ye , int isblank ) 
{ 
  int y ;

  {
  {
#line 2494
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2494
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2495
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2495
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2496
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2496
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2497
  if (! isblank) {
#line 2497
    if (xs == 0) {
#line 2497
      if (xe == display->d_width - 1) {
#line 2497
        if (ye == display->d_height - 1) {
#line 2497
          if (ys == 0) {
            {
#line 2499
            ClearArea(xs, ys, xs, xe, xe, ye, 0, 0);
#line 2500
            isblank = 1;
            }
          } else
#line 2497
          if (display->d_tcs[35].str) {
            {
#line 2499
            ClearArea(xs, ys, xs, xe, xe, ye, 0, 0);
#line 2500
            isblank = 1;
            }
          }
        }
      }
    }
  }
#line 2502
  y = ys;
  {
#line 2502
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2502
    if (! (y <= ye)) {
#line 2502
      goto while_break___2;
    }
    {
#line 2503
    RefreshLine(y, xs, xe, isblank);
#line 2502
    y ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2504
  return;
}
}
#line 2506 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void RefreshLine(int y , int from , int to , int isblank ) 
{ 
  struct viewport *vp ;
  struct viewport *lvp ;
  struct canvas *cv ;
  struct canvas *lcv ;
  struct canvas *cvlist ;
  struct canvas *cvlnext ;
  struct layer *oldflayer ;
  int xx ;
  int yy ;
  char *buf___0 ;
  struct win *p ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 2517
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2517
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2519
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2519
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2520
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2520
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2522
  if (display->d_status == 1) {
#line 2522
    if (y == display->d_height - 1) {
#line 2523
      return;
    }
  }
#line 2525
  if (isblank == 0) {
#line 2525
    if (display->d_tcs[37].str) {
#line 2525
      if (to == display->d_width - 1) {
#line 2525
        if (from < to) {
          {
#line 2527
          GotoPos(from, y);
          }
#line 2528
          if (display->d_tcs[33].flg) {
            {
#line 2529
            SetRendition(& mchar_null);
            }
          } else
#line 2528
          if (display->d_tcs[66].flg) {
            {
#line 2529
            SetRendition(& mchar_null);
            }
          }
          {
#line 2530
          AddCStr(display->d_tcs[37].str);
#line 2531
          isblank = 1;
          }
        }
      }
    }
  }
  {
#line 2533
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2533
    if (! (from <= to)) {
#line 2533
      goto while_break___2;
    }
#line 2535
    lcv = (struct canvas *)0;
#line 2536
    lvp = (struct viewport *)0;
#line 2537
    cv = display->d_cvlist;
    {
#line 2537
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2537
      if (! cv) {
#line 2537
        goto while_break___3;
      }
#line 2539
      if (y < cv->c_ys) {
#line 2540
        goto __Cont;
      } else
#line 2539
      if (y > cv->c_ye) {
#line 2540
        goto __Cont;
      } else
#line 2539
      if (to < cv->c_xs) {
#line 2540
        goto __Cont;
      } else
#line 2539
      if (from > cv->c_xe) {
#line 2540
        goto __Cont;
      }
      {
#line 2541
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 2541
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 2542
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 2542
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 2543
      vp = cv->c_vplist;
      {
#line 2543
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 2543
        if (! vp) {
#line 2543
          goto while_break___6;
        }
        {
#line 2545
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 2545
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 2546
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 2546
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 2548
        if (y >= vp->v_ys) {
#line 2548
          if (y <= vp->v_ye) {
#line 2548
            if (from <= vp->v_xe) {
#line 2548
              if (to >= vp->v_xs) {
#line 2548
                if ((unsigned long )lvp == (unsigned long )((struct viewport *)0)) {
#line 2550
                  lcv = cv;
#line 2551
                  lvp = vp;
                } else
#line 2548
                if (lvp->v_xs > vp->v_xs) {
#line 2550
                  lcv = cv;
#line 2551
                  lvp = vp;
                }
              }
            }
          }
        }
#line 2543
        vp = vp->v_next;
      }
      while_break___6: /* CIL Label */ ;
      }
      __Cont: /* CIL Label */ 
#line 2537
      cv = cv->c_next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2555
    if ((unsigned long )lvp == (unsigned long )((struct viewport *)0)) {
#line 2556
      goto while_break___2;
    }
#line 2557
    if (from < lvp->v_xs) {
#line 2559
      if (! isblank) {
        {
#line 2560
        DisplayLine(& mline_null, & mline_blank, y, from, lvp->v_xs - 1);
        }
      }
#line 2561
      from = lvp->v_xs;
    }
#line 2565
    yy = y - lvp->v_yoff;
#line 2566
    if (to < lvp->v_xe) {
#line 2566
      xx = to;
    } else {
#line 2566
      xx = lvp->v_xe;
    }
#line 2568
    if (lcv->c_layer) {
#line 2568
      if (yy == (lcv->c_layer)->l_height) {
        {
#line 2570
        GotoPos(from, y);
#line 2571
        SetRendition(& mchar_blank);
        }
        {
#line 2572
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 2572
          if (from <= lvp->v_xe) {
#line 2572
            if (! (from - lvp->v_xoff < (lcv->c_layer)->l_width)) {
#line 2572
              goto while_break___9;
            }
          } else {
#line 2572
            goto while_break___9;
          }
          {
#line 2574
          PUTCHARLP('-');
#line 2575
          from ++;
          }
        }
        while_break___9: /* CIL Label */ ;
        }
#line 2577
        if (from >= lvp->v_xe + 1) {
#line 2578
          goto while_continue___2;
        }
      }
    }
#line 2580
    if ((unsigned long )lcv->c_layer == (unsigned long )((struct layer *)0)) {
#line 2580
      goto _L;
    } else
#line 2580
    if (yy >= (lcv->c_layer)->l_height) {
#line 2580
      goto _L;
    } else
#line 2580
    if (from - lvp->v_xoff >= (lcv->c_layer)->l_width) {
      _L: /* CIL Label */ 
#line 2582
      if (! isblank) {
        {
#line 2583
        DisplayLine(& mline_null, & mline_blank, y, from, lvp->v_xe);
        }
      }
#line 2584
      from = lvp->v_xe + 1;
#line 2585
      goto while_continue___2;
    }
#line 2588
    if (xx - lvp->v_xoff >= (lcv->c_layer)->l_width) {
#line 2589
      xx = ((lcv->c_layer)->l_width + lvp->v_xoff) - 1;
    }
    {
#line 2590
    oldflayer = flayer;
#line 2591
    flayer = lcv->c_layer;
#line 2592
    cvlist = flayer->l_cvlist;
#line 2593
    cvlnext = lcv->c_lnext;
#line 2594
    flayer->l_cvlist = lcv;
#line 2595
    lcv->c_lnext = (struct canvas *)0;
#line 2596
    (*((flayer->l_layfn)->lf_LayRedisplayLine))(yy, from - lvp->v_xoff, xx - lvp->v_xoff,
                                                isblank);
#line 2597
    flayer->l_cvlist = cvlist;
#line 2598
    lcv->c_lnext = cvlnext;
#line 2599
    flayer = oldflayer;
#line 2601
    from = xx + 1;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2603
  if (from > to) {
#line 2604
    return;
  }
#line 2606
  if (y == display->d_height - 1) {
#line 2606
    if (display->d_has_hstatus == 1) {
      {
#line 2608
      RefreshHStatus();
      }
#line 2609
      return;
    }
  }
#line 2612
  cv = display->d_cvlist;
  {
#line 2612
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 2612
    if (! cv) {
#line 2612
      goto while_break___10;
    }
#line 2613
    if (y == cv->c_ye + 1) {
#line 2614
      goto while_break___10;
    }
#line 2612
    cv = cv->c_next;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 2615
  if ((unsigned long )cv == (unsigned long )((struct canvas *)0)) {
#line 2617
    if (! isblank) {
      {
#line 2618
      DisplayLine(& mline_null, & mline_blank, y, from, to);
      }
    }
#line 2619
    return;
  }
  {
#line 2622
  p = (struct win *)((cv->c_layer)->l_bottom)->l_data;
#line 2623
  buf___0 = MakeWinMsgEv(captionstring, p, '%', display->d_width - ! display->d_tcs[87].flg,
                         & cv->c_captev, 0);
  }
#line 2624
  if (cv->c_captev.timeout.tv_sec) {
    {
#line 2625
    evenq(& cv->c_captev);
    }
  }
  {
#line 2626
  tmp = strlen((char const   *)buf___0);
#line 2626
  xx = (int )tmp;
#line 2627
  GotoPos(from, y);
#line 2628
  SetRendition(& mchar_so);
#line 2629
  tmp___0 = PutWinMsg(buf___0, from, to + 1);
  }
#line 2629
  if (tmp___0) {
#line 2630
    if (xx > to + 1) {
#line 2630
      from = to + 1;
    } else {
#line 2630
      from = xx;
    }
  } else {
    {
#line 2633
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 2633
      if (from <= to) {
#line 2633
        if (! (from < xx)) {
#line 2633
          goto while_break___11;
        }
      } else {
#line 2633
        goto while_break___11;
      }
      {
#line 2635
      PUTCHARLP((int )*(buf___0 + from));
#line 2636
      from ++;
      }
    }
    while_break___11: /* CIL Label */ ;
    }
  }
  {
#line 2639
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 2639
    tmp___1 = from;
#line 2639
    from ++;
#line 2639
    if (! (tmp___1 <= to)) {
#line 2639
      goto while_break___12;
    }
    {
#line 2640
    PUTCHARLP(' ');
    }
  }
  while_break___12: /* CIL Label */ ;
  }
#line 2641
  return;
}
}
#line 2648 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
static void WriteLP(int x2 , int y2 ) 
{ 
  struct mchar oldrend ;

  {
  {
#line 2654
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2654
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2655
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2655
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2656
  oldrend = display->d_rend;
  {
#line 2657
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2657
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2659
  if (display->d_lpchar.mbcs) {
#line 2661
    if (x2 > 0) {
#line 2662
      x2 --;
    } else {
#line 2664
      display->d_lpchar = mchar_blank;
    }
  }
  {
#line 2668
  GotoPos(x2, y2);
#line 2669
  SetRendition(& display->d_lpchar);
#line 2670
  PUTCHAR((int )display->d_lpchar.image);
  }
#line 2672
  if (display->d_lpchar.mbcs) {
    {
#line 2673
    PUTCHAR((int )display->d_lpchar.mbcs);
    }
  }
  {
#line 2675
  display->d_lp_missing = 0;
#line 2676
  SetRendition(& oldrend);
  }
#line 2677
  return;
}
}
#line 2679 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void ClearLine(struct mline *oml , int y , int from , int to , int bce ) 
{ 
  int x ;
  struct mchar bcechar ;
  int tmp ;

  {
  {
#line 2689
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2689
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2690
  if (display->d_tcs[33].flg) {
    {
#line 2691
    SetRendition(& mchar_null);
    }
  }
#line 2693
  if (display->d_tcs[66].flg) {
    {
#line 2694
    SetBackColor(bce);
    }
  }
#line 2696
  if (from == 0) {
#line 2696
    if (display->d_tcs[38].str) {
#line 2696
      if (to != display->d_width - 1) {
#line 2696
        goto _L;
      } else
#line 2696
      if (display->d_x == to) {
#line 2696
        if (display->d_y == y) {
          _L: /* CIL Label */ 
#line 2696
          if (! bce) {
            {
#line 2698
            GotoPos(to, y);
#line 2699
            AddCStr(display->d_tcs[38].str);
            }
#line 2700
            return;
          } else
#line 2696
          if (display->d_tcs[66].flg) {
            {
#line 2698
            GotoPos(to, y);
#line 2699
            AddCStr(display->d_tcs[38].str);
            }
#line 2700
            return;
          }
        }
      }
    }
  }
#line 2702
  if (to == display->d_width - 1) {
#line 2702
    if (display->d_tcs[37].str) {
#line 2702
      if (! bce) {
        {
#line 2704
        GotoPos(from, y);
#line 2705
        AddCStr(display->d_tcs[37].str);
        }
#line 2706
        return;
      } else
#line 2702
      if (display->d_tcs[66].flg) {
        {
#line 2704
        GotoPos(from, y);
#line 2705
        AddCStr(display->d_tcs[37].str);
        }
#line 2706
        return;
      }
    }
  }
#line 2708
  if ((unsigned long )oml == (unsigned long )((struct mline *)0)) {
#line 2709
    oml = & mline_null;
  }
#line 2711
  if (! bce) {
    {
#line 2713
    DisplayLine(oml, & mline_blank, y, from, to);
    }
#line 2714
    return;
  }
#line 2716
  bcechar = mchar_blank;
#line 2717
  bcechar.color = (unsigned char )(((int )bcechar.color & 15) | ((bce << 4) & 240));
#line 2717
  if (bce & 256) {
#line 2717
    tmp = 0;
  } else {
#line 2717
    tmp = 1 << 7;
  }
#line 2717
  bcechar.attr = (unsigned char )(((int )bcechar.attr | (1 << 7)) ^ tmp);
#line 2718
  x = from;
  {
#line 2718
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2718
    if (! (x <= to)) {
#line 2718
      goto while_break___0;
    }
    {
#line 2719
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2719
      *(mline_old.image + x) = bcechar.image;
#line 2719
      *(mline_old.attr + x) = bcechar.attr;
#line 2719
      *(mline_old.font + x) = bcechar.font;
#line 2719
      *(mline_old.color + x) = bcechar.color;
#line 2719
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2718
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2720
  DisplayLine(oml, & mline_old, y, from, to);
  }
#line 2724
  return;
}
}
#line 2726 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void DisplayLine(struct mline *oml , struct mline *ml , int y , int from , int to ) 
{ 
  register int x ;
  int last2flag ;
  int delete_lp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 2732
  last2flag = 0;
#line 2732
  delete_lp = 0;
  {
#line 2734
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2734
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2735
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2735
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2736
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2736
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2737
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2737
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2738
  if (! display->d_tcs[87].flg) {
#line 2738
    if (y == display->d_bot) {
#line 2738
      if (to == display->d_width - 1) {
#line 2740
        if (display->d_lp_missing) {
#line 2740
          goto _L___8;
        } else
#line 2740
        if ((int )*(oml->image + to) == (int )*(ml->image + to)) {
#line 2740
          if ((int )*(oml->attr + to) == (int )*(ml->attr + to)) {
#line 2740
            if ((int )*(oml->font + to) == (int )*(ml->font + to)) {
#line 2740
              if (! ((int )*(oml->color + to) == (int )*(ml->color + to))) {
#line 2740
                goto _L___8;
              }
            } else {
#line 2740
              goto _L___8;
            }
          } else {
#line 2740
            goto _L___8;
          }
        } else
        _L___8: /* CIL Label */ 
#line 2743
        if (display->d_tcs[29].str) {
#line 2743
          goto _L___4;
        } else
#line 2743
        if (display->d_tcs[27].str) {
          _L___4: /* CIL Label */ 
#line 2743
          if (from < to) {
#line 2743
            if (display->d_encoding == 8) {
#line 2743
              if ((int )*(ml->font + (to + 1)) == 255) {
#line 2743
                if ((int )*(ml->image + (to + 1)) == 255) {
#line 2743
                  tmp___1 = 1;
                } else {
#line 2743
                  tmp___1 = 0;
                }
              } else {
#line 2743
                tmp___1 = 0;
              }
#line 2743
              tmp___3 = tmp___1;
            } else {
#line 2743
              if (((int )*(ml->font + to) & 31) != 0) {
#line 2743
                if (((int )*(ml->font + to) & 224) == 0) {
#line 2743
                  tmp___2 = 1;
                } else {
#line 2743
                  tmp___2 = 0;
                }
              } else {
#line 2743
                tmp___2 = 0;
              }
#line 2743
              tmp___3 = tmp___2;
            }
#line 2743
            if (tmp___3) {
#line 2743
              goto _L___3;
            } else {
#line 2748
              last2flag = 1;
#line 2749
              display->d_lp_missing = 0;
#line 2750
              to --;
            }
          } else {
#line 2743
            goto _L___3;
          }
        } else {
          _L___3: /* CIL Label */ 
#line 2754
          if ((int )mchar_blank.image == (int )*(oml->image + to)) {
#line 2754
            if ((int )mchar_blank.attr == (int )*(oml->attr + to)) {
#line 2754
              if ((int )mchar_blank.font == (int )*(oml->font + to)) {
#line 2754
                if ((int )mchar_blank.color == (int )*(oml->color + to)) {
#line 2754
                  tmp = 0;
                } else {
#line 2754
                  goto _L___1;
                }
              } else {
#line 2754
                goto _L___1;
              }
            } else {
#line 2754
              goto _L___1;
            }
          } else
          _L___1: /* CIL Label */ 
#line 2754
          if (display->d_tcs[37].str) {
#line 2754
            tmp = 1;
          } else
#line 2754
          if (display->d_tcs[31].str) {
#line 2754
            tmp = 1;
          } else
#line 2754
          if (display->d_tcs[32].str) {
#line 2754
            tmp = 1;
          } else {
#line 2754
            tmp = 0;
          }
#line 2754
          delete_lp = tmp;
#line 2755
          if ((int )mchar_blank.image == (int )*(ml->image + to)) {
#line 2755
            if ((int )mchar_blank.attr == (int )*(ml->attr + to)) {
#line 2755
              if ((int )mchar_blank.font == (int )*(ml->font + to)) {
#line 2755
                if ((int )mchar_blank.color == (int )*(ml->color + to)) {
#line 2755
                  tmp___0 = 0;
                } else {
#line 2755
                  tmp___0 = 1;
                }
              } else {
#line 2755
                tmp___0 = 1;
              }
            } else {
#line 2755
              tmp___0 = 1;
            }
          } else {
#line 2755
            tmp___0 = 1;
          }
#line 2755
          display->d_lp_missing = tmp___0;
          {
#line 2756
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 2756
            display->d_lpchar.image = *(ml->image + to);
#line 2756
            display->d_lpchar.attr = *(ml->attr + to);
#line 2756
            display->d_lpchar.font = *(ml->font + to);
#line 2756
            display->d_lpchar.color = *(ml->color + to);
#line 2756
            display->d_lpchar.mbcs = (unsigned char)0;
#line 2756
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 2759
        to --;
      }
    }
  }
#line 2762
  if (display->d_mbcs) {
    {
#line 2765
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2765
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 2766
    SetRenditionMline(ml, from);
#line 2767
    PUTCHAR((int )*(ml->image + from));
#line 2768
    from ++;
    }
  }
#line 2771
  x = from;
  {
#line 2771
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 2771
    if (! (x <= to)) {
#line 2771
      goto while_break___5;
    }
#line 2777
    if (x < to) {
#line 2777
      goto _L___9;
    } else
#line 2777
    if (x != display->d_width - 1) {
#line 2777
      goto _L___9;
    } else
#line 2777
    if (*(ml->image + (x + 1))) {
      _L___9: /* CIL Label */ 
#line 2778
      if ((int )*(oml->image + x) == (int )*(ml->image + x)) {
#line 2778
        if ((int )*(oml->attr + x) == (int )*(ml->attr + x)) {
#line 2778
          if ((int )*(oml->font + x) == (int )*(ml->font + x)) {
#line 2778
            if ((int )*(oml->color + x) == (int )*(ml->color + x)) {
#line 2779
              goto __Cont;
            }
          }
        }
      }
    }
    {
#line 2780
    GotoPos(x, y);
    }
#line 2783
    if (display->d_encoding == 8) {
#line 2783
      if ((int )*(ml->font + x) == 255) {
#line 2783
        if ((int )*(ml->image + x) == 255) {
#line 2783
          tmp___4 = 1;
        } else {
#line 2783
          tmp___4 = 0;
        }
      } else {
#line 2783
        tmp___4 = 0;
      }
#line 2783
      tmp___5 = tmp___4;
    } else {
#line 2783
      tmp___5 = ((int )*(ml->font + x) & 224) == 128;
    }
#line 2783
    if (tmp___5) {
#line 2785
      x --;
      {
#line 2786
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 2786
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 2787
      GotoPos(x, y);
      }
    }
#line 2789
    if (x == to) {
#line 2789
      if (display->d_encoding == 8) {
#line 2789
        if ((int )*(ml->font + (x + 1)) == 255) {
#line 2789
          if ((int )*(ml->image + (x + 1)) == 255) {
#line 2789
            tmp___6 = 1;
          } else {
#line 2789
            tmp___6 = 0;
          }
        } else {
#line 2789
          tmp___6 = 0;
        }
#line 2789
        tmp___8 = tmp___6;
      } else {
#line 2789
        if (((int )*(ml->font + x) & 31) != 0) {
#line 2789
          if (((int )*(ml->font + x) & 224) == 0) {
#line 2789
            tmp___7 = 1;
          } else {
#line 2789
            tmp___7 = 0;
          }
        } else {
#line 2789
          tmp___7 = 0;
        }
#line 2789
        tmp___8 = tmp___7;
      }
#line 2789
      if (tmp___8) {
#line 2790
        goto while_break___5;
      }
    }
    {
#line 2792
    SetRenditionMline(ml, x);
#line 2793
    PUTCHAR((int )*(ml->image + x));
    }
#line 2795
    if (display->d_encoding == 8) {
#line 2795
      if ((int )*(ml->font + (x + 1)) == 255) {
#line 2795
        if ((int )*(ml->image + (x + 1)) == 255) {
#line 2795
          tmp___9 = 1;
        } else {
#line 2795
          tmp___9 = 0;
        }
      } else {
#line 2795
        tmp___9 = 0;
      }
#line 2795
      tmp___11 = tmp___9;
    } else {
#line 2795
      if (((int )*(ml->font + x) & 31) != 0) {
#line 2795
        if (((int )*(ml->font + x) & 224) == 0) {
#line 2795
          tmp___10 = 1;
        } else {
#line 2795
          tmp___10 = 0;
        }
      } else {
#line 2795
        tmp___10 = 0;
      }
#line 2795
      tmp___11 = tmp___10;
    }
#line 2795
    if (tmp___11) {
      {
#line 2796
      x ++;
#line 2796
      PUTCHAR((int )*(ml->image + x));
      }
    }
    __Cont: /* CIL Label */ 
#line 2771
    x ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 2804
  if (last2flag) {
    {
#line 2806
    GotoPos(x, y);
#line 2807
    SetRenditionMline(ml, x + 1);
#line 2808
    PUTCHAR((int )*(ml->image + (x + 1)));
#line 2809
    GotoPos(x, y);
#line 2810
    SetRenditionMline(ml, x);
#line 2811
    INSERTCHAR((int )*(ml->image + x));
    }
  } else
#line 2813
  if (delete_lp) {
#line 2815
    if (display->d_tcs[33].flg) {
      {
#line 2816
      SetRendition(& mchar_null);
      }
    }
#line 2817
    if (display->d_tcs[31].str) {
      {
#line 2818
      AddCStr(display->d_tcs[31].str);
      }
    } else
#line 2819
    if (display->d_tcs[32].str) {
      {
#line 2820
      AddCStr2(display->d_tcs[32].str, 1);
      }
    } else
#line 2821
    if (display->d_tcs[37].str) {
      {
#line 2822
      AddCStr(display->d_tcs[37].str);
      }
    }
  }
#line 2824
  return;
}
}
#line 2826 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void PutChar(struct mchar *c , int x , int y ) 
{ 


  {
  {
#line 2831
  GotoPos(x, y);
#line 2832
  SetRendition(c);
#line 2833
  PUTCHARLP((int )c->image);
  }
#line 2835
  if (c->mbcs) {
#line 2838
    if (display->d_encoding == 8) {
#line 2839
      display->d_rend.font = (unsigned char)0;
    }
    {
#line 2841
    PUTCHARLP((int )c->mbcs);
    }
  }
#line 2844
  return;
}
}
#line 2846 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void InsChar(struct mchar *c , int x , int xe , int y , struct mline *oml ) 
{ 
  int tmp ;

  {
  {
#line 2852
  GotoPos(x, y);
  }
#line 2853
  if (y == display->d_bot) {
#line 2853
    if (! display->d_tcs[87].flg) {
#line 2855
      if (x == display->d_width - 1) {
#line 2857
        display->d_lp_missing = 1;
#line 2858
        display->d_lpchar = *c;
#line 2859
        return;
      }
#line 2861
      if (xe == display->d_width - 1) {
#line 2862
        display->d_lp_missing = 0;
      }
    }
  }
#line 2864
  if (x == xe) {
    {
#line 2866
    SetRendition(c);
#line 2867
    PUTCHARLP((int )c->image);
    }
#line 2868
    return;
  }
#line 2870
  if (display->d_tcs[29].str) {
#line 2870
    goto _L;
  } else
#line 2870
  if (display->d_tcs[30].str) {
#line 2870
    goto _L;
  } else
#line 2870
  if (display->d_tcs[27].str) {
    _L: /* CIL Label */ 
#line 2870
    if (xe != display->d_width - 1) {
      {
#line 2872
      RefreshLine(y, x, xe, 0);
#line 2873
      GotoPos(x + 1, y);
      }
#line 2875
      return;
    }
  } else {
    {
#line 2872
    RefreshLine(y, x, xe, 0);
#line 2873
    GotoPos(x + 1, y);
    }
#line 2875
    return;
  }
  {
#line 2877
  InsertMode(1);
  }
#line 2878
  if (! display->d_insert) {
#line 2881
    if (c->mbcs) {
#line 2881
      if (display->d_tcs[29].str) {
        {
#line 2882
        AddCStr(display->d_tcs[29].str);
        }
      }
    }
#line 2883
    if (display->d_tcs[29].str) {
      {
#line 2884
      AddCStr(display->d_tcs[29].str);
      }
    } else {
#line 2886
      if (c->mbcs) {
#line 2886
        tmp = 2;
      } else {
#line 2886
        tmp = 1;
      }
      {
#line 2886
      AddCStr2(display->d_tcs[30].str, tmp);
      }
    }
  }
  {
#line 2894
  SetRendition(c);
#line 2895
  RAW_PUTCHAR((int )c->image);
  }
#line 2897
  if (c->mbcs) {
#line 2900
    if (display->d_encoding == 8) {
#line 2901
      display->d_rend.font = (unsigned char)0;
    }
#line 2903
    if (display->d_x == display->d_width - 1) {
      {
#line 2904
      PUTCHARLP((int )c->mbcs);
      }
    } else {
      {
#line 2906
      RAW_PUTCHAR((int )c->mbcs);
      }
    }
  }
#line 2909
  return;
}
}
#line 2911 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void WrapChar(struct mchar *c , int x , int y , int xs , int ys , int xe , int ye ,
              int ins ) 
{ 
  int bce ;
  int tmp ;
  int tmp___0 ;

  {
#line 2921
  if ((int )c->attr & (1 << 7)) {
#line 2921
    tmp = 256;
  } else {
#line 2921
    tmp = 0;
  }
#line 2921
  bce = (((int )c->color & 240) >> 4) | tmp;
  {
#line 2925
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2925
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2926
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2926
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2927
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2927
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2928
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2928
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2929
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2929
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2930
  if (xs != 0) {
#line 2930
    goto _L;
  } else
#line 2930
  if (x != display->d_width) {
#line 2930
    goto _L;
  } else
#line 2930
  if (! display->d_tcs[83].flg) {
    _L: /* CIL Label */ 
#line 2932
    if (y == ye) {
      {
#line 2933
      ScrollV(xs, ys, xe, ye, 1, bce);
      }
    } else
#line 2934
    if (y < display->d_height - 1) {
#line 2935
      y ++;
    }
#line 2936
    if (ins) {
      {
#line 2937
      InsChar(c, xs, xe, y, (struct mline *)0);
      }
    } else {
      {
#line 2939
      PutChar(c, xs, y);
      }
    }
#line 2940
    return;
  }
#line 2942
  if (y == ye) {
    {
#line 2944
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2944
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 2945
    ChangeScrollRegion(ys, ye);
    }
#line 2946
    if (display->d_bot != y) {
#line 2946
      goto _L___0;
    } else
#line 2946
    if (display->d_x != display->d_width) {
#line 2946
      goto _L___0;
    } else
#line 2946
    if (! bce) {
#line 2946
      if (! display->d_tcs[66].flg) {
        _L___0: /* CIL Label */ 
        {
#line 2948
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 2948
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
        {
#line 2949
        ScrollV(xs, ys, xe, ye, 1, bce);
#line 2950
        y --;
        }
      }
    }
  } else
#line 2953
  if (y == display->d_bot) {
    {
#line 2954
    ChangeScrollRegion(0, display->d_height - 1);
    }
  }
#line 2955
  if (display->d_x != display->d_width) {
#line 2955
    goto _L___2;
  } else
#line 2955
  if (display->d_y != y) {
    _L___2: /* CIL Label */ 
#line 2957
    if (display->d_tcs[87].flg) {
#line 2957
      if (y >= 0) {
        {
#line 2958
        RefreshLine(y, display->d_width - 1, display->d_width - 1, 0);
        }
      }
    }
    {
#line 2959
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 2959
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 2960
    if (display->d_x != display->d_width) {
#line 2960
      goto _L___1;
    } else
#line 2960
    if (display->d_y != y) {
      _L___1: /* CIL Label */ 
#line 2962
      if (y == ye) {
        {
#line 2963
        ScrollV(xs, ys, xe, ye, 1, bce);
        }
      }
#line 2964
      if (y == ye) {
#line 2964
        tmp___0 = y;
      } else
#line 2964
      if (y == display->d_height - 1) {
#line 2964
        tmp___0 = y;
      } else {
#line 2964
        tmp___0 = y + 1;
      }
      {
#line 2964
      GotoPos(xs, tmp___0);
      }
    }
  }
  {
#line 2967
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 2967
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 2968
  if (y != ye) {
#line 2968
    if (y < display->d_height - 1) {
#line 2969
      y ++;
    }
  }
#line 2970
  if (ins != display->d_insert) {
    {
#line 2971
    InsertMode(ins);
    }
  }
#line 2972
  if (ins) {
#line 2972
    if (! display->d_insert) {
      {
#line 2974
      InsChar(c, 0, xe, y, (struct mline *)0);
      }
      {
#line 2975
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 2975
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 2976
      return;
    }
  }
  {
#line 2978
  display->d_y = y;
#line 2979
  display->d_x = 0;
#line 2980
  SetRendition(c);
#line 2981
  RAW_PUTCHAR((int )c->image);
  }
#line 2983
  if (c->mbcs) {
#line 2986
    if (display->d_encoding == 8) {
#line 2987
      display->d_rend.font = (unsigned char)0;
    }
    {
#line 2989
    RAW_PUTCHAR((int )c->mbcs);
    }
  }
  {
#line 2992
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 2992
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 2993
  return;
}
}
#line 2995 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
int ResizeDisplay(int wi , int he ) 
{ 
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 2999
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2999
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3000
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3000
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3001
  if (display->d_width == wi) {
#line 3001
    if (display->d_height == he) {
      {
#line 3003
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3003
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 3004
      return (0);
    }
  }
#line 3006
  if (display->d_width != wi) {
#line 3006
    if (display->d_height == he) {
#line 3006
      goto _L___0;
    } else
#line 3006
    if (! display->d_tcs[44].str) {
      _L___0: /* CIL Label */ 
#line 3006
      if (display->d_tcs[45].str) {
#line 3006
        if (wi == Z0width) {
#line 3006
          goto _L;
        } else
#line 3006
        if (wi == Z1width) {
          _L: /* CIL Label */ 
          {
#line 3008
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 3008
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 3009
          if (wi == Z0width) {
#line 3009
            tmp = display->d_tcs[45].str;
          } else {
#line 3009
            tmp = display->d_tcs[46].str;
          }
          {
#line 3009
          AddCStr(tmp);
#line 3010
          ChangeScreenSize(wi, display->d_height, 0);
          }
#line 3011
          if (he == display->d_height) {
#line 3011
            tmp___0 = 0;
          } else {
#line 3011
            tmp___0 = -1;
          }
#line 3011
          return (tmp___0);
        }
      }
    }
  }
#line 3013
  if (display->d_tcs[44].str) {
    {
#line 3015
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 3015
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 3016
    tmp___1 = tgoto(display->d_tcs[44].str, wi, he);
#line 3016
    AddCStr(tmp___1);
#line 3017
    ChangeScreenSize(wi, he, 0);
    }
#line 3018
    return (0);
  }
#line 3020
  return (-1);
}
}
#line 3023 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void ChangeScrollRegion(int newtop , int newbot ) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
#line 3027
  if ((unsigned long )display == (unsigned long )((struct display *)0)) {
#line 3028
    return;
  }
#line 3029
  if (newtop == newbot) {
#line 3030
    return;
  }
#line 3031
  if (newtop == -1) {
#line 3032
    newtop = 0;
  }
#line 3033
  if (newbot == -1) {
#line 3034
    newbot = display->d_height - 1;
  }
#line 3035
  if ((unsigned long )display->d_tcs[18].str == (unsigned long )((char *)0)) {
#line 3037
    display->d_top = 0;
#line 3038
    display->d_bot = display->d_height - 1;
#line 3039
    return;
  }
#line 3041
  if (display->d_top == newtop) {
#line 3041
    if (display->d_bot == newbot) {
#line 3042
      return;
    }
  }
  {
#line 3043
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3043
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3044
  tmp = tgoto(display->d_tcs[18].str, newbot, newtop);
#line 3044
  AddCStr(tmp);
#line 3045
  display->d_top = newtop;
#line 3046
  display->d_bot = newbot;
#line 3047
  tmp___0 = -1;
#line 3047
  display->d_x = tmp___0;
#line 3047
  display->d_y = tmp___0;
  }
#line 3048
  return;
}
}
#line 3093 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void AddStr(char *str ) 
{ 
  register char c ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 3099
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3099
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3102
  if (display->d_encoding == 8) {
    {
#line 3104
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3104
      tmp = str;
#line 3104
      str ++;
#line 3104
      c = *tmp;
#line 3104
      if (! c) {
#line 3104
        goto while_break___0;
      }
      {
#line 3105
      AddUtf8((int )((unsigned char )c));
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3106
    return;
  }
  {
#line 3109
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3109
    tmp___1 = str;
#line 3109
    str ++;
#line 3109
    c = *tmp___1;
#line 3109
    if (! c) {
#line 3109
      goto while_break___1;
    }
    {
#line 3110
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3110
      (display->d_obuffree) --;
#line 3110
      if (display->d_obuffree <= 0) {
        {
#line 3110
        Resize_obuf();
        }
      }
#line 3110
      tmp___0 = display->d_obufp;
#line 3110
      (display->d_obufp) ++;
#line 3110
      *tmp___0 = c;
#line 3110
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3111
  return;
}
}
#line 3113 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void AddStrn(char *str , int n ) 
{ 
  register char c ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 3120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3120
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3122
  if (display->d_encoding == 8) {
    {
#line 3124
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3124
      tmp = str;
#line 3124
      str ++;
#line 3124
      c = *tmp;
#line 3124
      if (c) {
#line 3124
        tmp___0 = n;
#line 3124
        n --;
#line 3124
        if (! (tmp___0 > 0)) {
#line 3124
          goto while_break___0;
        }
      } else {
#line 3124
        goto while_break___0;
      }
      {
#line 3125
      AddUtf8((int )((unsigned char )c));
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 3129
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3129
      tmp___2 = str;
#line 3129
      str ++;
#line 3129
      c = *tmp___2;
#line 3129
      if (c) {
#line 3129
        tmp___3 = n;
#line 3129
        n --;
#line 3129
        if (! (tmp___3 > 0)) {
#line 3129
          goto while_break___1;
        }
      } else {
#line 3129
        goto while_break___1;
      }
      {
#line 3130
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 3130
        (display->d_obuffree) --;
#line 3130
        if (display->d_obuffree <= 0) {
          {
#line 3130
          Resize_obuf();
          }
        }
#line 3130
        tmp___1 = display->d_obufp;
#line 3130
        (display->d_obufp) ++;
#line 3130
        *tmp___1 = c;
#line 3130
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 3131
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 3131
    tmp___5 = n;
#line 3131
    n --;
#line 3131
    if (! (tmp___5 > 0)) {
#line 3131
      goto while_break___3;
    }
    {
#line 3132
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 3132
      (display->d_obuffree) --;
#line 3132
      if (display->d_obuffree <= 0) {
        {
#line 3132
        Resize_obuf();
        }
      }
#line 3132
      tmp___4 = display->d_obufp;
#line 3132
      (display->d_obufp) ++;
#line 3132
      *tmp___4 = (char )' ';
#line 3132
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 3133
  return;
}
}
#line 3135 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void Flush(void) 
{ 
  register int l ;
  register char *p ;
  int tmp ;
  register int wr ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 3141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3141
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3142
  l = (int )(display->d_obufp - display->d_obuf);
  {
#line 3143
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3143
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3144
  if (l == 0) {
#line 3145
    return;
  }
  {
#line 3146
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3146
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3147
  if (display->d_userfd < 0) {
#line 3149
    display->d_obuffree += l;
#line 3150
    display->d_obufp = display->d_obuf;
#line 3151
    return;
  }
  {
#line 3153
  p = display->d_obuf;
#line 3154
  tmp = fcntl(display->d_userfd, 4, 0);
  }
#line 3154
  if (tmp) {
    {
#line 3155
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3155
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 3156
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 3156
    if (! l) {
#line 3156
      goto while_break___3;
    }
    {
#line 3159
    wr = write(display->d_userfd, (void const   *)p, (size_t )l);
    }
#line 3160
    if (wr <= 0) {
      {
#line 3162
      tmp___0 = __errno_location();
      }
#line 3162
      if (*tmp___0 == 4) {
#line 3163
        goto while_continue___3;
      }
      {
#line 3164
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 3164
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 3165
      wr = l;
    }
#line 3167
    if (! display) {
#line 3168
      return;
    }
#line 3169
    display->d_obuffree += wr;
#line 3170
    p += wr;
#line 3171
    l -= wr;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 3173
  display->d_obuffree += l;
#line 3174
  display->d_obufp = display->d_obuf;
#line 3175
  tmp___1 = fcntl(display->d_userfd, 4, 2048);
  }
#line 3175
  if (tmp___1) {
    {
#line 3176
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 3176
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 3177
  if (display->d_blocked == 1) {
#line 3178
    display->d_blocked = 0;
  }
#line 3179
  display->d_blocked_fuzz = 0;
#line 3180
  return;
}
}
#line 3182 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void freetty(void) 
{ 


  {
#line 3185
  if (display->d_userfd >= 0) {
    {
#line 3186
    close(display->d_userfd);
    }
  }
  {
#line 3187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3187
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3188
  display->d_userfd = -1;
#line 3189
  display->d_obufp = (char *)0;
#line 3190
  display->d_obuffree = 0;
#line 3191
  if (display->d_obuf) {
    {
#line 3192
    free((void *)display->d_obuf);
    }
  }
#line 3193
  display->d_obuf = (char *)0;
#line 3194
  display->d_obuflen = 0;
#line 3195
  display->d_obuflenmax = - display->d_obufmax;
#line 3196
  display->d_blocked = 0;
#line 3197
  display->d_blocked_fuzz = 0;
#line 3198
  return;
}
}
#line 3205 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void Resize_obuf(void) 
{ 
  register int ind ;
  struct timeval now ;
  int ti ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 3210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3210
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3211
  if (display->d_status_obuffree >= 0) {
    {
#line 3213
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3213
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3214
    if (! display->d_status_bell) {
      {
#line 3218
      gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
#line 3219
      ti = (int )((now.tv_sec - display->d_status_time.tv_sec) * 1000L + (now.tv_usec - display->d_status_time.tv_usec) / 1000L);
      }
#line 3220
      if (ti < MsgMinWait) {
        {
#line 3221
        DisplaySleep1000(MsgMinWait - ti, 0);
        }
      }
    }
    {
#line 3223
    RemoveStatus();
#line 3224
    (display->d_obuffree) --;
    }
#line 3224
    if (display->d_obuffree > 0) {
#line 3225
      return;
    }
  }
#line 3227
  if (display->d_obuflen) {
#line 3227
    if (display->d_obuf) {
      {
#line 3229
      ind = (int )(display->d_obufp - display->d_obuf);
#line 3230
      display->d_obuflen += 4096;
#line 3231
      display->d_obuffree += 4096;
#line 3232
      tmp = realloc((void *)display->d_obuf, (size_t )display->d_obuflen);
#line 3232
      display->d_obuf = (char *)tmp;
      }
    } else {
      {
#line 3236
      ind = 0;
#line 3237
      display->d_obuflen = 4096;
#line 3238
      display->d_obuffree = 4096;
#line 3239
      tmp___0 = malloc((size_t )display->d_obuflen);
#line 3239
      display->d_obuf = (char *)tmp___0;
      }
    }
  } else {
    {
#line 3236
    ind = 0;
#line 3237
    display->d_obuflen = 4096;
#line 3238
    display->d_obuffree = 4096;
#line 3239
    tmp___0 = malloc((size_t )display->d_obuflen);
#line 3239
    display->d_obuf = (char *)tmp___0;
    }
  }
#line 3241
  if (! display->d_obuf) {
    {
#line 3242
    Panic(0, (char *)"Out of memory");
    }
  }
#line 3243
  display->d_obufp = display->d_obuf + ind;
#line 3244
  display->d_obuflenmax = display->d_obuflen - display->d_obufmax;
  {
#line 3245
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3245
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3246
  return;
}
}
#line 3248 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void DisplaySleep1000(int n , int eat ) 
{ 
  char buf___0 ;
  fd_set r ;
  struct timeval t ;
  int __d0 ;
  int __d1 ;
  int tmp ;

  {
#line 3257
  if (n <= 0) {
#line 3258
    return;
  }
#line 3259
  if (! display) {
    {
#line 3261
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3261
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3262
    sleep1000(n);
    }
#line 3263
    return;
  }
#line 3265
  t.tv_usec = (__suseconds_t )((n % 1000) * 1000);
#line 3266
  t.tv_sec = (__time_t )(n / 1000);
  {
#line 3267
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3267
    __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& r.__fds_bits[0]): "memory");
#line 3267
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3268
  __asm__  volatile   ("btsl %1,%0": "=m" (r.__fds_bits[(unsigned long )display->d_userfd / (8UL * sizeof(__fd_mask ))]): "r" ((unsigned long )display->d_userfd % (8UL * sizeof(__fd_mask ))): "cc",
                       "memory");
#line 3269
  tmp = select(1024, (fd_set */* __restrict  */)(& r), (fd_set */* __restrict  */)((fd_set *)0),
               (fd_set */* __restrict  */)((fd_set *)0), (struct timeval */* __restrict  */)(& t));
  }
#line 3269
  if (tmp > 0) {
    {
#line 3271
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3271
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 3272
    if (eat) {
      {
#line 3273
      read(display->d_userfd, (void *)(& buf___0), (size_t )1);
      }
    }
  }
  {
#line 3275
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3275
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3276
  return;
}
}
#line 3279 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void NukePending(void) 
{ 
  register int len ;
  int oldtop ;
  int oldbot ;
  struct mchar oldrend ;
  int oldkeypad ;
  int oldcursorkeys ;
  int oldcurvis ;
  int oldmouse ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 3283
  oldtop = display->d_top;
#line 3283
  oldbot = display->d_bot;
#line 3285
  oldkeypad = display->d_keypad;
#line 3285
  oldcursorkeys = display->d_cursorkeys;
#line 3286
  oldcurvis = display->d_curvis;
#line 3287
  oldmouse = display->d_mouse;
#line 3289
  oldrend = display->d_rend;
#line 3290
  len = (int )(display->d_obufp - display->d_obuf);
  {
#line 3291
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3291
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3295
  tcflush(display->d_userfd, 1);
#line 3302
  display->d_obufp = display->d_obuf;
#line 3303
  display->d_obuffree += len;
#line 3304
  tmp = -1;
#line 3304
  display->d_bot = tmp;
#line 3304
  display->d_top = tmp;
#line 3305
  AddCStr(display->d_tcs[40].str);
#line 3306
  AddCStr(display->d_tcs[39].str);
  }
#line 3308
  if (display->d_tcs[55].str) {
    {
#line 3309
    AddCStr(display->d_tcs[55].str);
    }
  } else {
#line 3313
    if (display->d_hascolor) {
      {
#line 3314
      AddStr((char *)"\033[m");
      }
    }
    {
#line 3316
    AddCStr(display->d_tcs[54].str);
#line 3317
    AddCStr(display->d_tcs[53].str);
    }
  }
#line 3320
  if (display->d_tcs[27].str) {
    {
#line 3320
    tmp___0 = strcmp((char const   *)display->d_tcs[27].str, (char const   *)display->d_tcs[28].str);
    }
#line 3320
    if (tmp___0) {
      {
#line 3321
      AddCStr(display->d_tcs[28].str);
      }
    }
  }
#line 3322
  display->d_insert = 0;
#line 3325
  if (display->d_tcs[69].str) {
    {
#line 3325
    tmp___1 = strcmp((char const   *)display->d_tcs[69].str, (char const   *)display->d_tcs[70].str);
    }
#line 3325
    if (tmp___1) {
      {
#line 3326
      AddCStr(display->d_tcs[69].str);
      }
    }
  }
#line 3327
  if (display->d_tcs[71].str) {
    {
#line 3327
    tmp___2 = strcmp((char const   *)display->d_tcs[71].str, (char const   *)display->d_tcs[72].str);
    }
#line 3327
    if (tmp___2) {
      {
#line 3328
      AddCStr(display->d_tcs[71].str);
      }
    }
  }
  {
#line 3337
  AddCStr(display->d_tcs[99].str);
#line 3338
  display->d_rend = mchar_null;
#line 3339
  display->d_atyp = (char)0;
#line 3340
  AddCStr(display->d_tcs[79].str);
#line 3341
  display->d_hstatus = 0;
#line 3342
  AddCStr(display->d_tcs[82].str);
#line 3343
  display->d_curvis = 0;
#line 3344
  ChangeScrollRegion(oldtop, oldbot);
#line 3345
  SetRendition(& oldrend);
#line 3346
  KeypadMode(oldkeypad);
#line 3347
  CursorkeysMode(oldcursorkeys);
#line 3348
  CursorVisibility(oldcurvis);
#line 3349
  MouseMode(oldmouse);
  }
#line 3350
  if (display->d_tcs[44].str) {
    {
#line 3352
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3352
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3353
    tmp___3 = tgoto(display->d_tcs[44].str, display->d_width, display->d_height);
#line 3353
    AddCStr(tmp___3);
    }
  } else
#line 3355
  if (display->d_tcs[45].str) {
#line 3355
    if (display->d_width == Z0width) {
#line 3355
      goto _L;
    } else
#line 3355
    if (display->d_width == Z1width) {
      _L: /* CIL Label */ 
      {
#line 3357
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3357
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 3358
      if (display->d_width == Z0width) {
#line 3358
        tmp___4 = display->d_tcs[45].str;
      } else {
#line 3358
        tmp___4 = display->d_tcs[46].str;
      }
      {
#line 3358
      AddCStr(tmp___4);
      }
    }
  }
#line 3360
  return;
}
}
#line 3367 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
static void disp_writeev_eagain(struct event *ev , char *data ) 
{ 


  {
  {
#line 3372
  display = (struct display *)data;
#line 3373
  evdeq(& display->d_writeev);
#line 3374
  display->d_writeev.type = 2;
#line 3375
  display->d_writeev.handler = & disp_writeev_fn;
#line 3376
  evenq(& display->d_writeev);
  }
#line 3377
  return;
}
}
#line 3380 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
static void disp_writeev_fn(struct event *ev , char *data ) 
{ 
  int len ;
  int size ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 3385
  size = 256;
#line 3387
  display = (struct display *)data;
#line 3388
  len = (int )(display->d_obufp - display->d_obuf);
#line 3389
  if (len < size) {
#line 3390
    size = len;
  }
  {
#line 3391
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3391
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3392
  size = write(display->d_userfd, (void const   *)display->d_obuf, (size_t )size);
  }
#line 3393
  if (size >= 0) {
#line 3395
    len -= size;
#line 3396
    if (len) {
      {
#line 3398
      bcopy((void const   *)(display->d_obuf + size), (void *)display->d_obuf, (size_t )len);
      }
      {
#line 3399
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3399
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 3401
    display->d_obufp -= size;
#line 3402
    display->d_obuffree += size;
#line 3403
    if (display->d_blocked_fuzz) {
#line 3405
      display->d_blocked_fuzz -= size;
#line 3406
      if (display->d_blocked_fuzz < 0) {
#line 3407
        display->d_blocked_fuzz = 0;
      }
    }
#line 3409
    if (display->d_blockedev.queued) {
#line 3411
      if (display->d_obufp - display->d_obuf > (long )(display->d_obufmax / 2)) {
        {
#line 3413
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 3413
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 3414
        SetTimeout(& display->d_blockedev, display->d_nonblock);
        }
      } else {
        {
#line 3418
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 3418
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 3419
        evdeq(& display->d_blockedev);
        }
      }
    }
#line 3422
    if (display->d_blocked == 1) {
#line 3422
      if ((unsigned long )display->d_obuf == (unsigned long )display->d_obufp) {
        {
#line 3425
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 3425
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 3426
        display->d_blocked = 0;
#line 3427
        if (display->d_fore) {
#line 3427
          tmp = (int )(display->d_fore)->w_norefresh;
        } else {
#line 3427
          tmp = 0;
        }
        {
#line 3427
        Activate(tmp);
#line 3428
        display->d_blocked_fuzz = (int )(display->d_obufp - display->d_obuf);
        }
      }
    }
  } else {
    {
#line 3435
    tmp___0 = __errno_location();
    }
#line 3435
    if (*tmp___0 == 11) {
      {
#line 3437
      evdeq(& display->d_writeev);
#line 3438
      display->d_writeev.type = 0;
#line 3439
      display->d_writeev.handler = & disp_writeev_eagain;
#line 3440
      SetTimeout(& display->d_writeev, 100);
#line 3441
      evenq(& display->d_writeev);
      }
    }
    {
#line 3444
    tmp___2 = __errno_location();
    }
#line 3444
    if (*tmp___2 != 4) {
      {
#line 3444
      tmp___3 = __errno_location();
      }
#line 3444
      if (*tmp___3 != 11) {
        {
#line 3448
        tmp___1 = __errno_location();
#line 3448
        Msg(*tmp___1, (char *)"Error writing output to display");
        }
      }
    }
  }
#line 3450
  return;
}
}
#line 3452 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
static void disp_readev_fn(struct event *ev , char *data ) 
{ 
  int size ;
  char buf___0[4096] ;
  struct canvas *cv ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *bufp ;
  struct win *p ;
  unsigned char *bp ;
  int x ;
  int y ;
  int i ;
  int i___0 ;
  int j ;
  int c ;
  int enc ;
  char buf2[8202] ;
  int font ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 3461
  display = (struct display *)data;
#line 3464
  if (display->d_forecv) {
#line 3465
    cv = ((display->d_forecv)->c_layer)->l_cvlist;
    {
#line 3465
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3465
      if (! cv) {
#line 3465
        goto while_break;
      }
#line 3467
      display = cv->c_display;
#line 3468
      if (display->d_status == 1) {
        {
#line 3469
        RemoveStatus();
        }
      }
#line 3465
      cv = cv->c_lnext;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 3472
  display = (struct display *)data;
#line 3473
  if ((unsigned long )display->d_fore == (unsigned long )((struct win *)0)) {
#line 3474
    size = 4096;
  } else
#line 3478
  if ((display->d_fore)->w_pwin) {
#line 3478
    if (((display->d_fore)->w_pwin)->p_fdpat & 4096) {
#line 3479
      size = (int )(sizeof(((display->d_fore)->w_pwin)->p_inbuf) - (unsigned long )((display->d_fore)->w_pwin)->p_inlen);
    } else {
#line 3482
      size = (int )(sizeof((display->d_fore)->w_inbuf) - (unsigned long )(display->d_fore)->w_inlen);
    }
  } else {
#line 3482
    size = (int )(sizeof((display->d_fore)->w_inbuf) - (unsigned long )(display->d_fore)->w_inlen);
  }
#line 3485
  if (size > 4096) {
#line 3486
    size = 4096;
  }
#line 3487
  if (size <= 0) {
#line 3488
    size = 1;
  }
  {
#line 3490
  size = read(display->d_userfd, (void *)(buf___0), (size_t )size);
  }
#line 3491
  if (size < 0) {
    {
#line 3493
    tmp = __errno_location();
    }
#line 3493
    if (*tmp == 4) {
#line 3494
      return;
    } else {
      {
#line 3493
      tmp___0 = __errno_location();
      }
#line 3493
      if (*tmp___0 == 11) {
#line 3494
        return;
      }
    }
    {
#line 3499
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3499
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3500
    Hangup();
#line 3501
    sleep(1U);
    }
#line 3502
    return;
  } else
#line 3504
  if (size == 0) {
    {
#line 3506
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3506
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 3507
    Hangup();
#line 3508
    sleep(1U);
    }
#line 3509
    return;
  }
#line 3511
  if (display->d_blocked == 4) {
    {
#line 3513
    display->d_blocked = 0;
#line 3515
    KillBlanker();
    }
#line 3517
    if (display->d_fore) {
#line 3517
      tmp___1 = (int )(display->d_fore)->w_norefresh;
    } else {
#line 3517
      tmp___1 = 0;
    }
    {
#line 3517
    Activate(tmp___1);
#line 3518
    ResetIdle();
    }
#line 3519
    return;
  }
#line 3522
  if (display->d_blocked > 1) {
#line 3527
    flayer = (struct layer *)0;
#line 3528
    p = windows;
    {
#line 3528
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3528
      if (! p) {
#line 3528
        goto while_break___2;
      }
#line 3529
      if ((unsigned long )p->w_zdisplay == (unsigned long )display) {
#line 3531
        flayer = & p->w_layer;
#line 3532
        bufp = buf___0;
        {
#line 3533
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 3533
          if (! (size > 0)) {
#line 3533
            goto while_break___3;
          }
          {
#line 3534
          (*((flayer->l_layfn)->lf_LayProcess))(& bufp, & size);
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 3535
        return;
      }
#line 3528
      p = p->w_next;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 3537
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 3537
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 3538
    zmodem_abort((struct win *)0, display);
    }
  }
#line 3541
  if (idletimo > 0) {
    {
#line 3542
    ResetIdle();
    }
  }
#line 3543
  if (display->d_fore) {
#line 3544
    (display->d_fore)->w_lastdisp = display;
  }
#line 3545
  if (display->d_mouse) {
#line 3545
    if (display->d_forecv) {
#line 3547
      bp = (unsigned char *)(buf___0);
#line 3548
      i = size;
#line 3551
      i = size;
      {
#line 3551
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 3551
        if (! (i > 0)) {
#line 3551
          goto while_break___5;
        }
#line 3553
        if (i > 5) {
#line 3553
          if ((int )*(bp + 0) == 27) {
#line 3553
            if ((int )*(bp + 1) == 91) {
#line 3553
              if ((int )*(bp + 2) == 77) {
#line 3555
                bp ++;
#line 3556
                i --;
              } else {
#line 3553
                goto _L___1;
              }
            } else {
#line 3553
              goto _L___1;
            }
          } else {
#line 3553
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 3558
        if (i < 5) {
#line 3559
          goto __Cont;
        } else
#line 3558
        if ((int )*(bp + 0) != 155) {
#line 3559
          goto __Cont;
        } else
#line 3558
        if ((int )*(bp + 1) != 77) {
#line 3559
          goto __Cont;
        }
#line 3560
        x = (int )*(bp + 3) - 33;
#line 3561
        y = (int )*(bp + 4) - 33;
#line 3562
        if (x >= (display->d_forecv)->c_xs) {
#line 3562
          if (x <= (display->d_forecv)->c_xe) {
#line 3562
            if (y >= (display->d_forecv)->c_ys) {
#line 3562
              if (y <= (display->d_forecv)->c_ye) {
#line 3564
                x -= (display->d_forecv)->c_xoff;
#line 3565
                y -= (display->d_forecv)->c_yoff;
#line 3566
                if (x >= 0) {
#line 3566
                  if (x < ((display->d_forecv)->c_layer)->l_width) {
#line 3566
                    if (y >= 0) {
#line 3566
                      if (y < ((display->d_forecv)->c_layer)->l_height) {
#line 3568
                        *(bp + 3) = (unsigned char )(x + 33);
#line 3569
                        *(bp + 4) = (unsigned char )(y + 33);
#line 3570
                        i -= 4;
#line 3571
                        bp += 4;
#line 3572
                        goto __Cont;
                      }
                    }
                  }
                }
              }
            }
          }
        }
#line 3575
        if ((int )*(bp + 0) == 91) {
          {
#line 3577
          bcopy((void const   *)((char *)bp + 1), (void *)((char *)bp), (size_t )i);
#line 3578
          bp --;
#line 3579
          size --;
          }
        }
#line 3581
        if (i > 5) {
          {
#line 3582
          bcopy((void const   *)((char *)bp + 5), (void *)((char *)bp), (size_t )(i - 5));
          }
        }
#line 3583
        bp --;
#line 3584
        i -= 4;
#line 3585
        size -= 5;
        __Cont: /* CIL Label */ 
#line 3551
        i --;
#line 3551
        bp ++;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
  }
#line 3589
  if (display->d_forecv) {
#line 3589
    tmp___5 = ((display->d_forecv)->c_layer)->l_encoding;
  } else {
#line 3589
    tmp___5 = 0;
  }
#line 3589
  if (display->d_encoding != tmp___5) {
#line 3593
    if (display->d_forecv) {
#line 3593
      enc = ((display->d_forecv)->c_layer)->l_encoding;
    } else {
#line 3593
      enc = 0;
    }
#line 3594
    j = 0;
#line 3594
    i___0 = j;
    {
#line 3594
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 3594
      if (! (i___0 < size)) {
#line 3594
        goto while_break___6;
      }
      {
#line 3596
      c = (int )*((unsigned char *)(buf___0) + i___0);
#line 3597
      c = DecodeChar(c, display->d_encoding, & display->d_decodestate);
      }
#line 3598
      if (c == -2) {
#line 3599
        i___0 --;
      }
#line 3600
      if (c < 0) {
#line 3601
        goto __Cont___0;
      }
#line 3602
      if (pastefont) {
        {
#line 3604
        font = 0;
#line 3605
        tmp___2 = EncodeChar(buf2 + j, c, enc, & font);
#line 3605
        j += tmp___2;
#line 3606
        tmp___3 = EncodeChar(buf2 + j, -1, enc, & font);
#line 3606
        j += tmp___3;
        }
      } else {
        {
#line 3609
        tmp___4 = EncodeChar(buf2 + j, c, enc, (int *)0);
#line 3609
        j += tmp___4;
        }
      }
#line 3610
      if (j > (int )sizeof(buf2) - 10) {
#line 3611
        goto while_break___6;
      }
      __Cont___0: /* CIL Label */ 
#line 3594
      i___0 ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 3613
    (*(display->d_processinput))(buf2, j);
    }
#line 3614
    return;
  }
  {
#line 3617
  (*(display->d_processinput))(buf___0, size);
  }
#line 3618
  return;
}
}
#line 3620 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
static void disp_status_fn(struct event *ev , char *data ) 
{ 


  {
#line 3625
  display = (struct display *)data;
  {
#line 3626
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3626
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3627
  if (display->d_status) {
    {
#line 3628
    RemoveStatus();
    }
  }
#line 3629
  return;
}
}
#line 3631 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
static void disp_hstatus_fn(struct event *ev , char *data ) 
{ 


  {
#line 3636
  display = (struct display *)data;
#line 3637
  if (display->d_status == 2) {
    {
#line 3639
    SetTimeout(ev, 1);
#line 3640
    evenq(ev);
    }
#line 3641
    return;
  }
  {
#line 3643
  RefreshHStatus();
  }
#line 3644
  return;
}
}
#line 3646 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
static void disp_blocked_fn(struct event *ev , char *data ) 
{ 
  struct win *p ;
  int *tmp ;

  {
#line 3653
  display = (struct display *)data;
  {
#line 3654
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3654
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3655
  if (display->d_obufp - display->d_obuf > (long )(display->d_obufmax + display->d_blocked_fuzz)) {
    {
#line 3657
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3657
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3658
    display->d_blocked = 1;
#line 3660
    p = windows;
    {
#line 3660
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3660
      if (! p) {
#line 3660
        goto while_break___1;
      }
#line 3661
      if ((unsigned long )p->w_readev.condneg == (unsigned long )(& display->d_obuflenmax)) {
        {
#line 3663
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 3663
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 3664
        tmp = (int *)0;
#line 3664
        p->w_readev.condneg = tmp;
#line 3664
        p->w_readev.condpos = tmp;
      }
#line 3660
      p = p->w_next;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 3667
  return;
}
}
#line 3669 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
static void cv_winid_fn(struct event *ev , char *data ) 
{ 
  int ox ;
  int oy ;
  struct canvas *cv ;

  {
#line 3675
  cv = (struct canvas *)data;
#line 3677
  display = cv->c_display;
#line 3678
  if (display->d_status == 1) {
    {
#line 3680
    SetTimeout(ev, 1);
#line 3681
    evenq(ev);
    }
#line 3682
    return;
  }
#line 3684
  ox = display->d_x;
#line 3685
  oy = display->d_y;
#line 3686
  if (cv->c_ye + 1 < display->d_height) {
    {
#line 3687
    RefreshLine(cv->c_ye + 1, 0, display->d_width - 1, 0);
    }
  }
#line 3688
  if (ox != -1) {
#line 3688
    if (oy != -1) {
      {
#line 3689
      GotoPos(ox, oy);
      }
    }
  }
#line 3690
  return;
}
}
#line 3693 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
static void disp_map_fn(struct event *ev , char *data ) 
{ 
  char *p ;
  int l ;
  int i ;
  unsigned char *q ;
  int tmp ;

  {
#line 3701
  display = (struct display *)data;
  {
#line 3702
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3702
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3703
  l = display->d_seql;
#line 3703
  if (! l) {
#line 3704
    return;
  }
#line 3705
  p = (char *)display->d_seqp - l;
#line 3706
  display->d_seqp = display->d_kmaps + 3;
#line 3707
  display->d_seql = 0;
#line 3708
  q = display->d_seqh;
#line 3708
  if ((unsigned long )q != (unsigned long )((unsigned char *)0)) {
#line 3710
    display->d_seqh = (unsigned char *)0;
#line 3711
    i = ((int )*(q + 0) << 8) | (int )*(q + 1);
#line 3712
    i &= -16385;
    {
#line 3713
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3713
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3714
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3714
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 3715
    tmp = StuffKey(i);
    }
#line 3715
    if (tmp) {
      {
#line 3716
      ProcessInput2((char *)q + 3, (int )*(q + 2));
      }
    }
#line 3717
    if ((unsigned long )display == (unsigned long )((struct display *)0)) {
#line 3718
      return;
    }
#line 3719
    l -= (int )*(q + 2);
#line 3720
    p += (int )*(q + 2);
  } else {
#line 3723
    display->d_dontmap = 1;
  }
  {
#line 3724
  ProcessInput(p, l);
  }
#line 3725
  return;
}
}
#line 3728 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
static void disp_idle_fn(struct event *ev , char *data ) 
{ 
  struct display *olddisplay ;

  {
#line 3734
  display = (struct display *)data;
  {
#line 3735
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3735
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3736
  if (idletimo <= 0) {
#line 3737
    return;
  } else
#line 3736
  if (idleaction.nr == -1) {
#line 3737
    return;
  }
  {
#line 3738
  olddisplay = display;
#line 3739
  flayer = (display->d_forecv)->c_layer;
#line 3740
  fore = display->d_fore;
#line 3741
  DoAction(& idleaction, -1);
  }
#line 3742
  if (idleaction.nr == 19) {
#line 3743
    return;
  }
#line 3744
  display = displays;
  {
#line 3744
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3744
    if (! display) {
#line 3744
      goto while_break___0;
    }
#line 3745
    if ((unsigned long )olddisplay == (unsigned long )display) {
#line 3746
      goto while_break___0;
    }
#line 3744
    display = display->d_next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3747
  if (display) {
    {
#line 3748
    ResetIdle();
    }
  }
#line 3749
  return;
}
}
#line 3751 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void ResetIdle(void) 
{ 


  {
#line 3754
  if (idletimo > 0) {
    {
#line 3756
    SetTimeout(& display->d_idleev, idletimo);
    }
#line 3757
    if (! display->d_idleev.queued) {
      {
#line 3758
      evenq(& display->d_idleev);
      }
    }
  } else {
    {
#line 3761
    evdeq(& display->d_idleev);
    }
  }
#line 3762
  return;
}
}
#line 3767 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
static void disp_blanker_fn(struct event *ev , char *data ) 
{ 
  char buf___0[4096] ;
  char *b ;
  int size ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 3775
  display = (struct display *)data;
#line 3776
  size = read(display->d_blankerev.fd, (void *)(buf___0), (size_t )4096);
  }
#line 3777
  if (size <= 0) {
    {
#line 3779
    evdeq(& display->d_blankerev);
#line 3780
    close(display->d_blankerev.fd);
#line 3781
    display->d_blankerev.fd = -1;
    }
#line 3782
    return;
  }
#line 3784
  b = buf___0;
  {
#line 3784
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3784
    if (! size) {
#line 3784
      goto while_break;
    }
    {
#line 3785
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3785
      (display->d_obuffree) --;
#line 3785
      if (display->d_obuffree <= 0) {
        {
#line 3785
        Resize_obuf();
        }
      }
#line 3785
      tmp = display->d_obufp;
#line 3785
      (display->d_obufp) ++;
#line 3785
      tmp___0 = b;
#line 3785
      b ++;
#line 3785
      *tmp = *tmp___0;
#line 3785
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3784
    size --;
  }
  while_break: /* CIL Label */ ;
  }
#line 3786
  return;
}
}
#line 3788 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void KillBlanker(void) 
{ 
  int oldtop ;
  int oldbot ;
  struct mchar oldrend ;
  int tmp ;
  int tmp___0 ;

  {
#line 3791
  oldtop = display->d_top;
#line 3791
  oldbot = display->d_bot;
#line 3794
  if (display->d_blankerev.fd == -1) {
#line 3795
    return;
  }
#line 3796
  if (display->d_blocked == 4) {
#line 3797
    display->d_blocked = 0;
  }
  {
#line 3798
  evdeq(& display->d_blankerev);
#line 3799
  close(display->d_blankerev.fd);
#line 3800
  display->d_blankerev.fd = -1;
#line 3801
  Kill(display->d_blankerpid, 1);
#line 3802
  tmp = -1;
#line 3802
  display->d_bot = tmp;
#line 3802
  display->d_top = tmp;
#line 3803
  oldrend = display->d_rend;
  }
#line 3804
  if (display->d_tcs[55].str) {
    {
#line 3806
    AddCStr(display->d_tcs[55].str);
#line 3807
    AddCStr(display->d_tcs[55].str);
    }
  } else {
#line 3812
    if (display->d_hascolor) {
      {
#line 3813
      AddStr((char *)"\033[m\033[m");
      }
    }
    {
#line 3815
    AddCStr(display->d_tcs[54].str);
#line 3816
    AddCStr(display->d_tcs[53].str);
    }
  }
  {
#line 3818
  AddCStr(display->d_tcs[82].str);
#line 3819
  AddCStr(display->d_tcs[99].str);
#line 3820
  display->d_rend = mchar_null;
#line 3821
  display->d_atyp = (char)0;
#line 3822
  display->d_curvis = 0;
#line 3823
  tmp___0 = -1;
#line 3823
  display->d_y = tmp___0;
#line 3823
  display->d_x = tmp___0;
#line 3824
  ChangeScrollRegion(oldtop, oldbot);
#line 3825
  SetRendition(& oldrend);
#line 3826
  ClearAll();
  }
#line 3827
  return;
}
}
#line 3829 "/home/pronto/abs/test-suite/screen-4.0.2/display.c"
void RunBlanker(char **cmdv ) 
{ 
  char *m___0 ;
  int pid ;
  int slave ;
  char termname[30] ;
  char **np ;
  int tmp ;
  int *tmp___0 ;
  __pid_t tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  char **tmp___8 ;
  char **tmp___9 ;
  int *tmp___10 ;

  {
  {
#line 3835
  slave = -1;
#line 3842
  strcpy((char */* __restrict  */)(termname), (char const   */* __restrict  */)"TERM=");
#line 3843
  strncpy((char */* __restrict  */)(termname + 5), (char const   */* __restrict  */)(display->d_termname),
          (size_t )(sizeof(termname) - 6UL));
#line 3844
  termname[sizeof(termname) - 1UL] = (char)0;
#line 3845
  KillBlanker();
#line 3846
  display->d_blankerpid = -1;
#line 3847
  tmp = OpenPTY(& m___0);
#line 3847
  display->d_blankerev.fd = tmp;
  }
#line 3847
  if (tmp == -1) {
    {
#line 3849
    Msg(0, (char *)"OpenPty failed");
    }
#line 3850
    return;
  }
#line 3853
  if (pty_preopen) {
    {
#line 3855
    slave = open((char const   *)m___0, 258);
    }
#line 3855
    if (slave == -1) {
      {
#line 3857
      tmp___0 = __errno_location();
#line 3857
      Msg(*tmp___0, (char *)"%s", m___0);
#line 3858
      close(display->d_blankerev.fd);
#line 3859
      display->d_blankerev.fd = -1;
      }
#line 3860
      return;
    }
  }
  {
#line 3864
  tmp___1 = fork();
#line 3864
  pid = tmp___1;
  }
  {
#line 3866
  if (pid == -1) {
#line 3866
    goto case_neg_1;
  }
#line 3871
  if (pid == 0) {
#line 3871
    goto case_0;
  }
#line 3913
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 3867
  tmp___2 = __errno_location();
#line 3867
  Msg(*tmp___2, (char *)"fork");
#line 3868
  close(display->d_blankerev.fd);
#line 3869
  display->d_blankerev.fd = -1;
  }
#line 3870
  return;
  case_0: /* CIL Label */ 
  {
#line 3872
  displays = (struct display *)0;
#line 3877
  tmp___4 = setgid((__gid_t )real_gid);
  }
#line 3877
  if (tmp___4) {
    {
#line 3878
    tmp___3 = __errno_location();
#line 3878
    Panic(*tmp___3, (char *)"setuid/setgid");
    }
  } else {
    {
#line 3877
    tmp___5 = setuid((__uid_t )real_uid);
    }
#line 3877
    if (tmp___5) {
      {
#line 3878
      tmp___3 = __errno_location();
#line 3878
      Panic(*tmp___3, (char *)"setuid/setgid");
      }
    }
  }
  {
#line 3879
  brktty(display->d_userfd);
#line 3880
  freetty();
#line 3881
  close(0);
#line 3882
  close(1);
#line 3883
  close(2);
#line 3884
  closeallfiles(slave);
#line 3885
  tmp___7 = open((char const   *)m___0, 2);
  }
#line 3885
  if (tmp___7) {
    {
#line 3886
    tmp___6 = __errno_location();
#line 3886
    Panic(*tmp___6, (char *)"Cannot open %s", m___0);
    }
  }
  {
#line 3887
  dup(0);
#line 3888
  dup(0);
  }
#line 3889
  if (slave != -1) {
    {
#line 3890
    close(slave);
    }
  }
  {
#line 3891
  InitPTY(0);
#line 3892
  fgtty(0);
#line 3893
  SetTTY(0, & display->d_OldMode);
#line 3894
  np = NewEnv + 3;
#line 3895
  tmp___8 = np;
#line 3895
  np ++;
#line 3895
  *tmp___8 = *(NewEnv + 0);
#line 3896
  tmp___9 = np;
#line 3896
  np ++;
#line 3896
  *tmp___9 = termname;
#line 3898
  glwz.ws_col = (unsigned short )display->d_width;
#line 3899
  glwz.ws_row = (unsigned short )display->d_height;
#line 3900
  ioctl(0, 21524UL, (char *)(& glwz));
#line 3908
  xsignal(13, (void (*)(int  ))0);
#line 3910
  display = (struct display *)0;
#line 3911
  execvpe(*cmdv, cmdv, NewEnv + 3);
#line 3912
  tmp___10 = __errno_location();
#line 3912
  Panic(*tmp___10, *cmdv);
  }
  switch_default: /* CIL Label */ 
#line 3914
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 3916
  display->d_blankerpid = pid;
#line 3917
  evenq(& display->d_blankerev);
#line 3918
  display->d_blocked = 4;
#line 3919
  ClearAll();
  }
#line 3920
  return;
}
}
#line 184 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 154 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 648
extern long ftell(FILE *__stream ) ;
#line 256 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) access)(char const   *__name ,
                                                                                   int __type ) ;
#line 434
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chdir)(char const   *__path ) ;
#line 549
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 148 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 654
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
#line 675
extern  __attribute__((__nothrow__)) int unsetenv(char const   *__name ) ;
#line 102 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 299
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) bcmp)(void const   *__s1 ,
                                                                                   void const   *__s2 ,
                                                                                   size_t __n )  __attribute__((__pure__)) ;
#line 303
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) index)(char const   *__s ,
                                                                                    int __c )  __attribute__((__pure__)) ;
#line 307
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) rindex)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 262 "/home/pronto/abs/test-suite/screen-4.0.2/screen.h"
char strnomem[15] ;
#line 45 "/home/pronto/abs/test-suite/screen-4.0.2/extern.h"
void MakeNewEnv(void) ;
#line 46
char *MakeWinMsg(char *s , struct win *win , int esc ) ;
#line 50
void setbacktick(int num , int lifespan , int tick___0 , char **cmdv ) ;
#line 53
void ResetAnsiState(struct win *p ) ;
#line 55
void ResetCharsets(struct win *p ) ;
#line 56
void WriteString(struct win *wp , char *buf___0 , int len ) ;
#line 57
void ChangeAKA(struct win *p , char *s , int l ) ;
#line 59
int GetAnsiStatus(struct win *w , char *buf___0 ) ;
#line 61
void WBell(struct win *p , int visual ) ;
#line 70
void RcLine(char *ubuf , int ubufl ) ;
#line 73
void WriteFile(struct acluser *user , char *fn , int dump ) ;
#line 74
char *ReadFile(char *fn , int *lenp ) ;
#line 75
void KillBuffers(void) ;
#line 79
void do_source(char *rcfilename ) ;
#line 88
void SendBreak(struct win *wp , int n , int closeopen ) ;
#line 89
int TtyGrabConsole(int fd , int on , char *rc_name___0 ) ;
#line 90
char *TtyGetModemStatus(int fd , char *buf___0 ) ;
#line 102
int GetHistory(void) ;
#line 103
void MarkRoutine(void) ;
#line 106
int InMark(void) ;
#line 107
void MakePaster(struct paster *pa , char *buf___0 , int len , int bufiscopy ) ;
#line 116
void Input(char *istr , int len , int mode , void (*finfunc)(char *buf , int len ,
                                                             char *data ) , char *data ) ;
#line 117
int InInput(void) ;
#line 121
void display_help(char *class , struct action *ktabp ) ;
#line 122
void display_copyright(void) ;
#line 123
void display_displays(void) ;
#line 124
void display_bindkey(char *title , struct action *tab ) ;
#line 125
void display_wlist(int onblank , int order ) ;
#line 126
int InWList(void) ;
#line 128
void WListLinkChanged(void) ;
#line 134
int MakeWindow(struct NewWindow *newwin ) ;
#line 136
void FreeWindow(struct win *wp ) ;
#line 138
int winexec(char **av ) ;
#line 139
void FreePseudowin(struct win *w ) ;
#line 142
int DoStartLog(struct win *w , char *buf___0 , int bufsize ) ;
#line 143
int ReleaseAutoWritelock(struct display *dis , struct win *w ) ;
#line 144
int ObtainAutoWritelock(struct display *d , struct win *w ) ;
#line 156
int SetUtmp(struct win *wi ) ;
#line 157
int RemoveUtmp(struct win *wi ) ;
#line 159
void SlotToggle(int how ) ;
#line 181
void InitKeytab(void) ;
#line 186
void DoProcess(struct win *p , char **bufp , int *lenp , struct paster *pa ) ;
#line 189
void DoCommand(char **argv , int *argl ) ;
#line 191
void KillWindow(struct win *wi ) ;
#line 192
void SetForeWindow(struct win *wi ) ;
#line 193
int Parse(char *buf___0 , int bufl , char **args , int *argl ) ;
#line 194
void SetEscape(struct acluser *u , int e , int me ) ;
#line 195
void DoScreen(char *fn , char **av ) ;
#line 196
int IsNumColon(char *s , int base , char *p , int psize ) ;
#line 197
void ShowWindows(int where ) ;
#line 198
char *AddWindows(char *buf___0 , int len , int flags , int where ) ;
#line 199
char *AddWindowFlags(char *buf___0 , int len , struct win *p ) ;
#line 200
char *AddOtherUsers(char *buf___0 , int len , struct win *p ) ;
#line 202
struct win *FindNiceWindow(struct win *wi , char *presel ) ;
#line 204
int CompileKeys(char *s , int sl , unsigned char *array ) ;
#line 209
int ParseSaveStr(struct action *act , char **var ) ;
#line 210
int ParseNum(struct action *act , int *var ) ;
#line 211
int ParseSwitch(struct action *act , int *var ) ;
#line 212
int ParseAttrColor(char *s1 , char *s2 , int msgok ) ;
#line 214
void SwitchWindow(int n ) ;
#line 219
char *MakeTermcap(int aflag ) ;
#line 220
char *gettermcapstring(char *s ) ;
#line 222
int remap(int n , int map ) ;
#line 223
void CheckEscape(void) ;
#line 312
int ChangeWindowSize(struct win *p , int wi , int he , int hi ) ;
#line 315
char *xrealloc(char *mem , int len ) ;
#line 317
void ResizeLayer(struct layer *l , int wi , int he , struct display *norefdisp ) ;
#line 318
int MayResizeLayer(struct layer *l ) ;
#line 334
int chsock(void) ;
#line 341
char *SaveStrn(char const   *str , int n ) ;
#line 348
char *Filename(char *s ) ;
#line 369
int AddXChars(char *buf___0 , int len , char *str ) ;
#line 370
void xsetenv(char *var , char *value ) ;
#line 49 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
char *rc_name ;
#line 50
char *home ;
#line 51
char *BellString ;
#line 51
char *ActivityString ;
#line 51
char *ShellProg ;
#line 51
char *ShellArgs[2] ;
#line 52
char *timestring ;
#line 53
char *wliststr ;
#line 53
char *wlisttit ;
#line 55
char *hardcopydir ;
#line 55
char *screenlogfile ;
#line 55
char *logtstamp_string ;
#line 56
int log_flush ;
#line 56
int logtstamp_on ;
#line 56
int logtstamp_after ;
#line 57
char *VisualBellString ;
#line 58
int VBellWait ;
#line 58
int SilenceWait ;
#line 59
char *SockName ;
#line 60
int TtyMode ;
#line 60
int auto_detach ;
#line 60
int use_altscreen ;
#line 61
int iflag ;
#line 61
int maxwin ;
#line 62
int visual_bell ;
#line 68
char *printcmd ;
#line 69
int default_startup ;
#line 72
int ZombieKey_destroy ;
#line 73
int ZombieKey_resurrect ;
#line 77
int separate_sids ;
#line 78
struct NewWindow nwin_undef ;
#line 80
int join_with_cr ;
#line 81
int compacthist ;
#line 82
int search_ic ;
#line 86
unsigned char mark_key_tab[256] ;
#line 87
char *BufferFile ;
#line 90
char *PowDetachString ;
#line 95
struct term term[196] ;
#line 102
int VerboseCreate ;
#line 107
static int CheckArgNum(int nr , char **args ) ;
#line 108
static void ClearAction(struct action *act ) ;
#line 109
static void SaveAction(struct action *act , int nr , char **args , int *argl ) ;
#line 110
static int NextWindow(void) ;
#line 111
static int PreviousWindow(void) ;
#line 112
static int MoreWindows(void) ;
#line 113
static void LogToggle(int on ) ;
#line 114
static void ShowInfo(void) ;
#line 115
static void ShowDInfo(void) ;
#line 116
static struct win *WindowByName(char *s ) ;
#line 117
static int WindowByNumber(char *str ) ;
#line 118
static int ParseOnOff(struct action *act , int *var ) ;
#line 119
static int ParseWinNum(struct action *act , int *var ) ;
#line 120
static int ParseBase(struct action *act , char *p , int *var , int base , char *bname ) ;
#line 121
static int ParseNum1000(struct action *act , int *var ) ;
#line 122
static char **SaveArgs(char **args ) ;
#line 123
static int IsNum(char *s , int base ) ;
#line 124
static void Colonfin(char *buf___0 , int len , char *data ) ;
#line 125
static void InputSelect(void) ;
#line 126
static void InputSetenv(char *arg ) ;
#line 127
static void InputAKA(void) ;
#line 129
static int InputSu(struct win *w , struct acluser **up , char *name ) ;
#line 130
static void su_fin(char *buf___0 , int len , char *data ) ;
#line 132
static void AKAfin(char *buf___0 , int len , char *data ) ;
#line 134
static void copy_reg_fn(char *buf___0 , int len , char *data ) ;
#line 135
static void ins_reg_fn(char *buf___0 , int len , char *data ) ;
#line 137
static void process_fn(char *buf___0 , int len , char *data ) ;
#line 139
static void pass1(char *buf___0 , int len , char *data ) ;
#line 140
static void pass2(char *buf___0 , int len , char *data ) ;
#line 143
static void pow_detach_fn(char *buf___0 , int len , char *data ) ;
#line 145
static void digraph_fn(char *buf___0 , int len , char *data ) ;
#line 146
static void confirm_fn(char *buf___0 , int len , char *data ) ;
#line 147
static int IsOnDisplay(struct win *wi ) ;
#line 148
static void ResizeRegions(char *arg ) ;
#line 149
static void ResizeFin(char *buf___0 , int len , char *data ) ;
#line 150
static struct action *FindKtab(char *class , int create ) ;
#line 155
struct win *console_window ;
#line 158
char screenterm[20] ;
#line 158
char HostName[256] ;
#line 158
char version[40] ;
#line 170 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
struct win *wtab[40]  ;
#line 173
char *multi ;
#line 176 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
char NullStr[1]  = {      (char )'\000'};
#line 178 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
struct plop plop_tab[256]  ;
#line 184 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
int TtyMode  =    400;
#line 185 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
int hardcopy_append  =    0;
#line 186 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
int all_norefresh  =    0;
#line 188 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
int zmodem_mode  =    0;
#line 189 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
char *zmodem_sendcmd  ;
#line 190 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
char *zmodem_recvcmd  ;
#line 191 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static char *zmodes[4]  = {      (char *)"off",      (char *)"auto",      (char *)"catch",      (char *)"pass"};
#line 194 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
int idletimo  ;
#line 195 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
struct action idleaction  ;
#line 197 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
char **blankerprg  ;
#line 200 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
struct action ktab[256]  ;
#line 206 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
struct kclass *kclasses  ;
#line 209 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
struct action umtab[99]  ;
#line 210 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
struct action dmtab[99]  ;
#line 211 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
struct action mmtab[99]  ;
#line 212 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
struct kmap_ext *kmap_exts  ;
#line 213 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
int kmap_extn  ;
#line 214 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static int maptimeout  =    300;
#line 219 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static unsigned char const   digraphs[171][3]  = 
#line 219
  { {        (unsigned char const   )' ',        (unsigned char const   )' ',        (unsigned char const   )160}, 
   {        (unsigned char const   )'N',        (unsigned char const   )'S',        (unsigned char const   )160}, 
   {        (unsigned char const   )'~',        (unsigned char const   )'!',        (unsigned char const   )161}, 
   {        (unsigned char const   )'!',        (unsigned char const   )'!',        (unsigned char const   )161}, 
   {        (unsigned char const   )'!',        (unsigned char const   )'I',        (unsigned char const   )161}, 
   {        (unsigned char const   )'c',        (unsigned char const   )'|',        (unsigned char const   )162}, 
   {        (unsigned char const   )'c',        (unsigned char const   )'t',        (unsigned char const   )162}, 
   {        (unsigned char const   )'$',        (unsigned char const   )'$',        (unsigned char const   )163}, 
   {        (unsigned char const   )'P',        (unsigned char const   )'d',        (unsigned char const   )163}, 
   {        (unsigned char const   )'o',        (unsigned char const   )'x',        (unsigned char const   )164}, 
   {        (unsigned char const   )'C',        (unsigned char const   )'u',        (unsigned char const   )164}, 
   {        (unsigned char const   )'C',        (unsigned char const   )'u',        (unsigned char const   )164}, 
   {        (unsigned char const   )'E',        (unsigned char const   )'u',        (unsigned char const   )164}, 
   {        (unsigned char const   )'Y',        (unsigned char const   )'-',        (unsigned char const   )165}, 
   {        (unsigned char const   )'Y',        (unsigned char const   )'e',        (unsigned char const   )165}, 
   {        (unsigned char const   )'|',        (unsigned char const   )'|',        (unsigned char const   )166}, 
   {        (unsigned char const   )'B',        (unsigned char const   )'B',        (unsigned char const   )166}, 
   {        (unsigned char const   )'p',        (unsigned char const   )'a',        (unsigned char const   )167}, 
   {        (unsigned char const   )'S',        (unsigned char const   )'E',        (unsigned char const   )167}, 
   {        (unsigned char const   )'\"',        (unsigned char const   )'\"',        (unsigned char const   )168}, 
   {        (unsigned char const   )'\'',        (unsigned char const   )':',        (unsigned char const   )168}, 
   {        (unsigned char const   )'c',        (unsigned char const   )'O',        (unsigned char const   )169}, 
   {        (unsigned char const   )'C',        (unsigned char const   )'o',        (unsigned char const   )169}, 
   {        (unsigned char const   )'a',        (unsigned char const   )'-',        (unsigned char const   )170}, 
   {        (unsigned char const   )'<',        (unsigned char const   )'<',        (unsigned char const   )171}, 
   {        (unsigned char const   )'-',        (unsigned char const   )',',        (unsigned char const   )172}, 
   {        (unsigned char const   )'N',        (unsigned char const   )'O',        (unsigned char const   )172}, 
   {        (unsigned char const   )'-',        (unsigned char const   )'-',        (unsigned char const   )173}, 
   {        (unsigned char const   )'r',        (unsigned char const   )'O',        (unsigned char const   )174}, 
   {        (unsigned char const   )'R',        (unsigned char const   )'g',        (unsigned char const   )174}, 
   {        (unsigned char const   )'-',        (unsigned char const   )'=',        (unsigned char const   )175}, 
   {        (unsigned char const   )'\'',        (unsigned char const   )'m',        (unsigned char const   )175}, 
   {        (unsigned char const   )'~',        (unsigned char const   )'o',        (unsigned char const   )176}, 
   {        (unsigned char const   )'D',        (unsigned char const   )'G',        (unsigned char const   )176}, 
   {        (unsigned char const   )'+',        (unsigned char const   )'-',        (unsigned char const   )177}, 
   {        (unsigned char const   )'2',        (unsigned char const   )'2',        (unsigned char const   )178}, 
   {        (unsigned char const   )'2',        (unsigned char const   )'S',        (unsigned char const   )178}, 
   {        (unsigned char const   )'3',        (unsigned char const   )'3',        (unsigned char const   )179}, 
   {        (unsigned char const   )'3',        (unsigned char const   )'S',        (unsigned char const   )179}, 
   {        (unsigned char const   )'\'',        (unsigned char const   )'\'',        (unsigned char const   )180}, 
   {        (unsigned char const   )'j',        (unsigned char const   )'u',        (unsigned char const   )181}, 
   {        (unsigned char const   )'M',        (unsigned char const   )'y',        (unsigned char const   )181}, 
   {        (unsigned char const   )'p',        (unsigned char const   )'p',        (unsigned char const   )182}, 
   {        (unsigned char const   )'P',        (unsigned char const   )'I',        (unsigned char const   )182}, 
   {        (unsigned char const   )'~',        (unsigned char const   )'.',        (unsigned char const   )183}, 
   {        (unsigned char const   )'.',        (unsigned char const   )'M',        (unsigned char const   )183}, 
   {        (unsigned char const   )',',        (unsigned char const   )',',        (unsigned char const   )184}, 
   {        (unsigned char const   )'\'',        (unsigned char const   )',',        (unsigned char const   )184}, 
   {        (unsigned char const   )'1',        (unsigned char const   )'1',        (unsigned char const   )185}, 
   {        (unsigned char const   )'1',        (unsigned char const   )'S',        (unsigned char const   )185}, 
   {        (unsigned char const   )'o',        (unsigned char const   )'-',        (unsigned char const   )186}, 
   {        (unsigned char const   )'>',        (unsigned char const   )'>',        (unsigned char const   )187}, 
   {        (unsigned char const   )'1',        (unsigned char const   )'4',        (unsigned char const   )188}, 
   {        (unsigned char const   )'1',        (unsigned char const   )'2',        (unsigned char const   )189}, 
   {        (unsigned char const   )'3',        (unsigned char const   )'4',        (unsigned char const   )190}, 
   {        (unsigned char const   )'~',        (unsigned char const   )'?',        (unsigned char const   )191}, 
   {        (unsigned char const   )'?',        (unsigned char const   )'?',        (unsigned char const   )191}, 
   {        (unsigned char const   )'?',        (unsigned char const   )'I',        (unsigned char const   )191}, 
   {        (unsigned char const   )'A',        (unsigned char const   )'`',        (unsigned char const   )192}, 
   {        (unsigned char const   )'A',        (unsigned char const   )'!',        (unsigned char const   )192}, 
   {        (unsigned char const   )'A',        (unsigned char const   )'\'',        (unsigned char const   )193}, 
   {        (unsigned char const   )'A',        (unsigned char const   )'^',        (unsigned char const   )194}, 
   {        (unsigned char const   )'A',        (unsigned char const   )'>',        (unsigned char const   )194}, 
   {        (unsigned char const   )'A',        (unsigned char const   )'~',        (unsigned char const   )195}, 
   {        (unsigned char const   )'A',        (unsigned char const   )'?',        (unsigned char const   )195}, 
   {        (unsigned char const   )'A',        (unsigned char const   )'\"',        (unsigned char const   )196}, 
   {        (unsigned char const   )'A',        (unsigned char const   )':',        (unsigned char const   )196}, 
   {        (unsigned char const   )'A',        (unsigned char const   )'@',        (unsigned char const   )197}, 
   {        (unsigned char const   )'A',        (unsigned char const   )'A',        (unsigned char const   )197}, 
   {        (unsigned char const   )'A',        (unsigned char const   )'E',        (unsigned char const   )198}, 
   {        (unsigned char const   )'C',        (unsigned char const   )',',        (unsigned char const   )199}, 
   {        (unsigned char const   )'E',        (unsigned char const   )'`',        (unsigned char const   )200}, 
   {        (unsigned char const   )'E',        (unsigned char const   )'!',        (unsigned char const   )200}, 
   {        (unsigned char const   )'E',        (unsigned char const   )'\'',        (unsigned char const   )201}, 
   {        (unsigned char const   )'E',        (unsigned char const   )'^',        (unsigned char const   )202}, 
   {        (unsigned char const   )'E',        (unsigned char const   )'>',        (unsigned char const   )202}, 
   {        (unsigned char const   )'E',        (unsigned char const   )'\"',        (unsigned char const   )203}, 
   {        (unsigned char const   )'E',        (unsigned char const   )':',        (unsigned char const   )203}, 
   {        (unsigned char const   )'I',        (unsigned char const   )'`',        (unsigned char const   )204}, 
   {        (unsigned char const   )'I',        (unsigned char const   )'!',        (unsigned char const   )204}, 
   {        (unsigned char const   )'I',        (unsigned char const   )'\'',        (unsigned char const   )205}, 
   {        (unsigned char const   )'I',        (unsigned char const   )'^',        (unsigned char const   )206}, 
   {        (unsigned char const   )'I',        (unsigned char const   )'>',        (unsigned char const   )206}, 
   {        (unsigned char const   )'I',        (unsigned char const   )'\"',        (unsigned char const   )207}, 
   {        (unsigned char const   )'I',        (unsigned char const   )':',        (unsigned char const   )207}, 
   {        (unsigned char const   )'D',        (unsigned char const   )'-',        (unsigned char const   )208}, 
   {        (unsigned char const   )'N',        (unsigned char const   )'~',        (unsigned char const   )209}, 
   {        (unsigned char const   )'N',        (unsigned char const   )'?',        (unsigned char const   )209}, 
   {        (unsigned char const   )'O',        (unsigned char const   )'`',        (unsigned char const   )210}, 
   {        (unsigned char const   )'O',        (unsigned char const   )'!',        (unsigned char const   )210}, 
   {        (unsigned char const   )'O',        (unsigned char const   )'\'',        (unsigned char const   )211}, 
   {        (unsigned char const   )'O',        (unsigned char const   )'^',        (unsigned char const   )212}, 
   {        (unsigned char const   )'O',        (unsigned char const   )'>',        (unsigned char const   )212}, 
   {        (unsigned char const   )'O',        (unsigned char const   )'~',        (unsigned char const   )213}, 
   {        (unsigned char const   )'O',        (unsigned char const   )'?',        (unsigned char const   )213}, 
   {        (unsigned char const   )'O',        (unsigned char const   )'\"',        (unsigned char const   )214}, 
   {        (unsigned char const   )'O',        (unsigned char const   )':',        (unsigned char const   )214}, 
   {        (unsigned char const   )'/',        (unsigned char const   )'\\',        (unsigned char const   )215}, 
   {        (unsigned char const   )'*',        (unsigned char const   )'x',        (unsigned char const   )215}, 
   {        (unsigned char const   )'O',        (unsigned char const   )'/',        (unsigned char const   )216}, 
   {        (unsigned char const   )'U',        (unsigned char const   )'`',        (unsigned char const   )217}, 
   {        (unsigned char const   )'U',        (unsigned char const   )'!',        (unsigned char const   )217}, 
   {        (unsigned char const   )'U',        (unsigned char const   )'\'',        (unsigned char const   )218}, 
   {        (unsigned char const   )'U',        (unsigned char const   )'^',        (unsigned char const   )219}, 
   {        (unsigned char const   )'U',        (unsigned char const   )'>',        (unsigned char const   )219}, 
   {        (unsigned char const   )'U',        (unsigned char const   )'\"',        (unsigned char const   )220}, 
   {        (unsigned char const   )'U',        (unsigned char const   )':',        (unsigned char const   )220}, 
   {        (unsigned char const   )'Y',        (unsigned char const   )'\'',        (unsigned char const   )221}, 
   {        (unsigned char const   )'I',        (unsigned char const   )'p',        (unsigned char const   )222}, 
   {        (unsigned char const   )'T',        (unsigned char const   )'H',        (unsigned char const   )222}, 
   {        (unsigned char const   )'s',        (unsigned char const   )'s',        (unsigned char const   )223}, 
   {        (unsigned char const   )'s',        (unsigned char const   )'\"',        (unsigned char const   )223}, 
   {        (unsigned char const   )'a',        (unsigned char const   )'`',        (unsigned char const   )224}, 
   {        (unsigned char const   )'a',        (unsigned char const   )'!',        (unsigned char const   )224}, 
   {        (unsigned char const   )'a',        (unsigned char const   )'\'',        (unsigned char const   )225}, 
   {        (unsigned char const   )'a',        (unsigned char const   )'^',        (unsigned char const   )226}, 
   {        (unsigned char const   )'a',        (unsigned char const   )'>',        (unsigned char const   )226}, 
   {        (unsigned char const   )'a',        (unsigned char const   )'~',        (unsigned char const   )227}, 
   {        (unsigned char const   )'a',        (unsigned char const   )'?',        (unsigned char const   )227}, 
   {        (unsigned char const   )'a',        (unsigned char const   )'\"',        (unsigned char const   )228}, 
   {        (unsigned char const   )'a',        (unsigned char const   )':',        (unsigned char const   )228}, 
   {        (unsigned char const   )'a',        (unsigned char const   )'a',        (unsigned char const   )229}, 
   {        (unsigned char const   )'a',        (unsigned char const   )'e',        (unsigned char const   )230}, 
   {        (unsigned char const   )'c',        (unsigned char const   )',',        (unsigned char const   )231}, 
   {        (unsigned char const   )'e',        (unsigned char const   )'`',        (unsigned char const   )232}, 
   {        (unsigned char const   )'e',        (unsigned char const   )'!',        (unsigned char const   )232}, 
   {        (unsigned char const   )'e',        (unsigned char const   )'\'',        (unsigned char const   )233}, 
   {        (unsigned char const   )'e',        (unsigned char const   )'^',        (unsigned char const   )234}, 
   {        (unsigned char const   )'e',        (unsigned char const   )'>',        (unsigned char const   )234}, 
   {        (unsigned char const   )'e',        (unsigned char const   )'\"',        (unsigned char const   )235}, 
   {        (unsigned char const   )'e',        (unsigned char const   )':',        (unsigned char const   )235}, 
   {        (unsigned char const   )'i',        (unsigned char const   )'`',        (unsigned char const   )236}, 
   {        (unsigned char const   )'i',        (unsigned char const   )'!',        (unsigned char const   )236}, 
   {        (unsigned char const   )'i',        (unsigned char const   )'\'',        (unsigned char const   )237}, 
   {        (unsigned char const   )'i',        (unsigned char const   )'^',        (unsigned char const   )238}, 
   {        (unsigned char const   )'i',        (unsigned char const   )'>',        (unsigned char const   )238}, 
   {        (unsigned char const   )'i',        (unsigned char const   )'\"',        (unsigned char const   )239}, 
   {        (unsigned char const   )'i',        (unsigned char const   )':',        (unsigned char const   )239}, 
   {        (unsigned char const   )'d',        (unsigned char const   )'-',        (unsigned char const   )240}, 
   {        (unsigned char const   )'n',        (unsigned char const   )'~',        (unsigned char const   )241}, 
   {        (unsigned char const   )'n',        (unsigned char const   )'?',        (unsigned char const   )241}, 
   {        (unsigned char const   )'o',        (unsigned char const   )'`',        (unsigned char const   )242}, 
   {        (unsigned char const   )'o',        (unsigned char const   )'!',        (unsigned char const   )242}, 
   {        (unsigned char const   )'o',        (unsigned char const   )'\'',        (unsigned char const   )243}, 
   {        (unsigned char const   )'o',        (unsigned char const   )'^',        (unsigned char const   )244}, 
   {        (unsigned char const   )'o',        (unsigned char const   )'>',        (unsigned char const   )244}, 
   {        (unsigned char const   )'o',        (unsigned char const   )'~',        (unsigned char const   )245}, 
   {        (unsigned char const   )'o',        (unsigned char const   )'?',        (unsigned char const   )245}, 
   {        (unsigned char const   )'o',        (unsigned char const   )'\"',        (unsigned char const   )246}, 
   {        (unsigned char const   )'o',        (unsigned char const   )':',        (unsigned char const   )246}, 
   {        (unsigned char const   )':',        (unsigned char const   )'-',        (unsigned char const   )247}, 
   {        (unsigned char const   )'o',        (unsigned char const   )'/',        (unsigned char const   )248}, 
   {        (unsigned char const   )'u',        (unsigned char const   )'`',        (unsigned char const   )249}, 
   {        (unsigned char const   )'u',        (unsigned char const   )'!',        (unsigned char const   )249}, 
   {        (unsigned char const   )'u',        (unsigned char const   )'\'',        (unsigned char const   )250}, 
   {        (unsigned char const   )'u',        (unsigned char const   )'^',        (unsigned char const   )251}, 
   {        (unsigned char const   )'u',        (unsigned char const   )'>',        (unsigned char const   )251}, 
   {        (unsigned char const   )'u',        (unsigned char const   )'\"',        (unsigned char const   )252}, 
   {        (unsigned char const   )'u',        (unsigned char const   )':',        (unsigned char const   )252}, 
   {        (unsigned char const   )'y',        (unsigned char const   )'\'',        (unsigned char const   )253}, 
   {        (unsigned char const   )'i',        (unsigned char const   )'p',        (unsigned char const   )254}, 
   {        (unsigned char const   )'t',        (unsigned char const   )'h',        (unsigned char const   )254}, 
   {        (unsigned char const   )'y',        (unsigned char const   )'\"',        (unsigned char const   )255}, 
   {        (unsigned char const   )'y',        (unsigned char const   )':',        (unsigned char const   )255}, 
   {        (unsigned char const   )'\"',        (unsigned char const   )'[',        (unsigned char const   )196}, 
   {        (unsigned char const   )'\"',        (unsigned char const   )'\\',        (unsigned char const   )214}, 
   {        (unsigned char const   )'\"',        (unsigned char const   )']',        (unsigned char const   )220}, 
   {        (unsigned char const   )'\"',        (unsigned char const   )'{',        (unsigned char const   )228}, 
   {        (unsigned char const   )'\"',        (unsigned char const   )'|',        (unsigned char const   )246}, 
   {        (unsigned char const   )'\"',        (unsigned char const   )'}',        (unsigned char const   )252}, 
   {        (unsigned char const   )'\"',        (unsigned char const   )'~',        (unsigned char const   )223}};
#line 394 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
char *noargs[1]  ;
#line 396 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
void InitKeytab(void) 
{ 
  register unsigned int i ;
  char *argarr[2] ;
  char *args[2] ;
  char *args___0[2] ;
  char arg1[10] ;
  char *args___1[2] ;
  char *args___2[2] ;

  {
#line 404
  i = 0U;
  {
#line 404
  while (1) {
    while_continue: /* CIL Label */ ;
#line 404
    if (! ((unsigned long )i < sizeof(ktab) / sizeof(ktab[0]))) {
#line 404
      goto while_break;
    }
#line 406
    ktab[i].nr = -1;
#line 407
    ktab[i].args = noargs;
#line 408
    ktab[i].argl = (int *)0;
#line 404
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 411
  i = 0U;
  {
#line 411
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 411
    if (! (i < 99U)) {
#line 411
      goto while_break___0;
    }
#line 413
    umtab[i].nr = -1;
#line 414
    umtab[i].args = noargs;
#line 415
    umtab[i].argl = (int *)0;
#line 416
    dmtab[i].nr = -1;
#line 417
    dmtab[i].args = noargs;
#line 418
    dmtab[i].argl = (int *)0;
#line 419
    mmtab[i].nr = -1;
#line 420
    mmtab[i].args = noargs;
#line 421
    mmtab[i].argl = (int *)0;
#line 411
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 423
  argarr[1] = (char *)0;
#line 424
  i = 0U;
  {
#line 424
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 424
    if (! (i < 77U)) {
#line 424
      goto while_break___1;
    }
#line 426
    if (i + 106U < 106U) {
#line 427
      goto __Cont;
    }
#line 428
    if (i + 106U >= 183U) {
#line 429
      goto __Cont;
    }
#line 430
    if ((unsigned long )kmapdef[i] == (unsigned long )((char *)0)) {
#line 431
      goto __Cont;
    }
    {
#line 432
    argarr[0] = kmapdef[i];
#line 433
    SaveAction((dmtab + i) + 0, 147, argarr, (int *)0);
    }
    __Cont: /* CIL Label */ 
#line 424
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 435
  i = 0U;
  {
#line 435
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 435
    if (! (i < 22U)) {
#line 435
      goto while_break___2;
    }
#line 437
    if (i + 161U < 161U) {
#line 438
      goto __Cont___0;
    }
#line 439
    if (i + 161U >= 183U) {
#line 440
      goto __Cont___0;
    }
#line 441
    if ((unsigned long )kmapadef[i] == (unsigned long )((char *)0)) {
#line 442
      goto __Cont___0;
    }
    {
#line 443
    argarr[0] = kmapadef[i];
#line 444
    SaveAction((dmtab + i) + 77, 147, argarr, (int *)0);
    }
    __Cont___0: /* CIL Label */ 
#line 435
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 446
  i = 0U;
  {
#line 446
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 446
    if (! (i < 27U)) {
#line 446
      goto while_break___3;
    }
#line 448
    if (i + 138U < 106U) {
#line 449
      goto __Cont___1;
    }
#line 450
    if (i + 138U >= 183U) {
#line 451
      goto __Cont___1;
    }
#line 452
    if ((unsigned long )kmapmdef[i] == (unsigned long )((char *)0)) {
#line 453
      goto __Cont___1;
    }
    {
#line 454
    argarr[0] = kmapmdef[i];
#line 455
    argarr[1] = (char *)0;
#line 456
    SaveAction((mmtab + i) + 32, 147, argarr, (int *)0);
    }
    __Cont___1: /* CIL Label */ 
#line 446
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 460
  ktab['h'].nr = 75;
#line 462
  ktab[26].nr = 149;
#line 462
  ktab['z'].nr = ktab[26].nr;
#line 464
  ktab[3].nr = 131;
#line 464
  ktab['c'].nr = ktab[3].nr;
#line 465
  ktab[14].nr = 106;
#line 465
  ktab['n'].nr = ktab[14].nr;
#line 465
  ktab[0].nr = ktab['n'].nr;
#line 465
  ktab[' '].nr = ktab[0].nr;
#line 467
  ktab['N'].nr = 108;
#line 468
  ktab[16].nr = 119;
#line 468
  ktab['p'].nr = ktab[16].nr;
#line 468
  ktab[127].nr = ktab['p'].nr;
#line 468
  ktab[8].nr = ktab[127].nr;
#line 469
  ktab[11].nr = 87;
#line 469
  ktab['k'].nr = ktab[11].nr;
#line 470
  ktab[12].nr = 125;
#line 470
  ktab['l'].nr = ktab[12].nr;
#line 471
  ktab[23].nr = 167;
#line 471
  ktab['w'].nr = ktab[23].nr;
#line 472
  ktab['v'].nr = 163;
#line 473
  ktab[22].nr = 62;
#line 474
  ktab[17].nr = 172;
#line 474
  ktab['q'].nr = ktab[17].nr;
#line 475
  ktab[19].nr = 171;
#line 475
  ktab['s'].nr = ktab[19].nr;
#line 476
  ktab[20].nr = 154;
#line 476
  ktab['t'].nr = ktab[20].nr;
#line 477
  ktab[9].nr = 85;
#line 477
  ktab['i'].nr = ktab[9].nr;
#line 478
  ktab[13].nr = 88;
#line 478
  ktab['m'].nr = ktab[13].nr;
#line 479
  ktab['A'].nr = 155;
#line 481
  ktab['L'].nr = 93;
#line 483
  ktab[','].nr = 89;
#line 484
  ktab['W'].nr = 165;
#line 485
  ktab['.'].nr = 65;
#line 486
  ktab[28].nr = 122;
#line 488
  ktab[4].nr = 61;
#line 488
  ktab['d'].nr = ktab[4].nr;
#line 490
  ktab['D'].nr = 117;
#line 493
  ktab[18].nr = 168;
#line 493
  ktab['r'].nr = ktab[18].nr;
#line 494
  ktab[6].nr = 72;
#line 494
  ktab['f'].nr = ktab[6].nr;
#line 495
  ktab['C'].nr = 29;
#line 496
  ktab['Z'].nr = 129;
#line 497
  ktab['H'].nr = 91;
#line 498
  ktab['M'].nr = 101;
#line 499
  ktab['?'].nr = 80;
#line 501
  ktab['*'].nr = 64;
#line 505
  args[0] = (char *)"-";
#line 506
  args[1] = (char *)((void *)0);
#line 507
  SaveAction(ktab + 45, 133, args, (int *)0);
#line 509
  i = 0U;
  }
  {
#line 509
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 509
    if (! (i < 10U)) {
#line 509
      goto while_break___4;
    }
    {
#line 512
    args___0[0] = arg1;
#line 513
    args___0[1] = (char *)0;
#line 514
    sprintf((char */* __restrict  */)(arg1), (char const   */* __restrict  */)"%d",
            i);
#line 515
    SaveAction((ktab + 48) + i, 133, args___0, (int *)0);
#line 509
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 517
  ktab['\''].nr = 133;
#line 520
  args___1[0] = (char *)"-b";
#line 521
  args___1[1] = (char *)0;
#line 522
  SaveAction(ktab + 34, 166, args___1, (int *)0);
#line 524
  ktab[7].nr = 159;
#line 525
  ktab[':'].nr = 30;
#line 527
  ktab[27].nr = 34;
#line 527
  ktab['['].nr = ktab[27].nr;
#line 530
  args___2[0] = (char *)".";
#line 531
  args___2[1] = (char *)0;
#line 532
  SaveAction(ktab + 93, 114, args___2, (int *)0);
#line 533
  SaveAction(ktab + 29, 114, args___2, (int *)0);
#line 535
  ktab['{'].nr = 81;
#line 536
  ktab['}'].nr = 81;
#line 537
  ktab['>'].nr = 169;
#line 538
  ktab['<'].nr = 123;
#line 539
  ktab['='].nr = 128;
#line 542
  ktab['D'].nr = 117;
#line 545
  ktab[24].nr = 90;
#line 545
  ktab['x'].nr = ktab[24].nr;
#line 547
  ktab[2].nr = 21;
#line 547
  ktab['b'].nr = ktab[2].nr;
#line 548
  ktab['B'].nr = 116;
#line 549
  ktab['_'].nr = 139;
#line 550
  ktab['S'].nr = 145;
#line 551
  ktab['Q'].nr = 110;
#line 552
  ktab['X'].nr = 127;
#line 553
  ktab['F'].nr = 71;
#line 554
  ktab['\t'].nr = 73;
  }
#line 556
  if (DefaultEsc >= 0) {
    {
#line 558
    ClearAction(& ktab[DefaultEsc]);
#line 559
    ktab[DefaultEsc].nr = 111;
    }
  }
#line 561
  if (DefaultMetaEsc >= 0) {
    {
#line 563
    ClearAction(& ktab[DefaultMetaEsc]);
#line 564
    ktab[DefaultMetaEsc].nr = 100;
    }
  }
#line 567
  idleaction.nr = 19;
#line 568
  idleaction.args = noargs;
#line 569
  idleaction.argl = (int *)0;
#line 570
  return;
}
}
#line 572 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static struct action *FindKtab(char *class , int create ) 
{ 
  struct kclass *kp ;
  struct kclass **kpp ;
  int i ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 580
  if ((unsigned long )class == (unsigned long )((char *)0)) {
#line 581
    return (ktab);
  }
#line 582
  kpp = & kclasses;
  {
#line 582
  while (1) {
    while_continue: /* CIL Label */ ;
#line 582
    kp = *kpp;
#line 582
    if (! ((unsigned long )kp != (unsigned long )((struct kclass *)0))) {
#line 582
      goto while_break;
    }
    {
#line 583
    tmp = strcmp((char const   *)kp->name, (char const   *)class);
    }
#line 583
    if (! tmp) {
#line 584
      goto while_break;
    }
#line 582
    kpp = & kp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 585
  if ((unsigned long )kp == (unsigned long )((struct kclass *)0)) {
#line 587
    if (! create) {
#line 588
      return ((struct action *)0);
    }
    {
#line 589
    tmp___0 = strlen((char const   *)class);
    }
#line 589
    if (tmp___0 > 80U) {
      {
#line 591
      Msg(0, (char *)"Command class name too long.");
      }
#line 592
      return ((struct action *)0);
    }
    {
#line 594
    tmp___1 = malloc((size_t )sizeof(*kp));
#line 594
    kp = (struct kclass *)tmp___1;
    }
#line 595
    if ((unsigned long )kp == (unsigned long )((struct kclass *)0)) {
      {
#line 597
      Msg(0, strnomem);
      }
#line 598
      return ((struct action *)0);
    }
    {
#line 600
    kp->name = SaveStr((char const   *)class);
#line 601
    i = 0;
    }
    {
#line 601
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 601
      if (! (i < (int )(sizeof(kp->ktab) / sizeof(kp->ktab[0])))) {
#line 601
        goto while_break___0;
      }
#line 603
      kp->ktab[i].nr = -1;
#line 604
      kp->ktab[i].args = noargs;
#line 601
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 606
    kp->next = (struct kclass *)0;
#line 607
    *kpp = kp;
  }
#line 609
  return (kp->ktab);
}
}
#line 612 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static void ClearAction(struct action *act ) 
{ 
  char **p ;

  {
#line 618
  if (act->nr == -1) {
#line 619
    return;
  }
#line 620
  act->nr = -1;
#line 621
  if ((unsigned long )act->args == (unsigned long )(noargs)) {
#line 622
    return;
  }
#line 623
  p = act->args;
  {
#line 623
  while (1) {
    while_continue: /* CIL Label */ ;
#line 623
    if (! *p) {
#line 623
      goto while_break;
    }
    {
#line 624
    free((void *)*p);
#line 623
    p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 625
  free((void *)((char *)act->args));
#line 626
  act->args = noargs;
#line 627
  act->argl = (int *)0;
  }
#line 628
  return;
}
}
#line 642 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
void ProcessInput(char *ibuf , int ilen ) 
{ 
  int ch ;
  int slen ;
  unsigned char *s ;
  unsigned char *q ;
  int i ;
  int l ;
  char *p ;
  unsigned char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 652
  while (1) {
    while_continue: /* CIL Label */ ;
#line 652
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 653
  if ((unsigned long )display == (unsigned long )((struct display *)0)) {
#line 654
    return;
  } else
#line 653
  if (ilen == 0) {
#line 654
    return;
  }
#line 655
  if (display->d_seql) {
    {
#line 656
    evdeq(& display->d_mapev);
    }
  }
#line 657
  slen = ilen;
#line 658
  s = (unsigned char *)ibuf;
  {
#line 659
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 659
    tmp___4 = ilen;
#line 659
    ilen --;
#line 659
    if (! (tmp___4 > 0)) {
#line 659
      goto while_break___0;
    }
#line 661
    tmp = s;
#line 661
    s ++;
#line 661
    ch = (int )*tmp;
#line 662
    if (display->d_dontmap) {
#line 664
      display->d_dontmap = 0;
#line 665
      goto while_continue___0;
    } else
#line 662
    if (! display->d_nseqs) {
#line 664
      display->d_dontmap = 0;
#line 665
      goto while_continue___0;
    }
    {
#line 667
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 669
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 669
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 670
      if ((int )*(display->d_seqp) != ch) {
#line 672
        l = (int )*(display->d_seqp + ((int )*(display->d_seqp + (- display->d_seql - 1)) + 1));
#line 673
        if (l) {
#line 675
          display->d_seqp += l * 2 + 4;
          {
#line 676
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 676
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 677
          goto __Cont;
        }
        {
#line 679
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 679
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 680
        display->d_mapdefault = 0;
#line 681
        l = display->d_seql;
#line 682
        p = (char *)display->d_seqp - l;
#line 683
        display->d_seql = 0;
#line 684
        display->d_seqp = display->d_kmaps + 3;
#line 685
        if (l == 0) {
#line 686
          goto while_break___1;
        }
#line 687
        q = display->d_seqh;
#line 687
        if ((unsigned long )q != (unsigned long )((unsigned char *)0)) {
#line 689
          display->d_seqh = (unsigned char *)0;
#line 690
          i = ((int )*(q + 0) << 8) | (int )*(q + 1);
#line 691
          i &= -16385;
          {
#line 692
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 692
            goto while_break___5;
          }
          while_break___5: /* CIL Label */ ;
          }
          {
#line 693
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 693
            goto while_break___6;
          }
          while_break___6: /* CIL Label */ ;
          }
          {
#line 694
          tmp___0 = StuffKey(i);
          }
#line 694
          if (tmp___0) {
            {
#line 695
            ProcessInput2((char *)q + 3, (int )*(q + 2));
            }
          }
#line 696
          if ((unsigned long )display == (unsigned long )((struct display *)0)) {
#line 697
            return;
          }
#line 698
          l -= (int )*(q + 2);
#line 699
          p += (int )*(q + 2);
        } else {
#line 702
          display->d_dontmap = 1;
        }
        {
#line 703
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 703
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 704
        ProcessInput(p, l);
        }
#line 705
        if ((unsigned long )display == (unsigned long )((struct display *)0)) {
#line 706
          return;
        }
        {
#line 707
        evdeq(& display->d_mapev);
        }
#line 708
        goto __Cont;
      }
#line 710
      tmp___1 = display->d_seql;
#line 710
      (display->d_seql) ++;
#line 710
      if (tmp___1 == 0) {
#line 713
        slen -= ilen + 1;
        {
#line 714
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 714
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 715
        if (slen) {
          {
#line 716
          ProcessInput2(ibuf, slen);
          }
        }
#line 717
        if ((unsigned long )display == (unsigned long )((struct display *)0)) {
#line 718
          return;
        }
#line 719
        display->d_seqh = (unsigned char *)0;
      }
#line 721
      ibuf = (char *)s;
#line 722
      slen = ilen;
#line 723
      (display->d_seqp) ++;
#line 724
      l = display->d_seql;
      {
#line 725
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 725
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 726
      if (l == (int )*(display->d_seqp + (- l - 1))) {
#line 728
        if ((int )*(display->d_seqp + l) != l) {
#line 730
          q = (display->d_seqp + 1) + l;
#line 731
          if ((unsigned long )(display->d_kmaps + display->d_nseqs) > (unsigned long )q) {
#line 731
            if ((int )*(q + 2) > l) {
              {
#line 731
              tmp___2 = bcmp((void const   *)(display->d_seqp - l), (void const   *)(q + 3),
                             (size_t )l);
              }
#line 731
              if (! tmp___2) {
                {
#line 733
                while (1) {
                  while_continue___10: /* CIL Label */ ;
#line 733
                  goto while_break___10;
                }
                while_break___10: /* CIL Label */ ;
                }
#line 734
                display->d_seqh = (display->d_seqp - 3) - l;
#line 735
                display->d_seqp = (q + 3) + l;
#line 736
                goto while_break___1;
              }
            }
          }
        }
#line 739
        i = ((int )*(display->d_seqp + (- l - 3)) << 8) | (int )*(display->d_seqp + (- l - 2));
#line 740
        i &= -16385;
        {
#line 741
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 741
          goto while_break___11;
        }
        while_break___11: /* CIL Label */ ;
        }
#line 742
        p = (char *)display->d_seqp - l;
        {
#line 743
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 743
          goto while_break___12;
        }
        while_break___12: /* CIL Label */ ;
        }
        {
#line 744
        display->d_seql = 0;
#line 745
        display->d_seqp = display->d_kmaps + 3;
#line 746
        display->d_seqh = (unsigned char *)0;
#line 747
        tmp___3 = StuffKey(i);
        }
#line 747
        if (tmp___3) {
          {
#line 748
          ProcessInput2(p, l);
          }
        }
#line 749
        if ((unsigned long )display == (unsigned long )((struct display *)0)) {
#line 750
          return;
        }
      }
#line 752
      goto while_break___1;
      __Cont: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 755
  if (display->d_seql) {
    {
#line 757
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 757
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 758
    l = display->d_seql;
#line 759
    s = display->d_seqp;
    {
#line 759
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 761
      if ((int )*(s + (- l - 3)) & (16384 >> 8)) {
#line 762
        goto while_break___14;
      }
#line 763
      i = (int )*(s + ((int )*(s + (- l - 1)) + 1));
#line 763
      if (i == 0) {
        {
#line 765
        SetTimeout(& display->d_mapev, maptimeout);
#line 766
        evenq(& display->d_mapev);
        }
#line 767
        goto while_break___14;
      }
#line 759
      s += i * 2 + 4;
    }
    while_break___14: /* CIL Label */ ;
    }
  }
  {
#line 771
  ProcessInput2(ibuf, slen);
  }
#line 772
  return;
}
}
#line 783 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
void ProcessInput2(char *ibuf , int ilen ) 
{ 
  char *s ;
  int ch ;
  int slen ;
  struct action *ktabp ;
  char *tmp ;

  {
  {
#line 792
  while (1) {
    while_continue: /* CIL Label */ ;
#line 792
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 793
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 793
    if (ilen) {
#line 793
      if (! display) {
#line 793
        goto while_break___0;
      }
    } else {
#line 793
      goto while_break___0;
    }
    {
#line 795
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 795
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 796
    flayer = (display->d_forecv)->c_layer;
#line 797
    fore = display->d_fore;
#line 798
    slen = ilen;
#line 799
    s = ibuf;
#line 800
    if (! display->d_ESCseen) {
      {
#line 802
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 802
        if (! (ilen > 0)) {
#line 802
          goto while_break___2;
        }
#line 804
        tmp = s;
#line 804
        s ++;
#line 804
        if ((int )((unsigned char )*tmp) == (display->d_user)->u_Esc) {
#line 805
          goto while_break___2;
        }
#line 806
        ilen --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 808
      slen -= ilen;
#line 809
      if (slen) {
        {
#line 810
        DoProcess(fore, & ibuf, & slen, (struct paster *)0);
        }
      }
#line 811
      ilen --;
#line 811
      if (ilen == 0) {
#line 812
        display->d_ESCseen = ktab;
      }
    }
#line 814
    if (ilen <= 0) {
#line 815
      return;
    }
#line 816
    if (display->d_ESCseen) {
#line 816
      ktabp = display->d_ESCseen;
    } else {
#line 816
      ktabp = ktab;
    }
#line 817
    display->d_ESCseen = (struct action *)0;
#line 818
    ch = (int )((unsigned char )*s);
#line 826
    if (ch == (display->d_user)->u_Esc) {
#line 827
      ch = DefaultEsc;
    } else
#line 828
    if (ch == (display->d_user)->u_MetaEsc) {
#line 829
      ch = DefaultMetaEsc;
    }
#line 831
    if (ch >= 0) {
      {
#line 832
      DoAction(ktabp + ch, ch);
      }
    }
#line 833
    ibuf = s + 1;
#line 834
    ilen --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 836
  return;
}
}
#line 838 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
void DoProcess(struct win *p , char **bufp , int *lenp , struct paster *pa ) 
{ 
  int oldlen ;
  struct display *d ;

  {
#line 846
  d = display;
#line 850
  if (pa) {
#line 850
    if (*lenp > 1) {
#line 850
      if (p) {
#line 850
        if (p->w_slowpaste) {
          {
#line 853
          SetTimeout(& p->w_paster.pa_slowev, p->w_slowpaste);
#line 854
          evenq(& p->w_paster.pa_slowev);
          }
#line 855
          return;
        }
      }
    }
  }
  {
#line 858
  while (1) {
    while_continue: /* CIL Label */ ;
#line 858
    if (flayer) {
#line 858
      if (! *lenp) {
#line 858
        goto while_break;
      }
    } else {
#line 858
      goto while_break;
    }
#line 861
    if (! pa) {
#line 861
      if (p) {
#line 861
        if (p->w_paster.pa_pastelen) {
#line 861
          if ((unsigned long )flayer == (unsigned long )p->w_paster.pa_pastelayer) {
            {
#line 863
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 863
              goto while_break___0;
            }
            while_break___0: /* CIL Label */ ;
            }
            {
#line 864
            WBell(p, visual_bell);
#line 865
            *bufp += *lenp;
#line 866
            *lenp = 0;
#line 867
            display = d;
            }
#line 868
            return;
          }
        }
      }
    }
    {
#line 871
    oldlen = *lenp;
#line 872
    (*((flayer->l_layfn)->lf_LayProcess))(bufp, lenp);
    }
#line 874
    if (pa) {
#line 874
      if (! pa->pa_pastelayer) {
#line 875
        goto while_break;
      }
    }
#line 877
    if (*lenp == oldlen) {
#line 879
      if (pa) {
#line 881
        display = d;
#line 882
        return;
      }
      {
#line 885
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 885
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 886
      WBell(p, visual_bell);
      }
#line 887
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 890
  *bufp += *lenp;
#line 891
  *lenp = 0;
#line 892
  display = d;
#line 894
  if (pa) {
#line 894
    if (pa->pa_pastelen == 0) {
      {
#line 895
      FreePaster(pa);
      }
    }
  }
#line 897
  return;
}
}
#line 899 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
int FindCommnr(char *str ) 
{ 
  int x ;
  int m___0 ;
  int l ;
  int r ;

  {
#line 903
  l = 0;
#line 903
  r = 174;
  {
#line 904
  while (1) {
    while_continue: /* CIL Label */ ;
#line 904
    if (! (l <= r)) {
#line 904
      goto while_break;
    }
    {
#line 906
    m___0 = (l + r) / 2;
#line 907
    x = strcmp((char const   *)str, (char const   *)comms[m___0].name);
    }
#line 908
    if (x > 0) {
#line 909
      l = m___0 + 1;
    } else
#line 910
    if (x < 0) {
#line 911
      r = m___0 - 1;
    } else {
#line 913
      return (m___0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 915
  return (-1);
}
}
#line 924 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static char *argss[6]  = {      (char *)"no",      (char *)"one",      (char *)"two",      (char *)"three", 
        (char *)"four",      (char *)"OOPS"};
#line 925 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static char *orformat[4]  = {      (char *)"%s: %s: %s argument%s required",      (char *)"%s: %s: %s or %s argument%s required",      (char *)"%s: %s: %s, %s or %s argument%s required",      (char *)"%s: %s: %s, %s, %s or %s argument%s required"};
#line 918 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static int CheckArgNum(int nr , char **args ) 
{ 
  int i ;
  int n ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 933
  n = comms[nr].flags & 3;
#line 934
  i = 0;
  {
#line 934
  while (1) {
    while_continue: /* CIL Label */ ;
#line 934
    if (! *(args + i)) {
#line 934
      goto while_break;
    }
#line 934
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 936
  if (comms[nr].flags & (1 << 5)) {
#line 938
    if (i < n) {
#line 940
      if (n != 1) {
#line 940
        tmp = "s";
      } else {
#line 940
        tmp = "";
      }
      {
#line 940
      Msg(0, (char *)"%s: %s: at least %s argument%s required", rc_name, comms[nr].name,
          argss[n], tmp);
      }
#line 942
      return (-1);
    }
  } else
#line 945
  if (comms[nr].flags & (1 << 2)) {
#line 945
    if (comms[nr].flags & (1 << 3)) {
#line 945
      if (comms[nr].flags & (1 << 4)) {
#line 949
        if (i != n) {
#line 949
          if (i != n + 1) {
#line 949
            if (i != n + 2) {
#line 949
              if (i != n + 3) {
                {
#line 951
                Msg(0, orformat[3], rc_name, comms[nr].name, argss[n], argss[n + 1],
                    argss[n + 2], argss[n + 3], "");
                }
#line 953
                return (-1);
              }
            }
          }
        }
      } else {
#line 945
        goto _L___3;
      }
    } else {
#line 945
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 956
  if (comms[nr].flags & (1 << 2)) {
#line 956
    if (comms[nr].flags & (1 << 3)) {
#line 959
      if (i != n) {
#line 959
        if (i != n + 1) {
#line 959
          if (i != n + 2) {
            {
#line 961
            Msg(0, orformat[2], rc_name, comms[nr].name, argss[n], argss[n + 1], argss[n + 2],
                "");
            }
#line 963
            return (-1);
          }
        }
      }
    } else {
#line 956
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 966
  if (comms[nr].flags & (1 << 2)) {
#line 966
    if (comms[nr].flags & (1 << 4)) {
#line 969
      if (i != n) {
#line 969
        if (i != n + 1) {
#line 969
          if (i != n + 3) {
            {
#line 971
            Msg(0, orformat[2], rc_name, comms[nr].name, argss[n], argss[n + 1], argss[n + 3],
                "");
            }
#line 973
            return (-1);
          }
        }
      }
    } else {
#line 966
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 976
  if (comms[nr].flags & (1 << 3)) {
#line 976
    if (comms[nr].flags & (1 << 4)) {
#line 979
      if (i != n) {
#line 979
        if (i != n + 2) {
#line 979
          if (i != n + 3) {
            {
#line 981
            Msg(0, orformat[2], rc_name, comms[nr].name, argss[n], argss[n + 2], argss[n + 3],
                "");
            }
#line 983
            return (-1);
          }
        }
      }
    } else {
#line 976
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 986
  if (comms[nr].flags & (1 << 2)) {
#line 988
    if (i != n) {
#line 988
      if (i != n + 1) {
#line 990
        if (n != 0) {
#line 990
          tmp___0 = "s";
        } else {
#line 990
          tmp___0 = "";
        }
        {
#line 990
        Msg(0, orformat[1], rc_name, comms[nr].name, argss[n], argss[n + 1], tmp___0);
        }
#line 992
        return (-1);
      }
    }
  } else
#line 995
  if (comms[nr].flags & (1 << 3)) {
#line 997
    if (i != n) {
#line 997
      if (i != n + 2) {
        {
#line 999
        Msg(0, orformat[1], rc_name, comms[nr].name, argss[n], argss[n + 2], "s");
        }
#line 1001
        return (-1);
      }
    }
  } else
#line 1004
  if (comms[nr].flags & (1 << 4)) {
#line 1006
    if (i != n) {
#line 1006
      if (i != n + 3) {
        {
#line 1008
        Msg(0, orformat[1], rc_name, comms[nr].name, argss[n], argss[n + 3], "");
        }
#line 1010
        return (-1);
      }
    }
  } else
#line 1013
  if (i != n) {
#line 1015
    if (n != 1) {
#line 1015
      tmp___1 = "s";
    } else {
#line 1015
      tmp___1 = "";
    }
    {
#line 1015
    Msg(0, orformat[0], rc_name, comms[nr].name, argss[n], tmp___1);
    }
#line 1016
    return (-1);
  }
#line 1018
  return (i);
}
}
#line 1218 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static char buf[2]  ;
#line 1716 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static char *types[4]  = {      (char *)"TIOCSBRK",      (char *)"TCSBRK",      (char *)"tcsendbreak",      (char *)((void *)0)};
#line 1717
int breaktype ;
#line 2092 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static char *pasteargs[2]  = {      (char *)".",      (char *)0};
#line 2093 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static int pasteargl[1]  = {      1};
#line 1022 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
void DoAction(struct action *act , int key ) 
{ 
  int nr ;
  char **args ;
  int *argl ;
  struct win *p ;
  int argc ;
  int i ;
  int n ;
  int msgok ;
  char *s ;
  char ch ;
  struct display *odisplay ;
  struct acluser *user ;
  struct acluser *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int mode ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *name ;
  char const   *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  struct display *olddisplay ;
  size_t tmp___21 ;
  struct display *nd ;
  struct acluser *u ;
  int tmp___22 ;
  char const   *tmp___23 ;
  struct display *nd___0 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  char const   *tmp___29 ;
  struct win *nw ;
  int ch___0 ;
  int tmp___30 ;
  char const   *tmp___31 ;
  char const   *tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  struct plop *pp ;
  int tmp___35 ;
  int tmp___36 ;
  struct plop *plp ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  size_t tmp___40 ;
  char *tmp___41 ;
  struct action *ktabp ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int w ;
  int h ;
  int what ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  size_t tmp___52 ;
  size_t tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  char const   *tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  char const   *tmp___62 ;
  char const   *tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  struct action *ktabp___0 ;
  int tmp___73 ;
  int tmp___74 ;
  char *ss ;
  char *dbuf ;
  char dch ;
  int l ;
  int enc ;
  int tmp___75 ;
  int tmp___76 ;
  char *tmp___77 ;
  int tmp___78 ;
  void *tmp___79 ;
  struct plop *pp___0 ;
  struct plop *tmp___80 ;
  int tmp___81 ;
  struct plop *pp___1 ;
  struct plop oldplop ;
  int enc___0 ;
  int l___0 ;
  char *newbuf ;
  void *tmp___82 ;
  int tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;
  char *tmp___86 ;
  char const   *tmp___87 ;
  int *tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  char const   *tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  char const   *tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  int tmp___98 ;
  int tmp___99 ;
  int tmp___100 ;
  size_t tmp___101 ;
  int tmp___102 ;
  int tmp___103 ;
  int tmp___104 ;
  char buf___0[256] ;
  int tmp___105 ;
  char buf___1[256] ;
  int tmp___106 ;
  int tmp___107 ;
  int tmp___108 ;
  int tmp___109 ;
  int tmp___110 ;
  int tmp___111 ;
  int tmp___112 ;
  char const   *tmp___113 ;
  int tmp___114 ;
  struct display *olddisplay___0 ;
  int old_use ;
  int new_use ;
  int tmp___115 ;
  char buf___2[256] ;
  int tmp___116 ;
  int tmp___117 ;
  int tmp___118 ;
  int tmp___119 ;
  int tmp___120 ;
  int tmp___121 ;
  int tmp___122 ;
  char const   *tmp___123 ;
  struct display *olddisplay___1 ;
  char buf___3[256] ;
  int tmp___124 ;
  int tmp___125 ;
  int tmp___126 ;
  int tmp___127 ;
  int tmp___128 ;
  int tmp___129 ;
  char const   *tmp___130 ;
  int tmp___131 ;
  int tmp___132 ;
  int tmp___133 ;
  int tmp___134 ;
  int tmp___135 ;
  int old ;
  int tmp___136 ;
  int tmp___137 ;
  int tmp___138 ;
  char buf___4[4096] ;
  int tmp___139 ;
  size_t tmp___140 ;
  char *tmp___141 ;
  __pid_t tmp___142 ;
  int tmp___143 ;
  int *tmp___144 ;
  int *tmp___145 ;
  int tmp___146 ;
  char const   *tmp___147 ;
  char const   *tmp___148 ;
  int tmp___149 ;
  int tmp___150 ;
  char const   *tmp___151 ;
  int tmp___152 ;
  char const   *tmp___153 ;
  int tmp___154 ;
  char buf___5[256] ;
  int tmp___155 ;
  int tmp___156 ;
  char *tmp___157 ;
  struct action *ktabp___1 ;
  int tmp___158 ;
  int tmp___159 ;
  struct action *newact ;
  int newnr ;
  int fl ;
  int kf ;
  int af ;
  int df ;
  int mf ;
  struct display *odisp ;
  int used ;
  struct kmap_ext *kme ;
  int tmp___160 ;
  int tmp___161 ;
  int tmp___162 ;
  int tmp___163 ;
  int tmp___164 ;
  int tmp___165 ;
  int tmp___166 ;
  char *tmp___167 ;
  int tmp___168 ;
  int tmp___169 ;
  char **tmp___170 ;
  char **tmp___171 ;
  struct action *tmp___172 ;
  int tmp___173 ;
  struct action *tmp___174 ;
  int tmp___175 ;
  int tmp___176 ;
  int tmp___177 ;
  int tmp___178 ;
  int tmp___179 ;
  struct acluser *u___0 ;
  struct aclusergroup *g ;
  struct acluser **tmp___180 ;
  int tmp___181 ;
  char buf___6[256] ;
  char *p___0 ;
  int ngroups ;
  struct acluser *u___1 ;
  struct aclusergroup *g___0 ;
  struct acluser **tmp___182 ;
  size_t tmp___183 ;
  char const   *tmp___184 ;
  char const   *tmp___185 ;
  char *err ;
  struct acluser *tmp___186 ;
  int tmp___187 ;
  char **tmp___188 ;
  int tmp___189 ;
  char const   *tmp___190 ;
  int tmp___191 ;
  int tmp___192 ;
  int tmp___193 ;
  int tmp___194 ;
  char const   *tmp___195 ;
  int tmp___196 ;
  char const   *tmp___197 ;
  int tmp___198 ;
  char const   *tmp___199 ;
  int tmp___200 ;
  char const   *tmp___201 ;
  int tmp___202 ;
  int tmp___203 ;
  int tmp___204 ;
  int tmp___205 ;
  char const   *tmp___206 ;
  int tmp___207 ;
  int tmp___208 ;
  int tmp___209 ;
  int tmp___210 ;
  char const   *tmp___211 ;
  size_t tmp___212 ;
  char buf___7[256] ;
  char buf___8[256] ;
  size_t tmp___213 ;
  struct canvas *cv ;
  struct canvas *cv___0 ;
  int tmp___214 ;
  int tmp___215 ;
  int tmp___216 ;
  int tmp___217 ;
  struct win *tmp___218 ;
  struct display *olddisplay___2 ;
  struct layer *oldflayer ;
  struct layer *l___1 ;
  struct canvas *cvlist ;
  struct canvas *cvlnext ;
  char *ss___0 ;
  char *tmp___219 ;
  size_t tmp___220 ;
  char const   *tmp___221 ;
  int tmp___222 ;
  int tmp___223 ;
  int lifespan ;
  int tick___0 ;
  int tmp___224 ;
  int tmp___225 ;
  char **tmp___226 ;
  char **pp___2 ;
  struct display *olddisplay___3 ;
  int tmp___227 ;
  int tmp___228 ;
  int tmp___229 ;

  {
#line 1027
  nr = act->nr;
#line 1028
  args = act->args;
#line 1029
  argl = act->argl;
#line 1034
  odisplay = display;
#line 1037
  if (display) {
#line 1037
    user = display->d_user;
  } else {
#line 1037
    user = users;
  }
#line 1038
  if (nr == -1) {
    {
#line 1040
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1040
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1041
    return;
  }
#line 1043
  n = comms[nr].flags;
#line 1044
  if (n & (1 << 7)) {
#line 1044
    if ((unsigned long )display == (unsigned long )((struct display *)0)) {
      {
#line 1046
      Msg(0, (char *)"%s: %s: display required", rc_name, comms[nr].name);
      }
#line 1047
      return;
    }
  }
#line 1049
  if (n & (1 << 6)) {
#line 1049
    if ((unsigned long )fore == (unsigned long )((struct win *)0)) {
      {
#line 1051
      Msg(0, (char *)"%s: %s: window required", rc_name, comms[nr].name);
      }
#line 1052
      return;
    }
  }
#line 1054
  if (n & (1 << 8)) {
#line 1054
    if ((unsigned long )flayer == (unsigned long )((struct layer *)0)) {
      {
#line 1056
      Msg(0, (char *)"%s: %s: display or window required", rc_name, comms[nr].name);
      }
#line 1057
      return;
    }
  }
  {
#line 1059
  argc = CheckArgNum(nr, args);
  }
#line 1059
  if (argc < 0) {
#line 1060
    return;
  }
#line 1062
  if (display) {
    {
#line 1064
    tmp___0 = AclCheckPermCmd(display->d_user, 0, & comms[nr]);
    }
#line 1064
    if (tmp___0) {
#line 1066
      if (EffectiveAclUser) {
#line 1066
        tmp = EffectiveAclUser;
      } else {
#line 1066
        tmp = display->d_user;
      }
      {
#line 1066
      Msg(0, (char *)"%s: %s: permission denied (user %s)", rc_name, comms[nr].name,
          tmp->u_name);
      }
#line 1068
      return;
    }
  }
#line 1073
  if (display) {
#line 1073
    if (! *rc_name) {
#line 1073
      tmp___1 = 1;
    } else {
#line 1073
      tmp___1 = 0;
    }
  } else {
#line 1073
    tmp___1 = 0;
  }
#line 1073
  msgok = tmp___1;
  {
#line 1076
  if (nr == 133) {
#line 1076
    goto case_133;
  }
#line 1098
  if (nr == 37) {
#line 1098
    goto case_37;
  }
#line 1104
  if (nr == 12) {
#line 1104
    goto case_12;
  }
#line 1109
  if (nr == 53) {
#line 1109
    goto case_53;
  }
#line 1118
  if (nr == 109) {
#line 1118
    goto case_109;
  }
#line 1125
  if (nr == 65) {
#line 1125
    goto case_65;
  }
#line 1128
  if (nr == 75) {
#line 1128
    goto case_75;
  }
#line 1149
  if (nr == 48) {
#line 1149
    goto case_48;
  }
#line 1152
  if (nr == 91) {
#line 1152
    goto case_91;
  }
#line 1158
  if (nr == 149) {
#line 1158
    goto case_149;
  }
#line 1162
  if (nr == 106) {
#line 1162
    goto case_106;
  }
#line 1166
  if (nr == 119) {
#line 1166
    goto case_119;
  }
#line 1170
  if (nr == 87) {
#line 1170
    goto case_87;
  }
#line 1199
  if (nr == 122) {
#line 1199
    goto case_122;
  }
#line 1208
  if (nr == 61) {
#line 1208
    goto case_61;
  }
#line 1215
  if (nr == 117) {
#line 1215
    goto case_117;
  }
#line 1228
  if (nr == 36) {
#line 1228
    goto case_36;
  }
#line 1257
  if (nr == 173) {
#line 1257
    goto case_173;
  }
#line 1298
  if (nr == 174) {
#line 1298
    goto case_174;
  }
#line 1314
  if (nr == 164) {
#line 1314
    goto case_164;
  }
#line 1327
  if (nr == 9) {
#line 1327
    goto case_9;
  }
#line 1485
  if (nr == 124) {
#line 1485
    goto case_124;
  }
#line 1548
  if (nr == 126) {
#line 1548
    goto case_126;
  }
#line 1602
  if (nr == 121) {
#line 1602
    goto case_121;
  }
#line 1616
  if (nr == 147) {
#line 1616
    goto case_147;
  }
#line 1647
  if (nr == 125) {
#line 1647
    goto case_125;
  }
#line 1650
  if (nr == 167) {
#line 1650
    goto case_167;
  }
#line 1653
  if (nr == 163) {
#line 1653
    goto case_163;
  }
#line 1656
  if (nr == 154) {
#line 1656
    goto case_154;
  }
#line 1664
  if (nr == 85) {
#line 1664
    goto case_85;
  }
#line 1667
  if (nr == 63) {
#line 1667
    goto case_63;
  }
#line 1670
  if (nr == 31) {
#line 1670
    goto case_31;
  }
#line 1689
  if (nr == 111) {
#line 1689
    goto case_111;
  }
#line 1693
  if (nr == 100) {
#line 1693
    goto case_100;
  }
#line 1701
  if (nr == 172) {
#line 1701
    goto case_172;
  }
#line 1707
  if (nr == 171) {
#line 1707
    goto case_171;
  }
#line 1714
  if (nr == 22) {
#line 1714
    goto case_22;
  }
#line 1714
  if (nr == 39) {
#line 1714
    goto case_22;
  }
#line 1748
  if (nr == 21) {
#line 1748
    goto case_21;
  }
#line 1748
  if (nr == 116) {
#line 1748
    goto case_21;
  }
#line 1755
  if (nr == 90) {
#line 1755
    goto case_90;
  }
#line 1760
  if (nr == 79) {
#line 1760
    goto case_79;
  }
#line 1760
  if (nr == 165) {
#line 1760
    goto case_79;
  }
#line 1887
  if (nr == 155) {
#line 1887
    goto case_155;
  }
#line 1893
  if (nr == 30) {
#line 1893
    goto case_30;
  }
#line 1902
  if (nr == 88) {
#line 1902
    goto case_88;
  }
#line 1906
  if (nr == 131) {
#line 1906
    goto case_131;
  }
#line 1909
  if (nr == 168) {
#line 1909
    goto case_168;
  }
#line 1913
  if (nr == 72) {
#line 1913
    goto case_72;
  }
#line 1942
  if (nr == 60) {
#line 1942
    goto case_60;
  }
#line 1952
  if (nr == 170) {
#line 1952
    goto case_170;
  }
#line 1976
  if (nr == 29) {
#line 1976
    goto case_29;
  }
#line 1980
  if (nr == 129) {
#line 1980
    goto case_129;
  }
#line 1988
  if (nr == 101) {
#line 1988
    goto case_101;
  }
#line 2024
  if (nr == 64) {
#line 2024
    goto case_64;
  }
#line 2028
  if (nr == 166) {
#line 2028
    goto case_166;
  }
#line 2064
  if (nr == 80) {
#line 2064
    goto case_80;
  }
#line 2078
  if (nr == 89) {
#line 2078
    goto case_89;
  }
#line 2082
  if (nr == 34) {
#line 2082
    goto case_34;
  }
#line 2090
  if (nr == 81) {
#line 2090
    goto case_81;
  }
#line 2108
  if (nr == 114) {
#line 2108
    goto case_114;
  }
#line 2251
  if (nr == 169) {
#line 2251
    goto case_169;
  }
#line 2300
  if (nr == 123) {
#line 2300
    goto case_123;
  }
#line 2330
  if (nr == 128) {
#line 2330
    goto case_128;
  }
#line 2333
  if (nr == 84) {
#line 2333
    goto case_84;
  }
#line 2339
  if (nr == 68) {
#line 2339
    goto case_68;
  }
#line 2355
  if (nr == 43) {
#line 2355
    goto case_43;
  }
#line 2369
  if (nr == 28) {
#line 2369
    goto case_28;
  }
#line 2375
  if (nr == 55) {
#line 2375
    goto case_55;
  }
#line 2375
  if (nr == 137) {
#line 2375
    goto case_55;
  }
#line 2379
  if (nr == 77) {
#line 2379
    goto case_77;
  }
#line 2385
  if (nr == 92) {
#line 2385
    goto case_92;
  }
#line 2400
  if (nr == 94) {
#line 2400
    goto case_94;
  }
#line 2430
  if (nr == 138) {
#line 2430
    goto case_138;
  }
#line 2435
  if (nr == 153) {
#line 2435
    goto case_153;
  }
#line 2435
  if (nr == 152) {
#line 2435
    goto case_153;
  }
#line 2435
  if (nr == 151) {
#line 2435
    goto case_153;
  }
#line 2439
  if (nr == 141) {
#line 2439
    goto case_141;
  }
#line 2441
  if (nr == 150) {
#line 2441
    goto case_150;
  }
#line 2457
  if (nr == 66) {
#line 2457
    goto case_66;
  }
#line 2484
  if (nr == 16) {
#line 2484
    goto case_16;
  }
#line 2484
  if (nr == 15) {
#line 2484
    goto case_16;
  }
#line 2495
  if (nr == 23) {
#line 2495
    goto case_23;
  }
#line 2504
  if (nr == 5) {
#line 2504
    goto case_5;
  }
#line 2508
  if (nr == 118) {
#line 2508
    goto case_118;
  }
#line 2520
  if (nr == 93) {
#line 2520
    goto case_93;
  }
#line 2539
  if (nr == 49) {
#line 2539
    goto case_49;
  }
#line 2548
  if (nr == 44) {
#line 2548
    goto case_44;
  }
#line 2570
  if (nr == 59) {
#line 2570
    goto case_59;
  }
#line 2573
  if (nr == 40) {
#line 2573
    goto case_40;
  }
#line 2577
  if (nr == 38) {
#line 2577
    goto case_38;
  }
#line 2581
  if (nr == 45) {
#line 2581
    goto case_45;
  }
#line 2584
  if (nr == 51) {
#line 2584
    goto case_51;
  }
#line 2588
  if (nr == 56) {
#line 2588
    goto case_56;
  }
#line 2592
  if (nr == 162) {
#line 2592
    goto case_162;
  }
#line 2599
  if (nr == 78) {
#line 2599
    goto case_78;
  }
#line 2666
  if (nr == 25) {
#line 2666
    goto case_25;
  }
#line 2698
  if (nr == 33) {
#line 2698
    goto case_33;
  }
#line 2713
  if (nr == 7) {
#line 2713
    goto case_7;
  }
#line 2722
  if (nr == 112) {
#line 2722
    goto case_112;
  }
#line 2726
  if (nr == 159) {
#line 2726
    goto case_159;
  }
#line 2734
  if (nr == 161) {
#line 2734
    goto case_161;
  }
#line 2738
  if (nr == 103) {
#line 2738
    goto case_103;
  }
#line 2742
  if (nr == 102) {
#line 2742
    goto case_102;
  }
#line 2746
  if (nr == 140) {
#line 2746
    goto case_140;
  }
#line 2756
  if (nr == 108) {
#line 2756
    goto case_108;
  }
#line 2797
  if (nr == 139) {
#line 2797
    goto case_139;
  }
#line 2850
  if (nr == 54) {
#line 2850
    goto case_54;
  }
#line 2853
  if (nr == 132) {
#line 2853
    goto case_132;
  }
#line 2860
  if (nr == 134) {
#line 2860
    goto case_134;
  }
#line 2894
  if (nr == 135) {
#line 2894
    goto case_135;
  }
#line 2906
  if (nr == 157) {
#line 2906
    goto case_157;
  }
#line 2911
  if (nr == 57) {
#line 2911
    goto case_57;
  }
#line 2914
  if (nr == 142) {
#line 2914
    goto case_142;
  }
#line 2926
  if (nr == 98) {
#line 2926
    goto case_98;
  }
#line 2935
  if (nr == 115) {
#line 2935
    goto case_115;
  }
#line 2940
  if (nr == 35) {
#line 2940
    goto case_35___0;
  }
#line 2943
  if (nr == 32) {
#line 2943
    goto case_32;
  }
#line 2949
  if (nr == 105) {
#line 2949
    goto case_105;
  }
#line 2953
  if (nr == 76) {
#line 2953
    goto case_76;
  }
#line 2956
  if (nr == 160) {
#line 2956
    goto case_160;
  }
#line 2967
  if (nr == 50) {
#line 2967
    goto case_50;
  }
#line 2979
  if (nr == 11) {
#line 2979
    goto case_11;
  }
#line 2982
  if (nr == 146) {
#line 2982
    goto case_146;
  }
#line 2986
  if (nr == 113) {
#line 2986
    goto case_113;
  }
#line 3011
  if (nr == 17) {
#line 3011
    goto case_17;
  }
#line 3046
  if (nr == 18) {
#line 3046
    goto case_18;
  }
#line 3194
  if (nr == 97) {
#line 3194
    goto case_97;
  }
#line 3209
  if (nr == 96) {
#line 3209
    goto case_96;
  }
#line 3212
  if (nr == 95) {
#line 3212
    goto case_95;
  }
#line 3220
  if (nr == 26) {
#line 3220
    goto case_26;
  }
#line 3220
  if (nr == 6) {
#line 3220
    goto case_26;
  }
#line 3220
  if (nr == 0) {
#line 3220
    goto case_26;
  }
#line 3220
  if (nr == 1) {
#line 3220
    goto case_26;
  }
#line 3223
  if (nr == 2) {
#line 3223
    goto case_2;
  }
#line 3229
  if (nr == 3) {
#line 3229
    goto case_3;
  }
#line 3288
  if (nr == 156) {
#line 3288
    goto case_156;
  }
#line 3288
  if (nr == 4) {
#line 3288
    goto case_156;
  }
#line 3297
  if (nr == 104) {
#line 3297
    goto case_104;
  }
#line 3307
  if (nr == 70) {
#line 3307
    goto case_70;
  }
#line 3312
  if (nr == 107) {
#line 3312
    goto case_107;
  }
#line 3333
  if (nr == 52) {
#line 3333
    goto case_52;
  }
#line 3351
  if (nr == 74) {
#line 3351
    goto case_74;
  }
#line 3363
  if (nr == 24) {
#line 3363
    goto case_24;
  }
#line 3368
  if (nr == 14) {
#line 3368
    goto case_14;
  }
#line 3375
  if (nr == 67) {
#line 3375
    goto case_67;
  }
#line 3375
  if (nr == 86) {
#line 3375
    goto case_67;
  }
#line 3428
  if (nr == 42) {
#line 3428
    goto case_42___0;
  }
#line 3428
  if (nr == 47) {
#line 3428
    goto case_42___0;
  }
#line 3440
  if (nr == 58) {
#line 3440
    goto case_58;
  }
#line 3449
  if (nr == 158) {
#line 3449
    goto case_158;
  }
#line 3479
  if (nr == 120) {
#line 3479
    goto case_120;
  }
#line 3498
  if (nr == 62) {
#line 3498
    goto case_62;
  }
#line 3508
  if (nr == 46) {
#line 3508
    goto case_46;
  }
#line 3525
  if (nr == 82) {
#line 3525
    goto case_82;
  }
#line 3537
  if (nr == 27) {
#line 3537
    goto case_27;
  }
#line 3537
  if (nr == 41) {
#line 3537
    goto case_27;
  }
#line 3571
  if (nr == 10) {
#line 3571
    goto case_10;
  }
#line 3611
  if (nr == 143) {
#line 3611
    goto case_143;
  }
#line 3629
  if (nr == 144) {
#line 3629
    goto case_144;
  }
#line 3634
  if (nr == 148) {
#line 3634
    goto case_148;
  }
#line 3651
  if (nr == 145) {
#line 3651
    goto case_145;
  }
#line 3655
  if (nr == 127) {
#line 3655
    goto case_127;
  }
#line 3659
  if (nr == 110) {
#line 3659
    goto case_110;
  }
#line 3663
  if (nr == 71) {
#line 3663
    goto case_71;
  }
#line 3671
  if (nr == 73) {
#line 3671
    goto case_73;
  }
#line 3712
  if (nr == 130) {
#line 3712
    goto case_130;
  }
#line 3718
  if (nr == 136) {
#line 3718
    goto case_136;
  }
#line 3721
  if (nr == 69) {
#line 3721
    goto case_69;
  }
#line 3730
  if (nr == 8) {
#line 3730
    goto case_8;
  }
#line 3735
  if (nr == 99) {
#line 3735
    goto case_99;
  }
#line 3745
  if (nr == 13) {
#line 3745
    goto case_13;
  }
#line 3766
  if (nr == 19) {
#line 3766
    goto case_19;
  }
#line 3779
  if (nr == 20) {
#line 3779
    goto case_20;
  }
#line 3792
  if (nr == 83) {
#line 3792
    goto case_83;
  }
#line 3824
  goto switch_default___0;
  case_133: /* CIL Label */ 
#line 1077
  if (! *args) {
    {
#line 1078
    InputSelect();
    }
  } else
#line 1079
  if ((int )*(*(args + 0) + 0) == 45) {
#line 1079
    if (! *(*(args + 0) + 1)) {
      {
#line 1081
      SetForeWindow((struct win *)0);
#line 1082
      Activate(0);
      }
    } else {
#line 1079
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1084
  if ((int )*(*(args + 0) + 0) == 46) {
#line 1084
    if (! *(*(args + 0) + 1)) {
#line 1086
      if (! fore) {
        {
#line 1087
        Msg(0, (char *)"select . needs a window");
        }
      } else {
        {
#line 1090
        SetForeWindow(fore);
#line 1091
        Activate(0);
        }
      }
    } else {
#line 1084
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 1094
    tmp___2 = ParseWinNum(act, & n);
    }
#line 1094
    if (tmp___2 == 0) {
      {
#line 1095
      SwitchWindow(n);
      }
    }
  }
#line 1096
  goto switch_break;
  case_37: /* CIL Label */ 
  {
#line 1099
  tmp___4 = ParseOnOff(act, & defautonuke);
  }
#line 1099
  if (tmp___4 == 0) {
#line 1099
    if (msgok) {
#line 1100
      if (defautonuke) {
#line 1100
        tmp___3 = "on";
      } else {
#line 1100
        tmp___3 = "off";
      }
      {
#line 1100
      Msg(0, (char *)"Default autonuke turned %s", tmp___3);
      }
    }
  }
#line 1101
  if (display) {
#line 1101
    if (*rc_name) {
#line 1102
      display->d_auto_nuke = defautonuke;
    }
  }
#line 1103
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 1105
  tmp___6 = ParseOnOff(act, & display->d_auto_nuke);
  }
#line 1105
  if (tmp___6 == 0) {
#line 1105
    if (msgok) {
#line 1106
      if (display->d_auto_nuke) {
#line 1106
        tmp___5 = "on";
      } else {
#line 1106
        tmp___5 = "off";
      }
      {
#line 1106
      Msg(0, (char *)"Autonuke turned %s", tmp___5);
      }
    }
  }
#line 1107
  goto switch_break;
  case_53: /* CIL Label */ 
  {
#line 1110
  tmp___7 = ParseNum(act, & defobuflimit);
  }
#line 1110
  if (tmp___7 == 0) {
#line 1110
    if (msgok) {
      {
#line 1111
      Msg(0, (char *)"Default limit set to %d", defobuflimit);
      }
    }
  }
#line 1112
  if (display) {
#line 1112
    if (*rc_name) {
#line 1114
      display->d_obufmax = defobuflimit;
#line 1115
      display->d_obuflenmax = display->d_obuflen - display->d_obufmax;
    }
  }
#line 1117
  goto switch_break;
  case_109: /* CIL Label */ 
#line 1119
  if ((unsigned long )*args == (unsigned long )((char *)0)) {
    {
#line 1120
    Msg(0, (char *)"Limit is %d, current buffer size is %d", display->d_obufmax, display->d_obuflen);
    }
  } else {
    {
#line 1121
    tmp___8 = ParseNum(act, & display->d_obufmax);
    }
#line 1121
    if (tmp___8 == 0) {
#line 1121
      if (msgok) {
        {
#line 1122
        Msg(0, (char *)"Limit set to %d", display->d_obufmax);
        }
      }
    }
  }
#line 1123
  display->d_obuflenmax = display->d_obuflen - display->d_obufmax;
#line 1124
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 1126
  WriteFile(user, (char *)0, 0);
  }
#line 1127
  goto switch_break;
  case_75: /* CIL Label */ 
#line 1130
  mode = 1;
#line 1132
  if (argc > 1) {
    {
#line 1132
    tmp___9 = strcmp((char const   *)*args, "-h");
    }
#line 1132
    if (! tmp___9) {
#line 1134
      mode = 3;
#line 1135
      args ++;
#line 1136
      argc --;
    }
  }
#line 1138
  if (*args) {
#line 1138
    if (*(args + 1)) {
      {
#line 1140
      Msg(0, (char *)"%s: hardcopy: too many arguments", rc_name);
      }
#line 1141
      goto switch_break;
    }
  }
#line 1143
  if ((unsigned long )fore == (unsigned long )((struct win *)0)) {
#line 1143
    if ((unsigned long )*args == (unsigned long )((char *)0)) {
      {
#line 1144
      Msg(0, (char *)"%s: hardcopy: window required", rc_name);
      }
    } else {
      {
#line 1146
      WriteFile(user, *args, mode);
      }
    }
  } else {
    {
#line 1146
    WriteFile(user, *args, mode);
    }
  }
#line 1148
  goto switch_break;
  case_48: /* CIL Label */ 
  {
#line 1150
  ParseOnOff(act, & nwin_default.Lflag);
  }
#line 1151
  goto switch_break;
  case_91: /* CIL Label */ 
#line 1153
  if (fore->w_log) {
#line 1153
    n = 1;
  } else {
#line 1153
    n = 0;
  }
  {
#line 1154
  ParseSwitch(act, & n);
#line 1155
  LogToggle(n);
  }
#line 1156
  goto switch_break;
  case_149: /* CIL Label */ 
  {
#line 1159
  Detach(1);
  }
#line 1160
  goto switch_break;
  case_106: /* CIL Label */ 
  {
#line 1163
  tmp___11 = MoreWindows();
  }
#line 1163
  if (tmp___11) {
    {
#line 1164
    tmp___10 = NextWindow();
#line 1164
    SwitchWindow(tmp___10);
    }
  }
#line 1165
  goto switch_break;
  case_119: /* CIL Label */ 
  {
#line 1167
  tmp___13 = MoreWindows();
  }
#line 1167
  if (tmp___13) {
    {
#line 1168
    tmp___12 = PreviousWindow();
#line 1168
    SwitchWindow(tmp___12);
    }
  }
#line 1169
  goto switch_break;
  case_87: /* CIL Label */ 
#line 1174
  if (key >= 0) {
#line 1177
    if (fore->w_pwin) {
#line 1177
      tmp___14 = "Really kill this filter [y/n]";
    } else {
#line 1177
      tmp___14 = "Really kill this window [y/n]";
    }
    {
#line 1177
    Input((char *)tmp___14, 1, 2, & confirm_fn, (char *)87);
    }
#line 1181
    goto switch_break;
  }
#line 1183
  n = fore->w_number;
#line 1185
  if (fore->w_pwin) {
    {
#line 1187
    FreePseudowin(fore);
#line 1188
    Msg(0, (char *)"Filter removed.");
    }
#line 1189
    goto switch_break;
  }
  {
#line 1192
  name = SaveStr((char const   *)fore->w_title);
#line 1193
  KillWindow(fore);
#line 1194
  Msg(0, (char *)"Window %d (%s) killed.", n, name);
  }
#line 1195
  if (name) {
    {
#line 1196
    free((void *)name);
    }
  }
#line 1197
  goto switch_break;
  case_122: /* CIL Label */ 
#line 1200
  if (key >= 0) {
    {
#line 1202
    Input((char *)"Really quit and kill all your windows [y/n]", 1, 2, & confirm_fn,
          (char *)122);
    }
#line 1203
    goto switch_break;
  }
  {
#line 1205
  Finit(0);
  }
  case_61: /* CIL Label */ 
#line 1209
  if (*args) {
    {
#line 1209
    tmp___15 = strcmp((char const   *)*args, "-h");
    }
#line 1209
    if (tmp___15) {
      {
#line 1212
      Detach(0);
      }
    } else {
      {
#line 1210
      Hangup();
      }
    }
  } else {
    {
#line 1212
    Detach(0);
    }
  }
#line 1213
  goto switch_break;
  case_117: /* CIL Label */ 
#line 1216
  if (key >= 0) {
    {
#line 1220
    buf[0] = (char )key;
#line 1221
    Input(buf, 1, 2, & pow_detach_fn, (char *)((void *)0));
    }
  } else {
    {
#line 1224
    Detach(3);
    }
  }
#line 1225
  goto switch_break;
  case_36: /* CIL Label */ 
#line 1252
  if ((unsigned long )*args == (unsigned long )((char *)0)) {
    {
#line 1253
    Msg(0, (char *)"Sorry, screen was compiled without -DDEBUG option.");
    }
  } else {
    {
#line 1252
    tmp___16 = strcmp("off", (char const   *)*args);
    }
#line 1252
    if (tmp___16) {
      {
#line 1253
      Msg(0, (char *)"Sorry, screen was compiled without -DDEBUG option.");
      }
    }
  }
#line 1255
  goto switch_break;
  case_173: /* CIL Label */ 
#line 1258
  if (*args) {
    {
#line 1258
    tmp___17 = strcmp((char const   *)*args, "sendcmd");
    }
#line 1258
    if (! tmp___17) {
#line 1260
      if (*(args + 1)) {
        {
#line 1262
        free((void *)zmodem_sendcmd);
#line 1263
        zmodem_sendcmd = SaveStr((char const   *)*(args + 1));
        }
      }
#line 1265
      if (msgok) {
        {
#line 1266
        Msg(0, (char *)"zmodem sendcmd: %s", zmodem_sendcmd);
        }
      }
#line 1267
      goto switch_break;
    }
  }
#line 1269
  if (*args) {
    {
#line 1269
    tmp___18 = strcmp((char const   *)*args, "recvcmd");
    }
#line 1269
    if (! tmp___18) {
#line 1271
      if (*(args + 1)) {
        {
#line 1273
        free((void *)zmodem_recvcmd);
#line 1274
        zmodem_recvcmd = SaveStr((char const   *)*(args + 1));
        }
      }
#line 1276
      if (msgok) {
        {
#line 1277
        Msg(0, (char *)"zmodem recvcmd: %s", zmodem_recvcmd);
        }
      }
#line 1278
      goto switch_break;
    }
  }
#line 1280
  if (*args) {
#line 1282
    i = 0;
    {
#line 1282
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1282
      if (! (i < 4)) {
#line 1282
        goto while_break___0;
      }
      {
#line 1283
      tmp___19 = strcmp((char const   *)zmodes[i], (char const   *)*args);
      }
#line 1283
      if (! tmp___19) {
#line 1284
        goto while_break___0;
      }
#line 1282
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1285
    if (i == 4) {
      {
#line 1285
      tmp___20 = strcmp((char const   *)*args, "on");
      }
#line 1285
      if (! tmp___20) {
#line 1286
        i = 1;
      }
    }
#line 1287
    if (i == 4) {
      {
#line 1289
      Msg(0, (char *)"usage: zmodem off|auto|catch|pass");
      }
#line 1290
      goto switch_break;
    }
#line 1292
    zmodem_mode = i;
  }
#line 1294
  if (msgok) {
    {
#line 1295
    Msg(0, (char *)"zmodem mode is %s", zmodes[zmodem_mode]);
    }
  }
#line 1296
  goto switch_break;
  case_174: /* CIL Label */ 
#line 1300
  s = *args;
#line 1300
  if (! s) {
#line 1302
    ZombieKey_destroy = 0;
#line 1303
    goto switch_break;
  }
#line 1305
  if (*argl == 0) {
    {
#line 1307
    Msg(0, (char *)"%s:zombie: one or two characters expected.", rc_name);
    }
#line 1308
    goto switch_break;
  } else
#line 1305
  if (*argl > 2) {
    {
#line 1307
    Msg(0, (char *)"%s:zombie: one or two characters expected.", rc_name);
    }
#line 1308
    goto switch_break;
  }
#line 1310
  ZombieKey_destroy = (int )*(*(args + 0) + 0);
#line 1311
  if (*argl == 2) {
#line 1311
    ZombieKey_resurrect = (int )*(*(args + 0) + 1);
  } else {
#line 1311
    ZombieKey_resurrect = 0;
  }
#line 1313
  goto switch_break;
  case_164: /* CIL Label */ 
  {
#line 1316
  s = (display->d_user)->u_name;
#line 1321
  olddisplay = display;
#line 1322
  display = (struct display *)0;
#line 1323
  Msg(0, (char *)"%s: %s", s, *args);
#line 1324
  display = olddisplay;
  }
#line 1326
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 1330
  s = SaveStr((char const   *)((display->d_user)->u_name));
#line 1332
  EffectiveAclUser = display->d_user;
#line 1336
  tmp___21 = strlen((char const   *)*(args + 0));
#line 1336
  n = (int )tmp___21;
  }
#line 1337
  if (n) {
#line 1337
    n --;
  }
  {
#line 1345
  if ((int )*(*(args + 0) + n) == 42) {
#line 1345
    goto case_42;
  }
#line 1380
  if ((int )*(*(args + 0) + n) == 37) {
#line 1380
    goto case_37___0;
  }
#line 1409
  if ((int )*(*(args + 0) + n) == 35) {
#line 1409
    goto case_35;
  }
#line 1412
  goto switch_default;
  case_42: /* CIL Label */ 
#line 1350
  if (! n) {
#line 1351
    u = display->d_user;
  } else {
#line 1353
    u = users;
    {
#line 1353
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1353
      if (! u) {
#line 1353
        goto while_break___1;
      }
      {
#line 1355
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1355
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 1356
      tmp___22 = strncmp((char const   *)*args, (char const   *)(u->u_name), (size_t )n);
      }
#line 1356
      if (! tmp___22) {
#line 1357
        goto while_break___1;
      }
#line 1353
      u = u->u_next;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 1359
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1359
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1360
  display = displays;
  {
#line 1360
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1360
    if (! display) {
#line 1360
      goto while_break___4;
    }
#line 1362
    nd = display->d_next;
#line 1363
    if ((unsigned long )display->d_forecv == (unsigned long )((struct canvas *)0)) {
#line 1364
      goto __Cont;
    }
#line 1365
    flayer = (display->d_forecv)->c_layer;
#line 1366
    fore = display->d_fore;
#line 1367
    if ((unsigned long )display->d_user != (unsigned long )u) {
#line 1368
      goto __Cont;
    }
    {
#line 1369
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1369
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 1370
    DoCommand(args + 1, argl + 1);
    }
#line 1371
    if (display) {
#line 1372
      if (*(args + 2)) {
#line 1372
        tmp___23 = (char const   *)*(args + 2);
      } else {
#line 1372
        tmp___23 = "";
      }
      {
#line 1372
      Msg(0, (char *)"command from %s: %s %s", s, *(args + 1), tmp___23);
      }
    }
#line 1374
    display = (struct display *)((void *)0);
#line 1375
    flayer = (struct layer *)0;
#line 1376
    fore = (struct win *)((void *)0);
    __Cont: /* CIL Label */ 
#line 1360
    display = nd;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1378
  goto switch_break___0;
  case_37___0: /* CIL Label */ 
  {
#line 1384
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1384
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 1385
  display = displays;
  {
#line 1385
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1385
    if (! display) {
#line 1385
      goto while_break___7;
    }
#line 1387
    nd___0 = display->d_next;
#line 1388
    if ((unsigned long )display->d_forecv == (unsigned long )((struct canvas *)0)) {
#line 1389
      goto __Cont___0;
    }
    {
#line 1390
    fore = display->d_fore;
#line 1391
    flayer = (display->d_forecv)->c_layer;
#line 1392
    tmp___24 = strncmp((char const   *)*(args + 0), (char const   *)(display->d_usertty),
                       (size_t )n);
    }
#line 1392
    if (tmp___24) {
      {
#line 1392
      tmp___25 = strncmp("/dev/", (char const   *)(display->d_usertty), (size_t )5);
      }
#line 1392
      if (tmp___25) {
#line 1392
        goto _L___1;
      } else {
        {
#line 1392
        tmp___26 = strncmp((char const   *)*(args + 0), (char const   *)(display->d_usertty + 5),
                           (size_t )n);
        }
#line 1392
        if (tmp___26) {
          _L___1: /* CIL Label */ 
          {
#line 1392
          tmp___27 = strncmp("/dev/tty", (char const   *)(display->d_usertty), (size_t )8);
          }
#line 1392
          if (tmp___27) {
#line 1397
            goto __Cont___0;
          } else {
            {
#line 1392
            tmp___28 = strncmp((char const   *)*(args + 0), (char const   *)(display->d_usertty + 8),
                               (size_t )n);
            }
#line 1392
            if (tmp___28) {
#line 1397
              goto __Cont___0;
            }
          }
        }
      }
    }
    {
#line 1398
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1398
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 1399
    DoCommand(args + 1, argl + 1);
    }
#line 1400
    if (display) {
#line 1401
      if (*(args + 2)) {
#line 1401
        tmp___29 = (char const   *)*(args + 2);
      } else {
#line 1401
        tmp___29 = "";
      }
      {
#line 1401
      Msg(0, (char *)"command from %s: %s %s", s, *(args + 1), tmp___29);
      }
    }
#line 1403
    display = (struct display *)((void *)0);
#line 1404
    fore = (struct win *)((void *)0);
#line 1405
    flayer = (struct layer *)0;
    __Cont___0: /* CIL Label */ 
#line 1385
    display = nd___0;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 1407
  goto switch_break___0;
  case_35: /* CIL Label */ 
#line 1410
  n --;
  switch_default: /* CIL Label */ 
#line 1417
  n ++;
#line 1418
  ch___0 = (int )*(*(args + 0) + n);
#line 1419
  *(*(args + 0) + n) = (char )'\000';
#line 1420
  if (! *(*(args + 0))) {
#line 1420
    goto _L___2;
  } else {
    {
#line 1420
    i = WindowByNumber(*(args + 0));
    }
#line 1420
    if (i < 0) {
      _L___2: /* CIL Label */ 
#line 1422
      *(*(args + 0) + n) = (char )ch___0;
#line 1424
      fore = windows;
      {
#line 1424
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 1424
        if (! fore) {
#line 1424
          goto while_break___9;
        }
        {
#line 1426
        nw = fore->w_next;
#line 1427
        tmp___30 = strncmp((char const   *)*(args + 0), (char const   *)fore->w_title,
                           (size_t )n);
        }
#line 1427
        if (tmp___30) {
#line 1428
          goto __Cont___1;
        }
        {
#line 1429
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 1429
          goto while_break___10;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 1437
        i = 0;
#line 1439
        if (fore->w_layer.l_cvlist) {
#line 1440
          display = (fore->w_layer.l_cvlist)->c_display;
        }
#line 1441
        if (fore->w_savelayer) {
#line 1441
          flayer = fore->w_savelayer;
        } else {
#line 1441
          flayer = & fore->w_layer;
        }
        {
#line 1442
        DoCommand(args + 1, argl + 1);
        }
#line 1443
        if (fore) {
#line 1443
          if (fore->w_layer.l_cvlist) {
#line 1445
            display = (fore->w_layer.l_cvlist)->c_display;
#line 1446
            if (*(args + 2)) {
#line 1446
              tmp___31 = (char const   *)*(args + 2);
            } else {
#line 1446
              tmp___31 = "";
            }
            {
#line 1446
            Msg(0, (char *)"command from %s: %s %s", s, *(args + 1), tmp___31);
            }
          }
        }
        __Cont___1: /* CIL Label */ 
#line 1424
        fore = nw;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 1450
      display = (struct display *)((void *)0);
#line 1451
      fore = (struct win *)((void *)0);
#line 1452
      if (i < 0) {
        {
#line 1453
        Msg(0, (char *)"%s: at \'%s\': no such window.\n", rc_name, *(args + 0));
        }
      }
#line 1454
      goto switch_break___0;
    } else
#line 1456
    if (i < 40) {
#line 1456
      fore = wtab[i];
#line 1456
      if (fore) {
#line 1458
        *(*(args + 0) + n) = (char )ch___0;
        {
#line 1459
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 1459
          goto while_break___11;
        }
        while_break___11: /* CIL Label */ ;
        }
#line 1460
        if (fore->w_layer.l_cvlist) {
#line 1461
          display = (fore->w_layer.l_cvlist)->c_display;
        }
#line 1462
        if (fore->w_savelayer) {
#line 1462
          flayer = fore->w_savelayer;
        } else {
#line 1462
          flayer = & fore->w_layer;
        }
        {
#line 1463
        DoCommand(args + 1, argl + 1);
        }
#line 1464
        if (fore) {
#line 1464
          if (fore->w_layer.l_cvlist) {
#line 1466
            display = (fore->w_layer.l_cvlist)->c_display;
#line 1467
            if (*(args + 2)) {
#line 1467
              tmp___32 = (char const   *)*(args + 2);
            } else {
#line 1467
              tmp___32 = "";
            }
            {
#line 1467
            Msg(0, (char *)"command from %s: %s %s", s, *(args + 1), tmp___32);
            }
          }
        }
#line 1470
        display = (struct display *)((void *)0);
#line 1471
        fore = (struct win *)((void *)0);
      } else {
        {
#line 1474
        Msg(0, (char *)"%s: at [identifier][%%|*|#] command [args]", rc_name);
        }
      }
    } else {
      {
#line 1474
      Msg(0, (char *)"%s: at [identifier][%%|*|#] command [args]", rc_name);
      }
    }
  }
#line 1475
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 1478
  free((void *)s);
#line 1480
  EffectiveAclUser = (struct acluser *)((void *)0);
  }
#line 1482
  goto switch_break;
  case_124: /* CIL Label */ 
#line 1487
  if (fore) {
#line 1487
    i = fore->w_layer.l_encoding;
  } else {
#line 1487
    if (display) {
#line 1487
      tmp___33 = display->d_encoding;
    } else {
#line 1487
      tmp___33 = 0;
    }
#line 1487
    i = tmp___33;
  }
#line 1488
  if (*(args + 0)) {
#line 1488
    if (*(args + 1)) {
      {
#line 1488
      tmp___34 = strcmp((char const   *)*(args + 0), "-e");
      }
#line 1488
      if (! tmp___34) {
        {
#line 1490
        i = FindEncoding(*(args + 1));
        }
#line 1491
        if (i == -1) {
          {
#line 1493
          Msg(0, (char *)"%s: readreg: unknown encoding", rc_name);
          }
#line 1494
          goto switch_break;
        }
#line 1496
        args += 2;
      }
    }
  }
#line 1505
  s = *args;
#line 1505
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    {
#line 1507
    Input((char *)"Copy to register:", 1, 2, & copy_reg_fn, (char *)((void *)0));
    }
#line 1508
    goto switch_break;
  }
#line 1510
  if (*argl != 1) {
    {
#line 1512
    Msg(0, (char *)"%s: copyreg: character, ^x, or (octal) \\032 expected.", rc_name);
    }
#line 1513
    goto switch_break;
  }
#line 1515
  ch = *(*(args + 0) + 0);
#line 1519
  if (*(args + 1)) {
#line 1521
    if (*(args + 2)) {
      {
#line 1523
      Msg(0, (char *)"%s: readreg: too many arguments", rc_name);
      }
#line 1524
      goto switch_break;
    }
    {
#line 1526
    s = ReadFile(*(args + 1), & n);
    }
#line 1526
    if (s) {
#line 1528
      pp = plop_tab + (int )((unsigned char )ch);
#line 1530
      if (pp->buf) {
        {
#line 1531
        free((void *)pp->buf);
        }
      }
#line 1532
      pp->buf = s;
#line 1533
      pp->len = n;
#line 1535
      pp->enc = i;
    }
  } else {
    {
#line 1545
    copy_reg_fn(& ch, 0, (char *)((void *)0));
    }
  }
#line 1546
  goto switch_break;
  case_126: /* CIL Label */ 
#line 1550
  if (fore) {
#line 1550
    i = fore->w_layer.l_encoding;
  } else {
#line 1550
    if (display) {
#line 1550
      tmp___35 = display->d_encoding;
    } else {
#line 1550
      tmp___35 = 0;
    }
#line 1550
    i = tmp___35;
  }
#line 1551
  if (*(args + 0)) {
#line 1551
    if (*(args + 1)) {
      {
#line 1551
      tmp___36 = strcmp((char const   *)*(args + 0), "-e");
      }
#line 1551
      if (! tmp___36) {
        {
#line 1553
        i = FindEncoding(*(args + 1));
        }
#line 1554
        if (i == -1) {
          {
#line 1556
          Msg(0, (char *)"%s: register: unknown encoding", rc_name);
          }
#line 1557
          goto switch_break;
        }
#line 1559
        args += 2;
#line 1560
        argc -= 2;
      }
    }
  }
#line 1563
  if (argc != 2) {
    {
#line 1565
    Msg(0, (char *)"%s: register: illegal number of arguments.", rc_name);
    }
#line 1566
    goto switch_break;
  }
#line 1568
  if (*argl != 1) {
    {
#line 1570
    Msg(0, (char *)"%s: register: character, ^x, or (octal) \\032 expected.", rc_name);
    }
#line 1571
    goto switch_break;
  }
#line 1573
  ch = *(*(args + 0) + 0);
#line 1575
  if ((int )ch == 46) {
#line 1577
    if ((unsigned long )user->u_plop.buf != (unsigned long )((void *)0)) {
      {
#line 1578
      UserFreeCopyBuffer(user);
      }
    }
#line 1579
    if (*(args + 1)) {
#line 1579
      if (*(*(args + 1) + 0)) {
        {
#line 1581
        user->u_plop.buf = SaveStrn((char const   *)*(args + 1), *(argl + 1));
#line 1582
        user->u_plop.len = *(argl + 1);
#line 1584
        user->u_plop.enc = i;
        }
      }
    }
  } else {
#line 1591
    plp = plop_tab + (int )((unsigned char )ch);
#line 1593
    if (plp->buf) {
      {
#line 1594
      free((void *)plp->buf);
      }
    }
    {
#line 1595
    plp->buf = SaveStrn((char const   *)*(args + 1), *(argl + 1));
#line 1596
    plp->len = *(argl + 1);
#line 1598
    plp->enc = i;
    }
  }
#line 1601
  goto switch_break;
  case_121: /* CIL Label */ 
#line 1603
  s = *args;
#line 1603
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    {
#line 1605
    Input((char *)"Process register:", 1, 2, & process_fn, (char *)((void *)0));
    }
#line 1606
    goto switch_break;
  }
#line 1608
  if (*argl != 1) {
    {
#line 1610
    Msg(0, (char *)"%s: process: character, ^x, or (octal) \\032 expected.", rc_name);
    }
#line 1611
    goto switch_break;
  }
  {
#line 1613
  ch = *(*(args + 0) + 0);
#line 1614
  process_fn(& ch, 0, (char *)((void *)0));
  }
#line 1615
  goto switch_break;
  case_147: /* CIL Label */ 
#line 1617
  s = *args;
#line 1618
  n = *argl;
#line 1619
  if (*(args + 1)) {
    {
#line 1621
    tmp___37 = strcmp((char const   *)s, "-k");
    }
#line 1621
    if (tmp___37) {
      {
#line 1623
      Msg(0, (char *)"%s: stuff: invalid option %s", rc_name, s);
      }
#line 1624
      goto switch_break;
    }
#line 1626
    s = *(args + 1);
#line 1627
    i = 106;
    {
#line 1627
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 1627
      if (! (i < 183)) {
#line 1627
        goto while_break___12;
      }
      {
#line 1628
      tmp___38 = strcmp((char const   *)term[i].tcname, (char const   *)s);
      }
#line 1628
      if (tmp___38 == 0) {
#line 1629
        goto while_break___12;
      }
#line 1627
      i ++;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 1630
    if (i == 183) {
      {
#line 1632
      Msg(0, (char *)"%s: stuff: unknown key \'%s\'", rc_name, s);
      }
#line 1633
      goto switch_break;
    }
    {
#line 1636
    tmp___39 = StuffKey(i - 106);
    }
#line 1636
    if (tmp___39 == 0) {
#line 1637
      goto switch_break;
    }
#line 1639
    if (display) {
#line 1639
      s = display->d_tcs[i].str;
    } else {
#line 1639
      s = (char *)0;
    }
#line 1640
    if ((unsigned long )s == (unsigned long )((char *)0)) {
#line 1641
      goto switch_break;
    }
    {
#line 1642
    tmp___40 = strlen((char const   *)s);
#line 1642
    n = (int )tmp___40;
    }
  }
  {
#line 1644
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 1644
    if (! n) {
#line 1644
      goto while_break___13;
    }
    {
#line 1645
    (*((flayer->l_layfn)->lf_LayProcess))(& s, & n);
    }
  }
  while_break___13: /* CIL Label */ ;
  }
#line 1646
  goto switch_break;
  case_125: /* CIL Label */ 
  {
#line 1648
  Activate(-1);
  }
#line 1649
  goto switch_break;
  case_167: /* CIL Label */ 
  {
#line 1651
  ShowWindows(-1);
  }
#line 1652
  goto switch_break;
  case_163: /* CIL Label */ 
  {
#line 1654
  Msg(0, (char *)"screen %s", version);
  }
#line 1655
  goto switch_break;
  case_154: /* CIL Label */ 
#line 1657
  if (*args) {
    {
#line 1659
    timestring = SaveStr((char const   *)*args);
    }
#line 1660
    goto switch_break;
  }
  {
#line 1662
  tmp___41 = MakeWinMsg(timestring, fore, '%');
#line 1662
  Msg(0, (char *)"%s", tmp___41);
  }
#line 1663
  goto switch_break;
  case_85: /* CIL Label */ 
  {
#line 1665
  ShowInfo();
  }
#line 1666
  goto switch_break;
  case_63: /* CIL Label */ 
  {
#line 1668
  ShowDInfo();
  }
#line 1669
  goto switch_break;
  case_31: /* CIL Label */ 
#line 1672
  ktabp = ktab;
#line 1673
  if (argc == 2) {
    {
#line 1673
    tmp___42 = strcmp((char const   *)*args, "-c");
    }
#line 1673
    if (! tmp___42) {
      {
#line 1675
      ktabp = FindKtab(*(args + 1), 0);
      }
#line 1675
      if ((unsigned long )ktabp == (unsigned long )((struct action *)0)) {
        {
#line 1677
        Msg(0, (char *)"Unknown command class \'%s\'", *(args + 1));
        }
#line 1678
        goto switch_break;
      }
    }
  }
#line 1681
  if ((unsigned long )display->d_ESCseen != (unsigned long )(ktab)) {
#line 1683
    display->d_ESCseen = ktabp;
#line 1684
    goto switch_break;
  } else
#line 1681
  if ((unsigned long )ktabp != (unsigned long )(ktab)) {
#line 1683
    display->d_ESCseen = ktabp;
#line 1684
    goto switch_break;
  }
#line 1686
  display->d_ESCseen = (struct action *)0;
  case_111: /* CIL Label */ 
  {
#line 1690
  tmp___45 = MoreWindows();
  }
#line 1690
  if (tmp___45) {
#line 1691
    if (display) {
#line 1691
      if (display->d_other) {
#line 1691
        tmp___44 = (display->d_other)->w_number;
      } else {
        {
#line 1691
        tmp___43 = NextWindow();
#line 1691
        tmp___44 = tmp___43;
        }
      }
    } else {
      {
#line 1691
      tmp___43 = NextWindow();
#line 1691
      tmp___44 = tmp___43;
      }
    }
    {
#line 1691
    SwitchWindow(tmp___44);
    }
  }
#line 1692
  goto switch_break;
  case_100: /* CIL Label */ 
#line 1694
  if (user->u_Esc == -1) {
#line 1695
    goto switch_break;
  }
  {
#line 1696
  ch = (char )user->u_Esc;
#line 1697
  s = & ch;
#line 1698
  n = 1;
#line 1699
  (*((flayer->l_layfn)->lf_LayProcess))(& s, & n);
  }
#line 1700
  goto switch_break;
  case_172: /* CIL Label */ 
  {
#line 1702
  ch = (char)17;
#line 1703
  s = & ch;
#line 1704
  n = 1;
#line 1705
  (*((flayer->l_layfn)->lf_LayProcess))(& s, & n);
  }
#line 1706
  goto switch_break;
  case_171: /* CIL Label */ 
  {
#line 1708
  ch = (char)19;
#line 1709
  s = & ch;
#line 1710
  n = 1;
#line 1711
  (*((flayer->l_layfn)->lf_LayProcess))(& s, & n);
  }
#line 1712
  goto switch_break;
  case_22: /* CIL Label */ 
  case_39: /* CIL Label */ 
#line 1719
  if (*args) {
    {
#line 1721
    tmp___46 = ParseNum(act, & n);
    }
#line 1721
    if (tmp___46) {
#line 1722
      n = 0;
      {
#line 1722
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 1722
        if (! (n < (int )(sizeof(types) / sizeof(types[0])))) {
#line 1722
          goto while_break___14;
        }
#line 1724
        i = 0;
        {
#line 1724
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 1724
          if (! (i < 4)) {
#line 1724
            goto while_break___15;
          }
#line 1726
          ch = *(*(args + 0) + i);
#line 1727
          if ((int )ch >= 97) {
#line 1727
            if ((int )ch <= 122) {
#line 1728
              ch = (char )((int )ch - 32);
            }
          }
#line 1729
          if ((int )ch != (int )*(types[n] + i)) {
#line 1729
            if ((int )ch + 32 != (int )*(types[n] + i)) {
#line 1730
              goto while_break___15;
            }
          }
#line 1724
          i ++;
        }
        while_break___15: /* CIL Label */ ;
        }
#line 1732
        if (i == 4) {
#line 1733
          goto while_break___14;
        }
#line 1722
        n ++;
      }
      while_break___14: /* CIL Label */ ;
      }
    }
#line 1735
    if (n < 0) {
      {
#line 1736
      Msg(0, (char *)"%s invalid, chose one of %s, %s or %s", *args, types[0], types[1],
          types[2]);
      }
    } else
#line 1735
    if (n >= (int )(sizeof(types) / sizeof(types[0]))) {
      {
#line 1736
      Msg(0, (char *)"%s invalid, chose one of %s, %s or %s", *args, types[0], types[1],
          types[2]);
      }
    } else {
      {
#line 1739
      breaktype = n;
#line 1740
      Msg(0, (char *)"breaktype set to (%d) %s", n, types[n]);
      }
    }
  } else {
    {
#line 1744
    Msg(0, (char *)"breaktype is (%d) %s", breaktype, types[breaktype]);
    }
  }
#line 1746
  goto switch_break;
  case_21: /* CIL Label */ 
  case_116: /* CIL Label */ 
#line 1749
  n = 0;
#line 1750
  if (*args) {
    {
#line 1750
    tmp___47 = ParseNum(act, & n);
    }
#line 1750
    if (tmp___47) {
#line 1751
      goto switch_break;
    }
  }
  {
#line 1752
  SendBreak(fore, n, nr == 116);
  }
#line 1753
  goto switch_break;
  case_90: /* CIL Label */ 
  {
#line 1756
  Detach(5);
  }
#line 1757
  goto switch_break;
  case_79: /* CIL Label */ 
  case_165: /* CIL Label */ 
#line 1763
  what = 0;
#line 1765
  i = 1;
#line 1766
  if (*args) {
    {
#line 1766
    tmp___49 = strcmp((char const   *)*args, "-w");
    }
#line 1766
    if (tmp___49) {
#line 1766
      goto _L___3;
    } else {
#line 1767
      what = 1;
    }
  } else
  _L___3: /* CIL Label */ 
#line 1768
  if (*args) {
    {
#line 1768
    tmp___48 = strcmp((char const   *)*args, "-d");
    }
#line 1768
    if (! tmp___48) {
#line 1769
      what = 2;
    }
  }
#line 1770
  if (what) {
#line 1771
    args ++;
  }
#line 1772
  if (what == 0) {
#line 1772
    if (flayer) {
#line 1772
      if (! display) {
#line 1773
        what = 1;
      }
    }
  }
#line 1774
  if (what == 1) {
#line 1776
    if (! flayer) {
      {
#line 1778
      Msg(0, (char *)"%s: %s: window required", rc_name, comms[nr].name);
      }
#line 1779
      goto switch_break;
    }
#line 1781
    w = flayer->l_width;
#line 1782
    h = flayer->l_height;
  } else {
#line 1786
    if (! display) {
      {
#line 1788
      Msg(0, (char *)"%s: %s: display required", rc_name, comms[nr].name);
      }
#line 1789
      goto switch_break;
    }
#line 1791
    w = display->d_width;
#line 1792
    h = display->d_height;
  }
#line 1794
  if (*args) {
#line 1794
    if ((int )*(*(args + 0) + 0) == 45) {
      {
#line 1796
      Msg(0, (char *)"%s: %s: unknown option %s", rc_name, comms[nr].name, *args);
      }
#line 1797
      goto switch_break;
    }
  }
#line 1799
  if (nr == 79) {
#line 1801
    if (! *args) {
#line 1805
      if (h == 42) {
#line 1806
        h = 24;
      } else
#line 1807
      if (h == 24) {
#line 1808
        h = 42;
      } else
#line 1809
      if (h > 33) {
#line 1810
        h = 42;
      } else {
#line 1812
        h = 24;
      }
    } else {
      {
#line 1816
      h = atoi((char const   *)*args);
      }
#line 1817
      if (*(args + 1)) {
        {
#line 1818
        w = atoi((char const   *)*(args + 1));
        }
      }
    }
  } else
#line 1823
  if (! *args) {
#line 1825
    if (w == Z0width) {
#line 1826
      w = Z1width;
    } else
#line 1827
    if (w == Z1width) {
#line 1828
      w = Z0width;
    } else
#line 1829
    if (w > (Z0width + Z1width) / 2) {
#line 1830
      w = Z0width;
    } else {
#line 1832
      w = Z1width;
    }
  } else {
    {
#line 1836
    w = atoi((char const   *)*args);
    }
#line 1837
    if (*(args + 1)) {
      {
#line 1838
      h = atoi((char const   *)*(args + 1));
      }
    }
  }
#line 1841
  if (*args) {
#line 1841
    if (*(args + 1)) {
#line 1841
      if (*(args + 2)) {
        {
#line 1843
        Msg(0, (char *)"%s: %s: too many arguments", rc_name, comms[nr].name);
        }
#line 1844
        goto switch_break;
      }
    }
  }
#line 1846
  if (w <= 0) {
    {
#line 1848
    Msg(0, (char *)"Illegal width");
    }
#line 1849
    goto switch_break;
  }
#line 1851
  if (h <= 0) {
    {
#line 1853
    Msg(0, (char *)"Illegal height");
    }
#line 1854
    goto switch_break;
  }
#line 1856
  if (what == 1) {
#line 1858
    if (flayer->l_width == w) {
#line 1858
      if (flayer->l_height == h) {
#line 1859
        goto switch_break;
      }
    }
    {
#line 1860
    ResizeLayer(flayer, w, h, (struct display *)0);
    }
#line 1861
    goto switch_break;
  }
#line 1863
  if (display->d_width == w) {
#line 1863
    if (display->d_height == h) {
#line 1864
      goto switch_break;
    }
  }
#line 1865
  if (what == 2) {
    {
#line 1867
    ChangeScreenSize(w, h, 1);
    }
  } else {
    {
#line 1871
    tmp___51 = ResizeDisplay(w, h);
    }
#line 1871
    if (tmp___51 == 0) {
#line 1873
      if (display->d_fore) {
#line 1873
        tmp___50 = (int )(display->d_fore)->w_norefresh;
      } else {
#line 1873
        tmp___50 = 0;
      }
      {
#line 1873
      Activate(tmp___50);
#line 1875
      ResizeLayer((display->d_forecv)->c_layer, ((display->d_forecv)->c_xe - (display->d_forecv)->c_xs) + 1,
                  ((display->d_forecv)->c_ye - (display->d_forecv)->c_ys) + 1, (struct display *)0);
      }
#line 1876
      goto switch_break;
    }
#line 1878
    if (h == display->d_height) {
      {
#line 1879
      Msg(0, (char *)"Your termcap does not specify how to change the terminal\'s width to %d.",
          w);
      }
    } else
#line 1880
    if (w == display->d_width) {
      {
#line 1881
      Msg(0, (char *)"Your termcap does not specify how to change the terminal\'s height to %d.",
          h);
      }
    } else {
      {
#line 1883
      Msg(0, (char *)"Your termcap does not specify how to change the terminal\'s resolution to %dx%d.",
          w, h);
      }
    }
  }
#line 1886
  goto switch_break;
  case_155: /* CIL Label */ 
#line 1888
  if ((unsigned long )*args == (unsigned long )((char *)0)) {
    {
#line 1889
    InputAKA();
    }
  } else {
    {
#line 1891
    tmp___52 = strlen((char const   *)*args);
#line 1891
    ChangeAKA(fore, *args, (int )tmp___52);
    }
  }
#line 1892
  goto switch_break;
  case_30: /* CIL Label */ 
  {
#line 1894
  Input((char *)":", 100, 0, & Colonfin, (char *)((void *)0));
  }
#line 1895
  if (*args) {
#line 1895
    if (*(*args)) {
      {
#line 1897
      s = *args;
#line 1898
      tmp___53 = strlen((char const   *)s);
#line 1898
      n = (int )tmp___53;
#line 1899
      (*((flayer->l_layfn)->lf_LayProcess))(& s, & n);
      }
    }
  }
#line 1901
  goto switch_break;
  case_88: /* CIL Label */ 
#line 1903
  if (display->d_status_lastmsg) {
    {
#line 1904
    Msg(0, (char *)"%s", display->d_status_lastmsg);
    }
  }
#line 1905
  goto switch_break;
  case_131: /* CIL Label */ 
  {
#line 1907
  DoScreen((char *)"key", args);
  }
#line 1908
  goto switch_break;
  case_168: /* CIL Label */ 
  {
#line 1910
  tmp___55 = ParseSwitch(act, & fore->w_wrap);
  }
#line 1910
  if (tmp___55 == 0) {
#line 1910
    if (msgok) {
#line 1911
      if (fore->w_wrap) {
#line 1911
        tmp___54 = '+';
      } else {
#line 1911
        tmp___54 = '-';
      }
      {
#line 1911
      Msg(0, (char *)"%cwrap", tmp___54);
      }
    }
  }
#line 1912
  goto switch_break;
  case_72: /* CIL Label */ 
#line 1914
  if (*args) {
#line 1916
    if ((int )*(*(args + 0) + 0) == 97) {
#line 1918
      if (fore->w_flow & (1 << 1)) {
#line 1918
        fore->w_flow = ((1 << 2) | (1 << 1)) | 1;
      } else {
#line 1918
        fore->w_flow = 1 << 2;
      }
    } else {
      {
#line 1922
      tmp___56 = ParseOnOff(act, & n);
      }
#line 1922
      if (tmp___56) {
#line 1923
        goto switch_break;
      }
#line 1924
      fore->w_flow = (fore->w_flow & (1 << 1)) | n;
    }
  } else
#line 1929
  if (fore->w_flow & (1 << 2)) {
#line 1930
    fore->w_flow = (fore->w_flow & (1 << 1)) | 1;
  } else
#line 1931
  if (fore->w_flow & 1) {
#line 1932
    fore->w_flow &= -2;
  } else
#line 1934
  if (fore->w_flow) {
#line 1934
    fore->w_flow = ((1 << 2) | (1 << 1)) | 1;
  } else {
#line 1934
    fore->w_flow = 1 << 2;
  }
  {
#line 1936
  SetFlow(fore->w_flow & 1);
  }
#line 1937
  if (msgok) {
#line 1938
    if (fore->w_flow & (1 << 2)) {
#line 1938
      tmp___57 = "(auto)";
    } else {
#line 1938
      tmp___57 = "";
    }
#line 1938
    if (fore->w_flow & 1) {
#line 1938
      tmp___58 = '+';
    } else {
#line 1938
      tmp___58 = '-';
    }
    {
#line 1938
    Msg(0, (char *)"%cflow%s", tmp___58, tmp___57);
    }
  }
#line 1940
  goto switch_break;
  case_60: /* CIL Label */ 
#line 1943
  if ((int )*(*(args + 0) + 0) == 97) {
#line 1944
    nwin_default.wlock = 1;
  } else {
    {
#line 1947
    tmp___59 = ParseOnOff(act, & n);
    }
#line 1947
    if (tmp___59) {
#line 1948
      goto switch_break;
    }
#line 1949
    if (n) {
#line 1949
      nwin_default.wlock = 2;
    } else {
#line 1949
      nwin_default.wlock = 0;
    }
  }
#line 1951
  goto switch_break;
  case_170: /* CIL Label */ 
#line 1953
  if (*args) {
#line 1955
    if ((int )*(*(args + 0) + 0) == 97) {
#line 1957
      fore->w_wlock = 1;
    } else {
      {
#line 1961
      tmp___60 = ParseOnOff(act, & n);
      }
#line 1961
      if (tmp___60) {
#line 1962
        goto switch_break;
      }
#line 1963
      if (n) {
#line 1963
        fore->w_wlock = 2;
      } else {
#line 1963
        fore->w_wlock = 0;
      }
    }
    {
#line 1969
    tmp___61 = AclCheckPermWin(display->d_user, 1, fore);
    }
#line 1969
    if (! tmp___61) {
#line 1970
      fore->w_wlockuser = display->d_user;
    }
  }
#line 1972
  if (fore->w_wlock == 1) {
#line 1972
    tmp___63 = "auto";
  } else {
#line 1972
    if (fore->w_wlock == 0) {
#line 1972
      tmp___62 = "off";
    } else {
#line 1972
      tmp___62 = "on";
    }
#line 1972
    tmp___63 = tmp___62;
  }
  {
#line 1972
  Msg(0, (char *)"writelock %s", tmp___63);
  }
#line 1974
  goto switch_break;
  case_29: /* CIL Label */ 
  {
#line 1977
  ResetAnsiState(fore);
#line 1978
  WriteString(fore, (char *)"\033[H\033[J", 6);
  }
#line 1979
  goto switch_break;
  case_129: /* CIL Label */ 
  {
#line 1981
  ResetAnsiState(fore);
  }
#line 1983
  if (fore->w_zdisplay) {
    {
#line 1984
    zmodem_abort(fore, fore->w_zdisplay);
    }
  }
  {
#line 1986
  WriteString(fore, (char *)"\033c", 2);
  }
#line 1987
  goto switch_break;
  case_101: /* CIL Label */ 
  {
#line 1989
  n = fore->w_monitor != 0;
#line 1990
  tmp___64 = ParseSwitch(act, & n);
  }
#line 1990
  if (tmp___64) {
#line 1991
    goto switch_break;
  }
#line 1992
  if (n) {
#line 1995
    if (display) {
#line 1996
      *(fore->w_mon_notify + ((display->d_user)->u_id >> 3)) = (unsigned char )((int )*(fore->w_mon_notify + ((display->d_user)->u_id >> 3)) | (128 >> ((display->d_user)->u_id & 7)));
    } else {
#line 1998
      i = 0;
      {
#line 1998
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 1998
        if (! (i < maxusercount)) {
#line 1998
          goto while_break___16;
        }
#line 1999
        *(fore->w_mon_notify + (i >> 3)) = (unsigned char )((int )*(fore->w_mon_notify + (i >> 3)) | (128 >> (i & 7)));
#line 1998
        i ++;
      }
      while_break___16: /* CIL Label */ ;
      }
    }
#line 2001
    if (fore->w_monitor == 0) {
#line 2002
      fore->w_monitor = 1;
    }
    {
#line 2003
    Msg(0, (char *)"Window %d (%s) is now being monitored for all activity.", fore->w_number,
        fore->w_title);
    }
  } else {
#line 2008
    if (display) {
#line 2009
      *(fore->w_mon_notify + ((display->d_user)->u_id >> 3)) = (unsigned char )((int )*(fore->w_mon_notify + ((display->d_user)->u_id >> 3)) & ~ (128 >> ((display->d_user)->u_id & 7)));
    } else {
#line 2012
      i = 0;
      {
#line 2012
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 2012
        if (! (i < maxusercount)) {
#line 2012
          goto while_break___17;
        }
#line 2013
        *(fore->w_mon_notify + (i >> 3)) = (unsigned char )((int )*(fore->w_mon_notify + (i >> 3)) & ~ (128 >> (i & 7)));
#line 2012
        i ++;
      }
      while_break___17: /* CIL Label */ ;
      }
    }
#line 2014
    i = maxusercount - 1;
    {
#line 2014
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 2014
      if (! (i >= 0)) {
#line 2014
        goto while_break___18;
      }
#line 2015
      if (*(fore->w_mon_notify + (i >> 3))) {
#line 2016
        goto while_break___18;
      }
#line 2014
      i --;
    }
    while_break___18: /* CIL Label */ ;
    }
#line 2017
    if (i < 0) {
#line 2019
      fore->w_monitor = 0;
    }
    {
#line 2020
    Msg(0, (char *)"Window %d (%s) is no longer being monitored for activity.", fore->w_number,
        fore->w_title);
    }
  }
#line 2022
  goto switch_break;
  case_64: /* CIL Label */ 
  {
#line 2025
  display_displays();
  }
#line 2026
  goto switch_break;
  case_166: /* CIL Label */ 
#line 2029
  if (! *args) {
    {
#line 2030
    display_wlist(0, 0);
    }
  } else {
    {
#line 2031
    tmp___72 = strcmp((char const   *)*args, "-m");
    }
#line 2031
    if (tmp___72) {
      _L___9: /* CIL Label */ 
      {
#line 2033
      tmp___71 = strcmp((char const   *)*args, "-b");
      }
#line 2033
      if (tmp___71) {
        _L___8: /* CIL Label */ 
        {
#line 2035
        tmp___69 = strcmp((char const   *)*args, "-b");
        }
#line 2035
        if (tmp___69) {
          _L___7: /* CIL Label */ 
          {
#line 2037
          tmp___67 = strcmp((char const   *)*args, "-m");
          }
#line 2037
          if (tmp___67) {
            _L___5: /* CIL Label */ 
            {
#line 2039
            tmp___66 = strcmp((char const   *)*args, "string");
            }
#line 2039
            if (tmp___66) {
              {
#line 2050
              tmp___65 = strcmp((char const   *)*args, "title");
              }
#line 2050
              if (tmp___65) {
                {
#line 2062
                Msg(0, (char *)"usage: windowlist [-b] [string [string] | title [title]]");
                }
              } else {
#line 2052
                if (*(args + 1)) {
#line 2054
                  if (wlisttit) {
                    {
#line 2055
                    free((void *)wlisttit);
                    }
                  }
                  {
#line 2056
                  wlisttit = SaveStr((char const   *)*(args + 1));
                  }
                }
#line 2058
                if (msgok) {
                  {
#line 2059
                  Msg(0, (char *)"windowlist title is \'%s\'", wlisttit);
                  }
                }
              }
            } else {
#line 2041
              if (*(args + 1)) {
#line 2043
                if (wliststr) {
                  {
#line 2044
                  free((void *)wliststr);
                  }
                }
                {
#line 2045
                wliststr = SaveStr((char const   *)*(args + 1));
                }
              }
#line 2047
              if (msgok) {
                {
#line 2048
                Msg(0, (char *)"windowlist string is \'%s\'", wliststr);
                }
              }
            }
          } else {
            {
#line 2037
            tmp___68 = strcmp((char const   *)*(args + 1), "-b");
            }
#line 2037
            if (tmp___68) {
#line 2037
              goto _L___5;
            } else
#line 2037
            if (! *(args + 2)) {
              {
#line 2038
              display_wlist(1, 1);
              }
            } else {
#line 2037
              goto _L___5;
            }
          }
        } else {
          {
#line 2035
          tmp___70 = strcmp((char const   *)*(args + 1), "-m");
          }
#line 2035
          if (tmp___70) {
#line 2035
            goto _L___7;
          } else
#line 2035
          if (! *(args + 2)) {
            {
#line 2036
            display_wlist(1, 1);
            }
          } else {
#line 2035
            goto _L___7;
          }
        }
      } else
#line 2033
      if (! *(args + 1)) {
        {
#line 2034
        display_wlist(1, 0);
        }
      } else {
#line 2033
        goto _L___8;
      }
    } else
#line 2031
    if (! *(args + 1)) {
      {
#line 2032
      display_wlist(0, 1);
      }
    } else {
#line 2031
      goto _L___9;
    }
  }
#line 2063
  goto switch_break;
  case_80: /* CIL Label */ 
#line 2065
  if (argc == 2) {
    {
#line 2065
    tmp___73 = strcmp((char const   *)*args, "-c");
    }
#line 2065
    if (tmp___73) {
      {
#line 2076
      display_help((char *)0, ktab);
      }
    } else {
      {
#line 2068
      ktabp___0 = FindKtab(*(args + 1), 0);
      }
#line 2068
      if ((unsigned long )ktabp___0 == (unsigned long )((struct action *)0)) {
        {
#line 2070
        Msg(0, (char *)"Unknown command class \'%s\'", *(args + 1));
        }
#line 2071
        goto switch_break;
      }
      {
#line 2073
      display_help(*(args + 1), ktabp___0);
      }
    }
  } else {
    {
#line 2076
    display_help((char *)0, ktab);
    }
  }
#line 2077
  goto switch_break;
  case_89: /* CIL Label */ 
  {
#line 2079
  display_copyright();
  }
#line 2080
  goto switch_break;
  case_34: /* CIL Label */ 
#line 2083
  if ((unsigned long )flayer->l_layfn != (unsigned long )(& WinLf)) {
    {
#line 2085
    Msg(0, (char *)"Must be on a window layer");
    }
#line 2086
    goto switch_break;
  }
  {
#line 2088
  MarkRoutine();
  }
#line 2089
  goto switch_break;
  case_81: /* CIL Label */ 
#line 2095
  if ((unsigned long )flayer->l_layfn != (unsigned long )(& WinLf)) {
    {
#line 2097
    Msg(0, (char *)"Must be on a window layer");
    }
#line 2098
    goto switch_break;
  }
  {
#line 2100
  tmp___74 = GetHistory();
  }
#line 2100
  if (tmp___74 == 0) {
#line 2101
    goto switch_break;
  }
#line 2102
  if ((unsigned long )user->u_plop.buf == (unsigned long )((void *)0)) {
#line 2103
    goto switch_break;
  }
#line 2104
  args = pasteargs;
#line 2105
  argl = pasteargl;
  case_114: /* CIL Label */ 
#line 2111
  l = 0;
#line 2113
  enc = -1;
#line 2119
  s = *args;
#line 2119
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    {
#line 2121
    Input((char *)"Paste from register:", 1, 2, & ins_reg_fn, (char *)((void *)0));
    }
#line 2122
    goto switch_break;
  }
#line 2124
  if ((unsigned long )*(args + 1) == (unsigned long )((char *)0)) {
#line 2124
    if (! fore) {
#line 2125
      goto switch_break;
    }
  }
#line 2130
  if (*(args + 1)) {
#line 2130
    if (*(argl + 1) != 1) {
      {
#line 2132
      Msg(0, (char *)"%s: paste destination: character, ^x, or (octal) \\032 expected.",
          rc_name);
      }
#line 2134
      goto switch_break;
    } else {
#line 2130
      goto _L___10;
    }
  } else
  _L___10: /* CIL Label */ 
#line 2137
  if (fore) {
#line 2138
    enc = fore->w_layer.l_encoding;
  }
#line 2144
  s = *args;
#line 2144
  ss = s;
  {
#line 2144
  while (1) {
    while_continue___19: /* CIL Label */ ;
#line 2144
    ch = *ss;
#line 2144
    if (! ch) {
#line 2144
      goto while_break___19;
    }
#line 2146
    if ((int )ch == 46) {
#line 2149
      if (enc == -1) {
#line 2150
        enc = user->u_plop.enc;
      }
#line 2151
      if (enc != user->u_plop.enc) {
        {
#line 2152
        tmp___75 = RecodeBuf((unsigned char *)user->u_plop.buf, user->u_plop.len,
                             user->u_plop.enc, enc, (unsigned char *)0);
#line 2152
        l += tmp___75;
        }
      } else {
#line 2155
        l += user->u_plop.len;
      }
    } else {
#line 2160
      if (enc == -1) {
#line 2161
        enc = plop_tab[(int )((unsigned char )ch)].enc;
      }
#line 2162
      if (enc != plop_tab[(int )((unsigned char )ch)].enc) {
        {
#line 2163
        tmp___76 = RecodeBuf((unsigned char *)plop_tab[(int )((unsigned char )ch)].buf,
                             plop_tab[(int )((unsigned char )ch)].len, plop_tab[(int )((unsigned char )ch)].enc,
                             enc, (unsigned char *)0);
#line 2163
        l += tmp___76;
        }
      } else {
#line 2166
        l += plop_tab[(int )((unsigned char )ch)].len;
      }
    }
#line 2144
    ss ++;
  }
  while_break___19: /* CIL Label */ ;
  }
#line 2169
  if (l == 0) {
    {
#line 2171
    Msg(0, (char *)"empty buffer");
    }
#line 2172
    goto switch_break;
  }
#line 2179
  if ((int )*(s + 1) == 0) {
#line 2179
    if ((unsigned long )*(args + 1) == (unsigned long )((char *)0)) {
#line 2181
      if ((int )*s == 46) {
#line 2181
        tmp___78 = user->u_plop.enc;
      } else {
#line 2181
        tmp___78 = plop_tab[(int )((unsigned char )*s)].enc;
      }
#line 2181
      if (enc == tmp___78) {
#line 2184
        if ((int )*s == 46) {
#line 2184
          tmp___77 = user->u_plop.buf;
        } else {
#line 2184
          tmp___77 = plop_tab[(int )((unsigned char )*s)].buf;
        }
        {
#line 2184
        MakePaster(& fore->w_paster, tmp___77, l, 0);
        }
#line 2185
        goto switch_break;
      }
    }
  }
  {
#line 2190
  tmp___79 = malloc((size_t )l);
#line 2190
  dbuf = (char *)tmp___79;
  }
#line 2190
  if ((unsigned long )dbuf == (unsigned long )((char *)0)) {
    {
#line 2192
    Msg(0, strnomem);
    }
#line 2193
    goto switch_break;
  }
#line 2195
  l = 0;
#line 2200
  ss = s;
  {
#line 2200
  while (1) {
    while_continue___20: /* CIL Label */ ;
#line 2200
    ch = *ss;
#line 2200
    if (! ch) {
#line 2200
      goto while_break___20;
    }
#line 2202
    if ((int )ch == 46) {
#line 2202
      tmp___80 = & user->u_plop;
    } else {
#line 2202
      tmp___80 = & plop_tab[(int )((unsigned char )ch)];
    }
#line 2202
    pp___0 = tmp___80;
#line 2204
    if (pp___0->enc != enc) {
      {
#line 2206
      tmp___81 = RecodeBuf((unsigned char *)pp___0->buf, pp___0->len, pp___0->enc,
                           enc, (unsigned char *)dbuf + l);
#line 2206
      l += tmp___81;
      }
#line 2207
      goto __Cont___2;
    }
    {
#line 2210
    bcopy((void const   *)pp___0->buf, (void *)(dbuf + l), (size_t )pp___0->len);
#line 2211
    l += pp___0->len;
    }
    __Cont___2: /* CIL Label */ 
#line 2200
    ss ++;
  }
  while_break___20: /* CIL Label */ ;
  }
#line 2216
  if ((unsigned long )*(args + 1) == (unsigned long )((char *)0)) {
    {
#line 2218
    MakePaster(& fore->w_paster, dbuf, l, 1);
    }
  } else {
#line 2226
    dch = *(*(args + 1) + 0);
#line 2227
    if ((int )dch == 46) {
#line 2229
      if ((unsigned long )user->u_plop.buf != (unsigned long )((void *)0)) {
        {
#line 2230
        UserFreeCopyBuffer(user);
        }
      }
#line 2231
      user->u_plop.buf = dbuf;
#line 2232
      user->u_plop.len = l;
#line 2234
      user->u_plop.enc = enc;
    } else {
#line 2239
      pp___1 = plop_tab + (int )((unsigned char )dch);
#line 2240
      if (pp___1->buf) {
        {
#line 2241
        free((void *)pp___1->buf);
        }
      }
#line 2242
      pp___1->buf = dbuf;
#line 2243
      pp___1->len = l;
#line 2245
      pp___1->enc = enc;
    }
  }
#line 2249
  goto switch_break;
  case_169: /* CIL Label */ 
#line 2252
  if (! user->u_plop.buf) {
    {
#line 2254
    Msg(0, (char *)"empty buffer");
    }
#line 2255
    goto switch_break;
  }
#line 2261
  oldplop = user->u_plop;
#line 2262
  if (*(args + 0)) {
#line 2262
    if (*(args + 1)) {
      {
#line 2262
      tmp___83 = strcmp((char const   *)*(args + 0), "-e");
      }
#line 2262
      if (! tmp___83) {
        {
#line 2267
        enc___0 = FindEncoding(*(args + 1));
        }
#line 2268
        if (enc___0 == -1) {
          {
#line 2270
          Msg(0, (char *)"%s: writebuf: unknown encoding", rc_name);
          }
#line 2271
          goto switch_break;
        }
#line 2273
        if (enc___0 != oldplop.enc) {
          {
#line 2275
          l___0 = RecodeBuf((unsigned char *)oldplop.buf, oldplop.len, oldplop.enc,
                            enc___0, (unsigned char *)0);
#line 2276
          tmp___82 = malloc((size_t )(l___0 + 1));
#line 2276
          newbuf = (char *)tmp___82;
          }
#line 2277
          if (! newbuf) {
            {
#line 2279
            Msg(0, strnomem);
            }
#line 2280
            goto switch_break;
          }
          {
#line 2282
          user->u_plop.len = RecodeBuf((unsigned char *)oldplop.buf, oldplop.len,
                                       oldplop.enc, enc___0, (unsigned char *)newbuf);
#line 2283
          user->u_plop.buf = newbuf;
#line 2284
          user->u_plop.enc = enc___0;
          }
        }
#line 2286
        args += 2;
      }
    }
  }
#line 2289
  if (*(args + 0)) {
#line 2289
    if (*(args + 1)) {
      {
#line 2290
      Msg(0, (char *)"%s: writebuf: too many arguments", rc_name);
      }
    } else {
      {
#line 2292
      WriteFile(user, *(args + 0), 2);
      }
    }
  } else {
    {
#line 2292
    WriteFile(user, *(args + 0), 2);
    }
  }
#line 2294
  if ((unsigned long )user->u_plop.buf != (unsigned long )oldplop.buf) {
    {
#line 2295
    free((void *)user->u_plop.buf);
    }
  }
#line 2296
  user->u_plop = oldplop;
#line 2299
  goto switch_break;
  case_123: /* CIL Label */ 
#line 2302
  if (fore) {
#line 2302
    i = fore->w_layer.l_encoding;
  } else {
#line 2302
    if (display) {
#line 2302
      tmp___84 = display->d_encoding;
    } else {
#line 2302
      tmp___84 = 0;
    }
#line 2302
    i = tmp___84;
  }
#line 2303
  if (*(args + 0)) {
#line 2303
    if (*(args + 1)) {
      {
#line 2303
      tmp___85 = strcmp((char const   *)*(args + 0), "-e");
      }
#line 2303
      if (! tmp___85) {
        {
#line 2305
        i = FindEncoding(*(args + 1));
        }
#line 2306
        if (i == -1) {
          {
#line 2308
          Msg(0, (char *)"%s: readbuf: unknown encoding", rc_name);
          }
#line 2309
          goto switch_break;
        }
#line 2311
        args += 2;
      }
    }
  }
#line 2314
  if (*(args + 0)) {
#line 2314
    if (*(args + 1)) {
      {
#line 2316
      Msg(0, (char *)"%s: readbuf: too many arguments", rc_name);
      }
#line 2317
      goto switch_break;
    }
  }
#line 2319
  if (*(args + 0)) {
#line 2319
    tmp___86 = *(args + 0);
  } else {
#line 2319
    tmp___86 = BufferFile;
  }
  {
#line 2319
  s = ReadFile(tmp___86, & n);
  }
#line 2319
  if (s) {
#line 2321
    if (user->u_plop.buf) {
      {
#line 2322
      UserFreeCopyBuffer(user);
      }
    }
#line 2323
    user->u_plop.len = n;
#line 2324
    user->u_plop.buf = s;
#line 2326
    user->u_plop.enc = i;
  }
#line 2329
  goto switch_break;
  case_128: /* CIL Label */ 
  {
#line 2331
  KillBuffers();
  }
#line 2332
  goto switch_break;
  case_84: /* CIL Label */ 
  {
#line 2334
  ParseSwitch(act, & search_ic);
  }
#line 2335
  if (msgok) {
#line 2336
    if (search_ic) {
#line 2336
      tmp___87 = "";
    } else {
#line 2336
      tmp___87 = "not ";
    }
    {
#line 2336
    Msg(0, (char *)"Will %signore case in searches", tmp___87);
    }
  }
#line 2337
  goto switch_break;
  case_68: /* CIL Label */ 
#line 2340
  if (*argl == 0) {
    {
#line 2341
    SetEscape(user, -1, -1);
    }
  } else
#line 2342
  if (*argl == 2) {
    {
#line 2343
    SetEscape(user, (int )((unsigned char )*(*(args + 0) + 0)), (int )((unsigned char )*(*(args + 0) + 1)));
    }
  } else {
    {
#line 2346
    Msg(0, (char *)"%s: two characters required after escape.", rc_name);
    }
#line 2347
    goto switch_break;
  }
#line 2352
  if (display) {
#line 2352
    if ((unsigned long )user != (unsigned long )users) {
#line 2353
      goto switch_break;
    }
  }
  case_43: /* CIL Label */ 
#line 2356
  if (*argl == 0) {
    {
#line 2357
    SetEscape((struct acluser *)((void *)0), -1, -1);
    }
  } else
#line 2358
  if (*argl == 2) {
    {
#line 2359
    SetEscape((struct acluser *)((void *)0), (int )((unsigned char )*(*(args + 0) + 0)),
              (int )((unsigned char )*(*(args + 0) + 1)));
    }
  } else {
    {
#line 2362
    Msg(0, (char *)"%s: two characters required after defescape.", rc_name);
    }
#line 2363
    goto switch_break;
  }
  {
#line 2366
  CheckEscape();
  }
#line 2368
  goto switch_break;
  case_28: /* CIL Label */ 
#line 2370
  if (*args) {
#line 2370
    s = *args;
  } else {
#line 2370
    s = home;
  }
  {
#line 2371
  tmp___89 = chdir((char const   *)s);
  }
#line 2371
  if (tmp___89 == -1) {
    {
#line 2372
    tmp___88 = __errno_location();
#line 2372
    Msg(*tmp___88, (char *)"%s", s);
    }
  }
#line 2373
  goto switch_break;
  case_55: /* CIL Label */ 
  case_137: /* CIL Label */ 
  {
#line 2376
  tmp___90 = ParseSaveStr(act, & ShellProg);
  }
#line 2376
  if (tmp___90 == 0) {
#line 2377
    ShellArgs[0] = ShellProg;
  }
#line 2378
  goto switch_break;
  case_77: /* CIL Label */ 
#line 2380
  if (*args) {
    {
#line 2381
    ParseSaveStr(act, & hardcopydir);
    }
  }
#line 2382
  if (msgok) {
#line 2383
    if (hardcopydir) {
#line 2383
      if (*hardcopydir) {
#line 2383
        tmp___91 = (char const   *)hardcopydir;
      } else {
#line 2383
        tmp___91 = "<cwd>";
      }
    } else {
#line 2383
      tmp___91 = "<cwd>";
    }
    {
#line 2383
    Msg(0, (char *)"hardcopydir is %s\n", tmp___91);
    }
  }
#line 2384
  goto switch_break;
  case_92: /* CIL Label */ 
#line 2386
  if (*args) {
#line 2388
    if (*(args + 1)) {
      {
#line 2388
      tmp___92 = strcmp((char const   *)*args, "flush");
      }
#line 2388
      if (! tmp___92) {
        {
#line 2390
        log_flush = atoi((char const   *)*(args + 1));
        }
#line 2391
        if (msgok) {
          {
#line 2392
          Msg(0, (char *)"log flush timeout set to %ds\n", log_flush);
          }
        }
#line 2393
        goto switch_break;
      }
    }
    {
#line 2395
    tmp___93 = ParseSaveStr(act, & screenlogfile);
    }
#line 2395
    if (tmp___93) {
#line 2396
      goto switch_break;
    } else
#line 2395
    if (! msgok) {
#line 2396
      goto switch_break;
    }
  }
  {
#line 2398
  Msg(0, (char *)"logfile is \'%s\'", screenlogfile);
  }
#line 2399
  goto switch_break;
  case_94: /* CIL Label */ 
#line 2401
  if (! *args) {
#line 2401
    goto _L___11;
  } else {
    {
#line 2401
    tmp___98 = strcmp((char const   *)*args, "on");
    }
#line 2401
    if (tmp___98) {
      {
#line 2401
      tmp___99 = strcmp((char const   *)*args, "off");
      }
#line 2401
      if (tmp___99) {
        {
#line 2406
        tmp___97 = strcmp((char const   *)*args, "string");
        }
#line 2406
        if (tmp___97) {
          {
#line 2417
          tmp___96 = strcmp((char const   *)*args, "after");
          }
#line 2417
          if (tmp___96) {
            {
#line 2428
            Msg(0, (char *)"usage: logtstamp [after [n]|string [str]|on|off]");
            }
          } else {
#line 2419
            if (*(args + 1)) {
              {
#line 2421
              logtstamp_after = atoi((char const   *)*(args + 1));
              }
#line 2422
              if (! msgok) {
#line 2423
                goto switch_break;
              }
            }
            {
#line 2425
            Msg(0, (char *)"timestamp printed after %ds\n", logtstamp_after);
            }
          }
        } else {
#line 2408
          if (*(args + 1)) {
#line 2410
            if (logtstamp_string) {
              {
#line 2411
              free((void *)logtstamp_string);
              }
            }
            {
#line 2412
            logtstamp_string = SaveStr((char const   *)*(args + 1));
            }
          }
#line 2414
          if (msgok) {
            {
#line 2415
            Msg(0, (char *)"logfile timestamp is \'%s\'", logtstamp_string);
            }
          }
        }
      } else {
        _L___11: /* CIL Label */ 
        {
#line 2403
        tmp___95 = ParseSwitch(act, & logtstamp_on);
        }
#line 2403
        if (tmp___95 == 0) {
#line 2403
          if (msgok) {
#line 2404
            if (logtstamp_on) {
#line 2404
              tmp___94 = "on";
            } else {
#line 2404
              tmp___94 = "off";
            }
            {
#line 2404
            Msg(0, (char *)"timestamps turned %s", tmp___94);
            }
          }
        }
      }
    } else {
#line 2401
      goto _L___11;
    }
  }
#line 2429
  goto switch_break;
  case_138: /* CIL Label */ 
  {
#line 2431
  ParseSaveStr(act, & nwin_default.aka);
  }
#line 2432
  goto switch_break;
  case_153: /* CIL Label */ 
  case_152: /* CIL Label */ 
  case_151: /* CIL Label */ 
#line 2436
  if (! rc_name) {
    {
#line 2437
    Msg(0, (char *)"Sorry, too late now. Place that in your .screenrc file.");
    }
  } else
#line 2436
  if (! *rc_name) {
    {
#line 2437
    Msg(0, (char *)"Sorry, too late now. Place that in your .screenrc file.");
    }
  }
#line 2438
  goto switch_break;
  case_141: /* CIL Label */ 
#line 2440
  goto switch_break;
  case_150: /* CIL Label */ 
  {
#line 2442
  s = (char *)((void *)0);
#line 2443
  tmp___100 = ParseSaveStr(act, & s);
  }
#line 2443
  if (tmp___100) {
#line 2444
    goto switch_break;
  }
  {
#line 2445
  tmp___101 = strlen((char const   *)s);
  }
#line 2445
  if (tmp___101 >= 20U) {
    {
#line 2447
    Msg(0, (char *)"%s: term: argument too long ( < 20)", rc_name);
#line 2448
    free((void *)s);
    }
#line 2449
    goto switch_break;
  }
  {
#line 2451
  strcpy((char */* __restrict  */)(screenterm), (char const   */* __restrict  */)s);
#line 2452
  free((void *)s);
  }
  {
#line 2453
  while (1) {
    while_continue___21: /* CIL Label */ ;
#line 2453
    goto while_break___21;
  }
  while_break___21: /* CIL Label */ ;
  }
  {
#line 2454
  MakeTermcap((unsigned long )display == (unsigned long )((struct display *)0));
  }
  {
#line 2455
  while (1) {
    while_continue___22: /* CIL Label */ ;
#line 2455
    goto while_break___22;
  }
  while_break___22: /* CIL Label */ ;
  }
#line 2456
  goto switch_break;
  case_66: /* CIL Label */ 
#line 2458
  if (! msgok) {
#line 2458
    if (! rc_name) {
#line 2459
      goto switch_break;
    } else {
      {
#line 2458
      tmp___102 = strcmp((char const   *)rc_name, "-X");
      }
#line 2458
      if (tmp___102) {
#line 2459
        goto switch_break;
      }
    }
  }
#line 2464
  if (argc > 1) {
    {
#line 2464
    tmp___103 = strcmp((char const   *)*args, "-n");
    }
#line 2464
    if (! tmp___103) {
#line 2466
      args ++;
#line 2467
      argc --;
    }
  }
#line 2469
  s = *args;
#line 2470
  if (argc > 1) {
    {
#line 2470
    tmp___104 = strcmp((char const   *)*args, "-p");
    }
#line 2470
    if (! tmp___104) {
#line 2472
      args ++;
#line 2473
      argc --;
#line 2474
      s = *args;
#line 2475
      if (s) {
        {
#line 2476
        s = MakeWinMsg(s, fore, '%');
        }
      }
    }
  }
#line 2478
  if (s) {
    {
#line 2479
    Msg(0, (char *)"%s", s);
    }
  } else {
    {
#line 2481
    Msg(0, (char *)"%s: \'echo [-n] [-p] \"string\"\' expected.", rc_name);
    }
  }
#line 2482
  goto switch_break;
  case_16: /* CIL Label */ 
  case_15: /* CIL Label */ 
#line 2485
  if ((unsigned long )*args == (unsigned long )((char *)0)) {
    {
#line 2488
    AddXChars(buf___0, (int )sizeof(buf___0), BellString);
#line 2489
    Msg(0, (char *)"bell_msg is \'%s\'", buf___0);
    }
#line 2490
    goto switch_break;
  }
  {
#line 2492
  ParseSaveStr(act, & BellString);
  }
#line 2493
  goto switch_break;
  case_23: /* CIL Label */ 
#line 2496
  if ((unsigned long )*args == (unsigned long )((char *)0)) {
    {
#line 2497
    BufferFile = SaveStr("/tmp/screen-exchange");
    }
  } else {
    {
#line 2498
    tmp___105 = ParseSaveStr(act, & BufferFile);
    }
#line 2498
    if (tmp___105) {
#line 2499
      goto switch_break;
    }
  }
#line 2500
  if (msgok) {
    {
#line 2501
    Msg(0, (char *)"Bufferfile is now \'%s\'", BufferFile);
    }
  }
#line 2502
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 2505
  ParseSaveStr(act, & ActivityString);
  }
#line 2506
  goto switch_break;
  case_118: /* CIL Label */ 
#line 2509
  if ((unsigned long )*args == (unsigned long )((char *)0)) {
    {
#line 2512
    AddXChars(buf___1, (int )sizeof(buf___1), PowDetachString);
#line 2513
    Msg(0, (char *)"pow_detach_msg is \'%s\'", buf___1);
    }
#line 2514
    goto switch_break;
  }
  {
#line 2516
  ParseSaveStr(act, & PowDetachString);
  }
#line 2517
  goto switch_break;
  case_93: /* CIL Label */ 
#line 2521
  n = (unsigned long )fore->w_slot != (unsigned long )((slot_t )-1);
#line 2522
  if (*args) {
    {
#line 2522
    tmp___106 = strcmp((char const   *)*args, "always");
    }
#line 2522
    if (! tmp___106) {
#line 2524
      fore->w_lflag = 3;
#line 2525
      if (! displays) {
#line 2525
        if (n) {
          {
#line 2526
          SlotToggle(n);
          }
        }
      }
#line 2527
      goto switch_break;
    }
  }
#line 2529
  if (*args) {
    {
#line 2529
    tmp___107 = strcmp((char const   *)*args, "attached");
    }
#line 2529
    if (! tmp___107) {
#line 2531
      fore->w_lflag = 1;
#line 2532
      if (! displays) {
#line 2532
        if (n) {
          {
#line 2533
          SlotToggle(0);
          }
        }
      }
#line 2534
      goto switch_break;
    }
  }
  {
#line 2536
  tmp___108 = ParseSwitch(act, & n);
  }
#line 2536
  if (tmp___108 == 0) {
    {
#line 2537
    SlotToggle(n);
    }
  }
#line 2538
  goto switch_break;
  case_49: /* CIL Label */ 
  {
#line 2540
  tmp___110 = strcmp((char const   *)*args, "always");
  }
#line 2540
  if (tmp___110) {
    {
#line 2542
    tmp___109 = strcmp((char const   *)*args, "attached");
    }
#line 2542
    if (tmp___109) {
      {
#line 2545
      ParseOnOff(act, & nwin_default.lflag);
      }
    } else {
#line 2543
      nwin_default.lflag &= -3;
    }
  } else {
#line 2541
    nwin_default.lflag |= 2;
  }
#line 2546
  goto switch_break;
  case_44: /* CIL Label */ 
#line 2549
  if (*(args + 0)) {
#line 2549
    if (*(args + 1)) {
#line 2549
      if ((int )*(*(args + 1) + 0) == 105) {
#line 2551
        iflag = 1;
#line 2552
        display = displays;
        {
#line 2552
        while (1) {
          while_continue___23: /* CIL Label */ ;
#line 2552
          if (! display) {
#line 2552
            goto while_break___23;
          }
#line 2554
          if (! display->d_flow) {
#line 2555
            goto __Cont___3;
          }
          {
#line 2557
          display->d_NewMode.tio.c_cc[0] = display->d_OldMode.tio.c_cc[0];
#line 2558
          display->d_NewMode.tio.c_lflag |= 1U;
#line 2562
          SetTTY(display->d_userfd, & display->d_NewMode);
          }
          __Cont___3: /* CIL Label */ 
#line 2552
          display = display->d_next;
        }
        while_break___23: /* CIL Label */ ;
        }
      }
    }
  }
#line 2565
  if (*(args + 0)) {
#line 2565
    if ((int )*(*(args + 0) + 0) == 97) {
#line 2566
      nwin_default.flowflag = 1 << 2;
    } else {
      {
#line 2568
      ParseOnOff(act, & nwin_default.flowflag);
      }
    }
  } else {
    {
#line 2568
    ParseOnOff(act, & nwin_default.flowflag);
    }
  }
#line 2569
  goto switch_break;
  case_59: /* CIL Label */ 
  {
#line 2571
  ParseOnOff(act, & nwin_default.wrap);
  }
#line 2572
  goto switch_break;
  case_40: /* CIL Label */ 
  {
#line 2574
  ParseOnOff(act, & nwin_default.c1);
  }
#line 2575
  goto switch_break;
  case_38: /* CIL Label */ 
  {
#line 2578
  ParseOnOff(act, & nwin_default.bce);
  }
#line 2579
  goto switch_break;
  case_45: /* CIL Label */ 
  {
#line 2582
  ParseOnOff(act, & nwin_default.gr);
  }
#line 2583
  goto switch_break;
  case_51: /* CIL Label */ 
  {
#line 2585
  tmp___111 = ParseOnOff(act, & n);
  }
#line 2585
  if (tmp___111 == 0) {
#line 2586
    if (n == 0) {
#line 2586
      nwin_default.monitor = 0;
    } else {
#line 2586
      nwin_default.monitor = 1;
    }
  }
#line 2587
  goto switch_break;
  case_56: /* CIL Label */ 
  {
#line 2589
  tmp___112 = ParseOnOff(act, & n);
  }
#line 2589
  if (tmp___112 == 0) {
#line 2590
    if (n == 0) {
#line 2590
      nwin_default.silence = 0;
    } else {
#line 2590
      nwin_default.silence = 1;
    }
  }
#line 2591
  goto switch_break;
  case_162: /* CIL Label */ 
#line 2593
  if (! *args) {
#line 2594
    if (VerboseCreate) {
#line 2594
      tmp___113 = "ill";
    } else {
#line 2594
      tmp___113 = "on\'t";
    }
    {
#line 2594
    Msg(0, (char *)"W%s echo command when creating windows.", tmp___113);
    }
  } else {
    {
#line 2596
    tmp___114 = ParseOnOff(act, & n);
    }
#line 2596
    if (tmp___114 == 0) {
#line 2597
      VerboseCreate = n;
    }
  }
#line 2598
  goto switch_break;
  case_78: /* CIL Label */ 
#line 2600
  if (display) {
    {
#line 2602
    Msg(0, (char *)"%s", "");
#line 2603
    RemoveStatus();
    }
  }
#line 2605
  if (*(args + 0)) {
    {
#line 2605
    tmp___121 = strcmp((char const   *)*(args + 0), "on");
    }
#line 2605
    if (tmp___121) {
      {
#line 2605
      tmp___122 = strcmp((char const   *)*(args + 0), "off");
      }
#line 2605
      if (tmp___122) {
        {
#line 2607
        olddisplay___0 = display;
#line 2608
        new_use = -1;
#line 2610
        s = *(args + 0);
#line 2611
        tmp___115 = strncmp((char const   *)s, "always", (size_t )6);
        }
#line 2611
        if (! tmp___115) {
#line 2612
          s += 6;
        }
        {
#line 2613
        tmp___119 = strcmp((char const   *)s, "lastline");
        }
#line 2613
        if (tmp___119) {
          {
#line 2615
          tmp___118 = strcmp((char const   *)s, "ignore");
          }
#line 2615
          if (tmp___118) {
            {
#line 2617
            tmp___117 = strcmp((char const   *)s, "message");
            }
#line 2617
            if (tmp___117) {
              {
#line 2619
              tmp___116 = strcmp((char const   *)*(args + 0), "string");
              }
#line 2619
              if (tmp___116) {
                {
#line 2631
                Msg(0, (char *)"%s: usage: hardstatus [always]lastline|ignore|message|string [string]",
                    rc_name);
                }
#line 2632
                goto switch_break;
              } else
#line 2621
              if (! *(args + 1)) {
                {
#line 2624
                AddXChars(buf___2, (int )sizeof(buf___2), hstatusstring);
#line 2625
                Msg(0, (char *)"hardstatus string is \'%s\'", buf___2);
                }
#line 2626
                goto switch_break;
              }
            } else {
#line 2618
              new_use = 2;
            }
          } else {
#line 2616
            new_use = 0;
          }
        } else {
#line 2614
          new_use = 1;
        }
#line 2634
        if (new_use != -1) {
#line 2636
          if ((unsigned long )s == (unsigned long )*(args + 0)) {
#line 2636
            tmp___120 = 0;
          } else {
#line 2636
            tmp___120 = 1 << 2;
          }
#line 2636
          hardstatusemu = new_use | tmp___120;
#line 2637
          display = displays;
          {
#line 2637
          while (1) {
            while_continue___24: /* CIL Label */ ;
#line 2637
            if (! display) {
#line 2637
              goto while_break___24;
            }
            {
#line 2639
            RemoveStatus();
#line 2640
            new_use = hardstatusemu & ~ (1 << 2);
            }
#line 2641
            if (display->d_tcs[75].flg) {
#line 2641
              if ((unsigned long )s == (unsigned long )*(args + 0)) {
#line 2642
                new_use = 3;
              }
            }
            {
#line 2643
            ShowHStatus((char *)0);
#line 2644
            old_use = display->d_has_hstatus;
#line 2645
            display->d_has_hstatus = new_use;
            }
#line 2646
            if (new_use == 1) {
#line 2646
              if (old_use != 1) {
                {
#line 2647
                ChangeScreenSize(display->d_width, display->d_height, 1);
                }
              } else {
#line 2646
                goto _L___12;
              }
            } else
            _L___12: /* CIL Label */ 
#line 2646
            if (new_use != 1) {
#line 2646
              if (old_use == 1) {
                {
#line 2647
                ChangeScreenSize(display->d_width, display->d_height, 1);
                }
              }
            }
            {
#line 2648
            RefreshHStatus();
#line 2637
            display = display->d_next;
            }
          }
          while_break___24: /* CIL Label */ ;
          }
        }
#line 2651
        if (*(args + 1)) {
#line 2653
          if (hstatusstring) {
            {
#line 2654
            free((void *)hstatusstring);
            }
          }
          {
#line 2655
          hstatusstring = SaveStr((char const   *)*(args + 1));
#line 2656
          display = displays;
          }
          {
#line 2656
          while (1) {
            while_continue___25: /* CIL Label */ ;
#line 2656
            if (! display) {
#line 2656
              goto while_break___25;
            }
            {
#line 2657
            RefreshHStatus();
#line 2656
            display = display->d_next;
            }
          }
          while_break___25: /* CIL Label */ ;
          }
        }
#line 2659
        display = olddisplay___0;
#line 2660
        goto switch_break;
      }
    }
  }
  {
#line 2662
  ParseSwitch(act, & use_hardstatus);
  }
#line 2663
  if (msgok) {
#line 2664
    if (use_hardstatus) {
#line 2664
      tmp___123 = "hardstatus line";
    } else {
#line 2664
      tmp___123 = "window";
    }
    {
#line 2664
    Msg(0, (char *)"messages displayed on %s", tmp___123);
    }
  }
#line 2665
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 2667
  tmp___125 = strcmp((char const   *)*(args + 0), "always");
  }
#line 2667
  if (tmp___125 == 0) {
#line 2667
    goto _L___13;
  } else {
    {
#line 2667
    tmp___126 = strcmp((char const   *)*(args + 0), "splitonly");
    }
#line 2667
    if (tmp___126 == 0) {
      _L___13: /* CIL Label */ 
#line 2669
      olddisplay___1 = display;
#line 2671
      captionalways = (int )*(*(args + 0) + 0) == 97;
#line 2672
      display = displays;
      {
#line 2672
      while (1) {
        while_continue___26: /* CIL Label */ ;
#line 2672
        if (! display) {
#line 2672
          goto while_break___26;
        }
        {
#line 2673
        ChangeScreenSize(display->d_width, display->d_height, 1);
#line 2672
        display = display->d_next;
        }
      }
      while_break___26: /* CIL Label */ ;
      }
#line 2674
      display = olddisplay___1;
    } else {
      {
#line 2676
      tmp___124 = strcmp((char const   *)*(args + 0), "string");
      }
#line 2676
      if (tmp___124 == 0) {
#line 2678
        if (! *(args + 1)) {
          {
#line 2681
          AddXChars(buf___3, (int )sizeof(buf___3), captionstring);
#line 2682
          Msg(0, (char *)"caption string is \'%s\'", buf___3);
          }
#line 2683
          goto switch_break;
        }
      } else {
        {
#line 2688
        Msg(0, (char *)"%s: usage: caption always|splitonly|string <string>", rc_name);
        }
#line 2689
        goto switch_break;
      }
    }
  }
#line 2691
  if (! *(args + 1)) {
#line 2692
    goto switch_break;
  }
#line 2693
  if (captionstring) {
    {
#line 2694
    free((void *)captionstring);
    }
  }
  {
#line 2695
  captionstring = SaveStr((char const   *)*(args + 1));
#line 2696
  RedisplayDisplays(0);
  }
#line 2697
  goto switch_break;
  case_33: /* CIL Label */ 
  {
#line 2699
  n = (unsigned long )console_window != (unsigned long )((struct win *)0);
#line 2700
  tmp___127 = ParseSwitch(act, & n);
  }
#line 2700
  if (tmp___127) {
#line 2701
    goto switch_break;
  }
  {
#line 2702
  tmp___128 = TtyGrabConsole(fore->w_ptyfd, n, rc_name);
  }
#line 2702
  if (tmp___128) {
#line 2703
    goto switch_break;
  }
#line 2704
  if (n == 0) {
    {
#line 2705
    Msg(0, (char *)"%s: releasing console %s", rc_name, HostName);
    }
  } else
#line 2706
  if (console_window) {
    {
#line 2707
    Msg(0, (char *)"%s: stealing console %s from window %d (%s)", rc_name, HostName,
        console_window->w_number, console_window->w_title);
    }
  } else {
    {
#line 2710
    Msg(0, (char *)"%s: grabbing console %s", rc_name, HostName);
    }
  }
#line 2711
  if (n) {
#line 2711
    console_window = fore;
  } else {
#line 2711
    console_window = (struct win *)0;
  }
#line 2712
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 2714
  tmp___129 = ParseOnOff(act, & all_norefresh);
  }
#line 2714
  if (tmp___129) {
#line 2715
    goto switch_break;
  }
#line 2716
  if (! all_norefresh) {
#line 2716
    if (fore) {
      {
#line 2717
      Activate(-1);
      }
    }
  }
#line 2718
  if (msgok) {
#line 2719
    if (all_norefresh) {
#line 2719
      tmp___130 = "No refresh on window change!\n";
    } else {
#line 2719
      tmp___130 = "Window specific refresh\n";
    }
    {
#line 2719
    Msg(0, (char *)tmp___130);
    }
  }
#line 2721
  goto switch_break;
  case_112: /* CIL Label */ 
  {
#line 2723
  ParseSwitch(act, & n);
#line 2724
  fore->w_norefresh = (char )n;
  }
#line 2725
  goto switch_break;
  case_159: /* CIL Label */ 
  {
#line 2727
  tmp___131 = ParseSwitch(act, & visual_bell);
  }
#line 2727
  if (tmp___131) {
#line 2728
    goto switch_break;
  } else
#line 2727
  if (! msgok) {
#line 2728
    goto switch_break;
  }
#line 2729
  if (visual_bell == 0) {
    {
#line 2730
    Msg(0, (char *)"switched to audible bell.");
    }
  } else {
    {
#line 2732
    Msg(0, (char *)"switched to visual bell.");
    }
  }
#line 2733
  goto switch_break;
  case_161: /* CIL Label */ 
  {
#line 2735
  tmp___132 = ParseNum1000(act, & VBellWait);
  }
#line 2735
  if (tmp___132 == 0) {
#line 2735
    if (msgok) {
      {
#line 2736
      Msg(0, (char *)"vbellwait set to %.10g seconds", (double )VBellWait / 1000.);
      }
    }
  }
#line 2737
  goto switch_break;
  case_103: /* CIL Label */ 
  {
#line 2739
  tmp___133 = ParseNum1000(act, & MsgWait);
  }
#line 2739
  if (tmp___133 == 0) {
#line 2739
    if (msgok) {
      {
#line 2740
      Msg(0, (char *)"msgwait set to %.10g seconds", (double )MsgWait / 1000.);
      }
    }
  }
#line 2741
  goto switch_break;
  case_102: /* CIL Label */ 
  {
#line 2743
  tmp___134 = ParseNum1000(act, & MsgMinWait);
  }
#line 2743
  if (tmp___134 == 0) {
#line 2743
    if (msgok) {
      {
#line 2744
      Msg(0, (char *)"msgminwait set to %.10g seconds", (double )MsgMinWait / 1000.);
      }
    }
  }
#line 2745
  goto switch_break;
  case_140: /* CIL Label */ 
  {
#line 2747
  tmp___135 = ParseNum(act, & SilenceWait);
  }
#line 2747
  if (tmp___135) {
#line 2748
    goto switch_break;
  }
#line 2749
  if (SilenceWait < 1) {
#line 2750
    SilenceWait = 1;
  }
#line 2751
  p = windows;
  {
#line 2751
  while (1) {
    while_continue___27: /* CIL Label */ ;
#line 2751
    if (! p) {
#line 2751
      goto while_break___27;
    }
#line 2752
    p->w_silencewait = SilenceWait;
#line 2751
    p = p->w_next;
  }
  while_break___27: /* CIL Label */ ;
  }
#line 2753
  if (msgok) {
    {
#line 2754
    Msg(0, (char *)"silencewait set to %d seconds", SilenceWait);
    }
  }
#line 2755
  goto switch_break;
  case_108: /* CIL Label */ 
#line 2757
  if ((unsigned long )*args == (unsigned long )((char *)0)) {
    {
#line 2758
    Msg(0, (char *)"This is window %d (%s).\n", fore->w_number, fore->w_title);
    }
  } else {
    {
#line 2761
    old = fore->w_number;
#line 2763
    tmp___136 = ParseNum(act, & n);
    }
#line 2763
    if (tmp___136) {
#line 2764
      goto switch_break;
    } else
#line 2763
    if (n >= maxwin) {
#line 2764
      goto switch_break;
    }
#line 2765
    p = wtab[n];
#line 2766
    wtab[n] = fore;
#line 2767
    fore->w_number = n;
#line 2768
    wtab[old] = p;
#line 2769
    if (p) {
#line 2770
      p->w_number = old;
    }
    {
#line 2773
    AclWinSwap(old, n);
    }
#line 2777
    if ((unsigned long )fore->w_slot != (unsigned long )((slot_t )-1)) {
#line 2777
      if ((unsigned long )fore->w_slot != (unsigned long )((slot_t )0)) {
        {
#line 2779
        RemoveUtmp(fore);
#line 2780
        SetUtmp(fore);
        }
      }
    }
#line 2782
    if (p) {
#line 2782
      if ((unsigned long )p->w_slot != (unsigned long )((slot_t )-1)) {
#line 2782
        if ((unsigned long )p->w_slot != (unsigned long )((slot_t )0)) {
#line 2785
          if (fore->w_layer.l_cvlist) {
#line 2785
            display = (fore->w_layer.l_cvlist)->c_display;
          } else {
#line 2785
            display = (struct display *)0;
          }
          {
#line 2786
          RemoveUtmp(p);
#line 2787
          SetUtmp(p);
          }
        }
      }
    }
    {
#line 2791
    WindowChanged(fore, 'n');
#line 2792
    WindowChanged((struct win *)0, 'w');
#line 2793
    WindowChanged((struct win *)0, 'W');
#line 2794
    WindowChanged((struct win *)0, 0);
    }
  }
#line 2796
  goto switch_break;
  case_139: /* CIL Label */ 
#line 2798
  n = fore->w_silence != 0;
#line 2799
  i = fore->w_silencewait;
#line 2800
  if (*(args + 0)) {
#line 2800
    if ((int )*(*(args + 0) + 0) == 45) {
#line 2800
      goto _L___15;
    } else
#line 2800
    if ((int )*(*(args + 0) + 0) >= 48) {
#line 2800
      if ((int )*(*(args + 0) + 0) <= 57) {
        _L___15: /* CIL Label */ 
        {
#line 2802
        tmp___137 = ParseNum(act, & i);
        }
#line 2802
        if (tmp___137) {
#line 2803
          goto switch_break;
        }
#line 2804
        n = i > 0;
      } else {
#line 2800
        goto _L___14;
      }
    } else {
#line 2800
      goto _L___14;
    }
  } else {
    _L___14: /* CIL Label */ 
    {
#line 2806
    tmp___138 = ParseSwitch(act, & n);
    }
#line 2806
    if (tmp___138) {
#line 2807
      goto switch_break;
    }
  }
#line 2808
  if (n) {
#line 2811
    if (display) {
#line 2812
      *(fore->w_lio_notify + ((display->d_user)->u_id >> 3)) = (unsigned char )((int )*(fore->w_lio_notify + ((display->d_user)->u_id >> 3)) | (128 >> ((display->d_user)->u_id & 7)));
    } else {
#line 2814
      n = 0;
      {
#line 2814
      while (1) {
        while_continue___28: /* CIL Label */ ;
#line 2814
        if (! (n < maxusercount)) {
#line 2814
          goto while_break___28;
        }
#line 2815
        *(fore->w_lio_notify + (n >> 3)) = (unsigned char )((int )*(fore->w_lio_notify + (n >> 3)) | (128 >> (n & 7)));
#line 2814
        n ++;
      }
      while_break___28: /* CIL Label */ ;
      }
    }
    {
#line 2817
    fore->w_silencewait = i;
#line 2818
    fore->w_silence = 1;
#line 2819
    SetTimeout(& fore->w_silenceev, fore->w_silencewait * 1000);
#line 2820
    evenq(& fore->w_silenceev);
    }
#line 2822
    if (! msgok) {
#line 2823
      goto switch_break;
    }
    {
#line 2824
    Msg(0, (char *)"The window is now being monitored for %d sec. silence.", fore->w_silencewait);
    }
  } else {
#line 2829
    if (display) {
#line 2830
      *(fore->w_lio_notify + ((display->d_user)->u_id >> 3)) = (unsigned char )((int )*(fore->w_lio_notify + ((display->d_user)->u_id >> 3)) & ~ (128 >> ((display->d_user)->u_id & 7)));
    } else {
#line 2833
      n = 0;
      {
#line 2833
      while (1) {
        while_continue___29: /* CIL Label */ ;
#line 2833
        if (! (n < maxusercount)) {
#line 2833
          goto while_break___29;
        }
#line 2834
        *(fore->w_lio_notify + (n >> 3)) = (unsigned char )((int )*(fore->w_lio_notify + (n >> 3)) & ~ (128 >> (n & 7)));
#line 2833
        n ++;
      }
      while_break___29: /* CIL Label */ ;
      }
    }
#line 2835
    i = maxusercount - 1;
    {
#line 2835
    while (1) {
      while_continue___30: /* CIL Label */ ;
#line 2835
      if (! (i >= 0)) {
#line 2835
        goto while_break___30;
      }
#line 2836
      if (*(fore->w_lio_notify + (i >> 3))) {
#line 2837
        goto while_break___30;
      }
#line 2835
      i --;
    }
    while_break___30: /* CIL Label */ ;
    }
#line 2838
    if (i < 0) {
      {
#line 2841
      fore->w_silence = 0;
#line 2842
      evdeq(& fore->w_silenceev);
      }
    }
#line 2844
    if (! msgok) {
#line 2845
      goto switch_break;
    }
    {
#line 2846
    Msg(0, (char *)"The window is no longer being monitored for silence.");
    }
  }
#line 2848
  goto switch_break;
  case_54: /* CIL Label */ 
  {
#line 2851
  ParseNum(act, & nwin_default.histheight);
  }
#line 2852
  goto switch_break;
  case_132: /* CIL Label */ 
  {
#line 2854
  ParseNum(act, & n);
#line 2855
  ChangeWindowSize(fore, fore->w_layer.l_width, fore->w_layer.l_height, n);
  }
#line 2856
  if (msgok) {
    {
#line 2857
    Msg(0, (char *)"scrollback set to %d", fore->w_histheight);
    }
  }
#line 2858
  goto switch_break;
  case_134: /* CIL Label */ 
#line 2861
  if ((unsigned long )*args == (unsigned long )((char *)0)) {
    {
#line 2862
    Msg(0, (char *)"This session is named \'%s\'\n", SockName);
    }
  } else {
    {
#line 2867
    s = (char *)0;
#line 2868
    tmp___139 = ParseSaveStr(act, & s);
    }
#line 2868
    if (tmp___139) {
#line 2869
      goto switch_break;
    }
#line 2870
    if (! *s) {
      {
#line 2872
      Msg(0, (char *)"%s: bad session name \'%s\'\n", rc_name, s);
#line 2873
      free((void *)s);
      }
#line 2874
      goto switch_break;
    } else {
      {
#line 2870
      tmp___140 = strlen((char const   *)s);
      }
#line 2870
      if ((long )tmp___140 + (SockName - SockPath) > 4083L) {
        {
#line 2872
        Msg(0, (char *)"%s: bad session name \'%s\'\n", rc_name, s);
#line 2873
        free((void *)s);
        }
#line 2874
        goto switch_break;
      } else {
        {
#line 2870
        tmp___141 = index((char const   *)s, '/');
        }
#line 2870
        if (tmp___141) {
          {
#line 2872
          Msg(0, (char *)"%s: bad session name \'%s\'\n", rc_name, s);
#line 2873
          free((void *)s);
          }
#line 2874
          goto switch_break;
        }
      }
    }
    {
#line 2876
    strncpy((char */* __restrict  */)(buf___4), (char const   */* __restrict  */)(SockPath),
            (size_t )(SockName - SockPath));
#line 2877
    tmp___142 = getpid();
#line 2877
    sprintf((char */* __restrict  */)(buf___4 + (SockName - SockPath)), (char const   */* __restrict  */)"%d.%s",
            tmp___142, s);
#line 2878
    free((void *)s);
#line 2879
    tmp___143 = access((char const   *)(buf___4), 0);
    }
#line 2879
    if (tmp___143 == 0) {
      {
#line 2881
      Msg(0, (char *)"%s: inappropriate path: \'%s\'.", rc_name, buf___4);
      }
#line 2882
      goto switch_break;
    } else {
      {
#line 2879
      tmp___144 = __errno_location();
      }
#line 2879
      if (*tmp___144 != 2) {
        {
#line 2881
        Msg(0, (char *)"%s: inappropriate path: \'%s\'.", rc_name, buf___4);
        }
#line 2882
        goto switch_break;
      }
    }
    {
#line 2884
    tmp___146 = rename((char const   *)(SockPath), (char const   *)(buf___4));
    }
#line 2884
    if (tmp___146) {
      {
#line 2886
      tmp___145 = __errno_location();
#line 2886
      Msg(*tmp___145, (char *)"%s: failed to rename(%s, %s)", rc_name, SockPath, buf___4);
      }
#line 2887
      goto switch_break;
    }
    {
#line 2889
    while (1) {
      while_continue___31: /* CIL Label */ ;
#line 2889
      goto while_break___31;
    }
    while_break___31: /* CIL Label */ ;
    }
    {
#line 2890
    strcpy((char */* __restrict  */)(SockPath), (char const   */* __restrict  */)(buf___4));
#line 2891
    MakeNewEnv();
    }
  }
#line 2893
  goto switch_break;
  case_135: /* CIL Label */ 
#line 2895
  if (! *(args + 0)) {
#line 2895
    goto _L___16;
  } else
#line 2895
  if (! *(args + 1)) {
    _L___16: /* CIL Label */ 
    {
#line 2897
    while (1) {
      while_continue___32: /* CIL Label */ ;
#line 2897
      goto while_break___32;
    }
    while_break___32: /* CIL Label */ ;
    }
    {
#line 2898
    InputSetenv(*(args + 0));
    }
  } else {
    {
#line 2902
    xsetenv(*(args + 0), *(args + 1));
#line 2903
    MakeNewEnv();
    }
  }
#line 2905
  goto switch_break;
  case_157: /* CIL Label */ 
  {
#line 2907
  unsetenv((char const   *)*args);
#line 2908
  MakeNewEnv();
  }
#line 2909
  goto switch_break;
  case_57: /* CIL Label */ 
  {
#line 2912
  ParseNum(act, & nwin_default.slow);
  }
#line 2913
  goto switch_break;
  case_142: /* CIL Label */ 
#line 2915
  if ((unsigned long )*args == (unsigned long )((char *)0)) {
#line 2916
    if (fore->w_slowpaste) {
#line 2916
      tmp___147 = "Slowpaste in window %d is %d milliseconds.";
    } else {
#line 2916
      tmp___147 = "Slowpaste in window %d is unset.";
    }
    {
#line 2916
    Msg(0, (char *)tmp___147, fore->w_number, fore->w_slowpaste);
    }
  } else {
    {
#line 2920
    tmp___149 = ParseNum(act, & fore->w_slowpaste);
    }
#line 2920
    if (tmp___149 == 0) {
#line 2920
      if (msgok) {
#line 2921
        if (fore->w_slowpaste) {
#line 2921
          tmp___148 = "Slowpaste in window %d set to %d milliseconds.";
        } else {
#line 2921
          tmp___148 = "Slowpaste in window %d now unset.";
        }
        {
#line 2921
        Msg(0, (char *)tmp___148, fore->w_number, fore->w_slowpaste);
        }
      }
    }
  }
#line 2925
  goto switch_break;
  case_98: /* CIL Label */ 
  {
#line 2927
  tmp___150 = CompileKeys(*args, *argl, mark_key_tab);
  }
#line 2927
  if (tmp___150) {
    {
#line 2929
    Msg(0, (char *)"%s: markkeys: syntax error.", rc_name);
    }
#line 2930
    goto switch_break;
  }
  {
#line 2932
  while (1) {
    while_continue___33: /* CIL Label */ ;
#line 2932
    goto while_break___33;
  }
  while_break___33: /* CIL Label */ ;
  }
#line 2933
  goto switch_break;
  case_115: /* CIL Label */ 
  {
#line 2936
  tmp___152 = ParseSwitch(act, & pastefont);
  }
#line 2936
  if (tmp___152 == 0) {
#line 2936
    if (msgok) {
#line 2937
      if (pastefont) {
#line 2937
        tmp___151 = "";
      } else {
#line 2937
        tmp___151 = "not ";
      }
      {
#line 2937
      Msg(0, (char *)"Will %spaste font settings", tmp___151);
      }
    }
  }
#line 2938
  goto switch_break;
  case_35___0: /* CIL Label */ 
  {
#line 2941
  ParseSwitch(act, & join_with_cr);
  }
#line 2942
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 2944
  tmp___154 = ParseSwitch(act, & compacthist);
  }
#line 2944
  if (tmp___154 == 0) {
#line 2944
    if (msgok) {
#line 2945
      if (compacthist) {
#line 2945
        tmp___153 = "";
      } else {
#line 2945
        tmp___153 = "not ";
      }
      {
#line 2945
      Msg(0, (char *)"%scompacting history lines", tmp___153);
      }
    }
  }
#line 2946
  goto switch_break;
  case_105: /* CIL Label */ 
  {
#line 2950
  ParseOnOff(act, & nethackflag);
  }
#line 2951
  goto switch_break;
  case_76: /* CIL Label */ 
  {
#line 2954
  ParseOnOff(act, & hardcopy_append);
  }
#line 2955
  goto switch_break;
  case_160: /* CIL Label */ 
#line 2957
  if ((unsigned long )*args == (unsigned long )((char *)0)) {
    {
#line 2960
    AddXChars(buf___5, (int )sizeof(buf___5), VisualBellString);
#line 2961
    Msg(0, (char *)"vbell_msg is \'%s\'", buf___5);
    }
#line 2962
    goto switch_break;
  }
  {
#line 2964
  ParseSaveStr(act, & VisualBellString);
  }
  {
#line 2965
  while (1) {
    while_continue___34: /* CIL Label */ ;
#line 2965
    goto while_break___34;
  }
  while_break___34: /* CIL Label */ ;
  }
#line 2966
  goto switch_break;
  case_50: /* CIL Label */ 
  {
#line 2968
  tmp___155 = ParseBase(act, *args, & n, 8, (char *)"octal");
  }
#line 2968
  if (tmp___155) {
#line 2969
    goto switch_break;
  }
#line 2970
  if (n < 0) {
    {
#line 2972
    Msg(0, (char *)"%s: mode: Invalid tty mode %o", rc_name, n);
    }
#line 2973
    goto switch_break;
  } else
#line 2970
  if (n > 511) {
    {
#line 2972
    Msg(0, (char *)"%s: mode: Invalid tty mode %o", rc_name, n);
    }
#line 2973
    goto switch_break;
  }
#line 2975
  TtyMode = n;
#line 2976
  if (msgok) {
    {
#line 2977
    Msg(0, (char *)"Ttymode set to %03o", TtyMode);
    }
  }
#line 2978
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 2980
  ParseOnOff(act, & auto_detach);
  }
#line 2981
  goto switch_break;
  case_146: /* CIL Label */ 
  {
#line 2983
  ParseOnOff(act, & default_startup);
  }
#line 2984
  goto switch_break;
  case_113: /* CIL Label */ 
#line 2987
  if (*args) {
#line 2989
    if (*(user->u_password)) {
#line 2989
      n = 1;
    } else {
#line 2989
      n = 0;
    }
#line 2990
    if ((unsigned long )user->u_password != (unsigned long )(NullStr)) {
      {
#line 2990
      free((void *)user->u_password);
      }
    }
    {
#line 2991
    user->u_password = SaveStr((char const   *)*args);
#line 2992
    tmp___156 = strcmp((char const   *)user->u_password, "none");
    }
#line 2992
    if (! tmp___156) {
#line 2994
      if (n) {
        {
#line 2995
        Msg(0, (char *)"Password checking disabled");
        }
      }
      {
#line 2996
      free((void *)user->u_password);
#line 2997
      user->u_password = NullStr;
      }
    }
  } else {
#line 3002
    if (! fore) {
      {
#line 3004
      Msg(0, (char *)"%s: password: window required", rc_name);
      }
#line 3005
      goto switch_break;
    }
#line 3007
    if (display) {
#line 3007
      tmp___157 = (char *)display->d_user;
    } else {
#line 3007
      tmp___157 = (char *)users;
    }
    {
#line 3007
    Input((char *)"New screen password:", 100, 1, & pass1, tmp___157);
    }
  }
#line 3009
  goto switch_break;
  case_17: /* CIL Label */ 
#line 3013
  ktabp___1 = ktab;
#line 3015
  if (argc > 2) {
    {
#line 3015
    tmp___158 = strcmp((char const   *)*args, "-c");
    }
#line 3015
    if (! tmp___158) {
      {
#line 3017
      ktabp___1 = FindKtab(*(args + 1), 1);
      }
#line 3018
      if ((unsigned long )ktabp___1 == (unsigned long )((struct action *)0)) {
#line 3019
        goto switch_break;
      }
#line 3020
      args += 2;
#line 3021
      argl += 2;
    }
  }
#line 3023
  if (*argl != 1) {
    {
#line 3025
    Msg(0, (char *)"%s: bind: character, ^x, or (octal) \\032 expected.", rc_name);
    }
#line 3026
    goto switch_break;
  }
#line 3028
  n = (int )((unsigned char )*(*(args + 0) + 0));
#line 3029
  if (*(args + 1)) {
    {
#line 3031
    i = FindCommnr(*(args + 1));
    }
#line 3031
    if (i == -1) {
      {
#line 3033
      Msg(0, (char *)"%s: bind: unknown command \'%s\'", rc_name, *(args + 1));
      }
#line 3034
      goto switch_break;
    }
    {
#line 3036
    tmp___159 = CheckArgNum(i, args + 2);
    }
#line 3036
    if (tmp___159 < 0) {
#line 3037
      goto switch_break;
    }
    {
#line 3038
    ClearAction(ktabp___1 + n);
#line 3039
    SaveAction(ktabp___1 + n, i, args + 2, argl + 2);
    }
  } else {
    {
#line 3042
    ClearAction(ktabp___1 + n);
    }
  }
#line 3044
  goto switch_break;
  case_18: /* CIL Label */ 
#line 3049
  fl = 0;
#line 3049
  kf = 0;
#line 3049
  af = 0;
#line 3049
  df = 0;
#line 3049
  mf = 0;
#line 3050
  odisp = display;
#line 3051
  used = 0;
  {
#line 3054
  while (1) {
    while_continue___35: /* CIL Label */ ;
#line 3054
    if (*args) {
#line 3054
      if (! ((int )*(*args) == 45)) {
#line 3054
        goto while_break___35;
      }
    } else {
#line 3054
      goto while_break___35;
    }
    {
#line 3056
    tmp___165 = strcmp((char const   *)*args, "-t");
    }
#line 3056
    if (tmp___165 == 0) {
#line 3057
      fl = 16384;
    } else {
      {
#line 3058
      tmp___164 = strcmp((char const   *)*args, "-k");
      }
#line 3058
      if (tmp___164 == 0) {
#line 3059
        kf = 1;
      } else {
        {
#line 3060
        tmp___163 = strcmp((char const   *)*args, "-a");
        }
#line 3060
        if (tmp___163 == 0) {
#line 3061
          af = 1;
        } else {
          {
#line 3062
          tmp___162 = strcmp((char const   *)*args, "-d");
          }
#line 3062
          if (tmp___162 == 0) {
#line 3063
            df = 1;
          } else {
            {
#line 3064
            tmp___161 = strcmp((char const   *)*args, "-m");
            }
#line 3064
            if (tmp___161 == 0) {
#line 3065
              mf = 1;
            } else {
              {
#line 3066
              tmp___160 = strcmp((char const   *)*args, "--");
              }
#line 3066
              if (tmp___160 == 0) {
#line 3068
                args ++;
#line 3069
                argl ++;
#line 3070
                goto while_break___35;
              } else {
                {
#line 3074
                Msg(0, (char *)"%s: bindkey: invalid option %s", rc_name, *args);
                }
#line 3075
                return;
              }
            }
          }
        }
      }
    }
#line 3054
    args ++;
#line 3054
    argl ++;
  }
  while_break___35: /* CIL Label */ ;
  }
#line 3078
  if (df) {
#line 3078
    if (mf) {
      {
#line 3080
      Msg(0, (char *)"%s: bindkey: -d does not work with -m", rc_name);
      }
#line 3081
      goto switch_break;
    }
  }
#line 3083
  if ((unsigned long )*args == (unsigned long )((char *)0)) {
#line 3085
    if (mf) {
      {
#line 3086
      display_bindkey((char *)"Edit mode", mmtab);
      }
    } else
#line 3087
    if (df) {
      {
#line 3088
      display_bindkey((char *)"Default", dmtab);
      }
    } else {
      {
#line 3090
      display_bindkey((char *)"User", umtab);
      }
    }
#line 3091
    goto switch_break;
  }
#line 3093
  if (kf == 0) {
#line 3095
    if (af) {
      {
#line 3097
      Msg(0, (char *)"%s: bindkey: -a only works with -k", rc_name);
      }
#line 3098
      goto switch_break;
    }
#line 3100
    if (*argl == 0) {
      {
#line 3102
      Msg(0, (char *)"%s: bindkey: empty string makes no sense", rc_name);
      }
#line 3103
      goto switch_break;
    }
#line 3105
    i = 0;
#line 3105
    kme = kmap_exts;
    {
#line 3105
    while (1) {
      while_continue___36: /* CIL Label */ ;
#line 3105
      if (! (i < kmap_extn)) {
#line 3105
        goto while_break___36;
      }
#line 3106
      if ((unsigned long )kme->str == (unsigned long )((char *)0)) {
#line 3108
        if (*(args + 1)) {
#line 3109
          goto while_break___36;
        }
      } else
#line 3112
      if (*argl == (kme->fl & -16385)) {
        {
#line 3112
        tmp___166 = bcmp((void const   *)kme->str, (void const   *)*args, (size_t )*argl);
        }
#line 3112
        if (tmp___166 == 0) {
#line 3113
          goto while_break___36;
        }
      }
#line 3105
      i ++;
#line 3105
      kme ++;
    }
    while_break___36: /* CIL Label */ ;
    }
#line 3114
    if (i == kmap_extn) {
#line 3116
      if (! *(args + 1)) {
        {
#line 3118
        Msg(0, (char *)"%s: bindkey: keybinding not found", rc_name);
        }
#line 3119
        goto switch_break;
      }
      {
#line 3121
      kmap_extn += 8;
#line 3122
      tmp___167 = xrealloc((char *)kmap_exts, (int )((unsigned long )kmap_extn * sizeof(*kmap_exts)));
#line 3122
      kmap_exts = (struct kmap_ext *)tmp___167;
#line 3123
      kme = kmap_exts + i;
#line 3124
      bzero((void *)((char *)kme), (size_t )(8UL * sizeof(*kmap_exts)));
      }
      {
#line 3125
      while (1) {
        while_continue___37: /* CIL Label */ ;
#line 3125
        if (! (i < kmap_extn)) {
#line 3125
          goto while_break___37;
        }
#line 3127
        kme->str = (char *)0;
#line 3128
        tmp___169 = -1;
#line 3128
        kme->um.nr = tmp___169;
#line 3128
        tmp___168 = tmp___169;
#line 3128
        kme->mm.nr = tmp___168;
#line 3128
        kme->dm.nr = tmp___168;
#line 3129
        tmp___171 = noargs;
#line 3129
        kme->um.args = tmp___171;
#line 3129
        tmp___170 = tmp___171;
#line 3129
        kme->mm.args = tmp___170;
#line 3129
        kme->dm.args = tmp___170;
#line 3125
        i ++;
#line 3125
        kme ++;
      }
      while_break___37: /* CIL Label */ ;
      }
#line 3131
      i -= 8;
#line 3132
      kme -= 8;
    }
#line 3134
    if (df == 0) {
#line 3134
      if (kme->dm.nr != -1) {
#line 3135
        used = 1;
      }
    }
#line 3136
    if (mf == 0) {
#line 3136
      if (kme->mm.nr != -1) {
#line 3137
        used = 1;
      }
    }
#line 3138
    if (df) {
#line 3138
      goto _L___17;
    } else
#line 3138
    if (mf) {
      _L___17: /* CIL Label */ 
#line 3138
      if (kme->um.nr != -1) {
#line 3139
        used = 1;
      }
    }
#line 3140
    i += 99;
#line 3141
    if (df) {
#line 3141
      newact = & kme->dm;
    } else {
#line 3141
      if (mf) {
#line 3141
        tmp___172 = & kme->mm;
      } else {
#line 3141
        tmp___172 = & kme->um;
      }
#line 3141
      newact = tmp___172;
    }
  } else {
#line 3145
    i = 106;
    {
#line 3145
    while (1) {
      while_continue___38: /* CIL Label */ ;
#line 3145
      if (! (i < 183)) {
#line 3145
        goto while_break___38;
      }
      {
#line 3146
      tmp___173 = strcmp((char const   *)term[i].tcname, (char const   *)*args);
      }
#line 3146
      if (tmp___173 == 0) {
#line 3147
        goto while_break___38;
      }
#line 3145
      i ++;
    }
    while_break___38: /* CIL Label */ ;
    }
#line 3148
    if (i == 183) {
      {
#line 3150
      Msg(0, (char *)"%s: bindkey: unknown key \'%s\'", rc_name, *args);
      }
#line 3151
      goto switch_break;
    }
#line 3153
    if (af) {
#line 3153
      if (i >= 161) {
#line 3153
        if (i < 183) {
#line 3154
          i -= 84;
        } else {
#line 3156
          i -= 106;
        }
      } else {
#line 3156
        i -= 106;
      }
    } else {
#line 3156
      i -= 106;
    }
#line 3157
    if (df) {
#line 3157
      newact = & dmtab[i];
    } else {
#line 3157
      if (mf) {
#line 3157
        tmp___174 = & mmtab[i];
      } else {
#line 3157
        tmp___174 = & umtab[i];
      }
#line 3157
      newact = tmp___174;
    }
  }
#line 3159
  if (*(args + 1)) {
    {
#line 3161
    newnr = FindCommnr(*(args + 1));
    }
#line 3161
    if (newnr == -1) {
      {
#line 3163
      Msg(0, (char *)"%s: bindkey: unknown command \'%s\'", rc_name, *(args + 1));
      }
#line 3164
      goto switch_break;
    }
    {
#line 3166
    tmp___175 = CheckArgNum(newnr, args + 2);
    }
#line 3166
    if (tmp___175 < 0) {
#line 3167
      goto switch_break;
    }
    {
#line 3168
    ClearAction(newact);
#line 3169
    SaveAction(newact, newnr, args + 2, argl + 2);
    }
#line 3170
    if (kf == 0) {
#line 3170
      if (*(args + 1)) {
#line 3172
        if (kme->str) {
          {
#line 3173
          free((void *)kme->str);
          }
        }
        {
#line 3174
        kme->str = SaveStrn((char const   *)*args, *argl);
#line 3175
        kme->fl = fl | *argl;
        }
      }
    }
  } else {
    {
#line 3179
    ClearAction(newact);
    }
  }
#line 3180
  display = displays;
  {
#line 3180
  while (1) {
    while_continue___39: /* CIL Label */ ;
#line 3180
    if (! display) {
#line 3180
      goto while_break___39;
    }
#line 3181
    if (*(args + 1)) {
#line 3181
      tmp___176 = 1;
    } else {
#line 3181
      tmp___176 = 0;
    }
    {
#line 3181
    remap(i, tmp___176);
#line 3180
    display = display->d_next;
    }
  }
  while_break___39: /* CIL Label */ ;
  }
#line 3182
  if (kf == 0) {
#line 3182
    if (! *(args + 1)) {
#line 3184
      if (! used) {
#line 3184
        if (kme->str) {
          {
#line 3186
          free((void *)kme->str);
#line 3187
          kme->str = (char *)0;
#line 3188
          kme->fl = 0;
          }
        }
      }
    }
  }
#line 3191
  display = odisp;
#line 3193
  goto switch_break;
  case_97: /* CIL Label */ 
#line 3195
  if (*args) {
    {
#line 3197
    tmp___177 = ParseNum(act, & n);
    }
#line 3197
    if (tmp___177) {
#line 3198
      goto switch_break;
    }
#line 3199
    if (n < 0) {
      {
#line 3201
      Msg(0, (char *)"%s: maptimeout: illegal time %d", rc_name, n);
      }
#line 3202
      goto switch_break;
    }
#line 3204
    maptimeout = n;
  }
#line 3206
  if ((unsigned long )*args == (unsigned long )((char *)0)) {
    {
#line 3207
    Msg(0, (char *)"maptimeout is %dms", maptimeout);
    }
  } else
#line 3206
  if (msgok) {
    {
#line 3207
    Msg(0, (char *)"maptimeout is %dms", maptimeout);
    }
  }
#line 3208
  goto switch_break;
  case_96: /* CIL Label */ 
#line 3210
  display->d_dontmap = 1;
#line 3211
  goto switch_break;
  case_95: /* CIL Label */ 
#line 3213
  display->d_mapdefault = 1;
#line 3214
  goto switch_break;
  case_26: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_0: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 3221
  UsersAcl((struct acluser *)((void *)0), argc, args);
  }
#line 3222
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 3224
  tmp___178 = UserDel(*(args + 0), (struct acluser **)((void *)0));
  }
#line 3224
  if (tmp___178) {
#line 3225
    goto switch_break;
  }
#line 3226
  if (msgok) {
    {
#line 3227
    Msg(0, (char *)"%s removed from acl database", *(args + 0));
    }
  }
#line 3228
  goto switch_break;
  case_3: /* CIL Label */ 
#line 3235
  if (*(args + 1)) {
    {
#line 3237
    tmp___181 = strcmp((char const   *)*(args + 1), "none");
    }
#line 3237
    if (tmp___181) {
      {
#line 3239
      tmp___179 = AclLinkUser(*(args + 0), *(args + 1));
      }
#line 3239
      if (tmp___179) {
#line 3240
        goto switch_break;
      }
#line 3241
      if (msgok) {
        {
#line 3242
        Msg(0, (char *)"User %s joined acl-group %s", *(args + 0), *(args + 1));
        }
      }
    } else {
      {
#line 3249
      tmp___180 = FindUserPtr(*(args + 0));
#line 3249
      u___0 = *tmp___180;
      }
#line 3249
      if (! u___0) {
#line 3250
        goto switch_break;
      }
      {
#line 3251
      while (1) {
        while_continue___40: /* CIL Label */ ;
#line 3251
        g = u___0->u_group;
#line 3251
        if (! g) {
#line 3251
          goto while_break___40;
        }
        {
#line 3253
        u___0->u_group = g->next;
#line 3254
        free((void *)((char *)g));
        }
      }
      while_break___40: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 3260
    p___0 = buf___6;
#line 3261
    ngroups = 0;
#line 3265
    tmp___182 = FindUserPtr(*(args + 0));
#line 3265
    u___1 = *tmp___182;
    }
#line 3265
    if (! u___1) {
#line 3267
      if (msgok) {
        {
#line 3268
        Msg(0, (char *)"User %s does not exist.", *(args + 0));
        }
      }
#line 3269
      goto switch_break;
    }
#line 3271
    g___0 = u___1->u_group;
    {
#line 3272
    while (1) {
      while_continue___41: /* CIL Label */ ;
#line 3272
      if (! g___0) {
#line 3272
        goto while_break___41;
      }
      {
#line 3274
      ngroups ++;
#line 3275
      sprintf((char */* __restrict  */)p___0, (char const   */* __restrict  */)"%s ",
              (g___0->u)->u_name);
#line 3276
      tmp___183 = strlen((char const   *)p___0);
#line 3276
      p___0 += tmp___183;
      }
#line 3277
      if ((unsigned long )p___0 > (unsigned long )(buf___6 + 200)) {
#line 3278
        goto while_break___41;
      }
#line 3279
      g___0 = g___0->next;
    }
    while_break___41: /* CIL Label */ ;
    }
#line 3281
    if (ngroups) {
#line 3282
      p___0 --;
#line 3282
      *p___0 = (char )'\000';
    }
#line 3283
    if (ngroups == 0) {
#line 3283
      tmp___184 = "none";
    } else {
#line 3283
      tmp___184 = (char const   *)(buf___6);
    }
#line 3283
    if (ngroups == 1) {
#line 3283
      tmp___185 = "";
    } else {
#line 3283
      tmp___185 = "s";
    }
    {
#line 3283
    Msg(0, (char *)"%s\'s group%s: %s.", *(args + 0), tmp___185, tmp___184);
    }
  }
#line 3286
  goto switch_break;
  case_156: /* CIL Label */ 
  case_4: /* CIL Label */ 
  {
#line 3289
  while (1) {
    while_continue___42: /* CIL Label */ ;
#line 3289
    tmp___188 = args;
#line 3289
    args ++;
#line 3289
    s = *tmp___188;
#line 3289
    if (! s) {
#line 3289
      goto while_break___42;
    }
#line 3291
    err = (char *)0;
#line 3293
    if (display) {
#line 3293
      tmp___186 = display->d_user;
    } else {
#line 3293
      tmp___186 = users;
    }
    {
#line 3293
    tmp___187 = AclUmask(tmp___186, s, & err);
    }
#line 3293
    if (tmp___187) {
      {
#line 3294
      Msg(0, (char *)"umask: %s\n", err);
      }
    }
  }
  while_break___42: /* CIL Label */ ;
  }
#line 3296
  goto switch_break;
  case_104: /* CIL Label */ 
  {
#line 3298
  tmp___189 = ParseOnOff(act, & n);
  }
#line 3298
  if (tmp___189) {
#line 3299
    goto switch_break;
  }
#line 3300
  if (n) {
#line 3300
    multi = (char *)"";
  } else {
#line 3300
    multi = (char *)0;
  }
  {
#line 3301
  chsock();
  }
#line 3302
  if (msgok) {
#line 3303
    if (multi) {
#line 3303
      tmp___190 = "enabled";
    } else {
#line 3303
      tmp___190 = "disabled";
    }
    {
#line 3303
    Msg(0, (char *)"Multiuser mode %s", tmp___190);
    }
  }
#line 3304
  goto switch_break;
  case_70: /* CIL Label */ 
  {
#line 3308
  winexec(args);
  }
#line 3309
  goto switch_break;
  case_107: /* CIL Label */ 
#line 3313
  i = display->d_nonblock >= 0;
#line 3314
  if (*args) {
#line 3314
    if ((int )*(*(args + 0) + 0) >= 48) {
#line 3314
      if ((int )*(*(args + 0) + 0) <= 57) {
#line 3314
        goto _L___19;
      } else {
#line 3314
        goto _L___20;
      }
    } else
    _L___20: /* CIL Label */ 
#line 3314
    if ((int )*(*(args + 0) + 0) == 46) {
      _L___19: /* CIL Label */ 
      {
#line 3316
      tmp___191 = ParseNum1000(act, & i);
      }
#line 3316
      if (tmp___191) {
#line 3317
        goto switch_break;
      }
    } else {
#line 3314
      goto _L___18;
    }
  } else {
    _L___18: /* CIL Label */ 
    {
#line 3319
    tmp___192 = ParseSwitch(act, & i);
    }
#line 3319
    if (tmp___192) {
#line 3322
      goto switch_break;
    } else
#line 3320
    if (i == 0) {
#line 3320
      i = -1;
    } else {
#line 3320
      i = 1000;
    }
  }
#line 3323
  if (msgok) {
#line 3323
    if (i == -1) {
      {
#line 3324
      Msg(0, (char *)"display set to blocking mode");
      }
    } else {
#line 3323
      goto _L___22;
    }
  } else
  _L___22: /* CIL Label */ 
#line 3325
  if (msgok) {
#line 3325
    if (i == 0) {
      {
#line 3326
      Msg(0, (char *)"display set to nonblocking mode, no timeout");
      }
    } else {
#line 3325
      goto _L___21;
    }
  } else
  _L___21: /* CIL Label */ 
#line 3327
  if (msgok) {
    {
#line 3328
    Msg(0, (char *)"display set to nonblocking mode, %.10gs timeout", (double )i / 1000.);
    }
  }
#line 3329
  display->d_nonblock = i;
#line 3330
  if (display->d_nonblock <= 0) {
    {
#line 3331
    evdeq(& display->d_blockedev);
    }
  }
#line 3332
  goto switch_break;
  case_52: /* CIL Label */ 
#line 3334
  if (*args) {
#line 3334
    if ((int )*(*(args + 0) + 0) >= 48) {
#line 3334
      if ((int )*(*(args + 0) + 0) <= 57) {
#line 3334
        goto _L___24;
      } else {
#line 3334
        goto _L___25;
      }
    } else
    _L___25: /* CIL Label */ 
#line 3334
    if ((int )*(*(args + 0) + 0) == 46) {
      _L___24: /* CIL Label */ 
      {
#line 3336
      tmp___193 = ParseNum1000(act, & defnonblock);
      }
#line 3336
      if (tmp___193) {
#line 3337
        goto switch_break;
      }
    } else {
#line 3334
      goto _L___23;
    }
  } else {
    _L___23: /* CIL Label */ 
    {
#line 3339
    tmp___194 = ParseOnOff(act, & defnonblock);
    }
#line 3339
    if (tmp___194) {
#line 3342
      goto switch_break;
    } else
#line 3340
    if (defnonblock == 0) {
#line 3340
      defnonblock = -1;
    } else {
#line 3340
      defnonblock = 1000;
    }
  }
#line 3343
  if (display) {
#line 3343
    if (*rc_name) {
#line 3345
      display->d_nonblock = defnonblock;
#line 3346
      if (display->d_nonblock <= 0) {
        {
#line 3347
        evdeq(& display->d_blockedev);
        }
      }
    }
  }
#line 3349
  goto switch_break;
  case_74: /* CIL Label */ 
#line 3353
  if (fore->w_gr == 2) {
#line 3354
    fore->w_gr = 0;
  }
  {
#line 3356
  tmp___196 = ParseSwitch(act, & fore->w_gr);
  }
#line 3356
  if (tmp___196 == 0) {
#line 3356
    if (msgok) {
#line 3357
      if (fore->w_gr) {
#line 3357
        tmp___195 = "";
      } else {
#line 3357
        tmp___195 = "not ";
      }
      {
#line 3357
      Msg(0, (char *)"Will %suse GR", tmp___195);
      }
    }
  }
#line 3359
  if (fore->w_gr == 0) {
#line 3359
    if (fore->w_FontE) {
#line 3360
      fore->w_gr = 2;
    }
  }
#line 3362
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 3364
  tmp___198 = ParseSwitch(act, & fore->w_c1);
  }
#line 3364
  if (tmp___198 == 0) {
#line 3364
    if (msgok) {
#line 3365
      if (fore->w_c1) {
#line 3365
        tmp___197 = "";
      } else {
#line 3365
        tmp___197 = "not ";
      }
      {
#line 3365
      Msg(0, (char *)"Will %suse C1", tmp___197);
      }
    }
  }
#line 3366
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 3369
  tmp___200 = ParseSwitch(act, & fore->w_bce);
  }
#line 3369
  if (tmp___200 == 0) {
#line 3369
    if (msgok) {
#line 3370
      if (fore->w_bce) {
#line 3370
        tmp___199 = "";
      } else {
#line 3370
        tmp___199 = "not ";
      }
      {
#line 3370
      Msg(0, (char *)"Will %serase with background color", tmp___199);
      }
    }
  }
#line 3371
  goto switch_break;
  case_67: /* CIL Label */ 
  case_86: /* CIL Label */ 
#line 3377
  if (*args) {
    {
#line 3377
    tmp___202 = strcmp((char const   *)*(args + 0), "-d");
    }
#line 3377
    if (! tmp___202) {
#line 3379
      if (! *(args + 1)) {
#line 3380
        if (screenencodings) {
#line 3380
          tmp___201 = (char const   *)screenencodings;
        } else {
#line 3380
          tmp___201 = "<unset>";
        }
        {
#line 3380
        Msg(0, (char *)"encodings directory is %s", tmp___201);
        }
      } else {
        {
#line 3383
        free((void *)screenencodings);
#line 3384
        screenencodings = SaveStr((char const   *)*(args + 1));
        }
      }
#line 3386
      goto switch_break;
    }
  }
#line 3388
  if (*args) {
    {
#line 3388
    tmp___204 = strcmp((char const   *)*(args + 0), "-l");
    }
#line 3388
    if (! tmp___204) {
#line 3390
      if (! *(args + 1)) {
        {
#line 3391
        Msg(0, (char *)"encoding: -l: argument required");
        }
      } else {
        {
#line 3392
        tmp___203 = LoadFontTranslation(-1, *(args + 1));
        }
#line 3392
        if (tmp___203) {
          {
#line 3393
          Msg(0, (char *)"encoding: could not load utf8 encoding file");
          }
        } else
#line 3394
        if (msgok) {
          {
#line 3395
          Msg(0, (char *)"encoding: utf8 encoding file loaded");
          }
        }
      }
#line 3396
      goto switch_break;
    }
  }
#line 3406
  i = 0;
  {
#line 3406
  while (1) {
    while_continue___43: /* CIL Label */ ;
#line 3406
    if (! (i < 2)) {
#line 3406
      goto while_break___43;
    }
#line 3408
    if ((unsigned long )*(args + i) == (unsigned long )((char *)0)) {
#line 3409
      goto while_break___43;
    }
    {
#line 3410
    tmp___205 = strcmp((char const   *)*(args + i), ".");
    }
#line 3410
    if (! tmp___205) {
#line 3411
      goto __Cont___4;
    }
    {
#line 3412
    n = FindEncoding(*(args + i));
    }
#line 3413
    if (n == -1) {
      {
#line 3415
      Msg(0, (char *)"encoding: unknown encoding \'%s\'", *(args + i));
      }
#line 3416
      goto while_break___43;
    }
#line 3418
    if (i == 0) {
#line 3418
      if (fore) {
        {
#line 3420
        WinSwitchEncoding(fore, n);
#line 3421
        ResetCharsets(fore);
        }
      } else {
#line 3418
        goto _L___26;
      }
    } else
    _L___26: /* CIL Label */ 
#line 3423
    if (i) {
#line 3423
      if (display) {
#line 3424
        display->d_encoding = n;
      }
    }
    __Cont___4: /* CIL Label */ 
#line 3406
    i ++;
  }
  while_break___43: /* CIL Label */ ;
  }
#line 3426
  goto switch_break;
  case_42___0: /* CIL Label */ 
  case_47: /* CIL Label */ 
  {
#line 3429
  n = FindEncoding(*args);
  }
#line 3430
  if (n == -1) {
    {
#line 3432
    Msg(0, (char *)"defencoding: unknown encoding \'%s\'", *args);
    }
#line 3433
    goto switch_break;
  }
#line 3435
  nwin_default.encoding = n;
#line 3436
  goto switch_break;
  case_58: /* CIL Label */ 
  {
#line 3441
  n = nwin_default.encoding == 8;
#line 3442
  tmp___207 = ParseSwitch(act, & n);
  }
#line 3442
  if (tmp___207 == 0) {
#line 3444
    if (n) {
#line 3444
      nwin_default.encoding = 8;
    } else {
#line 3444
      nwin_default.encoding = 0;
    }
#line 3445
    if (msgok) {
#line 3446
      if (n) {
#line 3446
        tmp___206 = "";
      } else {
#line 3446
        tmp___206 = "not ";
      }
      {
#line 3446
      Msg(0, (char *)"Will %suse UTF-8 encoding for new windows", tmp___206);
      }
    }
  }
#line 3448
  goto switch_break;
  case_158: /* CIL Label */ 
#line 3450
  i = 0;
  {
#line 3450
  while (1) {
    while_continue___44: /* CIL Label */ ;
#line 3450
    if (! (i < 2)) {
#line 3450
      goto while_break___44;
    }
#line 3452
    if (i) {
#line 3452
      if ((unsigned long )*(args + i) == (unsigned long )((char *)0)) {
#line 3453
        goto while_break___44;
      }
    }
#line 3454
    if ((unsigned long )*(args + i) == (unsigned long )((char *)0)) {
#line 3455
      n = fore->w_layer.l_encoding != 8;
    } else {
      {
#line 3456
      tmp___209 = strcmp((char const   *)*(args + i), "off");
      }
#line 3456
      if (tmp___209 == 0) {
#line 3457
        n = 0;
      } else {
        {
#line 3458
        tmp___208 = strcmp((char const   *)*(args + i), "on");
        }
#line 3458
        if (tmp___208 == 0) {
#line 3459
          n = 1;
        } else {
          {
#line 3462
          Msg(0, (char *)"utf8: illegal argument (%s)", *(args + i));
          }
#line 3463
          goto while_break___44;
        }
      }
    }
#line 3465
    if (i == 0) {
#line 3467
      if (n) {
#line 3467
        tmp___210 = 8;
      } else {
#line 3467
        tmp___210 = 0;
      }
      {
#line 3467
      WinSwitchEncoding(fore, tmp___210);
      }
#line 3468
      if (msgok) {
#line 3469
        if (n) {
#line 3469
          tmp___211 = "";
        } else {
#line 3469
          tmp___211 = "not ";
        }
        {
#line 3469
        Msg(0, (char *)"Will %suse UTF-8 encoding", tmp___211);
        }
      }
    } else
#line 3471
    if (display) {
#line 3472
      if (n) {
#line 3472
        display->d_encoding = 8;
      } else {
#line 3472
        display->d_encoding = 0;
      }
    }
#line 3473
    if ((unsigned long )*(args + i) == (unsigned long )((char *)0)) {
#line 3474
      goto while_break___44;
    }
#line 3450
    i ++;
  }
  while_break___44: /* CIL Label */ ;
  }
#line 3476
  goto switch_break;
  case_120: /* CIL Label */ 
#line 3480
  if (*args) {
#line 3482
    if (printcmd) {
      {
#line 3483
      free((void *)printcmd);
      }
    }
#line 3484
    printcmd = (char *)0;
#line 3485
    if (*(*args)) {
      {
#line 3486
      printcmd = SaveStr((char const   *)*args);
      }
    }
  }
#line 3488
  if ((unsigned long )*args == (unsigned long )((char *)0)) {
#line 3488
    goto _L___27;
  } else
#line 3488
  if (msgok) {
    _L___27: /* CIL Label */ 
#line 3490
    if (printcmd) {
      {
#line 3491
      Msg(0, (char *)"using \'%s\' as print command", printcmd);
      }
    } else {
      {
#line 3493
      Msg(0, (char *)"using termcap entries for printing");
      }
    }
#line 3494
    goto switch_break;
  }
#line 3496
  goto switch_break;
  case_62: /* CIL Label */ 
  {
#line 3499
  Input((char *)"Enter digraph: ", 10, 4, & digraph_fn, (char *)((void *)0));
  }
#line 3500
  if (*args) {
#line 3500
    if (*(*args)) {
      {
#line 3502
      s = *args;
#line 3503
      tmp___212 = strlen((char const   *)s);
#line 3503
      n = (int )tmp___212;
#line 3504
      (*((flayer->l_layfn)->lf_LayProcess))(& s, & n);
      }
    }
  }
#line 3506
  goto switch_break;
  case_46: /* CIL Label */ 
#line 3509
  if ((unsigned long )*args == (unsigned long )((char *)0)) {
#line 3512
    buf___7[0] = (char)0;
#line 3513
    if (nwin_default.hstatus) {
      {
#line 3514
      AddXChars(buf___7, (int )sizeof(buf___7), nwin_default.hstatus);
      }
    }
    {
#line 3515
    Msg(0, (char *)"default hstatus is \'%s\'", buf___7);
    }
#line 3516
    goto switch_break;
  }
  {
#line 3518
  ParseSaveStr(act, & nwin_default.hstatus);
  }
#line 3519
  if ((int )*(nwin_default.hstatus) == 0) {
    {
#line 3521
    free((void *)nwin_default.hstatus);
#line 3522
    nwin_default.hstatus = (char *)0;
    }
  }
#line 3524
  goto switch_break;
  case_82: /* CIL Label */ 
  {
#line 3526
  ParseSaveStr(act, & fore->w_hstatus);
  }
#line 3527
  if ((int )*(fore->w_hstatus) == 0) {
    {
#line 3529
    free((void *)fore->w_hstatus);
#line 3530
    fore->w_hstatus = (char *)0;
    }
  }
  {
#line 3532
  WindowChanged(fore, 'h');
  }
#line 3533
  goto switch_break;
  case_27: /* CIL Label */ 
  case_41: /* CIL Label */ 
#line 3538
  if ((unsigned long )*args == (unsigned long )((char *)0)) {
#line 3541
    buf___8[0] = (char)0;
#line 3542
    if (nwin_default.charset) {
      {
#line 3543
      AddXChars(buf___8, (int )sizeof(buf___8), nwin_default.charset);
      }
    }
    {
#line 3544
    Msg(0, (char *)"default charset is \'%s\'", buf___8);
    }
#line 3545
    goto switch_break;
  }
  {
#line 3547
  tmp___213 = strlen((char const   *)*args);
#line 3547
  n = (int )tmp___213;
  }
#line 3548
  if (n == 0) {
    {
#line 3550
    Msg(0, (char *)"%s: %s: string has illegal size.", rc_name, comms[nr].name);
    }
#line 3551
    goto switch_break;
  } else
#line 3548
  if (n > 6) {
    {
#line 3550
    Msg(0, (char *)"%s: %s: string has illegal size.", rc_name, comms[nr].name);
    }
#line 3551
    goto switch_break;
  }
#line 3553
  if (n > 4) {
#line 3553
    if ((int )*(*(args + 0) + 4) < 48) {
#line 3553
      goto _L___30;
    } else
#line 3553
    if ((int )*(*(args + 0) + 4) > 51) {
      _L___30: /* CIL Label */ 
#line 3553
      if ((int )*(*(args + 0) + 4) != 46) {
        {
#line 3557
        Msg(0, (char *)"%s: %s: illegal mapping number.", rc_name, comms[nr].name);
        }
#line 3558
        goto switch_break;
      } else {
#line 3553
        goto _L___29;
      }
    } else
    _L___29: /* CIL Label */ 
#line 3553
    if ((int )*(*(args + 0) + 5) < 48) {
#line 3553
      goto _L___28;
    } else
#line 3553
    if ((int )*(*(args + 0) + 5) > 51) {
      _L___28: /* CIL Label */ 
#line 3553
      if (*(*(args + 0) + 5)) {
#line 3553
        if ((int )*(*(args + 0) + 5) != 46) {
          {
#line 3557
          Msg(0, (char *)"%s: %s: illegal mapping number.", rc_name, comms[nr].name);
          }
#line 3558
          goto switch_break;
        }
      }
    }
  }
#line 3560
  if (nr == 27) {
    {
#line 3562
    SetCharsets(fore, *args);
    }
#line 3563
    goto switch_break;
  }
#line 3565
  if (nwin_default.charset) {
    {
#line 3566
    free((void *)nwin_default.charset);
    }
  }
  {
#line 3567
  nwin_default.charset = SaveStr((char const   *)*args);
  }
#line 3568
  goto switch_break;
  case_10: /* CIL Label */ 
#line 3572
  s = *(args + 0);
#line 3573
  if ((int )*s >= 48) {
#line 3573
    if ((int )*s <= 57) {
#line 3574
      i = (int )*s - 48;
    } else {
#line 3573
      goto _L___31;
    }
  } else {
    _L___31: /* CIL Label */ 
#line 3576
    i = 0;
    {
#line 3576
    while (1) {
      while_continue___45: /* CIL Label */ ;
#line 3576
      if (! (i < 8)) {
#line 3576
        goto while_break___45;
      }
#line 3577
      if ((int )*s == (int )*("dubrsBiI" + i)) {
#line 3578
        goto while_break___45;
      }
#line 3576
      i ++;
    }
    while_break___45: /* CIL Label */ ;
    }
  }
#line 3579
  s ++;
#line 3580
  nr = 0;
#line 3581
  if (*s) {
#line 3581
    if (*(s + 1)) {
#line 3581
      if (! *(s + 2)) {
#line 3583
        if ((int )*s == 100) {
#line 3583
          if ((int )*(s + 1) == 100) {
#line 3584
            nr = 3;
          } else {
#line 3583
            goto _L___34;
          }
        } else
        _L___34: /* CIL Label */ 
#line 3585
        if ((int )*s == 46) {
#line 3585
          if ((int )*(s + 1) == 100) {
#line 3586
            nr = 2;
          } else {
#line 3585
            goto _L___33;
          }
        } else
        _L___33: /* CIL Label */ 
#line 3587
        if ((int )*s == 100) {
#line 3587
          if ((int )*(s + 1) == 46) {
#line 3588
            nr = 1;
          } else {
#line 3587
            goto _L___32;
          }
        } else
        _L___32: /* CIL Label */ 
#line 3589
        if ((int )*s != 46) {
#line 3590
          s --;
        } else
#line 3589
        if ((int )*(s + 1) != 46) {
#line 3590
          s --;
        }
#line 3591
        s += 2;
      }
    }
  }
#line 3593
  if (*s) {
    {
#line 3595
    Msg(0, (char *)"%s: attrcolor: unknown attribute \'%s\'.", rc_name, *(args + 0));
    }
#line 3596
    goto switch_break;
  } else
#line 3593
  if (i < 0) {
    {
#line 3595
    Msg(0, (char *)"%s: attrcolor: unknown attribute \'%s\'.", rc_name, *(args + 0));
    }
#line 3596
    goto switch_break;
  } else
#line 3593
  if (i >= 8) {
    {
#line 3595
    Msg(0, (char *)"%s: attrcolor: unknown attribute \'%s\'.", rc_name, *(args + 0));
    }
#line 3596
    goto switch_break;
  }
#line 3598
  n = 0;
#line 3599
  if (*(args + 1)) {
    {
#line 3600
    n = ParseAttrColor(*(args + 1), *(args + 2), 1);
    }
  }
#line 3601
  if (n == -1) {
#line 3602
    goto switch_break;
  }
#line 3603
  attr2color[i][nr] = n;
#line 3604
  n = 0;
#line 3605
  i = 0;
  {
#line 3605
  while (1) {
    while_continue___46: /* CIL Label */ ;
#line 3605
    if (! (i < 8)) {
#line 3605
      goto while_break___46;
    }
#line 3606
    if (attr2color[i][0]) {
#line 3607
      n |= 1 << i;
    } else
#line 3606
    if (attr2color[i][1]) {
#line 3607
      n |= 1 << i;
    } else
#line 3606
    if (attr2color[i][2]) {
#line 3607
      n |= 1 << i;
    } else
#line 3606
    if (attr2color[i][3]) {
#line 3607
      n |= 1 << i;
    }
#line 3605
    i ++;
  }
  while_break___46: /* CIL Label */ ;
  }
#line 3608
  nattr2color = n;
#line 3609
  goto switch_break;
  case_143: /* CIL Label */ 
#line 3612
  i = 0;
#line 3613
  if (*args) {
    {
#line 3615
    i = ParseAttrColor(*args, *(args + 1), 1);
    }
#line 3616
    if (i == -1) {
#line 3617
      goto switch_break;
    }
    {
#line 3618
    ApplyAttrColor(i, & mchar_so);
    }
    {
#line 3619
    while (1) {
      while_continue___47: /* CIL Label */ ;
#line 3619
      goto while_break___47;
    }
    while_break___47: /* CIL Label */ ;
    }
  }
#line 3621
  if (msgok) {
    {
#line 3623
    Msg(0, (char *)"Standout attributes 0x%02x  color 0x%02x", (int )mchar_so.attr,
        153 ^ (int )mchar_so.color);
    }
  }
#line 3627
  goto switch_break;
  case_144: /* CIL Label */ 
  {
#line 3630
  do_source(*args);
  }
#line 3631
  goto switch_break;
  case_148: /* CIL Label */ 
#line 3635
  s = (char *)((void *)0);
#line 3636
  if (! *args) {
    {
#line 3638
    Msg(0, (char *)"%s:%s screen login", HostName, SockPath);
#line 3639
    InputSu(display->d_fore, & display->d_user, (char *)((void *)0));
    }
  } else
#line 3641
  if (! *(args + 1)) {
    {
#line 3642
    InputSu(display->d_fore, & display->d_user, *(args + 0));
    }
  } else
#line 3643
  if (! *(args + 2)) {
    {
#line 3644
    s = DoSu(& display->d_user, *(args + 0), *(args + 1), (char *)"\377");
    }
  } else {
    {
#line 3646
    s = DoSu(& display->d_user, *(args + 0), *(args + 1), *(args + 2));
    }
  }
#line 3647
  if (s) {
    {
#line 3648
    Msg(0, (char *)"%s", s);
    }
  }
#line 3649
  goto switch_break;
  case_145: /* CIL Label */ 
  {
#line 3652
  AddCanvas();
#line 3653
  Activate(-1);
  }
#line 3654
  goto switch_break;
  case_127: /* CIL Label */ 
  {
#line 3656
  RemCanvas();
#line 3657
  Activate(-1);
  }
#line 3658
  goto switch_break;
  case_110: /* CIL Label */ 
  {
#line 3660
  OneCanvas();
#line 3661
  Activate(-1);
  }
#line 3662
  goto switch_break;
  case_71: /* CIL Label */ 
  {
#line 3664
  (display->d_forecv)->c_xoff = (display->d_forecv)->c_xs;
#line 3665
  (display->d_forecv)->c_yoff = (display->d_forecv)->c_ys;
#line 3666
  RethinkViewportOffsets(display->d_forecv);
#line 3667
  ResizeLayer((display->d_forecv)->c_layer, ((display->d_forecv)->c_xe - (display->d_forecv)->c_xs) + 1,
              ((display->d_forecv)->c_ye - (display->d_forecv)->c_ys) + 1, (struct display *)0);
#line 3668
  flayer = (display->d_forecv)->c_layer;
#line 3669
  LGotoPos(flayer, flayer->l_x, flayer->l_y);
  }
#line 3670
  goto switch_break;
  case_73: /* CIL Label */ 
#line 3672
  if (! *args) {
#line 3672
    goto _L___35;
  } else {
    {
#line 3672
    tmp___217 = strcmp((char const   *)*args, "down");
    }
#line 3672
    if (tmp___217) {
      {
#line 3674
      tmp___216 = strcmp((char const   *)*args, "up");
      }
#line 3674
      if (tmp___216) {
        {
#line 3681
        tmp___215 = strcmp((char const   *)*args, "top");
        }
#line 3681
        if (tmp___215) {
          {
#line 3683
          tmp___214 = strcmp((char const   *)*args, "bottom");
          }
#line 3683
          if (tmp___214) {
            {
#line 3692
            Msg(0, (char *)"%s: usage: focus [up|down|top|bottom]", rc_name);
            }
#line 3693
            goto switch_break;
          } else {
#line 3686
            cv___0 = display->d_cvlist;
            {
#line 3686
            while (1) {
              while_continue___48: /* CIL Label */ ;
#line 3686
              if (! cv___0->c_next) {
#line 3686
                goto while_break___48;
              }
#line 3686
              cv___0 = cv___0->c_next;
            }
            while_break___48: /* CIL Label */ ;
            }
#line 3688
            display->d_forecv = cv___0;
          }
        } else {
#line 3682
          display->d_forecv = display->d_cvlist;
        }
      } else {
#line 3677
        cv = display->d_cvlist;
        {
#line 3677
        while (1) {
          while_continue___49: /* CIL Label */ ;
#line 3677
          if (cv->c_next) {
#line 3677
            if (! ((unsigned long )cv->c_next != (unsigned long )display->d_forecv)) {
#line 3677
              goto while_break___49;
            }
          } else {
#line 3677
            goto while_break___49;
          }
#line 3677
          cv = cv->c_next;
        }
        while_break___49: /* CIL Label */ ;
        }
#line 3679
        display->d_forecv = cv;
      }
    } else
    _L___35: /* CIL Label */ 
#line 3673
    if ((display->d_forecv)->c_next) {
#line 3673
      display->d_forecv = (display->d_forecv)->c_next;
    } else {
#line 3673
      display->d_forecv = display->d_cvlist;
    }
  }
  {
#line 3695
  tmp___218 = (struct win *)(((display->d_forecv)->c_layer)->l_bottom)->l_data;
#line 3695
  display->d_fore = tmp___218;
#line 3695
  fore = tmp___218;
#line 3696
  flayer = (display->d_forecv)->c_layer;
#line 3704
  RefreshHStatus();
#line 3708
  flayer = (display->d_forecv)->c_layer;
#line 3709
  olddisplay___2 = display;
#line 3709
  oldflayer = flayer;
#line 3709
  l___1 = (display->d_forecv)->c_layer;
#line 3709
  cvlist = l___1->l_cvlist;
#line 3709
  cvlnext = (display->d_forecv)->c_lnext;
#line 3709
  flayer = l___1;
#line 3709
  l___1->l_cvlist = display->d_forecv;
#line 3709
  (display->d_forecv)->c_lnext = (struct canvas *)0;
#line 3709
  (*((flayer->l_layfn)->lf_LayRestore))();
#line 3709
  LGotoPos(flayer, flayer->l_x, flayer->l_y);
#line 3709
  flayer = oldflayer;
#line 3709
  l___1->l_cvlist = cvlist;
#line 3709
  (display->d_forecv)->c_lnext = cvlnext;
#line 3709
  display = olddisplay___2;
#line 3710
  WindowChanged((struct win *)0, 'F');
  }
#line 3711
  goto switch_break;
  case_130: /* CIL Label */ 
#line 3713
  if (*args) {
    {
#line 3714
    ResizeRegions(*args);
    }
  } else {
    {
#line 3716
    Input((char *)"resize # lines: ", 20, 0, & ResizeFin, (char *)0);
    }
  }
#line 3717
  goto switch_break;
  case_136: /* CIL Label */ 
  {
#line 3719
  ParseSwitch(act, & separate_sids);
  }
#line 3720
  goto switch_break;
  case_69: /* CIL Label */ 
  {
#line 3722
  while (1) {
    while_continue___50: /* CIL Label */ ;
#line 3722
    if (! *args) {
#line 3722
      goto while_break___50;
    }
    {
#line 3724
    tmp___219 = SaveStr((char const   *)*args);
#line 3724
    ss___0 = tmp___219;
    }
#line 3725
    if (*ss___0) {
      {
#line 3726
      tmp___220 = strlen((char const   *)ss___0);
#line 3726
      Colonfin(ss___0, (int )tmp___220, (char *)0);
      }
    }
    {
#line 3727
    free((void *)ss___0);
#line 3722
    args ++;
    }
  }
  while_break___50: /* CIL Label */ ;
  }
#line 3729
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 3731
  ParseSwitch(act, & use_altscreen);
  }
#line 3732
  if (msgok) {
#line 3733
    if (use_altscreen) {
#line 3733
      tmp___221 = "";
    } else {
#line 3733
      tmp___221 = "not ";
    }
    {
#line 3733
    Msg(0, (char *)"Will %sdo alternate screen switching", tmp___221);
    }
  }
#line 3734
  goto switch_break;
  case_99: /* CIL Label */ 
  {
#line 3736
  tmp___222 = ParseNum(act, & n);
  }
#line 3736
  if (tmp___222) {
#line 3737
    goto switch_break;
  }
#line 3738
  if (n < 1) {
    {
#line 3739
    Msg(0, (char *)"illegal maxwin number specified");
    }
  } else
#line 3740
  if (n > maxwin) {
    {
#line 3741
    Msg(0, (char *)"may only decrease maxwin number");
    }
  } else {
#line 3743
    maxwin = n;
  }
#line 3744
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 3746
  tmp___223 = ParseBase(act, *args, & n, 10, (char *)"decimal");
  }
#line 3746
  if (tmp___223) {
#line 3747
    goto switch_break;
  }
#line 3748
  if (! *(args + 1)) {
    {
#line 3749
    setbacktick(n, 0, 0, (char **)0);
    }
  } else {
#line 3753
    if (argc < 4) {
      {
#line 3755
      Msg(0, (char *)"%s: usage: backtick num [lifespan tick cmd args...]", rc_name);
      }
#line 3756
      goto switch_break;
    }
    {
#line 3758
    tmp___224 = ParseBase(act, *(args + 1), & lifespan, 10, (char *)"decimal");
    }
#line 3758
    if (tmp___224) {
#line 3759
      goto switch_break;
    }
    {
#line 3760
    tmp___225 = ParseBase(act, *(args + 2), & tick___0, 10, (char *)"decimal");
    }
#line 3760
    if (tmp___225) {
#line 3761
      goto switch_break;
    }
    {
#line 3762
    tmp___226 = SaveArgs(args + 3);
#line 3762
    setbacktick(n, lifespan, tick___0, tmp___226);
    }
  }
  {
#line 3764
  WindowChanged((struct win *)0, '`');
  }
#line 3765
  goto switch_break;
  case_19: /* CIL Label */ 
#line 3768
  if (blankerprg) {
    {
#line 3770
    RunBlanker(blankerprg);
    }
#line 3771
    goto switch_break;
  }
  {
#line 3774
  ClearAll();
#line 3775
  CursorVisibility(-1);
#line 3776
  display->d_blocked = 4;
  }
#line 3777
  goto switch_break;
  case_20: /* CIL Label */ 
#line 3780
  if (blankerprg) {
#line 3783
    pp___2 = blankerprg;
    {
#line 3783
    while (1) {
      while_continue___51: /* CIL Label */ ;
#line 3783
      if (! *pp___2) {
#line 3783
        goto while_break___51;
      }
      {
#line 3784
      free((void *)*pp___2);
#line 3783
      pp___2 ++;
      }
    }
    while_break___51: /* CIL Label */ ;
    }
    {
#line 3785
    free((void *)blankerprg);
#line 3786
    blankerprg = (char **)0;
    }
  }
#line 3788
  if (*(*(args + 0) + 0)) {
    {
#line 3789
    blankerprg = SaveArgs(args);
    }
  }
#line 3790
  goto switch_break;
  case_83: /* CIL Label */ 
#line 3793
  if (*args) {
    {
#line 3795
    olddisplay___3 = display;
#line 3796
    tmp___228 = strcmp((char const   *)*args, "off");
    }
#line 3796
    if (tmp___228) {
#line 3798
      if (*(*(args + 0) + 0)) {
        {
#line 3799
        tmp___227 = atoi((char const   *)*args);
#line 3799
        idletimo = tmp___227 * 1000;
        }
      }
    } else {
#line 3797
      idletimo = 0;
    }
#line 3800
    if (argc > 1) {
      {
#line 3802
      i = FindCommnr(*(args + 1));
      }
#line 3802
      if (i == -1) {
        {
#line 3804
        Msg(0, (char *)"%s: idle: unknown command \'%s\'", rc_name, *(args + 1));
        }
#line 3805
        goto switch_break;
      }
      {
#line 3807
      tmp___229 = CheckArgNum(i, args + 2);
      }
#line 3807
      if (tmp___229 < 0) {
#line 3808
        goto switch_break;
      }
      {
#line 3809
      ClearAction(& idleaction);
#line 3810
      SaveAction(& idleaction, i, args + 2, argl + 2);
      }
    }
#line 3812
    display = displays;
    {
#line 3812
    while (1) {
      while_continue___52: /* CIL Label */ ;
#line 3812
      if (! display) {
#line 3812
        goto while_break___52;
      }
      {
#line 3813
      ResetIdle();
#line 3812
      display = display->d_next;
      }
    }
    while_break___52: /* CIL Label */ ;
    }
#line 3814
    display = olddisplay___3;
  }
#line 3816
  if (msgok) {
#line 3818
    if (idletimo) {
      {
#line 3819
      Msg(0, (char *)"idle timeout %ds, %s", idletimo / 1000, comms[idleaction.nr].name);
      }
    } else {
      {
#line 3821
      Msg(0, (char *)"idle off");
      }
    }
  }
#line 3823
  goto switch_break;
  switch_default___0: /* CIL Label */ 
#line 3829
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3831
  if ((unsigned long )display != (unsigned long )odisplay) {
#line 3833
    display = displays;
    {
#line 3833
    while (1) {
      while_continue___53: /* CIL Label */ ;
#line 3833
      if (! display) {
#line 3833
        goto while_break___53;
      }
#line 3834
      if ((unsigned long )display == (unsigned long )odisplay) {
#line 3835
        goto while_break___53;
      }
#line 3833
      display = display->d_next;
    }
    while_break___53: /* CIL Label */ ;
    }
  }
#line 3837
  return;
}
}
#line 3839 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
void DoCommand(char **argv , int *argl ) 
{ 
  struct action act ;

  {
  {
#line 3846
  act.nr = FindCommnr(*argv);
  }
#line 3846
  if (act.nr == -1) {
    {
#line 3848
    Msg(0, (char *)"%s: unknown command \'%s\'", rc_name, *argv);
    }
#line 3849
    return;
  }
  {
#line 3851
  act.args = argv + 1;
#line 3852
  act.argl = argl + 1;
#line 3853
  DoAction(& act, -1);
  }
#line 3854
  return;
}
}
#line 3856 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static void SaveAction(struct action *act , int nr , char **args , int *argl ) 
{ 
  register int argc ;
  char **pp ;
  int *lp ;
  void *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  size_t tmp___2 ;
  char **tmp___3 ;
  int *tmp___4 ;
  char **tmp___5 ;
  int tmp___6 ;

  {
#line 3863
  argc = 0;
#line 3867
  if (args) {
    {
#line 3868
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3868
      if (! *(args + argc)) {
#line 3868
        goto while_break;
      }
#line 3869
      argc ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 3870
  if (argc == 0) {
#line 3872
    act->nr = nr;
#line 3873
    act->args = noargs;
#line 3874
    act->argl = (int *)0;
#line 3875
    return;
  }
  {
#line 3877
  tmp = malloc((size_t )((unsigned long )((unsigned int )(argc + 1)) * sizeof(char **)));
#line 3877
  pp = (char **)tmp;
  }
#line 3877
  if ((unsigned long )pp == (unsigned long )((char **)0)) {
    {
#line 3878
    Panic(0, strnomem);
    }
  }
  {
#line 3879
  tmp___0 = malloc((size_t )((unsigned long )((unsigned int )argc) * sizeof(int *)));
#line 3879
  lp = (int *)tmp___0;
  }
#line 3879
  if ((unsigned long )lp == (unsigned long )((int *)0)) {
    {
#line 3880
    Panic(0, strnomem);
    }
  }
#line 3881
  act->nr = nr;
#line 3882
  act->args = pp;
#line 3883
  act->argl = lp;
  {
#line 3884
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3884
    tmp___6 = argc;
#line 3884
    argc --;
#line 3884
    if (! tmp___6) {
#line 3884
      goto while_break___0;
    }
#line 3886
    if (argl) {
#line 3886
      tmp___1 = argl;
#line 3886
      argl ++;
#line 3886
      *lp = *tmp___1;
    } else {
      {
#line 3886
      tmp___2 = strlen((char const   *)*args);
#line 3886
      *lp = (int )tmp___2;
      }
    }
    {
#line 3887
    tmp___3 = pp;
#line 3887
    pp ++;
#line 3887
    tmp___4 = lp;
#line 3887
    lp ++;
#line 3887
    tmp___5 = args;
#line 3887
    args ++;
#line 3887
    *tmp___3 = SaveStrn((char const   *)*tmp___5, *tmp___4);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3889
  *pp = (char *)0;
#line 3890
  return;
}
}
#line 3892 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static char **SaveArgs(char **args ) 
{ 
  register char **ap ;
  register char **pp ;
  register int argc ;
  void *tmp ;
  char **tmp___0 ;
  char **tmp___1 ;
  int tmp___2 ;

  {
#line 3897
  argc = 0;
  {
#line 3899
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3899
    if (! *(args + argc)) {
#line 3899
      goto while_break;
    }
#line 3900
    argc ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3901
  tmp = malloc((size_t )((unsigned long )((unsigned int )(argc + 1)) * sizeof(char **)));
#line 3901
  ap = (char **)tmp;
#line 3901
  pp = ap;
  }
#line 3901
  if ((unsigned long )pp == (unsigned long )((char **)0)) {
    {
#line 3902
    Panic(0, strnomem);
    }
  }
  {
#line 3903
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3903
    tmp___2 = argc;
#line 3903
    argc --;
#line 3903
    if (! tmp___2) {
#line 3903
      goto while_break___0;
    }
    {
#line 3904
    tmp___0 = pp;
#line 3904
    pp ++;
#line 3904
    tmp___1 = args;
#line 3904
    args ++;
#line 3904
    *tmp___0 = SaveStr((char const   *)*tmp___1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3905
  *pp = (char *)0;
#line 3906
  return (ap);
}
}
#line 3919 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
int Parse(char *buf___0 , int bufl , char **args , int *argl ) 
{ 
  register char *p ;
  register char **ap ;
  register char *pp ;
  register int delim ;
  register int argc ;
  int *lp ;
  char **tmp ;
  int *tmp___0 ;
  char **tmp___1 ;
  char *tmp___2 ;
  char *ps ;
  char *pe ;
  char op ;
  char *v ;
  char xbuf[11] ;
  int vl ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  int right ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;

  {
#line 3924
  p = buf___0;
#line 3924
  ap = args;
#line 3926
  lp = argl;
  {
#line 3928
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3928
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3929
  argc = 0;
#line 3930
  pp = buf___0;
#line 3931
  delim = 0;
  {
#line 3932
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 3934
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3934
      if (*p) {
#line 3934
        if (! ((int )*p == 32)) {
#line 3934
          if (! ((int )*p == 9)) {
#line 3934
            goto while_break___1;
          }
        }
      } else {
#line 3934
        goto while_break___1;
      }
#line 3935
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 3937
    if (argc == 0) {
#line 3937
      if ((int )*p == 33) {
#line 3939
        tmp = ap;
#line 3939
        ap ++;
#line 3939
        *tmp = (char *)"exec";
#line 3940
        tmp___0 = lp;
#line 3940
        lp ++;
#line 3940
        *tmp___0 = 4;
#line 3941
        p ++;
#line 3942
        argc ++;
#line 3943
        goto __Cont;
      }
    }
#line 3946
    if ((int )*p == 0) {
#line 3946
      goto _L;
    } else
#line 3946
    if ((int )*p == 35) {
#line 3946
      goto _L;
    } else
#line 3946
    if ((int )*p == 10) {
      _L: /* CIL Label */ 
#line 3948
      *p = (char )'\000';
#line 3949
      delim = 0;
      {
#line 3949
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 3949
        if (! (delim < argc)) {
#line 3949
          goto while_break___2;
        }
        {
#line 3950
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 3950
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 3949
        delim ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 3951
      *(args + argc) = (char *)0;
#line 3952
      return (argc);
    }
#line 3954
    argc ++;
#line 3954
    if (argc >= 64) {
      {
#line 3956
      Msg(0, (char *)"%s: too many tokens.", rc_name);
      }
#line 3957
      return (0);
    }
#line 3959
    tmp___1 = ap;
#line 3959
    ap ++;
#line 3959
    *tmp___1 = pp;
    {
#line 3961
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 3961
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 3962
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 3962
      if (! *p) {
#line 3962
        goto while_break___5;
      }
#line 3964
      if ((int )*p == delim) {
#line 3965
        delim = 0;
      } else
#line 3966
      if (delim != 39) {
#line 3966
        if ((int )*p == 92) {
#line 3966
          if ((int )*(p + 1) == 39) {
#line 3966
            goto _L___14;
          } else
#line 3966
          if ((int )*(p + 1) == 34) {
#line 3966
            goto _L___14;
          } else
#line 3966
          if ((int )*(p + 1) == 92) {
#line 3966
            goto _L___14;
          } else
#line 3966
          if ((int )*(p + 1) == 36) {
#line 3966
            goto _L___14;
          } else
#line 3966
          if ((int )*(p + 1) == 35) {
#line 3966
            goto _L___14;
          } else
#line 3966
          if ((int )*(p + 1) == 94) {
#line 3966
            goto _L___14;
          } else
#line 3966
          if ((int )*(p + 1) >= 48) {
#line 3966
            if ((int )*(p + 1) <= 55) {
              _L___14: /* CIL Label */ 
#line 3968
              p ++;
#line 3969
              if ((int )*p >= 48) {
#line 3969
                if ((int )*p <= 55) {
#line 3971
                  *pp = (char )((int )*p - 48);
#line 3972
                  if ((int )*(p + 1) >= 48) {
#line 3972
                    if ((int )*(p + 1) <= 55) {
#line 3974
                      p ++;
#line 3975
                      *pp = (char )(((int )*pp << 3) | ((int )*p - 48));
#line 3976
                      if ((int )*(p + 1) >= 48) {
#line 3976
                        if ((int )*(p + 1) <= 55) {
#line 3978
                          p ++;
#line 3979
                          *pp = (char )(((int )*pp << 3) | ((int )*p - 48));
                        }
                      }
                    }
                  }
#line 3982
                  pp ++;
                } else {
#line 3985
                  tmp___2 = pp;
#line 3985
                  pp ++;
#line 3985
                  *tmp___2 = *p;
                }
              } else {
#line 3985
                tmp___2 = pp;
#line 3985
                pp ++;
#line 3985
                *tmp___2 = *p;
              }
            } else {
#line 3966
              goto _L___15;
            }
          } else {
#line 3966
            goto _L___15;
          }
        } else {
#line 3966
          goto _L___15;
        }
      } else
      _L___15: /* CIL Label */ 
#line 3987
      if (delim != 39) {
#line 3987
        if ((int )*p == 36) {
#line 3987
          if ((int )*(p + 1) == 123) {
#line 3987
            goto _L___8;
          } else
#line 3987
          if ((int )*(p + 1) == 58) {
#line 3987
            goto _L___8;
          } else
#line 3987
          if ((int )*(p + 1) >= 97) {
#line 3987
            if ((int )*(p + 1) <= 122) {
#line 3987
              goto _L___8;
            } else {
#line 3987
              goto _L___11;
            }
          } else
          _L___11: /* CIL Label */ 
#line 3987
          if ((int )*(p + 1) >= 65) {
#line 3987
            if ((int )*(p + 1) <= 90) {
#line 3987
              goto _L___8;
            } else {
#line 3987
              goto _L___10;
            }
          } else
          _L___10: /* CIL Label */ 
#line 3987
          if ((int )*(p + 1) >= 48) {
#line 3987
            if ((int )*(p + 1) <= 57) {
#line 3987
              goto _L___8;
            } else {
#line 3987
              goto _L___9;
            }
          } else
          _L___9: /* CIL Label */ 
#line 3987
          if ((int )*(p + 1) == 95) {
            _L___8: /* CIL Label */ 
#line 3993
            p ++;
#line 3993
            ps = p;
            {
#line 3994
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 3994
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
#line 3995
            p ++;
            {
#line 3996
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 3996
              if (! *p) {
#line 3996
                goto while_break___7;
              }
#line 3998
              if ((int )*ps == 123) {
#line 3998
                if ((int )*p == 125) {
#line 3999
                  goto while_break___7;
                }
              }
#line 4000
              if ((int )*ps == 58) {
#line 4000
                if ((int )*p == 58) {
#line 4001
                  goto while_break___7;
                }
              }
#line 4002
              if ((int )*ps != 123) {
#line 4002
                if ((int )*ps != 58) {
#line 4002
                  if ((int )*p < 97) {
#line 4002
                    goto _L___2;
                  } else
#line 4002
                  if ((int )*p > 122) {
                    _L___2: /* CIL Label */ 
#line 4002
                    if ((int )*p < 65) {
#line 4002
                      goto _L___1;
                    } else
#line 4002
                    if ((int )*p > 90) {
                      _L___1: /* CIL Label */ 
#line 4002
                      if ((int )*p < 48) {
#line 4002
                        goto _L___0;
                      } else
#line 4002
                      if ((int )*p > 57) {
                        _L___0: /* CIL Label */ 
#line 4002
                        if ((int )*p != 95) {
#line 4003
                          goto while_break___7;
                        }
                      }
                    }
                  }
                }
              }
#line 4004
              p ++;
            }
            while_break___7: /* CIL Label */ ;
            }
#line 4006
            pe = p;
#line 4007
            if ((int )*ps == 123) {
#line 4007
              goto _L___3;
            } else
#line 4007
            if ((int )*ps == 58) {
              _L___3: /* CIL Label */ 
#line 4009
              if (! *p) {
                {
#line 4011
                Msg(0, (char *)"%s: bad variable name.", rc_name);
                }
#line 4012
                return (0);
              }
#line 4014
              p ++;
            }
#line 4016
            op = *pe;
#line 4017
            *pe = (char)0;
            {
#line 4018
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 4018
              goto while_break___8;
            }
            while_break___8: /* CIL Label */ ;
            }
#line 4019
            if ((int )*ps == 58) {
              {
#line 4020
              v = gettermcapstring(ps + 1);
              }
            } else {
#line 4023
              if ((int )*ps == 123) {
#line 4024
                ps ++;
              }
              {
#line 4025
              v = xbuf;
#line 4026
              tmp___7 = strcmp((char const   *)ps, "TERM");
              }
#line 4026
              if (tmp___7) {
                {
#line 4028
                tmp___6 = strcmp((char const   *)ps, "COLUMNS");
                }
#line 4028
                if (tmp___6) {
                  {
#line 4030
                  tmp___5 = strcmp((char const   *)ps, "LINES");
                  }
#line 4030
                  if (tmp___5) {
                    {
#line 4033
                    v = getenv((char const   *)ps);
                    }
                  } else {
#line 4031
                    if (display) {
#line 4031
                      tmp___4 = display->d_height;
                    } else {
#line 4031
                      tmp___4 = -1;
                    }
                    {
#line 4031
                    sprintf((char */* __restrict  */)(xbuf), (char const   */* __restrict  */)"%d",
                            tmp___4);
                    }
                  }
                } else {
#line 4029
                  if (display) {
#line 4029
                    tmp___3 = display->d_width;
                  } else {
#line 4029
                    tmp___3 = -1;
                  }
                  {
#line 4029
                  sprintf((char */* __restrict  */)(xbuf), (char const   */* __restrict  */)"%d",
                          tmp___3);
                  }
                }
              } else
#line 4027
              if (display) {
#line 4027
                v = display->d_termname;
              } else {
#line 4027
                v = (char *)"unknown";
              }
            }
#line 4035
            *pe = op;
#line 4036
            if (v) {
              {
#line 4036
              tmp___8 = strlen((char const   *)v);
#line 4036
              vl = (int )tmp___8;
              }
            } else {
#line 4036
              vl = 0;
            }
#line 4037
            if (vl) {
              {
#line 4039
              while (1) {
                while_continue___9: /* CIL Label */ ;
#line 4039
                goto while_break___9;
              }
              while_break___9: /* CIL Label */ ;
              }
#line 4040
              if (p - pp < (long )vl) {
                {
#line 4042
                tmp___9 = strlen((char const   *)p);
#line 4042
                right = (int )((buf___0 + bufl) - ((p + tmp___9) + 1));
                }
#line 4043
                if (right > 0) {
                  {
#line 4045
                  tmp___10 = strlen((char const   *)p);
#line 4045
                  bcopy((void const   *)p, (void *)(p + right), tmp___10 + 1U);
#line 4046
                  p += right;
                  }
                }
              }
#line 4049
              if (p - pp < (long )vl) {
                {
#line 4051
                Msg(0, (char *)"%s: no space left for variable expansion.", rc_name);
                }
#line 4052
                return (0);
              }
              {
#line 4054
              bcopy((void const   *)v, (void *)pp, (size_t )vl);
#line 4055
              pp += vl;
              }
            }
#line 4057
            goto while_continue___5;
          } else {
#line 3987
            goto _L___12;
          }
        } else {
#line 3987
          goto _L___12;
        }
      } else
      _L___12: /* CIL Label */ 
#line 4059
      if (delim != 39) {
#line 4059
        if ((int )*p == 94) {
#line 4059
          if (*(p + 1)) {
#line 4061
            p ++;
#line 4062
            tmp___11 = pp;
#line 4062
            pp ++;
#line 4062
            if ((int )*p == 63) {
#line 4062
              *tmp___11 = (char )'\177';
            } else {
#line 4062
              *tmp___11 = (char )((int )*p & 31);
            }
          } else {
#line 4059
            goto _L___6;
          }
        } else {
#line 4059
          goto _L___6;
        }
      } else
      _L___6: /* CIL Label */ 
#line 4064
      if (delim == 0) {
#line 4064
        if ((int )*p == 39) {
#line 4065
          delim = (int )*p;
        } else
#line 4064
        if ((int )*p == 34) {
#line 4065
          delim = (int )*p;
        } else {
#line 4064
          goto _L___4;
        }
      } else
      _L___4: /* CIL Label */ 
#line 4066
      if (delim == 0) {
#line 4066
        if ((int )*p == 32) {
#line 4067
          goto while_break___5;
        } else
#line 4066
        if ((int )*p == 9) {
#line 4067
          goto while_break___5;
        } else
#line 4066
        if ((int )*p == 10) {
#line 4067
          goto while_break___5;
        } else {
#line 4069
          tmp___12 = pp;
#line 4069
          pp ++;
#line 4069
          *tmp___12 = *p;
        }
      } else {
#line 4069
        tmp___12 = pp;
#line 4069
        pp ++;
#line 4069
        *tmp___12 = *p;
      }
#line 4070
      p ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 4072
    if (delim) {
      {
#line 4074
      Msg(0, (char *)"%s: Missing %c quote.", rc_name, delim);
      }
#line 4075
      return (0);
    }
#line 4077
    if (*p) {
#line 4078
      p ++;
    }
#line 4079
    *pp = (char)0;
    {
#line 4080
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 4080
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 4081
    tmp___13 = lp;
#line 4081
    lp ++;
#line 4081
    *tmp___13 = (int )(pp - *(ap + -1));
#line 4082
    pp ++;
    __Cont: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 4086 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
void SetEscape(struct acluser *u , int e , int me ) 
{ 


  {
#line 4091
  if (u) {
#line 4093
    u->u_Esc = e;
#line 4094
    u->u_MetaEsc = me;
  } else {
#line 4098
    if (users) {
#line 4100
      if (DefaultEsc >= 0) {
        {
#line 4101
        ClearAction(& ktab[DefaultEsc]);
        }
      }
#line 4102
      if (DefaultMetaEsc >= 0) {
        {
#line 4103
        ClearAction(& ktab[DefaultMetaEsc]);
        }
      }
    }
#line 4105
    DefaultEsc = e;
#line 4106
    DefaultMetaEsc = me;
#line 4107
    if (users) {
#line 4109
      if (DefaultEsc >= 0) {
        {
#line 4111
        ClearAction(& ktab[DefaultEsc]);
#line 4112
        ktab[DefaultEsc].nr = 111;
        }
      }
#line 4114
      if (DefaultMetaEsc >= 0) {
        {
#line 4116
        ClearAction(& ktab[DefaultMetaEsc]);
#line 4117
        ktab[DefaultMetaEsc].nr = 100;
        }
      }
    }
  }
#line 4121
  return;
}
}
#line 4123 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
int ParseSwitch(struct action *act , int *var ) 
{ 
  int tmp ;

  {
#line 4128
  if ((unsigned long )*(act->args) == (unsigned long )((char *)0)) {
#line 4130
    *var ^= 1;
#line 4131
    return (0);
  }
  {
#line 4133
  tmp = ParseOnOff(act, var);
  }
#line 4133
  return (tmp);
}
}
#line 4136 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static int ParseOnOff(struct action *act , int *var ) 
{ 
  register int num ;
  char **args ;
  int tmp ;
  int tmp___0 ;

  {
#line 4141
  num = -1;
#line 4142
  args = act->args;
#line 4144
  if ((unsigned long )*(args + 1) == (unsigned long )((char *)0)) {
    {
#line 4146
    tmp___0 = strcmp((char const   *)*(args + 0), "on");
    }
#line 4146
    if (tmp___0 == 0) {
#line 4147
      num = 1;
    } else {
      {
#line 4148
      tmp = strcmp((char const   *)*(args + 0), "off");
      }
#line 4148
      if (tmp == 0) {
#line 4149
        num = 0;
      }
    }
  }
#line 4151
  if (num < 0) {
    {
#line 4153
    Msg(0, (char *)"%s: %s: invalid argument. Give \'on\' or \'off\'", rc_name, comms[act->nr].name);
    }
#line 4154
    return (-1);
  }
#line 4156
  *var = num;
#line 4157
  return (0);
}
}
#line 4160 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
int ParseSaveStr(struct action *act , char **var ) 
{ 
  char **args ;

  {
#line 4165
  args = act->args;
#line 4166
  if ((unsigned long )*args == (unsigned long )((char *)0)) {
    {
#line 4168
    Msg(0, (char *)"%s: %s: one argument required.", rc_name, comms[act->nr].name);
    }
#line 4169
    return (-1);
  } else
#line 4166
  if (*(args + 1)) {
    {
#line 4168
    Msg(0, (char *)"%s: %s: one argument required.", rc_name, comms[act->nr].name);
    }
#line 4169
    return (-1);
  }
#line 4171
  if (*var) {
    {
#line 4172
    free((void *)*var);
    }
  }
  {
#line 4173
  *var = SaveStr((char const   *)*args);
  }
#line 4174
  return (0);
}
}
#line 4177 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
int ParseNum(struct action *act , int *var ) 
{ 
  int i ;
  char *p ;
  char **args ;

  {
#line 4183
  args = act->args;
#line 4185
  p = *args;
#line 4186
  if ((unsigned long )p == (unsigned long )((char *)0)) {
    {
#line 4188
    Msg(0, (char *)"%s: %s: invalid argument. Give one argument.", rc_name, comms[act->nr].name);
    }
#line 4190
    return (-1);
  } else
#line 4186
  if ((int )*p == 0) {
    {
#line 4188
    Msg(0, (char *)"%s: %s: invalid argument. Give one argument.", rc_name, comms[act->nr].name);
    }
#line 4190
    return (-1);
  } else
#line 4186
  if (*(args + 1)) {
    {
#line 4188
    Msg(0, (char *)"%s: %s: invalid argument. Give one argument.", rc_name, comms[act->nr].name);
    }
#line 4190
    return (-1);
  }
#line 4192
  i = 0;
  {
#line 4193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4193
    if (! *p) {
#line 4193
      goto while_break;
    }
#line 4195
    if ((int )*p >= 48) {
#line 4195
      if ((int )*p <= 57) {
#line 4196
        i = 10 * i + ((int )*p - 48);
      } else {
        {
#line 4199
        Msg(0, (char *)"%s: %s: invalid argument. Give numeric argument.", rc_name,
            comms[act->nr].name);
        }
#line 4201
        return (-1);
      }
    } else {
      {
#line 4199
      Msg(0, (char *)"%s: %s: invalid argument. Give numeric argument.", rc_name,
          comms[act->nr].name);
      }
#line 4201
      return (-1);
    }
#line 4203
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4205
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4205
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4206
  *var = i;
#line 4207
  return (0);
}
}
#line 4210 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static int ParseNum1000(struct action *act , int *var ) 
{ 
  int i ;
  char *p ;
  char **args ;
  int dig ;
  int tmp ;

  {
#line 4216
  args = act->args;
#line 4217
  dig = 0;
#line 4219
  p = *args;
#line 4220
  if ((unsigned long )p == (unsigned long )((char *)0)) {
    {
#line 4222
    Msg(0, (char *)"%s: %s: invalid argument. Give one argument.", rc_name, comms[act->nr].name);
    }
#line 4224
    return (-1);
  } else
#line 4220
  if ((int )*p == 0) {
    {
#line 4222
    Msg(0, (char *)"%s: %s: invalid argument. Give one argument.", rc_name, comms[act->nr].name);
    }
#line 4224
    return (-1);
  } else
#line 4220
  if (*(args + 1)) {
    {
#line 4222
    Msg(0, (char *)"%s: %s: invalid argument. Give one argument.", rc_name, comms[act->nr].name);
    }
#line 4224
    return (-1);
  }
#line 4226
  i = 0;
  {
#line 4227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4227
    if (! *p) {
#line 4227
      goto while_break;
    }
#line 4229
    if ((int )*p >= 48) {
#line 4229
      if ((int )*p <= 57) {
#line 4231
        if (dig < 4) {
#line 4232
          i = 10 * i + ((int )*p - 48);
        } else
#line 4233
        if (dig == 4) {
#line 4233
          if ((int )*p >= 53) {
#line 4234
            i ++;
          }
        }
#line 4235
        if (dig) {
#line 4236
          dig ++;
        }
      } else {
#line 4229
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 4238
    if ((int )*p == 46) {
#line 4238
      if (! dig) {
#line 4239
        dig ++;
      } else {
        {
#line 4242
        Msg(0, (char *)"%s: %s: invalid argument. Give floating point argument.",
            rc_name, comms[act->nr].name);
        }
#line 4244
        return (-1);
      }
    } else {
      {
#line 4242
      Msg(0, (char *)"%s: %s: invalid argument. Give floating point argument.", rc_name,
          comms[act->nr].name);
      }
#line 4244
      return (-1);
    }
#line 4246
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4248
  if (dig == 0) {
#line 4249
    i *= 1000;
  } else {
    {
#line 4251
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4251
      tmp = dig;
#line 4251
      dig ++;
#line 4251
      if (! (tmp < 4)) {
#line 4251
        goto while_break___0;
      }
#line 4252
      i *= 10;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 4253
  if (i < 0) {
#line 4254
    i = (int )(4294967295U >> 1);
  }
  {
#line 4255
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 4255
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 4256
  *var = i;
#line 4257
  return (0);
}
}
#line 4260 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static struct win *WindowByName(char *s ) 
{ 
  struct win *p ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 4266
  p = windows;
  {
#line 4266
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4266
    if (! p) {
#line 4266
      goto while_break;
    }
    {
#line 4267
    tmp = strcmp((char const   *)p->w_title, (char const   *)s);
    }
#line 4267
    if (! tmp) {
#line 4268
      return (p);
    }
#line 4266
    p = p->w_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 4269
  p = windows;
  {
#line 4269
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4269
    if (! p) {
#line 4269
      goto while_break___0;
    }
    {
#line 4270
    tmp___0 = strlen((char const   *)s);
#line 4270
    tmp___1 = strncmp((char const   *)p->w_title, (char const   *)s, tmp___0);
    }
#line 4270
    if (! tmp___1) {
#line 4271
      return (p);
    }
#line 4269
    p = p->w_next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4272
  return ((struct win *)0);
}
}
#line 4275 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static int WindowByNumber(char *str ) 
{ 
  int i ;
  char *s ;
  int tmp ;

  {
#line 4282
  i = 0;
#line 4282
  s = str;
  {
#line 4282
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4282
    if (! *s) {
#line 4282
      goto while_break;
    }
#line 4284
    if ((int )*s < 48) {
#line 4285
      goto while_break;
    } else
#line 4284
    if ((int )*s > 57) {
#line 4285
      goto while_break;
    }
#line 4286
    i = i * 10 + ((int )*s - 48);
#line 4282
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4288
  if (*s) {
#line 4288
    tmp = -1;
  } else {
#line 4288
    tmp = i;
  }
#line 4288
  return (tmp);
}
}
#line 4296 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
int WindowByNoN(char *str ) 
{ 
  int i ;
  struct win *p ;

  {
  {
#line 4303
  i = WindowByNumber(str);
  }
#line 4303
  if (i < 0) {
#line 4303
    goto _L;
  } else
#line 4303
  if (i >= 40) {
    _L: /* CIL Label */ 
    {
#line 4305
    p = WindowByName(str);
    }
#line 4305
    if (p) {
#line 4306
      return (p->w_number);
    }
#line 4307
    return (-1);
  }
#line 4309
  return (i);
}
}
#line 4312 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static int ParseWinNum(struct action *act , int *var ) 
{ 
  char **args ;
  int i ;

  {
#line 4317
  args = act->args;
#line 4318
  i = 0;
#line 4320
  if ((unsigned long )*args == (unsigned long )((char *)0)) {
    {
#line 4322
    Msg(0, (char *)"%s: %s: one argument required.", rc_name, comms[act->nr].name);
    }
#line 4323
    return (-1);
  } else
#line 4320
  if (*(args + 1)) {
    {
#line 4322
    Msg(0, (char *)"%s: %s: one argument required.", rc_name, comms[act->nr].name);
    }
#line 4323
    return (-1);
  }
  {
#line 4326
  i = WindowByNoN(*args);
  }
#line 4327
  if (i < 0) {
    {
#line 4329
    Msg(0, (char *)"%s: %s: invalid argument. Give window number or name.", rc_name,
        comms[act->nr].name);
    }
#line 4331
    return (-1);
  }
  {
#line 4333
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4333
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 4334
  *var = i;
#line 4335
  return (0);
}
}
#line 4338 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static int ParseBase(struct action *act , char *p , int *var , int base , char *bname ) 
{ 
  int i ;
  int c ;
  char *tmp ;

  {
#line 4346
  i = 0;
#line 4349
  if ((int )*p == 0) {
    {
#line 4351
    Msg(0, (char *)"%s: %s: empty argument.", rc_name, comms[act->nr].name);
    }
#line 4352
    return (-1);
  }
  {
#line 4354
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4354
    tmp = p;
#line 4354
    p ++;
#line 4354
    c = (int )*tmp;
#line 4354
    if (! c) {
#line 4354
      goto while_break;
    }
#line 4356
    if (c >= 97) {
#line 4356
      if (c <= 122) {
#line 4357
        c -= 32;
      }
    }
#line 4358
    if (c >= 65) {
#line 4358
      if (c <= 90) {
#line 4359
        c -= 7;
      }
    }
#line 4360
    c -= 48;
#line 4361
    if (c < 0) {
      {
#line 4363
      Msg(0, (char *)"%s: %s: argument is not %s.", rc_name, comms[act->nr].name,
          bname);
      }
#line 4364
      return (-1);
    } else
#line 4361
    if (c >= base) {
      {
#line 4363
      Msg(0, (char *)"%s: %s: argument is not %s.", rc_name, comms[act->nr].name,
          bname);
      }
#line 4364
      return (-1);
    }
#line 4366
    i = base * i + c;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4368
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4368
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4369
  *var = i;
#line 4370
  return (0);
}
}
#line 4373 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static int IsNum(char *s , int base ) 
{ 


  {
#line 4378
  base += 48;
  {
#line 4378
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4378
    if (! *s) {
#line 4378
      goto while_break;
    }
#line 4379
    if ((int )*s < 48) {
#line 4380
      return (0);
    } else
#line 4379
    if ((int )*s > base) {
#line 4380
      return (0);
    }
#line 4378
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4381
  return (1);
}
}
#line 4384 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
int IsNumColon(char *s , int base , char *p , int psize ) 
{ 
  char *q ;
  int tmp ;

  {
  {
#line 4390
  q = rindex((char const   *)s, ':');
  }
#line 4390
  if ((unsigned long )q != (unsigned long )((char *)0)) {
    {
#line 4392
    strncpy((char */* __restrict  */)p, (char const   */* __restrict  */)(q + 1),
            (size_t )(psize - 1));
#line 4393
    *(p + (psize - 1)) = (char )'\000';
#line 4394
    *q = (char )'\000';
    }
  } else {
#line 4397
    *p = (char )'\000';
  }
  {
#line 4398
  tmp = IsNum(s, base);
  }
#line 4398
  return (tmp);
}
}
#line 4401 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
void SwitchWindow(int n ) 
{ 
  struct win *p ;
  int tmp ;

  {
  {
#line 4407
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4407
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 4408
  if (n < 0) {
    {
#line 4410
    ShowWindows(-1);
    }
#line 4411
    return;
  } else
#line 4408
  if (n >= 40) {
    {
#line 4410
    ShowWindows(-1);
    }
#line 4411
    return;
  }
#line 4413
  p = wtab[n];
#line 4413
  if ((unsigned long )p == (unsigned long )((struct win *)0)) {
    {
#line 4415
    ShowWindows(n);
    }
#line 4416
    return;
  }
#line 4418
  if ((unsigned long )display == (unsigned long )((struct display *)0)) {
#line 4420
    fore = p;
#line 4421
    return;
  }
#line 4423
  if ((unsigned long )p == (unsigned long )display->d_fore) {
    {
#line 4425
    Msg(0, (char *)"This IS window %d (%s).", n, p->w_title);
    }
#line 4426
    return;
  }
  {
#line 4429
  tmp = AclCheckPermWin(display->d_user, 2, p);
  }
#line 4429
  if (tmp) {
    {
#line 4431
    Msg(0, (char *)"Access to window %d denied.", p->w_number);
    }
#line 4432
    return;
  }
  {
#line 4435
  SetForeWindow(p);
#line 4436
  Activate((int )fore->w_norefresh);
  }
#line 4437
  return;
}
}
#line 4440 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
void SetCanvasWindow(struct canvas *cv , struct win *wi ) 
{ 
  struct win *p ;
  struct win **pp ;
  struct layer *l ;
  struct canvas *cvp ;
  struct canvas **cvpp ;

  {
#line 4445
  p = (struct win *)0;
#line 4449
  l = cv->c_layer;
#line 4450
  display = cv->c_display;
#line 4452
  if (l) {
#line 4455
    cvpp = & l->l_cvlist;
    {
#line 4455
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4455
      cvp = *cvpp;
#line 4455
      if (! cvp) {
#line 4455
        goto while_break;
      }
#line 4456
      if ((unsigned long )cvp == (unsigned long )cv) {
#line 4457
        goto while_break;
      }
#line 4455
      cvpp = & cvp->c_lnext;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 4458
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4458
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4459
    *cvpp = cvp->c_lnext;
#line 4461
    p = (struct win *)(l->l_bottom)->l_data;
#line 4462
    l = cv->c_layer;
#line 4463
    cv->c_layer = (struct layer *)0;
#line 4465
    if (p) {
#line 4465
      if ((unsigned long )cv == (unsigned long )display->d_forecv) {
        {
#line 4468
        ReleaseAutoWritelock(display, p);
        }
#line 4470
        if (p->w_silence) {
          {
#line 4472
          SetTimeout(& p->w_silenceev, p->w_silencewait * 1000);
#line 4473
          evenq(& p->w_silenceev);
          }
        }
#line 4475
        display->d_other = fore;
#line 4476
        display->d_fore = (struct win *)0;
      }
    }
#line 4478
    if ((unsigned long )l->l_cvlist == (unsigned long )((struct canvas *)0)) {
#line 4478
      if ((unsigned long )p == (unsigned long )((struct win *)0)) {
        {
#line 4479
        KillLayerChain(l);
        }
      } else
#line 4478
      if ((unsigned long )l != (unsigned long )p->w_savelayer) {
        {
#line 4479
        KillLayerChain(l);
        }
      }
    }
  }
#line 4483
  if (wi) {
#line 4485
    l = & wi->w_layer;
#line 4486
    if (wi->w_savelayer) {
#line 4486
      if (wi->w_blocked) {
#line 4487
        l = wi->w_savelayer;
      } else
#line 4486
      if ((unsigned long )(wi->w_savelayer)->l_cvlist == (unsigned long )((struct canvas *)0)) {
#line 4487
        l = wi->w_savelayer;
      }
    }
  } else {
#line 4490
    l = & cv->c_blank;
  }
  {
#line 4493
  cv->c_lnext = l->l_cvlist;
#line 4494
  l->l_cvlist = cv;
#line 4495
  cv->c_layer = l;
#line 4496
  cv->c_xoff = cv->c_xs;
#line 4497
  cv->c_yoff = cv->c_ys;
#line 4498
  RethinkViewportOffsets(cv);
  }
#line 4500
  if ((unsigned long )flayer == (unsigned long )((struct layer *)0)) {
#line 4501
    flayer = l;
  }
#line 4503
  if (wi) {
#line 4503
    if ((unsigned long )display->d_other == (unsigned long )wi) {
#line 4504
      display->d_other = wi->w_next;
    }
  }
#line 4505
  if ((unsigned long )cv == (unsigned long )display->d_forecv) {
#line 4507
    display->d_fore = wi;
#line 4508
    fore = display->d_fore;
#line 4509
    if (wi) {
      {
#line 4512
      ObtainAutoWritelock(display, wi);
      }
#line 4517
      if ((unsigned long )windows != (unsigned long )wi) {
#line 4519
        pp = & windows;
        {
#line 4519
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 4519
          p = *pp;
#line 4519
          if (! p) {
#line 4519
            goto while_break___1;
          }
#line 4520
          if ((unsigned long )p == (unsigned long )wi) {
#line 4521
            goto while_break___1;
          }
#line 4519
          pp = & p->w_next;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 4522
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 4522
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 4523
        *pp = p->w_next;
#line 4524
        p->w_next = windows;
#line 4525
        windows = p;
#line 4526
        WListLinkChanged();
        }
      }
    }
  }
#line 4530
  return;
}
}
#line 4537 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
void SetForeWindow(struct win *wi ) 
{ 
  struct win *p ;

  {
#line 4542
  if ((unsigned long )display == (unsigned long )((struct display *)0)) {
#line 4544
    fore = wi;
#line 4545
    return;
  }
  {
#line 4547
  p = (struct win *)(((display->d_forecv)->c_layer)->l_bottom)->l_data;
#line 4548
  SetCanvasWindow(display->d_forecv, wi);
  }
#line 4549
  if (p) {
    {
#line 4550
    WindowChanged(p, 'u');
    }
  }
#line 4551
  if (wi) {
    {
#line 4552
    WindowChanged(wi, 'u');
    }
  }
#line 4553
  flayer = (display->d_forecv)->c_layer;
#line 4555
  return;
}
}
#line 4564 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
void Activate(int norefresh ) 
{ 
  int tmp ;

  {
  {
#line 4568
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4568
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 4569
  if ((unsigned long )display == (unsigned long )((struct display *)0)) {
#line 4570
    return;
  }
#line 4571
  if (display->d_status) {
    {
#line 4573
    Msg(0, (char *)"%s", "");
#line 4574
    RemoveStatus();
    }
  }
  {
#line 4577
  tmp = MayResizeLayer((display->d_forecv)->c_layer);
  }
#line 4577
  if (tmp) {
    {
#line 4578
    ResizeLayer((display->d_forecv)->c_layer, ((display->d_forecv)->c_xe - (display->d_forecv)->c_xs) + 1,
                ((display->d_forecv)->c_ye - (display->d_forecv)->c_ys) + 1, display);
    }
  }
#line 4580
  fore = display->d_fore;
#line 4581
  if (fore) {
#line 4584
    if (fore->w_monitor != 0) {
#line 4585
      fore->w_monitor = 1;
    }
    {
#line 4586
    fore->w_bell = 0;
#line 4587
    WindowChanged(fore, 'f');
    }
  }
  {
#line 4598
  Redisplay(norefresh + all_norefresh);
  }
#line 4599
  return;
}
}
#line 4602 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static int NextWindow(void) 
{ 
  register struct win **pp ;
  int n ;
  int tmp ;

  {
#line 4606
  if (fore) {
#line 4606
    tmp = fore->w_number;
  } else {
#line 4606
    tmp = -1;
  }
#line 4606
  n = tmp;
#line 4608
  pp = (wtab + n) + 1;
  {
#line 4608
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4608
    if (! ((unsigned long )pp != (unsigned long )(wtab + n))) {
#line 4608
      goto while_break;
    }
#line 4610
    if ((unsigned long )pp == (unsigned long )(wtab + 40)) {
#line 4611
      pp = wtab;
    }
#line 4612
    if (*pp) {
#line 4613
      goto while_break;
    }
#line 4608
    pp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4615
  return ((int )(pp - wtab));
}
}
#line 4618 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static int PreviousWindow(void) 
{ 
  register struct win **pp ;
  int n ;
  int tmp ;

  {
#line 4622
  if (fore) {
#line 4622
    tmp = fore->w_number;
  } else {
#line 4622
    tmp = 39;
  }
#line 4622
  n = tmp;
#line 4624
  pp = (wtab + n) - 1;
  {
#line 4624
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4624
    if (! ((unsigned long )pp != (unsigned long )(wtab + n))) {
#line 4624
      goto while_break;
    }
#line 4626
    if ((unsigned long )pp < (unsigned long )(wtab)) {
#line 4627
      pp = (wtab + 40) - 1;
    }
#line 4628
    if (*pp) {
#line 4629
      goto while_break;
    }
#line 4624
    pp --;
  }
  while_break: /* CIL Label */ ;
  }
#line 4631
  return ((int )(pp - wtab));
}
}
#line 4634 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static int MoreWindows(void) 
{ 
  char *m___0 ;

  {
#line 4637
  m___0 = (char *)"No other window.";
#line 4638
  if (windows) {
#line 4638
    if ((unsigned long )fore == (unsigned long )((struct win *)0)) {
#line 4639
      return (1);
    } else
#line 4638
    if (windows->w_next) {
#line 4639
      return (1);
    }
  }
#line 4640
  if ((unsigned long )fore == (unsigned long )((struct win *)0)) {
    {
#line 4642
    Msg(0, (char *)"No window available");
    }
#line 4643
    return (0);
  }
  {
#line 4645
  Msg(0, m___0, fore->w_number);
  }
#line 4646
  return (0);
}
}
#line 4649 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
void KillWindow(struct win *wi ) 
{ 
  struct win **pp ;
  struct win *p ;
  struct canvas *cv ;
  int gotone ;
  struct win *tmp ;
  int *tmp___0 ;

  {
#line 4660
  pp = & windows;
  {
#line 4660
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4660
    p = *pp;
#line 4660
    if (! p) {
#line 4660
      goto while_break;
    }
#line 4661
    if ((unsigned long )p == (unsigned long )wi) {
#line 4662
      goto while_break;
    }
#line 4660
    pp = & p->w_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4663
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4663
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4664
  *pp = p->w_next;
#line 4665
  wi->w_inlen = 0;
#line 4666
  wtab[wi->w_number] = (struct win *)0;
#line 4668
  if ((unsigned long )windows == (unsigned long )((struct win *)0)) {
    {
#line 4670
    FreeWindow(wi);
#line 4671
    Finit(0);
    }
  }
#line 4677
  display = displays;
  {
#line 4677
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 4677
    if (! display) {
#line 4677
      goto while_break___1;
    }
#line 4679
    gotone = 0;
#line 4680
    cv = display->d_cvlist;
    {
#line 4680
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 4680
      if (! cv) {
#line 4680
        goto while_break___2;
      }
#line 4682
      if ((unsigned long )((struct win *)((cv->c_layer)->l_bottom)->l_data) != (unsigned long )wi) {
#line 4683
        goto __Cont;
      }
      {
#line 4685
      tmp = FindNiceWindow(display->d_other, (char *)0);
#line 4685
      SetCanvasWindow(cv, tmp);
#line 4686
      gotone = 1;
      }
      __Cont: /* CIL Label */ 
#line 4680
      cv = cv->c_next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 4688
    if (gotone) {
#line 4691
      if ((unsigned long )wi->w_zdisplay == (unsigned long )display) {
#line 4693
        display->d_blocked = 0;
#line 4694
        tmp___0 = (int *)0;
#line 4694
        display->d_readev.condneg = tmp___0;
#line 4694
        display->d_readev.condpos = tmp___0;
      }
      {
#line 4697
      Activate(-1);
      }
    }
#line 4677
    display = display->d_next;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 4700
  FreeWindow(wi);
#line 4701
  WindowChanged((struct win *)0, 'w');
#line 4702
  WindowChanged((struct win *)0, 'W');
#line 4703
  WindowChanged((struct win *)0, 0);
  }
#line 4704
  return;
}
}
#line 4706 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static void LogToggle(int on ) 
{ 
  char buf___0[1024] ;
  char const   *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 4712
  if (((unsigned long )fore->w_log != (unsigned long )((struct logfile *)0)) == on) {
#line 4714
    if (display) {
#line 4714
      if (! *rc_name) {
#line 4715
        if (on) {
#line 4715
          tmp = "already";
        } else {
#line 4715
          tmp = "not";
        }
        {
#line 4715
        Msg(0, (char *)"You are %s logging.", tmp);
        }
      }
    }
#line 4716
    return;
  }
#line 4718
  if ((unsigned long )fore->w_log != (unsigned long )((struct logfile *)0)) {
    {
#line 4720
    Msg(0, (char *)"Logfile \"%s\" closed.", (fore->w_log)->name);
#line 4721
    logfclose(fore->w_log);
#line 4722
    fore->w_log = (struct logfile *)0;
#line 4723
    WindowChanged(fore, 'f');
    }
#line 4724
    return;
  }
  {
#line 4726
  tmp___1 = DoStartLog(fore, buf___0, (int )sizeof(buf___0));
  }
#line 4726
  if (tmp___1) {
    {
#line 4728
    tmp___0 = __errno_location();
#line 4728
    Msg(*tmp___0, (char *)"Error opening logfile \"%s\"", buf___0);
    }
#line 4729
    return;
  }
  {
#line 4731
  tmp___2 = ftell((fore->w_log)->fp);
  }
#line 4731
  if (tmp___2 == 0L) {
    {
#line 4732
    Msg(0, (char *)"Creating logfile \"%s\".", (fore->w_log)->name);
    }
  } else {
    {
#line 4734
    Msg(0, (char *)"Appending to logfile \"%s\".", (fore->w_log)->name);
    }
  }
  {
#line 4735
  WindowChanged(fore, 'f');
  }
#line 4736
  return;
}
}
#line 4738 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
char *AddWindows(char *buf___0 , int len , int flags , int where ) 
{ 
  register char *s ;
  register char *ss ;
  register struct win **pp ;
  register struct win *p ;
  register char *cmd ;
  int l ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 4750
  ss = buf___0;
#line 4750
  s = ss;
#line 4751
  if (flags & 4) {
#line 4751
    if (where >= 0) {
#line 4751
      pp = (wtab + where) + 1;
    } else {
#line 4751
      pp = wtab;
    }
  } else {
#line 4751
    pp = wtab;
  }
  {
#line 4751
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4751
    if (! ((unsigned long )pp < (unsigned long )(wtab + 40))) {
#line 4751
      goto while_break;
    }
#line 4753
    if (pp - wtab == (long )where) {
#line 4753
      if ((unsigned long )ss == (unsigned long )buf___0) {
#line 4754
        ss = s;
      }
    }
#line 4755
    p = *pp;
#line 4755
    if ((unsigned long )p == (unsigned long )((struct win *)0)) {
#line 4756
      goto __Cont;
    }
#line 4757
    if (flags & 1) {
#line 4757
      if (display) {
#line 4757
        if ((unsigned long )p == (unsigned long )display->d_fore) {
#line 4758
          goto __Cont;
        }
      }
    }
    {
#line 4760
    cmd = p->w_title;
#line 4761
    tmp = strlen((char const   *)cmd);
#line 4761
    l = (int )tmp;
    }
#line 4762
    if (l > 20) {
#line 4763
      l = 20;
    }
#line 4764
    if ((s - buf___0) + (long )l > (long )(len - 24)) {
#line 4765
      goto while_break;
    }
#line 4766
    if ((unsigned long )s > (unsigned long )buf___0) {
#line 4766
      goto _L;
    } else
#line 4766
    if (flags & 4) {
      _L: /* CIL Label */ 
#line 4768
      tmp___0 = s;
#line 4768
      s ++;
#line 4768
      *tmp___0 = (char )' ';
#line 4769
      tmp___1 = s;
#line 4769
      s ++;
#line 4769
      *tmp___1 = (char )' ';
    }
    {
#line 4771
    sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)"%d", p->w_number);
    }
#line 4772
    if (p->w_number == where) {
#line 4773
      ss = s;
    }
    {
#line 4774
    tmp___2 = strlen((char const   *)s);
#line 4774
    s += tmp___2;
    }
#line 4775
    if (display) {
#line 4775
      if ((unsigned long )p == (unsigned long )display->d_fore) {
#line 4776
        tmp___3 = s;
#line 4776
        s ++;
#line 4776
        *tmp___3 = (char )'*';
      }
    }
#line 4777
    if (! (flags & 2)) {
#line 4779
      if (display) {
#line 4779
        if ((unsigned long )p == (unsigned long )display->d_other) {
#line 4780
          tmp___4 = s;
#line 4780
          s ++;
#line 4780
          *tmp___4 = (char )'-';
        }
      }
      {
#line 4781
      s = AddWindowFlags(s, len, p);
      }
    }
    {
#line 4783
    tmp___5 = s;
#line 4783
    s ++;
#line 4783
    *tmp___5 = (char )' ';
#line 4784
    strncpy((char */* __restrict  */)s, (char const   */* __restrict  */)cmd, (size_t )l);
#line 4785
    s += l;
    }
    __Cont: /* CIL Label */ 
#line 4751
    pp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4787
  *s = (char)0;
#line 4788
  return (ss);
}
}
#line 4791 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
char *AddWindowFlags(char *buf___0 , int len , struct win *p ) 
{ 
  char *s ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 4797
  s = buf___0;
#line 4798
  if ((unsigned long )p == (unsigned long )((struct win *)0)) {
#line 4800
    *s = (char)0;
#line 4801
    return (s);
  } else
#line 4798
  if (len < 12) {
#line 4800
    *s = (char)0;
#line 4801
    return (s);
  }
#line 4809
  if (p->w_layer.l_cvlist) {
#line 4809
    if ((p->w_layer.l_cvlist)->c_lnext) {
#line 4810
      tmp = s;
#line 4810
      s ++;
#line 4810
      *tmp = (char )'&';
    }
  }
#line 4811
  if (p->w_monitor == 3) {
#line 4812
    tmp___0 = s;
#line 4812
    s ++;
#line 4812
    *tmp___0 = (char )'@';
  }
#line 4813
  if (p->w_bell == 2) {
#line 4814
    tmp___1 = s;
#line 4814
    s ++;
#line 4814
    *tmp___1 = (char )'!';
  }
#line 4816
  if ((unsigned long )p->w_slot != (unsigned long )((slot_t )0)) {
#line 4816
    if ((unsigned long )p->w_slot != (unsigned long )((slot_t )-1)) {
#line 4817
      tmp___2 = s;
#line 4817
      s ++;
#line 4817
      *tmp___2 = (char )'$';
    }
  }
#line 4819
  if ((unsigned long )p->w_log != (unsigned long )((struct logfile *)0)) {
    {
#line 4821
    strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)"(L)");
#line 4822
    s += 3;
    }
  }
#line 4824
  if (p->w_ptyfd < 0) {
#line 4825
    tmp___3 = s;
#line 4825
    s ++;
#line 4825
    *tmp___3 = (char )'Z';
  }
#line 4826
  *s = (char)0;
#line 4827
  return (s);
}
}
#line 4830 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
char *AddOtherUsers(char *buf___0 , int len , struct win *p ) 
{ 
  struct display *d ;
  struct display *olddisplay ;
  struct canvas *cv ;
  char *s ;
  int l ;
  char *tmp ;
  size_t tmp___0 ;

  {
#line 4836
  olddisplay = display;
#line 4841
  s = buf___0;
#line 4842
  display = displays;
  {
#line 4842
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4842
    if (! display) {
#line 4842
      goto while_break;
    }
#line 4844
    if ((unsigned long )display->d_user == (unsigned long )olddisplay->d_user) {
#line 4845
      goto __Cont;
    }
#line 4846
    cv = display->d_cvlist;
    {
#line 4846
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4846
      if (! cv) {
#line 4846
        goto while_break___0;
      }
#line 4847
      if ((unsigned long )((struct win *)((cv->c_layer)->l_bottom)->l_data) == (unsigned long )p) {
#line 4848
        goto while_break___0;
      }
#line 4846
      cv = cv->c_next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4849
    if (! cv) {
#line 4850
      goto __Cont;
    }
#line 4851
    d = displays;
    {
#line 4851
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 4851
      if (d) {
#line 4851
        if (! ((unsigned long )d != (unsigned long )display)) {
#line 4851
          goto while_break___1;
        }
      } else {
#line 4851
        goto while_break___1;
      }
#line 4852
      if ((unsigned long )display->d_user == (unsigned long )d->d_user) {
#line 4853
        goto while_break___1;
      }
#line 4851
      d = d->d_next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 4854
    if (d) {
#line 4854
      if ((unsigned long )d != (unsigned long )display) {
#line 4855
        goto __Cont;
      }
    }
#line 4856
    if (len > 1) {
#line 4856
      if ((unsigned long )s != (unsigned long )buf___0) {
#line 4858
        tmp = s;
#line 4858
        s ++;
#line 4858
        *tmp = (char )',';
#line 4859
        len --;
      }
    }
    {
#line 4861
    tmp___0 = strlen((char const   *)((display->d_user)->u_name));
#line 4861
    l = (int )tmp___0;
    }
#line 4862
    if (l + 1 > len) {
#line 4863
      goto while_break;
    }
    {
#line 4864
    strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)((display->d_user)->u_name));
#line 4865
    s += l;
#line 4866
    len -= l;
    }
    __Cont: /* CIL Label */ 
#line 4842
    display = display->d_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 4868
  *s = (char)0;
#line 4869
  display = olddisplay;
#line 4870
  return (s);
}
}
#line 4873 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
void ShowWindows(int where ) 
{ 
  char buf___0[1024] ;
  char *s ;
  char *ss ;
  size_t tmp ;

  {
#line 4880
  if (! display) {
#line 4881
    return;
  }
#line 4882
  if (where == -1) {
#line 4882
    if (display->d_fore) {
#line 4883
      where = (display->d_fore)->w_number;
    }
  }
  {
#line 4884
  ss = AddWindows(buf___0, (int )sizeof(buf___0), 0, where);
#line 4885
  tmp = strlen((char const   *)(buf___0));
#line 4885
  s = buf___0 + tmp;
  }
#line 4886
  if (ss - buf___0 > (long )(display->d_width / 2)) {
#line 4888
    ss -= display->d_width / 2;
#line 4889
    if (s - ss < (long )display->d_width) {
#line 4891
      ss = s - display->d_width;
#line 4892
      if ((unsigned long )ss < (unsigned long )(buf___0)) {
#line 4893
        ss = buf___0;
      }
    }
  } else {
#line 4897
    ss = buf___0;
  }
  {
#line 4898
  Msg(0, (char *)"%s", ss);
  }
#line 4899
  return;
}
}
#line 4901 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static void ShowInfo(void) 
{ 
  char buf___0[512] ;
  char *p ;
  register struct win *wp ;
  register int i ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  size_t tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;

  {
#line 4905
  wp = fore;
#line 4908
  if ((unsigned long )wp == (unsigned long )((struct win *)0)) {
    {
#line 4910
    Msg(0, (char *)"(%d,%d)/(%d,%d) no window", display->d_x + 1, display->d_y + 1,
        display->d_width, display->d_height);
    }
#line 4911
    return;
  }
  {
#line 4913
  p = buf___0;
#line 4914
  tmp___0 = GetAnsiStatus(wp, p);
#line 4914
  p += tmp___0;
  }
#line 4914
  if ((unsigned long )(buf___0) < (unsigned long )p) {
#line 4915
    tmp = p;
#line 4915
    p ++;
#line 4915
    *tmp = (char )' ';
  }
  {
#line 4916
  sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"(%d,%d)/(%d,%d)",
          wp->w_layer.l_x + 1, wp->w_layer.l_y + 1, wp->w_layer.l_width, wp->w_layer.l_height);
#line 4919
  tmp___1 = strlen((char const   *)p);
#line 4919
  p += tmp___1;
#line 4919
  sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"+%d", wp->w_histheight);
  }
#line 4921
  if (wp->w_flow & (1 << 2)) {
#line 4921
    tmp___3 = "";
  } else {
#line 4921
    if (wp->w_flow & (1 << 1)) {
#line 4921
      tmp___2 = "(+)";
    } else {
#line 4921
      tmp___2 = "(-)";
    }
#line 4921
    tmp___3 = tmp___2;
  }
#line 4921
  if (wp->w_flow & 1) {
#line 4921
    tmp___4 = '+';
  } else {
#line 4921
    tmp___4 = '-';
  }
  {
#line 4921
  tmp___5 = strlen((char const   *)p);
#line 4921
  p += tmp___5;
#line 4921
  sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)" %c%sflow",
          tmp___4, tmp___3);
  }
#line 4925
  if (! wp->w_wrap) {
    {
#line 4925
    tmp___6 = strlen((char const   *)p);
#line 4925
    p += tmp___6;
#line 4925
    sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)" -wrap");
    }
  }
#line 4926
  if (wp->w_insert) {
    {
#line 4926
    tmp___7 = strlen((char const   *)p);
#line 4926
    p += tmp___7;
#line 4926
    sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)" ins");
    }
  }
#line 4927
  if (wp->w_origin) {
    {
#line 4927
    tmp___8 = strlen((char const   *)p);
#line 4927
    p += tmp___8;
#line 4927
    sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)" org");
    }
  }
#line 4928
  if (wp->w_keypad) {
    {
#line 4928
    tmp___9 = strlen((char const   *)p);
#line 4928
    p += tmp___9;
#line 4928
    sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)" app");
    }
  }
#line 4929
  if (wp->w_log) {
    {
#line 4929
    tmp___10 = strlen((char const   *)p);
#line 4929
    p += tmp___10;
#line 4929
    sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)" log");
    }
  }
#line 4930
  if (wp->w_monitor != 0) {
    {
#line 4930
    tmp___11 = strlen((char const   *)p);
#line 4930
    p += tmp___11;
#line 4930
    sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)" mon");
    }
  }
#line 4931
  if (wp->w_mouse) {
    {
#line 4931
    tmp___12 = strlen((char const   *)p);
#line 4931
    p += tmp___12;
#line 4931
    sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)" mouse");
    }
  }
#line 4933
  if (wp->w_bce) {
    {
#line 4933
    tmp___13 = strlen((char const   *)p);
#line 4933
    p += tmp___13;
#line 4933
    sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)" bce");
    }
  }
#line 4935
  if (! wp->w_c1) {
    {
#line 4935
    tmp___14 = strlen((char const   *)p);
#line 4935
    p += tmp___14;
#line 4935
    sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)" -c1");
    }
  }
#line 4936
  if (wp->w_norefresh) {
    {
#line 4936
    tmp___15 = strlen((char const   *)p);
#line 4936
    p += tmp___15;
#line 4936
    sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)" nored");
    }
  }
  {
#line 4938
  tmp___16 = strlen((char const   *)p);
#line 4938
  p += tmp___16;
  }
#line 4941
  if (wp->w_layer.l_encoding) {
#line 4941
    if ((unsigned long )display == (unsigned long )((struct display *)0)) {
#line 4941
      goto _L;
    } else
#line 4941
    if (display->d_encoding != wp->w_layer.l_encoding) {
#line 4941
      goto _L;
    } else {
      {
#line 4941
      tmp___20 = EncodingDefFont(wp->w_layer.l_encoding);
      }
#line 4941
      if (tmp___20 <= 0) {
        _L: /* CIL Label */ 
        {
#line 4943
        tmp___17 = p;
#line 4943
        p ++;
#line 4943
        *tmp___17 = (char )' ';
#line 4944
        tmp___18 = EncodingName(wp->w_layer.l_encoding);
#line 4944
        strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)tmp___18);
#line 4945
        tmp___19 = strlen((char const   *)p);
#line 4945
        p += tmp___19;
        }
      }
    }
  }
#line 4948
  if (wp->w_layer.l_encoding != 8) {
#line 4951
    if (display->d_tcs[100].str) {
#line 4951
      goto _L___0;
    } else
#line 4951
    if (display->d_tcs[98].str) {
#line 4951
      if (*(display->d_tcs[98].str)) {
        _L___0: /* CIL Label */ 
#line 4953
        if (wp->w_gr == 2) {
          {
#line 4955
          sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)" G%c",
                  wp->w_Charset + 48);
          }
#line 4956
          if ((int )wp->w_FontE >= 32) {
#line 4957
            *(p + 3) = wp->w_FontE;
          } else {
#line 4960
            *(p + 3) = (char )'^';
#line 4961
            *(p + 4) = (char )((int )wp->w_FontE ^ 64);
#line 4962
            p ++;
          }
#line 4964
          *(p + 4) = (char )'[';
#line 4965
          p ++;
        } else
#line 4967
        if (wp->w_gr) {
          {
#line 4968
          tmp___21 = p;
#line 4968
          p ++;
#line 4968
          sprintf((char */* __restrict  */)tmp___21, (char const   */* __restrict  */)" G%c%c[",
                  wp->w_Charset + 48, wp->w_CharsetR + 48);
          }
        } else {
          {
#line 4970
          sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)" G%c[",
                  wp->w_Charset + 48);
          }
        }
#line 4971
        p += 4;
#line 4972
        i = 0;
        {
#line 4972
        while (1) {
          while_continue: /* CIL Label */ ;
#line 4972
          if (! (i < 4)) {
#line 4972
            goto while_break;
          }
#line 4974
          if (wp->w_charsets[i] == 0) {
#line 4975
            tmp___22 = p;
#line 4975
            p ++;
#line 4975
            *tmp___22 = (char )'B';
          } else
#line 4976
          if (wp->w_charsets[i] >= 32) {
#line 4977
            tmp___23 = p;
#line 4977
            p ++;
#line 4977
            *tmp___23 = (char )wp->w_charsets[i];
          } else {
#line 4980
            tmp___24 = p;
#line 4980
            p ++;
#line 4980
            *tmp___24 = (char )'^';
#line 4981
            tmp___25 = p;
#line 4981
            p ++;
#line 4981
            *tmp___25 = (char )(wp->w_charsets[i] ^ 64);
          }
#line 4972
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 4984
        tmp___26 = p;
#line 4984
        p ++;
#line 4984
        *tmp___26 = (char )']';
#line 4985
        *p = (char)0;
      }
    }
  }
#line 4989
  if (wp->w_type == 1) {
    {
#line 4992
    tmp___27 = p;
#line 4992
    p ++;
#line 4992
    *tmp___27 = (char )' ';
#line 4993
    TtyGetModemStatus(wp->w_ptyfd, p);
    }
  }
  {
#line 5002
  Msg(0, (char *)"%s %d(%s)", buf___0, wp->w_number, wp->w_title);
  }
#line 5003
  return;
}
}
#line 5005 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static void ShowDInfo(void) 
{ 
  char buf___0[512] ;
  char *p ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;

  {
#line 5009
  if ((unsigned long )display == (unsigned long )((struct display *)0)) {
#line 5010
    return;
  }
  {
#line 5011
  p = buf___0;
#line 5012
  sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"(%d,%d)",
          display->d_width, display->d_height);
#line 5012
  tmp = strlen((char const   *)p);
#line 5012
  p += tmp;
  }
#line 5015
  if (display->d_encoding) {
    {
#line 5017
    tmp___0 = p;
#line 5017
    p ++;
#line 5017
    *tmp___0 = (char )' ';
#line 5018
    tmp___1 = EncodingName(display->d_encoding);
#line 5018
    strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)tmp___1);
#line 5019
    tmp___2 = strlen((char const   *)p);
#line 5019
    p += tmp___2;
    }
  }
#line 5022
  if (display->d_tcs[96].flg) {
    {
#line 5024
    strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)" xterm");
#line 5025
    tmp___3 = strlen((char const   *)p);
#line 5025
    p += tmp___3;
    }
  }
#line 5028
  if (display->d_hascolor) {
    {
#line 5030
    strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)" color");
#line 5031
    tmp___4 = strlen((char const   *)p);
#line 5031
    p += tmp___4;
    }
  }
#line 5035
  if (display->d_tcs[97].flg) {
    {
#line 5037
    strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)" iso2022");
#line 5038
    tmp___5 = strlen((char const   *)p);
#line 5038
    p += tmp___5;
    }
  } else
#line 5040
  if (display->d_tcs[98].str) {
#line 5040
    if (*(display->d_tcs[98].str)) {
      {
#line 5042
      strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)" altchar");
#line 5043
      tmp___6 = strlen((char const   *)p);
#line 5043
      p += tmp___6;
      }
    }
  }
  {
#line 5046
  Msg(0, (char *)"%s", buf___0);
  }
#line 5047
  return;
}
}
#line 5049 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static void AKAfin(char *buf___0 , int len , char *data ) 
{ 
  size_t tmp ;

  {
  {
#line 5055
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5055
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 5056
  if (len) {
#line 5056
    if (fore) {
      {
#line 5057
      tmp = strlen((char const   *)buf___0);
#line 5057
      ChangeAKA(fore, buf___0, (int )tmp);
      }
    }
  }
#line 5058
  return;
}
}
#line 5060 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static void InputAKA(void) 
{ 
  char *s ;
  char *ss ;
  int n ;

  {
  {
#line 5065
  Input((char *)"Set window\'s title to: ", (int )(sizeof(fore->w_akabuf) - 1UL),
        0, & AKAfin, (char *)((void *)0));
#line 5066
  s = fore->w_title;
  }
#line 5067
  if (! s) {
#line 5068
    return;
  }
  {
#line 5069
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5069
    if (! *s) {
#line 5069
      goto while_break;
    }
#line 5071
    if (((int )*((unsigned char *)s) & 127) < 32) {
#line 5072
      goto __Cont;
    } else
#line 5071
    if ((int )*s == 127) {
#line 5072
      goto __Cont;
    }
    {
#line 5073
    ss = s;
#line 5074
    n = 1;
#line 5075
    (*((flayer->l_layfn)->lf_LayProcess))(& ss, & n);
    }
    __Cont: /* CIL Label */ 
#line 5069
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5077
  return;
}
}
#line 5079 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static void Colonfin(char *buf___0 , int len , char *data ) 
{ 
  char mbuf[256] ;
  size_t tmp ;

  {
#line 5086
  if (len) {
    {
#line 5088
    tmp = strlen((char const   *)buf___0);
#line 5088
    len = (int )(tmp + 1U);
    }
#line 5089
    if (len > (int )sizeof(mbuf)) {
      {
#line 5090
      RcLine(buf___0, len);
      }
    } else {
      {
#line 5093
      bcopy((void const   *)buf___0, (void *)(mbuf), (size_t )len);
#line 5094
      RcLine(mbuf, (int )sizeof(mbuf));
      }
    }
  }
#line 5097
  return;
}
}
#line 5099 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static void SelectFin(char *buf___0 , int len , char *data ) 
{ 
  int n ;

  {
#line 5107
  if (! len) {
#line 5108
    return;
  } else
#line 5107
  if (! display) {
#line 5108
    return;
  }
#line 5109
  if (len == 1) {
#line 5109
    if ((int )*buf___0 == 45) {
      {
#line 5111
      SetForeWindow((struct win *)0);
#line 5112
      Activate(0);
      }
#line 5113
      return;
    }
  }
  {
#line 5115
  n = WindowByNoN(buf___0);
  }
#line 5115
  if (n < 0) {
#line 5116
    return;
  }
  {
#line 5117
  SwitchWindow(n);
  }
#line 5118
  return;
}
}
#line 5120 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static void InputSelect(void) 
{ 


  {
  {
#line 5123
  Input((char *)"Switch to window: ", 20, 0, & SelectFin, (char *)((void *)0));
  }
#line 5124
  return;
}
}
#line 5126 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static char setenv_var[31]  ;
#line 5129 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static void SetenvFin1(char *buf___0 , int len , char *data ) 
{ 


  {
#line 5135
  if (! len) {
#line 5136
    return;
  } else
#line 5135
  if (! display) {
#line 5136
    return;
  }
  {
#line 5137
  InputSetenv(buf___0);
  }
#line 5138
  return;
}
}
#line 5140 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static void SetenvFin2(char *buf___0 , int len , char *data ) 
{ 


  {
#line 5146
  if (! len) {
#line 5147
    return;
  } else
#line 5146
  if (! display) {
#line 5147
    return;
  }
  {
#line 5148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5148
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5149
  xsetenv(setenv_var, buf___0);
#line 5150
  MakeNewEnv();
  }
#line 5151
  return;
}
}
#line 5157 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static char setenv_buf[81UL]  ;
#line 5153 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static void InputSetenv(char *arg ) 
{ 


  {
#line 5159
  if (arg) {
    {
#line 5161
    strncpy((char */* __restrict  */)(setenv_var), (char const   */* __restrict  */)arg,
            (size_t )(sizeof(setenv_var) - 1UL));
#line 5162
    sprintf((char */* __restrict  */)(setenv_buf), (char const   */* __restrict  */)"Enter value for %s: ",
            setenv_var);
#line 5163
    Input(setenv_buf, 30, 0, & SetenvFin2, (char *)((void *)0));
    }
  } else {
    {
#line 5166
    Input((char *)"Setenv: Enter variable name: ", 30, 0, & SetenvFin1, (char *)((void *)0));
    }
  }
#line 5167
  return;
}
}
#line 5176 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
void DoScreen(char *fn , char **av ) 
{ 
  struct NewWindow nwin ;
  register int num ;
  char buf___0[20] ;
  int tmp ;

  {
#line 5184
  nwin = nwin_undef;
  {
#line 5185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5185
    if (av) {
#line 5185
      if (*av) {
#line 5185
        if (! ((int )*(*(av + 0) + 0) == 45)) {
#line 5185
          goto while_break;
        }
      } else {
#line 5185
        goto while_break;
      }
    } else {
#line 5185
      goto while_break;
    }
#line 5187
    if ((int )*(*(av + 0) + 1) == 45) {
#line 5189
      av ++;
#line 5190
      goto while_break;
    }
    {
#line 5194
    if ((int )*(*(av + 0) + 1) == 102) {
#line 5194
      goto case_102;
    }
#line 5213
    if ((int )*(*(av + 0) + 1) == 116) {
#line 5213
      goto case_116;
    }
#line 5221
    if ((int )*(*(av + 0) + 1) == 84) {
#line 5221
      goto case_84;
    }
#line 5229
    if ((int )*(*(av + 0) + 1) == 104) {
#line 5229
      goto case_104;
    }
#line 5238
    if ((int )*(*(av + 0) + 1) == 108) {
#line 5238
      goto case_108;
    }
#line 5258
    if ((int )*(*(av + 0) + 1) == 97) {
#line 5258
      goto case_97___1;
    }
#line 5261
    if ((int )*(*(av + 0) + 1) == 77) {
#line 5261
      goto case_77;
    }
#line 5264
    if ((int )*(*(av + 0) + 1) == 76) {
#line 5264
      goto case_76;
    }
#line 5267
    goto switch_default___1;
    case_102: /* CIL Label */ 
    {
#line 5198
    if ((int )*(*(av + 0) + 2) == 48) {
#line 5198
      goto case_48;
    }
#line 5198
    if ((int )*(*(av + 0) + 2) == 110) {
#line 5198
      goto case_48;
    }
#line 5203
    if ((int )*(*(av + 0) + 2) == 0) {
#line 5203
      goto case_0;
    }
#line 5203
    if ((int )*(*(av + 0) + 2) == 49) {
#line 5203
      goto case_0;
    }
#line 5203
    if ((int )*(*(av + 0) + 2) == 121) {
#line 5203
      goto case_0;
    }
#line 5206
    if ((int )*(*(av + 0) + 2) == 97) {
#line 5206
      goto case_97;
    }
#line 5209
    goto switch_default;
    case_48: /* CIL Label */ 
    case_110: /* CIL Label */ 
#line 5199
    nwin.flowflag = 0;
#line 5200
    goto switch_break___0;
    case_0: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_121: /* CIL Label */ 
#line 5204
    nwin.flowflag = 1;
#line 5205
    goto switch_break___0;
    case_97: /* CIL Label */ 
#line 5207
    nwin.flowflag = 1 << 2;
#line 5208
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 5210
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 5212
    goto switch_break;
    case_116: /* CIL Label */ 
#line 5214
    if (*(*(av + 0) + 2)) {
#line 5215
      nwin.aka = *(av + 0) + 2;
    } else {
#line 5216
      av ++;
#line 5216
      if (*av) {
#line 5217
        nwin.aka = *av;
      } else {
#line 5219
        av --;
      }
    }
#line 5220
    goto switch_break;
    case_84: /* CIL Label */ 
#line 5222
    if (*(*(av + 0) + 2)) {
#line 5223
      nwin.term = *(av + 0) + 2;
    } else {
#line 5224
      av ++;
#line 5224
      if (*av) {
#line 5225
        nwin.term = *av;
      } else {
#line 5227
        av --;
      }
    }
#line 5228
    goto switch_break;
    case_104: /* CIL Label */ 
#line 5230
    if (*(*(av + 0) + 2)) {
      {
#line 5231
      nwin.histheight = atoi((char const   *)(*(av + 0) + 2));
      }
    } else {
#line 5232
      av ++;
#line 5232
      if (*av) {
        {
#line 5233
        nwin.histheight = atoi((char const   *)*av);
        }
      } else {
#line 5235
        av --;
      }
    }
#line 5236
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 5242
    if ((int )*(*(av + 0) + 2) == 48) {
#line 5242
      goto case_48___0;
    }
#line 5242
    if ((int )*(*(av + 0) + 2) == 110) {
#line 5242
      goto case_48___0;
    }
#line 5247
    if ((int )*(*(av + 0) + 2) == 0) {
#line 5247
      goto case_0___0;
    }
#line 5247
    if ((int )*(*(av + 0) + 2) == 49) {
#line 5247
      goto case_0___0;
    }
#line 5247
    if ((int )*(*(av + 0) + 2) == 121) {
#line 5247
      goto case_0___0;
    }
#line 5250
    if ((int )*(*(av + 0) + 2) == 97) {
#line 5250
      goto case_97___0;
    }
#line 5253
    goto switch_default___0;
    case_48___0: /* CIL Label */ 
    case_110___0: /* CIL Label */ 
#line 5243
    nwin.lflag = 0;
#line 5244
    goto switch_break___1;
    case_0___0: /* CIL Label */ 
    case_49___0: /* CIL Label */ 
    case_121___0: /* CIL Label */ 
#line 5248
    nwin.lflag = 1;
#line 5249
    goto switch_break___1;
    case_97___0: /* CIL Label */ 
#line 5251
    nwin.lflag = 3;
#line 5252
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
#line 5254
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 5256
    goto switch_break;
    case_97___1: /* CIL Label */ 
#line 5259
    nwin.aflag = 1;
#line 5260
    goto switch_break;
    case_77: /* CIL Label */ 
#line 5262
    nwin.monitor = 1;
#line 5263
    goto switch_break;
    case_76: /* CIL Label */ 
#line 5265
    nwin.Lflag = 1;
#line 5266
    goto switch_break;
    switch_default___1: /* CIL Label */ 
    {
#line 5268
    Msg(0, (char *)"%s: screen: invalid option -%c.", fn, (int )*(*(av + 0) + 1));
    }
#line 5269
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 5271
    av ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5273
  num = 0;
#line 5274
  if (av) {
#line 5274
    if (*av) {
      {
#line 5274
      tmp = IsNumColon(*av, 10, buf___0, (int )sizeof(buf___0));
      }
#line 5274
      if (tmp) {
#line 5276
        if ((int )buf___0[0] != 0) {
#line 5277
          nwin.aka = buf___0;
        }
        {
#line 5278
        num = atoi((char const   *)*av);
        }
#line 5279
        if (num < 0) {
          {
#line 5281
          Msg(0, (char *)"%s: illegal screen number %d.", fn, num);
#line 5282
          num = 0;
          }
        } else
#line 5279
        if (num > 39) {
          {
#line 5281
          Msg(0, (char *)"%s: illegal screen number %d.", fn, num);
#line 5282
          num = 0;
          }
        }
#line 5284
        nwin.StartAt = num;
#line 5285
        av ++;
      }
    }
  }
#line 5287
  if (av) {
#line 5287
    if (*av) {
#line 5289
      nwin.args = av;
#line 5290
      if (! nwin.aka) {
        {
#line 5291
        nwin.aka = Filename(*av);
        }
      }
    }
  }
  {
#line 5293
  MakeWindow(& nwin);
  }
#line 5294
  return;
}
}
#line 5306 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
int CompileKeys(char *s , int sl , unsigned char *array ) 
{ 
  int i ;
  unsigned char key ;
  unsigned char value ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 5315
  if (sl == 0) {
#line 5317
    i = 0;
    {
#line 5317
    while (1) {
      while_continue: /* CIL Label */ ;
#line 5317
      if (! (i < 256)) {
#line 5317
        goto while_break;
      }
#line 5318
      *(array + i) = (unsigned char )i;
#line 5317
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 5319
    return (0);
  }
  {
#line 5321
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5321
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 5322
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 5322
    if (! sl) {
#line 5322
      goto while_break___1;
    }
#line 5324
    tmp = s;
#line 5324
    s ++;
#line 5324
    key = *((unsigned char *)tmp);
#line 5325
    if ((int )*s != 61) {
#line 5326
      return (-1);
    } else
#line 5325
    if (sl < 3) {
#line 5326
      return (-1);
    }
#line 5327
    sl --;
    {
#line 5328
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 5330
      s ++;
#line 5331
      sl -= 2;
#line 5332
      tmp___0 = s;
#line 5332
      s ++;
#line 5332
      value = *((unsigned char *)tmp___0);
#line 5333
      *(array + value) = key;
#line 5328
      if ((int )*s == 61) {
#line 5328
        if (! (sl >= 2)) {
#line 5328
          goto while_break___2;
        }
      } else {
#line 5328
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 5336
    if (sl == 0) {
#line 5337
      goto while_break___1;
    }
#line 5338
    tmp___1 = s;
#line 5338
    s ++;
#line 5338
    if ((int )*tmp___1 != 58) {
#line 5339
      return (-1);
    }
#line 5340
    sl --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 5342
  return (0);
}
}
#line 5351 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static void pow_detach_fn(char *buf___0 , int len , char *data ) 
{ 


  {
  {
#line 5357
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5357
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 5358
  if (len) {
#line 5360
    *buf___0 = (char)0;
#line 5361
    return;
  }
#line 5363
  if (ktab[(int )((unsigned char )*buf___0)].nr != 117) {
#line 5365
    if (display) {
      {
#line 5366
      write(display->d_userfd, (void const   *)"\a", (size_t )1);
      }
    }
    {
#line 5367
    Msg(0, (char *)"Detach aborted.");
    }
  } else {
    {
#line 5370
    Detach(3);
    }
  }
#line 5371
  return;
}
}
#line 5375 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static void copy_reg_fn(char *buf___0 , int len , char *data ) 
{ 
  struct plop *pp ;
  char *tmp ;
  void *tmp___0 ;

  {
#line 5381
  pp = plop_tab + (int )((unsigned char )*buf___0);
#line 5383
  if (len) {
#line 5385
    *buf___0 = (char)0;
#line 5386
    return;
  }
#line 5388
  if (pp->buf) {
    {
#line 5389
    free((void *)pp->buf);
    }
  }
#line 5390
  pp->buf = (char *)0;
#line 5391
  pp->len = 0;
#line 5392
  if ((display->d_user)->u_plop.len) {
    {
#line 5394
    tmp___0 = malloc((size_t )(display->d_user)->u_plop.len);
#line 5394
    tmp = (char *)tmp___0;
#line 5394
    pp->buf = tmp;
    }
#line 5394
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      {
#line 5396
      Msg(0, strnomem);
      }
#line 5397
      return;
    }
    {
#line 5399
    bcopy((void const   *)(display->d_user)->u_plop.buf, (void *)pp->buf, (size_t )(display->d_user)->u_plop.len);
    }
  }
  {
#line 5401
  pp->len = (display->d_user)->u_plop.len;
#line 5403
  pp->enc = (display->d_user)->u_plop.enc;
#line 5405
  Msg(0, (char *)"Copied %d characters into register %c", (display->d_user)->u_plop.len,
      (int )*buf___0);
  }
#line 5406
  return;
}
}
#line 5408 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static void ins_reg_fn(char *buf___0 , int len , char *data ) 
{ 
  struct plop *pp ;

  {
#line 5414
  pp = plop_tab + (int )((unsigned char )*buf___0);
#line 5417
  if (! fore) {
#line 5418
    return;
  }
#line 5419
  if ((int )*buf___0 == 46) {
    {
#line 5420
    Msg(0, (char *)"ins_reg_fn: Warning: pasting real register \'.\'!");
    }
  }
#line 5421
  if (len) {
#line 5423
    *buf___0 = (char)0;
#line 5424
    return;
  }
#line 5426
  if (pp->buf) {
    {
#line 5428
    MakePaster(& fore->w_paster, pp->buf, pp->len, 0);
    }
#line 5429
    return;
  }
  {
#line 5431
  Msg(0, (char *)"Empty register.");
  }
#line 5432
  return;
}
}
#line 5435 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static void process_fn(char *buf___0 , int len , char *data ) 
{ 
  struct plop *pp ;

  {
#line 5441
  pp = plop_tab + (int )((unsigned char )*buf___0);
#line 5443
  if (len) {
#line 5445
    *buf___0 = (char)0;
#line 5446
    return;
  }
#line 5448
  if (pp->buf) {
    {
#line 5450
    ProcessInput(pp->buf, pp->len);
    }
#line 5451
    return;
  }
  {
#line 5453
  Msg(0, (char *)"Empty register.");
  }
#line 5454
  return;
}
}
#line 5456 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static void confirm_fn(char *buf___0 , int len , char *data ) 
{ 
  struct action act ;

  {
#line 5464
  if (len) {
#line 5466
    *buf___0 = (char)0;
#line 5467
    return;
  } else
#line 5464
  if ((int )*buf___0 != 121) {
#line 5464
    if ((int )*buf___0 != 89) {
#line 5466
      *buf___0 = (char)0;
#line 5467
      return;
    }
  }
  {
#line 5469
  act.nr = (int )data;
#line 5470
  act.args = noargs;
#line 5471
  act.argl = (int *)0;
#line 5472
  DoAction(& act, -1);
  }
#line 5473
  return;
}
}
#line 5484 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static void su_fin(char *buf___0 , int len , char *data ) 
{ 
  struct inputsu *i ;
  char *p ;
  int l ;
  int tmp ;

  {
#line 5490
  i = (struct inputsu *)data;
#line 5494
  if (! i->name[0]) {
#line 5495
    p = i->name;
#line 5495
    l = (int )(sizeof(i->name) - 1UL);
  } else
#line 5496
  if (! i->pw1[0]) {
    {
#line 5497
    p = i->pw1;
#line 5497
    strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)"\377");
#line 5497
    l = (int )(sizeof(i->pw1) - 1UL);
    }
  } else {
    {
#line 5499
    p = i->pw2;
#line 5499
    strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)"\377");
#line 5499
    l = (int )(sizeof(i->pw2) - 1UL);
    }
  }
#line 5500
  if (buf___0) {
#line 5500
    if (len) {
#line 5501
      if (1 + (l < len)) {
#line 5501
        tmp = l;
      } else {
#line 5501
        tmp = len;
      }
      {
#line 5501
      strncpy((char */* __restrict  */)p, (char const   */* __restrict  */)buf___0,
              (size_t )tmp);
      }
    }
  }
#line 5502
  if (! i->name[0]) {
    {
#line 5503
    Input((char *)"Screen User: ", (int )(sizeof(i->name) - 1UL), 0, & su_fin, (char *)i);
    }
  } else
#line 5504
  if (! i->pw1[0]) {
    {
#line 5505
    Input((char *)"User\'s UNIX Password: ", (int )(sizeof(i->pw1) - 1UL), 1, & su_fin,
          (char *)i);
    }
  } else
#line 5506
  if (! i->pw2[0]) {
    {
#line 5507
    Input((char *)"User\'s Screen Password: ", (int )(sizeof(i->pw2) - 1UL), 1, & su_fin,
          (char *)i);
    }
  } else {
    {
#line 5510
    p = DoSu(i->up, i->name, i->pw2, i->pw1);
    }
#line 5510
    if (p) {
      {
#line 5511
      Msg(0, (char *)"%s", p);
      }
    }
    {
#line 5512
    free((void *)((char *)i));
    }
  }
#line 5514
  return;
}
}
#line 5516 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static int InputSu(struct win *w , struct acluser **up , char *name ) 
{ 
  struct inputsu *i ;
  void *tmp ;
  size_t tmp___0 ;

  {
  {
#line 5524
  tmp = calloc((size_t )1, (size_t )sizeof(struct inputsu ));
#line 5524
  i = (struct inputsu *)tmp;
  }
#line 5524
  if (! i) {
#line 5525
    return (-1);
  }
#line 5527
  i->up = up;
#line 5528
  if (name) {
#line 5528
    if (*name) {
      {
#line 5529
      tmp___0 = strlen((char const   *)name);
#line 5529
      su_fin(name, (int )tmp___0, (char *)i);
      }
    } else {
      {
#line 5531
      su_fin((char *)0, 0, (char *)i);
      }
    }
  } else {
    {
#line 5531
    su_fin((char *)0, 0, (char *)i);
    }
  }
#line 5532
  return (0);
}
}
#line 5538 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static void pass1(char *buf___0 , int len , char *data ) 
{ 
  struct acluser *u ;
  size_t tmp ;

  {
#line 5544
  u = (struct acluser *)data;
#line 5546
  if (! *buf___0) {
#line 5547
    return;
  }
  {
#line 5548
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5548
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 5549
  if ((unsigned long )u->u_password != (unsigned long )(NullStr)) {
    {
#line 5550
    free((void *)u->u_password);
    }
  }
  {
#line 5551
  u->u_password = SaveStr((char const   *)buf___0);
#line 5552
  tmp = strlen((char const   *)buf___0);
#line 5552
  bzero((void *)buf___0, tmp);
#line 5553
  Input((char *)"Retype new password:", 100, 1, & pass2, data);
  }
#line 5554
  return;
}
}
#line 5556 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static void pass2(char *buf___0 , int len , char *data ) 
{ 
  int st ;
  char salt[3] ;
  struct acluser *u ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  time_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;

  {
#line 5564
  u = (struct acluser *)data;
  {
#line 5566
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5566
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 5567
  if (! buf___0) {
#line 5567
    goto _L;
  } else {
    {
#line 5567
    tmp___1 = strcmp((char const   *)u->u_password, (char const   *)buf___0);
    }
#line 5567
    if (tmp___1) {
      _L: /* CIL Label */ 
      {
#line 5569
      Msg(0, (char *)"[ Passwords don\'t match - checking turned off ]");
      }
#line 5570
      if ((unsigned long )u->u_password != (unsigned long )(NullStr)) {
        {
#line 5572
        tmp = strlen((char const   *)u->u_password);
#line 5572
        bzero((void *)u->u_password, tmp);
#line 5573
        free((void *)u->u_password);
        }
      }
#line 5575
      u->u_password = NullStr;
    } else
#line 5577
    if ((int )*(u->u_password + 0) == 0) {
      {
#line 5579
      Msg(0, (char *)"[ No password - no secure ]");
      }
#line 5580
      if (buf___0) {
        {
#line 5581
        tmp___0 = strlen((char const   *)buf___0);
#line 5581
        bzero((void *)buf___0, tmp___0);
        }
      }
    }
  }
#line 5584
  if ((unsigned long )u->u_password != (unsigned long )(NullStr)) {
#line 5586
    st = 0;
    {
#line 5586
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 5586
      if (! (st < 2)) {
#line 5586
        goto while_break___0;
      }
      {
#line 5587
      tmp___2 = time((time_t *)0);
#line 5587
      salt[st] = (char )(65 + (int )((tmp___2 >> 6 * st) % 26L));
#line 5586
      st ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 5588
    salt[2] = (char)0;
#line 5589
    buf___0 = crypt(u->u_password, salt);
#line 5590
    tmp___3 = strlen((char const   *)u->u_password);
#line 5590
    bzero((void *)u->u_password, tmp___3);
#line 5591
    free((void *)u->u_password);
#line 5592
    u->u_password = SaveStr((char const   *)buf___0);
#line 5593
    tmp___4 = strlen((char const   *)buf___0);
#line 5593
    bzero((void *)buf___0, tmp___4);
    }
#line 5595
    if (u->u_plop.buf) {
      {
#line 5596
      UserFreeCopyBuffer(u);
      }
    }
    {
#line 5597
    tmp___5 = strlen((char const   *)u->u_password);
#line 5597
    u->u_plop.len = (int )tmp___5;
#line 5599
    u->u_plop.enc = 0;
#line 5601
    tmp___6 = SaveStr((char const   *)u->u_password);
#line 5601
    u->u_plop.buf = tmp___6;
    }
#line 5601
    if (tmp___6) {
      {
#line 5607
      Msg(0, (char *)"[ Password moved into copybuffer ]");
      }
    } else {
      {
#line 5603
      Msg(0, strnomem);
#line 5604
      (display->d_user)->u_plop.len = 0;
      }
    }
  }
#line 5612
  return;
}
}
#line 5615 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static void digraph_fn(char *buf___0 , int len , char *data ) 
{ 
  int ch ;
  int i ;
  int x ;
  int tmp ;

  {
#line 5623
  ch = (int )*(buf___0 + len);
#line 5624
  if (ch) {
#line 5626
    if (ch < 32) {
#line 5627
      return;
    } else
#line 5626
    if (ch == 127) {
#line 5627
      return;
    }
#line 5628
    if (len >= 1) {
#line 5628
      if ((int )*buf___0 == 85) {
#line 5628
        if ((int )*(buf___0 + 1) == 43) {
#line 5628
          goto _L___2;
        } else {
#line 5628
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 5628
      if ((int )*buf___0 == 48) {
#line 5628
        if ((int )*(buf___0 + 1) == 120) {
#line 5628
          goto _L___2;
        } else
#line 5628
        if ((int )*(buf___0 + 1) == 88) {
          _L___2: /* CIL Label */ 
#line 5630
          if (len == 1) {
#line 5631
            return;
          }
#line 5632
          if (ch < 48) {
#line 5632
            goto _L___0;
          } else
#line 5632
          if (ch > 57) {
            _L___0: /* CIL Label */ 
#line 5632
            if (ch < 97) {
#line 5632
              goto _L;
            } else
#line 5632
            if (ch > 102) {
              _L: /* CIL Label */ 
#line 5632
              if (ch < 65) {
#line 5634
                *(buf___0 + len) = (char )'\034';
#line 5635
                return;
              } else
#line 5632
              if (ch > 70) {
#line 5634
                *(buf___0 + len) = (char )'\034';
#line 5635
                return;
              }
            }
          }
#line 5637
          if ((int )*buf___0 == 85) {
#line 5637
            tmp = 5;
          } else {
#line 5637
            tmp = 3;
          }
#line 5637
          if (len == tmp) {
#line 5638
            *(buf___0 + len) = (char )'\n';
          }
#line 5639
          return;
        }
      }
    }
#line 5641
    if (len) {
#line 5641
      if ((int )*buf___0 == 48) {
#line 5643
        if (ch < 48) {
#line 5645
          *(buf___0 + len) = (char )'\034';
#line 5646
          return;
        } else
#line 5643
        if (ch > 55) {
#line 5645
          *(buf___0 + len) = (char )'\034';
#line 5646
          return;
        }
#line 5648
        if (len == 3) {
#line 5649
          *(buf___0 + len) = (char )'\n';
        }
#line 5650
        return;
      }
    }
#line 5652
    if (len == 1) {
#line 5653
      *(buf___0 + len) = (char )'\n';
    }
#line 5654
    return;
  }
#line 5656
  *(buf___0 + len) = *(buf___0 + (len + 1));
#line 5657
  len ++;
#line 5658
  if (len < 2) {
#line 5659
    return;
  }
#line 5660
  if (len >= 1) {
#line 5660
    if ((int )*buf___0 == 85) {
#line 5660
      if ((int )*(buf___0 + 1) == 43) {
#line 5660
        goto _L___9;
      } else {
#line 5660
        goto _L___10;
      }
    } else
    _L___10: /* CIL Label */ 
#line 5660
    if ((int )*buf___0 == 48) {
#line 5660
      if ((int )*(buf___0 + 1) == 120) {
#line 5660
        goto _L___9;
      } else
#line 5660
      if ((int )*(buf___0 + 1) == 88) {
        _L___9: /* CIL Label */ 
#line 5662
        x = 0;
#line 5663
        i = 2;
        {
#line 5663
        while (1) {
          while_continue: /* CIL Label */ ;
#line 5663
          if (! (i < len)) {
#line 5663
            goto while_break;
          }
#line 5665
          if ((int )*(buf___0 + i) >= 48) {
#line 5665
            if ((int )*(buf___0 + i) <= 57) {
#line 5666
              x = x * 16 | ((int )*(buf___0 + i) - 48);
            } else {
#line 5665
              goto _L___5;
            }
          } else
          _L___5: /* CIL Label */ 
#line 5667
          if ((int )*(buf___0 + i) >= 97) {
#line 5667
            if ((int )*(buf___0 + i) <= 102) {
#line 5668
              x = x * 16 | ((int )*(buf___0 + i) - 87);
            } else {
#line 5667
              goto _L___4;
            }
          } else
          _L___4: /* CIL Label */ 
#line 5669
          if ((int )*(buf___0 + i) >= 65) {
#line 5669
            if ((int )*(buf___0 + i) <= 70) {
#line 5670
              x = x * 16 | ((int )*(buf___0 + i) - 55);
            } else {
#line 5672
              goto while_break;
            }
          } else {
#line 5672
            goto while_break;
          }
#line 5663
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
      } else {
#line 5660
        goto _L___7;
      }
    } else {
#line 5660
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
#line 5675
  if ((int )*(buf___0 + 0) == 48) {
#line 5677
    x = 0;
#line 5678
    i = 1;
    {
#line 5678
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 5678
      if (! (i < len)) {
#line 5678
        goto while_break___0;
      }
#line 5680
      if ((int )*(buf___0 + i) < 48) {
#line 5681
        goto while_break___0;
      } else
#line 5680
      if ((int )*(buf___0 + i) > 55) {
#line 5681
        goto while_break___0;
      }
#line 5682
      x = x * 8 | ((int )*(buf___0 + i) - 48);
#line 5678
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 5687
    i = 0;
    {
#line 5687
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 5687
      if (! (i < (int )(sizeof(digraphs) / sizeof(digraphs[0])))) {
#line 5687
        goto while_break___1;
      }
#line 5688
      if ((int const   )digraphs[i][0] == (int const   )((unsigned char )*(buf___0 + 0))) {
#line 5688
        if ((int const   )digraphs[i][1] == (int const   )((unsigned char )*(buf___0 + 1))) {
#line 5690
          goto while_break___1;
        } else {
#line 5688
          goto _L___6;
        }
      } else
      _L___6: /* CIL Label */ 
#line 5688
      if ((int const   )digraphs[i][0] == (int const   )((unsigned char )*(buf___0 + 1))) {
#line 5688
        if ((int const   )digraphs[i][1] == (int const   )((unsigned char )*(buf___0 + 0))) {
#line 5690
          goto while_break___1;
        }
      }
#line 5687
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 5691
    if (i == (int )(sizeof(digraphs) / sizeof(digraphs[0]))) {
      {
#line 5693
      Msg(0, (char *)"Unknown digraph");
      }
#line 5694
      return;
    }
#line 5696
    x = (int )digraphs[i][2];
  }
#line 5698
  i = 1;
#line 5699
  *buf___0 = (char )x;
#line 5701
  if (flayer->l_encoding == 8) {
    {
#line 5702
    i = ToUtf8(buf___0, x);
    }
  }
  {
#line 5704
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 5704
    if (! i) {
#line 5704
      goto while_break___2;
    }
    {
#line 5705
    (*((flayer->l_layfn)->lf_LayProcess))(& buf___0, & i);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 5706
  return;
}
}
#line 5709 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
int StuffKey(int i ) 
{ 
  struct action *act ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 5715
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5715
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 5720
  if (i >= 55) {
#line 5720
    if (i < 59) {
#line 5720
      if (display->d_cursorkeys) {
#line 5721
        i += 22;
      } else {
#line 5720
        goto _L___0;
      }
    } else {
#line 5720
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 5722
  if (i >= 59) {
#line 5722
    if (i < 77) {
#line 5722
      if (display->d_keypad) {
#line 5723
        i += 22;
      }
    }
  }
  {
#line 5724
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5724
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 5725
  flayer = (display->d_forecv)->c_layer;
#line 5726
  fore = display->d_fore;
#line 5727
  act = (struct action *)0;
#line 5729
  tmp = InMark();
  }
#line 5729
  if (tmp) {
#line 5729
    goto _L___1;
  } else {
    {
#line 5729
    tmp___0 = InInput();
    }
#line 5729
    if (tmp___0) {
#line 5729
      goto _L___1;
    } else {
      {
#line 5729
      tmp___1 = InWList();
      }
#line 5729
      if (tmp___1) {
        _L___1: /* CIL Label */ 
#line 5730
        if (i < 99) {
#line 5730
          act = & mmtab[i];
        } else {
#line 5730
          act = & (kmap_exts + (i - 99))->mm;
        }
      }
    }
  }
#line 5732
  if (! act) {
#line 5732
    goto _L___2;
  } else
#line 5732
  if (act->nr == -1) {
    _L___2: /* CIL Label */ 
#line 5732
    if (! display->d_mapdefault) {
#line 5733
      if (i < 99) {
#line 5733
        act = & umtab[i];
      } else {
#line 5733
        act = & (kmap_exts + (i - 99))->um;
      }
    }
  }
#line 5734
  display->d_mapdefault = 0;
#line 5735
  if (! act) {
#line 5735
    goto _L___3;
  } else
#line 5735
  if (act->nr == -1) {
    _L___3: /* CIL Label */ 
#line 5736
    if (i < 99) {
#line 5736
      act = & dmtab[i];
    } else {
#line 5736
      act = & (kmap_exts + (i - 99))->dm;
    }
  }
#line 5737
  if ((unsigned long )act == (unsigned long )((struct action *)0)) {
#line 5738
    return (-1);
  } else
#line 5737
  if (act->nr == -1) {
#line 5738
    return (-1);
  }
  {
#line 5739
  DoAction(act, 0);
  }
#line 5740
  return (0);
}
}
#line 5745 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static int IsOnDisplay(struct win *wi ) 
{ 
  struct canvas *cv ;

  {
  {
#line 5750
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5750
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 5751
  cv = display->d_cvlist;
  {
#line 5751
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5751
    if (! cv) {
#line 5751
      goto while_break___0;
    }
#line 5752
    if ((unsigned long )((struct win *)((cv->c_layer)->l_bottom)->l_data) == (unsigned long )wi) {
#line 5753
      return (1);
    }
#line 5751
    cv = cv->c_next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 5754
  return (0);
}
}
#line 5757 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
struct win *FindNiceWindow(struct win *wi , char *presel ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 5764
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5764
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 5765
  if (presel) {
    {
#line 5767
    i = WindowByNoN(presel);
    }
#line 5768
    if (i >= 0) {
#line 5769
      wi = wtab[i];
    }
  }
#line 5771
  if (! display) {
#line 5772
    return (wi);
  }
#line 5774
  if (wi) {
    {
#line 5774
    tmp = AclCheckPermWin(display->d_user, 2, wi);
    }
#line 5774
    if (tmp) {
#line 5775
      wi = (struct win *)0;
    }
  }
#line 5777
  if (! wi) {
#line 5777
    goto _L;
  } else {
    {
#line 5777
    tmp___7 = IsOnDisplay(wi);
    }
#line 5777
    if (tmp___7) {
#line 5777
      if (! presel) {
        _L: /* CIL Label */ 
#line 5780
        wi = (struct win *)0;
#line 5782
        wi = windows;
        {
#line 5782
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 5782
          if (! wi) {
#line 5782
            goto while_break___0;
          }
#line 5783
          if (! wi->w_layer.l_cvlist) {
            {
#line 5783
            tmp___0 = AclCheckPermWin(display->d_user, 1, wi);
            }
#line 5783
            if (! tmp___0) {
#line 5784
              goto while_break___0;
            }
          }
#line 5782
          wi = wi->w_next;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 5785
        if (! wi) {
#line 5786
          wi = windows;
          {
#line 5786
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 5786
            if (! wi) {
#line 5786
              goto while_break___1;
            }
#line 5787
            if (wi->w_layer.l_cvlist) {
              {
#line 5787
              tmp___1 = IsOnDisplay(wi);
              }
#line 5787
              if (! tmp___1) {
                {
#line 5787
                tmp___2 = AclCheckPermWin(display->d_user, 1, wi);
                }
#line 5787
                if (! tmp___2) {
#line 5788
                  goto while_break___1;
                }
              }
            }
#line 5786
            wi = wi->w_next;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 5789
        if (! wi) {
#line 5790
          wi = windows;
          {
#line 5790
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 5790
            if (! wi) {
#line 5790
              goto while_break___2;
            }
#line 5791
            if (! wi->w_layer.l_cvlist) {
              {
#line 5791
              tmp___3 = AclCheckPermWin(display->d_user, 2, wi);
              }
#line 5791
              if (! tmp___3) {
#line 5792
                goto while_break___2;
              }
            }
#line 5790
            wi = wi->w_next;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
#line 5793
        if (! wi) {
#line 5794
          wi = windows;
          {
#line 5794
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 5794
            if (! wi) {
#line 5794
              goto while_break___3;
            }
#line 5795
            if (wi->w_layer.l_cvlist) {
              {
#line 5795
              tmp___4 = IsOnDisplay(wi);
              }
#line 5795
              if (! tmp___4) {
                {
#line 5795
                tmp___5 = AclCheckPermWin(display->d_user, 2, wi);
                }
#line 5795
                if (! tmp___5) {
#line 5796
                  goto while_break___3;
                }
              }
            }
#line 5794
            wi = wi->w_next;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 5798
        if (! wi) {
#line 5799
          wi = windows;
          {
#line 5799
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 5799
            if (! wi) {
#line 5799
              goto while_break___4;
            }
#line 5800
            if (! wi->w_layer.l_cvlist) {
#line 5801
              goto while_break___4;
            }
#line 5799
            wi = wi->w_next;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
#line 5802
        if (! wi) {
#line 5803
          wi = windows;
          {
#line 5803
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 5803
            if (! wi) {
#line 5803
              goto while_break___5;
            }
#line 5804
            if (wi->w_layer.l_cvlist) {
              {
#line 5804
              tmp___6 = IsOnDisplay(wi);
              }
#line 5804
              if (! tmp___6) {
#line 5805
                goto while_break___5;
              }
            }
#line 5803
            wi = wi->w_next;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
      }
    }
  }
#line 5808
  if (wi) {
    {
#line 5808
    tmp___8 = AclCheckPermWin(display->d_user, 2, wi);
    }
#line 5808
    if (tmp___8) {
#line 5809
      wi = (struct win *)0;
    }
  }
#line 5811
  return (wi);
}
}
#line 5876 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static void ResizeRegions(char *arg ) 
{ 
  struct canvas *cv ;
  int nreg ;
  int dsize ;
  int diff ;
  int siz ;
  int h ;
  int hh ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int s ;
  int i___0 ;
  int found ;
  int di ;
  int d2 ;

  {
  {
#line 5883
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5883
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 5884
  nreg = 0;
#line 5884
  cv = display->d_cvlist;
  {
#line 5884
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5884
    if (! cv) {
#line 5884
      goto while_break___0;
    }
#line 5885
    nreg ++;
#line 5884
    cv = cv->c_next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 5886
  if (nreg < 2) {
    {
#line 5888
    Msg(0, (char *)"resize: need more than one region");
    }
#line 5889
    return;
  }
#line 5891
  dsize = display->d_height - (display->d_has_hstatus == 1);
#line 5892
  if ((int )*arg == 61) {
#line 5895
    h = dsize;
#line 5896
    i = 0;
#line 5897
    cv = display->d_cvlist;
    {
#line 5897
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 5897
      if (! cv) {
#line 5897
        goto while_break___1;
      }
#line 5899
      tmp = nreg;
#line 5899
      nreg --;
#line 5899
      hh = h / tmp - 1;
#line 5900
      cv->c_ys = i;
#line 5901
      cv->c_ye = (i + hh) - 1;
#line 5902
      cv->c_yoff = i;
#line 5903
      i += hh + 1;
#line 5904
      h -= hh + 1;
#line 5897
      cv = cv->c_next;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 5906
    RethinkDisplayViewports();
#line 5907
    ResizeLayersToCanvases();
    }
#line 5908
    return;
  }
#line 5910
  siz = ((display->d_forecv)->c_ye - (display->d_forecv)->c_ys) + 1;
#line 5911
  if ((int )*arg == 43) {
    {
#line 5912
    diff = atoi((char const   *)(arg + 1));
    }
  } else
#line 5913
  if ((int )*arg == 45) {
    {
#line 5914
    tmp___0 = atoi((char const   *)(arg + 1));
#line 5914
    diff = - tmp___0;
    }
  } else {
    {
#line 5915
    tmp___3 = strcmp((char const   *)arg, "min");
    }
#line 5915
    if (tmp___3) {
      {
#line 5917
      tmp___2 = strcmp((char const   *)arg, "max");
      }
#line 5917
      if (tmp___2) {
        {
#line 5920
        tmp___1 = atoi((char const   *)arg);
#line 5920
        diff = tmp___1 - siz;
        }
      } else {
#line 5918
        diff = ((dsize - (nreg - 1) * 2) - 1) - siz;
      }
    } else {
#line 5916
      diff = 1 - siz;
    }
  }
#line 5921
  if (diff == 0) {
#line 5922
    return;
  }
#line 5923
  if (siz + diff < 1) {
#line 5924
    diff = 1 - siz;
  }
#line 5925
  if (siz + diff > (dsize - (nreg - 1) * 2) - 1) {
#line 5926
    diff = ((dsize - (nreg - 1) * 2) - 1) - siz;
  }
#line 5927
  if (diff == 0) {
#line 5928
    return;
  } else
#line 5927
  if (siz + diff < 1) {
#line 5928
    return;
  }
#line 5930
  if (diff < 0) {
#line 5932
    if ((display->d_forecv)->c_next) {
#line 5934
      (display->d_forecv)->c_ye += diff;
#line 5935
      ((display->d_forecv)->c_next)->c_ys += diff;
#line 5936
      ((display->d_forecv)->c_next)->c_yoff += diff;
    } else {
#line 5940
      cv = display->d_cvlist;
      {
#line 5940
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 5940
        if (! cv) {
#line 5940
          goto while_break___2;
        }
#line 5941
        if ((unsigned long )cv->c_next == (unsigned long )display->d_forecv) {
#line 5942
          goto while_break___2;
        }
#line 5940
        cv = cv->c_next;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 5943
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 5943
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 5944
      cv->c_ye -= diff;
#line 5945
      (display->d_forecv)->c_ys -= diff;
#line 5946
      (display->d_forecv)->c_yoff -= diff;
    }
  } else {
#line 5951
    i___0 = 0;
#line 5951
    found = 0;
#line 5951
    di = diff;
#line 5952
    s = ((dsize - (nreg - 1) * 2) - 1) - siz;
#line 5953
    cv = display->d_cvlist;
    {
#line 5953
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 5953
      if (! cv) {
#line 5953
        goto while_break___4;
      }
#line 5955
      if ((unsigned long )cv == (unsigned long )display->d_forecv) {
#line 5957
        cv->c_ye = (i___0 + (cv->c_ye - cv->c_ys)) + diff;
#line 5958
        cv->c_yoff -= cv->c_ys - i___0;
#line 5959
        cv->c_ys = i___0;
#line 5960
        found = 1;
#line 5961
        goto __Cont;
      }
#line 5963
      s -= cv->c_ye - cv->c_ys;
#line 5964
      if (! found) {
#line 5966
        if (s >= di) {
#line 5967
          goto __Cont;
        }
#line 5968
        d2 = di - s;
      } else
#line 5971
      if (di > cv->c_ye - cv->c_ys) {
#line 5971
        d2 = cv->c_ye - cv->c_ys;
      } else {
#line 5971
        d2 = di;
      }
#line 5972
      di -= d2;
#line 5973
      cv->c_ye = (i___0 + (cv->c_ye - cv->c_ys)) - d2;
#line 5974
      cv->c_yoff -= cv->c_ys - i___0;
#line 5975
      cv->c_ys = i___0;
      __Cont: /* CIL Label */ 
#line 5953
      i___0 = cv->c_ye + 2;
#line 5953
      cv = cv->c_next;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  {
#line 5978
  RethinkDisplayViewports();
#line 5979
  ResizeLayersToCanvases();
  }
#line 5980
  return;
}
}
#line 5982 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static void ResizeFin(char *buf___0 , int len , char *data ) 
{ 


  {
  {
#line 5988
  ResizeRegions(buf___0);
  }
#line 5989
  return;
}
}
#line 6116 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
static char costr[65]  = 
#line 6116
  {      (char )'k',      (char )'r',      (char )'g',      (char )'y', 
        (char )'b',      (char )'m',      (char )'c',      (char )'w', 
        (char )' ',      (char )'d',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'i',      (char )'.', 
        (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )' ',      (char )'9',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'f', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'F', 
        (char )'K',      (char )'R',      (char )'G',      (char )'Y', 
        (char )'B',      (char )'M',      (char )'C',      (char )'W', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'I',      (char )' ', 
        (char )'\000'};
#line 6004 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
int ParseAttrColor(char *s1 , char *s2 , int msgok ) 
{ 
  int i ;
  int n ;
  char *s ;
  char *ss ;
  int r ;
  int mode ;
  int n___0 ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int numco ;
  int j ;

  {
#line 6011
  r = 0;
#line 6013
  s = s1;
  {
#line 6014
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6014
    if (! ((int )*s == 32)) {
#line 6014
      goto while_break;
    }
#line 6015
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6016
  ss = s;
  {
#line 6017
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6017
    if (*ss) {
#line 6017
      if (! ((int )*ss != 32)) {
#line 6017
        goto while_break___0;
      }
    } else {
#line 6017
      goto while_break___0;
    }
#line 6018
    ss ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 6019
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 6019
    if (! ((int )*ss == 32)) {
#line 6019
      goto while_break___1;
    }
#line 6020
    ss ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 6021
  if (*s) {
#line 6021
    if (s2) {
#line 6021
      goto _L___3;
    } else
#line 6021
    if (*ss) {
#line 6021
      goto _L___3;
    } else
#line 6021
    if ((int )*s >= 97) {
#line 6021
      if (! ((int )*s <= 122)) {
#line 6021
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 6021
    if ((int )*s >= 65) {
#line 6021
      if (! ((int )*s <= 90)) {
#line 6021
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 6021
    if (! ((int )*s == 46)) {
      _L___3: /* CIL Label */ 
#line 6023
      mode = 0;
#line 6023
      n___0 = 0;
#line 6024
      if ((int )*s == 43) {
#line 6026
        mode = 1;
#line 6027
        s ++;
      } else
#line 6029
      if ((int )*s == 45) {
#line 6031
        mode = -1;
#line 6032
        s ++;
      } else
#line 6034
      if ((int )*s == 33) {
#line 6036
        mode = 2;
#line 6037
        s ++;
      } else
#line 6039
      if ((int )*s == 61) {
#line 6040
        s ++;
      }
#line 6041
      if ((int )*s >= 48) {
#line 6041
        if ((int )*s <= 57) {
#line 6043
          tmp = s;
#line 6043
          s ++;
#line 6043
          n___0 = (int )*tmp - 48;
#line 6044
          if ((int )*s >= 48) {
#line 6044
            if ((int )*s <= 57) {
#line 6045
              tmp___0 = s;
#line 6045
              s ++;
#line 6045
              n___0 = n___0 * 16 + ((int )*tmp___0 - 48);
            } else {
#line 6044
              goto _L___1;
            }
          } else
          _L___1: /* CIL Label */ 
#line 6046
          if ((int )*s >= 97) {
#line 6046
            if ((int )*s <= 102) {
#line 6047
              tmp___1 = s;
#line 6047
              s ++;
#line 6047
              n___0 = n___0 * 16 + ((int )*tmp___1 - 87);
            } else {
#line 6046
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 6048
          if ((int )*s >= 65) {
#line 6048
            if ((int )*s <= 70) {
#line 6049
              tmp___2 = s;
#line 6049
              s ++;
#line 6049
              n___0 = n___0 * 16 + ((int )*tmp___2 - 55);
            } else {
#line 6048
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 6050
          if (*s) {
#line 6050
            if ((int )*s != 32) {
#line 6052
              if (msgok) {
                {
#line 6053
                Msg(0, (char *)"Illegal attribute hexchar \'%c\'", (int )*s);
                }
              }
#line 6054
              return (-1);
            }
          }
        } else {
#line 6041
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
        {
#line 6059
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 6059
          if (*s) {
#line 6059
            if (! ((int )*s != 32)) {
#line 6059
              goto while_break___2;
            }
          } else {
#line 6059
            goto while_break___2;
          }
#line 6061
          if ((int )*s == 100) {
#line 6062
            n___0 |= 1;
          } else
#line 6063
          if ((int )*s == 117) {
#line 6064
            n___0 |= 1 << 1;
          } else
#line 6065
          if ((int )*s == 98) {
#line 6066
            n___0 |= 1 << 2;
          } else
#line 6067
          if ((int )*s == 114) {
#line 6068
            n___0 |= 1 << 3;
          } else
#line 6069
          if ((int )*s == 115) {
#line 6070
            n___0 |= 1 << 4;
          } else
#line 6071
          if ((int )*s == 66) {
#line 6072
            n___0 |= 1 << 5;
          } else {
#line 6075
            if (msgok) {
              {
#line 6076
              Msg(0, (char *)"Illegal attribute specifier \'%c\'", (int )*s);
              }
            }
#line 6077
            return (-1);
          }
#line 6079
          s ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 6082
      if (*s) {
#line 6082
        if ((int )*s != 32) {
#line 6084
          if (msgok) {
            {
#line 6085
            Msg(0, (char *)"junk after attribute description: \'%c\'", (int )*s);
            }
          }
#line 6086
          return (-1);
        }
      }
#line 6088
      if (mode == -1) {
#line 6089
        r = (n___0 << 8) | n___0;
      } else
#line 6090
      if (mode == 1) {
#line 6091
        r = n___0 << 8;
      } else
#line 6092
      if (mode == 2) {
#line 6093
        r = n___0;
      } else
#line 6094
      if (mode == 0) {
#line 6095
        r = 65535 ^ n___0;
      }
    }
  }
  {
#line 6097
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 6097
    if (*s) {
#line 6097
      if (! ((int )*s == 32)) {
#line 6097
        goto while_break___3;
      }
    } else {
#line 6097
      goto while_break___3;
    }
#line 6098
    s ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 6100
  if (s2) {
#line 6102
    if (*s) {
#line 6104
      if (msgok) {
        {
#line 6105
        Msg(0, (char *)"junk after description: \'%c\'", (int )*s);
        }
      }
#line 6106
      return (-1);
    }
#line 6108
    s = s2;
    {
#line 6109
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 6109
      if (*s) {
#line 6109
        if (! ((int )*s == 32)) {
#line 6109
          goto while_break___4;
        }
      } else {
#line 6109
        goto while_break___4;
      }
#line 6110
      s ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 6114
  if (*s) {
#line 6117
    numco = 0;
#line 6119
    n = 0;
#line 6120
    if ((int )*s == 46) {
#line 6122
      numco ++;
#line 6123
      n = 15;
#line 6124
      s ++;
    }
#line 6126
    j = 0;
    {
#line 6126
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 6126
      if (j < 2) {
#line 6126
        if (*s) {
#line 6126
          if (! ((int )*s != 32)) {
#line 6126
            goto while_break___5;
          }
        } else {
#line 6126
          goto while_break___5;
        }
      } else {
#line 6126
        goto while_break___5;
      }
#line 6128
      i = 0;
      {
#line 6128
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 6128
        if (! costr[i]) {
#line 6128
          goto while_break___6;
        }
#line 6129
        if ((int )*s == (int )costr[i]) {
#line 6130
          goto while_break___6;
        }
#line 6128
        i ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 6131
      if (! costr[i]) {
#line 6133
        if (msgok) {
          {
#line 6134
          Msg(0, (char *)"illegal color descriptor: \'%c\'", (int )*s);
          }
        }
#line 6135
        return (-1);
      }
#line 6137
      numco ++;
#line 6138
      n = (n << 4) | (i & 15);
#line 6140
      if (i >= 48) {
#line 6141
        n = (n & 8447) | 512;
      }
#line 6143
      s ++;
#line 6126
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 6145
    if ((n & 3840) == 3840) {
#line 6146
      n ^= 3840;
    }
#line 6148
    if (n & 8192) {
#line 6149
      n ^= 9216;
    }
#line 6151
    if (numco == 1) {
#line 6152
      n |= 240;
    }
#line 6153
    if (numco != 2) {
#line 6153
      if (n != 255) {
#line 6154
        n |= 256;
      }
    }
#line 6155
    if (*s) {
#line 6155
      if ((int )*s != 32) {
#line 6157
        if (msgok) {
          {
#line 6158
          Msg(0, (char *)"junk after color description: \'%c\'", (int )*s);
          }
        }
#line 6159
        return (-1);
      }
    }
#line 6161
    n ^= 255;
#line 6162
    r |= n << 16;
  }
  {
#line 6166
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 6166
    if (*s) {
#line 6166
      if (! ((int )*s == 32)) {
#line 6166
        goto while_break___7;
      }
    } else {
#line 6166
      goto while_break___7;
    }
#line 6167
    s ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 6168
  if (*s) {
#line 6170
    if (msgok) {
      {
#line 6171
      Msg(0, (char *)"junk after description: \'%c\'", (int )*s);
      }
    }
#line 6172
    return (-1);
  }
  {
#line 6174
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 6174
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 6175
  return (r);
}
}
#line 6186 "/home/pronto/abs/test-suite/screen-4.0.2/process.c"
void ApplyAttrColor(int i , struct mchar *mc ) 
{ 


  {
  {
#line 6191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6191
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 6192
  mc->attr = (unsigned char )((int )mc->attr | ((i >> 8) & 255));
#line 6193
  mc->attr = (unsigned char )((int )mc->attr ^ (i & 255));
#line 6195
  i = (i >> 16) ^ 255;
#line 6196
  if ((i & 256) != 0) {
#line 6198
    i &= 3839;
#line 6199
    if ((int )mc->attr & ((1 << 4) | (1 << 3))) {
#line 6201
      i = ((((i & 15) << 4) | ((i & 240) >> 4)) | ((i & 512) << 1)) | ((i & 1024) >> 1);
    }
  }
#line 6207
  if ((i & 15) != 15) {
#line 6208
    mc->attr = (unsigned char )(((int )mc->attr & 191) | ((i >> 3) & 64));
  }
#line 6209
  if ((i & 240) != 240) {
#line 6210
    mc->attr = (unsigned char )(((int )mc->attr & 127) | ((i >> 3) & 128));
  }
#line 6212
  mc->color = (unsigned char )(153 ^ (int )mc->color);
#line 6213
  if ((i & 14) == 14) {
#line 6214
    i = (i & 240) | ((int )mc->color & 15);
  }
#line 6215
  if ((i & 224) == 224) {
#line 6216
    i = (i & 15) | ((int )mc->color & 240);
  }
#line 6217
  mc->color = (unsigned char )(153 ^ i);
  {
#line 6218
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6218
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 6220
  return;
}
}
#line 75 "/home/pronto/abs/test-suite/screen-4.0.2/pty.c"
static char PtyName[32]  ;
#line 75 "/home/pronto/abs/test-suite/screen-4.0.2/pty.c"
static char TtyName[32]  ;
#line 92
static void initmaster(int f ) ;
#line 99 "/home/pronto/abs/test-suite/screen-4.0.2/pty.c"
int pty_preopen  =    0;
#line 112 "/home/pronto/abs/test-suite/screen-4.0.2/pty.c"
static void initmaster(int f ) 
{ 


  {
  {
#line 117
  tcflush(f, 2);
  }
#line 126
  return;
}
}
#line 128 "/home/pronto/abs/test-suite/screen-4.0.2/pty.c"
void InitPTY(int f ) 
{ 


  {
#line 132
  if (f < 0) {
#line 133
    return;
  }
#line 144
  return;
}
}
#line 250
extern char *ptsname() ;
#line 251
extern int unlockpt(int  ) ;
#line 251
extern int grantpt(int  ) ;
#line 253
extern int getpt(void) ;
#line 245 "/home/pronto/abs/test-suite/screen-4.0.2/pty.c"
int OpenPTY(char **ttyn ) 
{ 
  register int f ;
  char *m___0 ;
  void (*sigcld)(int  ) ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 257
  strcpy((char */* __restrict  */)(PtyName), (char const   */* __restrict  */)"/dev/ptmx");
#line 259
  f = getpt();
  }
#line 259
  if (f == -1) {
#line 263
    return (-1);
  }
  {
#line 269
  sigcld = xsignal(17, (void (*)(int  ))0);
#line 270
  m___0 = ptsname(f);
  }
#line 270
  if ((unsigned long )m___0 == (unsigned long )((void *)0)) {
    {
#line 272
    xsignal(17, sigcld);
#line 273
    close(f);
    }
#line 274
    return (-1);
  } else {
    {
#line 270
    tmp = grantpt(f);
    }
#line 270
    if (tmp) {
      {
#line 272
      xsignal(17, sigcld);
#line 273
      close(f);
      }
#line 274
      return (-1);
    } else {
      {
#line 270
      tmp___0 = unlockpt(f);
      }
#line 270
      if (tmp___0) {
        {
#line 272
        xsignal(17, sigcld);
#line 273
        close(f);
        }
#line 274
        return (-1);
      }
    }
  }
  {
#line 276
  xsignal(17, sigcld);
#line 277
  strncpy((char */* __restrict  */)(TtyName), (char const   */* __restrict  */)m___0,
          (size_t )sizeof(TtyName));
#line 278
  initmaster(f);
#line 279
  *ttyn = TtyName;
  }
#line 280
  return (f);
}
}
#line 256 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chmod)(char const   *__file ,
                                                                                  __mode_t __mode ) ;
#line 117 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 144 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 321
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 327
extern int printf(char const   * __restrict  __format  , ...) ;
#line 378 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 414
extern int pause(void) ;
#line 502
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) execl)(char const   *__path ,
                                                                                  char const   *__arg 
                                                                                  , ...) ;
#line 552
extern  __attribute__((__nothrow__)) __pid_t getppid(void) ;
#line 860
extern char *( __attribute__((__nonnull__(1))) getpass)(char const   *__prompt ) ;
#line 640 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 115 "/usr/include/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 33 "/home/pronto/abs/test-suite/screen-4.0.2/extern.h"
void eexit(int e ) ;
#line 229
int Attach(int how ) ;
#line 230
void Attacher(void) ;
#line 231
void AttacherFinit(int sigsig ) ;
#line 232
void SendCmdMessage(char *sty , char *match , char **av ) ;
#line 330
int FindSocket(int *fdp , int *nfoundp , int *notherp , char *match ) ;
#line 331
int MakeClientSocket(int err ) ;
#line 365
void xseteuid(int euid ) ;
#line 35 "/home/pronto/abs/test-suite/screen-4.0.2/attacher.c"
static int WriteMessage(int s , struct msg *m___0 ) ;
#line 36
static void AttacherSigInt(int sigsig ) ;
#line 38
static void AttacherWinch(int sigsig ) ;
#line 41
static void DoLock(int sigsig ) ;
#line 42
static void LockTerminal(void) ;
#line 43
static void LockHup(int sigsig ) ;
#line 44
static void screen_builtin_lck(void) ;
#line 50
static void AttachSigCont(int sigsig ) ;
#line 53
int eff_uid ;
#line 53
int eff_gid ;
#line 54
char *SockMatch ;
#line 55
struct passwd *ppp ;
#line 56
char *attach_tty ;
#line 56
char *attach_term ;
#line 56
char *LoginName ;
#line 56
char *preselect ;
#line 57
int xflag ;
#line 57
int dflag ;
#line 57
int rflag ;
#line 57
int quietflag ;
#line 57
int adaptflag ;
#line 58
struct mode attach_Mode ;
#line 59
struct NewWindow nwin_options ;
#line 60
int MasterPid ;
#line 64
int multiattach ;
#line 64
int multi_uid ;
#line 64
int own_uid ;
#line 65
int tty_mode ;
#line 65
int tty_oldmode ;
#line 73 "/home/pronto/abs/test-suite/screen-4.0.2/attacher.c"
static int ContinuePlease  ;
#line 75 "/home/pronto/abs/test-suite/screen-4.0.2/attacher.c"
static void AttachSigCont(int sigsig ) 
{ 


  {
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  ContinuePlease = 1;
#line 81
  return;
}
}
#line 92 "/home/pronto/abs/test-suite/screen-4.0.2/attacher.c"
static int WriteMessage(int s , struct msg *m___0 ) 
{ 
  int r ;
  int l ;
  int *tmp ;

  {
#line 97
  l = (int )sizeof(*m___0);
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (l > 0)) {
#line 99
      goto while_break;
    }
    {
#line 101
    r = write(s, (void const   *)((char *)m___0 + (sizeof(*m___0) - (unsigned long )l)),
              (size_t )l);
    }
#line 102
    if (r == -1) {
      {
#line 102
      tmp = __errno_location();
      }
#line 102
      if (*tmp == 4) {
#line 103
        goto while_continue;
      }
    }
#line 104
    if (r == -1) {
#line 105
      return (-1);
    } else
#line 104
    if (r == 0) {
#line 105
      return (-1);
    }
#line 106
    l -= r;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  return (0);
}
}
#line 112 "/home/pronto/abs/test-suite/screen-4.0.2/attacher.c"
int Attach(int how ) 
{ 
  int n ;
  int lasts ;
  struct msg m___0 ;
  struct stat st ;
  char *s ;
  int *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;

  {
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 183
  if (how == 2) {
#line 183
    goto _L;
  } else
#line 183
  if (how == 3) {
    _L: /* CIL Label */ 
#line 183
    if (multiattach) {
      {
#line 185
      real_uid = multi_uid;
#line 186
      eff_uid = own_uid;
#line 187
      xseteuid(multi_uid);
#line 188
      xseteuid(own_uid);
#line 189
      tmp___0 = chmod((char const   *)attach_tty, (__mode_t )438);
      }
#line 189
      if (tmp___0) {
        {
#line 190
        tmp = __errno_location();
#line 190
        Panic(*tmp, (char *)"chmod %s", attach_tty);
        }
      }
#line 191
      tty_oldmode = tty_mode;
    }
  }
  {
#line 196
  bzero((void *)((char *)(& m___0)), (size_t )sizeof(m___0));
#line 197
  m___0.type = how;
#line 198
  m___0.protocol_revision = ((109 << 24) | (115 << 16)) | (103 << 8);
#line 199
  strncpy((char */* __restrict  */)(m___0.m_tty), (char const   */* __restrict  */)attach_tty,
          (size_t )(sizeof(m___0.m_tty) - 1UL));
#line 200
  m___0.m_tty[sizeof(m___0.m_tty) - 1UL] = (char)0;
  }
#line 202
  if (how == 6) {
    {
#line 204
    lasts = MakeClientSocket(0);
    }
#line 204
    if (lasts >= 0) {
      {
#line 206
      WriteMessage(lasts, & m___0);
#line 207
      close(lasts);
      }
    }
#line 209
    return (0);
  }
#line 212
  if (how == 3) {
    {
#line 214
    lasts = MakeClientSocket(0);
    }
#line 214
    if (lasts < 0) {
      {
#line 216
      Panic(0, (char *)"Sorry, cannot contact session \"%s\" again.\r\n", SockName);
      }
    }
  } else {
    {
#line 222
    n = FindSocket(& lasts, (int *)0, (int *)0, SockMatch);
    }
    {
#line 225
    if (n == 0) {
#line 225
      goto case_0;
    }
#line 235
    if (n == 1) {
#line 235
      goto case_1;
    }
#line 237
    goto switch_default;
    case_0: /* CIL Label */ 
#line 226
    if (rflag) {
#line 226
      if ((rflag & 1) == 0) {
#line 227
        return (0);
      }
    }
#line 228
    if (quietflag) {
      {
#line 229
      eexit(10);
      }
    }
#line 230
    if (xflag) {
#line 230
      tmp___2 = "attach";
    } else {
#line 230
      if (dflag) {
#line 230
        tmp___1 = "detach";
      } else {
#line 230
        tmp___1 = "resum";
      }
#line 230
      tmp___2 = tmp___1;
    }
#line 230
    if (SockMatch) {
#line 230
      if (*SockMatch) {
#line 230
        tmp___3 = "There is no screen to be %sed matching %s.";
      } else {
#line 230
        tmp___3 = "There is no screen to be %sed.";
      }
    } else {
#line 230
      tmp___3 = "There is no screen to be %sed.";
    }
    {
#line 230
    Panic(0, (char *)tmp___3, tmp___2, SockMatch);
    }
    case_1: /* CIL Label */ 
#line 236
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 238
    if (rflag < 3) {
#line 240
      if (quietflag) {
        {
#line 241
        eexit(10 + n);
        }
      }
      {
#line 242
      Panic(0, (char *)"Type \"screen [-d] -r [pid.]tty.host\" to resume one of them.");
      }
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 253
  if (! multiattach) {
    {
#line 255
    setuid((__uid_t )real_uid);
    }
  } else {
    {
#line 260
    xseteuid(real_uid);
    }
  }
  {
#line 263
  setgid((__gid_t )real_gid);
#line 264
  eff_uid = real_uid;
#line 265
  eff_gid = real_gid;
  }
  {
#line 267
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 267
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 268
  MasterPid = 0;
#line 269
  s = SockName;
  {
#line 269
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 269
    if (! *s) {
#line 269
      goto while_break___1;
    }
#line 271
    if ((int )*s > 57) {
#line 272
      goto while_break___1;
    } else
#line 271
    if ((int )*s < 48) {
#line 272
      goto while_break___1;
    }
#line 273
    MasterPid = 10 * MasterPid + ((int )*s - 48);
#line 269
    s ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 275
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 275
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 276
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 276
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 277
  tmp___5 = stat((char const   */* __restrict  */)(SockPath), (struct stat */* __restrict  */)(& st));
  }
#line 277
  if (tmp___5 == -1) {
    {
#line 278
    tmp___4 = __errno_location();
#line 278
    Panic(*tmp___4, (char *)"stat %s", SockPath);
    }
  }
#line 279
  if ((st.st_mode & 384U) != 384U) {
    {
#line 280
    Panic(0, (char *)"Socket is in wrong mode (%03o)", (int )st.st_mode);
    }
  }
#line 285
  if (xflag) {
#line 285
    goto _L___0;
  } else
#line 285
  if (rflag) {
    _L___0: /* CIL Label */ 
#line 285
    if (dflag) {
#line 285
      if ((st.st_mode & 448U) == 384U) {
#line 286
        dflag = 0;
      }
    }
  }
#line 292
  if (dflag) {
#line 292
    goto _L___1;
  } else
#line 292
  if (! xflag) {
    _L___1: /* CIL Label */ 
#line 292
    if (dflag) {
#line 292
      tmp___7 = 448;
    } else {
#line 292
      tmp___7 = 384;
    }
#line 292
    if ((st.st_mode & 448U) != (unsigned int )tmp___7) {
#line 293
      if (dflag) {
#line 293
        tmp___6 = "already ";
      } else {
#line 293
        tmp___6 = "not ";
      }
      {
#line 293
      Panic(0, (char *)"That screen is %sdetached.", tmp___6);
      }
    }
  }
#line 295
  if (dflag) {
#line 295
    if (how == 2) {
#line 295
      goto _L___2;
    } else
#line 295
    if (how == 4) {
#line 295
      goto _L___2;
    } else
#line 295
    if (how == 5) {
      _L___2: /* CIL Label */ 
      {
#line 298
      m___0.m.detach.dpid = getpid();
#line 299
      strncpy((char */* __restrict  */)(m___0.m.detach.duser), (char const   */* __restrict  */)LoginName,
              (size_t )(sizeof(m___0.m.detach.duser) - 1UL));
#line 300
      m___0.m.detach.duser[sizeof(m___0.m.detach.duser) - 1UL] = (char)0;
      }
#line 302
      if (dflag == 2) {
#line 303
        m___0.type = 5;
      } else {
#line 306
        m___0.type = 4;
      }
      {
#line 307
      tmp___9 = WriteMessage(lasts, & m___0);
      }
#line 307
      if (tmp___9) {
        {
#line 308
        tmp___8 = __errno_location();
#line 308
        Panic(*tmp___8, (char *)"WriteMessage");
        }
      }
      {
#line 309
      close(lasts);
      }
#line 310
      if (how != 2) {
#line 311
        return (0);
      }
      {
#line 312
      sleep(1U);
#line 313
      lasts = MakeClientSocket(0);
      }
#line 313
      if (lasts == -1) {
        {
#line 314
        Panic(0, (char *)"Cannot contact screen again. Sigh.");
        }
      }
#line 315
      m___0.type = how;
    }
  }
  {
#line 318
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 318
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 319
  strncpy((char */* __restrict  */)(m___0.m.attach.envterm), (char const   */* __restrict  */)attach_term,
          (size_t )(sizeof(m___0.m.attach.envterm) - 1UL));
#line 320
  m___0.m.attach.envterm[sizeof(m___0.m.attach.envterm) - 1UL] = (char)0;
  }
  {
#line 321
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 321
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 323
  strncpy((char */* __restrict  */)(m___0.m.attach.auser), (char const   */* __restrict  */)LoginName,
          (size_t )(sizeof(m___0.m.attach.auser) - 1UL));
#line 324
  m___0.m.attach.auser[sizeof(m___0.m.attach.auser) - 1UL] = (char)0;
#line 325
  m___0.m.attach.esc = DefaultEsc;
#line 326
  m___0.m.attach.meta_esc = DefaultMetaEsc;
  }
#line 327
  if (preselect) {
#line 327
    tmp___10 = (char const   *)preselect;
  } else {
#line 327
    tmp___10 = "";
  }
  {
#line 327
  strncpy((char */* __restrict  */)(m___0.m.attach.preselect), (char const   */* __restrict  */)tmp___10,
          (size_t )(sizeof(m___0.m.attach.preselect) - 1UL));
#line 328
  m___0.m.attach.preselect[sizeof(m___0.m.attach.preselect) - 1UL] = (char)0;
#line 329
  m___0.m.attach.apid = getpid();
#line 330
  m___0.m.attach.adaptflag = adaptflag;
#line 331
  m___0.m.attach.columns = 0;
#line 331
  m___0.m.attach.lines = m___0.m.attach.columns;
#line 332
  s = getenv("LINES");
  }
#line 332
  if (s) {
    {
#line 333
    m___0.m.attach.lines = atoi((char const   *)s);
    }
  }
  {
#line 334
  s = getenv("COLUMNS");
  }
#line 334
  if (s) {
    {
#line 335
    m___0.m.attach.columns = atoi((char const   *)s);
    }
  }
#line 336
  if (nwin_options.encoding > 0) {
#line 336
    m___0.m.attach.encoding = nwin_options.encoding + 1;
  } else {
#line 336
    m___0.m.attach.encoding = 0;
  }
#line 340
  if (multi) {
#line 340
    if (how == 2) {
      {
#line 341
      xsignal(18, & AttachSigCont);
      }
    } else
#line 340
    if (how == 3) {
      {
#line 341
      xsignal(18, & AttachSigCont);
      }
    }
  }
  {
#line 344
  tmp___12 = WriteMessage(lasts, & m___0);
  }
#line 344
  if (tmp___12) {
    {
#line 345
    tmp___11 = __errno_location();
#line 345
    Panic(*tmp___11, (char *)"WriteMessage");
    }
  }
  {
#line 346
  close(lasts);
  }
  {
#line 347
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 347
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 349
  if (multi) {
#line 349
    if (how == 2) {
#line 349
      goto _L___3;
    } else
#line 349
    if (how == 3) {
      _L___3: /* CIL Label */ 
      {
#line 351
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 351
        if (! (! ContinuePlease)) {
#line 351
          goto while_break___7;
        }
        {
#line 352
        pause();
        }
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 353
      xsignal(18, (void (*)(int  ))0);
#line 354
      ContinuePlease = 0;
#line 358
      xseteuid(own_uid);
      }
#line 359
      if (tty_oldmode >= 0) {
        {
#line 360
        tmp___14 = chmod((char const   *)attach_tty, (__mode_t )tty_oldmode);
        }
#line 360
        if (tmp___14) {
          {
#line 361
          tmp___13 = __errno_location();
#line 361
          Panic(*tmp___13, (char *)"chmod %s", attach_tty);
          }
        }
      }
      {
#line 362
      tty_oldmode = -1;
#line 363
      xseteuid(real_uid);
      }
    }
  }
#line 367
  rflag = 0;
#line 368
  return (1);
}
}
#line 373 "/home/pronto/abs/test-suite/screen-4.0.2/attacher.c"
static int AttacherPanic  =    0;
#line 385 "/home/pronto/abs/test-suite/screen-4.0.2/attacher.c"
static void AttacherSigAlarm(int sigsig ) 
{ 


  {
#line 394
  return;
}
}
#line 400 "/home/pronto/abs/test-suite/screen-4.0.2/attacher.c"
static void AttacherSigInt(int sigsig ) 
{ 


  {
  {
#line 403
  xsignal(2, & AttacherSigInt);
#line 404
  Kill(MasterPid, 2);
  }
#line 406
  return;
}
}
#line 413 "/home/pronto/abs/test-suite/screen-4.0.2/attacher.c"
void AttacherFinit(int sigsig ) 
{ 
  struct stat statb ;
  struct msg m___0 ;
  int s ;
  int tmp ;

  {
  {
#line 420
  while (1) {
    while_continue: /* CIL Label */ ;
#line 420
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 421
  xsignal(1, (void (*)(int  ))1);
#line 423
  tmp = stat((char const   */* __restrict  */)(SockPath), (struct stat */* __restrict  */)(& statb));
  }
#line 423
  if (tmp == 0) {
#line 423
    if ((statb.st_mode & 511U) != 384U) {
      {
#line 425
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 425
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 426
      bzero((void *)((char *)(& m___0)), (size_t )sizeof(m___0));
#line 427
      strncpy((char */* __restrict  */)(m___0.m_tty), (char const   */* __restrict  */)attach_tty,
              (size_t )(sizeof(m___0.m_tty) - 1UL));
#line 428
      m___0.m_tty[sizeof(m___0.m_tty) - 1UL] = (char)0;
      }
      {
#line 429
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 429
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 430
      m___0.m.detach.dpid = getpid();
#line 431
      m___0.type = 7;
#line 432
      m___0.protocol_revision = ((109 << 24) | (115 << 16)) | (103 << 8);
#line 433
      s = MakeClientSocket(0);
      }
#line 433
      if (s >= 0) {
        {
#line 435
        WriteMessage(s, & m___0);
#line 436
        close(s);
        }
      }
    }
  }
#line 440
  if (tty_oldmode >= 0) {
    {
#line 442
    setuid((__uid_t )own_uid);
#line 443
    chmod((char const   *)attach_tty, (__mode_t )tty_oldmode);
    }
  }
  {
#line 446
  exit(0);
  }
}
}
#line 451 "/home/pronto/abs/test-suite/screen-4.0.2/attacher.c"
static void AttacherFinitBye(int sigsig ) 
{ 
  int ppid ;

  {
  {
#line 455
  while (1) {
    while_continue: /* CIL Label */ ;
#line 455
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 460
  setgid((__gid_t )real_gid);
#line 462
  setuid((__uid_t )own_uid);
#line 467
  ppid = getppid();
  }
#line 467
  if (ppid > 1) {
    {
#line 468
    Kill(ppid, 1);
    }
  }
  {
#line 469
  exit(0);
  }
}
}
#line 491 "/home/pronto/abs/test-suite/screen-4.0.2/attacher.c"
static int SuspendPlease  ;
#line 493 "/home/pronto/abs/test-suite/screen-4.0.2/attacher.c"
static void SigStop(int sigsig ) 
{ 


  {
  {
#line 496
  while (1) {
    while_continue: /* CIL Label */ ;
#line 496
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 497
  SuspendPlease = 1;
#line 499
  return;
}
}
#line 502 "/home/pronto/abs/test-suite/screen-4.0.2/attacher.c"
static int LockPlease  ;
#line 504 "/home/pronto/abs/test-suite/screen-4.0.2/attacher.c"
static void DoLock(int sigsig ) 
{ 


  {
  {
#line 510
  while (1) {
    while_continue: /* CIL Label */ ;
#line 510
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 511
  LockPlease = 1;
#line 513
  return;
}
}
#line 517 "/home/pronto/abs/test-suite/screen-4.0.2/attacher.c"
static int SigWinchPlease  ;
#line 519 "/home/pronto/abs/test-suite/screen-4.0.2/attacher.c"
static void AttacherWinch(int sigsig ) 
{ 


  {
  {
#line 522
  while (1) {
    while_continue: /* CIL Label */ ;
#line 522
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 523
  SigWinchPlease = 1;
#line 525
  return;
}
}
#line 533 "/home/pronto/abs/test-suite/screen-4.0.2/attacher.c"
void Attacher(void) 
{ 
  int tmp ;
  int *tmp___0 ;
  __pid_t tmp___1 ;

  {
  {
#line 536
  xsignal(1, & AttacherFinit);
#line 537
  xsignal(1, & AttacherFinit);
#line 539
  xsignal(10, & AttacherFinitBye);
#line 545
  xsignal(12, & DoLock);
#line 547
  xsignal(2, & AttacherSigInt);
#line 549
  xsignal(20, & SigStop);
#line 552
  xsignal(28, & AttacherWinch);
  }
  {
#line 557
  while (1) {
    while_continue: /* CIL Label */ ;
#line 557
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 558
  dflag = 0;
#line 560
  xflag = 1;
  {
#line 562
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 565
    xsignal(14, & AttacherSigAlarm);
#line 566
    alarm(15U);
#line 567
    pause();
#line 568
    alarm(0U);
#line 569
    tmp = kill(MasterPid, 0);
    }
#line 569
    if (tmp < 0) {
      {
#line 569
      tmp___0 = __errno_location();
      }
#line 569
      if (*tmp___0 != 1) {
        {
#line 571
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 571
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 572
        AttacherPanic ++;
      }
    }
#line 578
    if (AttacherPanic) {
      {
#line 580
      fcntl(0, 4, 0);
#line 581
      SetTTY(0, & attach_Mode);
#line 582
      printf((char const   */* __restrict  */)"\nSuddenly the Dungeon collapses!! - You die...\n");
#line 583
      eexit(1);
      }
    }
#line 587
    if (SuspendPlease) {
      {
#line 589
      SuspendPlease = 0;
#line 594
      xsignal(20, (void (*)(int  ))0);
      }
      {
#line 595
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 595
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 596
      tmp___1 = getpid();
#line 596
      kill(tmp___1, 20);
      }
      {
#line 597
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 597
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 598
      xsignal(20, & SigStop);
#line 599
      Attach(3);
      }
    }
#line 603
    if (LockPlease) {
      {
#line 605
      LockPlease = 0;
#line 610
      LockTerminal();
#line 614
      Attach(3);
      }
    }
#line 618
    if (SigWinchPlease) {
      {
#line 620
      SigWinchPlease = 0;
#line 624
      Attach(6);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 635 "/home/pronto/abs/test-suite/screen-4.0.2/attacher.c"
static char LockEnd[27]  = 
#line 635
  {      (char )'W',      (char )'e',      (char )'l',      (char )'c', 
        (char )'o',      (char )'m',      (char )'e',      (char )' ', 
        (char )'b',      (char )'a',      (char )'c',      (char )'k', 
        (char )' ',      (char )'t',      (char )'o',      (char )' ', 
        (char )'s',      (char )'c',      (char )'r',      (char )'e', 
        (char )'e',      (char )'n',      (char )' ',      (char )'!', 
        (char )'!',      (char )'\n',      (char )'\000'};
#line 637 "/home/pronto/abs/test-suite/screen-4.0.2/attacher.c"
static void LockHup(int sigsig ) 
{ 
  int ppid ;
  __pid_t tmp ;

  {
  {
#line 640
  tmp = getppid();
#line 640
  ppid = tmp;
#line 641
  setgid((__gid_t )real_gid);
#line 643
  setuid((__uid_t )own_uid);
  }
#line 647
  if (ppid > 1) {
    {
#line 648
    Kill(ppid, 1);
    }
  }
  {
#line 649
  exit(0);
  }
}
}
#line 652 "/home/pronto/abs/test-suite/screen-4.0.2/attacher.c"
static void LockTerminal(void) 
{ 
  char *prg ;
  int sig ;
  int pid ;
  void (*sigs[65])(int  ) ;
  void (*tmp)(int  ) ;
  int *tmp___0 ;
  int *tmp___1 ;
  int wstat ;
  int wret ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  char const   *tmp___6 ;
  union __anonunion___u_51 __u___0 ;
  union __anonunion___u_52 __u___1 ;
  union __anonunion___u_53 __u___2 ;
  union __anonunion___u_54 __u___3 ;
  int *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 659
  sig = 1;
  {
#line 659
  while (1) {
    while_continue: /* CIL Label */ ;
#line 659
    if (! (sig < 65)) {
#line 659
      goto while_break;
    }
#line 660
    if (sig == 17) {
#line 660
      tmp = (void (*)(int  ))0;
    } else {
#line 660
      tmp = (void (*)(int  ))1;
    }
    {
#line 660
    sigs[sig] = xsignal(sig, tmp);
#line 659
    sig ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 661
  xsignal(1, & LockHup);
#line 662
  printf((char const   */* __restrict  */)"\n");
#line 664
  prg = getenv("LOCKPRG");
  }
#line 665
  if (prg) {
    {
#line 665
    tmp___8 = strcmp((char const   *)prg, "builtin");
    }
#line 665
    if (tmp___8) {
      {
#line 665
      tmp___9 = access((char const   *)prg, 1);
      }
#line 665
      if (tmp___9) {
#line 665
        goto _L___0;
      } else {
        {
#line 667
        xsignal(17, (void (*)(int  ))0);
        }
        {
#line 668
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 668
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 669
        pid = fork();
        }
#line 669
        if (pid == 0) {
          {
#line 672
          setgid((__gid_t )real_gid);
#line 674
          setuid((__uid_t )own_uid);
#line 678
          closeallfiles(0);
#line 679
          execl((char const   *)prg, "SCREEN-LOCK", (void *)0);
#line 680
          tmp___0 = __errno_location();
#line 680
          exit(*tmp___0);
          }
        }
#line 682
        if (pid == -1) {
          {
#line 683
          tmp___1 = __errno_location();
#line 683
          Msg(*tmp___1, (char *)"Cannot lock terminal - fork failed");
          }
        } else {
          {
#line 696
          tmp___2 = __errno_location();
#line 696
          *tmp___2 = 0;
          }
          {
#line 697
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 697
            wret = wait((union wait *)(& wstat));
            }
#line 697
            if (! (wret != pid)) {
#line 697
              if (wret == -1) {
                {
#line 697
                tmp___4 = __errno_location();
                }
#line 697
                if (! (*tmp___4 == 4)) {
#line 697
                  goto while_break___1;
                }
              } else {
#line 697
                goto while_break___1;
              }
            }
            {
#line 700
            tmp___3 = __errno_location();
#line 700
            *tmp___3 = 0;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 702
          tmp___7 = __errno_location();
          }
#line 702
          if (*tmp___7) {
            {
#line 704
            tmp___5 = __errno_location();
#line 704
            Msg(*tmp___5, (char *)"Lock");
#line 705
            sleep(2U);
            }
          } else {
#line 707
            __u___3.__in = wstat;
#line 707
            if ((__u___3.__i & 127) != 0) {
#line 710
              __u___0.__in = wstat;
#line 710
              if (__u___0.__i & 128) {
#line 710
                tmp___6 = " (Core dumped)";
              } else {
#line 710
                tmp___6 = "";
              }
              {
#line 710
              __u___1.__in = wstat;
#line 710
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Lock: %s: Killed by signal: %d%s\n",
                      prg, __u___1.__i & 127, tmp___6);
#line 711
              sleep(2U);
              }
            } else {
#line 713
              __u___2.__in = wstat;
#line 713
              if ((__u___2.__i & 65280) >> 8) {
                {
#line 715
                while (1) {
                  while_continue___2: /* CIL Label */ ;
#line 715
                  goto while_break___2;
                }
                while_break___2: /* CIL Label */ ;
                }
              } else {
                {
#line 718
                printf((char const   */* __restrict  */)(LockEnd));
                }
              }
            }
          }
        }
      }
    } else {
#line 665
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 723
    if (prg) {
      {
#line 725
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 725
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
      {
#line 729
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 729
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    {
#line 731
    screen_builtin_lck();
    }
  }
#line 734
  sig = 1;
  {
#line 734
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 734
    if (! (sig < 65)) {
#line 734
      goto while_break___5;
    }
#line 736
    if ((unsigned long )sigs[sig] != (unsigned long )((void (*)(int  ))-1)) {
      {
#line 737
      xsignal(sig, sigs[sig]);
      }
    }
#line 734
    sig ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 739
  return;
}
}
#line 802 "/home/pronto/abs/test-suite/screen-4.0.2/attacher.c"
static void screen_builtin_lck(void) 
{ 
  char fullname[100] ;
  char *cp1 ;
  char message[200] ;
  char *pass ;
  char mypass[17] ;
  char salt[3] ;
  int tmp ;
  time_t tmp___0 ;
  time_t tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;

  {
#line 814
  pass = ppp->pw_passwd;
#line 815
  if ((unsigned long )pass == (unsigned long )((char *)0)) {
#line 815
    goto _L;
  } else
#line 815
  if ((int )*pass == 0) {
    _L: /* CIL Label */ 
    {
#line 817
    pass = getpass("Key:   ");
    }
#line 817
    if (pass) {
      {
#line 819
      strncpy((char */* __restrict  */)(mypass), (char const   */* __restrict  */)pass,
              (size_t )(sizeof(mypass) - 1UL));
#line 820
      mypass[sizeof(mypass) - 1UL] = (char)0;
      }
#line 821
      if ((int )mypass[0] == 0) {
#line 822
        return;
      }
      {
#line 823
      pass = getpass("Again: ");
      }
#line 823
      if (pass) {
        {
#line 825
        tmp = strcmp((char const   *)(mypass), (char const   *)pass);
        }
#line 825
        if (tmp) {
          {
#line 827
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Passwords don\'t match.\a\n");
#line 828
          sleep(2U);
          }
#line 829
          return;
        }
      }
    }
#line 833
    if ((unsigned long )pass == (unsigned long )((char *)0)) {
      {
#line 835
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Getpass error.\a\n");
#line 836
      sleep(2U);
      }
#line 837
      return;
    }
    {
#line 840
    tmp___0 = time((time_t *)0);
#line 840
    salt[0] = (char )(65 + (int )(tmp___0 % 26L));
#line 841
    tmp___1 = time((time_t *)0);
#line 841
    salt[1] = (char )(65 + (int )((tmp___1 >> 6) % 26L));
#line 842
    salt[2] = (char)0;
#line 843
    pass = crypt(mypass, salt);
#line 844
    tmp___2 = SaveStr((char const   *)pass);
#line 844
    ppp->pw_passwd = tmp___2;
#line 844
    pass = tmp___2;
    }
  }
  {
#line 848
  while (1) {
    while_continue: /* CIL Label */ ;
#line 848
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 849
  strncpy((char */* __restrict  */)(fullname), (char const   */* __restrict  */)ppp->pw_gecos,
          (size_t )(sizeof(fullname) - 9UL));
#line 850
  fullname[sizeof(fullname) - 9UL] = (char)0;
#line 852
  cp1 = index((char const   *)(fullname), ',');
  }
#line 852
  if ((unsigned long )cp1 != (unsigned long )((void *)0)) {
#line 853
    *cp1 = (char )'\000';
  }
  {
#line 854
  cp1 = index((char const   *)(fullname), '&');
  }
#line 854
  if ((unsigned long )cp1 != (unsigned long )((void *)0)) {
    {
#line 856
    strncpy((char */* __restrict  */)cp1, (char const   */* __restrict  */)ppp->pw_name,
            (size_t )8);
#line 857
    *(cp1 + 8) = (char)0;
    }
#line 858
    if ((int )*cp1 >= 97) {
#line 858
      if ((int )*cp1 <= 122) {
#line 859
        *cp1 = (char )((int )*cp1 - 32);
      }
    }
  }
  {
#line 862
  sprintf((char */* __restrict  */)(message), (char const   */* __restrict  */)"Screen used by %s <%s>.\nPassword:\a",
          fullname, ppp->pw_name);
  }
  {
#line 866
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 868
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 868
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 869
    tmp___3 = __errno_location();
#line 869
    *tmp___3 = 0;
#line 870
    cp1 = getpass((char const   *)(message));
    }
#line 870
    if ((unsigned long )cp1 == (unsigned long )((void *)0)) {
      {
#line 872
      AttacherFinit(0);
      }
    }
    {
#line 886
    tmp___4 = strlen((char const   *)pass);
#line 886
    tmp___5 = crypt(cp1, pass);
#line 886
    tmp___6 = strncmp((char const   *)tmp___5, (char const   *)pass, tmp___4);
    }
#line 886
    if (! tmp___6) {
#line 887
      goto while_break___0;
    }
    {
#line 889
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 889
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 890
    tmp___7 = strlen((char const   *)cp1);
#line 890
    bzero((void *)cp1, tmp___7);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 892
  tmp___8 = strlen((char const   *)cp1);
#line 892
  bzero((void *)cp1, tmp___8);
  }
  {
#line 893
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 893
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 894
  return;
}
}
#line 899 "/home/pronto/abs/test-suite/screen-4.0.2/attacher.c"
void SendCmdMessage(char *sty , char *match , char **av ) 
{ 
  int i ;
  int s ;
  struct msg m___0 ;
  char *p ;
  int len ;
  int n ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char const   *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 910
  if ((unsigned long )sty == (unsigned long )((char *)0)) {
    {
#line 912
    i = FindSocket(& s, (int *)0, (int *)0, match);
    }
#line 913
    if (i == 0) {
      {
#line 914
      Panic(0, (char *)"No screen session found.");
      }
    }
#line 915
    if (i != 1) {
      {
#line 916
      Panic(0, (char *)"Use -S to specify a session.");
      }
    }
  } else {
    {
#line 921
    tmp = strlen((char const   *)sty);
    }
#line 921
    if (tmp > 255U) {
#line 922
      *(sty + 255) = (char)0;
    }
    {
#line 924
    tmp___0 = strlen((char const   *)sty);
    }
#line 924
    if (tmp___0 > 511U) {
#line 925
      *(sty + 511) = (char)0;
    }
    {
#line 926
    tmp___1 = strlen((char const   *)(SockPath));
#line 926
    sprintf((char */* __restrict  */)(SockPath + tmp___1), (char const   */* __restrict  */)"/%s",
            sty);
#line 927
    s = MakeClientSocket(1);
    }
#line 927
    if (s == -1) {
      {
#line 928
      exit(1);
      }
    }
  }
  {
#line 930
  bzero((void *)((char *)(& m___0)), (size_t )sizeof(m___0));
#line 931
  m___0.type = 8;
  }
#line 932
  if (attach_tty) {
    {
#line 934
    strncpy((char */* __restrict  */)(m___0.m_tty), (char const   */* __restrict  */)attach_tty,
            (size_t )(sizeof(m___0.m_tty) - 1UL));
#line 935
    m___0.m_tty[sizeof(m___0.m_tty) - 1UL] = (char)0;
    }
  }
#line 937
  p = m___0.m.command.cmd;
#line 938
  n = 0;
  {
#line 939
  while (1) {
    while_continue: /* CIL Label */ ;
#line 939
    if (*av) {
#line 939
      if (! (n < 63)) {
#line 939
        goto while_break;
      }
    } else {
#line 939
      goto while_break;
    }
    {
#line 941
    tmp___2 = strlen((char const   *)*av);
#line 941
    len = (int )(tmp___2 + 1U);
    }
#line 942
    if ((unsigned long )(p + len) >= (unsigned long )((m___0.m.command.cmd + sizeof(m___0.m.command.cmd)) - 1)) {
#line 943
      goto while_break;
    }
    {
#line 944
    strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)*av);
#line 945
    p += len;
#line 939
    av ++;
#line 939
    n ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 947
  *p = (char)0;
#line 948
  m___0.m.command.nargs = n;
#line 949
  strncpy((char */* __restrict  */)(m___0.m.attach.auser), (char const   */* __restrict  */)LoginName,
          (size_t )(sizeof(m___0.m.attach.auser) - 1UL));
#line 950
  m___0.m.command.auser[sizeof(m___0.m.command.auser) - 1UL] = (char)0;
#line 951
  m___0.protocol_revision = ((109 << 24) | (115 << 16)) | (103 << 8);
  }
#line 952
  if (preselect) {
#line 952
    tmp___3 = (char const   *)preselect;
  } else {
#line 952
    tmp___3 = "";
  }
  {
#line 952
  strncpy((char */* __restrict  */)(m___0.m.command.preselect), (char const   */* __restrict  */)tmp___3,
          (size_t )(sizeof(m___0.m.command.preselect) - 1UL));
#line 953
  m___0.m.command.preselect[sizeof(m___0.m.command.preselect) - 1UL] = (char)0;
#line 954
  m___0.m.command.apid = getpid();
  }
  {
#line 955
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 955
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 956
  tmp___5 = WriteMessage(s, & m___0);
  }
#line 956
  if (tmp___5) {
    {
#line 957
    tmp___4 = __errno_location();
#line 957
    Msg(*tmp___4, (char *)"write");
    }
  }
  {
#line 958
  close(s);
  }
#line 959
  return;
}
}
#line 115 "/home/pronto/abs/test-suite/screen-4.0.2/extern.h"
void inp_setprompt(char *p , char *s ) ;
#line 31 "/home/pronto/abs/test-suite/screen-4.0.2/input.c"
static void InpProcess(char **ppbuf , int *plen ) ;
#line 32
static void InpAbort(void) ;
#line 33
static void InpRedisplayLine(int y , int xs , int xe , int isblank ) ;
#line 46 "/home/pronto/abs/test-suite/screen-4.0.2/input.c"
static struct inpline inphist  ;
#line 60 "/home/pronto/abs/test-suite/screen-4.0.2/input.c"
static struct LayFuncs InpLf  =    {& InpProcess, & InpAbort, & InpRedisplayLine, & DefClearLine, & DefRewrite, & DefResize,
    & DefRestore};
#line 76 "/home/pronto/abs/test-suite/screen-4.0.2/input.c"
void inp_setprompt(char *p , char *s ) 
{ 
  struct inpdata *inpdata ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
#line 82
  inpdata = (struct inpdata *)flayer->l_data;
#line 83
  if (p) {
    {
#line 85
    tmp = strlen((char const   *)p);
#line 85
    inpdata->inpstringlen = (int )tmp;
#line 86
    inpdata->inpstring = p;
    }
  }
#line 88
  if (s) {
#line 90
    if ((unsigned long )s != (unsigned long )(inpdata->inp.buf)) {
      {
#line 91
      strncpy((char */* __restrict  */)(inpdata->inp.buf), (char const   */* __restrict  */)s,
              (size_t )(sizeof(inpdata->inp.buf) - 1UL));
      }
    }
    {
#line 92
    inpdata->inp.buf[sizeof(inpdata->inp.buf) - 1UL] = (char)0;
#line 93
    tmp___1 = strlen((char const   *)(inpdata->inp.buf));
#line 93
    tmp___0 = (int )tmp___1;
#line 93
    inpdata->inp.len = tmp___0;
#line 93
    inpdata->inp.pos = tmp___0;
    }
  }
  {
#line 95
  InpRedisplayLine(flayer->l_height - 1, 0, flayer->l_width - 1, 0);
  }
#line 96
  return;
}
}
#line 108 "/home/pronto/abs/test-suite/screen-4.0.2/input.c"
void Input(char *istr , int len , int mode , void (*finfunc)(char *buf , int len ,
                                                             char *data ) , char *data ) 
{ 
  int maxlen___0 ;
  struct inpdata *inpdata ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 119
  if (len > 100) {
#line 120
    len = 100;
  }
#line 121
  if (! (mode & 1)) {
    {
#line 123
    tmp = strlen((char const   *)istr);
#line 123
    maxlen___0 = (int )((size_t )(flayer->l_width - 1) - tmp);
    }
#line 124
    if (len > maxlen___0) {
#line 125
      len = maxlen___0;
    }
  }
#line 127
  if (len < 0) {
    {
#line 129
    LMsg(0, (char *)"Width %d chars too small", - len);
    }
#line 130
    return;
  }
  {
#line 132
  tmp___0 = InitOverlayPage((int )sizeof(*inpdata), & InpLf, 1);
  }
#line 132
  if (tmp___0) {
#line 133
    return;
  }
  {
#line 134
  inpdata = (struct inpdata *)flayer->l_data;
#line 135
  inpdata->inpmaxlen = len;
#line 136
  inpdata->inpfinfunc = finfunc;
#line 137
  tmp___1 = 0;
#line 137
  inpdata->inp.len = tmp___1;
#line 137
  inpdata->inp.pos = tmp___1;
#line 138
  inpdata->inpmode = mode;
#line 139
  inpdata->priv = data;
#line 140
  inp_setprompt(istr, (char *)((void *)0));
#line 141
  flayer->l_x = inpdata->inpstringlen;
#line 142
  flayer->l_y = flayer->l_height - 1;
  }
#line 143
  return;
}
}
#line 145 "/home/pronto/abs/test-suite/screen-4.0.2/input.c"
static void InpProcess(char **ppbuf , int *plen ) 
{ 
  int len ;
  int x ;
  char *pbuf ;
  char ch ;
  struct inpdata *inpdata ;
  struct display *inpdisplay ;
  int tmp ;
  char *p ;
  char *tmp___0 ;
  int tmp___1 ;
  struct mchar mc ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  struct mchar mc___0 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  struct mchar mc___1 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 156
  inpdata = (struct inpdata *)flayer->l_data;
#line 157
  inpdisplay = display;
#line 159
  if (inpdata->inpmode & 1) {
#line 159
    tmp = 0;
  } else {
#line 159
    tmp = inpdata->inp.pos;
  }
  {
#line 159
  LGotoPos(flayer, inpdata->inpstringlen + tmp, flayer->l_height - 1);
  }
#line 160
  if ((unsigned long )ppbuf == (unsigned long )((char **)0)) {
    {
#line 162
    InpAbort();
    }
#line 163
    return;
  }
#line 165
  x = inpdata->inpstringlen + inpdata->inp.pos;
#line 166
  len = *plen;
#line 167
  pbuf = *ppbuf;
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 168
    if (! len) {
#line 168
      goto while_break;
    }
#line 170
    p = inpdata->inp.buf + inpdata->inp.pos;
#line 172
    tmp___0 = pbuf;
#line 172
    pbuf ++;
#line 172
    ch = *tmp___0;
#line 173
    len --;
#line 174
    if (inpdata->inpmode & 4) {
      {
#line 176
      inpdata->inp.buf[inpdata->inp.len] = ch;
#line 177
      inpdata->inp.buf[inpdata->inp.len + 1] = ch;
#line 178
      display = inpdisplay;
#line 179
      (*(inpdata->inpfinfunc))(inpdata->inp.buf, inpdata->inp.len, inpdata->priv);
#line 180
      ch = inpdata->inp.buf[inpdata->inp.len];
      }
    } else
#line 182
    if (inpdata->inpmode & 2) {
      {
#line 184
      display = inpdisplay;
#line 185
      (*(inpdata->inpfinfunc))(& ch, 1, inpdata->priv);
      }
#line 186
      if (ch) {
#line 187
        goto while_continue;
      }
    }
#line 189
    if (((int )((unsigned char )ch) & 127) >= 32) {
#line 189
      if ((int )ch != 127) {
#line 189
        if (inpdata->inp.len < inpdata->inpmaxlen) {
#line 191
          if (inpdata->inp.len > inpdata->inp.pos) {
            {
#line 192
            bcopy((void const   *)p, (void *)(p + 1), (size_t )(inpdata->inp.len - inpdata->inp.pos));
            }
          }
#line 193
          tmp___1 = inpdata->inp.pos;
#line 193
          (inpdata->inp.pos) ++;
#line 193
          inpdata->inp.buf[tmp___1] = ch;
#line 194
          (inpdata->inp.len) ++;
#line 196
          if (! (inpdata->inpmode & 1)) {
            {
#line 199
            mc = mchar_so;
#line 200
            tmp___2 = p;
#line 200
            p ++;
#line 200
            mc.image = (unsigned char )*tmp___2;
#line 201
            LPutChar(flayer, & mc, x, flayer->l_height - 1);
#line 202
            x ++;
            }
#line 203
            if ((unsigned long )p < (unsigned long )(inpdata->inp.buf + inpdata->inp.len)) {
              {
#line 205
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 205
                if (! ((unsigned long )p < (unsigned long )(inpdata->inp.buf + inpdata->inp.len))) {
#line 205
                  goto while_break___0;
                }
                {
#line 207
                tmp___3 = p;
#line 207
                p ++;
#line 207
                mc.image = (unsigned char )*tmp___3;
#line 208
                tmp___4 = x;
#line 208
                x ++;
#line 208
                LPutChar(flayer, & mc, tmp___4, flayer->l_height - 1);
                }
              }
              while_break___0: /* CIL Label */ ;
              }
              {
#line 210
              x = inpdata->inpstringlen + inpdata->inp.pos;
#line 211
              LGotoPos(flayer, x, flayer->l_height - 1);
              }
            }
          }
        } else {
#line 189
          goto _L___8;
        }
      } else {
#line 189
        goto _L___8;
      }
    } else
    _L___8: /* CIL Label */ 
#line 215
    if ((int )ch == 8) {
#line 215
      goto _L___6;
    } else
#line 215
    if ((int )ch == 127) {
      _L___6: /* CIL Label */ 
#line 215
      if (inpdata->inp.pos > 0) {
#line 217
        if (inpdata->inp.len > inpdata->inp.pos) {
          {
#line 218
          bcopy((void const   *)p, (void *)(p - 1), (size_t )(inpdata->inp.len - inpdata->inp.pos));
          }
        }
#line 219
        (inpdata->inp.len) --;
#line 220
        (inpdata->inp.pos) --;
#line 221
        p --;
#line 223
        if (! (inpdata->inpmode & 1)) {
#line 226
          mc___0 = mchar_so;
#line 227
          x --;
          {
#line 228
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 228
            if (! ((unsigned long )p < (unsigned long )(inpdata->inp.buf + inpdata->inp.len))) {
#line 228
              goto while_break___1;
            }
            {
#line 230
            tmp___5 = p;
#line 230
            p ++;
#line 230
            mc___0.image = (unsigned char )*tmp___5;
#line 231
            tmp___6 = x;
#line 231
            x ++;
#line 231
            LPutChar(flayer, & mc___0, tmp___6, flayer->l_height - 1);
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 233
          LPutChar(flayer, & mchar_blank, x, flayer->l_height - 1);
#line 234
          x = inpdata->inpstringlen + inpdata->inp.pos;
#line 235
          LGotoPos(flayer, x, flayer->l_height - 1);
          }
        }
      } else {
#line 215
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 238
    if ((int )ch == 21) {
#line 240
      x = inpdata->inpstringlen;
#line 241
      if (inpdata->inp.len) {
#line 241
        if (! (inpdata->inpmode & 1)) {
          {
#line 243
          LClearArea(flayer, x, flayer->l_height - 1, (x + inpdata->inp.len) - 1,
                     flayer->l_height - 1, 0, 0);
#line 244
          LGotoPos(flayer, x, flayer->l_height - 1);
          }
        }
      }
#line 246
      tmp___7 = 0;
#line 246
      inpdata->inp.pos = tmp___7;
#line 246
      inpdata->inp.len = tmp___7;
    } else
#line 248
    if ((int )ch == 11) {
#line 250
      x = inpdata->inpstringlen + inpdata->inp.pos;
#line 251
      if (inpdata->inp.len > inpdata->inp.pos) {
#line 251
        if (! (inpdata->inpmode & 1)) {
          {
#line 253
          LClearArea(flayer, x, flayer->l_height - 1, ((x + inpdata->inp.len) - inpdata->inp.pos) - 1,
                     flayer->l_height - 1, 0, 0);
#line 254
          LGotoPos(flayer, x, flayer->l_height - 1);
          }
        }
      }
#line 256
      inpdata->inp.len = inpdata->inp.pos;
    } else
#line 258
    if ((int )ch == 1) {
      {
#line 260
      x -= inpdata->inp.pos;
#line 260
      LGotoPos(flayer, x, flayer->l_height - 1);
#line 261
      inpdata->inp.pos = 0;
      }
    } else
#line 258
    if ((int )((unsigned char )ch) == 129) {
      {
#line 260
      x -= inpdata->inp.pos;
#line 260
      LGotoPos(flayer, x, flayer->l_height - 1);
#line 261
      inpdata->inp.pos = 0;
      }
    } else
#line 263
    if ((int )ch == 2) {
#line 263
      goto _L___4;
    } else
#line 263
    if ((int )((unsigned char )ch) == 130) {
      _L___4: /* CIL Label */ 
#line 263
      if (inpdata->inp.pos > 0) {
        {
#line 265
        x --;
#line 265
        LGotoPos(flayer, x, flayer->l_height - 1);
#line 266
        (inpdata->inp.pos) --;
        }
      } else {
#line 263
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 268
    if ((int )ch == 5) {
      {
#line 270
      x += inpdata->inp.len - inpdata->inp.pos;
#line 270
      LGotoPos(flayer, x, flayer->l_height - 1);
#line 271
      inpdata->inp.pos = inpdata->inp.len;
      }
    } else
#line 268
    if ((int )((unsigned char )ch) == 133) {
      {
#line 270
      x += inpdata->inp.len - inpdata->inp.pos;
#line 270
      LGotoPos(flayer, x, flayer->l_height - 1);
#line 271
      inpdata->inp.pos = inpdata->inp.len;
      }
    } else
#line 273
    if ((int )ch == 6) {
#line 273
      goto _L___2;
    } else
#line 273
    if ((int )((unsigned char )ch) == 134) {
      _L___2: /* CIL Label */ 
#line 273
      if (inpdata->inp.pos < inpdata->inp.len) {
        {
#line 275
        x ++;
#line 275
        LGotoPos(flayer, x, flayer->l_height - 1);
#line 276
        (inpdata->inp.pos) ++;
        }
      } else {
#line 273
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 278
    if ((int )ch == 16) {
#line 278
      goto _L___0;
    } else
#line 278
    if ((int )((unsigned char )ch) == 144) {
      _L___0: /* CIL Label */ 
#line 281
      mc___1 = mchar_so;
#line 282
      if (inpdata->inp.len) {
#line 282
        if (! (inpdata->inpmode & 1)) {
          {
#line 283
          LClearArea(flayer, inpdata->inpstringlen, flayer->l_height - 1, (inpdata->inpstringlen + inpdata->inp.len) - 1,
                     flayer->l_height - 1, 0, 0);
          }
        }
      }
#line 285
      inpdata->inp = inphist;
#line 286
      if (inpdata->inp.len > inpdata->inpmaxlen) {
#line 287
        inpdata->inp.len = inpdata->inpmaxlen;
      }
#line 288
      if (inpdata->inp.pos > inpdata->inp.len) {
#line 289
        inpdata->inp.pos = inpdata->inp.len;
      }
#line 291
      x = inpdata->inpstringlen;
#line 292
      p = inpdata->inp.buf;
#line 294
      if (! (inpdata->inpmode & 1)) {
        {
#line 296
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 296
          if (! ((unsigned long )p < (unsigned long )(inpdata->inp.buf + inpdata->inp.len))) {
#line 296
            goto while_break___2;
          }
          {
#line 298
          tmp___8 = p;
#line 298
          p ++;
#line 298
          mc___1.image = (unsigned char )*tmp___8;
#line 299
          tmp___9 = x;
#line 299
          x ++;
#line 299
          LPutChar(flayer, & mc___1, tmp___9, flayer->l_height - 1);
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
      {
#line 302
      x = inpdata->inpstringlen + inpdata->inp.pos;
#line 303
      LGotoPos(flayer, x, flayer->l_height - 1);
      }
    } else
#line 306
    if ((int )ch == 4) {
#line 306
      goto _L;
    } else
#line 306
    if ((int )ch == 3) {
#line 306
      goto _L;
    } else
#line 306
    if ((int )ch == 7) {
#line 306
      goto _L;
    } else
#line 306
    if ((int )ch == 27) {
#line 306
      goto _L;
    } else
#line 306
    if ((int )ch == 0) {
#line 306
      goto _L;
    } else
#line 306
    if ((int )ch == 10) {
#line 306
      goto _L;
    } else
#line 306
    if ((int )ch == 13) {
      _L: /* CIL Label */ 
#line 309
      if ((int )ch != 4) {
#line 309
        if ((int )ch != 10) {
#line 309
          if ((int )ch != 13) {
#line 310
            inpdata->inp.len = 0;
          }
        }
      }
#line 311
      inpdata->inp.buf[inpdata->inp.len] = (char)0;
#line 313
      if (inpdata->inp.len) {
#line 313
        if (inpdata->inpmode == 0) {
#line 314
          inphist = inpdata->inp;
        }
      }
      {
#line 316
      flayer->l_data = (char *)0;
#line 317
      InpAbort();
#line 318
      *ppbuf = pbuf;
#line 319
      *plen = len;
#line 320
      display = inpdisplay;
      }
#line 321
      if ((inpdata->inpmode & 2) == 0) {
        {
#line 322
        (*(inpdata->inpfinfunc))(inpdata->inp.buf, inpdata->inp.len, inpdata->priv);
        }
      } else {
        {
#line 324
        (*(inpdata->inpfinfunc))(pbuf - 1, 0, inpdata->priv);
        }
      }
      {
#line 325
      free((void *)((char *)inpdata));
      }
#line 326
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 329
  if (! (inpdata->inpmode & 2)) {
#line 331
    if (inpdata->inpmode & 1) {
#line 331
      tmp___10 = 0;
    } else {
#line 331
      tmp___10 = inpdata->inp.pos;
    }
#line 331
    flayer->l_x = inpdata->inpstringlen + tmp___10;
#line 332
    flayer->l_y = flayer->l_height - 1;
  }
#line 334
  *ppbuf = pbuf;
#line 335
  *plen = len;
#line 336
  return;
}
}
#line 338 "/home/pronto/abs/test-suite/screen-4.0.2/input.c"
static void InpAbort(void) 
{ 
  struct layer *oldlay ;
  struct canvas *oldcvlist ;
  struct canvas *cv ;

  {
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    oldlay = flayer;
    {
#line 341
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 341
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 341
    flayer = flayer->l_next;
#line 341
    oldcvlist = flayer->l_cvlist;
    {
#line 341
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 341
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 341
    flayer->l_cvlist = oldlay->l_cvlist;
#line 341
    cv = flayer->l_cvlist;
    {
#line 341
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 341
      if (! cv) {
#line 341
        goto while_break___2;
      }
#line 341
      cv->c_layer = flayer;
#line 341
      cv = cv->c_lnext;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 341
    (*((flayer->l_layfn)->lf_LayRedisplayLine))(flayer->l_height - 1, 0, flayer->l_width - 1,
                                                0);
#line 341
    flayer = oldlay;
#line 341
    cv = flayer->l_cvlist;
    }
    {
#line 341
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 341
      if (! cv) {
#line 341
        goto while_break___3;
      }
#line 341
      cv->c_layer = flayer;
#line 341
      cv = cv->c_lnext;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 341
    (flayer->l_next)->l_cvlist = oldcvlist;
#line 341
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 342
  ExitOverlayPage();
  }
#line 343
  return;
}
}
#line 345 "/home/pronto/abs/test-suite/screen-4.0.2/input.c"
static void InpRedisplayLine(int y , int xs , int xe , int isblank ) 
{ 
  int q ;
  int r ;
  int s ;
  int l ;
  int v ;
  struct inpdata *inpdata ;
  struct layer *oldlay ;
  struct canvas *oldcvlist ;
  struct canvas *cv ;

  {
#line 352
  inpdata = (struct inpdata *)flayer->l_data;
#line 353
  if (y != flayer->l_height - 1) {
    {
#line 355
    while (1) {
      while_continue: /* CIL Label */ ;
#line 355
      oldlay = flayer;
      {
#line 355
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 355
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 355
      flayer = flayer->l_next;
#line 355
      oldcvlist = flayer->l_cvlist;
      {
#line 355
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 355
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 355
      flayer->l_cvlist = oldlay->l_cvlist;
#line 355
      cv = flayer->l_cvlist;
      {
#line 355
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 355
        if (! cv) {
#line 355
          goto while_break___2;
        }
#line 355
        cv->c_layer = flayer;
#line 355
        cv = cv->c_lnext;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 355
      (*((flayer->l_layfn)->lf_LayRedisplayLine))(y, xs, xe, isblank);
#line 355
      flayer = oldlay;
#line 355
      cv = flayer->l_cvlist;
      }
      {
#line 355
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 355
        if (! cv) {
#line 355
          goto while_break___3;
        }
#line 355
        cv->c_layer = flayer;
#line 355
        cv = cv->c_lnext;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 355
      (flayer->l_next)->l_cvlist = oldcvlist;
#line 355
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 356
    return;
  }
#line 358
  inpdata->inp.buf[inpdata->inp.len] = (char)0;
#line 359
  q = xs;
#line 360
  v = (xe - xs) + 1;
#line 361
  s = 0;
#line 362
  r = inpdata->inpstringlen;
#line 363
  if (v > 0) {
#line 363
    if (q < r) {
#line 365
      l = v;
#line 366
      if (l > r - q) {
#line 367
        l = r - q;
      }
      {
#line 368
      LPutStr(flayer, (inpdata->inpstring + q) - s, l, & mchar_so, q, y);
#line 369
      q += l;
#line 370
      v -= l;
      }
    }
  }
#line 372
  s = r;
#line 373
  r += inpdata->inp.len;
#line 374
  if (! (inpdata->inpmode & 1)) {
#line 374
    if (v > 0) {
#line 374
      if (q < r) {
#line 376
        l = v;
#line 377
        if (l > r - q) {
#line 378
          l = r - q;
        }
        {
#line 379
        LPutStr(flayer, (inpdata->inp.buf + q) - s, l, & mchar_so, q, y);
#line 380
        q += l;
#line 381
        v -= l;
        }
      }
    }
  }
#line 383
  s = r;
#line 384
  r = flayer->l_width;
#line 385
  if (! isblank) {
#line 385
    if (v > 0) {
#line 385
      if (q < r) {
#line 387
        l = v;
#line 388
        if (l > r - q) {
#line 389
          l = r - q;
        }
        {
#line 390
        LClearArea(flayer, q, y, (q + l) - 1, y, 0, 0);
#line 391
        q += l;
        }
      }
    }
  }
#line 393
  return;
}
}
#line 395 "/home/pronto/abs/test-suite/screen-4.0.2/input.c"
int InInput(void) 
{ 


  {
#line 398
  if (flayer) {
#line 398
    if ((unsigned long )flayer->l_layfn == (unsigned long )(& InpLf)) {
#line 399
      return (1);
    }
  }
#line 400
  return (0);
}
}
#line 75 "/home/pronto/abs/test-suite/screen-4.0.2/osdef.h"
extern int tgetent(char * , char * ) ;
#line 76
extern char *tgetstr(char * , char ** ) ;
#line 77
extern int tgetnum(char * ) ;
#line 78
extern int tgetflag(char * ) ;
#line 218 "/home/pronto/abs/test-suite/screen-4.0.2/extern.h"
int InitTermcap(int wi , int he ) ;
#line 225
int CreateTransTable(char *s ) ;
#line 342
char *InStr(char *str , char const   *pat ) ;
#line 366
void xsetegid(int egid ) ;
#line 35 "/home/pronto/abs/test-suite/screen-4.0.2/termcap.c"
int force_vt ;
#line 48
static void AddCap(char *s ) ;
#line 49
static void MakeString(char *cap , char *buf___0 , int buflen , char *s ) ;
#line 50
static char *findcap(char *cap , char **tepp , int n ) ;
#line 51
static int copyarg(char **pp , char *s ) ;
#line 52
static int e_tgetent(char *bp , char *name ) ;
#line 53
static char *e_tgetstr(char *cap , char **tepp ) ;
#line 54
static int e_tgetflag(char *cap ) ;
#line 55
static int e_tgetnum(char *cap ) ;
#line 57
static int findseq_ge(char *seq , int k , unsigned char **sp ) ;
#line 58
static void setseqoff(unsigned char *p , int i , int o ) ;
#line 59
static int addmapseq(char *seq , int k , int nr ) ;
#line 60
static int remmapseq(char *seq , int k ) ;
#line 67 "/home/pronto/abs/test-suite/screen-4.0.2/termcap.c"
char Termcap[2056]  ;
#line 68 "/home/pronto/abs/test-suite/screen-4.0.2/termcap.c"
static int Termcaplen  ;
#line 69 "/home/pronto/abs/test-suite/screen-4.0.2/termcap.c"
static int tcLineLen  ;
#line 70 "/home/pronto/abs/test-suite/screen-4.0.2/termcap.c"
char Term[261]  ;
#line 71 "/home/pronto/abs/test-suite/screen-4.0.2/termcap.c"
char screenterm[20]  ;
#line 73 "/home/pronto/abs/test-suite/screen-4.0.2/termcap.c"
char *extra_incap  ;
#line 73 "/home/pronto/abs/test-suite/screen-4.0.2/termcap.c"
char *extra_outcap  ;
#line 75 "/home/pronto/abs/test-suite/screen-4.0.2/termcap.c"
static char const   TermcapConst[224]  = 
#line 75
  {      (char const   )'\\',      (char const   )'\n',      (char const   )'\t',      (char const   )':', 
        (char const   )'D',      (char const   )'O',      (char const   )'=',      (char const   )'\\', 
        (char const   )'E',      (char const   )'[',      (char const   )'%',      (char const   )'d', 
        (char const   )'B',      (char const   )':',      (char const   )'L',      (char const   )'E', 
        (char const   )'=',      (char const   )'\\',      (char const   )'E',      (char const   )'[', 
        (char const   )'%',      (char const   )'d',      (char const   )'D',      (char const   )':', 
        (char const   )'R',      (char const   )'I',      (char const   )'=',      (char const   )'\\', 
        (char const   )'E',      (char const   )'[',      (char const   )'%',      (char const   )'d', 
        (char const   )'C',      (char const   )':',      (char const   )'U',      (char const   )'P', 
        (char const   )'=',      (char const   )'\\',      (char const   )'E',      (char const   )'[', 
        (char const   )'%',      (char const   )'d',      (char const   )'A',      (char const   )':', 
        (char const   )'b',      (char const   )'s',      (char const   )':',      (char const   )'b', 
        (char const   )'t',      (char const   )'=',      (char const   )'\\',      (char const   )'E', 
        (char const   )'[',      (char const   )'Z',      (char const   )':',      (char const   )'\\', 
        (char const   )'\n',      (char const   )'\t',      (char const   )':',      (char const   )'c', 
        (char const   )'d',      (char const   )'=',      (char const   )'\\',      (char const   )'E', 
        (char const   )'[',      (char const   )'J',      (char const   )':',      (char const   )'c', 
        (char const   )'e',      (char const   )'=',      (char const   )'\\',      (char const   )'E', 
        (char const   )'[',      (char const   )'K',      (char const   )':',      (char const   )'c', 
        (char const   )'l',      (char const   )'=',      (char const   )'\\',      (char const   )'E', 
        (char const   )'[',      (char const   )'H',      (char const   )'\\',      (char const   )'E', 
        (char const   )'[',      (char const   )'J',      (char const   )':',      (char const   )'c', 
        (char const   )'m',      (char const   )'=',      (char const   )'\\',      (char const   )'E', 
        (char const   )'[',      (char const   )'%',      (char const   )'i',      (char const   )'%', 
        (char const   )'d',      (char const   )';',      (char const   )'%',      (char const   )'d', 
        (char const   )'H',      (char const   )':',      (char const   )'c',      (char const   )'t', 
        (char const   )'=',      (char const   )'\\',      (char const   )'E',      (char const   )'[', 
        (char const   )'3',      (char const   )'g',      (char const   )':',      (char const   )'\\', 
        (char const   )'\n',      (char const   )'\t',      (char const   )':',      (char const   )'d', 
        (char const   )'o',      (char const   )'=',      (char const   )'^',      (char const   )'J', 
        (char const   )':',      (char const   )'n',      (char const   )'d',      (char const   )'=', 
        (char const   )'\\',      (char const   )'E',      (char const   )'[',      (char const   )'C', 
        (char const   )':',      (char const   )'p',      (char const   )'t',      (char const   )':', 
        (char const   )'r',      (char const   )'c',      (char const   )'=',      (char const   )'\\', 
        (char const   )'E',      (char const   )'8',      (char const   )':',      (char const   )'r', 
        (char const   )'s',      (char const   )'=',      (char const   )'\\',      (char const   )'E', 
        (char const   )'c',      (char const   )':',      (char const   )'s',      (char const   )'c', 
        (char const   )'=',      (char const   )'\\',      (char const   )'E',      (char const   )'7', 
        (char const   )':',      (char const   )'s',      (char const   )'t',      (char const   )'=', 
        (char const   )'\\',      (char const   )'E',      (char const   )'H',      (char const   )':', 
        (char const   )'u',      (char const   )'p',      (char const   )'=',      (char const   )'\\', 
        (char const   )'E',      (char const   )'M',      (char const   )':',      (char const   )'\\', 
        (char const   )'\n',      (char const   )'\t',      (char const   )':',      (char const   )'l', 
        (char const   )'e',      (char const   )'=',      (char const   )'^',      (char const   )'H', 
        (char const   )':',      (char const   )'b',      (char const   )'l',      (char const   )'=', 
        (char const   )'^',      (char const   )'G',      (char const   )':',      (char const   )'c', 
        (char const   )'r',      (char const   )'=',      (char const   )'^',      (char const   )'M', 
        (char const   )':',      (char const   )'i',      (char const   )'t',      (char const   )'#', 
        (char const   )'8',      (char const   )':',      (char const   )'h',      (char const   )'o', 
        (char const   )'=',      (char const   )'\\',      (char const   )'E',      (char const   )'[', 
        (char const   )'H',      (char const   )':',      (char const   )'n',      (char const   )'w', 
        (char const   )'=',      (char const   )'\\',      (char const   )'E',      (char const   )'E', 
        (char const   )':',      (char const   )'t',      (char const   )'a',      (char const   )'=', 
        (char const   )'^',      (char const   )'I',      (char const   )':',      (char const   )'i', 
        (char const   )'s',      (char const   )'=',      (char const   )'\\',      (char const   )'E', 
        (char const   )')',      (char const   )'0',      (char const   )':',      (char const   )'\000'};
#line 81 "/home/pronto/abs/test-suite/screen-4.0.2/termcap.c"
char *gettermcapstring(char *s ) 
{ 
  int i ;
  int tmp ;

  {
#line 87
  if ((unsigned long )display == (unsigned long )((struct display *)0)) {
#line 88
    return ((char *)0);
  } else
#line 87
  if ((unsigned long )s == (unsigned long )((char *)0)) {
#line 88
    return ((char *)0);
  }
#line 89
  i = 0;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! (i < 196)) {
#line 89
      goto while_break;
    }
#line 91
    if (term[i].type != 2) {
#line 92
      goto __Cont;
    }
    {
#line 93
    tmp = strcmp((char const   *)term[i].tcname, (char const   *)s);
    }
#line 93
    if (tmp == 0) {
#line 94
      return (display->d_tcs[i].str);
    }
    __Cont: /* CIL Label */ 
#line 89
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  return ((char *)0);
}
}
#line 104 "/home/pronto/abs/test-suite/screen-4.0.2/termcap.c"
int InitTermcap(int wi , int he ) 
{ 
  register char *s ;
  int i ;
  char tbuf[2048] ;
  char *tp ;
  int t ;
  int xue ;
  int xse ;
  int xme ;
  int tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  size_t tmp___32 ;
  size_t tmp___33 ;
  int tmp___34 ;
  int enc ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;

  {
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 115
  bzero((void *)(tbuf), (size_t )sizeof(tbuf));
  }
  {
#line 116
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 116
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 117
  if ((int )display->d_termname[0] == 0) {
    {
#line 120
    Msg(0, (char *)"Cannot find terminfo entry for \'%s\'.", display->d_termname);
    }
#line 124
    return (-1);
  } else {
    {
#line 117
    tmp = e_tgetent(tbuf, display->d_termname);
    }
#line 117
    if (tmp != 1) {
      {
#line 120
      Msg(0, (char *)"Cannot find terminfo entry for \'%s\'.", display->d_termname);
      }
#line 124
      return (-1);
    }
  }
  {
#line 126
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 126
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 134
  if (extra_incap) {
    {
#line 134
    tmp___1 = strlen((char const   *)extra_incap);
#line 134
    tmp___2 = tmp___1 + 1U;
    }
  } else {
#line 134
    tmp___2 = (size_t )0;
  }
  {
#line 134
  tmp___3 = malloc(2048U + tmp___2);
#line 134
  tmp___0 = (char *)tmp___3;
#line 134
  display->d_tentry = tmp___0;
  }
#line 134
  if ((unsigned long )tmp___0 == (unsigned long )((char *)0)) {
    {
#line 136
    Msg(0, strnomem);
    }
#line 137
    return (-1);
  }
#line 143
  tp = display->d_tentry;
#line 144
  i = 0;
  {
#line 144
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 144
    if (! (i < 196)) {
#line 144
      goto while_break___2;
    }
    {
#line 148
    if (term[i].type == 0) {
#line 148
      goto case_0;
    }
#line 151
    if (term[i].type == 1) {
#line 151
      goto case_1;
    }
#line 154
    if (term[i].type == 2) {
#line 154
      goto case_2;
    }
#line 160
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 149
    display->d_tcs[i].flg = e_tgetflag(term[i].tcname);
    }
#line 150
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 152
    display->d_tcs[i].num = e_tgetnum(term[i].tcname);
    }
#line 153
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 155
    display->d_tcs[i].str = e_tgetstr(term[i].tcname, & tp);
    }
#line 157
    if (display->d_tcs[i].str) {
#line 157
      if ((int )*(display->d_tcs[i].str) == 0) {
#line 158
        display->d_tcs[i].str = (char *)0;
      }
    }
#line 159
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 161
    Panic(0, (char *)"Illegal tc type in entry #%d", i);
    }
    switch_break: /* CIL Label */ ;
    }
#line 144
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 169
  if (display->d_tcs[2].flg) {
    {
#line 171
    Msg(0, (char *)"You can\'t run screen on a hardcopy terminal.");
    }
#line 172
    return (-1);
  }
#line 174
  if (display->d_tcs[3].flg) {
    {
#line 176
    Msg(0, (char *)"You can\'t run screen on a terminal that overstrikes.");
    }
#line 177
    return (-1);
  }
#line 179
  if (! display->d_tcs[34].str) {
    {
#line 181
    Msg(0, (char *)"Clear screen capability required.");
    }
#line 182
    return (-1);
  }
#line 184
  if (! display->d_tcs[5].str) {
    {
#line 186
    Msg(0, (char *)"Addressable cursor capability required.");
    }
#line 187
    return (-1);
  }
  {
#line 189
  s = getenv("COLUMNS");
  }
#line 189
  if (s) {
    {
#line 189
    i = atoi((char const   *)s);
    }
#line 189
    if (i > 0) {
#line 190
      display->d_tcs[1].num = i;
    }
  }
  {
#line 191
  s = getenv("LINES");
  }
#line 191
  if (s) {
    {
#line 191
    i = atoi((char const   *)s);
    }
#line 191
    if (i > 0) {
#line 192
      display->d_tcs[0].num = i;
    }
  }
#line 193
  if (wi) {
#line 194
    display->d_tcs[1].num = wi;
  }
#line 195
  if (he) {
#line 196
    display->d_tcs[0].num = he;
  }
#line 197
  if (display->d_tcs[1].num <= 0) {
#line 198
    display->d_tcs[1].num = 80;
  }
#line 199
  if (display->d_tcs[0].num <= 0) {
#line 200
    display->d_tcs[0].num = 24;
  }
#line 202
  if (display->d_tcs[95].flg) {
#line 206
    if (! display->d_tcs[60].str) {
#line 206
      if (display->d_tcs[55].str) {
        {
#line 206
        tmp___4 = InStr(display->d_tcs[55].str, "\033[m");
        }
#line 206
        if (tmp___4) {
#line 209
          display->d_tcs[60].str = (char *)"\033[3%p1%dm";
#line 210
          display->d_tcs[61].str = (char *)"\033[4%p1%dm";
        } else {
          {
#line 206
          tmp___5 = InStr(display->d_tcs[55].str, "\033[0m");
          }
#line 206
          if (tmp___5) {
#line 209
            display->d_tcs[60].str = (char *)"\033[3%p1%dm";
#line 210
            display->d_tcs[61].str = (char *)"\033[4%p1%dm";
          }
        }
      }
    }
#line 216
    if (display->d_tcs[64].str) {
      {
#line 216
      tmp___6 = InStr(display->d_tcs[64].str, "\033[39;49m");
      }
#line 216
      if (tmp___6) {
#line 217
        display->d_tcs[67].flg = 1;
      }
    }
#line 218
    if (display->d_tcs[64].str) {
      {
#line 218
      tmp___7 = InStr(display->d_tcs[64].str, "\033[m");
      }
#line 218
      if (tmp___7) {
#line 219
        display->d_tcs[64].str = (char *)0;
      } else {
        {
#line 218
        tmp___8 = InStr(display->d_tcs[64].str, "\033[0m");
        }
#line 218
        if (tmp___8) {
#line 219
          display->d_tcs[64].str = (char *)0;
        }
      }
    }
#line 221
    if (display->d_tcs[104].str) {
      {
#line 221
      tmp___9 = InStr(display->d_tcs[104].str, "\033(B");
      }
#line 221
      if (tmp___9) {
#line 222
        display->d_tcs[97].flg = 1;
      } else {
#line 221
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 221
    if (display->d_tcs[101].str) {
      {
#line 221
      tmp___10 = InStr(display->d_tcs[101].str, "\033(0");
      }
#line 221
      if (tmp___10) {
#line 222
        display->d_tcs[97].flg = 1;
      }
    }
    {
#line 223
    tmp___11 = InStr(display->d_termname, "xterm");
    }
#line 223
    if (tmp___11) {
#line 224
      display->d_tcs[96].flg = 1;
    } else {
      {
#line 223
      tmp___12 = InStr(display->d_termname, "rxvt");
      }
#line 223
      if (tmp___12) {
#line 224
        display->d_tcs[96].flg = 1;
      }
    }
#line 226
    if (display->d_tcs[96].flg) {
#line 227
      display->d_tcs[66].flg = 1;
    }
  }
#line 229
  if (nwin_options.flowflag == nwin_undef.flowflag) {
#line 230
    if (display->d_tcs[88].flg) {
#line 230
      nwin_default.flowflag = 0;
    } else {
#line 230
      if (display->d_tcs[89].flg) {
#line 230
        tmp___13 = 1;
      } else {
#line 230
        tmp___13 = 1 << 2;
      }
#line 230
      nwin_default.flowflag = tmp___13;
    }
  }
#line 233
  if (! display->d_tcs[83].flg) {
#line 233
    tmp___14 = 1;
  } else
#line 233
  if (display->d_tcs[84].flg) {
#line 233
    tmp___14 = 1;
  } else
#line 233
  if (display->d_tcs[85].flg) {
#line 233
    tmp___14 = 1;
  } else {
#line 233
    tmp___14 = 0;
  }
#line 233
  display->d_tcs[87].flg |= tmp___14;
#line 234
  if (! display->d_tcs[42].str) {
#line 235
    display->d_tcs[42].str = (char *)"\a";
  }
#line 236
  if (! display->d_tcs[13].str) {
#line 238
    if (display->d_tcs[12].flg) {
#line 239
      display->d_tcs[13].str = (char *)"\b";
    } else {
#line 241
      display->d_tcs[13].str = display->d_tcs[14].str;
    }
  }
#line 243
  if (! display->d_tcs[7].str) {
#line 244
    display->d_tcs[7].str = (char *)"\r";
  }
#line 245
  if (! display->d_tcs[19].str) {
#line 246
    display->d_tcs[19].str = (char *)"\n";
  }
#line 254
  if (display->d_tcs[58].num > 0) {
#line 255
    tmp___15 = (char *)0;
#line 255
    display->d_tcs[53].str = tmp___15;
#line 255
    display->d_tcs[48].str = tmp___15;
  }
#line 256
  if (display->d_tcs[57].num > 0) {
#line 257
    tmp___16 = (char *)0;
#line 257
    display->d_tcs[54].str = tmp___16;
#line 257
    display->d_tcs[51].str = tmp___16;
  }
#line 261
  if (display->d_tcs[58].num > 0) {
#line 261
    if (display->d_tcs[57].num > 0) {
#line 262
      tmp___20 = (char *)0;
#line 262
      display->d_tcs[55].str = tmp___20;
#line 262
      tmp___19 = tmp___20;
#line 262
      display->d_tcs[52].str = tmp___19;
#line 262
      tmp___18 = tmp___19;
#line 262
      display->d_tcs[50].str = tmp___18;
#line 262
      tmp___17 = tmp___18;
#line 262
      display->d_tcs[49].str = tmp___17;
#line 262
      display->d_tcs[47].str = tmp___17;
    }
  }
#line 264
  xue = 1 << 2;
#line 265
  xse = 1 << 1;
#line 266
  xme = 1;
#line 268
  if (display->d_tcs[51].str) {
#line 268
    if ((unsigned long )display->d_tcs[54].str == (unsigned long )((char *)0)) {
      {
#line 270
      Msg(0, (char *)"Warning: \'so\' but no \'se\' capability.");
      }
#line 271
      if (display->d_tcs[55].str) {
#line 272
        xse = xme;
      } else {
#line 274
        display->d_tcs[51].str = (char *)0;
      }
    }
  }
#line 276
  if (display->d_tcs[48].str) {
#line 276
    if ((unsigned long )display->d_tcs[53].str == (unsigned long )((char *)0)) {
      {
#line 278
      Msg(0, (char *)"Warning: \'us\' but no \'ue\' capability.");
      }
#line 279
      if (display->d_tcs[55].str) {
#line 280
        xue = xme;
      } else {
#line 282
        display->d_tcs[48].str = (char *)0;
      }
    }
  }
#line 284
  if (display->d_tcs[47].str) {
#line 284
    goto _L___0;
  } else
#line 284
  if (display->d_tcs[49].str) {
#line 284
    goto _L___0;
  } else
#line 284
  if (display->d_tcs[50].str) {
#line 284
    goto _L___0;
  } else
#line 284
  if (display->d_tcs[52].str) {
    _L___0: /* CIL Label */ 
#line 284
    if ((unsigned long )display->d_tcs[55].str == (unsigned long )((char *)0)) {
      {
#line 286
      Msg(0, (char *)"Warning: \'m?\' but no \'me\' capability.");
#line 287
      tmp___23 = (char *)0;
#line 287
      display->d_tcs[52].str = tmp___23;
#line 287
      tmp___22 = tmp___23;
#line 287
      display->d_tcs[50].str = tmp___22;
#line 287
      tmp___21 = tmp___22;
#line 287
      display->d_tcs[49].str = tmp___21;
#line 287
      display->d_tcs[47].str = tmp___21;
      }
    }
  }
#line 294
  if (display->d_tcs[53].str) {
#line 294
    if (display->d_tcs[54].str) {
      {
#line 294
      tmp___24 = strcmp((char const   *)display->d_tcs[54].str, (char const   *)display->d_tcs[53].str);
      }
#line 294
      if (tmp___24 == 0) {
#line 295
        xse = xue;
      }
    }
  }
#line 296
  if (display->d_tcs[54].str) {
#line 296
    if (display->d_tcs[55].str) {
      {
#line 296
      tmp___25 = strcmp((char const   *)display->d_tcs[55].str, (char const   *)display->d_tcs[54].str);
      }
#line 296
      if (tmp___25 == 0) {
#line 297
        xse = xme;
      }
    }
  }
#line 298
  if (display->d_tcs[53].str) {
#line 298
    if (display->d_tcs[55].str) {
      {
#line 298
      tmp___26 = strcmp((char const   *)display->d_tcs[55].str, (char const   *)display->d_tcs[53].str);
      }
#line 298
      if (tmp___26 == 0) {
#line 299
        xue = xme;
      }
    }
  }
#line 301
  i = 0;
  {
#line 301
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 301
    if (! (i < 6)) {
#line 301
      goto while_break___3;
    }
#line 303
    display->d_attrtab[i] = display->d_tcs[47 + i].str;
#line 304
    if (i == 4) {
#line 304
      display->d_attrtyp[i] = (char )xse;
    } else {
#line 304
      if (i == 1) {
#line 304
        tmp___27 = xue;
      } else {
#line 304
        tmp___27 = xme;
      }
#line 304
      display->d_attrtyp[i] = (char )tmp___27;
    }
#line 301
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 308
  s = (char *)0;
#line 309
  t = 0;
#line 310
  i = 0;
  {
#line 310
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 310
    if (! (i < 6)) {
#line 310
      goto while_break___4;
    }
#line 311
    s = display->d_attrtab[i];
#line 311
    if (s) {
#line 313
      t = (int )display->d_attrtyp[i];
#line 314
      goto while_break___4;
    }
#line 310
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 316
  i = 0;
  {
#line 316
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 316
    if (! (i < 6)) {
#line 316
      goto while_break___5;
    }
#line 318
    if ((unsigned long )display->d_attrtab[i] == (unsigned long )((char *)0)) {
#line 320
      display->d_attrtab[i] = s;
#line 321
      display->d_attrtyp[i] = (char )t;
    } else {
#line 325
      s = display->d_attrtab[i];
#line 326
      t = (int )display->d_attrtyp[i];
    }
#line 316
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 329
  if (display->d_tcs[60].str) {
#line 330
    display->d_hascolor = 1;
  } else
#line 329
  if (display->d_tcs[61].str) {
#line 330
    display->d_hascolor = 1;
  } else
#line 329
  if (display->d_tcs[62].str) {
#line 330
    display->d_hascolor = 1;
  } else
#line 329
  if (display->d_tcs[63].str) {
#line 330
    display->d_hascolor = 1;
  }
#line 331
  if (display->d_tcs[33].flg) {
#line 332
    display->d_tcs[66].flg = 1;
  }
#line 334
  if (! display->d_tcs[10].str) {
#line 335
    display->d_tcs[10].str = display->d_tcs[19].str;
  }
#line 336
  if (! display->d_tcs[20].str) {
#line 337
    display->d_tcs[20].str = display->d_tcs[19].str;
  }
#line 338
  if (display->d_tcs[26].flg) {
#line 339
    tmp___28 = (char *)0;
#line 339
    display->d_tcs[27].str = tmp___28;
#line 339
    display->d_tcs[29].str = tmp___28;
  }
#line 340
  if ((unsigned long )display->d_tcs[28].str == (unsigned long )((char *)0)) {
#line 341
    display->d_tcs[27].str = (char *)0;
  }
#line 343
  if (display->d_tcs[29].str) {
#line 343
    if (display->d_tcs[27].str) {
      {
#line 343
      tmp___29 = strcmp((char const   *)display->d_tcs[29].str, (char const   *)display->d_tcs[27].str);
      }
#line 343
      if (tmp___29 == 0) {
#line 344
        display->d_tcs[29].str = (char *)0;
      }
    }
  }
#line 345
  if ((unsigned long )display->d_tcs[70].str == (unsigned long )((char *)0)) {
#line 346
    display->d_tcs[69].str = (char *)0;
  }
#line 347
  if ((unsigned long )display->d_tcs[94].str == (unsigned long )((char *)0)) {
#line 348
    display->d_tcs[93].str = (char *)0;
  }
#line 349
  if ((unsigned long )display->d_tcs[82].str == (unsigned long )((char *)0)) {
#line 350
    tmp___30 = (char *)0;
#line 350
    display->d_tcs[81].str = tmp___30;
#line 350
    display->d_tcs[80].str = tmp___30;
  }
#line 351
  if ((unsigned long )display->d_tcs[72].str == (unsigned long )((char *)0)) {
#line 352
    display->d_tcs[71].str = (char *)0;
  }
#line 355
  if (display->d_tcs[97].flg) {
#line 357
    if ((unsigned long )display->d_tcs[98].str == (unsigned long )((char *)0)) {
#line 359
      display->d_tcs[98].str = (char *)"\033(%p1%c";
    }
#line 363
    if ((unsigned long )display->d_tcs[99].str == (unsigned long )((char *)0)) {
#line 364
      display->d_tcs[99].str = (char *)"\033(B";
    }
#line 365
    display->d_tcs[103].str = (char *)0;
#line 366
    display->d_tcs[104].str = (char *)0;
  } else
#line 368
  if (display->d_tcs[103].str) {
#line 368
    goto _L___1;
  } else
#line 368
  if (display->d_tcs[101].str) {
#line 368
    if (display->d_tcs[102].str) {
      _L___1: /* CIL Label */ 
#line 370
      if (display->d_tcs[101].str) {
#line 370
        if (display->d_tcs[102].str) {
#line 370
          display->d_tcs[98].str = display->d_tcs[101].str;
        } else {
#line 370
          display->d_tcs[98].str = (char *)"";
        }
      } else {
#line 370
        display->d_tcs[98].str = (char *)"";
      }
#line 371
      if (display->d_tcs[101].str) {
#line 371
        if (display->d_tcs[102].str) {
#line 371
          display->d_tcs[99].str = display->d_tcs[102].str;
        } else {
#line 371
          display->d_tcs[99].str = (char *)"";
        }
      } else {
#line 371
        display->d_tcs[99].str = (char *)"";
      }
#line 372
      display->d_tcs[100].str = display->d_tcs[103].str;
    } else {
#line 376
      tmp___31 = (char *)"";
#line 376
      display->d_tcs[99].str = tmp___31;
#line 376
      display->d_tcs[98].str = tmp___31;
#line 377
      display->d_tcs[100].str = (char *)0;
#line 378
      display->d_tcs[103].str = (char *)"";
    }
  } else {
#line 376
    tmp___31 = (char *)"";
#line 376
    display->d_tcs[99].str = tmp___31;
#line 376
    display->d_tcs[98].str = tmp___31;
#line 377
    display->d_tcs[100].str = (char *)0;
#line 378
    display->d_tcs[103].str = (char *)"";
  }
#line 381
  i = 0;
  {
#line 381
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 381
    if (! (i < 256)) {
#line 381
      goto while_break___6;
    }
#line 382
    display->d_c0_tab[i] = (char )i;
#line 381
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 383
  if (display->d_tcs[103].str) {
    {
#line 386
    s = (char *)"l+m+k+j+u+t+v+w+q-x|n+o~s_p\"r#`+a:f\'g#~o.v-^+<,>h#I#0#y<z>";
#line 387
    tmp___32 = strlen((char const   *)s);
#line 387
    i = (int )(tmp___32 & 4294967294U);
    }
    {
#line 387
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 387
      if (! (i >= 0)) {
#line 387
        goto while_break___7;
      }
#line 388
      display->d_c0_tab[(int )((unsigned char )*(s + i))] = *(s + (i + 1));
#line 387
      i -= 2;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
#line 390
  if (display->d_tcs[100].str) {
    {
#line 391
    tmp___33 = strlen((char const   *)display->d_tcs[100].str);
#line 391
    i = (int )(tmp___33 & 4294967294U);
    }
    {
#line 391
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 391
      if (! (i >= 0)) {
#line 391
        goto while_break___8;
      }
#line 392
      display->d_c0_tab[(int )((unsigned char )*(display->d_tcs[100].str + i))] = *(display->d_tcs[100].str + (i + 1));
#line 391
      i -= 2;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
  {
#line 393
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 393
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 395
  if ((unsigned long )display->d_tcs[74].str == (unsigned long )((char *)0)) {
#line 396
    display->d_tcs[73].str = (char *)0;
  }
  {
#line 397
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 397
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 400
  if (display->d_tcs[105].str) {
    {
#line 401
    tmp___34 = CreateTransTable(display->d_tcs[105].str);
    }
#line 401
    if (tmp___34) {
#line 402
      return (-1);
    }
  }
#line 406
  if ((unsigned long )display->d_tcs[46].str == (unsigned long )((char *)0)) {
#line 407
    display->d_tcs[45].str = (char *)0;
  }
  {
#line 408
  Z0width = 132;
#line 409
  Z1width = 80;
#line 411
  CheckScreenSize(0);
  }
#line 413
  if ((unsigned long )display->d_tcs[77].str == (unsigned long )((char *)0)) {
#line 414
    display->d_tcs[75].flg = 0;
  } else
#line 413
  if ((unsigned long )display->d_tcs[78].str == (unsigned long )((char *)0)) {
#line 414
    display->d_tcs[75].flg = 0;
  } else
#line 413
  if ((unsigned long )display->d_tcs[79].str == (unsigned long )((char *)0)) {
#line 414
    display->d_tcs[75].flg = 0;
  }
#line 415
  if (display->d_tcs[75].flg) {
    {
#line 417
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 417
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 418
    if (display->d_tcs[76].num < 0) {
#line 419
      display->d_tcs[76].num = 0;
    }
  }
#line 421
  display->d_has_hstatus = hardstatusemu & ~ (1 << 2);
#line 422
  if (display->d_tcs[75].flg) {
#line 422
    if (! (hardstatusemu & (1 << 2))) {
#line 423
      display->d_has_hstatus = 3;
    }
  }
#line 426
  if (display->d_tcs[92].str) {
    {
#line 428
    tmp___35 = FindEncoding(display->d_tcs[92].str);
#line 428
    enc = tmp___35;
    }
#line 429
    if (enc != -1) {
#line 430
      display->d_encoding = enc;
    }
  }
#line 433
  if (! display->d_tcs[153].str) {
#line 433
    if (display->d_tcs[154].str) {
#line 434
      display->d_tcs[153].str = display->d_tcs[154].str;
    }
  }
#line 435
  if (! display->d_tcs[155].str) {
#line 435
    if (display->d_tcs[156].str) {
#line 436
      display->d_tcs[155].str = display->d_tcs[156].str;
    }
  }
  {
#line 438
  display->d_UPcost = CalcCost(display->d_tcs[8].str);
#line 439
  display->d_DOcost = CalcCost(display->d_tcs[10].str);
#line 440
  display->d_NLcost = CalcCost(display->d_tcs[19].str);
#line 441
  display->d_LEcost = CalcCost(display->d_tcs[13].str);
#line 442
  display->d_NDcost = CalcCost(display->d_tcs[16].str);
#line 443
  display->d_CRcost = CalcCost(display->d_tcs[7].str);
#line 444
  display->d_IMcost = CalcCost(display->d_tcs[27].str);
#line 445
  display->d_EIcost = CalcCost(display->d_tcs[28].str);
  }
#line 448
  if (display->d_tcs[90].flg) {
    {
#line 450
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 450
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 451
    display->d_auto_nuke = 1;
  }
#line 454
  if (display->d_tcs[91].num > 0) {
    {
#line 456
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 456
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 457
    display->d_obufmax = display->d_tcs[91].num;
#line 458
    display->d_obuflenmax = display->d_obuflen - display->d_obufmax;
  }
#line 462
  if (display->d_tcs[106].str) {
#line 462
    if (display->d_tcs[116].str) {
      {
#line 462
      tmp___36 = strcmp((char const   *)display->d_tcs[106].str, (char const   *)display->d_tcs[116].str);
      }
#line 462
      if (! tmp___36) {
#line 463
        display->d_tcs[106].str = (char *)0;
      }
    }
  }
#line 465
  if (display->d_tcs[160].str) {
    {
#line 465
    tmp___37 = strcmp((char const   *)display->d_tcs[160].str, "\0177");
    }
#line 465
    if (! tmp___37) {
#line 466
      display->d_tcs[160].str = (char *)0;
    }
  }
#line 468
  if (display->d_tcs[164].str) {
    {
#line 468
    tmp___38 = strcmp((char const   *)display->d_tcs[164].str, "\0008");
    }
#line 468
    if (! tmp___38) {
#line 469
      display->d_tcs[164].str = (char *)0;
    }
  }
#line 472
  display->d_nseqs = 0;
#line 473
  i = 0;
  {
#line 473
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 473
    if (! (i < 77)) {
#line 473
      goto while_break___14;
    }
    {
#line 474
    remap(i, 1);
#line 473
    i ++;
    }
  }
  while_break___14: /* CIL Label */ ;
  }
#line 475
  i = 0;
  {
#line 475
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 475
    if (! (i < kmap_extn)) {
#line 475
      goto while_break___15;
    }
    {
#line 476
    remap(i + 99, 1);
#line 475
    i ++;
    }
  }
  while_break___15: /* CIL Label */ ;
  }
  {
#line 477
  display->d_seqp = display->d_kmaps + 3;
#line 478
  display->d_seql = 0;
#line 479
  display->d_seqh = (unsigned char *)0;
#line 482
  display->d_tcinited = (char)1;
#line 483
  MakeTermcap(0);
#line 485
  CheckEscape();
  }
#line 487
  return (0);
}
}
#line 492 "/home/pronto/abs/test-suite/screen-4.0.2/termcap.c"
int remap(int n , int map ) 
{ 
  char *s ;
  int fl ;
  int domap ;
  struct action *a1 ;
  struct action *a2 ;
  struct action *tab ;
  int l ;
  struct kmap_ext *kme ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 497
  s = (char *)0;
#line 498
  fl = 0;
#line 498
  domap = 0;
#line 500
  l = 0;
#line 501
  kme = (struct kmap_ext *)0;
#line 503
  a1 = (struct action *)0;
#line 504
  if (n >= 99) {
#line 506
    kme = kmap_exts + (n - 99);
#line 507
    s = kme->str;
#line 508
    l = kme->fl & -16385;
#line 509
    fl = kme->fl & 16384;
#line 510
    a1 = & kme->um;
  }
#line 512
  tab = umtab;
  {
#line 513
  while (1) {
    while_continue: /* CIL Label */ ;
#line 515
    a2 = (struct action *)0;
#line 516
    if (n < 99) {
#line 518
      a1 = tab + n;
#line 519
      if (n >= 77) {
#line 520
        n -= 22;
      }
#line 521
      s = display->d_tcs[n + 106].str;
#line 522
      if (s) {
        {
#line 522
        tmp = strlen((char const   *)s);
#line 522
        l = (int )tmp;
        }
      } else {
#line 522
        l = 0;
      }
#line 523
      if (n >= 55) {
#line 524
        a2 = tab + (n + 22);
      }
    }
#line 526
    if ((unsigned long )s == (unsigned long )((char *)0)) {
#line 527
      return (0);
    } else
#line 526
    if (l == 0) {
#line 527
      return (0);
    }
#line 528
    if (a1) {
#line 528
      if (a1->nr == -1) {
#line 529
        a1 = (struct action *)0;
      }
    }
#line 530
    if (a2) {
#line 530
      if (a2->nr == -1) {
#line 531
        a2 = (struct action *)0;
      }
    }
#line 532
    if (a1) {
#line 532
      if (a1->nr == 147) {
        {
#line 532
        tmp___0 = strcmp((char const   *)*(a1->args + 0), (char const   *)s);
        }
#line 532
        if (tmp___0 == 0) {
#line 533
          a1 = (struct action *)0;
        }
      }
    }
#line 534
    if (a2) {
#line 534
      if (a2->nr == 147) {
        {
#line 534
        tmp___1 = strcmp((char const   *)*(a2->args + 0), (char const   *)s);
        }
#line 534
        if (tmp___1 == 0) {
#line 535
          a2 = (struct action *)0;
        }
      }
    }
#line 536
    if (a1) {
#line 536
      tmp___2 = 1;
    } else
#line 536
    if (a2) {
#line 536
      tmp___2 = 1;
    } else {
#line 536
      tmp___2 = 0;
    }
#line 536
    domap |= tmp___2;
#line 537
    if ((unsigned long )tab == (unsigned long )(umtab)) {
#line 539
      tab = dmtab;
#line 540
      if (kme) {
#line 540
        a1 = & kme->dm;
      } else {
#line 540
        a1 = (struct action *)0;
      }
    } else
#line 542
    if ((unsigned long )tab == (unsigned long )(dmtab)) {
#line 544
      tab = mmtab;
#line 545
      if (kme) {
#line 545
        a1 = & kme->mm;
      } else {
#line 545
        a1 = (struct action *)0;
      }
    } else {
#line 548
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 551
  if (map == 0) {
#line 551
    if (domap) {
#line 552
      return (0);
    }
  }
#line 553
  if (map) {
#line 553
    if (! domap) {
#line 554
      return (0);
    }
  }
  {
#line 555
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 555
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 556
  if (map) {
    {
#line 557
    tmp___3 = addmapseq(s, l, n | fl);
    }
#line 557
    return (tmp___3);
  } else {
    {
#line 559
    tmp___4 = remmapseq(s, l);
    }
#line 559
    return (tmp___4);
  }
}
}
#line 562 "/home/pronto/abs/test-suite/screen-4.0.2/termcap.c"
void CheckEscape(void) 
{ 
  struct display *odisplay ;
  int i ;
  int nr ;
  struct kmap_ext *kme ;

  {
#line 568
  if (DefaultEsc >= 0) {
#line 569
    return;
  }
#line 571
  odisplay = display;
#line 572
  display = displays;
  {
#line 572
  while (1) {
    while_continue: /* CIL Label */ ;
#line 572
    if (! display) {
#line 572
      goto while_break;
    }
#line 574
    i = 0;
    {
#line 574
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 574
      if (! (i < display->d_nseqs)) {
#line 574
        goto while_break___0;
      }
#line 576
      nr = (((int )*(display->d_kmaps + i) << 8) | (int )*(display->d_kmaps + (i + 1))) & -16385;
#line 577
      if (nr < 99) {
#line 579
        if (umtab[nr].nr == 31) {
#line 580
          goto while_break___0;
        }
#line 581
        if (umtab[nr].nr == -1) {
#line 581
          if (dmtab[nr].nr == 31) {
#line 582
            goto while_break___0;
          }
        }
      } else {
#line 586
        kme = (kmap_exts + nr) - 99;
#line 587
        if (kme->um.nr == 31) {
#line 588
          goto while_break___0;
        }
#line 589
        if (kme->um.nr == -1) {
#line 589
          if (kme->dm.nr == 31) {
#line 590
            goto while_break___0;
          }
        }
      }
#line 574
      i += (int )*(display->d_kmaps + (i + 2)) * 2 + 4;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 572
    display = display->d_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 594
  if ((unsigned long )display == (unsigned long )((struct display *)0)) {
#line 596
    display = odisplay;
#line 597
    return;
  }
  {
#line 599
  SetEscape((struct acluser *)0, 1, 'a');
  }
#line 600
  if ((odisplay->d_user)->u_Esc == -1) {
#line 601
    (odisplay->d_user)->u_Esc = DefaultEsc;
  }
#line 602
  if ((odisplay->d_user)->u_MetaEsc == -1) {
#line 603
    (odisplay->d_user)->u_MetaEsc = DefaultMetaEsc;
  }
  {
#line 604
  display = (struct display *)0;
#line 605
  Msg(0, (char *)"Warning: escape char set back to ^A");
#line 606
  display = odisplay;
  }
#line 607
  return;
}
}
#line 609 "/home/pronto/abs/test-suite/screen-4.0.2/termcap.c"
static int findseq_ge(char *seq , int k , unsigned char **sp ) 
{ 
  unsigned char *p ;
  int j ;
  int l ;

  {
#line 618
  p = display->d_kmaps;
  {
#line 619
  while (1) {
    while_continue: /* CIL Label */ ;
#line 619
    if (! (p - display->d_kmaps < (long )display->d_nseqs)) {
#line 619
      goto while_break;
    }
#line 621
    l = (int )*(p + 2);
#line 622
    p += 3;
#line 623
    j = 0;
    {
#line 623
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 625
      if (j == k) {
#line 626
        j = l - k;
      } else
#line 625
      if (j == l) {
#line 626
        j = l - k;
      } else
#line 627
      if ((int )*(p + j) != (int )*((unsigned char *)seq + j)) {
#line 628
        j = (int )*(p + j) - (int )*((unsigned char *)seq + j);
      } else {
#line 630
        goto __Cont;
      }
#line 631
      goto while_break___0;
      __Cont: /* CIL Label */ 
#line 623
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 633
    if (j >= 0) {
#line 635
      *sp = p - 3;
#line 636
      return (j);
    }
#line 638
    p += 2 * l + 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 640
  *sp = p;
#line 641
  return (-1);
}
}
#line 644 "/home/pronto/abs/test-suite/screen-4.0.2/termcap.c"
static void setseqoff(unsigned char *p , int i , int o ) 
{ 
  unsigned char *q ;
  int l ;
  int k ;

  {
#line 653
  k = (int )*(p + 2);
#line 654
  if (o < 256) {
#line 656
    *(p + ((k + 4) + i)) = (unsigned char )o;
#line 657
    return;
  }
#line 660
  q = (p + k * 2) + 4;
  {
#line 660
  while (1) {
    while_continue: /* CIL Label */ ;
#line 662
    l = (int )*(q + 2);
#line 663
    if (((q + l * 2) - p) / 2L >= 256L) {
#line 665
      *(p + ((k + 4) + i)) = (unsigned char )(((q - p) - 4L) / 2L);
#line 666
      return;
    }
#line 660
    q += l * 2 + 4;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 671 "/home/pronto/abs/test-suite/screen-4.0.2/termcap.c"
static int addmapseq(char *seq , int k , int nr ) 
{ 
  int i ;
  int j ;
  int l ;
  int mo ;
  int m___0 ;
  unsigned char *p ;
  unsigned char *q ;
  char *tmp ;
  int tmp___0 ;

  {
#line 680
  if (k >= 254) {
#line 681
    return (-1);
  }
  {
#line 682
  j = findseq_ge(seq, k, & p);
  }
#line 683
  if (j == 0) {
#line 685
    *(p + 0) = (unsigned char )(nr >> 8);
#line 686
    *(p + 1) = (unsigned char )nr;
#line 687
    return (0);
  }
#line 689
  i = (int )(p - display->d_kmaps);
#line 690
  if ((display->d_nseqs + 2 * k) + 4 >= display->d_aseqs) {
    {
#line 692
    tmp = xrealloc((char *)display->d_kmaps, display->d_aseqs + 256);
#line 692
    display->d_kmaps = (unsigned char *)tmp;
#line 693
    display->d_aseqs += 256;
#line 694
    p = display->d_kmaps + i;
    }
  }
  {
#line 696
  display->d_seqp = display->d_kmaps + 3;
#line 697
  display->d_seql = 0;
#line 698
  display->d_seqh = (unsigned char *)0;
#line 699
  evdeq(& display->d_mapev);
  }
#line 700
  if (j > 0) {
    {
#line 701
    bcopy((void const   *)((char *)p), (void *)(((char *)p + 2 * k) + 4), (size_t )(display->d_nseqs - i));
    }
  }
  {
#line 702
  *(p + 0) = (unsigned char )(nr >> 8);
#line 703
  *(p + 1) = (unsigned char )nr;
#line 704
  *(p + 2) = (unsigned char )k;
#line 705
  bcopy((void const   *)seq, (void *)((char *)p + 3), (size_t )k);
#line 706
  bzero((void *)((p + k) + 3), (size_t )(k + 1));
#line 707
  display->d_nseqs += 2 * k + 4;
  }
#line 708
  if (j > 0) {
#line 710
    q = (p + 2 * k) + 4;
#line 711
    l = (int )*(q + 2);
#line 712
    i = 0;
    {
#line 712
    while (1) {
      while_continue: /* CIL Label */ ;
#line 712
      if (! (i < k)) {
#line 712
        goto while_break;
      }
#line 714
      if ((int )*(p + (3 + i)) != (int )*(q + (3 + i))) {
#line 716
        *(p + ((k + 4) + i)) = (unsigned char )k;
#line 717
        goto while_break;
      }
#line 719
      if (*(q + ((l + 4) + i))) {
#line 719
        tmp___0 = ((int )*(q + ((l + 4) + i)) + k) + 2;
      } else {
#line 719
        tmp___0 = 0;
      }
      {
#line 719
      setseqoff(p, i, tmp___0);
#line 712
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 722
  q = display->d_kmaps;
  {
#line 722
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 722
    if (! ((unsigned long )q < (unsigned long )p)) {
#line 722
      goto while_break___0;
    }
#line 724
    l = (int )*(q + 2);
#line 725
    j = 0;
#line 725
    m___0 = j;
    {
#line 725
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 725
      if (! (j < l)) {
#line 725
        goto while_break___1;
      }
#line 727
      mo = m___0;
#line 728
      if (! m___0) {
#line 728
        if ((int )*(q + (3 + j)) != (int )*(seq + j)) {
#line 729
          m___0 = 1;
        }
      }
#line 730
      if ((int )*(q + ((l + 4) + j)) == 0) {
#line 732
        if (! mo) {
#line 732
          if (m___0) {
            {
#line 733
            setseqoff(q, j, (int )(((p - q) - 4L) / 2L));
            }
          }
        }
      } else
#line 735
      if ((unsigned long )((q + (int )*(q + ((l + 4) + j)) * 2) + 4) > (unsigned long )p) {
        {
#line 736
        setseqoff(q, j, ((int )*(q + ((l + 4) + j)) + k) + 2);
        }
      } else
#line 735
      if ((unsigned long )((q + (int )*(q + ((l + 4) + j)) * 2) + 4) == (unsigned long )p) {
#line 735
        if (! m___0) {
          {
#line 736
          setseqoff(q, j, ((int )*(q + ((l + 4) + j)) + k) + 2);
          }
        }
      }
#line 725
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 722
    q += 2 * l + 4;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 742
  return (0);
}
}
#line 745 "/home/pronto/abs/test-suite/screen-4.0.2/termcap.c"
static int remmapseq(char *seq , int k ) 
{ 
  int j ;
  int l ;
  unsigned char *p ;
  unsigned char *q ;
  int tmp ;

  {
#line 753
  if (k >= 254) {
#line 754
    return (-1);
  } else {
    {
#line 753
    j = findseq_ge(seq, k, & p);
    }
#line 753
    if (j != 0) {
#line 754
      return (-1);
    }
  }
#line 755
  q = display->d_kmaps;
  {
#line 755
  while (1) {
    while_continue: /* CIL Label */ ;
#line 755
    if (! ((unsigned long )q < (unsigned long )p)) {
#line 755
      goto while_break;
    }
#line 757
    l = (int )*(q + 2);
#line 758
    j = 0;
    {
#line 758
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 758
      if (! (j < l)) {
#line 758
        goto while_break___0;
      }
#line 760
      if ((unsigned long )((q + (int )*(q + ((l + 4) + j)) * 2) + 4) == (unsigned long )p) {
#line 761
        if (*(p + ((k + 4) + j))) {
#line 761
          tmp = ((int )*(q + ((l + 4) + j)) + (int )*(p + ((k + 4) + j))) - k;
        } else {
#line 761
          tmp = 0;
        }
        {
#line 761
        setseqoff(q, j, tmp);
        }
      } else
#line 762
      if ((unsigned long )((q + (int )*(q + ((l + 4) + j)) * 2) + 4) > (unsigned long )p) {
#line 763
        *(q + ((l + 4) + j)) = (unsigned char )((int )*(q + ((l + 4) + j)) - (k + 2));
      }
#line 758
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 755
    q += 2 * l + 4;
  }
  while_break: /* CIL Label */ ;
  }
#line 766
  if ((unsigned long )(display->d_kmaps + display->d_nseqs) > (unsigned long )((p + 2 * k) + 4)) {
    {
#line 767
    bcopy((void const   *)(((char *)p + 2 * k) + 4), (void *)((char *)p), (size_t )((display->d_kmaps + display->d_nseqs) - ((p + 2 * k) + 4)));
    }
  }
  {
#line 768
  display->d_nseqs -= 2 * k + 4;
#line 769
  display->d_seqp = display->d_kmaps + 3;
#line 770
  display->d_seql = 0;
#line 771
  display->d_seqh = (unsigned char *)0;
#line 772
  evdeq(& display->d_mapev);
  }
#line 776
  return (0);
}
}
#line 817 "/home/pronto/abs/test-suite/screen-4.0.2/termcap.c"
static void AddCap(char *s ) 
{ 
  register int n ;
  size_t tmp ;

  {
  {
#line 823
  tmp = strlen((char const   *)s);
#line 823
  n = (int )tmp;
  }
#line 823
  if (tcLineLen + n > 55) {
#line 823
    if (Termcaplen < 2043) {
      {
#line 825
      strcpy((char */* __restrict  */)(Termcap + Termcaplen), (char const   */* __restrict  */)"\\\n\t:");
#line 826
      Termcaplen += 4;
#line 827
      tcLineLen = 0;
      }
    }
  }
#line 829
  if (Termcaplen + n < 2047) {
    {
#line 831
    strcpy((char */* __restrict  */)(Termcap + Termcaplen), (char const   */* __restrict  */)s);
#line 832
    Termcaplen += n;
#line 833
    tcLineLen += n;
    }
  } else {
    {
#line 836
    Panic(0, (char *)"TERMCAP overflow - sorry.");
    }
  }
#line 837
  return;
}
}
#line 843 "/home/pronto/abs/test-suite/screen-4.0.2/termcap.c"
char *MakeTermcap(int aflag ) 
{ 
  char buf___0[2048] ;
  register char *p ;
  register char *cp ;
  register char *s ;
  register char ch ;
  register char *tname ;
  int i ;
  int wi ;
  int he ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  struct action *act ;

  {
#line 854
  if (display) {
#line 856
    wi = display->d_width;
#line 857
    he = display->d_height;
#line 858
    tname = display->d_termname;
  } else {
#line 862
    wi = 80;
#line 863
    he = 24;
#line 864
    tname = (char *)"vt100";
  }
  {
#line 866
  while (1) {
    while_continue: /* CIL Label */ ;
#line 866
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 867
  s = getenv("SCREENCAP");
  }
#line 867
  if (s) {
    {
#line 867
    tmp = strlen((char const   *)s);
    }
#line 867
    if (tmp < 2048U) {
      {
#line 869
      sprintf((char */* __restrict  */)(Termcap), (char const   */* __restrict  */)"TERMCAP=%s",
              s);
#line 870
      strcpy((char */* __restrict  */)(Term), (char const   */* __restrict  */)"TERM=screen");
      }
      {
#line 871
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 871
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 872
      return (Termcap);
    }
  }
#line 874
  Termcaplen = 0;
  {
#line 875
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 875
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 876
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 876
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 877
  if ((int )screenterm[0] == 0) {
#line 877
    goto _L;
  } else {
    {
#line 877
    tmp___0 = strlen((char const   *)(screenterm));
    }
#line 877
    if (tmp___0 > 253U) {
      _L: /* CIL Label */ 
      {
#line 879
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 879
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 880
      strcpy((char */* __restrict  */)(screenterm), (char const   */* __restrict  */)"screen");
      }
    }
  }
  {
#line 885
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 887
    strcpy((char */* __restrict  */)(Term), (char const   */* __restrict  */)"TERM=");
#line 888
    p = Term + 5;
    }
#line 889
    if (! aflag) {
      {
#line 889
      tmp___2 = strlen((char const   *)(screenterm));
#line 889
      tmp___3 = strlen((char const   *)tname);
      }
#line 889
      if (tmp___2 + tmp___3 < 255U) {
        {
#line 891
        sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%s.%s",
                screenterm, tname);
#line 892
        tmp___1 = e_tgetent(buf___0, p);
        }
#line 892
        if (tmp___1 == 1) {
#line 893
          goto while_break___4;
        }
      }
    }
#line 896
    if (nwin_default.bce) {
      {
#line 898
      sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%s-bce",
              screenterm);
#line 899
      tmp___4 = e_tgetent(buf___0, p);
      }
#line 899
      if (tmp___4 == 1) {
#line 900
        goto while_break___4;
      }
    }
    {
#line 911
    strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)(screenterm));
#line 912
    tmp___5 = e_tgetent(buf___0, p);
    }
#line 912
    if (tmp___5 == 1) {
#line 913
      goto while_break___4;
    }
    {
#line 914
    strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)"vt100");
    }
#line 885
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 935
  tcLineLen = 100;
#line 936
  tmp___6 = strlen((char const   *)(Term));
  }
#line 936
  if (tmp___6 > 2008U) {
    {
#line 937
    strcpy((char */* __restrict  */)(Term), (char const   */* __restrict  */)"too_long");
    }
  }
  {
#line 938
  sprintf((char */* __restrict  */)(Termcap), (char const   */* __restrict  */)"TERMCAP=SC|%s|VT 100/ANSI X3.64 virtual terminal:",
          Term + 5);
#line 939
  tmp___7 = strlen((char const   *)(Termcap));
#line 939
  Termcaplen = (int )tmp___7;
  }
  {
#line 940
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 940
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 941
  if (extra_outcap) {
#line 941
    if (*extra_outcap) {
#line 943
      cp = extra_outcap;
      {
#line 943
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 943
        p = index((char const   *)cp, ':');
        }
#line 943
        if (! p) {
#line 943
          goto while_break___6;
        }
        {
#line 945
        p ++;
#line 945
        ch = *p;
#line 946
        *p = (char )'\000';
#line 947
        AddCap(cp);
#line 948
        *p = ch;
#line 943
        cp = p;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
#line 950
      tcLineLen = 100;
    }
  }
  {
#line 952
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 952
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 953
  tmp___9 = strlen(TermcapConst);
  }
#line 953
  if ((size_t )Termcaplen + tmp___9 < 2048U) {
    {
#line 955
    strcpy((char */* __restrict  */)(Termcap + Termcaplen), (char const   */* __restrict  */)((char *)(TermcapConst)));
#line 956
    tmp___8 = strlen(TermcapConst);
#line 956
    Termcaplen = (int )((size_t )Termcaplen + tmp___8);
    }
  }
  {
#line 958
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"li#%d:co#%d:",
          he, wi);
#line 959
  AddCap(buf___0);
#line 960
  AddCap((char *)"am:");
  }
#line 961
  if (aflag) {
    {
#line 963
    AddCap((char *)"xn:");
#line 964
    AddCap((char *)"xv:");
#line 965
    AddCap((char *)"LP:");
    }
  } else
#line 961
  if (force_vt) {
#line 961
    if (! display->d_tcs[86].flg) {
      {
#line 963
      AddCap((char *)"xn:");
#line 964
      AddCap((char *)"xv:");
#line 965
      AddCap((char *)"LP:");
      }
    } else {
#line 961
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 961
  if (display->d_tcs[87].flg) {
    {
#line 963
    AddCap((char *)"xn:");
#line 964
    AddCap((char *)"xv:");
#line 965
    AddCap((char *)"LP:");
    }
  } else
#line 961
  if (! display->d_tcs[83].flg) {
    {
#line 963
    AddCap((char *)"xn:");
#line 964
    AddCap((char *)"xv:");
#line 965
    AddCap((char *)"LP:");
    }
  }
#line 967
  if (aflag) {
    {
#line 969
    AddCap((char *)"sr=\\EM:");
#line 970
    AddCap((char *)"al=\\E[L:");
#line 971
    AddCap((char *)"AL=\\E[%dL:");
    }
  } else
#line 967
  if (display->d_tcs[18].str) {
#line 967
    if (display->d_tcs[21].str) {
      {
#line 969
      AddCap((char *)"sr=\\EM:");
#line 970
      AddCap((char *)"al=\\E[L:");
#line 971
      AddCap((char *)"AL=\\E[%dL:");
      }
    } else {
#line 967
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 967
  if (display->d_tcs[22].str) {
    {
#line 969
    AddCap((char *)"sr=\\EM:");
#line 970
    AddCap((char *)"al=\\E[L:");
#line 971
    AddCap((char *)"AL=\\E[%dL:");
    }
  } else
#line 967
  if (display->d_tcs[23].str) {
    {
#line 969
    AddCap((char *)"sr=\\EM:");
#line 970
    AddCap((char *)"al=\\E[L:");
#line 971
    AddCap((char *)"AL=\\E[%dL:");
    }
  } else
#line 973
  if (display->d_tcs[21].str) {
    {
#line 974
    AddCap((char *)"sr=\\EM:");
    }
  }
#line 975
  if (aflag) {
    {
#line 976
    AddCap((char *)"cs=\\E[%i%d;%dr:");
    }
  } else
#line 975
  if (display->d_tcs[18].str) {
    {
#line 976
    AddCap((char *)"cs=\\E[%i%d;%dr:");
    }
  }
#line 977
  if (aflag) {
    {
#line 979
    AddCap((char *)"dl=\\E[M:");
#line 980
    AddCap((char *)"DL=\\E[%dM:");
    }
  } else
#line 977
  if (display->d_tcs[18].str) {
    {
#line 979
    AddCap((char *)"dl=\\E[M:");
#line 980
    AddCap((char *)"DL=\\E[%dM:");
    }
  } else
#line 977
  if (display->d_tcs[24].str) {
    {
#line 979
    AddCap((char *)"dl=\\E[M:");
#line 980
    AddCap((char *)"DL=\\E[%dM:");
    }
  } else
#line 977
  if (display->d_tcs[25].str) {
    {
#line 979
    AddCap((char *)"dl=\\E[M:");
#line 980
    AddCap((char *)"DL=\\E[%dM:");
    }
  }
#line 982
  if (aflag) {
    {
#line 984
    AddCap((char *)"dc=\\E[P:");
#line 985
    AddCap((char *)"DC=\\E[%dP:");
    }
  } else
#line 982
  if (display->d_tcs[31].str) {
    {
#line 984
    AddCap((char *)"dc=\\E[P:");
#line 985
    AddCap((char *)"DC=\\E[%dP:");
    }
  } else
#line 982
  if (display->d_tcs[32].str) {
    {
#line 984
    AddCap((char *)"dc=\\E[P:");
#line 985
    AddCap((char *)"DC=\\E[%dP:");
    }
  }
#line 987
  if (aflag) {
    {
#line 989
    AddCap((char *)"im=\\E[4h:");
#line 990
    AddCap((char *)"ei=\\E[4l:");
#line 991
    AddCap((char *)"mi:");
#line 992
    AddCap((char *)"IC=\\E[%d@:");
    }
  } else
#line 987
  if (display->d_tcs[30].str) {
    {
#line 989
    AddCap((char *)"im=\\E[4h:");
#line 990
    AddCap((char *)"ei=\\E[4l:");
#line 991
    AddCap((char *)"mi:");
#line 992
    AddCap((char *)"IC=\\E[%d@:");
    }
  } else
#line 987
  if (display->d_tcs[29].str) {
    {
#line 989
    AddCap((char *)"im=\\E[4h:");
#line 990
    AddCap((char *)"ei=\\E[4l:");
#line 991
    AddCap((char *)"mi:");
#line 992
    AddCap((char *)"IC=\\E[%d@:");
    }
  } else
#line 987
  if (display->d_tcs[27].str) {
    {
#line 989
    AddCap((char *)"im=\\E[4h:");
#line 990
    AddCap((char *)"ei=\\E[4l:");
#line 991
    AddCap((char *)"mi:");
#line 992
    AddCap((char *)"IC=\\E[%d@:");
    }
  }
  {
#line 995
  AddCap((char *)"ks=\\E[?1h\\E=:");
#line 996
  AddCap((char *)"ke=\\E[?1l\\E>:");
#line 998
  AddCap((char *)"vi=\\E[?25l:");
#line 999
  AddCap((char *)"ve=\\E[34h\\E[?25h:");
#line 1000
  AddCap((char *)"vs=\\E[34l:");
#line 1001
  AddCap((char *)"ti=\\E[?1049h:");
#line 1002
  AddCap((char *)"te=\\E[?1049l:");
  }
#line 1003
  if (display) {
#line 1005
    if (display->d_tcs[48].str) {
      {
#line 1007
      AddCap((char *)"us=\\E[4m:");
#line 1008
      AddCap((char *)"ue=\\E[24m:");
      }
    }
#line 1010
    if (display->d_tcs[51].str) {
      {
#line 1012
      AddCap((char *)"so=\\E[3m:");
#line 1013
      AddCap((char *)"se=\\E[23m:");
      }
    }
#line 1015
    if (display->d_tcs[52].str) {
      {
#line 1016
      AddCap((char *)"mb=\\E[5m:");
      }
    }
#line 1017
    if (display->d_tcs[49].str) {
      {
#line 1018
      AddCap((char *)"md=\\E[1m:");
      }
    }
#line 1019
    if (display->d_tcs[47].str) {
      {
#line 1020
      AddCap((char *)"mh=\\E[2m:");
      }
    }
#line 1021
    if (display->d_tcs[50].str) {
      {
#line 1022
      AddCap((char *)"mr=\\E[7m:");
      }
    }
#line 1023
    if (display->d_tcs[52].str) {
      {
#line 1024
      AddCap((char *)"me=\\E[m:ms:");
      }
    } else
#line 1023
    if (display->d_tcs[49].str) {
      {
#line 1024
      AddCap((char *)"me=\\E[m:ms:");
      }
    } else
#line 1023
    if (display->d_tcs[47].str) {
      {
#line 1024
      AddCap((char *)"me=\\E[m:ms:");
      }
    } else
#line 1023
    if (display->d_tcs[50].str) {
      {
#line 1024
      AddCap((char *)"me=\\E[m:ms:");
      }
    }
#line 1025
    if (display->d_hascolor) {
      {
#line 1026
      AddCap((char *)"Co#8:pa#64:AF=\\E[3%dm:AB=\\E[4%dm:op=\\E[39;49m:AX:");
      }
    }
#line 1027
    if (display->d_tcs[43].str) {
      {
#line 1028
      AddCap((char *)"vb=\\Eg:");
      }
    }
#line 1041
    if (display->d_tcs[97].flg) {
      {
#line 1042
      AddCap((char *)"G0:");
      }
    }
#line 1043
    if (display->d_tcs[100].str) {
      {
#line 1045
      AddCap((char *)"as=\\E(0:");
#line 1046
      AddCap((char *)"ae=\\E(B:");
#line 1048
      AddCap((char *)"ac=\\140\\140aaffggjjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~..--++,,hhII00:");
      }
    } else
#line 1043
    if (display->d_tcs[98].str) {
#line 1043
      if (*(display->d_tcs[98].str)) {
        {
#line 1045
        AddCap((char *)"as=\\E(0:");
#line 1046
        AddCap((char *)"ae=\\E(B:");
#line 1048
        AddCap((char *)"ac=\\140\\140aaffggjjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~..--++,,hhII00:");
        }
      }
    }
#line 1050
    if (display->d_tcs[73].str) {
      {
#line 1052
      AddCap((char *)"po=\\E[5i:");
#line 1053
      AddCap((char *)"pf=\\E[4i:");
      }
    }
#line 1055
    if (display->d_tcs[45].str) {
      {
#line 1057
      AddCap((char *)"Z0=\\E[?3h:");
#line 1058
      AddCap((char *)"Z1=\\E[?3l:");
      }
    }
#line 1060
    if (display->d_tcs[44].str) {
      {
#line 1061
      AddCap((char *)"WS=\\E[8;%d;%dt:");
      }
    }
  }
#line 1063
  i = 106;
  {
#line 1063
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 1063
    if (! (i < 196)) {
#line 1063
      goto while_break___8;
    }
#line 1067
    if (i < 183) {
#line 1069
      if (i >= 165) {
#line 1070
        goto __Cont;
      }
#line 1071
      if (i >= 161) {
#line 1071
        if (i < 183) {
#line 1073
          act = & umtab[i - 84];
#line 1074
          if (act->nr == -1) {
#line 1075
            act = & dmtab[i - 84];
          }
        } else {
#line 1071
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
#line 1079
        act = & umtab[i - 106];
#line 1080
        if (act->nr == -1) {
#line 1081
          act = & dmtab[i - 106];
        }
      }
#line 1083
      if (act->nr == -1) {
#line 1083
        if (i == 154) {
#line 1083
          goto _L___3;
        } else
#line 1083
        if (i == 156) {
          _L___3: /* CIL Label */ 
#line 1086
          act = & umtab[(i - 106) - 1];
#line 1087
          if (act->nr == -1) {
#line 1088
            act = & dmtab[(i - 106) - 1];
          }
        }
      }
#line 1090
      if (act->nr != -1) {
#line 1092
        if (act->nr == 147) {
          {
#line 1094
          MakeString(term[i].tcname, buf___0, (int )sizeof(buf___0), *(act->args + 0));
#line 1095
          AddCap(buf___0);
          }
        }
#line 1097
        goto __Cont;
      }
    }
#line 1101
    if ((unsigned long )display == (unsigned long )((struct display *)0)) {
#line 1102
      goto __Cont;
    }
    {
#line 1105
    if (term[i].type == 2) {
#line 1105
      goto case_2;
    }
#line 1111
    if (term[i].type == 0) {
#line 1111
      goto case_0;
    }
#line 1117
    goto switch_default;
    case_2: /* CIL Label */ 
#line 1106
    if ((unsigned long )display->d_tcs[i].str == (unsigned long )((char *)0)) {
#line 1107
      goto switch_break;
    }
    {
#line 1108
    MakeString(term[i].tcname, buf___0, (int )sizeof(buf___0), display->d_tcs[i].str);
#line 1109
    AddCap(buf___0);
    }
#line 1110
    goto switch_break;
    case_0: /* CIL Label */ 
#line 1112
    if (display->d_tcs[i].flg == 0) {
#line 1113
      goto switch_break;
    }
    {
#line 1114
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%s:",
            term[i].tcname);
#line 1115
    AddCap(buf___0);
    }
#line 1116
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1118
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 1063
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 1121
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 1121
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 1122
  return (Termcap);
}
}
#line 1125 "/home/pronto/abs/test-suite/screen-4.0.2/termcap.c"
static void MakeString(char *cap , char *buf___0 , int buflen , char *s ) 
{ 
  register char *p ;
  register char *pmax ;
  register unsigned int c ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
#line 1134
  p = buf___0;
#line 1135
  pmax = (p + buflen) - 9;
#line 1136
  tmp = p;
#line 1136
  p ++;
#line 1136
  tmp___0 = cap;
#line 1136
  cap ++;
#line 1136
  *tmp = *tmp___0;
#line 1137
  tmp___1 = p;
#line 1137
  p ++;
#line 1137
  *tmp___1 = *cap;
#line 1138
  tmp___2 = p;
#line 1138
  p ++;
#line 1138
  *tmp___2 = (char )'=';
  {
#line 1139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1139
    tmp___10 = s;
#line 1139
    s ++;
#line 1139
    c = (unsigned int )*tmp___10;
#line 1139
    if (c) {
#line 1139
      if (! ((unsigned long )p < (unsigned long )pmax)) {
#line 1139
        goto while_break;
      }
    } else {
#line 1139
      goto while_break;
    }
    {
#line 1143
    if (c == 27U) {
#line 1143
      goto case_27;
    }
#line 1147
    if (c == 58U) {
#line 1147
      goto case_58;
    }
#line 1152
    if (c == 92U) {
#line 1152
      goto case_92;
    }
#line 1152
    if (c == 94U) {
#line 1152
      goto case_92;
    }
#line 1156
    goto switch_default;
    case_27: /* CIL Label */ 
#line 1144
    tmp___3 = p;
#line 1144
    p ++;
#line 1144
    *tmp___3 = (char )'\\';
#line 1145
    tmp___4 = p;
#line 1145
    p ++;
#line 1145
    *tmp___4 = (char )'E';
#line 1146
    goto switch_break;
    case_58: /* CIL Label */ 
    {
#line 1148
    strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)"\\072");
#line 1149
    p += 4;
    }
#line 1150
    goto switch_break;
    case_92: /* CIL Label */ 
    case_94: /* CIL Label */ 
#line 1153
    tmp___5 = p;
#line 1153
    p ++;
#line 1153
    *tmp___5 = (char )'\\';
#line 1154
    tmp___6 = p;
#line 1154
    p ++;
#line 1154
    *tmp___6 = (char )c;
#line 1155
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1157
    if (c >= 200U) {
      {
#line 1159
      sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"\\%03o",
              c & 255U);
#line 1160
      p += 4;
      }
    } else
#line 1162
    if (c < 32U) {
#line 1164
      tmp___7 = p;
#line 1164
      p ++;
#line 1164
      *tmp___7 = (char )'^';
#line 1165
      tmp___8 = p;
#line 1165
      p ++;
#line 1165
      *tmp___8 = (char )(c + 64U);
    } else {
#line 1168
      tmp___9 = p;
#line 1168
      p ++;
#line 1168
      *tmp___9 = (char )c;
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1171
  tmp___11 = p;
#line 1171
  p ++;
#line 1171
  *tmp___11 = (char )':';
#line 1172
  *p = (char )'\000';
#line 1173
  return;
}
}
#line 1181 "/home/pronto/abs/test-suite/screen-4.0.2/termcap.c"
int CreateTransTable(char *s ) 
{ 
  int curchar ;
  char *templ ;
  char *arg ;
  int templlen ;
  int templnsub ;
  char *p ;
  char *sx ;
  char **ctable ;
  int l ;
  int c ;
  char ***tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char **tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 1193
  tmp___0 = malloc((size_t )(256UL * sizeof(char **)));
#line 1193
  tmp = (char ***)tmp___0;
#line 1193
  display->d_xtable = tmp;
  }
#line 1193
  if ((unsigned long )tmp == (unsigned long )((char ***)0)) {
    {
#line 1195
    Msg(0, strnomem);
    }
#line 1196
    return (-1);
  }
  {
#line 1198
  bzero((void *)((char *)display->d_xtable), (size_t )(256UL * sizeof(char **)));
  }
  {
#line 1200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1200
    if (! *s) {
#line 1200
      goto while_break;
    }
#line 1202
    if ((int )*s == 92) {
#line 1202
      if ((int )*(s + 1) == 92) {
#line 1203
        s ++;
      } else
#line 1202
      if ((int )*(s + 1) == 44) {
#line 1203
        s ++;
      } else
#line 1202
      if ((int )*(s + 1) == 37) {
#line 1203
        s ++;
      }
    }
#line 1204
    tmp___1 = s;
#line 1204
    s ++;
#line 1204
    curchar = (int )((unsigned char )*tmp___1);
#line 1205
    if (curchar == 66) {
#line 1206
      curchar = 0;
    }
#line 1207
    templ = s;
#line 1208
    templlen = 0;
#line 1209
    templnsub = 0;
#line 1210
    if ((unsigned long )*(display->d_xtable + curchar) == (unsigned long )((char **)0)) {
      {
#line 1212
      tmp___3 = malloc((size_t )(257UL * sizeof(char *)));
#line 1212
      tmp___2 = (char **)tmp___3;
#line 1212
      *(display->d_xtable + curchar) = tmp___2;
      }
#line 1212
      if ((unsigned long )tmp___2 == (unsigned long )((char **)0)) {
        {
#line 1214
        Msg(0, strnomem);
#line 1215
        FreeTransTable();
        }
#line 1216
        return (-1);
      }
      {
#line 1218
      bzero((void *)((char *)*(display->d_xtable + curchar)), (size_t )(257UL * sizeof(char *)));
      }
    }
#line 1220
    ctable = *(display->d_xtable + curchar);
    {
#line 1221
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1221
      if (*s) {
#line 1221
        if (! ((int )*s != 44)) {
#line 1221
          goto while_break___0;
        }
      } else {
#line 1221
        goto while_break___0;
      }
#line 1223
      if ((int )*s == 92) {
#line 1223
        if ((int )*(s + 1) == 92) {
#line 1224
          s ++;
        } else
#line 1223
        if ((int )*(s + 1) == 44) {
#line 1224
          s ++;
        } else
#line 1223
        if ((int )*(s + 1) == 37) {
#line 1224
          s ++;
        } else {
#line 1223
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1225
      if ((int )*s == 37) {
#line 1227
        templnsub ++;
#line 1228
        goto __Cont;
      }
#line 1230
      templlen ++;
      __Cont: /* CIL Label */ 
#line 1221
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1232
    tmp___4 = s;
#line 1232
    s ++;
#line 1232
    if ((int )*tmp___4 == 0) {
#line 1233
      goto while_break;
    }
    {
#line 1234
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1234
      if (*s) {
#line 1234
        if (! ((int )*s != 44)) {
#line 1234
          goto while_break___1;
        }
      } else {
#line 1234
        goto while_break___1;
      }
#line 1236
      tmp___5 = s;
#line 1236
      s ++;
#line 1236
      c = (int )((unsigned char )*tmp___5);
#line 1237
      if ((int )*(s - 1) == 92) {
#line 1237
        if ((int )*((s - 1) + 1) == 92) {
#line 1238
          tmp___6 = s;
#line 1238
          s ++;
#line 1238
          c = (int )((unsigned char )*tmp___6);
        } else
#line 1237
        if ((int )*((s - 1) + 1) == 44) {
#line 1238
          tmp___6 = s;
#line 1238
          s ++;
#line 1238
          c = (int )((unsigned char )*tmp___6);
        } else
#line 1237
        if ((int )*((s - 1) + 1) == 37) {
#line 1238
          tmp___6 = s;
#line 1238
          s ++;
#line 1238
          c = (int )((unsigned char )*tmp___6);
        } else {
#line 1237
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 1239
      if (c == 37) {
#line 1240
        c = 256;
      }
#line 1241
      if (*(ctable + c)) {
        {
#line 1242
        free((void *)*(ctable + c));
        }
      }
      {
#line 1243
      arg = s;
#line 1244
      l = copyarg(& s, (char *)0);
      }
#line 1245
      if (c != 256) {
#line 1246
        l = l * templnsub + templlen;
      }
      {
#line 1247
      tmp___8 = malloc((size_t )(l + 1));
#line 1247
      tmp___7 = (char *)tmp___8;
#line 1247
      *(ctable + c) = tmp___7;
      }
#line 1247
      if ((unsigned long )tmp___7 == (unsigned long )((char *)0)) {
        {
#line 1249
        Msg(0, strnomem);
#line 1250
        FreeTransTable();
        }
#line 1251
        return (-1);
      }
#line 1253
      sx = *(ctable + c);
#line 1254
      if (c == 256) {
#line 1254
        p = (char *)"%";
      } else {
#line 1254
        p = templ;
      }
      {
#line 1254
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1254
        if (*p) {
#line 1254
          if (! ((int )*p != 44)) {
#line 1254
            goto while_break___2;
          }
        } else {
#line 1254
          goto while_break___2;
        }
#line 1256
        if ((int )*p == 92) {
#line 1256
          if ((int )*(p + 1) == 92) {
#line 1257
            p ++;
          } else
#line 1256
          if ((int )*(p + 1) == 44) {
#line 1257
            p ++;
          } else
#line 1256
          if ((int )*(p + 1) == 37) {
#line 1257
            p ++;
          } else {
#line 1256
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 1258
        if ((int )*p == 37) {
          {
#line 1260
          s = arg;
#line 1261
          tmp___9 = copyarg(& s, sx);
#line 1261
          sx += tmp___9;
          }
#line 1262
          goto __Cont___0;
        }
#line 1264
        tmp___10 = sx;
#line 1264
        sx ++;
#line 1264
        *tmp___10 = *p;
        __Cont___0: /* CIL Label */ 
#line 1254
        p ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1266
      *sx = (char)0;
      {
#line 1267
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1267
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 1268
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1268
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1270
    if ((int )*s == 44) {
#line 1271
      s ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1273
  return (0);
}
}
#line 1276 "/home/pronto/abs/test-suite/screen-4.0.2/termcap.c"
void FreeTransTable(void) 
{ 
  char ***p ;
  char **q ;
  int i ;
  int j ;

  {
#line 1282
  p = display->d_xtable;
#line 1282
  if ((unsigned long )p == (unsigned long )((char ***)0)) {
#line 1283
    return;
  }
#line 1284
  i = 0;
  {
#line 1284
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1284
    if (! (i < 256)) {
#line 1284
      goto while_break;
    }
#line 1286
    if ((unsigned long )*p == (unsigned long )((char **)0)) {
#line 1287
      goto __Cont;
    }
#line 1288
    q = *p;
#line 1289
    j = 0;
    {
#line 1289
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1289
      if (! (j < 257)) {
#line 1289
        goto while_break___0;
      }
#line 1290
      if (*q) {
        {
#line 1291
        free((void *)*q);
        }
      }
#line 1289
      j ++;
#line 1289
      q ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1292
    free((void *)*p);
    }
    __Cont: /* CIL Label */ 
#line 1284
    i ++;
#line 1284
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1294
  free((void *)display->d_xtable);
  }
#line 1295
  return;
}
}
#line 1298 "/home/pronto/abs/test-suite/screen-4.0.2/termcap.c"
static int copyarg(char **pp , char *s ) 
{ 
  int l ;
  char *p ;
  char *tmp ;

  {
#line 1305
  l = 0;
#line 1305
  p = *pp;
  {
#line 1305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1305
    if (*p) {
#line 1305
      if (! ((int )*p != 44)) {
#line 1305
        goto while_break;
      }
    } else {
#line 1305
      goto while_break;
    }
#line 1307
    if ((int )*p == 92) {
#line 1307
      if ((int )*(p + 1) == 92) {
#line 1308
        p ++;
      } else
#line 1307
      if ((int )*(p + 1) == 44) {
#line 1308
        p ++;
      } else
#line 1307
      if ((int )*(p + 1) == 37) {
#line 1308
        p ++;
      }
    }
#line 1309
    if (s) {
#line 1310
      tmp = s;
#line 1310
      s ++;
#line 1310
      *tmp = *p;
    }
#line 1311
    l ++;
#line 1305
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1313
  if ((int )*p == 44) {
#line 1314
    p ++;
  }
#line 1315
  *pp = p;
#line 1316
  return (l);
}
}
#line 1326 "/home/pronto/abs/test-suite/screen-4.0.2/termcap.c"
static int e_tgetent(char *bp , char *name ) 
{ 
  int r ;

  {
  {
#line 1333
  xseteuid(real_uid);
#line 1334
  xsetegid(real_gid);
#line 1336
  r = tgetent(bp, name);
#line 1338
  xseteuid(eff_uid);
#line 1339
  xsetegid(eff_gid);
  }
#line 1341
  return (r);
}
}
#line 1351 "/home/pronto/abs/test-suite/screen-4.0.2/termcap.c"
static char *findcap(char *cap , char **tepp , int n ) 
{ 
  char *tep ;
  char c ;
  char *p ;
  char *cp ;
  int mode ;
  int num ;
  int capl ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 1360
  num = 0;
#line 1362
  if (! extra_incap) {
#line 1363
    return ((char *)0);
  }
  {
#line 1364
  tep = *tepp;
#line 1365
  tmp = strlen((char const   *)cap);
#line 1365
  capl = (int )tmp;
#line 1366
  cp = (char *)0;
#line 1367
  mode = 0;
#line 1368
  p = extra_incap;
  }
  {
#line 1368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1368
    if (! *p) {
#line 1368
      goto while_break;
    }
    {
#line 1370
    tmp___0 = strncmp((char const   *)p, (char const   *)cap, (size_t )capl);
    }
#line 1370
    if (tmp___0 == 0) {
#line 1372
      p += capl;
#line 1373
      c = *p;
#line 1374
      if (c) {
#line 1374
        if ((int )c != 58) {
#line 1374
          if ((int )c != 64) {
#line 1375
            p ++;
          }
        }
      }
#line 1376
      if ((int )c == 0) {
#line 1377
        cp = tep;
      } else
#line 1376
      if ((int )c == 64) {
#line 1377
        cp = tep;
      } else
#line 1376
      if ((int )c == 61) {
#line 1377
        cp = tep;
      } else
#line 1376
      if ((int )c == 58) {
#line 1377
        cp = tep;
      } else
#line 1376
      if ((int )c == 35) {
#line 1377
        cp = tep;
      }
    }
    {
#line 1379
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1379
      c = *p;
#line 1379
      if (! c) {
#line 1379
        goto while_break___0;
      }
#line 1381
      p ++;
#line 1382
      if (mode == 0) {
#line 1384
        if ((int )c == 58) {
#line 1385
          goto while_break___0;
        }
#line 1386
        if ((int )c == 94) {
#line 1387
          mode = 1;
        }
#line 1388
        if ((int )c == 92) {
#line 1389
          mode = 2;
        }
      } else
#line 1391
      if (mode == 1) {
#line 1393
        mode = 0;
#line 1394
        c = (char )((int )c & 31);
      } else
#line 1396
      if (mode == 2) {
#line 1398
        mode = 0;
        {
#line 1410
        if ((int )c == 57) {
#line 1410
          goto case_57;
        }
#line 1410
        if ((int )c == 56) {
#line 1410
          goto case_57;
        }
#line 1410
        if ((int )c == 55) {
#line 1410
          goto case_57;
        }
#line 1410
        if ((int )c == 54) {
#line 1410
          goto case_57;
        }
#line 1410
        if ((int )c == 53) {
#line 1410
          goto case_57;
        }
#line 1410
        if ((int )c == 52) {
#line 1410
          goto case_57;
        }
#line 1410
        if ((int )c == 51) {
#line 1410
          goto case_57;
        }
#line 1410
        if ((int )c == 50) {
#line 1410
          goto case_57;
        }
#line 1410
        if ((int )c == 49) {
#line 1410
          goto case_57;
        }
#line 1410
        if ((int )c == 48) {
#line 1410
          goto case_57;
        }
#line 1414
        if ((int )c == 69) {
#line 1414
          goto case_69;
        }
#line 1417
        if ((int )c == 110) {
#line 1417
          goto case_110;
        }
#line 1420
        if ((int )c == 114) {
#line 1420
          goto case_114;
        }
#line 1423
        if ((int )c == 116) {
#line 1423
          goto case_116;
        }
#line 1426
        if ((int )c == 98) {
#line 1426
          goto case_98;
        }
#line 1429
        if ((int )c == 102) {
#line 1429
          goto case_102;
        }
#line 1399
        goto switch_break;
        case_57: /* CIL Label */ 
        case_56: /* CIL Label */ 
        case_55: /* CIL Label */ 
        case_54: /* CIL Label */ 
        case_53: /* CIL Label */ 
        case_52: /* CIL Label */ 
        case_51: /* CIL Label */ 
        case_50: /* CIL Label */ 
        case_49: /* CIL Label */ 
        case_48: /* CIL Label */ 
#line 1411
        mode = 3;
#line 1412
        num = 0;
#line 1413
        goto switch_break;
        case_69: /* CIL Label */ 
#line 1415
        c = (char)27;
#line 1416
        goto switch_break;
        case_110: /* CIL Label */ 
#line 1418
        c = (char )'\n';
#line 1419
        goto switch_break;
        case_114: /* CIL Label */ 
#line 1421
        c = (char )'\r';
#line 1422
        goto switch_break;
        case_116: /* CIL Label */ 
#line 1424
        c = (char )'\t';
#line 1425
        goto switch_break;
        case_98: /* CIL Label */ 
#line 1427
        c = (char )'\b';
#line 1428
        goto switch_break;
        case_102: /* CIL Label */ 
#line 1430
        c = (char )'\f';
#line 1431
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
#line 1434
      if (mode > 2) {
#line 1436
        num = num * 8 + ((int )c - 48);
#line 1437
        tmp___1 = mode;
#line 1437
        mode ++;
#line 1437
        if (tmp___1 == 5) {
#line 1439
          c = (char )num;
#line 1440
          mode = 0;
        } else
#line 1437
        if ((int )*p < 48) {
#line 1439
          c = (char )num;
#line 1440
          mode = 0;
        } else
#line 1437
        if ((int )*p > 57) {
#line 1439
          c = (char )num;
#line 1440
          mode = 0;
        }
      }
#line 1443
      if (mode) {
#line 1444
        goto while_continue___0;
      }
#line 1446
      if (cp) {
#line 1446
        if (n != 1) {
#line 1448
          tmp___2 = cp;
#line 1448
          cp ++;
#line 1448
          *tmp___2 = c;
#line 1449
          n --;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1452
    if (cp) {
#line 1454
      tmp___3 = cp;
#line 1454
      cp ++;
#line 1454
      *tmp___3 = (char)0;
#line 1455
      *tepp = cp;
      {
#line 1456
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1456
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1457
      return (tep);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1460
  return ((char *)0);
}
}
#line 1463 "/home/pronto/abs/test-suite/screen-4.0.2/termcap.c"
static char *e_tgetstr(char *cap , char **tepp ) 
{ 
  char *tep ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 1469
  tep = findcap(cap, tepp, 0);
  }
#line 1469
  if (tep) {
#line 1470
    if ((int )*tep == 64) {
#line 1470
      tmp = (char *)0;
    } else {
#line 1470
      tmp = tep;
    }
#line 1470
    return (tmp);
  }
  {
#line 1471
  tmp___0 = tgetstr(cap, tepp);
  }
#line 1471
  return (tmp___0);
}
}
#line 1474 "/home/pronto/abs/test-suite/screen-4.0.2/termcap.c"
static int e_tgetflag(char *cap ) 
{ 
  char buf___0[2] ;
  char *bufp ;
  char *tep ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1480
  bufp = buf___0;
#line 1481
  tep = findcap(cap, & bufp, 2);
  }
#line 1481
  if (tep) {
#line 1482
    if ((int )*tep == 64) {
#line 1482
      tmp = 0;
    } else {
#line 1482
      tmp = 1;
    }
#line 1482
    return (tmp);
  }
  {
#line 1483
  tmp___0 = tgetflag(cap);
  }
#line 1483
  return (tmp___0 > 0);
}
}
#line 1486 "/home/pronto/abs/test-suite/screen-4.0.2/termcap.c"
static int e_tgetnum(char *cap ) 
{ 
  char buf___0[20] ;
  char *bufp ;
  char *tep ;
  char c ;
  int res ;
  int base ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 1492
  base = 10;
#line 1494
  bufp = buf___0;
#line 1495
  tep = findcap(cap, & bufp, 20);
  }
#line 1495
  if (tep) {
#line 1497
    c = *tep;
#line 1498
    if ((int )c == 64) {
#line 1499
      return (-1);
    }
#line 1500
    if ((int )c == 48) {
#line 1501
      base = 8;
    }
#line 1502
    res = 0;
    {
#line 1503
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1503
      tmp = tep;
#line 1503
      tep ++;
#line 1503
      c = *tmp;
#line 1503
      if ((int )c >= 48) {
#line 1503
        if (! ((int )c <= 57)) {
#line 1503
          goto while_break;
        }
      } else {
#line 1503
        goto while_break;
      }
#line 1504
      res = res * base + ((int )c - 48);
    }
    while_break: /* CIL Label */ ;
    }
#line 1505
    return (res);
  }
  {
#line 1507
  tmp___0 = tgetnum(cap);
  }
#line 1507
  return (tmp___0);
}
}
#line 92 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 120 "/home/pronto/abs/test-suite/screen-4.0.2/extern.h"
void exit_with_usage(char *myname , char *message , char *arg ) ;
#line 127
void WListUpdatecv(struct canvas *cv , struct win *p ) ;
#line 130
void ZmodemPage(void) ;
#line 346
void centerline(char *str , int y ) ;
#line 347
void leftline(char *str , int y ) ;
#line 368
int AddXChar(char *buf___0 , int ch ) ;
#line 31 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
char version[40]  ;
#line 38
unsigned char *blank ;
#line 41
static void PadStr(char *str , int n , int x , int y ) ;
#line 46 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
void exit_with_usage(char *myname , char *message , char *arg ) 
{ 


  {
  {
#line 50
  printf((char const   */* __restrict  */)"Use: %s [-opts] [cmd [args]]\n", myname);
#line 51
  printf((char const   */* __restrict  */)" or: %s -r [host.tty]\n\nOptions:\n", myname);
#line 52
  printf((char const   */* __restrict  */)"-a            Force all capabilities into each window\'s termcap.\n");
#line 53
  printf((char const   */* __restrict  */)"-A -[r|R]     Adapt all windows to the new display width & height.\n");
#line 54
  printf((char const   */* __restrict  */)"-c file       Read configuration file instead of \'.screenrc\'.\n");
#line 56
  printf((char const   */* __restrict  */)"-d (-r)       Detach the elsewhere running screen (and reattach here).\n");
#line 57
  printf((char const   */* __restrict  */)"-dmS name     Start as daemon: Screen session in detached mode.\n");
#line 58
  printf((char const   */* __restrict  */)"-D (-r)       Detach and logout remote (and reattach here).\n");
#line 59
  printf((char const   */* __restrict  */)"-D -RR        Do whatever is needed to get a screen session.\n");
#line 61
  printf((char const   */* __restrict  */)"-e xy         Change command characters.\n");
#line 62
  printf((char const   */* __restrict  */)"-f            Flow control on, -fn = off, -fa = auto.\n");
#line 63
  printf((char const   */* __restrict  */)"-h lines      Set the size of the scrollback history buffer.\n");
#line 64
  printf((char const   */* __restrict  */)"-i            Interrupt output sooner when flow control is on.\n");
#line 66
  printf((char const   */* __restrict  */)"-l            Login mode on (update %s), -ln = off.\n",
         "/var/run/utmp");
#line 68
  printf((char const   */* __restrict  */)"-list         or -ls. Do nothing, just list our SockDir.\n");
#line 69
  printf((char const   */* __restrict  */)"-L            Turn on output logging.\n");
#line 70
  printf((char const   */* __restrict  */)"-m            ignore $STY variable, do create a new screen session.\n");
#line 71
  printf((char const   */* __restrict  */)"-O            Choose optimal output rather than exact vt100 emulation.\n");
#line 72
  printf((char const   */* __restrict  */)"-p window     Preselect the named window if it exists.\n");
#line 73
  printf((char const   */* __restrict  */)"-q            Quiet startup. Exits with non-zero return code if unsuccessful.\n");
#line 74
  printf((char const   */* __restrict  */)"-r            Reattach to a detached screen process.\n");
#line 75
  printf((char const   */* __restrict  */)"-R            Reattach if possible, otherwise start a new session.\n");
#line 76
  printf((char const   */* __restrict  */)"-s shell      Shell to execute rather than $SHELL.\n");
#line 77
  printf((char const   */* __restrict  */)"-S sockname   Name this session <pid>.sockname instead of <pid>.<tty>.<host>.\n");
#line 78
  printf((char const   */* __restrict  */)"-t title      Set title. (window\'s name).\n");
#line 79
  printf((char const   */* __restrict  */)"-T term       Use term as $TERM for windows, rather than \"screen\".\n");
#line 81
  printf((char const   */* __restrict  */)"-U            Tell screen to use UTF-8 encoding.\n");
#line 83
  printf((char const   */* __restrict  */)"-v            Print \"Screen version %s\".\n",
         version);
#line 84
  printf((char const   */* __restrict  */)"-wipe         Do nothing, just clean up SockDir.\n");
#line 86
  printf((char const   */* __restrict  */)"-x            Attach to a not detached screen. (Multi display mode).\n");
#line 88
  printf((char const   */* __restrict  */)"-X            Execute <cmd> as a screen command in the specified session.\n");
  }
#line 89
  if (message) {
#line 89
    if (*message) {
      {
#line 91
      printf((char const   */* __restrict  */)"\nError: ");
#line 92
      printf((char const   */* __restrict  */)message, arg);
#line 93
      printf((char const   */* __restrict  */)"\n");
      }
    }
  }
  {
#line 95
  exit(1);
  }
}
}
#line 105
static void HelpProcess(char **ppbuf , int *plen ) ;
#line 106
static void HelpAbort(void) ;
#line 107
static void HelpRedisplayLine(int y , int xs , int xe , int isblank ) ;
#line 108
static void add_key_to_buf(char *buf___0 , int key ) ;
#line 109
static void AddAction(struct action *act , int x , int y ) ;
#line 110
static int helppage(void) ;
#line 126 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
static struct LayFuncs HelpLf  =    {& HelpProcess, & HelpAbort, & HelpRedisplayLine, & DefClearLine, & DefRewrite,
    & DefResize, & DefRestore};
#line 138 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
void display_help(char *class , struct action *ktabp ) 
{ 
  int i ;
  int n ;
  int key ;
  int mcom ;
  int mkey ;
  int l ;
  struct helpdata *helpdata ;
  int used[175] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
#line 147
  if (flayer->l_height < 6) {
    {
#line 149
    LMsg(0, (char *)"Window height too small for help page");
    }
#line 150
    return;
  }
  {
#line 152
  tmp = InitOverlayPage((int )sizeof(*helpdata), & HelpLf, 0);
  }
#line 152
  if (tmp) {
#line 153
    return;
  }
#line 155
  helpdata = (struct helpdata *)flayer->l_data;
#line 156
  helpdata->class = class;
#line 157
  helpdata->ktabp = ktabp;
#line 158
  tmp___0 = 0;
#line 158
  helpdata->command_bindings = tmp___0;
#line 158
  helpdata->num_names = tmp___0;
#line 159
  helpdata->command_search = 0;
#line 160
  n = 0;
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    if (! (n <= 174)) {
#line 160
      goto while_break;
    }
#line 161
    used[n] = 0;
#line 160
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  mcom = 0;
#line 163
  mkey = 0;
#line 164
  key = 0;
  {
#line 164
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 164
    if (! (key < 256)) {
#line 164
      goto while_break___0;
    }
#line 166
    n = (ktabp + key)->nr;
#line 167
    if (n == -1) {
#line 168
      goto __Cont;
    }
#line 169
    if ((unsigned long )(ktabp + key)->args == (unsigned long )(noargs)) {
#line 171
      if (key <= 32) {
#line 171
        tmp___2 = 3;
      } else
#line 171
      if (key == 127) {
#line 171
        tmp___2 = 3;
      } else {
#line 171
        if (key > 127) {
#line 171
          tmp___1 = 5;
        } else {
#line 171
          tmp___1 = 2;
        }
#line 171
        tmp___2 = tmp___1;
      }
#line 171
      used[n] += tmp___2;
    } else {
#line 175
      (helpdata->command_bindings) ++;
    }
    __Cont: /* CIL Label */ 
#line 164
    key ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 177
  i = 0;
#line 177
  n = i;
  {
#line 177
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 177
    if (! (n <= 174)) {
#line 177
      goto while_break___1;
    }
#line 178
    if (used[n]) {
      {
#line 180
      tmp___3 = strlen((char const   *)comms[n].name);
#line 180
      l = (int )tmp___3;
      }
#line 181
      if (l > mcom) {
#line 182
        mcom = l;
      }
#line 183
      if (used[n] > mkey) {
#line 184
        mkey = used[n];
      }
#line 185
      tmp___4 = i;
#line 185
      i ++;
#line 185
      helpdata->nact[tmp___4] = n;
    }
#line 177
    n ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 187
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 187
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 188
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 188
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 189
  helpdata->num_names = i;
#line 191
  if (mkey > 256) {
#line 192
    mkey = 256;
  }
#line 193
  helpdata->numcols = flayer->l_width / ((mcom + mkey) + 1);
#line 194
  if (helpdata->numcols == 0) {
    {
#line 196
    HelpAbort();
#line 197
    LMsg(0, (char *)"Width too small");
    }
#line 198
    return;
  }
#line 200
  helpdata->inter = (flayer->l_width - (mcom + mkey) * helpdata->numcols) / (helpdata->numcols + 1);
#line 201
  if (helpdata->inter <= 0) {
#line 202
    helpdata->inter = 1;
  }
  {
#line 203
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 203
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 204
  helpdata->mcom = mcom;
#line 205
  helpdata->mkey = mkey;
#line 206
  helpdata->numrows = ((helpdata->num_names + helpdata->numcols) - 1) / helpdata->numcols;
  {
#line 207
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 207
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 208
  helpdata->numskip = (flayer->l_height - 5) - (2 + helpdata->numrows);
  {
#line 209
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 209
    if (! (helpdata->numskip < 0)) {
#line 209
      goto while_break___6;
    }
#line 210
    helpdata->numskip += flayer->l_height - 5;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 211
  helpdata->numskip %= flayer->l_height - 5;
  {
#line 212
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 212
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 213
  if (helpdata->numskip > flayer->l_height / 3) {
#line 214
    helpdata->numskip = 1;
  } else
#line 213
  if (helpdata->numskip > helpdata->command_bindings) {
#line 214
    helpdata->numskip = 1;
  }
  {
#line 215
  helpdata->maxrow = ((2 + helpdata->numrows) + helpdata->numskip) + helpdata->command_bindings;
#line 216
  helpdata->grow = 0;
#line 218
  helpdata->numpages = ((helpdata->maxrow + flayer->l_height) - 6) / (flayer->l_height - 5);
#line 219
  flayer->l_x = 0;
#line 220
  flayer->l_y = flayer->l_height - 1;
#line 221
  helppage();
  }
#line 222
  return;
}
}
#line 224 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
static void HelpProcess(char **ppbuf , int *plen ) 
{ 
  int done ;
  int tmp ;

  {
#line 229
  done = 0;
  {
#line 231
  while (1) {
    while_continue: /* CIL Label */ ;
#line 231
    if (! done) {
#line 231
      if (! (*plen > 0)) {
#line 231
        goto while_break;
      }
    } else {
#line 231
      goto while_break;
    }
    {
#line 235
    if ((int )*(*ppbuf) == 32) {
#line 235
      goto case_32;
    }
#line 240
    if ((int )*(*ppbuf) == 10) {
#line 240
      goto case_10;
    }
#line 240
    if ((int )*(*ppbuf) == 13) {
#line 240
      goto case_10;
    }
#line 243
    goto switch_default;
    case_32: /* CIL Label */ 
    {
#line 236
    tmp = helppage();
    }
#line 236
    if (tmp == 0) {
#line 237
      goto switch_break;
    }
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
#line 241
    done = 1;
#line 242
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 244
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 246
    (*ppbuf) ++;
#line 247
    (*plen) --;
  }
  while_break: /* CIL Label */ ;
  }
#line 249
  if (done) {
    {
#line 250
    HelpAbort();
    }
  }
#line 251
  return;
}
}
#line 253 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
static void HelpAbort(void) 
{ 
  struct layer *oldlay ;
  struct canvas *oldcvlist ;
  struct canvas *cv ;

  {
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 256
    oldlay = flayer;
    {
#line 256
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 256
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 256
    flayer = flayer->l_next;
#line 256
    oldcvlist = flayer->l_cvlist;
    {
#line 256
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 256
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 256
    flayer->l_cvlist = oldlay->l_cvlist;
#line 256
    cv = flayer->l_cvlist;
    {
#line 256
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 256
      if (! cv) {
#line 256
        goto while_break___2;
      }
#line 256
      cv->c_layer = flayer;
#line 256
      cv = cv->c_lnext;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 256
    LRefreshAll(flayer, 0);
#line 256
    flayer = oldlay;
#line 256
    cv = flayer->l_cvlist;
    }
    {
#line 256
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 256
      if (! cv) {
#line 256
        goto while_break___3;
      }
#line 256
      cv->c_layer = flayer;
#line 256
      cv = cv->c_lnext;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 256
    (flayer->l_next)->l_cvlist = oldcvlist;
#line 256
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 257
  ExitOverlayPage();
  }
#line 258
  return;
}
}
#line 261 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
static int helppage(void) 
{ 
  struct helpdata *helpdata ;
  int col ;
  int crow ;
  int n ;
  int key ;
  int x ;
  char buf___0[256] ;
  char Esc_buf[5] ;
  char cbuf[256] ;
  struct action *ktabp ;
  size_t tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
#line 269
  helpdata = (struct helpdata *)flayer->l_data;
#line 271
  ktabp = helpdata->ktabp;
#line 272
  if (helpdata->grow >= helpdata->maxrow) {
#line 273
    return (-1);
  }
  {
#line 274
  helpdata->refgrow = helpdata->grow;
#line 275
  helpdata->refcommand_search = helpdata->command_search;
#line 278
  LClearAll(flayer, 0);
#line 280
  sprintf((char */* __restrict  */)(cbuf), (char const   */* __restrict  */)"Screen key bindings, page %d of %d.",
          helpdata->grow / (flayer->l_height - 5) + 1, helpdata->numpages);
#line 281
  centerline(cbuf, 0);
#line 282
  crow = 2;
#line 284
  Esc_buf[0] = (char )'\000';
#line 285
  buf___0[0] = (char )'\000';
  }
#line 287
  if (flayer->l_cvlist) {
#line 287
    if ((flayer->l_cvlist)->c_display) {
      {
#line 289
      add_key_to_buf(buf___0, (((flayer->l_cvlist)->c_display)->d_user)->u_MetaEsc);
#line 290
      add_key_to_buf(Esc_buf, (((flayer->l_cvlist)->c_display)->d_user)->u_Esc);
      }
    } else {
      {
#line 294
      strcpy((char */* __restrict  */)(Esc_buf), (char const   */* __restrict  */)"??");
#line 295
      strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"??");
      }
    }
  } else {
    {
#line 294
    strcpy((char */* __restrict  */)(Esc_buf), (char const   */* __restrict  */)"??");
#line 295
    strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"??");
    }
  }
  {
#line 298
  while (1) {
    while_continue: /* CIL Label */ ;
#line 298
    if (! (crow < flayer->l_height - 3)) {
#line 298
      goto while_break;
    }
#line 300
    if (helpdata->grow < 1) {
#line 302
      if ((unsigned long )ktabp == (unsigned long )(ktab)) {
        {
#line 303
        sprintf((char */* __restrict  */)(cbuf), (char const   */* __restrict  */)"Command key:  %s   Literal %s:  %s",
                Esc_buf, Esc_buf, buf___0);
        }
      } else {
        {
#line 305
        sprintf((char */* __restrict  */)(cbuf), (char const   */* __restrict  */)"Command class: \'%.80s\'",
                helpdata->class);
        }
      }
      {
#line 306
      centerline(cbuf, crow);
#line 307
      (helpdata->grow) ++;
      }
    } else
#line 309
    if (helpdata->grow >= 2) {
#line 309
      if (helpdata->grow - 2 < helpdata->numrows) {
#line 311
        x = 0;
#line 312
        col = 0;
        {
#line 312
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 312
          if (col < helpdata->numcols) {
#line 312
            n = helpdata->numrows * col + (helpdata->grow - 2);
#line 312
            if (! (n < helpdata->num_names)) {
#line 312
              goto while_break___0;
            }
          } else {
#line 312
            goto while_break___0;
          }
#line 314
          x += helpdata->inter - ! col;
#line 315
          n = helpdata->nact[n];
#line 316
          buf___0[0] = (char )'\000';
#line 317
          key = 0;
          {
#line 317
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 317
            if (! (key < 256)) {
#line 317
              goto while_break___1;
            }
#line 318
            if ((ktabp + key)->nr == n) {
#line 318
              if ((unsigned long )(ktabp + key)->args == (unsigned long )(noargs)) {
                {
#line 318
                tmp = strlen((char const   *)(buf___0));
                }
#line 318
                if ((unsigned long )tmp < sizeof(buf___0) - 7UL) {
                  {
#line 320
                  strcat((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)" ");
#line 321
                  add_key_to_buf(buf___0, key);
                  }
                }
              }
            }
#line 317
            key ++;
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 323
          PadStr(comms[n].name, helpdata->mcom, x, crow);
#line 324
          x += helpdata->mcom;
#line 325
          PadStr(buf___0, helpdata->mkey, x, crow);
#line 326
          x += helpdata->mkey;
#line 312
          col ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 328
        (helpdata->grow) ++;
      } else {
#line 309
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 330
    if ((helpdata->grow - 2) - helpdata->numrows >= helpdata->numskip) {
#line 330
      if (((helpdata->grow - 2) - helpdata->numrows) - helpdata->numskip < helpdata->command_bindings) {
        {
#line 333
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 333
          n = (ktabp + helpdata->command_search)->nr;
#line 333
          if (! (n == -1)) {
#line 333
            if (! ((unsigned long )(ktabp + helpdata->command_search)->args == (unsigned long )(noargs))) {
#line 333
              goto while_break___2;
            }
          }
#line 336
          (helpdata->command_search) ++;
#line 336
          if (helpdata->command_search >= 256) {
#line 337
            return (-1);
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 339
        buf___0[0] = (char )'\000';
#line 340
        add_key_to_buf(buf___0, helpdata->command_search);
#line 341
        PadStr(buf___0, 4, 0, crow);
#line 342
        tmp___0 = helpdata->command_search;
#line 342
        (helpdata->command_search) ++;
#line 342
        AddAction(ktabp + tmp___0, 4, crow);
#line 343
        (helpdata->grow) ++;
        }
      } else {
#line 346
        (helpdata->grow) ++;
      }
    } else {
#line 346
      (helpdata->grow) ++;
    }
#line 298
    crow ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 348
  if (helpdata->grow < helpdata->maxrow) {
#line 348
    tmp___1 = "for next page;";
  } else {
#line 348
    tmp___1 = "or";
  }
  {
#line 348
  sprintf((char */* __restrict  */)(cbuf), (char const   */* __restrict  */)"[Press Space %s Return to end.]",
          tmp___1);
#line 350
  centerline(cbuf, flayer->l_height - 2);
#line 351
  LGotoPos(flayer, flayer->l_x, flayer->l_y);
  }
#line 352
  return (0);
}
}
#line 355 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
static void AddAction(struct action *act , int x , int y ) 
{ 
  char buf___0[256] ;
  int del ;
  int l ;
  char *bp ;
  char *cp ;
  char **pp ;
  int *lp ;
  int ll ;
  int fr ;
  struct mchar mchar_dol ;
  size_t tmp ;
  int tmp___0 ;
  struct mchar *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  struct mchar *tmp___14 ;

  {
#line 367
  mchar_dol = mchar_blank;
#line 368
  mchar_dol.image = (unsigned char )'$';
#line 370
  fr = (flayer->l_width - 1) - x;
#line 371
  if (fr <= 0) {
#line 372
    return;
  }
  {
#line 373
  tmp = strlen((char const   *)comms[act->nr].name);
#line 373
  l = (int )tmp;
  }
#line 375
  if (l + 1 > fr) {
#line 376
    l = fr - 1;
  }
  {
#line 377
  PadStr(comms[act->nr].name, l, x, y);
#line 378
  x += l;
#line 379
  fr -= l + 1;
#line 380
  tmp___0 = x;
#line 380
  x ++;
  }
#line 380
  if (fr) {
#line 380
    tmp___1 = & mchar_blank;
  } else {
#line 380
    tmp___1 = & mchar_dol;
  }
  {
#line 380
  LPutChar(flayer, tmp___1, tmp___0, y);
#line 382
  pp = act->args;
#line 383
  lp = act->argl;
  }
  {
#line 384
  while (1) {
    while_continue: /* CIL Label */ ;
#line 384
    if (pp) {
#line 384
      cp = *pp;
#line 384
      if (! ((unsigned long )cp != (unsigned long )((void *)0))) {
#line 384
        goto while_break;
      }
    } else {
#line 384
      goto while_break;
    }
#line 386
    del = 0;
#line 387
    bp = buf___0;
#line 388
    tmp___2 = lp;
#line 388
    lp ++;
#line 388
    ll = *tmp___2;
#line 389
    if (! ll) {
#line 389
      goto _L;
    } else {
      {
#line 389
      tmp___6 = index((char const   *)cp, ' ');
      }
#line 389
      if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
        _L: /* CIL Label */ 
        {
#line 391
        tmp___5 = index((char const   *)cp, '\'');
        }
#line 391
        if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 392
          tmp___3 = bp;
#line 392
          bp ++;
#line 392
          del = '\"';
#line 392
          *tmp___3 = (char )del;
        } else {
#line 394
          tmp___4 = bp;
#line 394
          bp ++;
#line 394
          del = '\'';
#line 394
          *tmp___4 = (char )del;
        }
      }
    }
    {
#line 396
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 396
      tmp___9 = ll;
#line 396
      ll --;
#line 396
      if (tmp___9) {
#line 396
        if (! ((unsigned long )bp < (unsigned long )(buf___0 + 250))) {
#line 396
          goto while_break___0;
        }
      } else {
#line 396
        goto while_break___0;
      }
      {
#line 397
      tmp___7 = cp;
#line 397
      cp ++;
#line 397
      tmp___8 = AddXChar(bp, (int )*((unsigned char *)tmp___7));
#line 397
      bp += tmp___8;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 398
    if (del) {
#line 399
      tmp___10 = bp;
#line 399
      bp ++;
#line 399
      *tmp___10 = (char )del;
    }
#line 400
    *bp = (char)0;
#line 401
    fr = (int )((long )fr - ((bp - buf___0) + 1L));
#line 401
    if (fr < 0) {
#line 403
      fr = (int )((long )fr + (bp - buf___0));
#line 404
      if (fr > 0) {
        {
#line 405
        PadStr(buf___0, fr, x, y);
        }
      }
#line 406
      if (fr == 0) {
        {
#line 407
        LPutChar(flayer, & mchar_dol, x, y);
        }
      }
#line 408
      return;
    }
    {
#line 410
    tmp___11 = strlen((char const   *)(buf___0));
#line 410
    PadStr(buf___0, (int )tmp___11, x, y);
#line 411
    tmp___12 = strlen((char const   *)(buf___0));
#line 411
    x = (int )((size_t )x + tmp___12);
#line 412
    pp ++;
    }
#line 413
    if (*pp) {
#line 414
      tmp___13 = x;
#line 414
      x ++;
#line 414
      if (fr) {
#line 414
        tmp___14 = & mchar_blank;
      } else {
#line 414
        tmp___14 = & mchar_dol;
      }
      {
#line 414
      LPutChar(flayer, tmp___14, tmp___13, y);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 416
  return;
}
}
#line 418 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
static void add_key_to_buf(char *buf___0 , int key ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 423
  tmp = strlen((char const   *)buf___0);
#line 423
  buf___0 += tmp;
  }
#line 424
  if (key < 0) {
    {
#line 425
    strcpy((char */* __restrict  */)buf___0, (char const   */* __restrict  */)"unset");
    }
  } else
#line 426
  if (key == 32) {
    {
#line 427
    strcpy((char */* __restrict  */)buf___0, (char const   */* __restrict  */)"sp");
    }
  } else {
    {
#line 429
    tmp___0 = AddXChar(buf___0, key);
#line 429
    *(buf___0 + tmp___0) = (char)0;
    }
  }
#line 430
  return;
}
}
#line 433 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
static void HelpRedisplayLine(int y , int xs , int xe , int isblank ) 
{ 
  struct helpdata *helpdata ;

  {
#line 437
  if (y < 0) {
    {
#line 441
    helpdata = (struct helpdata *)flayer->l_data;
#line 442
    helpdata->grow = helpdata->refgrow;
#line 443
    helpdata->command_search = helpdata->refcommand_search;
#line 444
    helppage();
    }
#line 445
    return;
  }
#line 447
  if (y != 0) {
#line 447
    if (y != flayer->l_height - 1) {
#line 448
      return;
    }
  }
#line 449
  if (! isblank) {
    {
#line 450
    LClearArea(flayer, xs, y, xe, y, 0, 0);
    }
  }
#line 451
  return;
}
}
#line 460
static void CopyrightProcess(char **ppbuf , int *plen ) ;
#line 461
static void CopyrightRedisplayLine(int y , int xs , int xe , int isblank ) ;
#line 462
static void CopyrightAbort(void) ;
#line 463
static void copypage(void) ;
#line 471 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
static struct LayFuncs CopyrightLf  =    {& CopyrightProcess, & CopyrightAbort, & CopyrightRedisplayLine, & DefClearLine,
    & DefRewrite, & DefResize, & DefRestore};
#line 482 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
static char const   cpmsg[895]  = 
#line 482
  {      (char const   )'\n',      (char const   )'S',      (char const   )'c',      (char const   )'r', 
        (char const   )'e',      (char const   )'e',      (char const   )'n',      (char const   )' ', 
        (char const   )'v',      (char const   )'e',      (char const   )'r',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )' ', 
        (char const   )'%',      (char const   )'v',      (char const   )'\n',      (char const   )'\n', 
        (char const   )'C',      (char const   )'o',      (char const   )'p',      (char const   )'y', 
        (char const   )'r',      (char const   )'i',      (char const   )'g',      (char const   )'h', 
        (char const   )'t',      (char const   )' ',      (char const   )'(',      (char const   )'c', 
        (char const   )')',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )'9',      (char const   )'3',      (char const   )'-',      (char const   )'2', 
        (char const   )'0',      (char const   )'0',      (char const   )'2',      (char const   )' ', 
        (char const   )'J',      (char const   )'u',      (char const   )'e',      (char const   )'r', 
        (char const   )'g',      (char const   )'e',      (char const   )'n',      (char const   )' ', 
        (char const   )'W',      (char const   )'e',      (char const   )'i',      (char const   )'g', 
        (char const   )'e',      (char const   )'r',      (char const   )'t',      (char const   )',', 
        (char const   )' ',      (char const   )'M',      (char const   )'i',      (char const   )'c', 
        (char const   )'h',      (char const   )'a',      (char const   )'e',      (char const   )'l', 
        (char const   )' ',      (char const   )'S',      (char const   )'c',      (char const   )'h', 
        (char const   )'r',      (char const   )'o',      (char const   )'e',      (char const   )'d', 
        (char const   )'e',      (char const   )'r',      (char const   )'\n',      (char const   )'C', 
        (char const   )'o',      (char const   )'p',      (char const   )'y',      (char const   )'r', 
        (char const   )'i',      (char const   )'g',      (char const   )'h',      (char const   )'t', 
        (char const   )' ',      (char const   )'(',      (char const   )'c',      (char const   )')', 
        (char const   )' ',      (char const   )'1',      (char const   )'9',      (char const   )'8', 
        (char const   )'7',      (char const   )' ',      (char const   )'O',      (char const   )'l', 
        (char const   )'i',      (char const   )'v',      (char const   )'e',      (char const   )'r', 
        (char const   )' ',      (char const   )'L',      (char const   )'a',      (char const   )'u', 
        (char const   )'m',      (char const   )'a',      (char const   )'n',      (char const   )'n', 
        (char const   )'\n',      (char const   )'\n',      (char const   )'T',      (char const   )'h', 
        (char const   )'i',      (char const   )'s',      (char const   )' ',      (char const   )'p', 
        (char const   )'r',      (char const   )'o',      (char const   )'g',      (char const   )'r', 
        (char const   )'a',      (char const   )'m',      (char const   )' ',      (char const   )'i', 
        (char const   )'s',      (char const   )' ',      (char const   )'f',      (char const   )'r', 
        (char const   )'e',      (char const   )'e',      (char const   )' ',      (char const   )'s', 
        (char const   )'o',      (char const   )'f',      (char const   )'t',      (char const   )'w', 
        (char const   )'a',      (char const   )'r',      (char const   )'e',      (char const   )';', 
        (char const   )' ',      (char const   )'y',      (char const   )'o',      (char const   )'u', 
        (char const   )' ',      (char const   )'c',      (char const   )'a',      (char const   )'n', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'d', 
        (char const   )'i',      (char const   )'s',      (char const   )'t',      (char const   )'r', 
        (char const   )'i',      (char const   )'b',      (char const   )'u',      (char const   )'t', 
        (char const   )'e',      (char const   )' ',      (char const   )'i',      (char const   )'t', 
        (char const   )' ',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )'/',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'m',      (char const   )'o',      (char const   )'d',      (char const   )'i', 
        (char const   )'f',      (char const   )'y',      (char const   )' ',      (char const   )'i', 
        (char const   )'t',      (char const   )' ',      (char const   )'u',      (char const   )'n', 
        (char const   )'d',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'t',      (char const   )'h',      (char const   )'e',      (char const   )' ', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )'m', 
        (char const   )'s',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'e', 
        (char const   )' ',      (char const   )'G',      (char const   )'N',      (char const   )'U', 
        (char const   )' ',      (char const   )'G',      (char const   )'e',      (char const   )'n', 
        (char const   )'e',      (char const   )'r',      (char const   )'a',      (char const   )'l', 
        (char const   )' ',      (char const   )'P',      (char const   )'u',      (char const   )'b', 
        (char const   )'l',      (char const   )'i',      (char const   )'c',      (char const   )' ', 
        (char const   )'L',      (char const   )'i',      (char const   )'c',      (char const   )'e', 
        (char const   )'n',      (char const   )'s',      (char const   )'e',      (char const   )' ', 
        (char const   )'a',      (char const   )'s',      (char const   )' ',      (char const   )'p', 
        (char const   )'u',      (char const   )'b',      (char const   )'l',      (char const   )'i', 
        (char const   )'s',      (char const   )'h',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'b',      (char const   )'y',      (char const   )' ', 
        (char const   )'t',      (char const   )'h',      (char const   )'e',      (char const   )' ', 
        (char const   )'F',      (char const   )'r',      (char const   )'e',      (char const   )'e', 
        (char const   )' ',      (char const   )'S',      (char const   )'o',      (char const   )'f', 
        (char const   )'t',      (char const   )'w',      (char const   )'a',      (char const   )'r', 
        (char const   )'e',      (char const   )' ',      (char const   )'F',      (char const   )'o', 
        (char const   )'u',      (char const   )'n',      (char const   )'d',      (char const   )'a', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )';',      (char const   )' ',      (char const   )'e',      (char const   )'i', 
        (char const   )'t',      (char const   )'h',      (char const   )'e',      (char const   )'r', 
        (char const   )' ',      (char const   )'v',      (char const   )'e',      (char const   )'r', 
        (char const   )'s',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )' ',      (char const   )'2',      (char const   )',',      (char const   )' ', 
        (char const   )'o',      (char const   )'r',      (char const   )' ',      (char const   )'(', 
        (char const   )'a',      (char const   )'t',      (char const   )' ',      (char const   )'y', 
        (char const   )'o',      (char const   )'u',      (char const   )'r',      (char const   )' ', 
        (char const   )'o',      (char const   )'p',      (char const   )'t',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )')',      (char const   )' ', 
        (char const   )'a',      (char const   )'n',      (char const   )'y',      (char const   )' ', 
        (char const   )'l',      (char const   )'a',      (char const   )'t',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'v',      (char const   )'e', 
        (char const   )'r',      (char const   )'s',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )'.',      (char const   )'\n',      (char const   )'\n', 
        (char const   )'T',      (char const   )'h',      (char const   )'i',      (char const   )'s', 
        (char const   )' ',      (char const   )'p',      (char const   )'r',      (char const   )'o', 
        (char const   )'g',      (char const   )'r',      (char const   )'a',      (char const   )'m', 
        (char const   )' ',      (char const   )'i',      (char const   )'s',      (char const   )' ', 
        (char const   )'d',      (char const   )'i',      (char const   )'s',      (char const   )'t', 
        (char const   )'r',      (char const   )'i',      (char const   )'b',      (char const   )'u', 
        (char const   )'t',      (char const   )'e',      (char const   )'d',      (char const   )' ', 
        (char const   )'i',      (char const   )'n',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'h', 
        (char const   )'o',      (char const   )'p',      (char const   )'e',      (char const   )' ', 
        (char const   )'t',      (char const   )'h',      (char const   )'a',      (char const   )'t', 
        (char const   )' ',      (char const   )'i',      (char const   )'t',      (char const   )' ', 
        (char const   )'w',      (char const   )'i',      (char const   )'l',      (char const   )'l', 
        (char const   )' ',      (char const   )'b',      (char const   )'e',      (char const   )' ', 
        (char const   )'u',      (char const   )'s',      (char const   )'e',      (char const   )'f', 
        (char const   )'u',      (char const   )'l',      (char const   )',',      (char const   )' ', 
        (char const   )'b',      (char const   )'u',      (char const   )'t',      (char const   )' ', 
        (char const   )'W',      (char const   )'I',      (char const   )'T',      (char const   )'H', 
        (char const   )'O',      (char const   )'U',      (char const   )'T',      (char const   )' ', 
        (char const   )'A',      (char const   )'N',      (char const   )'Y',      (char const   )' ', 
        (char const   )'W',      (char const   )'A',      (char const   )'R',      (char const   )'R', 
        (char const   )'A',      (char const   )'N',      (char const   )'T',      (char const   )'Y', 
        (char const   )';',      (char const   )' ',      (char const   )'w',      (char const   )'i', 
        (char const   )'t',      (char const   )'h',      (char const   )'o',      (char const   )'u', 
        (char const   )'t',      (char const   )' ',      (char const   )'e',      (char const   )'v', 
        (char const   )'e',      (char const   )'n',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'i', 
        (char const   )'m',      (char const   )'p',      (char const   )'l',      (char const   )'i', 
        (char const   )'e',      (char const   )'d',      (char const   )' ',      (char const   )'w', 
        (char const   )'a',      (char const   )'r',      (char const   )'r',      (char const   )'a', 
        (char const   )'n',      (char const   )'t',      (char const   )'y',      (char const   )' ', 
        (char const   )'o',      (char const   )'f',      (char const   )' ',      (char const   )'M', 
        (char const   )'E',      (char const   )'R',      (char const   )'C',      (char const   )'H', 
        (char const   )'A',      (char const   )'N',      (char const   )'T',      (char const   )'A', 
        (char const   )'B',      (char const   )'I',      (char const   )'L',      (char const   )'I', 
        (char const   )'T',      (char const   )'Y',      (char const   )' ',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'F',      (char const   )'I', 
        (char const   )'T',      (char const   )'N',      (char const   )'E',      (char const   )'S', 
        (char const   )'S',      (char const   )' ',      (char const   )'F',      (char const   )'O', 
        (char const   )'R',      (char const   )' ',      (char const   )'A',      (char const   )' ', 
        (char const   )'P',      (char const   )'A',      (char const   )'R',      (char const   )'T', 
        (char const   )'I',      (char const   )'C',      (char const   )'U',      (char const   )'L', 
        (char const   )'A',      (char const   )'R',      (char const   )' ',      (char const   )'P', 
        (char const   )'U',      (char const   )'R',      (char const   )'P',      (char const   )'O', 
        (char const   )'S',      (char const   )'E',      (char const   )'.',      (char const   )' ', 
        (char const   )'S',      (char const   )'e',      (char const   )'e',      (char const   )' ', 
        (char const   )'t',      (char const   )'h',      (char const   )'e',      (char const   )' ', 
        (char const   )'G',      (char const   )'N',      (char const   )'U',      (char const   )' ', 
        (char const   )'G',      (char const   )'e',      (char const   )'n',      (char const   )'e', 
        (char const   )'r',      (char const   )'a',      (char const   )'l',      (char const   )' ', 
        (char const   )'P',      (char const   )'u',      (char const   )'b',      (char const   )'l', 
        (char const   )'i',      (char const   )'c',      (char const   )' ',      (char const   )'L', 
        (char const   )'i',      (char const   )'c',      (char const   )'e',      (char const   )'n', 
        (char const   )'s',      (char const   )'e',      (char const   )' ',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )' ',      (char const   )'m', 
        (char const   )'o',      (char const   )'r',      (char const   )'e',      (char const   )' ', 
        (char const   )'d',      (char const   )'e',      (char const   )'t',      (char const   )'a', 
        (char const   )'i',      (char const   )'l',      (char const   )'s',      (char const   )'.', 
        (char const   )'\n',      (char const   )'\n',      (char const   )'Y',      (char const   )'o', 
        (char const   )'u',      (char const   )' ',      (char const   )'s',      (char const   )'h', 
        (char const   )'o',      (char const   )'u',      (char const   )'l',      (char const   )'d', 
        (char const   )' ',      (char const   )'h',      (char const   )'a',      (char const   )'v', 
        (char const   )'e',      (char const   )' ',      (char const   )'r',      (char const   )'e', 
        (char const   )'c',      (char const   )'e',      (char const   )'i',      (char const   )'v', 
        (char const   )'e',      (char const   )'d',      (char const   )' ',      (char const   )'a', 
        (char const   )' ',      (char const   )'c',      (char const   )'o',      (char const   )'p', 
        (char const   )'y',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'e', 
        (char const   )' ',      (char const   )'G',      (char const   )'N',      (char const   )'U', 
        (char const   )' ',      (char const   )'G',      (char const   )'e',      (char const   )'n', 
        (char const   )'e',      (char const   )'r',      (char const   )'a',      (char const   )'l', 
        (char const   )' ',      (char const   )'P',      (char const   )'u',      (char const   )'b', 
        (char const   )'l',      (char const   )'i',      (char const   )'c',      (char const   )' ', 
        (char const   )'L',      (char const   )'i',      (char const   )'c',      (char const   )'e', 
        (char const   )'n',      (char const   )'s',      (char const   )'e',      (char const   )' ', 
        (char const   )'a',      (char const   )'l',      (char const   )'o',      (char const   )'n', 
        (char const   )'g',      (char const   )' ',      (char const   )'w',      (char const   )'i', 
        (char const   )'t',      (char const   )'h',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'i',      (char const   )'s',      (char const   )' ', 
        (char const   )'p',      (char const   )'r',      (char const   )'o',      (char const   )'g', 
        (char const   )'r',      (char const   )'a',      (char const   )'m',      (char const   )' ', 
        (char const   )'(',      (char const   )'s',      (char const   )'e',      (char const   )'e', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'e', 
        (char const   )' ',      (char const   )'f',      (char const   )'i',      (char const   )'l', 
        (char const   )'e',      (char const   )' ',      (char const   )'C',      (char const   )'O', 
        (char const   )'P',      (char const   )'Y',      (char const   )'I',      (char const   )'N', 
        (char const   )'G',      (char const   )')',      (char const   )';',      (char const   )' ', 
        (char const   )'i',      (char const   )'f',      (char const   )' ',      (char const   )'n', 
        (char const   )'o',      (char const   )'t',      (char const   )',',      (char const   )' ', 
        (char const   )'w',      (char const   )'r',      (char const   )'i',      (char const   )'t', 
        (char const   )'e',      (char const   )' ',      (char const   )'t',      (char const   )'o', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'e', 
        (char const   )' ',      (char const   )'F',      (char const   )'r',      (char const   )'e', 
        (char const   )'e',      (char const   )' ',      (char const   )'S',      (char const   )'o', 
        (char const   )'f',      (char const   )'t',      (char const   )'w',      (char const   )'a', 
        (char const   )'r',      (char const   )'e',      (char const   )' ',      (char const   )'F', 
        (char const   )'o',      (char const   )'u',      (char const   )'n',      (char const   )'d', 
        (char const   )'a',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )',',      (char const   )' ',      (char const   )'I', 
        (char const   )'n',      (char const   )'c',      (char const   )'.',      (char const   )',', 
        (char const   )' ',      (char const   )'5',      (char const   )'9',      (char const   )' ', 
        (char const   )'T',      (char const   )'e',      (char const   )'m',      (char const   )'p', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'P', 
        (char const   )'l',      (char const   )'a',      (char const   )'c',      (char const   )'e', 
        (char const   )' ',      (char const   )'-',      (char const   )' ',      (char const   )'S', 
        (char const   )'u',      (char const   )'i',      (char const   )'t',      (char const   )'e', 
        (char const   )' ',      (char const   )'3',      (char const   )'3',      (char const   )'0', 
        (char const   )',',      (char const   )' ',      (char const   )'B',      (char const   )'o', 
        (char const   )'s',      (char const   )'t',      (char const   )'o',      (char const   )'n', 
        (char const   )',',      (char const   )' ',      (char const   )'M',      (char const   )'A', 
        (char const   )' ',      (char const   )' ',      (char const   )'0',      (char const   )'2', 
        (char const   )'1',      (char const   )'1',      (char const   )'1',      (char const   )'-', 
        (char const   )'1',      (char const   )'3',      (char const   )'0',      (char const   )'7', 
        (char const   )',',      (char const   )' ',      (char const   )'U',      (char const   )'S', 
        (char const   )'A',      (char const   )'.',      (char const   )'\n',      (char const   )'\n', 
        (char const   )'S',      (char const   )'e',      (char const   )'n',      (char const   )'d', 
        (char const   )' ',      (char const   )'b',      (char const   )'u',      (char const   )'g', 
        (char const   )'r',      (char const   )'e',      (char const   )'p',      (char const   )'o', 
        (char const   )'r',      (char const   )'t',      (char const   )'s',      (char const   )',', 
        (char const   )' ',      (char const   )'f',      (char const   )'i',      (char const   )'x', 
        (char const   )'e',      (char const   )'s',      (char const   )',',      (char const   )' ', 
        (char const   )'e',      (char const   )'n',      (char const   )'h',      (char const   )'a', 
        (char const   )'n',      (char const   )'c',      (char const   )'e',      (char const   )'m', 
        (char const   )'e',      (char const   )'n',      (char const   )'t',      (char const   )'s', 
        (char const   )',',      (char const   )' ',      (char const   )'t',      (char const   )'-', 
        (char const   )'s',      (char const   )'h',      (char const   )'i',      (char const   )'r', 
        (char const   )'t',      (char const   )'s',      (char const   )',',      (char const   )' ', 
        (char const   )'m',      (char const   )'o',      (char const   )'n',      (char const   )'e', 
        (char const   )'y',      (char const   )',',      (char const   )' ',      (char const   )'b', 
        (char const   )'e',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'&',      (char const   )' ',      (char const   )'p',      (char const   )'i', 
        (char const   )'z',      (char const   )'z',      (char const   )'a',      (char const   )' ', 
        (char const   )'t',      (char const   )'o',      (char const   )' ',      (char const   )'s', 
        (char const   )'c',      (char const   )'r',      (char const   )'e',      (char const   )'e', 
        (char const   )'n',      (char const   )'@',      (char const   )'u',      (char const   )'n', 
        (char const   )'i',      (char const   )'-',      (char const   )'e',      (char const   )'r', 
        (char const   )'l',      (char const   )'a',      (char const   )'n',      (char const   )'g', 
        (char const   )'e',      (char const   )'n',      (char const   )'.',      (char const   )'d', 
        (char const   )'e',      (char const   )'\n',      (char const   )'\000'};
#line 508 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
static void CopyrightProcess(char **ppbuf , int *plen ) 
{ 
  int done ;
  struct copydata *copydata ;

  {
#line 513
  done = 0;
#line 516
  copydata = (struct copydata *)flayer->l_data;
  {
#line 517
  while (1) {
    while_continue: /* CIL Label */ ;
#line 517
    if (! done) {
#line 517
      if (! (*plen > 0)) {
#line 517
        goto while_break;
      }
    } else {
#line 517
      goto while_break;
    }
    {
#line 521
    if ((int )*(*ppbuf) == 32) {
#line 521
      goto case_32;
    }
#line 529
    if ((int )*(*ppbuf) == 10) {
#line 529
      goto case_10;
    }
#line 529
    if ((int )*(*ppbuf) == 13) {
#line 529
      goto case_10;
    }
#line 533
    goto switch_default;
    case_32: /* CIL Label */ 
#line 522
    if (*(copydata->cps)) {
      {
#line 524
      copypage();
      }
#line 525
      goto switch_break;
    }
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
    {
#line 530
    CopyrightAbort();
#line 531
    done = 1;
    }
#line 532
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 534
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 536
    (*ppbuf) ++;
#line 537
    (*plen) --;
  }
  while_break: /* CIL Label */ ;
  }
#line 539
  return;
}
}
#line 541 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
static void CopyrightAbort(void) 
{ 
  struct layer *oldlay ;
  struct canvas *oldcvlist ;
  struct canvas *cv ;

  {
  {
#line 544
  while (1) {
    while_continue: /* CIL Label */ ;
#line 544
    oldlay = flayer;
    {
#line 544
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 544
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 544
    flayer = flayer->l_next;
#line 544
    oldcvlist = flayer->l_cvlist;
    {
#line 544
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 544
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 544
    flayer->l_cvlist = oldlay->l_cvlist;
#line 544
    cv = flayer->l_cvlist;
    {
#line 544
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 544
      if (! cv) {
#line 544
        goto while_break___2;
      }
#line 544
      cv->c_layer = flayer;
#line 544
      cv = cv->c_lnext;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 544
    LRefreshAll(flayer, 0);
#line 544
    flayer = oldlay;
#line 544
    cv = flayer->l_cvlist;
    }
    {
#line 544
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 544
      if (! cv) {
#line 544
        goto while_break___3;
      }
#line 544
      cv->c_layer = flayer;
#line 544
      cv = cv->c_lnext;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 544
    (flayer->l_next)->l_cvlist = oldcvlist;
#line 544
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 545
  ExitOverlayPage();
  }
#line 546
  return;
}
}
#line 548 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
void display_copyright(void) 
{ 
  struct copydata *copydata ;
  int tmp ;

  {
#line 553
  if (flayer->l_width < 10) {
    {
#line 555
    LMsg(0, (char *)"Window size too small for copyright page");
    }
#line 556
    return;
  } else
#line 553
  if (flayer->l_height < 5) {
    {
#line 555
    LMsg(0, (char *)"Window size too small for copyright page");
    }
#line 556
    return;
  }
  {
#line 558
  tmp = InitOverlayPage((int )sizeof(*copydata), & CopyrightLf, 0);
  }
#line 558
  if (tmp) {
#line 559
    return;
  }
  {
#line 560
  copydata = (struct copydata *)flayer->l_data;
#line 561
  copydata->cps = (char *)(cpmsg);
#line 562
  copydata->savedcps = (char *)0;
#line 563
  flayer->l_x = 0;
#line 564
  flayer->l_y = flayer->l_height - 1;
#line 565
  copypage();
  }
#line 566
  return;
}
}
#line 568 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
static void copypage(void) 
{ 
  register char *cps ;
  char *ws ;
  int x ;
  int y ;
  int l ;
  char cbuf[80] ;
  struct copydata *copydata ;
  int tmp ;
  char const   *tmp___0 ;

  {
  {
#line 577
  while (1) {
    while_continue: /* CIL Label */ ;
#line 577
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 578
  copydata = (struct copydata *)flayer->l_data;
#line 580
  LClearAll(flayer, 0);
#line 581
  y = 0;
#line 581
  x = y;
#line 582
  cps = copydata->cps;
#line 583
  copydata->refcps = cps;
#line 584
  copydata->refsavedcps = copydata->savedcps;
  }
  {
#line 585
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 585
    if (*cps) {
#line 585
      if (! (y < flayer->l_height - 3)) {
#line 585
        goto while_break___0;
      }
    } else {
#line 585
      goto while_break___0;
    }
#line 587
    ws = cps;
    {
#line 588
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 588
      if (! ((int )*cps == 32)) {
#line 588
        goto while_break___1;
      }
#line 589
      cps ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 590
    tmp = strncmp((char const   *)cps, "%v", (size_t )2);
    }
#line 590
    if (tmp == 0) {
#line 592
      copydata->savedcps = cps + 2;
#line 593
      cps = version;
#line 594
      goto while_continue___0;
    }
    {
#line 596
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 596
      if (*cps) {
#line 596
        if ((int )*cps != 32) {
#line 596
          if (! ((int )*cps != 10)) {
#line 596
            goto while_break___2;
          }
        } else {
#line 596
          goto while_break___2;
        }
      } else {
#line 596
        goto while_break___2;
      }
#line 597
      cps ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 598
    l = (int )(cps - ws);
#line 599
    cps = ws;
#line 600
    if (l > flayer->l_width - 1) {
#line 601
      l = flayer->l_width - 1;
    }
#line 602
    if (x) {
#line 602
      if (x + l >= flayer->l_width - 2) {
#line 604
        x = 0;
#line 605
        y ++;
#line 606
        goto while_continue___0;
      }
    }
#line 608
    if (x) {
      {
#line 610
      LPutChar(flayer, & mchar_blank, x, y);
#line 611
      x ++;
      }
    }
#line 613
    if (l) {
      {
#line 614
      LPutStr(flayer, ws, l, & mchar_blank, x, y);
      }
    }
#line 615
    x += l;
#line 616
    cps += l;
#line 617
    if ((int )*cps == 0) {
#line 617
      if (copydata->savedcps) {
#line 619
        cps = copydata->savedcps;
#line 620
        copydata->savedcps = (char *)0;
      }
    }
#line 622
    if ((int )*cps == 10) {
#line 624
      x = 0;
#line 625
      y ++;
    }
#line 627
    if ((int )*cps == 32) {
#line 628
      cps ++;
    } else
#line 627
    if ((int )*cps == 10) {
#line 628
      cps ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 630
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 630
    if (! ((int )*cps == 10)) {
#line 630
      goto while_break___3;
    }
#line 631
    cps ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 632
  if (*cps) {
#line 632
    tmp___0 = "for next page;";
  } else {
#line 632
    tmp___0 = "or";
  }
  {
#line 632
  sprintf((char */* __restrict  */)(cbuf), (char const   */* __restrict  */)"[Press Space %s Return to end.]",
          tmp___0);
#line 634
  centerline(cbuf, flayer->l_height - 2);
#line 635
  copydata->cps = cps;
#line 636
  LGotoPos(flayer, flayer->l_x, flayer->l_y);
  }
#line 637
  return;
}
}
#line 639 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
static void CopyrightRedisplayLine(int y , int xs , int xe , int isblank ) 
{ 
  struct copydata *copydata ;

  {
  {
#line 643
  while (1) {
    while_continue: /* CIL Label */ ;
#line 643
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 644
  if (y < 0) {
    {
#line 648
    copydata = (struct copydata *)flayer->l_data;
#line 649
    copydata->cps = copydata->refcps;
#line 650
    copydata->savedcps = copydata->refsavedcps;
#line 651
    copypage();
    }
#line 652
    return;
  }
#line 654
  if (y != 0) {
#line 654
    if (y != flayer->l_height - 1) {
#line 655
      return;
    }
  }
#line 656
  if (isblank) {
#line 657
    return;
  }
  {
#line 658
  LClearArea(flayer, xs, y, xe, y, 0, 0);
  }
#line 659
  return;
}
}
#line 671
static void DisplaysProcess(char **ppbuf , int *plen ) ;
#line 672
static void DisplaysRedisplayLine(int y , int xs , int xe , int isblank ) ;
#line 673
static void displayspage(void) ;
#line 680 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
static struct LayFuncs DisplaysLf  =    {& DisplaysProcess, & HelpAbort, & DisplaysRedisplayLine, & DefClearLine, & DefRewrite,
    & DefResize, & DefRestore};
#line 691 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
static void DisplaysProcess(char **ppbuf , int *plen ) 
{ 
  int done ;

  {
#line 696
  done = 0;
  {
#line 698
  while (1) {
    while_continue: /* CIL Label */ ;
#line 698
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 699
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 699
    if (! done) {
#line 699
      if (! (*plen > 0)) {
#line 699
        goto while_break___0;
      }
    } else {
#line 699
      goto while_break___0;
    }
    {
#line 703
    if ((int )*(*ppbuf) == 32) {
#line 703
      goto case_32;
    }
#line 707
    if ((int )*(*ppbuf) == 10) {
#line 707
      goto case_10;
    }
#line 707
    if ((int )*(*ppbuf) == 13) {
#line 707
      goto case_10;
    }
#line 711
    goto switch_default;
    case_32: /* CIL Label */ 
    {
#line 704
    displayspage();
    }
#line 705
    goto switch_break;
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
    {
#line 708
    HelpAbort();
#line 709
    done = 1;
    }
#line 710
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 712
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 714
    (*ppbuf) ++;
#line 715
    (*plen) --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 717
  return;
}
}
#line 720 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
void display_displays(void) 
{ 
  int tmp ;

  {
#line 723
  if (flayer->l_width < 10) {
    {
#line 725
    LMsg(0, (char *)"Window size too small for displays page");
    }
#line 726
    return;
  } else
#line 723
  if (flayer->l_height < 5) {
    {
#line 725
    LMsg(0, (char *)"Window size too small for displays page");
    }
#line 726
    return;
  }
  {
#line 728
  tmp = InitOverlayPage((int )sizeof(struct displaysdata ), & DisplaysLf, 0);
  }
#line 728
  if (tmp) {
#line 729
    return;
  }
  {
#line 730
  flayer->l_x = 0;
#line 731
  flayer->l_y = flayer->l_height - 1;
#line 732
  displayspage();
  }
#line 733
  return;
}
}
#line 763 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
static char *blockstates[5]  = {      (char *)"nb",      (char *)"NB",      (char *)"Z<",      (char *)"Z>", 
        (char *)"BL"};
#line 756 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
static void displayspage(void) 
{ 
  int y ;
  int l ;
  char tbuf[80] ;
  struct display *d ;
  struct win *w ;
  char const   *tmp ;
  size_t tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;

  {
  {
#line 765
  LClearAll(flayer, 0);
#line 767
  leftline((char *)"term-type   size         user interface           window", 0);
#line 768
  leftline((char *)"---------- ------- ---------- ----------------- ----------", 1);
#line 769
  y = 2;
#line 771
  d = displays;
  }
  {
#line 771
  while (1) {
    while_continue: /* CIL Label */ ;
#line 771
    if (! d) {
#line 771
      goto while_break;
    }
#line 773
    w = d->d_fore;
#line 775
    if (y >= flayer->l_height - 3) {
#line 776
      goto while_break;
    }
#line 777
    if (d->d_blocked) {
#line 777
      goto _L;
    } else
#line 777
    if (d->d_nonblock >= 0) {
      _L: /* CIL Label */ 
#line 777
      if (d->d_blocked <= 4) {
#line 777
        tmp = (char const   *)blockstates[d->d_blocked];
      } else {
#line 777
        tmp = "  ";
      }
    } else {
#line 777
      tmp = "  ";
    }
    {
#line 777
    sprintf((char */* __restrict  */)(tbuf), (char const   */* __restrict  */)"%-10.10s%4dx%-4d%10.10s@%-16.16s%s",
            d->d_termname, d->d_width, d->d_height, (d->d_user)->u_name, d->d_usertty,
            tmp);
    }
#line 782
    if (w) {
      {
#line 784
      tmp___0 = strlen((char const   *)w->w_title);
#line 784
      l = (int )(10U - tmp___0);
      }
#line 785
      if (l < 0) {
#line 786
        l = 0;
      }
      {
#line 787
      tmp___3 = AclCheckPermWin(d->d_user, 2, w);
      }
#line 787
      if (tmp___3) {
#line 787
        tmp___2 = '-';
      } else {
#line 787
        tmp___2 = 'x';
      }
      {
#line 787
      tmp___8 = AclCheckPermWin(d->d_user, 2, w);
      }
#line 787
      if (tmp___8) {
#line 787
        tmp___7 = '-';
      } else {
#line 787
        if (w->w_wlock == 0) {
#line 787
          tmp___6 = 'w';
        } else {
#line 787
          if ((unsigned long )d->d_user == (unsigned long )w->w_wlockuser) {
#line 787
            tmp___5 = 'W';
          } else {
#line 787
            tmp___5 = 'v';
          }
#line 787
          tmp___6 = tmp___5;
        }
#line 787
        tmp___7 = tmp___6;
      }
      {
#line 787
      tmp___12 = AclCheckPermWin(d->d_user, 2, w);
      }
#line 787
      if (tmp___12) {
#line 787
        tmp___11 = '-';
      } else {
#line 787
        if (w->w_wlock == 0) {
#line 787
          tmp___10 = 'r';
        } else
#line 787
        if ((unsigned long )d->d_user == (unsigned long )w->w_wlockuser) {
#line 787
          tmp___10 = 'r';
        } else {
#line 787
          tmp___10 = 'R';
        }
#line 787
        tmp___11 = tmp___10;
      }
      {
#line 787
      tmp___13 = strlen((char const   *)(tbuf));
#line 787
      sprintf((char */* __restrict  */)(tbuf + tmp___13), (char const   */* __restrict  */)"%3d(%.10s)%*s%c%c%c%c",
              w->w_number, w->w_title, l, "", ' ', tmp___11, tmp___7, tmp___2);
      }
    }
    {
#line 810
    leftline(tbuf, y);
#line 811
    y ++;
#line 771
    d = d->d_next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 813
  sprintf((char */* __restrict  */)(tbuf), (char const   */* __restrict  */)"[Press Space %s Return to end.]",
          "to refresh;");
#line 815
  centerline(tbuf, flayer->l_height - 2);
#line 816
  LGotoPos(flayer, flayer->l_x, flayer->l_y);
  }
#line 817
  return;
}
}
#line 819 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
static void DisplaysRedisplayLine(int y , int xs , int xe , int isblank ) 
{ 


  {
  {
#line 823
  while (1) {
    while_continue: /* CIL Label */ ;
#line 823
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 824
  if (y < 0) {
    {
#line 826
    displayspage();
    }
#line 827
    return;
  }
#line 829
  if (y != 0) {
#line 829
    if (y != flayer->l_height - 1) {
#line 830
      return;
    }
  }
#line 831
  if (isblank) {
#line 832
    return;
  }
  {
#line 833
  LClearArea(flayer, xs, y, xe, y, 0, 0);
  }
#line 835
  return;
}
}
#line 848
static void WListProcess(char **ppbuf , int *plen ) ;
#line 849
static void WListRedisplayLine(int y , int xs , int xe , int isblank ) ;
#line 850
static void wlistpage(void) ;
#line 851
static void WListLine(int y , int i , int pos , int isblank ) ;
#line 852
static void WListLines(int up , int oldpos ) ;
#line 853
static void WListMove(int num , int ypos ) ;
#line 854
static void WListUpdate(struct win *p ) ;
#line 855
static int WListNormalize(void) ;
#line 856
static int WListResize(int wi , int he ) ;
#line 857
static int WListNext(struct wlistdata *wlistdata , int old , int delta ) ;
#line 870 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
static struct LayFuncs WListLf  =    {& WListProcess, & HelpAbort, & WListRedisplayLine, & DefClearLine, & DefRewrite,
    & WListResize, & DefRestore};
#line 881 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
static int WListResize(int wi , int he ) 
{ 
  struct wlistdata *wlistdata ;

  {
#line 886
  if (wi < 10) {
#line 887
    return (-1);
  } else
#line 886
  if (he < 5) {
#line 887
    return (-1);
  }
#line 888
  wlistdata = (struct wlistdata *)flayer->l_data;
#line 889
  flayer->l_width = wi;
#line 890
  flayer->l_height = he;
#line 891
  wlistdata->numwin = he - 3;
#line 892
  if (wlistdata->ypos >= wlistdata->numwin) {
#line 893
    wlistdata->ypos = wlistdata->numwin - 1;
  }
#line 894
  flayer->l_y = he - 1;
#line 895
  return (0);
}
}
#line 898 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
static void WListProcess(char **ppbuf , int *plen ) 
{ 
  int done ;
  struct wlistdata *wlistdata ;
  struct display *olddisplay ;
  int h ;
  int n ;
  int d ;
  int i ;
  int tmp ;
  struct win *p ;
  struct win *tmp___0 ;
  struct win *tmp___1 ;

  {
#line 903
  done = 0;
#line 905
  olddisplay = display;
  {
#line 908
  while (1) {
    while_continue: /* CIL Label */ ;
#line 908
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 909
  wlistdata = (struct wlistdata *)flayer->l_data;
#line 910
  h = wlistdata->numwin;
  {
#line 911
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 911
    if (! done) {
#line 911
      if (! (*plen > 0)) {
#line 911
        goto while_break___0;
      }
    } else {
#line 911
      goto while_break___0;
    }
#line 913
    if ((int )((unsigned char )*(*ppbuf)) >= 48) {
#line 913
      if ((int )((unsigned char )*(*ppbuf)) <= 57) {
#line 915
        n = (int )((unsigned char )*(*ppbuf)) - 48;
#line 916
        d = 0;
#line 917
        if (n < 40) {
#line 917
          if (wtab[n]) {
            {
#line 920
            d = - wlistdata->npos;
#line 920
            i = WListNext(wlistdata, -1, 0);
            }
            {
#line 920
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 920
              if (! (i != n)) {
#line 920
                goto while_break___1;
              }
              {
#line 920
              i = WListNext(wlistdata, i, 1);
#line 920
              d ++;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
          }
        }
#line 923
        if (d) {
          {
#line 924
          WListMove(d, -1);
          }
        }
      }
    }
    {
#line 930
    if ((int )((unsigned char )*(*ppbuf)) == 107) {
#line 930
      goto case_107;
    }
#line 930
    if ((int )((unsigned char )*(*ppbuf)) == 16) {
#line 930
      goto case_107;
    }
#line 930
    if ((int )((unsigned char )*(*ppbuf)) == 144) {
#line 930
      goto case_107;
    }
#line 935
    if ((int )((unsigned char )*(*ppbuf)) == 106) {
#line 935
      goto case_106;
    }
#line 935
    if ((int )((unsigned char )*(*ppbuf)) == 14) {
#line 935
      goto case_106;
    }
#line 935
    if ((int )((unsigned char )*(*ppbuf)) == 142) {
#line 935
      goto case_106;
    }
#line 938
    if ((int )((unsigned char )*(*ppbuf)) == 21) {
#line 938
      goto case_21;
    }
#line 941
    if ((int )((unsigned char )*(*ppbuf)) == 4) {
#line 941
      goto case_4;
    }
#line 945
    if ((int )((unsigned char )*(*ppbuf)) == 98) {
#line 945
      goto case_98;
    }
#line 945
    if ((int )((unsigned char )*(*ppbuf)) == 2) {
#line 945
      goto case_98;
    }
#line 949
    if ((int )((unsigned char )*(*ppbuf)) == 102) {
#line 949
      goto case_102;
    }
#line 949
    if ((int )((unsigned char )*(*ppbuf)) == 6) {
#line 949
      goto case_102;
    }
#line 952
    if ((int )((unsigned char )*(*ppbuf)) == 129) {
#line 952
      goto case_129;
    }
#line 955
    if ((int )((unsigned char )*(*ppbuf)) == 133) {
#line 955
      goto case_133;
    }
#line 960
    if ((int )((unsigned char )*(*ppbuf)) == 32) {
#line 960
      goto case_32;
    }
#line 960
    if ((int )((unsigned char )*(*ppbuf)) == 10) {
#line 960
      goto case_32;
    }
#line 960
    if ((int )((unsigned char )*(*ppbuf)) == 13) {
#line 960
      goto case_32;
    }
#line 976
    if ((int )((unsigned char )*(*ppbuf)) == 7) {
#line 976
      goto case_7;
    }
#line 976
    if ((int )((unsigned char )*(*ppbuf)) == 27) {
#line 976
      goto case_7;
    }
#line 990
    goto switch_default;
    case_107: /* CIL Label */ 
    case_16: /* CIL Label */ 
    case_144: /* CIL Label */ 
    {
#line 931
    WListMove(-1, -1);
    }
#line 932
    goto switch_break;
    case_106: /* CIL Label */ 
    case_14: /* CIL Label */ 
    case_142: /* CIL Label */ 
    {
#line 936
    WListMove(1, -1);
    }
#line 937
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 939
    WListMove(- (h / 2), wlistdata->ypos);
    }
#line 940
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 942
    WListMove(h / 2, wlistdata->ypos);
    }
#line 943
    goto switch_break;
    case_98: /* CIL Label */ 
    case_2: /* CIL Label */ 
    {
#line 946
    WListMove(- h, -1);
    }
#line 947
    goto switch_break;
    case_102: /* CIL Label */ 
    case_6: /* CIL Label */ 
    {
#line 950
    WListMove(h, -1);
    }
#line 951
    goto switch_break;
    case_129: /* CIL Label */ 
    {
#line 953
    WListMove(- wlistdata->pos, -1);
    }
#line 954
    goto switch_break;
    case_133: /* CIL Label */ 
    {
#line 956
    WListMove(40, -1);
    }
#line 957
    goto switch_break;
    case_32: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
#line 961
    done = 1;
#line 962
    h = wlistdata->pos;
#line 963
    if (! display) {
      {
#line 964
      HelpAbort();
      }
    } else
#line 963
    if (! wtab[h]) {
      {
#line 964
      HelpAbort();
      }
    } else
#line 963
    if ((unsigned long )wtab[h] == (unsigned long )display->d_fore) {
      {
#line 964
      HelpAbort();
      }
    } else
#line 963
    if (flayer->l_cvlist) {
#line 963
      if ((flayer->l_cvlist)->c_lnext) {
        {
#line 964
        HelpAbort();
        }
      } else {
#line 963
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 966
      tmp = AclCheckPermWin(display->d_user, 2, wtab[h]);
      }
#line 966
      if (tmp) {
        {
#line 967
        HelpAbort();
        }
      } else {
        {
#line 970
        ExitOverlayPage();
        }
      }
    }
    {
#line 972
    display = olddisplay;
#line 973
    SwitchWindow(h);
    }
#line 974
    goto switch_break;
    case_7: /* CIL Label */ 
    case_27: /* CIL Label */ 
    {
#line 977
    h = wlistdata->start;
#line 978
    HelpAbort();
#line 979
    display = olddisplay;
    }
#line 980
    if (h >= 0) {
#line 980
      if (wtab[h]) {
        {
#line 981
        SwitchWindow(h);
        }
      } else {
#line 980
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 982
    if (h == -2) {
#line 984
      if (display) {
#line 984
        tmp___0 = display->d_other;
      } else {
#line 984
        tmp___0 = (struct win *)0;
      }
      {
#line 984
      tmp___1 = FindNiceWindow(tmp___0, (char *)0);
#line 984
      p = tmp___1;
      }
#line 985
      if (p) {
        {
#line 986
        SwitchWindow(p->w_number);
        }
      }
    }
#line 988
    done = 1;
#line 989
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 991
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 993
    (*ppbuf) ++;
#line 994
    (*plen) --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 996
  return;
}
}
#line 998 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
static void WListLine(int y , int i , int pos , int isblank ) 
{ 
  char *str ;
  int n ;
  size_t tmp ;
  struct mchar *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1007
  display = (struct display *)0;
#line 1008
  str = MakeWinMsgEv(wliststr, wtab[i], '%', flayer->l_width, (struct event *)0, 0);
#line 1009
  tmp = strlen((char const   *)str);
#line 1009
  n = (int )tmp;
  }
#line 1010
  if (i != pos) {
#line 1010
    if (isblank) {
      {
#line 1011
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1011
        if (n) {
#line 1011
          if (! ((int )*(str + (n - 1)) == 32)) {
#line 1011
            goto while_break;
          }
        } else {
#line 1011
          goto while_break;
        }
#line 1012
        n --;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 1013
  if (i == pos) {
#line 1013
    tmp___0 = & mchar_so;
  } else {
#line 1013
    tmp___0 = & mchar_blank;
  }
#line 1013
  if (i == pos) {
#line 1013
    tmp___1 = flayer->l_width;
  } else
#line 1013
  if (! isblank) {
#line 1013
    tmp___1 = flayer->l_width;
  } else {
#line 1013
    tmp___1 = n;
  }
  {
#line 1013
  LPutWinMsg(flayer, str, tmp___1, tmp___0, 0, y + 2);
  }
#line 1020
  return;
}
}
#line 1023 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
static int WListNext(struct wlistdata *wlistdata , int old , int delta ) 
{ 
  int i ;
  int j ;
  int tmp ;

  {
#line 1030
  if (old == 40) {
#line 1031
    return (40);
  }
#line 1032
  if (wlistdata->order == 0) {
#line 1034
    if (old == -1) {
#line 1036
      old = 0;
      {
#line 1036
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1036
        if (! (old < 40)) {
#line 1036
          goto while_break;
        }
#line 1037
        if (wtab[old]) {
#line 1038
          goto while_break;
        }
#line 1036
        old ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 1039
      if (old == 40) {
#line 1040
        return (old);
      }
    }
#line 1042
    if (! wtab[old]) {
#line 1043
      return (40);
    }
#line 1044
    i = old;
    {
#line 1045
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1045
      if (delta > 0) {
#line 1045
        if (! (i < 39)) {
#line 1045
          goto while_break___0;
        }
      } else {
#line 1045
        goto while_break___0;
      }
#line 1046
      i ++;
#line 1046
      if (wtab[i]) {
#line 1048
        old = i;
#line 1049
        delta --;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1051
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1051
      if (delta < 0) {
#line 1051
        if (! (i > 0)) {
#line 1051
          goto while_break___1;
        }
      } else {
#line 1051
        goto while_break___1;
      }
#line 1052
      i --;
#line 1052
      if (wtab[i]) {
#line 1054
        old = i;
#line 1055
        delta ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 1060
    if (old == -1) {
#line 1061
      old = windows->w_number;
    }
#line 1062
    if (! wtab[old]) {
#line 1063
      return (40);
    }
    {
#line 1064
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1064
      if (! (delta > 0)) {
#line 1064
        goto while_break___2;
      }
#line 1065
      if ((wtab[old])->w_next) {
#line 1066
        old = ((wtab[old])->w_next)->w_number;
      }
#line 1064
      delta --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1067
    if (delta < 0) {
#line 1069
      i = windows->w_number;
#line 1069
      j = i;
      {
#line 1069
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1069
        if (! (j != old)) {
#line 1069
          goto while_break___3;
        }
#line 1071
        tmp = delta;
#line 1071
        delta ++;
#line 1071
        if (tmp >= 0) {
#line 1071
          if ((wtab[i])->w_next) {
#line 1072
            i = ((wtab[i])->w_next)->w_number;
          }
        }
#line 1073
        if ((wtab[j])->w_next) {
#line 1074
          j = ((wtab[j])->w_next)->w_number;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1076
      old = i;
    }
  }
#line 1079
  return (old);
}
}
#line 1082 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
static void WListLines(int up , int oldpos ) 
{ 
  struct wlistdata *wlistdata ;
  int ypos ;
  int pos ;
  int y ;
  int i ;
  int oldi ;

  {
  {
#line 1090
  wlistdata = (struct wlistdata *)flayer->l_data;
#line 1091
  ypos = wlistdata->ypos;
#line 1092
  pos = wlistdata->pos;
#line 1094
  i = WListNext(wlistdata, pos, - ypos);
#line 1095
  y = 0;
  }
  {
#line 1095
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1095
    if (! (y < wlistdata->numwin)) {
#line 1095
      goto while_break;
    }
#line 1097
    if (i == 40) {
#line 1098
      return;
    } else
#line 1097
    if (! wtab[i]) {
#line 1098
      return;
    }
#line 1099
    if (y == 0) {
#line 1100
      wlistdata->first = i;
    }
#line 1101
    wlistdata->last = i;
#line 1102
    if (i == oldpos) {
#line 1102
      goto _L___1;
    } else
#line 1102
    if (i == pos) {
      _L___1: /* CIL Label */ 
#line 1102
      if (pos != oldpos) {
        {
#line 1103
        WListLine(y, i, pos, i != oldpos);
        }
      } else {
#line 1102
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1102
    if (up > 0) {
#line 1102
      if (y >= wlistdata->numwin - up) {
        {
#line 1103
        WListLine(y, i, pos, i != oldpos);
        }
      } else {
#line 1102
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1102
    if (up < 0) {
#line 1102
      if (y < - up) {
        {
#line 1103
        WListLine(y, i, pos, i != oldpos);
        }
      }
    }
#line 1104
    if (i == pos) {
#line 1105
      wlistdata->ypos = y;
    }
    {
#line 1106
    oldi = i;
#line 1107
    i = WListNext(wlistdata, i, 1);
    }
#line 1108
    if (i == 40) {
#line 1109
      goto while_break;
    } else
#line 1108
    if (i == oldi) {
#line 1109
      goto while_break;
    }
#line 1095
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1111
  return;
}
}
#line 1113 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
static int WListNormalize(void) 
{ 
  struct wlistdata *wlistdata ;
  int i ;
  int oldi ;
  int n ;
  int ypos ;
  int pos ;

  {
#line 1120
  wlistdata = (struct wlistdata *)flayer->l_data;
#line 1121
  ypos = wlistdata->ypos;
#line 1122
  pos = wlistdata->pos;
#line 1123
  if (ypos < 0) {
#line 1124
    ypos = 0;
  }
#line 1125
  if (ypos >= wlistdata->numwin) {
#line 1126
    ypos = wlistdata->numwin - 1;
  }
#line 1127
  n = 0;
#line 1127
  oldi = 40;
#line 1127
  i = pos;
  {
#line 1127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1127
    if (i != 40) {
#line 1127
      if (i != oldi) {
#line 1127
        if (! (n < wlistdata->numwin)) {
#line 1127
          goto while_break;
        }
      } else {
#line 1127
        goto while_break;
      }
    } else {
#line 1127
      goto while_break;
    }
    {
#line 1128
    n ++;
#line 1127
    oldi = i;
#line 1127
    i = WListNext(wlistdata, i, 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1129
  if (ypos < wlistdata->numwin - n) {
#line 1130
    ypos = wlistdata->numwin - n;
  }
  {
#line 1131
  n = 0;
#line 1131
  oldi = 40;
#line 1131
  i = WListNext(wlistdata, -1, 0);
  }
  {
#line 1131
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1131
    if (i != 40) {
#line 1131
      if (i != oldi) {
#line 1131
        if (! (i != pos)) {
#line 1131
          goto while_break___0;
        }
      } else {
#line 1131
        goto while_break___0;
      }
    } else {
#line 1131
      goto while_break___0;
    }
    {
#line 1132
    n ++;
#line 1131
    oldi = i;
#line 1131
    i = WListNext(wlistdata, i, 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1133
  if (ypos > n) {
#line 1134
    ypos = n;
  }
#line 1135
  wlistdata->ypos = ypos;
#line 1136
  wlistdata->npos = n;
#line 1137
  return (ypos);
}
}
#line 1140 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
static void WListMove(int num , int ypos ) 
{ 
  struct wlistdata *wlistdata ;
  int oldpos ;
  int oldypos ;
  int oldnpos ;
  int pos ;
  int up ;

  {
#line 1149
  wlistdata = (struct wlistdata *)flayer->l_data;
#line 1150
  oldpos = wlistdata->pos;
#line 1151
  oldypos = wlistdata->ypos;
#line 1152
  oldnpos = wlistdata->npos;
#line 1153
  if (ypos == -1) {
#line 1153
    wlistdata->ypos = oldypos + num;
  } else {
#line 1153
    wlistdata->ypos = ypos;
  }
  {
#line 1154
  pos = WListNext(wlistdata, oldpos, num);
#line 1155
  wlistdata->pos = pos;
#line 1156
  ypos = WListNormalize();
#line 1157
  up = (wlistdata->npos - ypos) - (oldnpos - oldypos);
  }
#line 1158
  if (up) {
    {
#line 1160
    LScrollV(flayer, up, 2, (2 + wlistdata->numwin) - 1, 0);
#line 1161
    WListLines(up, oldpos);
#line 1162
    LGotoPos(flayer, flayer->l_x, flayer->l_y);
    }
#line 1163
    return;
  }
#line 1165
  if (pos == oldpos) {
#line 1166
    return;
  }
  {
#line 1167
  WListLine(oldypos, oldpos, pos, 0);
#line 1168
  WListLine(ypos, pos, pos, 1);
#line 1169
  LGotoPos(flayer, flayer->l_x, flayer->l_y);
  }
#line 1170
  return;
}
}
#line 1172 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
static void WListRedisplayLine(int y , int xs , int xe , int isblank ) 
{ 


  {
  {
#line 1176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1176
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1177
  if (y < 0) {
    {
#line 1179
    wlistpage();
    }
#line 1180
    return;
  }
#line 1182
  if (y != 0) {
#line 1182
    if (y != flayer->l_height - 1) {
#line 1183
      return;
    }
  }
#line 1184
  if (! isblank) {
    {
#line 1185
    LClearArea(flayer, xs, y, xe, y, 0, 0);
    }
  }
#line 1186
  return;
}
}
#line 1188 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
void display_wlist(int onblank , int order ) 
{ 
  struct win *p ;
  struct wlistdata *wlistdata ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1196
  if (flayer->l_width < 10) {
    {
#line 1198
    LMsg(0, (char *)"Window size too small for window list page");
    }
#line 1199
    return;
  } else
#line 1196
  if (flayer->l_height < 5) {
    {
#line 1198
    LMsg(0, (char *)"Window size too small for window list page");
    }
#line 1199
    return;
  }
#line 1201
  if (onblank) {
    {
#line 1203
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1203
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1204
    if (! display) {
      {
#line 1206
      LMsg(0, (char *)"windowlist -b: display required");
      }
#line 1207
      return;
    }
    {
#line 1209
    p = display->d_fore;
#line 1210
    SetForeWindow((struct win *)0);
#line 1211
    Activate(0);
    }
#line 1212
    if (flayer->l_width < 10) {
      {
#line 1214
      LMsg(0, (char *)"Window size too small for window list page");
      }
#line 1215
      return;
    } else
#line 1212
    if (flayer->l_height < 5) {
      {
#line 1214
      LMsg(0, (char *)"Window size too small for window list page");
      }
#line 1215
      return;
    }
    {
#line 1217
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1217
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 1220
    p = (struct win *)(flayer->l_bottom)->l_data;
  }
  {
#line 1221
  tmp = InitOverlayPage((int )sizeof(*wlistdata), & WListLf, 0);
  }
#line 1221
  if (tmp) {
#line 1222
    return;
  }
#line 1223
  wlistdata = (struct wlistdata *)flayer->l_data;
#line 1224
  flayer->l_x = 0;
#line 1225
  flayer->l_y = flayer->l_height - 1;
#line 1226
  if (onblank) {
#line 1226
    if (p) {
#line 1226
      wlistdata->start = p->w_number;
    } else {
#line 1226
      wlistdata->start = -1;
    }
  } else {
#line 1226
    wlistdata->start = -1;
  }
#line 1227
  wlistdata->order = order;
#line 1228
  if (p) {
#line 1228
    wlistdata->pos = p->w_number;
  } else {
    {
#line 1228
    tmp___0 = WListNext(wlistdata, -1, 0);
#line 1228
    wlistdata->pos = tmp___0;
    }
  }
  {
#line 1229
  tmp___1 = 0;
#line 1229
  wlistdata->npos = tmp___1;
#line 1229
  wlistdata->ypos = tmp___1;
#line 1230
  wlistdata->numwin = flayer->l_height - 3;
#line 1231
  wlistpage();
  }
#line 1232
  return;
}
}
#line 1234 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
static void wlistpage(void) 
{ 
  struct wlistdata *wlistdata ;
  char *str ;
  int pos ;
  size_t tmp ;

  {
  {
#line 1241
  wlistdata = (struct wlistdata *)flayer->l_data;
#line 1243
  LClearAll(flayer, 0);
  }
#line 1244
  if (wlistdata->start >= 0) {
#line 1244
    if ((unsigned long )wtab[wlistdata->start] == (unsigned long )((struct win *)0)) {
#line 1245
      wlistdata->start = -2;
    }
  }
#line 1247
  pos = wlistdata->pos;
#line 1248
  if ((unsigned long )wtab[pos] == (unsigned long )((struct win *)0)) {
#line 1250
    if (wlistdata->order == 1) {
      {
#line 1251
      pos = WListNext(wlistdata, -1, wlistdata->npos);
      }
    } else {
      {
#line 1255
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1255
        pos ++;
#line 1255
        if (! (pos < 40)) {
#line 1255
          goto while_break;
        }
#line 1256
        if (wtab[pos]) {
#line 1257
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 1258
      if (pos == 40) {
        {
#line 1259
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1259
          pos --;
#line 1259
          if (! (pos > 0)) {
#line 1259
            goto while_break___0;
          }
#line 1260
          if (wtab[pos]) {
#line 1261
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
  }
  {
#line 1264
  wlistdata->pos = pos;
#line 1266
  display = (struct display *)0;
#line 1267
  str = MakeWinMsgEv(wlisttit, (struct win *)0, '%', flayer->l_width, (struct event *)0,
                     0);
#line 1268
  tmp = strlen((char const   *)str);
#line 1268
  LPutWinMsg(flayer, str, (int )tmp, & mchar_blank, 0, 0);
#line 1269
  WListNormalize();
#line 1270
  WListLines(wlistdata->numwin, -1);
#line 1271
  LGotoPos(flayer, flayer->l_x, flayer->l_y);
  }
#line 1272
  return;
}
}
#line 1274 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
static void WListUpdate(struct win *p ) 
{ 
  struct wlistdata *wlistdata ;
  int i ;
  int n ;
  int y ;

  {
#line 1281
  if ((unsigned long )p == (unsigned long )((struct win *)0)) {
    {
#line 1283
    wlistpage();
    }
#line 1284
    return;
  }
#line 1286
  wlistdata = (struct wlistdata *)flayer->l_data;
#line 1287
  n = p->w_number;
#line 1288
  if (wlistdata->order == 0) {
#line 1288
    if (n < wlistdata->first) {
#line 1289
      return;
    } else
#line 1288
    if (n > wlistdata->last) {
#line 1289
      return;
    }
  }
#line 1290
  i = wlistdata->first;
#line 1291
  y = 0;
  {
#line 1291
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1291
    if (! (y < wlistdata->numwin)) {
#line 1291
      goto while_break;
    }
#line 1293
    if (i == n) {
#line 1294
      goto while_break;
    }
    {
#line 1295
    i = WListNext(wlistdata, i, 1);
#line 1291
    y ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1297
  if (y == wlistdata->numwin) {
#line 1298
    return;
  }
  {
#line 1299
  WListLine(y, i, wlistdata->pos, 0);
#line 1300
  LGotoPos(flayer, flayer->l_x, flayer->l_y);
  }
#line 1301
  return;
}
}
#line 1303 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
void WListUpdatecv(struct canvas *cv , struct win *p ) 
{ 
  struct display *olddisplay ;
  struct layer *oldflayer ;
  struct layer *l ;
  struct canvas *cvlist ;
  struct canvas *cvlnext ;

  {
#line 1308
  if ((unsigned long )(cv->c_layer)->l_layfn != (unsigned long )(& WListLf)) {
#line 1309
    return;
  }
  {
#line 1310
  olddisplay = display;
#line 1310
  oldflayer = flayer;
#line 1310
  l = cv->c_layer;
#line 1310
  cvlist = l->l_cvlist;
#line 1310
  cvlnext = cv->c_lnext;
#line 1310
  flayer = l;
#line 1310
  l->l_cvlist = cv;
#line 1310
  cv->c_lnext = (struct canvas *)0;
#line 1310
  WListUpdate(p);
#line 1310
  flayer = oldflayer;
#line 1310
  l->l_cvlist = cvlist;
#line 1310
  cv->c_lnext = cvlnext;
#line 1310
  display = olddisplay;
  }
#line 1311
  return;
}
}
#line 1313 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
void WListLinkChanged(void) 
{ 
  struct display *olddisplay ;
  struct canvas *cv ;
  struct wlistdata *wlistdata ;
  struct display *olddisplay___0 ;
  struct layer *oldflayer ;
  struct layer *l ;
  struct canvas *cvlist ;
  struct canvas *cvlnext ;

  {
#line 1316
  olddisplay = display;
#line 1320
  display = displays;
  {
#line 1320
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1320
    if (! display) {
#line 1320
      goto while_break;
    }
#line 1321
    cv = display->d_cvlist;
    {
#line 1321
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1321
      if (! cv) {
#line 1321
        goto while_break___0;
      }
#line 1323
      if ((unsigned long )(cv->c_layer)->l_layfn != (unsigned long )(& WListLf)) {
#line 1324
        goto __Cont;
      }
#line 1325
      wlistdata = (struct wlistdata *)(cv->c_layer)->l_data;
#line 1326
      if (wlistdata->order != 1) {
#line 1327
        goto __Cont;
      }
      {
#line 1328
      olddisplay___0 = display;
#line 1328
      oldflayer = flayer;
#line 1328
      l = cv->c_layer;
#line 1328
      cvlist = l->l_cvlist;
#line 1328
      cvlnext = cv->c_lnext;
#line 1328
      flayer = l;
#line 1328
      l->l_cvlist = cv;
#line 1328
      cv->c_lnext = (struct canvas *)0;
#line 1328
      WListUpdate((struct win *)0);
#line 1328
      flayer = oldflayer;
#line 1328
      l->l_cvlist = cvlist;
#line 1328
      cv->c_lnext = cvlnext;
#line 1328
      display = olddisplay___0;
      }
      __Cont: /* CIL Label */ 
#line 1321
      cv = cv->c_next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1320
    display = display->d_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1330
  display = olddisplay;
#line 1331
  return;
}
}
#line 1333 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
int InWList(void) 
{ 


  {
#line 1336
  if (flayer) {
#line 1336
    if ((unsigned long )flayer->l_layfn == (unsigned long )(& WListLf)) {
#line 1337
      return (1);
    }
  }
#line 1338
  return (0);
}
}
#line 1358
static void BindkeyProcess(char **ppbuf , int *plen ) ;
#line 1359
static void BindkeyAbort(void) ;
#line 1360
static void BindkeyRedisplayLine(int y , int xs , int xe , int isblank ) ;
#line 1361
static void bindkeypage(void) ;
#line 1373 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
static struct LayFuncs BindkeyLf  =    {& BindkeyProcess, & BindkeyAbort, & BindkeyRedisplayLine, & DefClearLine, & DefRewrite,
    & DefResize, & DefRestore};
#line 1385 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
void display_bindkey(char *title , struct action *tab ) 
{ 
  struct bindkeydata *bindkeydata ;
  int i ;
  int n ;
  int tmp ;

  {
#line 1393
  if (flayer->l_height < 6) {
    {
#line 1395
    LMsg(0, (char *)"Window height too small for bindkey page");
    }
#line 1396
    return;
  }
  {
#line 1398
  tmp = InitOverlayPage((int )sizeof(*bindkeydata), & BindkeyLf, 0);
  }
#line 1398
  if (tmp) {
#line 1399
    return;
  }
#line 1401
  bindkeydata = (struct bindkeydata *)flayer->l_data;
#line 1402
  bindkeydata->title = title;
#line 1403
  bindkeydata->tab = tab;
#line 1405
  n = 0;
#line 1406
  i = 0;
  {
#line 1406
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1406
    if (! (i < 99 + kmap_extn)) {
#line 1406
      goto while_break;
    }
#line 1408
    if ((tab + i)->nr != -1) {
#line 1409
      n ++;
    }
#line 1406
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1411
  bindkeydata->pos = 0;
#line 1412
  bindkeydata->page = 1;
#line 1413
  bindkeydata->pages = ((n + flayer->l_height) - 6) / (flayer->l_height - 5);
#line 1414
  if (bindkeydata->pages == 0) {
#line 1415
    bindkeydata->pages = 1;
  }
  {
#line 1416
  flayer->l_x = 0;
#line 1417
  flayer->l_y = flayer->l_height - 1;
#line 1418
  bindkeypage();
  }
#line 1419
  return;
}
}
#line 1421 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
static void BindkeyAbort(void) 
{ 
  struct layer *oldlay ;
  struct canvas *oldcvlist ;
  struct canvas *cv ;

  {
  {
#line 1424
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1424
    oldlay = flayer;
    {
#line 1424
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1424
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1424
    flayer = flayer->l_next;
#line 1424
    oldcvlist = flayer->l_cvlist;
    {
#line 1424
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1424
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1424
    flayer->l_cvlist = oldlay->l_cvlist;
#line 1424
    cv = flayer->l_cvlist;
    {
#line 1424
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1424
      if (! cv) {
#line 1424
        goto while_break___2;
      }
#line 1424
      cv->c_layer = flayer;
#line 1424
      cv = cv->c_lnext;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1424
    LRefreshAll(flayer, 0);
#line 1424
    flayer = oldlay;
#line 1424
    cv = flayer->l_cvlist;
    }
    {
#line 1424
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1424
      if (! cv) {
#line 1424
        goto while_break___3;
      }
#line 1424
      cv->c_layer = flayer;
#line 1424
      cv = cv->c_lnext;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1424
    (flayer->l_next)->l_cvlist = oldcvlist;
#line 1424
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1425
  ExitOverlayPage();
  }
#line 1426
  return;
}
}
#line 1428 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
static void bindkeypage(void) 
{ 
  struct bindkeydata *bindkeydata ;
  struct kmap_ext *kme ;
  char tbuf[256] ;
  int del ;
  int i ;
  int y ;
  int sl ;
  struct action *act ;
  char *xch ;
  char *s ;
  char *p ;
  char *tmp ;
  char tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char tmp___3 ;
  size_t tmp___4 ;
  struct action *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  char const   *tmp___14 ;

  {
  {
#line 1438
  bindkeydata = (struct bindkeydata *)flayer->l_data;
#line 1440
  LClearAll(flayer, 0);
#line 1442
  sprintf((char */* __restrict  */)(tbuf), (char const   */* __restrict  */)"%s key bindings, page %d of %d.",
          bindkeydata->title, bindkeydata->page, bindkeydata->pages);
#line 1443
  centerline(tbuf, 0);
#line 1444
  y = 2;
#line 1445
  i = bindkeydata->pos;
  }
  {
#line 1445
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1445
    if (i < 99 + kmap_extn) {
#line 1445
      if (! (y < flayer->l_height - 3)) {
#line 1445
        goto while_break;
      }
    } else {
#line 1445
      goto while_break;
    }
#line 1447
    p = tbuf;
#line 1448
    xch = (char *)"   ";
#line 1449
    if (i < 77) {
#line 1451
      act = bindkeydata->tab + i;
#line 1452
      if (act->nr == -1) {
#line 1453
        goto __Cont;
      }
#line 1454
      tmp = p;
#line 1454
      p ++;
#line 1454
      tmp___0 = (char )':';
#line 1454
      *tmp = tmp___0;
#line 1454
      del = (int )tmp___0;
#line 1455
      s = term[i + 106].tcname;
#line 1456
      if (s) {
        {
#line 1456
        tmp___1 = strlen((char const   *)s);
#line 1456
        sl = (int )tmp___1;
        }
      } else {
#line 1456
        sl = 0;
      }
    } else
#line 1458
    if (i < 99) {
#line 1460
      act = bindkeydata->tab + i;
#line 1461
      if (act->nr == -1) {
#line 1462
        goto __Cont;
      }
#line 1463
      tmp___2 = p;
#line 1463
      p ++;
#line 1463
      tmp___3 = (char )':';
#line 1463
      *tmp___2 = tmp___3;
#line 1463
      del = (int )tmp___3;
#line 1464
      s = term[i + 84].tcname;
#line 1465
      if (s) {
        {
#line 1465
        tmp___4 = strlen((char const   *)s);
#line 1465
        sl = (int )tmp___4;
        }
      } else {
#line 1465
        sl = 0;
      }
#line 1466
      xch = (char *)"[A]";
    } else {
#line 1470
      kme = kmap_exts + (i - 99);
#line 1471
      del = 0;
#line 1472
      s = kme->str;
#line 1473
      sl = kme->fl & -16385;
#line 1474
      if ((kme->fl & 16384) != 0) {
#line 1475
        xch = (char *)"[T]";
      }
#line 1476
      if ((unsigned long )bindkeydata->tab == (unsigned long )(dmtab)) {
#line 1476
        act = & kme->dm;
      } else {
#line 1476
        if ((unsigned long )bindkeydata->tab == (unsigned long )(mmtab)) {
#line 1476
          tmp___5 = & kme->mm;
        } else {
#line 1476
          tmp___5 = & kme->um;
        }
#line 1476
        act = tmp___5;
      }
#line 1477
      if (act->nr == -1) {
#line 1478
        goto __Cont;
      }
    }
    {
#line 1480
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1480
      tmp___8 = sl;
#line 1480
      sl --;
#line 1480
      if (! (tmp___8 > 0)) {
#line 1480
        goto while_break___0;
      }
      {
#line 1481
      tmp___6 = s;
#line 1481
      s ++;
#line 1481
      tmp___7 = AddXChar(p, (int )*((unsigned char *)tmp___6));
#line 1481
      p += tmp___7;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1482
    if (del) {
#line 1483
      tmp___9 = p;
#line 1483
      p ++;
#line 1483
      *tmp___9 = (char )del;
    }
#line 1484
    tmp___10 = p;
#line 1484
    p ++;
#line 1484
    *tmp___10 = (char )' ';
    {
#line 1485
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1485
      if (! ((unsigned long )p < (unsigned long )(tbuf + 15))) {
#line 1485
        goto while_break___1;
      }
#line 1486
      tmp___11 = p;
#line 1486
      p ++;
#line 1486
      *tmp___11 = (char )' ';
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1487
    sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%s -> ",
            xch);
#line 1488
    p += 7;
    }
#line 1489
    if (p - tbuf > (long )(flayer->l_width - 1)) {
#line 1491
      tbuf[flayer->l_width - 2] = (char )'$';
#line 1492
      tbuf[flayer->l_width - 1] = (char)0;
    }
    {
#line 1494
    tmp___12 = strlen((char const   *)(tbuf));
#line 1494
    PadStr(tbuf, (int )tmp___12, 0, y);
#line 1495
    tmp___13 = strlen((char const   *)(tbuf));
#line 1495
    AddAction(act, (int )tmp___13, y);
#line 1496
    y ++;
    }
    __Cont: /* CIL Label */ 
#line 1445
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1498
  y ++;
#line 1499
  bindkeydata->last = i;
#line 1500
  if (bindkeydata->page < bindkeydata->pages) {
#line 1500
    tmp___14 = "for next page;";
  } else {
#line 1500
    tmp___14 = "or";
  }
  {
#line 1500
  sprintf((char */* __restrict  */)(tbuf), (char const   */* __restrict  */)"[Press Space %s Return to end.]",
          tmp___14);
#line 1501
  centerline(tbuf, flayer->l_height - 2);
#line 1502
  LGotoPos(flayer, flayer->l_x, flayer->l_y);
  }
#line 1503
  return;
}
}
#line 1505 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
static void BindkeyProcess(char **ppbuf , int *plen ) 
{ 
  int done ;
  struct bindkeydata *bindkeydata ;

  {
#line 1510
  done = 0;
#line 1513
  bindkeydata = (struct bindkeydata *)flayer->l_data;
  {
#line 1514
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1514
    if (! done) {
#line 1514
      if (! (*plen > 0)) {
#line 1514
        goto while_break;
      }
    } else {
#line 1514
      goto while_break;
    }
    {
#line 1518
    if ((int )*(*ppbuf) == 32) {
#line 1518
      goto case_32;
    }
#line 1528
    if ((int )*(*ppbuf) == 10) {
#line 1528
      goto case_10;
    }
#line 1528
    if ((int )*(*ppbuf) == 13) {
#line 1528
      goto case_10;
    }
#line 1531
    goto switch_default;
    case_32: /* CIL Label */ 
#line 1519
    if (bindkeydata->page < bindkeydata->pages) {
      {
#line 1521
      bindkeydata->pos = bindkeydata->last;
#line 1522
      (bindkeydata->page) ++;
#line 1523
      bindkeypage();
      }
#line 1524
      goto switch_break;
    }
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
#line 1529
    done = 1;
#line 1530
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1532
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1534
    (*ppbuf) ++;
#line 1535
    (*plen) --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1537
  if (done) {
    {
#line 1538
    BindkeyAbort();
    }
  }
#line 1539
  return;
}
}
#line 1541 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
static void BindkeyRedisplayLine(int y , int xs , int xe , int isblank ) 
{ 


  {
#line 1545
  if (y < 0) {
    {
#line 1547
    bindkeypage();
    }
#line 1548
    return;
  }
#line 1550
  if (y != 0) {
#line 1550
    if (y != flayer->l_height - 1) {
#line 1551
      return;
    }
  }
#line 1552
  if (! isblank) {
    {
#line 1553
    LClearArea(flayer, xs, y, xe, y, 0, 0);
    }
  }
#line 1554
  return;
}
}
#line 1567
static void ZmodemRedisplayLine(int y , int xs , int xe , int isblank ) ;
#line 1568
static int ZmodemResize(int wi , int he ) ;
#line 1570 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
static struct LayFuncs ZmodemLf  =    {& DefProcess, (void (*)(void))0, & ZmodemRedisplayLine, & DefClearLine, & DefRewrite,
    & ZmodemResize, & DefRestore};
#line 1582 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
static int ZmodemResize(int wi , int he ) 
{ 


  {
#line 1586
  flayer->l_width = wi;
#line 1587
  flayer->l_height = he;
#line 1588
  if (flayer->l_width > 32) {
#line 1588
    flayer->l_x = 32;
  } else {
#line 1588
    flayer->l_x = 0;
  }
#line 1589
  return (0);
}
}
#line 1592 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
static void ZmodemRedisplayLine(int y , int xs , int xe , int isblank ) 
{ 
  int tmp ;

  {
  {
#line 1596
  DefRedisplayLine(y, xs, xe, isblank);
  }
#line 1597
  if (y == 0) {
#line 1597
    if (xs == 0) {
#line 1598
      if (flayer->l_width > 32) {
#line 1598
        tmp = 32;
      } else {
#line 1598
        tmp = flayer->l_width;
      }
      {
#line 1598
      LPutStr(flayer, (char *)"Zmodem active on another display", tmp, & mchar_blank,
              0, 0);
      }
    }
  }
#line 1599
  return;
}
}
#line 1601 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
void ZmodemPage(void) 
{ 
  int tmp ;

  {
  {
#line 1604
  tmp = InitOverlayPage(1, & ZmodemLf, 1);
  }
#line 1604
  if (tmp) {
#line 1605
    return;
  }
  {
#line 1606
  LRefreshAll(flayer, 0);
  }
#line 1607
  if (flayer->l_width > 32) {
#line 1607
    flayer->l_x = 32;
  } else {
#line 1607
    flayer->l_x = 0;
  }
#line 1608
  flayer->l_y = 0;
#line 1609
  return;
}
}
#line 1615 "/home/pronto/abs/test-suite/screen-4.0.2/help.c"
static void PadStr(char *str , int n , int x , int y ) 
{ 
  int l ;
  size_t tmp ;

  {
  {
#line 1622
  tmp = strlen((char const   *)str);
#line 1622
  l = (int )tmp;
  }
#line 1623
  if (l > n) {
#line 1624
    l = n;
  }
  {
#line 1625
  LPutStr(flayer, str, l, & mchar_blank, x, y);
  }
#line 1626
  if (l < n) {
    {
#line 1627
    LPutStr(flayer, (char *)blank, n - l, & mchar_blank, x + l, y);
    }
  }
#line 1628
  return;
}
}
#line 526 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 172 "/home/pronto/abs/test-suite/screen-4.0.2/extern.h"
void InitLoadav(void) ;
#line 173
void AddLoadav(char *p ) ;
#line 47 "/home/pronto/abs/test-suite/screen-4.0.2/loadav.c"
static int GetLoadav(void) ;
#line 49 "/home/pronto/abs/test-suite/screen-4.0.2/loadav.c"
static double loadav[3]  ;
#line 50 "/home/pronto/abs/test-suite/screen-4.0.2/loadav.c"
static int loadok  ;
#line 62 "/home/pronto/abs/test-suite/screen-4.0.2/loadav.c"
void InitLoadav(void) 
{ 


  {
#line 65
  loadok = 1;
#line 66
  return;
}
}
#line 68 "/home/pronto/abs/test-suite/screen-4.0.2/loadav.c"
static int GetLoadav(void) 
{ 
  FILE *fp ;
  char buf___0[128] ;
  char *s ;
  int i ;
  double d ;
  double e ;

  {
  {
#line 76
  fp = secfopen((char *)"/proc/loadavg", (char *)"r");
  }
#line 76
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 77
    return (0);
  }
  {
#line 78
  buf___0[0] = (char)0;
#line 79
  fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
#line 80
  fclose(fp);
#line 84
  s = buf___0;
#line 85
  i = 0;
  }
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! (i < 3)) {
#line 85
      goto while_break;
    }
#line 87
    e = (double )0;
#line 87
    d = e;
    {
#line 88
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 88
      if (! ((int )*s == 32)) {
#line 88
        goto while_break___0;
      }
#line 89
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 90
    if ((int )*s == 0) {
#line 91
      goto while_break;
    }
    {
#line 92
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 94
      if ((int )*s == 46) {
#line 95
        e = (double )1;
      } else
#line 96
      if ((int )*s >= 48) {
#line 96
        if ((int )*s <= 57) {
#line 98
          d = d * (double )10 + (double )((int )*s - 48);
#line 99
          if (e) {
#line 100
            e *= (double )10;
          }
        } else {
#line 103
          goto while_break___1;
        }
      } else {
#line 103
        goto while_break___1;
      }
#line 104
      s ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 106
    if (e) {
#line 106
      loadav[i] = d / e;
    } else {
#line 106
      loadav[i] = d;
    }
#line 85
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  return (i);
}
}
#line 336 "/home/pronto/abs/test-suite/screen-4.0.2/loadav.c"
void AddLoadav(char *p ) 
{ 
  int i ;
  int j ;
  size_t tmp ;

  {
#line 341
  if (loadok == 0) {
#line 342
    return;
  }
  {
#line 343
  j = GetLoadav();
#line 344
  i = 0;
  }
  {
#line 344
  while (1) {
    while_continue: /* CIL Label */ ;
#line 344
    if (! (i < j)) {
#line 344
      goto while_break;
    }
    {
#line 346
    sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)(" %2.2f" + ! i),
            loadav[i] / (double )1);
#line 347
    tmp = strlen((char const   *)p);
#line 347
    p += tmp;
#line 344
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 349
  return;
}
}
#line 708 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) char *ttyname(int __fd ) ;
#line 66 "/usr/include/utmp.h"
extern  __attribute__((__nothrow__)) void setutent(void) ;
#line 77
extern  __attribute__((__nothrow__)) struct utmp *getutline(struct utmp  const  *__line ) ;
#line 80
extern  __attribute__((__nothrow__)) struct utmp *pututline(struct utmp  const  *__utmp_ptr ) ;
#line 153 "/home/pronto/abs/test-suite/screen-4.0.2/extern.h"
void InitUtmp(void) ;
#line 154
void RemoveLoginSlot(void) ;
#line 155
void RestoreLoginSlot(void) ;
#line 349
char *stripdev(char *nam ) ;
#line 81 "/home/pronto/abs/test-suite/screen-4.0.2/utmp.c"
static slot_t TtyNameSlot(char *nam ) ;
#line 82
static void makeuser(struct utmp *u , char *line , char *user , int pid ) ;
#line 83
static void makedead(struct utmp *u ) ;
#line 84
static int pututslot(slot_t slot , struct utmp *u , char *host , struct win *wi ) ;
#line 85
static struct utmp *getutslot(slot_t slot ) ;
#line 93
static struct utmp *xpututline(struct utmp *u ) ;
#line 98 "/home/pronto/abs/test-suite/screen-4.0.2/utmp.c"
static int utmpok  ;
#line 99 "/home/pronto/abs/test-suite/screen-4.0.2/utmp.c"
static char UtmpName[14]  = 
#line 99
  {      (char )'/',      (char )'v',      (char )'a',      (char )'r', 
        (char )'/',      (char )'r',      (char )'u',      (char )'n', 
        (char )'/',      (char )'u',      (char )'t',      (char )'m', 
        (char )'p',      (char )'\000'};
#line 101 "/home/pronto/abs/test-suite/screen-4.0.2/utmp.c"
static int utmpfd  =    -1;
#line 171 "/home/pronto/abs/test-suite/screen-4.0.2/utmp.c"
void SlotToggle(int how ) 
{ 
  int tmp ;

  {
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 176
  if (fore->w_type != 0) {
    {
#line 178
    Msg(0, (char *)"Can only work with normal windows.\n");
    }
#line 179
    return;
  }
#line 181
  if (how) {
    {
#line 183
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 183
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 184
    if ((unsigned long )fore->w_slot == (unsigned long )((slot_t )-1)) {
#line 184
      goto _L;
    } else
#line 184
    if ((unsigned long )fore->w_slot == (unsigned long )((slot_t )0)) {
      _L: /* CIL Label */ 
      {
#line 193
      tmp = SetUtmp(fore);
      }
#line 193
      if (tmp == 0) {
        {
#line 194
        Msg(0, (char *)"This window is now logged in.");
        }
      } else {
        {
#line 196
        Msg(0, (char *)"This window should now be logged in.");
        }
      }
      {
#line 197
      WindowChanged(fore, 'f');
      }
    } else {
      {
#line 200
      Msg(0, (char *)"This window is already logged in.");
      }
    }
  } else {
    {
#line 204
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 204
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 205
    if ((unsigned long )fore->w_slot == (unsigned long )((slot_t )-1)) {
      {
#line 206
      Msg(0, (char *)"This window is already logged out\n");
      }
    } else
#line 207
    if ((unsigned long )fore->w_slot == (unsigned long )((slot_t )0)) {
      {
#line 209
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 209
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 210
      Msg(0, (char *)"This window is not logged in.");
#line 211
      fore->w_slot = (slot_t )-1;
      }
    } else {
      {
#line 215
      RemoveUtmp(fore);
      }
#line 216
      if ((unsigned long )fore->w_slot != (unsigned long )((slot_t )-1)) {
        {
#line 217
        Msg(0, (char *)"What? Cannot remove Utmp slot?");
        }
      } else {
        {
#line 219
        Msg(0, (char *)"This window is no longer logged in.");
        }
      }
      {
#line 223
      WindowChanged(fore, 'f');
      }
    }
  }
#line 226
  return;
}
}
#line 258 "/home/pronto/abs/test-suite/screen-4.0.2/utmp.c"
void InitUtmp(void) 
{ 
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 263
  utmpfd = open((char const   *)(UtmpName), 2);
  }
#line 263
  if (utmpfd == -1) {
    {
#line 265
    tmp___0 = __errno_location();
    }
#line 265
    if (*tmp___0 != 13) {
      {
#line 266
      tmp = __errno_location();
#line 266
      Msg(*tmp, UtmpName);
      }
    }
    {
#line 267
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 267
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 268
    utmpok = 0;
#line 269
    return;
  }
  {
#line 272
  close(utmpfd);
#line 273
  utmpfd = -1;
#line 276
  utmpok = 1;
  }
#line 277
  return;
}
}
#line 306 "/home/pronto/abs/test-suite/screen-4.0.2/utmp.c"
void RemoveLoginSlot(void) 
{ 
  struct utmp u ;
  struct utmp *uu ;
  int tmp ;
  struct stat stb ;
  char *tty ;
  int tmp___0 ;

  {
  {
#line 311
  while (1) {
    while_continue: /* CIL Label */ ;
#line 311
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 312
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 312
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 313
  display->d_loginslot = TtyNameSlot(display->d_usertty);
  }
#line 314
  if ((unsigned long )display->d_loginslot == (unsigned long )((slot_t )0)) {
#line 315
    return;
  } else
#line 314
  if ((unsigned long )display->d_loginslot == (unsigned long )((slot_t )-1)) {
#line 315
    return;
  }
#line 319
  if (! utmpok) {
#line 322
    display->d_loginslot = (slot_t )0;
    {
#line 323
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 323
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 336
    uu = getutslot(display->d_loginslot);
    }
#line 336
    if ((unsigned long )uu == (unsigned long )((struct utmp *)0)) {
      {
#line 338
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 338
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 339
      display->d_loginslot = (slot_t )0;
    } else {
      {
#line 343
      display->d_utmp_logintty = *uu;
#line 344
      u = *uu;
#line 345
      makedead(& u);
#line 346
      tmp = pututslot(display->d_loginslot, & u, (char *)0, (struct win *)0);
      }
#line 346
      if (tmp == 0) {
#line 347
        display->d_loginslot = (slot_t )0;
      }
    }
  }
  {
#line 351
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 351
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 352
  if ((unsigned long )display->d_loginslot == (unsigned long )((slot_t )0)) {
    {
#line 357
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 357
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 358
    display->d_loginttymode = 0;
#line 359
    tty = ttyname(display->d_userfd);
    }
#line 359
    if (tty) {
      {
#line 359
      tmp___0 = stat((char const   */* __restrict  */)tty, (struct stat */* __restrict  */)(& stb));
      }
#line 359
      if (tmp___0 == 0) {
#line 359
        if ((int )stb.st_uid == real_uid) {
#line 359
          if (((int )stb.st_mode & 511) != 438) {
            {
#line 361
            display->d_loginttymode = (int )stb.st_mode & 511;
#line 362
            chmod((char const   *)(display->d_usertty), stb.st_mode & 384U);
            }
          }
        }
      }
    }
  }
#line 365
  return;
}
}
#line 370 "/home/pronto/abs/test-suite/screen-4.0.2/utmp.c"
void RestoreLoginSlot(void) 
{ 
  char *tty ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 375
  while (1) {
    while_continue: /* CIL Label */ ;
#line 375
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 376
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 376
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 377
  if (utmpok) {
#line 377
    if ((unsigned long )display->d_loginslot != (unsigned long )((slot_t )0)) {
#line 377
      if ((unsigned long )display->d_loginslot != (unsigned long )((slot_t )-1)) {
        {
#line 379
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 379
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 380
        tmp___0 = pututslot(display->d_loginslot, & display->d_utmp_logintty, display->d_utmp_logintty.ut_host,
                            (struct win *)0);
        }
#line 380
        if (tmp___0 == 0) {
          {
#line 381
          tmp = __errno_location();
#line 381
          Msg(*tmp, (char *)"Could not write %s", UtmpName);
          }
        }
      }
    }
  }
#line 384
  display->d_loginslot = (slot_t )0;
#line 385
  if (display->d_loginttymode) {
    {
#line 385
    tty = ttyname(display->d_userfd);
    }
#line 385
    if (tty) {
      {
#line 386
      chmod((char const   *)tty, (__mode_t )display->d_loginttymode);
      }
    }
  }
#line 387
  return;
}
}
#line 400 "/home/pronto/abs/test-suite/screen-4.0.2/utmp.c"
int SetUtmp(struct win *wi ) 
{ 
  register slot_t slot ;
  struct utmp u ;
  int saved_ut ;
  char *p ;
  char host[sizeof(display->d_utmp_logintty.ut_host) + 15UL] ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
#line 414
  wi->w_slot = (slot_t )0;
#line 415
  if (! utmpok) {
#line 416
    return (-1);
  } else
#line 415
  if (wi->w_type != 0) {
#line 416
    return (-1);
  }
  {
#line 417
  slot = TtyNameSlot(wi->w_tty);
  }
#line 417
  if ((unsigned long )slot == (unsigned long )((slot_t )0)) {
    {
#line 419
    while (1) {
      while_continue: /* CIL Label */ ;
#line 419
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 420
    return (-1);
  }
  {
#line 422
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 422
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 424
  bzero((void *)((char *)(& u)), (size_t )sizeof(u));
#line 425
  saved_ut = bcmp((void const   *)((char *)(& wi->w_savut)), (void const   *)((char *)(& u)),
                  (size_t )sizeof(u));
  }
#line 425
  if (saved_ut) {
    {
#line 427
    bcopy((void const   *)((char *)(& wi->w_savut)), (void *)((char *)(& u)), (size_t )sizeof(u));
    }
  }
#line 429
  if (! saved_ut) {
    {
#line 430
    tmp = stripdev(wi->w_tty);
#line 430
    makeuser(& u, tmp, LoginName, wi->w_pid);
    }
  }
#line 433
  host[sizeof(host) - 15UL] = (char )'\000';
#line 434
  if (display) {
    {
#line 436
    strncpy((char */* __restrict  */)(host), (char const   */* __restrict  */)(display->d_utmp_logintty.ut_host),
            (size_t )(sizeof(host) - 15UL));
    }
#line 437
    if ((unsigned long )display->d_loginslot != (unsigned long )((slot_t )0)) {
#line 437
      if ((unsigned long )display->d_loginslot != (unsigned long )((slot_t )-1)) {
#line 437
        if ((int )host[0] != 0) {
#line 447
          p = host;
          {
#line 447
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 447
            if (! *p) {
#line 447
              goto while_break___1;
            }
#line 448
            if ((int )*p < 48) {
#line 448
              goto _L;
            } else
#line 448
            if ((int )*p > 57) {
              _L: /* CIL Label */ 
#line 448
              if ((int )*p != 46) {
#line 449
                goto while_break___1;
              }
            }
#line 447
            p ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 450
          if (*p) {
#line 452
            p = host;
            {
#line 452
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 452
              if (! *p) {
#line 452
                goto while_break___2;
              }
#line 453
              if ((int )*p == 46) {
#line 455
                *p = (char )'\000';
#line 456
                goto while_break___2;
              } else
#line 453
              if ((int )*p == 58) {
#line 453
                if ((unsigned long )p != (unsigned long )(host)) {
#line 455
                  *p = (char )'\000';
#line 456
                  goto while_break___2;
                }
              }
#line 452
              p ++;
            }
            while_break___2: /* CIL Label */ ;
            }
          }
        } else {
          {
#line 462
          tmp___0 = stripdev(display->d_usertty);
#line 462
          strncpy((char */* __restrict  */)(host + 1), (char const   */* __restrict  */)tmp___0,
                  (size_t )((sizeof(host) - 15UL) - 1UL));
#line 463
          host[0] = (char )':';
          }
        }
      } else {
        {
#line 462
        tmp___0 = stripdev(display->d_usertty);
#line 462
        strncpy((char */* __restrict  */)(host + 1), (char const   */* __restrict  */)tmp___0,
                (size_t )((sizeof(host) - 15UL) - 1UL));
#line 463
        host[0] = (char )':';
        }
      }
    } else {
      {
#line 462
      tmp___0 = stripdev(display->d_usertty);
#line 462
      strncpy((char */* __restrict  */)(host + 1), (char const   */* __restrict  */)tmp___0,
              (size_t )((sizeof(host) - 15UL) - 1UL));
#line 463
      host[0] = (char )':';
      }
    }
  } else {
    {
#line 467
    strncpy((char */* __restrict  */)(host), (char const   */* __restrict  */)"local",
            (size_t )(sizeof(host) - 15UL));
    }
  }
  {
#line 469
  tmp___1 = strlen((char const   *)(host));
#line 469
  sprintf((char */* __restrict  */)(host + tmp___1), (char const   */* __restrict  */)":S.%d",
          wi->w_number);
  }
  {
#line 470
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 470
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 473
  strncpy((char */* __restrict  */)(u.ut_host), (char const   */* __restrict  */)(host),
          (size_t )sizeof(u.ut_host));
#line 477
  tmp___3 = pututslot(slot, & u, host, wi);
  }
#line 477
  if (tmp___3 == 0) {
    {
#line 479
    tmp___2 = __errno_location();
#line 479
    Msg(*tmp___2, (char *)"Could not write %s", UtmpName);
    }
#line 481
    return (-1);
  }
  {
#line 483
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 483
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 484
  wi->w_slot = slot;
#line 485
  bcopy((void const   *)((char *)(& u)), (void *)((char *)(& wi->w_savut)), (size_t )sizeof(u));
  }
#line 487
  return (0);
}
}
#line 495 "/home/pronto/abs/test-suite/screen-4.0.2/utmp.c"
int RemoveUtmp(struct win *wi ) 
{ 
  struct utmp u ;
  struct utmp *uu ;
  slot_t slot ;
  int *tmp ;
  int tmp___0 ;

  {
#line 502
  slot = wi->w_slot;
  {
#line 503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 503
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 504
  if (! utmpok) {
#line 505
    return (-1);
  }
#line 506
  if ((unsigned long )slot == (unsigned long )((slot_t )0)) {
#line 508
    wi->w_slot = (slot_t )-1;
#line 509
    return (0);
  } else
#line 506
  if ((unsigned long )slot == (unsigned long )((slot_t )-1)) {
#line 508
    wi->w_slot = (slot_t )-1;
#line 509
    return (0);
  }
  {
#line 511
  bzero((void *)((char *)(& u)), (size_t )sizeof(u));
#line 516
  uu = getutslot(slot);
  }
#line 516
  if ((unsigned long )uu == (unsigned long )((struct utmp *)0)) {
    {
#line 518
    Msg(0, (char *)"Utmp slot not found -> not removed");
    }
#line 519
    return (-1);
  }
  {
#line 521
  bcopy((void const   *)((char *)uu), (void *)((char *)(& wi->w_savut)), (size_t )sizeof(wi->w_savut));
#line 523
  u = *uu;
#line 524
  makedead(& u);
#line 525
  tmp___0 = pututslot(slot, & u, (char *)0, wi);
  }
#line 525
  if (tmp___0 == 0) {
    {
#line 527
    tmp = __errno_location();
#line 527
    Msg(*tmp, (char *)"Could not write %s", UtmpName);
    }
#line 529
    return (-1);
  }
  {
#line 531
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 531
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 532
  wi->w_slot = (slot_t )-1;
#line 534
  return (0);
}
}
#line 548 "/home/pronto/abs/test-suite/screen-4.0.2/utmp.c"
static struct utmp *getutslot(slot_t slot ) 
{ 
  struct utmp u ;
  struct utmp *tmp ;

  {
  {
#line 553
  bzero((void *)((char *)(& u)), (size_t )sizeof(u));
#line 554
  strncpy((char */* __restrict  */)(u.ut_line), (char const   */* __restrict  */)slot,
          (size_t )sizeof(u.ut_line));
#line 555
  setutent();
#line 556
  tmp = getutline((struct utmp  const  *)(& u));
  }
#line 556
  return (tmp);
}
}
#line 559 "/home/pronto/abs/test-suite/screen-4.0.2/utmp.c"
static int pututslot(slot_t slot , struct utmp *u , char *host , struct win *wi ) 
{ 
  struct utmp *tmp ;

  {
  {
#line 583
  setutent();
#line 584
  tmp = xpututline(u);
  }
#line 584
  return ((unsigned long )tmp != (unsigned long )((struct utmp *)0));
}
}
#line 587 "/home/pronto/abs/test-suite/screen-4.0.2/utmp.c"
static void makedead(struct utmp *u ) 
{ 


  {
#line 591
  u->ut_type = (short)8;
#line 593
  u->ut_exit.e_termination = (short)0;
#line 594
  u->ut_exit.e_exit = (short)0;
#line 597
  u->ut_user[0] = (char)0;
#line 599
  return;
}
}
#line 601 "/home/pronto/abs/test-suite/screen-4.0.2/utmp.c"
static void makeuser(struct utmp *u , char *line , char *user , int pid ) 
{ 


  {
  {
#line 607
  u->ut_type = (short)7;
#line 608
  strncpy((char */* __restrict  */)(u->ut_user), (char const   */* __restrict  */)user,
          (size_t )sizeof(u->ut_user));
#line 611
  strncpy((char */* __restrict  */)(u->ut_id), (char const   */* __restrict  */)(line + 3),
          (size_t )sizeof(u->ut_id));
#line 619
  strncpy((char */* __restrict  */)(u->ut_line), (char const   */* __restrict  */)line,
          (size_t )sizeof(u->ut_line));
#line 620
  u->ut_pid = pid;
#line 621
  time(& u->ut_tv.tv_sec);
  }
#line 622
  return;
}
}
#line 624 "/home/pronto/abs/test-suite/screen-4.0.2/utmp.c"
static slot_t TtyNameSlot(char *nam ) 
{ 
  char *tmp ;

  {
  {
#line 628
  tmp = stripdev(nam);
  }
#line 628
  return (tmp);
}
}
#line 865 "/home/pronto/abs/test-suite/screen-4.0.2/utmp.c"
static struct utmp *xpututline(struct utmp *u ) 
{ 
  struct utmp *u2 ;
  struct utmp *tmp ;
  struct utmp *tmp___0 ;

  {
  {
#line 870
  pututline((struct utmp  const  *)u);
#line 871
  setutent();
#line 872
  u2 = getutline((struct utmp  const  *)u);
  }
#line 873
  if ((unsigned long )u2 == (unsigned long )((struct utmp *)0)) {
#line 874
    if ((int )u->ut_type == 8) {
#line 874
      tmp = u;
    } else {
#line 874
      tmp = (struct utmp *)0;
    }
#line 874
    return (tmp);
  }
#line 875
  if ((int )u->ut_type == (int )u2->ut_type) {
#line 875
    tmp___0 = u;
  } else {
#line 875
    tmp___0 = (struct utmp *)0;
  }
#line 875
  return (tmp___0);
}
}
#line 143 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 418 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chown)(char const   *__file ,
                                                                                  __uid_t __owner ,
                                                                                  __gid_t __group ) ;
#line 480
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) execve)(char const   *__path ,
                                                                                   char * const  *__argv ,
                                                                                   char * const  *__envp ) ;
#line 49 "/home/pronto/abs/test-suite/screen-4.0.2/extern.h"
void WindowDied(struct win *p ) ;
#line 54
void ResetWindow(struct win *p ) ;
#line 60
void WNewAutoFlow(struct win *win , int on ) ;
#line 82
int OpenTTY(char *line , char *opt ) ;
#line 83
void InitTTY(struct mode *m___0 , int ttyflag ) ;
#line 135
int RemakeWindow(struct win *p ) ;
#line 141
void nwin_compose(struct NewWindow *def , struct NewWindow *new , struct NewWindow *res ) ;
#line 145
void CloseDevice(struct win *wp ) ;
#line 51 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
struct event logflushev ;
#line 72
static void WinProcess(char **bufpp , int *lenp ) ;
#line 73
static void WinRedisplayLine(int y , int from , int to , int isblank ) ;
#line 74
static void WinClearLine(int y , int xs , int xe , int bce ) ;
#line 75
static int WinRewrite(int y , int x1 , int x2 , struct mchar *rend , int doit ) ;
#line 76
static int WinResize(int wi , int he ) ;
#line 77
static void WinRestore(void) ;
#line 78
static int DoAutolf(char *buf___0 , int *lenp , int fr ) ;
#line 79
static void ZombieProcess(char **bufpp , int *lenp ) ;
#line 80
static void win_readev_fn(struct event *ev , char *data ) ;
#line 81
static void win_writeev_fn(struct event *ev , char *data ) ;
#line 82
static int muchpending(struct win *p , struct event *ev ) ;
#line 84
static void paste_slowev_fn(struct event *ev , char *data ) ;
#line 87
static void pseu_readev_fn(struct event *ev , char *data ) ;
#line 88
static void pseu_writeev_fn(struct event *ev , char *data ) ;
#line 90
static void win_silenceev_fn(struct event *ev , char *data ) ;
#line 92
static int OpenDevice(char **args , int lflag , int *typep , char **namep ) ;
#line 93
static int ForkWindow(struct win *win , char **args , char *ttyn ) ;
#line 95
static void zmodem_found(struct win *p , int send , char *bp , int len ) ;
#line 96
static void zmodem_fin(char *buf___0 , int len , char *data ) ;
#line 97
static int zmodem_parse(struct win *p , char *bp , int len ) ;
#line 102 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
int VerboseCreate  =    0;
#line 104 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
char DefaultShell[8]  = 
#line 104
  {      (char )'/',      (char )'b',      (char )'i',      (char )'n', 
        (char )'/',      (char )'s',      (char )'h',      (char )'\000'};
#line 105 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
static char DefaultPath[24]  = 
#line 105
  {      (char )':',      (char )'/',      (char )'u',      (char )'s', 
        (char )'r',      (char )'/',      (char )'u',      (char )'c', 
        (char )'b',      (char )':',      (char )'/',      (char )'b', 
        (char )'i',      (char )'n',      (char )':',      (char )'/', 
        (char )'u',      (char )'s',      (char )'r',      (char )'/', 
        (char )'b',      (char )'i',      (char )'n',      (char )'\000'};
#line 108 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
struct NewWindow nwin_undef  = 
#line 108
     {-1, (char *)0, (char **)0, (char *)0, (char *)0, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, (char *)0, (char *)0};
#line 133 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
struct NewWindow nwin_default  = 
#line 133
     {0, (char *)0, ShellArgs, (char *)0, screenterm, 0, 1, 1, 100, 0, 0, 0, 1, 0, 0,
    0, 1, 0, 0, (char *)0, (char *)0};
#line 158 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
struct NewWindow nwin_options  ;
#line 160 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
static int const_IOSIZE  =    4096;
#line 161 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
static int const_one  =    1;
#line 163 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
void nwin_compose(struct NewWindow *def , struct NewWindow *new , struct NewWindow *res ) 
{ 


  {
#line 168
  if (new->StartAt != nwin_undef.StartAt) {
#line 168
    res->StartAt = new->StartAt;
  } else {
#line 168
    res->StartAt = def->StartAt;
  }
#line 169
  if ((unsigned long )new->aka != (unsigned long )nwin_undef.aka) {
#line 169
    res->aka = new->aka;
  } else {
#line 169
    res->aka = def->aka;
  }
#line 170
  if ((unsigned long )new->args != (unsigned long )nwin_undef.args) {
#line 170
    res->args = new->args;
  } else {
#line 170
    res->args = def->args;
  }
#line 171
  if ((unsigned long )new->dir != (unsigned long )nwin_undef.dir) {
#line 171
    res->dir = new->dir;
  } else {
#line 171
    res->dir = def->dir;
  }
#line 172
  if ((unsigned long )new->term != (unsigned long )nwin_undef.term) {
#line 172
    res->term = new->term;
  } else {
#line 172
    res->term = def->term;
  }
#line 173
  if (new->aflag != nwin_undef.aflag) {
#line 173
    res->aflag = new->aflag;
  } else {
#line 173
    res->aflag = def->aflag;
  }
#line 174
  if (new->flowflag != nwin_undef.flowflag) {
#line 174
    res->flowflag = new->flowflag;
  } else {
#line 174
    res->flowflag = def->flowflag;
  }
#line 175
  if (new->lflag != nwin_undef.lflag) {
#line 175
    res->lflag = new->lflag;
  } else {
#line 175
    res->lflag = def->lflag;
  }
#line 176
  if (new->histheight != nwin_undef.histheight) {
#line 176
    res->histheight = new->histheight;
  } else {
#line 176
    res->histheight = def->histheight;
  }
#line 177
  if (new->monitor != nwin_undef.monitor) {
#line 177
    res->monitor = new->monitor;
  } else {
#line 177
    res->monitor = def->monitor;
  }
#line 178
  if (new->wlock != nwin_undef.wlock) {
#line 178
    res->wlock = new->wlock;
  } else {
#line 178
    res->wlock = def->wlock;
  }
#line 179
  if (new->silence != nwin_undef.silence) {
#line 179
    res->silence = new->silence;
  } else {
#line 179
    res->silence = def->silence;
  }
#line 180
  if (new->wrap != nwin_undef.wrap) {
#line 180
    res->wrap = new->wrap;
  } else {
#line 180
    res->wrap = def->wrap;
  }
#line 181
  if (new->Lflag != nwin_undef.Lflag) {
#line 181
    res->Lflag = new->Lflag;
  } else {
#line 181
    res->Lflag = def->Lflag;
  }
#line 182
  if (new->slow != nwin_undef.slow) {
#line 182
    res->slow = new->slow;
  } else {
#line 182
    res->slow = def->slow;
  }
#line 183
  if (new->gr != nwin_undef.gr) {
#line 183
    res->gr = new->gr;
  } else {
#line 183
    res->gr = def->gr;
  }
#line 184
  if (new->c1 != nwin_undef.c1) {
#line 184
    res->c1 = new->c1;
  } else {
#line 184
    res->c1 = def->c1;
  }
#line 185
  if (new->bce != nwin_undef.bce) {
#line 185
    res->bce = new->bce;
  } else {
#line 185
    res->bce = def->bce;
  }
#line 186
  if (new->encoding != nwin_undef.encoding) {
#line 186
    res->encoding = new->encoding;
  } else {
#line 186
    res->encoding = def->encoding;
  }
#line 187
  if ((unsigned long )new->hstatus != (unsigned long )nwin_undef.hstatus) {
#line 187
    res->hstatus = new->hstatus;
  } else {
#line 187
    res->hstatus = def->hstatus;
  }
#line 188
  if ((unsigned long )new->charset != (unsigned long )nwin_undef.charset) {
#line 188
    res->charset = new->charset;
  } else {
#line 188
    res->charset = def->charset;
  }
#line 190
  return;
}
}
#line 197 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
struct LayFuncs WinLf  =    {& WinProcess, (void (*)(void))0, & WinRedisplayLine, & WinClearLine, & WinRewrite,
    & WinResize, & WinRestore};
#line 208 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
static int DoAutolf(char *buf___0 , int *lenp , int fr ) 
{ 
  char *p ;
  int len ;
  int trunc ;
  int tmp ;
  int tmp___0 ;

  {
#line 215
  len = *lenp;
#line 216
  trunc = 0;
#line 218
  p = buf___0;
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 218
    if (! (len > 0)) {
#line 218
      goto while_break;
    }
#line 220
    if ((int )*p != 13) {
#line 221
      goto __Cont;
    }
#line 222
    tmp = fr;
#line 222
    fr --;
#line 222
    if (tmp <= 0) {
#line 224
      trunc ++;
#line 225
      len --;
    }
#line 227
    if (len == 0) {
#line 228
      goto while_break;
    }
    {
#line 229
    tmp___0 = len;
#line 229
    len ++;
#line 229
    bcopy((void const   *)p, (void *)(p + 1), (size_t )tmp___0);
#line 230
    *(p + 1) = (char )'\n';
    }
    __Cont: /* CIL Label */ 
#line 218
    p ++;
#line 218
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 232
  *lenp = (int )(p - buf___0);
#line 233
  return (trunc);
}
}
#line 236 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
static void WinProcess(char **bufpp , int *lenp ) 
{ 
  int l2 ;
  int f ;
  int *ilen ;
  int l ;
  int trunc ;
  char *ibuf ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 241
  l2 = 0;
#line 241
  l = *lenp;
  {
#line 244
  while (1) {
    while_continue: /* CIL Label */ ;
#line 244
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 245
  fore = (struct win *)flayer->l_data;
#line 247
  if (fore->w_ptyfd < 0) {
    {
#line 249
    ZombieProcess(bufpp, lenp);
    }
#line 250
    return;
  }
#line 257
  if (display) {
#line 257
    if (fore->w_wlock == 1) {
#line 257
      if (! fore->w_wlockuser) {
        {
#line 257
        tmp = AclCheckPermWin(display->d_user, 1, fore);
        }
#line 257
        if (! tmp) {
#line 260
          fore->w_wlockuser = display->d_user;
          {
#line 261
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 261
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
    }
  }
#line 265
  if (display) {
#line 265
    if (fore->w_wlock == 0) {
      {
#line 265
      tmp___0 = AclCheckPermWin(display->d_user, 1, fore);
#line 265
      tmp___1 = tmp___0;
      }
    } else {
#line 265
      tmp___1 = (unsigned long )display->d_user != (unsigned long )fore->w_wlockuser;
    }
#line 265
    if (tmp___1) {
      {
#line 269
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 269
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 270
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 270
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 273
      WBell(fore, visual_bell);
#line 274
      *bufpp += *lenp;
#line 275
      *lenp = 0;
      }
#line 276
      return;
    }
  }
#line 289
  if (fore->w_pwin) {
#line 289
    if ((fore->w_pwin)->p_fdpat & 4096) {
#line 292
      ibuf = (fore->w_pwin)->p_inbuf;
#line 292
      ilen = & (fore->w_pwin)->p_inlen;
#line 293
      f = (int )(sizeof((fore->w_pwin)->p_inbuf) - (unsigned long )*ilen);
    } else {
#line 299
      ibuf = fore->w_inbuf;
#line 299
      ilen = & fore->w_inlen;
#line 300
      f = (int )(sizeof(fore->w_inbuf) - (unsigned long )*ilen);
    }
  } else {
#line 299
    ibuf = fore->w_inbuf;
#line 299
    ilen = & fore->w_inlen;
#line 300
    f = (int )(sizeof(fore->w_inbuf) - (unsigned long )*ilen);
  }
#line 303
  if (l > f) {
#line 304
    l = f;
  }
#line 308
  if (l > 0) {
    {
#line 311
    l2 = l;
#line 312
    bcopy((void const   *)*bufpp, (void *)(ibuf + *ilen), (size_t )l2);
    }
#line 313
    if (fore->w_autolf) {
      {
#line 313
      trunc = DoAutolf(ibuf + *ilen, & l2, f - l2);
      }
#line 313
      if (trunc) {
#line 314
        l -= trunc;
      }
    }
#line 323
    *ilen += l2;
#line 324
    *bufpp += l;
#line 325
    *lenp -= l;
#line 326
    return;
  }
#line 328
  return;
}
}
#line 330 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
static void ZombieProcess(char **bufpp , int *lenp ) 
{ 
  int l ;
  char *buf___0 ;
  char b1[10] ;
  char b2[10] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 335
  l = *lenp;
#line 336
  buf___0 = *bufpp;
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 339
  fore = (struct win *)flayer->l_data;
  {
#line 341
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 341
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 342
  *bufpp += *lenp;
#line 343
  *lenp = 0;
  {
#line 344
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 344
    tmp = l;
#line 344
    l --;
#line 344
    if (! (tmp > 0)) {
#line 344
      goto while_break___1;
    }
#line 346
    if ((int )*((unsigned char *)buf___0) == ZombieKey_destroy) {
      {
#line 348
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 348
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 349
      KillWindow(fore);
      }
#line 350
      return;
    }
#line 352
    if ((int )*((unsigned char *)buf___0) == ZombieKey_resurrect) {
      {
#line 354
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 354
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 355
      WriteString(fore, (char *)"\r\n", 2);
#line 356
      RemakeWindow(fore);
      }
#line 357
      return;
    }
#line 344
    buf___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 360
  tmp___0 = AddXChar(b1, ZombieKey_destroy);
#line 360
  b1[tmp___0] = (char )'\000';
#line 361
  tmp___1 = AddXChar(b2, ZombieKey_resurrect);
#line 361
  b2[tmp___1] = (char )'\000';
#line 362
  Msg(0, (char *)"Press %s to destroy or %s to resurrect window", b1, b2);
  }
#line 363
  return;
}
}
#line 365 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
static void WinRedisplayLine(int y , int from , int to , int isblank ) 
{ 


  {
  {
#line 369
  while (1) {
    while_continue: /* CIL Label */ ;
#line 369
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 370
  if (y < 0) {
#line 371
    return;
  }
#line 372
  fore = (struct win *)flayer->l_data;
#line 373
  if (from == 0) {
#line 373
    if (y > 0) {
#line 373
      if ((int )*((fore->w_mlines + (y - 1))->image + fore->w_layer.l_width) == 0) {
        {
#line 374
        LCDisplayLineWrap(& fore->w_layer, fore->w_mlines + y, y, from, to, isblank);
        }
      } else {
        {
#line 376
        LCDisplayLine(& fore->w_layer, fore->w_mlines + y, y, from, to, isblank);
        }
      }
    } else {
      {
#line 376
      LCDisplayLine(& fore->w_layer, fore->w_mlines + y, y, from, to, isblank);
      }
    }
  } else {
    {
#line 376
    LCDisplayLine(& fore->w_layer, fore->w_mlines + y, y, from, to, isblank);
    }
  }
#line 377
  return;
}
}
#line 379 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
static int WinRewrite(int y , int x1 , int x2 , struct mchar *rend , int doit ) 
{ 
  register int cost ;
  register int dx ;
  register unsigned char *p ;
  register unsigned char *i ;
  register unsigned char *f ;
  register unsigned char *c ;
  unsigned char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 396
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 397
  fore = (struct win *)flayer->l_data;
#line 398
  dx = (x2 - x1) + 1;
#line 399
  if (doit) {
#line 401
    i = (fore->w_mlines + y)->image + x1;
    {
#line 402
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 402
      tmp___0 = dx;
#line 402
      dx --;
#line 402
      if (! (tmp___0 > 0)) {
#line 402
        goto while_break___0;
      }
      {
#line 403
      tmp = i;
#line 403
      i ++;
#line 403
      PUTCHAR((int )*tmp);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 404
    return (0);
  }
#line 406
  p = (fore->w_mlines + y)->attr + x1;
#line 408
  f = (fore->w_mlines + y)->font + x1;
#line 410
  if (rend->font) {
#line 410
    if (((int )rend->font & 96) == 0) {
#line 411
      return (1000);
    }
  }
#line 414
  if (fore->w_layer.l_encoding) {
#line 414
    if (fore->w_layer.l_encoding != 8) {
#line 414
      if (display->d_encoding == 8) {
        {
#line 414
        tmp___1 = ContainsSpecialDeffont(fore->w_mlines + y, x1, x2, fore->w_layer.l_encoding);
        }
#line 414
        if (tmp___1) {
#line 415
          return (1000);
        }
      }
    }
  }
#line 419
  c = (fore->w_mlines + y)->color + x1;
#line 425
  dx = (x2 - x1) + 1;
#line 425
  cost = dx;
  {
#line 426
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 426
    tmp___5 = dx;
#line 426
    dx --;
#line 426
    if (! (tmp___5 > 0)) {
#line 426
      goto while_break___1;
    }
#line 428
    tmp___2 = p;
#line 428
    p ++;
#line 428
    if ((int )*tmp___2 != (int )rend->attr) {
#line 429
      return (1000);
    }
#line 431
    tmp___3 = f;
#line 431
    f ++;
#line 431
    if ((int )*tmp___3 != (int )rend->font) {
#line 432
      return (1000);
    }
#line 435
    tmp___4 = c;
#line 435
    c ++;
#line 435
    if ((int )*tmp___4 != (int )rend->color) {
#line 436
      return (1000);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 443
  return (cost);
}
}
#line 446 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
static void WinClearLine(int y , int xs , int xe , int bce ) 
{ 


  {
#line 450
  fore = (struct win *)flayer->l_data;
  {
#line 451
  while (1) {
    while_continue: /* CIL Label */ ;
#line 451
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 452
  LClearLine(flayer, y, xs, xe, bce, fore->w_mlines + y);
  }
#line 453
  return;
}
}
#line 455 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
static int WinResize(int wi , int he ) 
{ 


  {
  {
#line 459
  fore = (struct win *)flayer->l_data;
#line 460
  ChangeWindowSize(fore, wi, he, fore->w_histheight);
  }
#line 461
  return (0);
}
}
#line 464 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
static void WinRestore(void) 
{ 
  struct canvas *cv ;
  int tmp ;

  {
#line 468
  fore = (struct win *)flayer->l_data;
  {
#line 469
  while (1) {
    while_continue: /* CIL Label */ ;
#line 469
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 470
  cv = flayer->l_cvlist;
  {
#line 470
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 470
    if (! cv) {
#line 470
      goto while_break___0;
    }
#line 472
    display = cv->c_display;
#line 473
    if ((unsigned long )cv != (unsigned long )display->d_forecv) {
#line 474
      goto __Cont;
    }
    {
#line 476
    KeypadMode(fore->w_keypad);
#line 477
    CursorkeysMode(fore->w_cursorkeys);
#line 478
    SetFlow(fore->w_flow & 1);
#line 479
    InsertMode(fore->w_insert);
#line 480
    ReverseVideo(fore->w_revvid);
    }
#line 481
    if (fore->w_curinv) {
#line 481
      tmp = -1;
    } else {
#line 481
      tmp = fore->w_curvvis;
    }
    {
#line 481
    CursorVisibility(tmp);
#line 482
    MouseMode(fore->w_mouse);
    }
    __Cont: /* CIL Label */ 
#line 470
    cv = cv->c_next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 484
  return;
}
}
#line 495 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
int DoStartLog(struct win *w , char *buf___0 , int bufsize ) 
{ 
  int n ;
  char *tmp ;
  struct logfile *tmp___0 ;
  FILE *tmp___2 ;
  FILE *tmp___3 ;
  int tmp___4 ;

  {
#line 502
  if (! w) {
#line 503
    return (-1);
  } else
#line 502
  if (! buf___0) {
#line 503
    return (-1);
  }
  {
#line 505
  tmp = MakeWinMsg(screenlogfile, w, '%');
#line 505
  strncpy((char */* __restrict  */)buf___0, (char const   */* __restrict  */)tmp,
          (size_t )(bufsize - 1));
#line 506
  *(buf___0 + (bufsize - 1)) = (char)0;
  }
  {
#line 508
  while (1) {
    while_continue: /* CIL Label */ ;
#line 508
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 510
  if ((unsigned long )w->w_log != (unsigned long )((void *)0)) {
    {
#line 511
    logfclose(w->w_log);
    }
  }
  {
#line 513
  tmp___4 = islogfile(buf___0);
  }
#line 513
  if (tmp___4) {
#line 513
    tmp___3 = (FILE *)((void *)0);
  } else {
    {
#line 513
    tmp___2 = secfopen(buf___0, (char *)"a");
#line 513
    tmp___3 = tmp___2;
    }
  }
  {
#line 513
  tmp___0 = logfopen(buf___0, tmp___3);
#line 513
  w->w_log = tmp___0;
  }
#line 513
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 514
    return (-2);
  }
#line 515
  if (! logflushev.queued) {
#line 517
    if (log_flush) {
#line 517
      n = log_flush;
    } else {
#line 517
      n = (logtstamp_after + 4) / 5;
    }
#line 518
    if (n) {
      {
#line 520
      SetTimeout(& logflushev, n * 1000);
#line 521
      evenq(& logflushev);
      }
    }
  }
#line 524
  return (0);
}
}
#line 531 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
int MakeWindow(struct NewWindow *newwin ) 
{ 
  register struct win **pp ;
  register struct win *p ;
  register int n ;
  register int i ;
  int f ;
  struct NewWindow nwin ;
  int type ;
  int startat ;
  char *TtyName___0 ;
  void *tmp ;
  struct acluser *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  struct display *d ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  char buf___0[1024] ;
  int tmp___12 ;
  char *tmp___13 ;

  {
#line 537
  f = -1;
  {
#line 545
  while (1) {
    while_continue: /* CIL Label */ ;
#line 545
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 546
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 546
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 547
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 547
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 548
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 548
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 550
  nwin_compose(& nwin_default, newwin, & nwin);
  }
  {
#line 551
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 551
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 552
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 552
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 553
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 553
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 555
  if (nwin.StartAt < maxwin) {
#line 555
    startat = nwin.StartAt;
  } else {
#line 555
    startat = 0;
  }
#line 556
  pp = wtab + startat;
  {
#line 558
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 560
    if ((unsigned long )*pp == (unsigned long )((struct win *)0)) {
#line 561
      goto while_break___6;
    }
#line 562
    pp ++;
#line 562
    if ((unsigned long )pp == (unsigned long )(wtab + maxwin)) {
#line 563
      pp = wtab;
    }
#line 558
    if (! ((unsigned long )pp != (unsigned long )(wtab + startat))) {
#line 558
      goto while_break___6;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 566
  if (*pp) {
    {
#line 568
    Msg(0, (char *)"No more windows.");
    }
#line 569
    return (-1);
  }
#line 582
  n = (int )(pp - wtab);
  {
#line 583
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 583
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 585
  f = OpenDevice(nwin.args, nwin.lflag, & type, & TtyName___0);
  }
#line 585
  if (f < 0) {
#line 586
    return (-1);
  }
  {
#line 588
  tmp = malloc((size_t )sizeof(struct win ));
#line 588
  p = (struct win *)tmp;
  }
#line 588
  if ((unsigned long )p == (unsigned long )((struct win *)0)) {
    {
#line 590
    close(f);
#line 591
    Msg(0, strnomem);
    }
#line 592
    return (-1);
  }
  {
#line 594
  bzero((void *)((char *)p), (size_t )((int )sizeof(struct win )));
  }
#line 597
  if (type != 0) {
#line 598
    nwin.lflag = 0;
  }
#line 601
  p->w_type = type;
#line 604
  i = 0;
  {
#line 604
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 604
    if (*(nwin.args + i)) {
#line 604
      if (! (i < 63)) {
#line 604
        goto while_break___8;
      }
    } else {
#line 604
      goto while_break___8;
    }
    {
#line 605
    p->w_cmdargs[i] = SaveStr((char const   *)*(nwin.args + i));
#line 604
    i ++;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
#line 606
  p->w_cmdargs[i] = (char *)0;
#line 607
  if (nwin.dir) {
    {
#line 608
    p->w_dir = SaveStr((char const   *)nwin.dir);
    }
  }
#line 609
  if (nwin.term) {
    {
#line 610
    p->w_term = SaveStr((char const   *)nwin.term);
    }
  }
#line 612
  p->w_number = n;
#line 619
  if (display) {
#line 619
    tmp___0 = display->d_user;
  } else {
#line 619
    tmp___0 = users;
  }
  {
#line 619
  tmp___1 = NewWindowAcl(p, tmp___0);
  }
#line 619
  if (tmp___1) {
    {
#line 621
    free((void *)((char *)p));
#line 622
    close(f);
#line 623
    Msg(0, strnomem);
    }
#line 624
    return (-1);
  }
#line 627
  p->w_layer.l_next = (struct layer *)0;
#line 628
  p->w_layer.l_bottom = & p->w_layer;
#line 629
  p->w_layer.l_layfn = & WinLf;
#line 630
  p->w_layer.l_data = (char *)p;
#line 631
  p->w_savelayer = & p->w_layer;
#line 632
  p->w_pdisplay = (struct display *)0;
#line 633
  p->w_lastdisp = (struct display *)0;
#line 636
  if (display) {
    {
#line 636
    tmp___2 = AclCheckPermWin(display->d_user, 1, p);
    }
#line 636
    if (! tmp___2) {
#line 637
      p->w_wlockuser = display->d_user;
    }
  }
#line 638
  p->w_wlock = nwin.wlock;
#line 640
  p->w_ptyfd = f;
#line 641
  p->w_aflag = nwin.aflag;
#line 642
  if (nwin.flowflag & (1 << 2)) {
#line 642
    tmp___3 = (1 << 1) | 1;
  } else {
#line 642
    tmp___3 = 1 << 1;
  }
#line 642
  p->w_flow = nwin.flowflag | tmp___3;
#line 643
  if (! nwin.aka) {
    {
#line 644
    nwin.aka = Filename(*(nwin.args + 0));
    }
  }
  {
#line 645
  strncpy((char */* __restrict  */)(p->w_akabuf), (char const   */* __restrict  */)nwin.aka,
          (size_t )(sizeof(p->w_akabuf) - 1UL));
#line 646
  nwin.aka = rindex((char const   *)(p->w_akabuf), '|');
  }
#line 646
  if ((unsigned long )nwin.aka != (unsigned long )((void *)0)) {
    {
#line 648
    p->w_autoaka = 0;
#line 649
    tmp___4 = nwin.aka;
#line 649
    (nwin.aka) ++;
#line 649
    *tmp___4 = (char)0;
#line 650
    p->w_title = nwin.aka;
#line 651
    tmp___5 = strlen((char const   *)nwin.aka);
#line 651
    p->w_akachange = nwin.aka + tmp___5;
    }
  } else {
#line 654
    tmp___6 = p->w_akabuf;
#line 654
    p->w_akachange = tmp___6;
#line 654
    p->w_title = tmp___6;
  }
#line 655
  if (nwin.hstatus) {
    {
#line 656
    p->w_hstatus = SaveStr((char const   *)nwin.hstatus);
    }
  }
#line 657
  p->w_monitor = nwin.monitor;
#line 659
  if (p->w_monitor == 1) {
#line 662
    i = 0;
    {
#line 662
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 662
      if (! (i < maxusercount)) {
#line 662
        goto while_break___9;
      }
#line 663
      *(p->w_mon_notify + (i >> 3)) = (unsigned char )((int )*(p->w_mon_notify + (i >> 3)) | (128 >> (i & 7)));
#line 662
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
  }
#line 669
  p->w_silence = nwin.silence;
#line 670
  p->w_silencewait = SilenceWait;
#line 672
  if (p->w_silence == 1) {
#line 675
    i = 0;
    {
#line 675
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 675
      if (! (i < maxusercount)) {
#line 675
        goto while_break___10;
      }
#line 676
      *(p->w_lio_notify + (i >> 3)) = (unsigned char )((int )*(p->w_lio_notify + (i >> 3)) | (128 >> (i & 7)));
#line 675
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
  }
  {
#line 680
  p->w_slowpaste = nwin.slow;
#line 685
  p->w_norefresh = (char)0;
#line 686
  strncpy((char */* __restrict  */)(p->w_tty), (char const   */* __restrict  */)TtyName___0,
          (size_t )255);
  }
#line 698
  if (display) {
#line 698
    tmp___7 = ((display->d_forecv)->c_ye - (display->d_forecv)->c_ys) + 1;
  } else {
#line 698
    tmp___7 = 24;
  }
#line 698
  if (display) {
#line 698
    tmp___8 = ((display->d_forecv)->c_xe - (display->d_forecv)->c_xs) + 1;
  } else {
#line 698
    tmp___8 = 80;
  }
  {
#line 698
  tmp___9 = ChangeWindowSize(p, tmp___8, tmp___7, nwin.histheight);
  }
#line 698
  if (tmp___9) {
    {
#line 702
    FreeWindow(p);
    }
#line 703
    return (-1);
  }
  {
#line 707
  p->w_layer.l_encoding = nwin.encoding;
#line 708
  ResetWindow(p);
  }
#line 711
  if (nwin.charset) {
    {
#line 712
    SetCharsets(p, nwin.charset);
    }
  }
#line 715
  if (VerboseCreate) {
    {
#line 717
    d = display;
#line 719
    WriteString(p, (char *)":screen (", 9);
#line 720
    tmp___10 = strlen((char const   *)p->w_title);
#line 720
    WriteString(p, p->w_title, (int )tmp___10);
#line 721
    WriteString(p, (char *)"):", 2);
#line 722
    f = 0;
    }
    {
#line 722
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 722
      if (! p->w_cmdargs[f]) {
#line 722
        goto while_break___11;
      }
      {
#line 724
      WriteString(p, (char *)" ", 1);
#line 725
      tmp___11 = strlen((char const   *)p->w_cmdargs[f]);
#line 725
      WriteString(p, p->w_cmdargs[f], (int )tmp___11);
#line 722
      f ++;
      }
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 727
    WriteString(p, (char *)"\r\n", 2);
#line 728
    display = d;
    }
  }
#line 731
  p->w_pid = 0;
#line 733
  p->w_pwin = (struct pseudowin *)0;
#line 747
  if (type == 0) {
    {
#line 749
    p->w_pid = ForkWindow(p, nwin.args, TtyName___0);
    }
#line 750
    if (p->w_pid < 0) {
      {
#line 752
      FreeWindow(p);
      }
#line 753
      return (-1);
    }
  }
#line 760
  if (display) {
#line 760
    if (display->d_fore) {
#line 761
      display->d_other = display->d_fore;
    }
  }
#line 762
  *pp = p;
#line 763
  p->w_next = windows;
#line 764
  windows = p;
#line 765
  p->w_lflag = nwin.lflag;
#line 767
  p->w_slot = (slot_t )-1;
  {
#line 769
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 769
    goto while_break___12;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 770
  if (nwin.lflag & 1) {
#line 776
    p->w_slot = (slot_t )0;
#line 777
    if (display) {
      {
#line 778
      SetUtmp(p);
      }
    } else
#line 777
    if (p->w_lflag & 2) {
      {
#line 778
      SetUtmp(p);
      }
    }
  }
#line 785
  if (nwin.Lflag) {
    {
#line 788
    DoStartLog(p, buf___0, (int )sizeof(buf___0));
    }
  }
  {
#line 791
  tmp___12 = p->w_ptyfd;
#line 791
  p->w_writeev.fd = tmp___12;
#line 791
  p->w_readev.fd = tmp___12;
#line 792
  p->w_readev.type = 1;
#line 793
  p->w_writeev.type = 2;
#line 794
  tmp___13 = (char *)p;
#line 794
  p->w_writeev.data = tmp___13;
#line 794
  p->w_readev.data = tmp___13;
#line 795
  p->w_readev.handler = & win_readev_fn;
#line 796
  p->w_writeev.handler = & win_writeev_fn;
#line 797
  p->w_writeev.condpos = & p->w_inlen;
#line 798
  evenq(& p->w_readev);
#line 799
  evenq(& p->w_writeev);
#line 801
  p->w_paster.pa_slowev.type = 0;
#line 802
  p->w_paster.pa_slowev.data = (char *)(& p->w_paster);
#line 803
  p->w_paster.pa_slowev.handler = & paste_slowev_fn;
#line 805
  p->w_silenceev.type = 0;
#line 806
  p->w_silenceev.data = (char *)p;
#line 807
  p->w_silenceev.handler = & win_silenceev_fn;
  }
#line 808
  if (p->w_silence > 0) {
    {
#line 810
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 810
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
    {
#line 811
    SetTimeout(& p->w_silenceev, p->w_silencewait * 1000);
#line 812
    evenq(& p->w_silenceev);
    }
  }
  {
#line 815
  SetForeWindow(p);
#line 816
  Activate((int )p->w_norefresh);
#line 817
  WindowChanged((struct win *)0, 'w');
#line 818
  WindowChanged((struct win *)0, 'W');
#line 819
  WindowChanged((struct win *)0, 0);
  }
#line 820
  return (n);
}
}
#line 829 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
int RemakeWindow(struct win *p ) 
{ 
  char *TtyName___0 ;
  int lflag ;
  int f ;
  char *tmp ;
  struct display *d ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 836
  lflag = nwin_default.lflag;
#line 837
  f = OpenDevice(p->w_cmdargs, lflag, & p->w_type, & TtyName___0);
  }
#line 837
  if (f < 0) {
#line 838
    return (-1);
  }
#line 840
  if (*TtyName___0) {
#line 840
    tmp = TtyName___0;
  } else {
#line 840
    tmp = p->w_title;
  }
  {
#line 840
  strncpy((char */* __restrict  */)(p->w_tty), (char const   */* __restrict  */)tmp,
          (size_t )255);
#line 841
  p->w_ptyfd = f;
#line 842
  p->w_readev.fd = f;
#line 843
  p->w_writeev.fd = f;
#line 844
  evenq(& p->w_readev);
#line 845
  evenq(& p->w_writeev);
  }
#line 847
  if (VerboseCreate) {
    {
#line 849
    d = display;
#line 851
    WriteString(p, (char *)":screen (", 9);
#line 852
    tmp___0 = strlen((char const   *)p->w_title);
#line 852
    WriteString(p, p->w_title, (int )tmp___0);
#line 853
    WriteString(p, (char *)"):", 2);
#line 854
    f = 0;
    }
    {
#line 854
    while (1) {
      while_continue: /* CIL Label */ ;
#line 854
      if (! p->w_cmdargs[f]) {
#line 854
        goto while_break;
      }
      {
#line 856
      WriteString(p, (char *)" ", 1);
#line 857
      tmp___1 = strlen((char const   *)p->w_cmdargs[f]);
#line 857
      WriteString(p, p->w_cmdargs[f], (int )tmp___1);
#line 854
      f ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 859
    WriteString(p, (char *)"\r\n", 2);
#line 860
    display = d;
    }
  }
#line 863
  p->w_pid = 0;
#line 872
  if (p->w_type == 0) {
    {
#line 874
    p->w_pid = ForkWindow(p, p->w_cmdargs, TtyName___0);
    }
#line 875
    if (p->w_pid < 0) {
#line 876
      return (-1);
    }
  }
#line 880
  if ((unsigned long )p->w_slot == (unsigned long )((slot_t )0)) {
#line 880
    if (display) {
      {
#line 881
      SetUtmp(p);
      }
    } else
#line 880
    if (p->w_lflag & 2) {
      {
#line 881
      SetUtmp(p);
      }
    }
  }
  {
#line 886
  WindowChanged(p, 'f');
  }
#line 887
  return (p->w_number);
}
}
#line 890 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
void CloseDevice(struct win *wp ) 
{ 
  int tmp ;

  {
#line 894
  if (wp->w_ptyfd < 0) {
#line 895
    return;
  }
#line 896
  if (wp->w_type == 0) {
    {
#line 899
    chmod((char const   *)(wp->w_tty), (__mode_t )438);
#line 900
    chown((char const   *)(wp->w_tty), (__uid_t )0, (__gid_t )0);
    }
  }
  {
#line 902
  close(wp->w_ptyfd);
#line 903
  wp->w_ptyfd = -1;
#line 904
  wp->w_tty[0] = (char)0;
#line 905
  evdeq(& wp->w_readev);
#line 906
  evdeq(& wp->w_writeev);
#line 910
  tmp = -1;
#line 910
  wp->w_writeev.fd = tmp;
#line 910
  wp->w_readev.fd = tmp;
  }
#line 911
  return;
}
}
#line 913 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
void FreeWindow(struct win *wp ) 
{ 
  struct display *d ;
  int i ;
  struct canvas *cv ;
  struct canvas *ncv ;
  struct layer *l ;

  {
  {
#line 922
  while (1) {
    while_continue: /* CIL Label */ ;
#line 922
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 924
  if (wp->w_pwin) {
    {
#line 925
    FreePseudowin(wp);
    }
  }
  {
#line 928
  RemoveUtmp(wp);
#line 930
  CloseDevice(wp);
  }
#line 932
  if ((unsigned long )wp == (unsigned long )console_window) {
    {
#line 934
    TtyGrabConsole(-1, -1, (char *)"free");
#line 935
    console_window = (struct win *)0;
    }
  }
#line 937
  if ((unsigned long )wp->w_log != (unsigned long )((void *)0)) {
    {
#line 938
    logfclose(wp->w_log);
    }
  }
  {
#line 939
  ChangeWindowSize(wp, 0, 0, 0);
  }
#line 941
  if (wp->w_hstatus) {
    {
#line 942
    free((void *)wp->w_hstatus);
    }
  }
#line 943
  i = 0;
  {
#line 943
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 943
    if (! wp->w_cmdargs[i]) {
#line 943
      goto while_break___0;
    }
    {
#line 944
    free((void *)wp->w_cmdargs[i]);
#line 943
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 945
  if (wp->w_dir) {
    {
#line 946
    free((void *)wp->w_dir);
    }
  }
#line 947
  if (wp->w_term) {
    {
#line 948
    free((void *)wp->w_term);
    }
  }
#line 949
  d = displays;
  {
#line 949
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 949
    if (! d) {
#line 949
      goto while_break___1;
    }
#line 951
    if ((unsigned long )d->d_other == (unsigned long )wp) {
#line 952
      if (d->d_fore) {
#line 952
        if ((unsigned long )(d->d_fore)->w_next != (unsigned long )wp) {
#line 952
          d->d_other = (d->d_fore)->w_next;
        } else {
#line 952
          d->d_other = wp->w_next;
        }
      } else {
#line 952
        d->d_other = wp->w_next;
      }
    }
#line 953
    if ((unsigned long )d->d_fore == (unsigned long )wp) {
#line 954
      d->d_fore = (struct win *)((void *)0);
    }
#line 955
    cv = d->d_cvlist;
    {
#line 955
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 955
      if (! cv) {
#line 955
        goto while_break___2;
      }
#line 957
      l = cv->c_layer;
      {
#line 957
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 957
        if (! l) {
#line 957
          goto while_break___3;
        }
#line 958
        if ((unsigned long )l->l_layfn == (unsigned long )(& WinLf)) {
#line 959
          goto while_break___3;
        }
#line 957
        l = l->l_next;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 960
      if (! l) {
#line 961
        goto __Cont;
      }
#line 962
      if ((unsigned long )((struct win *)l->l_data) != (unsigned long )wp) {
#line 963
        goto __Cont;
      }
#line 964
      if ((unsigned long )cv->c_layer == (unsigned long )wp->w_savelayer) {
#line 965
        wp->w_savelayer = (struct layer *)0;
      }
      {
#line 966
      KillLayerChain(cv->c_layer);
      }
      __Cont: /* CIL Label */ 
#line 955
      cv = cv->c_next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 949
    d = d->d_next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 969
  if (wp->w_savelayer) {
    {
#line 970
    KillLayerChain(wp->w_savelayer);
    }
  }
#line 971
  cv = wp->w_layer.l_cvlist;
  {
#line 971
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 971
    if (! cv) {
#line 971
      goto while_break___4;
    }
    {
#line 973
    ncv = cv->c_lnext;
#line 974
    cv->c_layer = & cv->c_blank;
#line 975
    cv->c_blank.l_cvlist = cv;
#line 976
    cv->c_lnext = (struct canvas *)0;
#line 977
    cv->c_xoff = cv->c_xs;
#line 978
    cv->c_yoff = cv->c_ys;
#line 979
    RethinkViewportOffsets(cv);
#line 971
    cv = ncv;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 981
  wp->w_layer.l_cvlist = (struct canvas *)0;
#line 982
  if ((unsigned long )flayer == (unsigned long )(& wp->w_layer)) {
#line 983
    flayer = (struct layer *)0;
  }
  {
#line 986
  FreeWindowAcl(wp);
#line 988
  evdeq(& wp->w_readev);
#line 989
  evdeq(& wp->w_writeev);
#line 990
  evdeq(& wp->w_silenceev);
#line 992
  FreePaster(& wp->w_paster);
#line 994
  free((void *)((char *)wp));
  }
#line 995
  return;
}
}
#line 997 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
static int OpenDevice(char **args , int lflag , int *typep , char **namep ) 
{ 
  char *arg ;
  struct stat st ;
  int f ;
  int *tmp ;
  int tmp___0 ;
  int flag ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 1004
  arg = *(args + 0);
#line 1008
  if (! arg) {
#line 1009
    return (-1);
  }
  {
#line 1020
  tmp___3 = stat((char const   */* __restrict  */)arg, (struct stat */* __restrict  */)(& st));
  }
#line 1020
  if (tmp___3 == 0) {
#line 1020
    if ((st.st_mode & 61440U) == 8192U) {
      {
#line 1022
      tmp___0 = access((char const   *)arg, 6);
      }
#line 1022
      if (tmp___0 == -1) {
        {
#line 1024
        tmp = __errno_location();
#line 1024
        Msg(*tmp, (char *)"Cannot access line \'%s\' for R/W", arg);
        }
#line 1025
        return (-1);
      }
      {
#line 1027
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1027
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1028
      f = OpenTTY(arg, *(args + 1));
      }
#line 1028
      if (f < 0) {
#line 1029
        return (-1);
      }
#line 1030
      lflag = 0;
#line 1031
      *typep = 1;
#line 1032
      *namep = arg;
    } else {
#line 1020
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 1036
    *typep = 0;
#line 1037
    f = OpenPTY(namep);
    }
#line 1038
    if (f == -1) {
      {
#line 1040
      Msg(0, (char *)"No more PTYs.");
      }
#line 1041
      return (-1);
    }
    {
#line 1045
    flag = 1;
#line 1046
    tmp___2 = ioctl(f, 21536UL, (char *)(& flag));
    }
#line 1046
    if (tmp___2) {
      {
#line 1048
      tmp___1 = __errno_location();
#line 1048
      Msg(*tmp___1, (char *)"TIOCPKT ioctl");
#line 1049
      close(f);
      }
#line 1050
      return (-1);
    }
  }
  {
#line 1055
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1055
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1056
  fcntl(f, 4, 2048);
  }
#line 1074
  if (*typep == 0) {
    {
#line 1075
    tcflush(f, 2);
    }
  } else
#line 1074
  if (*typep == 1) {
    {
#line 1075
    tcflush(f, 2);
    }
  }
#line 1078
  if (*typep != 0) {
#line 1079
    return (f);
  }
  {
#line 1083
  tmp___5 = chown((char const   *)*namep, (__uid_t )real_uid, (__gid_t )5);
  }
#line 1083
  if (tmp___5) {
#line 1083
    if (! eff_uid) {
      {
#line 1088
      tmp___4 = __errno_location();
#line 1088
      Msg(*tmp___4, (char *)"chown tty");
#line 1089
      close(f);
      }
#line 1090
      return (-1);
    }
  }
#line 1093
  if (lflag) {
#line 1093
    tmp___7 = TtyMode;
  } else {
#line 1093
    tmp___7 = TtyMode & -19;
  }
  {
#line 1093
  tmp___8 = chmod((char const   *)*namep, (__mode_t )tmp___7);
  }
#line 1093
  if (tmp___8) {
#line 1093
    if (! eff_uid) {
      {
#line 1098
      tmp___6 = __errno_location();
#line 1098
      Msg(*tmp___6, (char *)"chmod tty");
#line 1099
      close(f);
      }
#line 1100
      return (-1);
    }
  }
#line 1103
  return (f);
}
}
#line 1113 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
static int ForkWindow(struct win *win , char **args , char *ttyn ) 
{ 
  int pid ;
  char tebuf[25] ;
  char ebuf[10] ;
  char shellbuf[4103] ;
  char *proc ;
  int newfd ;
  int w ;
  int h ;
  int i ;
  int pat ;
  int wfdused ;
  struct pseudowin *pwin ;
  int slave ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  struct mode fakemode ;
  struct mode *modep ;
  int *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *s1 ;
  char *s2 ;
  char tl ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  size_t tmp___16 ;
  int *tmp___17 ;

  {
#line 1127
  w = win->w_layer.l_width;
#line 1128
  h = win->w_layer.l_height;
#line 1131
  pwin = win->w_pwin;
#line 1133
  slave = -1;
#line 1136
  if (pty_preopen) {
    {
#line 1138
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1138
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1139
    slave = open((char const   *)ttyn, 258);
    }
#line 1139
    if (slave == -1) {
      {
#line 1141
      tmp = __errno_location();
#line 1141
      Msg(*tmp, (char *)"ttyn");
      }
#line 1142
      return (-1);
    }
  }
  {
#line 1146
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1146
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1147
  proc = *args;
#line 1148
  if ((unsigned long )proc == (unsigned long )((char *)0)) {
#line 1150
    args = ShellArgs;
#line 1151
    proc = *args;
  }
  {
#line 1153
  fflush(stdout);
#line 1154
  fflush(stderr);
#line 1155
  pid = fork();
  }
  {
#line 1157
  if (pid == -1) {
#line 1157
    goto case_neg_1;
  }
#line 1160
  if (pid == 0) {
#line 1160
    goto case_0;
  }
#line 1382
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 1158
  tmp___0 = __errno_location();
#line 1158
  Msg(*tmp___0, (char *)"fork");
  }
#line 1159
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1161
  xsignal(1, (void (*)(int  ))0);
#line 1162
  xsignal(2, (void (*)(int  ))0);
#line 1163
  xsignal(3, (void (*)(int  ))0);
#line 1164
  xsignal(15, (void (*)(int  ))0);
#line 1166
  xsignal(21, (void (*)(int  ))0);
#line 1167
  xsignal(22, (void (*)(int  ))0);
#line 1170
  xsignal(13, (void (*)(int  ))0);
#line 1173
  xsignal(25, (void (*)(int  ))0);
#line 1176
  displays = (struct display *)0;
#line 1177
  tmp___2 = setgid((__gid_t )real_gid);
  }
#line 1177
  if (tmp___2) {
    {
#line 1178
    tmp___1 = __errno_location();
#line 1178
    Panic(*tmp___1, (char *)"Setuid/gid");
    }
  } else {
    {
#line 1177
    tmp___3 = setuid((__uid_t )real_uid);
    }
#line 1177
    if (tmp___3) {
      {
#line 1178
      tmp___1 = __errno_location();
#line 1178
      Panic(*tmp___1, (char *)"Setuid/gid");
      }
    }
  }
#line 1179
  eff_uid = real_uid;
#line 1180
  eff_gid = real_gid;
#line 1182
  if (! pwin) {
#line 1184
    if (win->w_dir) {
#line 1184
      if (*(win->w_dir)) {
        {
#line 1184
        tmp___5 = chdir((char const   *)win->w_dir);
        }
#line 1184
        if (tmp___5) {
          {
#line 1185
          tmp___4 = __errno_location();
#line 1185
          Panic(*tmp___4, (char *)"Cannot chdir to %s", win->w_dir);
          }
        }
      }
    }
  }
#line 1187
  if (display) {
    {
#line 1189
    brktty(display->d_userfd);
#line 1190
    freetty();
    }
  } else {
    {
#line 1193
    brktty(-1);
    }
  }
#line 1198
  if (slave != -1) {
    {
#line 1200
    close(0);
#line 1201
    dup(slave);
#line 1202
    close(slave);
#line 1203
    closeallfiles(win->w_ptyfd);
#line 1204
    slave = dup(0);
    }
  } else {
    {
#line 1207
    closeallfiles(win->w_ptyfd);
    }
  }
  {
#line 1222
  close(0);
#line 1223
  close(1);
#line 1224
  close(2);
#line 1225
  newfd = -1;
  }
#line 1230
  if (pwin) {
#line 1230
    pat = pwin->p_fdpat;
  } else {
#line 1230
    pat = ((1 << 4) | (1 << 2)) | 1;
  }
  {
#line 1232
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1232
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1233
  wfdused = 0;
#line 1234
  i = 0;
  {
#line 1234
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1234
    if (! (i < 3)) {
#line 1234
      goto while_break___2;
    }
#line 1236
    if (pat & (1 << 2 * i)) {
#line 1238
      if (newfd < 0) {
#line 1241
        if (separate_sids) {
          {
#line 1242
          newfd = open((char const   *)ttyn, 2);
          }
        } else {
          {
#line 1244
          newfd = open((char const   *)ttyn, 258);
          }
        }
#line 1248
        if (newfd < 0) {
          {
#line 1249
          tmp___6 = __errno_location();
#line 1249
          Panic(*tmp___6, (char *)"Cannot open %s", ttyn);
          }
        }
      } else {
        {
#line 1252
        dup(newfd);
        }
      }
    } else {
      {
#line 1256
      dup(win->w_ptyfd);
#line 1257
      wfdused = 1;
      }
    }
#line 1234
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1260
  if (wfdused) {
    {
#line 1266
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1266
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 1267
    tmp___8 = fcntl(win->w_ptyfd, 4, 0);
    }
#line 1267
    if (tmp___8) {
      {
#line 1268
      tmp___7 = __errno_location();
#line 1268
      Msg(*tmp___7, (char *)"Warning: clear NBLOCK fcntl failed");
      }
    }
  }
  {
#line 1284
  close(win->w_ptyfd);
  }
#line 1285
  if (slave != -1) {
    {
#line 1286
    close(slave);
    }
  }
#line 1287
  if (newfd >= 0) {
    {
#line 1290
    InitPTY(newfd);
#line 1291
    tmp___10 = fgtty(newfd);
    }
#line 1291
    if (tmp___10) {
      {
#line 1292
      tmp___9 = __errno_location();
#line 1292
      Msg(*tmp___9, (char *)"fgtty");
      }
    }
#line 1293
    if (display) {
      {
#line 1295
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1295
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1296
      modep = & display->d_OldMode;
    } else {
      {
#line 1300
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1300
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 1301
      modep = & fakemode;
#line 1302
      InitTTY(modep, 0);
      }
    }
#line 1311
    if (pwin) {
#line 1311
      if (! (pat & 4096)) {
#line 1311
        goto _L;
      } else
#line 1311
      if (pat & (2 << 2)) {
        _L: /* CIL Label */ 
        {
#line 1313
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1313
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 1315
        modep->tio.c_lflag &= 4294967287U;
#line 1316
        modep->tio.c_iflag &= 4294967039U;
      }
    }
    {
#line 1322
    SetTTY(newfd, modep);
#line 1324
    glwz.ws_col = (unsigned short )w;
#line 1325
    glwz.ws_row = (unsigned short )h;
#line 1326
    ioctl(newfd, 21524UL, (char *)(& glwz));
#line 1329
    fcntl(newfd, 4, 0);
    }
  }
#line 1338
  if ((unsigned long )display == (unsigned long )((struct display *)0)) {
#line 1338
    tmp___11 = 1;
  } else
#line 1338
  if (win->w_aflag) {
#line 1338
    tmp___11 = 1;
  } else {
#line 1338
    tmp___11 = 0;
  }
  {
#line 1338
  *(NewEnv + 2) = MakeTermcap(tmp___11);
#line 1345
  strcpy((char */* __restrict  */)(shellbuf), (char const   */* __restrict  */)"SHELL=");
#line 1346
  strncpy((char */* __restrict  */)(shellbuf + 6), (char const   */* __restrict  */)(ShellProg + ((int )*ShellProg == 45)),
          (size_t )(sizeof(shellbuf) - 7UL));
#line 1347
  shellbuf[sizeof(shellbuf) - 1UL] = (char)0;
#line 1348
  *(NewEnv + 4) = shellbuf;
  }
  {
#line 1349
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1349
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 1350
  if (win->w_term) {
#line 1350
    if (*(win->w_term)) {
      {
#line 1350
      tmp___15 = strcmp((char const   *)(screenterm), (char const   *)win->w_term);
      }
#line 1350
      if (tmp___15) {
        {
#line 1350
        tmp___16 = strlen((char const   *)win->w_term);
        }
#line 1350
        if (tmp___16 < 20U) {
          {
#line 1355
          sprintf((char */* __restrict  */)(tebuf), (char const   */* __restrict  */)"TERM=%s",
                  win->w_term);
          }
          {
#line 1356
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 1356
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
          {
#line 1357
          tmp___12 = strlen((char const   *)win->w_term);
#line 1357
          tl = (char )tmp___12;
#line 1358
          *(NewEnv + 1) = tebuf;
#line 1359
          s1 = index((char const   *)*(NewEnv + 2), '|');
          }
#line 1359
          if (s1) {
            {
#line 1361
            s1 ++;
#line 1361
            s2 = index((char const   *)s1, '|');
            }
#line 1361
            if (s2) {
              {
#line 1363
              tmp___14 = strlen((char const   *)*(NewEnv + 2));
              }
#line 1363
              if (((long )tmp___14 - (s2 - s1)) + (long )tl < 1024L) {
                {
#line 1365
                tmp___13 = strlen((char const   *)s2);
#line 1365
                bcopy((void const   *)s2, (void *)(s1 + (int )tl), tmp___13 + 1U);
#line 1366
                bcopy((void const   *)win->w_term, (void *)s1, (size_t )tl);
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 1371
  sprintf((char */* __restrict  */)(ebuf), (char const   */* __restrict  */)"WINDOW=%d",
          win->w_number);
#line 1372
  *(NewEnv + 3) = ebuf;
  }
#line 1374
  if ((int )*proc == 45) {
#line 1375
    proc ++;
  }
#line 1376
  if (! *proc) {
#line 1377
    proc = DefaultShell;
  }
  {
#line 1378
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 1378
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 1379
  execvpe(proc, args, NewEnv);
  }
  {
#line 1380
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 1380
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 1381
  tmp___17 = __errno_location();
#line 1381
  Panic(*tmp___17, (char *)"Cannot exec \'%s\'", proc);
  }
  switch_default: /* CIL Label */ 
#line 1383
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1385
  if (slave != -1) {
    {
#line 1386
    close(slave);
    }
  }
#line 1387
  return (pid);
}
}
#line 1390 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
void execvpe(char *prog , char **args , char **env ) 
{ 
  register char *path ;
  register char *p ;
  char buf___0[1024] ;
  char *shargs[65] ;
  register int i ;
  register int eaccess ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;

  {
  {
#line 1394
  path = (char *)((void *)0);
#line 1397
  eaccess = 0;
#line 1399
  tmp = rindex((char const   *)prog, '/');
  }
#line 1399
  if (tmp) {
#line 1400
    path = (char *)"";
  }
#line 1401
  if (! path) {
    {
#line 1401
    path = getenv("PATH");
    }
#line 1401
    if (! path) {
#line 1402
      path = DefaultPath;
    }
  }
  {
#line 1403
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1405
    p = buf___0;
    {
#line 1405
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1405
      if (*path) {
#line 1405
        if (! ((int )*path != 58)) {
#line 1405
          goto while_break___0;
        }
      } else {
#line 1405
        goto while_break___0;
      }
#line 1406
      if (p - buf___0 < (long )((int )sizeof(buf___0) - 2)) {
#line 1407
        tmp___0 = p;
#line 1407
        p ++;
#line 1407
        *tmp___0 = *path;
      }
#line 1405
      path ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1408
    if ((unsigned long )p > (unsigned long )(buf___0)) {
#line 1409
      tmp___1 = p;
#line 1409
      p ++;
#line 1409
      *tmp___1 = (char )'/';
    }
    {
#line 1410
    tmp___2 = strlen((char const   *)prog);
    }
#line 1410
    if ((unsigned long )((p - buf___0) + (long )tmp___2) >= sizeof(buf___0) - 1UL) {
#line 1411
      goto __Cont;
    }
    {
#line 1412
    strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)prog);
#line 1413
    execve((char const   *)(buf___0), (char * const  *)args, (char * const  *)env);
#line 1414
    tmp___3 = __errno_location();
    }
    {
#line 1416
    if (*tmp___3 == 8) {
#line 1416
      goto case_8;
    }
#line 1423
    if (*tmp___3 == 13) {
#line 1423
      goto case_13;
    }
#line 1428
    if (*tmp___3 == 26) {
#line 1428
      goto case_26;
    }
#line 1428
    if (*tmp___3 == 7) {
#line 1428
      goto case_26;
    }
#line 1428
    if (*tmp___3 == 12) {
#line 1428
      goto case_26;
    }
#line 1414
    goto switch_break;
    case_8: /* CIL Label */ 
#line 1417
    shargs[0] = DefaultShell;
#line 1418
    shargs[1] = buf___0;
#line 1419
    i = 1;
    {
#line 1419
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1419
      tmp___4 = *(args + i);
#line 1419
      shargs[i + 1] = tmp___4;
#line 1419
      if (! ((unsigned long )tmp___4 != (unsigned long )((void *)0))) {
#line 1419
        goto while_break___1;
      }
#line 1419
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1421
    execve((char const   *)(DefaultShell), (char * const  *)(shargs), (char * const  *)env);
    }
#line 1422
    return;
    case_13: /* CIL Label */ 
#line 1424
    eaccess = 1;
#line 1425
    goto switch_break;
    case_26: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_12: /* CIL Label */ 
#line 1429
    return;
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 1403
    tmp___5 = path;
#line 1403
    path ++;
#line 1403
    if (! *tmp___5) {
#line 1403
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1432
  if (eaccess) {
    {
#line 1433
    tmp___6 = __errno_location();
#line 1433
    *tmp___6 = 13;
    }
  }
#line 1434
  return;
}
}
#line 1438 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
int winexec(char **av ) 
{ 
  char **pp ;
  char *p ;
  char *s ;
  char *t ;
  int i ;
  int r ;
  int l ;
  struct win *w ;
  struct pseudowin *pwin ;
  int type ;
  char const   *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int flag ;
  int *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;

  {
#line 1444
  r = 0;
#line 1444
  l = 0;
#line 1451
  if (display) {
#line 1451
    w = fore;
  } else {
#line 1451
    w = windows;
  }
#line 1451
  if ((unsigned long )w == (unsigned long )((void *)0)) {
#line 1452
    return (-1);
  }
#line 1453
  if (! *av) {
#line 1453
    goto _L;
  } else
#line 1453
  if (w->w_pwin) {
    _L: /* CIL Label */ 
#line 1455
    if (w->w_pwin) {
#line 1455
      tmp = (char const   *)((w->w_pwin)->p_cmd);
    } else {
#line 1455
      tmp = "(none)";
    }
    {
#line 1455
    Msg(0, (char *)"Filter running: %s", tmp);
    }
#line 1456
    return (-1);
  }
#line 1458
  if (w->w_ptyfd < 0) {
    {
#line 1460
    Msg(0, (char *)"You feel dead inside.");
    }
#line 1461
    return (-1);
  }
  {
#line 1463
  tmp___0 = malloc((size_t )sizeof(struct pseudowin ));
#line 1463
  pwin = (struct pseudowin *)tmp___0;
  }
#line 1463
  if (! pwin) {
    {
#line 1465
    Msg(0, strnomem);
    }
#line 1466
    return (-1);
  }
  {
#line 1468
  bzero((void *)((char *)pwin), (size_t )((int )sizeof(*pwin)));
#line 1471
  s = *av;
  }
  {
#line 1471
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1471
    if (! ((int )*s == 32)) {
#line 1471
      goto while_break;
    }
#line 1471
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1473
  p = s;
  {
#line 1473
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1473
    if (! ((int )*p == 58)) {
#line 1473
      if (! ((int )*p == 46)) {
#line 1473
        if (! ((int )*p == 33)) {
#line 1473
          goto while_break___0;
        }
      }
    }
#line 1473
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1475
  if ((int )*p != 124) {
    {
#line 1476
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1476
      if (*p) {
#line 1476
        if ((unsigned long )p > (unsigned long )s) {
#line 1476
          if (! ((int )*(p + -1) == 46)) {
#line 1476
            goto while_break___1;
          }
        } else {
#line 1476
          goto while_break___1;
        }
      } else {
#line 1476
        goto while_break___1;
      }
#line 1477
      p --;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1478
  if ((int )*p == 124) {
#line 1480
    l = 4096;
#line 1481
    p ++;
  }
#line 1483
  if (*p) {
#line 1484
    *(av + 0) = p;
  } else {
#line 1486
    av ++;
  }
#line 1488
  t = pwin->p_cmd;
#line 1489
  i = 0;
  {
#line 1489
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1489
    if (! (i < 3)) {
#line 1489
      goto while_break___2;
    }
#line 1491
    if ((unsigned long )s < (unsigned long )p) {
#line 1491
      tmp___1 = s;
#line 1491
      s ++;
#line 1491
      *t = *tmp___1;
    } else {
#line 1491
      *t = (char )'.';
    }
#line 1492
    tmp___2 = t;
#line 1492
    t ++;
    {
#line 1495
    if ((int )*tmp___2 == 124) {
#line 1495
      goto case_124;
    }
#line 1495
    if ((int )*tmp___2 == 46) {
#line 1495
      goto case_124;
    }
#line 1498
    if ((int )*tmp___2 == 33) {
#line 1498
      goto case_33;
    }
#line 1501
    if ((int )*tmp___2 == 58) {
#line 1501
      goto case_58;
    }
#line 1492
    goto switch_break;
    case_124: /* CIL Label */ 
    case_46: /* CIL Label */ 
#line 1496
    l |= 1 << i * 2;
#line 1497
    goto switch_break;
    case_33: /* CIL Label */ 
#line 1499
    l |= 2 << i * 2;
#line 1500
    goto switch_break;
    case_58: /* CIL Label */ 
#line 1502
    l |= 3 << i * 2;
#line 1503
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1489
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1507
  if (l & 4096) {
#line 1509
    tmp___3 = t;
#line 1509
    t ++;
#line 1509
    *tmp___3 = (char )'|';
#line 1510
    if ((l & 3) == 1) {
#line 1512
      pwin->p_cmd[0] = (char )'!';
#line 1513
      l ^= 3;
    }
  }
#line 1516
  if (! (l & 2)) {
#line 1517
    l |= 4096;
  }
#line 1518
  tmp___4 = t;
#line 1518
  t ++;
#line 1518
  *tmp___4 = (char )' ';
#line 1519
  pwin->p_fdpat = l;
  {
#line 1520
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1520
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1522
  l = 252;
#line 1523
  pp = av;
  {
#line 1523
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1523
    if (! *pp) {
#line 1523
      goto while_break___4;
    }
#line 1525
    p = *pp;
    {
#line 1526
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1526
      if (*p) {
#line 1526
        tmp___7 = l;
#line 1526
        l --;
#line 1526
        if (! (tmp___7 > 0)) {
#line 1526
          goto while_break___5;
        }
      } else {
#line 1526
        goto while_break___5;
      }
#line 1527
      tmp___5 = t;
#line 1527
      t ++;
#line 1527
      tmp___6 = p;
#line 1527
      p ++;
#line 1527
      *tmp___5 = *tmp___6;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1528
    if (l <= 0) {
#line 1529
      goto while_break___4;
    }
#line 1530
    tmp___8 = t;
#line 1530
    t ++;
#line 1530
    *tmp___8 = (char )' ';
#line 1523
    pp ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1532
  t --;
#line 1532
  *t = (char )'\000';
  {
#line 1533
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1533
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 1535
  tmp___9 = OpenDevice(av, 0, & type, & t);
#line 1535
  pwin->p_ptyfd = tmp___9;
  }
#line 1535
  if (tmp___9 < 0) {
    {
#line 1537
    free((void *)((char *)pwin));
    }
#line 1538
    return (-1);
  }
  {
#line 1540
  strncpy((char */* __restrict  */)(pwin->p_tty), (char const   */* __restrict  */)t,
          (size_t )255);
#line 1541
  w->w_pwin = pwin;
  }
#line 1542
  if (type != 0) {
    {
#line 1544
    FreePseudowin(w);
#line 1545
    Msg(0, (char *)"Cannot only use commands as pseudo win.");
    }
#line 1546
    return (-1);
  }
#line 1548
  if (! (pwin->p_fdpat & 1)) {
    {
#line 1549
    evdeq(& w->w_readev);
    }
  }
  {
#line 1552
  flag = 0;
#line 1554
  tmp___11 = ioctl(pwin->p_ptyfd, 21536UL, (char *)(& flag));
  }
#line 1554
  if (tmp___11) {
    {
#line 1556
    tmp___10 = __errno_location();
#line 1556
    Msg(*tmp___10, (char *)"TIOCPKT pwin ioctl");
#line 1557
    FreePseudowin(w);
    }
#line 1558
    return (-1);
  }
#line 1560
  if (w->w_type == 0) {
#line 1560
    if (! (pwin->p_fdpat & 1)) {
      {
#line 1562
      tmp___13 = ioctl(w->w_ptyfd, 21536UL, (char *)(& flag));
      }
#line 1562
      if (tmp___13) {
        {
#line 1564
        tmp___12 = __errno_location();
#line 1564
        Msg(*tmp___12, (char *)"TIOCPKT win ioctl");
#line 1565
        FreePseudowin(w);
        }
#line 1566
        return (-1);
      }
    }
  }
#line 1572
  tmp___14 = pwin->p_ptyfd;
#line 1572
  pwin->p_writeev.fd = tmp___14;
#line 1572
  pwin->p_readev.fd = tmp___14;
#line 1573
  pwin->p_readev.type = 1;
#line 1574
  pwin->p_writeev.type = 2;
#line 1575
  tmp___15 = (char *)w;
#line 1575
  pwin->p_writeev.data = tmp___15;
#line 1575
  pwin->p_readev.data = tmp___15;
#line 1576
  pwin->p_readev.handler = & pseu_readev_fn;
#line 1577
  pwin->p_writeev.handler = & pseu_writeev_fn;
#line 1578
  pwin->p_writeev.condpos = & pwin->p_inlen;
#line 1579
  if (pwin->p_fdpat & ((1 << 4) | (1 << 2))) {
    {
#line 1580
    evenq(& pwin->p_readev);
    }
  }
  {
#line 1581
  evenq(& pwin->p_writeev);
#line 1582
  tmp___16 = ForkWindow(w, av, t);
#line 1582
  pwin->p_pid = tmp___16;
#line 1582
  r = tmp___16;
  }
#line 1583
  if (r < 0) {
    {
#line 1584
    FreePseudowin(w);
    }
  }
#line 1585
  return (r);
}
}
#line 1588 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
void FreePseudowin(struct win *w ) 
{ 
  struct pseudowin *pwin ;
  int *tmp ;
  int tmp___0 ;
  int flag ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
#line 1592
  pwin = w->w_pwin;
  {
#line 1594
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1594
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1595
  tmp___0 = fcntl(w->w_ptyfd, 4, 2048);
  }
#line 1595
  if (tmp___0) {
    {
#line 1596
    tmp = __errno_location();
#line 1596
    Msg(*tmp, (char *)"Warning: FreePseudowin: NBLOCK fcntl failed");
    }
  }
#line 1598
  if (w->w_type == 0) {
#line 1598
    if (! (pwin->p_fdpat & 1)) {
      {
#line 1600
      flag = 1;
#line 1601
      tmp___2 = ioctl(w->w_ptyfd, 21536UL, (char *)(& flag));
      }
#line 1601
      if (tmp___2) {
        {
#line 1602
        tmp___1 = __errno_location();
#line 1602
        Msg(*tmp___1, (char *)"Warning: FreePseudowin: TIOCPKT win ioctl");
        }
      }
    }
  }
  {
#line 1606
  chmod((char const   *)(pwin->p_tty), (__mode_t )438);
#line 1607
  chown((char const   *)(pwin->p_tty), (__uid_t )0, (__gid_t )0);
  }
#line 1608
  if (pwin->p_ptyfd >= 0) {
    {
#line 1609
    close(pwin->p_ptyfd);
    }
  }
  {
#line 1610
  evdeq(& pwin->p_readev);
#line 1611
  evdeq(& pwin->p_writeev);
  }
#line 1612
  if ((unsigned long )w->w_readev.condneg == (unsigned long )(& pwin->p_inlen)) {
#line 1613
    tmp___3 = (int *)0;
#line 1613
    w->w_readev.condneg = tmp___3;
#line 1613
    w->w_readev.condpos = tmp___3;
  }
  {
#line 1614
  evenq(& w->w_readev);
#line 1615
  free((void *)((char *)pwin));
#line 1616
  w->w_pwin = (struct pseudowin *)((void *)0);
  }
#line 1617
  return;
}
}
#line 1626 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
int ReleaseAutoWritelock(struct display *dis , struct win *w ) 
{ 
  struct display *d ;

  {
  {
#line 1631
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1631
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1635
  if (w->w_wlock == 1) {
#line 1635
    if ((unsigned long )w->w_wlockuser == (unsigned long )dis->d_user) {
#line 1639
      d = displays;
      {
#line 1639
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1639
        if (! d) {
#line 1639
          goto while_break___0;
        }
#line 1640
        if ((unsigned long )d != (unsigned long )dis) {
#line 1640
          if ((unsigned long )d->d_fore == (unsigned long )w) {
#line 1640
            if ((unsigned long )d->d_user == (unsigned long )dis->d_user) {
#line 1641
              goto while_break___0;
            }
          }
        }
#line 1639
        d = d->d_next;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1642
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1642
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1644
      if (! d) {
#line 1646
        w->w_wlockuser = (struct acluser *)((void *)0);
#line 1647
        return (0);
      }
    }
  }
#line 1650
  return (1);
}
}
#line 1656 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
int ObtainAutoWritelock(struct display *d , struct win *w ) 
{ 
  int tmp ;

  {
#line 1661
  if (w->w_wlock == 1) {
    {
#line 1661
    tmp = AclCheckPermWin(d->d_user, 1, w);
    }
#line 1661
    if (! tmp) {
#line 1661
      if (! w->w_wlockuser) {
        {
#line 1665
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1665
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
#line 1667
        w->w_wlockuser = d->d_user;
#line 1668
        return (0);
      }
    }
  }
#line 1670
  return (1);
}
}
#line 1680 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
static void paste_slowev_fn(struct event *ev , char *data ) 
{ 
  struct paster *pa ;
  struct win *p ;
  int l ;

  {
#line 1685
  pa = (struct paster *)data;
#line 1688
  l = 1;
#line 1689
  flayer = pa->pa_pastelayer;
#line 1690
  if (! flayer) {
#line 1691
    pa->pa_pastelen = 0;
  }
#line 1692
  if (! pa->pa_pastelen) {
#line 1693
    return;
  }
  {
#line 1694
  p = (struct win *)(flayer->l_bottom)->l_data;
#line 1695
  DoProcess(p, & pa->pa_pasteptr, & l, pa);
#line 1696
  pa->pa_pastelen -= 1 - l;
  }
#line 1697
  if (pa->pa_pastelen > 0) {
    {
#line 1699
    SetTimeout(& pa->pa_slowev, p->w_slowpaste);
#line 1700
    evenq(& pa->pa_slowev);
    }
  }
#line 1702
  return;
}
}
#line 1706 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
static int muchpending(struct win *p , struct event *ev ) 
{ 
  struct canvas *cv ;

  {
#line 1712
  cv = p->w_layer.l_cvlist;
  {
#line 1712
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1712
    if (! cv) {
#line 1712
      goto while_break;
    }
#line 1714
    display = cv->c_display;
#line 1715
    if (display->d_status == 1) {
#line 1715
      if (! display->d_status_bell) {
        {
#line 1718
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1718
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1719
        ev->condpos = & const_one;
#line 1720
        ev->condneg = & display->d_status;
#line 1721
        return (1);
      }
    }
    {
#line 1723
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1723
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1724
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1724
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1725
    if (display->d_blocked) {
#line 1726
      goto __Cont;
    }
#line 1727
    if (display->d_obufp - display->d_obuf > (long )(display->d_obufmax + display->d_blocked_fuzz)) {
#line 1729
      if (display->d_nonblock == 0) {
        {
#line 1731
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1731
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 1732
        display->d_blocked = 1;
#line 1733
        goto __Cont;
      }
      {
#line 1735
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1735
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1736
      ev->condpos = & display->d_obuffree;
#line 1737
      ev->condneg = & display->d_obuflenmax;
#line 1738
      if (display->d_nonblock > 0) {
#line 1738
        if (! display->d_blockedev.queued) {
          {
#line 1740
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 1740
            goto while_break___5;
          }
          while_break___5: /* CIL Label */ ;
          }
          {
#line 1741
          SetTimeout(& display->d_blockedev, display->d_nonblock);
#line 1742
          evenq(& display->d_blockedev);
          }
        }
      }
#line 1744
      return (1);
    }
    __Cont: /* CIL Label */ 
#line 1712
    cv = cv->c_lnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 1747
  return (0);
}
}
#line 1750 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
static void win_readev_fn(struct event *ev , char *data ) 
{ 
  struct win *p ;
  char buf___0[4096] ;
  char *bp ;
  int size ;
  int len ;
  int wtop ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
#line 1755
  p = (struct win *)data;
#line 1762
  bp = buf___0;
#line 1763
  size = 4096;
#line 1766
  if (p->w_pwin) {
#line 1766
    if (((p->w_pwin)->p_fdpat & 3) == 3) {
#line 1766
      tmp = 1;
    } else {
#line 1766
      tmp = 0;
    }
  } else {
#line 1766
    tmp = 0;
  }
#line 1766
  wtop = tmp;
#line 1767
  if (wtop) {
    {
#line 1769
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1769
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1770
    size = 4096 - (p->w_pwin)->p_inlen;
#line 1771
    if (size <= 0) {
#line 1773
      ev->condpos = & const_IOSIZE;
#line 1774
      ev->condneg = & (p->w_pwin)->p_inlen;
#line 1775
      return;
    }
  }
#line 1779
  if (p->w_layer.l_cvlist) {
    {
#line 1779
    tmp___0 = muchpending(p, ev);
    }
#line 1779
    if (tmp___0) {
#line 1780
      return;
    }
  }
#line 1782
  if (! p->w_zdisplay) {
#line 1784
    if (p->w_blocked) {
#line 1786
      ev->condpos = & const_one;
#line 1787
      ev->condneg = & p->w_blocked;
#line 1788
      return;
    }
  }
#line 1790
  if (ev->condpos) {
#line 1791
    tmp___1 = (int *)0;
#line 1791
    ev->condneg = tmp___1;
#line 1791
    ev->condpos = tmp___1;
  }
#line 1793
  len = p->w_outlen;
#line 1793
  if (len) {
    {
#line 1795
    p->w_outlen = 0;
#line 1796
    WriteString(p, p->w_outbuf, len);
    }
#line 1797
    return;
  }
  {
#line 1800
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1800
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1801
  len = read(ev->fd, (void *)(buf___0), (size_t )size);
  }
#line 1801
  if (len < 0) {
    {
#line 1803
    tmp___2 = __errno_location();
    }
#line 1803
    if (*tmp___2 == 4) {
#line 1804
      return;
    } else {
      {
#line 1803
      tmp___3 = __errno_location();
      }
#line 1803
      if (*tmp___3 == 11) {
#line 1804
        return;
      }
    }
    {
#line 1809
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1809
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1810
    WindowDied(p);
    }
#line 1811
    return;
  }
#line 1813
  if (len == 0) {
    {
#line 1815
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1815
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1816
    WindowDied(p);
    }
#line 1817
    return;
  }
  {
#line 1819
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1819
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1821
  if (p->w_type == 0) {
#line 1823
    if (buf___0[0]) {
      {
#line 1825
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1825
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1826
      if ((int )buf___0[0] & 16) {
        {
#line 1827
        WNewAutoFlow(p, 0);
        }
      }
#line 1828
      if ((int )buf___0[0] & 32) {
        {
#line 1829
        WNewAutoFlow(p, 1);
        }
      }
    }
#line 1831
    bp ++;
#line 1832
    len --;
  }
#line 1839
  if (len == 0) {
#line 1840
    return;
  }
#line 1842
  if (zmodem_mode) {
    {
#line 1842
    tmp___4 = zmodem_parse(p, bp, len);
    }
#line 1842
    if (tmp___4) {
#line 1843
      return;
    }
  }
#line 1846
  if (wtop) {
    {
#line 1848
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1848
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 1849
    bcopy((void const   *)bp, (void *)((p->w_pwin)->p_inbuf + (p->w_pwin)->p_inlen),
          (size_t )len);
#line 1850
    (p->w_pwin)->p_inlen += len;
    }
  }
  {
#line 1853
  WriteString(p, bp, len);
  }
#line 1854
  return;
}
}
#line 1858 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
static void win_writeev_fn(struct event *ev , char *data ) 
{ 
  struct win *p ;
  int len ;
  int tmp ;
  struct paster *pa ;

  {
#line 1863
  p = (struct win *)data;
#line 1865
  if (p->w_inlen) {
    {
#line 1867
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1867
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1868
    len = write(ev->fd, (void const   *)(p->w_inbuf), (size_t )p->w_inlen);
    }
#line 1868
    if (len <= 0) {
#line 1869
      len = p->w_inlen;
    }
#line 1870
    tmp = p->w_inlen - len;
#line 1870
    p->w_inlen = tmp;
#line 1870
    if (tmp) {
      {
#line 1871
      bcopy((void const   *)(p->w_inbuf + len), (void *)(p->w_inbuf), (size_t )p->w_inlen);
      }
    }
  }
#line 1874
  if (p->w_paster.pa_pastelen) {
#line 1874
    if (! p->w_slowpaste) {
#line 1876
      pa = & p->w_paster;
#line 1877
      flayer = pa->pa_pastelayer;
#line 1878
      if (flayer) {
        {
#line 1879
        DoProcess(p, & pa->pa_pasteptr, & pa->pa_pastelen, pa);
        }
      }
    }
  }
#line 1882
  return;
}
}
#line 1889 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
static void pseu_readev_fn(struct event *ev , char *data ) 
{ 
  struct win *p ;
  char buf___0[4096] ;
  int size ;
  int ptow ;
  int len ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 1894
  p = (struct win *)data;
#line 1898
  size = 4096;
#line 1900
  if (((p->w_pwin)->p_fdpat & (3 << 2)) == 3 << 2) {
#line 1900
    tmp = 1;
  } else
#line 1900
  if (((p->w_pwin)->p_fdpat & (3 << 4)) == 3 << 4) {
#line 1900
    tmp = 1;
  } else {
#line 1900
    tmp = 0;
  }
#line 1900
  ptow = tmp;
#line 1901
  if (ptow) {
    {
#line 1903
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1903
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1904
    size = 4096 - p->w_inlen;
#line 1905
    if (size <= 0) {
#line 1907
      ev->condpos = & const_IOSIZE;
#line 1908
      ev->condneg = & p->w_inlen;
#line 1909
      return;
    }
  }
#line 1912
  if (p->w_layer.l_cvlist) {
    {
#line 1912
    tmp___0 = muchpending(p, ev);
    }
#line 1912
    if (tmp___0) {
#line 1913
      return;
    }
  }
#line 1914
  if (p->w_blocked) {
#line 1916
    ev->condpos = & const_one;
#line 1917
    ev->condneg = & p->w_blocked;
#line 1918
    return;
  }
#line 1920
  if (ev->condpos) {
#line 1921
    tmp___1 = (int *)0;
#line 1921
    ev->condneg = tmp___1;
#line 1921
    ev->condpos = tmp___1;
  }
#line 1923
  len = p->w_outlen;
#line 1923
  if (len) {
    {
#line 1925
    p->w_outlen = 0;
#line 1926
    WriteString(p, p->w_outbuf, len);
    }
#line 1927
    return;
  }
  {
#line 1930
  len = read(ev->fd, (void *)(buf___0), (size_t )size);
  }
#line 1930
  if (len <= 0) {
    {
#line 1932
    tmp___2 = __errno_location();
    }
#line 1932
    if (*tmp___2 == 4) {
#line 1933
      return;
    } else {
      {
#line 1932
      tmp___3 = __errno_location();
      }
#line 1932
      if (*tmp___3 == 11) {
#line 1933
        return;
      }
    }
    {
#line 1938
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1938
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1939
    FreePseudowin(p);
    }
#line 1940
    return;
  }
#line 1943
  if (ptow) {
    {
#line 1945
    bcopy((void const   *)(buf___0), (void *)(p->w_inbuf + p->w_inlen), (size_t )len);
#line 1946
    p->w_inlen += len;
    }
  }
  {
#line 1948
  WriteString(p, buf___0, len);
  }
#line 1949
  return;
}
}
#line 1952 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
static void pseu_writeev_fn(struct event *ev , char *data ) 
{ 
  struct win *p ;
  struct pseudowin *pw ;
  int len ;
  int tmp ;

  {
#line 1957
  p = (struct win *)data;
#line 1958
  pw = p->w_pwin;
  {
#line 1961
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1961
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1962
  if (pw->p_inlen == 0) {
#line 1963
    return;
  }
  {
#line 1964
  len = write(ev->fd, (void const   *)(pw->p_inbuf), (size_t )pw->p_inlen);
  }
#line 1964
  if (len <= 0) {
#line 1965
    len = pw->p_inlen;
  }
#line 1966
  tmp = (p->w_pwin)->p_inlen - len;
#line 1966
  (p->w_pwin)->p_inlen = tmp;
#line 1966
  if (tmp) {
    {
#line 1967
    bcopy((void const   *)((p->w_pwin)->p_inbuf + len), (void *)((p->w_pwin)->p_inbuf),
          (size_t )(p->w_pwin)->p_inlen);
    }
  }
#line 1968
  return;
}
}
#line 1973 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
static void win_silenceev_fn(struct event *ev , char *data ) 
{ 
  struct win *p ;
  struct canvas *cv ;

  {
#line 1978
  p = (struct win *)data;
  {
#line 1980
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1980
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1981
  display = displays;
  {
#line 1981
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1981
    if (! display) {
#line 1981
      goto while_break___0;
    }
#line 1983
    cv = display->d_cvlist;
    {
#line 1983
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1983
      if (! cv) {
#line 1983
        goto while_break___1;
      }
#line 1984
      if ((unsigned long )(cv->c_layer)->l_bottom == (unsigned long )(& p->w_layer)) {
#line 1985
        goto while_break___1;
      }
#line 1983
      cv = cv->c_next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1986
    if (cv) {
#line 1987
      goto __Cont;
    }
#line 1989
    if (! ((int )*(p->w_lio_notify + ((display->d_user)->u_id >> 3)) & (128 >> ((display->d_user)->u_id & 7)))) {
#line 1990
      goto __Cont;
    }
    {
#line 1992
    Msg(0, (char *)"Window %d: silence for %d seconds", p->w_number, p->w_silencewait);
    }
    __Cont: /* CIL Label */ 
#line 1981
    display = display->d_next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1994
  return;
}
}
#line 1998 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
static int zmodem_parse(struct win *p , char *bp , int len ) 
{ 
  int i ;
  char *b2 ;
  int se ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
#line 2005
  b2 = bp;
#line 2006
  i = 0;
  {
#line 2006
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2006
    if (! (i < len)) {
#line 2006
      goto while_break;
    }
#line 2008
    if (p->w_zauto == 0) {
      {
#line 2010
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2010
        if (! (i < len)) {
#line 2010
          goto while_break___0;
        }
#line 2011
        if ((int )*b2 == 24) {
#line 2012
          goto while_break___0;
        }
#line 2010
        i ++;
#line 2010
        b2 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2013
      if (i == len) {
#line 2014
        goto while_break;
      }
#line 2015
      if (i > 1) {
#line 2015
        if ((int )*(b2 + -1) == 42) {
#line 2015
          if ((int )*(b2 + -2) == 42) {
#line 2016
            p->w_zauto = 3;
          }
        }
      }
#line 2017
      goto __Cont;
    }
#line 2019
    if (p->w_zauto > 5) {
#line 2019
      goto _L___0;
    } else
#line 2019
    if ((int )*b2 == (int )*("**\030B00" + p->w_zauto)) {
#line 2019
      goto _L___0;
    } else
#line 2019
    if (p->w_zauto == 5) {
#line 2019
      if ((int )*b2 == 49) {
#line 2019
        goto _L___0;
      } else {
#line 2019
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 2019
    if (p->w_zauto == 5) {
#line 2019
      if (p->w_zdisplay) {
#line 2019
        if ((int )*b2 == 56) {
          _L___0: /* CIL Label */ 
#line 2021
          (p->w_zauto) ++;
#line 2021
          if (p->w_zauto < 6) {
#line 2022
            goto __Cont;
          }
#line 2023
          if (p->w_zauto == 6) {
#line 2024
            p->w_zauto = 0;
          }
#line 2025
          if (! p->w_zdisplay) {
#line 2027
            if (i > 6) {
              {
#line 2028
              WriteString(p, bp, (i + 1) - 6);
              }
            }
            {
#line 2029
            WriteString(p, (char *)"\r\n", 2);
#line 2030
            zmodem_found(p, (int )*b2 == 49, b2 + 1, (len - i) - 1);
            }
#line 2031
            return (1);
          } else
#line 2033
          if (p->w_zauto == 7) {
#line 2033
            goto _L;
          } else
#line 2033
          if ((int )*b2 == 56) {
            _L: /* CIL Label */ 
#line 2035
            if ((p->w_zdisplay)->d_blocked == 2) {
#line 2035
              tmp = 'O';
            } else {
#line 2035
              tmp = '\212';
            }
#line 2035
            se = tmp;
            {
#line 2036
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 2036
              if (! (i < len)) {
#line 2036
                goto while_break___1;
              }
#line 2037
              if ((int )*b2 == se) {
#line 2038
                goto while_break___1;
              }
#line 2036
              i ++;
#line 2036
              b2 ++;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 2039
            if (i < len) {
              {
#line 2041
              zmodem_abort(p, (struct display *)0);
#line 2042
              display->d_blocked = 0;
#line 2043
              tmp___0 = (int *)0;
#line 2043
              display->d_readev.condneg = tmp___0;
#line 2043
              display->d_readev.condpos = tmp___0;
              }
              {
#line 2044
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 2044
                tmp___3 = len;
#line 2044
                len --;
#line 2044
                if (! (tmp___3 > 0)) {
#line 2044
                  goto while_break___2;
                }
                {
#line 2045
                while (1) {
                  while_continue___3: /* CIL Label */ ;
#line 2045
                  (display->d_obuffree) --;
#line 2045
                  if (display->d_obuffree <= 0) {
                    {
#line 2045
                    Resize_obuf();
                    }
                  }
#line 2045
                  tmp___1 = display->d_obufp;
#line 2045
                  (display->d_obufp) ++;
#line 2045
                  tmp___2 = bp;
#line 2045
                  bp ++;
#line 2045
                  *tmp___1 = *tmp___2;
#line 2045
                  goto while_break___3;
                }
                while_break___3: /* CIL Label */ ;
                }
              }
              while_break___2: /* CIL Label */ ;
              }
              {
#line 2046
              Flush();
              }
#line 2047
              if (display->d_fore) {
#line 2047
                tmp___4 = (int )(display->d_fore)->w_norefresh;
              } else {
#line 2047
                tmp___4 = 0;
              }
              {
#line 2047
              Activate(tmp___4);
              }
#line 2048
              return (1);
            }
#line 2050
            p->w_zauto = 6;
          }
        } else {
#line 2019
          goto _L___2;
        }
      } else {
#line 2019
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 2054
    if ((int )*b2 == 42) {
#line 2054
      if (p->w_zauto == 2) {
#line 2054
        tmp___5 = 2;
      } else {
#line 2054
        tmp___5 = 1;
      }
#line 2054
      p->w_zauto = tmp___5;
    } else {
#line 2054
      p->w_zauto = 0;
    }
    __Cont: /* CIL Label */ 
#line 2006
    i ++;
#line 2006
    b2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2056
  if (p->w_zauto == 0) {
#line 2056
    if ((int )*(bp + (len - 1)) == 42) {
#line 2057
      if (len > 1) {
#line 2057
        if ((int )*(bp + (len - 2)) == 42) {
#line 2057
          p->w_zauto = 2;
        } else {
#line 2057
          p->w_zauto = 1;
        }
      } else {
#line 2057
        p->w_zauto = 1;
      }
    }
  }
#line 2058
  if (p->w_zdisplay) {
#line 2060
    display = p->w_zdisplay;
    {
#line 2061
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2061
      tmp___8 = len;
#line 2061
      len --;
#line 2061
      if (! (tmp___8 > 0)) {
#line 2061
        goto while_break___4;
      }
      {
#line 2062
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 2062
        (display->d_obuffree) --;
#line 2062
        if (display->d_obuffree <= 0) {
          {
#line 2062
          Resize_obuf();
          }
        }
#line 2062
        tmp___6 = display->d_obufp;
#line 2062
        (display->d_obufp) ++;
#line 2062
        tmp___7 = bp;
#line 2062
        bp ++;
#line 2062
        *tmp___6 = *tmp___7;
#line 2062
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 2063
    return (1);
  }
#line 2065
  return (0);
}
}
#line 2068 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
static void zmodem_fin(char *buf___0 , int len , char *data ) 
{ 
  char *s ;
  int n ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 2077
  if (len) {
    {
#line 2078
    tmp = strlen((char const   *)buf___0);
#line 2078
    RcLine(buf___0, (int )(tmp + 1U));
    }
  } else {
    {
#line 2081
    s = (char *)"\030\030\030\030\030\030\030\030\030\030";
#line 2082
    tmp___0 = strlen((char const   *)s);
#line 2082
    n = (int )tmp___0;
#line 2083
    (*((flayer->l_layfn)->lf_LayProcess))(& s, & n);
    }
  }
#line 2085
  return;
}
}
#line 2087 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
static void zmodem_found(struct win *p , int send , char *bp , int len ) 
{ 
  char *s ;
  int i ;
  int n ;
  struct display *d ;
  struct display *olddisplay ;
  char const   *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 2099
  n = 0;
#line 2100
  i = 0;
  {
#line 2100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2100
    if (! (i < len)) {
#line 2100
      goto while_break;
    }
#line 2101
    if ((int )*(bp + i) != 24) {
#line 2102
      n = 0;
    } else {
#line 2103
      n ++;
#line 2103
      if (n > 4) {
#line 2104
        return;
      }
    }
#line 2100
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2105
  if (zmodem_mode == 3) {
#line 2105
    goto _L___0;
  } else
#line 2105
  if (zmodem_mode == 1) {
#line 2105
    if (p->w_type != 1) {
      _L___0: /* CIL Label */ 
#line 2109
      olddisplay = display;
#line 2110
      d = p->w_lastdisp;
#line 2111
      if (! d) {
#line 2111
        goto _L;
      } else
#line 2111
      if ((unsigned long )d->d_fore != (unsigned long )p) {
        _L: /* CIL Label */ 
#line 2112
        d = displays;
        {
#line 2112
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2112
          if (! d) {
#line 2112
            goto while_break___0;
          }
#line 2113
          if ((unsigned long )d->d_fore == (unsigned long )p) {
#line 2114
            goto while_break___0;
          }
#line 2112
          d = d->d_next;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 2115
      if (! d) {
#line 2115
        if (p->w_layer.l_cvlist) {
#line 2116
          d = (p->w_layer.l_cvlist)->c_display;
        }
      }
#line 2117
      if (! d) {
#line 2118
        d = displays;
      }
#line 2119
      if (! d) {
#line 2120
        return;
      }
      {
#line 2121
      display = d;
#line 2122
      RemoveStatus();
#line 2123
      p->w_zdisplay = display;
#line 2124
      display->d_blocked = 2 + send;
#line 2125
      flayer = & p->w_layer;
#line 2126
      ZmodemPage();
#line 2127
      display = d;
#line 2128
      evdeq(& display->d_blockedev);
#line 2129
      display->d_readev.condpos = & const_IOSIZE;
#line 2130
      display->d_readev.condneg = & p->w_inlen;
#line 2131
      ClearAll();
#line 2132
      GotoPos(0, 0);
#line 2133
      SetRendition(& mchar_blank);
#line 2134
      AddStr((char *)"Zmodem active\r\n\r\n");
      }
#line 2135
      if (send) {
#line 2135
        tmp = "**\030B01";
      } else {
#line 2135
        tmp = "**\030B00";
      }
      {
#line 2135
      AddStr((char *)tmp);
      }
      {
#line 2136
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2136
        tmp___2 = len;
#line 2136
        len --;
#line 2136
        if (! (tmp___2 > 0)) {
#line 2136
          goto while_break___1;
        }
        {
#line 2137
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2137
          (display->d_obuffree) --;
#line 2137
          if (display->d_obuffree <= 0) {
            {
#line 2137
            Resize_obuf();
            }
          }
#line 2137
          tmp___0 = display->d_obufp;
#line 2137
          (display->d_obufp) ++;
#line 2137
          tmp___1 = bp;
#line 2137
          bp ++;
#line 2137
          *tmp___0 = *tmp___1;
#line 2137
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2138
      display = olddisplay;
#line 2139
      return;
    }
  }
  {
#line 2141
  flayer = & p->w_layer;
#line 2142
  Input((char *)":", 100, 0, & zmodem_fin, (char *)((void *)0));
  }
#line 2143
  if (send) {
#line 2143
    s = zmodem_sendcmd;
  } else {
#line 2143
    s = zmodem_recvcmd;
  }
  {
#line 2144
  tmp___3 = strlen((char const   *)s);
#line 2144
  n = (int )tmp___3;
#line 2145
  (*((flayer->l_layfn)->lf_LayProcess))(& s, & n);
  }
#line 2146
  return;
}
}
#line 2148 "/home/pronto/abs/test-suite/screen-4.0.2/window.c"
void zmodem_abort(struct win *p , struct display *d ) 
{ 
  struct display *olddisplay ;
  struct layer *oldflayer ;
  int *tmp ;
  int tmp___0 ;

  {
#line 2153
  olddisplay = display;
#line 2154
  oldflayer = flayer;
#line 2155
  if (p) {
#line 2157
    if (p->w_savelayer) {
#line 2157
      if ((p->w_savelayer)->l_next) {
#line 2159
        if ((unsigned long )oldflayer == (unsigned long )p->w_savelayer) {
#line 2160
          oldflayer = flayer->l_next;
        }
        {
#line 2161
        flayer = p->w_savelayer;
#line 2162
        ExitOverlayPage();
        }
      }
    }
    {
#line 2164
    p->w_zdisplay = (struct display *)0;
#line 2165
    p->w_zauto = 0;
#line 2166
    LRefreshAll(& p->w_layer, 0);
    }
  }
#line 2168
  if (d) {
#line 2170
    display = d;
#line 2171
    display->d_blocked = 0;
#line 2172
    tmp = (int *)0;
#line 2172
    display->d_readev.condneg = tmp;
#line 2172
    display->d_readev.condpos = tmp;
#line 2173
    if (display->d_fore) {
#line 2173
      tmp___0 = (int )(display->d_fore)->w_norefresh;
    } else {
#line 2173
      tmp___0 = 0;
    }
    {
#line 2173
    Activate(tmp___0);
    }
  }
#line 2175
  display = olddisplay;
#line 2176
  flayer = oldflayer;
#line 2177
  return;
}
}
#line 30 "/home/pronto/abs/test-suite/screen-4.0.2/term.c"
struct term term[196]  = 
#line 30 "/home/pronto/abs/test-suite/screen-4.0.2/term.c"
  {      {(char *)"li", 1}, 
        {(char *)"co", 1}, 
        {(char *)"hc", 0}, 
        {(char *)"os", 0}, 
        {(char *)"ns", 0}, 
        {(char *)"cm", 2}, 
        {(char *)"ho", 2}, 
        {(char *)"cr", 2}, 
        {(char *)"up", 2}, 
        {(char *)"UP", 2}, 
        {(char *)"do", 2}, 
        {(char *)"DO", 2}, 
        {(char *)"bs", 0}, 
        {(char *)"bc", 2}, 
        {(char *)"le", 2}, 
        {(char *)"LE", 2}, 
        {(char *)"nd", 2}, 
        {(char *)"RI", 2}, 
        {(char *)"cs", 2}, 
        {(char *)"nl", 2}, 
        {(char *)"sf", 2}, 
        {(char *)"sr", 2}, 
        {(char *)"al", 2}, 
        {(char *)"AL", 2}, 
        {(char *)"dl", 2}, 
        {(char *)"DL", 2}, 
        {(char *)"in", 0}, 
        {(char *)"im", 2}, 
        {(char *)"ei", 2}, 
        {(char *)"ic", 2}, 
        {(char *)"IC", 2}, 
        {(char *)"dc", 2}, 
        {(char *)"DC", 2}, 
        {(char *)"ut", 0}, 
        {(char *)"cl", 2}, 
        {(char *)"cd", 2}, 
        {(char *)"CD", 2}, 
        {(char *)"ce", 2}, 
        {(char *)"cb", 2}, 
        {(char *)"is", 2}, 
        {(char *)"ti", 2}, 
        {(char *)"te", 2}, 
        {(char *)"bl", 2}, 
        {(char *)"vb", 2}, 
        {(char *)"WS", 2}, 
        {(char *)"Z0", 2}, 
        {(char *)"Z1", 2}, 
        {(char *)"mh", 2}, 
        {(char *)"us", 2}, 
        {(char *)"md", 2}, 
        {(char *)"mr", 2}, 
        {(char *)"so", 2}, 
        {(char *)"mb", 2}, 
        {(char *)"ue", 2}, 
        {(char *)"se", 2}, 
        {(char *)"me", 2}, 
        {(char *)"ms", 0}, 
        {(char *)"sg", 1}, 
        {(char *)"ug", 1}, 
        {(char *)"sa", 2}, 
        {(char *)"AF", 2}, 
        {(char *)"AB", 2}, 
        {(char *)"Sf", 2}, 
        {(char *)"Sb", 2}, 
        {(char *)"op", 2}, 
        {(char *)"Co", 1}, 
        {(char *)"be", 0}, 
        {(char *)"AX", 0}, 
        {(char *)"C8", 0}, 
        {(char *)"ks", 2}, 
        {(char *)"ke", 2}, 
        {(char *)"CS", 2}, 
        {(char *)"CE", 2}, 
        {(char *)"po", 2}, 
        {(char *)"pf", 2}, 
        {(char *)"hs", 0}, 
        {(char *)"ws", 1}, 
        {(char *)"ts", 2}, 
        {(char *)"fs", 2}, 
        {(char *)"ds", 2}, 
        {(char *)"vi", 2}, 
        {(char *)"vs", 2}, 
        {(char *)"ve", 2}, 
        {(char *)"am", 0}, 
        {(char *)"xv", 0}, 
        {(char *)"xn", 0}, 
        {(char *)"OP", 0}, 
        {(char *)"LP", 0}, 
        {(char *)"NF", 0}, 
        {(char *)"nx", 0}, 
        {(char *)"AN", 0}, 
        {(char *)"OL", 1}, 
        {(char *)"KJ", 2}, 
        {(char *)"VR", 2}, 
        {(char *)"VN", 2}, 
        {(char *)"TF", 0}, 
        {(char *)"XT", 0}, 
        {(char *)"G0", 0}, 
        {(char *)"S0", 2}, 
        {(char *)"E0", 2}, 
        {(char *)"C0", 2}, 
        {(char *)"as", 2}, 
        {(char *)"ae", 2}, 
        {(char *)"ac", 2}, 
        {(char *)"eA", 2}, 
        {(char *)"XC", 2}, 
        {(char *)"k0", 2}, 
        {(char *)"k1", 2}, 
        {(char *)"k2", 2}, 
        {(char *)"k3", 2}, 
        {(char *)"k4", 2}, 
        {(char *)"k5", 2}, 
        {(char *)"k6", 2}, 
        {(char *)"k7", 2}, 
        {(char *)"k8", 2}, 
        {(char *)"k9", 2}, 
        {(char *)"k;", 2}, 
        {(char *)"F1", 2}, 
        {(char *)"F2", 2}, 
        {(char *)"F3", 2}, 
        {(char *)"F4", 2}, 
        {(char *)"F5", 2}, 
        {(char *)"F6", 2}, 
        {(char *)"F7", 2}, 
        {(char *)"F8", 2}, 
        {(char *)"F9", 2}, 
        {(char *)"FA", 2}, 
        {(char *)"kb", 2}, 
        {(char *)"K1", 2}, 
        {(char *)"K2", 2}, 
        {(char *)"K3", 2}, 
        {(char *)"K4", 2}, 
        {(char *)"K5", 2}, 
        {(char *)"kA", 2}, 
        {(char *)"ka", 2}, 
        {(char *)"kB", 2}, 
        {(char *)"kC", 2}, 
        {(char *)"kE", 2}, 
        {(char *)"kF", 2}, 
        {(char *)"kL", 2}, 
        {(char *)"kM", 2}, 
        {(char *)"kR", 2}, 
        {(char *)"kS", 2}, 
        {(char *)"kT", 2}, 
        {(char *)"kt", 2}, 
        {(char *)"*4", 2}, 
        {(char *)"*7", 2}, 
        {(char *)"#2", 2}, 
        {(char *)"#3", 2}, 
        {(char *)"#4", 2}, 
        {(char *)"%c", 2}, 
        {(char *)"%e", 2}, 
        {(char *)"%i", 2}, 
        {(char *)"kh", 2}, 
        {(char *)"@1", 2}, 
        {(char *)"kH", 2}, 
        {(char *)"@7", 2}, 
        {(char *)"kN", 2}, 
        {(char *)"kP", 2}, 
        {(char *)"kI", 2}, 
        {(char *)"kD", 2}, 
        {(char *)"ku", 2}, 
        {(char *)"kd", 2}, 
        {(char *)"kr", 2}, 
        {(char *)"kl", 2}, 
        {(char *)"f0", 2}, 
        {(char *)"f1", 2}, 
        {(char *)"f2", 2}, 
        {(char *)"f3", 2}, 
        {(char *)"f4", 2}, 
        {(char *)"f5", 2}, 
        {(char *)"f6", 2}, 
        {(char *)"f7", 2}, 
        {(char *)"f8", 2}, 
        {(char *)"f9", 2}, 
        {(char *)"f+", 2}, 
        {(char *)"f-", 2}, 
        {(char *)"f*", 2}, 
        {(char *)"f/", 2}, 
        {(char *)"fq", 2}, 
        {(char *)"f.", 2}, 
        {(char *)"f,", 2}, 
        {(char *)"fe", 2}, 
        {(char *)"km", 0}, 
        {(char *)"ko", 2}, 
        {(char *)"l0", 2}, 
        {(char *)"l1", 2}, 
        {(char *)"l2", 2}, 
        {(char *)"l3", 2}, 
        {(char *)"l4", 2}, 
        {(char *)"l5", 2}, 
        {(char *)"l6", 2}, 
        {(char *)"l7", 2}, 
        {(char *)"l8", 2}, 
        {(char *)"l9", 2}, 
        {(char *)"la", 2}};
#line 610 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 717
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 754
extern  __attribute__((__nothrow__)) int tcsetpgrp(int __fd , __pid_t __pgrp_id ) ;
#line 55 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int cfsetospeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 58
extern  __attribute__((__nothrow__)) int cfsetispeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 67
extern  __attribute__((__nothrow__)) int tcgetattr(int __fd , struct termios *__termios_p ) ;
#line 71
extern  __attribute__((__nothrow__)) int tcsetattr(int __fd , int __optional_actions ,
                                                   struct termios  const  *__termios_p ) ;
#line 81
extern  __attribute__((__nothrow__)) int tcsendbreak(int __fd , int __duration ) ;
#line 72 "/home/pronto/abs/test-suite/screen-4.0.2/extern.h"
int secopen(char *name , int flags , int mode ) ;
#line 84
void GetTTY(int fd , struct mode *mp ) ;
#line 86
void SetMode(struct mode *op , struct mode *np , int flow , int interrupt ) ;
#line 97
int SetBaud(struct mode *m___0 , int ibaud , int obaud ) ;
#line 98
int SttyMode(struct mode *m___0 , char *opt ) ;
#line 355
int UserContext(void) ;
#line 356
void UserReturn(int val ) ;
#line 357
int UserStatus(void) ;
#line 68 "/home/pronto/abs/test-suite/screen-4.0.2/tty.c"
static void consredir_readev_fn(struct event *ev , char *data ) ;
#line 71 "/home/pronto/abs/test-suite/screen-4.0.2/tty.c"
int separate_sids  =    1;
#line 73
static void DoSendBreak(int fd , int n , int type ) ;
#line 74
static void SigAlrmDummy(int sigsig ) ;
#line 100 "/home/pronto/abs/test-suite/screen-4.0.2/tty.c"
static void SigAlrmDummy(int sigsig ) 
{ 


  {
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  return;
}
}
#line 112 "/home/pronto/abs/test-suite/screen-4.0.2/tty.c"
int OpenTTY(char *line , char *opt ) 
{ 
  int f ;
  struct mode Mode ;
  void (*sigalrm)(int  ) ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int mcs ;

  {
  {
#line 120
  sigalrm = xsignal(14, & SigAlrmDummy);
#line 121
  alarm(2U);
#line 124
  f = secopen(line, 2306, 0);
  }
#line 124
  if (f == -1) {
    {
#line 126
    tmp___0 = __errno_location();
    }
#line 126
    if (*tmp___0 == 4) {
      {
#line 127
      Msg(0, (char *)"Cannot open line \'%s\' for R/W: open() blocked, aborted.",
          line);
      }
    } else {
      {
#line 129
      tmp = __errno_location();
#line 129
      Msg(*tmp, (char *)"Cannot open line \'%s\' for R/W", line);
      }
    }
    {
#line 130
    alarm(0U);
#line 131
    xsignal(14, sigalrm);
    }
#line 132
    return (-1);
  }
  {
#line 134
  tmp___1 = isatty(f);
  }
#line 134
  if (! tmp___1) {
    {
#line 136
    Msg(0, (char *)"\'%s\' is not a tty", line);
#line 137
    alarm(0U);
#line 138
    xsignal(14, sigalrm);
#line 139
    close(f);
    }
#line 140
    return (-1);
  }
  {
#line 153
  tmp___2 = __errno_location();
#line 153
  *tmp___2 = 0;
#line 154
  tmp___4 = ioctl(f, 21516UL, (char *)0);
  }
#line 154
  if (tmp___4 < 0) {
    {
#line 155
    tmp___3 = __errno_location();
#line 155
    Msg(*tmp___3, (char *)"%s: ioctl TIOCEXCL failed", line);
    }
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 157
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 157
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 170
  InitTTY(& Mode, 1);
#line 172
  SttyMode(& Mode, opt);
#line 176
  SetTTY(f, & Mode);
#line 180
  mcs = 0;
#line 181
  ioctl(f, 21525UL, & mcs);
#line 182
  mcs |= 4;
#line 183
  ioctl(f, 21528UL, & mcs);
#line 187
  brktty(f);
#line 188
  alarm(0U);
#line 189
  xsignal(14, sigalrm);
  }
  {
#line 190
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 190
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 191
  return (f);
}
}
#line 199 "/home/pronto/abs/test-suite/screen-4.0.2/tty.c"
void InitTTY(struct mode *m___0 , int ttyflag ) 
{ 


  {
  {
#line 204
  bzero((void *)((char *)m___0), (size_t )sizeof(*m___0));
  }
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 211
  m___0->tio.c_iflag |= 2U;
#line 214
  m___0->tio.c_iflag |= 4U;
#line 218
  m___0->tio.c_iflag |= 1024U;
#line 222
  if (! ttyflag) {
#line 225
    m___0->tio.c_iflag |= 256U;
#line 228
    m___0->tio.c_oflag |= 4U;
#line 231
    m___0->tio.c_oflag |= 6144U;
#line 238
    m___0->tio.c_oflag |= 1U;
  }
  {
#line 254
  cfsetospeed(& m___0->tio, (speed_t )13);
#line 257
  cfsetispeed(& m___0->tio, (speed_t )13);
#line 261
  m___0->tio.c_cflag |= 48U;
#line 264
  m___0->tio.c_cflag |= 128U;
#line 267
  m___0->tio.c_cflag |= 2048U;
#line 271
  m___0->tio.c_lflag |= 512U;
#line 274
  m___0->tio.c_lflag |= 2048U;
  }
#line 277
  if (! ttyflag) {
#line 280
    m___0->tio.c_lflag |= 1U;
#line 283
    m___0->tio.c_lflag |= 2U;
#line 286
    m___0->tio.c_lflag |= 8U;
  }
#line 290
  m___0->tio.c_lflag |= 16U;
#line 293
  m___0->tio.c_lflag |= 32U;
#line 296
  m___0->tio.c_lflag |= 32768U;
#line 301
  m___0->tio.c_cc[0] = (cc_t )3;
#line 306
  m___0->tio.c_cc[1] = (cc_t )28;
#line 311
  m___0->tio.c_cc[2] = (cc_t )127;
#line 316
  m___0->tio.c_cc[3] = (cc_t )8;
#line 321
  m___0->tio.c_cc[4] = (cc_t )4;
#line 326
  m___0->tio.c_cc[11] = (cc_t )0;
#line 331
  m___0->tio.c_cc[16] = (cc_t )0;
#line 341
  m___0->tio.c_cc[8] = (cc_t )17;
#line 346
  m___0->tio.c_cc[9] = (cc_t )19;
#line 351
  m___0->tio.c_cc[10] = (cc_t )26;
#line 361
  m___0->tio.c_cc[12] = (cc_t )18;
#line 366
  m___0->tio.c_cc[13] = (cc_t )15;
#line 371
  m___0->tio.c_cc[14] = (cc_t )23;
#line 376
  m___0->tio.c_cc[15] = (cc_t )22;
#line 385
  if (ttyflag) {
#line 387
    m___0->tio.c_cc[6] = (cc_t )100;
#line 388
    m___0->tio.c_cc[5] = (cc_t )2;
  }
#line 579
  return;
}
}
#line 581 "/home/pronto/abs/test-suite/screen-4.0.2/tty.c"
void SetTTY(int fd , struct mode *mp ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 586
  tmp = __errno_location();
#line 586
  *tmp = 0;
#line 588
  tcsetattr(fd, 1, (struct termios  const  *)(& mp->tio));
#line 616
  tmp___1 = __errno_location();
  }
#line 616
  if (*tmp___1) {
    {
#line 617
    tmp___0 = __errno_location();
#line 617
    Msg(*tmp___0, (char *)"SetTTY (fd %d): ioctl failed", fd);
    }
  }
#line 618
  return;
}
}
#line 620 "/home/pronto/abs/test-suite/screen-4.0.2/tty.c"
void GetTTY(int fd , struct mode *mp ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 625
  tmp = __errno_location();
#line 625
  *tmp = 0;
#line 627
  tcgetattr(fd, & mp->tio);
#line 660
  tmp___1 = __errno_location();
  }
#line 660
  if (*tmp___1) {
    {
#line 661
    tmp___0 = __errno_location();
#line 661
    Msg(*tmp___0, (char *)"GetTTY (fd %d): ioctl failed", fd);
    }
  }
#line 662
  return;
}
}
#line 667 "/home/pronto/abs/test-suite/screen-4.0.2/tty.c"
void SetMode(struct mode *op , struct mode *np , int flow , int interrupt ) 
{ 


  {
#line 672
  *np = *op;
  {
#line 674
  while (1) {
    while_continue: /* CIL Label */ ;
#line 674
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 682
  np->tio.c_iflag &= 4294967039U;
#line 685
  np->tio.c_iflag &= 4294967263U;
#line 688
  np->tio.c_oflag &= 4294967291U;
#line 690
  np->tio.c_lflag &= 4294967285U;
#line 696
  np->tio.c_lflag &= 4294934527U;
#line 708
  if (interrupt) {
#line 709
    np->tio.c_lflag |= 1U;
  } else {
#line 711
    np->tio.c_lflag &= 4294967294U;
  }
#line 720
  np->tio.c_cc[6] = (cc_t )1;
#line 721
  np->tio.c_cc[5] = (cc_t )0;
#line 722
  if (! interrupt) {
#line 723
    np->tio.c_cc[0] = (cc_t )'\000';
  } else
#line 722
  if (! flow) {
#line 723
    np->tio.c_cc[0] = (cc_t )'\000';
  }
#line 724
  np->tio.c_cc[1] = (cc_t )'\000';
#line 725
  if (flow == 0) {
#line 729
    np->tio.c_cc[8] = (cc_t )'\000';
#line 734
    np->tio.c_cc[9] = (cc_t )'\000';
#line 737
    np->tio.c_iflag &= 4294966271U;
  }
#line 741
  np->tio.c_cc[13] = (cc_t )'\000';
#line 746
  np->tio.c_cc[15] = (cc_t )'\000';
#line 756
  np->tio.c_cc[10] = (cc_t )'\000';
#line 761
  np->tio.c_cc[2] = (cc_t )'\000';
#line 766
  np->tio.c_cc[3] = (cc_t )'\000';
#line 784
  np->tio.c_cc[12] = (cc_t )'\000';
#line 789
  np->tio.c_cc[14] = (cc_t )'\000';
#line 813
  return;
}
}
#line 816 "/home/pronto/abs/test-suite/screen-4.0.2/tty.c"
void SetFlow(int on ) 
{ 
  int tmp ;

  {
  {
#line 820
  while (1) {
    while_continue: /* CIL Label */ ;
#line 820
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 821
  if (display->d_flow == on) {
#line 822
    return;
  }
#line 824
  if (on) {
#line 826
    if (iflag) {
#line 826
      display->d_NewMode.tio.c_cc[0] = display->d_OldMode.tio.c_cc[0];
    } else {
#line 826
      display->d_NewMode.tio.c_cc[0] = (cc_t )'\000';
    }
#line 829
    display->d_NewMode.tio.c_cc[8] = display->d_OldMode.tio.c_cc[8];
#line 834
    display->d_NewMode.tio.c_cc[9] = display->d_OldMode.tio.c_cc[9];
#line 837
    display->d_NewMode.tio.c_iflag |= display->d_OldMode.tio.c_iflag & 1024U;
  } else {
#line 841
    display->d_NewMode.tio.c_cc[0] = (cc_t )'\000';
#line 844
    display->d_NewMode.tio.c_cc[8] = (cc_t )'\000';
#line 849
    display->d_NewMode.tio.c_cc[9] = (cc_t )'\000';
#line 852
    display->d_NewMode.tio.c_iflag &= 4294966271U;
  }
  {
#line 855
  tmp = tcsetattr(display->d_userfd, 0, (struct termios  const  *)(& display->d_NewMode.tio));
  }
#line 855
  if (tmp) {
    {
#line 859
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 859
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 876
  display->d_flow = on;
#line 877
  return;
}
}
#line 885 "/home/pronto/abs/test-suite/screen-4.0.2/tty.c"
static char const   sep[6]  = {      (char const   )' ',      (char const   )'\t',      (char const   )':',      (char const   )';', 
        (char const   )',',      (char const   )'\000'};
#line 880 "/home/pronto/abs/test-suite/screen-4.0.2/tty.c"
int SttyMode(struct mode *m___0 , char *opt ) 
{ 
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;

  {
#line 887
  if (! opt) {
#line 888
    return (0);
  }
  {
#line 890
  while (1) {
    while_continue: /* CIL Label */ ;
#line 890
    if (! *opt) {
#line 890
      goto while_break;
    }
    {
#line 892
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 892
      tmp = index(sep, (int )*opt);
      }
#line 892
      if (! tmp) {
#line 892
        goto while_break___0;
      }
#line 892
      opt ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 893
    if ((int )*opt >= 48) {
#line 893
      if ((int )*opt <= 57) {
        {
#line 895
        tmp___0 = atoi((char const   *)opt);
#line 895
        tmp___1 = atoi((char const   *)opt);
#line 895
        tmp___2 = SetBaud(m___0, tmp___1, tmp___0);
        }
#line 895
        if (tmp___2) {
#line 896
          return (-1);
        }
      } else {
#line 893
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 898
      tmp___12 = strncmp("cs7", (char const   *)opt, (size_t )3);
      }
#line 898
      if (tmp___12) {
        {
#line 907
        tmp___11 = strncmp("cs8", (char const   *)opt, (size_t )3);
        }
#line 907
        if (tmp___11) {
          {
#line 916
          tmp___10 = strncmp("istrip", (char const   *)opt, (size_t )6);
          }
#line 916
          if (tmp___10) {
            {
#line 924
            tmp___9 = strncmp("-istrip", (char const   *)opt, (size_t )7);
            }
#line 924
            if (tmp___9) {
              {
#line 932
              tmp___8 = strncmp("ixon", (char const   *)opt, (size_t )4);
              }
#line 932
              if (tmp___8) {
                {
#line 940
                tmp___7 = strncmp("-ixon", (char const   *)opt, (size_t )5);
                }
#line 940
                if (tmp___7) {
                  {
#line 948
                  tmp___6 = strncmp("ixoff", (char const   *)opt, (size_t )5);
                  }
#line 948
                  if (tmp___6) {
                    {
#line 956
                    tmp___5 = strncmp("-ixoff", (char const   *)opt, (size_t )6);
                    }
#line 956
                    if (tmp___5) {
                      {
#line 964
                      tmp___4 = strncmp("crtscts", (char const   *)opt, (size_t )7);
                      }
#line 964
                      if (tmp___4) {
                        {
#line 970
                        tmp___3 = strncmp("-crtscts", (char const   *)opt, (size_t )8);
                        }
#line 970
                        if (tmp___3) {
#line 977
                          return (-1);
                        } else {
#line 973
                          m___0->tio.c_cflag &= 2147483647U;
                        }
                      } else {
#line 967
                        m___0->tio.c_cflag |= 2147483648U;
                      }
                    } else {
#line 959
                      m___0->tio.c_iflag &= 4294963199U;
                    }
                  } else {
#line 951
                    m___0->tio.c_iflag |= 4096U;
                  }
                } else {
#line 943
                  m___0->tio.c_iflag &= 4294966271U;
                }
              } else {
#line 935
                m___0->tio.c_iflag |= 1024U;
              }
            } else {
#line 927
              m___0->tio.c_iflag &= 4294967263U;
            }
          } else {
#line 919
            m___0->tio.c_iflag |= 32U;
          }
        } else {
#line 910
          m___0->tio.c_cflag &= 4294967247U;
#line 911
          m___0->tio.c_cflag |= 48U;
        }
      } else {
#line 901
        m___0->tio.c_cflag &= 4294967247U;
#line 902
        m___0->tio.c_cflag |= 32U;
      }
    }
    {
#line 978
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 978
      if (*opt) {
        {
#line 978
        tmp___13 = index(sep, (int )*opt);
        }
#line 978
        if (tmp___13) {
#line 978
          goto while_break___1;
        }
      } else {
#line 978
        goto while_break___1;
      }
#line 978
      opt ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 980
  return (0);
}
}
#line 991 "/home/pronto/abs/test-suite/screen-4.0.2/tty.c"
void brktty(int fd ) 
{ 


  {
#line 996
  if (separate_sids) {
    {
#line 997
    setsid();
    }
  }
#line 1019
  return;
}
}
#line 1021 "/home/pronto/abs/test-suite/screen-4.0.2/tty.c"
int fgtty(int fd ) 
{ 
  int mypid ;
  int tmp ;

  {
  {
#line 1028
  mypid = getpid();
  }
#line 1045
  if (separate_sids) {
    {
#line 1046
    tmp = tcsetpgrp(fd, mypid);
    }
#line 1046
    if (tmp) {
      {
#line 1048
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1048
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 1049
      return (-1);
    }
  }
#line 1061
  return (0);
}
}
#line 1070 "/home/pronto/abs/test-suite/screen-4.0.2/tty.c"
int breaktype  =    2;
#line 1090 "/home/pronto/abs/test-suite/screen-4.0.2/tty.c"
static void DoSendBreak(int fd , int n , int type ) 
{ 
  int i ;
  int *tmp ;
  int tmp___0 ;
  int i___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;

  {
  {
#line 1096
  if (type == 2) {
#line 1096
    goto case_2;
  }
#line 1138
  if (type == 1) {
#line 1138
    goto case_1;
  }
#line 1162
  if (type == 0) {
#line 1162
    goto case_0;
  }
#line 1185
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 1119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1119
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1123
  if (! n) {
#line 1124
    n ++;
  }
#line 1125
  i = 0;
  {
#line 1125
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1125
    if (! (i < n)) {
#line 1125
      goto while_break___0;
    }
    {
#line 1126
    tmp___0 = tcsendbreak(fd, 0);
    }
#line 1126
    if (tmp___0 < 0) {
      {
#line 1128
      tmp = __errno_location();
#line 1128
      Msg(*tmp, (char *)"cannot send BREAK (tcsendbreak SVR4)");
      }
#line 1129
      return;
    }
#line 1125
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1136
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1140
  if (! n) {
#line 1141
    n ++;
  }
  {
#line 1146
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1146
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1150
  i___0 = 0;
  {
#line 1150
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1150
    if (! (i___0 < n)) {
#line 1150
      goto while_break___2;
    }
    {
#line 1151
    tmp___2 = ioctl(fd, 21513UL, (char *)0);
    }
#line 1151
    if (tmp___2 < 0) {
      {
#line 1153
      tmp___1 = __errno_location();
#line 1153
      Msg(*tmp___1, (char *)"Cannot send BREAK (TCSBRK)");
      }
#line 1154
      return;
    }
#line 1150
    i___0 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1160
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1168
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1168
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1169
  tmp___4 = ioctl(fd, 21543UL, (char *)0);
  }
#line 1169
  if (tmp___4 < 0) {
    {
#line 1171
    tmp___3 = __errno_location();
#line 1171
    Msg(*tmp___3, (char *)"Can\'t send BREAK (TIOCSBRK)");
    }
#line 1172
    return;
  }
#line 1174
  if (n) {
#line 1174
    tmp___5 = n * 250;
  } else {
#line 1174
    tmp___5 = 250;
  }
  {
#line 1174
  sleep1000(tmp___5);
#line 1175
  tmp___7 = ioctl(fd, 21544UL, (char *)0);
  }
#line 1175
  if (tmp___7 < 0) {
    {
#line 1177
    tmp___6 = __errno_location();
#line 1177
    Msg(*tmp___6, (char *)"BREAK stuck!!! -- HELP! (TIOCCBRK)");
    }
#line 1178
    return;
  }
#line 1183
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1186
  Msg(0, (char *)"Internal SendBreak error: method %d unknown", type);
  }
  switch_break: /* CIL Label */ ;
  }
#line 1188
  return;
}
}
#line 1195 "/home/pronto/abs/test-suite/screen-4.0.2/tty.c"
void SendBreak(struct win *wp , int n , int closeopen ) 
{ 
  void (*sigalrm)(int  ) ;
  int tmp ;
  int tmp___0 ;

  {
#line 1209
  if (wp->w_type != 1) {
#line 1210
    return;
  }
  {
#line 1212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1212
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1215
  tcflush(wp->w_ptyfd, 2);
  }
#line 1222
  if (closeopen) {
    {
#line 1224
    close(wp->w_ptyfd);
    }
#line 1225
    if (n) {
#line 1225
      tmp = n * 250;
    } else {
#line 1225
      tmp = 250;
    }
    {
#line 1225
    sleep1000(tmp);
#line 1226
    tmp___0 = OpenTTY(wp->w_tty, wp->w_cmdargs[1]);
#line 1226
    wp->w_ptyfd = tmp___0;
    }
#line 1226
    if (tmp___0 < 1) {
      {
#line 1228
      Msg(0, (char *)"Ouch, cannot reopen line %s, please try harder", wp->w_tty);
      }
#line 1229
      return;
    }
    {
#line 1231
    fcntl(wp->w_ptyfd, 4, 2048);
    }
  } else {
    {
#line 1235
    sigalrm = xsignal(14, & SigAlrmDummy);
#line 1236
    alarm(15U);
#line 1238
    DoSendBreak(wp->w_ptyfd, n, breaktype);
#line 1240
    alarm(0U);
#line 1241
    xsignal(14, sigalrm);
    }
  }
  {
#line 1243
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1243
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1244
  return;
}
}
#line 1252 "/home/pronto/abs/test-suite/screen-4.0.2/tty.c"
static struct event consredir_ev  ;
#line 1253 "/home/pronto/abs/test-suite/screen-4.0.2/tty.c"
static int consredirfd[2]  = {      -1,      -1};
#line 1255 "/home/pronto/abs/test-suite/screen-4.0.2/tty.c"
static void consredir_readev_fn(struct event *ev , char *data ) 
{ 
  char *p ;
  char *n ;
  char buf___0[256] ;
  int l ;

  {
#line 1263
  if (! console_window) {
#line 1263
    goto _L;
  } else {
    {
#line 1263
    l = read(consredirfd[0], (void *)(buf___0), (size_t )sizeof(buf___0));
    }
#line 1263
    if (l <= 0) {
      _L: /* CIL Label */ 
      {
#line 1265
      close(consredirfd[0]);
#line 1266
      close(consredirfd[1]);
#line 1267
      consredirfd[1] = -1;
#line 1267
      consredirfd[0] = consredirfd[1];
#line 1268
      evdeq(ev);
      }
#line 1269
      return;
    }
  }
#line 1271
  n = buf___0;
#line 1271
  p = n;
  {
#line 1271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1271
    if (! (l > 0)) {
#line 1271
      goto while_break;
    }
#line 1272
    if ((int )*n == 10) {
#line 1274
      if ((unsigned long )n > (unsigned long )p) {
        {
#line 1275
        WriteString(console_window, p, (int )(n - p));
        }
      }
      {
#line 1276
      WriteString(console_window, (char *)"\r\n", 2);
#line 1277
      p = n + 1;
      }
    }
#line 1271
    n ++;
#line 1271
    l --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1279
  if ((unsigned long )n > (unsigned long )p) {
    {
#line 1280
    WriteString(console_window, p, (int )(n - p));
    }
  }
#line 1281
  return;
}
}
#line 1286 "/home/pronto/abs/test-suite/screen-4.0.2/tty.c"
int TtyGrabConsole(int fd , int on , char *rc_name___0 ) 
{ 
  struct display *d ;
  struct mode new1 ;
  struct mode new2 ;
  char *slave ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 1352
  if (on > 0) {
#line 1354
    if ((unsigned long )displays == (unsigned long )((struct display *)0)) {
      {
#line 1356
      Msg(0, (char *)"I need a display");
      }
#line 1357
      return (-1);
    }
#line 1359
    d = displays;
    {
#line 1359
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1359
      if (! d) {
#line 1359
        goto while_break;
      }
      {
#line 1360
      tmp = strcmp((char const   *)(d->d_usertty), "/dev/console");
      }
#line 1360
      if (tmp == 0) {
#line 1361
        goto while_break;
      }
#line 1359
      d = d->d_next;
    }
    while_break: /* CIL Label */ ;
    }
#line 1362
    if (d) {
      {
#line 1364
      Msg(0, (char *)"too dangerous - screen is running on /dev/console");
      }
#line 1365
      return (-1);
    }
  }
#line 1368
  if (consredirfd[0] >= 0) {
    {
#line 1370
    evdeq(& consredir_ev);
#line 1371
    close(consredirfd[0]);
#line 1372
    close(consredirfd[1]);
#line 1373
    consredirfd[1] = -1;
#line 1373
    consredirfd[0] = consredirfd[1];
    }
  }
#line 1375
  if (on <= 0) {
#line 1376
    return (0);
  }
  {
#line 1402
  consredirfd[0] = OpenPTY(& slave);
  }
#line 1402
  if (consredirfd[0] < 0) {
    {
#line 1404
    tmp___0 = __errno_location();
#line 1404
    Msg(*tmp___0, (char *)"%s: could not open detach pty master", rc_name___0);
    }
#line 1405
    return (-1);
  }
  {
#line 1407
  consredirfd[1] = open((char const   *)slave, 258);
  }
#line 1407
  if (consredirfd[1] < 0) {
    {
#line 1409
    tmp___1 = __errno_location();
#line 1409
    Msg(*tmp___1, (char *)"%s: could not open detach pty slave", rc_name___0);
#line 1410
    close(consredirfd[0]);
    }
#line 1411
    return (-1);
  }
  {
#line 1413
  InitTTY(& new1, 0);
#line 1414
  SetMode(& new1, & new2, 0, 0);
#line 1415
  SetTTY(consredirfd[1], & new2);
#line 1416
  tmp___3 = UserContext();
  }
#line 1416
  if (tmp___3 == 1) {
    {
#line 1417
    tmp___2 = ioctl(consredirfd[1], 21533UL, (char *)(& on));
#line 1417
    UserReturn(tmp___2);
    }
  }
  {
#line 1418
  tmp___5 = UserStatus();
  }
#line 1418
  if (tmp___5) {
    {
#line 1420
    tmp___4 = __errno_location();
#line 1420
    Msg(*tmp___4, (char *)"%s: ioctl TIOCCONS failed", rc_name___0);
#line 1421
    close(consredirfd[0]);
#line 1422
    close(consredirfd[1]);
    }
#line 1423
    return (-1);
  }
  {
#line 1426
  consredir_ev.fd = consredirfd[0];
#line 1427
  consredir_ev.type = 1;
#line 1428
  consredir_ev.handler = & consredir_readev_fn;
#line 1429
  evenq(& consredir_ev);
  }
#line 1430
  return (0);
}
}
#line 1445 "/home/pronto/abs/test-suite/screen-4.0.2/tty.c"
char *TtyGetModemStatus(int fd , char *buf___0 ) 
{ 
  char *p ;
  unsigned int softcar ;
  unsigned int mflags ;
  struct mode mtio ;
  int rtscts ;
  int clocal ;
  char *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  size_t tmp___2 ;
  char *s ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;

  {
  {
#line 1450
  p = buf___0;
#line 1489
  GetTTY(fd, & mtio);
#line 1491
  clocal = 0;
  }
#line 1493
  if (mtio.tio.c_cflag & 2048U) {
#line 1495
    clocal = 1;
#line 1496
    tmp = p;
#line 1496
    p ++;
#line 1496
    *tmp = (char )'{';
  }
#line 1502
  if (! (mtio.tio.c_cflag & 2147483648U)) {
#line 1503
    rtscts = 0;
  } else {
#line 1506
    rtscts = 1;
  }
  {
#line 1510
  tmp___0 = ioctl(fd, 21529UL, (char *)(& softcar));
  }
#line 1510
  if (tmp___0 < 0) {
#line 1511
    softcar = 0U;
  }
  {
#line 1516
  tmp___17 = ioctl(fd, 21525UL, (char *)(& mflags));
  }
#line 1516
  if (tmp___17 < 0) {
#line 1526
    if (softcar) {
#line 1526
      tmp___1 = "(CD)";
    } else {
#line 1526
      tmp___1 = "CD";
    }
    {
#line 1526
    sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"NO-TTY? %s",
            tmp___1);
#line 1530
    tmp___2 = strlen((char const   *)p);
#line 1530
    p += tmp___2;
    }
  } else {
#line 1543
    s = (char *)"!RTS ";
#line 1543
    if (mflags & 4U) {
#line 1543
      s ++;
    }
    {
#line 1544
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1544
      if (! *s) {
#line 1544
        goto while_break;
      }
#line 1544
      tmp___3 = p;
#line 1544
      p ++;
#line 1544
      tmp___4 = s;
#line 1544
      s ++;
#line 1544
      *tmp___3 = *tmp___4;
    }
    while_break: /* CIL Label */ ;
    }
#line 1547
    s = (char *)"!CTS ";
#line 1548
    if (! rtscts) {
#line 1550
      tmp___5 = p;
#line 1550
      p ++;
#line 1550
      *tmp___5 = (char )'(';
#line 1551
      s = (char *)"!CTS) ";
    }
#line 1553
    if (mflags & 32U) {
#line 1553
      s ++;
    }
    {
#line 1554
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1554
      if (! *s) {
#line 1554
        goto while_break___0;
      }
#line 1554
      tmp___6 = p;
#line 1554
      p ++;
#line 1554
      tmp___7 = s;
#line 1554
      s ++;
#line 1554
      *tmp___6 = *tmp___7;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1558
    s = (char *)"!DTR ";
#line 1558
    if (mflags & 2U) {
#line 1558
      s ++;
    }
    {
#line 1559
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1559
      if (! *s) {
#line 1559
        goto while_break___1;
      }
#line 1559
      tmp___8 = p;
#line 1559
      p ++;
#line 1559
      tmp___9 = s;
#line 1559
      s ++;
#line 1559
      *tmp___8 = *tmp___9;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1562
    s = (char *)"!DSR ";
#line 1562
    if (mflags & 256U) {
#line 1562
      s ++;
    }
    {
#line 1563
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1563
      if (! *s) {
#line 1563
        goto while_break___2;
      }
#line 1563
      tmp___10 = p;
#line 1563
      p ++;
#line 1563
      tmp___11 = s;
#line 1563
      s ++;
#line 1563
      *tmp___10 = *tmp___11;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1566
    s = (char *)"!CD ";
#line 1568
    if (softcar) {
#line 1570
      tmp___12 = p;
#line 1570
      p ++;
#line 1570
      *tmp___12 = (char )'(';
#line 1571
      s = (char *)"!CD) ";
    }
#line 1575
    if (mflags & 64U) {
#line 1575
      s ++;
    }
    {
#line 1579
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1579
      if (! *s) {
#line 1579
        goto while_break___3;
      }
#line 1579
      tmp___13 = p;
#line 1579
      p ++;
#line 1579
      tmp___14 = s;
#line 1579
      s ++;
#line 1579
      *tmp___13 = *tmp___14;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1583
    if (mflags & 128U) {
#line 1587
      s = (char *)"RI ";
      {
#line 1587
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1587
        if (! *s) {
#line 1587
          goto while_break___4;
        }
#line 1587
        tmp___15 = p;
#line 1587
        p ++;
#line 1587
        tmp___16 = s;
#line 1587
        s ++;
#line 1587
        *tmp___15 = *tmp___16;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 1599
    if ((unsigned long )p > (unsigned long )buf___0) {
#line 1599
      if ((int )*(p + -1) == 32) {
#line 1600
        p --;
      }
    }
#line 1601
    *p = (char )'\000';
  }
#line 1609
  if (clocal) {
#line 1610
    tmp___18 = p;
#line 1610
    p ++;
#line 1610
    *tmp___18 = (char )'}';
  }
#line 1611
  *p = (char )'\000';
#line 1612
  return (buf___0);
}
}
#line 1681 "/home/pronto/abs/test-suite/screen-4.0.2/tty.c"
static struct baud_values btable[23]  = 
#line 1681
  {      {13, 9600, 13}, 
        {14, 19200, 14}, 
        {14, 19200, 14}, 
        {15, 38400, 15}, 
        {15, 38400, 15}, 
        {16, 57600, 4097}, 
        {17, 115200, 4098}, 
        {18, 230400, 4099}, 
        {19, 460800, 4100}, 
        {12, 4800, 12}, 
        {11, 2400, 11}, 
        {10, 1800, 10}, 
        {9, 1200, 9}, 
        {8, 600, 8}, 
        {7, 300, 7}, 
        {6, 200, 6}, 
        {5, 150, 5}, 
        {4, 134, 4}, 
        {3, 110, 3}, 
        {2, 75, 2}, 
        {1, 50, 1}, 
        {0, 0, 0}, 
        {-1, -1, -1}};
#line 1765 "/home/pronto/abs/test-suite/screen-4.0.2/tty.c"
struct baud_values *lookup_baud(int baud ) 
{ 
  struct baud_values *p ;

  {
#line 1771
  p = btable;
  {
#line 1771
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1771
    if (! (p->idx >= 0)) {
#line 1771
      goto while_break;
    }
#line 1772
    if (baud == p->bps) {
#line 1773
      return (p);
    } else
#line 1772
    if (baud == p->sym) {
#line 1773
      return (p);
    }
#line 1771
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1774
  return ((struct baud_values *)((void *)0));
}
}
#line 1783 "/home/pronto/abs/test-suite/screen-4.0.2/tty.c"
int SetBaud(struct mode *m___0 , int ibaud , int obaud ) 
{ 
  struct baud_values *ip ;
  struct baud_values *op ;

  {
  {
#line 1790
  ip = lookup_baud(ibaud);
  }
#line 1790
  if (ip) {
    _L: /* CIL Label */ 
    {
#line 1790
    op = lookup_baud(obaud);
    }
#line 1790
    if (! op) {
#line 1790
      if (obaud != -1) {
#line 1792
        return (-1);
      }
    }
  } else
#line 1790
  if (ibaud != -1) {
#line 1792
    return (-1);
  } else {
#line 1790
    goto _L;
  }
#line 1795
  if (ip) {
    {
#line 1795
    cfsetispeed(& m___0->tio, (speed_t )ip->sym);
    }
  }
#line 1796
  if (op) {
    {
#line 1796
    cfsetospeed(& m___0->tio, (speed_t )op->sym);
    }
  }
#line 1819
  return (0);
}
}
#line 104 "/home/pronto/abs/test-suite/screen-4.0.2/extern.h"
void revto_line(int tx , int ty , int line ) ;
#line 105
void revto(int tx , int ty ) ;
#line 111
void Search(int dir ) ;
#line 112
void ISearch(int dir ) ;
#line 38 "/home/pronto/abs/test-suite/screen-4.0.2/search.c"
int search_ic  ;
#line 44
static int matchword(char *pattern , int y , int sx , int ex ) ;
#line 45
static void searchend(char *buf___0 , int len , char *data ) ;
#line 46
static void backsearchend(char *buf___0 , int len , char *data ) ;
#line 48 "/home/pronto/abs/test-suite/screen-4.0.2/search.c"
void Search(int dir ) 
{ 
  struct markdata *markdata___0 ;
  void (*tmp)(char * , int  , char * ) ;
  char const   *tmp___0 ;

  {
#line 53
  if (dir == 0) {
#line 55
    markdata___0 = (struct markdata *)flayer->l_data;
#line 56
    if (markdata___0->isdir > 0) {
      {
#line 57
      searchend((char *)0, 0, (char *)((void *)0));
      }
    } else
#line 58
    if (markdata___0->isdir < 0) {
      {
#line 59
      backsearchend((char *)0, 0, (char *)((void *)0));
      }
    } else {
      {
#line 61
      LMsg(0, (char *)"No previous pattern");
      }
    }
  } else {
#line 64
    if (dir > 0) {
#line 64
      tmp = & searchend;
    } else {
#line 64
      tmp = & backsearchend;
    }
#line 64
    if (dir > 0) {
#line 64
      tmp___0 = "/";
    } else {
#line 64
      tmp___0 = "?";
    }
    {
#line 64
    Input((char *)tmp___0, (int )(sizeof(markdata___0->isstr) - 1UL), 0, tmp, (char *)((void *)0));
    }
  }
#line 66
  return;
}
}
#line 68 "/home/pronto/abs/test-suite/screen-4.0.2/search.c"
static void searchend(char *buf___0 , int len , char *data ) 
{ 
  int x ;
  int sx ;
  int ex ;
  int y ;
  struct markdata *markdata___0 ;
  struct win *p ;

  {
#line 74
  x = 0;
#line 78
  markdata___0 = (struct markdata *)flayer->l_data;
#line 79
  p = markdata___0->md_window;
#line 80
  markdata___0->isdir = 1;
#line 81
  if (len) {
    {
#line 82
    strcpy((char */* __restrict  */)(markdata___0->isstr), (char const   */* __restrict  */)buf___0);
    }
  }
#line 83
  sx = markdata___0->cx + 1;
#line 84
  ex = flayer->l_width - 1;
#line 85
  y = markdata___0->cy;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! (y < p->w_histheight + flayer->l_height)) {
#line 85
      goto while_break;
    }
    {
#line 87
    x = matchword(markdata___0->isstr, y, sx, ex);
    }
#line 87
    if (x >= 0) {
#line 88
      goto while_break;
    }
#line 85
    y ++;
#line 85
    sx = 0;
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  if (y >= p->w_histheight + flayer->l_height) {
    {
#line 92
    LGotoPos(flayer, markdata___0->cx, markdata___0->cy - markdata___0->hist_offset);
#line 93
    LMsg(0, (char *)"Pattern not found");
    }
  } else {
    {
#line 96
    revto(x, y);
    }
  }
#line 97
  return;
}
}
#line 99 "/home/pronto/abs/test-suite/screen-4.0.2/search.c"
static void backsearchend(char *buf___0 , int len , char *data ) 
{ 
  int sx ;
  int ex ;
  int x ;
  int y ;
  struct markdata *markdata___0 ;
  int tmp ;

  {
#line 105
  x = -1;
#line 108
  markdata___0 = (struct markdata *)flayer->l_data;
#line 109
  markdata___0->isdir = -1;
#line 110
  if (len) {
    {
#line 111
    strcpy((char */* __restrict  */)(markdata___0->isstr), (char const   */* __restrict  */)buf___0);
    }
  }
#line 112
  ex = markdata___0->cx - 1;
#line 113
  y = markdata___0->cy;
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! (y >= 0)) {
#line 113
      goto while_break;
    }
#line 115
    sx = 0;
    {
#line 116
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 116
      sx = matchword(markdata___0->isstr, y, sx, ex);
      }
#line 116
      if (! (sx >= 0)) {
#line 116
        goto while_break___0;
      }
#line 117
      tmp = sx;
#line 117
      sx ++;
#line 117
      x = tmp;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 118
    if (x >= 0) {
#line 119
      goto while_break;
    }
#line 113
    y --;
#line 113
    ex = flayer->l_width - 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  if (y < 0) {
    {
#line 123
    LGotoPos(flayer, markdata___0->cx, markdata___0->cy - markdata___0->hist_offset);
#line 124
    LMsg(0, (char *)"Pattern not found");
    }
  } else {
    {
#line 127
    revto(x, y);
    }
  }
#line 128
  return;
}
}
#line 130 "/home/pronto/abs/test-suite/screen-4.0.2/search.c"
static int matchword(char *pattern , int y , int sx , int ex ) 
{ 
  unsigned char *ip ;
  unsigned char *ipe ;
  unsigned char *cp ;
  unsigned char *pp ;
  struct mline *ml ;
  unsigned char *tmp ;

  {
#line 139
  fore = ((struct markdata *)flayer->l_data)->md_window;
#line 141
  if (y < fore->w_histheight) {
#line 141
    ml = fore->w_hlines + (fore->w_histidx + y) % fore->w_histheight;
  } else {
#line 141
    ml = fore->w_mlines + (y - fore->w_histheight);
  }
#line 142
  ip = ml->image + sx;
#line 143
  ipe = ml->image + flayer->l_width;
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (! (sx <= ex)) {
#line 144
      goto while_break;
    }
#line 146
    tmp = ip;
#line 146
    ip ++;
#line 146
    cp = tmp;
#line 147
    pp = (unsigned char *)pattern;
    {
#line 148
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 150
      if ((int )*cp != (int )*pp) {
#line 151
        if (! search_ic) {
#line 152
          goto while_break___0;
        } else
#line 151
        if (((int )*cp ^ (int )*pp) & 223) {
#line 152
          goto while_break___0;
        } else
#line 151
        if (((int )*cp | 32) < 97) {
#line 152
          goto while_break___0;
        } else
#line 151
        if (((int )*cp | 32) > 122) {
#line 152
          goto while_break___0;
        }
      }
#line 153
      cp ++;
#line 154
      pp ++;
#line 155
      if ((int )*pp == 0) {
#line 156
        return (sx);
      }
#line 157
      if ((unsigned long )cp == (unsigned long )ipe) {
#line 158
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 144
    sx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  return (-1);
}
}
#line 169 "/home/pronto/abs/test-suite/screen-4.0.2/search.c"
static char *isprompts[4]  = {      (char *)"I-search backward: ",      (char *)"failing I-search backward: ",      (char *)"I-search: ",      (char *)"failing I-search: "};
#line 175
static int is_redo(struct markdata *markdata___0 ) ;
#line 176
static void is_process(char *p , int n , char *data ) ;
#line 177
static int is_bm(char *str , int l , int p , int end , int dir ) ;
#line 180 "/home/pronto/abs/test-suite/screen-4.0.2/search.c"
static int is_bm(char *str , int l , int p , int end , int dir ) 
{ 
  int tab[256] ;
  int i ;
  int q ;
  unsigned char *s ;
  unsigned char c ;
  int w ;
  struct mline *tmp ;
  int tmp___0 ;

  {
#line 188
  w = flayer->l_width;
#line 191
  fore = ((struct markdata *)(flayer->l_next)->l_data)->md_window;
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 192
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 193
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 193
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 194
  if (p < 0) {
#line 195
    return (-1);
  } else
#line 194
  if (p + l > end) {
#line 195
    return (-1);
  }
#line 196
  if (l == 0) {
#line 197
    return (p);
  }
#line 198
  if (dir < 0) {
#line 199
    str += l - 1;
  }
#line 200
  i = 0;
  {
#line 200
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 200
    if (! (i < 256)) {
#line 200
      goto while_break___1;
    }
#line 201
    tab[i] = l * dir;
#line 200
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 202
  i = 0;
  {
#line 202
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 202
    if (! (i < l - 1)) {
#line 202
      goto while_break___2;
    }
#line 204
    q = (int )*((unsigned char *)str);
#line 205
    tab[q] = ((l - 1) - i) * dir;
#line 206
    if (search_ic) {
#line 206
      if ((q | 32) >= 97) {
#line 206
        if ((q | 32) <= 122) {
#line 207
          tab[q ^ 32] = ((l - 1) - i) * dir;
        }
      }
    }
#line 202
    i ++;
#line 202
    str += dir;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 209
  if (dir > 0) {
#line 210
    p += l - 1;
  }
  {
#line 211
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 211
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 212
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 212
    if (p >= 0) {
#line 212
      if (! (p < end)) {
#line 212
        goto while_break___4;
      }
    } else {
#line 212
      goto while_break___4;
    }
#line 214
    q = p;
#line 215
    s = (unsigned char *)str;
#line 216
    i = 0;
    {
#line 216
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 218
      if (q / w < fore->w_histheight) {
#line 218
        tmp = fore->w_hlines + (fore->w_histidx + q / w) % fore->w_histheight;
      } else {
#line 218
        tmp = fore->w_mlines + (q / w - fore->w_histheight);
      }
#line 218
      c = *(tmp->image + q % w);
#line 219
      if (i == 0) {
#line 220
        p += tab[(int )c];
      }
#line 221
      if ((int )c != (int )*s) {
#line 222
        if (! search_ic) {
#line 223
          goto while_break___5;
        } else
#line 222
        if (((int )c ^ (int )*s) & 223) {
#line 223
          goto while_break___5;
        } else
#line 222
        if (((int )c | 32) < 97) {
#line 223
          goto while_break___5;
        } else
#line 222
        if (((int )c | 32) > 122) {
#line 223
          goto while_break___5;
        }
      }
#line 224
      q -= dir;
#line 225
      s -= dir;
#line 226
      i ++;
#line 226
      if (i == l) {
#line 227
        if (dir > 0) {
#line 227
          tmp___0 = 1;
        } else {
#line 227
          tmp___0 = - l;
        }
#line 227
        return (q + tmp___0);
      }
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 230
  return (-1);
}
}
#line 235 "/home/pronto/abs/test-suite/screen-4.0.2/search.c"
static void is_process(char *p , int n , char *data ) 
{ 
  int pos ;
  int x ;
  int y ;
  int dir ;
  struct markdata *markdata___0 ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct layer *oldlay ;
  struct canvas *oldcvlist ;
  struct canvas *cv ;
  int tmp___4 ;
  char const   *tmp___5 ;

  {
#line 244
  if (n == 0) {
#line 245
    return;
  }
  {
#line 246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 246
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 247
  markdata___0 = (struct markdata *)(flayer->l_next)->l_data;
#line 249
  pos = markdata___0->cx + markdata___0->cy * flayer->l_width;
#line 250
  LGotoPos(flayer, markdata___0->cx, markdata___0->cy - markdata___0->hist_offset);
  }
  {
#line 254
  if ((int )*p == 7) {
#line 254
    goto case_7;
  }
#line 257
  if ((int )*p == 27) {
#line 257
    goto case_27;
  }
#line 261
  if ((int )*p == 23) {
#line 261
    goto case_23;
  }
#line 261
  if ((int )*p == 11) {
#line 261
    goto case_23;
  }
#line 265
  if ((int )*p == 127) {
#line 265
    goto case_127;
  }
#line 265
  if ((int )*p == 8) {
#line 265
    goto case_127;
  }
#line 273
  if ((int )*p == 18) {
#line 273
    goto case_18;
  }
#line 273
  if ((int )*p == 19) {
#line 273
    goto case_18;
  }
#line 287
  goto switch_default;
  case_7: /* CIL Label */ 
#line 255
  pos = markdata___0->isstartpos;
  case_27: /* CIL Label */ 
#line 258
  *p = (char)0;
#line 259
  goto switch_break;
  case_23: /* CIL Label */ 
  case_11: /* CIL Label */ 
#line 262
  markdata___0->isistrl = 1;
  case_127: /* CIL Label */ 
  case_8: /* CIL Label */ 
#line 266
  if (markdata___0->isistrl == 0) {
#line 267
    return;
  }
  {
#line 268
  (markdata___0->isistrl) --;
#line 269
  pos = is_redo(markdata___0);
#line 270
  *p = (char )'\b';
  }
#line 271
  goto switch_break;
  case_18: /* CIL Label */ 
  case_19: /* CIL Label */ 
#line 274
  if (markdata___0->isistrl >= (int )sizeof(markdata___0->isistr)) {
#line 275
    return;
  }
#line 276
  if ((int )*p == 19) {
#line 276
    dir = 1;
  } else {
#line 276
    dir = -1;
  }
#line 277
  pos += dir;
#line 278
  if (markdata___0->isdir == dir) {
#line 278
    if (markdata___0->isistrl == 0) {
      {
#line 280
      strcpy((char */* __restrict  */)(markdata___0->isistr), (char const   */* __restrict  */)(markdata___0->isstr));
#line 281
      tmp___0 = strlen((char const   *)(markdata___0->isstr));
#line 281
      tmp = (int )tmp___0;
#line 281
      markdata___0->isstrl = tmp;
#line 281
      markdata___0->isistrl = tmp;
      }
#line 282
      goto switch_break;
    }
  }
#line 284
  markdata___0->isdir = dir;
#line 285
  tmp___1 = markdata___0->isistrl;
#line 285
  (markdata___0->isistrl) ++;
#line 285
  markdata___0->isistr[tmp___1] = *p;
#line 286
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 288
  if ((int )*p < 32) {
#line 290
    return;
  } else
#line 288
  if (markdata___0->isistrl >= (int )sizeof(markdata___0->isistr)) {
#line 290
    return;
  } else
#line 288
  if (markdata___0->isstrl >= (int )sizeof(markdata___0->isstr) - 1) {
#line 290
    return;
  }
#line 291
  tmp___2 = markdata___0->isstrl;
#line 291
  (markdata___0->isstrl) ++;
#line 291
  markdata___0->isstr[tmp___2] = *p;
#line 292
  tmp___3 = markdata___0->isistrl;
#line 292
  (markdata___0->isistrl) ++;
#line 292
  markdata___0->isistr[tmp___3] = *p;
#line 293
  markdata___0->isstr[markdata___0->isstrl] = (char)0;
  {
#line 294
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 294
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
#line 296
  if (*p) {
#line 296
    if ((int )*p != 8) {
      {
#line 297
      pos = is_bm(markdata___0->isstr, markdata___0->isstrl, pos, flayer->l_width * ((markdata___0->md_window)->w_histheight + flayer->l_height),
                  markdata___0->isdir);
      }
    }
  }
#line 298
  if (pos >= 0) {
#line 300
    x = pos % flayer->l_width;
#line 301
    y = pos / flayer->l_width;
    {
#line 302
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 302
      oldlay = flayer;
      {
#line 302
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 302
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 302
      flayer = flayer->l_next;
#line 302
      oldcvlist = flayer->l_cvlist;
      {
#line 302
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 302
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 302
      flayer->l_cvlist = oldlay->l_cvlist;
#line 302
      cv = flayer->l_cvlist;
      {
#line 302
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 302
        if (! cv) {
#line 302
          goto while_break___4;
        }
#line 302
        cv->c_layer = flayer;
#line 302
        cv = cv->c_lnext;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 302
      (*((flayer->l_layfn)->lf_LayRedisplayLine))(flayer->l_height - 1, 0, flayer->l_width - 1,
                                                  0);
#line 302
      revto(x, y);
      }
#line 302
      if (markdata___0->cy - markdata___0->hist_offset == flayer->l_height - 1) {
#line 302
        if (flayer->l_height - 1 > 0) {
#line 302
          tmp___4 = (flayer->l_height - 1) - 1;
        } else {
#line 302
          tmp___4 = 1;
        }
        {
#line 302
        revto_line(markdata___0->cx, markdata___0->cy, tmp___4);
        }
      }
#line 302
      flayer = oldlay;
#line 302
      cv = flayer->l_cvlist;
      {
#line 302
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 302
        if (! cv) {
#line 302
          goto while_break___5;
        }
#line 302
        cv->c_layer = flayer;
#line 302
        cv = cv->c_lnext;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 302
      (flayer->l_next)->l_cvlist = oldcvlist;
#line 302
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 310
  if (*p) {
#line 311
    if (markdata___0->isstrl) {
#line 311
      tmp___5 = (char const   *)(markdata___0->isstr);
    } else {
#line 311
      tmp___5 = "";
    }
    {
#line 311
    inp_setprompt(isprompts[(markdata___0->isdir + (pos < 0)) + 1], (char *)tmp___5);
    }
  }
  {
#line 312
  flayer->l_x = markdata___0->cx;
#line 313
  flayer->l_y = markdata___0->cy - markdata___0->hist_offset;
#line 314
  LGotoPos(flayer, flayer->l_x, flayer->l_y);
  }
#line 315
  if (! *p) {
#line 318
    (flayer->l_next)->l_x = markdata___0->cx;
#line 319
    (flayer->l_next)->l_y = markdata___0->cy - markdata___0->hist_offset;
  }
#line 321
  return;
}
}
#line 323 "/home/pronto/abs/test-suite/screen-4.0.2/search.c"
static int is_redo(struct markdata *markdata___0 ) 
{ 
  int i ;
  int pos ;
  int npos ;
  int dir ;
  char c ;
  int tmp ;

  {
#line 330
  pos = markdata___0->isstartpos;
#line 330
  npos = pos;
#line 331
  dir = markdata___0->isstartdir;
#line 332
  markdata___0->isstrl = 0;
#line 333
  i = 0;
  {
#line 333
  while (1) {
    while_continue: /* CIL Label */ ;
#line 333
    if (! (i < markdata___0->isistrl)) {
#line 333
      goto while_break;
    }
#line 335
    c = markdata___0->isistr[i];
#line 336
    if ((int )c == 18) {
#line 337
      dir = -1;
#line 337
      pos += dir;
    } else
#line 338
    if ((int )c == 19) {
#line 339
      dir = 1;
#line 339
      pos += dir;
    } else {
#line 341
      tmp = markdata___0->isstrl;
#line 341
      (markdata___0->isstrl) ++;
#line 341
      markdata___0->isstr[tmp] = c;
    }
#line 342
    if (pos >= 0) {
      {
#line 344
      npos = is_bm(markdata___0->isstr, markdata___0->isstrl, pos, flayer->l_width * ((markdata___0->md_window)->w_histheight + flayer->l_height),
                   dir);
      }
#line 345
      if (npos >= 0) {
#line 346
        pos = npos;
      }
    }
#line 333
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 349
  markdata___0->isstr[markdata___0->isstrl] = (char)0;
#line 350
  markdata___0->isdir = dir;
#line 351
  return (npos);
}
}
#line 354 "/home/pronto/abs/test-suite/screen-4.0.2/search.c"
void ISearch(int dir ) 
{ 
  struct markdata *markdata___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 360
  markdata___0 = (struct markdata *)flayer->l_data;
#line 361
  tmp = dir;
#line 361
  markdata___0->isstartdir = tmp;
#line 361
  markdata___0->isdir = tmp;
#line 362
  markdata___0->isstartpos = markdata___0->cx + markdata___0->cy * flayer->l_width;
#line 363
  tmp___0 = 0;
#line 363
  markdata___0->isstrl = tmp___0;
#line 363
  markdata___0->isistrl = tmp___0;
#line 364
  if (markdata___0->cy - markdata___0->hist_offset == flayer->l_height - 1) {
#line 365
    if (flayer->l_height - 1 > 0) {
#line 365
      tmp___1 = (flayer->l_height - 1) - 1;
    } else {
#line 365
      tmp___1 = 1;
    }
    {
#line 365
    revto_line(markdata___0->cx, markdata___0->cy, tmp___1);
    }
  }
  {
#line 366
  Input(isprompts[dir + 1], (int )(sizeof(markdata___0->isstr) - 1UL), 2, & is_process,
        (char *)((void *)0));
#line 368
  LGotoPos(flayer, markdata___0->cx, markdata___0->cy - markdata___0->hist_offset);
#line 369
  flayer->l_x = markdata___0->cx;
#line 370
  flayer->l_y = markdata___0->cy - markdata___0->hist_offset;
  }
#line 371
  return;
}
}
#line 297 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) mkfifo)(char const   *__path ,
                                                                                   __mode_t __mode ) ;
#line 448 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size ) ;
#line 621
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 744
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unlink)(char const   *__name ) ;
#line 138 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int utimes(char const   *__file , struct timeval  const  *__tvp ) ;
#line 135 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 142
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 155
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 32 "/home/pronto/abs/test-suite/screen-4.0.2/extern.h"
void SigHup(int sigsig ) ;
#line 68
void StartRc(char *rcfilename ) ;
#line 332
int MakeServerSocket(void) ;
#line 333
int RecoverSocket(void) ;
#line 335
void ReceiveMsg(void) ;
#line 336
void SendCreateMsg(char *sty , struct NewWindow *nwin ) ;
#line 337
int SendErrorMsg(char *tty , char *buf___0 ) ;
#line 48 "/home/pronto/abs/test-suite/screen-4.0.2/socket.c"
static int CheckPid(int pid ) ;
#line 49
static void ExecCreate(struct msg *mp ) ;
#line 50
static void DoCommandMsg(struct msg *mp ) ;
#line 55
static void FinishAttach(struct msg *m___0 ) ;
#line 56
static void AskPassword(struct msg *m___0 ) ;
#line 59
char *RcFileName ;
#line 60
int ServerSocket ;
#line 61
int lsflag ;
#line 61
int wipeflag ;
#line 74
struct event serv_read ;
#line 105 "/home/pronto/abs/test-suite/screen-4.0.2/socket.c"
int FindSocket(int *fdp , int *nfoundp , int *notherp , char *match ) 
{ 
  DIR *dirp ;
  struct dirent *dp ;
  struct stat st ;
  int mode ;
  int sdirlen ;
  int matchlen ;
  char *name ;
  char *n ;
  int firsts ;
  int sockfd ;
  char *firstn ;
  int nfound ;
  int ngood ;
  int ndead ;
  int nwipe ;
  int npriv ;
  struct sent *slist ;
  struct sent **slisttail ;
  struct sent *sent ;
  struct sent *nsent ;
  size_t tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char *m___0 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;

  {
#line 116
  matchlen = 0;
#line 118
  firsts = -1;
#line 119
  firstn = (char *)((void *)0);
#line 120
  nfound = 0;
#line 120
  ngood = 0;
#line 120
  ndead = 0;
#line 120
  nwipe = 0;
#line 120
  npriv = 0;
#line 128
  if (match) {
    {
#line 130
    tmp = strlen((char const   *)match);
#line 130
    matchlen = (int )tmp;
    }
#line 132
    if (matchlen > 255) {
#line 133
      matchlen = 255;
    }
  }
  {
#line 142
  tmp___0 = strlen((char const   *)(SockPath));
#line 142
  sdirlen = (int )tmp___0;
#line 145
  xseteuid(real_uid);
#line 146
  xsetegid(real_gid);
#line 149
  dirp = opendir((char const   *)(SockPath));
  }
#line 149
  if ((unsigned long )dirp == (unsigned long )((DIR *)0)) {
    {
#line 150
    tmp___1 = __errno_location();
#line 150
    Panic(*tmp___1, (char *)"Cannot opendir %s", SockPath);
    }
  }
#line 152
  slist = (struct sent *)0;
#line 153
  slisttail = & slist;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 154
    dp = readdir(dirp);
    }
#line 154
    if (! dp) {
#line 154
      goto while_break;
    }
#line 156
    name = dp->d_name;
    {
#line 157
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 157
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 158
    if ((int )*name == 0) {
#line 159
      goto while_continue;
    } else
#line 158
    if ((int )*name == 46) {
#line 159
      goto while_continue;
    } else {
      {
#line 158
      tmp___2 = strlen((char const   *)name);
      }
#line 158
      if (tmp___2 > 512U) {
#line 159
        goto while_continue;
      }
    }
#line 160
    if (matchlen) {
#line 162
      n = name;
#line 164
      if ((int )*match <= 48) {
#line 164
        goto _L;
      } else
#line 164
      if ((int )*match > 57) {
        _L: /* CIL Label */ 
#line 164
        if ((int )*n > 48) {
#line 164
          if ((int )*n <= 57) {
            {
#line 166
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 166
              if ((int )*n >= 48) {
#line 166
                if (! ((int )*n <= 57)) {
#line 166
                  goto while_break___1;
                }
              } else {
#line 166
                goto while_break___1;
              }
#line 167
              n ++;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 168
            if ((int )*n == 46) {
#line 169
              n ++;
            }
          }
        }
      }
      {
#line 172
      tmp___3 = strncmp((char const   *)match, "tty", (size_t )3);
      }
#line 172
      if (tmp___3) {
        {
#line 172
        tmp___4 = strncmp((char const   *)n, "tty", (size_t )3);
        }
#line 172
        if (tmp___4 == 0) {
#line 173
          n += 3;
        }
      }
      {
#line 174
      tmp___5 = strncmp((char const   *)match, (char const   *)n, (size_t )matchlen);
      }
#line 174
      if (tmp___5) {
#line 175
        goto while_continue;
      }
      {
#line 176
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 176
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    {
#line 178
    sprintf((char */* __restrict  */)(SockPath + sdirlen), (char const   */* __restrict  */)"/%s",
            name);
    }
    {
#line 180
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 180
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 181
    tmp___6 = __errno_location();
#line 181
    *tmp___6 = 0;
    }
    {
#line 182
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 182
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 183
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 183
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 184
    tmp___7 = stat((char const   */* __restrict  */)(SockPath), (struct stat */* __restrict  */)(& st));
    }
#line 184
    if (tmp___7) {
      {
#line 186
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 186
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 187
      goto while_continue;
    }
    {
#line 193
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 193
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 194
    if (! ((st.st_mode & 61440U) == 4096U)) {
#line 195
      goto while_continue;
    }
    {
#line 206
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 206
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 207
    if ((int )st.st_uid != real_uid) {
#line 208
      goto while_continue;
    }
#line 209
    mode = (int )st.st_mode & 511;
    {
#line 210
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 210
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 212
    if (multi) {
#line 212
      if ((mode & 447) != 385) {
        {
#line 214
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 214
          goto while_break___10;
        }
        while_break___10: /* CIL Label */ ;
        }
        {
#line 215
        tmp___8 = strcmp((char const   *)multi, (char const   *)LoginName);
        }
#line 215
        if (tmp___8) {
          {
#line 217
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 217
            goto while_break___11;
          }
          while_break___11: /* CIL Label */ ;
          }
#line 218
          mode = -4;
        } else {
          {
#line 222
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 222
            goto while_break___12;
          }
          while_break___12: /* CIL Label */ ;
          }
        }
      }
    }
    {
#line 226
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 226
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
    {
#line 227
    tmp___9 = malloc((size_t )sizeof(struct sent ));
#line 227
    sent = (struct sent *)tmp___9;
    }
#line 227
    if ((unsigned long )sent == (unsigned long )((struct sent *)0)) {
#line 228
      goto while_continue;
    }
    {
#line 229
    sent->next = (struct sent *)0;
#line 230
    sent->name = SaveStr((char const   *)name);
#line 231
    sent->mode = mode;
#line 232
    *slisttail = sent;
#line 233
    slisttail = & sent->next;
#line 234
    nfound ++;
#line 235
    sockfd = MakeClientSocket(0);
#line 238
    xseteuid(real_uid);
#line 239
    xsetegid(real_gid);
    }
#line 241
    if (sockfd == -1) {
      {
#line 243
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 243
        goto while_break___14;
      }
      while_break___14: /* CIL Label */ ;
      }
#line 245
      sent->mode = -3;
#line 259
      ndead ++;
#line 260
      sent->mode = -1;
#line 261
      if (wipeflag) {
        {
#line 263
        tmp___10 = unlink((char const   *)(SockPath));
        }
#line 263
        if (tmp___10 == 0) {
#line 265
          sent->mode = -2;
#line 266
          nwipe ++;
        }
      }
#line 269
      goto while_continue;
    }
#line 272
    mode &= 510;
    {
#line 274
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 274
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
    {
#line 275
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 275
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 287
    if (mode != 448) {
#line 287
      if (mode != 384) {
#line 287
        goto _L___0;
      } else {
#line 287
        goto _L___7;
      }
    } else
    _L___7: /* CIL Label */ 
#line 287
    if (dflag) {
#line 287
      if (! rflag) {
#line 287
        if (! xflag) {
#line 287
          if (mode == 384) {
#line 287
            goto _L___0;
          } else {
#line 287
            goto _L___6;
          }
        } else {
#line 287
          goto _L___6;
        }
      } else {
#line 287
        goto _L___6;
      }
    } else
    _L___6: /* CIL Label */ 
#line 287
    if (! dflag) {
#line 287
      if (rflag) {
#line 287
        if (mode == 448) {
#line 287
          if (! xflag) {
#line 287
            goto _L___0;
          } else {
#line 287
            goto _L___3;
          }
        } else {
#line 287
          goto _L___3;
        }
      } else {
#line 287
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 287
    if (! dflag) {
#line 287
      if (! rflag) {
#line 287
        if (! xflag) {
          _L___0: /* CIL Label */ 
          {
#line 292
          close(sockfd);
          }
          {
#line 293
          while (1) {
            while_continue___17: /* CIL Label */ ;
#line 293
            goto while_break___17;
          }
          while_break___17: /* CIL Label */ ;
          }
#line 294
          npriv ++;
#line 295
          goto while_continue;
        }
      }
    }
#line 297
    ngood ++;
#line 298
    if (fdp) {
#line 298
      if (firsts == -1) {
#line 300
        firsts = sockfd;
#line 301
        firstn = sent->name;
        {
#line 302
        while (1) {
          while_continue___18: /* CIL Label */ ;
#line 302
          goto while_break___18;
        }
        while_break___18: /* CIL Label */ ;
        }
      } else {
#line 298
        goto _L___8;
      }
    } else {
      _L___8: /* CIL Label */ 
      {
#line 306
      while (1) {
        while_continue___19: /* CIL Label */ ;
#line 306
        goto while_break___19;
      }
      while_break___19: /* CIL Label */ ;
      }
      {
#line 307
      close(sockfd);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 310
  closedir(dirp);
  }
#line 311
  if (nfound) {
#line 311
    if (lsflag) {
#line 311
      goto _L___9;
    } else
#line 311
    if (ngood != 1) {
      _L___9: /* CIL Label */ 
#line 311
      if (! quietflag) {
        {
#line 315
        if (ngood == 0) {
#line 315
          goto case_0;
        }
#line 318
        if (ngood == 1) {
#line 318
          goto case_1;
        }
#line 321
        goto switch_default;
        case_0: /* CIL Label */ 
#line 316
        if (nfound > 1) {
#line 316
          tmp___11 = "There are screens on:";
        } else {
#line 316
          tmp___11 = "There is a screen on:";
        }
        {
#line 316
        Msg(0, (char *)tmp___11);
        }
#line 317
        goto switch_break;
        case_1: /* CIL Label */ 
#line 319
        if (nfound > 1) {
#line 319
          tmp___12 = "There are several screens on:";
        } else {
#line 319
          tmp___12 = "There is a suitable screen on:";
        }
        {
#line 319
        Msg(0, (char *)tmp___12);
        }
#line 320
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 322
        Msg(0, (char *)"There are several suitable screens on:");
        }
#line 323
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 325
        sent = slist;
        {
#line 325
        while (1) {
          while_continue___20: /* CIL Label */ ;
#line 325
          if (! sent) {
#line 325
            goto while_break___20;
          }
          {
#line 329
          if (sent->mode == 448) {
#line 329
            goto case_448;
          }
#line 332
          if (sent->mode == 384) {
#line 332
            goto case_384;
          }
#line 336
          if (sent->mode == 449) {
#line 336
            goto case_449;
          }
#line 339
          if (sent->mode == 385) {
#line 339
            goto case_385;
          }
#line 343
          if (sent->mode == -1) {
#line 343
            goto case_neg_1;
          }
#line 347
          if (sent->mode == -2) {
#line 347
            goto case_neg_2;
          }
#line 350
          if (sent->mode == -3) {
#line 350
            goto case_neg_3;
          }
#line 353
          if (sent->mode == -4) {
#line 353
            goto case_neg_4;
          }
#line 327
          goto switch_break___0;
          case_448: /* CIL Label */ 
          {
#line 330
          printf((char const   */* __restrict  */)"\t%s\t(Attached)\n", sent->name);
          }
#line 331
          goto switch_break___0;
          case_384: /* CIL Label */ 
          {
#line 333
          printf((char const   */* __restrict  */)"\t%s\t(Detached)\n", sent->name);
          }
#line 334
          goto switch_break___0;
          case_449: /* CIL Label */ 
          {
#line 337
          printf((char const   */* __restrict  */)"\t%s\t(Multi, attached)\n", sent->name);
          }
#line 338
          goto switch_break___0;
          case_385: /* CIL Label */ 
          {
#line 340
          printf((char const   */* __restrict  */)"\t%s\t(Multi, detached)\n", sent->name);
          }
#line 341
          goto switch_break___0;
          case_neg_1: /* CIL Label */ 
          {
#line 345
          printf((char const   */* __restrict  */)"\t%s\t(Dead ?%c?)\n", sent->name,
                 '?');
          }
#line 346
          goto switch_break___0;
          case_neg_2: /* CIL Label */ 
          {
#line 348
          printf((char const   */* __restrict  */)"\t%s\t(Removed)\n", sent->name);
          }
#line 349
          goto switch_break___0;
          case_neg_3: /* CIL Label */ 
          {
#line 351
          printf((char const   */* __restrict  */)"\t%s\t(Remote or dead)\n", sent->name);
          }
#line 352
          goto switch_break___0;
          case_neg_4: /* CIL Label */ 
          {
#line 354
          printf((char const   */* __restrict  */)"\t%s\t(Private)\n", sent->name);
          }
#line 355
          goto switch_break___0;
          switch_break___0: /* CIL Label */ ;
          }
#line 325
          sent = sent->next;
        }
        while_break___20: /* CIL Label */ ;
        }
      }
    }
  }
#line 359
  if (ndead) {
#line 359
    if (! quietflag) {
#line 361
      m___0 = (char *)"Remove dead screens with \'screen -wipe\'.";
#line 362
      if (wipeflag) {
#line 363
        if (nwipe > 1) {
#line 363
          tmp___13 = "s";
        } else {
#line 363
          tmp___13 = "";
        }
        {
#line 363
        Msg(0, (char *)"%d socket%s wiped out.", nwipe, tmp___13);
        }
      } else {
#line 365
        if (ndead > 1) {
#line 365
          tmp___14 = "";
        } else {
#line 365
          tmp___14 = "es";
        }
#line 365
        if (ndead > 1) {
#line 365
          tmp___15 = "s";
        } else {
#line 365
          tmp___15 = "";
        }
        {
#line 365
        Msg(0, m___0, tmp___15, tmp___14);
        }
      }
    }
  }
#line 367
  if (firsts != -1) {
    {
#line 369
    sprintf((char */* __restrict  */)(SockPath + sdirlen), (char const   */* __restrict  */)"/%s",
            firstn);
#line 370
    *fdp = firsts;
    }
  } else {
#line 373
    SockPath[sdirlen] = (char)0;
  }
#line 374
  sent = slist;
  {
#line 374
  while (1) {
    while_continue___21: /* CIL Label */ ;
#line 374
    if (! sent) {
#line 374
      goto while_break___21;
    }
    {
#line 376
    nsent = sent->next;
#line 377
    free((void *)sent->name);
#line 378
    free((void *)((char *)sent));
#line 374
    sent = nsent;
    }
  }
  while_break___21: /* CIL Label */ ;
  }
  {
#line 381
  xseteuid(eff_uid);
#line 382
  xsetegid(eff_gid);
  }
#line 384
  if (notherp) {
#line 385
    *notherp = npriv;
  }
#line 386
  if (nfoundp) {
#line 387
    *nfoundp = nfound - nwipe;
  }
#line 388
  return (ngood);
}
}
#line 400 "/home/pronto/abs/test-suite/screen-4.0.2/socket.c"
int MakeServerSocket(void) 
{ 
  register int s ;
  struct stat st ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;

  {
  {
#line 407
  xseteuid(real_uid);
#line 408
  xsetegid(real_gid);
#line 410
  s = open((char const   *)(SockPath), 2049);
  }
#line 410
  if (s >= 0) {
    {
#line 412
    while (1) {
      while_continue: /* CIL Label */ ;
#line 412
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 413
    if (quietflag) {
      {
#line 415
      Kill(display->d_userpid, 1);
#line 416
      eexit(11);
      }
    }
    {
#line 418
    tmp = Filename(SockPath);
#line 418
    Msg(0, (char *)"There is already a screen running on %s.", tmp);
#line 419
    tmp___1 = stat((char const   */* __restrict  */)(SockPath), (struct stat */* __restrict  */)(& st));
    }
#line 419
    if (tmp___1 == -1) {
      {
#line 420
      tmp___0 = __errno_location();
#line 420
      Panic(*tmp___0, (char *)"stat");
      }
    }
#line 421
    if ((int )st.st_uid != real_uid) {
      {
#line 422
      Panic(0, (char *)"Unfortunatelly you are not its owner.");
      }
    }
#line 423
    if ((st.st_mode & 448U) == 384U) {
      {
#line 424
      Panic(0, (char *)"To resume it, use \"screen -r\"");
      }
    } else {
      {
#line 426
      Panic(0, (char *)"It is not detached.");
      }
    }
  }
  {
#line 430
  unlink((char const   *)(SockPath));
  }
#line 431
  if (displays) {
#line 431
    tmp___2 = 64;
  } else {
#line 431
    tmp___2 = 0;
  }
#line 431
  if (multi) {
#line 431
    tmp___3 = 1;
  } else {
#line 431
    tmp___3 = 0;
  }
  {
#line 431
  tmp___4 = mkfifo((char const   *)(SockPath), (__mode_t )((384 | tmp___2) | tmp___3));
  }
#line 431
  if (tmp___4) {
    {
#line 432
    Panic(0, (char *)"mkfifo %s failed", SockPath);
    }
  }
  {
#line 436
  s = open((char const   *)(SockPath), 2048, 0);
  }
#line 436
  if (s < 0) {
    {
#line 438
    tmp___5 = __errno_location();
#line 438
    Panic(*tmp___5, (char *)"open fifo %s", SockPath);
    }
  }
  {
#line 439
  xseteuid(eff_uid);
#line 440
  xsetegid(eff_gid);
  }
#line 441
  return (s);
}
}
#line 461 "/home/pronto/abs/test-suite/screen-4.0.2/socket.c"
int MakeClientSocket(int err ) 
{ 
  register int s ;
  int *tmp ;

  {
  {
#line 465
  s = 0;
#line 467
  s = secopen(SockPath, 2049, 0);
  }
#line 467
  if (s >= 0) {
    {
#line 469
    fcntl(s, 4, 0);
    }
#line 470
    return (s);
  }
#line 472
  if (err) {
    {
#line 473
    tmp = __errno_location();
#line 473
    Msg(*tmp, (char *)"%s", SockPath);
    }
  }
  {
#line 474
  while (1) {
    while_continue: /* CIL Label */ ;
#line 474
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 475
  return (-1);
}
}
#line 603 "/home/pronto/abs/test-suite/screen-4.0.2/socket.c"
void SendCreateMsg(char *sty , struct NewWindow *nwin ) 
{ 
  int s ;
  struct msg m___0 ;
  register char *p ;
  register int len ;
  register int n ;
  char **av ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  ssize_t tmp___7 ;

  {
  {
#line 612
  av = nwin->args;
#line 615
  tmp = strlen((char const   *)sty);
  }
#line 615
  if (tmp > 255U) {
#line 616
    *(sty + 255) = (char)0;
  }
  {
#line 618
  tmp___0 = strlen((char const   *)sty);
  }
#line 618
  if (tmp___0 > 511U) {
#line 619
    *(sty + 511) = (char)0;
  }
  {
#line 620
  tmp___1 = strlen((char const   *)(SockPath));
#line 620
  sprintf((char */* __restrict  */)(SockPath + tmp___1), (char const   */* __restrict  */)"/%s",
          sty);
#line 621
  s = MakeClientSocket(1);
  }
#line 621
  if (s == -1) {
    {
#line 622
    exit(1);
    }
  }
  {
#line 623
  while (1) {
    while_continue: /* CIL Label */ ;
#line 623
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 624
  bzero((void *)((char *)(& m___0)), (size_t )sizeof(m___0));
#line 625
  m___0.type = 0;
#line 626
  strncpy((char */* __restrict  */)(m___0.m_tty), (char const   */* __restrict  */)attach_tty,
          (size_t )(sizeof(m___0.m_tty) - 1UL));
#line 627
  m___0.m_tty[sizeof(m___0.m_tty) - 1UL] = (char)0;
#line 628
  p = m___0.m.create.line;
#line 629
  n = 0;
  }
#line 630
  if ((unsigned long )nwin->args != (unsigned long )nwin_undef.args) {
#line 631
    av = nwin->args;
    {
#line 631
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 631
      if (*av) {
#line 631
        if (! (n < 63)) {
#line 631
          goto while_break___0;
        }
      } else {
#line 631
        goto while_break___0;
      }
      {
#line 633
      tmp___2 = strlen((char const   *)*av);
#line 633
      len = (int )(tmp___2 + 1U);
      }
#line 634
      if ((unsigned long )(p + len) >= (unsigned long )((m___0.m.create.line + sizeof(m___0.m.create.line)) - 1)) {
#line 635
        goto while_break___0;
      }
      {
#line 636
      strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)*av);
#line 637
      p += len;
#line 631
      av ++;
#line 631
      n ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 639
  if ((unsigned long )nwin->aka != (unsigned long )nwin_undef.aka) {
    {
#line 639
    tmp___3 = strlen((char const   *)nwin->aka);
    }
#line 639
    if ((unsigned long )((p + tmp___3) + 1) < (unsigned long )(m___0.m.create.line + sizeof(m___0.m.create.line))) {
      {
#line 640
      strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)nwin->aka);
      }
    } else {
#line 642
      *p = (char )'\000';
    }
  } else {
#line 642
    *p = (char )'\000';
  }
  {
#line 643
  m___0.m.create.nargs = n;
#line 644
  m___0.m.create.aflag = nwin->aflag;
#line 645
  m___0.m.create.flowflag = nwin->flowflag;
#line 646
  m___0.m.create.lflag = nwin->lflag;
#line 647
  m___0.m.create.hheight = nwin->histheight;
#line 648
  tmp___5 = getcwd(m___0.m.create.dir, (size_t )sizeof(m___0.m.create.dir));
  }
#line 648
  if ((unsigned long )tmp___5 == (unsigned long )((char *)0)) {
    {
#line 650
    tmp___4 = __errno_location();
#line 650
    Msg(*tmp___4, (char *)"getcwd");
    }
#line 651
    return;
  }
#line 653
  if ((unsigned long )nwin->term != (unsigned long )nwin_undef.term) {
    {
#line 654
    strncpy((char */* __restrict  */)(m___0.m.create.screenterm), (char const   */* __restrict  */)nwin->term,
            (size_t )19);
    }
  }
#line 655
  m___0.m.create.screenterm[19] = (char )'\000';
#line 656
  m___0.protocol_revision = ((109 << 24) | (115 << 16)) | (103 << 8);
  {
#line 657
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 657
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 658
  tmp___7 = write(s, (void const   *)((char *)(& m___0)), (size_t )sizeof(m___0));
  }
#line 658
  if ((unsigned long )tmp___7 != sizeof(m___0)) {
    {
#line 659
    tmp___6 = __errno_location();
#line 659
    Msg(*tmp___6, (char *)"write");
    }
  }
  {
#line 660
  close(s);
  }
#line 661
  return;
}
}
#line 663 "/home/pronto/abs/test-suite/screen-4.0.2/socket.c"
int SendErrorMsg(char *tty , char *buf___0 ) 
{ 
  int s ;
  struct msg m___0 ;

  {
  {
#line 670
  strncpy((char */* __restrict  */)(m___0.m.message), (char const   */* __restrict  */)buf___0,
          (size_t )(sizeof(m___0.m.message) - 1UL));
#line 671
  m___0.m.message[sizeof(m___0.m.message) - 1UL] = (char)0;
#line 672
  s = MakeClientSocket(0);
  }
#line 673
  if (s < 0) {
#line 674
    return (-1);
  }
  {
#line 675
  m___0.type = 1;
#line 676
  strncpy((char */* __restrict  */)(m___0.m_tty), (char const   */* __restrict  */)tty,
          (size_t )(sizeof(m___0.m_tty) - 1UL));
#line 677
  m___0.m_tty[sizeof(m___0.m_tty) - 1UL] = (char)0;
#line 678
  m___0.protocol_revision = ((109 << 24) | (115 << 16)) | (103 << 8);
  }
  {
#line 679
  while (1) {
    while_continue: /* CIL Label */ ;
#line 679
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 680
  write(s, (void const   *)((char *)(& m___0)), (size_t )sizeof(m___0));
#line 681
  close(s);
  }
#line 682
  return (0);
}
}
#line 685 "/home/pronto/abs/test-suite/screen-4.0.2/socket.c"
static void ExecCreate(struct msg *mp ) 
{ 
  struct NewWindow nwin ;
  char *args[64] ;
  register int n ;
  register char **pp ;
  register char *p ;
  int l ;
  int num ;
  char buf___0[20] ;
  size_t tmp ;
  int tmp___0 ;
  char **tmp___1 ;
  size_t tmp___2 ;

  {
#line 692
  pp = args;
#line 692
  p = mp->m.create.line;
#line 694
  nwin = nwin_undef;
#line 695
  n = mp->m.create.nargs;
#line 696
  if (n > 63) {
#line 697
    n = 63;
  }
#line 699
  if (n) {
    {
#line 704
    tmp = strlen((char const   *)p);
#line 704
    l = (int )tmp;
#line 705
    tmp___0 = IsNumColon(p, 10, buf___0, (int )sizeof(buf___0));
    }
#line 705
    if (tmp___0) {
#line 707
      if (buf___0[0]) {
#line 708
        nwin.aka = buf___0;
      }
      {
#line 709
      num = atoi((char const   *)p);
      }
#line 710
      if (num < 0) {
#line 711
        num = 0;
      } else
#line 710
      if (num > 39) {
#line 711
        num = 0;
      }
#line 712
      nwin.StartAt = num;
#line 713
      p += l + 1;
#line 714
      n --;
    }
  }
  {
#line 717
  while (1) {
    while_continue: /* CIL Label */ ;
#line 717
    if (! (n > 0)) {
#line 717
      goto while_break;
    }
    {
#line 719
    tmp___1 = pp;
#line 719
    pp ++;
#line 719
    *tmp___1 = p;
#line 720
    tmp___2 = strlen((char const   *)p);
#line 720
    p += tmp___2 + 1U;
#line 717
    n --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 722
  *pp = (char *)0;
#line 723
  if (*p) {
#line 724
    nwin.aka = p;
  }
#line 725
  if (args[0]) {
#line 726
    nwin.args = args;
  }
#line 727
  nwin.aflag = mp->m.create.aflag;
#line 728
  nwin.flowflag = mp->m.create.flowflag;
#line 729
  if (mp->m.create.dir[0]) {
#line 730
    nwin.dir = mp->m.create.dir;
  }
#line 731
  nwin.lflag = mp->m.create.lflag;
#line 732
  nwin.histheight = mp->m.create.hheight;
#line 733
  if (mp->m.create.screenterm[0]) {
#line 734
    nwin.term = mp->m.create.screenterm;
  }
  {
#line 735
  MakeWindow(& nwin);
  }
#line 736
  return;
}
}
#line 738 "/home/pronto/abs/test-suite/screen-4.0.2/socket.c"
static int CheckPid(int pid ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 742
  while (1) {
    while_continue: /* CIL Label */ ;
#line 742
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 743
  if (pid < 2) {
#line 744
    return (-1);
  }
#line 745
  if (eff_uid == real_uid) {
    {
#line 746
    tmp = kill(pid, 0);
    }
#line 746
    return (tmp);
  }
  {
#line 747
  tmp___1 = UserContext();
  }
#line 747
  if (tmp___1 > 0) {
    {
#line 748
    tmp___0 = kill(pid, 0);
#line 748
    UserReturn(tmp___0);
    }
  }
  {
#line 749
  tmp___2 = UserStatus();
  }
#line 749
  return (tmp___2);
}
}
#line 783 "/home/pronto/abs/test-suite/screen-4.0.2/socket.c"
static struct msg m  ;
#line 779 "/home/pronto/abs/test-suite/screen-4.0.2/socket.c"
void ReceiveMsg(void) 
{ 
  int left ;
  int len ;
  int i ;
  char *p ;
  int ns ;
  struct mode Mode ;
  struct win *wi ;
  struct display *next ;
  struct display *olddisplays ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  struct acluser **tmp___9 ;
  int tmp___10 ;
  struct display *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  int *tmp___14 ;
  int tmp___15 ;

  {
#line 785
  ns = ServerSocket;
#line 791
  olddisplays = displays;
  {
#line 794
  while (1) {
    while_continue: /* CIL Label */ ;
#line 794
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 795
  tmp___0 = fcntl(ServerSocket, 4, 0);
  }
#line 795
  if (tmp___0 == -1) {
    {
#line 796
    tmp = __errno_location();
#line 796
    Panic(*tmp, (char *)"BLOCK fcntl");
    }
  }
#line 809
  p = (char *)(& m);
#line 810
  left = (int )sizeof(m);
  {
#line 811
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 811
    if (! (left > 0)) {
#line 811
      goto while_break___0;
    }
    {
#line 813
    len = read(ns, (void *)p, (size_t )left);
    }
#line 814
    if (len < 0) {
      {
#line 814
      tmp___1 = __errno_location();
      }
#line 814
      if (*tmp___1 == 4) {
#line 815
        goto while_continue___0;
      }
    }
#line 816
    if (len <= 0) {
#line 817
      goto while_break___0;
    }
#line 818
    p += len;
#line 819
    left -= len;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 825
  close(ServerSocket);
#line 826
  ServerSocket = secopen(SockPath, 2048, 0);
  }
#line 826
  if (ServerSocket < 0) {
    {
#line 827
    tmp___2 = __errno_location();
#line 827
    Panic(*tmp___2, (char *)"reopen fifo %s", SockPath);
    }
  }
  {
#line 828
  evdeq(& serv_read);
#line 829
  serv_read.fd = ServerSocket;
#line 830
  evenq(& serv_read);
  }
#line 836
  if (len < 0) {
    {
#line 838
    tmp___3 = __errno_location();
#line 838
    Msg(*tmp___3, (char *)"read");
    }
#line 839
    return;
  }
#line 841
  if (left > 0) {
#line 843
    if ((unsigned long )left != sizeof(m)) {
      {
#line 844
      Msg(0, (char *)"Message %d of %d bytes too small", left, (int )sizeof(m));
      }
    } else {
      {
#line 846
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 846
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 847
    return;
  }
#line 849
  if (m.protocol_revision != (((109 << 24) | (115 << 16)) | (103 << 8))) {
    {
#line 851
    Msg(0, (char *)"Invalid message (magic 0x%08x).", m.protocol_revision);
    }
#line 852
    return;
  }
  {
#line 855
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 855
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 856
  display = displays;
  {
#line 856
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 856
    if (! display) {
#line 856
      goto while_break___3;
    }
    {
#line 857
    tmp___4 = strcmp((char const   *)(display->d_usertty), (char const   *)(m.m_tty));
    }
#line 857
    if (tmp___4 == 0) {
#line 858
      goto while_break___3;
    }
#line 856
    display = display->d_next;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 859
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 859
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 860
  wi = (struct win *)0;
#line 861
  if (! display) {
#line 863
    wi = windows;
    {
#line 863
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 863
      if (! wi) {
#line 863
        goto while_break___5;
      }
      {
#line 864
      tmp___5 = strcmp((char const   *)(m.m_tty), (char const   *)(wi->w_tty));
      }
#line 864
      if (! tmp___5) {
#line 867
        if (wi->w_layer.l_cvlist) {
#line 867
          display = (wi->w_layer.l_cvlist)->c_display;
        } else {
#line 867
          display = (struct display *)0;
        }
        {
#line 868
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 868
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 870
        goto while_break___5;
      }
#line 863
      wi = wi->w_next;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 875
  if (display) {
#line 875
    if (display->d_status) {
      {
#line 876
      RemoveStatus();
      }
    }
  }
#line 878
  if (display) {
#line 878
    if (! display->d_tcinited) {
#line 878
      if (m.type != 7) {
#line 879
        return;
      }
    }
  }
  {
#line 883
  if (m.type == 6) {
#line 883
    goto case_6;
  }
#line 887
  if (m.type == 0) {
#line 887
    goto case_0;
  }
#line 899
  if (m.type == 3) {
#line 899
    goto case_3;
  }
#line 905
  if (m.type == 2) {
#line 905
    goto case_2;
  }
#line 1000
  if (m.type == 1) {
#line 1000
    goto case_1;
  }
#line 1003
  if (m.type == 7) {
#line 1003
    goto case_7;
  }
#line 1010
  if (m.type == 5) {
#line 1010
    goto case_5;
  }
#line 1010
  if (m.type == 4) {
#line 1010
    goto case_5;
  }
#line 1025
  if (m.type == 8) {
#line 1025
    goto case_8;
  }
#line 1028
  goto switch_default;
  case_6: /* CIL Label */ 
#line 884
  if (display) {
    {
#line 885
    CheckScreenSize(1);
    }
  }
#line 886
  goto switch_break;
  case_0: /* CIL Label */ 
#line 896
  if (displays) {
    {
#line 897
    ExecCreate(& m);
    }
  }
#line 898
  goto switch_break;
  case_3: /* CIL Label */ 
#line 900
  if (display) {
#line 900
    if (display->d_userpid != 0) {
      {
#line 900
      tmp___6 = kill(display->d_userpid, 0);
      }
#line 900
      if (tmp___6 == 0) {
#line 901
        goto switch_break;
      }
    }
  }
  {
#line 902
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 902
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
  case_2: /* CIL Label */ 
  {
#line 906
  tmp___7 = CheckPid(m.m.attach.apid);
  }
#line 906
  if (tmp___7) {
    {
#line 908
    Msg(0, (char *)"Attach attempt with bad pid(%d)!", m.m.attach.apid);
    }
#line 909
    goto switch_break;
  }
  {
#line 911
  i = secopen(m.m_tty, 2050, 0);
  }
#line 911
  if (i < 0) {
    {
#line 913
    tmp___8 = __errno_location();
#line 913
    Msg(*tmp___8, (char *)"Attach: Could not open %s!", m.m_tty);
#line 914
    Kill(m.m.attach.apid, 1);
    }
#line 915
    goto switch_break;
  }
  {
#line 918
  Kill(m.m.attach.apid, 18);
  }
#line 925
  if (display) {
    {
#line 927
    write(i, (void const   *)"Attaching from inside of screen?\n", (size_t )33);
#line 928
    close(i);
#line 929
    Kill(m.m.attach.apid, 1);
#line 930
    Msg(0, (char *)"Attach msg ignored: coming from inside.");
    }
#line 931
    goto switch_break;
  } else
#line 925
  if (wi) {
    {
#line 927
    write(i, (void const   *)"Attaching from inside of screen?\n", (size_t )33);
#line 928
    close(i);
#line 929
    Kill(m.m.attach.apid, 1);
#line 930
    Msg(0, (char *)"Attach msg ignored: coming from inside.");
    }
#line 931
    goto switch_break;
  }
  {
#line 935
  tmp___10 = strcmp((char const   *)(m.m.attach.auser), (char const   *)LoginName);
  }
#line 935
  if (tmp___10) {
    {
#line 936
    tmp___9 = FindUserPtr(m.m.attach.auser);
    }
#line 936
    if ((unsigned long )*tmp___9 == (unsigned long )((struct acluser *)0)) {
      {
#line 938
      write(i, (void const   *)"Access to session denied.\n", (size_t )26);
#line 939
      close(i);
#line 940
      Kill(m.m.attach.apid, 1);
#line 941
      Msg(0, (char *)"Attach: access denied for user %s.", m.m.attach.auser);
      }
#line 942
      goto switch_break;
    }
  }
  {
#line 946
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 946
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 958
  GetTTY(i, & Mode);
#line 959
  tmp___11 = MakeDisplay(m.m.attach.auser, m.m_tty, m.m.attach.envterm, i, m.m.attach.apid,
                         & Mode);
  }
#line 959
  if ((unsigned long )tmp___11 == (unsigned long )((struct display *)0)) {
    {
#line 961
    write(i, (void const   *)"Could not make display.\n", (size_t )24);
#line 962
    close(i);
#line 963
    Msg(0, (char *)"Attach: could not make display for user %s", m.m.attach.auser);
#line 964
    Kill(m.m.attach.apid, 1);
    }
#line 965
    goto switch_break;
  }
#line 969
  if (m.m.attach.encoding == 1) {
#line 969
    display->d_encoding = 8;
  } else {
#line 969
    if (m.m.attach.encoding) {
#line 969
      tmp___12 = m.m.attach.encoding - 1;
    } else {
#line 969
      tmp___12 = 0;
    }
#line 969
    display->d_encoding = tmp___12;
  }
#line 973
  if (display->d_encoding < 0) {
#line 974
    display->d_encoding = 0;
  } else {
    {
#line 973
    tmp___13 = EncodingName(display->d_encoding);
    }
#line 973
    if (! tmp___13) {
#line 974
      display->d_encoding = 0;
    }
  }
#line 977
  if (iflag) {
#line 977
    if (olddisplays) {
      {
#line 979
      iflag = 0;
#line 981
      olddisplays->d_NewMode.tio.c_cc[0] = (cc_t )'\000';
#line 982
      olddisplays->d_NewMode.tio.c_lflag &= 4294967294U;
#line 986
      SetTTY(olddisplays->d_userfd, & olddisplays->d_NewMode);
      }
    }
  }
  {
#line 988
  SetMode(& display->d_OldMode, & display->d_NewMode, display->d_flow, iflag);
#line 989
  SetTTY(display->d_userfd, & display->d_NewMode);
#line 990
  tmp___15 = fcntl(display->d_userfd, 4, 2048);
  }
#line 990
  if (tmp___15) {
    {
#line 991
    tmp___14 = __errno_location();
#line 991
    Msg(*tmp___14, (char *)"Warning: NBLOCK fcntl failed");
    }
  }
#line 994
  if ((display->d_user)->u_password) {
#line 994
    if (*((display->d_user)->u_password)) {
      {
#line 995
      AskPassword(& m);
      }
    } else {
      {
#line 998
      FinishAttach(& m);
      }
    }
  } else {
    {
#line 998
    FinishAttach(& m);
    }
  }
#line 999
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1001
  Msg(0, (char *)"%s", m.m.message);
  }
#line 1002
  goto switch_break;
  case_7: /* CIL Label */ 
#line 1004
  if (! wi) {
    {
#line 1005
    Hangup();
    }
  }
#line 1006
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 1012
  display = displays;
  {
#line 1012
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 1012
    if (! display) {
#line 1012
      goto while_break___9;
    }
#line 1014
    next = display->d_next;
#line 1016
    if (m.type == 5) {
      {
#line 1017
      Detach(4);
      }
    } else
#line 1020
    if (m.type == 4) {
      {
#line 1021
      Detach(2);
      }
    }
#line 1012
    display = next;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 1023
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 1026
  DoCommandMsg(& m);
  }
#line 1027
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1029
  Msg(0, (char *)"Invalid message (type %d).", m.type);
  }
  switch_break: /* CIL Label */ ;
  }
#line 1031
  return;
}
}
#line 1061 "/home/pronto/abs/test-suite/screen-4.0.2/socket.c"
int chsock(void) 
{ 
  int r ;
  int euid ;
  __uid_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1064
  tmp = geteuid();
#line 1064
  euid = (int )tmp;
  }
#line 1065
  if (euid != real_uid) {
    {
#line 1067
    tmp___1 = UserContext();
    }
#line 1067
    if (tmp___1 <= 0) {
      {
#line 1068
      tmp___0 = UserStatus();
      }
#line 1068
      return (tmp___0);
    }
  }
#line 1070
  if (displays) {
#line 1070
    tmp___2 = 64;
  } else {
#line 1070
    tmp___2 = 0;
  }
#line 1070
  if (multi) {
#line 1070
    tmp___3 = 1;
  } else {
#line 1070
    tmp___3 = 0;
  }
  {
#line 1070
  r = chmod((char const   *)(SockPath), (__mode_t )((384 | tmp___2) | tmp___3));
#line 1076
  utimes((char const   *)(SockPath), (struct timeval  const  *)((void *)0));
  }
#line 1078
  if (euid != real_uid) {
    {
#line 1079
    UserReturn(r);
    }
  }
#line 1080
  return (r);
}
}
#line 1086 "/home/pronto/abs/test-suite/screen-4.0.2/socket.c"
int RecoverSocket(void) 
{ 
  int tmp ;
  int tmp___0 ;
  __uid_t tmp___1 ;

  {
  {
#line 1089
  close(ServerSocket);
#line 1090
  tmp___1 = geteuid();
  }
#line 1090
  if ((int )tmp___1 != real_uid) {
    {
#line 1092
    tmp___0 = UserContext();
    }
#line 1092
    if (tmp___0 > 0) {
      {
#line 1093
      tmp = unlink((char const   *)(SockPath));
#line 1093
      UserReturn(tmp);
      }
    }
    {
#line 1094
    UserStatus();
    }
  } else {
    {
#line 1097
    unlink((char const   *)(SockPath));
    }
  }
  {
#line 1099
  ServerSocket = MakeServerSocket();
  }
#line 1099
  if (ServerSocket < 0) {
#line 1100
    return (0);
  }
  {
#line 1101
  evdeq(& serv_read);
#line 1102
  serv_read.fd = ServerSocket;
#line 1103
  evenq(& serv_read);
  }
#line 1104
  return (1);
}
}
#line 1108 "/home/pronto/abs/test-suite/screen-4.0.2/socket.c"
static void FinishAttach(struct msg *m___0 ) 
{ 
  char *p ;
  int pid ;
  int noshowwin ;
  struct win *wi ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1117
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1118
  pid = display->d_userpid;
#line 1137
  if (extra_outcap) {
    {
#line 1138
    free((void *)extra_outcap);
    }
  }
#line 1139
  if (extra_incap) {
    {
#line 1140
    free((void *)extra_incap);
    }
  }
#line 1141
  extra_outcap = (char *)0;
#line 1141
  extra_incap = extra_outcap;
  {
#line 1142
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1142
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1145
  p = getenv("SYSSCREENRC");
  }
#line 1145
  if (p) {
    {
#line 1146
    StartRc(p);
    }
  } else {
    {
#line 1149
    StartRc((char *)"/usr/etc/screenrc");
    }
  }
  {
#line 1151
  StartRc(RcFileName);
#line 1152
  tmp = InitTermcap(m___0->m.attach.columns, m___0->m.attach.lines);
  }
#line 1152
  if (tmp) {
    {
#line 1154
    FreeDisplay();
#line 1155
    Kill(pid, 1);
    }
#line 1156
    return;
  }
  {
#line 1158
  MakeDefaultCanvas();
#line 1159
  InitTerm(m___0->m.attach.adaptflag);
  }
#line 1160
  if ((unsigned long )displays->d_next == (unsigned long )((struct display *)0)) {
    {
#line 1161
    chsock();
    }
  }
  {
#line 1162
  xsignal(1, & SigHup);
  }
#line 1163
  if (m___0->m.attach.esc != -1) {
#line 1163
    if (m___0->m.attach.meta_esc != -1) {
#line 1165
      (display->d_user)->u_Esc = m___0->m.attach.esc;
#line 1166
      (display->d_user)->u_MetaEsc = m___0->m.attach.meta_esc;
    }
  }
  {
#line 1175
  RemoveLoginSlot();
  }
#line 1176
  if ((unsigned long )displays->d_next == (unsigned long )((struct display *)0)) {
#line 1177
    wi = windows;
    {
#line 1177
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1177
      if (! wi) {
#line 1177
        goto while_break___1;
      }
#line 1178
      if (wi->w_ptyfd >= 0) {
#line 1178
        if ((unsigned long )wi->w_slot != (unsigned long )((slot_t )-1)) {
          {
#line 1179
          SetUtmp(wi);
          }
        }
      }
#line 1177
      wi = wi->w_next;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1182
  display->d_fore = (struct win *)((void *)0);
  {
#line 1186
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1186
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1187
  if ((display->d_user)->u_detachwin >= 0) {
#line 1188
    fore = wtab[(display->d_user)->u_detachwin];
  } else {
#line 1190
    fore = (struct win *)0;
  }
#line 1193
  if ((display->d_user)->u_detachotherwin >= 0) {
#line 1194
    display->d_other = wtab[(display->d_user)->u_detachotherwin];
  }
#line 1196
  noshowwin = 0;
#line 1197
  if (m___0->m.attach.preselect[0]) {
    {
#line 1199
    tmp___1 = strcmp((char const   *)(m___0->m.attach.preselect), "=");
    }
#line 1199
    if (tmp___1) {
      {
#line 1201
      tmp___0 = strcmp((char const   *)(m___0->m.attach.preselect), "-");
      }
#line 1201
      if (tmp___0) {
        {
#line 1207
        fore = FindNiceWindow(fore, m___0->m.attach.preselect);
        }
      } else {
#line 1203
        fore = (struct win *)0;
#line 1204
        noshowwin = 1;
      }
    } else {
#line 1200
      fore = (struct win *)0;
    }
  } else {
    {
#line 1210
    fore = FindNiceWindow(fore, (char *)0);
    }
  }
#line 1211
  if (fore) {
    {
#line 1212
    SetForeWindow(fore);
    }
  } else
#line 1213
  if (! noshowwin) {
    {
#line 1216
    tmp___2 = AclCheckPermCmd(display->d_user, 0, & comms[166]);
    }
#line 1216
    if (! tmp___2) {
      {
#line 1219
      flayer = (display->d_forecv)->c_layer;
#line 1220
      display_wlist(1, 0);
#line 1221
      noshowwin = 1;
      }
    }
  }
  {
#line 1224
  Activate(0);
#line 1225
  ResetIdle();
  }
#line 1226
  if (! display->d_fore) {
#line 1226
    if (! noshowwin) {
      {
#line 1227
      ShowWindows(-1);
      }
    }
  }
#line 1228
  if ((unsigned long )displays->d_next == (unsigned long )((struct display *)0)) {
#line 1228
    if (console_window) {
      {
#line 1230
      tmp___3 = TtyGrabConsole(console_window->w_ptyfd, 1, (char *)"reattach");
      }
#line 1230
      if (tmp___3 == 0) {
        {
#line 1231
        Msg(0, (char *)"console %s is on window %d", HostName, console_window->w_number);
        }
      }
    }
  }
  {
#line 1233
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1233
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1243
  return;
}
}
#line 1247
static void PasswordProcessInput(char *ibuf , int ilen ) ;
#line 1255 "/home/pronto/abs/test-suite/screen-4.0.2/socket.c"
static void AskPassword(struct msg *m___0 ) 
{ 
  struct pwdata *pwdata ;
  void *tmp ;

  {
  {
#line 1260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1260
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1261
  tmp = malloc((size_t )sizeof(struct pwdata ));
#line 1261
  pwdata = (struct pwdata *)tmp;
  }
#line 1262
  if (! pwdata) {
    {
#line 1263
    Panic(0, strnomem);
    }
  }
  {
#line 1264
  pwdata->l = 0;
#line 1265
  pwdata->m = *m___0;
#line 1266
  display->d_processinputdata = (char *)pwdata;
#line 1267
  display->d_processinput = & PasswordProcessInput;
#line 1268
  AddStr((char *)"Screen password: ");
  }
#line 1269
  return;
}
}
#line 1271 "/home/pronto/abs/test-suite/screen-4.0.2/socket.c"
static void PasswordProcessInput(char *ibuf , int ilen ) 
{ 
  struct pwdata *pwdata ;
  int c ;
  int l ;
  char *up ;
  int pid ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1279
  pid = display->d_userpid;
#line 1281
  pwdata = (struct pwdata *)display->d_processinputdata;
#line 1282
  l = pwdata->l;
  {
#line 1283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1283
    tmp___4 = ilen;
#line 1283
    ilen --;
#line 1283
    if (! (tmp___4 > 0)) {
#line 1283
      goto while_break;
    }
#line 1285
    tmp = ibuf;
#line 1285
    ibuf ++;
#line 1285
    c = (int )*((unsigned char *)tmp);
#line 1286
    if (c == 13) {
#line 1286
      goto _L;
    } else
#line 1286
    if (c == 10) {
      _L: /* CIL Label */ 
      {
#line 1288
      up = (display->d_user)->u_password;
#line 1289
      pwdata->buf[l] = (char)0;
#line 1290
      tmp___0 = strlen((char const   *)up);
#line 1290
      tmp___1 = crypt(pwdata->buf, up);
#line 1290
      tmp___2 = strncmp((char const   *)tmp___1, (char const   *)up, tmp___0);
      }
#line 1290
      if (tmp___2) {
        {
#line 1293
        bzero((void *)(pwdata->buf), (size_t )sizeof(pwdata->buf));
#line 1294
        AddStr((char *)"\r\nPassword incorrect.\r\n");
#line 1295
        display->d_processinputdata = (char *)0;
#line 1296
        FreeDisplay();
#line 1297
        Msg(0, (char *)"Illegal reattach attempt from terminal %s.", pwdata->m.m_tty);
#line 1298
        free((void *)pwdata);
#line 1299
        Kill(pid, 1);
        }
#line 1300
        return;
      }
      {
#line 1303
      bzero((void *)(pwdata->buf), (size_t )sizeof(pwdata->buf));
#line 1304
      AddStr((char *)"\r\n");
#line 1305
      display->d_processinputdata = (char *)0;
#line 1306
      display->d_processinput = & ProcessInput;
#line 1307
      FinishAttach(& pwdata->m);
#line 1308
      free((void *)pwdata);
      }
#line 1309
      return;
    }
#line 1311
    if (c == 3) {
      {
#line 1313
      AddStr((char *)"\r\n");
#line 1314
      FreeDisplay();
#line 1315
      Kill(pid, 1);
      }
#line 1316
      return;
    }
#line 1318
    if (c == 8) {
#line 1318
      goto _L___0;
    } else
#line 1318
    if (c == 127) {
      _L___0: /* CIL Label */ 
#line 1320
      if (l > 0) {
#line 1321
        l --;
      }
#line 1322
      goto while_continue;
    }
#line 1324
    if (c == 21) {
#line 1326
      l = 0;
#line 1327
      goto while_continue;
    }
#line 1329
    if (l < (int )sizeof(pwdata->buf) - 1) {
#line 1330
      tmp___3 = l;
#line 1330
      l ++;
#line 1330
      pwdata->buf[tmp___3] = (char )c;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1332
  pwdata->l = l;
#line 1333
  return;
}
}
#line 1336 "/home/pronto/abs/test-suite/screen-4.0.2/socket.c"
static void DoCommandMsg(struct msg *mp ) 
{ 
  char *args[64] ;
  int argl[64] ;
  int n ;
  int *lp ;
  register char **pp ;
  register char *p ;
  struct acluser *user ;
  char **tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;
  struct acluser **tmp___2 ;
  int tmp___3 ;
  int i ;
  int tmp___4 ;
  char *oldrcname ;

  {
#line 1343
  pp = args;
#line 1343
  p = mp->m.command.cmd;
#line 1351
  lp = argl;
#line 1352
  n = mp->m.command.nargs;
#line 1353
  if (n > 63) {
#line 1354
    n = 63;
  }
  {
#line 1355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1355
    if (! (n > 0)) {
#line 1355
      goto while_break;
    }
    {
#line 1357
    tmp = pp;
#line 1357
    pp ++;
#line 1357
    *tmp = p;
#line 1358
    tmp___0 = strlen((char const   *)p);
#line 1358
    *lp = (int )tmp___0;
#line 1359
    tmp___1 = lp;
#line 1359
    lp ++;
#line 1359
    p += *tmp___1 + 1;
#line 1355
    n --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1361
  *pp = (char *)0;
#line 1363
  tmp___2 = FindUserPtr(mp->m.attach.auser);
#line 1363
  user = *tmp___2;
  }
#line 1364
  if ((unsigned long )user == (unsigned long )((struct acluser *)0)) {
    {
#line 1366
    Msg(0, (char *)"Unknown user %s tried to send a command!", mp->m.attach.auser);
    }
#line 1367
    return;
  }
#line 1373
  if (user->u_password) {
#line 1373
    if (*(user->u_password)) {
      {
#line 1375
      Msg(0, (char *)"User %s has a password, cannot use -X option.", mp->m.attach.auser);
      }
#line 1376
      return;
    }
  }
#line 1379
  if (! display) {
#line 1380
    display = displays;
    {
#line 1380
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1380
      if (! display) {
#line 1380
        goto while_break___0;
      }
#line 1381
      if ((unsigned long )display->d_user == (unsigned long )user) {
#line 1382
        goto while_break___0;
      }
#line 1380
      display = display->d_next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1383
  fore = windows;
  {
#line 1383
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1383
    if (! fore) {
#line 1383
      goto while_break___1;
    }
    {
#line 1384
    tmp___3 = strcmp((char const   *)(mp->m_tty), (char const   *)(fore->w_tty));
    }
#line 1384
    if (! tmp___3) {
#line 1386
      if (! display) {
#line 1387
        if (fore->w_layer.l_cvlist) {
#line 1387
          display = (fore->w_layer.l_cvlist)->c_display;
        } else {
#line 1387
          display = (struct display *)0;
        }
      }
#line 1388
      goto while_break___1;
    }
#line 1383
    fore = fore->w_next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1390
  if (! display) {
#line 1391
    display = displays;
  }
#line 1392
  if (mp->m.command.preselect[0]) {
    {
#line 1394
    i = -1;
#line 1395
    tmp___4 = strcmp((char const   *)(mp->m.command.preselect), "-");
    }
#line 1395
    if (tmp___4) {
      {
#line 1396
      i = WindowByNoN(mp->m.command.preselect);
      }
    }
#line 1397
    if (i >= 0) {
#line 1397
      fore = wtab[i];
    } else {
#line 1397
      fore = (struct win *)0;
    }
  } else
#line 1399
  if (! fore) {
#line 1401
    if (display) {
#line 1401
      if ((unsigned long )display->d_user == (unsigned long )user) {
#line 1402
        fore = (struct win *)(((display->d_forecv)->c_layer)->l_bottom)->l_data;
      }
    }
#line 1403
    if (! fore) {
#line 1405
      if (user->u_detachwin >= 0) {
#line 1405
        fore = wtab[user->u_detachwin];
      } else {
#line 1405
        fore = (struct win *)0;
      }
      {
#line 1406
      fore = FindNiceWindow(fore, (char *)0);
      }
    }
  }
#line 1410
  EffectiveAclUser = user;
#line 1412
  if (args[0]) {
#line 1414
    oldrcname = rc_name;
#line 1415
    rc_name = (char *)"-X";
    {
#line 1416
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1416
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1417
    if (fore) {
#line 1417
      flayer = & fore->w_layer;
    } else {
#line 1417
      flayer = (struct layer *)0;
    }
#line 1418
    if (fore) {
#line 1418
      if (fore->w_savelayer) {
#line 1418
        if (fore->w_blocked) {
#line 1419
          flayer = fore->w_savelayer;
        } else
#line 1418
        if ((unsigned long )(fore->w_savelayer)->l_cvlist == (unsigned long )((struct canvas *)0)) {
#line 1419
          flayer = fore->w_savelayer;
        }
      }
    }
    {
#line 1420
    DoCommand(args, argl);
#line 1421
    rc_name = oldrcname;
    }
  }
#line 1424
  EffectiveAclUser = (struct acluser *)0;
#line 1426
  return;
}
}
#line 319 "/home/pronto/abs/test-suite/screen-4.0.2/extern.h"
void FreeAltScreen(struct win *p ) ;
#line 320
void EnterAltScreen(struct win *p ) ;
#line 321
void LeaveAltScreen(struct win *p ) ;
#line 40 "/home/pronto/abs/test-suite/screen-4.0.2/resize.c"
static void CheckMaxSize(int wi ) ;
#line 41
static void FreeMline(struct mline *ml ) ;
#line 42
static int AllocMline(struct mline *ml , int w ) ;
#line 43
static void MakeBlankLine(unsigned char *p , int n ) ;
#line 44
static void kaablamm(void) ;
#line 45
static int BcopyMline(struct mline *mlf , int xf , struct mline *mlt , int xt , int l ,
                      int w ) ;
#line 46
static void SwapAltScreen(struct win *p ) ;
#line 57 "/home/pronto/abs/test-suite/screen-4.0.2/resize.c"
struct winsize glwz  ;
#line 60 "/home/pronto/abs/test-suite/screen-4.0.2/resize.c"
static struct mline mline_zero  =    {(unsigned char *)0, (unsigned char *)0, (unsigned char *)0, (unsigned char *)0};
#line 83 "/home/pronto/abs/test-suite/screen-4.0.2/resize.c"
void CheckScreenSize(int change_flag ) 
{ 
  int wi ;
  int he ;
  int tmp ;

  {
#line 89
  if ((unsigned long )display == (unsigned long )((struct display *)0)) {
    {
#line 91
    while (1) {
      while_continue: /* CIL Label */ ;
#line 91
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 92
    return;
  }
  {
#line 95
  tmp = ioctl(display->d_userfd, 21523UL, (char *)(& glwz));
  }
#line 95
  if (tmp != 0) {
    {
#line 97
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 97
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 98
    wi = display->d_tcs[1].num;
#line 99
    he = display->d_tcs[0].num;
  } else {
#line 103
    wi = (int )glwz.ws_col;
#line 104
    he = (int )glwz.ws_row;
#line 105
    if (wi == 0) {
#line 106
      wi = display->d_tcs[1].num;
    }
#line 107
    if (he == 0) {
#line 108
      he = display->d_tcs[0].num;
    }
  }
  {
#line 115
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 115
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 126
  if (display->d_width == wi) {
#line 126
    if (display->d_height == he) {
      {
#line 128
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 128
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 129
      return;
    }
  }
  {
#line 132
  KillBlanker();
#line 134
  ResetIdle();
#line 135
  ChangeScreenSize(wi, he, change_flag);
  }
#line 141
  return;
}
}
#line 143 "/home/pronto/abs/test-suite/screen-4.0.2/resize.c"
void ChangeScreenSize(int wi , int he , int change_fore ) 
{ 
  struct win *p ;
  struct canvas *cv ;
  struct canvas **cvpp ;
  int wwi ;
  int y ;
  int h ;
  int hn ;

  {
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 154
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 154
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 161
  y = 0;
#line 162
  h = he;
#line 163
  if (display->d_has_hstatus == 1) {
#line 165
    if (h > 1) {
#line 166
      h --;
    } else {
#line 168
      display->d_has_hstatus = 0;
    }
  }
#line 170
  cvpp = & display->d_cvlist;
  {
#line 170
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 170
    cv = *cvpp;
#line 170
    if (! cv) {
#line 170
      goto while_break___1;
    }
#line 172
    if (h < 2) {
#line 172
      if ((unsigned long )cvpp != (unsigned long )(& display->d_cvlist)) {
        {
#line 175
        SetCanvasWindow(cv, (struct win *)0);
#line 176
        *cvpp = cv->c_next;
#line 177
        free((void *)cv);
        }
#line 178
        if ((unsigned long )display->d_forecv == (unsigned long )cv) {
#line 179
          display->d_forecv = (struct canvas *)0;
        }
#line 180
        goto __Cont;
      }
    }
#line 182
    hn = (((cv->c_ye - cv->c_ys) + 1) * he) / display->d_height;
#line 183
    if (hn == 0) {
#line 184
      hn = 1;
    }
#line 185
    if (hn + 2 >= h) {
#line 186
      hn = h - 1;
    } else
#line 185
    if ((unsigned long )cv->c_next == (unsigned long )((struct canvas *)0)) {
#line 186
      hn = h - 1;
    }
#line 187
    if (! captionalways) {
#line 187
      if ((unsigned long )cv == (unsigned long )display->d_cvlist) {
#line 187
        if (h - hn < 2) {
#line 188
          hn = h;
        } else {
#line 187
          goto _L___0;
        }
      } else {
#line 187
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 187
    if (hn == 0) {
#line 188
      hn = h;
    }
    {
#line 189
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 189
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 190
    cv->c_xs = 0;
#line 191
    cv->c_xe = wi - 1;
#line 192
    cv->c_ys = y;
#line 193
    cv->c_ye = (y + hn) - 1;
#line 195
    cv->c_xoff = cv->c_xs;
#line 196
    cv->c_yoff = cv->c_ys;
#line 198
    y += hn + 1;
#line 199
    h -= hn + 1;
#line 200
    cvpp = & cv->c_next;
    __Cont: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 202
  RethinkDisplayViewports();
  }
#line 203
  if ((unsigned long )display->d_forecv == (unsigned long )((struct canvas *)0)) {
#line 204
    display->d_forecv = display->d_cvlist;
  }
#line 205
  if (display->d_forecv) {
#line 206
    display->d_fore = (struct win *)(((display->d_forecv)->c_layer)->l_bottom)->l_data;
  }
  {
#line 208
  display->d_width = wi;
#line 209
  display->d_height = he;
#line 211
  CheckMaxSize(wi);
  }
#line 212
  if (display->d_tcs[44].str) {
#line 214
    display->d_defwidth = display->d_tcs[1].num;
#line 215
    display->d_defheight = display->d_tcs[0].num;
  } else {
#line 219
    if (display->d_tcs[45].str) {
#line 219
      if (wi == Z0width) {
#line 219
        goto _L___1;
      } else
#line 219
      if (wi == Z1width) {
        _L___1: /* CIL Label */ 
#line 219
        if (display->d_tcs[1].num == Z0width) {
#line 221
          display->d_defwidth = display->d_tcs[1].num;
        } else
#line 219
        if (display->d_tcs[1].num == Z1width) {
#line 221
          display->d_defwidth = display->d_tcs[1].num;
        } else {
#line 223
          display->d_defwidth = wi;
        }
      } else {
#line 223
        display->d_defwidth = wi;
      }
    } else {
#line 223
      display->d_defwidth = wi;
    }
#line 224
    display->d_defheight = he;
  }
  {
#line 226
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 226
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 227
  if (change_fore) {
    {
#line 228
    ResizeLayersToCanvases();
    }
  }
#line 229
  if ((unsigned long )display->d_tcs[44].str == (unsigned long )((void *)0)) {
#line 229
    if ((unsigned long )displays->d_next == (unsigned long )((struct display *)0)) {
#line 232
      p = windows;
      {
#line 232
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 232
        if (! p) {
#line 232
          goto while_break___4;
        }
        {
#line 234
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 234
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 235
        wwi = wi;
#line 245
        if (p->w_savelayer) {
#line 245
          if ((unsigned long )(p->w_savelayer)->l_cvlist == (unsigned long )((struct canvas *)0)) {
            {
#line 246
            ResizeLayer(p->w_savelayer, wwi, he, (struct display *)0);
            }
          }
        }
#line 232
        p = p->w_next;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
  }
#line 252
  return;
}
}
#line 254 "/home/pronto/abs/test-suite/screen-4.0.2/resize.c"
void ResizeLayersToCanvases(void) 
{ 
  struct canvas *cv ;
  struct layer *l ;
  int lx ;
  int ly ;
  int tmp ;
  int n ;
  int n___0 ;

  {
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  display->d_kaablamm = 0;
#line 263
  cv = display->d_cvlist;
  {
#line 263
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 263
    if (! cv) {
#line 263
      goto while_break___0;
    }
#line 265
    l = cv->c_layer;
#line 266
    if ((unsigned long )l == (unsigned long )((struct layer *)0)) {
#line 267
      goto __Cont;
    }
    {
#line 268
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 268
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 269
    if (l->l_width == (cv->c_xe - cv->c_xs) + 1) {
#line 269
      if (l->l_height == (cv->c_ye - cv->c_ys) + 1) {
        {
#line 272
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 272
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 273
        goto __Cont;
      }
    }
    {
#line 275
    tmp = MayResizeLayer(l);
    }
#line 275
    if (tmp) {
      {
#line 281
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 281
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 282
      ResizeLayer(l, (cv->c_xe - cv->c_xs) + 1, (cv->c_ye - cv->c_ys) + 1, display);
      }
    } else {
      {
#line 277
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 277
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 286
    lx = (cv->c_layer)->l_x;
#line 287
    ly = (cv->c_layer)->l_y;
#line 288
    if (ly + cv->c_yoff < cv->c_ys) {
      {
#line 290
      cv->c_yoff = cv->c_ys - ly;
#line 291
      RethinkViewportOffsets(cv);
      }
    } else
#line 293
    if (ly + cv->c_yoff > cv->c_ye) {
      {
#line 295
      cv->c_yoff = cv->c_ye - ly;
#line 296
      RethinkViewportOffsets(cv);
      }
    }
#line 298
    if (lx + cv->c_xoff < cv->c_xs) {
#line 300
      n = cv->c_xs - (lx + cv->c_xoff);
#line 301
      if (n < ((cv->c_xe - cv->c_xs) + 1) / 2) {
#line 302
        n = ((cv->c_xe - cv->c_xs) + 1) / 2;
      }
#line 303
      if (cv->c_xoff + n > cv->c_xs) {
#line 304
        n = cv->c_xs - cv->c_xoff;
      }
      {
#line 305
      cv->c_xoff += n;
#line 306
      RethinkViewportOffsets(cv);
      }
    } else
#line 308
    if (lx + cv->c_xoff > cv->c_xe) {
#line 310
      n___0 = (lx + cv->c_xoff) - cv->c_xe;
#line 311
      if (n___0 < ((cv->c_xe - cv->c_xs) + 1) / 2) {
#line 312
        n___0 = ((cv->c_xe - cv->c_xs) + 1) / 2;
      }
#line 313
      if (((cv->c_xoff - n___0) + (cv->c_layer)->l_width) - 1 < cv->c_xe) {
#line 314
        n___0 = ((cv->c_xoff + (cv->c_layer)->l_width) - 1) - cv->c_xe;
      }
      {
#line 315
      cv->c_xoff -= n___0;
#line 316
      RethinkViewportOffsets(cv);
      }
    }
    __Cont: /* CIL Label */ 
#line 263
    cv = cv->c_next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 319
  Redisplay(0);
  }
#line 320
  if (display->d_kaablamm) {
    {
#line 322
    kaablamm();
#line 323
    display->d_kaablamm = 0;
    }
  }
#line 325
  return;
}
}
#line 327 "/home/pronto/abs/test-suite/screen-4.0.2/resize.c"
int MayResizeLayer(struct layer *l ) 
{ 
  int cvs ;

  {
#line 331
  cvs = 0;
  {
#line 332
  while (1) {
    while_continue: /* CIL Label */ ;
#line 332
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 333
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 333
    if (! l) {
#line 333
      goto while_break___0;
    }
#line 335
    if (l->l_cvlist) {
#line 336
      cvs ++;
#line 336
      if (cvs > 1) {
#line 336
        goto _L;
      } else
#line 336
      if ((l->l_cvlist)->c_lnext) {
        _L: /* CIL Label */ 
        {
#line 338
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 338
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 339
        return (0);
      }
    }
#line 333
    l = l->l_next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 342
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 342
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 343
  return (1);
}
}
#line 353 "/home/pronto/abs/test-suite/screen-4.0.2/resize.c"
static void kaablamm(void) 
{ 


  {
  {
#line 356
  Msg(0, (char *)"Aborted because of window size change.");
  }
#line 357
  return;
}
}
#line 359 "/home/pronto/abs/test-suite/screen-4.0.2/resize.c"
void ResizeLayer(struct layer *l , int wi , int he , struct display *norefdisp ) 
{ 
  struct win *p ;
  struct canvas *cv ;
  struct layer *oldflayer ;
  struct display *d ;
  struct display *olddisplay ;
  int tmp ;
  struct display *olddisplay___0 ;
  struct layer *oldflayer___0 ;
  struct layer *l___0 ;
  struct canvas *cvlist ;
  struct canvas *cvlnext ;

  {
#line 367
  oldflayer = flayer;
#line 368
  olddisplay = display;
#line 370
  if (l->l_width == wi) {
#line 370
    if (l->l_height == he) {
#line 371
      return;
    }
  }
#line 372
  p = (struct win *)(l->l_bottom)->l_data;
#line 374
  if (oldflayer) {
#line 374
    if ((unsigned long )l == (unsigned long )oldflayer) {
#line 374
      goto _L;
    } else
#line 374
    if ((unsigned long )((struct win *)(oldflayer->l_bottom)->l_data) == (unsigned long )p) {
      _L: /* CIL Label */ 
      {
#line 375
      while (1) {
        while_continue: /* CIL Label */ ;
#line 375
        if (! oldflayer->l_next) {
#line 375
          goto while_break;
        }
#line 376
        oldflayer = oldflayer->l_next;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 378
  if (p) {
#line 380
    d = displays;
    {
#line 380
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 380
      if (! d) {
#line 380
        goto while_break___0;
      }
#line 381
      cv = d->d_cvlist;
      {
#line 381
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 381
        if (! cv) {
#line 381
          goto while_break___1;
        }
#line 383
        if ((unsigned long )p == (unsigned long )((struct win *)((cv->c_layer)->l_bottom)->l_data)) {
#line 385
          flayer = cv->c_layer;
#line 386
          if (flayer->l_next) {
#line 387
            d->d_kaablamm = 1;
          }
          {
#line 388
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 388
            if (! flayer->l_next) {
#line 388
              goto while_break___2;
            }
            {
#line 389
            ExitOverlayPage();
            }
          }
          while_break___2: /* CIL Label */ ;
          }
        }
#line 381
        cv = cv->c_next;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 380
      d = d->d_next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 392
    l = p->w_savelayer;
  }
#line 394
  flayer = l;
#line 395
  if ((unsigned long )p == (unsigned long )((struct win *)0)) {
#line 395
    if (flayer->l_next) {
#line 395
      if ((unsigned long )(flayer->l_next)->l_next == (unsigned long )((struct layer *)0)) {
        {
#line 395
        tmp = (*((flayer->l_layfn)->lf_LayResize))(wi, he);
        }
#line 395
        if (tmp == 0) {
          {
#line 397
          flayer = flayer->l_next;
#line 398
          (*((flayer->l_layfn)->lf_LayResize))(wi, he);
#line 399
          flayer = l;
          }
        } else {
#line 395
          goto _L___2;
        }
      } else {
#line 395
        goto _L___2;
      }
    } else {
#line 395
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
#line 403
    if (flayer->l_next) {
#line 404
      cv = flayer->l_cvlist;
      {
#line 404
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 404
        if (! cv) {
#line 404
          goto while_break___3;
        }
#line 405
        (cv->c_display)->d_kaablamm = 1;
#line 404
        cv = cv->c_lnext;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    {
#line 406
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 406
      if (! flayer->l_next) {
#line 406
        goto while_break___4;
      }
      {
#line 407
      ExitOverlayPage();
      }
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 409
  if (p) {
#line 410
    flayer = & p->w_layer;
  }
  {
#line 411
  (*((flayer->l_layfn)->lf_LayResize))(wi, he);
#line 413
  l = flayer;
#line 414
  display = displays;
  }
  {
#line 414
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 414
    if (! display) {
#line 414
      goto while_break___5;
    }
#line 416
    if ((unsigned long )display == (unsigned long )norefdisp) {
#line 417
      goto __Cont;
    }
#line 418
    cv = display->d_cvlist;
    {
#line 418
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 418
      if (! cv) {
#line 418
        goto while_break___6;
      }
#line 419
      if ((unsigned long )cv->c_layer == (unsigned long )l) {
        {
#line 421
        olddisplay___0 = display;
#line 421
        oldflayer___0 = flayer;
#line 421
        l___0 = cv->c_layer;
#line 421
        cvlist = l___0->l_cvlist;
#line 421
        cvlnext = cv->c_lnext;
#line 421
        flayer = l___0;
#line 421
        l___0->l_cvlist = cv;
#line 421
        cv->c_lnext = (struct canvas *)0;
#line 421
        (*((flayer->l_layfn)->lf_LayRedisplayLine))(-1, -1, -1, 0);
#line 421
        flayer = oldflayer___0;
#line 421
        l___0->l_cvlist = cvlist;
#line 421
        cv->c_lnext = cvlnext;
#line 421
        display = olddisplay___0;
#line 422
        RefreshArea(cv->c_xs, cv->c_ys, cv->c_xe, cv->c_ye, 0);
        }
      }
#line 418
      cv = cv->c_next;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 424
    if (display->d_kaablamm) {
      {
#line 426
      kaablamm();
#line 427
      display->d_kaablamm = 0;
      }
    }
    __Cont: /* CIL Label */ 
#line 414
    display = display->d_next;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 430
  flayer = oldflayer;
#line 431
  display = olddisplay;
#line 432
  return;
}
}
#line 435 "/home/pronto/abs/test-suite/screen-4.0.2/resize.c"
static void FreeMline(struct mline *ml ) 
{ 


  {
#line 439
  if (ml->image) {
    {
#line 440
    free((void *)ml->image);
    }
  }
#line 441
  if (ml->attr) {
#line 441
    if ((unsigned long )ml->attr != (unsigned long )null) {
      {
#line 442
      free((void *)ml->attr);
      }
    }
  }
#line 444
  if (ml->font) {
#line 444
    if ((unsigned long )ml->font != (unsigned long )null) {
      {
#line 445
      free((void *)ml->font);
      }
    }
  }
#line 448
  if (ml->color) {
#line 448
    if ((unsigned long )ml->color != (unsigned long )null) {
      {
#line 449
      free((void *)ml->color);
      }
    }
  }
#line 455
  *ml = mline_zero;
#line 456
  return;
}
}
#line 458 "/home/pronto/abs/test-suite/screen-4.0.2/resize.c"
static int AllocMline(struct mline *ml , int w ) 
{ 
  void *tmp ;

  {
  {
#line 463
  tmp = malloc((size_t )w);
#line 463
  ml->image = (unsigned char *)tmp;
#line 464
  ml->attr = null;
#line 466
  ml->font = null;
#line 469
  ml->color = null;
  }
#line 474
  if ((unsigned long )ml->image == (unsigned long )((unsigned char *)0)) {
#line 475
    return (-1);
  }
#line 476
  return (0);
}
}
#line 480 "/home/pronto/abs/test-suite/screen-4.0.2/resize.c"
static int BcopyMline(struct mline *mlf , int xf , struct mline *mlt , int xt , int l ,
                      int w ) 
{ 
  int r ;
  unsigned char *tmp ;
  void *tmp___0 ;
  unsigned char *tmp___1 ;
  void *tmp___2 ;
  unsigned char *tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 485
  r = 0;
#line 487
  bcopy((void const   *)((char *)mlf->image + xf), (void *)((char *)mlt->image + xt),
        (size_t )l);
  }
#line 488
  if ((unsigned long )mlf->attr != (unsigned long )null) {
#line 488
    if ((unsigned long )mlt->attr == (unsigned long )null) {
      {
#line 490
      tmp___0 = malloc((size_t )w);
#line 490
      tmp = (unsigned char *)tmp___0;
#line 490
      mlt->attr = tmp;
      }
#line 490
      if ((unsigned long )tmp == (unsigned long )((unsigned char *)0)) {
#line 491
        mlt->attr = null;
#line 491
        r = -1;
      }
      {
#line 492
      bzero((void *)((char *)mlt->attr), (size_t )w);
      }
    }
  }
#line 494
  if ((unsigned long )mlt->attr != (unsigned long )null) {
    {
#line 495
    bcopy((void const   *)((char *)mlf->attr + xf), (void *)((char *)mlt->attr + xt),
          (size_t )l);
    }
  }
#line 497
  if ((unsigned long )mlf->font != (unsigned long )null) {
#line 497
    if ((unsigned long )mlt->font == (unsigned long )null) {
      {
#line 499
      tmp___2 = malloc((size_t )w);
#line 499
      tmp___1 = (unsigned char *)tmp___2;
#line 499
      mlt->font = tmp___1;
      }
#line 499
      if ((unsigned long )tmp___1 == (unsigned long )((unsigned char *)0)) {
#line 500
        mlt->font = null;
#line 500
        r = -1;
      }
      {
#line 501
      bzero((void *)((char *)mlt->font), (size_t )w);
      }
    }
  }
#line 503
  if ((unsigned long )mlt->font != (unsigned long )null) {
    {
#line 504
    bcopy((void const   *)((char *)mlf->font + xf), (void *)((char *)mlt->font + xt),
          (size_t )l);
    }
  }
#line 507
  if ((unsigned long )mlf->color != (unsigned long )null) {
#line 507
    if ((unsigned long )mlt->color == (unsigned long )null) {
      {
#line 509
      tmp___4 = malloc((size_t )w);
#line 509
      tmp___3 = (unsigned char *)tmp___4;
#line 509
      mlt->color = tmp___3;
      }
#line 509
      if ((unsigned long )tmp___3 == (unsigned long )((unsigned char *)0)) {
#line 510
        mlt->color = null;
#line 510
        r = -1;
      }
      {
#line 511
      bzero((void *)((char *)mlt->color), (size_t )w);
      }
    }
  }
#line 513
  if ((unsigned long )mlt->color != (unsigned long )null) {
    {
#line 514
    bcopy((void const   *)((char *)mlf->color + xf), (void *)((char *)mlt->color + xt),
          (size_t )l);
    }
  }
#line 526
  return (r);
}
}
#line 530 "/home/pronto/abs/test-suite/screen-4.0.2/resize.c"
static int maxwidth  ;
#line 532 "/home/pronto/abs/test-suite/screen-4.0.2/resize.c"
static void CheckMaxSize(int wi ) 
{ 
  unsigned char *oldnull ;
  struct win *p ;
  int i ;
  struct mline *ml ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 536
  oldnull = null;
#line 541
  wi = ((wi + 1) + 255) & -256;
#line 542
  if (wi <= maxwidth) {
#line 543
    return;
  }
#line 544
  maxwidth = wi;
  {
#line 545
  while (1) {
    while_continue: /* CIL Label */ ;
#line 545
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 546
  tmp = xrealloc((char *)blank, maxwidth);
#line 546
  blank = (unsigned char *)tmp;
#line 547
  tmp___0 = xrealloc((char *)null, maxwidth);
#line 547
  null = (unsigned char *)tmp___0;
#line 548
  tmp___1 = xrealloc((char *)mline_old.image, maxwidth);
#line 548
  mline_old.image = (unsigned char *)tmp___1;
#line 549
  tmp___2 = xrealloc((char *)mline_old.attr, maxwidth);
#line 549
  mline_old.attr = (unsigned char *)tmp___2;
#line 551
  tmp___3 = xrealloc((char *)mline_old.font, maxwidth);
#line 551
  mline_old.font = (unsigned char *)tmp___3;
#line 554
  tmp___4 = xrealloc((char *)mline_old.color, maxwidth);
#line 554
  mline_old.color = (unsigned char *)tmp___4;
  }
#line 559
  if (blank) {
#line 559
    if (null) {
#line 559
      if (mline_old.image) {
#line 559
        if (mline_old.attr) {
#line 559
          if (mline_old.font) {
#line 559
            if (! mline_old.color) {
              {
#line 560
              Panic(0, strnomem);
              }
            }
          } else {
            {
#line 560
            Panic(0, strnomem);
            }
          }
        } else {
          {
#line 560
          Panic(0, strnomem);
          }
        }
      } else {
        {
#line 560
        Panic(0, strnomem);
        }
      }
    } else {
      {
#line 560
      Panic(0, strnomem);
      }
    }
  } else {
    {
#line 560
    Panic(0, strnomem);
    }
  }
  {
#line 562
  MakeBlankLine(blank, maxwidth);
#line 563
  bzero((void *)((char *)null), (size_t )maxwidth);
#line 565
  mline_blank.image = blank;
#line 566
  mline_blank.attr = null;
#line 567
  mline_null.image = null;
#line 568
  mline_null.attr = null;
#line 570
  mline_blank.font = null;
#line 571
  mline_null.font = null;
#line 574
  mline_blank.color = null;
#line 575
  mline_null.color = null;
#line 585
  p = windows;
  }
  {
#line 585
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 585
    if (! p) {
#line 585
      goto while_break___0;
    }
#line 587
    ml = p->w_mlines;
#line 588
    i = 0;
    {
#line 588
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 588
      if (! (i < p->w_layer.l_height)) {
#line 588
        goto while_break___1;
      }
#line 590
      if ((unsigned long )ml->attr == (unsigned long )oldnull) {
#line 591
        ml->attr = null;
      }
#line 593
      if ((unsigned long )ml->font == (unsigned long )oldnull) {
#line 594
        ml->font = null;
      }
#line 597
      if ((unsigned long )ml->color == (unsigned long )oldnull) {
#line 598
        ml->color = null;
      }
#line 588
      i ++;
#line 588
      ml ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 606
    ml = p->w_hlines;
#line 607
    i = 0;
    {
#line 607
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 607
      if (! (i < p->w_histheight)) {
#line 607
        goto while_break___2;
      }
#line 609
      if ((unsigned long )ml->attr == (unsigned long )oldnull) {
#line 610
        ml->attr = null;
      }
#line 612
      if ((unsigned long )ml->font == (unsigned long )oldnull) {
#line 613
        ml->font = null;
      }
#line 616
      if ((unsigned long )ml->color == (unsigned long )oldnull) {
#line 617
        ml->color = null;
      }
#line 607
      i ++;
#line 607
      ml ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 585
    p = p->w_next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 626
  return;
}
}
#line 629 "/home/pronto/abs/test-suite/screen-4.0.2/resize.c"
char *xrealloc(char *mem , int len ) 
{ 
  register char *nmem ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 636
  if ((unsigned long )mem == (unsigned long )((char *)0)) {
    {
#line 637
    tmp = malloc((size_t )len);
    }
#line 637
    return ((char *)tmp);
  }
  {
#line 638
  tmp___0 = realloc((void *)mem, (size_t )len);
#line 638
  nmem = (char *)tmp___0;
  }
#line 638
  if (nmem) {
#line 639
    return (nmem);
  }
  {
#line 640
  free((void *)mem);
  }
#line 641
  return ((char *)0);
}
}
#line 644 "/home/pronto/abs/test-suite/screen-4.0.2/resize.c"
static void MakeBlankLine(unsigned char *p , int n ) 
{ 
  unsigned char *tmp ;
  int tmp___0 ;

  {
  {
#line 649
  while (1) {
    while_continue: /* CIL Label */ ;
#line 649
    tmp___0 = n;
#line 649
    n --;
#line 649
    if (! tmp___0) {
#line 649
      goto while_break;
    }
#line 650
    tmp = p;
#line 650
    p ++;
#line 650
    *tmp = (unsigned char )' ';
  }
  while_break: /* CIL Label */ ;
  }
#line 651
  return;
}
}
#line 672 "/home/pronto/abs/test-suite/screen-4.0.2/resize.c"
int ChangeWindowSize(struct win *p , int wi , int he , int hi ) 
{ 
  struct mline *mlf ;
  struct mline *mlt ;
  struct mline *ml ;
  struct mline *nmlines ;
  struct mline *nhlines ;
  int fy ;
  int ty ;
  int l ;
  int lx ;
  int lf ;
  int lt ;
  int yy ;
  int oty ;
  int addone ;
  int ncx ;
  int ncy ;
  int naka ;
  int t ;
  int y ;
  int shift ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 677
  mlf = (struct mline *)0;
#line 677
  mlt = (struct mline *)0;
#line 682
  if (wi == 0) {
#line 683
    hi = 0;
#line 683
    he = hi;
  }
#line 685
  if (p->w_layer.l_width == wi) {
#line 685
    if (p->w_layer.l_height == he) {
#line 685
      if (p->w_histheight == hi) {
        {
#line 687
        while (1) {
          while_continue: /* CIL Label */ ;
#line 687
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
#line 688
        return (0);
      }
    }
  }
  {
#line 691
  CheckMaxSize(wi);
  }
  {
#line 703
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 703
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 704
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 704
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 705
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 705
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 707
  fy = (p->w_histheight + p->w_layer.l_height) - 1;
#line 708
  ty = (hi + he) - 1;
#line 710
  nhlines = (struct mline *)0;
#line 710
  nmlines = nhlines;
#line 711
  ncx = 0;
#line 712
  ncy = 0;
#line 713
  naka = 0;
#line 715
  if (wi) {
#line 717
    if (wi != p->w_layer.l_width) {
#line 717
      goto _L;
    } else
#line 717
    if (he != p->w_layer.l_height) {
      _L: /* CIL Label */ 
      {
#line 719
      tmp = calloc((size_t )he, (size_t )sizeof(struct mline ));
#line 719
      nmlines = (struct mline *)tmp;
      }
#line 719
      if ((unsigned long )nmlines == (unsigned long )((struct mline *)0)) {
        {
#line 721
        KillWindow(p);
#line 722
        Msg(0, strnomem);
        }
#line 723
        return (-1);
      }
    } else {
      {
#line 728
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 728
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 729
      nmlines = p->w_mlines;
#line 730
      fy -= he;
#line 731
      ty -= he;
#line 732
      ncx = p->w_layer.l_x;
#line 733
      ncy = p->w_layer.l_y;
#line 734
      naka = p->w_autoaka;
    }
  }
#line 738
  if (hi) {
    {
#line 740
    tmp___0 = calloc((size_t )hi, (size_t )sizeof(struct mline ));
#line 740
    nhlines = (struct mline *)tmp___0;
    }
#line 740
    if ((unsigned long )nhlines == (unsigned long )((struct mline *)0)) {
      {
#line 742
      Msg(0, (char *)"No memory for history buffer - turned off");
#line 743
      hi = 0;
#line 744
      ty = he - 1;
      }
    }
  }
#line 750
  addone = 0;
#line 751
  if (p->w_layer.l_width) {
#line 751
    if (p->w_layer.l_x == p->w_layer.l_width) {
      {
#line 753
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 753
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 754
      addone = 1;
#line 755
      (p->w_layer.l_x) --;
    }
  }
#line 759
  if (p->w_layer.l_width == wi) {
#line 761
    ncx = p->w_layer.l_x + addone;
#line 762
    ncy = (p->w_layer.l_y + he) - p->w_layer.l_height;
#line 764
    shift = - ncy;
#line 765
    yy = (p->w_layer.l_y + p->w_histheight) - 1;
    {
#line 765
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 765
      if (yy >= 0) {
#line 765
        if (! (ncy + shift < he)) {
#line 765
          goto while_break___5;
        }
      } else {
#line 765
        goto while_break___5;
      }
#line 767
      if (yy < p->w_histheight) {
#line 767
        ml = p->w_hlines + (p->w_histidx + yy) % p->w_histheight;
      } else {
#line 767
        ml = p->w_mlines + (yy - p->w_histheight);
      }
#line 768
      if ((int )*(ml->image + p->w_layer.l_width) == 32) {
#line 769
        goto while_break___5;
      }
#line 770
      shift ++;
#line 765
      yy --;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 772
    if (shift < 0) {
#line 773
      shift = 0;
    } else {
      {
#line 775
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 775
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 776
    ncy += shift;
#line 777
    if (p->w_autoaka > 0) {
#line 779
      naka = ((p->w_autoaka + he) - p->w_layer.l_height) + shift;
#line 780
      if (naka < 1) {
#line 781
        naka = 0;
      } else
#line 780
      if (naka > he) {
#line 781
        naka = 0;
      }
    }
    {
#line 783
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 783
      tmp___1 = shift;
#line 783
      shift --;
#line 783
      if (! (tmp___1 > 0)) {
#line 783
        goto while_break___7;
      }
#line 785
      if (fy < p->w_histheight) {
#line 785
        ml = p->w_hlines + (p->w_histidx + fy) % p->w_histheight;
      } else {
#line 785
        ml = p->w_mlines + (fy - p->w_histheight);
      }
      {
#line 786
      FreeMline(ml);
#line 787
      fy --;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
  }
  {
#line 790
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 790
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 791
  if (fy >= 0) {
#line 792
    if (fy < p->w_histheight) {
#line 792
      mlf = p->w_hlines + (p->w_histidx + fy) % p->w_histheight;
    } else {
#line 792
      mlf = p->w_mlines + (fy - p->w_histheight);
    }
  }
#line 793
  if (ty >= 0) {
#line 794
    if (ty < hi) {
#line 794
      mlt = nhlines + ty;
    } else {
#line 794
      mlt = nmlines + (ty - hi);
    }
  }
  {
#line 796
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 796
    if (fy >= 0) {
#line 796
      if (! (ty >= 0)) {
#line 796
        goto while_break___9;
      }
    } else {
#line 796
      goto while_break___9;
    }
#line 798
    if (p->w_layer.l_width == wi) {
#line 801
      *mlt = *mlf;
#line 802
      *mlf = mline_zero;
#line 803
      fy --;
#line 803
      if (fy >= 0) {
#line 804
        if (fy < p->w_histheight) {
#line 804
          mlf = p->w_hlines + (p->w_histidx + fy) % p->w_histheight;
        } else {
#line 804
          mlf = p->w_mlines + (fy - p->w_histheight);
        }
      }
#line 805
      ty --;
#line 805
      if (ty >= 0) {
#line 806
        if (ty < hi) {
#line 806
          mlt = nhlines + ty;
        } else {
#line 806
          mlt = nmlines + (ty - hi);
        }
      }
#line 807
      goto while_continue___9;
    }
#line 811
    l = p->w_layer.l_width - 1;
    {
#line 811
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 811
      if (! (l > 0)) {
#line 811
        goto while_break___10;
      }
#line 812
      if ((int )*(mlf->image + l) != 32) {
#line 813
        goto while_break___10;
      } else
#line 812
      if (*(mlf->attr + l)) {
#line 813
        goto while_break___10;
      }
#line 811
      l --;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 814
    if (fy == p->w_layer.l_y + p->w_histheight) {
#line 814
      if (l < p->w_layer.l_x) {
#line 815
        l = p->w_layer.l_x;
      }
    }
#line 816
    l ++;
#line 817
    lf = l;
#line 820
    yy = fy - 1;
    {
#line 820
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 820
      if (! (yy >= 0)) {
#line 820
        goto while_break___11;
      }
#line 822
      if (yy < p->w_histheight) {
#line 822
        ml = p->w_hlines + (p->w_histidx + yy) % p->w_histheight;
      } else {
#line 822
        ml = p->w_mlines + (yy - p->w_histheight);
      }
#line 823
      if ((int )*(ml->image + p->w_layer.l_width) == 32) {
#line 824
        goto while_break___11;
      }
#line 825
      l += p->w_layer.l_width;
#line 820
      yy --;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 829
    lt = (l - 1) % wi + 1;
#line 830
    oty = ty;
    {
#line 831
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 831
      if (l > 0) {
#line 831
        if (fy >= 0) {
#line 831
          if (! (ty >= 0)) {
#line 831
            goto while_break___12;
          }
        } else {
#line 831
          goto while_break___12;
        }
      } else {
#line 831
        goto while_break___12;
      }
#line 833
      if (lt > lf) {
#line 833
        lx = lf;
      } else {
#line 833
        lx = lt;
      }
#line 834
      if ((unsigned long )mlt->image == (unsigned long )((unsigned char *)0)) {
        {
#line 836
        tmp___2 = AllocMline(mlt, wi + 1);
        }
#line 836
        if (tmp___2) {
#line 837
          goto nomem;
        }
        {
#line 838
        MakeBlankLine(mlt->image + lt, wi - lt);
        }
#line 839
        if (oty == ty) {
#line 839
          *(mlt->image + wi) = (unsigned char )' ';
        } else {
#line 839
          *(mlt->image + wi) = (unsigned char)0;
        }
      }
      {
#line 841
      tmp___3 = BcopyMline(mlf, lf - lx, mlt, lt - lx, lx, wi + 1);
      }
#line 841
      if (tmp___3) {
#line 842
        goto nomem;
      }
#line 845
      if (fy == p->w_layer.l_y + p->w_histheight) {
#line 845
        if (lf - lx <= p->w_layer.l_x) {
#line 845
          if (lf > p->w_layer.l_x) {
#line 847
            ncx = ((p->w_layer.l_x + lt) - lf) + addone;
#line 848
            ncy = ty - hi;
#line 849
            if (wi) {
#line 849
              shift = - ncy + (l - lx) / wi;
            } else {
#line 849
              shift = 0;
            }
#line 850
            if (ty + shift > (hi + he) - 1) {
#line 851
              shift = ((hi + he) - 1) - ty;
            }
#line 852
            if (shift > 0) {
              {
#line 854
              while (1) {
                while_continue___13: /* CIL Label */ ;
#line 854
                goto while_break___13;
              }
              while_break___13: /* CIL Label */ ;
              }
#line 855
              y = (hi + he) - 1;
              {
#line 855
              while (1) {
                while_continue___14: /* CIL Label */ ;
#line 855
                if (! (y >= ty)) {
#line 855
                  goto while_break___14;
                }
#line 857
                if (y < hi) {
#line 857
                  mlt = nhlines + y;
                } else {
#line 857
                  mlt = nmlines + (y - hi);
                }
                {
#line 858
                FreeMline(mlt);
                }
#line 859
                if (y - shift < ty) {
#line 860
                  goto __Cont;
                }
#line 861
                if (y - shift < hi) {
#line 861
                  ml = nhlines + (y - shift);
                } else {
#line 861
                  ml = nmlines + ((y - shift) - hi);
                }
#line 862
                *mlt = *ml;
#line 863
                *ml = mline_zero;
                __Cont: /* CIL Label */ 
#line 855
                y --;
              }
              while_break___14: /* CIL Label */ ;
              }
#line 865
              ncy += shift;
#line 866
              ty += shift;
#line 867
              if (ty < hi) {
#line 867
                mlt = nhlines + ty;
              } else {
#line 867
                mlt = nmlines + (ty - hi);
              }
#line 868
              if (naka > 0) {
#line 869
                if (naka + shift > he) {
#line 869
                  naka = 0;
                } else {
#line 869
                  naka += shift;
                }
              }
            }
            {
#line 871
            while (1) {
              while_continue___15: /* CIL Label */ ;
#line 871
              goto while_break___15;
            }
            while_break___15: /* CIL Label */ ;
            }
          }
        }
      }
#line 874
      if (p->w_autoaka > 0) {
#line 874
        if (fy == (p->w_autoaka - 1) + p->w_histheight) {
#line 874
          if (lf - lx <= 0) {
#line 875
            if (ty - hi >= 0) {
#line 875
              naka = (1 + ty) - hi;
            } else {
#line 875
              naka = 0;
            }
          }
        }
      }
#line 877
      lf -= lx;
#line 878
      lt -= lx;
#line 879
      l -= lx;
#line 880
      if (lf == 0) {
        {
#line 882
        FreeMline(mlf);
#line 883
        lf = p->w_layer.l_width;
#line 884
        fy --;
        }
#line 884
        if (fy >= 0) {
#line 885
          if (fy < p->w_histheight) {
#line 885
            mlf = p->w_hlines + (p->w_histidx + fy) % p->w_histheight;
          } else {
#line 885
            mlf = p->w_mlines + (fy - p->w_histheight);
          }
        }
      }
#line 887
      if (lt == 0) {
#line 889
        lt = wi;
#line 890
        ty --;
#line 890
        if (ty >= 0) {
#line 891
          if (ty < hi) {
#line 891
            mlt = nhlines + ty;
          } else {
#line 891
            mlt = nmlines + (ty - hi);
          }
        }
      }
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 894
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 894
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 896
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 896
    if (! (fy >= 0)) {
#line 896
      goto while_break___17;
    }
    {
#line 898
    FreeMline(mlf);
#line 899
    fy --;
    }
#line 899
    if (fy >= 0) {
#line 900
      if (fy < p->w_histheight) {
#line 900
        mlf = p->w_hlines + (p->w_histidx + fy) % p->w_histheight;
      } else {
#line 900
        mlf = p->w_mlines + (fy - p->w_histheight);
      }
    }
  }
  while_break___17: /* CIL Label */ ;
  }
  {
#line 902
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 902
    if (! (ty >= 0)) {
#line 902
      goto while_break___18;
    }
    {
#line 904
    tmp___4 = AllocMline(mlt, wi + 1);
    }
#line 904
    if (tmp___4) {
#line 905
      goto nomem;
    }
    {
#line 906
    MakeBlankLine(mlt->image, wi + 1);
#line 907
    ty --;
    }
#line 907
    if (ty >= 0) {
#line 908
      if (ty < hi) {
#line 908
        mlt = nhlines + ty;
      } else {
#line 908
        mlt = nmlines + (ty - hi);
      }
    }
  }
  while_break___18: /* CIL Label */ ;
  }
#line 920
  if (p->w_mlines) {
#line 920
    if ((unsigned long )p->w_mlines != (unsigned long )nmlines) {
      {
#line 921
      free((void *)((char *)p->w_mlines));
      }
    }
  }
#line 922
  p->w_mlines = nmlines;
#line 924
  if (p->w_hlines) {
#line 924
    if ((unsigned long )p->w_hlines != (unsigned long )nhlines) {
      {
#line 925
      free((void *)((char *)p->w_hlines));
      }
    }
  }
#line 926
  p->w_hlines = nhlines;
#line 928
  nhlines = (struct mline *)0;
#line 928
  nmlines = nhlines;
#line 931
  if (p->w_layer.l_width != wi) {
#line 933
    if (wi) {
#line 935
      if (p->w_tabs) {
#line 935
        t = p->w_layer.l_width;
      } else {
#line 935
        t = 0;
      }
      {
#line 936
      p->w_tabs = xrealloc(p->w_tabs, wi + 1);
      }
#line 937
      if ((unsigned long )p->w_tabs == (unsigned long )((char *)0)) {
        nomem: 
#line 940
        if (nmlines) {
#line 942
          ty = (he + hi) - 1;
          {
#line 942
          while (1) {
            while_continue___19: /* CIL Label */ ;
#line 942
            if (! (ty >= 0)) {
#line 942
              goto while_break___19;
            }
#line 944
            if (ty < hi) {
#line 944
              mlt = nhlines + ty;
            } else {
#line 944
              mlt = nmlines + (ty - hi);
            }
            {
#line 945
            FreeMline(mlt);
#line 942
            ty --;
            }
          }
          while_break___19: /* CIL Label */ ;
          }
#line 947
          if (nmlines) {
#line 947
            if ((unsigned long )p->w_mlines != (unsigned long )nmlines) {
              {
#line 948
              free((void *)((char *)nmlines));
              }
            }
          }
#line 950
          if (nhlines) {
#line 950
            if ((unsigned long )p->w_hlines != (unsigned long )nhlines) {
              {
#line 951
              free((void *)((char *)nhlines));
              }
            }
          }
        }
        {
#line 954
        KillWindow(p);
#line 955
        Msg(0, strnomem);
        }
#line 956
        return (-1);
      }
      {
#line 958
      while (1) {
        while_continue___20: /* CIL Label */ ;
#line 958
        if (! (t < wi)) {
#line 958
          goto while_break___20;
        }
#line 959
        if (t) {
#line 959
          if (! (t & 7)) {
#line 959
            *(p->w_tabs + t) = (char)1;
          } else {
#line 959
            *(p->w_tabs + t) = (char)0;
          }
        } else {
#line 959
          *(p->w_tabs + t) = (char)0;
        }
#line 958
        t ++;
      }
      while_break___20: /* CIL Label */ ;
      }
#line 960
      *(p->w_tabs + wi) = (char)0;
    } else {
#line 964
      if (p->w_tabs) {
        {
#line 965
        free((void *)p->w_tabs);
        }
      }
#line 966
      p->w_tabs = (char *)0;
    }
  }
#line 971
  p->w_Saved_y += ncy - p->w_layer.l_y;
#line 973
  p->w_layer.l_x = ncx;
#line 974
  p->w_layer.l_y = ncy;
#line 975
  if (p->w_autoaka > 0) {
#line 976
    p->w_autoaka = naka;
  }
#line 979
  if (p->w_layer.l_x > wi) {
#line 980
    p->w_layer.l_x = wi;
  }
#line 981
  if (p->w_layer.l_y >= he) {
#line 982
    p->w_layer.l_y = he - 1;
  }
#line 983
  if (p->w_Saved_x > wi) {
#line 984
    p->w_Saved_x = wi;
  }
#line 985
  if (p->w_Saved_y < 0) {
#line 986
    p->w_Saved_y = 0;
  }
#line 987
  if (p->w_Saved_y >= he) {
#line 988
    p->w_Saved_y = he - 1;
  }
#line 991
  p->w_top = 0;
#line 992
  p->w_bot = he - 1;
#line 996
  if (wi) {
#line 996
    if (p->w_layer.l_width != wi) {
#line 996
      goto _L___0;
    } else
#line 996
    if (p->w_layer.l_height != he) {
      _L___0: /* CIL Label */ 
#line 996
      if (p->w_ptyfd >= 0) {
#line 996
        if (p->w_pid) {
#line 998
          glwz.ws_col = (unsigned short )wi;
#line 999
          glwz.ws_row = (unsigned short )he;
          {
#line 1000
          while (1) {
            while_continue___21: /* CIL Label */ ;
#line 1000
            goto while_break___21;
          }
          while_break___21: /* CIL Label */ ;
          }
          {
#line 1001
          tmp___5 = ioctl(p->w_ptyfd, 21524UL, (char *)(& glwz));
          }
#line 1001
          if (tmp___5) {
            {
#line 1002
            while (1) {
              while_continue___22: /* CIL Label */ ;
#line 1002
              goto while_break___22;
            }
            while_break___22: /* CIL Label */ ;
            }
          }
        }
      }
    }
  }
#line 1007
  p->w_layer.l_width = wi;
#line 1008
  p->w_layer.l_height = he;
#line 1010
  p->w_histidx = 0;
#line 1011
  p->w_histheight = hi;
#line 1037
  return (0);
}
}
#line 1040 "/home/pronto/abs/test-suite/screen-4.0.2/resize.c"
void FreeAltScreen(struct win *p ) 
{ 
  int i ;

  {
#line 1046
  if (p->w_alt_mlines) {
#line 1047
    i = 0;
    {
#line 1047
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1047
      if (! (i < p->w_alt_height)) {
#line 1047
        goto while_break;
      }
      {
#line 1048
      FreeMline(p->w_alt_mlines + i);
#line 1047
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1049
  p->w_alt_mlines = (struct mline *)0;
#line 1050
  p->w_alt_width = 0;
#line 1051
  p->w_alt_height = 0;
#line 1052
  p->w_alt_x = 0;
#line 1053
  p->w_alt_y = 0;
#line 1055
  if (p->w_alt_hlines) {
#line 1056
    i = 0;
    {
#line 1056
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1056
      if (! (i < p->w_alt_histheight)) {
#line 1056
        goto while_break___0;
      }
      {
#line 1057
      FreeMline(p->w_alt_hlines + i);
#line 1056
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1058
  p->w_alt_hlines = (struct mline *)0;
#line 1059
  p->w_alt_histidx = 0;
#line 1061
  p->w_alt_histheight = 0;
#line 1062
  return;
}
}
#line 1064 "/home/pronto/abs/test-suite/screen-4.0.2/resize.c"
static void SwapAltScreen(struct win *p ) 
{ 
  struct mline *ml ;
  int t ;

  {
#line 1071
  ml = p->w_alt_mlines;
#line 1071
  p->w_alt_mlines = p->w_mlines;
#line 1071
  p->w_mlines = ml;
#line 1072
  t = p->w_alt_width;
#line 1072
  p->w_alt_width = p->w_layer.l_width;
#line 1072
  p->w_layer.l_width = t;
#line 1073
  t = p->w_alt_height;
#line 1073
  p->w_alt_height = p->w_layer.l_height;
#line 1073
  p->w_layer.l_height = t;
#line 1074
  t = p->w_alt_histheight;
#line 1074
  p->w_alt_histheight = p->w_histheight;
#line 1074
  p->w_histheight = t;
#line 1075
  t = p->w_alt_x;
#line 1075
  p->w_alt_x = p->w_layer.l_x;
#line 1075
  p->w_layer.l_x = t;
#line 1076
  t = p->w_alt_y;
#line 1076
  p->w_alt_y = p->w_layer.l_y;
#line 1076
  p->w_layer.l_y = t;
#line 1078
  ml = p->w_alt_hlines;
#line 1078
  p->w_alt_hlines = p->w_hlines;
#line 1078
  p->w_hlines = ml;
#line 1079
  t = p->w_alt_histidx;
#line 1079
  p->w_alt_histidx = p->w_histidx;
#line 1079
  p->w_histidx = t;
#line 1081
  return;
}
}
#line 1083 "/home/pronto/abs/test-suite/screen-4.0.2/resize.c"
void EnterAltScreen(struct win *p ) 
{ 
  int ox ;
  int oy ;

  {
  {
#line 1087
  ox = p->w_layer.l_x;
#line 1087
  oy = p->w_layer.l_y;
#line 1088
  FreeAltScreen(p);
#line 1089
  SwapAltScreen(p);
#line 1090
  ChangeWindowSize(p, p->w_alt_width, p->w_alt_height, p->w_alt_histheight);
#line 1091
  p->w_layer.l_x = ox;
#line 1092
  p->w_layer.l_y = oy;
  }
#line 1093
  return;
}
}
#line 1095 "/home/pronto/abs/test-suite/screen-4.0.2/resize.c"
void LeaveAltScreen(struct win *p ) 
{ 


  {
#line 1099
  if (! p->w_alt_mlines) {
#line 1100
    return;
  }
  {
#line 1101
  SwapAltScreen(p);
#line 1102
  ChangeWindowSize(p, p->w_alt_width, p->w_alt_height, p->w_alt_histheight);
#line 1103
  FreeAltScreen(p);
  }
#line 1104
  return;
}
}
#line 216 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigemptyset)(sigset_t *__set ) ;
#line 260
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
#line 618 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 624
extern  __attribute__((__nothrow__)) __gid_t getgid(void) ;
#line 627
extern  __attribute__((__nothrow__)) __gid_t getegid(void) ;
#line 648
extern  __attribute__((__nothrow__)) int setreuid(__uid_t __ruid , __uid_t __euid ) ;
#line 665
extern  __attribute__((__nothrow__)) int setregid(__gid_t __rgid , __gid_t __egid ) ;
#line 889
extern  __attribute__((__nothrow__)) int getdtablesize(void) ;
#line 671 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) setenv)(char const   *__name ,
                                                                                   char const   *__value ,
                                                                                   int __replace ) ;
#line 353 "/home/pronto/abs/test-suite/screen-4.0.2/extern.h"
void bclear(char *p , int n ) ;
#line 48 "/home/pronto/abs/test-suite/screen-4.0.2/misc.c"
char *SaveStr(char const   *str ) 
{ 
  register char *cp ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 54
  tmp = strlen(str);
#line 54
  tmp___0 = malloc(tmp + 1U);
#line 54
  cp = (char *)tmp___0;
  }
#line 54
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
    {
#line 55
    Panic(0, strnomem);
    }
  } else {
    {
#line 57
    strcpy((char */* __restrict  */)cp, (char const   */* __restrict  */)str);
    }
  }
#line 58
  return (cp);
}
}
#line 61 "/home/pronto/abs/test-suite/screen-4.0.2/misc.c"
char *SaveStrn(char const   *str , int n ) 
{ 
  register char *cp ;
  void *tmp ;

  {
  {
#line 68
  tmp = malloc((size_t )(n + 1));
#line 68
  cp = (char *)tmp;
  }
#line 68
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
    {
#line 69
    Panic(0, strnomem);
    }
  } else {
    {
#line 72
    bcopy((void const   *)((char *)str), (void *)cp, (size_t )n);
#line 73
    *(cp + n) = (char)0;
    }
  }
#line 75
  return (cp);
}
}
#line 79 "/home/pronto/abs/test-suite/screen-4.0.2/misc.c"
char *InStr(char *str , char const   *pat ) 
{ 
  int npat ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 84
  tmp = strlen(pat);
#line 84
  npat = (int )tmp;
  }
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! *str) {
#line 85
      goto while_break;
    }
    {
#line 86
    tmp___0 = strncmp((char const   *)str, pat, (size_t )npat);
    }
#line 86
    if (! tmp___0) {
#line 87
      return (str);
    }
#line 85
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  return ((char *)0);
}
}
#line 107 "/home/pronto/abs/test-suite/screen-4.0.2/misc.c"
void centerline(char *str , int y ) 
{ 
  int l ;
  int n ;
  size_t tmp ;

  {
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 115
  tmp = strlen((char const   *)str);
#line 115
  n = (int )tmp;
  }
#line 116
  if (n > flayer->l_width - 1) {
#line 117
    n = flayer->l_width - 1;
  }
  {
#line 118
  l = ((flayer->l_width - 1) - n) / 2;
#line 119
  LPutStr(flayer, str, n, & mchar_blank, l, y);
  }
#line 120
  return;
}
}
#line 122 "/home/pronto/abs/test-suite/screen-4.0.2/misc.c"
void leftline(char *str , int y ) 
{ 
  int l ;
  int n ;
  struct mchar mchar_dol ;
  size_t tmp ;

  {
#line 130
  mchar_dol = mchar_blank;
#line 131
  mchar_dol.image = (unsigned char )'$';
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 134
  tmp = strlen((char const   *)str);
#line 134
  n = (int )tmp;
#line 134
  l = n;
  }
#line 135
  if (n > flayer->l_width - 1) {
#line 136
    n = flayer->l_width - 1;
  }
  {
#line 137
  LPutStr(flayer, str, n, & mchar_blank, 0, y);
  }
#line 138
  if (n != l) {
    {
#line 139
    LPutChar(flayer, & mchar_dol, n, y);
    }
  }
#line 140
  return;
}
}
#line 143 "/home/pronto/abs/test-suite/screen-4.0.2/misc.c"
char *Filename(char *s ) 
{ 
  register char *p ;
  char *tmp ;

  {
#line 147
  p = s;
#line 149
  if (p) {
    {
#line 150
    while (1) {
      while_continue: /* CIL Label */ ;
#line 150
      if (! *p) {
#line 150
        goto while_break;
      }
#line 151
      tmp = p;
#line 151
      p ++;
#line 151
      if ((int )*tmp == 47) {
#line 152
        s = p;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 153
  return (s);
}
}
#line 156 "/home/pronto/abs/test-suite/screen-4.0.2/misc.c"
char *stripdev(char *nam ) 
{ 
  int tmp ;

  {
#line 177
  if ((unsigned long )nam == (unsigned long )((void *)0)) {
#line 178
    return ((char *)((void *)0));
  }
  {
#line 179
  tmp = strncmp((char const   *)nam, "/dev/", (size_t )5);
  }
#line 179
  if (tmp == 0) {
#line 180
    return (nam + 5);
  }
#line 182
  return (nam);
}
}
#line 191 "/home/pronto/abs/test-suite/screen-4.0.2/misc.c"
void (*xsignal(int sig , void (*func)(int  ) ))(int  ) 
{ 
  struct sigaction osa ;
  struct sigaction sa ;
  int tmp ;

  {
  {
#line 201
  sa.__sigaction_handler.sa_handler = func;
#line 202
  sigemptyset(& sa.sa_mask);
  }
#line 204
  if (sig == 17) {
#line 204
    sa.sa_flags = 268435456;
  } else {
#line 204
    sa.sa_flags = 0;
  }
  {
#line 208
  tmp = sigaction(sig, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)(& osa));
  }
#line 208
  if (tmp) {
#line 209
    return ((void (*)(int  ))-1);
  }
#line 210
  return (osa.__sigaction_handler.sa_handler);
}
}
#line 264 "/home/pronto/abs/test-suite/screen-4.0.2/misc.c"
void xseteuid(int euid ) 
{ 
  int oeuid ;
  __uid_t tmp ;
  __uid_t tmp___0 ;
  __uid_t tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 270
  tmp = geteuid();
#line 270
  oeuid = (int )tmp;
  }
#line 271
  if (oeuid == euid) {
#line 272
    return;
  }
  {
#line 273
  tmp___1 = getuid();
  }
#line 273
  if ((int )tmp___1 != euid) {
    {
#line 274
    tmp___0 = getuid();
#line 274
    oeuid = (int )tmp___0;
    }
  }
  {
#line 275
  tmp___3 = setreuid((__uid_t )oeuid, (__uid_t )euid);
  }
#line 275
  if (tmp___3) {
    {
#line 276
    tmp___2 = __errno_location();
#line 276
    Panic(*tmp___2, (char *)"setreuid");
    }
  }
#line 277
  return;
}
}
#line 279 "/home/pronto/abs/test-suite/screen-4.0.2/misc.c"
void xsetegid(int egid ) 
{ 
  int oegid ;
  __gid_t tmp ;
  __gid_t tmp___0 ;
  __gid_t tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 285
  tmp = getegid();
#line 285
  oegid = (int )tmp;
  }
#line 286
  if (oegid == egid) {
#line 287
    return;
  }
  {
#line 288
  tmp___1 = getgid();
  }
#line 288
  if ((int )tmp___1 != egid) {
    {
#line 289
    tmp___0 = getgid();
#line 289
    oegid = (int )tmp___0;
    }
  }
  {
#line 290
  tmp___3 = setregid((__gid_t )oegid, (__gid_t )egid);
  }
#line 290
  if (tmp___3) {
    {
#line 291
    tmp___2 = __errno_location();
#line 291
    Panic(*tmp___2, (char *)"setregid");
    }
  }
#line 292
  return;
}
}
#line 318 "/home/pronto/abs/test-suite/screen-4.0.2/misc.c"
void bclear(char *p , int n ) 
{ 


  {
  {
#line 323
  bcopy((void const   *)((char *)blank), (void *)p, (size_t )n);
  }
#line 324
  return;
}
}
#line 327 "/home/pronto/abs/test-suite/screen-4.0.2/misc.c"
void Kill(int pid , int sig ) 
{ 


  {
#line 331
  if (pid < 2) {
#line 332
    return;
  }
  {
#line 333
  kill(pid, sig);
  }
#line 334
  return;
}
}
#line 362 "/home/pronto/abs/test-suite/screen-4.0.2/misc.c"
void closeallfiles(int except ) 
{ 
  int f ;

  {
  {
#line 377
  f = getdtablesize();
  }
  {
#line 379
  while (1) {
    while_continue: /* CIL Label */ ;
#line 379
    f --;
#line 379
    if (! (f > 2)) {
#line 379
      goto while_break;
    }
#line 380
    if (f != except) {
      {
#line 381
      close(f);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 382
  return;
}
}
#line 395 "/home/pronto/abs/test-suite/screen-4.0.2/misc.c"
static int UserSTAT  ;
#line 397 "/home/pronto/abs/test-suite/screen-4.0.2/misc.c"
int UserContext(void) 
{ 


  {
  {
#line 426
  xseteuid(real_uid);
#line 427
  xsetegid(real_gid);
  }
#line 428
  return (1);
}
}
#line 432 "/home/pronto/abs/test-suite/screen-4.0.2/misc.c"
void UserReturn(int val ) 
{ 


  {
  {
#line 442
  xseteuid(eff_uid);
#line 443
  xsetegid(eff_gid);
#line 444
  UserSTAT = val;
  }
#line 446
  return;
}
}
#line 448 "/home/pronto/abs/test-suite/screen-4.0.2/misc.c"
int UserStatus(void) 
{ 


  {
#line 471
  return (UserSTAT);
}
}
#line 488 "/home/pronto/abs/test-suite/screen-4.0.2/misc.c"
int AddXChar(char *buf___0 , int ch ) 
{ 
  char *p ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 493
  p = buf___0;
#line 495
  if (ch < 32) {
#line 495
    goto _L;
  } else
#line 495
  if (ch == 127) {
    _L: /* CIL Label */ 
#line 497
    tmp = p;
#line 497
    p ++;
#line 497
    *tmp = (char )'^';
#line 498
    tmp___0 = p;
#line 498
    p ++;
#line 498
    *tmp___0 = (char )(ch ^ 64);
  } else
#line 500
  if (ch >= 128) {
#line 502
    tmp___1 = p;
#line 502
    p ++;
#line 502
    *tmp___1 = (char )'\\';
#line 503
    tmp___2 = p;
#line 503
    p ++;
#line 503
    *tmp___2 = (char )(((ch >> 6) & 7) + 48);
#line 504
    tmp___3 = p;
#line 504
    p ++;
#line 504
    *tmp___3 = (char )(((ch >> 3) & 7) + 48);
#line 505
    tmp___4 = p;
#line 505
    p ++;
#line 505
    *tmp___4 = (char )((ch & 7) + 48);
  } else {
#line 508
    tmp___5 = p;
#line 508
    p ++;
#line 508
    *tmp___5 = (char )ch;
  }
#line 509
  return ((int )(p - buf___0));
}
}
#line 512 "/home/pronto/abs/test-suite/screen-4.0.2/misc.c"
int AddXChars(char *buf___0 , int len , char *str ) 
{ 
  char *p ;
  char *tmp ;
  int tmp___0 ;

  {
#line 519
  if ((unsigned long )str == (unsigned long )((char *)0)) {
#line 521
    *buf___0 = (char)0;
#line 522
    return (0);
  }
#line 524
  len -= 4;
#line 525
  p = buf___0;
  {
#line 525
  while (1) {
    while_continue: /* CIL Label */ ;
#line 525
    if ((unsigned long )p < (unsigned long )(buf___0 + len)) {
#line 525
      if (! *str) {
#line 525
        goto while_break;
      }
    } else {
#line 525
      goto while_break;
    }
#line 527
    if ((int )*str == 32) {
#line 528
      tmp = p;
#line 528
      p ++;
#line 528
      *tmp = *str;
    } else {
      {
#line 530
      tmp___0 = AddXChar(p, (int )*str);
#line 530
      p += tmp___0;
      }
    }
#line 525
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 532
  *p = (char)0;
#line 533
  return ((int )(p - buf___0));
}
}
#line 564 "/home/pronto/abs/test-suite/screen-4.0.2/misc.c"
void sleep1000(int msec ) 
{ 
  struct timeval t ;

  {
  {
#line 571
  t.tv_sec = (long )(msec / 1000);
#line 572
  t.tv_usec = (long )((msec % 1000) * 1000);
#line 573
  select(0, (fd_set */* __restrict  */)((fd_set *)0), (fd_set */* __restrict  */)((fd_set *)0),
         (fd_set */* __restrict  */)((fd_set *)0), (struct timeval */* __restrict  */)(& t));
  }
#line 574
  return;
}
}
#line 581 "/home/pronto/abs/test-suite/screen-4.0.2/misc.c"
void xsetenv(char *var , char *value ) 
{ 


  {
  {
#line 617
  setenv((char const   *)var, (char const   *)value, 1);
  }
#line 622
  return;
}
}
#line 636
int _delay(int delay , int (*outc)(int  ) ) ;
#line 636 "/home/pronto/abs/test-suite/screen-4.0.2/misc.c"
static short osp2pad[18]  = 
#line 636
  {      (short)0,      (short)2000,      (short)1333,      (short)909, 
        (short)743,      (short)666,      (short)500,      (short)333, 
        (short)166,      (short)83,      (short)55,      (short)41, 
        (short)20,      (short)10,      (short)5,      (short)2, 
        (short)1,      (short)1};
#line 629 "/home/pronto/abs/test-suite/screen-4.0.2/misc.c"
int _delay(int delay , int (*outc)(int  ) ) 
{ 
  int pad ;
  int tmp ;

  {
#line 640
  if ((int )ospeed <= 0) {
#line 641
    return (0);
  } else
#line 640
  if ((int )ospeed >= (int )(sizeof(osp2pad) / sizeof(osp2pad[0]))) {
#line 641
    return (0);
  }
#line 642
  pad = (int )osp2pad[ospeed];
#line 643
  delay = (delay + pad / 2) / pad;
  {
#line 644
  while (1) {
    while_continue: /* CIL Label */ ;
#line 644
    tmp = delay;
#line 644
    delay --;
#line 644
    if (! (tmp > 0)) {
#line 644
      goto while_break;
    }
    {
#line 645
    (*outc)(0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 646
  return (0);
}
}
#line 657 "/home/pronto/abs/test-suite/screen-4.0.2/misc.c"
int (*save_outc)(int  )  ;
#line 667
extern int tputs(char const   * , int  , int (*)(int  ) ) ;
#line 661 "/home/pronto/abs/test-suite/screen-4.0.2/misc.c"
void xtputs(char *str , int affcnt , int (*outc)(int  ) ) 
{ 


  {
  {
#line 668
  save_outc = outc;
#line 669
  tputs((char const   *)str, affcnt, outc);
  }
#line 670
  return;
}
}
#line 672 "/home/pronto/abs/test-suite/screen-4.0.2/misc.c"
int _nc_timed_wait(int mode , int ms , int *tlp ) 
{ 


  {
  {
#line 676
  _delay(ms * 10, save_outc);
  }
#line 677
  return (0);
}
}
#line 42 "/home/pronto/abs/test-suite/screen-4.0.2/mark.c"
static int is_letter(char c ) ;
#line 43
static void nextword(int *xp , int *yp , int flags , int num ) ;
#line 44
static int linestart(int y ) ;
#line 45
static int lineend(int y ) ;
#line 46
static int rem(int x1 , int y1 , int x2 , int y2 , int redisplay , char *pt , int yend ) ;
#line 47
static int eq(int a , int b ) ;
#line 48
static int MarkScrollDownDisplay(int n ) ;
#line 49
static int MarkScrollUpDisplay(int n ) ;
#line 51
static void MarkProcess(char **inbufp , int *inlenp ) ;
#line 52
static void MarkAbort(void) ;
#line 53
static void MarkRedisplayLine(int y , int xs , int xe , int isblank ) ;
#line 54
static int MarkRewrite(int ry , int xs , int xe , struct mchar *rend , int doit ) ;
#line 63 "/home/pronto/abs/test-suite/screen-4.0.2/mark.c"
int pastefont  =    1;
#line 66 "/home/pronto/abs/test-suite/screen-4.0.2/mark.c"
static struct LayFuncs MarkLf  =    {& MarkProcess, & MarkAbort, & MarkRedisplayLine, & DefClearLine, & MarkRewrite,
    & DefResize, & DefRestore};
#line 77 "/home/pronto/abs/test-suite/screen-4.0.2/mark.c"
int join_with_cr  =    0;
#line 78 "/home/pronto/abs/test-suite/screen-4.0.2/mark.c"
int compacthist  =    0;
#line 80 "/home/pronto/abs/test-suite/screen-4.0.2/mark.c"
unsigned char mark_key_tab[256]  ;
#line 82 "/home/pronto/abs/test-suite/screen-4.0.2/mark.c"
static struct markdata *markdata  ;
#line 90 "/home/pronto/abs/test-suite/screen-4.0.2/mark.c"
static int is_letter(char c ) 
{ 


  {
#line 93
  if ((int )c >= 97) {
#line 93
    if ((int )c <= 122) {
#line 101
      return (1);
    } else {
#line 93
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 93
  if ((int )c >= 65) {
#line 93
    if ((int )c <= 90) {
#line 101
      return (1);
    } else {
#line 93
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 93
  if ((int )c >= 48) {
#line 93
    if ((int )c <= 57) {
#line 101
      return (1);
    } else {
#line 93
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 93
  if ((int )c == 95) {
#line 101
    return (1);
  } else
#line 93
  if ((int )c == 46) {
#line 101
    return (1);
  } else
#line 93
  if ((int )c == 64) {
#line 101
    return (1);
  } else
#line 93
  if ((int )c == 58) {
#line 101
    return (1);
  } else
#line 93
  if ((int )c == 37) {
#line 101
    return (1);
  } else
#line 93
  if ((int )c == 33) {
#line 101
    return (1);
  } else
#line 93
  if ((int )c == 45) {
#line 101
    return (1);
  } else
#line 93
  if ((int )c == 43) {
#line 101
    return (1);
  } else
#line 102
  if ((int )c != 32) {
#line 103
    return (2);
  }
#line 104
  return (0);
}
}
#line 107 "/home/pronto/abs/test-suite/screen-4.0.2/mark.c"
static int linestart(int y ) 
{ 
  register int x ;
  register unsigned char *i ;
  struct mline *tmp ;
  unsigned char *tmp___0 ;

  {
#line 114
  x = markdata->left_mar;
#line 114
  if (y < fore->w_histheight) {
#line 114
    tmp = fore->w_hlines + (fore->w_histidx + y) % fore->w_histheight;
  } else {
#line 114
    tmp = fore->w_mlines + (y - fore->w_histheight);
  }
#line 114
  i = tmp->image + x;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! (x < fore->w_layer.l_width - 1)) {
#line 114
      goto while_break;
    }
#line 115
    tmp___0 = i;
#line 115
    i ++;
#line 115
    if ((int )*tmp___0 != 32) {
#line 116
      goto while_break;
    }
#line 114
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 117
  if (x == fore->w_layer.l_width - 1) {
#line 118
    x = markdata->left_mar;
  }
#line 119
  return (x);
}
}
#line 122 "/home/pronto/abs/test-suite/screen-4.0.2/mark.c"
static int lineend(int y ) 
{ 
  register int x ;
  register unsigned char *i ;
  struct mline *tmp ;
  unsigned char *tmp___0 ;

  {
#line 129
  x = markdata->right_mar;
#line 129
  if (y < fore->w_histheight) {
#line 129
    tmp = fore->w_hlines + (fore->w_histidx + y) % fore->w_histheight;
  } else {
#line 129
    tmp = fore->w_mlines + (y - fore->w_histheight);
  }
#line 129
  i = tmp->image + x;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if (! (x >= 0)) {
#line 129
      goto while_break;
    }
#line 130
    tmp___0 = i;
#line 130
    i --;
#line 130
    if ((int )*tmp___0 != 32) {
#line 131
      goto while_break;
    }
#line 129
    x --;
  }
  while_break: /* CIL Label */ ;
  }
#line 132
  if (x < 0) {
#line 133
    x = markdata->left_mar;
  }
#line 134
  return (x);
}
}
#line 152 "/home/pronto/abs/test-suite/screen-4.0.2/mark.c"
static void nextword(int *xp , int *yp , int flags , int num ) 
{ 
  int xx ;
  int yy ;
  register int sx ;
  register int oq ;
  register int q ;
  register int x ;
  register int y ;
  struct mline *ml ;

  {
#line 156
  xx = fore->w_layer.l_width;
#line 156
  yy = fore->w_histheight + fore->w_layer.l_height;
#line 160
  x = *xp;
#line 161
  y = *yp;
#line 162
  if (flags & 1) {
#line 162
    sx = -1;
  } else {
#line 162
    sx = 1;
  }
#line 163
  if (flags & (1 << 1)) {
#line 163
    if (flags & (1 << 2)) {
#line 164
      x += sx;
    }
  }
#line 165
  if (y < fore->w_histheight) {
#line 165
    ml = fore->w_hlines + (fore->w_histidx + y) % fore->w_histheight;
  } else {
#line 165
    ml = fore->w_mlines + (y - fore->w_histheight);
  }
#line 166
  oq = -1;
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 168
    if (x >= xx) {
#line 169
      q = 0;
    } else
#line 168
    if (x < 0) {
#line 169
      q = 0;
    } else
#line 170
    if (flags & (1 << 3)) {
#line 171
      q = (int )*(ml->image + x) == 32;
    } else {
      {
#line 173
      q = is_letter((char )*(ml->image + x));
      }
    }
#line 174
    if (oq >= 0) {
#line 174
      if (oq != q) {
#line 176
        if (oq == 0) {
#line 177
          *xp = x;
        } else
#line 176
        if (! (flags & (1 << 1))) {
#line 177
          *xp = x;
        } else {
#line 179
          *xp = x - sx;
        }
#line 180
        *yp = y;
#line 181
        if (! (flags & (1 << 1))) {
#line 181
          if (q) {
#line 181
            goto _L;
          } else {
#line 181
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 181
        if (flags & (1 << 1)) {
#line 181
          if (oq) {
            _L: /* CIL Label */ 
#line 184
            num --;
#line 184
            if (num <= 0) {
#line 185
              return;
            }
          }
        }
      }
    }
#line 188
    if (x == xx) {
#line 190
      x = -1;
#line 191
      y ++;
#line 191
      if (y >= yy) {
#line 192
        return;
      }
#line 193
      if (y < fore->w_histheight) {
#line 193
        ml = fore->w_hlines + (fore->w_histidx + y) % fore->w_histheight;
      } else {
#line 193
        ml = fore->w_mlines + (y - fore->w_histheight);
      }
    } else
#line 195
    if (x < 0) {
#line 197
      x = xx;
#line 198
      y --;
#line 198
      if (y < 0) {
#line 199
        return;
      }
#line 200
      if (y < fore->w_histheight) {
#line 200
        ml = fore->w_hlines + (fore->w_histidx + y) % fore->w_histheight;
      } else {
#line 200
        ml = fore->w_mlines + (y - fore->w_histheight);
      }
    }
#line 166
    x += sx;
#line 166
    oq = q;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 214 "/home/pronto/abs/test-suite/screen-4.0.2/mark.c"
static int rem(int x1 , int y1 , int x2 , int y2 , int redisplay , char *pt , int yend ) 
{ 
  int i ;
  int j ;
  int from ;
  int to ;
  int ry ;
  int c ;
  int l ;
  unsigned char *im ;
  struct mline *ml ;
  int cf ;
  int font ;
  unsigned char *fo ;
  unsigned char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
#line 220
  l = 0;
#line 228
  markdata->second = 0;
#line 229
  if (y2 < y1) {
#line 229
    goto _L;
  } else
#line 229
  if (y2 == y1) {
#line 229
    if (x2 < x1) {
      _L: /* CIL Label */ 
#line 231
      i = y2;
#line 232
      y2 = y1;
#line 233
      y1 = i;
#line 234
      i = x2;
#line 235
      x2 = x1;
#line 236
      x1 = i;
    }
  }
#line 238
  ry = y1 - markdata->hist_offset;
#line 240
  i = y1;
#line 241
  if (redisplay != 2) {
#line 241
    if ((unsigned long )pt == (unsigned long )((char *)0)) {
#line 241
      if (ry < 0) {
#line 243
        i -= ry;
#line 244
        ry = 0;
      }
    }
  }
  {
#line 246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 246
    if (! (i <= y2)) {
#line 246
      goto while_break;
    }
#line 248
    if (redisplay != 2) {
#line 248
      if ((unsigned long )pt == (unsigned long )((char *)0)) {
#line 248
        if (ry > yend) {
#line 249
          goto while_break;
        }
      }
    }
#line 250
    if (i < fore->w_histheight) {
#line 250
      ml = fore->w_hlines + (fore->w_histidx + i) % fore->w_histheight;
    } else {
#line 250
      ml = fore->w_mlines + (i - fore->w_histheight);
    }
#line 251
    if (i == y1) {
#line 251
      from = x1;
    } else {
#line 251
      from = 0;
    }
#line 252
    if (from < markdata->left_mar) {
#line 253
      from = markdata->left_mar;
    }
#line 254
    to = fore->w_layer.l_width;
#line 254
    im = ml->image + to;
    {
#line 254
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 254
      if (! (to >= 0)) {
#line 254
        goto while_break___0;
      }
#line 255
      tmp = im;
#line 255
      im --;
#line 255
      if ((int )*tmp != 32) {
#line 256
        goto while_break___0;
      }
#line 254
      to --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 257
    if (i == y2) {
#line 257
      if (x2 < to) {
#line 258
        to = x2;
      }
    }
#line 259
    if (to > markdata->right_mar) {
#line 260
      to = markdata->right_mar;
    }
#line 261
    if (redisplay == 1) {
#line 261
      if (from <= to) {
#line 261
        if (ry >= 0) {
#line 261
          if (ry <= yend) {
            {
#line 262
            MarkRedisplayLine(ry, from, to, 0);
            }
          }
        }
      }
    }
#line 263
    if (redisplay != 2) {
#line 263
      if ((unsigned long )pt == (unsigned long )((char *)0)) {
#line 264
        goto __Cont;
      }
    }
#line 265
    j = from;
#line 267
    if (fore->w_layer.l_encoding == 8) {
#line 267
      if ((int )*(ml->font + j) == 255) {
#line 267
        if ((int )*(ml->image + j) == 255) {
#line 267
          tmp___0 = 1;
        } else {
#line 267
          tmp___0 = 0;
        }
      } else {
#line 267
        tmp___0 = 0;
      }
#line 267
      tmp___1 = tmp___0;
    } else {
#line 267
      tmp___1 = ((int )*(ml->font + j) & 224) == 128;
    }
#line 267
    if (tmp___1) {
#line 268
      j --;
    }
#line 270
    im = ml->image + j;
#line 272
    fo = ml->font + j;
#line 273
    font = 0;
    {
#line 275
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 275
      if (! (j <= to)) {
#line 275
        goto while_break___1;
      }
#line 277
      tmp___2 = im;
#line 277
      im ++;
#line 277
      c = (int )*tmp___2;
#line 279
      tmp___3 = fo;
#line 279
      fo ++;
#line 279
      cf = (int )*tmp___3;
#line 281
      if (fore->w_layer.l_encoding == 8) {
#line 283
        c |= cf << 8;
#line 284
        if (c == 65535) {
#line 285
          goto __Cont___0;
        }
        {
#line 286
        c = ToUtf8_comb(pt, c);
#line 287
        l += c;
        }
#line 288
        if (pt) {
#line 289
          pt += c;
        }
#line 290
        goto __Cont___0;
      }
#line 294
      if (cf) {
#line 294
        if ((cf & 96) == 0) {
#line 296
          tmp___4 = im;
#line 296
          im ++;
#line 296
          c = (c << 8) | (int )*tmp___4;
#line 297
          fo ++;
#line 298
          j ++;
        }
      }
#line 301
      if (pastefont) {
        {
#line 303
        c = EncodeChar(pt, c | (cf << 16), fore->w_layer.l_encoding, & font);
#line 304
        l += c;
        }
#line 305
        if (pt) {
#line 306
          pt += c;
        }
#line 307
        goto __Cont___0;
      }
#line 310
      if (pt) {
#line 311
        tmp___5 = pt;
#line 311
        pt ++;
#line 311
        *tmp___5 = (char )c;
      }
#line 312
      l ++;
      __Cont___0: /* CIL Label */ 
#line 275
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 315
    if (pastefont) {
#line 315
      if (font != 0) {
#line 317
        if (pt) {
          {
#line 319
          strcpy((char */* __restrict  */)pt, (char const   */* __restrict  */)"\033(B");
#line 320
          pt += 3;
          }
        }
#line 322
        l += 3;
      }
    }
#line 325
    if (i != y2) {
#line 325
      if (to != fore->w_layer.l_width - 1) {
#line 325
        goto _L___0;
      } else
#line 325
      if ((int )*(ml->image + (to + 1)) == 32) {
        _L___0: /* CIL Label */ 
        {
#line 332
        if (markdata->nonl == 0) {
#line 332
          goto case_0;
        }
#line 343
        if (markdata->nonl == 1) {
#line 343
          goto case_1;
        }
#line 345
        if (markdata->nonl == 2) {
#line 345
          goto case_2;
        }
#line 350
        if (markdata->nonl == 3) {
#line 350
          goto case_3;
        }
#line 330
        goto switch_break;
        case_0: /* CIL Label */ 
#line 333
        if (pt) {
#line 334
          tmp___6 = pt;
#line 334
          pt ++;
#line 334
          *tmp___6 = (char )'\r';
        }
#line 335
        l ++;
#line 336
        if (join_with_cr) {
#line 338
          if (pt) {
#line 339
            tmp___7 = pt;
#line 339
            pt ++;
#line 339
            *tmp___7 = (char )'\n';
          }
#line 340
          l ++;
        }
#line 342
        goto switch_break;
        case_1: /* CIL Label */ 
#line 344
        goto switch_break;
        case_2: /* CIL Label */ 
#line 346
        if (pt) {
#line 347
          tmp___8 = pt;
#line 347
          pt ++;
#line 347
          *tmp___8 = (char )' ';
        }
#line 348
        l ++;
#line 349
        goto switch_break;
        case_3: /* CIL Label */ 
#line 351
        if (pt) {
#line 352
          tmp___9 = pt;
#line 352
          pt ++;
#line 352
          *tmp___9 = (char )',';
        }
#line 353
        l ++;
#line 354
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 246
    i ++;
#line 246
    ry ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 358
  return (l);
}
}
#line 365 "/home/pronto/abs/test-suite/screen-4.0.2/mark.c"
static int eq(int a , int b ) 
{ 


  {
#line 369
  if (a == b) {
#line 370
    return (1);
  }
#line 371
  if (a == 0) {
#line 372
    return (1);
  } else
#line 371
  if (b == 0) {
#line 372
    return (1);
  }
#line 373
  if (a <= 57) {
#line 373
    if (a >= 48) {
#line 373
      if (b <= 57) {
#line 373
        if (b >= 48) {
#line 374
          return (1);
        }
      }
    }
  }
#line 375
  return (0);
}
}
#line 381 "/home/pronto/abs/test-suite/screen-4.0.2/mark.c"
int GetHistory(void) 
{ 
  int i ;
  int q ;
  int xx ;
  int yy ;
  int x ;
  int y ;
  unsigned char *linep ;
  struct mline *ml ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;

  {
#line 384
  i = 0;
#line 384
  q = 0;
  {
#line 388
  while (1) {
    while_continue: /* CIL Label */ ;
#line 388
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 389
  x = fore->w_layer.l_x;
#line 390
  if (x >= fore->w_layer.l_width) {
#line 391
    x = fore->w_layer.l_width - 1;
  }
#line 392
  y = fore->w_layer.l_y + fore->w_histheight;
  {
#line 393
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 393
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 394
  if (y < fore->w_histheight) {
#line 394
    ml = fore->w_hlines + (fore->w_histidx + y) % fore->w_histheight;
  } else {
#line 394
    ml = fore->w_mlines + (y - fore->w_histheight);
  }
#line 395
  xx = x - 1;
#line 395
  linep = ml->image + xx;
  {
#line 395
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 395
    if (! (xx >= 0)) {
#line 395
      goto while_break___1;
    }
#line 396
    tmp = linep;
#line 396
    linep --;
#line 396
    q = (int )*tmp;
#line 396
    if (q != 32) {
#line 397
      goto while_break___1;
    }
#line 395
    xx --;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 398
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 398
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 399
  yy = y - 1;
  {
#line 399
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 399
    if (! (yy >= 0)) {
#line 399
      goto while_break___3;
    }
#line 401
    if (yy < fore->w_histheight) {
#line 401
      ml = fore->w_hlines + (fore->w_histidx + yy) % fore->w_histheight;
    } else {
#line 401
      ml = fore->w_mlines + (yy - fore->w_histheight);
    }
#line 402
    linep = ml->image;
#line 403
    if (xx < 0) {
#line 403
      goto _L;
    } else {
      {
#line 403
      tmp___1 = eq((int )*(linep + xx), q);
      }
#line 403
      if (tmp___1) {
        _L: /* CIL Label */ 
#line 405
        i = fore->w_layer.l_width - 1;
#line 405
        linep += i;
        {
#line 405
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 405
          if (! (i >= x)) {
#line 405
            goto while_break___4;
          }
#line 406
          tmp___0 = linep;
#line 406
          linep --;
#line 406
          if ((int )*tmp___0 != 32) {
#line 407
            goto while_break___4;
          }
#line 405
          i --;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 408
        if (i >= x) {
#line 409
          goto while_break___3;
        }
      }
    }
#line 399
    yy --;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 412
  if (yy < 0) {
#line 413
    return (0);
  }
#line 414
  if ((display->d_user)->u_plop.buf) {
    {
#line 415
    UserFreeCopyBuffer(display->d_user);
    }
  }
  {
#line 416
  tmp___3 = malloc((unsigned int )((i - x) + 2));
#line 416
  tmp___2 = (char *)tmp___3;
#line 416
  (display->d_user)->u_plop.buf = tmp___2;
  }
#line 416
  if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
    {
#line 418
    LMsg(0, (char *)"Not enough memory... Sorry.");
    }
#line 419
    return (0);
  }
  {
#line 421
  bcopy((void const   *)((((char *)linep - i) + x) + 1), (void *)(display->d_user)->u_plop.buf,
        (size_t )((i - x) + 1));
#line 422
  (display->d_user)->u_plop.len = (i - x) + 1;
#line 424
  (display->d_user)->u_plop.enc = fore->w_layer.l_encoding;
  }
#line 426
  return (1);
}
}
#line 432 "/home/pronto/abs/test-suite/screen-4.0.2/mark.c"
void MarkRoutine(void) 
{ 
  int x ;
  int y ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 437
  while (1) {
    while_continue: /* CIL Label */ ;
#line 437
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 439
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 439
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 442
  tmp = InitOverlayPage((int )sizeof(*markdata), & MarkLf, 1);
  }
#line 442
  if (tmp) {
#line 443
    return;
  }
#line 444
  flayer->l_encoding = fore->w_layer.l_encoding;
#line 445
  markdata = (struct markdata *)flayer->l_data;
#line 446
  markdata->md_user = display->d_user;
#line 447
  markdata->md_window = fore;
#line 448
  markdata->second = 0;
#line 449
  markdata->rep_cnt = 0;
#line 450
  markdata->append_mode = 0;
#line 451
  markdata->write_buffer = 0;
#line 452
  markdata->nonl = 0;
#line 453
  markdata->left_mar = 0;
#line 454
  markdata->right_mar = fore->w_layer.l_width - 1;
#line 455
  markdata->hist_offset = fore->w_histheight;
#line 456
  x = fore->w_layer.l_x;
#line 457
  y = fore->w_layer.l_y + markdata->hist_offset;
#line 458
  if (x >= fore->w_layer.l_width) {
#line 459
    x = fore->w_layer.l_width - 1;
  }
  {
#line 461
  LGotoPos(flayer, x, y - markdata->hist_offset);
#line 462
  LMsg(0, (char *)"Copy mode - Column %d Line %d(+%d) (%d,%d)", x + 1, (y + 1) - markdata->hist_offset,
       fore->w_histheight, fore->w_layer.l_width, fore->w_layer.l_height);
#line 464
  tmp___0 = x;
#line 464
  markdata->x1 = tmp___0;
#line 464
  markdata->cx = tmp___0;
#line 465
  tmp___1 = y;
#line 465
  markdata->y1 = tmp___1;
#line 465
  markdata->cy = tmp___1;
#line 466
  flayer->l_x = x;
#line 467
  flayer->l_y = y - markdata->hist_offset;
  }
#line 468
  return;
}
}
#line 470 "/home/pronto/abs/test-suite/screen-4.0.2/mark.c"
static void MarkProcess(char **inbufp , int *inlenp ) 
{ 
  char *inbuf ;
  char *pt ;
  int inlen ;
  int cx ;
  int cy ;
  int x2 ;
  int y2 ;
  int j ;
  int yend ;
  int newcopylen ;
  int od ;
  int in_mark ;
  int rep_cnt ;
  struct acluser *md_user ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int append_mode ;
  int write_buffer ;
  int tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  int tmp___17 ;
  struct layer *oldlay ;
  struct canvas *oldcvlist ;
  struct canvas *cv ;

  {
#line 478
  newcopylen = 0;
#line 487
  markdata = (struct markdata *)flayer->l_data;
#line 488
  fore = markdata->md_window;
#line 489
  md_user = markdata->md_user;
#line 490
  if ((unsigned long )inbufp == (unsigned long )((char **)0)) {
    {
#line 492
    MarkAbort();
    }
#line 493
    return;
  }
  {
#line 496
  LGotoPos(flayer, markdata->cx, markdata->cy - markdata->hist_offset);
#line 497
  inbuf = *inbufp;
#line 498
  inlen = *inlenp;
#line 499
  pt = inbuf;
#line 500
  in_mark = 1;
  }
  {
#line 501
  while (1) {
    while_continue: /* CIL Label */ ;
#line 501
    if (in_mark) {
#line 501
      if (! inlen) {
#line 501
        goto while_break;
      }
    } else {
#line 501
      goto while_break;
    }
#line 513
    tmp = pt;
#line 513
    pt ++;
#line 513
    od = (int )mark_key_tab[(int )((unsigned char )*tmp)];
#line 514
    inlen --;
#line 516
    rep_cnt = markdata->rep_cnt;
#line 517
    if (od >= 48) {
#line 517
      if (od <= 57) {
#line 519
        if (rep_cnt < 1001) {
#line 519
          if (od != 48) {
#line 521
            markdata->rep_cnt = (10 * rep_cnt + od) - 48;
#line 522
            goto while_continue;
          } else
#line 519
          if (rep_cnt != 0) {
#line 521
            markdata->rep_cnt = (10 * rep_cnt + od) - 48;
#line 522
            goto while_continue;
          }
        }
      }
    }
#line 535
    cx = markdata->cx;
#line 536
    cy = markdata->cy;
    {
#line 540
    if (od == 120) {
#line 540
      goto case_120;
    }
#line 540
    if (od == 111) {
#line 540
      goto case_120;
    }
#line 549
    if (od == 12) {
#line 549
      goto case_12;
    }
#line 555
    if (od == 104) {
#line 555
      goto case_104;
    }
#line 555
    if (od == 8) {
#line 555
      goto case_104;
    }
#line 555
    if (od == 130) {
#line 555
      goto case_104;
    }
#line 562
    if (od == 106) {
#line 562
      goto case_106;
    }
#line 562
    if (od == 14) {
#line 562
      goto case_106;
    }
#line 562
    if (od == 142) {
#line 562
      goto case_106;
    }
#line 567
    if (od == 43) {
#line 567
      goto case_43;
    }
#line 575
    if (od == 45) {
#line 575
      goto case_45;
    }
#line 583
    if (od == 94) {
#line 583
      goto case_94;
    }
#line 586
    if (od == 10) {
#line 586
      goto case_10;
    }
#line 591
    if (od == 107) {
#line 591
      goto case_107;
    }
#line 591
    if (od == 16) {
#line 591
      goto case_107;
    }
#line 591
    if (od == 144) {
#line 591
      goto case_107;
    }
#line 597
    if (od == 108) {
#line 597
      goto case_108;
    }
#line 597
    if (od == 134) {
#line 597
      goto case_108;
    }
#line 603
    if (od == 48) {
#line 603
      goto case_48;
    }
#line 603
    if (od == 1) {
#line 603
      goto case_48;
    }
#line 606
    if (od == 4) {
#line 606
      goto case_4;
    }
#line 611
    if (od == 36) {
#line 611
      goto case_36;
    }
#line 614
    if (od == 18) {
#line 614
      goto case_18;
    }
#line 618
    if (od == 19) {
#line 618
      goto case_19;
    }
#line 622
    if (od == 21) {
#line 622
      goto case_21;
    }
#line 627
    if (od == 7) {
#line 627
      goto case_7;
    }
#line 635
    if (od == 2) {
#line 635
      goto case_2;
    }
#line 641
    if (od == 6) {
#line 641
      goto case_6;
    }
#line 647
    if (od == 5) {
#line 647
      goto case_5;
    }
#line 656
    if (od == 25) {
#line 656
      goto case_25;
    }
#line 665
    if (od == 64) {
#line 665
      goto case_64;
    }
#line 668
    if (od == 37) {
#line 668
      goto case_37;
    }
#line 678
    if (od == 103) {
#line 678
      goto case_103;
    }
#line 678
    if (od == 129) {
#line 678
      goto case_103;
    }
#line 682
    if (od == 71) {
#line 682
      goto case_71;
    }
#line 682
    if (od == 133) {
#line 682
      goto case_71;
    }
#line 688
    if (od == 72) {
#line 688
      goto case_72;
    }
#line 691
    if (od == 77) {
#line 691
      goto case_77;
    }
#line 694
    if (od == 76) {
#line 694
      goto case_76;
    }
#line 697
    if (od == 124) {
#line 697
      goto case_124;
    }
#line 700
    if (od == 119) {
#line 700
      goto case_119;
    }
#line 707
    if (od == 69) {
#line 707
      goto case_69;
    }
#line 707
    if (od == 101) {
#line 707
      goto case_69;
    }
#line 714
    if (od == 66) {
#line 714
      goto case_66;
    }
#line 714
    if (od == 98) {
#line 714
      goto case_66;
    }
#line 720
    if (od == 97) {
#line 720
      goto case_97;
    }
#line 726
    if (od == 86) {
#line 726
      goto case_86;
    }
#line 726
    if (od == 118) {
#line 726
      goto case_86;
    }
#line 734
    if (od == 67) {
#line 734
      goto case_67;
    }
#line 734
    if (od == 99) {
#line 734
      goto case_67;
    }
#line 764
    if (od == 74) {
#line 764
      goto case_74;
    }
#line 786
    if (od == 47) {
#line 786
      goto case_47;
    }
#line 790
    if (od == 63) {
#line 790
      goto case_63;
    }
#line 794
    if (od == 110) {
#line 794
      goto case_110;
    }
#line 798
    if (od == 89) {
#line 798
      goto case_89;
    }
#line 798
    if (od == 121) {
#line 798
      goto case_89;
    }
#line 812
    if (od == 87) {
#line 812
      goto case_87;
    }
#line 831
    if (od == 65) {
#line 831
      goto case_65;
    }
#line 835
    if (od == 62) {
#line 835
      goto case_62;
    }
#line 840
    if (od == 13) {
#line 840
      goto case_13;
    }
#line 840
    if (od == 32) {
#line 840
      goto case_13;
    }
#line 936
    goto switch_default;
    case_120: /* CIL Label */ 
    case_111: /* CIL Label */ 
#line 541
    if (! markdata->second) {
#line 542
      goto switch_break;
    }
    {
#line 543
    markdata->cx = markdata->x1;
#line 544
    markdata->cy = markdata->y1;
#line 545
    markdata->x1 = cx;
#line 546
    markdata->y1 = cy;
#line 547
    revto(markdata->cx, markdata->cy);
    }
#line 548
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 550
    Redisplay(0);
#line 551
    LGotoPos(flayer, cx, cy - markdata->hist_offset);
    }
#line 552
    goto switch_break;
    case_104: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_130: /* CIL Label */ 
#line 556
    if (rep_cnt == 0) {
#line 557
      rep_cnt = 1;
    }
    {
#line 558
    revto(cx - rep_cnt, cy);
    }
#line 559
    goto switch_break;
    case_106: /* CIL Label */ 
    case_14: /* CIL Label */ 
    case_142: /* CIL Label */ 
#line 563
    if (rep_cnt == 0) {
#line 564
      rep_cnt = 1;
    }
    {
#line 565
    revto(cx, cy + rep_cnt);
    }
#line 566
    goto switch_break;
    case_43: /* CIL Label */ 
#line 568
    if (rep_cnt == 0) {
#line 569
      rep_cnt = 1;
    }
#line 570
    j = cy + rep_cnt;
#line 571
    if (j > (fore->w_histheight + fore->w_layer.l_height) - 1) {
#line 572
      j = (fore->w_histheight + fore->w_layer.l_height) - 1;
    }
    {
#line 573
    tmp___0 = linestart(j);
#line 573
    revto(tmp___0, j);
    }
#line 574
    goto switch_break;
    case_45: /* CIL Label */ 
#line 576
    if (rep_cnt == 0) {
#line 577
      rep_cnt = 1;
    }
#line 578
    cy -= rep_cnt;
#line 579
    if (cy < 0) {
#line 580
      cy = 0;
    }
    {
#line 581
    tmp___1 = linestart(cy);
#line 581
    revto(tmp___1, cy);
    }
#line 582
    goto switch_break;
    case_94: /* CIL Label */ 
    {
#line 584
    tmp___2 = linestart(cy);
#line 584
    revto(tmp___2, cy);
    }
#line 585
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 587
    revto(markdata->left_mar, cy + 1);
    }
#line 588
    goto switch_break;
    case_107: /* CIL Label */ 
    case_16: /* CIL Label */ 
    case_144: /* CIL Label */ 
#line 592
    if (rep_cnt == 0) {
#line 593
      rep_cnt = 1;
    }
    {
#line 594
    revto(cx, cy - rep_cnt);
    }
#line 595
    goto switch_break;
    case_108: /* CIL Label */ 
    case_134: /* CIL Label */ 
#line 598
    if (rep_cnt == 0) {
#line 599
      rep_cnt = 1;
    }
    {
#line 600
    revto(cx + rep_cnt, cy);
    }
#line 601
    goto switch_break;
    case_48: /* CIL Label */ 
    case_1: /* CIL Label */ 
    {
#line 604
    revto(markdata->left_mar, cy);
    }
#line 605
    goto switch_break;
    case_4: /* CIL Label */ 
#line 607
    if (rep_cnt == 0) {
#line 608
      rep_cnt = (fore->w_layer.l_height + 1) >> 1;
    }
    {
#line 609
    revto_line(cx, cy + rep_cnt, cy - markdata->hist_offset);
    }
#line 610
    goto switch_break;
    case_36: /* CIL Label */ 
    {
#line 612
    tmp___3 = lineend(cy);
#line 612
    revto(tmp___3, cy);
    }
#line 613
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 615
    ISearch(-1);
#line 616
    in_mark = 0;
    }
#line 617
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 619
    ISearch(1);
#line 620
    in_mark = 0;
    }
#line 621
    goto switch_break;
    case_21: /* CIL Label */ 
#line 623
    if (rep_cnt == 0) {
#line 624
      rep_cnt = (fore->w_layer.l_height + 1) >> 1;
    }
    {
#line 625
    revto_line(cx, cy - rep_cnt, cy - markdata->hist_offset);
    }
#line 626
    goto switch_break;
    case_7: /* CIL Label */ 
#line 628
    if (markdata->left_mar == 0) {
#line 628
      if (markdata->right_mar == fore->w_layer.l_width - 1) {
        {
#line 629
        LMsg(0, (char *)"Column %d Line %d(+%d)", cx + 1, (cy - markdata->hist_offset) + 1,
             markdata->hist_offset);
        }
      } else {
        {
#line 632
        LMsg(0, (char *)"Column %d(%d..%d) Line %d(+%d)", cx + 1, markdata->left_mar + 1,
             markdata->right_mar + 1, (cy - markdata->hist_offset) + 1, markdata->hist_offset);
        }
      }
    } else {
      {
#line 632
      LMsg(0, (char *)"Column %d(%d..%d) Line %d(+%d)", cx + 1, markdata->left_mar + 1,
           markdata->right_mar + 1, (cy - markdata->hist_offset) + 1, markdata->hist_offset);
      }
    }
#line 634
    goto switch_break;
    case_2: /* CIL Label */ 
#line 636
    if (rep_cnt == 0) {
#line 637
      rep_cnt = 1;
    }
    {
#line 638
    rep_cnt *= fore->w_layer.l_height;
#line 639
    revto(cx, cy - rep_cnt);
    }
#line 640
    goto switch_break;
    case_6: /* CIL Label */ 
#line 642
    if (rep_cnt == 0) {
#line 643
      rep_cnt = 1;
    }
    {
#line 644
    rep_cnt *= fore->w_layer.l_height;
#line 645
    revto(cx, cy + rep_cnt);
    }
#line 646
    goto switch_break;
    case_5: /* CIL Label */ 
#line 648
    if (rep_cnt == 0) {
#line 649
      rep_cnt = 1;
    }
    {
#line 650
    rep_cnt = MarkScrollUpDisplay(rep_cnt);
    }
#line 651
    if (cy < markdata->hist_offset) {
      {
#line 652
      revto(cx, markdata->hist_offset);
      }
    } else {
      {
#line 654
      LGotoPos(flayer, cx, cy - markdata->hist_offset);
      }
    }
#line 655
    goto switch_break;
    case_25: /* CIL Label */ 
#line 657
    if (rep_cnt == 0) {
#line 658
      rep_cnt = 1;
    }
    {
#line 659
    rep_cnt = MarkScrollDownDisplay(rep_cnt);
    }
#line 660
    if (cy > (fore->w_layer.l_height - 1) + markdata->hist_offset) {
      {
#line 661
      revto(cx, (fore->w_layer.l_height - 1) + markdata->hist_offset);
      }
    } else {
      {
#line 663
      LGotoPos(flayer, cx, cy - markdata->hist_offset);
      }
    }
#line 664
    goto switch_break;
    case_64: /* CIL Label */ 
#line 667
    goto switch_break;
    case_37: /* CIL Label */ 
#line 669
    rep_cnt --;
#line 671
    if (rep_cnt < 0) {
#line 672
      rep_cnt = 0;
    }
#line 673
    if (rep_cnt > 100) {
#line 674
      rep_cnt = 100;
    }
    {
#line 675
    revto_line(markdata->left_mar, (rep_cnt * (fore->w_histheight + fore->w_layer.l_height)) / 100,
               (fore->w_layer.l_height - 1) / 2);
    }
#line 676
    goto switch_break;
    case_103: /* CIL Label */ 
    case_129: /* CIL Label */ 
#line 679
    rep_cnt = 1;
    case_71: /* CIL Label */ 
    case_133: /* CIL Label */ 
#line 684
    if (rep_cnt == 0) {
#line 685
      rep_cnt = fore->w_histheight + fore->w_layer.l_height;
    }
    {
#line 686
    rep_cnt --;
#line 686
    revto_line(markdata->left_mar, rep_cnt, (fore->w_layer.l_height - 1) / 2);
    }
#line 687
    goto switch_break;
    case_72: /* CIL Label */ 
    {
#line 689
    revto(markdata->left_mar, markdata->hist_offset);
    }
#line 690
    goto switch_break;
    case_77: /* CIL Label */ 
    {
#line 692
    revto(markdata->left_mar, (fore->w_layer.l_height - 1) / 2 + markdata->hist_offset);
    }
#line 693
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 695
    revto(markdata->left_mar, (fore->w_layer.l_height - 1) + markdata->hist_offset);
    }
#line 696
    goto switch_break;
    case_124: /* CIL Label */ 
    {
#line 698
    rep_cnt --;
#line 698
    revto(rep_cnt, cy);
    }
#line 699
    goto switch_break;
    case_119: /* CIL Label */ 
#line 701
    if (rep_cnt == 0) {
#line 702
      rep_cnt = 1;
    }
    {
#line 703
    nextword(& cx, & cy, 1 << 2, rep_cnt);
#line 704
    revto(cx, cy);
    }
#line 705
    goto switch_break;
    case_69: /* CIL Label */ 
    case_101: /* CIL Label */ 
#line 708
    if (rep_cnt == 0) {
#line 709
      rep_cnt = 1;
    }
#line 710
    if (od == 69) {
#line 710
      tmp___4 = 1 << 3;
    } else {
#line 710
      tmp___4 = 0;
    }
    {
#line 710
    nextword(& cx, & cy, ((1 << 1) | (1 << 2)) | tmp___4, rep_cnt);
#line 711
    revto(cx, cy);
    }
#line 712
    goto switch_break;
    case_66: /* CIL Label */ 
    case_98: /* CIL Label */ 
#line 715
    if (rep_cnt == 0) {
#line 716
      rep_cnt = 1;
    }
#line 717
    if (od == 66) {
#line 717
      tmp___5 = 1 << 3;
    } else {
#line 717
      tmp___5 = 0;
    }
    {
#line 717
    nextword(& cx, & cy, ((1 | (1 << 1)) | (1 << 2)) | tmp___5, rep_cnt);
#line 718
    revto(cx, cy);
    }
#line 719
    goto switch_break;
    case_97: /* CIL Label */ 
#line 721
    markdata->append_mode = 1 - markdata->append_mode;
    {
#line 722
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 722
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 723
    if (markdata->append_mode) {
#line 723
      tmp___6 = ":set append";
    } else {
#line 723
      tmp___6 = ":set noappend";
    }
    {
#line 723
    LMsg(0, (char *)tmp___6);
    }
#line 724
    goto switch_break;
    case_86: /* CIL Label */ 
    case_118: /* CIL Label */ 
#line 728
    if (markdata->left_mar == 8) {
#line 729
      rep_cnt = 1;
    } else {
#line 731
      rep_cnt = 9;
    }
    case_67: /* CIL Label */ 
    case_99: /* CIL Label */ 
#line 736
    if (markdata->second) {
      {
#line 738
      rem(markdata->x1, markdata->y1, cx, cy, 1, (char *)0, fore->w_layer.l_height - 1);
#line 739
      markdata->second = 1;
      }
    }
#line 741
    rep_cnt --;
#line 742
    if (rep_cnt < 0) {
#line 743
      rep_cnt = cx;
    }
#line 744
    if (od != 67) {
#line 746
      markdata->left_mar = rep_cnt;
#line 747
      if (markdata->left_mar > markdata->right_mar) {
#line 748
        markdata->left_mar = markdata->right_mar;
      }
    } else {
#line 752
      markdata->right_mar = rep_cnt;
#line 753
      if (markdata->left_mar > markdata->right_mar) {
#line 754
        markdata->right_mar = markdata->left_mar;
      }
    }
#line 756
    if (markdata->second) {
      {
#line 758
      markdata->cx = markdata->x1;
#line 758
      markdata->cy = markdata->y1;
#line 759
      revto(cx, cy);
      }
    }
#line 761
    if (od == 118) {
#line 761
      goto _L;
    } else
#line 761
    if (od == 86) {
      _L: /* CIL Label */ 
#line 762
      if (markdata->left_mar != 8) {
#line 762
        tmp___7 = ":set nonu";
      } else {
#line 762
        tmp___7 = ":set nu";
      }
      {
#line 762
      LMsg(0, (char *)tmp___7);
      }
    }
#line 763
    goto switch_break;
    case_74: /* CIL Label */ 
#line 766
    markdata->nonl = (markdata->nonl + 1) % 4;
    {
#line 769
    if (markdata->nonl == 0) {
#line 769
      goto case_0;
    }
#line 775
    if (markdata->nonl == 1) {
#line 775
      goto case_1___0;
    }
#line 778
    if (markdata->nonl == 2) {
#line 778
      goto case_2___0;
    }
#line 781
    if (markdata->nonl == 3) {
#line 781
      goto case_3;
    }
#line 767
    goto switch_break___0;
    case_0: /* CIL Label */ 
#line 770
    if (join_with_cr) {
      {
#line 771
      LMsg(0, (char *)"Multiple lines (CR/LF)");
      }
    } else {
      {
#line 773
      LMsg(0, (char *)"Multiple lines (LF)");
      }
    }
#line 774
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
    {
#line 776
    LMsg(0, (char *)"Lines joined");
    }
#line 777
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 779
    LMsg(0, (char *)"Lines joined with blanks");
    }
#line 780
    goto switch_break___0;
    case_3: /* CIL Label */ 
    {
#line 782
    LMsg(0, (char *)"Lines joined with comma");
    }
#line 783
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 785
    goto switch_break;
    case_47: /* CIL Label */ 
    {
#line 787
    Search(1);
#line 788
    in_mark = 0;
    }
#line 789
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 791
    Search(-1);
#line 792
    in_mark = 0;
    }
#line 793
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 795
    Search(0);
    }
#line 796
    goto switch_break;
    case_89: /* CIL Label */ 
    case_121: /* CIL Label */ 
#line 799
    if (markdata->second == 0) {
      {
#line 801
      tmp___8 = linestart(cy);
#line 801
      revto(tmp___8, cy);
#line 802
      (markdata->second) ++;
#line 803
      tmp___9 = markdata->cx;
#line 803
      markdata->x1 = tmp___9;
#line 803
      cx = tmp___9;
#line 804
      tmp___10 = markdata->cy;
#line 804
      markdata->y1 = tmp___10;
#line 804
      cy = tmp___10;
      }
    }
#line 806
    rep_cnt --;
#line 806
    if (rep_cnt > 0) {
      {
#line 807
      revto(cx, cy + rep_cnt);
      }
    }
    {
#line 808
    tmp___11 = lineend(markdata->cy);
#line 808
    revto(tmp___11, markdata->cy);
    }
#line 809
    if (od == 121) {
#line 810
      goto switch_break;
    }
    case_87: /* CIL Label */ 
#line 813
    if (od == 87) {
#line 815
      if (rep_cnt == 0) {
#line 816
        rep_cnt = 1;
      }
#line 817
      if (! markdata->second) {
        {
#line 819
        nextword(& cx, & cy, 1 | (1 << 1), 1);
#line 820
        revto(cx, cy);
#line 821
        (markdata->second) ++;
#line 822
        tmp___12 = markdata->cx;
#line 822
        markdata->x1 = tmp___12;
#line 822
        cx = tmp___12;
#line 823
        tmp___13 = markdata->cy;
#line 823
        markdata->y1 = tmp___13;
#line 823
        cy = tmp___13;
        }
      }
      {
#line 825
      nextword(& cx, & cy, 1 << 1, rep_cnt);
#line 826
      revto(cx, cy);
      }
    }
#line 828
    cx = markdata->cx;
#line 829
    cy = markdata->cy;
    case_65: /* CIL Label */ 
#line 832
    if (od == 65) {
#line 833
      markdata->append_mode = 1;
    }
    case_62: /* CIL Label */ 
#line 836
    if (od == 62) {
#line 837
      markdata->write_buffer = 1;
    }
    case_13: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 841
    if (! markdata->second) {
      {
#line 843
      (markdata->second) ++;
#line 844
      markdata->x1 = cx;
#line 845
      markdata->y1 = cy;
#line 846
      revto(cx, cy);
#line 847
      LMsg(0, (char *)"First mark set - Column %d Line %d", cx + 1, (cy - markdata->hist_offset) + 1);
      }
#line 848
      goto switch_break;
    } else {
      {
#line 852
      append_mode = markdata->append_mode;
#line 853
      write_buffer = markdata->write_buffer;
#line 855
      x2 = cx;
#line 856
      y2 = cy;
#line 857
      newcopylen = rem(markdata->x1, markdata->y1, x2, y2, 2, (char *)0, 0);
      }
#line 858
      if (md_user->u_plop.buf) {
#line 858
        if (! append_mode) {
          {
#line 859
          UserFreeCopyBuffer(md_user);
          }
        }
      }
#line 860
      yend = fore->w_layer.l_height - 1;
#line 861
      if (fore->w_histheight - markdata->hist_offset < fore->w_layer.l_height) {
        {
#line 863
        markdata->second = 0;
#line 864
        tmp___14 = MarkScrollUpDisplay(fore->w_histheight - markdata->hist_offset);
#line 864
        yend -= tmp___14;
        }
      }
#line 866
      if (newcopylen > 0) {
#line 869
        if (md_user->u_plop.buf) {
          {
#line 870
          tmp___15 = realloc((void *)md_user->u_plop.buf, (unsigned int )((md_user->u_plop.len + newcopylen) + 3));
#line 870
          md_user->u_plop.buf = (char *)tmp___15;
          }
        } else {
          {
#line 874
          md_user->u_plop.len = 0;
#line 875
          tmp___16 = malloc((unsigned int )(newcopylen + 3));
#line 875
          md_user->u_plop.buf = (char *)tmp___16;
          }
        }
#line 877
        if (! md_user->u_plop.buf) {
          {
#line 879
          MarkAbort();
#line 880
          in_mark = 0;
#line 881
          LMsg(0, (char *)"Not enough memory... Sorry.");
#line 882
          md_user->u_plop.len = 0;
#line 883
          md_user->u_plop.buf = (char *)0;
          }
#line 884
          goto switch_break;
        }
#line 886
        if (append_mode) {
          {
#line 893
          if (markdata->nonl == 0) {
#line 893
            goto case_0___0;
          }
#line 902
          if (markdata->nonl == 1) {
#line 902
            goto case_1___1;
          }
#line 904
          if (markdata->nonl == 2) {
#line 904
            goto case_2___1;
          }
#line 908
          if (markdata->nonl == 3) {
#line 908
            goto case_3___0;
          }
#line 888
          goto switch_break___1;
          case_0___0: /* CIL Label */ 
#line 894
          if (join_with_cr) {
#line 896
            *(md_user->u_plop.buf + md_user->u_plop.len) = (char )'\r';
#line 897
            (md_user->u_plop.len) ++;
          }
#line 899
          *(md_user->u_plop.buf + md_user->u_plop.len) = (char )'\n';
#line 900
          (md_user->u_plop.len) ++;
#line 901
          goto switch_break___1;
          case_1___1: /* CIL Label */ 
#line 903
          goto switch_break___1;
          case_2___1: /* CIL Label */ 
#line 905
          *(md_user->u_plop.buf + md_user->u_plop.len) = (char )' ';
#line 906
          (md_user->u_plop.len) ++;
#line 907
          goto switch_break___1;
          case_3___0: /* CIL Label */ 
#line 909
          *(md_user->u_plop.buf + md_user->u_plop.len) = (char )',';
#line 910
          (md_user->u_plop.len) ++;
#line 911
          goto switch_break___1;
          switch_break___1: /* CIL Label */ ;
          }
        }
        {
#line 914
        tmp___17 = rem(markdata->x1, markdata->y1, x2, y2, markdata->hist_offset == fore->w_histheight,
                       md_user->u_plop.buf + md_user->u_plop.len, yend);
#line 914
        md_user->u_plop.len += tmp___17;
#line 918
        md_user->u_plop.enc = fore->w_layer.l_encoding;
        }
      }
#line 921
      if (markdata->hist_offset != fore->w_histheight) {
        {
#line 923
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 923
          oldlay = flayer;
          {
#line 923
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 923
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 923
          flayer = flayer->l_next;
#line 923
          oldcvlist = flayer->l_cvlist;
          {
#line 923
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 923
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 923
          flayer->l_cvlist = oldlay->l_cvlist;
#line 923
          cv = flayer->l_cvlist;
          {
#line 923
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 923
            if (! cv) {
#line 923
              goto while_break___4;
            }
#line 923
            cv->c_layer = flayer;
#line 923
            cv = cv->c_lnext;
          }
          while_break___4: /* CIL Label */ ;
          }
          {
#line 923
          LRefreshAll(flayer, 0);
#line 923
          flayer = oldlay;
#line 923
          cv = flayer->l_cvlist;
          }
          {
#line 923
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 923
            if (! cv) {
#line 923
              goto while_break___5;
            }
#line 923
            cv->c_layer = flayer;
#line 923
            cv = cv->c_lnext;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 923
          (flayer->l_next)->l_cvlist = oldcvlist;
#line 923
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      {
#line 925
      ExitOverlayPage();
      }
#line 926
      if (append_mode) {
        {
#line 927
        LMsg(0, (char *)"Appended %d characters to buffer", newcopylen);
        }
      } else {
        {
#line 930
        LMsg(0, (char *)"Copied %d characters into buffer", md_user->u_plop.len);
        }
      }
#line 931
      if (write_buffer) {
        {
#line 932
        WriteFile(md_user, (char *)0, 2);
        }
      }
#line 933
      in_mark = 0;
#line 934
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
    {
#line 937
    MarkAbort();
#line 938
    LMsg(0, (char *)"Copy mode aborted");
#line 939
    in_mark = 0;
    }
#line 940
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 942
    if (in_mark) {
#line 943
      markdata->rep_cnt = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 945
  if (in_mark) {
#line 947
    flayer->l_x = markdata->cx;
#line 948
    flayer->l_y = markdata->cy - markdata->hist_offset;
  }
#line 950
  *inbufp = pt;
#line 951
  *inlenp = inlen;
#line 952
  return;
}
}
#line 954 "/home/pronto/abs/test-suite/screen-4.0.2/mark.c"
void revto(int tx , int ty ) 
{ 


  {
  {
#line 957
  revto_line(tx, ty, -1);
  }
#line 958
  return;
}
}
#line 961 "/home/pronto/abs/test-suite/screen-4.0.2/mark.c"
void revto_line(int tx , int ty , int line ) 
{ 
  int fx ;
  int fy ;
  int x ;
  int y ;
  int t ;
  int revst ;
  int reven ;
  int qq ;
  int ff ;
  int tt ;
  int st ;
  int en ;
  int ce ;
  int ystart ;
  int yend ;
  int i ;
  int ry ;
  unsigned char *wi ;
  struct mline *ml ;
  struct mchar mc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 965
  ce = 0;
#line 966
  ystart = 0;
#line 966
  yend = fore->w_layer.l_height - 1;
#line 972
  if (tx < 0) {
#line 973
    tx = 0;
  } else
#line 974
  if (tx > fore->w_layer.l_width - 1) {
#line 975
    tx = fore->w_layer.l_width - 1;
  }
#line 976
  if (ty < 0) {
#line 977
    ty = 0;
  } else
#line 978
  if (ty > (fore->w_histheight + fore->w_layer.l_height) - 1) {
#line 979
    ty = (fore->w_histheight + fore->w_layer.l_height) - 1;
  }
#line 981
  fx = markdata->cx;
#line 981
  fy = markdata->cy;
#line 985
  if (ty < fore->w_histheight) {
#line 985
    ml = fore->w_hlines + (fore->w_histidx + ty) % fore->w_histheight;
  } else {
#line 985
    ml = fore->w_mlines + (ty - fore->w_histheight);
  }
#line 986
  if (ty == fy) {
#line 986
    if (fx + 1 == tx) {
#line 986
      if (fore->w_layer.l_encoding == 8) {
#line 986
        if ((int )*(ml->font + tx) == 255) {
#line 986
          if ((int )*(ml->image + tx) == 255) {
#line 986
            tmp = 1;
          } else {
#line 986
            tmp = 0;
          }
        } else {
#line 986
          tmp = 0;
        }
#line 986
        tmp___0 = tmp;
      } else {
#line 986
        tmp___0 = ((int )*(ml->font + tx) & 224) == 128;
      }
#line 986
      if (tmp___0) {
#line 986
        if (tx < display->d_width - 1) {
#line 987
          tx ++;
        }
      }
    }
  }
#line 988
  if (ty == fy) {
#line 988
    if (fx - 1 == tx) {
#line 988
      if (fore->w_layer.l_encoding == 8) {
#line 988
        if ((int )*(ml->font + fx) == 255) {
#line 988
          if ((int )*(ml->image + fx) == 255) {
#line 988
            tmp___1 = 1;
          } else {
#line 988
            tmp___1 = 0;
          }
        } else {
#line 988
          tmp___1 = 0;
        }
#line 988
        tmp___2 = tmp___1;
      } else {
#line 988
        tmp___2 = ((int )*(ml->font + fx) & 224) == 128;
      }
#line 988
      if (tmp___2) {
#line 988
        if (tx) {
#line 989
          tx --;
        }
      }
    }
  }
#line 992
  markdata->cx = tx;
#line 992
  markdata->cy = ty;
#line 998
  i = 0;
#line 999
  if (line >= 0) {
#line 999
    if (line < fore->w_layer.l_height) {
#line 1000
      i = (ty - markdata->hist_offset) - line;
    } else {
#line 999
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1001
  if (ty < markdata->hist_offset) {
#line 1002
    i = ty - markdata->hist_offset;
  } else
#line 1003
  if (ty > markdata->hist_offset + (fore->w_layer.l_height - 1)) {
#line 1004
    i = (ty - markdata->hist_offset) - (fore->w_layer.l_height - 1);
  }
#line 1005
  if (i > 0) {
    {
#line 1006
    tmp___3 = MarkScrollUpDisplay(i);
#line 1006
    yend -= tmp___3;
    }
  } else
#line 1007
  if (i < 0) {
    {
#line 1008
    tmp___4 = MarkScrollDownDisplay(- i);
#line 1008
    ystart += tmp___4;
    }
  }
#line 1010
  if (markdata->second == 0) {
    {
#line 1012
    LGotoPos(flayer, tx, ty - markdata->hist_offset);
    }
#line 1013
    return;
  }
#line 1016
  qq = markdata->x1 + markdata->y1 * fore->w_layer.l_width;
#line 1017
  ff = fx + fy * fore->w_layer.l_width;
#line 1018
  tt = tx + ty * fore->w_layer.l_width;
#line 1020
  if (ff > tt) {
#line 1022
    st = tt;
#line 1022
    en = ff;
#line 1023
    x = tx;
#line 1023
    y = ty;
  } else {
#line 1027
    st = ff;
#line 1027
    en = tt;
#line 1028
    x = fx;
#line 1028
    y = fy;
  }
#line 1030
  if (st > qq) {
#line 1032
    st ++;
#line 1033
    x ++;
  }
#line 1035
  if (en < qq) {
#line 1036
    en --;
  }
#line 1037
  if (tt > qq) {
#line 1039
    revst = qq;
#line 1039
    reven = tt;
  } else {
#line 1043
    revst = tt;
#line 1043
    reven = qq;
  }
#line 1045
  ry = y - markdata->hist_offset;
#line 1046
  if (ry < ystart) {
#line 1048
    y += ystart - ry;
#line 1049
    x = 0;
#line 1050
    st = y * fore->w_layer.l_width;
#line 1051
    ry = ystart;
  }
#line 1053
  if (y < fore->w_histheight) {
#line 1053
    ml = fore->w_hlines + (fore->w_histidx + y) % fore->w_histheight;
  } else {
#line 1053
    ml = fore->w_mlines + (y - fore->w_histheight);
  }
#line 1054
  t = st;
  {
#line 1054
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1054
    if (! (t <= en)) {
#line 1054
      goto while_break;
    }
#line 1056
    if (x >= fore->w_layer.l_width) {
#line 1058
      x = 0;
#line 1059
      y ++;
#line 1059
      ry ++;
#line 1060
      if (y < fore->w_histheight) {
#line 1060
        ml = fore->w_hlines + (fore->w_histidx + y) % fore->w_histheight;
      } else {
#line 1060
        ml = fore->w_mlines + (y - fore->w_histheight);
      }
    }
#line 1062
    if (ry > yend) {
#line 1063
      goto while_break;
    }
#line 1064
    if (t == st) {
#line 1064
      goto _L___0;
    } else
#line 1064
    if (x == 0) {
      _L___0: /* CIL Label */ 
#line 1066
      wi = ml->image + fore->w_layer.l_width;
#line 1067
      ce = fore->w_layer.l_width;
      {
#line 1067
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1067
        if (! (ce >= 0)) {
#line 1067
          goto while_break___0;
        }
#line 1068
        if ((int )*wi != 32) {
#line 1069
          goto while_break___0;
        }
#line 1067
        ce --;
#line 1067
        wi --;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1071
    if (x <= ce) {
#line 1071
      if (x >= markdata->left_mar) {
#line 1071
        if (x <= markdata->right_mar) {
#line 1074
          if (fore->w_layer.l_encoding == 8) {
#line 1074
            if ((int )*(ml->font + x) == 255) {
#line 1074
              if ((int )*(ml->image + x) == 255) {
#line 1074
                tmp___5 = 1;
              } else {
#line 1074
                tmp___5 = 0;
              }
            } else {
#line 1074
              tmp___5 = 0;
            }
#line 1074
            tmp___6 = tmp___5;
          } else {
#line 1074
            tmp___6 = ((int )*(ml->font + x) & 224) == 128;
          }
#line 1074
          if (tmp___6) {
#line 1076
            if (t == revst) {
#line 1077
              revst --;
            }
#line 1078
            t --;
#line 1079
            x --;
          }
#line 1082
          if (t >= revst) {
#line 1082
            if (t <= reven) {
#line 1084
              mc = mchar_so;
#line 1086
              if (pastefont) {
#line 1087
                mc.font = *(ml->font + x);
              }
#line 1089
              mc.image = *(ml->image + x);
            } else {
#line 1082
              goto _L___1;
            }
          } else {
            _L___1: /* CIL Label */ 
            {
#line 1092
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 1092
              mc.image = *(ml->image + x);
#line 1092
              mc.attr = *(ml->attr + x);
#line 1092
              mc.font = *(ml->font + x);
#line 1092
              mc.color = *(ml->color + x);
#line 1092
              mc.mbcs = (unsigned char)0;
#line 1092
              goto while_break___1;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
#line 1094
          if (fore->w_layer.l_encoding == 8) {
#line 1094
            if ((int )*(ml->font + (x + 1)) == 255) {
#line 1094
              if ((int )*(ml->image + (x + 1)) == 255) {
#line 1094
                tmp___7 = 1;
              } else {
#line 1094
                tmp___7 = 0;
              }
            } else {
#line 1094
              tmp___7 = 0;
            }
#line 1094
            tmp___9 = tmp___7;
          } else {
#line 1094
            if (((int )*(ml->font + x) & 31) != 0) {
#line 1094
              if (((int )*(ml->font + x) & 224) == 0) {
#line 1094
                tmp___8 = 1;
              } else {
#line 1094
                tmp___8 = 0;
              }
            } else {
#line 1094
              tmp___8 = 0;
            }
#line 1094
            tmp___9 = tmp___8;
          }
#line 1094
          if (tmp___9) {
            {
#line 1096
            mc.mbcs = *(ml->image + (x + 1));
#line 1097
            LPutChar(flayer, & mc, x, y - markdata->hist_offset);
#line 1098
            t ++;
            }
          }
          {
#line 1101
          LPutChar(flayer, & mc, x, y - markdata->hist_offset);
          }
#line 1103
          if (fore->w_layer.l_encoding == 8) {
#line 1103
            if ((int )*(ml->font + (x + 1)) == 255) {
#line 1103
              if ((int )*(ml->image + (x + 1)) == 255) {
#line 1103
                tmp___10 = 1;
              } else {
#line 1103
                tmp___10 = 0;
              }
            } else {
#line 1103
              tmp___10 = 0;
            }
#line 1103
            tmp___12 = tmp___10;
          } else {
#line 1103
            if (((int )*(ml->font + x) & 31) != 0) {
#line 1103
              if (((int )*(ml->font + x) & 224) == 0) {
#line 1103
                tmp___11 = 1;
              } else {
#line 1103
                tmp___11 = 0;
              }
            } else {
#line 1103
              tmp___11 = 0;
            }
#line 1103
            tmp___12 = tmp___11;
          }
#line 1103
          if (tmp___12) {
#line 1104
            x ++;
          }
        }
      }
    }
#line 1054
    t ++;
#line 1054
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1108
  LGotoPos(flayer, tx, ty - markdata->hist_offset);
  }
#line 1109
  return;
}
}
#line 1111 "/home/pronto/abs/test-suite/screen-4.0.2/mark.c"
static void MarkAbort(void) 
{ 
  int yend ;
  int redisp ;
  int tmp ;
  struct layer *oldlay ;
  struct canvas *oldcvlist ;
  struct canvas *cv ;

  {
  {
#line 1116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1116
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1117
  markdata = (struct markdata *)flayer->l_data;
#line 1118
  fore = markdata->md_window;
#line 1119
  yend = fore->w_layer.l_height - 1;
#line 1120
  redisp = markdata->second;
#line 1121
  if (fore->w_histheight - markdata->hist_offset < fore->w_layer.l_height) {
    {
#line 1123
    markdata->second = 0;
#line 1124
    tmp = MarkScrollUpDisplay(fore->w_histheight - markdata->hist_offset);
#line 1124
    yend -= tmp;
    }
  }
#line 1126
  if (markdata->hist_offset != fore->w_histheight) {
    {
#line 1128
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1128
      oldlay = flayer;
      {
#line 1128
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1128
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1128
      flayer = flayer->l_next;
#line 1128
      oldcvlist = flayer->l_cvlist;
      {
#line 1128
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1128
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1128
      flayer->l_cvlist = oldlay->l_cvlist;
#line 1128
      cv = flayer->l_cvlist;
      {
#line 1128
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1128
        if (! cv) {
#line 1128
          goto while_break___3;
        }
#line 1128
        cv->c_layer = flayer;
#line 1128
        cv = cv->c_lnext;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 1128
      LRefreshAll(flayer, 0);
#line 1128
      flayer = oldlay;
#line 1128
      cv = flayer->l_cvlist;
      }
      {
#line 1128
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1128
        if (! cv) {
#line 1128
          goto while_break___4;
        }
#line 1128
        cv->c_layer = flayer;
#line 1128
        cv = cv->c_lnext;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1128
      (flayer->l_next)->l_cvlist = oldcvlist;
#line 1128
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 1132
    rem(markdata->x1, markdata->y1, markdata->cx, markdata->cy, redisp, (char *)0,
        yend);
    }
  }
  {
#line 1134
  ExitOverlayPage();
  }
#line 1135
  return;
}
}
#line 1138 "/home/pronto/abs/test-suite/screen-4.0.2/mark.c"
static void MarkRedisplayLine(int y , int xs , int xe , int isblank ) 
{ 
  int wy ;
  int x ;
  int i ;
  int rm ;
  int sta ;
  int sto ;
  int cp ;
  unsigned char *wi ;
  struct mline *ml ;
  struct mchar mchar_marked ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct mline *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 1150
  if (y < 0) {
#line 1151
    return;
  }
#line 1153
  markdata = (struct markdata *)flayer->l_data;
#line 1154
  fore = markdata->md_window;
#line 1156
  mchar_marked = mchar_so;
#line 1158
  wy = y + markdata->hist_offset;
#line 1159
  if (wy < fore->w_histheight) {
#line 1159
    ml = fore->w_hlines + (fore->w_histidx + wy) % fore->w_histheight;
  } else {
#line 1159
    ml = fore->w_mlines + (wy - fore->w_histheight);
  }
#line 1161
  if (markdata->second == 0) {
#line 1163
    if (fore->w_layer.l_encoding == 8) {
#line 1163
      if ((int )*(ml->font + xs) == 255) {
#line 1163
        if ((int )*(ml->image + xs) == 255) {
#line 1163
          tmp = 1;
        } else {
#line 1163
          tmp = 0;
        }
      } else {
#line 1163
        tmp = 0;
      }
#line 1163
      tmp___0 = tmp;
    } else {
#line 1163
      tmp___0 = ((int )*(ml->font + xs) & 224) == 128;
    }
#line 1163
    if (tmp___0) {
#line 1163
      if (xs > 0) {
#line 1164
        xs --;
      }
    }
#line 1165
    if (fore->w_layer.l_encoding == 8) {
#line 1165
      if ((int )*(ml->font + (xe + 1)) == 255) {
#line 1165
        if ((int )*(ml->image + (xe + 1)) == 255) {
#line 1165
          tmp___1 = 1;
        } else {
#line 1165
          tmp___1 = 0;
        }
      } else {
#line 1165
        tmp___1 = 0;
      }
#line 1165
      tmp___3 = tmp___1;
    } else {
#line 1165
      if (((int )*(ml->font + xe) & 31) != 0) {
#line 1165
        if (((int )*(ml->font + xe) & 224) == 0) {
#line 1165
          tmp___2 = 1;
        } else {
#line 1165
          tmp___2 = 0;
        }
      } else {
#line 1165
        tmp___2 = 0;
      }
#line 1165
      tmp___3 = tmp___2;
    }
#line 1165
    if (tmp___3) {
#line 1165
      if (xe < fore->w_layer.l_width - 1) {
#line 1166
        xe ++;
      }
    }
#line 1167
    if (xs == 0) {
#line 1167
      if (y > 0) {
#line 1167
        if (wy > 0) {
#line 1167
          if (wy - 1 < fore->w_histheight) {
#line 1167
            tmp___4 = fore->w_hlines + ((fore->w_histidx + wy) - 1) % fore->w_histheight;
          } else {
#line 1167
            tmp___4 = fore->w_mlines + ((wy - 1) - fore->w_histheight);
          }
#line 1167
          if ((int )*(tmp___4->image + flayer->l_width) == 0) {
            {
#line 1168
            LCDisplayLineWrap(flayer, ml, y, xs, xe, isblank);
            }
          } else {
            {
#line 1170
            LCDisplayLine(flayer, ml, y, xs, xe, isblank);
            }
          }
        } else {
          {
#line 1170
          LCDisplayLine(flayer, ml, y, xs, xe, isblank);
          }
        }
      } else {
        {
#line 1170
        LCDisplayLine(flayer, ml, y, xs, xe, isblank);
        }
      }
    } else {
      {
#line 1170
      LCDisplayLine(flayer, ml, y, xs, xe, isblank);
      }
    }
#line 1171
    return;
  }
#line 1174
  sta = markdata->y1 * fore->w_layer.l_width + markdata->x1;
#line 1175
  sto = markdata->cy * fore->w_layer.l_width + markdata->cx;
#line 1176
  if (sta > sto) {
#line 1178
    i = sta;
#line 1178
    sta = sto;
#line 1178
    sto = i;
  }
#line 1180
  cp = wy * fore->w_layer.l_width + xs;
#line 1182
  rm = markdata->right_mar;
#line 1183
  x = fore->w_layer.l_width;
#line 1183
  wi = ml->image + fore->w_layer.l_width;
  {
#line 1183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1183
    if (! (x >= 0)) {
#line 1183
      goto while_break;
    }
#line 1184
    if ((int )*wi != 32) {
#line 1185
      goto while_break;
    }
#line 1183
    x --;
#line 1183
    wi --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1186
  if (x < rm) {
#line 1187
    rm = x;
  }
#line 1189
  x = xs;
  {
#line 1189
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1189
    if (! (x <= xe)) {
#line 1189
      goto while_break___0;
    }
#line 1190
    if (cp >= sta) {
#line 1190
      if (x >= markdata->left_mar) {
#line 1191
        goto while_break___0;
      }
    }
#line 1189
    x ++;
#line 1189
    cp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1193
  if (fore->w_layer.l_encoding == 8) {
#line 1193
    if ((int )*(ml->font + x) == 255) {
#line 1193
      if ((int )*(ml->image + x) == 255) {
#line 1193
        tmp___5 = 1;
      } else {
#line 1193
        tmp___5 = 0;
      }
    } else {
#line 1193
      tmp___5 = 0;
    }
#line 1193
    tmp___6 = tmp___5;
  } else {
#line 1193
    tmp___6 = ((int )*(ml->font + x) & 224) == 128;
  }
#line 1193
  if (tmp___6) {
#line 1194
    x --;
  }
#line 1196
  if (x > xs) {
    {
#line 1197
    LCDisplayLine(flayer, ml, y, xs, x - 1, isblank);
    }
  }
  {
#line 1198
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1198
    if (! (x <= xe)) {
#line 1198
      goto while_break___1;
    }
#line 1200
    if (cp > sto) {
#line 1201
      goto while_break___1;
    } else
#line 1200
    if (x > rm) {
#line 1201
      goto while_break___1;
    }
#line 1203
    if (pastefont) {
#line 1204
      mchar_marked.font = *(ml->font + x);
    }
#line 1206
    mchar_marked.image = *(ml->image + x);
#line 1208
    mchar_marked.mbcs = (unsigned char)0;
#line 1209
    if (fore->w_layer.l_encoding == 8) {
#line 1209
      if ((int )*(ml->font + (x + 1)) == 255) {
#line 1209
        if ((int )*(ml->image + (x + 1)) == 255) {
#line 1209
          tmp___7 = 1;
        } else {
#line 1209
          tmp___7 = 0;
        }
      } else {
#line 1209
        tmp___7 = 0;
      }
#line 1209
      tmp___9 = tmp___7;
    } else {
#line 1209
      if (((int )*(ml->font + x) & 31) != 0) {
#line 1209
        if (((int )*(ml->font + x) & 224) == 0) {
#line 1209
          tmp___8 = 1;
        } else {
#line 1209
          tmp___8 = 0;
        }
      } else {
#line 1209
        tmp___8 = 0;
      }
#line 1209
      tmp___9 = tmp___8;
    }
#line 1209
    if (tmp___9) {
#line 1211
      mchar_marked.mbcs = *(ml->image + (x + 1));
#line 1212
      cp ++;
    }
    {
#line 1215
    LPutChar(flayer, & mchar_marked, x, y);
    }
#line 1217
    if (fore->w_layer.l_encoding == 8) {
#line 1217
      if ((int )*(ml->font + (x + 1)) == 255) {
#line 1217
        if ((int )*(ml->image + (x + 1)) == 255) {
#line 1217
          tmp___10 = 1;
        } else {
#line 1217
          tmp___10 = 0;
        }
      } else {
#line 1217
        tmp___10 = 0;
      }
#line 1217
      tmp___12 = tmp___10;
    } else {
#line 1217
      if (((int )*(ml->font + x) & 31) != 0) {
#line 1217
        if (((int )*(ml->font + x) & 224) == 0) {
#line 1217
          tmp___11 = 1;
        } else {
#line 1217
          tmp___11 = 0;
        }
      } else {
#line 1217
        tmp___11 = 0;
      }
#line 1217
      tmp___12 = tmp___11;
    }
#line 1217
    if (tmp___12) {
#line 1218
      x ++;
    }
#line 1198
    x ++;
#line 1198
    cp ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1221
  if (x <= xe) {
    {
#line 1222
    LCDisplayLine(flayer, ml, y, x, xe, isblank);
    }
  }
#line 1223
  return;
}
}
#line 1229 "/home/pronto/abs/test-suite/screen-4.0.2/mark.c"
static int MarkRewrite(int ry , int xs , int xe , struct mchar *rend , int doit ) 
{ 
  int dx ;
  int x ;
  int y ;
  int st ;
  int en ;
  int t ;
  int rm ;
  unsigned char *i ;
  struct mline *ml ;
  struct mchar mchar_marked ;
  int tmp ;
  unsigned char *tmp___0 ;
  int tmp___1 ;
  unsigned char *tmp___2 ;
  int tmp___3 ;

  {
#line 1239
  mchar_marked = mchar_so;
  {
#line 1241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1241
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1242
  markdata = (struct markdata *)flayer->l_data;
#line 1243
  fore = markdata->md_window;
#line 1244
  y = ry + markdata->hist_offset;
#line 1245
  if (y < fore->w_histheight) {
#line 1245
    ml = fore->w_hlines + (fore->w_histidx + y) % fore->w_histheight;
  } else {
#line 1245
    ml = fore->w_mlines + (y - fore->w_histheight);
  }
#line 1247
  if (fore->w_layer.l_encoding) {
#line 1247
    if (fore->w_layer.l_encoding != 8) {
#line 1247
      if (display->d_encoding == 8) {
        {
#line 1247
        tmp = ContainsSpecialDeffont(ml, xs, xe, fore->w_layer.l_encoding);
        }
#line 1247
        if (tmp) {
#line 1248
          return (1000);
        }
      }
    }
  }
#line 1250
  dx = (xe - xs) + 1;
#line 1251
  if (doit) {
#line 1253
    i = ml->image + xs;
    {
#line 1254
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1254
      tmp___1 = dx;
#line 1254
      dx --;
#line 1254
      if (! tmp___1) {
#line 1254
        goto while_break___0;
      }
      {
#line 1255
      tmp___0 = i;
#line 1255
      i ++;
#line 1255
      PUTCHAR((int )*tmp___0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1256
    return (0);
  }
#line 1259
  if (markdata->second == 0) {
#line 1260
    en = -1;
#line 1260
    st = en;
  } else {
#line 1263
    st = markdata->y1 * fore->w_layer.l_width + markdata->x1;
#line 1264
    en = markdata->cy * fore->w_layer.l_width + markdata->cx;
#line 1265
    if (st > en) {
#line 1267
      t = st;
#line 1267
      st = en;
#line 1267
      en = t;
    }
  }
#line 1270
  t = y * fore->w_layer.l_width + xs;
#line 1271
  rm = fore->w_layer.l_width;
#line 1271
  i = ml->image + fore->w_layer.l_width;
  {
#line 1271
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1271
    if (! (rm >= 0)) {
#line 1271
      goto while_break___1;
    }
#line 1272
    tmp___2 = i;
#line 1272
    i --;
#line 1272
    if ((int )*tmp___2 != 32) {
#line 1273
      goto while_break___1;
    }
#line 1271
    rm --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1274
  if (rm > markdata->right_mar) {
#line 1275
    rm = markdata->right_mar;
  }
#line 1276
  x = xs;
  {
#line 1277
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1277
    tmp___3 = dx;
#line 1277
    dx --;
#line 1277
    if (! tmp___3) {
#line 1277
      goto while_break___2;
    }
#line 1279
    if (t >= st) {
#line 1279
      if (t <= en) {
#line 1279
        if (x >= markdata->left_mar) {
#line 1279
          if (x <= rm) {
#line 1282
            if (pastefont) {
#line 1283
              mchar_marked.font = *(ml->font + x);
            }
#line 1285
            rend->image = mchar_marked.image;
#line 1286
            if ((int )rend->image == (int )mchar_marked.image) {
#line 1286
              if ((int )rend->attr == (int )mchar_marked.attr) {
#line 1286
                if ((int )rend->font == (int )mchar_marked.font) {
#line 1286
                  if (! ((int )rend->color == (int )mchar_marked.color)) {
#line 1287
                    return (1000);
                  }
                } else {
#line 1287
                  return (1000);
                }
              } else {
#line 1287
                return (1000);
              }
            } else {
#line 1287
              return (1000);
            }
          } else {
#line 1279
            goto _L___1;
          }
        } else {
#line 1279
          goto _L___1;
        }
      } else {
#line 1279
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 1291
      rend->image = *(ml->image + x);
#line 1292
      if ((int )rend->image == (int )*(ml->image + x)) {
#line 1292
        if ((int )rend->attr == (int )*(ml->attr + x)) {
#line 1292
          if ((int )rend->font == (int )*(ml->font + x)) {
#line 1292
            if (! ((int )rend->color == (int )*(ml->color + x))) {
#line 1293
              return (1000);
            }
          } else {
#line 1293
            return (1000);
          }
        } else {
#line 1293
          return (1000);
        }
      } else {
#line 1293
        return (1000);
      }
    }
#line 1295
    x ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1297
  return ((xe - xs) + 1);
}
}
#line 1304 "/home/pronto/abs/test-suite/screen-4.0.2/mark.c"
static int MarkScrollUpDisplay(int n ) 
{ 
  int i ;
  int tmp ;

  {
  {
#line 1309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1309
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1310
  if (n <= 0) {
#line 1311
    return (0);
  }
#line 1312
  if (n > fore->w_histheight - markdata->hist_offset) {
#line 1313
    n = fore->w_histheight - markdata->hist_offset;
  }
#line 1314
  markdata->hist_offset += n;
#line 1315
  if (n < flayer->l_height) {
#line 1315
    i = n;
  } else {
#line 1315
    i = flayer->l_height;
  }
  {
#line 1316
  LScrollV(flayer, i, 0, flayer->l_height - 1, 0);
  }
  {
#line 1317
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1317
    tmp = i;
#line 1317
    i --;
#line 1317
    if (! (tmp > 0)) {
#line 1317
      goto while_break___0;
    }
    {
#line 1318
    MarkRedisplayLine((flayer->l_height - i) - 1, 0, flayer->l_width - 1, 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1319
  return (n);
}
}
#line 1322 "/home/pronto/abs/test-suite/screen-4.0.2/mark.c"
static int MarkScrollDownDisplay(int n ) 
{ 
  int i ;
  int tmp ;

  {
  {
#line 1328
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1328
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1329
  if (n <= 0) {
#line 1330
    return (0);
  }
#line 1331
  if (n > markdata->hist_offset) {
#line 1332
    n = markdata->hist_offset;
  }
#line 1333
  markdata->hist_offset -= n;
#line 1334
  if (n < flayer->l_height) {
#line 1334
    i = n;
  } else {
#line 1334
    i = flayer->l_height;
  }
  {
#line 1335
  LScrollV(flayer, - i, 0, fore->w_layer.l_height - 1, 0);
  }
  {
#line 1336
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1336
    tmp = i;
#line 1336
    i --;
#line 1336
    if (! (tmp > 0)) {
#line 1336
      goto while_break___0;
    }
    {
#line 1337
    MarkRedisplayLine(i, 0, flayer->l_width - 1, 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1338
  return (n);
}
}
#line 1341 "/home/pronto/abs/test-suite/screen-4.0.2/mark.c"
int InMark(void) 
{ 


  {
#line 1344
  if (flayer) {
#line 1344
    if ((unsigned long )flayer->l_layfn == (unsigned long )(& MarkLf)) {
#line 1345
      return (1);
    }
  }
#line 1346
  return (0);
}
}
#line 1349 "/home/pronto/abs/test-suite/screen-4.0.2/mark.c"
void MakePaster(struct paster *pa , char *buf___0 , int len , int bufiscopy ) 
{ 


  {
  {
#line 1356
  FreePaster(pa);
#line 1357
  pa->pa_pasteptr = buf___0;
#line 1358
  pa->pa_pastelen = len;
  }
#line 1359
  if (bufiscopy) {
#line 1360
    pa->pa_pastebuf = buf___0;
  }
  {
#line 1361
  pa->pa_pastelayer = flayer;
#line 1362
  DoProcess((struct win *)(flayer->l_bottom)->l_data, & pa->pa_pasteptr, & pa->pa_pastelen,
            pa);
  }
#line 1363
  return;
}
}
#line 1365 "/home/pronto/abs/test-suite/screen-4.0.2/mark.c"
void FreePaster(struct paster *pa ) 
{ 


  {
#line 1369
  if (pa->pa_pastebuf) {
    {
#line 1370
    free((void *)pa->pa_pastebuf);
    }
  }
  {
#line 1371
  pa->pa_pastebuf = (char *)0;
#line 1372
  pa->pa_pasteptr = (char *)0;
#line 1373
  pa->pa_pastelen = 0;
#line 1374
  pa->pa_pastelayer = (struct layer *)0;
#line 1375
  evdeq(& pa->pa_slowev);
  }
#line 1376
  return;
}
}
#line 275 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t umask(__mode_t __mask ) ;
#line 445 "/usr/include/libio.h"
extern  __attribute__((__nothrow__)) int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 241 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 273
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 583
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 369 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 507
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) execvp)(char const   *__file ,
                                                                                   char * const  *__argv ) ;
#line 916
extern  __attribute__((__nothrow__)) int ftruncate(int __fd , __off_t __length ) ;
#line 62 "/home/pronto/abs/test-suite/screen-4.0.2/extern.h"
void WMsg(struct win *p , int err , char *str ) ;
#line 69
void FinishRc(char *rcfilename ) ;
#line 76
int printpipe(struct win *p , char *cmd ) ;
#line 77
int readpipe(char **cmdv ) ;
#line 50 "/home/pronto/abs/test-suite/screen-4.0.2/fileio.c"
static char *CatExtra(char *str1 , char *str2 ) ;
#line 51
static char *findrcfile(char *rcfile ) ;
#line 54 "/home/pronto/abs/test-suite/screen-4.0.2/fileio.c"
char *rc_name  =    (char *)"";
#line 55 "/home/pronto/abs/test-suite/screen-4.0.2/fileio.c"
int rc_recursion  =    0;
#line 57 "/home/pronto/abs/test-suite/screen-4.0.2/fileio.c"
static char *CatExtra(char *str1 , char *str2 ) 
{ 
  register char *cp ;
  register int len1 ;
  register int len2 ;
  register int add_colon ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 64
  tmp = strlen((char const   *)str1);
#line 64
  len1 = (int )tmp;
  }
#line 65
  if (len1 == 0) {
#line 66
    return (str2);
  }
#line 67
  add_colon = (int )*(str1 + (len1 - 1)) != 58;
#line 68
  if (str2) {
    {
#line 70
    tmp___0 = strlen((char const   *)str2);
#line 70
    len2 = (int )tmp___0;
#line 71
    tmp___1 = realloc((void *)str2, (((unsigned int )len1 + (unsigned int )len2) + (unsigned int )add_colon) + 1U);
#line 71
    cp = (char *)tmp___1;
    }
#line 71
    if ((unsigned long )cp == (unsigned long )((void *)0)) {
      {
#line 72
      Panic(0, strnomem);
      }
    }
    {
#line 73
    bcopy((void const   *)cp, (void *)((cp + len1) + add_colon), (size_t )(len2 + 1));
    }
  } else {
#line 77
    if (len1 == 0) {
#line 78
      return ((char *)0);
    }
    {
#line 79
    tmp___2 = malloc(((unsigned int )len1 + (unsigned int )add_colon) + 1U);
#line 79
    cp = (char *)tmp___2;
    }
#line 79
    if ((unsigned long )cp == (unsigned long )((void *)0)) {
      {
#line 80
      Panic(0, strnomem);
      }
    }
#line 81
    *(cp + (len1 + add_colon)) = (char )'\000';
  }
  {
#line 83
  bcopy((void const   *)str1, (void *)cp, (size_t )len1);
  }
#line 84
  if (add_colon) {
#line 85
    *(cp + len1) = (char )':';
  }
#line 87
  return (cp);
}
}
#line 90 "/home/pronto/abs/test-suite/screen-4.0.2/fileio.c"
static char *findrcfile(char *rcfile ) 
{ 
  char buf___0[256] ;
  char *p ;
  char *rcend ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;

  {
#line 97
  if (rcfile) {
    {
#line 99
    tmp = rindex((char const   *)rc_name, '/');
#line 99
    rcend = tmp;
    }
#line 100
    if ((int )*rcfile != 47) {
#line 100
      if (rcend) {
        {
#line 100
        tmp___2 = strlen((char const   *)rcfile);
        }
#line 100
        if ((unsigned long )(((rcend - rc_name) + (long )tmp___2) + 2L) < sizeof(buf___0)) {
          {
#line 102
          strncpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)rc_name,
                  (size_t )((rcend - rc_name) + 1L));
#line 103
          strcpy((char */* __restrict  */)((buf___0 + (rcend - rc_name)) + 1), (char const   */* __restrict  */)rcfile);
#line 104
          tmp___1 = access((char const   *)(buf___0), 4);
          }
#line 104
          if (tmp___1 == 0) {
            {
#line 105
            tmp___0 = SaveStr((char const   *)(buf___0));
            }
#line 105
            return (tmp___0);
          }
        }
      }
    }
    {
#line 107
    while (1) {
      while_continue: /* CIL Label */ ;
#line 107
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 108
    tmp___3 = SaveStr((char const   *)rcfile);
    }
#line 108
    return (tmp___3);
  }
  {
#line 110
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 110
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 111
  p = getenv("SCREENRC");
  }
#line 111
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 111
    if ((int )*p != 0) {
      {
#line 113
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 113
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 114
      tmp___4 = SaveStr((char const   *)p);
      }
#line 114
      return (tmp___4);
    } else {
#line 111
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 118
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 118
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 119
    tmp___5 = strlen((char const   *)home);
    }
#line 119
    if ((unsigned long )tmp___5 > sizeof(buf___0) - 12UL) {
      {
#line 120
      Panic(0, (char *)"Rc: home too large");
      }
    }
    {
#line 121
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%s/.screenrc",
            home);
#line 122
    tmp___6 = SaveStr((char const   *)(buf___0));
    }
#line 122
    return (tmp___6);
  }
}
}
#line 131 "/home/pronto/abs/test-suite/screen-4.0.2/fileio.c"
void StartRc(char *rcfilename ) 
{ 
  register int argc ;
  register int len ;
  register char *p ;
  register char *cp ;
  char buf___0[2048] ;
  char *args[64] ;
  int argl[64] ;
  FILE *fp ;
  char *oldrc_name ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 141
  oldrc_name = rc_name;
#line 144
  extra_incap = CatExtra((char *)"TF", extra_incap);
  }
#line 147
  if (display) {
    {
#line 147
    tmp = strncmp((char const   *)(display->d_termname), "vt", (size_t )2);
    }
#line 147
    if (tmp) {
      {
#line 147
      tmp___0 = strncmp((char const   *)(display->d_termname), "xterm", (size_t )5);
      }
#line 147
      if (! tmp___0) {
        {
#line 148
        extra_incap = CatExtra((char *)"xn:f0=\033Op:f1=\033Oq:f2=\033Or:f3=\033Os:f4=\033Ot:f5=\033Ou:f6=\033Ov:f7=\033Ow:f8=\033Ox:f9=\033Oy:f.=\033On:f,=\033Ol:fe=\033OM:f+=\033Ok:f-=\033Om:f*=\033Oj:f/=\033Oo:fq=\033OX",
                               extra_incap);
        }
      }
    } else {
      {
#line 148
      extra_incap = CatExtra((char *)"xn:f0=\033Op:f1=\033Oq:f2=\033Or:f3=\033Os:f4=\033Ot:f5=\033Ou:f6=\033Ov:f7=\033Ow:f8=\033Ox:f9=\033Oy:f.=\033On:f,=\033Ol:fe=\033OM:f+=\033Ok:f-=\033Om:f*=\033Oj:f/=\033Oo:fq=\033OX",
                             extra_incap);
      }
    }
  }
  {
#line 150
  rc_name = findrcfile(rcfilename);
#line 152
  fp = secfopen(rc_name, (char *)"r");
  }
#line 152
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 154
    if (! rc_recursion) {
#line 154
      if (RcFileName) {
        {
#line 154
        tmp___1 = strcmp((char const   *)RcFileName, (char const   *)rc_name);
        }
#line 154
        if (! tmp___1) {
          {
#line 161
          while (1) {
            while_continue: /* CIL Label */ ;
#line 161
            goto while_break;
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 162
          Panic(0, (char *)"Unable to open \"%s\".", rc_name);
          }
        }
      }
    }
    {
#line 165
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 165
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 166
    if ((unsigned long )rc_name == (unsigned long )((char *)0)) {
      {
#line 166
      abort();
      }
    } else {
      {
#line 166
      free((void *)rc_name);
      }
    }
#line 166
    rc_name = (char *)0;
#line 167
    rc_name = oldrc_name;
#line 168
    return;
  }
  {
#line 170
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 170
    tmp___13 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
#line 170
    if (! ((unsigned long )tmp___13 != (unsigned long )((void *)0))) {
#line 170
      goto while_break___1;
    }
    {
#line 172
    p = rindex((char const   *)(buf___0), '\n');
    }
#line 172
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 173
      *p = (char )'\000';
    }
    {
#line 174
    argc = Parse(buf___0, (int )sizeof(buf___0), args, argl);
    }
#line 174
    if (argc == 0) {
#line 175
      goto while_continue___1;
    }
    {
#line 176
    tmp___12 = strcmp((char const   *)args[0], "echo");
    }
#line 176
    if (tmp___12 == 0) {
#line 178
      if (! display) {
#line 179
        goto while_continue___1;
      }
#line 180
      if (argc < 2) {
        {
#line 182
        Msg(0, (char *)"%s: \'echo [-n] \"string\"\' expected.", rc_name);
        }
#line 183
        goto while_continue___1;
      } else
#line 180
      if (argc == 3) {
        {
#line 180
        tmp___2 = strcmp((char const   *)args[1], "-n");
        }
#line 180
        if (tmp___2) {
          {
#line 182
          Msg(0, (char *)"%s: \'echo [-n] \"string\"\' expected.", rc_name);
          }
#line 183
          goto while_continue___1;
        } else {
#line 180
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 180
      if (argc > 3) {
        {
#line 182
        Msg(0, (char *)"%s: \'echo [-n] \"string\"\' expected.", rc_name);
        }
#line 183
        goto while_continue___1;
      }
      {
#line 185
      AddStr(args[argc - 1]);
      }
#line 186
      if (argc != 3) {
        {
#line 188
        AddStr((char *)"\r\n");
#line 189
        Flush();
        }
      }
    } else {
      {
#line 192
      tmp___11 = strcmp((char const   *)args[0], "sleep");
      }
#line 192
      if (tmp___11 == 0) {
#line 194
        if (! display) {
#line 195
          goto while_continue___1;
        }
        {
#line 196
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 196
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 197
        if (argc != 2) {
          {
#line 199
          Msg(0, (char *)"%s: sleep: one numeric argument expected.", rc_name);
          }
#line 200
          goto while_continue___1;
        }
        {
#line 202
        tmp___3 = atoi((char const   *)args[1]);
#line 202
        DisplaySleep1000(1000 * tmp___3, 1);
        }
      } else {
        {
#line 205
        tmp___9 = strcmp((char const   *)args[0], "termcapinfo");
        }
#line 205
        if (tmp___9) {
          {
#line 205
          tmp___10 = strcmp((char const   *)args[0], "terminfo");
          }
#line 205
          if (tmp___10) {
            {
#line 236
            tmp___8 = strcmp((char const   *)args[0], "source");
            }
#line 236
            if (! tmp___8) {
#line 238
              if (rc_recursion <= 10) {
                {
#line 240
                rc_recursion ++;
#line 241
                StartRc(args[1]);
#line 242
                rc_recursion --;
                }
              }
            }
          } else {
            _L___0: /* CIL Label */ 
#line 210
            if (! display) {
#line 211
              goto while_continue___1;
            }
#line 212
            if (argc < 3) {
              {
#line 214
              Msg(0, (char *)"%s: %s: incorrect number of arguments.", rc_name, args[0]);
              }
#line 215
              goto while_continue___1;
            } else
#line 212
            if (argc > 4) {
              {
#line 214
              Msg(0, (char *)"%s: %s: incorrect number of arguments.", rc_name, args[0]);
              }
#line 215
              goto while_continue___1;
            }
#line 217
            p = args[1];
            {
#line 217
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 217
              if (p) {
#line 217
                if (! *p) {
#line 217
                  goto while_break___3;
                }
              } else {
#line 217
                goto while_break___3;
              }
              {
#line 219
              cp = index((char const   *)p, '|');
              }
#line 219
              if ((unsigned long )cp != (unsigned long )((char *)0)) {
#line 220
                tmp___4 = cp;
#line 220
                cp ++;
#line 220
                *tmp___4 = (char )'\000';
              }
              {
#line 221
              tmp___5 = strlen((char const   *)p);
#line 221
              len = (int )tmp___5;
              }
#line 222
              if ((int )*(p + (len - 1)) == 42) {
#line 224
                if (! (len - 1)) {
#line 225
                  goto while_break___3;
                } else {
                  {
#line 224
                  tmp___6 = strncmp((char const   *)p, (char const   *)(display->d_termname),
                                    (size_t )(len - 1));
                  }
#line 224
                  if (! tmp___6) {
#line 225
                    goto while_break___3;
                  }
                }
              } else {
                {
#line 227
                tmp___7 = strcmp((char const   *)p, (char const   *)(display->d_termname));
                }
#line 227
                if (! tmp___7) {
#line 228
                  goto while_break___3;
                }
              }
#line 217
              p = cp;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 230
            if (p) {
#line 230
              if (! *p) {
#line 231
                goto while_continue___1;
              }
            } else {
#line 231
              goto while_continue___1;
            }
            {
#line 232
            extra_incap = CatExtra(args[2], extra_incap);
            }
#line 233
            if (argc == 4) {
              {
#line 234
              extra_outcap = CatExtra(args[3], extra_outcap);
              }
            }
          }
        } else {
#line 205
          goto _L___0;
        }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 246
  fclose(fp);
  }
#line 247
  if ((unsigned long )rc_name == (unsigned long )((char *)0)) {
    {
#line 247
    abort();
    }
  } else {
    {
#line 247
    free((void *)rc_name);
    }
  }
#line 247
  rc_name = (char *)0;
#line 248
  rc_name = oldrc_name;
#line 249
  return;
}
}
#line 251 "/home/pronto/abs/test-suite/screen-4.0.2/fileio.c"
void FinishRc(char *rcfilename ) 
{ 
  char buf___0[2048] ;
  FILE *fp ;
  char *oldrc_name ;
  int *tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 257
  oldrc_name = rc_name;
#line 259
  rc_name = findrcfile(rcfilename);
#line 261
  fp = secfopen(rc_name, (char *)"r");
  }
#line 261
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 263
    if (rc_recursion) {
      {
#line 264
      tmp = __errno_location();
#line 264
      Msg(*tmp, (char *)"%s: source %s", oldrc_name, rc_name);
      }
    } else
#line 265
    if (RcFileName) {
      {
#line 265
      tmp___0 = strcmp((char const   *)RcFileName, (char const   *)rc_name);
      }
#line 265
      if (! tmp___0) {
        {
#line 272
        while (1) {
          while_continue: /* CIL Label */ ;
#line 272
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 273
        Panic(0, (char *)"Unable to open \"%s\".", rc_name);
        }
      }
    }
    {
#line 276
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 276
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 277
    if ((unsigned long )rc_name == (unsigned long )((char *)0)) {
      {
#line 277
      abort();
      }
    } else {
      {
#line 277
      free((void *)rc_name);
      }
    }
#line 277
    rc_name = (char *)0;
#line 278
    rc_name = oldrc_name;
#line 279
    return;
  }
  {
#line 282
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 282
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 283
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 283
    tmp___1 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
#line 283
    if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
#line 283
      goto while_break___2;
    }
    {
#line 284
    RcLine(buf___0, (int )sizeof(buf___0));
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 285
  fclose(fp);
  }
#line 286
  if ((unsigned long )rc_name == (unsigned long )((char *)0)) {
    {
#line 286
    abort();
    }
  } else {
    {
#line 286
    free((void *)rc_name);
    }
  }
#line 286
  rc_name = (char *)0;
#line 287
  rc_name = oldrc_name;
#line 288
  return;
}
}
#line 290 "/home/pronto/abs/test-suite/screen-4.0.2/fileio.c"
void do_source(char *rcfilename ) 
{ 


  {
#line 294
  if (rc_recursion > 10) {
    {
#line 296
    Msg(0, (char *)"%s: source: recursion limit reached", rc_name);
    }
#line 297
    return;
  }
  {
#line 299
  rc_recursion ++;
#line 300
  FinishRc(rcfilename);
#line 301
  rc_recursion --;
  }
#line 302
  return;
}
}
#line 310 "/home/pronto/abs/test-suite/screen-4.0.2/fileio.c"
void RcLine(char *ubuf , int ubufl ) 
{ 
  char *args[64] ;
  int argl[64] ;
  int tmp ;

  {
#line 322
  if (display) {
#line 324
    fore = display->d_fore;
#line 325
    flayer = (display->d_forecv)->c_layer;
  } else
#line 328
  if (fore) {
#line 328
    flayer = fore->w_savelayer;
  } else {
#line 328
    flayer = (struct layer *)0;
  }
  {
#line 329
  tmp = Parse(ubuf, ubufl, args, argl);
  }
#line 329
  if (tmp <= 0) {
#line 330
    return;
  }
#line 332
  if (! display) {
#line 335
    EffectiveAclUser = users;
    {
#line 336
    while (1) {
      while_continue: /* CIL Label */ ;
#line 336
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 339
  DoCommand(args, argl);
#line 341
  EffectiveAclUser = (struct acluser *)0;
  }
#line 343
  return;
}
}
#line 348 "/home/pronto/abs/test-suite/screen-4.0.2/fileio.c"
void WriteFile(struct acluser *user , char *fn , int dump ) 
{ 
  register int i ;
  register int j ;
  register int k ;
  register char *p ;
  register FILE *f ;
  char fnbuf[1024] ;
  char *mode ;
  int public ;
  int old_umask ;
  struct stat stb ;
  struct stat stb2 ;
  int fd ;
  int exists ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  __mode_t tmp___5 ;
  int tmp___6 ;
  FILE *tmp___7 ;
  struct mline *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char const   *tmp___12 ;
  int tmp___13 ;

  {
#line 365
  mode = (char *)"w";
#line 367
  public = 0;
#line 375
  exists = 0;
  {
#line 381
  if (dump == 0) {
#line 381
    goto case_0;
  }
#line 393
  if (dump == 3) {
#line 393
    goto case_3;
  }
#line 393
  if (dump == 1) {
#line 393
    goto case_3;
  }
#line 408
  if (dump == 2) {
#line 408
    goto case_2;
  }
#line 379
  goto switch_break;
  case_0: /* CIL Label */ 
#line 382
  if ((unsigned long )fn == (unsigned long )((char *)0)) {
#line 384
    i = (int )(SockName - SockPath);
#line 385
    if (i > (int )sizeof(fnbuf) - 9) {
#line 386
      i = 0;
    }
    {
#line 387
    strncpy((char */* __restrict  */)(fnbuf), (char const   */* __restrict  */)(SockPath),
            (size_t )i);
#line 388
    strcpy((char */* __restrict  */)(fnbuf + i), (char const   */* __restrict  */)".termcap");
#line 389
    fn = fnbuf;
    }
  }
#line 391
  goto switch_break;
  case_3: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 394
  if ((unsigned long )fn == (unsigned long )((char *)0)) {
#line 396
    if ((unsigned long )fore == (unsigned long )((struct win *)0)) {
#line 397
      return;
    }
#line 398
    if (hardcopydir) {
#line 398
      if (*hardcopydir) {
        {
#line 398
        tmp = strlen((char const   *)hardcopydir);
        }
#line 398
        if ((unsigned long )tmp < sizeof(fnbuf) - 21UL) {
          {
#line 399
          sprintf((char */* __restrict  */)(fnbuf), (char const   */* __restrict  */)"%s/hardcopy.%d",
                  hardcopydir, fore->w_number);
          }
        } else {
          {
#line 401
          sprintf((char */* __restrict  */)(fnbuf), (char const   */* __restrict  */)"hardcopy.%d",
                  fore->w_number);
          }
        }
      } else {
        {
#line 401
        sprintf((char */* __restrict  */)(fnbuf), (char const   */* __restrict  */)"hardcopy.%d",
                fore->w_number);
        }
      }
    } else {
      {
#line 401
      sprintf((char */* __restrict  */)(fnbuf), (char const   */* __restrict  */)"hardcopy.%d",
              fore->w_number);
      }
    }
#line 402
    fn = fnbuf;
  }
#line 404
  if (hardcopy_append) {
    {
#line 404
    tmp___0 = access((char const   *)fn, 2);
    }
#line 404
    if (! tmp___0) {
#line 405
      mode = (char *)"a";
    }
  }
#line 406
  goto switch_break;
  case_2: /* CIL Label */ 
#line 409
  if ((unsigned long )fn == (unsigned long )((char *)0)) {
    {
#line 411
    strncpy((char */* __restrict  */)(fnbuf), (char const   */* __restrict  */)BufferFile,
            (size_t )(sizeof(fnbuf) - 1UL));
#line 412
    fnbuf[sizeof(fnbuf) - 1UL] = (char)0;
#line 413
    fn = fnbuf;
    }
  }
  {
#line 415
  tmp___1 = strcmp((char const   *)fn, "/tmp/screen-exchange");
  }
#line 415
  if (tmp___1) {
#line 415
    tmp___2 = 0;
  } else {
#line 415
    tmp___2 = 1;
  }
  {
#line 415
  public = tmp___2;
#line 417
  tmp___3 = lstat((char const   */* __restrict  */)fn, (struct stat */* __restrict  */)(& stb));
  }
#line 417
  if (tmp___3) {
#line 417
    tmp___4 = 0;
  } else {
#line 417
    tmp___4 = 1;
  }
#line 417
  exists = tmp___4;
#line 418
  if (public) {
#line 418
    if (exists) {
#line 418
      if ((stb.st_mode & 61440U) == 40960U) {
        {
#line 420
        Msg(0, (char *)"No write to links, please.");
        }
#line 421
        return;
      } else
#line 418
      if (stb.st_nlink > 1U) {
        {
#line 420
        Msg(0, (char *)"No write to links, please.");
        }
#line 421
        return;
      }
    }
  }
#line 424
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 428
  while (1) {
    while_continue: /* CIL Label */ ;
#line 428
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 429
  tmp___11 = UserContext();
  }
#line 429
  if (tmp___11 > 0) {
    {
#line 431
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 431
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 433
    if (dump == 2) {
#line 433
      if (public) {
        {
#line 435
        tmp___5 = umask((__mode_t )0);
#line 435
        old_umask = (int )tmp___5;
        }
#line 437
        if (exists) {
          {
#line 439
          fd = open((char const   *)fn, 1, 438);
          }
#line 439
          if (fd >= 0) {
            {
#line 441
            tmp___6 = fstat(fd, & stb2);
            }
#line 441
            if (tmp___6 == 0) {
#line 441
              if (stb.st_dev == stb2.st_dev) {
#line 441
                if (stb.st_ino == stb2.st_ino) {
                  {
#line 442
                  ftruncate(fd, (__off_t )0);
                  }
                } else {
                  {
#line 445
                  close(fd);
#line 446
                  fd = -1;
                  }
                }
              } else {
                {
#line 445
                close(fd);
#line 446
                fd = -1;
                }
              }
            } else {
              {
#line 445
              close(fd);
#line 446
              fd = -1;
              }
            }
          }
        } else {
          {
#line 451
          fd = open((char const   *)fn, 193, 438);
          }
        }
#line 452
        if (fd >= 0) {
          {
#line 452
          tmp___7 = fdopen(fd, (char const   *)mode);
#line 452
          f = tmp___7;
          }
        } else {
#line 452
          f = (FILE *)0;
        }
        {
#line 456
        umask((__mode_t )old_umask);
        }
      } else {
        {
#line 460
        f = fopen((char const   */* __restrict  */)fn, (char const   */* __restrict  */)mode);
        }
      }
    } else {
      {
#line 460
      f = fopen((char const   */* __restrict  */)fn, (char const   */* __restrict  */)mode);
      }
    }
#line 461
    if ((unsigned long )f == (unsigned long )((void *)0)) {
      {
#line 463
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 463
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 464
      UserReturn(0);
      }
    } else {
      {
#line 471
      if (dump == 3) {
#line 471
        goto case_3___0;
      }
#line 471
      if (dump == 1) {
#line 471
        goto case_3___0;
      }
#line 503
      if (dump == 0) {
#line 503
        goto case_0___0;
      }
#line 511
      if (dump == 2) {
#line 511
        goto case_2___0;
      }
#line 468
      goto switch_break___0;
      case_3___0: /* CIL Label */ 
      case_1___0: /* CIL Label */ 
#line 472
      if (! fore) {
#line 473
        goto switch_break___0;
      }
#line 474
      if ((int )*mode == 97) {
        {
#line 476
        _IO_putc('>', f);
#line 477
        j = fore->w_layer.l_width - 2;
        }
        {
#line 477
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 477
          if (! (j > 0)) {
#line 477
            goto while_break___2;
          }
          {
#line 478
          _IO_putc('=', f);
#line 477
          j --;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 479
        fputs((char const   */* __restrict  */)"<\n", (FILE */* __restrict  */)f);
        }
      }
#line 481
      if (dump == 3) {
#line 483
        i = 0;
        {
#line 483
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 483
          if (! (i < fore->w_histheight)) {
#line 483
            goto while_break___3;
          }
#line 485
          if (i < fore->w_histheight) {
#line 485
            tmp___8 = fore->w_hlines + (fore->w_histidx + i) % fore->w_histheight;
          } else {
#line 485
            tmp___8 = fore->w_mlines + (i - fore->w_histheight);
          }
#line 485
          p = (char *)tmp___8->image;
#line 486
          k = fore->w_layer.l_width - 1;
          {
#line 486
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 486
            if (k >= 0) {
#line 486
              if (! ((int )*(p + k) == 32)) {
#line 486
                goto while_break___4;
              }
            } else {
#line 486
              goto while_break___4;
            }
#line 486
            k --;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 488
          j = 0;
          {
#line 488
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 488
            if (! (j <= k)) {
#line 488
              goto while_break___5;
            }
            {
#line 489
            _IO_putc((int )*(p + j), f);
#line 488
            j ++;
            }
          }
          while_break___5: /* CIL Label */ ;
          }
          {
#line 490
          _IO_putc('\n', f);
#line 483
          i ++;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 493
      i = 0;
      {
#line 493
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 493
        if (! (i < fore->w_layer.l_height)) {
#line 493
          goto while_break___6;
        }
#line 495
        p = (char *)(fore->w_mlines + i)->image;
#line 496
        k = fore->w_layer.l_width - 1;
        {
#line 496
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 496
          if (k >= 0) {
#line 496
            if (! ((int )*(p + k) == 32)) {
#line 496
              goto while_break___7;
            }
          } else {
#line 496
            goto while_break___7;
          }
#line 496
          k --;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 498
        j = 0;
        {
#line 498
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 498
          if (! (j <= k)) {
#line 498
            goto while_break___8;
          }
          {
#line 499
          _IO_putc((int )*(p + j), f);
#line 498
          j ++;
          }
        }
        while_break___8: /* CIL Label */ ;
        }
        {
#line 500
        _IO_putc('\n', f);
#line 493
        i ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
#line 502
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
      {
#line 504
      tmp___9 = MakeTermcap(fore->w_aflag);
#line 504
      p = index((char const   *)tmp___9, '=');
      }
#line 504
      if ((unsigned long )p != (unsigned long )((void *)0)) {
        {
#line 506
        p ++;
#line 506
        fputs((char const   */* __restrict  */)p, (FILE */* __restrict  */)f);
#line 507
        _IO_putc('\n', f);
        }
      }
#line 509
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
#line 512
      p = user->u_plop.buf;
#line 513
      i = user->u_plop.len;
      {
#line 513
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 513
        tmp___10 = i;
#line 513
        i --;
#line 513
        if (! (tmp___10 > 0)) {
#line 513
          goto while_break___9;
        }
#line 514
        if ((int )*p == 13) {
#line 514
          if (i == 0) {
            {
#line 515
            _IO_putc('\n', f);
            }
          } else
#line 514
          if ((int )*(p + 1) != 10) {
            {
#line 515
            _IO_putc('\n', f);
            }
          } else {
            {
#line 517
            _IO_putc((int )*p, f);
            }
          }
        } else {
          {
#line 517
          _IO_putc((int )*p, f);
          }
        }
#line 513
        p ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 518
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 521
      fclose(f);
#line 522
      UserReturn(1);
      }
    }
  }
  {
#line 525
  tmp___13 = UserStatus();
  }
#line 525
  if (tmp___13 <= 0) {
    {
#line 526
    Msg(0, (char *)"Cannot open \"%s\"", fn);
    }
  } else
#line 527
  if (display) {
#line 527
    if (! *rc_name) {
      {
#line 531
      if (dump == 0) {
#line 531
        goto case_0___1;
      }
#line 535
      if (dump == 3) {
#line 535
        goto case_3___1;
      }
#line 535
      if (dump == 1) {
#line 535
        goto case_3___1;
      }
#line 540
      if (dump == 2) {
#line 540
        goto case_2___1;
      }
#line 529
      goto switch_break___1;
      case_0___1: /* CIL Label */ 
      {
#line 532
      Msg(0, (char *)"Termcap entry written to \"%s\".", fn);
      }
#line 533
      goto switch_break___1;
      case_3___1: /* CIL Label */ 
      case_1___1: /* CIL Label */ 
#line 536
      if ((int )*mode == 97) {
#line 536
        tmp___12 = "appended";
      } else {
#line 536
        tmp___12 = "written";
      }
      {
#line 536
      Msg(0, (char *)"Screen image %s to \"%s\".", tmp___12, fn);
      }
#line 538
      goto switch_break___1;
      case_2___1: /* CIL Label */ 
      {
#line 541
      Msg(0, (char *)"Copybuffer written to \"%s\".", fn);
      }
      switch_break___1: /* CIL Label */ ;
      }
    }
  }
#line 545
  return;
}
}
#line 554 "/home/pronto/abs/test-suite/screen-4.0.2/fileio.c"
char *ReadFile(char *fn , int *lenp ) 
{ 
  int i ;
  int l ;
  int size ;
  char c ;
  char *bp ;
  char *buf___0 ;
  struct stat stb ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  ssize_t tmp___5 ;
  int tmp___6 ;

  {
  {
#line 563
  while (1) {
    while_continue: /* CIL Label */ ;
#line 563
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 564
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 564
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 565
  i = secopen(fn, 0, 0);
  }
#line 565
  if (i < 0) {
    {
#line 567
    tmp = __errno_location();
#line 567
    Msg(*tmp, (char *)"no %s -- no slurp", fn);
    }
#line 568
    return ((char *)((void *)0));
  }
  {
#line 570
  tmp___1 = fstat(i, & stb);
  }
#line 570
  if (tmp___1) {
    {
#line 572
    tmp___0 = __errno_location();
#line 572
    Msg(*tmp___0, (char *)"no good %s -- no slurp", fn);
#line 573
    close(i);
    }
#line 574
    return ((char *)((void *)0));
  }
  {
#line 576
  size = (int )stb.st_size;
#line 577
  tmp___2 = malloc((size_t )size);
#line 577
  buf___0 = (char *)tmp___2;
  }
#line 577
  if ((unsigned long )buf___0 == (unsigned long )((void *)0)) {
    {
#line 579
    close(i);
#line 580
    Msg(0, strnomem);
    }
#line 581
    return ((char *)((void *)0));
  }
  {
#line 583
  tmp___3 = __errno_location();
#line 583
  *tmp___3 = 0;
#line 584
  l = read(i, (void *)buf___0, (size_t )size);
  }
#line 584
  if (l != size) {
#line 586
    if (l < 0) {
#line 587
      l = 0;
    }
    {
#line 588
    tmp___4 = __errno_location();
#line 588
    Msg(*tmp___4, (char *)"Got only %d bytes from %s", l, fn);
#line 589
    close(i);
    }
  } else {
    {
#line 593
    tmp___5 = read(i, (void *)(& c), (size_t )1);
    }
#line 593
    if (tmp___5 > 0) {
      {
#line 594
      Msg(0, (char *)"Slurped only %d characters (of %d) into buffer - try again",
          l, size);
      }
    } else {
      {
#line 597
      Msg(0, (char *)"Slurped %d characters into buffer", l);
      }
    }
  }
  {
#line 599
  close(i);
#line 600
  *lenp = l;
#line 601
  bp = buf___0;
  }
  {
#line 601
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 601
    tmp___6 = l;
#line 601
    l --;
#line 601
    if (! (tmp___6 > 0)) {
#line 601
      goto while_break___1;
    }
#line 602
    if ((int )*bp == 10) {
#line 602
      if ((unsigned long )bp == (unsigned long )buf___0) {
#line 603
        *bp = (char )'\r';
      } else
#line 602
      if ((int )*(bp + -1) != 13) {
#line 603
        *bp = (char )'\r';
      }
    }
#line 601
    bp ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 604
  return (buf___0);
}
}
#line 607 "/home/pronto/abs/test-suite/screen-4.0.2/fileio.c"
void KillBuffers(void) 
{ 
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char const   *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;

  {
  {
#line 610
  tmp___3 = UserContext();
  }
#line 610
  if (tmp___3 > 0) {
    {
#line 611
    tmp___2 = unlink((char const   *)BufferFile);
    }
#line 611
    if (tmp___2) {
      {
#line 611
      tmp___0 = __errno_location();
#line 611
      tmp___1 = *tmp___0;
      }
    } else {
#line 611
      tmp___1 = 0;
    }
    {
#line 611
    UserReturn(tmp___1);
    }
  }
  {
#line 612
  tmp___4 = __errno_location();
#line 612
  *tmp___4 = UserStatus();
#line 613
  tmp___7 = __errno_location();
  }
#line 613
  if (*tmp___7) {
#line 613
    tmp___6 = "not ";
  } else {
#line 613
    tmp___6 = "";
  }
  {
#line 613
  tmp___8 = __errno_location();
#line 613
  Msg(*tmp___8, (char *)"%s %sremoved", BufferFile, tmp___6);
  }
#line 614
  return;
}
}
#line 622 "/home/pronto/abs/test-suite/screen-4.0.2/fileio.c"
FILE *secfopen(char *name , char *mode ) 
{ 
  FILE *fi ;

  {
  {
#line 632
  while (1) {
    while_continue: /* CIL Label */ ;
#line 632
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 634
  xseteuid(real_uid);
#line 635
  xsetegid(real_gid);
#line 636
  fi = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)mode);
#line 637
  xseteuid(eff_uid);
#line 638
  xsetegid(eff_gid);
  }
#line 639
  return (fi);
}
}
#line 668 "/home/pronto/abs/test-suite/screen-4.0.2/fileio.c"
int secopen(char *name , int flags , int mode ) 
{ 
  int fd ;

  {
  {
#line 680
  while (1) {
    while_continue: /* CIL Label */ ;
#line 680
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 682
  xseteuid(real_uid);
#line 683
  xsetegid(real_gid);
#line 684
  fd = open((char const   *)name, flags, mode);
#line 685
  xseteuid(eff_uid);
#line 686
  xsetegid(eff_gid);
  }
#line 687
  return (fd);
}
}
#line 751 "/home/pronto/abs/test-suite/screen-4.0.2/fileio.c"
int printpipe(struct win *p , char *cmd ) 
{ 
  int pi[2] ;
  int *tmp ;
  int tmp___0 ;
  __pid_t tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;

  {
  {
#line 757
  tmp___0 = pipe((int *)(pi));
  }
#line 757
  if (tmp___0) {
    {
#line 759
    tmp = __errno_location();
#line 759
    WMsg(p, *tmp, (char *)"printing pipe");
    }
#line 760
    return (-1);
  }
  {
#line 762
  tmp___1 = fork();
  }
  {
#line 764
  if (tmp___1 == -1) {
#line 764
    goto case_neg_1;
  }
#line 767
  if (tmp___1 == 0) {
#line 767
    goto case_0;
  }
#line 784
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 765
  tmp___2 = __errno_location();
#line 765
  WMsg(p, *tmp___2, (char *)"printing fork");
  }
#line 766
  return (-1);
  case_0: /* CIL Label */ 
  {
#line 768
  display = p->w_pdisplay;
#line 769
  displays = (struct display *)0;
#line 774
  close(0);
#line 775
  dup(pi[0]);
#line 776
  closeallfiles(0);
#line 777
  tmp___4 = setgid((__gid_t )real_gid);
  }
#line 777
  if (tmp___4) {
    {
#line 778
    tmp___3 = __errno_location();
#line 778
    Panic(*tmp___3, (char *)"printpipe setuid");
    }
  } else {
    {
#line 777
    tmp___5 = setuid((__uid_t )real_uid);
    }
#line 777
    if (tmp___5) {
      {
#line 778
      tmp___3 = __errno_location();
#line 778
      Panic(*tmp___3, (char *)"printpipe setuid");
      }
    }
  }
  {
#line 780
  xsignal(13, (void (*)(int  ))0);
#line 782
  execl("/bin/sh", "sh", "-c", cmd, 0);
#line 783
  tmp___6 = __errno_location();
#line 783
  Panic(*tmp___6, (char *)"/bin/sh");
  }
  switch_default: /* CIL Label */ 
#line 785
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 787
  close(pi[0]);
  }
#line 788
  return (pi[1]);
}
}
#line 791 "/home/pronto/abs/test-suite/screen-4.0.2/fileio.c"
int readpipe(char **cmdv ) 
{ 
  int pi[2] ;
  int *tmp ;
  int tmp___0 ;
  __pid_t tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;

  {
  {
#line 797
  tmp___0 = pipe((int *)(pi));
  }
#line 797
  if (tmp___0) {
    {
#line 799
    tmp = __errno_location();
#line 799
    Msg(*tmp, (char *)"pipe");
    }
#line 800
    return (-1);
  }
  {
#line 802
  tmp___1 = fork();
  }
  {
#line 804
  if (tmp___1 == -1) {
#line 804
    goto case_neg_1;
  }
#line 807
  if (tmp___1 == 0) {
#line 807
    goto case_0;
  }
#line 831
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 805
  tmp___2 = __errno_location();
#line 805
  Msg(*tmp___2, (char *)"fork");
  }
#line 806
  return (-1);
  case_0: /* CIL Label */ 
  {
#line 808
  displays = (struct display *)0;
#line 813
  close(1);
#line 814
  tmp___3 = dup(pi[1]);
  }
#line 814
  if (tmp___3 != 1) {
    {
#line 816
    close(pi[1]);
#line 817
    Panic(0, (char *)"dup");
    }
  }
  {
#line 819
  closeallfiles(1);
#line 820
  tmp___5 = setgid((__gid_t )real_gid);
  }
#line 820
  if (tmp___5) {
    {
#line 822
    close(1);
#line 823
    tmp___4 = __errno_location();
#line 823
    Panic(*tmp___4, (char *)"setuid/setgid");
    }
  } else {
    {
#line 820
    tmp___6 = setuid((__uid_t )real_uid);
    }
#line 820
    if (tmp___6) {
      {
#line 822
      close(1);
#line 823
      tmp___4 = __errno_location();
#line 823
      Panic(*tmp___4, (char *)"setuid/setgid");
      }
    }
  }
  {
#line 826
  xsignal(13, (void (*)(int  ))0);
#line 828
  execvp((char const   *)*cmdv, (char * const  *)cmdv);
#line 829
  close(1);
#line 830
  tmp___7 = __errno_location();
#line 830
  Panic(*tmp___7, *cmdv);
  }
  switch_default: /* CIL Label */ 
#line 832
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 834
  close(pi[1]);
  }
#line 835
  return (pi[0]);
}
}
#line 63 "/home/pronto/abs/test-suite/screen-4.0.2/extern.h"
void WChangeSize(struct win *p , int w , int h ) ;
#line 65
int MFindUsedLine(struct win *p , int ye , int ys ) ;
#line 41 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
int nversion ;
#line 54 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
int Z0width  ;
#line 54 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
int Z1width  ;
#line 57 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static struct win *curr  ;
#line 58 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static int rows  ;
#line 58 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static int cols  ;
#line 60 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
int visual_bell  =    0;
#line 61 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
int use_hardstatus  =    1;
#line 62 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
char *printcmd  =    (char *)0;
#line 63 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
int use_altscreen  =    0;
#line 65 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
unsigned char *blank  ;
#line 66 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
unsigned char *null  ;
#line 68 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
struct mline mline_old  ;
#line 69 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
struct mline mline_blank  ;
#line 70 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
struct mline mline_null  ;
#line 72 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
struct mchar mchar_null  ;
#line 73 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
struct mchar mchar_blank  =    {(unsigned char )' ', (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0};
#line 74 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
struct mchar mchar_so  =    {(unsigned char )' ', (unsigned char )(1 << 4), (unsigned char)0, (unsigned char)0,
    (unsigned char)0};
#line 77 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static char *string_t_string[8]  = 
#line 77
  {      (char *)"NONE",      (char *)"DCS",      (char *)"OSC",      (char *)"APC", 
        (char *)"PM",      (char *)"AKA",      (char *)"GM",      (char *)"STATUS"};
#line 91 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static char *state_t_string[9]  = 
#line 91
  {      (char *)"LIT",      (char *)"ESC",      (char *)"ASTR",      (char *)"STRESC", 
        (char *)"CSI",      (char *)"PRIN",      (char *)"PRINESC",      (char *)"PRINCSI", 
        (char *)"PRIN4"};
#line 104
static int Special(int c ) ;
#line 105
static void DoESC(int c , int intermediate ) ;
#line 106
static void DoCSI(int c , int intermediate ) ;
#line 107
static void StringStart(enum string_t type ) ;
#line 108
static void StringChar(int c ) ;
#line 109
static int StringEnd(void) ;
#line 110
static void PrintStart(void) ;
#line 111
static void PrintChar(int c ) ;
#line 112
static void PrintFlush(void) ;
#line 114
static void DesignateCharset(int c , int n ) ;
#line 115
static void MapCharset(int n ) ;
#line 116
static void MapCharsetR(int n ) ;
#line 118
static void SaveCursor(void) ;
#line 119
static void RestoreCursor(void) ;
#line 120
static void BackSpace(void) ;
#line 121
static void Return(void) ;
#line 122
static void LineFeed(int out_mode ) ;
#line 123
static void ReverseLineFeed(void) ;
#line 124
static void InsertChar(int n ) ;
#line 125
static void DeleteChar(int n ) ;
#line 126
static void DeleteLine(int n ) ;
#line 127
static void InsertLine(int n ) ;
#line 128
static void Scroll(char *cp , int cnt1 , int cnt2 , char *tmp ) ;
#line 129
static void ForwardTab(void) ;
#line 130
static void BackwardTab(void) ;
#line 131
static void ClearScreen(void) ;
#line 132
static void ClearFromBOS(void) ;
#line 133
static void ClearToEOS(void) ;
#line 134
static void ClearLineRegion(int from , int to ) ;
#line 135
static void CursorRight(int n ) ;
#line 136
static void CursorUp(int n ) ;
#line 137
static void CursorDown(int n ) ;
#line 138
static void CursorLeft(int n ) ;
#line 139
static void ASetMode(int on ) ;
#line 140
static void SelectRendition(void) ;
#line 141
static void RestorePosRendition(void) ;
#line 142
static void FillWithEs(void) ;
#line 143
static void FindAKA(void) ;
#line 144
static void Report(char *fmt , int n1 , int n2 ) ;
#line 145
static void ScrollRegion(int n ) ;
#line 147
static void WAddLineToHist(struct win *wp , struct mline *ml ) ;
#line 149
static void WLogString(struct win *p , char *buf___0 , int len ) ;
#line 150
static void WReverseVideo(struct win *p , int on ) ;
#line 151
static int WindowChangedCheck(char *s , int what , int *hp ) ;
#line 152
static void MFixLine(struct win *p , int y , struct mchar *mc ) ;
#line 153
static void MScrollH(struct win *p , int n , int y , int xs , int xe , int bce ) ;
#line 154
static void MScrollV(struct win *p , int n , int ys , int ye , int bce ) ;
#line 155
static void MClearArea(struct win *p , int xs , int ys , int xe , int ye , int bce ) ;
#line 156
static void MInsChar(struct win *p , struct mchar *c , int x , int y ) ;
#line 157
static void MPutChar(struct win *p , struct mchar *c , int x , int y ) ;
#line 158
static void MPutStr(struct win *p , char *s , int n , struct mchar *r , int x , int y ) ;
#line 159
static void MWrapChar(struct win *p , struct mchar *c , int y , int top , int bot ,
                      int ins ) ;
#line 161
static void MBceLine(struct win *p , int y , int xs , int xe , int bce ) ;
#line 170 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
void ResetAnsiState(struct win *p ) 
{ 


  {
#line 174
  p->w_state = (enum state_t )0;
#line 175
  p->w_StringType = (enum string_t )0;
#line 176
  return;
}
}
#line 178 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
void ResetWindow(struct win *p ) 
{ 
  register int i ;
  int tmp ;

  {
  {
#line 184
  p->w_wrap = nwin_default.wrap;
#line 185
  p->w_origin = 0;
#line 186
  p->w_insert = 0;
#line 187
  p->w_revvid = 0;
#line 188
  p->w_mouse = 0;
#line 189
  p->w_curinv = 0;
#line 190
  p->w_curvvis = 0;
#line 191
  p->w_autolf = 0;
#line 192
  p->w_keypad = 0;
#line 193
  p->w_cursorkeys = 0;
#line 194
  p->w_top = 0;
#line 195
  p->w_bot = p->w_layer.l_height - 1;
#line 196
  p->w_saved = 0;
#line 197
  tmp = 0;
#line 197
  p->w_layer.l_y = tmp;
#line 197
  p->w_layer.l_x = tmp;
#line 198
  p->w_state = (enum state_t )0;
#line 199
  p->w_StringType = (enum string_t )0;
#line 200
  bzero((void *)p->w_tabs, (size_t )p->w_layer.l_width);
#line 201
  i = 8;
  }
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    if (! (i < p->w_layer.l_width)) {
#line 201
      goto while_break;
    }
#line 202
    *(p->w_tabs + i) = (char)1;
#line 201
    i += 8;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 203
  p->w_rend = mchar_null;
#line 205
  ResetCharsets(p);
#line 208
  p->w_bce = nwin_default.bce;
  }
#line 210
  return;
}
}
#line 213 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
int GetAnsiStatus(struct win *w , char *buf___0 ) 
{ 
  char *p ;
  size_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 218
  p = buf___0;
#line 220
  if ((unsigned int )w->w_state == 0U) {
#line 221
    return (0);
  }
  {
#line 223
  strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)state_t_string[w->w_state]);
#line 224
  tmp = strlen((char const   *)p);
#line 224
  p += tmp;
  }
#line 225
  if (w->w_intermediate) {
#line 227
    tmp___0 = p;
#line 227
    p ++;
#line 227
    *tmp___0 = (char )'-';
#line 228
    if (w->w_intermediate > 255) {
      {
#line 229
      tmp___1 = AddXChar(p, w->w_intermediate >> 8);
#line 229
      p += tmp___1;
      }
    }
    {
#line 230
    tmp___2 = AddXChar(p, w->w_intermediate & 255);
#line 230
    p += tmp___2;
#line 231
    *p = (char)0;
    }
  }
#line 233
  if ((unsigned int )w->w_state == 2U) {
    {
#line 234
    sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"-%s", string_t_string[w->w_StringType]);
    }
  } else
#line 233
  if ((unsigned int )w->w_state == 3U) {
    {
#line 234
    sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"-%s", string_t_string[w->w_StringType]);
    }
  }
  {
#line 235
  tmp___3 = strlen((char const   *)p);
#line 235
  p += tmp___3;
  }
#line 236
  return ((int )(p - buf___0));
}
}
#line 242 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
void ResetCharsets(struct win *p ) 
{ 


  {
  {
#line 246
  p->w_gr = nwin_default.gr;
#line 247
  p->w_c1 = nwin_default.c1;
#line 248
  SetCharsets(p, (char *)"BBBB02");
  }
#line 249
  if (nwin_default.charset) {
    {
#line 250
    SetCharsets(p, nwin_default.charset);
    }
  }
  {
#line 252
  ResetEncoding(p);
  }
#line 254
  return;
}
}
#line 256 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
void SetCharsets(struct win *p , char *s ) 
{ 
  int i ;
  char *tmp ;

  {
#line 263
  i = 0;
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 263
    if (i < 4) {
#line 263
      if (! *s) {
#line 263
        goto while_break;
      }
    } else {
#line 263
      goto while_break;
    }
#line 264
    if ((int )*s != 46) {
#line 265
      if ((int )*s == 66) {
#line 265
        p->w_charsets[i] = 0;
      } else {
#line 265
        p->w_charsets[i] = (int )*s;
      }
    }
#line 263
    i ++;
#line 263
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 266
  if (*s) {
#line 266
    tmp = s;
#line 266
    s ++;
#line 266
    if ((int )*tmp != 46) {
#line 267
      p->w_Charset = (int )*(s + -1) - 48;
    }
  }
#line 268
  if (*s) {
#line 268
    if ((int )*s != 46) {
#line 269
      p->w_CharsetR = (int )*s - 48;
    }
  }
#line 270
  p->w_ss = 0;
#line 271
  p->w_FontL = (char )p->w_charsets[p->w_Charset];
#line 272
  p->w_FontR = (char )p->w_charsets[p->w_CharsetR];
#line 273
  return;
}
}
#line 287 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
void WriteString(struct win *wp , char *buf___0 , int len ) 
{ 
  register int c ;
  register int font ;
  struct canvas *cv ;
  char *tmp ;
  register int currx ;
  char *imp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct mchar mc ;
  struct mchar *mcp ;
  int tmp___4 ;
  int ox ;
  int oy ;
  struct mchar omc ;
  int tmp___5 ;
  unsigned char tmp___6 ;
  unsigned char tmp___7 ;
  int t ;
  int tmp___8 ;
  unsigned char tmp___9 ;
  int tmp___10 ;

  {
#line 299
  if (! len) {
#line 300
    return;
  }
#line 301
  if (wp->w_log) {
    {
#line 302
    WLogString(wp, buf___0, len);
    }
  }
#line 305
  curr = wp;
#line 306
  cols = curr->w_layer.l_width;
#line 307
  rows = curr->w_layer.l_height;
#line 309
  if (curr->w_silence) {
    {
#line 310
    SetTimeout(& curr->w_silenceev, curr->w_silencewait * 1000);
    }
  }
#line 312
  if (curr->w_monitor == 1) {
    {
#line 314
    while (1) {
      while_continue: /* CIL Label */ ;
#line 314
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 315
    curr->w_monitor = 2;
  }
  {
#line 318
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 320
    tmp = buf___0;
#line 320
    buf___0 ++;
#line 320
    c = (int )((unsigned char )*tmp);
#line 323
    if (! curr->w_mbcs) {
#line 325
      curr->w_rend.font = (unsigned char )curr->w_FontL;
    }
#line 329
    if ((unsigned int )curr->w_state == 0U) {
#line 329
      if (curr->w_layer.l_encoding != 8) {
#line 329
        if (curr->w_rend.font) {
#line 329
          if (! (((int )curr->w_rend.font & 96) == 0)) {
#line 329
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
#line 329
        if ((int )curr->w_rend.font != 73) {
#line 329
          if (! curr->w_mbcs) {
#line 329
            if ((int )curr->w_rend.font != 60) {
#line 329
              if (c >= 32) {
#line 329
                if (c != 127) {
#line 329
                  if ((c & 128) == 0) {
#line 329
                    goto _L___0;
                  } else
#line 329
                  if (c >= 160) {
#line 329
                    goto _L___1;
                  } else
#line 329
                  if (! curr->w_c1) {
                    _L___1: /* CIL Label */ 
#line 329
                    if (! curr->w_gr) {
                      _L___0: /* CIL Label */ 
#line 329
                      if (! curr->w_ss) {
#line 329
                        if (! curr->w_insert) {
#line 329
                          if (curr->w_layer.l_x < cols - 1) {
#line 346
                            currx = curr->w_layer.l_x;
#line 347
                            imp = buf___0 - 1;
                            {
#line 349
                            while (1) {
                              while_continue___1: /* CIL Label */ ;
#line 349
                              if (! (currx < cols - 1)) {
#line 349
                                goto while_break___1;
                              }
#line 351
                              currx ++;
#line 352
                              len --;
#line 352
                              if (len == 0) {
#line 353
                                goto while_break___1;
                              }
#line 354
                              tmp___0 = buf___0;
#line 354
                              buf___0 ++;
#line 354
                              c = (int )((unsigned char )*tmp___0);
#line 355
                              if (c < 32) {
#line 356
                                goto while_break___1;
                              } else
#line 355
                              if (c == 127) {
#line 356
                                goto while_break___1;
                              } else
#line 355
                              if (c & 128) {
#line 355
                                if (c < 160) {
#line 355
                                  if (curr->w_c1) {
#line 356
                                    goto while_break___1;
                                  } else {
#line 355
                                    goto _L;
                                  }
                                } else
                                _L: /* CIL Label */ 
#line 355
                                if (curr->w_gr) {
#line 356
                                  goto while_break___1;
                                }
                              }
                            }
                            while_break___1: /* CIL Label */ ;
                            }
#line 358
                            currx -= curr->w_layer.l_x;
#line 359
                            if (currx > 0) {
                              {
#line 361
                              MPutStr(curr, imp, currx, & curr->w_rend, curr->w_layer.l_x,
                                      curr->w_layer.l_y);
#line 362
                              LPutStr(& curr->w_layer, imp, currx, & curr->w_rend,
                                      curr->w_layer.l_x, curr->w_layer.l_y);
#line 363
                              curr->w_layer.l_x += currx;
                              }
                            }
#line 365
                            if (len == 0) {
#line 366
                              goto while_break___0;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 371
    if (curr->w_layer.l_encoding == 8) {
      {
#line 373
      c = FromUtf8(c, & curr->w_decodestate);
      }
#line 374
      if (c == -1) {
#line 375
        goto __Cont;
      }
#line 376
      if (c == -2) {
#line 378
        c = 65533;
#line 380
        buf___0 --;
#line 381
        len ++;
      }
#line 383
      if (c > 255) {
        {
#line 384
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 384
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
    tryagain: 
    {
#line 391
    if ((unsigned int )curr->w_state == 5U) {
#line 391
      goto case_5;
    }
#line 401
    if ((unsigned int )curr->w_state == 6U) {
#line 401
      goto case_6;
    }
#line 413
    if ((unsigned int )curr->w_state == 7U) {
#line 413
      goto case_7;
    }
#line 426
    if ((unsigned int )curr->w_state == 8U) {
#line 426
      goto case_8;
    }
#line 447
    if ((unsigned int )curr->w_state == 2U) {
#line 447
      goto case_2;
    }
#line 465
    if ((unsigned int )curr->w_state == 3U) {
#line 465
      goto case_3;
    }
#line 497
    if ((unsigned int )curr->w_state == 1U) {
#line 497
      goto case_1;
    }
#line 557
    if ((unsigned int )curr->w_state == 4U) {
#line 557
      goto case_4;
    }
#line 595
    goto switch_default___6;
    case_5: /* CIL Label */ 
    {
#line 394
    if (c == 27) {
#line 394
      goto case_27;
    }
#line 397
    goto switch_default;
    case_27: /* CIL Label */ 
#line 395
    curr->w_state = (enum state_t )6;
#line 396
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 398
    PrintChar(c);
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 400
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 404
    if (c == 91) {
#line 404
      goto case_91;
    }
#line 407
    goto switch_default___0;
    case_91: /* CIL Label */ 
#line 405
    curr->w_state = (enum state_t )7;
#line 406
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
    {
#line 408
    PrintChar('\033');
#line 409
    PrintChar(c);
#line 410
    curr->w_state = (enum state_t )5;
    }
    switch_break___1: /* CIL Label */ ;
    }
#line 412
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 416
    if (c == 52) {
#line 416
      goto case_52;
    }
#line 419
    goto switch_default___1;
    case_52: /* CIL Label */ 
#line 417
    curr->w_state = (enum state_t )8;
#line 418
    goto switch_break___2;
    switch_default___1: /* CIL Label */ 
    {
#line 420
    PrintChar('\033');
#line 421
    PrintChar('[');
#line 422
    PrintChar(c);
#line 423
    curr->w_state = (enum state_t )5;
    }
    switch_break___2: /* CIL Label */ ;
    }
#line 425
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 429
    if (c == 105) {
#line 429
      goto case_105;
    }
#line 439
    goto switch_default___2;
    case_105: /* CIL Label */ 
    {
#line 430
    curr->w_state = (enum state_t )0;
#line 431
    PrintFlush();
    }
#line 432
    if (curr->w_pdisplay) {
#line 432
      if ((curr->w_pdisplay)->d_printfd >= 0) {
        {
#line 434
        close((curr->w_pdisplay)->d_printfd);
#line 435
        (curr->w_pdisplay)->d_printfd = -1;
        }
      }
    }
#line 437
    curr->w_pdisplay = (struct display *)0;
#line 438
    goto switch_break___3;
    switch_default___2: /* CIL Label */ 
    {
#line 440
    PrintChar('\033');
#line 441
    PrintChar('[');
#line 442
    PrintChar('4');
#line 443
    PrintChar(c);
#line 444
    curr->w_state = (enum state_t )5;
    }
    switch_break___3: /* CIL Label */ ;
    }
#line 446
    goto switch_break;
    case_2: /* CIL Label */ 
#line 448
    if (c == 0) {
#line 449
      goto switch_break;
    }
#line 450
    if (c == 27) {
#line 452
      curr->w_state = (enum state_t )3;
#line 453
      goto switch_break;
    }
#line 457
    if ((unsigned int )curr->w_StringType == 2U) {
#line 457
      if (c < 32) {
#line 457
        if (! (c != 5)) {
#line 457
          goto _L___4;
        }
      } else {
#line 457
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 458
    if (! curr->w_c1) {
      {
#line 460
      StringChar(c);
      }
#line 461
      goto switch_break;
    } else
#line 458
    if (c != 156) {
      {
#line 460
      StringChar(c);
      }
#line 461
      goto switch_break;
    }
#line 463
    c = '\\';
    case_3: /* CIL Label */ 
    {
#line 468
    if (c == 92) {
#line 468
      goto case_92;
    }
#line 487
    if (c == 27) {
#line 487
      goto case_27___0;
    }
#line 490
    goto switch_default___3;
    case_92: /* CIL Label */ 
    {
#line 469
    tmp___1 = StringEnd();
    }
#line 469
    if (tmp___1 == 0) {
#line 470
      goto switch_break___4;
    } else
#line 469
    if (len <= 1) {
#line 470
      goto switch_break___4;
    }
#line 472
    cv = curr->w_layer.l_cvlist;
    {
#line 472
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 472
      if (! cv) {
#line 472
        goto while_break___3;
      }
#line 474
      display = cv->c_display;
#line 475
      if (display->d_status == 1) {
#line 476
        goto while_break___3;
      }
#line 472
      cv = cv->c_lnext;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 478
    if (cv) {
#line 480
      if (len > 4097) {
#line 481
        len = 4097;
      }
      {
#line 482
      curr->w_outlen = len - 1;
#line 483
      bcopy((void const   *)buf___0, (void *)(curr->w_outbuf), (size_t )(len - 1));
      }
#line 484
      return;
    }
#line 486
    goto switch_break___4;
    case_27___0: /* CIL Label */ 
    {
#line 488
    StringChar('\033');
    }
#line 489
    goto switch_break___4;
    switch_default___3: /* CIL Label */ 
    {
#line 491
    curr->w_state = (enum state_t )2;
#line 492
    StringChar('\033');
#line 493
    StringChar(c);
    }
#line 494
    goto switch_break___4;
    switch_break___4: /* CIL Label */ ;
    }
#line 496
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 500
    if (c == 91) {
#line 500
      goto case_91___0;
    }
#line 506
    if (c == 93) {
#line 506
      goto case_93;
    }
#line 509
    if (c == 95) {
#line 509
      goto case_95;
    }
#line 512
    if (c == 80) {
#line 512
      goto case_80;
    }
#line 515
    if (c == 94) {
#line 515
      goto case_94;
    }
#line 518
    if (c == 33) {
#line 518
      goto case_33;
    }
#line 522
    if (c == 107) {
#line 522
      goto case_107;
    }
#line 522
    if (c == 34) {
#line 522
      goto case_107;
    }
#line 525
    goto switch_default___4;
    case_91___0: /* CIL Label */ 
    {
#line 501
    curr->w_NumArgs = 0;
#line 502
    curr->w_intermediate = 0;
#line 503
    bzero((void *)((char *)(curr->w_args)), (size_t )(64UL * sizeof(int )));
#line 504
    curr->w_state = (enum state_t )4;
    }
#line 505
    goto switch_break___5;
    case_93: /* CIL Label */ 
    {
#line 507
    StringStart((enum string_t )2);
    }
#line 508
    goto switch_break___5;
    case_95: /* CIL Label */ 
    {
#line 510
    StringStart((enum string_t )3);
    }
#line 511
    goto switch_break___5;
    case_80: /* CIL Label */ 
    {
#line 513
    StringStart((enum string_t )1);
    }
#line 514
    goto switch_break___5;
    case_94: /* CIL Label */ 
    {
#line 516
    StringStart((enum string_t )4);
    }
#line 517
    goto switch_break___5;
    case_33: /* CIL Label */ 
    {
#line 519
    StringStart((enum string_t )6);
    }
#line 520
    goto switch_break___5;
    case_107: /* CIL Label */ 
    case_34: /* CIL Label */ 
    {
#line 523
    StringStart((enum string_t )5);
    }
#line 524
    goto switch_break___5;
    switch_default___4: /* CIL Label */ 
    {
#line 526
    tmp___2 = Special(c);
    }
#line 526
    if (tmp___2) {
#line 528
      curr->w_state = (enum state_t )0;
#line 529
      goto switch_break___5;
    }
    {
#line 531
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 531
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 532
    if (c >= 32) {
#line 532
      if (c <= 47) {
#line 534
        if (curr->w_intermediate) {
#line 537
          if (curr->w_intermediate == 36) {
#line 538
            c |= 36 << 8;
          } else {
#line 541
            c = -1;
          }
        }
#line 543
        curr->w_intermediate = c;
      } else {
#line 532
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 545
    if (c >= 48) {
#line 545
      if (c <= 126) {
        {
#line 547
        DoESC(c, curr->w_intermediate);
#line 548
        curr->w_state = (enum state_t )0;
        }
      } else {
#line 552
        curr->w_state = (enum state_t )0;
#line 553
        goto tryagain;
      }
    } else {
#line 552
      curr->w_state = (enum state_t )0;
#line 553
      goto tryagain;
    }
    switch_break___5: /* CIL Label */ ;
    }
#line 556
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 561
    if (c == 57) {
#line 561
      goto case_57;
    }
#line 561
    if (c == 56) {
#line 561
      goto case_57;
    }
#line 561
    if (c == 55) {
#line 561
      goto case_57;
    }
#line 561
    if (c == 54) {
#line 561
      goto case_57;
    }
#line 561
    if (c == 53) {
#line 561
      goto case_57;
    }
#line 561
    if (c == 52) {
#line 561
      goto case_57;
    }
#line 561
    if (c == 51) {
#line 561
      goto case_57;
    }
#line 561
    if (c == 50) {
#line 561
      goto case_57;
    }
#line 561
    if (c == 49) {
#line 561
      goto case_57;
    }
#line 561
    if (c == 48) {
#line 561
      goto case_57;
    }
#line 570
    if (c == 58) {
#line 570
      goto case_58;
    }
#line 570
    if (c == 59) {
#line 570
      goto case_58;
    }
#line 574
    goto switch_default___5;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52___0: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
#line 562
    if (curr->w_NumArgs < 64) {
#line 564
      if (curr->w_args[curr->w_NumArgs] < 100000000) {
#line 565
        curr->w_args[curr->w_NumArgs] = 10 * curr->w_args[curr->w_NumArgs] + (c - 48);
      }
    }
#line 568
    goto switch_break___6;
    case_58: /* CIL Label */ 
    case_59: /* CIL Label */ 
#line 571
    if (curr->w_NumArgs < 64) {
#line 572
      (curr->w_NumArgs) ++;
    }
#line 573
    goto switch_break___6;
    switch_default___5: /* CIL Label */ 
    {
#line 575
    tmp___3 = Special(c);
    }
#line 575
    if (tmp___3) {
#line 576
      goto switch_break___6;
    }
#line 577
    if (c >= 64) {
#line 577
      if (c <= 126) {
#line 579
        if (curr->w_NumArgs < 64) {
#line 580
          (curr->w_NumArgs) ++;
        }
        {
#line 581
        DoCSI(c, curr->w_intermediate);
        }
#line 582
        if ((unsigned int )curr->w_state != 5U) {
#line 583
          curr->w_state = (enum state_t )0;
        }
      } else {
#line 577
        goto _L___8;
      }
    } else
    _L___8: /* CIL Label */ 
#line 585
    if (c >= 32) {
#line 585
      if (c <= 47) {
#line 585
        goto _L___6;
      } else {
#line 585
        goto _L___7;
      }
    } else
    _L___7: /* CIL Label */ 
#line 585
    if (c >= 60) {
#line 585
      if (c <= 63) {
        _L___6: /* CIL Label */ 
#line 586
        if (curr->w_intermediate) {
#line 586
          curr->w_intermediate = -1;
        } else {
#line 586
          curr->w_intermediate = c;
        }
      } else {
#line 589
        curr->w_state = (enum state_t )0;
#line 590
        goto tryagain;
      }
    } else {
#line 589
      curr->w_state = (enum state_t )0;
#line 590
      goto tryagain;
    }
    switch_break___6: /* CIL Label */ ;
    }
#line 593
    goto switch_break;
    switch_default___6: /* CIL Label */ 
#line 597
    if (curr->w_mbcs) {
#line 598
      if (c <= 32) {
#line 599
        curr->w_mbcs = 0;
      } else
#line 598
      if (c == 127) {
#line 599
        curr->w_mbcs = 0;
      } else
#line 598
      if (c >= 128) {
#line 598
        if (c < 160) {
#line 598
          if (curr->w_c1) {
#line 599
            curr->w_mbcs = 0;
          }
        }
      }
    }
#line 601
    if (c < 32) {
#line 603
      if (c == 27) {
#line 605
        curr->w_intermediate = 0;
#line 606
        curr->w_state = (enum state_t )1;
#line 607
        if (curr->w_autoaka < 0) {
#line 608
          curr->w_autoaka = 0;
        }
      } else {
        {
#line 611
        Special(c);
        }
      }
#line 612
      goto switch_break;
    }
#line 614
    if (c >= 128) {
#line 614
      if (c < 160) {
#line 614
        if (curr->w_c1) {
#line 616
          if (((int )curr->w_FontR & 240) != 32) {
#line 616
            goto _L___9;
          } else
#line 616
          if (curr->w_layer.l_encoding == 8) {
            _L___9: /* CIL Label */ 
            {
#line 630
            if (c == 143) {
#line 630
              goto case_143;
            }
#line 630
            if (c == 142) {
#line 630
              goto case_143;
            }
#line 630
            if (c == 141) {
#line 630
              goto case_143;
            }
#line 630
            if (c == 136) {
#line 630
              goto case_143;
            }
#line 630
            if (c == 133) {
#line 630
              goto case_143;
            }
#line 630
            if (c == 132) {
#line 630
              goto case_143;
            }
#line 633
            if (c == 155) {
#line 633
              goto case_155;
            }
#line 641
            if (c == 144) {
#line 641
              goto case_144;
            }
#line 644
            goto switch_default___7;
            case_143: /* CIL Label */ 
            case_142: /* CIL Label */ 
            case_141: /* CIL Label */ 
            case_136: /* CIL Label */ 
            case_133: /* CIL Label */ 
            case_132: /* CIL Label */ 
            {
#line 631
            DoESC(c ^ 192, 0);
            }
#line 632
            goto switch_break___7;
            case_155: /* CIL Label */ 
#line 634
            if (curr->w_autoaka < 0) {
#line 635
              curr->w_autoaka = 0;
            }
            {
#line 636
            curr->w_NumArgs = 0;
#line 637
            curr->w_intermediate = 0;
#line 638
            bzero((void *)((char *)(curr->w_args)), (size_t )(64UL * sizeof(int )));
#line 639
            curr->w_state = (enum state_t )4;
            }
#line 640
            goto switch_break___7;
            case_144: /* CIL Label */ 
            {
#line 642
            StringStart((enum string_t )1);
            }
#line 643
            goto switch_break___7;
            switch_default___7: /* CIL Label */ 
#line 645
            goto switch_break___7;
            switch_break___7: /* CIL Label */ ;
            }
#line 647
            goto switch_break;
          }
        }
      }
    }
#line 652
    if (! curr->w_mbcs) {
#line 655
      if (c < 128) {
#line 656
        curr->w_rend.font = (unsigned char )curr->w_FontL;
      } else
#line 655
      if (curr->w_gr == 0) {
#line 656
        curr->w_rend.font = (unsigned char )curr->w_FontL;
      } else
#line 658
      if (curr->w_gr == 2) {
#line 658
        if (! curr->w_ss) {
#line 659
          curr->w_rend.font = (unsigned char )curr->w_FontE;
        } else {
#line 662
          curr->w_rend.font = (unsigned char )curr->w_FontR;
        }
      } else {
#line 662
        curr->w_rend.font = (unsigned char )curr->w_FontR;
      }
    }
#line 667
    if (curr->w_layer.l_encoding == 8) {
#line 669
      if ((int )curr->w_rend.font == 48) {
        {
#line 673
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 673
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
        {
#line 674
        mc.image = (unsigned char )c;
#line 675
        mc.mbcs = (unsigned char)0;
#line 676
        mc.font = (unsigned char )'0';
#line 677
        mcp = recode_mchar(& mc, 0, 8);
        }
        {
#line 678
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 678
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 679
        c = (int )mcp->image | ((int )mcp->font << 8);
      }
#line 681
      curr->w_rend.font = (unsigned char)0;
    }
#line 684
    if (curr->w_layer.l_encoding == 8) {
#line 684
      if (c >= 4352) {
        {
#line 684
        tmp___4 = utf8_isdouble(c);
        }
#line 684
        if (tmp___4) {
#line 685
          curr->w_mbcs = 255;
        }
      }
    }
#line 687
    if (curr->w_layer.l_encoding == 8) {
#line 687
      if (c >= 768) {
        {
#line 687
        tmp___5 = utf8_iscomb(c);
        }
#line 687
        if (tmp___5) {
#line 692
          ox = curr->w_layer.l_x - 1;
#line 693
          oy = curr->w_layer.l_y;
#line 694
          if (ox < 0) {
#line 696
            ox = curr->w_layer.l_width - 1;
#line 697
            oy --;
          }
#line 699
          if (oy < 0) {
#line 700
            oy = 0;
          }
          {
#line 701
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 701
            omc.image = *((curr->w_mlines + oy)->image + ox);
#line 701
            omc.attr = *((curr->w_mlines + oy)->attr + ox);
#line 701
            omc.font = *((curr->w_mlines + oy)->font + ox);
#line 701
            omc.color = *((curr->w_mlines + oy)->color + ox);
#line 701
            omc.mbcs = (unsigned char)0;
#line 701
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
#line 702
          if ((int )omc.image == 255) {
#line 702
            if ((int )omc.font == 255) {
#line 704
              ox --;
#line 705
              if (ox >= 0) {
                {
#line 707
                while (1) {
                  while_continue___8: /* CIL Label */ ;
#line 707
                  omc.image = *((curr->w_mlines + oy)->image + ox);
#line 707
                  omc.attr = *((curr->w_mlines + oy)->attr + ox);
#line 707
                  omc.font = *((curr->w_mlines + oy)->font + ox);
#line 707
                  omc.color = *((curr->w_mlines + oy)->color + ox);
#line 707
                  omc.mbcs = (unsigned char)0;
#line 707
                  goto while_break___8;
                }
                while_break___8: /* CIL Label */ ;
                }
#line 708
                omc.mbcs = (unsigned char)255;
              }
            }
          }
#line 711
          if (ox >= 0) {
            {
#line 713
            utf8_handle_comb(c, & omc);
#line 714
            MFixLine(curr, oy, & omc);
            }
            {
#line 715
            while (1) {
              while_continue___9: /* CIL Label */ ;
#line 715
              *((curr->w_mlines + oy)->image + ox) = omc.image;
#line 715
              *((curr->w_mlines + oy)->attr + ox) = omc.attr;
#line 715
              *((curr->w_mlines + oy)->font + ox) = omc.font;
#line 715
              *((curr->w_mlines + oy)->color + ox) = omc.color;
#line 715
              goto while_break___9;
            }
            while_break___9: /* CIL Label */ ;
            }
            {
#line 716
            LPutChar(& curr->w_layer, & omc, ox, oy);
#line 717
            LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
            }
          }
#line 719
          goto switch_break;
        }
      }
    }
#line 721
    font = (int )curr->w_rend.font;
#line 725
    if (font == 73) {
#line 725
      if (curr->w_layer.l_encoding == 2) {
#line 725
        if (curr->w_mbcs == 0) {
          {
#line 728
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 728
            goto while_break___10;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 729
          if (129 <= c) {
#line 729
            if (c <= 159) {
#line 729
              goto _L___10;
            } else {
#line 729
              goto _L___11;
            }
          } else
          _L___11: /* CIL Label */ 
#line 729
          if (224 <= c) {
#line 729
            if (c <= 239) {
              _L___10: /* CIL Label */ 
              {
#line 731
              while (1) {
                while_continue___11: /* CIL Label */ ;
#line 731
                goto while_break___11;
              }
              while_break___11: /* CIL Label */ ;
              }
#line 732
              curr->w_mbcs = c;
#line 733
              goto switch_break;
            }
          }
        }
      }
    }
#line 737
    if (font == 25) {
#line 737
      if (c == 128) {
#line 737
        if (! curr->w_mbcs) {
#line 738
          tmp___6 = (unsigned char)0;
#line 738
          curr->w_rend.font = tmp___6;
#line 738
          font = (int )tmp___6;
        }
      }
    }
#line 739
    if (font) {
#line 739
      if ((font & 96) == 0) {
#line 739
        if (c == 32) {
#line 740
          tmp___7 = (unsigned char)0;
#line 740
          curr->w_rend.font = tmp___7;
#line 740
          font = (int )tmp___7;
        }
      }
    }
#line 741
    if (font) {
#line 741
      if ((font & 96) == 0) {
#line 741
        goto _L___12;
      } else {
#line 741
        goto _L___13;
      }
    } else
    _L___13: /* CIL Label */ 
#line 741
    if (curr->w_mbcs) {
      _L___12: /* CIL Label */ 
#line 743
      t = c;
#line 744
      if (curr->w_mbcs == 0) {
#line 746
        curr->w_mbcs = c;
#line 747
        goto switch_break;
      }
#line 749
      if (curr->w_layer.l_x == cols - 1) {
#line 751
        if (curr->w_wrap) {
#line 751
          tmp___8 = 1;
        } else {
#line 751
          tmp___8 = -1;
        }
#line 751
        curr->w_layer.l_x += tmp___8;
        {
#line 752
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 752
          goto while_break___12;
        }
        while_break___12: /* CIL Label */ ;
        }
      }
#line 755
      if (curr->w_layer.l_encoding != 8) {
#line 758
        c = curr->w_mbcs;
#line 760
        if (font == 73) {
#line 760
          if (curr->w_layer.l_encoding == 2) {
            {
#line 762
            while (1) {
              while_continue___13: /* CIL Label */ ;
#line 762
              goto while_break___13;
            }
            while_break___13: /* CIL Label */ ;
            }
#line 773
            if (64 <= t) {
#line 773
              if (t <= 252) {
#line 773
                if (t != 127) {
#line 775
                  if (c <= 159) {
#line 775
                    c = (c - 129) * 2 + 33;
                  } else {
#line 776
                    c = (c - 193) * 2 + 33;
                  }
#line 777
                  if (t <= 126) {
#line 777
                    t -= 31;
                  } else
#line 778
                  if (t <= 158) {
#line 778
                    t -= 32;
                  } else {
#line 779
                    t -= 126;
#line 779
                    c ++;
                  }
#line 780
                  curr->w_rend.font = (unsigned char)2;
                } else {
#line 785
                  c = t;
#line 786
                  t = 0;
                }
              } else {
#line 785
                c = t;
#line 786
                t = 0;
              }
            } else {
#line 785
              c = t;
#line 786
              t = 0;
            }
            {
#line 788
            while (1) {
              while_continue___14: /* CIL Label */ ;
#line 788
              goto while_break___14;
            }
            while_break___14: /* CIL Label */ ;
            }
          }
        }
#line 791
        if (t) {
#line 791
          if (curr->w_gr) {
#line 791
            if (font != 24) {
#line 791
              if (font != 25) {
#line 793
                t &= 127;
#line 794
                if (t < 32) {
#line 795
                  goto tryagain;
                }
              }
            }
          }
        }
#line 797
        if (t == 127) {
#line 798
          goto switch_break;
        }
#line 799
        curr->w_mbcs = t;
      }
    }
#line 803
    if (font == 60) {
#line 803
      if (c >= 32) {
#line 805
        tmp___9 = (unsigned char)0;
#line 805
        curr->w_rend.font = tmp___9;
#line 805
        font = (int )tmp___9;
#line 806
        c |= 128;
      } else {
#line 803
        goto _L___14;
      }
    } else
    _L___14: /* CIL Label */ 
#line 809
    if (curr->w_gr) {
#line 809
      if (curr->w_layer.l_encoding != 8) {
#line 815
        if (c == 128) {
#line 815
          if (font == 0) {
#line 815
            if (curr->w_layer.l_encoding == 20) {
#line 816
              c = 164;
            } else {
#line 818
              c &= 127;
            }
          } else {
#line 818
            c &= 127;
          }
        } else {
#line 818
          c &= 127;
        }
#line 819
        if (c < 32) {
#line 819
          if (font != 25) {
#line 820
            goto tryagain;
          }
        }
      }
    }
#line 828
    if (c == 127) {
#line 829
      goto switch_break;
    }
#line 830
    curr->w_rend.image = (unsigned char )c;
#line 832
    if (curr->w_layer.l_encoding == 8) {
#line 833
      curr->w_rend.font = (unsigned char )(c >> 8);
    }
#line 836
    curr->w_rend.mbcs = (unsigned char )curr->w_mbcs;
#line 838
    if (curr->w_layer.l_x < cols - 1) {
#line 840
      if (curr->w_insert) {
        {
#line 842
        while (1) {
          while_continue___15: /* CIL Label */ ;
          {
#line 842
          bcopy((void const   *)((char *)(curr->w_mlines + curr->w_layer.l_y)->image),
                (void *)((char *)mline_old.image), (size_t )cols);
#line 842
          bcopy((void const   *)((char *)(curr->w_mlines + curr->w_layer.l_y)->attr),
                (void *)((char *)mline_old.attr), (size_t )cols);
#line 842
          bcopy((void const   *)((char *)(curr->w_mlines + curr->w_layer.l_y)->font),
                (void *)((char *)mline_old.font), (size_t )cols);
#line 842
          bcopy((void const   *)((char *)(curr->w_mlines + curr->w_layer.l_y)->color),
                (void *)((char *)mline_old.color), (size_t )cols);
          }
#line 842
          goto while_break___15;
        }
        while_break___15: /* CIL Label */ ;
        }
        {
#line 843
        MInsChar(curr, & curr->w_rend, curr->w_layer.l_x, curr->w_layer.l_y);
#line 844
        LInsChar(& curr->w_layer, & curr->w_rend, curr->w_layer.l_x, curr->w_layer.l_y,
                 & mline_old);
#line 845
        (curr->w_layer.l_x) ++;
        }
      } else {
        {
#line 849
        MPutChar(curr, & curr->w_rend, curr->w_layer.l_x, curr->w_layer.l_y);
#line 850
        LPutChar(& curr->w_layer, & curr->w_rend, curr->w_layer.l_x, curr->w_layer.l_y);
#line 851
        (curr->w_layer.l_x) ++;
        }
      }
    } else
#line 854
    if (curr->w_layer.l_x == cols - 1) {
      {
#line 856
      MPutChar(curr, & curr->w_rend, curr->w_layer.l_x, curr->w_layer.l_y);
#line 857
      LPutChar(& curr->w_layer, & curr->w_rend, curr->w_layer.l_x, curr->w_layer.l_y);
      }
#line 858
      if (curr->w_wrap) {
#line 859
        (curr->w_layer.l_x) ++;
      }
    } else {
      {
#line 863
      MWrapChar(curr, & curr->w_rend, curr->w_layer.l_y, curr->w_top, curr->w_bot,
                curr->w_insert);
#line 864
      LWrapChar(& curr->w_layer, & curr->w_rend, curr->w_layer.l_y, curr->w_top, curr->w_bot,
                curr->w_insert);
      }
#line 865
      if (curr->w_layer.l_y != curr->w_bot) {
#line 865
        if (curr->w_layer.l_y != curr->w_layer.l_height - 1) {
#line 866
          (curr->w_layer.l_y) ++;
        }
      }
#line 867
      curr->w_layer.l_x = 1;
    }
#line 871
    if (curr->w_mbcs) {
#line 873
      tmp___10 = 0;
#line 873
      curr->w_mbcs = tmp___10;
#line 873
      curr->w_rend.mbcs = (unsigned char )tmp___10;
#line 874
      (curr->w_layer.l_x) ++;
    }
#line 877
    if (curr->w_ss) {
      {
#line 879
      curr->w_FontL = (char )curr->w_charsets[curr->w_Charset];
#line 880
      curr->w_FontR = (char )curr->w_charsets[curr->w_CharsetR];
#line 881
      curr->w_rend.font = (unsigned char )curr->w_FontL;
#line 882
      LSetRendition(& curr->w_layer, & curr->w_rend);
#line 883
      curr->w_ss = 0;
      }
    }
#line 886
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 318
    len --;
#line 318
    if (! len) {
#line 318
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 890
  if (! printcmd) {
#line 890
    if ((unsigned int )curr->w_state == 5U) {
      {
#line 891
      PrintFlush();
      }
    }
  }
#line 892
  return;
}
}
#line 894 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void WLogString(struct win *p , char *buf___0 , int len ) 
{ 
  char *t ;
  char *tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 900
  if (! p->w_log) {
#line 901
    return;
  }
#line 902
  if (logtstamp_on) {
#line 902
    if (p->w_logsilence >= logtstamp_after * 2) {
      {
#line 904
      tmp = MakeWinMsg(logtstamp_string, p, '%');
#line 904
      t = tmp;
#line 905
      tmp___0 = strlen((char const   *)t);
#line 905
      logfwrite(p->w_log, t, (int )tmp___0);
      }
    }
  }
  {
#line 907
  p->w_logsilence = 0;
#line 908
  tmp___2 = logfwrite(p->w_log, buf___0, len);
  }
#line 908
  if (tmp___2 < 1) {
    {
#line 910
    tmp___1 = __errno_location();
#line 910
    WMsg(p, *tmp___1, (char *)"Error writing logfile");
#line 911
    logfclose(p->w_log);
#line 912
    p->w_log = (struct logfile *)0;
    }
  }
#line 914
  if (! log_flush) {
    {
#line 915
    logfflush(p->w_log);
    }
  }
#line 916
  return;
}
}
#line 918 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static int Special(int c ) 
{ 


  {
  {
#line 924
  if (c == 8) {
#line 924
    goto case_8;
  }
#line 927
  if (c == 13) {
#line 927
    goto case_13;
  }
#line 930
  if (c == 10) {
#line 930
    goto case_10;
  }
#line 935
  if (c == 7) {
#line 935
    goto case_7;
  }
#line 938
  if (c == 9) {
#line 938
    goto case_9;
  }
#line 942
  if (c == 15) {
#line 942
    goto case_15;
  }
#line 945
  if (c == 14) {
#line 945
    goto case_14;
  }
#line 922
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 925
  BackSpace();
  }
#line 926
  return (1);
  case_13: /* CIL Label */ 
  {
#line 928
  Return();
  }
#line 929
  return (1);
  case_10: /* CIL Label */ 
#line 931
  if (curr->w_autoaka) {
    {
#line 932
    FindAKA();
    }
  }
  {
#line 933
  LineFeed(0);
  }
#line 934
  return (1);
  case_7: /* CIL Label */ 
  {
#line 936
  WBell(curr, visual_bell);
  }
#line 937
  return (1);
  case_9: /* CIL Label */ 
  {
#line 939
  ForwardTab();
  }
#line 940
  return (1);
  case_15: /* CIL Label */ 
  {
#line 943
  MapCharset(0);
  }
#line 944
  return (1);
  case_14: /* CIL Label */ 
  {
#line 946
  MapCharset(1);
  }
#line 947
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 950
  return (0);
}
}
#line 953 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void DoESC(int c , int intermediate ) 
{ 
  int tmp ;
  int tmp___0 ;
  char tmp___1 ;
  int tmp___2 ;
  char tmp___3 ;
  int tmp___4 ;

  {
  {
#line 957
  while (1) {
    while_continue: /* CIL Label */ ;
#line 957
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 960
  if (intermediate == 0) {
#line 960
    goto case_0;
  }
#line 1048
  if (intermediate == 35) {
#line 1048
    goto case_35;
  }
#line 1057
  if (intermediate == 40) {
#line 1057
    goto case_40;
  }
#line 1060
  if (intermediate == 41) {
#line 1060
    goto case_41;
  }
#line 1063
  if (intermediate == 42) {
#line 1063
    goto case_42;
  }
#line 1066
  if (intermediate == 43) {
#line 1066
    goto case_43;
  }
#line 1078
  if (intermediate == ((36 << 8) | 40)) {
#line 1078
    goto case_exp;
  }
#line 1078
  if (intermediate == 36) {
#line 1078
    goto case_exp;
  }
#line 1081
  if (intermediate == ((36 << 8) | 41)) {
#line 1081
    goto case_exp___0;
  }
#line 1084
  if (intermediate == ((36 << 8) | 42)) {
#line 1084
    goto case_exp___1;
  }
#line 1087
  if (intermediate == ((36 << 8) | 43)) {
#line 1087
    goto case_exp___2;
  }
#line 958
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 963
  if (c == 69) {
#line 963
    goto case_69;
  }
#line 966
  if (c == 68) {
#line 966
    goto case_68;
  }
#line 969
  if (c == 77) {
#line 969
    goto case_77;
  }
#line 972
  if (c == 72) {
#line 972
    goto case_72;
  }
#line 975
  if (c == 90) {
#line 975
    goto case_90;
  }
#line 978
  if (c == 55) {
#line 978
    goto case_55;
  }
#line 981
  if (c == 56) {
#line 981
    goto case_56;
  }
#line 984
  if (c == 99) {
#line 984
    goto case_99;
  }
#line 999
  if (c == 61) {
#line 999
    goto case_61;
  }
#line 1005
  if (c == 62) {
#line 1005
    goto case_62;
  }
#line 1012
  if (c == 110) {
#line 1012
    goto case_110;
  }
#line 1015
  if (c == 111) {
#line 1015
    goto case_111;
  }
#line 1018
  if (c == 126) {
#line 1018
    goto case_126;
  }
#line 1022
  if (c == 125) {
#line 1022
    goto case_125;
  }
#line 1025
  if (c == 124) {
#line 1025
    goto case_124;
  }
#line 1028
  if (c == 78) {
#line 1028
    goto case_78;
  }
#line 1035
  if (c == 79) {
#line 1035
    goto case_79;
  }
#line 1043
  if (c == 103) {
#line 1043
    goto case_103;
  }
#line 961
  goto switch_break___0;
  case_69: /* CIL Label */ 
  {
#line 964
  LineFeed(1);
  }
#line 965
  goto switch_break___0;
  case_68: /* CIL Label */ 
  {
#line 967
  LineFeed(0);
  }
#line 968
  goto switch_break___0;
  case_77: /* CIL Label */ 
  {
#line 970
  ReverseLineFeed();
  }
#line 971
  goto switch_break___0;
  case_72: /* CIL Label */ 
#line 973
  *(curr->w_tabs + curr->w_layer.l_x) = (char)1;
#line 974
  goto switch_break___0;
  case_90: /* CIL Label */ 
  {
#line 976
  Report((char *)"\033[?%d;%dc", 1, 2);
  }
#line 977
  goto switch_break___0;
  case_55: /* CIL Label */ 
  {
#line 979
  SaveCursor();
  }
#line 980
  goto switch_break___0;
  case_56: /* CIL Label */ 
  {
#line 982
  RestoreCursor();
  }
#line 983
  goto switch_break___0;
  case_99: /* CIL Label */ 
  {
#line 985
  ClearScreen();
#line 986
  ResetWindow(curr);
#line 987
  LKeypadMode(& curr->w_layer, 0);
#line 988
  LCursorkeysMode(& curr->w_layer, 0);
#line 997
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
#line 998
  goto switch_break___0;
  case_61: /* CIL Label */ 
  {
#line 1000
  tmp = 1;
#line 1000
  curr->w_keypad = tmp;
#line 1000
  LKeypadMode(& curr->w_layer, tmp);
  }
#line 1004
  goto switch_break___0;
  case_62: /* CIL Label */ 
  {
#line 1006
  tmp___0 = 0;
#line 1006
  curr->w_keypad = tmp___0;
#line 1006
  LKeypadMode(& curr->w_layer, tmp___0);
  }
#line 1010
  goto switch_break___0;
  case_110: /* CIL Label */ 
  {
#line 1013
  MapCharset(2);
  }
#line 1014
  goto switch_break___0;
  case_111: /* CIL Label */ 
  {
#line 1016
  MapCharset(3);
  }
#line 1017
  goto switch_break___0;
  case_126: /* CIL Label */ 
  {
#line 1019
  MapCharsetR(1);
  }
#line 1020
  goto switch_break___0;
  case_125: /* CIL Label */ 
  {
#line 1023
  MapCharsetR(2);
  }
#line 1024
  goto switch_break___0;
  case_124: /* CIL Label */ 
  {
#line 1026
  MapCharsetR(3);
  }
#line 1027
  goto switch_break___0;
  case_78: /* CIL Label */ 
#line 1029
  if (curr->w_charsets[curr->w_Charset] != curr->w_charsets[2]) {
#line 1031
    tmp___2 = 2;
#line 1031
    curr->w_ss = tmp___2;
#line 1031
    tmp___1 = (char )curr->w_charsets[tmp___2];
#line 1031
    curr->w_FontL = tmp___1;
#line 1031
    curr->w_FontR = tmp___1;
  } else
#line 1029
  if (curr->w_charsets[curr->w_CharsetR] != curr->w_charsets[2]) {
#line 1031
    tmp___2 = 2;
#line 1031
    curr->w_ss = tmp___2;
#line 1031
    tmp___1 = (char )curr->w_charsets[tmp___2];
#line 1031
    curr->w_FontL = tmp___1;
#line 1031
    curr->w_FontR = tmp___1;
  } else {
#line 1033
    curr->w_ss = 0;
  }
#line 1034
  goto switch_break___0;
  case_79: /* CIL Label */ 
#line 1036
  if (curr->w_charsets[curr->w_Charset] != curr->w_charsets[3]) {
#line 1038
    tmp___4 = 3;
#line 1038
    curr->w_ss = tmp___4;
#line 1038
    tmp___3 = (char )curr->w_charsets[tmp___4];
#line 1038
    curr->w_FontL = tmp___3;
#line 1038
    curr->w_FontR = tmp___3;
  } else
#line 1036
  if (curr->w_charsets[curr->w_CharsetR] != curr->w_charsets[3]) {
#line 1038
    tmp___4 = 3;
#line 1038
    curr->w_ss = tmp___4;
#line 1038
    tmp___3 = (char )curr->w_charsets[tmp___4];
#line 1038
    curr->w_FontL = tmp___3;
#line 1038
    curr->w_FontR = tmp___3;
  } else {
#line 1040
    curr->w_ss = 0;
  }
#line 1041
  goto switch_break___0;
  case_103: /* CIL Label */ 
  {
#line 1044
  WBell(curr, 1);
  }
#line 1045
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1047
  goto switch_break;
  case_35: /* CIL Label */ 
  {
#line 1051
  if (c == 56) {
#line 1051
    goto case_56___0;
  }
#line 1049
  goto switch_break___1;
  case_56___0: /* CIL Label */ 
  {
#line 1052
  FillWithEs();
  }
#line 1053
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 1055
  goto switch_break;
  case_40: /* CIL Label */ 
  {
#line 1058
  DesignateCharset(c, 0);
  }
#line 1059
  goto switch_break;
  case_41: /* CIL Label */ 
  {
#line 1061
  DesignateCharset(c, 1);
  }
#line 1062
  goto switch_break;
  case_42: /* CIL Label */ 
  {
#line 1064
  DesignateCharset(c, 2);
  }
#line 1065
  goto switch_break;
  case_43: /* CIL Label */ 
  {
#line 1067
  DesignateCharset(c, 3);
  }
#line 1068
  goto switch_break;
  case_exp: /* CIL Label */ 
  case_36: /* CIL Label */ 
  {
#line 1079
  DesignateCharset(c & 31, 0);
  }
#line 1080
  goto switch_break;
  case_exp___0: /* CIL Label */ 
  {
#line 1082
  DesignateCharset(c & 31, 1);
  }
#line 1083
  goto switch_break;
  case_exp___1: /* CIL Label */ 
  {
#line 1085
  DesignateCharset(c & 31, 2);
  }
#line 1086
  goto switch_break;
  case_exp___2: /* CIL Label */ 
  {
#line 1088
  DesignateCharset(c & 31, 3);
  }
#line 1089
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1093
  return;
}
}
#line 1095 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void DoCSI(int c , int intermediate ) 
{ 
  register int i ;
  register int a1 ;
  register int a2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  char tmp___21 ;
  char tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;

  {
#line 1099
  a1 = curr->w_args[0];
#line 1099
  a2 = curr->w_args[1];
#line 1101
  if (curr->w_NumArgs > 64) {
#line 1102
    curr->w_NumArgs = 64;
  }
  {
#line 1105
  if (intermediate == 0) {
#line 1105
    goto case_0;
  }
#line 1308
  if (intermediate == 63) {
#line 1308
    goto case_63;
  }
#line 1417
  if (intermediate == 62) {
#line 1417
    goto case_62;
  }
#line 1103
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1109
  if (c == 102) {
#line 1109
    goto case_102;
  }
#line 1109
  if (c == 72) {
#line 1109
    goto case_102;
  }
#line 1126
  if (c == 74) {
#line 1126
    goto case_74;
  }
#line 1143
  if (c == 75) {
#line 1143
    goto case_75;
  }
#line 1159
  if (c == 88) {
#line 1159
    goto case_88;
  }
#line 1163
  if (c == 65) {
#line 1163
    goto case_65;
  }
#line 1166
  if (c == 66) {
#line 1166
    goto case_66;
  }
#line 1169
  if (c == 67) {
#line 1169
    goto case_67;
  }
#line 1172
  if (c == 68) {
#line 1172
    goto case_68;
  }
#line 1175
  if (c == 69) {
#line 1175
    goto case_69;
  }
#line 1179
  if (c == 70) {
#line 1179
    goto case_70;
  }
#line 1184
  if (c == 96) {
#line 1184
    goto case_96;
  }
#line 1184
  if (c == 71) {
#line 1184
    goto case_96;
  }
#line 1190
  if (c == 100) {
#line 1190
    goto case_100;
  }
#line 1196
  if (c == 109) {
#line 1196
    goto case_109;
  }
#line 1199
  if (c == 103) {
#line 1199
    goto case_103;
  }
#line 1205
  if (c == 114) {
#line 1205
    goto case_114;
  }
#line 1224
  if (c == 115) {
#line 1224
    goto case_115;
  }
#line 1227
  if (c == 116) {
#line 1227
    goto case_116;
  }
#line 1241
  if (c == 117) {
#line 1241
    goto case_117;
  }
#line 1244
  if (c == 73) {
#line 1244
    goto case_73;
  }
#line 1250
  if (c == 90) {
#line 1250
    goto case_90;
  }
#line 1256
  if (c == 76) {
#line 1256
    goto case_76;
  }
#line 1259
  if (c == 77) {
#line 1259
    goto case_77;
  }
#line 1262
  if (c == 80) {
#line 1262
    goto case_80;
  }
#line 1265
  if (c == 64) {
#line 1265
    goto case_64;
  }
#line 1268
  if (c == 104) {
#line 1268
    goto case_104;
  }
#line 1271
  if (c == 108) {
#line 1271
    goto case_108;
  }
#line 1274
  if (c == 105) {
#line 1274
    goto case_105;
  }
#line 1278
  if (c == 110) {
#line 1278
    goto case_110;
  }
#line 1284
  if (c == 99) {
#line 1284
    goto case_99;
  }
#line 1288
  if (c == 120) {
#line 1288
    goto case_120;
  }
#line 1292
  if (c == 112) {
#line 1292
    goto case_112;
  }
#line 1299
  if (c == 83) {
#line 1299
    goto case_83;
  }
#line 1303
  if (c == 94) {
#line 1303
    goto case_94;
  }
#line 1303
  if (c == 84) {
#line 1303
    goto case_94;
  }
#line 1106
  goto switch_break___0;
  case_102: /* CIL Label */ 
  case_72: /* CIL Label */ 
#line 1110
  if (a1 < 1) {
#line 1111
    a1 = 1;
  }
#line 1112
  if (curr->w_origin) {
#line 1113
    a1 += curr->w_top;
  }
#line 1114
  if (a1 > rows) {
#line 1115
    a1 = rows;
  }
#line 1116
  if (a2 < 1) {
#line 1117
    a2 = 1;
  }
#line 1118
  if (a2 > cols) {
#line 1119
    a2 = cols;
  }
  {
#line 1120
  a1 --;
#line 1120
  a2 --;
#line 1120
  LGotoPos(& curr->w_layer, a2, a1);
#line 1121
  curr->w_layer.l_x = a2;
#line 1122
  curr->w_layer.l_y = a1;
  }
#line 1123
  if (curr->w_autoaka) {
#line 1124
    curr->w_autoaka = a1 + 1;
  }
#line 1125
  goto switch_break___0;
  case_74: /* CIL Label */ 
#line 1127
  if (a1 < 0) {
#line 1128
    a1 = 0;
  } else
#line 1127
  if (a1 > 2) {
#line 1128
    a1 = 0;
  }
  {
#line 1131
  if (a1 == 0) {
#line 1131
    goto case_0___0;
  }
#line 1134
  if (a1 == 1) {
#line 1134
    goto case_1;
  }
#line 1137
  if (a1 == 2) {
#line 1137
    goto case_2;
  }
#line 1129
  goto switch_break___1;
  case_0___0: /* CIL Label */ 
  {
#line 1132
  ClearToEOS();
  }
#line 1133
  goto switch_break___1;
  case_1: /* CIL Label */ 
  {
#line 1135
  ClearFromBOS();
  }
#line 1136
  goto switch_break___1;
  case_2: /* CIL Label */ 
  {
#line 1138
  ClearScreen();
#line 1139
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
#line 1140
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 1142
  goto switch_break___0;
  case_75: /* CIL Label */ 
#line 1144
  if (a1 < 0) {
#line 1145
    a1 %= 3;
  } else
#line 1144
  if (a1 > 2) {
#line 1145
    a1 %= 3;
  }
  {
#line 1148
  if (a1 == 0) {
#line 1148
    goto case_0___1;
  }
#line 1151
  if (a1 == 1) {
#line 1151
    goto case_1___0;
  }
#line 1154
  if (a1 == 2) {
#line 1154
    goto case_2___0;
  }
#line 1146
  goto switch_break___2;
  case_0___1: /* CIL Label */ 
  {
#line 1149
  ClearLineRegion(curr->w_layer.l_x, cols - 1);
  }
#line 1150
  goto switch_break___2;
  case_1___0: /* CIL Label */ 
  {
#line 1152
  ClearLineRegion(0, curr->w_layer.l_x);
  }
#line 1153
  goto switch_break___2;
  case_2___0: /* CIL Label */ 
  {
#line 1155
  ClearLineRegion(0, cols - 1);
  }
#line 1156
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 1158
  goto switch_break___0;
  case_88: /* CIL Label */ 
#line 1160
  if (a1) {
#line 1160
    tmp = a1 - 1;
  } else {
#line 1160
    tmp = 0;
  }
#line 1160
  a1 = curr->w_layer.l_x + tmp;
#line 1161
  if (a1 < cols) {
#line 1161
    tmp___0 = a1;
  } else {
#line 1161
    tmp___0 = cols - 1;
  }
  {
#line 1161
  ClearLineRegion(curr->w_layer.l_x, tmp___0);
  }
#line 1162
  goto switch_break___0;
  case_65: /* CIL Label */ 
#line 1164
  if (a1) {
#line 1164
    tmp___1 = a1;
  } else {
#line 1164
    tmp___1 = 1;
  }
  {
#line 1164
  CursorUp(tmp___1);
  }
#line 1165
  goto switch_break___0;
  case_66: /* CIL Label */ 
#line 1167
  if (a1) {
#line 1167
    tmp___2 = a1;
  } else {
#line 1167
    tmp___2 = 1;
  }
  {
#line 1167
  CursorDown(tmp___2);
  }
#line 1168
  goto switch_break___0;
  case_67: /* CIL Label */ 
#line 1170
  if (a1) {
#line 1170
    tmp___3 = a1;
  } else {
#line 1170
    tmp___3 = 1;
  }
  {
#line 1170
  CursorRight(tmp___3);
  }
#line 1171
  goto switch_break___0;
  case_68: /* CIL Label */ 
#line 1173
  if (a1) {
#line 1173
    tmp___4 = a1;
  } else {
#line 1173
    tmp___4 = 1;
  }
  {
#line 1173
  CursorLeft(tmp___4);
  }
#line 1174
  goto switch_break___0;
  case_69: /* CIL Label */ 
#line 1176
  curr->w_layer.l_x = 0;
#line 1177
  if (a1) {
#line 1177
    tmp___5 = a1;
  } else {
#line 1177
    tmp___5 = 1;
  }
  {
#line 1177
  CursorDown(tmp___5);
  }
#line 1178
  goto switch_break___0;
  case_70: /* CIL Label */ 
#line 1180
  curr->w_layer.l_x = 0;
#line 1181
  if (a1) {
#line 1181
    tmp___6 = a1;
  } else {
#line 1181
    tmp___6 = 1;
  }
  {
#line 1181
  CursorUp(tmp___6);
  }
#line 1182
  goto switch_break___0;
  case_96: /* CIL Label */ 
  case_71: /* CIL Label */ 
#line 1185
  if (a1) {
#line 1185
    curr->w_layer.l_x = a1 - 1;
  } else {
#line 1185
    curr->w_layer.l_x = 0;
  }
#line 1186
  if (curr->w_layer.l_x >= cols) {
#line 1187
    curr->w_layer.l_x = cols - 1;
  }
  {
#line 1188
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
#line 1189
  goto switch_break___0;
  case_100: /* CIL Label */ 
#line 1191
  if (a1) {
#line 1191
    curr->w_layer.l_y = a1 - 1;
  } else {
#line 1191
    curr->w_layer.l_y = 0;
  }
#line 1192
  if (curr->w_layer.l_y >= rows) {
#line 1193
    curr->w_layer.l_y = rows - 1;
  }
  {
#line 1194
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
#line 1195
  goto switch_break___0;
  case_109: /* CIL Label */ 
  {
#line 1197
  SelectRendition();
  }
#line 1198
  goto switch_break___0;
  case_103: /* CIL Label */ 
#line 1200
  if (a1 == 0) {
#line 1201
    *(curr->w_tabs + curr->w_layer.l_x) = (char)0;
  } else
#line 1202
  if (a1 == 3) {
    {
#line 1203
    bzero((void *)curr->w_tabs, (size_t )cols);
    }
  }
#line 1204
  goto switch_break___0;
  case_114: /* CIL Label */ 
#line 1206
  if (! a1) {
#line 1207
    a1 = 1;
  }
#line 1208
  if (! a2) {
#line 1209
    a2 = rows;
  }
#line 1210
  if (a1 < 1) {
#line 1211
    goto switch_break___0;
  } else
#line 1210
  if (a2 > rows) {
#line 1211
    goto switch_break___0;
  } else
#line 1210
  if (a1 >= a2) {
#line 1211
    goto switch_break___0;
  }
#line 1212
  curr->w_top = a1 - 1;
#line 1213
  curr->w_bot = a2 - 1;
#line 1215
  if (curr->w_origin) {
#line 1217
    curr->w_layer.l_y = curr->w_top;
#line 1218
    curr->w_layer.l_x = 0;
  } else {
#line 1221
    tmp___7 = 0;
#line 1221
    curr->w_layer.l_x = tmp___7;
#line 1221
    curr->w_layer.l_y = tmp___7;
  }
  {
#line 1222
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
#line 1223
  goto switch_break___0;
  case_115: /* CIL Label */ 
  {
#line 1225
  SaveCursor();
  }
#line 1226
  goto switch_break___0;
  case_116: /* CIL Label */ 
#line 1228
  if (a1 != 8) {
#line 1229
    goto switch_break___0;
  }
#line 1230
  a1 = curr->w_args[2];
#line 1231
  if (a1 < 1) {
#line 1232
    a1 = curr->w_layer.l_width;
  }
#line 1233
  if (a2 < 1) {
#line 1234
    a2 = curr->w_layer.l_height;
  }
#line 1235
  if (a1 > 10000) {
#line 1236
    goto switch_break___0;
  } else
#line 1235
  if (a2 > 10000) {
#line 1236
    goto switch_break___0;
  }
  {
#line 1237
  WChangeSize(curr, a1, a2);
#line 1238
  cols = curr->w_layer.l_width;
#line 1239
  rows = curr->w_layer.l_height;
  }
#line 1240
  goto switch_break___0;
  case_117: /* CIL Label */ 
  {
#line 1242
  RestoreCursor();
  }
#line 1243
  goto switch_break___0;
  case_73: /* CIL Label */ 
#line 1245
  if (! a1) {
#line 1246
    a1 = 1;
  }
  {
#line 1247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1247
    tmp___8 = a1;
#line 1247
    a1 --;
#line 1247
    if (! tmp___8) {
#line 1247
      goto while_break;
    }
    {
#line 1248
    ForwardTab();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1249
  goto switch_break___0;
  case_90: /* CIL Label */ 
#line 1251
  if (! a1) {
#line 1252
    a1 = 1;
  }
  {
#line 1253
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1253
    tmp___9 = a1;
#line 1253
    a1 --;
#line 1253
    if (! tmp___9) {
#line 1253
      goto while_break___0;
    }
    {
#line 1254
    BackwardTab();
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1255
  goto switch_break___0;
  case_76: /* CIL Label */ 
#line 1257
  if (a1) {
#line 1257
    tmp___10 = a1;
  } else {
#line 1257
    tmp___10 = 1;
  }
  {
#line 1257
  InsertLine(tmp___10);
  }
#line 1258
  goto switch_break___0;
  case_77: /* CIL Label */ 
#line 1260
  if (a1) {
#line 1260
    tmp___11 = a1;
  } else {
#line 1260
    tmp___11 = 1;
  }
  {
#line 1260
  DeleteLine(tmp___11);
  }
#line 1261
  goto switch_break___0;
  case_80: /* CIL Label */ 
#line 1263
  if (a1) {
#line 1263
    tmp___12 = a1;
  } else {
#line 1263
    tmp___12 = 1;
  }
  {
#line 1263
  DeleteChar(tmp___12);
  }
#line 1264
  goto switch_break___0;
  case_64: /* CIL Label */ 
#line 1266
  if (a1) {
#line 1266
    tmp___13 = a1;
  } else {
#line 1266
    tmp___13 = 1;
  }
  {
#line 1266
  InsertChar(tmp___13);
  }
#line 1267
  goto switch_break___0;
  case_104: /* CIL Label */ 
  {
#line 1269
  ASetMode(1);
  }
#line 1270
  goto switch_break___0;
  case_108: /* CIL Label */ 
  {
#line 1272
  ASetMode(0);
  }
#line 1273
  goto switch_break___0;
  case_105: /* CIL Label */ 
#line 1275
  if (a1 == 5) {
    {
#line 1276
    PrintStart();
    }
  }
#line 1277
  goto switch_break___0;
  case_110: /* CIL Label */ 
#line 1279
  if (a1 == 5) {
    {
#line 1280
    Report((char *)"\033[0n", 0, 0);
    }
  } else
#line 1281
  if (a1 == 6) {
    {
#line 1282
    Report((char *)"\033[%d;%dR", curr->w_layer.l_y + 1, curr->w_layer.l_x + 1);
    }
  }
#line 1283
  goto switch_break___0;
  case_99: /* CIL Label */ 
#line 1285
  if (a1 == 0) {
    {
#line 1286
    Report((char *)"\033[?%d;%dc", 1, 2);
    }
  }
#line 1287
  goto switch_break___0;
  case_120: /* CIL Label */ 
#line 1289
  if (a1 == 0) {
    {
#line 1290
    Report((char *)"\033[%d;1;1;112;112;1;0x", a1 + 2, 0);
    }
  } else
#line 1289
  if (a1 == 1) {
    {
#line 1290
    Report((char *)"\033[%d;1;1;112;112;1;0x", a1 + 2, 0);
    }
  }
#line 1291
  goto switch_break___0;
  case_112: /* CIL Label */ 
#line 1293
  if (a1 == 6) {
#line 1293
    goto _L;
  } else
#line 1293
  if (a1 == 7) {
    _L: /* CIL Label */ 
#line 1295
    curr->w_curinv = 7 - a1;
#line 1296
    if (curr->w_curinv) {
#line 1296
      tmp___14 = -1;
    } else {
#line 1296
      tmp___14 = curr->w_curvvis;
    }
    {
#line 1296
    LCursorVisibility(& curr->w_layer, tmp___14);
    }
  }
#line 1298
  goto switch_break___0;
  case_83: /* CIL Label */ 
#line 1300
  if (a1) {
#line 1300
    tmp___15 = a1;
  } else {
#line 1300
    tmp___15 = 1;
  }
  {
#line 1300
  ScrollRegion(tmp___15);
  }
#line 1301
  goto switch_break___0;
  case_94: /* CIL Label */ 
  case_84: /* CIL Label */ 
#line 1304
  if (a1) {
#line 1304
    tmp___16 = - a1;
  } else {
#line 1304
    tmp___16 = -1;
  }
  {
#line 1304
  ScrollRegion(tmp___16);
  }
#line 1305
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1307
  goto switch_break;
  case_63: /* CIL Label */ 
#line 1309
  a2 = 0;
  {
#line 1309
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1309
    if (! (a2 < curr->w_NumArgs)) {
#line 1309
      goto while_break___1;
    }
#line 1311
    a1 = curr->w_args[a2];
    {
#line 1312
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1312
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1313
    if (c != 104) {
#line 1313
      if (c != 108) {
#line 1314
        goto while_break___1;
      }
    }
#line 1315
    i = c == 104;
    {
#line 1318
    if (a1 == 1) {
#line 1318
      goto case_1___1;
    }
#line 1324
    if (a1 == 2) {
#line 1324
      goto case_2___1;
    }
#line 1341
    if (a1 == 3) {
#line 1341
      goto case_3;
    }
#line 1348
    if (a1 == 5) {
#line 1348
      goto case_5;
    }
#line 1353
    if (a1 == 6) {
#line 1353
      goto case_6;
    }
#line 1363
    if (a1 == 7) {
#line 1363
      goto case_7;
    }
#line 1368
    if (a1 == 9) {
#line 1368
      goto case_9;
    }
#line 1379
    if (a1 == 25) {
#line 1379
      goto case_25;
    }
#line 1392
    if (a1 == 1049) {
#line 1392
      goto case_1049;
    }
#line 1392
    if (a1 == 1047) {
#line 1392
      goto case_1049;
    }
#line 1392
    if (a1 == 47) {
#line 1392
      goto case_1049;
    }
#line 1410
    if (a1 == 1003) {
#line 1410
      goto case_1003;
    }
#line 1410
    if (a1 == 1002) {
#line 1410
      goto case_1003;
    }
#line 1410
    if (a1 == 1001) {
#line 1410
      goto case_1003;
    }
#line 1410
    if (a1 == 1000) {
#line 1410
      goto case_1003;
    }
#line 1316
    goto switch_break___3;
    case_1___1: /* CIL Label */ 
    {
#line 1319
    tmp___17 = i;
#line 1319
    curr->w_cursorkeys = tmp___17;
#line 1319
    LCursorkeysMode(& curr->w_layer, tmp___17);
    }
#line 1323
    goto switch_break___3;
    case_2___1: /* CIL Label */ 
#line 1325
    if (i) {
#line 1329
      if (curr->w_layer.l_encoding) {
#line 1330
        goto switch_break___3;
      }
#line 1332
      tmp___22 = (char)0;
#line 1332
      curr->w_FontR = tmp___22;
#line 1332
      tmp___21 = tmp___22;
#line 1332
      curr->w_FontL = tmp___21;
#line 1332
      tmp___20 = (int )tmp___21;
#line 1332
      curr->w_charsets[2] = tmp___20;
#line 1332
      tmp___19 = tmp___20;
#line 1332
      curr->w_charsets[2] = tmp___19;
#line 1332
      tmp___18 = tmp___19;
#line 1332
      curr->w_charsets[1] = tmp___18;
#line 1332
      curr->w_charsets[0] = tmp___18;
#line 1335
      curr->w_Charset = 0;
#line 1336
      curr->w_CharsetR = 2;
#line 1337
      curr->w_ss = 0;
    }
#line 1340
    goto switch_break___3;
    case_3: /* CIL Label */ 
#line 1342
    if (i) {
#line 1342
      i = Z0width;
    } else {
#line 1342
      i = Z1width;
    }
    {
#line 1343
    WChangeSize(curr, i, curr->w_layer.l_height);
#line 1344
    cols = curr->w_layer.l_width;
#line 1345
    rows = curr->w_layer.l_height;
    }
#line 1346
    goto switch_break___3;
    case_5: /* CIL Label */ 
#line 1349
    if (i != curr->w_revvid) {
      {
#line 1350
      WReverseVideo(curr, i);
      }
    }
#line 1351
    curr->w_revvid = i;
#line 1352
    goto switch_break___3;
    case_6: /* CIL Label */ 
#line 1354
    tmp___24 = i;
#line 1354
    curr->w_origin = tmp___24;
#line 1354
    if (tmp___24 != 0) {
#line 1356
      curr->w_layer.l_y = curr->w_top;
#line 1357
      curr->w_layer.l_x = 0;
    } else {
#line 1360
      tmp___23 = 0;
#line 1360
      curr->w_layer.l_x = tmp___23;
#line 1360
      curr->w_layer.l_y = tmp___23;
    }
    {
#line 1361
    LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
    }
#line 1362
    goto switch_break___3;
    case_7: /* CIL Label */ 
#line 1364
    curr->w_wrap = i;
#line 1365
    goto switch_break___3;
    case_9: /* CIL Label */ 
#line 1369
    if (i) {
#line 1369
      curr->w_mouse = 9;
    } else {
#line 1369
      curr->w_mouse = 0;
    }
    {
#line 1370
    LMouseMode(& curr->w_layer, curr->w_mouse);
    }
#line 1371
    goto switch_break___3;
    case_25: /* CIL Label */ 
#line 1380
    curr->w_curinv = ! i;
#line 1381
    if (curr->w_curinv) {
#line 1381
      tmp___25 = -1;
    } else {
#line 1381
      tmp___25 = curr->w_curvvis;
    }
    {
#line 1381
    LCursorVisibility(& curr->w_layer, tmp___25);
    }
#line 1382
    goto switch_break___3;
    case_1049: /* CIL Label */ 
    case_1047: /* CIL Label */ 
    case_47: /* CIL Label */ 
#line 1393
    if (use_altscreen) {
#line 1395
      if (i) {
        {
#line 1396
        EnterAltScreen(curr);
        }
      } else {
        {
#line 1398
        LeaveAltScreen(curr);
        }
      }
#line 1399
      if (a1 == 47) {
#line 1399
        if (! i) {
#line 1400
          curr->w_saved = 0;
        }
      }
      {
#line 1401
      LRefreshAll(& curr->w_layer, 0);
#line 1402
      LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
      }
    }
#line 1404
    goto switch_break___3;
    case_1003: /* CIL Label */ 
    case_1002: /* CIL Label */ 
    case_1001: /* CIL Label */ 
    case_1000: /* CIL Label */ 
#line 1411
    if (i) {
#line 1411
      curr->w_mouse = a1;
    } else {
#line 1411
      curr->w_mouse = 0;
    }
    {
#line 1412
    LMouseMode(& curr->w_layer, curr->w_mouse);
    }
#line 1413
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
#line 1309
    a2 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1416
  goto switch_break;
  case_62: /* CIL Label */ 
  {
#line 1420
  if (c == 99) {
#line 1420
    goto case_99___0;
  }
#line 1418
  goto switch_break___4;
  case_99___0: /* CIL Label */ 
#line 1421
  if (a1 == 0) {
    {
#line 1422
    Report((char *)"\033[>%d;%d;0c", 83, nversion);
    }
  }
#line 1423
  goto switch_break___4;
  switch_break___4: /* CIL Label */ ;
  }
#line 1425
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1427
  return;
}
}
#line 1430 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void StringStart(enum string_t type ) 
{ 


  {
#line 1434
  curr->w_StringType = type;
#line 1435
  curr->w_stringp = curr->w_string;
#line 1436
  curr->w_state = (enum state_t )2;
#line 1437
  return;
}
}
#line 1439 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void StringChar(int c ) 
{ 
  char *tmp ;

  {
#line 1443
  if ((unsigned long )curr->w_stringp >= (unsigned long )((curr->w_string + 256) - 1)) {
#line 1444
    curr->w_state = (enum state_t )0;
  } else {
#line 1446
    tmp = curr->w_stringp;
#line 1446
    (curr->w_stringp) ++;
#line 1446
    *tmp = (char )c;
  }
#line 1447
  return;
}
}
#line 1453 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static int StringEnd(void) 
{ 
  struct canvas *cv ;
  char *p ;
  int typ ;
  char *args[64] ;
  int argl[64] ;
  struct acluser *windowuser ;
  struct acluser **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct display *olddisplay ;
  struct canvas *cv___0 ;
  size_t tmp___2 ;

  {
#line 1460
  curr->w_state = (enum state_t )0;
#line 1461
  *(curr->w_stringp) = (char )'\000';
  {
#line 1464
  if ((unsigned int )curr->w_StringType == 2U) {
#line 1464
    goto case_2;
  }
#line 1533
  if ((unsigned int )curr->w_StringType == 3U) {
#line 1533
    goto case_3;
  }
#line 1546
  if ((unsigned int )curr->w_StringType == 6U) {
#line 1546
    goto case_6;
  }
#line 1546
  if ((unsigned int )curr->w_StringType == 4U) {
#line 1546
    goto case_6;
  }
#line 1556
  if ((unsigned int )curr->w_StringType == 1U) {
#line 1556
    goto case_1;
  }
#line 1559
  if ((unsigned int )curr->w_StringType == 5U) {
#line 1559
    goto case_5;
  }
#line 1566
  goto switch_default;
  case_2: /* CIL Label */ 
#line 1465
  if ((int )curr->w_string[0] == 59) {
#line 1466
    goto switch_break;
  } else {
    {
#line 1465
    p = index((char const   *)(curr->w_string), ';');
    }
#line 1465
    if ((unsigned long )p == (unsigned long )((char *)0)) {
#line 1466
      goto switch_break;
    }
  }
  {
#line 1467
  typ = atoi((char const   *)(curr->w_string));
#line 1468
  p ++;
  }
#line 1470
  if (typ == 83) {
    {
#line 1477
    tmp = FindUserPtr((char *)":window:");
#line 1477
    windowuser = *tmp;
    }
#line 1478
    if (windowuser) {
      {
#line 1478
      tmp___0 = Parse(p, (int )(sizeof(curr->w_string) - (unsigned long )(p - curr->w_string)),
                      args, argl);
      }
#line 1478
      if (tmp___0) {
#line 1480
        display = displays;
        {
#line 1480
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1480
          if (! display) {
#line 1480
            goto while_break;
          }
#line 1481
          if ((unsigned long )((display->d_forecv)->c_layer)->l_bottom == (unsigned long )(& curr->w_layer)) {
#line 1482
            goto while_break;
          }
#line 1480
          display = display->d_next;
        }
        while_break: /* CIL Label */ ;
        }
#line 1483
        if ((unsigned long )display == (unsigned long )((struct display *)0)) {
#line 1483
          if (curr->w_layer.l_cvlist) {
#line 1484
            display = (curr->w_layer.l_cvlist)->c_display;
          }
        }
#line 1485
        if ((unsigned long )display == (unsigned long )((struct display *)0)) {
#line 1486
          display = displays;
        }
#line 1487
        EffectiveAclUser = windowuser;
#line 1488
        fore = curr;
#line 1489
        if (fore->w_savelayer) {
#line 1489
          flayer = fore->w_savelayer;
        } else {
#line 1489
          flayer = & fore->w_layer;
        }
        {
#line 1490
        DoCommand(args, argl);
#line 1491
        EffectiveAclUser = (struct acluser *)0;
#line 1492
        fore = (struct win *)0;
#line 1493
        flayer = (struct layer *)0;
        }
      }
    }
#line 1495
    goto switch_break;
  }
#line 1524
  if (typ < 0) {
#line 1525
    goto switch_break;
  } else
#line 1524
  if (typ > 2) {
#line 1525
    goto switch_break;
  }
#line 1528
  curr->w_stringp -= p - curr->w_string;
#line 1529
  if ((unsigned long )curr->w_stringp > (unsigned long )(curr->w_string)) {
    {
#line 1530
    bcopy((void const   *)p, (void *)(curr->w_string), (size_t )(curr->w_stringp - curr->w_string));
    }
  }
#line 1531
  *(curr->w_stringp) = (char )'\000';
  case_3: /* CIL Label */ 
#line 1534
  if (curr->w_hstatus) {
    {
#line 1536
    tmp___1 = strcmp((char const   *)curr->w_hstatus, (char const   *)(curr->w_string));
    }
#line 1536
    if (tmp___1 == 0) {
#line 1537
      goto switch_break;
    }
    {
#line 1538
    free((void *)curr->w_hstatus);
#line 1539
    curr->w_hstatus = (char *)0;
    }
  }
#line 1541
  if ((unsigned long )(curr->w_string) != (unsigned long )curr->w_stringp) {
    {
#line 1542
    curr->w_hstatus = SaveStr((char const   *)(curr->w_string));
    }
  }
  {
#line 1543
  WindowChanged(curr, 'h');
  }
#line 1544
  goto switch_break;
  case_6: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 1547
  display = displays;
  {
#line 1547
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1547
    if (! display) {
#line 1547
      goto while_break___0;
    }
#line 1549
    cv = display->d_cvlist;
    {
#line 1549
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1549
      if (! cv) {
#line 1549
        goto while_break___1;
      }
#line 1550
      if ((unsigned long )(cv->c_layer)->l_bottom == (unsigned long )(& curr->w_layer)) {
#line 1551
        goto while_break___1;
      }
#line 1549
      cv = cv->c_next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1552
    if (cv) {
      {
#line 1553
      MakeStatus(curr->w_string);
      }
    } else
#line 1552
    if ((unsigned int )curr->w_StringType == 6U) {
      {
#line 1553
      MakeStatus(curr->w_string);
      }
    }
#line 1547
    display = display->d_next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1555
  return (-1);
  case_1: /* CIL Label */ 
  {
#line 1557
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1557
    olddisplay = display;
#line 1557
    display = displays;
    {
#line 1557
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1557
      if (! display) {
#line 1557
        goto while_break___3;
      }
#line 1557
      cv___0 = display->d_cvlist;
      {
#line 1557
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1557
        if (! cv___0) {
#line 1557
          goto while_break___4;
        }
#line 1557
        if ((unsigned long )cv___0->c_layer == (unsigned long )(& curr->w_layer)) {
#line 1557
          goto while_break___4;
        }
#line 1557
        cv___0 = cv___0->c_next;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1557
      if ((unsigned long )cv___0 == (unsigned long )((struct canvas *)0)) {
#line 1557
        goto __Cont;
      }
      {
#line 1557
      AddStr(curr->w_string);
      }
      __Cont: /* CIL Label */ 
#line 1557
      display = display->d_next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1557
    display = olddisplay;
#line 1557
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1558
  goto switch_break;
  case_5: /* CIL Label */ 
#line 1560
  if ((unsigned long )curr->w_title == (unsigned long )(curr->w_akabuf)) {
#line 1560
    if (! curr->w_string[0]) {
#line 1561
      goto switch_break;
    }
  }
  {
#line 1562
  tmp___2 = strlen((char const   *)(curr->w_string));
#line 1562
  ChangeAKA(curr, curr->w_string, (int )tmp___2);
  }
#line 1563
  if (! curr->w_string[0]) {
#line 1564
    curr->w_autoaka = curr->w_layer.l_y + 1;
  }
#line 1565
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1567
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1569
  return (0);
}
}
#line 1572 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void PrintStart(void) 
{ 
  struct canvas *cv ;

  {
#line 1575
  curr->w_pdisplay = (struct display *)0;
#line 1578
  display = curr->w_lastdisp;
#line 1579
  if (display) {
#line 1579
    if ((unsigned long )curr == (unsigned long )display->d_fore) {
#line 1579
      if (! printcmd) {
#line 1579
        if (! display->d_tcs[73].str) {
#line 1579
          goto _L___0;
        }
      }
    } else {
#line 1579
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 1580
    display = displays;
    {
#line 1580
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1580
      if (! display) {
#line 1580
        goto while_break;
      }
#line 1581
      if ((unsigned long )curr == (unsigned long )display->d_fore) {
#line 1581
        if (printcmd) {
#line 1582
          goto while_break;
        } else
#line 1581
        if (display->d_tcs[73].str) {
#line 1582
          goto while_break;
        }
      }
#line 1580
      display = display->d_next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1583
  if (! display) {
#line 1586
    cv = curr->w_layer.l_cvlist;
    {
#line 1586
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1586
      if (! cv) {
#line 1586
        goto while_break___0;
      }
#line 1588
      display = cv->c_display;
#line 1589
      if (printcmd) {
#line 1590
        goto while_break___0;
      } else
#line 1589
      if (display->d_tcs[73].str) {
#line 1590
        goto while_break___0;
      }
#line 1586
      cv = cv->c_lnext;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1592
    if (! cv) {
#line 1594
      display = displays;
#line 1595
      if (! display) {
#line 1596
        return;
      } else
#line 1595
      if (display->d_next) {
#line 1596
        return;
      } else
#line 1595
      if (! printcmd) {
#line 1595
        if (! display->d_tcs[73].str) {
#line 1596
          return;
        }
      }
    }
  }
#line 1599
  curr->w_pdisplay = display;
#line 1600
  curr->w_stringp = curr->w_string;
#line 1601
  curr->w_state = (enum state_t )5;
#line 1602
  if (printcmd) {
#line 1602
    if ((curr->w_pdisplay)->d_printfd < 0) {
      {
#line 1603
      (curr->w_pdisplay)->d_printfd = printpipe(curr, printcmd);
      }
    }
  }
#line 1604
  return;
}
}
#line 1606 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void PrintChar(int c ) 
{ 
  char *tmp ;

  {
#line 1610
  if ((unsigned long )curr->w_stringp >= (unsigned long )((curr->w_string + 256) - 1)) {
    {
#line 1611
    PrintFlush();
    }
  }
#line 1612
  tmp = curr->w_stringp;
#line 1612
  (curr->w_stringp) ++;
#line 1612
  *tmp = (char )c;
#line 1613
  return;
}
}
#line 1615 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void PrintFlush(void) 
{ 
  char *bp ;
  int len ;
  int r ;
  int *tmp ;

  {
#line 1618
  display = curr->w_pdisplay;
#line 1619
  if (display) {
#line 1619
    if (printcmd) {
#line 1621
      bp = curr->w_string;
#line 1622
      len = (int )(curr->w_stringp - curr->w_string);
      {
#line 1624
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1624
        if (len) {
#line 1624
          if (! (display->d_printfd >= 0)) {
#line 1624
            goto while_break;
          }
        } else {
#line 1624
          goto while_break;
        }
        {
#line 1626
        r = write(display->d_printfd, (void const   *)bp, (size_t )len);
        }
#line 1627
        if (r <= 0) {
          {
#line 1629
          tmp = __errno_location();
#line 1629
          WMsg(curr, *tmp, (char *)"printing aborted");
#line 1630
          close(display->d_printfd);
#line 1631
          display->d_printfd = -1;
          }
#line 1632
          goto while_break;
        }
#line 1634
        bp += r;
#line 1635
        len -= r;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 1619
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1638
  if (display) {
#line 1638
    if ((unsigned long )curr->w_stringp > (unsigned long )(curr->w_string)) {
      {
#line 1640
      AddCStr(display->d_tcs[73].str);
#line 1641
      AddStrn(curr->w_string, (int )(curr->w_stringp - curr->w_string));
#line 1642
      AddCStr(display->d_tcs[74].str);
#line 1643
      Flush();
      }
    }
  }
#line 1645
  curr->w_stringp = curr->w_string;
#line 1646
  return;
}
}
#line 1649 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
void WNewAutoFlow(struct win *win , int on ) 
{ 


  {
  {
#line 1654
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1654
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1655
  if (win->w_flow & (1 << 2)) {
#line 1656
    win->w_flow = (1 << 2) | ((1 << 1) | 1) * on;
  } else {
#line 1658
    win->w_flow = (win->w_flow & ~ (1 << 1)) | (1 << 1) * on;
  }
  {
#line 1659
  LSetFlow(& win->w_layer, win->w_flow & 1);
  }
#line 1660
  return;
}
}
#line 1665 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void DesignateCharset(int c , int n ) 
{ 


  {
#line 1669
  curr->w_ss = 0;
#line 1671
  if (c == 0) {
#line 1672
    c = 2;
  }
#line 1674
  if (c == 66) {
#line 1675
    c = 0;
  }
#line 1676
  if (curr->w_charsets[n] != c) {
#line 1678
    curr->w_charsets[n] = c;
#line 1679
    if (curr->w_Charset == n) {
      {
#line 1681
      curr->w_FontL = (char )c;
#line 1682
      curr->w_rend.font = (unsigned char )curr->w_FontL;
#line 1683
      LSetRendition(& curr->w_layer, & curr->w_rend);
      }
    }
#line 1685
    if (curr->w_CharsetR == n) {
#line 1686
      curr->w_FontR = (char )c;
    }
  }
#line 1688
  return;
}
}
#line 1690 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void MapCharset(int n ) 
{ 


  {
#line 1694
  curr->w_ss = 0;
#line 1695
  if (curr->w_Charset != n) {
    {
#line 1697
    curr->w_Charset = n;
#line 1698
    curr->w_FontL = (char )curr->w_charsets[n];
#line 1699
    curr->w_rend.font = (unsigned char )curr->w_FontL;
#line 1700
    LSetRendition(& curr->w_layer, & curr->w_rend);
    }
  }
#line 1702
  return;
}
}
#line 1704 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void MapCharsetR(int n ) 
{ 


  {
#line 1708
  curr->w_ss = 0;
#line 1709
  if (curr->w_CharsetR != n) {
#line 1711
    curr->w_CharsetR = n;
#line 1712
    curr->w_FontR = (char )curr->w_charsets[n];
  }
#line 1714
  curr->w_gr = 1;
#line 1715
  return;
}
}
#line 1719 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void SaveCursor(void) 
{ 


  {
  {
#line 1722
  curr->w_saved = 1;
#line 1723
  curr->w_Saved_x = curr->w_layer.l_x;
#line 1724
  curr->w_Saved_y = curr->w_layer.l_y;
#line 1725
  curr->w_SavedRend = curr->w_rend;
#line 1727
  curr->w_SavedCharset = curr->w_Charset;
#line 1728
  curr->w_SavedCharsetR = curr->w_CharsetR;
#line 1729
  bcopy((void const   *)((char *)(curr->w_charsets)), (void *)((char *)(curr->w_SavedCharsets)),
        (size_t )(4UL * sizeof(int )));
  }
#line 1732
  return;
}
}
#line 1734 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void RestoreCursor(void) 
{ 


  {
#line 1737
  if (! curr->w_saved) {
#line 1738
    return;
  }
  {
#line 1739
  LGotoPos(& curr->w_layer, curr->w_Saved_x, curr->w_Saved_y);
#line 1740
  curr->w_layer.l_x = curr->w_Saved_x;
#line 1741
  curr->w_layer.l_y = curr->w_Saved_y;
#line 1742
  curr->w_rend = curr->w_SavedRend;
#line 1744
  bcopy((void const   *)((char *)(curr->w_SavedCharsets)), (void *)((char *)(curr->w_charsets)),
        (size_t )(4UL * sizeof(int )));
#line 1746
  curr->w_Charset = curr->w_SavedCharset;
#line 1747
  curr->w_CharsetR = curr->w_SavedCharsetR;
#line 1748
  curr->w_ss = 0;
#line 1749
  curr->w_FontL = (char )curr->w_charsets[curr->w_Charset];
#line 1750
  curr->w_FontR = (char )curr->w_charsets[curr->w_CharsetR];
#line 1752
  LSetRendition(& curr->w_layer, & curr->w_rend);
  }
#line 1753
  return;
}
}
#line 1755 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void BackSpace(void) 
{ 


  {
#line 1758
  if (curr->w_layer.l_x > 0) {
#line 1760
    (curr->w_layer.l_x) --;
  } else
#line 1762
  if (curr->w_wrap) {
#line 1762
    if (curr->w_layer.l_y > 0) {
#line 1764
      curr->w_layer.l_x = cols - 1;
#line 1765
      (curr->w_layer.l_y) --;
    }
  }
  {
#line 1767
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
#line 1768
  return;
}
}
#line 1770 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void Return(void) 
{ 


  {
#line 1773
  if (curr->w_layer.l_x == 0) {
#line 1774
    return;
  }
  {
#line 1775
  curr->w_layer.l_x = 0;
#line 1776
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
#line 1777
  return;
}
}
#line 1779 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void LineFeed(int out_mode ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1784
  if (out_mode) {
#line 1785
    curr->w_layer.l_x = 0;
  }
#line 1786
  if (curr->w_layer.l_y != curr->w_bot) {
#line 1788
    if (curr->w_layer.l_y < rows - 1) {
#line 1789
      (curr->w_layer.l_y) ++;
    }
    {
#line 1790
    LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
    }
#line 1791
    return;
  }
#line 1793
  if (curr->w_autoaka > 1) {
#line 1794
    (curr->w_autoaka) --;
  }
#line 1795
  if (curr->w_bce) {
#line 1795
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1795
      tmp = 256;
    } else {
#line 1795
      tmp = 0;
    }
#line 1795
    tmp___0 = (((int )curr->w_rend.color & 240) >> 4) | tmp;
  } else {
#line 1795
    tmp___0 = 0;
  }
  {
#line 1795
  MScrollV(curr, 1, curr->w_top, curr->w_bot, tmp___0);
  }
#line 1796
  if (curr->w_bce) {
#line 1796
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1796
      tmp___1 = 256;
    } else {
#line 1796
      tmp___1 = 0;
    }
#line 1796
    tmp___2 = (((int )curr->w_rend.color & 240) >> 4) | tmp___1;
  } else {
#line 1796
    tmp___2 = 0;
  }
  {
#line 1796
  LScrollV(& curr->w_layer, 1, curr->w_top, curr->w_bot, tmp___2);
#line 1797
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
#line 1798
  return;
}
}
#line 1800 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void ReverseLineFeed(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1803
  if (curr->w_layer.l_y == curr->w_top) {
#line 1805
    if (curr->w_bce) {
#line 1805
      if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1805
        tmp = 256;
      } else {
#line 1805
        tmp = 0;
      }
#line 1805
      tmp___0 = (((int )curr->w_rend.color & 240) >> 4) | tmp;
    } else {
#line 1805
      tmp___0 = 0;
    }
    {
#line 1805
    MScrollV(curr, -1, curr->w_top, curr->w_bot, tmp___0);
    }
#line 1806
    if (curr->w_bce) {
#line 1806
      if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1806
        tmp___1 = 256;
      } else {
#line 1806
        tmp___1 = 0;
      }
#line 1806
      tmp___2 = (((int )curr->w_rend.color & 240) >> 4) | tmp___1;
    } else {
#line 1806
      tmp___2 = 0;
    }
    {
#line 1806
    LScrollV(& curr->w_layer, -1, curr->w_top, curr->w_bot, tmp___2);
#line 1807
    LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
    }
  } else
#line 1809
  if (curr->w_layer.l_y > 0) {
    {
#line 1810
    CursorUp(1);
    }
  }
#line 1811
  return;
}
}
#line 1813 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void InsertChar(int n ) 
{ 
  register int y ;
  register int x ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1817
  y = curr->w_layer.l_y;
#line 1817
  x = curr->w_layer.l_x;
#line 1819
  if (n <= 0) {
#line 1820
    return;
  }
#line 1821
  if (x == cols) {
#line 1822
    x --;
  }
  {
#line 1823
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1823
    bcopy((void const   *)((char *)(curr->w_mlines + y)->image), (void *)((char *)mline_old.image),
          (size_t )cols);
#line 1823
    bcopy((void const   *)((char *)(curr->w_mlines + y)->attr), (void *)((char *)mline_old.attr),
          (size_t )cols);
#line 1823
    bcopy((void const   *)((char *)(curr->w_mlines + y)->font), (void *)((char *)mline_old.font),
          (size_t )cols);
#line 1823
    bcopy((void const   *)((char *)(curr->w_mlines + y)->color), (void *)((char *)mline_old.color),
          (size_t )cols);
    }
#line 1823
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1824
  if (curr->w_bce) {
#line 1824
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1824
      tmp = 256;
    } else {
#line 1824
      tmp = 0;
    }
#line 1824
    tmp___0 = (((int )curr->w_rend.color & 240) >> 4) | tmp;
  } else {
#line 1824
    tmp___0 = 0;
  }
  {
#line 1824
  MScrollH(curr, - n, y, x, curr->w_layer.l_width - 1, tmp___0);
  }
#line 1825
  if (curr->w_bce) {
#line 1825
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1825
      tmp___1 = 256;
    } else {
#line 1825
      tmp___1 = 0;
    }
#line 1825
    tmp___2 = (((int )curr->w_rend.color & 240) >> 4) | tmp___1;
  } else {
#line 1825
    tmp___2 = 0;
  }
  {
#line 1825
  LScrollH(& curr->w_layer, - n, y, x, curr->w_layer.l_width - 1, tmp___2, & mline_old);
#line 1826
  LGotoPos(& curr->w_layer, x, y);
  }
#line 1827
  return;
}
}
#line 1829 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void DeleteChar(int n ) 
{ 
  register int y ;
  register int x ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1833
  y = curr->w_layer.l_y;
#line 1833
  x = curr->w_layer.l_x;
#line 1835
  if (x == cols) {
#line 1836
    x --;
  }
  {
#line 1837
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1837
    bcopy((void const   *)((char *)(curr->w_mlines + y)->image), (void *)((char *)mline_old.image),
          (size_t )cols);
#line 1837
    bcopy((void const   *)((char *)(curr->w_mlines + y)->attr), (void *)((char *)mline_old.attr),
          (size_t )cols);
#line 1837
    bcopy((void const   *)((char *)(curr->w_mlines + y)->font), (void *)((char *)mline_old.font),
          (size_t )cols);
#line 1837
    bcopy((void const   *)((char *)(curr->w_mlines + y)->color), (void *)((char *)mline_old.color),
          (size_t )cols);
    }
#line 1837
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1838
  if (curr->w_bce) {
#line 1838
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1838
      tmp = 256;
    } else {
#line 1838
      tmp = 0;
    }
#line 1838
    tmp___0 = (((int )curr->w_rend.color & 240) >> 4) | tmp;
  } else {
#line 1838
    tmp___0 = 0;
  }
  {
#line 1838
  MScrollH(curr, n, y, x, curr->w_layer.l_width - 1, tmp___0);
  }
#line 1839
  if (curr->w_bce) {
#line 1839
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1839
      tmp___1 = 256;
    } else {
#line 1839
      tmp___1 = 0;
    }
#line 1839
    tmp___2 = (((int )curr->w_rend.color & 240) >> 4) | tmp___1;
  } else {
#line 1839
    tmp___2 = 0;
  }
  {
#line 1839
  LScrollH(& curr->w_layer, n, y, x, curr->w_layer.l_width - 1, tmp___2, & mline_old);
#line 1840
  LGotoPos(& curr->w_layer, x, y);
  }
#line 1841
  return;
}
}
#line 1843 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void DeleteLine(int n ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1847
  if (curr->w_layer.l_y < curr->w_top) {
#line 1848
    return;
  } else
#line 1847
  if (curr->w_layer.l_y > curr->w_bot) {
#line 1848
    return;
  }
#line 1849
  if (n > (curr->w_bot - curr->w_layer.l_y) + 1) {
#line 1850
    n = (curr->w_bot - curr->w_layer.l_y) + 1;
  }
#line 1851
  if (curr->w_bce) {
#line 1851
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1851
      tmp = 256;
    } else {
#line 1851
      tmp = 0;
    }
#line 1851
    tmp___0 = (((int )curr->w_rend.color & 240) >> 4) | tmp;
  } else {
#line 1851
    tmp___0 = 0;
  }
  {
#line 1851
  MScrollV(curr, n, curr->w_layer.l_y, curr->w_bot, tmp___0);
  }
#line 1852
  if (curr->w_bce) {
#line 1852
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1852
      tmp___1 = 256;
    } else {
#line 1852
      tmp___1 = 0;
    }
#line 1852
    tmp___2 = (((int )curr->w_rend.color & 240) >> 4) | tmp___1;
  } else {
#line 1852
    tmp___2 = 0;
  }
  {
#line 1852
  LScrollV(& curr->w_layer, n, curr->w_layer.l_y, curr->w_bot, tmp___2);
#line 1853
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
#line 1854
  return;
}
}
#line 1856 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void InsertLine(int n ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1860
  if (curr->w_layer.l_y < curr->w_top) {
#line 1861
    return;
  } else
#line 1860
  if (curr->w_layer.l_y > curr->w_bot) {
#line 1861
    return;
  }
#line 1862
  if (n > (curr->w_bot - curr->w_layer.l_y) + 1) {
#line 1863
    n = (curr->w_bot - curr->w_layer.l_y) + 1;
  }
#line 1864
  if (curr->w_bce) {
#line 1864
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1864
      tmp = 256;
    } else {
#line 1864
      tmp = 0;
    }
#line 1864
    tmp___0 = (((int )curr->w_rend.color & 240) >> 4) | tmp;
  } else {
#line 1864
    tmp___0 = 0;
  }
  {
#line 1864
  MScrollV(curr, - n, curr->w_layer.l_y, curr->w_bot, tmp___0);
  }
#line 1865
  if (curr->w_bce) {
#line 1865
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1865
      tmp___1 = 256;
    } else {
#line 1865
      tmp___1 = 0;
    }
#line 1865
    tmp___2 = (((int )curr->w_rend.color & 240) >> 4) | tmp___1;
  } else {
#line 1865
    tmp___2 = 0;
  }
  {
#line 1865
  LScrollV(& curr->w_layer, - n, curr->w_layer.l_y, curr->w_bot, tmp___2);
#line 1866
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
#line 1867
  return;
}
}
#line 1869 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void ScrollRegion(int n ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1873
  if (curr->w_bce) {
#line 1873
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1873
      tmp = 256;
    } else {
#line 1873
      tmp = 0;
    }
#line 1873
    tmp___0 = (((int )curr->w_rend.color & 240) >> 4) | tmp;
  } else {
#line 1873
    tmp___0 = 0;
  }
  {
#line 1873
  MScrollV(curr, n, curr->w_top, curr->w_bot, tmp___0);
  }
#line 1874
  if (curr->w_bce) {
#line 1874
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1874
      tmp___1 = 256;
    } else {
#line 1874
      tmp___1 = 0;
    }
#line 1874
    tmp___2 = (((int )curr->w_rend.color & 240) >> 4) | tmp___1;
  } else {
#line 1874
    tmp___2 = 0;
  }
  {
#line 1874
  LScrollV(& curr->w_layer, n, curr->w_top, curr->w_bot, tmp___2);
#line 1875
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
#line 1876
  return;
}
}
#line 1879 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void ForwardTab(void) 
{ 
  register int x ;

  {
#line 1882
  x = curr->w_layer.l_x;
#line 1884
  if (x == cols) {
    {
#line 1886
    LineFeed(1);
#line 1887
    x = 0;
    }
  }
#line 1889
  if (*(curr->w_tabs + x)) {
#line 1889
    if (x < cols - 1) {
#line 1890
      x ++;
    }
  }
  {
#line 1891
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1891
    if (x < cols - 1) {
#line 1891
      if (! (! *(curr->w_tabs + x))) {
#line 1891
        goto while_break;
      }
    } else {
#line 1891
      goto while_break;
    }
#line 1892
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1893
  curr->w_layer.l_x = x;
#line 1894
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
#line 1895
  return;
}
}
#line 1897 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void BackwardTab(void) 
{ 
  register int x ;

  {
#line 1900
  x = curr->w_layer.l_x;
#line 1902
  if (*(curr->w_tabs + x)) {
#line 1902
    if (x > 0) {
#line 1903
      x --;
    }
  }
  {
#line 1904
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1904
    if (x > 0) {
#line 1904
      if (! (! *(curr->w_tabs + x))) {
#line 1904
        goto while_break;
      }
    } else {
#line 1904
      goto while_break;
    }
#line 1905
    x --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1906
  curr->w_layer.l_x = x;
#line 1907
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
#line 1908
  return;
}
}
#line 1910 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void ClearScreen(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1913
  if (curr->w_bce) {
#line 1913
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1913
      tmp = 256;
    } else {
#line 1913
      tmp = 0;
    }
#line 1913
    tmp___0 = (((int )curr->w_rend.color & 240) >> 4) | tmp;
  } else {
#line 1913
    tmp___0 = 0;
  }
  {
#line 1913
  LClearArea(& curr->w_layer, 0, 0, curr->w_layer.l_width - 1, curr->w_layer.l_height - 1,
             tmp___0, 1);
  }
#line 1915
  if (curr->w_bce) {
#line 1915
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1915
      tmp___1 = 256;
    } else {
#line 1915
      tmp___1 = 0;
    }
#line 1915
    tmp___2 = (((int )curr->w_rend.color & 240) >> 4) | tmp___1;
  } else {
#line 1915
    tmp___2 = 0;
  }
  {
#line 1915
  MScrollV(curr, curr->w_layer.l_height, 0, curr->w_layer.l_height - 1, tmp___2);
  }
#line 1919
  return;
}
}
#line 1921 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void ClearFromBOS(void) 
{ 
  register int y ;
  register int x ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1924
  y = curr->w_layer.l_y;
#line 1924
  x = curr->w_layer.l_x;
#line 1926
  if (curr->w_bce) {
#line 1926
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1926
      tmp = 256;
    } else {
#line 1926
      tmp = 0;
    }
#line 1926
    tmp___0 = (((int )curr->w_rend.color & 240) >> 4) | tmp;
  } else {
#line 1926
    tmp___0 = 0;
  }
  {
#line 1926
  LClearArea(& curr->w_layer, 0, 0, x, y, tmp___0, 1);
  }
#line 1927
  if (curr->w_bce) {
#line 1927
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1927
      tmp___1 = 256;
    } else {
#line 1927
      tmp___1 = 0;
    }
#line 1927
    tmp___2 = (((int )curr->w_rend.color & 240) >> 4) | tmp___1;
  } else {
#line 1927
    tmp___2 = 0;
  }
  {
#line 1927
  MClearArea(curr, 0, 0, x, y, tmp___2);
#line 1928
  RestorePosRendition();
  }
#line 1929
  return;
}
}
#line 1931 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void ClearToEOS(void) 
{ 
  register int y ;
  register int x ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1934
  y = curr->w_layer.l_y;
#line 1934
  x = curr->w_layer.l_x;
#line 1936
  if (x == 0) {
#line 1936
    if (y == 0) {
      {
#line 1938
      ClearScreen();
#line 1939
      RestorePosRendition();
      }
#line 1940
      return;
    }
  }
#line 1942
  if (curr->w_bce) {
#line 1942
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1942
      tmp = 256;
    } else {
#line 1942
      tmp = 0;
    }
#line 1942
    tmp___0 = (((int )curr->w_rend.color & 240) >> 4) | tmp;
  } else {
#line 1942
    tmp___0 = 0;
  }
  {
#line 1942
  LClearArea(& curr->w_layer, x, y, cols - 1, rows - 1, tmp___0, 1);
  }
#line 1943
  if (curr->w_bce) {
#line 1943
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1943
      tmp___1 = 256;
    } else {
#line 1943
      tmp___1 = 0;
    }
#line 1943
    tmp___2 = (((int )curr->w_rend.color & 240) >> 4) | tmp___1;
  } else {
#line 1943
    tmp___2 = 0;
  }
  {
#line 1943
  MClearArea(curr, x, y, cols - 1, rows - 1, tmp___2);
#line 1944
  RestorePosRendition();
  }
#line 1945
  return;
}
}
#line 1947 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void ClearLineRegion(int from , int to ) 
{ 
  register int y ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1951
  y = curr->w_layer.l_y;
#line 1952
  if (curr->w_bce) {
#line 1952
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1952
      tmp = 256;
    } else {
#line 1952
      tmp = 0;
    }
#line 1952
    tmp___0 = (((int )curr->w_rend.color & 240) >> 4) | tmp;
  } else {
#line 1952
    tmp___0 = 0;
  }
  {
#line 1952
  LClearArea(& curr->w_layer, from, y, to, y, tmp___0, 1);
  }
#line 1953
  if (curr->w_bce) {
#line 1953
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1953
      tmp___1 = 256;
    } else {
#line 1953
      tmp___1 = 0;
    }
#line 1953
    tmp___2 = (((int )curr->w_rend.color & 240) >> 4) | tmp___1;
  } else {
#line 1953
    tmp___2 = 0;
  }
  {
#line 1953
  MClearArea(curr, from, y, to, y, tmp___2);
#line 1954
  RestorePosRendition();
  }
#line 1955
  return;
}
}
#line 1957 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void CursorRight(int n ) 
{ 
  register int x ;
  int tmp ;

  {
#line 1961
  x = curr->w_layer.l_x;
#line 1963
  if (x == cols) {
    {
#line 1965
    LineFeed(1);
#line 1966
    x = 0;
    }
  }
#line 1968
  tmp = curr->w_layer.l_x + n;
#line 1968
  curr->w_layer.l_x = tmp;
#line 1968
  if (tmp >= cols) {
#line 1969
    curr->w_layer.l_x = cols - 1;
  }
  {
#line 1970
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
#line 1971
  return;
}
}
#line 1973 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void CursorUp(int n ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1977
  if (curr->w_layer.l_y < curr->w_top) {
#line 1979
    tmp = curr->w_layer.l_y - n;
#line 1979
    curr->w_layer.l_y = tmp;
#line 1979
    if (tmp < 0) {
#line 1980
      curr->w_layer.l_y = 0;
    }
  } else {
#line 1983
    tmp___0 = curr->w_layer.l_y - n;
#line 1983
    curr->w_layer.l_y = tmp___0;
#line 1983
    if (tmp___0 < curr->w_top) {
#line 1984
      curr->w_layer.l_y = curr->w_top;
    }
  }
  {
#line 1985
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
#line 1986
  return;
}
}
#line 1988 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void CursorDown(int n ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1992
  if (curr->w_layer.l_y > curr->w_bot) {
#line 1994
    tmp = curr->w_layer.l_y + n;
#line 1994
    curr->w_layer.l_y = tmp;
#line 1994
    if (tmp > rows - 1) {
#line 1995
      curr->w_layer.l_y = rows - 1;
    }
  } else {
#line 1998
    tmp___0 = curr->w_layer.l_y + n;
#line 1998
    curr->w_layer.l_y = tmp___0;
#line 1998
    if (tmp___0 > curr->w_bot) {
#line 1999
      curr->w_layer.l_y = curr->w_bot;
    }
  }
  {
#line 2000
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
#line 2001
  return;
}
}
#line 2003 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void CursorLeft(int n ) 
{ 
  int tmp ;

  {
#line 2007
  tmp = curr->w_layer.l_x - n;
#line 2007
  curr->w_layer.l_x = tmp;
#line 2007
  if (tmp < 0) {
#line 2008
    curr->w_layer.l_x = 0;
  }
  {
#line 2009
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
#line 2010
  return;
}
}
#line 2012 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void ASetMode(int on ) 
{ 
  register int i ;
  struct display *olddisplay ;
  struct canvas *cv ;
  int tmp ;

  {
#line 2018
  i = 0;
  {
#line 2018
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2018
    if (! (i < curr->w_NumArgs)) {
#line 2018
      goto while_break;
    }
    {
#line 2023
    if (curr->w_args[i] == 4) {
#line 2023
      goto case_4;
    }
#line 2028
    if (curr->w_args[i] == 20) {
#line 2028
      goto case_20;
    }
#line 2031
    if (curr->w_args[i] == 34) {
#line 2031
      goto case_34;
    }
#line 2035
    goto switch_default;
    case_4: /* CIL Label */ 
#line 2024
    curr->w_insert = on;
    {
#line 2025
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2025
      olddisplay = display;
#line 2025
      display = displays;
      {
#line 2025
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2025
        if (! display) {
#line 2025
          goto while_break___1;
        }
#line 2025
        cv = display->d_cvlist;
        {
#line 2025
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2025
          if (! cv) {
#line 2025
            goto while_break___2;
          }
#line 2025
          if ((unsigned long )cv->c_layer == (unsigned long )(& curr->w_layer)) {
#line 2025
            goto while_break___2;
          }
#line 2025
          cv = cv->c_next;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 2025
        if ((unsigned long )cv == (unsigned long )((struct canvas *)0)) {
#line 2025
          goto __Cont;
        }
        {
#line 2025
        InsertMode(on);
        }
        __Cont: /* CIL Label */ 
#line 2025
        display = display->d_next;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2025
      display = olddisplay;
#line 2025
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2026
    goto switch_break;
    case_20: /* CIL Label */ 
#line 2029
    curr->w_autolf = on;
#line 2030
    goto switch_break;
    case_34: /* CIL Label */ 
#line 2032
    curr->w_curvvis = ! on;
#line 2033
    if (curr->w_curinv) {
#line 2033
      tmp = -1;
    } else {
#line 2033
      tmp = curr->w_curvvis;
    }
    {
#line 2033
    LCursorVisibility(& curr->w_layer, tmp);
    }
#line 2034
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2036
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2018
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2039
  return;
}
}
#line 2041 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static char rendlist[28]  = 
#line 2041
  {      (char )(~ ((1 << 6) - 1)),      (char )(1 << 2),      (char)1,      (char )(1 << 4), 
        (char )(1 << 1),      (char )(1 << 5),      (char)0,      (char )(1 << 3), 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char )(~ (((1 << 2) | (1 << 4)) | 1)),      (char )(~ (1 << 4)), 
        (char )(~ (1 << 1)),      (char )(~ (1 << 5)),      (char)0,      (char )(~ (1 << 3))};
#line 2048 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void SelectRendition(void) 
{ 
  register int j ;
  register int i ;
  register int a ;
  register int c ;
  int jj ;
  int tmp ;

  {
#line 2052
  i = 0;
#line 2052
  a = (int )curr->w_rend.attr;
#line 2052
  c = (int )curr->w_rend.color;
  {
#line 2060
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2062
    j = curr->w_args[i];
#line 2064
    if (j == 38) {
#line 2064
      goto _L;
    } else
#line 2064
    if (j == 48) {
      _L: /* CIL Label */ 
#line 2064
      if (i + 2 < curr->w_NumArgs) {
#line 2064
        if (curr->w_args[i + 1] == 5) {
#line 2068
          i += 2;
#line 2069
          jj = curr->w_args[i];
#line 2070
          if (jj < 0) {
#line 2071
            goto __Cont;
          } else
#line 2070
          if (jj > 255) {
#line 2071
            goto __Cont;
          }
          {
#line 2096
          tmp = color256to16(jj);
#line 2096
          jj = tmp + 30;
          }
#line 2097
          if (jj >= 38) {
#line 2098
            jj += 52;
          }
#line 2099
          if (j == 38) {
#line 2099
            j = jj;
          } else {
#line 2099
            j = jj + 10;
          }
        }
      }
    }
#line 2103
    if (j == 0) {
#line 2104
      a &= 191;
    } else
#line 2103
    if (j >= 30) {
#line 2103
      if (j <= 39) {
#line 2103
        if (j != 38) {
#line 2104
          a &= 191;
        }
      }
    }
#line 2105
    if (j == 0) {
#line 2106
      a &= 127;
    } else
#line 2105
    if (j >= 40) {
#line 2105
      if (j <= 49) {
#line 2105
        if (j != 48) {
#line 2106
          a &= 127;
        }
      }
    }
#line 2107
    if (j >= 90) {
#line 2107
      if (j <= 97) {
#line 2108
        a |= 64;
      }
    }
#line 2109
    if (j >= 100) {
#line 2109
      if (j <= 107) {
#line 2110
        a |= 128;
      }
    }
#line 2112
    if (j >= 90) {
#line 2112
      if (j <= 97) {
#line 2113
        j -= 60;
      }
    }
#line 2114
    if (j >= 100) {
#line 2114
      if (j <= 107) {
#line 2115
        j -= 60;
      }
    }
#line 2116
    if (j >= 30) {
#line 2116
      if (j <= 39) {
#line 2116
        if (j != 38) {
#line 2117
          c = (c & 240) | ((j - 30) ^ 9);
        } else {
#line 2116
          goto _L___1;
        }
      } else {
#line 2116
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 2118
    if (j >= 40) {
#line 2118
      if (j <= 49) {
#line 2118
        if (j != 48) {
#line 2119
          c = (c & 15) | (((j - 40) ^ 9) << 4);
        }
      }
    }
#line 2120
    if (j == 0) {
#line 2121
      c = 0;
    }
#line 2129
    if (j < 0) {
#line 2130
      goto __Cont;
    } else
#line 2129
    if (j >= (int )(sizeof(rendlist) / sizeof(rendlist[0]))) {
#line 2130
      goto __Cont;
    }
#line 2131
    j = (int )rendlist[j];
#line 2132
    if (j & (1 << 6)) {
#line 2133
      a &= j;
    } else {
#line 2135
      a |= j;
    }
    __Cont: /* CIL Label */ 
#line 2060
    i ++;
#line 2060
    if (! (i < curr->w_NumArgs)) {
#line 2060
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2138
  curr->w_rend.attr = (unsigned char )a;
#line 2140
  curr->w_rend.color = (unsigned char )c;
#line 2145
  LSetRendition(& curr->w_layer, & curr->w_rend);
  }
#line 2146
  return;
}
}
#line 2148 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void FillWithEs(void) 
{ 
  register int i ;
  register unsigned char *p ;
  register unsigned char *ep ;
  int tmp ;
  unsigned char *tmp___0 ;

  {
  {
#line 2154
  LClearAll(& curr->w_layer, 1);
#line 2155
  tmp = 0;
#line 2155
  curr->w_layer.l_x = tmp;
#line 2155
  curr->w_layer.l_y = tmp;
#line 2156
  i = 0;
  }
  {
#line 2156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2156
    if (! (i < rows)) {
#line 2156
      goto while_break;
    }
    {
#line 2158
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2158
      bclear((char *)(curr->w_mlines + i)->image + 0, cols + 1);
      }
#line 2158
      if ((unsigned long )(curr->w_mlines + i)->attr != (unsigned long )null) {
        {
#line 2158
        bzero((void *)((char *)(curr->w_mlines + i)->attr + 0), (size_t )(cols + 1));
        }
      }
#line 2158
      if ((unsigned long )(curr->w_mlines + i)->font != (unsigned long )null) {
        {
#line 2158
        bzero((void *)((char *)(curr->w_mlines + i)->font + 0), (size_t )(cols + 1));
        }
      }
#line 2158
      if ((unsigned long )(curr->w_mlines + i)->color != (unsigned long )null) {
        {
#line 2158
        bzero((void *)((char *)(curr->w_mlines + i)->color + 0), (size_t )(cols + 1));
        }
      }
#line 2158
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2159
    p = (curr->w_mlines + i)->image;
#line 2160
    ep = p + cols;
    {
#line 2161
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2161
      if (! ((unsigned long )p < (unsigned long )ep)) {
#line 2161
        goto while_break___1;
      }
#line 2162
      tmp___0 = p;
#line 2162
      p ++;
#line 2162
      *tmp___0 = (unsigned char )'E';
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2156
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2164
  LRefreshAll(& curr->w_layer, 1);
  }
#line 2165
  return;
}
}
#line 2174 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
void ChangeAKA(struct win *p , char *s , int l ) 
{ 
  int i ;
  int c ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
#line 2182
  i = 0;
  {
#line 2182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2182
    if (! (l > 0)) {
#line 2182
      goto while_break;
    }
#line 2184
    if ((unsigned long )(p->w_akachange + i) == (unsigned long )((p->w_akabuf + sizeof(p->w_akabuf)) - 1)) {
#line 2185
      goto while_break;
    }
#line 2186
    tmp = s;
#line 2186
    s ++;
#line 2186
    c = (int )((unsigned char )*tmp);
#line 2187
    if (c == 0) {
#line 2188
      goto while_break;
    }
#line 2189
    if (c < 32) {
#line 2190
      goto __Cont;
    } else
#line 2189
    if (c == 127) {
#line 2190
      goto __Cont;
    } else
#line 2189
    if (c >= 128) {
#line 2189
      if (c < 160) {
#line 2189
        if (p->w_c1) {
#line 2190
          goto __Cont;
        }
      }
    }
#line 2191
    tmp___0 = i;
#line 2191
    i ++;
#line 2191
    *(p->w_akachange + tmp___0) = (char )c;
    __Cont: /* CIL Label */ 
#line 2182
    l --;
  }
  while_break: /* CIL Label */ ;
  }
#line 2193
  *(p->w_akachange + i) = (char)0;
#line 2194
  p->w_title = p->w_akachange;
#line 2195
  if ((unsigned long )p->w_akachange != (unsigned long )(p->w_akabuf)) {
#line 2196
    if ((int )*(p->w_akachange + 0) == 0) {
      {
#line 2197
      tmp___1 = strlen((char const   *)(p->w_akabuf));
#line 2197
      p->w_title = (p->w_akabuf + tmp___1) + 1;
      }
    } else
#line 2196
    if ((int )*(p->w_akachange + -1) == 58) {
      {
#line 2197
      tmp___1 = strlen((char const   *)(p->w_akabuf));
#line 2197
      p->w_title = (p->w_akabuf + tmp___1) + 1;
      }
    }
  }
  {
#line 2198
  WindowChanged(p, 't');
#line 2199
  WindowChanged((struct win *)0, 'w');
#line 2200
  WindowChanged((struct win *)0, 'W');
  }
#line 2201
  return;
}
}
#line 2203 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void FindAKA(void) 
{ 
  register unsigned char *cp ;
  register unsigned char *line ;
  register struct win *wp ;
  register int len ;
  size_t tmp ;
  int y ;
  int tmp___0 ;
  unsigned char *tmp___1 ;

  {
  {
#line 2207
  wp = curr;
#line 2208
  tmp = strlen((char const   *)(wp->w_akabuf));
#line 2208
  len = (int )tmp;
  }
#line 2211
  if (wp->w_autoaka > 0) {
#line 2211
    if (wp->w_autoaka <= wp->w_layer.l_height) {
#line 2211
      y = wp->w_autoaka - 1;
    } else {
#line 2211
      y = wp->w_layer.l_y;
    }
  } else {
#line 2211
    y = wp->w_layer.l_y;
  }
#line 2212
  cols = wp->w_layer.l_width;
  try_line: 
#line 2214
  line = (wp->w_mlines + y)->image;
#line 2214
  cp = line;
#line 2215
  if (wp->w_autoaka > 0) {
#line 2215
    if ((int )wp->w_akabuf[0] != 0) {
      {
#line 2217
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2219
        if (cp - line >= (long )(cols - len)) {
#line 2221
          y ++;
#line 2221
          if (y == wp->w_autoaka) {
#line 2221
            if (y < rows) {
#line 2222
              goto try_line;
            }
          }
#line 2223
          return;
        }
        {
#line 2225
        tmp___0 = strncmp((char const   *)((char *)cp), (char const   *)(wp->w_akabuf),
                          (size_t )len);
        }
#line 2225
        if (tmp___0 == 0) {
#line 2226
          goto while_break;
        }
#line 2227
        cp ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 2229
      cp += len;
    }
  }
#line 2231
  len = (int )((long )cols - (cp - line));
  {
#line 2231
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2231
    if (len) {
#line 2231
      if (! ((int )*cp == 32)) {
#line 2231
        goto while_break___0;
      }
    } else {
#line 2231
      goto while_break___0;
    }
#line 2231
    len --;
#line 2231
    cp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2233
  if (len) {
#line 2235
    if (wp->w_autoaka > 0) {
#line 2235
      if ((int )*cp == 33) {
#line 2236
        wp->w_autoaka = -1;
      } else
#line 2235
      if ((int )*cp == 37) {
#line 2236
        wp->w_autoaka = -1;
      } else
#line 2235
      if ((int )*cp == 94) {
#line 2236
        wp->w_autoaka = -1;
      } else {
#line 2238
        wp->w_autoaka = 0;
      }
    } else {
#line 2238
      wp->w_autoaka = 0;
    }
#line 2239
    line = cp;
    {
#line 2240
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2240
      if (len) {
#line 2240
        if (! ((int )*cp != 32)) {
#line 2240
          goto while_break___1;
        }
      } else {
#line 2240
        goto while_break___1;
      }
#line 2242
      tmp___1 = cp;
#line 2242
      cp ++;
#line 2242
      if ((int )*tmp___1 == 47) {
#line 2243
        line = cp;
      }
#line 2244
      len --;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2246
    ChangeAKA(wp, (char *)line, (int )(cp - line));
    }
  } else {
#line 2249
    wp->w_autoaka = 0;
  }
#line 2250
  return;
}
}
#line 2252 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void RestorePosRendition(void) 
{ 


  {
  {
#line 2255
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
#line 2256
  LSetRendition(& curr->w_layer, & curr->w_rend);
  }
#line 2257
  return;
}
}
#line 2260 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void Report(char *fmt , int n1 , int n2 ) 
{ 
  register int len ;
  char rbuf[40] ;
  size_t tmp ;

  {
  {
#line 2268
  sprintf((char */* __restrict  */)(rbuf), (char const   */* __restrict  */)fmt, n1,
          n2);
#line 2269
  tmp = strlen((char const   *)(rbuf));
#line 2269
  len = (int )tmp;
  }
#line 2271
  if ((unsigned long )((unsigned int )(curr->w_inlen + len)) <= sizeof(curr->w_inbuf)) {
    {
#line 2273
    bcopy((void const   *)(rbuf), (void *)(curr->w_inbuf + curr->w_inlen), (size_t )len);
#line 2274
    curr->w_inlen += len;
    }
  }
#line 2276
  return;
}
}
#line 2291 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void MFixLine(struct win *p , int y , struct mchar *mc ) 
{ 
  struct mline *ml ;
  unsigned char tmp ;
  unsigned char *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned char tmp___6 ;
  unsigned char *tmp___7 ;
  void *tmp___8 ;
  unsigned char tmp___9 ;
  unsigned char *tmp___10 ;
  void *tmp___11 ;

  {
#line 2297
  ml = p->w_mlines + y;
#line 2298
  if (mc->attr) {
#line 2298
    if ((unsigned long )ml->attr == (unsigned long )null) {
      {
#line 2300
      tmp___1 = malloc((size_t )(p->w_layer.l_width + 1));
#line 2300
      tmp___0 = (unsigned char *)tmp___1;
#line 2300
      ml->attr = tmp___0;
      }
#line 2300
      if ((unsigned long )tmp___0 == (unsigned long )((unsigned char *)0)) {
        {
#line 2302
        ml->attr = null;
#line 2303
        tmp = (unsigned char)0;
#line 2303
        p->w_rend.attr = tmp;
#line 2303
        mc->attr = tmp;
#line 2304
        WMsg(p, 0, (char *)"Warning: no space for attr - turned off");
        }
      }
      {
#line 2306
      bzero((void *)((char *)ml->attr), (size_t )(p->w_layer.l_width + 1));
      }
    }
  }
#line 2309
  if (mc->font) {
#line 2309
    if ((unsigned long )ml->font == (unsigned long )null) {
      {
#line 2311
      tmp___8 = malloc((size_t )(p->w_layer.l_width + 1));
#line 2311
      tmp___7 = (unsigned char *)tmp___8;
#line 2311
      ml->font = tmp___7;
      }
#line 2311
      if ((unsigned long )tmp___7 == (unsigned long )((unsigned char *)0)) {
#line 2313
        ml->font = null;
#line 2314
        if (p->w_ss) {
#line 2314
          tmp___2 = p->w_ss;
        } else {
#line 2314
          tmp___2 = p->w_Charset;
        }
#line 2314
        tmp___3 = 0;
#line 2314
        p->w_charsets[tmp___2] = tmp___3;
#line 2314
        p->w_FontL = (char )tmp___3;
#line 2315
        if (p->w_ss) {
#line 2315
          tmp___4 = p->w_ss;
        } else {
#line 2315
          tmp___4 = p->w_CharsetR;
        }
        {
#line 2315
        tmp___5 = 0;
#line 2315
        p->w_charsets[tmp___4] = tmp___5;
#line 2315
        p->w_FontR = (char )tmp___5;
#line 2316
        tmp___6 = (unsigned char)0;
#line 2316
        p->w_rend.font = tmp___6;
#line 2316
        mc->font = tmp___6;
#line 2317
        WMsg(p, 0, (char *)"Warning: no space for font - turned off");
        }
      }
      {
#line 2319
      bzero((void *)((char *)ml->font), (size_t )(p->w_layer.l_width + 1));
      }
    }
  }
#line 2323
  if (mc->color) {
#line 2323
    if ((unsigned long )ml->color == (unsigned long )null) {
      {
#line 2325
      tmp___11 = malloc((size_t )(p->w_layer.l_width + 1));
#line 2325
      tmp___10 = (unsigned char *)tmp___11;
#line 2325
      ml->color = tmp___10;
      }
#line 2325
      if ((unsigned long )tmp___10 == (unsigned long )((unsigned char *)0)) {
        {
#line 2327
        ml->color = null;
#line 2328
        tmp___9 = (unsigned char)0;
#line 2328
        p->w_rend.color = tmp___9;
#line 2328
        mc->color = tmp___9;
#line 2329
        WMsg(p, 0, (char *)"Warning: no space for color - turned off");
        }
      }
      {
#line 2331
      bzero((void *)((char *)ml->color), (size_t )(p->w_layer.l_width + 1));
      }
    }
  }
#line 2346
  return;
}
}
#line 2370 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void MScrollH(struct win *p , int n , int y , int xs , int xe , int bce ) 
{ 
  struct mline *ml ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 2377
  if (n == 0) {
#line 2378
    return;
  }
#line 2379
  ml = p->w_mlines + y;
#line 2380
  if (p->w_layer.l_encoding == 8) {
#line 2380
    if ((int )*(ml->font + xs) == 255) {
#line 2380
      if ((int )*(ml->image + xs) == 255) {
#line 2380
        tmp = 1;
      } else {
#line 2380
        tmp = 0;
      }
    } else {
#line 2380
      tmp = 0;
    }
#line 2380
    tmp___0 = tmp;
  } else {
#line 2380
    tmp___0 = ((int )*(ml->font + xs) & 224) == 128;
  }
#line 2380
  if (tmp___0) {
#line 2380
    if (xs > 0) {
      {
#line 2380
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2380
        *(ml->image + (xs - 1)) = mchar_blank.image;
#line 2380
        *(ml->attr + (xs - 1)) = mchar_blank.attr;
#line 2380
        *(ml->font + (xs - 1)) = mchar_blank.font;
#line 2380
        *(ml->color + (xs - 1)) = mchar_blank.color;
#line 2380
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 2380
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2380
      *(ml->image + xs) = mchar_blank.image;
#line 2380
      *(ml->attr + xs) = mchar_blank.attr;
#line 2380
      *(ml->font + xs) = mchar_blank.font;
#line 2380
      *(ml->color + xs) = mchar_blank.color;
#line 2380
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 2381
  if (p->w_layer.l_encoding == 8) {
#line 2381
    if ((int )*(ml->font + (xe + 1)) == 255) {
#line 2381
      if ((int )*(ml->image + (xe + 1)) == 255) {
#line 2381
        tmp___1 = 1;
      } else {
#line 2381
        tmp___1 = 0;
      }
    } else {
#line 2381
      tmp___1 = 0;
    }
#line 2381
    tmp___3 = tmp___1;
  } else {
#line 2381
    if (((int )*(ml->font + xe) & 31) != 0) {
#line 2381
      if (((int )*(ml->font + xe) & 224) == 0) {
#line 2381
        tmp___2 = 1;
      } else {
#line 2381
        tmp___2 = 0;
      }
    } else {
#line 2381
      tmp___2 = 0;
    }
#line 2381
    tmp___3 = tmp___2;
  }
#line 2381
  if (tmp___3) {
    {
#line 2381
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2381
      *(ml->image + xe) = mchar_blank.image;
#line 2381
      *(ml->attr + xe) = mchar_blank.attr;
#line 2381
      *(ml->font + xe) = mchar_blank.font;
#line 2381
      *(ml->color + xe) = mchar_blank.color;
#line 2381
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2381
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2381
      *(ml->image + (xe + 1)) = mchar_blank.image;
#line 2381
      *(ml->attr + (xe + 1)) = mchar_blank.attr;
#line 2381
      *(ml->font + (xe + 1)) = mchar_blank.font;
#line 2381
      *(ml->color + (xe + 1)) = mchar_blank.color;
#line 2381
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 2382
  if (n > 0) {
#line 2384
    if ((xe - xs) + 1 > n) {
#line 2386
      if (p->w_layer.l_encoding == 8) {
#line 2386
        if ((int )*(ml->font + (xs + n)) == 255) {
#line 2386
          if ((int )*(ml->image + (xs + n)) == 255) {
#line 2386
            tmp___4 = 1;
          } else {
#line 2386
            tmp___4 = 0;
          }
        } else {
#line 2386
          tmp___4 = 0;
        }
#line 2386
        tmp___5 = tmp___4;
      } else {
#line 2386
        tmp___5 = ((int )*(ml->font + (xs + n)) & 224) == 128;
      }
#line 2386
      if (tmp___5) {
#line 2386
        if (xs + n > 0) {
          {
#line 2386
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 2386
            *(ml->image + ((xs + n) - 1)) = mchar_blank.image;
#line 2386
            *(ml->attr + ((xs + n) - 1)) = mchar_blank.attr;
#line 2386
            *(ml->font + ((xs + n) - 1)) = mchar_blank.font;
#line 2386
            *(ml->color + ((xs + n) - 1)) = mchar_blank.color;
#line 2386
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
        {
#line 2386
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 2386
          *(ml->image + (xs + n)) = mchar_blank.image;
#line 2386
          *(ml->attr + (xs + n)) = mchar_blank.attr;
#line 2386
          *(ml->font + (xs + n)) = mchar_blank.font;
#line 2386
          *(ml->color + (xs + n)) = mchar_blank.color;
#line 2386
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
      {
#line 2387
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 2387
        bcopy((void const   *)((char *)ml->image + (xs + n)), (void *)((char *)ml->image + xs),
              (size_t )(((xe + 1) - xs) - n));
#line 2387
        bcopy((void const   *)((char *)ml->attr + (xs + n)), (void *)((char *)ml->attr + xs),
              (size_t )(((xe + 1) - xs) - n));
#line 2387
        bcopy((void const   *)((char *)ml->font + (xs + n)), (void *)((char *)ml->font + xs),
              (size_t )(((xe + 1) - xs) - n));
#line 2387
        bcopy((void const   *)((char *)ml->color + (xs + n)), (void *)((char *)ml->color + xs),
              (size_t )(((xe + 1) - xs) - n));
        }
#line 2387
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    } else {
#line 2390
      n = (xe - xs) + 1;
    }
    {
#line 2391
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 2391
      bclear((char *)ml->image + ((xe + 1) - n), n);
      }
#line 2391
      if ((unsigned long )ml->attr != (unsigned long )null) {
        {
#line 2391
        bzero((void *)((char *)ml->attr + ((xe + 1) - n)), (size_t )n);
        }
      }
#line 2391
      if ((unsigned long )ml->font != (unsigned long )null) {
        {
#line 2391
        bzero((void *)((char *)ml->font + ((xe + 1) - n)), (size_t )n);
        }
      }
#line 2391
      if ((unsigned long )ml->color != (unsigned long )null) {
        {
#line 2391
        bzero((void *)((char *)ml->color + ((xe + 1) - n)), (size_t )n);
        }
      }
#line 2391
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 2393
    if (bce) {
      {
#line 2394
      MBceLine(p, y, (xe + 1) - n, n, bce);
      }
    }
  } else {
#line 2399
    n = - n;
#line 2400
    if ((xe - xs) + 1 > n) {
#line 2402
      if (p->w_layer.l_encoding == 8) {
#line 2402
        if ((int )*(ml->font + ((xe - n) + 1)) == 255) {
#line 2402
          if ((int )*(ml->image + ((xe - n) + 1)) == 255) {
#line 2402
            tmp___6 = 1;
          } else {
#line 2402
            tmp___6 = 0;
          }
        } else {
#line 2402
          tmp___6 = 0;
        }
#line 2402
        tmp___8 = tmp___6;
      } else {
#line 2402
        if (((int )*(ml->font + (xe - n)) & 31) != 0) {
#line 2402
          if (((int )*(ml->font + (xe - n)) & 224) == 0) {
#line 2402
            tmp___7 = 1;
          } else {
#line 2402
            tmp___7 = 0;
          }
        } else {
#line 2402
          tmp___7 = 0;
        }
#line 2402
        tmp___8 = tmp___7;
      }
#line 2402
      if (tmp___8) {
        {
#line 2402
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 2402
          *(ml->image + (xe - n)) = mchar_blank.image;
#line 2402
          *(ml->attr + (xe - n)) = mchar_blank.attr;
#line 2402
          *(ml->font + (xe - n)) = mchar_blank.font;
#line 2402
          *(ml->color + (xe - n)) = mchar_blank.color;
#line 2402
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 2402
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 2402
          *(ml->image + ((xe - n) + 1)) = mchar_blank.image;
#line 2402
          *(ml->attr + ((xe - n) + 1)) = mchar_blank.attr;
#line 2402
          *(ml->font + ((xe - n) + 1)) = mchar_blank.font;
#line 2402
          *(ml->color + ((xe - n) + 1)) = mchar_blank.color;
#line 2402
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
      }
      {
#line 2403
      while (1) {
        while_continue___9: /* CIL Label */ ;
        {
#line 2403
        bcopy((void const   *)((char *)ml->image + xs), (void *)((char *)ml->image + (xs + n)),
              (size_t )(((xe + 1) - xs) - n));
#line 2403
        bcopy((void const   *)((char *)ml->attr + xs), (void *)((char *)ml->attr + (xs + n)),
              (size_t )(((xe + 1) - xs) - n));
#line 2403
        bcopy((void const   *)((char *)ml->font + xs), (void *)((char *)ml->font + (xs + n)),
              (size_t )(((xe + 1) - xs) - n));
#line 2403
        bcopy((void const   *)((char *)ml->color + xs), (void *)((char *)ml->color + (xs + n)),
              (size_t )(((xe + 1) - xs) - n));
        }
#line 2403
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
    } else {
#line 2406
      n = (xe - xs) + 1;
    }
    {
#line 2407
    while (1) {
      while_continue___10: /* CIL Label */ ;
      {
#line 2407
      bclear((char *)ml->image + xs, n);
      }
#line 2407
      if ((unsigned long )ml->attr != (unsigned long )null) {
        {
#line 2407
        bzero((void *)((char *)ml->attr + xs), (size_t )n);
        }
      }
#line 2407
      if ((unsigned long )ml->font != (unsigned long )null) {
        {
#line 2407
        bzero((void *)((char *)ml->font + xs), (size_t )n);
        }
      }
#line 2407
      if ((unsigned long )ml->color != (unsigned long )null) {
        {
#line 2407
        bzero((void *)((char *)ml->color + xs), (size_t )n);
        }
      }
#line 2407
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 2409
    if (bce) {
      {
#line 2410
      MBceLine(p, y, xs, n, bce);
      }
    }
  }
#line 2413
  return;
}
}
#line 2415 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void MScrollV(struct win *p , int n , int ys , int ye , int bce ) 
{ 
  int i ;
  int cnt1 ;
  int cnt2 ;
  struct mline tmp[256] ;
  struct mline *ml ;

  {
#line 2424
  if (n == 0) {
#line 2425
    return;
  }
#line 2426
  if (n > 0) {
#line 2428
    if (n > 256) {
      {
#line 2430
      MScrollV(p, n - 256, ys, ye, bce);
#line 2431
      n = 256;
      }
    }
#line 2433
    if ((ye - ys) + 1 < n) {
#line 2434
      n = (ye - ys) + 1;
    }
#line 2436
    if (compacthist) {
      {
#line 2438
      ye = MFindUsedLine(p, ye, ys);
      }
#line 2439
      if ((ye - ys) + 1 < n) {
#line 2440
        n = (ye - ys) + 1;
      }
#line 2441
      if (n <= 0) {
#line 2442
        return;
      }
    }
#line 2446
    ml = p->w_mlines + ys;
#line 2447
    i = ys;
    {
#line 2447
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2447
      if (! (i < ys + n)) {
#line 2447
        goto while_break;
      }
#line 2450
      if (ys == p->w_top) {
        {
#line 2451
        WAddLineToHist(p, ml);
        }
      }
#line 2453
      if ((unsigned long )ml->attr != (unsigned long )null) {
        {
#line 2454
        free((void *)ml->attr);
        }
      }
#line 2455
      ml->attr = null;
#line 2457
      if ((unsigned long )ml->font != (unsigned long )null) {
        {
#line 2458
        free((void *)ml->font);
        }
      }
#line 2459
      ml->font = null;
#line 2462
      if ((unsigned long )ml->color != (unsigned long )null) {
        {
#line 2463
        free((void *)ml->color);
        }
      }
      {
#line 2464
      ml->color = null;
#line 2471
      bclear((char *)ml->image, p->w_layer.l_width + 1);
      }
#line 2473
      if (bce) {
        {
#line 2474
        MBceLine(p, i, 0, p->w_layer.l_width, bce);
        }
      }
#line 2447
      i ++;
#line 2447
      ml ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 2478
    cnt1 = (int )((unsigned long )n * sizeof(struct mline ));
#line 2479
    cnt2 = (int )((unsigned long )(((ye - ys) + 1) - n) * sizeof(struct mline ));
#line 2480
    if (cnt1) {
#line 2480
      if (cnt2) {
        {
#line 2481
        Scroll((char *)(p->w_mlines + ys), cnt1, cnt2, (char *)(tmp));
        }
      }
    }
  } else {
#line 2485
    if (n < -256) {
      {
#line 2487
      MScrollV(p, n + 256, ys, ye, bce);
#line 2488
      n = -256;
      }
    }
#line 2490
    n = - n;
#line 2491
    if ((ye - ys) + 1 < n) {
#line 2492
      n = (ye - ys) + 1;
    }
#line 2494
    ml = p->w_mlines + ye;
#line 2496
    i = ye;
    {
#line 2496
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2496
      if (! (i > ye - n)) {
#line 2496
        goto while_break___0;
      }
#line 2498
      if ((unsigned long )ml->attr != (unsigned long )null) {
        {
#line 2499
        free((void *)ml->attr);
        }
      }
#line 2500
      ml->attr = null;
#line 2502
      if ((unsigned long )ml->font != (unsigned long )null) {
        {
#line 2503
        free((void *)ml->font);
        }
      }
#line 2504
      ml->font = null;
#line 2507
      if ((unsigned long )ml->color != (unsigned long )null) {
        {
#line 2508
        free((void *)ml->color);
        }
      }
      {
#line 2509
      ml->color = null;
#line 2516
      bclear((char *)ml->image, p->w_layer.l_width + 1);
      }
#line 2518
      if (bce) {
        {
#line 2519
        MBceLine(p, i, 0, p->w_layer.l_width, bce);
        }
      }
#line 2496
      i --;
#line 2496
      ml --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2522
    cnt1 = (int )((unsigned long )n * sizeof(struct mline ));
#line 2523
    cnt2 = (int )((unsigned long )(((ye - ys) + 1) - n) * sizeof(struct mline ));
#line 2524
    if (cnt1) {
#line 2524
      if (cnt2) {
        {
#line 2525
        Scroll((char *)(p->w_mlines + ys), cnt2, cnt1, (char *)(tmp));
        }
      }
    }
  }
#line 2527
  return;
}
}
#line 2529 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void Scroll(char *cp , int cnt1 , int cnt2 , char *tmp ) 
{ 


  {
#line 2534
  if (! cnt1) {
#line 2535
    return;
  } else
#line 2534
  if (! cnt2) {
#line 2535
    return;
  }
#line 2536
  if (cnt1 <= cnt2) {
    {
#line 2538
    bcopy((void const   *)cp, (void *)tmp, (size_t )cnt1);
#line 2539
    bcopy((void const   *)(cp + cnt1), (void *)cp, (size_t )cnt2);
#line 2540
    bcopy((void const   *)tmp, (void *)(cp + cnt2), (size_t )cnt1);
    }
  } else {
    {
#line 2544
    bcopy((void const   *)(cp + cnt1), (void *)tmp, (size_t )cnt2);
#line 2545
    bcopy((void const   *)cp, (void *)(cp + cnt2), (size_t )cnt1);
#line 2546
    bcopy((void const   *)tmp, (void *)cp, (size_t )cnt2);
    }
  }
#line 2548
  return;
}
}
#line 2550 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void MClearArea(struct win *p , int xs , int ys , int xe , int ye , int bce ) 
{ 
  int n ;
  int y ;
  int xxe ;
  struct mline *ml ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 2560
  if (xs >= p->w_layer.l_width) {
#line 2561
    xs = p->w_layer.l_width - 1;
  }
#line 2562
  if (xe >= p->w_layer.l_width) {
#line 2563
    xe = p->w_layer.l_width - 1;
  }
#line 2565
  if (p->w_layer.l_encoding == 8) {
#line 2565
    if ((int )*((p->w_mlines + ys)->font + xs) == 255) {
#line 2565
      if ((int )*((p->w_mlines + ys)->image + xs) == 255) {
#line 2565
        tmp = 1;
      } else {
#line 2565
        tmp = 0;
      }
    } else {
#line 2565
      tmp = 0;
    }
#line 2565
    tmp___0 = tmp;
  } else {
#line 2565
    tmp___0 = ((int )*((p->w_mlines + ys)->font + xs) & 224) == 128;
  }
#line 2565
  if (tmp___0) {
#line 2565
    if (xs > 0) {
      {
#line 2565
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2565
        *((p->w_mlines + ys)->image + (xs - 1)) = mchar_blank.image;
#line 2565
        *((p->w_mlines + ys)->attr + (xs - 1)) = mchar_blank.attr;
#line 2565
        *((p->w_mlines + ys)->font + (xs - 1)) = mchar_blank.font;
#line 2565
        *((p->w_mlines + ys)->color + (xs - 1)) = mchar_blank.color;
#line 2565
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 2565
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2565
      *((p->w_mlines + ys)->image + xs) = mchar_blank.image;
#line 2565
      *((p->w_mlines + ys)->attr + xs) = mchar_blank.attr;
#line 2565
      *((p->w_mlines + ys)->font + xs) = mchar_blank.font;
#line 2565
      *((p->w_mlines + ys)->color + xs) = mchar_blank.color;
#line 2565
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 2566
  if (p->w_layer.l_encoding == 8) {
#line 2566
    if ((int )*((p->w_mlines + ye)->font + (xe + 1)) == 255) {
#line 2566
      if ((int )*((p->w_mlines + ye)->image + (xe + 1)) == 255) {
#line 2566
        tmp___1 = 1;
      } else {
#line 2566
        tmp___1 = 0;
      }
    } else {
#line 2566
      tmp___1 = 0;
    }
#line 2566
    tmp___3 = tmp___1;
  } else {
#line 2566
    if (((int )*((p->w_mlines + ye)->font + xe) & 31) != 0) {
#line 2566
      if (((int )*((p->w_mlines + ye)->font + xe) & 224) == 0) {
#line 2566
        tmp___2 = 1;
      } else {
#line 2566
        tmp___2 = 0;
      }
    } else {
#line 2566
      tmp___2 = 0;
    }
#line 2566
    tmp___3 = tmp___2;
  }
#line 2566
  if (tmp___3) {
    {
#line 2566
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2566
      *((p->w_mlines + ye)->image + xe) = mchar_blank.image;
#line 2566
      *((p->w_mlines + ye)->attr + xe) = mchar_blank.attr;
#line 2566
      *((p->w_mlines + ye)->font + xe) = mchar_blank.font;
#line 2566
      *((p->w_mlines + ye)->color + xe) = mchar_blank.color;
#line 2566
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2566
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2566
      *((p->w_mlines + ye)->image + (xe + 1)) = mchar_blank.image;
#line 2566
      *((p->w_mlines + ye)->attr + (xe + 1)) = mchar_blank.attr;
#line 2566
      *((p->w_mlines + ye)->font + (xe + 1)) = mchar_blank.font;
#line 2566
      *((p->w_mlines + ye)->color + (xe + 1)) = mchar_blank.color;
#line 2566
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 2568
  ml = p->w_mlines + ys;
#line 2569
  y = ys;
  {
#line 2569
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2569
    if (! (y <= ye)) {
#line 2569
      goto while_break___3;
    }
#line 2571
    if (y == ye) {
#line 2571
      xxe = xe;
    } else {
#line 2571
      xxe = p->w_layer.l_width - 1;
    }
#line 2572
    n = (xxe - xs) + 1;
#line 2573
    if (n > 0) {
      {
#line 2574
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 2574
        bclear((char *)ml->image + xs, n);
        }
#line 2574
        if ((unsigned long )ml->attr != (unsigned long )null) {
          {
#line 2574
          bzero((void *)((char *)ml->attr + xs), (size_t )n);
          }
        }
#line 2574
        if ((unsigned long )ml->font != (unsigned long )null) {
          {
#line 2574
          bzero((void *)((char *)ml->font + xs), (size_t )n);
          }
        }
#line 2574
        if ((unsigned long )ml->color != (unsigned long )null) {
          {
#line 2574
          bzero((void *)((char *)ml->color + xs), (size_t )n);
          }
        }
#line 2574
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 2576
    if (n > 0) {
#line 2576
      if (bce) {
        {
#line 2577
        MBceLine(p, y, xs, (xs + n) - 1, bce);
        }
      }
    }
#line 2579
    xs = 0;
#line 2569
    y ++;
#line 2569
    ml ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2581
  return;
}
}
#line 2583 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void MInsChar(struct win *p , struct mchar *c , int x , int y ) 
{ 
  int n ;
  struct mline *ml ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 2592
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2592
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2593
  MFixLine(p, y, c);
#line 2594
  ml = p->w_mlines + y;
#line 2595
  n = (p->w_layer.l_width - x) - 1;
  }
#line 2596
  if (p->w_layer.l_encoding == 8) {
#line 2596
    if ((int )*(ml->font + x) == 255) {
#line 2596
      if ((int )*(ml->image + x) == 255) {
#line 2596
        tmp = 1;
      } else {
#line 2596
        tmp = 0;
      }
    } else {
#line 2596
      tmp = 0;
    }
#line 2596
    tmp___0 = tmp;
  } else {
#line 2596
    tmp___0 = ((int )*(ml->font + x) & 224) == 128;
  }
#line 2596
  if (tmp___0) {
#line 2596
    if (x > 0) {
      {
#line 2596
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2596
        *(ml->image + (x - 1)) = mchar_blank.image;
#line 2596
        *(ml->attr + (x - 1)) = mchar_blank.attr;
#line 2596
        *(ml->font + (x - 1)) = mchar_blank.font;
#line 2596
        *(ml->color + (x - 1)) = mchar_blank.color;
#line 2596
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 2596
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2596
      *(ml->image + x) = mchar_blank.image;
#line 2596
      *(ml->attr + x) = mchar_blank.attr;
#line 2596
      *(ml->font + x) = mchar_blank.font;
#line 2596
      *(ml->color + x) = mchar_blank.color;
#line 2596
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 2597
  if (n > 0) {
#line 2599
    if (p->w_layer.l_encoding == 8) {
#line 2599
      if ((int )*(ml->font + (p->w_layer.l_width - 1)) == 255) {
#line 2599
        if ((int )*(ml->image + (p->w_layer.l_width - 1)) == 255) {
#line 2599
          tmp___1 = 1;
        } else {
#line 2599
          tmp___1 = 0;
        }
      } else {
#line 2599
        tmp___1 = 0;
      }
#line 2599
      tmp___2 = tmp___1;
    } else {
#line 2599
      tmp___2 = ((int )*(ml->font + (p->w_layer.l_width - 1)) & 224) == 128;
    }
#line 2599
    if (tmp___2) {
#line 2599
      if (p->w_layer.l_width - 1 > 0) {
        {
#line 2599
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2599
          *(ml->image + ((p->w_layer.l_width - 1) - 1)) = mchar_blank.image;
#line 2599
          *(ml->attr + ((p->w_layer.l_width - 1) - 1)) = mchar_blank.attr;
#line 2599
          *(ml->font + ((p->w_layer.l_width - 1) - 1)) = mchar_blank.font;
#line 2599
          *(ml->color + ((p->w_layer.l_width - 1) - 1)) = mchar_blank.color;
#line 2599
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
      {
#line 2599
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2599
        *(ml->image + (p->w_layer.l_width - 1)) = mchar_blank.image;
#line 2599
        *(ml->attr + (p->w_layer.l_width - 1)) = mchar_blank.attr;
#line 2599
        *(ml->font + (p->w_layer.l_width - 1)) = mchar_blank.font;
#line 2599
        *(ml->color + (p->w_layer.l_width - 1)) = mchar_blank.color;
#line 2599
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    {
#line 2600
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 2600
      bcopy((void const   *)((char *)ml->image + x), (void *)((char *)ml->image + (x + 1)),
            (size_t )n);
#line 2600
      bcopy((void const   *)((char *)ml->attr + x), (void *)((char *)ml->attr + (x + 1)),
            (size_t )n);
#line 2600
      bcopy((void const   *)((char *)ml->font + x), (void *)((char *)ml->font + (x + 1)),
            (size_t )n);
#line 2600
      bcopy((void const   *)((char *)ml->color + x), (void *)((char *)ml->color + (x + 1)),
            (size_t )n);
      }
#line 2600
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  {
#line 2602
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 2602
    *(ml->image + x) = c->image;
#line 2602
    *(ml->attr + x) = c->attr;
#line 2602
    *(ml->font + x) = c->font;
#line 2602
    *(ml->color + x) = c->color;
#line 2602
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 2604
  if (c->mbcs) {
#line 2606
    n --;
#line 2606
    if (n > 0) {
#line 2608
      if (p->w_layer.l_encoding == 8) {
#line 2608
        if ((int )*(ml->font + (p->w_layer.l_width - 1)) == 255) {
#line 2608
          if ((int )*(ml->image + (p->w_layer.l_width - 1)) == 255) {
#line 2608
            tmp___3 = 1;
          } else {
#line 2608
            tmp___3 = 0;
          }
        } else {
#line 2608
          tmp___3 = 0;
        }
#line 2608
        tmp___4 = tmp___3;
      } else {
#line 2608
        tmp___4 = ((int )*(ml->font + (p->w_layer.l_width - 1)) & 224) == 128;
      }
#line 2608
      if (tmp___4) {
#line 2608
        if (p->w_layer.l_width - 1 > 0) {
          {
#line 2608
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 2608
            *(ml->image + ((p->w_layer.l_width - 1) - 1)) = mchar_blank.image;
#line 2608
            *(ml->attr + ((p->w_layer.l_width - 1) - 1)) = mchar_blank.attr;
#line 2608
            *(ml->font + ((p->w_layer.l_width - 1) - 1)) = mchar_blank.font;
#line 2608
            *(ml->color + ((p->w_layer.l_width - 1) - 1)) = mchar_blank.color;
#line 2608
            goto while_break___6;
          }
          while_break___6: /* CIL Label */ ;
          }
        }
        {
#line 2608
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 2608
          *(ml->image + (p->w_layer.l_width - 1)) = mchar_blank.image;
#line 2608
          *(ml->attr + (p->w_layer.l_width - 1)) = mchar_blank.attr;
#line 2608
          *(ml->font + (p->w_layer.l_width - 1)) = mchar_blank.font;
#line 2608
          *(ml->color + (p->w_layer.l_width - 1)) = mchar_blank.color;
#line 2608
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
      {
#line 2609
      while (1) {
        while_continue___8: /* CIL Label */ ;
        {
#line 2609
        bcopy((void const   *)((char *)ml->image + (x + 1)), (void *)((char *)ml->image + (x + 2)),
              (size_t )n);
#line 2609
        bcopy((void const   *)((char *)ml->attr + (x + 1)), (void *)((char *)ml->attr + (x + 2)),
              (size_t )n);
#line 2609
        bcopy((void const   *)((char *)ml->font + (x + 1)), (void *)((char *)ml->font + (x + 2)),
              (size_t )n);
#line 2609
        bcopy((void const   *)((char *)ml->color + (x + 1)), (void *)((char *)ml->color + (x + 2)),
              (size_t )n);
        }
#line 2609
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
    }
    {
#line 2611
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 2611
      *(ml->image + (x + 1)) = c->image;
#line 2611
      *(ml->attr + (x + 1)) = c->attr;
#line 2611
      *(ml->font + (x + 1)) = c->font;
#line 2611
      *(ml->color + (x + 1)) = c->color;
#line 2611
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 2612
    *(ml->image + (x + 1)) = c->mbcs;
#line 2614
    if (p->w_layer.l_encoding != 8) {
#line 2615
      *(ml->font + (x + 1)) = (unsigned char )((int )*(ml->font + (x + 1)) | 128);
    } else
#line 2616
    if (p->w_layer.l_encoding == 8) {
#line 2616
      if (c->mbcs) {
#line 2617
        *(ml->font + (x + 1)) = c->mbcs;
      }
    }
  }
#line 2623
  return;
}
}
#line 2625 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void MPutChar(struct win *p , struct mchar *c , int x , int y ) 
{ 
  struct mline *ml ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 2633
  MFixLine(p, y, c);
#line 2634
  ml = p->w_mlines + y;
  }
#line 2635
  if (p->w_layer.l_encoding == 8) {
#line 2635
    if ((int )*(ml->font + x) == 255) {
#line 2635
      if ((int )*(ml->image + x) == 255) {
#line 2635
        tmp = 1;
      } else {
#line 2635
        tmp = 0;
      }
    } else {
#line 2635
      tmp = 0;
    }
#line 2635
    tmp___0 = tmp;
  } else {
#line 2635
    tmp___0 = ((int )*(ml->font + x) & 224) == 128;
  }
#line 2635
  if (tmp___0) {
#line 2635
    if (x > 0) {
      {
#line 2635
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2635
        *(ml->image + (x - 1)) = mchar_blank.image;
#line 2635
        *(ml->attr + (x - 1)) = mchar_blank.attr;
#line 2635
        *(ml->font + (x - 1)) = mchar_blank.font;
#line 2635
        *(ml->color + (x - 1)) = mchar_blank.color;
#line 2635
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 2635
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2635
      *(ml->image + x) = mchar_blank.image;
#line 2635
      *(ml->attr + x) = mchar_blank.attr;
#line 2635
      *(ml->font + x) = mchar_blank.font;
#line 2635
      *(ml->color + x) = mchar_blank.color;
#line 2635
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 2636
  if (p->w_layer.l_encoding == 8) {
#line 2636
    if ((int )*(ml->font + (x + 1)) == 255) {
#line 2636
      if ((int )*(ml->image + (x + 1)) == 255) {
#line 2636
        tmp___1 = 1;
      } else {
#line 2636
        tmp___1 = 0;
      }
    } else {
#line 2636
      tmp___1 = 0;
    }
#line 2636
    tmp___3 = tmp___1;
  } else {
#line 2636
    if (((int )*(ml->font + x) & 31) != 0) {
#line 2636
      if (((int )*(ml->font + x) & 224) == 0) {
#line 2636
        tmp___2 = 1;
      } else {
#line 2636
        tmp___2 = 0;
      }
    } else {
#line 2636
      tmp___2 = 0;
    }
#line 2636
    tmp___3 = tmp___2;
  }
#line 2636
  if (tmp___3) {
    {
#line 2636
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2636
      *(ml->image + x) = mchar_blank.image;
#line 2636
      *(ml->attr + x) = mchar_blank.attr;
#line 2636
      *(ml->font + x) = mchar_blank.font;
#line 2636
      *(ml->color + x) = mchar_blank.color;
#line 2636
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2636
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2636
      *(ml->image + (x + 1)) = mchar_blank.image;
#line 2636
      *(ml->attr + (x + 1)) = mchar_blank.attr;
#line 2636
      *(ml->font + (x + 1)) = mchar_blank.font;
#line 2636
      *(ml->color + (x + 1)) = mchar_blank.color;
#line 2636
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 2637
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2637
    *(ml->image + x) = c->image;
#line 2637
    *(ml->attr + x) = c->attr;
#line 2637
    *(ml->font + x) = c->font;
#line 2637
    *(ml->color + x) = c->color;
#line 2637
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2639
  if (c->mbcs) {
#line 2641
    if (p->w_layer.l_encoding == 8) {
#line 2641
      if ((int )*(ml->font + ((x + 1) + 1)) == 255) {
#line 2641
        if ((int )*(ml->image + ((x + 1) + 1)) == 255) {
#line 2641
          tmp___4 = 1;
        } else {
#line 2641
          tmp___4 = 0;
        }
      } else {
#line 2641
        tmp___4 = 0;
      }
#line 2641
      tmp___6 = tmp___4;
    } else {
#line 2641
      if (((int )*(ml->font + (x + 1)) & 31) != 0) {
#line 2641
        if (((int )*(ml->font + (x + 1)) & 224) == 0) {
#line 2641
          tmp___5 = 1;
        } else {
#line 2641
          tmp___5 = 0;
        }
      } else {
#line 2641
        tmp___5 = 0;
      }
#line 2641
      tmp___6 = tmp___5;
    }
#line 2641
    if (tmp___6) {
      {
#line 2641
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 2641
        *(ml->image + (x + 1)) = mchar_blank.image;
#line 2641
        *(ml->attr + (x + 1)) = mchar_blank.attr;
#line 2641
        *(ml->font + (x + 1)) = mchar_blank.font;
#line 2641
        *(ml->color + (x + 1)) = mchar_blank.color;
#line 2641
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 2641
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 2641
        *(ml->image + ((x + 1) + 1)) = mchar_blank.image;
#line 2641
        *(ml->attr + ((x + 1) + 1)) = mchar_blank.attr;
#line 2641
        *(ml->font + ((x + 1) + 1)) = mchar_blank.font;
#line 2641
        *(ml->color + ((x + 1) + 1)) = mchar_blank.color;
#line 2641
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
    {
#line 2642
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 2642
      *(ml->image + (x + 1)) = c->image;
#line 2642
      *(ml->attr + (x + 1)) = c->attr;
#line 2642
      *(ml->font + (x + 1)) = c->font;
#line 2642
      *(ml->color + (x + 1)) = c->color;
#line 2642
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 2643
    *(ml->image + (x + 1)) = c->mbcs;
#line 2645
    if (p->w_layer.l_encoding != 8) {
#line 2646
      *(ml->font + (x + 1)) = (unsigned char )((int )*(ml->font + (x + 1)) | 128);
    } else
#line 2647
    if (p->w_layer.l_encoding == 8) {
#line 2647
      if (c->mbcs) {
#line 2648
        *(ml->font + (x + 1)) = c->mbcs;
      }
    }
  }
#line 2654
  return;
}
}
#line 2657 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void MWrapChar(struct win *p , struct mchar *c , int y , int top , int bot ,
                      int ins ) 
{ 
  struct mline *ml ;
  int bce ;
  int tmp ;

  {
#line 2668
  if ((int )c->attr & (1 << 7)) {
#line 2668
    tmp = 256;
  } else {
#line 2668
    tmp = 0;
  }
  {
#line 2668
  bce = (((int )c->color & 240) >> 4) | tmp;
#line 2672
  MFixLine(p, y, c);
#line 2673
  ml = p->w_mlines + y;
  }
  {
#line 2674
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2674
    *(ml->image + p->w_layer.l_width) = mchar_null.image;
#line 2674
    *(ml->attr + p->w_layer.l_width) = mchar_null.attr;
#line 2674
    *(ml->font + p->w_layer.l_width) = mchar_null.font;
#line 2674
    *(ml->color + p->w_layer.l_width) = mchar_null.color;
#line 2674
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2675
  if (y == bot) {
    {
#line 2676
    MScrollV(p, 1, top, bot, bce);
    }
  } else
#line 2677
  if (y < p->w_layer.l_height - 1) {
#line 2678
    y ++;
  }
#line 2679
  if (ins) {
    {
#line 2680
    MInsChar(p, c, 0, y);
    }
  } else {
    {
#line 2682
    MPutChar(p, c, 0, y);
    }
  }
#line 2683
  return;
}
}
#line 2685 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void MPutStr(struct win *p , char *s , int n , struct mchar *r , int x , int y ) 
{ 
  struct mline *ml ;
  int i ;
  unsigned char *b ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned char *tmp___4 ;
  int tmp___5 ;
  unsigned char *tmp___6 ;
  int tmp___7 ;
  unsigned char *tmp___8 ;
  int tmp___9 ;

  {
#line 2697
  if (n <= 0) {
#line 2698
    return;
  }
  {
#line 2699
  MFixLine(p, y, r);
#line 2700
  ml = p->w_mlines + y;
  }
#line 2701
  if (p->w_layer.l_encoding == 8) {
#line 2701
    if ((int )*(ml->font + x) == 255) {
#line 2701
      if ((int )*(ml->image + x) == 255) {
#line 2701
        tmp = 1;
      } else {
#line 2701
        tmp = 0;
      }
    } else {
#line 2701
      tmp = 0;
    }
#line 2701
    tmp___0 = tmp;
  } else {
#line 2701
    tmp___0 = ((int )*(ml->font + x) & 224) == 128;
  }
#line 2701
  if (tmp___0) {
#line 2701
    if (x > 0) {
      {
#line 2701
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2701
        *(ml->image + (x - 1)) = mchar_blank.image;
#line 2701
        *(ml->attr + (x - 1)) = mchar_blank.attr;
#line 2701
        *(ml->font + (x - 1)) = mchar_blank.font;
#line 2701
        *(ml->color + (x - 1)) = mchar_blank.color;
#line 2701
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 2701
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2701
      *(ml->image + x) = mchar_blank.image;
#line 2701
      *(ml->attr + x) = mchar_blank.attr;
#line 2701
      *(ml->font + x) = mchar_blank.font;
#line 2701
      *(ml->color + x) = mchar_blank.color;
#line 2701
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 2702
  if (p->w_layer.l_encoding == 8) {
#line 2702
    if ((int )*(ml->font + (((x + n) - 1) + 1)) == 255) {
#line 2702
      if ((int )*(ml->image + (((x + n) - 1) + 1)) == 255) {
#line 2702
        tmp___1 = 1;
      } else {
#line 2702
        tmp___1 = 0;
      }
    } else {
#line 2702
      tmp___1 = 0;
    }
#line 2702
    tmp___3 = tmp___1;
  } else {
#line 2702
    if (((int )*(ml->font + ((x + n) - 1)) & 31) != 0) {
#line 2702
      if (((int )*(ml->font + ((x + n) - 1)) & 224) == 0) {
#line 2702
        tmp___2 = 1;
      } else {
#line 2702
        tmp___2 = 0;
      }
    } else {
#line 2702
      tmp___2 = 0;
    }
#line 2702
    tmp___3 = tmp___2;
  }
#line 2702
  if (tmp___3) {
    {
#line 2702
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2702
      *(ml->image + ((x + n) - 1)) = mchar_blank.image;
#line 2702
      *(ml->attr + ((x + n) - 1)) = mchar_blank.attr;
#line 2702
      *(ml->font + ((x + n) - 1)) = mchar_blank.font;
#line 2702
      *(ml->color + ((x + n) - 1)) = mchar_blank.color;
#line 2702
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2702
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2702
      *(ml->image + (((x + n) - 1) + 1)) = mchar_blank.image;
#line 2702
      *(ml->attr + (((x + n) - 1) + 1)) = mchar_blank.attr;
#line 2702
      *(ml->font + (((x + n) - 1) + 1)) = mchar_blank.font;
#line 2702
      *(ml->color + (((x + n) - 1) + 1)) = mchar_blank.color;
#line 2702
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 2703
  bcopy((void const   *)s, (void *)((char *)ml->image + x), (size_t )n);
#line 2704
  b = ml->attr + x;
#line 2705
  i = n;
  }
  {
#line 2705
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2705
    tmp___5 = i;
#line 2705
    i --;
#line 2705
    if (! (tmp___5 > 0)) {
#line 2705
      goto while_break___3;
    }
#line 2706
    tmp___4 = b;
#line 2706
    b ++;
#line 2706
    *tmp___4 = r->attr;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2708
  b = ml->font + x;
#line 2709
  i = n;
  {
#line 2709
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 2709
    tmp___7 = i;
#line 2709
    i --;
#line 2709
    if (! (tmp___7 > 0)) {
#line 2709
      goto while_break___4;
    }
#line 2710
    tmp___6 = b;
#line 2710
    b ++;
#line 2710
    *tmp___6 = r->font;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 2713
  b = ml->color + x;
#line 2714
  i = n;
  {
#line 2714
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 2714
    tmp___9 = i;
#line 2714
    i --;
#line 2714
    if (! (tmp___9 > 0)) {
#line 2714
      goto while_break___5;
    }
#line 2715
    tmp___8 = b;
#line 2715
    b ++;
#line 2715
    *tmp___8 = r->color;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 2722
  return;
}
}
#line 2725 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void MBceLine(struct win *p , int y , int xs , int xe , int bce ) 
{ 
  struct mchar mc ;
  struct mline *ml ;
  int x ;
  int tmp ;

  {
#line 2734
  mc = mchar_null;
#line 2735
  mc.color = (unsigned char )(((int )mc.color & 15) | ((bce << 4) & 240));
#line 2735
  if (bce & 256) {
#line 2735
    tmp = 0;
  } else {
#line 2735
    tmp = 1 << 7;
  }
  {
#line 2735
  mc.attr = (unsigned char )(((int )mc.attr | (1 << 7)) ^ tmp);
#line 2736
  MFixLine(p, y, & mc);
#line 2737
  ml = p->w_mlines + y;
  }
#line 2739
  if (mc.attr) {
#line 2740
    x = xs;
    {
#line 2740
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2740
      if (! (x <= xe)) {
#line 2740
        goto while_break;
      }
#line 2741
      *(ml->attr + x) = mc.attr;
#line 2740
      x ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2743
  if (mc.color) {
#line 2744
    x = xs;
    {
#line 2744
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2744
      if (! (x <= xe)) {
#line 2744
        goto while_break___0;
      }
#line 2745
      *(ml->color + x) = mc.color;
#line 2744
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 2751
  return;
}
}
#line 2756 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void WAddLineToHist(struct win *wp , struct mline *ml ) 
{ 
  register unsigned char *q ;
  register unsigned char *o ;
  struct mline *hml ;

  {
#line 2764
  if (wp->w_histheight == 0) {
#line 2765
    return;
  }
#line 2766
  hml = wp->w_hlines + wp->w_histidx;
#line 2767
  q = ml->image;
#line 2767
  ml->image = hml->image;
#line 2767
  hml->image = q;
#line 2769
  q = ml->attr;
#line 2769
  o = hml->attr;
#line 2769
  hml->attr = q;
#line 2769
  ml->attr = null;
#line 2770
  if ((unsigned long )o != (unsigned long )null) {
    {
#line 2771
    free((void *)o);
    }
  }
#line 2774
  q = ml->font;
#line 2774
  o = hml->font;
#line 2774
  hml->font = q;
#line 2774
  ml->font = null;
#line 2775
  if ((unsigned long )o != (unsigned long )null) {
    {
#line 2776
    free((void *)o);
    }
  }
#line 2780
  q = ml->color;
#line 2780
  o = hml->color;
#line 2780
  hml->color = q;
#line 2780
  ml->color = null;
#line 2781
  if ((unsigned long )o != (unsigned long )null) {
    {
#line 2782
    free((void *)o);
    }
  }
#line 2790
  (wp->w_histidx) ++;
#line 2790
  if (wp->w_histidx >= wp->w_histheight) {
#line 2791
    wp->w_histidx = 0;
  }
#line 2792
  return;
}
}
#line 2795 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
int MFindUsedLine(struct win *p , int ye , int ys ) 
{ 
  int y ;
  struct mline *ml ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2801
  ml = p->w_mlines + ye;
  {
#line 2803
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2803
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2804
  y = ye;
  {
#line 2804
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2804
    if (! (y >= ys)) {
#line 2804
      goto while_break___0;
    }
    {
#line 2806
    tmp = bcmp((void const   *)((char *)ml->image), (void const   *)blank, (size_t )p->w_layer.l_width);
    }
#line 2806
    if (tmp) {
#line 2807
      goto while_break___0;
    }
#line 2808
    if ((unsigned long )ml->attr != (unsigned long )null) {
      {
#line 2808
      tmp___0 = bcmp((void const   *)((char *)ml->attr), (void const   *)null, (size_t )p->w_layer.l_width);
      }
#line 2808
      if (tmp___0) {
#line 2809
        goto while_break___0;
      }
    }
#line 2811
    if ((unsigned long )ml->color != (unsigned long )null) {
      {
#line 2811
      tmp___1 = bcmp((void const   *)((char *)ml->color), (void const   *)null, (size_t )p->w_layer.l_width);
      }
#line 2811
      if (tmp___1) {
#line 2812
        goto while_break___0;
      }
    }
#line 2804
    y --;
#line 2804
    ml --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2819
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2819
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2820
  return (y);
}
}
#line 2833 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
void WBell(struct win *p , int visual ) 
{ 
  struct canvas *cv ;

  {
#line 2839
  display = displays;
  {
#line 2839
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2839
    if (! display) {
#line 2839
      goto while_break;
    }
#line 2841
    cv = display->d_cvlist;
    {
#line 2841
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2841
      if (! cv) {
#line 2841
        goto while_break___0;
      }
#line 2842
      if ((unsigned long )(cv->c_layer)->l_bottom == (unsigned long )(& p->w_layer)) {
#line 2843
        goto while_break___0;
      }
#line 2841
      cv = cv->c_next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2844
    if (cv) {
#line 2844
      if (! visual) {
        {
#line 2845
        AddCStr(display->d_tcs[42].str);
        }
      } else {
#line 2844
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2846
    if (cv) {
#line 2846
      if (display->d_tcs[43].str) {
        {
#line 2847
        AddCStr(display->d_tcs[43].str);
        }
      } else {
#line 2846
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2849
    if (visual) {
#line 2849
      p->w_bell = 3;
    } else {
#line 2849
      p->w_bell = 1;
    }
#line 2839
    display = display->d_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2851
  return;
}
}
#line 2860 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static void WReverseVideo(struct win *p , int on ) 
{ 
  struct canvas *cv ;

  {
#line 2866
  cv = p->w_layer.l_cvlist;
  {
#line 2866
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2866
    if (! cv) {
#line 2866
      goto while_break;
    }
#line 2868
    display = cv->c_display;
#line 2869
    if ((unsigned long )cv != (unsigned long )display->d_forecv) {
#line 2870
      goto __Cont;
    }
    {
#line 2871
    ReverseVideo(on);
    }
#line 2872
    if (! on) {
#line 2872
      if (p->w_revvid) {
#line 2872
        if (! display->d_tcs[93].str) {
#line 2874
          if (display->d_tcs[43].str) {
            {
#line 2875
            AddCStr(display->d_tcs[43].str);
            }
          } else {
#line 2877
            p->w_bell = 3;
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 2866
    cv = cv->c_lnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 2880
  return;
}
}
#line 2882 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
void WMsg(struct win *p , int err , char *str ) 
{ 
  struct layer *oldflayer ;

  {
  {
#line 2889
  oldflayer = flayer;
#line 2890
  flayer = & p->w_layer;
#line 2891
  LMsg(err, str);
#line 2892
  flayer = oldflayer;
  }
#line 2893
  return;
}
}
#line 2895 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
void WChangeSize(struct win *p , int w , int h ) 
{ 
  int wok ;
  struct canvas *cv ;

  {
#line 2900
  wok = 0;
#line 2903
  if ((unsigned long )p->w_layer.l_cvlist == (unsigned long )((struct canvas *)0)) {
    {
#line 2906
    ChangeWindowSize(p, w, h, p->w_histheight);
    }
#line 2907
    return;
  }
#line 2909
  cv = p->w_layer.l_cvlist;
  {
#line 2909
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2909
    if (! cv) {
#line 2909
      goto while_break;
    }
#line 2911
    display = cv->c_display;
#line 2912
    if ((unsigned long )p != (unsigned long )display->d_fore) {
#line 2913
      goto __Cont;
    }
#line 2914
    if (display->d_tcs[44].str) {
#line 2915
      goto while_break;
    }
#line 2916
    if (display->d_tcs[45].str) {
#line 2916
      if (w == Z0width) {
#line 2917
        wok = 1;
      } else
#line 2916
      if (w == Z1width) {
#line 2917
        wok = 1;
      }
    }
    __Cont: /* CIL Label */ 
#line 2909
    cv = cv->c_lnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 2919
  if ((unsigned long )cv == (unsigned long )((struct canvas *)0)) {
#line 2919
    if (wok == 0) {
#line 2920
      return;
    }
  }
#line 2921
  if (! display->d_tcs[44].str) {
#line 2922
    h = p->w_layer.l_height;
  }
  {
#line 2923
  ChangeWindowSize(p, w, h, p->w_histheight);
#line 2924
  display = displays;
  }
  {
#line 2924
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2924
    if (! display) {
#line 2924
      goto while_break___0;
    }
#line 2926
    if ((unsigned long )p == (unsigned long )display->d_fore) {
#line 2928
      if (display->d_cvlist) {
#line 2928
        if ((unsigned long )(display->d_cvlist)->c_next == (unsigned long )((struct canvas *)0)) {
          {
#line 2929
          ResizeDisplay(w, h);
          }
        } else {
          {
#line 2931
          ResizeDisplay(w, display->d_height);
          }
        }
      } else {
        {
#line 2931
        ResizeDisplay(w, display->d_height);
        }
      }
      {
#line 2932
      ResizeLayersToCanvases();
      }
#line 2933
      goto __Cont___0;
    }
#line 2935
    cv = display->d_cvlist;
    {
#line 2935
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2935
      if (! cv) {
#line 2935
        goto while_break___1;
      }
#line 2936
      if ((unsigned long )(cv->c_layer)->l_bottom == (unsigned long )(& p->w_layer)) {
#line 2937
        goto while_break___1;
      }
#line 2935
      cv = cv->c_next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2938
    if (cv) {
      {
#line 2939
      Redisplay(0);
      }
    }
    __Cont___0: /* CIL Label */ 
#line 2924
    display = display->d_next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2941
  return;
}
}
#line 2943 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
static int WindowChangedCheck(char *s , int what , int *hp ) 
{ 
  int h ;
  int l ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2949
  h = 0;
  {
#line 2951
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2951
    if (! *s) {
#line 2951
      goto while_break;
    }
#line 2953
    tmp = s;
#line 2953
    s ++;
#line 2953
    if (hp) {
#line 2953
      tmp___0 = '%';
    } else {
#line 2953
      tmp___0 = '\005';
    }
#line 2953
    if ((int )*tmp != tmp___0) {
#line 2954
      goto while_continue;
    }
#line 2955
    l = 0;
    {
#line 2956
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2956
      if ((int )*s >= 48) {
#line 2956
        if (! ((int )*s <= 57)) {
#line 2956
          goto while_break___0;
        }
      } else {
#line 2956
        goto while_break___0;
      }
#line 2957
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2958
    if ((int )*s == 76) {
#line 2960
      s ++;
#line 2961
      l = 256;
    }
#line 2963
    if ((int )*s == 104) {
#line 2964
      h = 1;
    }
#line 2965
    if ((int )*s == what) {
#line 2966
      goto while_break;
    } else
#line 2965
    if (((int )*s | l) == what) {
#line 2966
      goto while_break;
    } else
#line 2965
    if (what == 100) {
#line 2966
      goto while_break;
    }
#line 2967
    if (*s) {
#line 2968
      s ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2970
  if (hp) {
#line 2971
    *hp = h;
  }
#line 2972
  if (*s) {
#line 2972
    tmp___1 = 1;
  } else {
#line 2972
    tmp___1 = 0;
  }
#line 2972
  return (tmp___1);
}
}
#line 2975 "/home/pronto/abs/test-suite/screen-4.0.2/ansi.c"
void WindowChanged(struct win *p , int what ) 
{ 
  int inwstr ;
  int inhstr ;
  int inlstr ;
  int inwstrh ;
  int inhstrh ;
  int inlstrh ;
  int got ;
  int ox ;
  int oy ;
  struct display *olddisplay ;
  struct canvas *cv ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 2981
  inwstrh = 0;
#line 2981
  inhstrh = 0;
#line 2981
  inlstrh = 0;
#line 2983
  olddisplay = display;
#line 2986
  inhstr = 0;
#line 2986
  inwstr = inhstr;
#line 2988
  if (what == 102) {
    {
#line 2990
    WindowChanged((struct win *)0, 375);
#line 2991
    WindowChanged((struct win *)0, 343);
    }
  }
#line 2994
  if (what) {
    {
#line 2996
    inwstr = WindowChangedCheck(captionstring, what, & inwstrh);
#line 2997
    inhstr = WindowChangedCheck(hstatusstring, what, & inhstrh);
#line 2998
    inlstr = WindowChangedCheck(wliststr, what, & inlstrh);
    }
  } else {
#line 3002
    inhstr = 0;
#line 3002
    inwstr = inhstr;
#line 3003
    inlstr = 1;
  }
#line 3006
  if ((unsigned long )p == (unsigned long )((struct win *)0)) {
#line 3008
    display = displays;
    {
#line 3008
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3008
      if (! display) {
#line 3008
        goto while_break;
      }
#line 3010
      ox = display->d_x;
#line 3011
      oy = display->d_y;
#line 3012
      cv = display->d_cvlist;
      {
#line 3012
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3012
        if (! cv) {
#line 3012
          goto while_break___0;
        }
#line 3014
        if (inlstr) {
          {
#line 3015
          WListUpdatecv(cv, (struct win *)0);
          }
        } else
#line 3014
        if (inlstrh) {
#line 3014
          if (p) {
#line 3014
            if (p->w_hstatus) {
#line 3014
              if (*(p->w_hstatus)) {
                {
#line 3014
                tmp = WindowChangedCheck(p->w_hstatus, what, (int *)0);
                }
#line 3014
                if (tmp) {
                  {
#line 3015
                  WListUpdatecv(cv, (struct win *)0);
                  }
                }
              }
            }
          }
        }
#line 3016
        p = (struct win *)((cv->c_layer)->l_bottom)->l_data;
#line 3017
        if (inwstr) {
#line 3017
          goto _L;
        } else
#line 3017
        if (inwstrh) {
#line 3017
          if (p) {
#line 3017
            if (p->w_hstatus) {
#line 3017
              if (*(p->w_hstatus)) {
                {
#line 3017
                tmp___0 = WindowChangedCheck(p->w_hstatus, what, (int *)0);
                }
#line 3017
                if (tmp___0) {
                  _L: /* CIL Label */ 
#line 3018
                  if (cv->c_ye + 1 < display->d_height) {
                    {
#line 3019
                    RefreshLine(cv->c_ye + 1, 0, display->d_width - 1, 0);
                    }
                  }
                }
              }
            }
          }
        }
#line 3012
        cv = cv->c_next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 3021
      p = display->d_fore;
#line 3022
      if (inhstr) {
        {
#line 3023
        RefreshHStatus();
        }
      } else
#line 3022
      if (inhstrh) {
#line 3022
        if (p) {
#line 3022
          if (p->w_hstatus) {
#line 3022
            if (*(p->w_hstatus)) {
              {
#line 3022
              tmp___1 = WindowChangedCheck(p->w_hstatus, what, (int *)0);
              }
#line 3022
              if (tmp___1) {
                {
#line 3023
                RefreshHStatus();
                }
              }
            }
          }
        }
      }
#line 3024
      if (ox != -1) {
#line 3024
        if (ox != -1) {
          {
#line 3025
          GotoPos(ox, oy);
          }
        }
      }
#line 3008
      display = display->d_next;
    }
    while_break: /* CIL Label */ ;
    }
#line 3027
    display = olddisplay;
#line 3028
    return;
  }
#line 3031
  if (p->w_hstatus) {
#line 3031
    if (*(p->w_hstatus)) {
#line 3031
      if (inwstrh) {
#line 3031
        goto _L___0;
      } else
#line 3031
      if (inhstrh) {
#line 3031
        goto _L___0;
      } else
#line 3031
      if (inlstrh) {
        _L___0: /* CIL Label */ 
        {
#line 3031
        tmp___2 = WindowChangedCheck(p->w_hstatus, what, (int *)0);
        }
#line 3031
        if (tmp___2) {
#line 3033
          inwstr |= inwstrh;
#line 3034
          inhstr |= inhstrh;
#line 3035
          inlstr |= inlstrh;
        }
      }
    }
  }
#line 3037
  if (! inwstr) {
#line 3037
    if (! inhstr) {
#line 3037
      if (! inlstr) {
#line 3038
        return;
      }
    }
  }
#line 3039
  display = displays;
  {
#line 3039
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3039
    if (! display) {
#line 3039
      goto while_break___1;
    }
#line 3041
    got = 0;
#line 3042
    ox = display->d_x;
#line 3043
    oy = display->d_y;
#line 3044
    cv = display->d_cvlist;
    {
#line 3044
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3044
      if (! cv) {
#line 3044
        goto while_break___2;
      }
#line 3046
      if (inlstr) {
        {
#line 3047
        WListUpdatecv(cv, p);
        }
      }
#line 3048
      if ((unsigned long )((struct win *)((cv->c_layer)->l_bottom)->l_data) != (unsigned long )p) {
#line 3049
        goto __Cont;
      }
#line 3050
      got = 1;
#line 3051
      if (inwstr) {
#line 3051
        if (cv->c_ye + 1 < display->d_height) {
          {
#line 3052
          RefreshLine(cv->c_ye + 1, 0, display->d_width - 1, 0);
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 3044
      cv = cv->c_next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 3054
    if (got) {
#line 3054
      if (inhstr) {
#line 3054
        if ((unsigned long )p == (unsigned long )display->d_fore) {
          {
#line 3055
          RefreshHStatus();
          }
        }
      }
    }
#line 3056
    if (ox != -1) {
#line 3056
      if (ox != -1) {
        {
#line 3057
        GotoPos(ox, oy);
        }
      }
    }
#line 3039
    display = display->d_next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3059
  display = olddisplay;
#line 3060
  return;
}
}
#line 284 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) mkdir)(char const   *__path ,
                                                                                  __mode_t __mode ) ;
#line 124 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int killpg(__pid_t __pgrp , int __sig ) ;
#line 125 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *setlocale(int __category , char const   *__locale ) ;
#line 576 "/usr/include/langinfo.h"
extern  __attribute__((__nothrow__)) char *nl_langinfo(nl_item __item ) ;
#line 142 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 247
extern FILE *freopen(char const   * __restrict  __filename , char const   * __restrict  __modes ,
                     FILE * __restrict  __stream ) ;
#line 524 "/usr/include/unistd.h"
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 761
extern char *getlogin(void) ;
#line 791
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gethostname)(char *__name ,
                                                                                        size_t __len ) ;
#line 197 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t strftime(char * __restrict  __s , size_t __maxsize ,
                                                     char const   * __restrict  __format ,
                                                     struct tm  const  * __restrict  __tp ) ;
#line 233
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t const   *__timer ) ;
#line 254
extern  __attribute__((__nothrow__)) char *ctime(time_t const   *__timer ) ;
#line 138 "/usr/include/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 111 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 71 "/usr/include/shadow.h"
extern void endspent(void) ;
#line 109 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
extern char **environ ;
#line 110 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
int force_vt  =    1;
#line 111 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
int VBellWait  ;
#line 111 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
int MsgWait  ;
#line 111 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
int MsgMinWait  ;
#line 111 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
int SilenceWait  ;
#line 129 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
char *ShellProg  ;
#line 130 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
char *ShellArgs[2]  ;
#line 135
static struct passwd *getpwbyname(char *name , struct passwd *ppp___0 ) ;
#line 136
static void SigChldHandler(void) ;
#line 137
static void SigChld(int sigsig ) ;
#line 138
static void SigInt(int sigsig ) ;
#line 139
static void CoreDump(int sigsig ) ;
#line 140
static void FinitHandler(int sigsig ) ;
#line 141
static void DoWait(void) ;
#line 142
static void serv_read_fn(struct event *ev , char *data ) ;
#line 143
static void serv_select_fn(struct event *ev , char *data ) ;
#line 144
static void logflush_fn(struct event *ev , char *data ) ;
#line 145
static void backtick_filter(struct backtick *bt ) ;
#line 146
static void backtick_fn(struct event *ev , char *data ) ;
#line 147
static char *runbacktick(struct backtick *bt , int *tickp , time_t now ) ;
#line 148
static int IsSymbol(char *e , char *s ) ;
#line 149
static char *ParseChar(char *p , char *cp ) ;
#line 150
static int ParseEscape(char *p ) ;
#line 151
static char *pad_expand(char *buf___0 , char *p , int numpad , int padlen ) ;
#line 156 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
int nversion  ;
#line 159 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
struct passwd *ppp  ;
#line 160 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
char *attach_tty  ;
#line 161 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
char *attach_term  ;
#line 162 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
char *LoginName  ;
#line 163 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
struct mode attach_Mode  ;
#line 165 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
char SockPath[4608]  ;
#line 166 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
char *SockName  ;
#line 167 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
char *SockMatch  =    (char *)((void *)0);
#line 168 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
int ServerSocket  =    -1;
#line 169 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
struct event serv_read  ;
#line 170 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
struct event serv_select  ;
#line 171 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
struct event logflushev  ;
#line 173 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
char **NewEnv  =    (char **)((void *)0);
#line 175 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
char *RcFileName  =    (char *)((void *)0);
#line 176 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
char *home  ;
#line 178 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
char *screenlogfile  ;
#line 179 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
int log_flush  =    10;
#line 180 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
int logtstamp_on  =    0;
#line 181 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
char *logtstamp_string  ;
#line 182 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
int logtstamp_after  =    120;
#line 183 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
char *hardcopydir  =    (char *)((void *)0);
#line 184 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
char *BellString  ;
#line 185 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
char *VisualBellString  ;
#line 186 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
char *ActivityString  ;
#line 188 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
char *BufferFile  ;
#line 191 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
char *PowDetachString  ;
#line 193 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
char *hstatusstring  ;
#line 194 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
char *captionstring  ;
#line 195 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
char *timestring  ;
#line 196 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
char *wliststr  ;
#line 197 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
char *wlisttit  ;
#line 198 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
int auto_detach  =    1;
#line 199 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
int iflag  ;
#line 199 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
int rflag  ;
#line 199 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
int dflag  ;
#line 199 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
int lsflag  ;
#line 199 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
int quietflag  ;
#line 199 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
int wipeflag  ;
#line 199 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
int xflag  ;
#line 200 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
int cmdflag  ;
#line 201 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
int adaptflag  ;
#line 204 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
char *multi  ;
#line 205 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
char *multi_home  ;
#line 206 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
int multi_uid  ;
#line 207 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
int own_uid  ;
#line 208 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
int multiattach  ;
#line 209 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
int tty_mode  ;
#line 210 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
int tty_oldmode  =    -1;
#line 213 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
char HostName[256]  ;
#line 214 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
int MasterPid  ;
#line 215 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
int real_uid  ;
#line 215 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
int real_gid  ;
#line 215 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
int eff_uid  ;
#line 215 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
int eff_gid  ;
#line 216 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
int default_startup  ;
#line 217 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
int ZombieKey_destroy  ;
#line 217 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
int ZombieKey_resurrect  ;
#line 218 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
char *preselect  =    (char *)((void *)0);
#line 221 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
char *screenencodings  ;
#line 225 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
int nethackflag  =    0;
#line 227 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
int maxwin  =    40;
#line 230 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
struct layer *flayer  ;
#line 231 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
struct win *fore  ;
#line 232 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
struct win *windows  ;
#line 233 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
struct win *console_window  ;
#line 31 "/home/pronto/abs/test-suite/screen-4.0.2/extern.h"
int main(int ac , char **av ) ;
#line 242 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
char strnomem[15]  = 
#line 242 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
  {      (char )'O',      (char )'u',      (char )'t',      (char )' ', 
        (char )'o',      (char )'f',      (char )' ',      (char )'m', 
        (char )'e',      (char )'m',      (char )'o',      (char )'r', 
        (char )'y',      (char )'.',      (char )'\000'};
#line 245 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
static int InterruptPlease  ;
#line 246 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
static int GotSigChld  ;
#line 248 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
static int lf_secreopen(char *name , int wantfd , struct logfile *l ) 
{ 
  int got_fd ;
  int tmp ;
  __dev_t tmp___0 ;

  {
  {
#line 256
  close(wantfd);
#line 257
  got_fd = secopen(name, 1089, 438);
  }
#line 257
  if (got_fd < 0) {
#line 257
    goto _L;
  } else {
    {
#line 257
    tmp = lf_move_fd(got_fd, wantfd);
    }
#line 257
    if (tmp < 0) {
      _L: /* CIL Label */ 
      {
#line 260
      logfclose(l);
      }
      {
#line 261
      while (1) {
        while_continue: /* CIL Label */ ;
#line 261
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 262
      return (-1);
    }
  }
#line 264
  tmp___0 = (__dev_t )0;
#line 264
  (l->st)->st_dev = tmp___0;
#line 264
  (l->st)->st_ino = (__ino_t )tmp___0;
  {
#line 265
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 265
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 266
  return (0);
}
}
#line 282 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
static char *spw  =    (char *)((void *)0);
#line 274 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
static struct passwd *getpwbyname(char *name , struct passwd *ppp___0 ) 
{ 
  int n ;
  struct spwd *sss ;
  int tmp ;
  char c ;
  size_t tmp___0 ;

  {
#line 281
  sss = (struct spwd *)((void *)0);
#line 285
  if (! ppp___0) {
    {
#line 285
    ppp___0 = getpwnam((char const   *)name);
    }
#line 285
    if (! ppp___0) {
#line 286
      return ((struct passwd *)((void *)0));
    }
  }
  pw_try_again: 
#line 292
  n = 0;
#line 293
  if ((int )*(ppp___0->pw_passwd + 0) == 35) {
#line 293
    if ((int )*(ppp___0->pw_passwd + 1) == 35) {
      {
#line 293
      tmp = strcmp((char const   *)(ppp___0->pw_passwd + 2), (char const   *)ppp___0->pw_name);
      }
#line 293
      if (tmp == 0) {
#line 295
        n = 13;
      }
    }
  }
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! (n < 13)) {
#line 296
      goto while_break;
    }
#line 298
    c = *(ppp___0->pw_passwd + n);
#line 299
    if (! ((int )c == 46)) {
#line 299
      if (! ((int )c == 47)) {
#line 299
        if (! ((int )c == 36)) {
#line 299
          if ((int )c >= 48) {
#line 299
            if (! ((int )c <= 57)) {
#line 299
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 299
          if ((int )c >= 97) {
#line 299
            if (! ((int )c <= 122)) {
#line 299
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 299
          if ((int )c >= 65) {
#line 299
            if (! ((int )c <= 90)) {
#line 303
              goto while_break;
            }
          } else {
#line 303
            goto while_break;
          }
        }
      }
    }
#line 296
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 308
  if (n < 13) {
#line 308
    if ((unsigned long )sss == (unsigned long )((struct spwd *)0)) {
      {
#line 310
      sss = getspnam((char const   *)ppp___0->pw_name);
      }
#line 311
      if (sss) {
#line 313
        if (spw) {
          {
#line 314
          free((void *)spw);
          }
        }
        {
#line 315
        spw = SaveStr((char const   *)sss->sp_pwdp);
#line 315
        ppp___0->pw_passwd = spw;
#line 316
        endspent();
        }
#line 317
        goto pw_try_again;
      }
      {
#line 319
      endspent();
      }
    }
  }
#line 322
  if (n < 13) {
#line 323
    ppp___0->pw_passwd = (char *)0;
  }
#line 325
  if (ppp___0->pw_passwd) {
    {
#line 325
    tmp___0 = strlen((char const   *)ppp___0->pw_passwd);
    }
#line 325
    if (tmp___0 == 24U) {
#line 326
      *(ppp___0->pw_passwd + 13) = (char)0;
    }
  }
#line 329
  return (ppp___0);
}
}
#line 333 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
int main(int ac , char **av ) 
{ 
  register int n ;
  char *ap ;
  char *av0 ;
  char socknamebuf[512] ;
  int mflag ;
  char *myname ;
  char const   *tmp ;
  char *SockDir ;
  struct stat st ;
  int oumask ;
  struct NewWindow nwin ;
  int detached ;
  char *sockp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  __uid_t tmp___7 ;
  __gid_t tmp___8 ;
  __uid_t tmp___9 ;
  __gid_t tmp___10 ;
  char *tmp___11 ;
  size_t tmp___12 ;
  register char *sh ;
  char *tmp___13 ;
  char nethackrc[4096] ;
  int tmp___14 ;
  int tmp___15 ;
  size_t tmp___16 ;
  char *tmp___17 ;
  struct passwd *mppp ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  int *tmp___23 ;
  int tmp___24 ;
  size_t tmp___25 ;
  int *tmp___26 ;
  __mode_t tmp___27 ;
  size_t tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int *tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int *tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int *tmp___41 ;
  int tmp___42 ;
  char *tmp___43 ;
  size_t tmp___44 ;
  int i ;
  int fo ;
  int oth ;
  int tmp___45 ;
  int tmp___46 ;
  char const   *tmp___47 ;
  char *sty ;
  size_t tmp___48 ;
  int tmp___49 ;
  char const   *tmp___50 ;
  register char *sty___0 ;
  int *tmp___51 ;
  char *tmp___52 ;
  size_t tmp___53 ;
  size_t tmp___54 ;
  size_t tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  __pid_t tmp___58 ;
  struct display *tmp___59 ;
  __pid_t tmp___60 ;
  char *tmp___61 ;
  __pid_t tmp___62 ;
  size_t tmp___63 ;
  size_t tmp___64 ;
  int tmp___65 ;
  int *tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;

  {
#line 342
  mflag = 0;
#line 343
  if (ac == 0) {
#line 343
    tmp = "screen";
  } else {
#line 343
    tmp = (char const   *)*(av + 0);
  }
  {
#line 343
  myname = (char *)tmp;
#line 355
  detached = 0;
#line 376
  closeallfiles(0);
#line 380
  sprintf((char */* __restrict  */)(version), (char const   */* __restrict  */)"%d.%.2d.%.2d%s (%s) %s",
          4, 0, 2, "", "FAU", "5-Dec-03");
#line 382
  nversion = 40002;
  }
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
#line 383
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 385
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 385
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 388
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 388
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 397
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 397
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 400
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 400
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 403
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 403
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 412
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 412
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 415
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 415
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 418
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 418
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 421
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 421
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 424
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 424
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 427
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 427
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 430
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 430
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 433
  BellString = SaveStr("Bell in window %n");
#line 434
  VisualBellString = SaveStr("   Wuff,  Wuff!!  ");
#line 435
  ActivityString = SaveStr("Activity in window %n");
#line 436
  screenlogfile = SaveStr("screenlog.%n");
#line 437
  logtstamp_string = SaveStr("-- %n:%t -- time-stamp -- %M/%d/%y %c:%s --\n");
#line 438
  hstatusstring = SaveStr("%h");
#line 439
  captionstring = SaveStr("%3n %t");
#line 440
  timestring = SaveStr("%c:%s %M %d %H%? %l%?");
#line 441
  wlisttit = SaveStr("Num Name%=Flags");
#line 442
  wliststr = SaveStr("%3n %t%=%f");
#line 444
  BufferFile = SaveStr("/tmp/screen-exchange");
#line 446
  ShellProg = (char *)((void *)0);
#line 448
  PowDetachString = (char *)0;
  }
#line 450
  if (ac > 1) {
#line 450
    default_startup = 0;
  } else {
#line 450
    default_startup = 1;
  }
  {
#line 451
  adaptflag = 0;
#line 452
  VBellWait = 1000;
#line 453
  MsgWait = 5000;
#line 454
  MsgMinWait = 1000;
#line 455
  SilenceWait = 30;
#line 460
  zmodem_sendcmd = SaveStr("!!! sz -vv -b ");
#line 461
  zmodem_recvcmd = SaveStr("!!! rz -vv -b -E");
#line 465
  CompileKeys((char *)0, 0, mark_key_tab);
#line 468
  InitBuiltinTabs();
#line 469
  screenencodings = SaveStr("/usr/share/screen/utf8encodings");
#line 471
  nwin = nwin_undef;
#line 472
  nwin_options = nwin_undef;
#line 473
  strcpy((char */* __restrict  */)(screenterm), (char const   */* __restrict  */)"screen");
#line 475
  logreopen_register(& lf_secreopen);
#line 477
  av0 = *av;
  }
#line 479
  if ((int )*av0 == 45) {
    {
#line 481
    rflag = 4;
#line 483
    xflag = 1;
#line 487
    ShellProg = SaveStr((char const   *)(DefaultShell));
    }
  }
  {
#line 489
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 489
    if (! (ac > 0)) {
#line 489
      goto while_break___12;
    }
#line 491
    av ++;
#line 491
    ap = *av;
#line 492
    ac --;
#line 492
    if (ac > 0) {
#line 492
      if ((int )*ap == 45) {
#line 494
        if ((int )*(ap + 1) == 45) {
#line 494
          if ((int )*(ap + 2) == 0) {
#line 496
            av ++;
#line 497
            ac --;
#line 498
            goto while_break___12;
          }
        }
#line 500
        if ((int )*(ap + 1) == 45) {
          {
#line 500
          tmp___0 = strcmp((char const   *)ap, "--version");
          }
#line 500
          if (! tmp___0) {
            {
#line 501
            Panic(0, (char *)"Screen version %s", version);
            }
          }
        }
#line 502
        if ((int )*(ap + 1) == 45) {
          {
#line 502
          tmp___1 = strcmp((char const   *)ap, "--help");
          }
#line 502
          if (! tmp___1) {
            {
#line 503
            exit_with_usage(myname, (char *)((void *)0), (char *)((void *)0));
            }
          }
        }
        {
#line 504
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 504
          if (ap) {
#line 504
            if (*ap) {
#line 504
              ap ++;
#line 504
              if (! *ap) {
#line 504
                goto while_break___13;
              }
            } else {
#line 504
              goto while_break___13;
            }
          } else {
#line 504
            goto while_break___13;
          }
          {
#line 508
          if ((int )*ap == 97) {
#line 508
            goto case_97;
          }
#line 511
          if ((int )*ap == 65) {
#line 511
            goto case_65;
          }
#line 514
          if ((int )*ap == 112) {
#line 514
            goto case_112;
          }
#line 530
          if ((int )*ap == 99) {
#line 530
            goto case_99;
          }
#line 541
          if ((int )*ap == 101) {
#line 541
            goto case_101;
          }
#line 552
          if ((int )*ap == 102) {
#line 552
            goto case_102;
          }
#line 574
          if ((int )*ap == 104) {
#line 574
            goto case_104;
          }
#line 581
          if ((int )*ap == 105) {
#line 581
            goto case_105;
          }
#line 584
          if ((int )*ap == 116) {
#line 584
            goto case_116;
          }
#line 589
          if ((int )*ap == 108) {
#line 589
            goto case_108;
          }
#line 621
          if ((int )*ap == 119) {
#line 621
            goto case_119;
          }
#line 630
          if ((int )*ap == 76) {
#line 630
            goto case_76;
          }
#line 633
          if ((int )*ap == 109) {
#line 633
            goto case_109;
          }
#line 636
          if ((int )*ap == 79) {
#line 636
            goto case_79;
          }
#line 639
          if ((int )*ap == 84) {
#line 639
            goto case_84;
          }
#line 648
          if ((int )*ap == 113) {
#line 648
            goto case_113;
          }
#line 654
          if ((int )*ap == 120) {
#line 654
            goto case_120;
          }
#line 654
          if ((int )*ap == 82) {
#line 654
            goto case_120;
          }
#line 654
          if ((int )*ap == 114) {
#line 654
            goto case_120;
          }
#line 671
          if ((int )*ap == 100) {
#line 671
            goto case_100;
          }
#line 674
          if ((int )*ap == 68) {
#line 674
            goto case_68;
          }
#line 688
          if ((int )*ap == 115) {
#line 688
            goto case_115___0;
          }
#line 696
          if ((int )*ap == 83) {
#line 696
            goto case_83;
          }
#line 706
          if ((int )*ap == 88) {
#line 706
            goto case_88;
          }
#line 709
          if ((int )*ap == 118) {
#line 709
            goto case_118;
          }
#line 713
          if ((int )*ap == 85) {
#line 713
            goto case_85;
          }
#line 717
          goto switch_default___1;
          case_97: /* CIL Label */ 
#line 509
          nwin_options.aflag = 1;
#line 510
          goto switch_break;
          case_65: /* CIL Label */ 
#line 512
          adaptflag = 1;
#line 513
          goto switch_break;
          case_112: /* CIL Label */ 
#line 515
          ap ++;
#line 515
          if (*ap) {
#line 516
            preselect = ap;
          } else {
#line 519
            ac --;
#line 519
            if (! ac) {
              {
#line 520
              exit_with_usage(myname, (char *)"Specify a window to preselect with -p",
                              (char *)((void *)0));
              }
            }
#line 521
            av ++;
#line 521
            preselect = *av;
          }
#line 523
          ap = (char *)((void *)0);
#line 524
          goto switch_break;
          case_99: /* CIL Label */ 
#line 531
          ap ++;
#line 531
          if (*ap) {
#line 532
            RcFileName = ap;
          } else {
#line 535
            ac --;
#line 535
            if (ac == 0) {
              {
#line 536
              exit_with_usage(myname, (char *)"Specify an alternate rc-filename with -c",
                              (char *)((void *)0));
              }
            }
#line 537
            av ++;
#line 537
            RcFileName = *av;
          }
#line 539
          ap = (char *)((void *)0);
#line 540
          goto switch_break;
          case_101: /* CIL Label */ 
#line 542
          ap ++;
#line 542
          if (! *ap) {
#line 544
            ac --;
#line 544
            if (ac == 0) {
              {
#line 545
              exit_with_usage(myname, (char *)"Specify command characters with -e",
                              (char *)((void *)0));
              }
            }
#line 546
            av ++;
#line 546
            ap = *av;
          }
          {
#line 548
          tmp___2 = ParseEscape(ap);
          }
#line 548
          if (tmp___2) {
            {
#line 549
            Panic(0, (char *)"Two characters are required with -e option, not \'%s\'.",
                  ap);
            }
          }
#line 550
          ap = (char *)((void *)0);
#line 551
          goto switch_break;
          case_102: /* CIL Label */ 
#line 553
          ap ++;
#line 554
          tmp___3 = ap;
#line 554
          ap ++;
          {
#line 557
          if ((int )*tmp___3 == 48) {
#line 557
            goto case_48;
          }
#line 557
          if ((int )*tmp___3 == 110) {
#line 557
            goto case_48;
          }
#line 560
          if ((int )*tmp___3 == 0) {
#line 560
            goto case_0;
          }
#line 564
          if ((int )*tmp___3 == 49) {
#line 564
            goto case_49;
          }
#line 564
          if ((int )*tmp___3 == 121) {
#line 564
            goto case_49;
          }
#line 567
          if ((int )*tmp___3 == 97) {
#line 567
            goto case_97___0;
          }
#line 570
          goto switch_default;
          case_48: /* CIL Label */ 
          case_110: /* CIL Label */ 
#line 558
          nwin_options.flowflag = 0;
#line 559
          goto switch_break___0;
          case_0: /* CIL Label */ 
#line 561
          ap --;
          case_49: /* CIL Label */ 
          case_121: /* CIL Label */ 
#line 565
          nwin_options.flowflag = 1;
#line 566
          goto switch_break___0;
          case_97___0: /* CIL Label */ 
#line 568
          nwin_options.flowflag = 1 << 2;
#line 569
          goto switch_break___0;
          switch_default: /* CIL Label */ 
          {
#line 571
          ap --;
#line 571
          exit_with_usage(myname, (char *)"Unknown flow option -%s", ap);
          }
          switch_break___0: /* CIL Label */ ;
          }
#line 573
          goto switch_break;
          case_104: /* CIL Label */ 
#line 575
          ac --;
#line 575
          if (ac == 0) {
            {
#line 576
            exit_with_usage(myname, (char *)((void *)0), (char *)((void *)0));
            }
          }
          {
#line 577
          av ++;
#line 577
          nwin_options.histheight = atoi((char const   *)*av);
          }
#line 578
          if (nwin_options.histheight < 0) {
            {
#line 579
            exit_with_usage(myname, (char *)"-h: %s: negative scrollback size?", *av);
            }
          }
#line 580
          goto switch_break;
          case_105: /* CIL Label */ 
#line 582
          iflag = 1;
#line 583
          goto switch_break;
          case_116: /* CIL Label */ 
#line 585
          ac --;
#line 585
          if (ac == 0) {
            {
#line 586
            exit_with_usage(myname, (char *)"Specify a new window-name with -t", (char *)((void *)0));
            }
          }
#line 587
          av ++;
#line 587
          nwin_options.aka = *av;
#line 588
          goto switch_break;
          case_108: /* CIL Label */ 
#line 590
          ap ++;
#line 591
          tmp___4 = ap;
#line 591
          ap ++;
          {
#line 594
          if ((int )*tmp___4 == 48) {
#line 594
            goto case_48___0;
          }
#line 594
          if ((int )*tmp___4 == 110) {
#line 594
            goto case_48___0;
          }
#line 597
          if ((int )*tmp___4 == 0) {
#line 597
            goto case_0___0;
          }
#line 601
          if ((int )*tmp___4 == 49) {
#line 601
            goto case_49___0;
          }
#line 601
          if ((int )*tmp___4 == 121) {
#line 601
            goto case_49___0;
          }
#line 604
          if ((int )*tmp___4 == 97) {
#line 604
            goto case_97___1;
          }
#line 608
          if ((int )*tmp___4 == 105) {
#line 608
            goto case_105___0;
          }
#line 608
          if ((int )*tmp___4 == 115) {
#line 608
            goto case_105___0;
          }
#line 617
          goto switch_default___0;
          case_48___0: /* CIL Label */ 
          case_110___0: /* CIL Label */ 
#line 595
          nwin_options.lflag = 0;
#line 596
          goto switch_break___1;
          case_0___0: /* CIL Label */ 
#line 598
          ap --;
          case_49___0: /* CIL Label */ 
          case_121___0: /* CIL Label */ 
#line 602
          nwin_options.lflag = 1;
#line 603
          goto switch_break___1;
          case_97___1: /* CIL Label */ 
#line 605
          nwin_options.lflag = 3;
#line 606
          goto switch_break___1;
          case_105___0: /* CIL Label */ 
          case_115: /* CIL Label */ 
#line 609
          lsflag = 1;
#line 610
          if (ac > 1) {
#line 610
            if (! SockMatch) {
#line 612
              av ++;
#line 612
              SockMatch = *av;
#line 613
              ac --;
            }
          }
#line 615
          ap = (char *)((void *)0);
#line 616
          goto switch_break___1;
          switch_default___0: /* CIL Label */ 
          {
#line 618
          ap --;
#line 618
          exit_with_usage(myname, (char *)"%s: Unknown suboption to -l", ap);
          }
          switch_break___1: /* CIL Label */ ;
          }
#line 620
          goto switch_break;
          case_119: /* CIL Label */ 
#line 622
          lsflag = 1;
#line 623
          wipeflag = 1;
#line 624
          if (ac > 1) {
#line 624
            if (! SockMatch) {
#line 626
              av ++;
#line 626
              SockMatch = *av;
#line 627
              ac --;
            }
          }
#line 629
          goto switch_break;
          case_76: /* CIL Label */ 
#line 631
          nwin_options.Lflag = 1;
#line 632
          goto switch_break;
          case_109: /* CIL Label */ 
#line 634
          mflag = 1;
#line 635
          goto switch_break;
          case_79: /* CIL Label */ 
#line 637
          force_vt = 0;
#line 638
          goto switch_break;
          case_84: /* CIL Label */ 
#line 640
          ac --;
#line 640
          if (ac == 0) {
            {
#line 641
            exit_with_usage(myname, (char *)"Specify terminal-type with -T", (char *)((void *)0));
            }
          }
          {
#line 642
          av ++;
#line 642
          tmp___5 = strlen((char const   *)*av);
          }
#line 642
          if (tmp___5 < 20U) {
            {
#line 643
            strcpy((char */* __restrict  */)(screenterm), (char const   */* __restrict  */)*av);
            }
          } else {
            {
#line 645
            Panic(0, (char *)"-T: terminal name too long. (max. 20 char)");
            }
          }
#line 646
          nwin_options.term = screenterm;
#line 647
          goto switch_break;
          case_113: /* CIL Label */ 
#line 649
          quietflag = 1;
#line 650
          goto switch_break;
          case_120: /* CIL Label */ 
          case_82: /* CIL Label */ 
          case_114: /* CIL Label */ 
#line 656
          if (ac > 1) {
#line 656
            if ((int )*(*(av + 1)) != 45) {
#line 656
              if (! SockMatch) {
#line 658
                av ++;
#line 658
                SockMatch = *av;
#line 659
                ac --;
                {
#line 660
                while (1) {
                  while_continue___14: /* CIL Label */ ;
#line 660
                  goto while_break___14;
                }
                while_break___14: /* CIL Label */ ;
                }
              }
            }
          }
#line 663
          if ((int )*ap == 120) {
#line 664
            xflag = 1;
          }
#line 666
          if (rflag) {
#line 667
            rflag = 2;
          }
#line 668
          if ((int )*ap == 82) {
#line 668
            tmp___6 = 2;
          } else {
#line 668
            tmp___6 = 1;
          }
#line 668
          rflag += tmp___6;
#line 669
          goto switch_break;
          case_100: /* CIL Label */ 
#line 672
          dflag = 1;
          case_68: /* CIL Label */ 
#line 675
          if (! dflag) {
#line 676
            dflag = 2;
          }
#line 677
          if (ac == 2) {
#line 679
            if ((int )*(*(av + 1)) != 45) {
#line 679
              if (! SockMatch) {
#line 681
                av ++;
#line 681
                SockMatch = *av;
#line 682
                ac --;
                {
#line 683
                while (1) {
                  while_continue___15: /* CIL Label */ ;
#line 683
                  goto while_break___15;
                }
                while_break___15: /* CIL Label */ ;
                }
              }
            }
          }
#line 686
          goto switch_break;
          case_115___0: /* CIL Label */ 
#line 689
          ac --;
#line 689
          if (ac == 0) {
            {
#line 690
            exit_with_usage(myname, (char *)"Specify shell with -s", (char *)((void *)0));
            }
          }
#line 691
          if (ShellProg) {
            {
#line 692
            free((void *)ShellProg);
            }
          }
          {
#line 693
          av ++;
#line 693
          ShellProg = SaveStr((char const   *)*av);
          }
          {
#line 694
          while (1) {
            while_continue___16: /* CIL Label */ ;
#line 694
            goto while_break___16;
          }
          while_break___16: /* CIL Label */ ;
          }
#line 695
          goto switch_break;
          case_83: /* CIL Label */ 
#line 697
          if (! SockMatch) {
#line 699
            ac --;
#line 699
            if (ac == 0) {
              {
#line 700
              exit_with_usage(myname, (char *)"Specify session-name with -S", (char *)((void *)0));
              }
            }
#line 701
            av ++;
#line 701
            SockMatch = *av;
          }
#line 703
          if (! *SockMatch) {
            {
#line 704
            exit_with_usage(myname, (char *)"Empty session-name?", (char *)((void *)0));
            }
          }
#line 705
          goto switch_break;
          case_88: /* CIL Label */ 
#line 707
          cmdflag = 1;
#line 708
          goto switch_break;
          case_118: /* CIL Label */ 
          {
#line 710
          Panic(0, (char *)"Screen version %s", version);
          }
          case_85: /* CIL Label */ 
#line 714
          if (nwin_options.encoding == -1) {
#line 714
            nwin_options.encoding = 8;
          } else {
#line 714
            nwin_options.encoding = 0;
          }
#line 715
          goto switch_break;
          switch_default___1: /* CIL Label */ 
          {
#line 718
          ap --;
#line 718
          exit_with_usage(myname, (char *)"Unknown option %s", ap);
          }
          switch_break: /* CIL Label */ ;
          }
        }
        while_break___13: /* CIL Label */ ;
        }
      } else {
#line 723
        goto while_break___12;
      }
    } else {
#line 723
      goto while_break___12;
    }
  }
  while_break___12: /* CIL Label */ ;
  }
  {
#line 726
  tmp___7 = getuid();
#line 726
  real_uid = (int )tmp___7;
#line 727
  tmp___8 = getgid();
#line 727
  real_gid = (int )tmp___8;
#line 728
  tmp___9 = geteuid();
#line 728
  eff_uid = (int )tmp___9;
#line 729
  tmp___10 = getegid();
#line 729
  eff_gid = (int )tmp___10;
  }
#line 730
  if (eff_uid != real_uid) {
    {
#line 737
    xsignal(7, & CoreDump);
#line 739
    xsignal(11, & CoreDump);
    }
  }
  {
#line 743
  setlocale(6, "");
  }
#line 746
  if (nwin_options.encoding == -1) {
    {
#line 753
    tmp___11 = nl_langinfo(14);
#line 753
    nwin_options.encoding = FindEncoding(tmp___11);
    }
    {
#line 754
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 754
      goto while_break___17;
    }
    while_break___17: /* CIL Label */ ;
    }
  }
#line 766
  if (SockMatch) {
    {
#line 766
    tmp___12 = strlen((char const   *)SockMatch);
    }
#line 766
    if (tmp___12 >= 256U) {
      {
#line 767
      Panic(0, (char *)"Ridiculously long socketname - try again.");
      }
    }
  }
#line 768
  if (cmdflag) {
#line 768
    if (! rflag) {
#line 768
      if (! dflag) {
#line 768
        if (! xflag) {
#line 769
          xflag = 1;
        }
      }
    }
  }
#line 770
  if (! cmdflag) {
#line 770
    if (dflag) {
#line 770
      if (mflag) {
#line 770
        if (! rflag) {
#line 770
          if (! xflag) {
#line 771
            detached = 1;
          }
        }
      }
    }
  }
#line 772
  nwin = nwin_options;
#line 774
  nwin.encoding = nwin_undef.encoding;
#line 776
  if (ac) {
#line 777
    nwin.args = av;
  }
  {
#line 790
  xsignal(25, (void (*)(int  ))1);
#line 794
  xsignal(13, (void (*)(int  ))1);
  }
#line 797
  if (! ShellProg) {
    {
#line 801
    sh = getenv("SHELL");
    }
#line 802
    if (sh) {
#line 802
      tmp___13 = sh;
    } else {
#line 802
      tmp___13 = DefaultShell;
    }
    {
#line 802
    ShellProg = SaveStr((char const   *)tmp___13);
    }
  }
  {
#line 804
  ShellArgs[0] = ShellProg;
#line 805
  home = getenv("HOME");
#line 808
  tmp___17 = getenv("NETHACKOPTIONS");
#line 808
  nethackflag = (unsigned long )tmp___17 != (unsigned long )((void *)0);
  }
#line 808
  if (! nethackflag) {
#line 812
    if (home) {
      {
#line 812
      tmp___16 = strlen((char const   *)home);
      }
#line 812
      if (tmp___16 < 4076U) {
        {
#line 814
        sprintf((char */* __restrict  */)(nethackrc), (char const   */* __restrict  */)"%s/.nethackrc",
                home);
#line 815
        tmp___14 = access((char const   *)(nethackrc), 0);
        }
#line 815
        if (tmp___14) {
#line 815
          tmp___15 = 0;
        } else {
#line 815
          tmp___15 = 1;
        }
#line 815
        nethackflag = tmp___15;
      }
    }
  }
#line 821
  multi_uid = real_uid;
#line 821
  own_uid = multi_uid;
#line 822
  if (SockMatch) {
    {
#line 822
    sockp = index((char const   *)SockMatch, '/');
    }
#line 822
    if (sockp) {
#line 824
      if (eff_uid) {
        {
#line 825
        Panic(0, (char *)"Must run suid root for multiuser support.");
        }
      }
#line 826
      *sockp = (char)0;
#line 827
      multi = SockMatch;
#line 828
      SockMatch = sockp + 1;
#line 829
      if (*multi) {
        {
#line 832
        mppp = getpwnam((char const   *)multi);
        }
#line 832
        if ((unsigned long )mppp == (unsigned long )((struct passwd *)0)) {
          {
#line 833
          Panic(0, (char *)"Cannot identify account \'%s\'.", multi);
          }
        }
        {
#line 834
        multi_uid = (int )mppp->pw_uid;
#line 835
        multi_home = SaveStr((char const   *)mppp->pw_dir);
#line 836
        tmp___18 = strlen((char const   *)multi_home);
        }
#line 836
        if (tmp___18 > 4086U) {
          {
#line 837
          Panic(0, (char *)"home directory path too long");
          }
        }
#line 840
        if (rflag) {
#line 841
          xflag = 1;
        } else
#line 840
        if (lsflag) {
#line 841
          xflag = 1;
        }
#line 843
        detached = 0;
#line 844
        multiattach = 1;
      }
    }
  }
#line 847
  if (SockMatch) {
#line 847
    if ((int )*SockMatch == 0) {
#line 848
      SockMatch = (char *)0;
    }
  }
  {
#line 851
  LoginName = getlogin();
  }
#line 851
  if (LoginName) {
#line 851
    if ((int )*(LoginName + 0) != 0) {
      {
#line 853
      ppp = getpwnam((char const   *)LoginName);
      }
#line 853
      if ((unsigned long )ppp != (unsigned long )((struct passwd *)0)) {
#line 854
        if ((int )ppp->pw_uid != real_uid) {
#line 855
          ppp = (struct passwd *)0;
        }
      }
    }
  }
#line 857
  if ((unsigned long )ppp == (unsigned long )((struct passwd *)0)) {
    {
#line 859
    ppp = getpwuid((__uid_t )real_uid);
    }
#line 859
    if ((unsigned long )ppp == (unsigned long )((struct passwd *)0)) {
      {
#line 861
      Panic(0, (char *)"getpwuid() can\'t identify your account!");
#line 862
      exit(1);
      }
    }
#line 864
    LoginName = ppp->pw_name;
  }
  {
#line 866
  LoginName = SaveStr((char const   *)LoginName);
#line 868
  ppp = getpwbyname(LoginName, ppp);
  }
#line 878
  if ((unsigned long )home == (unsigned long )((char *)0)) {
#line 879
    home = ppp->pw_dir;
  } else
#line 878
  if ((int )*home == 0) {
#line 879
    home = ppp->pw_dir;
  }
  {
#line 880
  tmp___19 = strlen((char const   *)LoginName);
  }
#line 880
  if (tmp___19 > 20U) {
    {
#line 881
    Panic(0, (char *)"LoginName too long - sorry.");
    }
  }
#line 883
  if (multi) {
    {
#line 883
    tmp___20 = strlen((char const   *)multi);
    }
#line 883
    if (tmp___20 > 20U) {
      {
#line 884
      Panic(0, (char *)"Screen owner name too long - sorry.");
      }
    }
  }
  {
#line 886
  tmp___21 = strlen((char const   *)home);
  }
#line 886
  if (tmp___21 > 4071U) {
    {
#line 887
    Panic(0, (char *)"$HOME too long - sorry.");
    }
  }
#line 889
  attach_tty = (char *)"";
#line 890
  if (! detached) {
#line 890
    if (! lsflag) {
#line 890
      if (! cmdflag) {
#line 890
        if (dflag) {
#line 890
          if (! mflag) {
#line 890
            if (! rflag) {
#line 890
              if (! (! xflag)) {
#line 890
                goto _L___1;
              }
            } else {
#line 890
              goto _L___1;
            }
          } else {
#line 890
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
          {
#line 893
          attach_tty = ttyname(0);
          }
#line 893
          if (! attach_tty) {
            {
#line 894
            Panic(0, (char *)"Must be connected to a terminal.");
            }
          }
          {
#line 895
          tmp___22 = strlen((char const   *)attach_tty);
          }
#line 895
          if (tmp___22 >= 4096U) {
            {
#line 896
            Panic(0, (char *)"TtyName too long - sorry.");
            }
          }
          {
#line 897
          tmp___24 = stat((char const   */* __restrict  */)attach_tty, (struct stat */* __restrict  */)(& st));
          }
#line 897
          if (tmp___24) {
            {
#line 898
            tmp___23 = __errno_location();
#line 898
            Panic(*tmp___23, (char *)"Cannot access \'%s\'", attach_tty);
            }
          }
          {
#line 900
          tty_mode = (int )st.st_mode & 511;
#line 902
          n = secopen(attach_tty, 2050, 0);
          }
#line 902
          if (n < 0) {
            {
#line 903
            Panic(0, (char *)"Cannot open your terminal \'%s\' - please check.", attach_tty);
            }
          }
          {
#line 904
          close(n);
          }
          {
#line 905
          while (1) {
            while_continue___18: /* CIL Label */ ;
#line 905
            goto while_break___18;
          }
          while_break___18: /* CIL Label */ ;
          }
          {
#line 906
          attach_term = getenv("TERM");
          }
#line 906
          if ((unsigned long )attach_term == (unsigned long )((char *)0)) {
            {
#line 907
            Panic(0, (char *)"Please set a terminal type.");
            }
          } else
#line 906
          if ((int )*attach_term == 0) {
            {
#line 907
            Panic(0, (char *)"Please set a terminal type.");
            }
          }
          {
#line 908
          tmp___25 = strlen((char const   *)attach_term);
          }
#line 908
          if ((unsigned long )tmp___25 > sizeof(display->d_termname) - 1UL) {
            {
#line 909
            Panic(0, (char *)"$TERM too long - sorry.");
            }
          }
          {
#line 910
          GetTTY(0, & attach_Mode);
          }
        }
      }
    }
  }
  {
#line 919
  tmp___27 = umask((__mode_t )0);
#line 919
  oumask = (int )tmp___27;
  }
#line 919
  if (oumask == -1) {
    {
#line 920
    tmp___26 = __errno_location();
#line 920
    Panic(*tmp___26, (char *)"Cannot change umask to zero");
    }
  }
  {
#line 922
  SockDir = getenv("SCREENDIR");
  }
#line 923
  if (SockDir) {
    {
#line 925
    tmp___28 = strlen((char const   *)SockDir);
    }
#line 925
    if (tmp___28 >= 4095U) {
      {
#line 926
      Panic(0, (char *)"Ridiculously long $SCREENDIR - try again.");
      }
    }
#line 928
    if (multi) {
      {
#line 929
      Panic(0, (char *)"No $SCREENDIR with multi screens, please.");
      }
    }
  }
#line 933
  if (multiattach) {
#line 939
    if (eff_uid) {
#line 939
      SockDir = (char *)"/tmp/uscreens";
    } else {
#line 939
      SockDir = (char *)"/tmp/screens";
    }
    {
#line 940
    sprintf((char */* __restrict  */)(SockPath), (char const   */* __restrict  */)"%s/S-%s",
            SockDir, multi);
    }
  } else
#line 953
  if (SockDir) {
    {
#line 955
    tmp___32 = access((char const   *)SockDir, 0);
    }
#line 955
    if (tmp___32) {
      {
#line 957
      while (1) {
        while_continue___19: /* CIL Label */ ;
#line 957
        goto while_break___19;
      }
      while_break___19: /* CIL Label */ ;
      }
      {
#line 958
      tmp___30 = UserContext();
      }
#line 958
      if (tmp___30 > 0) {
        {
#line 960
        tmp___29 = mkdir((char const   *)SockDir, (__mode_t )448);
        }
#line 960
        if (tmp___29) {
          {
#line 961
          UserReturn(0);
          }
        }
        {
#line 962
        UserReturn(1);
        }
      }
      {
#line 964
      tmp___31 = UserStatus();
      }
#line 964
      if (tmp___31 <= 0) {
        {
#line 965
        Panic(0, (char *)"Cannot make directory \'%s\'.", SockDir);
        }
      }
    }
#line 967
    if ((unsigned long )SockDir != (unsigned long )(SockPath)) {
      {
#line 968
      strcpy((char */* __restrict  */)(SockPath), (char const   */* __restrict  */)SockDir);
      }
    }
  } else {
#line 973
    if (eff_uid) {
#line 973
      SockDir = (char *)"/tmp/uscreens";
    } else {
#line 973
      SockDir = (char *)"/tmp/screens";
    }
    {
#line 974
    tmp___37 = lstat((char const   */* __restrict  */)SockDir, (struct stat */* __restrict  */)(& st));
    }
#line 974
    if (tmp___37) {
#line 976
      if (eff_uid == 0) {
#line 976
        if (real_uid) {
#line 976
          n = 493;
        } else
#line 976
        if (eff_gid == real_gid) {
#line 976
          n = 493;
        } else {
#line 976
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
#line 976
        if (eff_gid != real_gid) {
#line 976
          tmp___33 = 509;
        } else {
#line 976
          tmp___33 = 1023;
        }
#line 976
        n = tmp___33;
      }
      {
#line 983
      tmp___35 = mkdir((char const   *)SockDir, (__mode_t )n);
      }
#line 983
      if (tmp___35 == -1) {
        {
#line 984
        tmp___34 = __errno_location();
#line 984
        Panic(*tmp___34, (char *)"Cannot make directory \'%s\'", SockDir);
        }
      }
    } else {
#line 988
      if (! ((st.st_mode & 61440U) == 16384U)) {
        {
#line 989
        Panic(0, (char *)"\'%s\' must be a directory.", SockDir);
        }
      }
#line 990
      if (eff_uid == 0) {
#line 990
        if (real_uid) {
#line 990
          if ((int )st.st_uid != eff_uid) {
            {
#line 991
            Panic(0, (char *)"Directory \'%s\' must be owned by root.", SockDir);
            }
          }
        }
      }
#line 992
      if (eff_uid == 0) {
#line 992
        if (real_uid) {
#line 992
          n = 493;
        } else
#line 992
        if ((st.st_mode & 509U) != 509U) {
#line 992
          n = 493;
        } else {
#line 992
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ 
#line 992
        if (eff_gid == (int )st.st_gid) {
#line 992
          if (eff_gid != real_gid) {
#line 992
            tmp___36 = 509;
          } else {
#line 992
            tmp___36 = 511;
          }
        } else {
#line 992
          tmp___36 = 511;
        }
#line 992
        n = tmp___36;
      }
#line 995
      if (((int )st.st_mode & 511) != n) {
        {
#line 996
        Panic(0, (char *)"Directory \'%s\' must have mode %03o.", SockDir, n);
        }
      }
    }
    {
#line 998
    sprintf((char */* __restrict  */)(SockPath), (char const   */* __restrict  */)"%s/S-%s",
            SockDir, LoginName);
#line 999
    tmp___40 = access((char const   *)(SockPath), 0);
    }
#line 999
    if (tmp___40) {
      {
#line 1001
      tmp___39 = mkdir((char const   *)(SockPath), (__mode_t )448);
      }
#line 1001
      if (tmp___39 == -1) {
        {
#line 1002
        tmp___38 = __errno_location();
#line 1002
        Panic(*tmp___38, (char *)"Cannot make directory \'%s\'", SockPath);
        }
      }
      {
#line 1003
      chown((char const   *)(SockPath), (__uid_t )real_uid, (__gid_t )real_gid);
      }
    }
  }
  {
#line 1009
  tmp___42 = stat((char const   */* __restrict  */)(SockPath), (struct stat */* __restrict  */)(& st));
  }
#line 1009
  if (tmp___42 == -1) {
    {
#line 1010
    tmp___41 = __errno_location();
#line 1010
    Panic(*tmp___41, (char *)"Cannot access %s", SockPath);
    }
  } else
#line 1012
  if (! ((st.st_mode & 61440U) == 16384U)) {
    {
#line 1013
    Panic(0, (char *)"%s is not a directory.", SockPath);
    }
  }
#line 1015
  if (multi) {
#line 1017
    if ((int )st.st_uid != multi_uid) {
      {
#line 1018
      Panic(0, (char *)"%s is not the owner of %s.", multi, SockPath);
      }
    }
  } else
#line 1023
  if ((int )st.st_uid != real_uid) {
    {
#line 1024
    Panic(0, (char *)"You are not the owner of %s.", SockPath);
    }
  }
#line 1026
  if ((st.st_mode & 511U) != 448U) {
    {
#line 1027
    Panic(0, (char *)"Directory %s must have mode 700.", SockPath);
    }
  }
#line 1028
  if (SockMatch) {
    {
#line 1028
    tmp___43 = index((char const   *)SockMatch, '/');
    }
#line 1028
    if (tmp___43) {
      {
#line 1029
      Panic(0, (char *)"Bad session name \'%s\'", SockMatch);
      }
    }
  }
  {
#line 1030
  tmp___44 = strlen((char const   *)(SockPath));
#line 1030
  SockName = (SockPath + tmp___44) + 1;
#line 1031
  *SockName = (char)0;
#line 1032
  umask((__mode_t )oumask);
  }
  {
#line 1033
  while (1) {
    while_continue___20: /* CIL Label */ ;
#line 1033
    goto while_break___20;
  }
  while_break___20: /* CIL Label */ ;
  }
  {
#line 1041
  gethostname(HostName, (size_t )256);
#line 1042
  HostName[255] = (char )'\000';
#line 1044
  ap = index((char const   *)(HostName), '.');
  }
#line 1044
  if ((unsigned long )ap != (unsigned long )((void *)0)) {
#line 1045
    *ap = (char )'\000';
  }
#line 1047
  if (lsflag) {
#line 1052
    if (multi) {
#line 1053
      real_uid = multi_uid;
    }
    {
#line 1055
    setgid((__gid_t )real_gid);
#line 1056
    setuid((__uid_t )real_uid);
#line 1057
    eff_uid = real_uid;
#line 1058
    eff_gid = real_gid;
#line 1059
    i = FindSocket((int *)((void *)0), & fo, & oth, SockMatch);
    }
#line 1060
    if (quietflag) {
#line 1061
      if (fo) {
#line 1061
        if (oth) {
#line 1061
          tmp___45 = 2;
        } else
#line 1061
        if (i) {
#line 1061
          tmp___45 = 2;
        } else {
#line 1061
          tmp___45 = 1;
        }
#line 1061
        tmp___46 = tmp___45;
      } else {
#line 1061
        tmp___46 = 0;
      }
      {
#line 1061
      exit((8 + tmp___46) + i);
      }
    }
#line 1062
    if (fo == 0) {
      {
#line 1063
      Panic(0, (char *)"No Sockets found in %s.\n", SockPath);
      }
    }
#line 1064
    if (fo > 1) {
#line 1064
      tmp___47 = "s";
    } else {
#line 1064
      tmp___47 = "";
    }
    {
#line 1064
    Panic(0, (char *)"%d Socket%s in %s.\n", fo, tmp___47, SockPath);
    }
  }
  {
#line 1067
  xsignal(1, & AttacherFinit);
  }
#line 1068
  if (cmdflag) {
    {
#line 1070
    sty = (char *)0;
#line 1073
    attach_tty = ttyname(0);
    }
#line 1073
    if ((unsigned long )attach_tty == (unsigned long )((char *)0)) {
#line 1074
      attach_tty = (char *)"";
    }
    {
#line 1075
    tmp___48 = strlen((char const   *)attach_tty);
    }
#line 1075
    if (tmp___48 >= 4096U) {
      {
#line 1076
      Panic(0, (char *)"TtyName too long - sorry.");
      }
    }
#line 1077
    if (! *av) {
      {
#line 1078
      Panic(0, (char *)"Please specify a command.");
      }
    }
    {
#line 1079
    setgid((__gid_t )real_gid);
#line 1080
    setuid((__uid_t )real_uid);
#line 1081
    eff_uid = real_uid;
#line 1082
    eff_gid = real_gid;
    }
#line 1083
    if (! mflag) {
#line 1083
      if (! SockMatch) {
        {
#line 1085
        sty = getenv("STY");
        }
#line 1086
        if (sty) {
#line 1086
          if ((int )*sty == 0) {
#line 1087
            sty = (char *)0;
          }
        }
      }
    }
    {
#line 1089
    SendCmdMessage(sty, SockMatch, av);
#line 1090
    exit(0);
    }
  } else
#line 1092
  if (rflag) {
#line 1092
    goto _L___4;
  } else
#line 1092
  if (xflag) {
    _L___4: /* CIL Label */ 
    {
#line 1094
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 1094
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
    {
#line 1095
    tmp___49 = Attach(2);
    }
#line 1095
    if (tmp___49) {
      {
#line 1097
      Attacher();
      }
    }
#line 1101
    if (multiattach) {
      {
#line 1102
      Panic(0, (char *)"Can\'t create sessions of other users.");
      }
    }
    {
#line 1104
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 1104
      goto while_break___22;
    }
    while_break___22: /* CIL Label */ ;
    }
  } else
#line 1106
  if (dflag) {
#line 1106
    if (! mflag) {
      {
#line 1108
      Attach(4);
      }
#line 1109
      if (dflag > 1) {
#line 1109
        tmp___50 = "power ";
      } else {
#line 1109
        tmp___50 = "";
      }
      {
#line 1109
      Msg(0, (char *)"[%s %sdetached.]\n", SockName, tmp___50);
#line 1110
      eexit(0);
      }
    }
  }
#line 1113
  if (! SockMatch) {
#line 1113
    if (! mflag) {
      {
#line 1117
      sty___0 = getenv("STY");
      }
#line 1117
      if ((unsigned long )sty___0 != (unsigned long )((char *)0)) {
#line 1117
        if ((int )*sty___0 != 0) {
          {
#line 1119
          setgid((__gid_t )real_gid);
#line 1120
          setuid((__uid_t )real_uid);
#line 1121
          eff_uid = real_uid;
#line 1122
          eff_gid = real_gid;
#line 1123
          nwin_options.args = av;
#line 1124
          SendCreateMsg(sty___0, & nwin);
#line 1125
          exit(0);
          }
        }
      }
    }
  }
  {
#line 1129
  nwin_compose(& nwin_default, & nwin_options, & nwin_default);
  }
#line 1131
  if (! detached) {
    {
#line 1132
    MasterPid = fork();
    }
  } else
#line 1131
  if (dflag != 2) {
    {
#line 1132
    MasterPid = fork();
    }
  } else {
#line 1134
    MasterPid = 0;
  }
  {
#line 1138
  if (MasterPid == -1) {
#line 1138
    goto case_neg_1;
  }
#line 1141
  if (MasterPid == 0) {
#line 1141
    goto case_0___1;
  }
#line 1143
  goto switch_default___2;
  case_neg_1: /* CIL Label */ 
  {
#line 1139
  tmp___51 = __errno_location();
#line 1139
  Panic(*tmp___51, (char *)"fork");
  }
  case_0___1: /* CIL Label */ 
#line 1142
  goto switch_break___2;
  switch_default___2: /* CIL Label */ 
#line 1144
  if (detached) {
    {
#line 1145
    exit(0);
    }
  }
#line 1146
  if (SockMatch) {
    {
#line 1147
    sprintf((char */* __restrict  */)(socknamebuf), (char const   */* __restrict  */)"%d.%s",
            MasterPid, SockMatch);
    }
  } else {
    {
#line 1149
    tmp___52 = stripdev(attach_tty);
#line 1149
    sprintf((char */* __restrict  */)(socknamebuf), (char const   */* __restrict  */)"%d.%s.%s",
            MasterPid, tmp___52, HostName);
    }
  }
#line 1150
  ap = socknamebuf;
  {
#line 1150
  while (1) {
    while_continue___23: /* CIL Label */ ;
#line 1150
    if (! *ap) {
#line 1150
      goto while_break___23;
    }
#line 1151
    if ((int )*ap == 47) {
#line 1152
      *ap = (char )'-';
    }
#line 1150
    ap ++;
  }
  while_break___23: /* CIL Label */ ;
  }
  {
#line 1154
  tmp___53 = strlen((char const   *)(socknamebuf));
  }
#line 1154
  if (tmp___53 > 255U) {
#line 1155
    socknamebuf[255] = (char)0;
  }
  {
#line 1157
  tmp___54 = strlen((char const   *)(SockPath));
#line 1157
  sprintf((char */* __restrict  */)(SockPath + tmp___54), (char const   */* __restrict  */)"/%s",
          socknamebuf);
#line 1158
  setgid((__gid_t )real_gid);
#line 1159
  setuid((__uid_t )real_uid);
#line 1160
  eff_uid = real_uid;
#line 1161
  eff_gid = real_gid;
#line 1162
  Attacher();
  }
  switch_break___2: /* CIL Label */ ;
  }
#line 1166
  if (DefaultEsc == -1) {
#line 1167
    DefaultEsc = 1;
  }
#line 1168
  if (DefaultMetaEsc == -1) {
#line 1169
    DefaultMetaEsc = 'a';
  }
  {
#line 1171
  tmp___55 = strlen((char const   *)av0);
#line 1171
  ap = (av0 + tmp___55) - 1;
  }
  {
#line 1172
  while (1) {
    while_continue___24: /* CIL Label */ ;
#line 1172
    if (! ((unsigned long )ap >= (unsigned long )av0)) {
#line 1172
      goto while_break___24;
    }
    {
#line 1174
    tmp___56 = strncmp("screen", (char const   *)ap, (size_t )6);
    }
#line 1174
    if (! tmp___56) {
      {
#line 1176
      strncpy((char */* __restrict  */)ap, (char const   */* __restrict  */)"SCREEN",
              (size_t )6);
      }
#line 1177
      goto while_break___24;
    }
#line 1179
    ap --;
  }
  while_break___24: /* CIL Label */ ;
  }
#line 1181
  if ((unsigned long )ap < (unsigned long )av0) {
#line 1182
    *av0 = (char )'S';
  }
#line 1197
  if (! detached) {
    {
#line 1200
    n = secopen(attach_tty, 2, 0);
    }
#line 1200
    if (n < 0) {
      {
#line 1201
      Panic(0, (char *)"Cannot reopen \'%s\' - please check.", attach_tty);
      }
    }
  } else {
#line 1204
    n = -1;
  }
  {
#line 1205
  freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"r",
          (FILE */* __restrict  */)stdin);
#line 1206
  freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"w",
          (FILE */* __restrict  */)stdout);
#line 1211
  freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"w",
          (FILE */* __restrict  */)stderr);
  }
  {
#line 1212
  while (1) {
    while_continue___25: /* CIL Label */ ;
#line 1212
    goto while_break___25;
  }
  while_break___25: /* CIL Label */ ;
  }
  {
#line 1219
  tmp___57 = UserAdd(LoginName, (char *)0, (struct acluser **)0);
  }
#line 1219
  if (tmp___57 < 0) {
    {
#line 1220
    Panic(0, (char *)"Could not create user info");
    }
  }
#line 1221
  if (! detached) {
    {
#line 1223
    tmp___58 = getppid();
#line 1223
    tmp___59 = MakeDisplay(LoginName, attach_tty, attach_term, n, tmp___58, & attach_Mode);
    }
#line 1223
    if ((unsigned long )tmp___59 == (unsigned long )((struct display *)0)) {
      {
#line 1224
      Panic(0, (char *)"Could not alloc display");
      }
    }
#line 1226
    if (nwin_options.encoding > 0) {
#line 1226
      display->d_encoding = nwin_options.encoding;
    } else {
#line 1226
      display->d_encoding = 0;
    }
    {
#line 1227
    while (1) {
      while_continue___26: /* CIL Label */ ;
#line 1227
      goto while_break___26;
    }
    while_break___26: /* CIL Label */ ;
    }
  }
#line 1231
  if (SockMatch) {
    {
#line 1234
    tmp___60 = getpid();
#line 1234
    sprintf((char */* __restrict  */)(socknamebuf), (char const   */* __restrict  */)"%d.%s",
            tmp___60, SockMatch);
    }
  } else {
    {
#line 1238
    tmp___61 = stripdev(attach_tty);
#line 1238
    tmp___62 = getpid();
#line 1238
    sprintf((char */* __restrict  */)(socknamebuf), (char const   */* __restrict  */)"%d.%s.%s",
            tmp___62, tmp___61, HostName);
    }
  }
#line 1241
  ap = socknamebuf;
  {
#line 1241
  while (1) {
    while_continue___27: /* CIL Label */ ;
#line 1241
    if (! *ap) {
#line 1241
      goto while_break___27;
    }
#line 1242
    if ((int )*ap == 47) {
#line 1243
      *ap = (char )'-';
    }
#line 1241
    ap ++;
  }
  while_break___27: /* CIL Label */ ;
  }
  {
#line 1245
  tmp___63 = strlen((char const   *)(socknamebuf));
  }
#line 1245
  if (tmp___63 > 255U) {
    {
#line 1247
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 1247
      goto while_break___28;
    }
    while_break___28: /* CIL Label */ ;
    }
#line 1248
    socknamebuf[255] = (char)0;
  }
  {
#line 1251
  tmp___64 = strlen((char const   *)(SockPath));
#line 1251
  sprintf((char */* __restrict  */)(SockPath + tmp___64), (char const   */* __restrict  */)"/%s",
          socknamebuf);
#line 1253
  ServerSocket = MakeServerSocket();
#line 1254
  InitKeytab();
#line 1257
  ap = getenv("SYSSCREENRC");
  }
#line 1257
  if (ap) {
    {
#line 1258
    StartRc(ap);
    }
  } else {
    {
#line 1261
    StartRc((char *)"/usr/etc/screenrc");
    }
  }
  {
#line 1263
  StartRc(RcFileName);
#line 1266
  InitUtmp();
  }
#line 1269
  if (display) {
    {
#line 1271
    tmp___65 = InitTermcap(0, 0);
    }
#line 1271
    if (tmp___65) {
      {
#line 1273
      while (1) {
        while_continue___29: /* CIL Label */ ;
#line 1273
        goto while_break___29;
      }
      while_break___29: /* CIL Label */ ;
      }
      {
#line 1274
      fcntl(display->d_userfd, 4, 0);
#line 1275
      freetty();
      }
#line 1276
      if (display->d_userpid) {
        {
#line 1277
        Kill(display->d_userpid, 1);
        }
      }
      {
#line 1278
      eexit(1);
      }
    }
    {
#line 1280
    MakeDefaultCanvas();
#line 1281
    InitTerm(0);
#line 1283
    RemoveLoginSlot();
    }
  } else {
    {
#line 1287
    MakeTermcap(1);
    }
  }
  {
#line 1289
  InitLoadav();
#line 1291
  MakeNewEnv();
#line 1292
  xsignal(1, & SigHup);
#line 1293
  xsignal(2, & FinitHandler);
#line 1294
  xsignal(3, & FinitHandler);
#line 1295
  xsignal(15, & FinitHandler);
#line 1297
  xsignal(21, (void (*)(int  ))1);
#line 1298
  xsignal(22, (void (*)(int  ))1);
  }
#line 1301
  if (display) {
    {
#line 1303
    brktty(display->d_userfd);
#line 1304
    SetMode(& display->d_OldMode, & display->d_NewMode, display->d_flow, iflag);
#line 1306
    SetTTY(display->d_userfd, & display->d_NewMode);
#line 1307
    tmp___67 = fcntl(display->d_userfd, 4, 2048);
    }
#line 1307
    if (tmp___67) {
      {
#line 1308
      tmp___66 = __errno_location();
#line 1308
      Msg(*tmp___66, (char *)"Warning: NBLOCK fcntl failed");
      }
    }
  } else {
    {
#line 1311
    brktty(-1);
    }
  }
  {
#line 1312
  xsignal(17, & SigChld);
#line 1315
  ap = getenv("SYSSCREENRC");
  }
#line 1315
  if (ap) {
    {
#line 1316
    FinishRc(ap);
    }
  } else {
    {
#line 1319
    FinishRc((char *)"/usr/etc/screenrc");
    }
  }
  {
#line 1321
  FinishRc(RcFileName);
  }
  {
#line 1323
  while (1) {
    while_continue___30: /* CIL Label */ ;
#line 1323
    goto while_break___30;
  }
  while_break___30: /* CIL Label */ ;
  }
#line 1324
  if ((unsigned long )windows == (unsigned long )((void *)0)) {
    {
#line 1326
    while (1) {
      while_continue___31: /* CIL Label */ ;
#line 1326
      goto while_break___31;
    }
    while_break___31: /* CIL Label */ ;
    }
    {
#line 1327
    tmp___68 = MakeWindow(& nwin);
    }
#line 1327
    if (tmp___68 == -1) {
      {
#line 1329
      Msg(0, (char *)"Sorry, could not find a PTY.");
#line 1330
      sleep(5U);
#line 1331
      Finit(0);
      }
    }
  }
#line 1340
  if (display) {
#line 1340
    if (default_startup) {
      {
#line 1341
      display_copyright();
      }
    }
  }
  {
#line 1342
  xsignal(2, & SigInt);
  }
#line 1343
  if (rflag) {
#line 1343
    if ((rflag & 1) == 0) {
      {
#line 1345
      Msg(0, (char *)"New screen...");
#line 1346
      rflag = 0;
      }
    }
  }
  {
#line 1349
  serv_read.type = 1;
#line 1350
  serv_read.fd = ServerSocket;
#line 1351
  serv_read.handler = & serv_read_fn;
#line 1352
  evenq(& serv_read);
#line 1354
  serv_select.pri = -10;
#line 1355
  serv_select.type = 3;
#line 1356
  serv_select.handler = & serv_select_fn;
#line 1357
  evenq(& serv_select);
#line 1359
  logflushev.type = 0;
#line 1360
  logflushev.handler = & logflush_fn;
#line 1362
  sched();
  }
#line 1364
  return (0);
}
}
#line 1367 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
void WindowDied(struct win *p ) 
{ 
  char buf___0[100] ;
  char *s ;
  time_t now ;
  size_t tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;

  {
#line 1371
  if (ZombieKey_destroy) {
    {
#line 1376
    time(& now);
#line 1377
    s = ctime((time_t const   *)(& now));
    }
#line 1378
    if (s) {
#line 1378
      if (*s) {
        {
#line 1379
        tmp = strlen((char const   *)s);
#line 1379
        *(s + (tmp - 1U)) = (char )'\000';
        }
      }
    }
    {
#line 1380
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1380
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1383
    if ((unsigned long )p->w_slot != (unsigned long )((slot_t )0)) {
#line 1383
      if ((unsigned long )p->w_slot != (unsigned long )((slot_t )-1)) {
        {
#line 1385
        RemoveUtmp(p);
#line 1386
        p->w_slot = (slot_t )0;
        }
      }
    }
    {
#line 1389
    CloseDevice(p);
#line 1391
    p->w_pid = 0;
#line 1392
    ResetWindow(p);
#line 1394
    p->w_layer.l_y = MFindUsedLine(p, p->w_bot, 1);
    }
#line 1395
    if (s) {
#line 1395
      tmp___0 = (char const   *)s;
    } else {
#line 1395
      tmp___0 = "?";
    }
    {
#line 1395
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"\n\r=== Window terminated (%s) ===",
            tmp___0);
#line 1396
    tmp___1 = strlen((char const   *)(buf___0));
#line 1396
    WriteString(p, buf___0, (int )tmp___1);
#line 1397
    WindowChanged(p, 'f');
    }
  } else {
    {
#line 1400
    KillWindow(p);
    }
  }
#line 1404
  return;
}
}
#line 1406 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
static void SigChldHandler(void) 
{ 
  struct stat st ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1413
    if (! GotSigChld) {
#line 1413
      goto while_break;
    }
    {
#line 1415
    GotSigChld = 0;
#line 1416
    DoWait();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1421
  tmp___0 = stat((char const   */* __restrict  */)(SockPath), (struct stat */* __restrict  */)(& st));
  }
#line 1421
  if (tmp___0 == -1) {
    {
#line 1423
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1423
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1424
    tmp = RecoverSocket();
    }
#line 1424
    if (tmp) {
      {
#line 1430
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1430
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      {
#line 1426
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1426
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 1427
      Finit(1);
      }
    }
  } else {
    {
#line 1433
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1433
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 1434
  return;
}
}
#line 1436 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
static void SigChld(int sigsig ) 
{ 


  {
  {
#line 1439
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1439
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1440
  GotSigChld = 1;
#line 1442
  return;
}
}
#line 1444 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
void SigHup(int sigsig ) 
{ 


  {
  {
#line 1448
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1448
    display = displays;
#line 1448
    if (! ((unsigned long )display != (unsigned long )((struct display *)0))) {
#line 1448
      goto while_break;
    }
    {
#line 1449
    Hangup();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1451
  return;
}
}
#line 1458 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
static void SigInt(int sigsig ) 
{ 


  {
  {
#line 1476
  xsignal(2, & SigInt);
  }
  {
#line 1477
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1477
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1478
  InterruptPlease = 1;
#line 1481
  return;
}
}
#line 1483 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
static void CoreDump(int sigsig ) 
{ 
  struct display *disp ;
  char buf___0[80] ;
  __gid_t tmp ;
  __uid_t tmp___0 ;
  size_t tmp___1 ;
  __pid_t tmp___2 ;

  {
  {
#line 1492
  tmp = getgid();
#line 1492
  setgid(tmp);
#line 1493
  tmp___0 = getuid();
#line 1493
  setuid(tmp___0);
#line 1494
  unlink("core");
#line 1496
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"\r\n[screen caught signal %d.%s]\r\n",
          sigsig, "");
#line 1506
  disp = displays;
  }
  {
#line 1506
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1506
    if (! disp) {
#line 1506
      goto while_break;
    }
    {
#line 1508
    fcntl(disp->d_userfd, 4, 0);
#line 1509
    SetTTY(disp->d_userfd, & display->d_OldMode);
#line 1510
    tmp___1 = strlen((char const   *)(buf___0));
#line 1510
    write(disp->d_userfd, (void const   *)(buf___0), tmp___1);
#line 1511
    Kill(disp->d_userpid, 1);
#line 1506
    disp = disp->d_next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1514
  tmp___2 = getpid();
#line 1514
  Kill(tmp___2, 9);
#line 1515
  eexit(11);
  }
#line 1520
  return;
}
}
#line 1522 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
static void DoWait(void) 
{ 
  register int pid ;
  struct win *p ;
  struct win *next ;
  int wstat ;
  union __anonunion___u_53___0 __u ;
  union __anonunion___u_54___0 __u___0 ;
  int tmp ;
  union __anonunion___u_55 __u___1 ;

  {
  {
#line 1535
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1535
    pid = waitpid(-1, & wstat, 3);
    }
#line 1535
    if (! (pid > 0)) {
#line 1535
      goto while_break;
    }
#line 1555
    p = windows;
    {
#line 1555
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1555
      if (! p) {
#line 1555
        goto while_break___0;
      }
#line 1557
      next = p->w_next;
#line 1558
      if (pid == p->w_pid) {
#line 1561
        __u___1.__in = wstat;
#line 1561
        if ((__u___1.__i & 255) == 127) {
          {
#line 1563
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1563
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 1565
          __u.__in = wstat;
#line 1565
          if ((__u.__i & 65280) >> 8 == 21) {
            {
#line 1567
            Msg(0, (char *)"Suspended (tty input)");
            }
#line 1568
            goto __Cont;
          }
#line 1572
          __u___0.__in = wstat;
#line 1572
          if ((__u___0.__i & 65280) >> 8 == 22) {
            {
#line 1574
            Msg(0, (char *)"Suspended (tty output)");
            }
#line 1575
            goto __Cont;
          }
          {
#line 1579
          Msg(0, (char *)"Child has been stopped, restarting.");
#line 1580
          tmp = killpg(p->w_pid, 18);
          }
#line 1580
          if (tmp) {
            {
#line 1581
            kill(p->w_pid, 18);
            }
          }
        } else {
          {
#line 1586
          WindowDied(p);
          }
        }
#line 1588
        goto while_break___0;
      }
#line 1591
      if (p->w_pwin) {
#line 1591
        if (pid == (p->w_pwin)->p_pid) {
          {
#line 1593
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1593
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 1594
          FreePseudowin(p);
          }
#line 1595
          goto while_break___0;
        }
      }
      __Cont: /* CIL Label */ 
#line 1555
      p = next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1599
    if ((unsigned long )p == (unsigned long )((struct win *)0)) {
      {
#line 1601
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1601
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1604
  return;
}
}
#line 1607 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
static void FinitHandler(int sigsig ) 
{ 


  {
  {
#line 1611
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1611
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1615
  Finit(1);
  }
#line 1617
  return;
}
}
#line 1619 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
void Finit(int i ) 
{ 
  struct win *p ;
  struct win *next ;

  {
  {
#line 1625
  xsignal(17, (void (*)(int  ))0);
#line 1626
  xsignal(1, (void (*)(int  ))1);
  }
  {
#line 1627
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1627
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1628
  p = windows;
  {
#line 1628
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1628
    if (! p) {
#line 1628
      goto while_break___0;
    }
    {
#line 1630
    next = p->w_next;
#line 1631
    FreeWindow(p);
#line 1628
    p = next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1633
  if (ServerSocket != -1) {
    {
#line 1635
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1635
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1637
    xseteuid(real_uid);
#line 1638
    xsetegid(real_gid);
#line 1640
    unlink((char const   *)(SockPath));
#line 1642
    xseteuid(eff_uid);
#line 1643
    xsetegid(eff_gid);
    }
  }
#line 1646
  display = displays;
  {
#line 1646
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1646
    if (! display) {
#line 1646
      goto while_break___2;
    }
#line 1648
    if (display->d_status) {
      {
#line 1649
      RemoveStatus();
      }
    }
    {
#line 1650
    FinitTerm();
#line 1652
    RestoreLoginSlot();
#line 1654
    AddStr((char *)"[screen is terminating]\r\n");
#line 1655
    Flush();
#line 1656
    SetTTY(display->d_userfd, & display->d_OldMode);
#line 1657
    fcntl(display->d_userfd, 4, 0);
#line 1658
    freetty();
#line 1659
    Kill(display->d_userpid, 1);
#line 1646
    display = display->d_next;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1665
  exit(i);
  }
}
}
#line 1668 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
void eexit(int e ) 
{ 


  {
  {
#line 1672
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1672
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1673
  if (ServerSocket != -1) {
    {
#line 1675
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1675
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1676
    setgid((__gid_t )real_gid);
#line 1677
    setuid((__uid_t )real_uid);
#line 1678
    unlink((char const   *)(SockPath));
    }
  }
  {
#line 1680
  exit(e);
  }
}
}
#line 1683 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
void Hangup(void) 
{ 


  {
#line 1686
  if ((unsigned long )display == (unsigned long )((struct display *)0)) {
#line 1687
    return;
  }
  {
#line 1688
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1688
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1689
  if (display->d_userfd >= 0) {
    {
#line 1691
    close(display->d_userfd);
#line 1692
    display->d_userfd = -1;
    }
  }
#line 1694
  if (auto_detach) {
    {
#line 1695
    Detach(6);
    }
  } else
#line 1694
  if (displays->d_next) {
    {
#line 1695
    Detach(6);
    }
  } else {
    {
#line 1697
    Finit(0);
    }
  }
#line 1698
  return;
}
}
#line 1713 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
void Detach(int mode ) 
{ 
  int sign ;
  int pid ;
  struct canvas *cv ;
  struct win *p ;
  int tmp ;

  {
#line 1717
  sign = 0;
#line 1721
  if ((unsigned long )display == (unsigned long )((struct display *)0)) {
#line 1722
    return;
  }
  {
#line 1724
  xsignal(1, (void (*)(int  ))1);
  }
  {
#line 1725
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1725
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1726
  if (display->d_status) {
    {
#line 1727
    RemoveStatus();
    }
  }
  {
#line 1728
  FinitTerm();
  }
#line 1729
  if (! display) {
#line 1730
    return;
  }
  {
#line 1733
  if (mode == 6) {
#line 1733
    goto case_6;
  }
#line 1736
  if (mode == 0) {
#line 1736
    goto case_0;
  }
#line 1741
  if (mode == 1) {
#line 1741
    goto case_1;
  }
#line 1746
  if (mode == 2) {
#line 1746
    goto case_2;
  }
#line 1752
  if (mode == 3) {
#line 1752
    goto case_3;
  }
#line 1762
  if (mode == 4) {
#line 1762
    goto case_4;
  }
#line 1773
  if (mode == 5) {
#line 1773
    goto case_5;
  }
#line 1731
  goto switch_break;
  case_6: /* CIL Label */ 
#line 1734
  sign = 1;
#line 1735
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1737
  AddStr((char *)"[detached]\r\n");
#line 1738
  sign = 1;
  }
#line 1739
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1742
  sign = 20;
#line 1743
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1747
  AddStr((char *)"[remote detached]\r\n");
#line 1748
  sign = 1;
  }
#line 1749
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1753
  AddStr((char *)"[power detached]\r\n");
  }
#line 1754
  if (PowDetachString) {
    {
#line 1756
    AddStr(PowDetachString);
#line 1757
    AddStr((char *)"\r\n");
    }
  }
#line 1759
  sign = 10;
#line 1760
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 1763
  AddStr((char *)"[remote power detached]\r\n");
  }
#line 1764
  if (PowDetachString) {
    {
#line 1766
    AddStr(PowDetachString);
#line 1767
    AddStr((char *)"\r\n");
    }
  }
#line 1769
  sign = 10;
#line 1770
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 1774
  ClearAll();
#line 1775
  sign = 12;
  }
#line 1777
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1780
  if ((unsigned long )displays->d_next == (unsigned long )((struct display *)0)) {
#line 1782
    p = windows;
    {
#line 1782
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1782
      if (! p) {
#line 1782
        goto while_break___0;
      }
#line 1784
      if ((unsigned long )p->w_slot != (unsigned long )((slot_t )-1)) {
#line 1784
        if (! (p->w_lflag & 2)) {
          {
#line 1786
          RemoveUtmp(p);
#line 1791
          p->w_slot = (slot_t )0;
          }
        }
      }
#line 1782
      p = p->w_next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1795
  if (mode != 6) {
    {
#line 1796
    RestoreLoginSlot();
    }
  }
#line 1798
  if ((unsigned long )displays->d_next == (unsigned long )((struct display *)0)) {
#line 1798
    if (console_window) {
      {
#line 1800
      tmp = TtyGrabConsole(console_window->w_ptyfd, 0, (char *)"detach");
      }
#line 1800
      if (tmp) {
        {
#line 1802
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1802
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 1803
        KillWindow(console_window);
#line 1804
        display = displays;
        }
      }
    }
  }
#line 1807
  if (display->d_fore) {
    {
#line 1810
    ReleaseAutoWritelock(display, display->d_fore);
#line 1812
    (display->d_user)->u_detachwin = (display->d_fore)->w_number;
    }
#line 1813
    if (display->d_other) {
#line 1813
      (display->d_user)->u_detachotherwin = (display->d_other)->w_number;
    } else {
#line 1813
      (display->d_user)->u_detachotherwin = -1;
    }
  }
#line 1815
  cv = display->d_cvlist;
  {
#line 1815
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1815
    if (! cv) {
#line 1815
      goto while_break___2;
    }
    {
#line 1817
    p = (struct win *)((cv->c_layer)->l_bottom)->l_data;
#line 1818
    SetCanvasWindow(cv, (struct win *)0);
    }
#line 1819
    if (p) {
      {
#line 1820
      WindowChanged(p, 'u');
      }
    }
#line 1815
    cv = cv->c_next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1823
  pid = display->d_userpid;
  {
#line 1824
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1824
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1825
  FreeDisplay();
  }
#line 1826
  if ((unsigned long )displays == (unsigned long )((struct display *)0)) {
    {
#line 1828
    chsock();
    }
  }
  {
#line 1834
  Kill(pid, sign);
  }
  {
#line 1835
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1835
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 1836
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1836
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 1837
  xsignal(1, & SigHup);
  }
#line 1838
  return;
}
}
#line 1840 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
static int IsSymbol(char *e , char *s ) 
{ 
  register int l ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1846
  tmp = strlen((char const   *)s);
#line 1846
  l = (int )tmp;
#line 1847
  tmp___0 = strncmp((char const   *)e, (char const   *)s, (size_t )l);
  }
#line 1847
  if (tmp___0 == 0) {
#line 1847
    if ((int )*(e + l) == 61) {
#line 1847
      tmp___1 = 1;
    } else {
#line 1847
      tmp___1 = 0;
    }
  } else {
#line 1847
    tmp___1 = 0;
  }
#line 1847
  return (tmp___1);
}
}
#line 1854 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
static char stybuf[256]  ;
#line 1850 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
void MakeNewEnv(void) 
{ 
  register char **op ;
  register char **np ;
  void *tmp ;
  char const   *tmp___1 ;
  size_t tmp___2 ;
  char **tmp___3 ;
  char **tmp___4 ;
  char **tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 1856
  op = environ;
  {
#line 1856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1856
    if (! *op) {
#line 1856
      goto while_break;
    }
#line 1856
    op ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1858
  if (NewEnv) {
    {
#line 1859
    free((void *)((char *)NewEnv));
    }
  }
  {
#line 1860
  tmp = malloc((size_t )((unsigned long )((unsigned int )(((op - environ) + 7L) + 1L)) * sizeof(char **)));
#line 1860
  np = (char **)tmp;
#line 1860
  NewEnv = np;
  }
#line 1861
  if (! NewEnv) {
    {
#line 1862
    Panic(0, strnomem);
    }
  }
  {
#line 1863
  tmp___2 = strlen((char const   *)SockName);
  }
#line 1863
  if (tmp___2 <= 251U) {
#line 1863
    tmp___1 = (char const   *)SockName;
  } else {
#line 1863
    tmp___1 = "?";
  }
  {
#line 1863
  sprintf((char */* __restrict  */)(stybuf), (char const   */* __restrict  */)"STY=%s",
          tmp___1);
#line 1864
  tmp___3 = np;
#line 1864
  np ++;
#line 1864
  *tmp___3 = stybuf;
#line 1865
  tmp___4 = np;
#line 1865
  np ++;
#line 1865
  *tmp___4 = Term;
#line 1866
  np ++;
#line 1868
  np += 2;
#line 1873
  op = environ;
  }
  {
#line 1873
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1873
    if (! *op) {
#line 1873
      goto while_break___0;
    }
    {
#line 1875
    tmp___6 = IsSymbol(*op, (char *)"TERM");
    }
#line 1875
    if (! tmp___6) {
      {
#line 1875
      tmp___7 = IsSymbol(*op, (char *)"TERMCAP");
      }
#line 1875
      if (! tmp___7) {
        {
#line 1875
        tmp___8 = IsSymbol(*op, (char *)"STY");
        }
#line 1875
        if (! tmp___8) {
          {
#line 1875
          tmp___9 = IsSymbol(*op, (char *)"WINDOW");
          }
#line 1875
          if (! tmp___9) {
            {
#line 1875
            tmp___10 = IsSymbol(*op, (char *)"SCREENCAP");
            }
#line 1875
            if (! tmp___10) {
              {
#line 1875
              tmp___11 = IsSymbol(*op, (char *)"SHELL");
              }
#line 1875
              if (! tmp___11) {
                {
#line 1875
                tmp___12 = IsSymbol(*op, (char *)"LINES");
                }
#line 1875
                if (! tmp___12) {
                  {
#line 1875
                  tmp___13 = IsSymbol(*op, (char *)"COLUMNS");
                  }
#line 1875
                  if (! tmp___13) {
#line 1880
                    tmp___5 = np;
#line 1880
                    np ++;
#line 1880
                    *tmp___5 = *op;
                  }
                }
              }
            }
          }
        }
      }
    }
#line 1873
    op ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1882
  *np = (char *)0;
#line 1883
  return;
}
}
#line 1885 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
void ( /* format attribute */  Msg)(int err , char *fmt  , ...) 
{ 
  va_list ap ;
  char buf___0[8192] ;
  char *p ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tty ;
  struct display *olddisplay ;

  {
  {
#line 1898
  p = buf___0;
#line 1900
  __builtin_va_start(ap, fmt);
#line 1901
  fmt = DoNLS(fmt);
#line 1902
  vsnprintf((char */* __restrict  */)p, (size_t )(sizeof(buf___0) - 100UL), (char const   */* __restrict  */)fmt,
            ap);
#line 1903
  __builtin_va_end(ap);
  }
#line 1904
  if (err) {
    {
#line 1906
    tmp = strlen((char const   *)p);
#line 1906
    p += tmp;
#line 1907
    tmp___0 = p;
#line 1907
    p ++;
#line 1907
    *tmp___0 = (char )':';
#line 1908
    tmp___1 = p;
#line 1908
    p ++;
#line 1908
    *tmp___1 = (char )' ';
#line 1909
    tmp___2 = strerror(err);
#line 1909
    strncpy((char */* __restrict  */)p, (char const   */* __restrict  */)tmp___2,
            (size_t )(((buf___0 + sizeof(buf___0)) - p) - 1L));
#line 1910
    buf___0[sizeof(buf___0) - 1UL] = (char)0;
    }
  }
  {
#line 1912
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1912
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1914
  if (display) {
#line 1914
    if (displays) {
      {
#line 1915
      MakeStatus(buf___0);
      }
    } else {
#line 1914
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1916
  if (displays) {
#line 1918
    display = displays;
    {
#line 1918
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1918
      if (! display) {
#line 1918
        goto while_break___0;
      }
      {
#line 1919
      MakeStatus(buf___0);
#line 1918
      display = display->d_next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 1921
  if (display) {
    {
#line 1926
    tty = display->d_usertty;
#line 1927
    olddisplay = display;
#line 1928
    display = (struct display *)0;
#line 1929
    SendErrorMsg(tty, buf___0);
#line 1930
    display = olddisplay;
    }
  } else {
    {
#line 1933
    printf((char const   */* __restrict  */)"%s\r\n", buf___0);
    }
  }
#line 1934
  return;
}
}
#line 1939 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
void ( /* format attribute */  Panic)(int err , char *fmt  , ...) 
{ 
  va_list ap ;
  char buf___0[8192] ;
  char *p ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tty ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
  {
#line 1946
  p = buf___0;
#line 1948
  __builtin_va_start(ap, fmt);
#line 1949
  fmt = DoNLS(fmt);
#line 1950
  vsnprintf((char */* __restrict  */)p, (size_t )(sizeof(buf___0) - 100UL), (char const   */* __restrict  */)fmt,
            ap);
#line 1951
  __builtin_va_end(ap);
  }
#line 1952
  if (err) {
    {
#line 1954
    tmp = strlen((char const   *)p);
#line 1954
    p += tmp;
#line 1955
    tmp___0 = p;
#line 1955
    p ++;
#line 1955
    *tmp___0 = (char )':';
#line 1956
    tmp___1 = p;
#line 1956
    p ++;
#line 1956
    *tmp___1 = (char )' ';
#line 1957
    tmp___2 = strerror(err);
#line 1957
    strncpy((char */* __restrict  */)p, (char const   */* __restrict  */)tmp___2,
            (size_t )(((buf___0 + sizeof(buf___0)) - p) - 1L));
#line 1958
    buf___0[sizeof(buf___0) - 1UL] = (char)0;
    }
  }
  {
#line 1960
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1960
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1962
  if ((unsigned long )displays == (unsigned long )((struct display *)0)) {
#line 1962
    if ((unsigned long )display == (unsigned long )((struct display *)0)) {
      {
#line 1963
      printf((char const   */* __restrict  */)"%s\r\n", buf___0);
      }
    } else {
#line 1962
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1964
  if ((unsigned long )displays == (unsigned long )((struct display *)0)) {
    {
#line 1967
    tty = display->d_usertty;
#line 1968
    display = (struct display *)0;
#line 1969
    SendErrorMsg(tty, buf___0);
#line 1970
    sleep(2U);
#line 1971
    _exit(1);
    }
  } else {
#line 1974
    display = displays;
    {
#line 1974
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1974
      if (! display) {
#line 1974
        goto while_break___0;
      }
#line 1976
      if (display->d_status) {
        {
#line 1977
        RemoveStatus();
        }
      }
      {
#line 1978
      FinitTerm();
#line 1979
      Flush();
#line 1981
      RestoreLoginSlot();
#line 1983
      SetTTY(display->d_userfd, & display->d_OldMode);
#line 1984
      fcntl(display->d_userfd, 4, 0);
#line 1985
      tmp___3 = strlen((char const   *)(buf___0));
#line 1985
      write(display->d_userfd, (void const   *)(buf___0), tmp___3);
#line 1986
      write(display->d_userfd, (void const   *)"\n", (size_t )1);
#line 1987
      freetty();
      }
#line 1988
      if (display->d_userpid) {
        {
#line 1989
        Kill(display->d_userpid, 1);
        }
      }
#line 1974
      display = display->d_next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1992
  if (tty_oldmode >= 0) {
    {
#line 1995
    tmp___4 = setuid((__uid_t )own_uid);
    }
#line 1995
    if (tmp___4) {
      {
#line 1996
      xseteuid(own_uid);
      }
    }
    {
#line 2000
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2000
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2001
    chmod((char const   *)attach_tty, (__mode_t )tty_oldmode);
    }
  }
  {
#line 2004
  eexit(1);
  }
#line 2005
  return;
}
}
#line 2028 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
static char winmsg_buf[256]  ;
#line 2030 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
static int winmsg_rend[16]  ;
#line 2031 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
static int winmsg_rendpos[16]  ;
#line 2032 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
static int winmsg_numrend  ;
#line 2034 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
static char *pad_expand(char *buf___0 , char *p , int numpad , int padlen ) 
{ 
  char *pn ;
  char *pn2 ;
  int i ;
  int r ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 2044
  padlen = (int )((long )padlen - (p - buf___0));
#line 2045
  if (padlen < 0) {
#line 2046
    padlen = 0;
  }
#line 2047
  pn = p + padlen;
#line 2047
  pn2 = pn;
#line 2048
  r = winmsg_numrend;
  {
#line 2049
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2049
    if (! ((unsigned long )p >= (unsigned long )buf___0)) {
#line 2049
      goto while_break;
    }
#line 2051
    if (r) {
#line 2051
      if (p - buf___0 == (long )winmsg_rendpos[r - 1]) {
#line 2053
        r --;
#line 2053
        winmsg_rendpos[r] = (int )(pn - buf___0);
#line 2054
        goto while_continue;
      }
    }
#line 2056
    tmp = pn;
#line 2056
    pn --;
#line 2056
    *tmp = *p;
#line 2057
    tmp___2 = p;
#line 2057
    p --;
#line 2057
    if ((int )*tmp___2 == 127) {
#line 2059
      *(pn + 1) = (char )' ';
#line 2060
      if (numpad > 0) {
#line 2060
        i = ((padlen + numpad) - 1) / numpad;
      } else {
#line 2060
        i = 0;
      }
#line 2061
      padlen -= i;
      {
#line 2062
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2062
        tmp___1 = i;
#line 2062
        i --;
#line 2062
        if (! (tmp___1 > 0)) {
#line 2062
          goto while_break___0;
        }
#line 2063
        tmp___0 = pn;
#line 2063
        pn --;
#line 2063
        *tmp___0 = (char )' ';
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2064
      numpad --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2067
  return (pn2);
}
}
#line 2083 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
struct backtick *backticks  ;
#line 2085 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
static void backtick_filter(struct backtick *bt ) 
{ 
  char *p ;
  char *q ;
  int c ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 2092
  q = bt->result;
#line 2092
  p = q;
  {
#line 2092
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2092
    tmp___0 = p;
#line 2092
    p ++;
#line 2092
    c = (int )((unsigned char )*tmp___0);
#line 2092
    if (! (c != 0)) {
#line 2092
      goto while_break;
    }
#line 2094
    if (c == 9) {
#line 2095
      c = ' ';
    }
#line 2096
    if (c >= 32) {
#line 2097
      tmp = q;
#line 2097
      q ++;
#line 2097
      *tmp = (char )c;
    } else
#line 2096
    if (c == 5) {
#line 2097
      tmp = q;
#line 2097
      q ++;
#line 2097
      *tmp = (char )c;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2099
  *q = (char)0;
#line 2100
  return;
}
}
#line 2102 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
static void backtick_fn(struct event *ev , char *data ) 
{ 
  struct backtick *bt ;
  int i ;
  int j ;
  int k ;
  int l ;

  {
#line 2110
  bt = (struct backtick *)data;
  {
#line 2111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2111
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2112
  i = bt->bufi;
#line 2113
  l = read(ev->fd, (void *)(bt->buf + i), (size_t )(256 - i));
  }
#line 2114
  if (l <= 0) {
    {
#line 2116
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2116
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2117
    evdeq(ev);
#line 2118
    close(ev->fd);
#line 2119
    ev->fd = -1;
    }
#line 2120
    return;
  }
  {
#line 2122
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2122
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2123
  i += l;
#line 2124
  j = 0;
  {
#line 2124
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2124
    if (! (j < l)) {
#line 2124
      goto while_break___2;
    }
#line 2125
    if ((int )*(bt->buf + ((i - j) - 1)) == 10) {
#line 2126
      goto while_break___2;
    }
#line 2124
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2127
  if (j < l) {
#line 2129
    k = (i - j) - 2;
    {
#line 2129
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2129
      if (! (k >= 0)) {
#line 2129
        goto while_break___3;
      }
#line 2130
      if ((int )*(bt->buf + k) == 10) {
#line 2131
        goto while_break___3;
      }
#line 2129
      k --;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 2132
    k ++;
#line 2133
    bcopy((void const   *)(bt->buf + k), (void *)(bt->result), (size_t )((i - j) - k));
#line 2134
    bt->result[((i - j) - k) - 1] = (char)0;
#line 2135
    backtick_filter(bt);
#line 2136
    WindowChanged((struct win *)0, '`');
    }
  }
#line 2138
  if (j == l) {
#line 2138
    if (i == 256) {
#line 2140
      j = 128;
#line 2141
      l = j + 1;
    }
  }
#line 2143
  if (j < l) {
#line 2145
    if (j) {
      {
#line 2146
      bcopy((void const   *)((bt->buf + i) - j), (void *)bt->buf, (size_t )j);
      }
    }
#line 2147
    i = j;
  }
#line 2149
  bt->bufi = i;
#line 2150
  return;
}
}
#line 2152 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
void setbacktick(int num , int lifespan , int tick___0 , char **cmdv ) 
{ 
  struct backtick **btp ;
  struct backtick *bt ;
  char **v ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 2162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2162
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2163
  btp = & backticks;
  {
#line 2163
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2163
    bt = *btp;
#line 2163
    if (! ((unsigned long )bt != (unsigned long )((struct backtick *)0))) {
#line 2163
      goto while_break___0;
    }
#line 2164
    if (bt->num == num) {
#line 2165
      goto while_break___0;
    }
#line 2163
    btp = & bt->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2166
  if (! bt) {
#line 2166
    if (! cmdv) {
#line 2167
      return;
    }
  }
#line 2168
  if (bt) {
#line 2170
    v = bt->cmdv;
    {
#line 2170
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2170
      if (! *v) {
#line 2170
        goto while_break___1;
      }
      {
#line 2171
      free((void *)*v);
#line 2170
      v ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2172
    free((void *)bt->cmdv);
    }
#line 2173
    if (bt->buf) {
      {
#line 2174
      free((void *)bt->buf);
      }
    }
#line 2175
    if (bt->ev.fd >= 0) {
      {
#line 2176
      close(bt->ev.fd);
      }
    }
    {
#line 2177
    evdeq(& bt->ev);
    }
  }
#line 2179
  if (bt) {
#line 2179
    if (! cmdv) {
      {
#line 2181
      *btp = bt->next;
#line 2182
      free((void *)bt);
      }
#line 2183
      return;
    }
  }
#line 2185
  if (! bt) {
    {
#line 2187
    tmp = malloc((size_t )sizeof(*bt));
#line 2187
    bt = (struct backtick *)tmp;
    }
#line 2188
    if (! bt) {
      {
#line 2190
      Msg(0, strnomem);
      }
#line 2191
      return;
    }
    {
#line 2193
    bzero((void *)bt, (size_t )sizeof(*bt));
#line 2194
    bt->next = (struct backtick *)0;
#line 2195
    *btp = bt;
    }
  }
#line 2197
  bt->num = num;
#line 2198
  bt->tick = tick___0;
#line 2199
  bt->lifespan = lifespan;
#line 2200
  bt->bestbefore = (time_t )0;
#line 2201
  bt->result[0] = (char)0;
#line 2202
  bt->buf = (char *)0;
#line 2203
  bt->bufi = 0;
#line 2204
  bt->cmdv = cmdv;
#line 2205
  bt->ev.fd = -1;
#line 2206
  if (bt->tick == 0) {
#line 2206
    if (bt->lifespan == 0) {
      {
#line 2208
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2208
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 2209
      tmp___0 = malloc((size_t )256);
#line 2209
      bt->buf = (char *)tmp___0;
      }
#line 2210
      if ((unsigned long )bt->buf == (unsigned long )((char *)0)) {
        {
#line 2212
        Msg(0, strnomem);
#line 2213
        setbacktick(num, 0, 0, (char **)0);
        }
#line 2214
        return;
      }
      {
#line 2216
      bt->ev.type = 1;
#line 2217
      bt->ev.fd = readpipe(bt->cmdv);
#line 2218
      bt->ev.handler = & backtick_fn;
#line 2219
      bt->ev.data = (char *)bt;
      }
#line 2220
      if (bt->ev.fd >= 0) {
        {
#line 2221
        evenq(& bt->ev);
        }
      }
    }
  }
#line 2223
  return;
}
}
#line 2225 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
static char *runbacktick(struct backtick *bt , int *tickp , time_t now ) 
{ 
  int f ;
  int i ;
  int l ;
  int j ;
  time_t now2 ;

  {
  {
#line 2234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2234
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2235
  if (bt->tick) {
#line 2235
    if (! *tickp) {
#line 2236
      *tickp = bt->tick;
    } else
#line 2235
    if (bt->tick < *tickp) {
#line 2236
      *tickp = bt->tick;
    }
  }
#line 2237
  if (bt->lifespan == 0) {
#line 2237
    if (bt->tick == 0) {
#line 2237
      goto _L;
    } else {
#line 2237
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 2237
  if (now < bt->bestbefore) {
    _L: /* CIL Label */ 
    {
#line 2239
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2239
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2240
    return (bt->result);
  }
  {
#line 2242
  f = readpipe(bt->cmdv);
  }
#line 2243
  if (f == -1) {
#line 2244
    return (bt->result);
  }
#line 2245
  i = 0;
  {
#line 2246
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 2246
    l = read(f, (void *)(bt->result + i), (size_t )(sizeof(bt->result) - (unsigned long )i));
    }
#line 2246
    if (! (l > 0)) {
#line 2246
      goto while_break___1;
    }
    {
#line 2248
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2248
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2249
    i += l;
#line 2250
    j = 1;
    {
#line 2250
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2250
      if (! (j < l)) {
#line 2250
        goto while_break___3;
      }
#line 2251
      if ((int )bt->result[(i - j) - 1] == 10) {
#line 2252
        goto while_break___3;
      }
#line 2250
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2253
    if (j == l) {
#line 2253
      if ((unsigned long )i == sizeof(bt->result)) {
#line 2255
        j = (int )(sizeof(bt->result) / 2UL);
#line 2256
        l = j + 1;
      }
    }
#line 2258
    if (j < l) {
      {
#line 2260
      bcopy((void const   *)((bt->result + i) - j), (void *)(bt->result), (size_t )j);
#line 2261
      i = j;
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2264
  close(f);
#line 2265
  bt->result[sizeof(bt->result) - 1UL] = (char )'\n';
  }
#line 2266
  if (i) {
#line 2266
    if ((int )bt->result[i - 1] == 10) {
#line 2267
      i --;
    }
  }
  {
#line 2268
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 2268
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 2269
  bt->result[i] = (char)0;
#line 2270
  backtick_filter(bt);
#line 2271
  time(& now2);
#line 2272
  bt->bestbefore = now2 + (time_t )bt->lifespan;
  }
#line 2273
  return (bt->result);
}
}
#line 2285 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
static int tick  ;
#line 2276 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
char *MakeWinMsgEv(char *str , struct win *win , int esc , int padlen , struct event *ev ,
                   int rec ) 
{ 
  char *s ;
  register char *p ;
  register int ctrl ;
  struct timeval now ;
  struct tm *tm ;
  int l ;
  int i ;
  int r ;
  int num ;
  int zeroflg ;
  int longflg ;
  int minusflg ;
  int plusflg ;
  int qmflag ;
  int omflag ;
  int qmnumrend ;
  char *qmpos ;
  int numpad ;
  int lastpad ;
  int truncpos ;
  int truncper ;
  int trunclong ;
  struct backtick *bt ;
  char *tmp ;
  char *tmp___0 ;
  time_t nowsec ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  char savebuf[sizeof(winmsg_buf)] ;
  int oldtick ;
  int oldnumrend ;
  char *tmp___10 ;
  char *tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  struct win *oldfore ;
  char *ss ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  char rbuf[128] ;
  size_t tmp___24 ;
  size_t tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int left ;
  int trunc ;
  char *tmp___28 ;
  char const   *tmp___29 ;
  size_t tmp___30 ;

  {
#line 2286
  s = str;
#line 2287
  p = winmsg_buf;
#line 2297
  qmflag = 0;
#line 2297
  omflag = 0;
#line 2297
  qmnumrend = 0;
#line 2298
  qmpos = (char *)0;
#line 2299
  numpad = 0;
#line 2300
  lastpad = 0;
#line 2301
  truncpos = -1;
#line 2302
  truncper = 0;
#line 2303
  trunclong = 0;
#line 2306
  if (winmsg_numrend >= 0) {
#line 2307
    winmsg_numrend = 0;
  } else {
#line 2309
    winmsg_numrend = - winmsg_numrend;
  }
  {
#line 2311
  tick = 0;
#line 2312
  tm = (struct tm *)0;
#line 2313
  ctrl = 0;
#line 2314
  gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
  }
  {
#line 2315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2315
    if (*s) {
#line 2315
      l = (int )(((winmsg_buf + 256) - 1) - p);
#line 2315
      if (! (l > 0)) {
#line 2315
        goto while_break;
      }
    } else {
#line 2315
      goto while_break;
    }
#line 2317
    *p = *s;
#line 2318
    if (ctrl) {
#line 2320
      ctrl = 0;
#line 2321
      if ((int )*s != 94) {
#line 2321
        if ((int )*s >= 64) {
#line 2322
          *p = (char )((int )*p & 31);
        }
      }
#line 2323
      goto __Cont;
    }
#line 2325
    if ((int )*s != esc) {
#line 2327
      if (esc == 37) {
        {
#line 2336
        if ((int )*s == 94) {
#line 2336
          goto case_94;
        }
#line 2340
        goto switch_default;
        case_94: /* CIL Label */ 
#line 2337
        ctrl = 1;
#line 2338
        tmp = p;
#line 2338
        p --;
#line 2338
        *tmp = (char )'^';
#line 2339
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 2341
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
#line 2344
      goto __Cont;
    }
#line 2346
    s ++;
#line 2346
    if ((int )*s == esc) {
#line 2347
      goto __Cont;
    }
#line 2348
    plusflg = (int )*s == 43;
#line 2348
    if (plusflg != 0) {
#line 2349
      s ++;
    }
#line 2350
    minusflg = (int )*s == 45;
#line 2350
    if (minusflg != 0) {
#line 2351
      s ++;
    }
#line 2352
    zeroflg = (int )*s == 48;
#line 2352
    if (zeroflg != 0) {
#line 2353
      s ++;
    }
#line 2354
    num = 0;
    {
#line 2355
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2355
      if ((int )*s >= 48) {
#line 2355
        if (! ((int )*s <= 57)) {
#line 2355
          goto while_break___0;
        }
      } else {
#line 2355
        goto while_break___0;
      }
#line 2356
      tmp___0 = s;
#line 2356
      s ++;
#line 2356
      num = num * 10 + ((int )*tmp___0 - 48);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2357
    longflg = (int )*s == 76;
#line 2357
    if (longflg != 0) {
#line 2358
      s ++;
    }
    {
#line 2361
    if ((int )*s == 63) {
#line 2361
      goto case_63;
    }
#line 2378
    if ((int )*s == 58) {
#line 2378
      goto case_58;
    }
#line 2397
    if ((int )*s == 67) {
#line 2397
      goto case_67;
    }
#line 2397
    if ((int )*s == 99) {
#line 2397
      goto case_67;
    }
#line 2397
    if ((int )*s == 115) {
#line 2397
      goto case_67;
    }
#line 2397
    if ((int )*s == 65) {
#line 2397
      goto case_67;
    }
#line 2397
    if ((int )*s == 97) {
#line 2397
      goto case_67;
    }
#line 2397
    if ((int )*s == 89) {
#line 2397
      goto case_67;
    }
#line 2397
    if ((int )*s == 121) {
#line 2397
      goto case_67;
    }
#line 2397
    if ((int )*s == 77) {
#line 2397
      goto case_67;
    }
#line 2397
    if ((int )*s == 109) {
#line 2397
      goto case_67;
    }
#line 2397
    if ((int )*s == 68) {
#line 2397
      goto case_67;
    }
#line 2397
    if ((int )*s == 100) {
#line 2397
      goto case_67;
    }
#line 2461
    if ((int )*s == 108) {
#line 2461
      goto case_108;
    }
#line 2481
    if ((int )*s == 104) {
#line 2481
      goto case_104;
    }
#line 2481
    if ((int )*s == 96) {
#line 2481
      goto case_104;
    }
#line 2521
    if ((int )*s == 87) {
#line 2521
      goto case_87;
    }
#line 2521
    if ((int )*s == 119) {
#line 2521
      goto case_87;
    }
#line 2541
    if ((int )*s == 117) {
#line 2541
      goto case_117;
    }
#line 2549
    if ((int )*s == 102) {
#line 2549
      goto case_102;
    }
#line 2557
    if ((int )*s == 116) {
#line 2557
      goto case_116;
    }
#line 2567
    if ((int )*s == 123) {
#line 2567
      goto case_123;
    }
#line 2594
    if ((int )*s == 72) {
#line 2594
      goto case_72;
    }
#line 2604
    if ((int )*s == 70) {
#line 2604
      goto case_70;
    }
#line 2610
    if ((int )*s == 62) {
#line 2610
      goto case_62;
    }
#line 2617
    if ((int )*s == 60) {
#line 2617
      goto case_60;
    }
#line 2617
    if ((int )*s == 61) {
#line 2617
      goto case_60;
    }
#line 2732
    if ((int )*s == 110) {
#line 2732
      goto case_110;
    }
#line 2735
    goto switch_default___1;
    case_63: /* CIL Label */ 
#line 2362
    p --;
#line 2363
    if (qmpos) {
#line 2365
      if (! qmflag) {
#line 2365
        if (! omflag) {
#line 2365
          goto _L;
        } else {
#line 2365
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 2365
      if (omflag == 1) {
        _L: /* CIL Label */ 
#line 2367
        p = qmpos;
#line 2368
        if (qmnumrend < winmsg_numrend) {
#line 2369
          winmsg_numrend = qmnumrend;
        }
      }
#line 2371
      qmpos = (char *)0;
#line 2372
      goto switch_break___0;
    }
#line 2374
    qmpos = p;
#line 2375
    qmnumrend = winmsg_numrend;
#line 2376
    omflag = 0;
#line 2376
    qmflag = omflag;
#line 2377
    goto switch_break___0;
    case_58: /* CIL Label */ 
#line 2379
    p --;
#line 2380
    if (! qmpos) {
#line 2381
      goto switch_break___0;
    }
#line 2382
    if (qmflag) {
#line 2382
      if (omflag != 1) {
#line 2384
        omflag = 1;
#line 2385
        qmpos = p;
#line 2386
        qmnumrend = winmsg_numrend;
      } else {
#line 2382
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 2390
      p = qmpos;
#line 2391
      if (qmnumrend < winmsg_numrend) {
#line 2392
        winmsg_numrend = qmnumrend;
      }
#line 2393
      omflag = -1;
    }
#line 2395
    goto switch_break___0;
    case_67: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_97: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_100: /* CIL Label */ 
#line 2398
    if (l < 4) {
#line 2399
      goto switch_break___0;
    }
#line 2400
    if ((unsigned long )tm == (unsigned long )((struct tm *)0)) {
      {
#line 2402
      nowsec = now.tv_sec;
#line 2403
      tm = localtime((time_t const   *)(& nowsec));
      }
    }
#line 2405
    qmflag = 1;
#line 2406
    if (! tick) {
#line 2407
      tick = 3600;
    } else
#line 2406
    if (tick > 3600) {
#line 2407
      tick = 3600;
    }
    {
#line 2410
    if ((int )*s == 100) {
#line 2410
      goto case_100___0;
    }
#line 2413
    if ((int )*s == 68) {
#line 2413
      goto case_68___0;
    }
#line 2420
    if ((int )*s == 109) {
#line 2420
      goto case_109___0;
    }
#line 2423
    if ((int )*s == 77) {
#line 2423
      goto case_77___0;
    }
#line 2430
    if ((int )*s == 121) {
#line 2430
      goto case_121___0;
    }
#line 2433
    if ((int )*s == 89) {
#line 2433
      goto case_89___0;
    }
#line 2436
    if ((int )*s == 97) {
#line 2436
      goto case_97___0;
    }
#line 2439
    if ((int )*s == 65) {
#line 2439
      goto case_65___0;
    }
#line 2442
    if ((int )*s == 115) {
#line 2442
      goto case_115___0;
    }
#line 2446
    if ((int )*s == 99) {
#line 2446
      goto case_99___0;
    }
#line 2451
    if ((int )*s == 67) {
#line 2451
      goto case_67___0;
    }
#line 2456
    goto switch_default___0;
    case_100___0: /* CIL Label */ 
    {
#line 2411
    sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%02d", tm->tm_mday % 100);
    }
#line 2412
    goto switch_break___1;
    case_68___0: /* CIL Label */ 
#line 2415
    if (longflg) {
#line 2415
      tmp___1 = "%A";
    } else {
#line 2415
      tmp___1 = "%a";
    }
    {
#line 2415
    strftime((char */* __restrict  */)p, (size_t )l, (char const   */* __restrict  */)tmp___1,
             (struct tm  const  */* __restrict  */)tm);
    }
#line 2419
    goto switch_break___1;
    case_109___0: /* CIL Label */ 
    {
#line 2421
    sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%02d", tm->tm_mon + 1);
    }
#line 2422
    goto switch_break___1;
    case_77___0: /* CIL Label */ 
#line 2425
    if (longflg) {
#line 2425
      tmp___2 = "%B";
    } else {
#line 2425
      tmp___2 = "%b";
    }
    {
#line 2425
    strftime((char */* __restrict  */)p, (size_t )l, (char const   */* __restrict  */)tmp___2,
             (struct tm  const  */* __restrict  */)tm);
    }
#line 2429
    goto switch_break___1;
    case_121___0: /* CIL Label */ 
    {
#line 2431
    sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%02d", tm->tm_year % 100);
    }
#line 2432
    goto switch_break___1;
    case_89___0: /* CIL Label */ 
    {
#line 2434
    sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%04d", tm->tm_year + 1900);
    }
#line 2435
    goto switch_break___1;
    case_97___0: /* CIL Label */ 
#line 2437
    if (tm->tm_hour >= 12) {
#line 2437
      tmp___3 = "pm";
    } else {
#line 2437
      tmp___3 = "am";
    }
    {
#line 2437
    sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)tmp___3);
    }
#line 2438
    goto switch_break___1;
    case_65___0: /* CIL Label */ 
#line 2440
    if (tm->tm_hour >= 12) {
#line 2440
      tmp___4 = "PM";
    } else {
#line 2440
      tmp___4 = "AM";
    }
    {
#line 2440
    sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)tmp___4);
    }
#line 2441
    goto switch_break___1;
    case_115___0: /* CIL Label */ 
    {
#line 2443
    sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%02d", tm->tm_sec);
#line 2444
    tick = 1;
    }
#line 2445
    goto switch_break___1;
    case_99___0: /* CIL Label */ 
#line 2447
    if (zeroflg) {
#line 2447
      tmp___5 = "%02d:%02d";
    } else {
#line 2447
      tmp___5 = "%2d:%02d";
    }
    {
#line 2447
    sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)tmp___5,
            tm->tm_hour, tm->tm_min);
    }
#line 2448
    if (! tick) {
#line 2449
      tick = 60;
    } else
#line 2448
    if (tick > 60) {
#line 2449
      tick = 60;
    }
#line 2450
    goto switch_break___1;
    case_67___0: /* CIL Label */ 
#line 2452
    if (zeroflg) {
#line 2452
      tmp___6 = "%02d:%02d";
    } else {
#line 2452
      tmp___6 = "%2d:%02d";
    }
    {
#line 2452
    sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)tmp___6,
            (tm->tm_hour + 11) % 12 + 1, tm->tm_min);
    }
#line 2453
    if (! tick) {
#line 2454
      tick = 60;
    } else
#line 2453
    if (tick > 60) {
#line 2454
      tick = 60;
    }
#line 2455
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
#line 2457
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
    {
#line 2459
    tmp___7 = strlen((char const   *)p);
#line 2459
    p += tmp___7 - 1U;
    }
#line 2460
    goto switch_break___0;
    case_108: /* CIL Label */ 
#line 2463
    *p = (char)0;
#line 2464
    if (l > 20) {
      {
#line 2465
      AddLoadav(p);
      }
    }
#line 2466
    if (*p) {
      {
#line 2468
      qmflag = 1;
#line 2469
      tmp___8 = strlen((char const   *)p);
#line 2469
      p += tmp___8 - 1U;
      }
    } else {
#line 2472
      *p = (char )'?';
    }
#line 2473
    if (! tick) {
#line 2474
      tick = 60;
    } else
#line 2473
    if (tick > 60) {
#line 2474
      tick = 60;
    }
    {
#line 2478
    tmp___9 = strlen((char const   *)p);
#line 2478
    p += tmp___9 - 1U;
    }
#line 2479
    goto switch_break___0;
    case_104: /* CIL Label */ 
    case_96: /* CIL Label */ 
#line 2482
    if (rec >= 10) {
#line 2484
      p --;
#line 2485
      goto switch_break___0;
    } else
#line 2482
    if ((int )*s == 104) {
#line 2482
      if ((unsigned long )win == (unsigned long )((struct win *)0)) {
#line 2484
        p --;
#line 2485
        goto switch_break___0;
      } else
#line 2482
      if ((unsigned long )win->w_hstatus == (unsigned long )((char *)0)) {
#line 2484
        p --;
#line 2485
        goto switch_break___0;
      } else
#line 2482
      if ((int )*(win->w_hstatus) == 0) {
#line 2484
        p --;
#line 2485
        goto switch_break___0;
      }
    }
#line 2487
    if ((int )*s == 96) {
#line 2489
      bt = backticks;
      {
#line 2489
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2489
        if (! bt) {
#line 2489
          goto while_break___1;
        }
#line 2490
        if (bt->num == num) {
#line 2491
          goto while_break___1;
        }
#line 2489
        bt = bt->next;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2492
      if ((unsigned long )bt == (unsigned long )((struct backtick *)0)) {
#line 2494
        p --;
#line 2495
        goto switch_break___0;
      }
    }
    {
#line 2500
    oldtick = tick;
#line 2501
    oldnumrend = winmsg_numrend;
#line 2503
    *p = (char)0;
#line 2504
    strcpy((char */* __restrict  */)(savebuf), (char const   */* __restrict  */)(winmsg_buf));
#line 2505
    winmsg_numrend = - winmsg_numrend;
    }
#line 2506
    if ((int )*s == 104) {
#line 2506
      tmp___11 = win->w_hstatus;
    } else {
      {
#line 2506
      tmp___10 = runbacktick(bt, & oldtick, now.tv_sec);
#line 2506
      tmp___11 = tmp___10;
      }
    }
    {
#line 2506
    MakeWinMsgEv(tmp___11, win, '\005', 0, (struct event *)0, rec + 1);
    }
    {
#line 2507
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2507
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2508
    if (! tick) {
#line 2509
      tick = oldtick;
    } else
#line 2508
    if (oldtick < tick) {
#line 2509
      tick = oldtick;
    }
    {
#line 2510
    tmp___12 = strlen((char const   *)(winmsg_buf));
    }
#line 2510
    if ((int )tmp___12 < l) {
      {
#line 2511
      strcat((char */* __restrict  */)(savebuf), (char const   */* __restrict  */)(winmsg_buf));
      }
    }
    {
#line 2512
    strcpy((char */* __restrict  */)(winmsg_buf), (char const   */* __restrict  */)(savebuf));
    }
    {
#line 2513
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2513
      if (! (oldnumrend < winmsg_numrend)) {
#line 2513
        goto while_break___3;
      }
#line 2514
      tmp___13 = oldnumrend;
#line 2514
      oldnumrend ++;
#line 2514
      winmsg_rendpos[tmp___13] = (int )((long )winmsg_rendpos[tmp___13] + (p - winmsg_buf));
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2515
    if (*p) {
#line 2516
      qmflag = 1;
    }
    {
#line 2517
    tmp___14 = strlen((char const   *)p);
#line 2517
    p += tmp___14 - 1U;
    }
#line 2519
    goto switch_break___0;
    case_87: /* CIL Label */ 
    case_119: /* CIL Label */ 
#line 2523
    oldfore = (struct win *)0;
#line 2526
    if (display) {
#line 2528
      oldfore = display->d_fore;
#line 2529
      display->d_fore = win;
    }
#line 2531
    if (win) {
#line 2531
      tmp___15 = win->w_number;
    } else {
#line 2531
      tmp___15 = -1;
    }
#line 2531
    if ((int )*s == 119) {
#line 2531
      tmp___16 = 0;
    } else {
#line 2531
      tmp___16 = 1;
    }
#line 2531
    if (longflg) {
#line 2531
      tmp___17 = 0;
    } else {
#line 2531
      tmp___17 = 2;
    }
#line 2531
    if (plusflg) {
#line 2531
      tmp___18 = 4;
    } else {
#line 2531
      tmp___18 = 0;
    }
    {
#line 2531
    ss = AddWindows(p, l - 1, (tmp___16 | tmp___17) | tmp___18, tmp___15);
    }
#line 2532
    if (minusflg) {
#line 2533
      *ss = (char)0;
    }
#line 2534
    if (display) {
#line 2535
      display->d_fore = oldfore;
    }
#line 2537
    if (*p) {
#line 2538
      qmflag = 1;
    }
    {
#line 2539
    tmp___19 = strlen((char const   *)p);
#line 2539
    p += tmp___19 - 1U;
    }
#line 2540
    goto switch_break___0;
    case_117: /* CIL Label */ 
#line 2542
    *p = (char)0;
#line 2543
    if (win) {
      {
#line 2544
      AddOtherUsers(p, l - 1, win);
      }
    }
#line 2545
    if (*p) {
#line 2546
      qmflag = 1;
    }
    {
#line 2547
    tmp___20 = strlen((char const   *)p);
#line 2547
    p += tmp___20 - 1U;
    }
#line 2548
    goto switch_break___0;
    case_102: /* CIL Label */ 
#line 2550
    *p = (char)0;
#line 2551
    if (win) {
      {
#line 2552
      AddWindowFlags(p, l - 1, win);
      }
    }
#line 2553
    if (*p) {
#line 2554
      qmflag = 1;
    }
    {
#line 2555
    tmp___21 = strlen((char const   *)p);
#line 2555
    p += tmp___21 - 1U;
    }
#line 2556
    goto switch_break___0;
    case_116: /* CIL Label */ 
#line 2558
    *p = (char)0;
#line 2559
    if (win) {
      {
#line 2559
      tmp___22 = strlen((char const   *)win->w_title);
      }
#line 2559
      if ((int )tmp___22 < l) {
        {
#line 2561
        strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)win->w_title);
        }
#line 2562
        if (*p) {
#line 2563
          qmflag = 1;
        }
      }
    }
    {
#line 2565
    tmp___23 = strlen((char const   *)p);
#line 2565
    p += tmp___23 - 1U;
    }
#line 2566
    goto switch_break___0;
    case_123: /* CIL Label */ 
#line 2570
    s ++;
#line 2571
    i = 0;
    {
#line 2571
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2571
      if (! (i < 127)) {
#line 2571
        goto while_break___4;
      }
#line 2572
      if (*(s + i)) {
#line 2572
        if ((int )*(s + i) != 125) {
#line 2573
          rbuf[i] = *(s + i);
        } else {
#line 2575
          goto while_break___4;
        }
      } else {
#line 2575
        goto while_break___4;
      }
#line 2571
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 2576
    if ((int )*(s + i) == 125) {
#line 2576
      if (winmsg_numrend < 16) {
#line 2578
        r = -1;
#line 2579
        rbuf[i] = (char)0;
        {
#line 2580
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 2580
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 2581
        if (i != 1) {
          {
#line 2582
          r = ParseAttrColor(rbuf, (char *)0, 0);
          }
        } else
#line 2581
        if ((int )rbuf[0] != 45) {
          {
#line 2582
          r = ParseAttrColor(rbuf, (char *)0, 0);
          }
        }
#line 2583
        if (r != -1) {
#line 2585
          winmsg_rend[winmsg_numrend] = r;
#line 2586
          winmsg_rendpos[winmsg_numrend] = (int )(p - winmsg_buf);
#line 2587
          winmsg_numrend ++;
        } else
#line 2583
        if (i == 1) {
#line 2583
          if ((int )rbuf[0] == 45) {
#line 2585
            winmsg_rend[winmsg_numrend] = r;
#line 2586
            winmsg_rendpos[winmsg_numrend] = (int )(p - winmsg_buf);
#line 2587
            winmsg_numrend ++;
          }
        }
      }
    }
#line 2590
    s += i;
#line 2591
    p --;
#line 2593
    goto switch_break___0;
    case_72: /* CIL Label */ 
    {
#line 2595
    *p = (char)0;
#line 2596
    tmp___24 = strlen((char const   *)(HostName));
    }
#line 2596
    if ((int )tmp___24 < l) {
      {
#line 2598
      strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)(HostName));
      }
#line 2599
      if (*p) {
#line 2600
        qmflag = 1;
      }
    }
    {
#line 2602
    tmp___25 = strlen((char const   *)p);
#line 2602
    p += tmp___25 - 1U;
    }
#line 2603
    goto switch_break___0;
    case_70: /* CIL Label */ 
#line 2605
    p --;
#line 2607
    if (display) {
#line 2607
      if (ev) {
#line 2607
        if ((unsigned long )ev == (unsigned long )(& (display->d_forecv)->c_captev)) {
#line 2608
          qmflag = 1;
        } else {
#line 2607
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 2607
      if (! ev) {
#line 2607
        if (win) {
#line 2607
          if ((unsigned long )win == (unsigned long )display->d_fore) {
#line 2608
            qmflag = 1;
          }
        }
      }
    }
#line 2609
    goto switch_break___0;
    case_62: /* CIL Label */ 
#line 2611
    truncpos = (int )(p - winmsg_buf);
#line 2612
    if (num > 100) {
#line 2612
      truncper = 100;
    } else {
#line 2612
      truncper = num;
    }
#line 2613
    trunclong = longflg;
#line 2614
    p --;
#line 2615
    goto switch_break___0;
    case_60: /* CIL Label */ 
    case_61: /* CIL Label */ 
#line 2618
    *p = (char )' ';
#line 2619
    if (num) {
#line 2619
      goto _L___3;
    } else
#line 2619
    if (zeroflg) {
#line 2619
      goto _L___3;
    } else
#line 2619
    if (plusflg) {
#line 2619
      goto _L___3;
    } else
#line 2619
    if (longflg) {
#line 2619
      goto _L___3;
    } else
#line 2619
    if ((int )*s != 61) {
      _L___3: /* CIL Label */ 
#line 2622
      if (minusflg) {
#line 2624
        if (plusflg) {
#line 2624
          tmp___26 = lastpad;
        } else {
#line 2624
          tmp___26 = padlen;
        }
#line 2624
        num = tmp___26 - num;
#line 2625
        if (! plusflg) {
#line 2625
          if (padlen == 0) {
#line 2626
            num = (int )(p - winmsg_buf);
          }
        }
#line 2627
        plusflg = 0;
      } else
#line 2629
      if (! zeroflg) {
#line 2631
        if ((int )*s != 61) {
#line 2631
          if (num == 0) {
#line 2631
            if (! plusflg) {
#line 2632
              num = 100;
            }
          }
        }
#line 2633
        if (num > 100) {
#line 2634
          num = 100;
        }
#line 2635
        if (padlen == 0) {
#line 2636
          num = (int )(p - winmsg_buf);
        } else {
#line 2638
          if (plusflg) {
#line 2638
            tmp___27 = lastpad;
          } else {
#line 2638
            tmp___27 = 0;
          }
#line 2638
          num = ((padlen - tmp___27) * num) / 100;
        }
      }
#line 2640
      if (num < 0) {
#line 2641
        num = 0;
      }
#line 2642
      if (plusflg) {
#line 2643
        num += lastpad;
      }
#line 2644
      if (num > 255) {
#line 2645
        num = 255;
      }
#line 2646
      if (numpad) {
        {
#line 2647
        p = pad_expand(winmsg_buf, p, numpad, num);
        }
      }
#line 2648
      numpad = 0;
#line 2649
      if (p - winmsg_buf > (long )num) {
#line 2649
        if (! longflg) {
#line 2653
          if (truncpos == -1) {
#line 2655
            truncpos = lastpad;
#line 2656
            truncper = 0;
          }
#line 2658
          trunc = lastpad + (truncper * (num - lastpad)) / 100;
#line 2659
          if (trunc > num) {
#line 2660
            trunc = num;
          }
#line 2661
          if (trunc < lastpad) {
#line 2662
            trunc = lastpad;
          }
#line 2663
          left = truncpos - trunc;
#line 2664
          if ((long )left > (p - winmsg_buf) - (long )num) {
#line 2665
            left = (int )((p - winmsg_buf) - (long )num);
          }
          {
#line 2666
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 2666
            goto while_break___6;
          }
          while_break___6: /* CIL Label */ ;
          }
          {
#line 2667
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 2667
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
#line 2668
          if (left > 0) {
#line 2670
            if ((long )(left + lastpad) > p - winmsg_buf) {
#line 2671
              left = (int )((p - winmsg_buf) - (long )lastpad);
            }
#line 2672
            if (((p - winmsg_buf) - (long )lastpad) - (long )left > 0L) {
              {
#line 2673
              bcopy((void const   *)((winmsg_buf + lastpad) + left), (void *)(winmsg_buf + lastpad),
                    (size_t )(((p - winmsg_buf) - (long )lastpad) - (long )left));
              }
            }
#line 2674
            p -= left;
#line 2675
            r = winmsg_numrend;
            {
#line 2676
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 2676
              if (r) {
#line 2676
                if (! (winmsg_rendpos[r - 1] > lastpad)) {
#line 2676
                  goto while_break___8;
                }
              } else {
#line 2676
                goto while_break___8;
              }
#line 2678
              r --;
#line 2679
              winmsg_rendpos[r] -= left;
#line 2680
              if (winmsg_rendpos[r] < lastpad) {
#line 2681
                winmsg_rendpos[r] = lastpad;
              }
            }
            while_break___8: /* CIL Label */ ;
            }
#line 2683
            if (trunclong) {
#line 2685
              if (p - winmsg_buf > (long )lastpad) {
#line 2686
                winmsg_buf[lastpad] = (char )'.';
              }
#line 2687
              if (p - winmsg_buf > (long )(lastpad + 1)) {
#line 2688
                winmsg_buf[lastpad + 1] = (char )'.';
              }
#line 2689
              if (p - winmsg_buf > (long )(lastpad + 2)) {
#line 2690
                winmsg_buf[lastpad + 2] = (char )'.';
              }
            }
          }
#line 2693
          if (p - winmsg_buf > (long )num) {
#line 2695
            p = winmsg_buf + num;
#line 2696
            if (trunclong) {
#line 2698
              if (num - 1 >= lastpad) {
#line 2699
                *(p + -1) = (char )'.';
              }
#line 2700
              if (num - 2 >= lastpad) {
#line 2701
                *(p + -2) = (char )'.';
              }
#line 2702
              if (num - 3 >= lastpad) {
#line 2703
                *(p + -3) = (char )'.';
              }
            }
#line 2705
            r = winmsg_numrend;
            {
#line 2706
            while (1) {
              while_continue___9: /* CIL Label */ ;
#line 2706
              if (r) {
#line 2706
                if (! (winmsg_rendpos[r - 1] > num)) {
#line 2706
                  goto while_break___9;
                }
              } else {
#line 2706
                goto while_break___9;
              }
#line 2707
              r --;
#line 2707
              winmsg_rendpos[r] = num;
            }
            while_break___9: /* CIL Label */ ;
            }
          }
#line 2709
          truncpos = -1;
#line 2710
          trunclong = 0;
#line 2711
          if ((long )lastpad > p - winmsg_buf) {
#line 2712
            lastpad = (int )(p - winmsg_buf);
          }
          {
#line 2713
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 2713
            goto while_break___10;
          }
          while_break___10: /* CIL Label */ ;
          }
        }
      }
#line 2715
      if ((int )*s == 61) {
        {
#line 2717
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 2717
          if (! (p - winmsg_buf < (long )num)) {
#line 2717
            goto while_break___11;
          }
#line 2718
          tmp___28 = p;
#line 2718
          p ++;
#line 2718
          *tmp___28 = (char )' ';
        }
        while_break___11: /* CIL Label */ ;
        }
#line 2719
        lastpad = (int )(p - winmsg_buf);
#line 2720
        truncpos = -1;
#line 2721
        trunclong = 0;
        {
#line 2722
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 2722
          goto while_break___12;
        }
        while_break___12: /* CIL Label */ ;
        }
      }
#line 2724
      p --;
    } else
#line 2726
    if (padlen) {
#line 2728
      *p = (char)127;
#line 2729
      numpad ++;
    }
#line 2731
    goto switch_break___0;
    case_110: /* CIL Label */ 
#line 2733
    s ++;
    switch_default___1: /* CIL Label */ 
#line 2736
    s --;
#line 2737
    if (l > 10 + num) {
#line 2739
      if (num == 0) {
#line 2740
        num = 1;
      }
#line 2741
      if (! win) {
#line 2742
        if (num > 1) {
#line 2742
          tmp___29 = "--";
        } else {
#line 2742
          tmp___29 = "-";
        }
        {
#line 2742
        sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%*s",
                num, tmp___29);
        }
      } else {
        {
#line 2744
        sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%*d",
                num, win->w_number);
        }
      }
      {
#line 2745
      qmflag = 1;
#line 2746
      tmp___30 = strlen((char const   *)p);
#line 2746
      p += tmp___30 - 1U;
      }
    }
#line 2748
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 2315
    s ++;
#line 2315
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2751
  if (qmpos) {
#line 2751
    if (! qmflag) {
#line 2752
      p = qmpos + 1;
    }
  }
#line 2753
  *p = (char )'\000';
#line 2754
  if (numpad) {
#line 2756
    if (padlen > 255) {
#line 2757
      padlen = 255;
    }
    {
#line 2758
    p = pad_expand(winmsg_buf, p, numpad, padlen);
    }
  }
#line 2760
  if (ev) {
    {
#line 2762
    evdeq(ev);
#line 2763
    ev->timeout.tv_sec = (__time_t )0;
#line 2764
    ev->timeout.tv_usec = (__suseconds_t )0;
    }
  }
#line 2766
  if (ev) {
#line 2766
    if (tick) {
#line 2768
      now.tv_usec = (__suseconds_t )100000;
#line 2769
      if (tick == 1) {
#line 2770
        (now.tv_sec) ++;
      } else {
#line 2772
        now.tv_sec += (long )tick - now.tv_sec % (long )tick;
      }
#line 2773
      ev->timeout = now;
      {
#line 2774
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 2774
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
    }
  }
#line 2776
  return (winmsg_buf);
}
}
#line 2779 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
char *MakeWinMsg(char *s , struct win *win , int esc ) 
{ 
  char *tmp ;

  {
  {
#line 2785
  tmp = MakeWinMsgEv(s, win, esc, 0, (struct event *)0, 0);
  }
#line 2785
  return (tmp);
}
}
#line 2788 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
int PutWinMsg(char *s , int start , int max ) 
{ 
  int i ;
  int p ;
  int l ;
  int r ;
  int n ;
  struct mchar rend ;
  struct mchar rendstack[16] ;
  int rendstackn ;
  size_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 2796
  rendstackn = 0;
#line 2798
  if ((unsigned long )s != (unsigned long )(winmsg_buf)) {
#line 2799
    return (0);
  }
  {
#line 2800
  rend = display->d_rend;
#line 2801
  p = 0;
#line 2802
  tmp = strlen((char const   *)s);
#line 2802
  l = (int )tmp;
  }
  {
#line 2803
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2803
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2804
  i = 0;
  {
#line 2804
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2804
    if (i < winmsg_numrend) {
#line 2804
      if (! (max > 0)) {
#line 2804
        goto while_break___0;
      }
    } else {
#line 2804
      goto while_break___0;
    }
#line 2806
    if (p > winmsg_rendpos[i]) {
#line 2807
      goto while_break___0;
    } else
#line 2806
    if (winmsg_rendpos[i] > l) {
#line 2807
      goto while_break___0;
    }
#line 2808
    if (p < winmsg_rendpos[i]) {
#line 2810
      n = winmsg_rendpos[i] - p;
#line 2811
      if (n > max) {
#line 2812
        n = max;
      }
#line 2813
      max -= n;
#line 2814
      p += n;
      {
#line 2815
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2815
        tmp___2 = n;
#line 2815
        n --;
#line 2815
        if (! (tmp___2 > 0)) {
#line 2815
          goto while_break___1;
        }
#line 2817
        tmp___1 = start;
#line 2817
        start --;
#line 2817
        if (tmp___1 > 0) {
#line 2818
          s ++;
        } else {
          {
#line 2820
          tmp___0 = s;
#line 2820
          s ++;
#line 2820
          PUTCHARLP((int )*tmp___0);
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 2823
    r = winmsg_rend[i];
#line 2824
    if (r == -1) {
#line 2826
      if (rendstackn > 0) {
#line 2827
        rendstackn --;
#line 2827
        rend = rendstack[rendstackn];
      }
    } else {
      {
#line 2831
      tmp___3 = rendstackn;
#line 2831
      rendstackn ++;
#line 2831
      rendstack[tmp___3] = rend;
#line 2832
      ApplyAttrColor(r, & rend);
      }
    }
    {
#line 2834
    SetRendition(& rend);
#line 2804
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2836
  if (p < l) {
#line 2838
    n = l - p;
#line 2839
    if (n > max) {
#line 2840
      n = max;
    }
    {
#line 2841
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2841
      tmp___6 = n;
#line 2841
      n --;
#line 2841
      if (! (tmp___6 > 0)) {
#line 2841
        goto while_break___2;
      }
#line 2843
      tmp___5 = start;
#line 2843
      start --;
#line 2843
      if (tmp___5 > 0) {
#line 2844
        s ++;
      } else {
        {
#line 2846
        tmp___4 = s;
#line 2846
        s ++;
#line 2846
        PUTCHARLP((int )*tmp___4);
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 2849
  return (1);
}
}
#line 2884 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
static void serv_read_fn(struct event *ev , char *data ) 
{ 


  {
  {
#line 2889
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2889
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2890
  ReceiveMsg();
  }
#line 2891
  return;
}
}
#line 2893 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
static void serv_select_fn(struct event *ev , char *data ) 
{ 
  struct win *p ;
  char ibuf ;
  int tmp ;
  struct canvas *cv ;
  int visual ;
  int tmp___0 ;
  char *tmp___1 ;
  struct canvas *cv___0 ;
  char *tmp___2 ;
  struct canvas *cv___1 ;
  int lx ;
  int ly ;
  int i ;
  int n ;
  struct display *olddisplay ;
  struct layer *oldflayer ;
  struct layer *l ;
  struct canvas *cvlist ;
  struct canvas *cvlnext ;
  int i___0 ;
  int n___0 ;
  struct display *olddisplay___0 ;
  struct layer *oldflayer___0 ;
  struct layer *l___0 ;
  struct canvas *cvlist___0 ;
  struct canvas *cvlnext___0 ;
  int i___1 ;
  int n___1 ;
  struct display *olddisplay___1 ;
  struct layer *oldflayer___1 ;
  struct layer *l___1 ;
  struct canvas *cvlist___1 ;
  struct canvas *cvlnext___1 ;
  int i___2 ;
  int n___2 ;
  struct display *olddisplay___2 ;
  struct layer *oldflayer___2 ;
  struct layer *l___2 ;
  struct canvas *cvlist___2 ;
  struct canvas *cvlnext___2 ;
  struct display *olddisplay___3 ;
  struct layer *oldflayer___3 ;
  struct layer *l___3 ;
  struct canvas *cvlist___3 ;
  struct canvas *cvlnext___3 ;

  {
  {
#line 2900
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2900
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2902
  if (GotSigChld) {
    {
#line 2904
    SigChldHandler();
    }
  }
#line 2906
  if (InterruptPlease) {
    {
#line 2908
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2908
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2911
    if (fore) {
#line 2911
      if (displays) {
#line 2914
        ibuf = (char )displays->d_OldMode.tio.c_cc[0];
#line 2919
        if (fore->w_pwin) {
#line 2919
          if ((fore->w_pwin)->p_fdpat & 4096) {
#line 2919
            tmp = (fore->w_pwin)->p_ptyfd;
          } else {
#line 2919
            tmp = fore->w_ptyfd;
          }
        } else {
#line 2919
          tmp = fore->w_ptyfd;
        }
        {
#line 2919
        write(tmp, (void const   *)(& ibuf), (size_t )1);
        }
        {
#line 2921
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2921
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 2922
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2922
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
#line 2928
    InterruptPlease = 0;
  }
#line 2931
  p = windows;
  {
#line 2931
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2931
    if (! p) {
#line 2931
      goto while_break___3;
    }
#line 2933
    if (p->w_bell == 1) {
#line 2933
      goto _L___0;
    } else
#line 2933
    if (p->w_bell == 3) {
      _L___0: /* CIL Label */ 
#line 2936
      if (p->w_bell == 3) {
#line 2936
        tmp___0 = 1;
      } else
#line 2936
      if (visual_bell) {
#line 2936
        tmp___0 = 1;
      } else {
#line 2936
        tmp___0 = 0;
      }
#line 2936
      visual = tmp___0;
#line 2937
      p->w_bell = 0;
#line 2938
      display = displays;
      {
#line 2938
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 2938
        if (! display) {
#line 2938
          goto while_break___4;
        }
#line 2940
        cv = display->d_cvlist;
        {
#line 2940
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 2940
          if (! cv) {
#line 2940
            goto while_break___5;
          }
#line 2941
          if ((unsigned long )(cv->c_layer)->l_bottom == (unsigned long )(& p->w_layer)) {
#line 2942
            goto while_break___5;
          }
#line 2940
          cv = cv->c_next;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 2943
        if ((unsigned long )cv == (unsigned long )((struct canvas *)0)) {
          {
#line 2945
          p->w_bell = 2;
#line 2946
          tmp___1 = MakeWinMsg(BellString, p, '%');
#line 2946
          Msg(0, (char *)"%s", tmp___1);
          }
        } else
#line 2948
        if (visual) {
#line 2948
          if (! display->d_tcs[43].str) {
#line 2948
            if (! display->d_status) {
#line 2948
              goto _L;
            } else
#line 2948
            if (! display->d_status_bell) {
              _L: /* CIL Label */ 
              {
#line 2950
              Msg(0, (char *)"%s", VisualBellString);
              }
#line 2951
              if (display->d_status) {
#line 2953
                display->d_status_bell = (char)1;
                {
#line 2954
                while (1) {
                  while_continue___6: /* CIL Label */ ;
#line 2954
                  goto while_break___6;
                }
                while_break___6: /* CIL Label */ ;
                }
                {
#line 2955
                SetTimeout(& display->d_statusev, VBellWait);
                }
              }
            }
          }
        }
#line 2938
        display = display->d_next;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 2960
      if (p->w_monitor == 2) {
#line 2961
        p->w_monitor = 3;
      }
      {
#line 2962
      WindowChanged(p, 'f');
      }
    }
#line 2964
    if (p->w_monitor == 2) {
#line 2967
      p->w_monitor = 1;
#line 2968
      display = displays;
      {
#line 2968
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 2968
        if (! display) {
#line 2968
          goto while_break___7;
        }
#line 2970
        cv___0 = display->d_cvlist;
        {
#line 2970
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 2970
          if (! cv___0) {
#line 2970
            goto while_break___8;
          }
#line 2971
          if ((unsigned long )(cv___0->c_layer)->l_bottom == (unsigned long )(& p->w_layer)) {
#line 2972
            goto while_break___8;
          }
#line 2970
          cv___0 = cv___0->c_next;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 2973
        if (cv___0) {
#line 2974
          goto __Cont;
        }
#line 2976
        if (! ((int )*(p->w_mon_notify + ((display->d_user)->u_id >> 3)) & (128 >> ((display->d_user)->u_id & 7)))) {
#line 2977
          goto __Cont;
        }
        {
#line 2979
        tmp___2 = MakeWinMsg(ActivityString, p, '%');
#line 2979
        Msg(0, (char *)"%s", tmp___2);
#line 2980
        p->w_monitor = 3;
        }
        __Cont: /* CIL Label */ 
#line 2968
        display = display->d_next;
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 2982
      WindowChanged(p, 'f');
      }
    }
#line 2931
    p = p->w_next;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2986
  display = displays;
  {
#line 2986
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 2986
    if (! display) {
#line 2986
      goto while_break___9;
    }
#line 2989
    if (display->d_status == 1) {
#line 2990
      goto __Cont___0;
    }
#line 2992
    cv___1 = display->d_cvlist;
    {
#line 2992
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 2992
      if (! cv___1) {
#line 2992
        goto while_break___10;
      }
#line 2997
      lx = (cv___1->c_layer)->l_x;
#line 2998
      ly = (cv___1->c_layer)->l_y;
#line 2999
      if (lx == (cv___1->c_layer)->l_width) {
#line 3000
        lx --;
      }
#line 3001
      if (ly + cv___1->c_yoff < cv___1->c_ys) {
        {
#line 3003
        n = cv___1->c_ys - (ly + cv___1->c_yoff);
#line 3004
        cv___1->c_yoff = cv___1->c_ys - ly;
#line 3005
        RethinkViewportOffsets(cv___1);
        }
#line 3006
        if (n > (cv___1->c_layer)->l_height) {
#line 3007
          n = (cv___1->c_layer)->l_height;
        }
        {
#line 3008
        olddisplay = display;
#line 3008
        oldflayer = flayer;
#line 3008
        l = cv___1->c_layer;
#line 3008
        cvlist = l->l_cvlist;
#line 3008
        cvlnext = cv___1->c_lnext;
#line 3008
        flayer = l;
#line 3008
        l->l_cvlist = cv___1;
#line 3008
        cv___1->c_lnext = (struct canvas *)0;
#line 3008
        LScrollV(flayer, - n, 0, flayer->l_height - 1, 0);
#line 3008
        (*((flayer->l_layfn)->lf_LayRedisplayLine))(-1, -1, -1, 1);
#line 3008
        i = 0;
        }
        {
#line 3008
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 3008
          if (! (i < n)) {
#line 3008
            goto while_break___11;
          }
          {
#line 3008
          (*((flayer->l_layfn)->lf_LayRedisplayLine))(i, 0, flayer->l_width - 1, 1);
#line 3008
          i ++;
          }
        }
        while_break___11: /* CIL Label */ ;
        }
#line 3008
        if ((unsigned long )cv___1 == (unsigned long )(cv___1->c_display)->d_forecv) {
          {
#line 3008
          LGotoPos(flayer, flayer->l_x, flayer->l_y);
          }
        }
#line 3008
        flayer = oldflayer;
#line 3008
        l->l_cvlist = cvlist;
#line 3008
        cv___1->c_lnext = cvlnext;
#line 3008
        display = olddisplay;
      } else
#line 3017
      if (ly + cv___1->c_yoff > cv___1->c_ye) {
        {
#line 3019
        n___0 = (ly + cv___1->c_yoff) - cv___1->c_ye;
#line 3020
        cv___1->c_yoff = cv___1->c_ye - ly;
#line 3021
        RethinkViewportOffsets(cv___1);
        }
#line 3022
        if (n___0 > (cv___1->c_layer)->l_height) {
#line 3023
          n___0 = (cv___1->c_layer)->l_height;
        }
        {
#line 3024
        olddisplay___0 = display;
#line 3024
        oldflayer___0 = flayer;
#line 3024
        l___0 = cv___1->c_layer;
#line 3024
        cvlist___0 = l___0->l_cvlist;
#line 3024
        cvlnext___0 = cv___1->c_lnext;
#line 3024
        flayer = l___0;
#line 3024
        l___0->l_cvlist = cv___1;
#line 3024
        cv___1->c_lnext = (struct canvas *)0;
#line 3024
        LScrollV(flayer, n___0, 0, (cv___1->c_layer)->l_height - 1, 0);
#line 3024
        (*((flayer->l_layfn)->lf_LayRedisplayLine))(-1, -1, -1, 1);
#line 3024
        i___0 = 0;
        }
        {
#line 3024
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 3024
          if (! (i___0 < n___0)) {
#line 3024
            goto while_break___12;
          }
          {
#line 3024
          (*((flayer->l_layfn)->lf_LayRedisplayLine))((i___0 + flayer->l_height) - n___0,
                                                      0, flayer->l_width - 1, 1);
#line 3024
          i___0 ++;
          }
        }
        while_break___12: /* CIL Label */ ;
        }
#line 3024
        if ((unsigned long )cv___1 == (unsigned long )(cv___1->c_display)->d_forecv) {
          {
#line 3024
          LGotoPos(flayer, flayer->l_x, flayer->l_y);
          }
        }
#line 3024
        flayer = oldflayer___0;
#line 3024
        l___0->l_cvlist = cvlist___0;
#line 3024
        cv___1->c_lnext = cvlnext___0;
#line 3024
        display = olddisplay___0;
      }
#line 3033
      if (lx + cv___1->c_xoff < cv___1->c_xs) {
#line 3035
        n___1 = cv___1->c_xs - (lx + cv___1->c_xoff);
#line 3036
        if (n___1 < ((cv___1->c_xe - cv___1->c_xs) + 1) / 2) {
#line 3037
          n___1 = ((cv___1->c_xe - cv___1->c_xs) + 1) / 2;
        }
#line 3038
        if (cv___1->c_xoff + n___1 > cv___1->c_xs) {
#line 3039
          n___1 = cv___1->c_xs - cv___1->c_xoff;
        }
        {
#line 3040
        cv___1->c_xoff += n___1;
#line 3041
        RethinkViewportOffsets(cv___1);
        }
#line 3042
        if (n___1 > (cv___1->c_layer)->l_width) {
#line 3043
          n___1 = (cv___1->c_layer)->l_width;
        }
        {
#line 3044
        olddisplay___1 = display;
#line 3044
        oldflayer___1 = flayer;
#line 3044
        l___1 = cv___1->c_layer;
#line 3044
        cvlist___1 = l___1->l_cvlist;
#line 3044
        cvlnext___1 = cv___1->c_lnext;
#line 3044
        flayer = l___1;
#line 3044
        l___1->l_cvlist = cv___1;
#line 3044
        cv___1->c_lnext = (struct canvas *)0;
#line 3044
        (*((flayer->l_layfn)->lf_LayRedisplayLine))(-1, -1, -1, 1);
#line 3044
        i___1 = 0;
        }
        {
#line 3044
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 3044
          if (! (i___1 < flayer->l_height)) {
#line 3044
            goto while_break___13;
          }
          {
#line 3044
          LScrollH(flayer, - n___1, i___1, 0, flayer->l_width - 1, 0, (struct mline *)0);
#line 3044
          (*((flayer->l_layfn)->lf_LayRedisplayLine))(i___1, 0, n___1 - 1, 1);
#line 3044
          i___1 ++;
          }
        }
        while_break___13: /* CIL Label */ ;
        }
#line 3044
        if ((unsigned long )cv___1 == (unsigned long )(cv___1->c_display)->d_forecv) {
          {
#line 3044
          LGotoPos(flayer, flayer->l_x, flayer->l_y);
          }
        }
#line 3044
        flayer = oldflayer___1;
#line 3044
        l___1->l_cvlist = cvlist___1;
#line 3044
        cv___1->c_lnext = cvlnext___1;
#line 3044
        display = olddisplay___1;
      } else
#line 3055
      if (lx + cv___1->c_xoff > cv___1->c_xe) {
#line 3057
        n___2 = (lx + cv___1->c_xoff) - cv___1->c_xe;
#line 3058
        if (n___2 < ((cv___1->c_xe - cv___1->c_xs) + 1) / 2) {
#line 3059
          n___2 = ((cv___1->c_xe - cv___1->c_xs) + 1) / 2;
        }
#line 3060
        if (((cv___1->c_xoff - n___2) + (cv___1->c_layer)->l_width) - 1 < cv___1->c_xe) {
#line 3061
          n___2 = ((cv___1->c_xoff + (cv___1->c_layer)->l_width) - 1) - cv___1->c_xe;
        }
        {
#line 3062
        cv___1->c_xoff -= n___2;
#line 3063
        RethinkViewportOffsets(cv___1);
        }
#line 3064
        if (n___2 > (cv___1->c_layer)->l_width) {
#line 3065
          n___2 = (cv___1->c_layer)->l_width;
        }
        {
#line 3066
        olddisplay___2 = display;
#line 3066
        oldflayer___2 = flayer;
#line 3066
        l___2 = cv___1->c_layer;
#line 3066
        cvlist___2 = l___2->l_cvlist;
#line 3066
        cvlnext___2 = cv___1->c_lnext;
#line 3066
        flayer = l___2;
#line 3066
        l___2->l_cvlist = cv___1;
#line 3066
        cv___1->c_lnext = (struct canvas *)0;
#line 3066
        (*((flayer->l_layfn)->lf_LayRedisplayLine))(-1, -1, -1, 1);
#line 3066
        i___2 = 0;
        }
        {
#line 3066
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 3066
          if (! (i___2 < flayer->l_height)) {
#line 3066
            goto while_break___14;
          }
          {
#line 3066
          LScrollH(flayer, n___2, i___2, 0, flayer->l_width - 1, 0, (struct mline *)0);
#line 3066
          (*((flayer->l_layfn)->lf_LayRedisplayLine))(i___2, flayer->l_width - n___2,
                                                      flayer->l_width - 1, 1);
#line 3066
          i___2 ++;
          }
        }
        while_break___14: /* CIL Label */ ;
        }
#line 3066
        if ((unsigned long )cv___1 == (unsigned long )(cv___1->c_display)->d_forecv) {
          {
#line 3066
          LGotoPos(flayer, flayer->l_x, flayer->l_y);
          }
        }
#line 3066
        flayer = oldflayer___2;
#line 3066
        l___2->l_cvlist = cvlist___2;
#line 3066
        cv___1->c_lnext = cvlnext___2;
#line 3066
        display = olddisplay___2;
      }
#line 2992
      cv___1 = cv___1->c_next;
    }
    while_break___10: /* CIL Label */ ;
    }
    __Cont___0: /* CIL Label */ 
#line 2986
    display = display->d_next;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 3080
  display = displays;
  {
#line 3080
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 3080
    if (! display) {
#line 3080
      goto while_break___15;
    }
#line 3082
    if (display->d_status == 1) {
#line 3083
      goto __Cont___1;
    } else
#line 3082
    if ((unsigned long )display->d_cvlist == (unsigned long )((struct canvas *)0)) {
#line 3083
      goto __Cont___1;
    } else
#line 3082
    if ((unsigned long )(display->d_cvlist)->c_next == (unsigned long )((struct canvas *)0)) {
#line 3083
      goto __Cont___1;
    }
    {
#line 3084
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 3084
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
    {
#line 3085
    olddisplay___3 = display;
#line 3085
    oldflayer___3 = flayer;
#line 3085
    l___3 = (display->d_forecv)->c_layer;
#line 3085
    cvlist___3 = l___3->l_cvlist;
#line 3085
    cvlnext___3 = (display->d_forecv)->c_lnext;
#line 3085
    flayer = l___3;
#line 3085
    l___3->l_cvlist = display->d_forecv;
#line 3085
    (display->d_forecv)->c_lnext = (struct canvas *)0;
#line 3085
    (*((flayer->l_layfn)->lf_LayRestore))();
#line 3085
    LGotoPos(flayer, flayer->l_x, flayer->l_y);
#line 3085
    flayer = oldflayer___3;
#line 3085
    l___3->l_cvlist = cvlist___3;
#line 3085
    (display->d_forecv)->c_lnext = cvlnext___3;
#line 3085
    display = olddisplay___3;
    }
    __Cont___1: /* CIL Label */ 
#line 3080
    display = display->d_next;
  }
  while_break___15: /* CIL Label */ ;
  }
#line 3087
  return;
}
}
#line 3089 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
static void logflush_fn(struct event *ev , char *data ) 
{ 
  struct win *p ;
  char *buf___0 ;
  int n ;
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 3098
  tmp = islogfile((char *)((void *)0));
  }
#line 3098
  if (! tmp) {
#line 3099
    return;
  }
  {
#line 3100
  logfflush((struct logfile *)((void *)0));
  }
#line 3101
  if (log_flush) {
#line 3101
    n = log_flush;
  } else {
#line 3101
    n = (logtstamp_after + 4) / 5;
  }
#line 3102
  if (n) {
    {
#line 3104
    SetTimeout(ev, n * 1000);
#line 3105
    evenq(ev);
    }
  }
#line 3107
  if (! logtstamp_on) {
#line 3108
    return;
  }
#line 3110
  p = windows;
  {
#line 3110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3110
    if (! p) {
#line 3110
      goto while_break;
    }
#line 3112
    if (! p->w_log) {
#line 3113
      goto __Cont;
    }
#line 3114
    p->w_logsilence += n;
#line 3115
    if (p->w_logsilence < logtstamp_after) {
#line 3116
      goto __Cont;
    }
#line 3117
    if (p->w_logsilence - n >= logtstamp_after) {
#line 3118
      goto __Cont;
    }
    {
#line 3119
    buf___0 = MakeWinMsg(logtstamp_string, p, '%');
#line 3120
    tmp___0 = strlen((char const   *)buf___0);
#line 3120
    logfwrite(p->w_log, buf___0, (int )tmp___0);
    }
    __Cont: /* CIL Label */ 
#line 3110
    p = p->w_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 3122
  return;
}
}
#line 3131 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
static char *ParseChar(char *p , char *cp ) 
{ 
  char *tmp ;

  {
#line 3135
  if ((int )*p == 0) {
#line 3136
    return ((char *)0);
  }
#line 3137
  if ((int )*p == 94) {
#line 3137
    if (*(p + 1)) {
#line 3139
      p ++;
#line 3139
      if ((int )*p == 63) {
#line 3140
        *cp = (char )'\177';
      } else
#line 3141
      if ((int )*p >= 64) {
#line 3142
        *cp = (char )((int )*p & 31);
      } else {
#line 3144
        return ((char *)0);
      }
#line 3145
      p ++;
    } else {
#line 3137
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3147
  if ((int )*p == 92) {
#line 3147
    p ++;
#line 3147
    if ((int )*p <= 55) {
#line 3147
      if ((int )*p >= 48) {
#line 3149
        *cp = (char)0;
        {
#line 3150
        while (1) {
          while_continue: /* CIL Label */ ;
#line 3151
          *cp = (char )(((int )*cp * 8 + (int )*p) - 48);
#line 3150
          p ++;
#line 3150
          if ((int )*p <= 55) {
#line 3150
            if (! ((int )*p >= 48)) {
#line 3150
              goto while_break;
            }
          } else {
#line 3150
            goto while_break;
          }
        }
        while_break: /* CIL Label */ ;
        }
      } else {
#line 3155
        tmp = p;
#line 3155
        p ++;
#line 3155
        *cp = *tmp;
      }
    } else {
#line 3155
      tmp = p;
#line 3155
      p ++;
#line 3155
      *cp = *tmp;
    }
  } else {
#line 3155
    tmp = p;
#line 3155
    p ++;
#line 3155
    *cp = *tmp;
  }
#line 3156
  return (p);
}
}
#line 3159 "/home/pronto/abs/test-suite/screen-4.0.2/screen.c"
static int ParseEscape(char *p ) 
{ 
  unsigned char buf___0[2] ;

  {
#line 3165
  if ((int )*p == 0) {
    {
#line 3166
    SetEscape((struct acluser *)0, -1, -1);
    }
  } else {
    {
#line 3169
    p = ParseChar(p, (char *)(buf___0));
    }
#line 3169
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 3171
      return (-1);
    } else {
      {
#line 3169
      p = ParseChar(p, (char *)(buf___0) + 1);
      }
#line 3169
      if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 3171
        return (-1);
      } else
#line 3169
      if (*p) {
#line 3171
        return (-1);
      }
    }
    {
#line 3172
    SetEscape((struct acluser *)0, (int )buf___0[0], (int )buf___0[1]);
    }
  }
#line 3174
  return (0);
}
}
