/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 42 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_34 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_34 __in6_u ;
};
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 29 "/usr/include/x86_64-linux-gnu/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 322 "/home/june/repo/benchmarks/collector/temp/spawn-fcgi-1.6.3/src/spawn-fcgi.c"
union __anonunion_64 {
   int __in ;
   int __i ;
};
#line 324 "/home/june/repo/benchmarks/collector/temp/spawn-fcgi-1.6.3/src/spawn-fcgi.c"
union __anonunion_65 {
   int __in ;
   int __i ;
};
#line 326 "/home/june/repo/benchmarks/collector/temp/spawn-fcgi-1.6.3/src/spawn-fcgi.c"
union __anonunion_66 {
   int __in ;
   int __i ;
};
#line 325 "/home/june/repo/benchmarks/collector/temp/spawn-fcgi-1.6.3/src/spawn-fcgi.c"
union __anonunion_67 {
   int __in ;
   int __i ;
};
#line 321 "/home/june/repo/benchmarks/collector/temp/spawn-fcgi-1.6.3/src/spawn-fcgi.c"
union __anonunion_68 {
   int __in ;
   int __i ;
};
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 284
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) putenv)(char *__string ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 473
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chown)(char const   *__file ,
                                                                                            __uid_t __owner ,
                                                                                            __gid_t __group ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 563
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execv)(char const   *__path ,
                                                                                              char * const  *__argv ) ;
#line 573
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *__path ,
                                                                                              char const   *__arg 
                                                                                              , ...) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 681
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getegid)(void) ;
#line 700
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 717
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 944 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chroot)(char const   *__path ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 111 "/usr/include/grp.h"
extern struct group *getgrnam(char const   *__name ) ;
#line 180
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgroups)(size_t __n ,
                                                                                __gid_t const   *__groups ) ;
#line 201
extern int initgroups(char const   *__user , __gid_t __group ) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 116
extern struct passwd *getpwnam(char const   *__name ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 377 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 58 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_pton)(int __af ,
                                                                                char const   * __restrict  __cp ,
                                                                                void * __restrict  __buf ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 63 "/home/june/repo/benchmarks/collector/temp/spawn-fcgi-1.6.3/src/spawn-fcgi.c"
static int issetugid(void) 
{ 
  __uid_t tmp ;
  __uid_t tmp___0 ;
  __gid_t tmp___1 ;
  __gid_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 64
  tmp = geteuid();
#line 64
  tmp___0 = getuid();
  }
#line 64
  if (tmp != tmp___0) {
#line 64
    tmp___3 = 1;
  } else {
    {
#line 64
    tmp___1 = getegid();
#line 64
    tmp___2 = getgid();
    }
#line 64
    if (tmp___1 != tmp___2) {
#line 64
      tmp___3 = 1;
    } else {
#line 64
      tmp___3 = 0;
    }
  }
#line 64
  return (tmp___3);
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/spawn-fcgi-1.6.3/src/spawn-fcgi.c"
static int bind_socket(char const   *addr , unsigned short port , char const   *unixsocket ,
                       uid_t uid , gid_t gid , int mode ) 
{ 
  int fcgi_fd ;
  int socket_type ;
  int val ;
  struct sockaddr_un fcgi_addr_un ;
  struct sockaddr_in fcgi_addr_in ;
  struct sockaddr_in6 fcgi_addr_in6 ;
  struct sockaddr *fcgi_addr ;
  socklen_t servlen ;
  size_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;

  {
#line 94
  if (unixsocket) {
    {
#line 95
    memset((void *)(& fcgi_addr_un), 0, sizeof(fcgi_addr_un));
#line 97
    fcgi_addr_un.sun_family = (sa_family_t )1;
#line 98
    strcpy((char */* __restrict  */)(fcgi_addr_un.sun_path), (char const   */* __restrict  */)unixsocket);
#line 101
    tmp = strlen((char const   *)(fcgi_addr_un.sun_path));
#line 101
    servlen = (socklen_t )((size_t )(((struct sockaddr_un *)0)->sun_path) + tmp);
#line 106
    socket_type = 1;
#line 107
    fcgi_addr = (struct sockaddr *)(& fcgi_addr_un);
#line 112
    fcgi_fd = socket(socket_type, 1, 0);
    }
#line 112
    if (-1 == fcgi_fd) {
      {
#line 113
      tmp___0 = __errno_location();
#line 113
      tmp___1 = strerror(*tmp___0);
#line 113
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spawn-fcgi: couldn\'t create socket: %s\n",
              tmp___1);
      }
#line 114
      return (-1);
    }
    {
#line 117
    tmp___2 = connect(fcgi_fd, (struct sockaddr  const  *)fcgi_addr, servlen);
    }
#line 117
    if (0 == tmp___2) {
      {
#line 118
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spawn-fcgi: socket is already in use, can\'t spawn\n");
#line 119
      close(fcgi_fd);
      }
#line 120
      return (-1);
    }
    {
#line 124
    tmp___6 = unlink(unixsocket);
    }
#line 124
    if (-1 == tmp___6) {
      {
#line 125
      tmp___3 = __errno_location();
      }
      {
#line 126
      if (*tmp___3 == 2) {
#line 126
        goto case_2;
      }
#line 128
      goto switch_default;
      case_2: /* CIL Label */ 
#line 127
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 129
      tmp___4 = __errno_location();
#line 129
      tmp___5 = strerror(*tmp___4);
#line 129
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spawn-fcgi: removing old socket failed: %s\n",
              tmp___5);
      }
#line 130
      return (-1);
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 134
    close(fcgi_fd);
    }
  } else {
    {
#line 136
    memset((void *)(& fcgi_addr_in), 0, sizeof(fcgi_addr_in));
#line 137
    fcgi_addr_in.sin_family = (sa_family_t )2;
#line 138
    fcgi_addr_in.sin_port = htons(port);
#line 140
    servlen = (socklen_t )sizeof(fcgi_addr_in);
#line 141
    socket_type = 2;
#line 142
    fcgi_addr = (struct sockaddr *)(& fcgi_addr_in);
#line 145
    memset((void *)(& fcgi_addr_in6), 0, sizeof(fcgi_addr_in6));
#line 146
    fcgi_addr_in6.sin6_family = (sa_family_t )10;
#line 147
    fcgi_addr_in6.sin6_port = fcgi_addr_in.sin_port;
    }
#line 150
    if ((unsigned long )addr == (unsigned long )((void *)0)) {
      {
#line 151
      fcgi_addr_in.sin_addr.s_addr = htonl((in_addr_t )0);
      }
    } else {
      {
#line 153
      tmp___8 = inet_pton(2, (char const   */* __restrict  */)addr, (void */* __restrict  */)(& fcgi_addr_in.sin_addr));
      }
#line 153
      if (! (1 == tmp___8)) {
        {
#line 156
        tmp___7 = inet_pton(10, (char const   */* __restrict  */)addr, (void */* __restrict  */)(& fcgi_addr_in6.sin6_addr));
        }
#line 156
        if (1 == tmp___7) {
#line 157
          servlen = (socklen_t )sizeof(fcgi_addr_in6);
#line 158
          socket_type = 10;
#line 159
          fcgi_addr = (struct sockaddr *)(& fcgi_addr_in6);
        } else {
          {
#line 162
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spawn-fcgi: \'%s\' is not a valid IP address\n",
                  addr);
          }
#line 163
          return (-1);
        }
      }
    }
  }
  {
#line 175
  fcgi_fd = socket(socket_type, 1, 0);
  }
#line 175
  if (-1 == fcgi_fd) {
    {
#line 176
    tmp___9 = __errno_location();
#line 176
    tmp___10 = strerror(*tmp___9);
#line 176
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spawn-fcgi: couldn\'t create socket: %s\n",
            tmp___10);
    }
#line 177
    return (-1);
  }
  {
#line 180
  val = 1;
#line 181
  tmp___13 = setsockopt(fcgi_fd, 1, 2, (void const   *)(& val), (socklen_t )sizeof(val));
  }
#line 181
  if (tmp___13 < 0) {
    {
#line 182
    tmp___11 = __errno_location();
#line 182
    tmp___12 = strerror(*tmp___11);
#line 182
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spawn-fcgi: couldn\'t set SO_REUSEADDR: %s\n",
            tmp___12);
    }
#line 183
    return (-1);
  }
  {
#line 186
  tmp___16 = bind(fcgi_fd, (struct sockaddr  const  *)fcgi_addr, servlen);
  }
#line 186
  if (-1 == tmp___16) {
    {
#line 187
    tmp___14 = __errno_location();
#line 187
    tmp___15 = strerror(*tmp___14);
#line 187
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spawn-fcgi: bind failed: %s\n",
            tmp___15);
    }
#line 188
    return (-1);
  }
#line 191
  if (unixsocket) {
#line 192
    if (0U != uid) {
#line 192
      goto _L;
    } else
#line 192
    if (0U != gid) {
      _L: /* CIL Label */ 
#line 193
      if (0U == uid) {
#line 193
        uid = (uid_t )-1;
      }
#line 194
      if (0U == gid) {
#line 194
        gid = (gid_t )-1;
      }
      {
#line 195
      tmp___19 = chown(unixsocket, uid, gid);
      }
#line 195
      if (-1 == tmp___19) {
        {
#line 196
        tmp___17 = __errno_location();
#line 196
        tmp___18 = strerror(*tmp___17);
#line 196
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spawn-fcgi: couldn\'t chown socket: %s\n",
                tmp___18);
#line 197
        close(fcgi_fd);
#line 198
        unlink(unixsocket);
        }
#line 199
        return (-1);
      }
    }
#line 203
    if (-1 != mode) {
      {
#line 203
      tmp___22 = chmod(unixsocket, (__mode_t )mode);
      }
#line 203
      if (-1 == tmp___22) {
        {
#line 204
        tmp___20 = __errno_location();
#line 204
        tmp___21 = strerror(*tmp___20);
#line 204
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spawn-fcgi: couldn\'t chmod socket: %s\n",
                tmp___21);
#line 205
        close(fcgi_fd);
#line 206
        unlink(unixsocket);
        }
#line 207
        return (-1);
      }
    }
  }
  {
#line 211
  tmp___25 = listen(fcgi_fd, 1024);
  }
#line 211
  if (-1 == tmp___25) {
    {
#line 212
    tmp___23 = __errno_location();
#line 212
    tmp___24 = strerror(*tmp___23);
#line 212
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spawn-fcgi: listen failed: %s\n",
            tmp___24);
    }
#line 213
    return (-1);
  }
#line 216
  return (fcgi_fd);
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/spawn-fcgi-1.6.3/src/spawn-fcgi.c"
static int fcgi_spawn_connection(char *appPath , char **appArgv , int fcgi_fd , int fork_count ,
                                 int child_count , int pid_fd , int nofork ) 
{ 
  int status ;
  int rc ;
  struct timeval tv ;
  pid_t child ;
  char cgi_childs[64] ;
  int max_fd ;
  int i ;
  int *tmp ;
  char *tmp___0 ;
  char *b ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  __pid_t tmp___8 ;
  char pidbuf[12] ;
  size_t tmp___9 ;
  union __anonunion_64 __constr_expr_0 ;
  union __anonunion_65 __constr_expr_1 ;
  union __anonunion_66 __constr_expr_2 ;
  union __anonunion_67 __constr_expr_3 ;
  union __anonunion_68 __constr_expr_4 ;
  int tmp___10 ;

  {
#line 220
  rc = 0;
#line 221
  tv.tv_sec = (__time_t )0;
#line 221
  tv.tv_usec = (__suseconds_t )100000;
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 225
    tmp___10 = fork_count;
#line 225
    fork_count --;
#line 225
    if (! (tmp___10 > 0)) {
#line 225
      goto while_break;
    }
#line 227
    if (! nofork) {
      {
#line 228
      child = fork();
      }
    } else {
#line 230
      child = 0;
    }
    {
#line 234
    if (child == 0) {
#line 234
      goto case_0;
    }
#line 289
    if (child == -1) {
#line 289
      goto case_neg_1;
    }
#line 293
    goto switch_default;
    case_0: /* CIL Label */ 
#line 236
    max_fd = 0;
#line 238
    i = 0;
#line 240
    if (child_count >= 0) {
      {
#line 241
      snprintf((char */* __restrict  */)(cgi_childs), sizeof(cgi_childs), (char const   */* __restrict  */)"PHP_FCGI_CHILDREN=%d",
               child_count);
#line 242
      putenv(cgi_childs);
      }
    }
#line 245
    if (fcgi_fd != 0) {
      {
#line 246
      close(0);
#line 247
      dup2(fcgi_fd, 0);
#line 248
      close(fcgi_fd);
      }
    }
#line 252
    if (! nofork) {
      {
#line 253
      setsid();
#line 255
      max_fd = open("/dev/null", 2);
      }
#line 256
      if (-1 != max_fd) {
#line 257
        if (max_fd != 1) {
          {
#line 257
          dup2(max_fd, 1);
          }
        }
#line 258
        if (max_fd != 2) {
          {
#line 258
          dup2(max_fd, 2);
          }
        }
#line 259
        if (max_fd != 1) {
#line 259
          if (max_fd != 2) {
            {
#line 259
            close(max_fd);
            }
          }
        }
      } else {
        {
#line 261
        tmp = __errno_location();
#line 261
        tmp___0 = strerror(*tmp);
#line 261
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spawn-fcgi: couldn\'t open and redirect stdout/stderr to \'/dev/null\': %s\n",
                tmp___0);
        }
      }
    }
#line 266
    i = 3;
    {
#line 266
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 266
      if (! (i < max_fd)) {
#line 266
        goto while_break___0;
      }
#line 267
      if (i != 0) {
        {
#line 267
        close(i);
        }
      }
#line 266
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 271
    if (appArgv) {
      {
#line 272
      execv((char const   *)*(appArgv + 0), (char * const  *)appArgv);
      }
    } else {
      {
#line 275
      tmp___1 = strlen((char const   *)appPath);
#line 275
      tmp___2 = malloc(((sizeof("exec ") - 1UL) + tmp___1) + 1UL);
#line 275
      b = (char *)tmp___2;
#line 276
      strcpy((char */* __restrict  */)b, (char const   */* __restrict  */)"exec ");
#line 277
      strcat((char */* __restrict  */)b, (char const   */* __restrict  */)appPath);
#line 280
      execl("/bin/sh", "sh", "-c", b, (char *)((void *)0));
      }
    }
    {
#line 284
    tmp___3 = __errno_location();
#line 284
    tmp___4 = strerror(*tmp___3);
#line 284
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spawn-fcgi: exec failed: %s\n",
            tmp___4);
#line 285
    tmp___5 = __errno_location();
#line 285
    exit(*tmp___5);
    }
#line 287
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    {
#line 291
    tmp___6 = __errno_location();
#line 291
    tmp___7 = strerror(*tmp___6);
#line 291
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spawn-fcgi: fork failed: %s\n",
            tmp___7);
    }
#line 292
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 297
    select(0, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)((void *)0),
           (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
#line 299
    tmp___8 = waitpid(child, & status, 1);
    }
    {
#line 300
    if (tmp___8 == 0) {
#line 300
      goto case_0___0;
    }
#line 318
    if (tmp___8 == -1) {
#line 318
      goto case_neg_1___0;
    }
#line 320
    goto switch_default___0;
    case_0___0: /* CIL Label */ 
    {
#line 301
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"spawn-fcgi: child spawned successfully: PID: %d\n",
            child);
    }
#line 304
    if (pid_fd != -1) {
      {
#line 308
      snprintf((char */* __restrict  */)(pidbuf), sizeof(pidbuf) - 1UL, (char const   */* __restrict  */)"%d",
               child);
#line 310
      tmp___9 = strlen((char const   *)(pidbuf));
#line 310
      write(pid_fd, (void const   *)(pidbuf), tmp___9);
      }
#line 312
      if (fork_count != 0) {
        {
#line 313
        write(pid_fd, (void const   *)"\n", (size_t )1);
        }
      }
    }
#line 317
    goto switch_break___0;
    case_neg_1___0: /* CIL Label */ 
#line 319
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 321
    __constr_expr_4.__in = status;
#line 321
    if ((__constr_expr_4.__i & 127) == 0) {
      {
#line 322
      __constr_expr_0.__in = status;
#line 322
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spawn-fcgi: child exited with: %d\n",
              (__constr_expr_0.__i & 65280) >> 8);
#line 324
      __constr_expr_1.__in = status;
#line 324
      rc = (__constr_expr_1.__i & 65280) >> 8;
      }
    } else {
#line 325
      __constr_expr_3.__in = status;
#line 325
      if ((int )((signed char )((__constr_expr_3.__i & 127) + 1)) >> 1 > 0) {
        {
#line 326
        __constr_expr_2.__in = status;
#line 326
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spawn-fcgi: child signaled: %d\n",
                __constr_expr_2.__i & 127);
#line 328
        rc = 1;
        }
      } else {
        {
#line 330
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spawn-fcgi: child died somehow: exit status = %d\n",
                status);
#line 332
        rc = status;
        }
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 336
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 339
  close(pid_fd);
#line 341
  close(fcgi_fd);
  }
#line 343
  return (rc);
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/spawn-fcgi-1.6.3/src/spawn-fcgi.c"
static int find_user_group(char const   *user , char const   *group , uid_t *uid ,
                           gid_t *gid , char const   **username ) 
{ 
  uid_t my_uid ;
  gid_t my_gid ;
  struct passwd *my_pwd ;
  struct group *my_grp ;
  char *endptr ;
  long tmp ;
  long tmp___0 ;

  {
#line 347
  my_uid = (uid_t )0;
#line 348
  my_gid = (gid_t )0;
#line 349
  my_pwd = (struct passwd *)((void *)0);
#line 350
  my_grp = (struct group *)((void *)0);
#line 351
  endptr = (char *)((void *)0);
#line 352
  *uid = (uid_t )0;
#line 352
  *gid = (gid_t )0;
#line 353
  if (username) {
#line 353
    *username = (char const   *)((void *)0);
  }
#line 355
  if (user) {
    {
#line 356
    tmp = strtol((char const   */* __restrict  */)user, (char **/* __restrict  */)(& endptr),
                 10);
#line 356
    my_uid = (uid_t )tmp;
    }
#line 358
    if (my_uid <= 0U) {
#line 358
      goto _L;
    } else
#line 358
    if (*endptr) {
      _L: /* CIL Label */ 
      {
#line 359
      my_pwd = getpwnam(user);
      }
#line 359
      if ((unsigned long )((void *)0) == (unsigned long )my_pwd) {
        {
#line 360
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spawn-fcgi: can\'t find user name %s\n",
                user);
        }
#line 361
        return (-1);
      }
#line 363
      my_uid = my_pwd->pw_uid;
#line 365
      if (my_uid == 0U) {
        {
#line 366
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spawn-fcgi: I will not set uid to 0\n");
        }
#line 367
        return (-1);
      }
#line 370
      if (username) {
#line 370
        *username = user;
      }
    } else {
      {
#line 372
      my_pwd = getpwuid(my_uid);
      }
#line 373
      if (username) {
#line 373
        if (my_pwd) {
#line 373
          *username = (char const   *)my_pwd->pw_name;
        }
      }
    }
  }
#line 377
  if (group) {
    {
#line 378
    tmp___0 = strtol((char const   */* __restrict  */)group, (char **/* __restrict  */)(& endptr),
                     10);
#line 378
    my_gid = (gid_t )tmp___0;
    }
#line 380
    if (my_gid <= 0U) {
#line 380
      goto _L___0;
    } else
#line 380
    if (*endptr) {
      _L___0: /* CIL Label */ 
      {
#line 381
      my_grp = getgrnam(group);
      }
#line 381
      if ((unsigned long )((void *)0) == (unsigned long )my_grp) {
        {
#line 382
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spawn-fcgi: can\'t find group name %s\n",
                group);
        }
#line 383
        return (-1);
      }
#line 385
      my_gid = my_grp->gr_gid;
#line 387
      if (my_gid == 0U) {
        {
#line 388
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spawn-fcgi: I will not set gid to 0\n");
        }
#line 389
        return (-1);
      }
    }
  } else
#line 392
  if (my_pwd) {
#line 393
    my_gid = my_pwd->pw_gid;
#line 395
    if (my_gid == 0U) {
      {
#line 396
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spawn-fcgi: I will not set gid to 0\n");
      }
#line 397
      return (-1);
    }
  }
#line 401
  *uid = my_uid;
#line 402
  *gid = my_gid;
#line 403
  return (0);
}
}
#line 406 "/home/june/repo/benchmarks/collector/temp/spawn-fcgi-1.6.3/src/spawn-fcgi.c"
static void show_version(void) 
{ 


  {
  {
#line 407
  write(1, (void const   *)"spawn-fcgi v1.6.3 (ipv6) - spawns FastCGI processes\nBuild-Date: Mar 10 2016 14:21:10\n",
        sizeof("spawn-fcgi v1.6.3 (ipv6) - spawns FastCGI processes\nBuild-Date: Mar 10 2016 14:21:10\n") - 1UL);
  }
#line 411
  return;
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/spawn-fcgi-1.6.3/src/spawn-fcgi.c"
static void show_help(void) 
{ 


  {
  {
#line 414
  write(1, (void const   *)"Usage: spawn-fcgi [options] [-- <fcgiapp> [fcgi app arguments]]\n\nspawn-fcgi v1.6.3 (ipv6) - spawns FastCGI processes\n\nOptions:\n -f <path>      filename of the fcgi-application (deprecated; ignored if\n                <fcgiapp> is given; needs /bin/sh)\n -d <directory> chdir to directory before spawning\n -a <address>   bind to IPv4/IPv6 address (defaults to 0.0.0.0)\n -p <port>      bind to TCP-port\n -s <path>      bind to Unix domain socket\n -M <mode>      change Unix domain socket mode\n -C <children>  (PHP only) numbers of childs to spawn (default: not setting\n                the PHP_FCGI_CHILDREN environment variable - PHP defaults to 0)\n -F <children>  number of children to fork (default 1)\n -P <path>      name of PID-file for spawned process (ignored in no-fork mode)\n -n             no fork (for daemontools)\n -v             show version\n -?, -h         show this help\n(root only)\n -c <directory> chroot to directory\n -S             create socket before chroot() (default is to create the socket\n                in the chroot)\n -u <user>      change to user-id\n -g <group>     change to group-id (default: primary group of user if -u\n                is given)\n -U <user>      change Unix domain socket owner to user-id\n -G <group>     change Unix domain socket group to group-id\n",
        sizeof("Usage: spawn-fcgi [options] [-- <fcgiapp> [fcgi app arguments]]\n\nspawn-fcgi v1.6.3 (ipv6) - spawns FastCGI processes\n\nOptions:\n -f <path>      filename of the fcgi-application (deprecated; ignored if\n                <fcgiapp> is given; needs /bin/sh)\n -d <directory> chdir to directory before spawning\n -a <address>   bind to IPv4/IPv6 address (defaults to 0.0.0.0)\n -p <port>      bind to TCP-port\n -s <path>      bind to Unix domain socket\n -M <mode>      change Unix domain socket mode\n -C <children>  (PHP only) numbers of childs to spawn (default: not setting\n                the PHP_FCGI_CHILDREN environment variable - PHP defaults to 0)\n -F <children>  number of children to fork (default 1)\n -P <path>      name of PID-file for spawned process (ignored in no-fork mode)\n -n             no fork (for daemontools)\n -v             show version\n -?, -h         show this help\n(root only)\n -c <directory> chroot to directory\n -S             create socket before chroot() (default is to create the socket\n                in the chroot)\n -u <user>      change to user-id\n -g <group>     change to group-id (default: primary group of user if -u\n                is given)\n -U <user>      change Unix domain socket owner to user-id\n -G <group>     change Unix domain socket group to group-id\n") - 1UL);
  }
#line 444
  return;
}
}
#line 447 "/home/june/repo/benchmarks/collector/temp/spawn-fcgi-1.6.3/src/spawn-fcgi.c"
int main(int argc , char **argv ) 
{ 
  char *fcgi_app ;
  char *changeroot ;
  char *username ;
  char *groupname ;
  char *unixsocket ;
  char *pid_file ;
  char *sockusername ;
  char *sockgroupname ;
  char *fcgi_dir ;
  char *addr ;
  char **fcgi_app_argv ;
  char *endptr ;
  unsigned short port ;
  int sockmode ;
  int child_count ;
  int fork_count ;
  int i_am_root ;
  int o ;
  int pid_fd ;
  int nofork ;
  int sockbeforechroot ;
  struct sockaddr_un un ;
  int fcgi_fd ;
  __uid_t tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  struct stat st ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  uid_t uid ;
  uid_t sockuid ;
  gid_t gid ;
  gid_t sockgid ;
  char const   *real_username ;
  int tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;

  {
#line 448
  fcgi_app = (char *)((void *)0);
#line 448
  changeroot = (char *)((void *)0);
#line 448
  username = (char *)((void *)0);
#line 448
  groupname = (char *)((void *)0);
#line 448
  unixsocket = (char *)((void *)0);
#line 448
  pid_file = (char *)((void *)0);
#line 448
  sockusername = (char *)((void *)0);
#line 448
  sockgroupname = (char *)((void *)0);
#line 448
  fcgi_dir = (char *)((void *)0);
#line 448
  addr = (char *)((void *)0);
#line 452
  fcgi_app_argv = (char **)((void *)0);
#line 453
  endptr = (char *)((void *)0);
#line 454
  port = (unsigned short)0;
#line 455
  sockmode = -1;
#line 456
  child_count = -1;
#line 457
  fork_count = 1;
#line 459
  pid_fd = -1;
#line 460
  nofork = 0;
#line 461
  sockbeforechroot = 0;
#line 463
  fcgi_fd = -1;
#line 465
  if (argc < 2) {
    {
#line 466
    show_help();
    }
#line 467
    return (-1);
  }
  {
#line 470
  tmp = getuid();
#line 470
  i_am_root = tmp == 0U;
  }
  {
#line 472
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 472
    o = getopt(argc, (char * const  *)argv, "c:d:f:g:?hna:p:u:vC:F:s:P:U:G:M:S");
    }
#line 472
    if (! (-1 != o)) {
#line 472
      goto while_break;
    }
    {
#line 474
    if (o == 102) {
#line 474
      goto case_102;
    }
#line 475
    if (o == 100) {
#line 475
      goto case_100;
    }
#line 476
    if (o == 97) {
#line 476
      goto case_97;
    }
#line 477
    if (o == 112) {
#line 477
      goto case_112;
    }
#line 483
    if (o == 67) {
#line 483
      goto case_67;
    }
#line 484
    if (o == 70) {
#line 484
      goto case_70;
    }
#line 485
    if (o == 115) {
#line 485
      goto case_115;
    }
#line 486
    if (o == 99) {
#line 486
      goto case_99;
    }
#line 487
    if (o == 117) {
#line 487
      goto case_117;
    }
#line 488
    if (o == 103) {
#line 488
      goto case_103;
    }
#line 489
    if (o == 85) {
#line 489
      goto case_85;
    }
#line 490
    if (o == 71) {
#line 490
      goto case_71;
    }
#line 491
    if (o == 83) {
#line 491
      goto case_83;
    }
#line 492
    if (o == 77) {
#line 492
      goto case_77;
    }
#line 493
    if (o == 110) {
#line 493
      goto case_110;
    }
#line 494
    if (o == 80) {
#line 494
      goto case_80;
    }
#line 495
    if (o == 118) {
#line 495
      goto case_118;
    }
#line 497
    if (o == 104) {
#line 497
      goto case_104;
    }
#line 497
    if (o == 63) {
#line 497
      goto case_104;
    }
#line 498
    goto switch_default;
    case_102: /* CIL Label */ 
#line 474
    fcgi_app = optarg;
#line 474
    goto switch_break;
    case_100: /* CIL Label */ 
#line 475
    fcgi_dir = optarg;
#line 475
    goto switch_break;
    case_97: /* CIL Label */ 
#line 476
    addr = optarg;
#line 476
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 477
    tmp___0 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& endptr),
                     10);
#line 477
    port = (unsigned short )tmp___0;
    }
#line 478
    if (*endptr) {
      {
#line 479
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spawn-fcgi: invalid port: %u\n",
              (unsigned int )port);
      }
#line 480
      return (-1);
    }
#line 482
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 483
    tmp___1 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                     10);
#line 483
    child_count = (int )tmp___1;
    }
#line 483
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 484
    tmp___2 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                     10);
#line 484
    fork_count = (int )tmp___2;
    }
#line 484
    goto switch_break;
    case_115: /* CIL Label */ 
#line 485
    unixsocket = optarg;
#line 485
    goto switch_break;
    case_99: /* CIL Label */ 
#line 486
    if (i_am_root) {
#line 486
      changeroot = optarg;
    }
#line 486
    goto switch_break;
    case_117: /* CIL Label */ 
#line 487
    if (i_am_root) {
#line 487
      username = optarg;
    }
#line 487
    goto switch_break;
    case_103: /* CIL Label */ 
#line 488
    if (i_am_root) {
#line 488
      groupname = optarg;
    }
#line 488
    goto switch_break;
    case_85: /* CIL Label */ 
#line 489
    if (i_am_root) {
#line 489
      sockusername = optarg;
    }
#line 489
    goto switch_break;
    case_71: /* CIL Label */ 
#line 490
    if (i_am_root) {
#line 490
      sockgroupname = optarg;
    }
#line 490
    goto switch_break;
    case_83: /* CIL Label */ 
#line 491
    if (i_am_root) {
#line 491
      sockbeforechroot = 1;
    }
#line 491
    goto switch_break;
    case_77: /* CIL Label */ 
    {
#line 492
    tmp___3 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                     0);
#line 492
    sockmode = (int )tmp___3;
    }
#line 492
    goto switch_break;
    case_110: /* CIL Label */ 
#line 493
    nofork = 1;
#line 493
    goto switch_break;
    case_80: /* CIL Label */ 
#line 494
    pid_file = optarg;
#line 494
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 495
    show_version();
    }
#line 495
    return (0);
    case_104: /* CIL Label */ 
    case_63: /* CIL Label */ 
    {
#line 497
    show_help();
    }
#line 497
    return (0);
    switch_default: /* CIL Label */ 
    {
#line 499
    show_help();
    }
#line 500
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 504
  if (optind < argc) {
#line 505
    fcgi_app_argv = argv + optind;
  }
#line 508
  if ((unsigned long )((void *)0) == (unsigned long )fcgi_app) {
#line 508
    if ((unsigned long )((void *)0) == (unsigned long )fcgi_app_argv) {
      {
#line 509
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spawn-fcgi: no FastCGI application given\n");
      }
#line 510
      return (-1);
    }
  }
#line 513
  if (0 == (int )port) {
#line 513
    if ((unsigned long )((void *)0) == (unsigned long )unixsocket) {
      {
#line 514
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spawn-fcgi: no socket given (use either -p or -s)\n");
      }
#line 515
      return (-1);
    } else {
#line 513
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 516
  if (0 != (int )port) {
#line 516
    if ((unsigned long )((void *)0) != (unsigned long )unixsocket) {
      {
#line 517
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spawn-fcgi: either a Unix domain socket or a TCP-port, but not both\n");
      }
#line 518
      return (-1);
    }
  }
#line 521
  if (unixsocket) {
    {
#line 521
    tmp___4 = strlen((char const   *)unixsocket);
    }
#line 521
    if (tmp___4 > sizeof(un.sun_path) - 1UL) {
      {
#line 522
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spawn-fcgi: path of the Unix domain socket is too long\n");
      }
#line 523
      return (-1);
    }
  }
#line 527
  if (! i_am_root) {
    {
#line 527
    tmp___5 = issetugid();
    }
#line 527
    if (tmp___5) {
      {
#line 528
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spawn-fcgi: Are you nuts? Don\'t apply a SUID bit to this binary\n");
      }
#line 529
      return (-1);
    }
  }
#line 532
  if (nofork) {
#line 532
    pid_file = (char *)((void *)0);
  }
#line 534
  if (pid_file) {
    {
#line 534
    pid_fd = open((char const   *)pid_file, 705, (384 | (256 >> 3)) | ((256 >> 3) >> 3));
    }
#line 534
    if (-1 == pid_fd) {
      {
#line 537
      tmp___8 = __errno_location();
      }
#line 537
      if (*tmp___8 != 17) {
        {
#line 538
        tmp___6 = __errno_location();
#line 538
        tmp___7 = strerror(*tmp___6);
#line 538
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spawn-fcgi: opening PID-file \'%s\' failed: %s\n",
                pid_file, tmp___7);
        }
#line 540
        return (-1);
      }
      {
#line 545
      tmp___11 = stat((char const   */* __restrict  */)pid_file, (struct stat */* __restrict  */)(& st));
      }
#line 545
      if (0 != tmp___11) {
        {
#line 546
        tmp___9 = __errno_location();
#line 546
        tmp___10 = strerror(*tmp___9);
#line 546
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spawn-fcgi: stating PID-file \'%s\' failed: %s\n",
                pid_file, tmp___10);
        }
#line 548
        return (-1);
      }
#line 553
      if (! ((st.st_mode & 61440U) == 32768U)) {
        {
#line 554
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spawn-fcgi: PID-file exists and isn\'t regular file: \'%s\'\n",
                pid_file);
        }
#line 556
        return (-1);
      }
      {
#line 559
      pid_fd = open((char const   *)pid_file, 577, (384 | (256 >> 3)) | ((256 >> 3) >> 3));
      }
#line 559
      if (-1 == pid_fd) {
        {
#line 560
        tmp___12 = __errno_location();
#line 560
        tmp___13 = strerror(*tmp___12);
#line 560
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spawn-fcgi: opening PID-file \'%s\' failed: %s\n",
                pid_file, tmp___13);
        }
#line 562
        return (-1);
      }
    }
  }
#line 566
  if (i_am_root) {
    {
#line 571
    tmp___14 = find_user_group((char const   *)username, (char const   *)groupname,
                               & uid, & gid, & real_username);
    }
#line 571
    if (-1 == tmp___14) {
#line 572
      return (-1);
    }
    {
#line 574
    tmp___15 = find_user_group((char const   *)sockusername, (char const   *)sockgroupname,
                               & sockuid, & sockgid, (char const   **)((void *)0));
    }
#line 574
    if (-1 == tmp___15) {
#line 575
      return (-1);
    }
#line 577
    if (uid != 0U) {
#line 577
      if (gid == 0U) {
        {
#line 578
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spawn-fcgi: WARNING: couldn\'t find the user for uid %i and no group was specified, so only the user privileges will be dropped\n",
                (int )uid);
        }
      }
    }
#line 581
    if (0U == sockuid) {
#line 581
      sockuid = uid;
    }
#line 582
    if (0U == sockgid) {
#line 582
      sockgid = gid;
    }
#line 584
    if (sockbeforechroot) {
      {
#line 584
      fcgi_fd = bind_socket((char const   *)addr, port, (char const   *)unixsocket,
                            sockuid, sockgid, sockmode);
      }
#line 584
      if (-1 == fcgi_fd) {
#line 585
        return (-1);
      }
    }
#line 590
    if (gid != 0U) {
      {
#line 591
      setgid(gid);
#line 592
      setgroups((size_t )0, (__gid_t const   *)((void *)0));
      }
#line 593
      if (real_username) {
        {
#line 594
        initgroups(real_username, gid);
        }
      }
    }
#line 598
    if (changeroot) {
      {
#line 599
      tmp___18 = chroot((char const   *)changeroot);
      }
#line 599
      if (-1 == tmp___18) {
        {
#line 600
        tmp___16 = __errno_location();
#line 600
        tmp___17 = strerror(*tmp___16);
#line 600
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spawn-fcgi: chroot(\'%s\') failed: %s\n",
                changeroot, tmp___17);
        }
#line 601
        return (-1);
      }
      {
#line 603
      tmp___21 = chdir("/");
      }
#line 603
      if (-1 == tmp___21) {
        {
#line 604
        tmp___19 = __errno_location();
#line 604
        tmp___20 = strerror(*tmp___19);
#line 604
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spawn-fcgi: chdir(\'/\') failed: %s\n",
                tmp___20);
        }
#line 605
        return (-1);
      }
    }
#line 609
    if (! sockbeforechroot) {
      {
#line 609
      fcgi_fd = bind_socket((char const   *)addr, port, (char const   *)unixsocket,
                            sockuid, sockgid, sockmode);
      }
#line 609
      if (-1 == fcgi_fd) {
#line 610
        return (-1);
      }
    }
#line 613
    if (uid != 0U) {
      {
#line 614
      setuid(uid);
      }
    }
  } else {
    {
#line 617
    fcgi_fd = bind_socket((char const   *)addr, port, (char const   *)unixsocket,
                          (uid_t )0, (gid_t )0, sockmode);
    }
#line 617
    if (-1 == fcgi_fd) {
#line 618
      return (-1);
    }
  }
#line 621
  if (fcgi_dir) {
    {
#line 621
    tmp___24 = chdir((char const   *)fcgi_dir);
    }
#line 621
    if (-1 == tmp___24) {
      {
#line 622
      tmp___22 = __errno_location();
#line 622
      tmp___23 = strerror(*tmp___22);
#line 622
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spawn-fcgi: chdir(\'%s\') failed: %s\n",
              fcgi_dir, tmp___23);
      }
#line 623
      return (-1);
    }
  }
  {
#line 626
  tmp___25 = fcgi_spawn_connection(fcgi_app, fcgi_app_argv, fcgi_fd, fork_count, child_count,
                                   pid_fd, nofork);
  }
#line 626
  return (tmp___25);
}
}
