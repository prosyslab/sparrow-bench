/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 108 "../include/Garmin.h"
struct DATUM {
   char *name ;
   short ellipsoid ;
   short dx ;
   short dy ;
   short dz ;
};
#line 117 "../include/Garmin.h"
struct ELLIPSOID {
   char *name ;
   double a ;
   double invf ;
};
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 30 "include/Prefs.h"
enum FORMAT {
    DMS = 0,
    DMM = 1,
    DDD = 2,
    UTM = 3,
    BNG = 4,
    ITM = 5,
    KKJ = 6,
    SEG = 7,
    GKK = 8
} ;
#line 33 "include/Prefs.h"
struct PREFS {
   short datum ;
   enum FORMAT format ;
   double offset ;
   char Device[255] ;
   char feet ;
   char model ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int int32_t;
#line 201 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short u_int16_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 6 "../include/Garmin.h"
typedef unsigned char BYTE;
#line 32
enum PROTOCOL {
    NONE = 0,
    GARMIN = 1,
    NMEA = 2
} ;
#line 139
enum FILE_FORMAT {
    TSV = 3333,
    MAYKO = 3334,
    MAYKO2 = 3335
} ;
#line 6 "../include/protocols.h"
typedef unsigned char uint8;
#line 16 "../include/protocols.h"
struct __anonstruct_position_type_28 {
   int32_t lat ;
   int32_t lon ;
};
#line 16 "../include/protocols.h"
typedef struct __anonstruct_position_type_28 position_type;
#line 22 "../include/protocols.h"
typedef u_int16_t symbol_type;
#line 346 "../include/protocols.h"
struct __anonstruct_D100_Wpt_Type_31 {
   char ident[6] ;
   position_type posn  __attribute__((__packed__)) ;
   u_int32_t unused  __attribute__((__packed__)) ;
   char cmnt[40]  __attribute__((__packed__)) ;
};
#line 346 "../include/protocols.h"
typedef struct __anonstruct_D100_Wpt_Type_31 D100_Wpt_Type;
#line 354 "../include/protocols.h"
struct __anonstruct_D101_Wpt_Type_32 {
   char ident[6] ;
   position_type posn  __attribute__((__packed__)) ;
   u_int32_t unused  __attribute__((__packed__)) ;
   char cmnt[40]  __attribute__((__packed__)) ;
   float dst  __attribute__((__packed__)) ;
   uint8 smbl  __attribute__((__packed__)) ;
};
#line 354 "../include/protocols.h"
typedef struct __anonstruct_D101_Wpt_Type_32 D101_Wpt_Type;
#line 370 "../include/protocols.h"
struct __anonstruct_D102_Wpt_Type_33 {
   char ident[6] ;
   position_type posn  __attribute__((__packed__)) ;
   u_int32_t unused  __attribute__((__packed__)) ;
   char cmnt[40]  __attribute__((__packed__)) ;
   float dst  __attribute__((__packed__)) ;
   symbol_type smbl  __attribute__((__packed__)) ;
};
#line 370 "../include/protocols.h"
typedef struct __anonstruct_D102_Wpt_Type_33 D102_Wpt_Type;
#line 384 "../include/protocols.h"
struct __anonstruct_D103_Wpt_Type_34 {
   char ident[6] ;
   position_type posn  __attribute__((__packed__)) ;
   u_int32_t unused  __attribute__((__packed__)) ;
   char cmnt[40]  __attribute__((__packed__)) ;
   uint8 smbl  __attribute__((__packed__)) ;
   uint8 dspl  __attribute__((__packed__)) ;
};
#line 384 "../include/protocols.h"
typedef struct __anonstruct_D103_Wpt_Type_34 D103_Wpt_Type;
#line 423 "../include/protocols.h"
struct __anonstruct_D104_Wpt_Type_37 {
   char ident[6] ;
   position_type posn  __attribute__((__packed__)) ;
   u_int32_t unused  __attribute__((__packed__)) ;
   char cmnt[40]  __attribute__((__packed__)) ;
   float dst  __attribute__((__packed__)) ;
   symbol_type smbl  __attribute__((__packed__)) ;
   uint8 dspl  __attribute__((__packed__)) ;
};
#line 423 "../include/protocols.h"
typedef struct __anonstruct_D104_Wpt_Type_37 D104_Wpt_Type;
#line 446 "../include/protocols.h"
struct __anonstruct_D105_Wpt_Type_39 {
   position_type posn ;
   symbol_type smbl  __attribute__((__packed__)) ;
   char ident[1]  __attribute__((__packed__)) ;
};
#line 446 "../include/protocols.h"
typedef struct __anonstruct_D105_Wpt_Type_39 D105_Wpt_Type;
#line 453 "../include/protocols.h"
struct __anonstruct_D106_Wpt_Type_40 {
   uint8 wpt_class ;
   uint8 subclass[13]  __attribute__((__packed__)) ;
   position_type posn  __attribute__((__packed__)) ;
   symbol_type smbl  __attribute__((__packed__)) ;
   char ident[1]  __attribute__((__packed__)) ;
};
#line 453 "../include/protocols.h"
typedef struct __anonstruct_D106_Wpt_Type_40 D106_Wpt_Type;
#line 486 "../include/protocols.h"
struct __anonstruct_D107_Wpt_Type_41 {
   char ident[6] ;
   position_type posn  __attribute__((__packed__)) ;
   u_int32_t unused  __attribute__((__packed__)) ;
   char cmnt[40]  __attribute__((__packed__)) ;
   uint8 smbl  __attribute__((__packed__)) ;
   uint8 dspl  __attribute__((__packed__)) ;
   float dst  __attribute__((__packed__)) ;
   uint8 color  __attribute__((__packed__)) ;
};
#line 486 "../include/protocols.h"
typedef struct __anonstruct_D107_Wpt_Type_41 D107_Wpt_Type;
#line 514 "../include/protocols.h"
struct __anonstruct_D108_Wpt_Type_43 {
   uint8 wpt_class ;
   uint8 color  __attribute__((__packed__)) ;
   uint8 dspl  __attribute__((__packed__)) ;
   uint8 attr  __attribute__((__packed__)) ;
   symbol_type smbl  __attribute__((__packed__)) ;
   uint8 subclass[18]  __attribute__((__packed__)) ;
   position_type posn  __attribute__((__packed__)) ;
   float alt  __attribute__((__packed__)) ;
   float dpth  __attribute__((__packed__)) ;
   float dist  __attribute__((__packed__)) ;
   char state[2]  __attribute__((__packed__)) ;
   char cc[2]  __attribute__((__packed__)) ;
   char ident[1]  __attribute__((__packed__)) ;
};
#line 514 "../include/protocols.h"
typedef struct __anonstruct_D108_Wpt_Type_43 D108_Wpt_Type;
#line 606 "../include/protocols.h"
struct __anonstruct_D109_Wpt_Type_46 {
   uint8 dtyp ;
   uint8 wpt_class  __attribute__((__packed__)) ;
   uint8 dspl_color  __attribute__((__packed__)) ;
   uint8 attr  __attribute__((__packed__)) ;
   symbol_type smbl  __attribute__((__packed__)) ;
   uint8 subclass[18]  __attribute__((__packed__)) ;
   position_type posn  __attribute__((__packed__)) ;
   float alt  __attribute__((__packed__)) ;
   float dpth  __attribute__((__packed__)) ;
   float dist  __attribute__((__packed__)) ;
   char state[2]  __attribute__((__packed__)) ;
   char cc[2]  __attribute__((__packed__)) ;
   u_int32_t ete  __attribute__((__packed__)) ;
   char ident[1]  __attribute__((__packed__)) ;
};
#line 606 "../include/protocols.h"
typedef struct __anonstruct_D109_Wpt_Type_46 D109_Wpt_Type;
#line 645 "../include/protocols.h"
struct __anonstruct_D110_Wpt_Type_47 {
   uint8 dtyp ;
   uint8 wpt_class  __attribute__((__packed__)) ;
   uint8 dspl_color  __attribute__((__packed__)) ;
   uint8 attr  __attribute__((__packed__)) ;
   symbol_type smbl  __attribute__((__packed__)) ;
   uint8 subclass[18]  __attribute__((__packed__)) ;
   position_type posn  __attribute__((__packed__)) ;
   float alt  __attribute__((__packed__)) ;
   float dpth  __attribute__((__packed__)) ;
   float dist  __attribute__((__packed__)) ;
   char state[2]  __attribute__((__packed__)) ;
   char cc[2]  __attribute__((__packed__)) ;
   u_int32_t ete  __attribute__((__packed__)) ;
   float temp  __attribute__((__packed__)) ;
   u_int32_t time  __attribute__((__packed__)) ;
   u_int16_t wpt_cat  __attribute__((__packed__)) ;
   char ident[1]  __attribute__((__packed__)) ;
};
#line 645 "../include/protocols.h"
typedef struct __anonstruct_D110_Wpt_Type_47 D110_Wpt_Type;
#line 1026 "../include/protocols.h"
struct __anonstruct_D300_Trk_Point_Type_67 {
   position_type posn ;
   u_int32_t time  __attribute__((__packed__)) ;
   uint8 new_trk  __attribute__((__packed__)) ;
};
#line 1026 "../include/protocols.h"
typedef struct __anonstruct_D300_Trk_Point_Type_67 D300_Trk_Point_Type;
#line 1038 "../include/protocols.h"
struct __anonstruct_D301_Trk_Point_Type_68 {
   position_type posn ;
   u_int32_t time  __attribute__((__packed__)) ;
   float alt  __attribute__((__packed__)) ;
   float dpth  __attribute__((__packed__)) ;
   uint8 new_trk  __attribute__((__packed__)) ;
};
#line 1038 "../include/protocols.h"
typedef struct __anonstruct_D301_Trk_Point_Type_68 D301_Trk_Point_Type;
#line 1056 "../include/protocols.h"
struct __anonstruct_D302_Trk_Point_Type_69 {
   position_type posn ;
   u_int32_t time  __attribute__((__packed__)) ;
   float alt  __attribute__((__packed__)) ;
   float dpth  __attribute__((__packed__)) ;
   float temp  __attribute__((__packed__)) ;
   uint8 new_trk  __attribute__((__packed__)) ;
};
#line 1056 "../include/protocols.h"
typedef struct __anonstruct_D302_Trk_Point_Type_69 D302_Trk_Point_Type;
#line 73 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/sendgpsinfo.c"
struct __anonstruct_column_86 {
   int count ;
   int type ;
   int name ;
   int comment ;
   int date ;
   int altitude ;
   int position ;
};
#line 496 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/sendgpsinfo.c"
struct __anonstruct_has_93 {
   unsigned int altitude : 1 ;
   unsigned int seconds : 1 ;
   unsigned int name : 1 ;
   unsigned int comment : 1 ;
};
#line 496 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/sendgpsinfo.c"
struct __anonstruct_pkt_92 {
   char type ;
   char *comment ;
   char *name ;
   long seconds ;
   double latitude ;
   double longitude ;
   double altitude ;
   struct __anonstruct_has_93 has ;
};
#line 948 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/sendgpsinfo.c"
struct __anonstruct_has_100 {
   unsigned int altitude : 1 ;
   unsigned int seconds : 1 ;
   unsigned int name : 1 ;
   unsigned int comment : 1 ;
};
#line 948 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/sendgpsinfo.c"
struct __anonstruct_pkt_99 {
   char type ;
   char *comment ;
   char *name ;
   long seconds ;
   double latitude ;
   double longitude ;
   double altitude ;
   struct __anonstruct_has_100 has ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 195 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef short int16_t;
#line 989 "../include/protocols.h"
struct __anonstruct_D201_Rte_Hdr_Type_63 {
   uint8 nmbr ;
   char cmnt[20]  __attribute__((__packed__)) ;
};
#line 989 "../include/protocols.h"
typedef struct __anonstruct_D201_Rte_Hdr_Type_63 D201_Rte_Hdr_Type;
#line 1000 "../include/protocols.h"
struct __anonstruct_D202_Rte_Hdr_Type_64 {
   char rte_ident[1] ;
};
#line 1000 "../include/protocols.h"
typedef struct __anonstruct_D202_Rte_Hdr_Type_64 D202_Rte_Hdr_Type;
#line 1070 "../include/protocols.h"
struct __anonstruct_D310_Trk_Hdr_Type_70 {
   uint8 dspl ;
   uint8 color  __attribute__((__packed__)) ;
   char trk_ident[1]  __attribute__((__packed__)) ;
};
#line 1070 "../include/protocols.h"
typedef struct __anonstruct_D310_Trk_Hdr_Type_70 D310_Trk_Hdr_Type;
#line 1079 "../include/protocols.h"
struct __anonstruct_D311_Trk_Hdr_Type_71 {
   u_int16_t index ;
};
#line 1079 "../include/protocols.h"
typedef struct __anonstruct_D311_Trk_Hdr_Type_71 D311_Trk_Hdr_Type;
#line 1084 "../include/protocols.h"
struct __anonstruct_D312_Trk_Hdr_Type_72 {
   uint8 dspl ;
   uint8 color  __attribute__((__packed__)) ;
   char trk_ident[1]  __attribute__((__packed__)) ;
};
#line 1084 "../include/protocols.h"
typedef struct __anonstruct_D312_Trk_Hdr_Type_72 D312_Trk_Hdr_Type;
#line 1118 "../include/protocols.h"
struct __anonstruct_D500_Almanac_Type_76 {
   u_int16_t wn ;
   float toa  __attribute__((__packed__)) ;
   float af0  __attribute__((__packed__)) ;
   float af1  __attribute__((__packed__)) ;
   float e  __attribute__((__packed__)) ;
   float sqrta  __attribute__((__packed__)) ;
   float m0  __attribute__((__packed__)) ;
   float w  __attribute__((__packed__)) ;
   float omg0  __attribute__((__packed__)) ;
   float odot  __attribute__((__packed__)) ;
   float i  __attribute__((__packed__)) ;
};
#line 1118 "../include/protocols.h"
typedef struct __anonstruct_D500_Almanac_Type_76 D500_Almanac_Type;
#line 1133 "../include/protocols.h"
struct __anonstruct_D501_Almanac_Type_77 {
   u_int16_t wn ;
   float toa  __attribute__((__packed__)) ;
   float af0  __attribute__((__packed__)) ;
   float af1  __attribute__((__packed__)) ;
   float e  __attribute__((__packed__)) ;
   float sqrta  __attribute__((__packed__)) ;
   float m0  __attribute__((__packed__)) ;
   float w  __attribute__((__packed__)) ;
   float omg0  __attribute__((__packed__)) ;
   float odot  __attribute__((__packed__)) ;
   float i  __attribute__((__packed__)) ;
   uint8 hlth  __attribute__((__packed__)) ;
};
#line 1133 "../include/protocols.h"
typedef struct __anonstruct_D501_Almanac_Type_77 D501_Almanac_Type;
#line 1149 "../include/protocols.h"
struct __anonstruct_D550_Almanac_Type_78 {
   uint8 svid ;
   u_int16_t wn  __attribute__((__packed__)) ;
   float toa  __attribute__((__packed__)) ;
   float af0  __attribute__((__packed__)) ;
   float af1  __attribute__((__packed__)) ;
   float e  __attribute__((__packed__)) ;
   float sqrta  __attribute__((__packed__)) ;
   float m0  __attribute__((__packed__)) ;
   float w  __attribute__((__packed__)) ;
   float omg0  __attribute__((__packed__)) ;
   float odot  __attribute__((__packed__)) ;
   float i  __attribute__((__packed__)) ;
};
#line 1149 "../include/protocols.h"
typedef struct __anonstruct_D550_Almanac_Type_78 D550_Almanac_Type;
#line 1168 "../include/protocols.h"
struct __anonstruct_D551_Almanac_Type_79 {
   uint8 svid ;
   u_int16_t wn  __attribute__((__packed__)) ;
   float toa  __attribute__((__packed__)) ;
   float af0  __attribute__((__packed__)) ;
   float af1  __attribute__((__packed__)) ;
   float e  __attribute__((__packed__)) ;
   float sqrta  __attribute__((__packed__)) ;
   float m0  __attribute__((__packed__)) ;
   float w  __attribute__((__packed__)) ;
   float omg0  __attribute__((__packed__)) ;
   float odot  __attribute__((__packed__)) ;
   float i  __attribute__((__packed__)) ;
   uint8 hlth  __attribute__((__packed__)) ;
};
#line 1168 "../include/protocols.h"
typedef struct __anonstruct_D551_Almanac_Type_79 D551_Almanac_Type;
#line 377 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/getgpsinfo.c"
struct __anonstruct_protocol_t_87 {
   u_int16_t product_ID ;
   int16_t software_version ;
   char *protocol ;
};
#line 377 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/getgpsinfo.c"
typedef struct __anonstruct_protocol_t_87 protocol_t;
#line 733 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/getgpsinfo.c"
struct __anonstruct_route_name_type_88 {
   unsigned int nmbr ;
   char *cmnt ;
};
#line 733 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/getgpsinfo.c"
typedef struct __anonstruct_route_name_type_88 route_name_type;
#line 792 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/getgpsinfo.c"
struct __anonstruct_has_90 {
   unsigned int dspl : 1 ;
   unsigned int color : 1 ;
   unsigned int ident : 1 ;
   unsigned int index : 1 ;
};
#line 792 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/getgpsinfo.c"
struct __anonstruct_hdr_89 {
   unsigned char dspl ;
   unsigned char color ;
   char *ident ;
   int index ;
   struct __anonstruct_has_90 has ;
};
#line 1119 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/getgpsinfo.c"
struct __anonstruct_has_92 {
   unsigned int altitude : 1 ;
   unsigned int seconds : 1 ;
   unsigned int name : 1 ;
   unsigned int comment : 1 ;
};
#line 1119 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/getgpsinfo.c"
struct __anonstruct_pkt_91 {
   double latitude ;
   double longitude ;
   double altitude ;
   double seconds ;
   char name[16] ;
   char *comment ;
   char new_trk ;
   struct __anonstruct_has_92 has ;
};
#line 1532 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/getgpsinfo.c"
struct __anonstruct_almanac_type_93 {
   int svid ;
   short wn ;
   double toa ;
   double af0 ;
   double af1 ;
   double e ;
   double sqrta ;
   double m0 ;
   double w ;
   double omg0 ;
   double odot ;
   double i ;
   int hlth ;
};
#line 1532 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/getgpsinfo.c"
typedef struct __anonstruct_almanac_type_93 almanac_type;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 151 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short ushort;
#line 36 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct termio {
   unsigned short c_iflag ;
   unsigned short c_oflag ;
   unsigned short c_cflag ;
   unsigned short c_lflag ;
   unsigned char c_line ;
   unsigned char c_cc[8] ;
};
#line 52 "../include/Garmin.h"
double int2deg(long n ) ;
#line 53
long deg2int(double x ) ;
#line 105
void translate(short fromWGS84 , double *latitude , double *longitude , short datumID ) ;
#line 58 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) atan)(double __x ) ;
#line 67
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) tan)(double __x ) ;
#line 153
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) pow)(double __x ,
                                                                             double __y ) ;
#line 156
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 181
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) fabs)(double __x )  __attribute__((__const__)) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/latlong.c"
static double const   CONVERT  =    (double const   )11930464.7111111111111;
#line 35 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/latlong.c"
static double const   PI  =    (double const   )3.14159265358979323846;
#line 37 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/latlong.c"
static double const   WGSa  =    (double const   )6378137.0;
#line 38 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/latlong.c"
static double const   WGSinvf  =    (double const   )298.257223563;
#line 39 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/latlong.c"
static short const   WGS84ID  =    (short const   )100;
#line 53
struct DATUM  const  gDatum[103] ;
#line 54
struct ELLIPSOID  const  gEllipsoid[23] ;
#line 49 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/latlong.c"
void translate(short fromWGS84 , double *latitude , double *longitude , short datumID ) 
{ 
  double dx ;
  double dy ;
  double dz ;
  double phi ;
  double lambda ;
  double a0 ;
  double b0 ;
  double es0 ;
  double f0 ;
  double a1 ;
  double b1 ;
  double es1 ;
  double f1 ;
  double psi ;
  double x ;
  double y ;
  double z ;
  double psi1 ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  double tmp___15 ;
  double tmp___16 ;

  {
#line 56
  dx = (double )gDatum[datumID].dx;
#line 57
  dy = (double )gDatum[datumID].dy;
#line 58
  dz = (double )gDatum[datumID].dz;
#line 60
  phi = (*latitude * (double )PI) / 180.0;
#line 61
  lambda = (*longitude * (double )PI) / 180.0;
#line 68
  if ((int )datumID == (int )WGS84ID) {
#line 69
    return;
  }
#line 71
  if (fromWGS84) {
#line 73
    a0 = (double )WGSa;
#line 74
    f0 = 1.0 / (double )WGSinvf;
#line 75
    a1 = (double )gEllipsoid[gDatum[datumID].ellipsoid].a;
#line 76
    f1 = 1.0 / (double )gEllipsoid[gDatum[datumID].ellipsoid].invf;
  } else {
#line 80
    a0 = (double )gEllipsoid[gDatum[datumID].ellipsoid].a;
#line 81
    f0 = 1.0 / (double )gEllipsoid[gDatum[datumID].ellipsoid].invf;
#line 82
    a1 = (double )WGSa;
#line 83
    f1 = (double )((double const   )1 / WGSinvf);
#line 84
    dx = - dx;
#line 85
    dy = - dy;
#line 86
    dz = - dz;
  }
#line 89
  b0 = a0 * ((double )1 - f0);
#line 90
  es0 = (double )2 * f0 - f0 * f0;
#line 92
  b1 = a1 * ((double )1 - f1);
#line 93
  es1 = (double )2 * f1 - f1 * f1;
#line 96
  if (*latitude == 0.0) {
#line 97
    psi = phi;
  } else
#line 96
  if (*latitude == 90.0) {
#line 97
    psi = phi;
  } else
#line 96
  if (*latitude == - 90.0) {
#line 97
    psi = phi;
  } else {
    {
#line 99
    tmp = tan(phi);
#line 99
    psi = atan(((double )1 - es0) * tmp);
    }
  }
#line 102
  if (*longitude == 90.0) {
    {
#line 104
    x = 0.0;
#line 105
    tmp___0 = tan(psi);
#line 105
    tmp___1 = pow(tmp___0, 2.0);
#line 105
    tmp___2 = sqrt(b0 * b0 + (a0 * a0) * tmp___1);
#line 105
    y = fabs((a0 * b0) / tmp___2);
    }
  } else
#line 102
  if (*longitude == - 90.0) {
    {
#line 104
    x = 0.0;
#line 105
    tmp___0 = tan(psi);
#line 105
    tmp___1 = pow(tmp___0, 2.0);
#line 105
    tmp___2 = sqrt(b0 * b0 + (a0 * a0) * tmp___1);
#line 105
    y = fabs((a0 * b0) / tmp___2);
    }
  } else {
    {
#line 109
    tmp___3 = tan(lambda);
#line 109
    tmp___4 = pow(tmp___3, 2.0);
#line 109
    tmp___5 = tan(psi);
#line 109
    tmp___6 = pow(tmp___5, 2.0);
#line 109
    tmp___7 = sqrt(((double )1 + tmp___4) * (b0 * b0 + (a0 * a0) * tmp___6));
#line 109
    x = fabs((a0 * b0) / tmp___7);
#line 112
    tmp___8 = tan(lambda);
#line 112
    y = fabs(x * tmp___8);
    }
  }
#line 115
  if (*longitude < - 90.0) {
#line 116
    x = - x;
  } else
#line 115
  if (*longitude > 90.0) {
#line 116
    x = - x;
  }
#line 117
  if (*longitude < 0.0) {
#line 118
    y = - y;
  }
#line 121
  if (*latitude == 90.0) {
#line 122
    z = b0;
  } else
#line 123
  if (*latitude == - 90.0) {
#line 124
    z = - b0;
  } else {
    {
#line 126
    tmp___9 = tan(psi);
#line 126
    tmp___10 = tan(psi);
#line 126
    tmp___11 = pow(tmp___10, 2.0);
#line 126
    tmp___12 = sqrt((((a0 * a0) * b0) * b0) / (b0 * b0 + (a0 * a0) * tmp___11));
#line 126
    z = tmp___9 * tmp___12;
    }
  }
  {
#line 131
  tmp___13 = sqrt((x - dx) * (x - dx) + (y - dy) * (y - dy));
#line 131
  psi1 = atan((z - dz) / tmp___13);
#line 134
  tmp___14 = tan(psi1);
#line 134
  tmp___15 = atan(tmp___14 / ((double )1 - es1));
#line 134
  *latitude = (tmp___15 * 180.0) / (double )PI;
#line 137
  tmp___16 = atan((y - dy) / (x - dx));
#line 137
  *longitude = (tmp___16 * 180.0) / (double )PI;
  }
#line 140
  if (x - dx < 0.0) {
#line 142
    if (y - dy > 0.0) {
#line 143
      *longitude = 180.0 + *longitude;
    } else {
#line 145
      *longitude = - 180.0 + *longitude;
    }
  }
#line 147
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/latlong.c"
double int2deg(long n ) 
{ 
  double res ;

  {
#line 158
  res = (double )((double const   )n / CONVERT);
#line 159
  return (res);
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/latlong.c"
long deg2int(double x ) 
{ 
  long res ;

  {
#line 171
  res = (long )(x * (double )CONVERT);
#line 172
  return (res);
}
}
#line 32 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/graph.c"
void SetBarGraph(double value ) 
{ 


  {
#line 35
  return;
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/graph.c"
void InitBarGraph(void) 
{ 


  {
#line 44
  return;
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/graph.c"
void CloseBarGraph(void) 
{ 


  {
#line 53
  return;
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/graph.c"
void SetFrameBusy(void) 
{ 


  {
#line 62
  return;
}
}
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 65 "../include/Garmin.h"
void toTM(double lat , double lon , double lat0___5 , double lon0___4 , double k0___5 ,
          double *x , double *y ) ;
#line 67
void fromTM(double x , double y , double lat0___5 , double lon0___4 , double k0___5 ,
            double *lat , double *lon ) ;
#line 74
void DegToBNG(double lat , double lon , char *zone , double *x , double *y ) ;
#line 75
void BNGtoDeg(char *zone , double x , double y , double *lat , double *lon ) ;
#line 184 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) floor)(double __x )  __attribute__((__const__)) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/bng.c"
static char const   *zoneID0  =    "STUQRNOPLMHJKFGCDEABXYZVW";
#line 42 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/bng.c"
static char const   *zoneID1  =    "VWXYZQRSTULMNOPFGHJKABCDE";
#line 43 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/bng.c"
static double const   lat0  =    (double const   )49.0;
#line 44 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/bng.c"
static double const   lon0  =    (double const   )(- 2.0);
#line 45 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/bng.c"
static double const   k0  =    (double const   )0.99960133;
#line 52 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/bng.c"
void DegToBNG(double lat , double lon , char *zone , double *x , double *y ) 
{ 
  short X0 ;
  short Y0 ;
  short X1 ;
  short Y1 ;

  {
  {
#line 57
  strcpy((char */* __restrict  */)zone, (char const   */* __restrict  */)"--");
#line 58
  toTM(lat, lon, (double )lat0, (double )lon0, (double )k0, x, y);
#line 61
  *x = floor((*x + 400000.0) + 0.5);
#line 62
  *y = floor((*y - 100000.0) + 0.5);
  }
#line 65
  if (*x < 0.0) {
#line 69
    *x = 0.0;
#line 70
    *y = 0.0;
#line 71
    return;
  } else
#line 65
  if (*x > 1.0e6) {
#line 69
    *x = 0.0;
#line 70
    *y = 0.0;
#line 71
    return;
  } else
#line 65
  if (*y < 0.0) {
#line 69
    *x = 0.0;
#line 70
    *y = 0.0;
#line 71
    return;
  } else
#line 65
  if (*y > 2.5e6) {
#line 69
    *x = 0.0;
#line 70
    *y = 0.0;
#line 71
    return;
  }
#line 74
  X0 = (short )((long )*x / 500000L);
#line 75
  Y0 = (short )((long )*y / 500000L);
#line 77
  X1 = (short )(((long )*x / 100000L) % 5L);
#line 78
  Y1 = (short )(((long )*y / 100000L) % 5L);
#line 80
  *x = (double )((long )*x % 100000L);
#line 81
  *y = (double )((long )*y % 100000L);
#line 83
  *(zone + 0) = (char )*(zoneID0 + (5 * (int )Y0 + (int )X0));
#line 84
  *(zone + 1) = (char )*(zoneID1 + (5 * (int )Y1 + (int )X1));
#line 85
  return;
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/bng.c"
void BNGtoDeg(char *zone , double x , double y , double *lat , double *lon ) 
{ 
  int m ;
  int n ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 97
  tmp = strcmp((char const   *)zone, "--");
  }
#line 97
  if (tmp == 0) {
#line 100
    *lat = 0.0;
#line 101
    *lon = 0.0;
#line 102
    return;
  } else
#line 97
  if (x < 0.0) {
#line 100
    *lat = 0.0;
#line 101
    *lon = 0.0;
#line 102
    return;
  } else
#line 97
  if (x > 100000.0) {
#line 100
    *lat = 0.0;
#line 101
    *lon = 0.0;
#line 102
    return;
  } else
#line 97
  if (y < 0.0) {
#line 100
    *lat = 0.0;
#line 101
    *lon = 0.0;
#line 102
    return;
  } else
#line 97
  if (y > 100000.0) {
#line 100
    *lat = 0.0;
#line 101
    *lon = 0.0;
#line 102
    return;
  }
  {
#line 105
  tmp___0 = strchr(zoneID0, (int )*(zone + 0));
#line 105
  m = (int )(tmp___0 - (char *)zoneID0);
#line 106
  tmp___1 = strchr(zoneID1, (int )*(zone + 1));
#line 106
  n = (int )(tmp___1 - (char *)zoneID1);
#line 108
  x += ((double )(m % 5) * 500000.0 + (double )(n % 5) * 100000.0) - 400000.0;
#line 109
  y += ((double )(m / 5) * 500000.0 + (double )(n / 5) * 100000.0) + 100000.0;
#line 111
  fromTM(x, y, (double )lat0, (double )lon0, (double )k0, lat, lon);
  }
#line 112
  return;
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 538
extern int getchar(void) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 92 "include/Garmin.h"
void Message(char *txt ) ;
#line 44 "include/Prefs.h"
void InitPrefs(void) ;
#line 45
void SetupProgram(void) ;
#line 13 "getline/getline.h"
char *my_getline(char *prompt ) ;
#line 116 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/prefs.c"
short nDatums ;
#line 40
char gMessageStr[255] ;
#line 43 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/prefs.c"
char prop_scratch[255]  ;
#line 44 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/prefs.c"
struct PREFS gPrefs  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/prefs.c"
char *AbsolutFilename(char *ch ) 
{ 
  char temp[255] ;
  char temp1[255] ;
  char *search ;
  struct passwd *pwdentry ;
  char *tmp ;

  {
#line 62
  if ((int )*(ch + 0) != 126) {
    {
#line 64
    sprintf((char */* __restrict  */)(prop_scratch), (char const   */* __restrict  */)"%s",
            ch);
    }
#line 65
    return (& prop_scratch[0]);
  }
  {
#line 67
  sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"%s",
          ch);
  }
#line 68
  if ((int )*(ch + 1) == 47) {
    {
#line 70
    tmp = getenv("HOME");
#line 70
    sprintf((char */* __restrict  */)(temp1), (char const   */* __restrict  */)"%s%s",
            tmp, & temp[1]);
#line 71
    sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"%s",
            temp1);
    }
  } else {
    {
#line 75
    sprintf((char */* __restrict  */)(temp1), (char const   */* __restrict  */)"%s",
            temp);
#line 76
    search = strchr((char const   *)(temp1), '/');
#line 77
    *search = (char)0;
#line 78
    pwdentry = getpwnam((char const   *)(& temp1[1]));
#line 79
    search = strchr((char const   *)(temp), '/');
    }
#line 80
    if ((unsigned long )pwdentry != (unsigned long )((void *)0)) {
      {
#line 82
      sprintf((char */* __restrict  */)(temp1), (char const   */* __restrict  */)"%s%s",
              pwdentry->pw_dir, search);
#line 83
      sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"%s",
              temp1);
      }
    } else {
#line 87
      temp[0] = (char)0;
    }
  }
  {
#line 90
  sprintf((char */* __restrict  */)(prop_scratch), (char const   */* __restrict  */)"%s",
          temp);
  }
#line 91
  return (& prop_scratch[0]);
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/prefs.c"
int AnalyzeLine(char *line , char *key , char *data ) 
{ 
  int i ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
  {
#line 104
  tmp___0 = strlen((char const   *)line);
  }
#line 104
  if ((int )*(line + (tmp___0 - 1UL)) == 10) {
    {
#line 105
    tmp = strlen((char const   *)line);
#line 105
    *(line + (tmp - 1UL)) = (char )'\000';
    }
  }
#line 107
  if ((int )*(line + 0) == 35) {
#line 108
    return (0);
  }
  {
#line 109
  tmp___1 = strlen((char const   *)line);
  }
#line 109
  if (tmp___1 < 5UL) {
#line 110
    return (0);
  }
#line 112
  i = 0;
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 113
    tmp___2 = strlen((char const   *)line);
    }
#line 113
    if ((size_t )i <= tmp___2) {
#line 113
      if (! ((int )*(line + i) != 58)) {
#line 113
        goto while_break;
      }
    } else {
#line 113
      goto while_break;
    }
#line 114
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 116
  tmp___3 = strlen((char const   *)line);
  }
#line 116
  if ((size_t )i >= tmp___3) {
#line 117
    return (0);
  }
  {
#line 119
  sprintf((char */* __restrict  */)key, (char const   */* __restrict  */)"%s", line);
#line 120
  *(key + i) = (char )'\000';
  }
  {
#line 122
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 122
    if (! ((int )*(key + 0) == 32)) {
#line 122
      goto while_break___0;
    }
    {
#line 123
    sprintf((char */* __restrict  */)key, (char const   */* __restrict  */)"%s", key + 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 124
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 124
    if (! ((int )*(key + 0) == 9)) {
#line 124
      goto while_break___1;
    }
    {
#line 125
    sprintf((char */* __restrict  */)key, (char const   */* __restrict  */)"%s", key + 1);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 127
  tmp___4 = strlen((char const   *)key);
  }
#line 127
  if (tmp___4 != 4UL) {
#line 128
    return (0);
  }
  {
#line 130
  sprintf((char */* __restrict  */)data, (char const   */* __restrict  */)"%s", line + (i + 2));
  }
#line 132
  return (1);
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/prefs.c"
void SavePrefs(void) 
{ 
  FILE *preffp ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 144
  tmp = AbsolutFilename((char *)"~/.gpstrans");
#line 144
  preffp = fopen((char const   */* __restrict  */)tmp, (char const   */* __restrict  */)"wt");
  }
#line 145
  if ((unsigned long )preffp == (unsigned long )((FILE *)0)) {
    {
#line 147
    tmp___0 = AbsolutFilename((char *)"~/.gpstrans");
#line 147
    sprintf((char */* __restrict  */)(gMessageStr), (char const   */* __restrict  */)"Can\'t write preferences in file \'%s\'",
            tmp___0);
#line 149
    Message(gMessageStr);
    }
  } else {
    {
#line 153
    fprintf((FILE */* __restrict  */)preffp, (char const   */* __restrict  */)"# Properties file of gpstrans - do not edit this file\n");
#line 155
    fprintf((FILE */* __restrict  */)preffp, (char const   */* __restrict  */)"FMAT: %d\n",
            (unsigned int )gPrefs.format);
#line 156
    fprintf((FILE */* __restrict  */)preffp, (char const   */* __restrict  */)"OFFS: %1.2f\n",
            gPrefs.offset);
#line 157
    fprintf((FILE */* __restrict  */)preffp, (char const   */* __restrict  */)"DATU: %d\n",
            (int )gPrefs.datum);
#line 158
    fprintf((FILE */* __restrict  */)preffp, (char const   */* __restrict  */)"DEVI: %s\n",
            gPrefs.Device);
#line 159
    fprintf((FILE */* __restrict  */)preffp, (char const   */* __restrict  */)"MODL: %c\n",
            (int )gPrefs.model);
#line 160
    fprintf((FILE */* __restrict  */)preffp, (char const   */* __restrict  */)"FEET: %d\n",
            (int )gPrefs.feet);
#line 161
    fclose(preffp);
    }
  }
#line 163
  return;
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/prefs.c"
void LoadPrefs(void) 
{ 
  char Line[255] ;
  char Keyword[255] ;
  char Data[255] ;
  int value ;
  float floatval ;
  FILE *preffp ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 177
  gPrefs.format = (enum FORMAT )0;
#line 178
  gPrefs.offset = 0.0;
#line 179
  gPrefs.datum = (short)100;
#line 180
  gPrefs.model = (char )'n';
#line 181
  gPrefs.feet = (char)0;
#line 182
  sprintf((char */* __restrict  */)(gPrefs.Device), (char const   */* __restrict  */)"%s",
          "/dev/ttyS1");
#line 184
  tmp = AbsolutFilename((char *)"~/.gpstrans");
#line 184
  preffp = fopen((char const   */* __restrict  */)tmp, (char const   */* __restrict  */)"rt");
  }
#line 185
  if ((unsigned long )preffp != (unsigned long )((FILE *)0)) {
    {
#line 188
    fgets((char */* __restrict  */)(Line), 255, (FILE */* __restrict  */)preffp);
    }
    {
#line 189
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 189
      tmp___6 = feof(preffp);
      }
#line 189
      if (tmp___6) {
#line 189
        goto while_break;
      }
      {
#line 192
      tmp___5 = AnalyzeLine((char *)(Line), (char *)(Keyword), (char *)(Data));
      }
#line 192
      if (tmp___5) {
        {
#line 195
        tmp___3 = strcmp((char const   *)(Keyword), "FMAT");
        }
#line 195
        if (tmp___3) {
          {
#line 200
          tmp___2 = strcmp((char const   *)(Keyword), "OFFS");
          }
#line 200
          if (tmp___2) {
            {
#line 205
            tmp___1 = strcmp((char const   *)(Keyword), "DATU");
            }
#line 205
            if (tmp___1) {
              {
#line 210
              tmp___0 = strcmp((char const   *)(Keyword), "DEVI");
              }
#line 210
              if (! tmp___0) {
                {
#line 212
                sprintf((char */* __restrict  */)(gPrefs.Device), (char const   */* __restrict  */)"%s",
                        Data);
                }
              }
            } else {
              {
#line 207
              sscanf((char const   */* __restrict  */)(Data), (char const   */* __restrict  */)"%d",
                     & value);
#line 208
              gPrefs.datum = (short )value;
              }
            }
          } else {
            {
#line 202
            sscanf((char const   */* __restrict  */)(Data), (char const   */* __restrict  */)"%f",
                   & floatval);
#line 203
            gPrefs.offset = (double )floatval;
            }
          }
        } else {
          {
#line 197
          sscanf((char const   */* __restrict  */)(Data), (char const   */* __restrict  */)"%d",
                 & value);
#line 198
          gPrefs.format = (enum FORMAT )value;
          }
        }
        {
#line 214
        tmp___4 = strcmp((char const   *)(Keyword), "MODL");
        }
#line 214
        if (! tmp___4) {
          {
#line 216
          sscanf((char const   */* __restrict  */)(Data), (char const   */* __restrict  */)"%c",
                 & gPrefs.model);
          }
        }
      }
      {
#line 219
      fgets((char */* __restrict  */)(Line), 255, (FILE */* __restrict  */)preffp);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 221
    fclose(preffp);
    }
  }
#line 223
  return;
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/prefs.c"
void InitPrefs(void) 
{ 


  {
  {
#line 232
  LoadPrefs();
  }
#line 233
  return;
}
}
#line 239 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/prefs.c"
void WaitforReturn(void) 
{ 


  {
  {
#line 242
  printf((char const   */* __restrict  */)"Press RETURN for more ");
#line 243
  fflush(stdout);
#line 244
  getchar();
  }
#line 245
  return;
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/prefs.c"
void SetupProgram(void) 
{ 
  int value ;
  short v ;
  float floatval ;
  char *p ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 259
  v = (short)0;
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
#line 259
    if (! ((int )v <= (int )nDatums)) {
#line 259
      goto while_break;
    }
    {
#line 261
    printf((char const   */* __restrict  */)"%3d - %-25s    ", (int )v, gDatum[v].name);
    }
#line 262
    if (((int )v + 1) % 2 == 0) {
      {
#line 263
      printf((char const   */* __restrict  */)"\n");
      }
    }
#line 264
    if ((int )v == 39) {
      {
#line 265
      WaitforReturn();
      }
    } else
#line 264
    if ((int )v == 85) {
      {
#line 265
      WaitforReturn();
      }
    }
#line 259
    v = (short )((int )v + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 267
  printf((char const   */* __restrict  */)"\n");
  }
  {
#line 269
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 271
    p = my_getline((char *)"Please select datum: ");
#line 272
    sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%d",
           & value);
#line 273
    printf((char const   */* __restrict  */)"\n");
    }
#line 269
    if (! (value < 0)) {
#line 269
      if (! (value > (int )nDatums)) {
#line 269
        if (! ((int )*(p + 0) < 48)) {
#line 269
          if (! ((int )*(p + 0) > 57)) {
#line 269
            goto while_break___0;
          }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 276
  gPrefs.datum = (short )value;
#line 278
  printf((char const   */* __restrict  */)"\n\n");
#line 279
  printf((char const   */* __restrict  */)"   0 - lat/lon  ddd\260mm\'ss.s\"\n");
#line 280
  printf((char const   */* __restrict  */)"   1 - lat/lon  ddd\260mm.mmm\'\n");
#line 281
  printf((char const   */* __restrict  */)"   2 - lat/lon  ddd.ddddd\n");
#line 282
  printf((char const   */* __restrict  */)"   3 - utm/ups Grid\n");
#line 283
  printf((char const   */* __restrict  */)"   4 - British Grid\n");
#line 284
  printf((char const   */* __restrict  */)"   5 - Irish   Grid\n");
#line 285
  printf((char const   */* __restrict  */)"   6 - Finnish Grid\n");
#line 286
  printf((char const   */* __restrict  */)"   7 - Swedish Grid\n");
#line 287
  printf((char const   */* __restrict  */)"   8 - German  Grid\n\n");
  }
  {
#line 289
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 291
    p = my_getline((char *)"Please select format: ");
#line 292
    sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%d",
           & value);
#line 293
    printf((char const   */* __restrict  */)"\n");
    }
#line 289
    if (! (value < 0)) {
#line 289
      if (! (value > 8)) {
#line 289
        if (! ((int )*(p + 0) < 48)) {
#line 289
          if (! ((int )*(p + 0) > 57)) {
#line 289
            goto while_break___1;
          }
        }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 296
  gPrefs.format = (enum FORMAT )value;
#line 298
  printf((char const   */* __restrict  */)"\n");
  }
  {
#line 299
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 301
    p = my_getline((char *)"Please select time offset (-12 to +12): ");
#line 302
    sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%f",
           & floatval);
#line 303
    printf((char const   */* __restrict  */)"\n");
    }
#line 299
    if (! ((double )floatval < - 12.0)) {
#line 299
      if (! ((double )floatval > 12.0)) {
#line 299
        goto while_break___2;
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 306
  gPrefs.offset = (double )floatval;
#line 308
  printf((char const   */* __restrict  */)"\n");
  }
  {
#line 309
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 311
    p = my_getline((char *)"Please enter serial device name: ");
#line 312
    sprintf((char */* __restrict  */)(gPrefs.Device), (char const   */* __restrict  */)"%s",
            p);
#line 313
    printf((char const   */* __restrict  */)"\n");
#line 309
    tmp = strlen((char const   *)(gPrefs.Device));
    }
#line 309
    if (! (tmp == 0UL)) {
#line 309
      goto while_break___3;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 317
  printf((char const   */* __restrict  */)"\n");
  }
  {
#line 318
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 320
    p = my_getline((char *)"Is your model etrex (or other similar model) (y/n)?");
#line 326
    sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%c",
           & gPrefs.model);
#line 318
    tmp___0 = strlen((char const   *)(& gPrefs.model));
    }
#line 318
    if (! (tmp___0 == 0UL)) {
#line 318
      goto while_break___4;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 333
  printf((char const   */* __restrict  */)"\n");
#line 335
  printf((char const   */* __restrict  */)"\n\n");
#line 336
  printf((char const   */* __restrict  */)"Preferences have been saved to ~/.gpstrans and will be used in the");
#line 338
  printf((char const   */* __restrict  */)" future.\n");
#line 340
  SavePrefs();
#line 341
  exit(0);
  }
}
}
#line 14 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.h"
char *getlinenoecho(char *prompt ) ;
#line 15
void gl_setwidth(int w ) ;
#line 16
void gl_histadd(char *buf ) ;
#line 17
void gl_strwidth(size_t (*func)(char * ) ) ;
#line 19
int (*gl_in_hook)(char * ) ;
#line 20
int (*gl_out_hook)(char * ) ;
#line 21
int (*gl_tab_hook)(char * , int  , int * ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static int gl_tab(char *buf , int offset , int *loc ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
extern int isatty() ;
#line 35
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 36
extern void free() ;
#line 45 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
int (*gl_in_hook)(char * )  =    (int (*)(char * ))0;
#line 46 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
int (*gl_out_hook)(char * )  =    (int (*)(char * ))0;
#line 47 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
int (*gl_tab_hook)(char * , int  , int * )  =    (int (*)(char * , int  , int * ))(& gl_tab);
#line 49 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
int echo  =    1;
#line 55 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static int gl_init_done  =    -1;
#line 56 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static int gl_termw  =    80;
#line 57 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static int gl_scroll  =    27;
#line 58 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static int gl_width  =    0;
#line 59 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static int gl_extent  =    0;
#line 60 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static int gl_overwrite  =    0;
#line 61 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static int gl_pos  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static int gl_cnt  =    0;
#line 62 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static char gl_buf[1024]  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static char gl_killbuf[1024]  = {      (char )'\000'};
#line 64 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static char *gl_prompt  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static char gl_intrc  =    (char)0;
#line 66 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static char gl_quitc  =    (char)0;
#line 67 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static char gl_suspc  =    (char)0;
#line 68 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static char gl_dsuspc  =    (char)0;
#line 69 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static int gl_search_mode  =    0;
#line 71
static void gl_init(void) ;
#line 72
static void gl_cleanup(void) ;
#line 73
static void gl_char_init(void) ;
#line 74
static void gl_char_cleanup(void) ;
#line 75 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static size_t (*gl_strlen)()  =    (size_t (*)())(& strlen);
#line 78
static void gl_addchar(int c ) ;
#line 79
static void gl_del(int loc ) ;
#line 80
static void gl_error(char *buf ) ;
#line 81
static void gl_fixup(char *prompt , int change , int cursor ) ;
#line 82
static int gl_getc(void) ;
#line 83
static void gl_kill(int pos ) ;
#line 85
static void gl_putc(int c ) ;
#line 86
static void gl_puts(char *buf ) ;
#line 87
static void gl_redraw(void) ;
#line 88
static void gl_transpose(void) ;
#line 89
static void gl_yank(void) ;
#line 90
static void gl_word(int direction ) ;
#line 92
static void hist_init(void) ;
#line 93
static char *hist_next(void) ;
#line 94
static char *hist_prev(void) ;
#line 95
static char *hist_save(char *p ) ;
#line 97
static void search_addchar(int c ) ;
#line 98
static void search_term(void) ;
#line 99
static void search_back(int new_search ) ;
#line 100
static void search_forw(int new_search ) ;
#line 103 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
char *stop  =    (char *)"CRTL-C";
#line 106
extern int write() ;
#line 133
extern int read() ;
#line 66 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 139 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
struct termios new_termios  ;
#line 139 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
struct termios old_termios  ;
#line 168 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static void gl_char_init(void) 
{ 


  {
  {
#line 173
  tcgetattr(0, & old_termios);
#line 174
  gl_intrc = (char )old_termios.c_cc[0];
#line 175
  gl_quitc = (char )old_termios.c_cc[1];
#line 177
  gl_suspc = (char )old_termios.c_cc[10];
#line 182
  new_termios = old_termios;
#line 183
  new_termios.c_iflag &= 4294962141U;
#line 184
  new_termios.c_iflag |= 5U;
#line 185
  new_termios.c_lflag &= 4294934516U;
#line 186
  new_termios.c_cc[6] = (cc_t )1;
#line 187
  new_termios.c_cc[5] = (cc_t )0;
#line 188
  tcsetattr(0, 0, (struct termios  const  *)(& new_termios));
  }
#line 227
  return;
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static void gl_char_cleanup(void) 
{ 


  {
  {
#line 234
  tcsetattr(0, 0, (struct termios  const  *)(& old_termios));
  }
#line 250
  return;
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static int gl_getc(void) 
{ 
  int c ;
  char ch ;
  int *tmp ;

  {
  {
#line 288
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 288
    c = read(0, & ch, 1);
    }
#line 288
    if (! (c == -1)) {
#line 288
      goto while_break;
    }
    {
#line 290
    tmp = __errno_location();
    }
#line 290
    if (*tmp != 4) {
#line 291
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 293
  if (c == 3) {
#line 295
    return ((int )*stop);
  }
#line 297
  if ((int )ch <= 0) {
#line 297
    c = -1;
  } else {
#line 297
    c = (int )ch;
  }
#line 341
  return (c);
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static void gl_putc(int c ) 
{ 
  char ch ;

  {
  {
#line 348
  ch = (char )c;
#line 350
  write(1, & ch, 1);
  }
#line 351
  if ((int )ch == 10) {
    {
#line 353
    ch = (char )'\r';
#line 354
    write(1, & ch, 1);
    }
  }
#line 356
  return;
}
}
#line 360 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static void gl_puts(char *buf ) 
{ 
  int len ;
  size_t tmp ;

  {
#line 366
  if (buf) {
    {
#line 368
    tmp = strlen((char const   *)buf);
#line 368
    len = (int )tmp;
#line 369
    write(1, buf, len);
    }
  }
#line 371
  return;
}
}
#line 373 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static void gl_error(char *buf ) 
{ 
  int len ;
  size_t tmp ;

  {
  {
#line 377
  tmp = strlen((char const   *)buf);
#line 377
  len = (int )tmp;
#line 379
  gl_cleanup();
#line 380
  write(2, buf, len);
#line 381
  printf((char const   */* __restrict  */)"In gl_error");
#line 382
  fflush(stdout);
#line 383
  exit(1);
  }
}
}
#line 386 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static void gl_init(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 390
  if (gl_init_done < 0) {
    {
#line 392
    hist_init();
    }
  }
  {
#line 394
  tmp = isatty(0);
  }
#line 394
  if (tmp == 0) {
    {
#line 395
    gl_error((char *)"\n*** Error: my_getline(): not interactive, use stdio.\n");
    }
  } else {
    {
#line 394
    tmp___0 = isatty(1);
    }
#line 394
    if (tmp___0 == 0) {
      {
#line 395
      gl_error((char *)"\n*** Error: my_getline(): not interactive, use stdio.\n");
      }
    }
  }
  {
#line 396
  gl_char_init();
#line 397
  gl_init_done = 1;
  }
#line 398
  return;
}
}
#line 400 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static void gl_cleanup(void) 
{ 


  {
#line 404
  if (gl_init_done > 0) {
    {
#line 405
    gl_char_cleanup();
    }
  }
#line 406
  gl_init_done = 0;
#line 407
  return;
}
}
#line 409 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
void gl_setwidth(int w ) 
{ 


  {
#line 413
  if (w > 20) {
#line 415
    gl_termw = w;
#line 416
    gl_scroll = w / 3;
  } else {
    {
#line 420
    gl_error((char *)"\n*** Error: minimum screen width is 21\n");
    }
  }
#line 422
  return;
}
}
#line 424 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
char *my_getline(char *prompt ) 
{ 
  int c ;
  int loc ;
  int tmp ;
  int sig ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
  {
#line 434
  gl_init();
  }
#line 435
  if (prompt) {
#line 435
    gl_prompt = prompt;
  } else {
#line 435
    gl_prompt = (char *)"";
  }
#line 436
  gl_buf[0] = (char)0;
#line 437
  if (gl_in_hook) {
    {
#line 438
    (*gl_in_hook)(gl_buf);
    }
  }
  {
#line 439
  gl_fixup(gl_prompt, -2, 1024);
  }
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 440
    c = gl_getc();
    }
#line 440
    if (! (c >= 0)) {
#line 440
      goto while_break;
    }
    {
#line 442
    gl_extent = 0;
#line 443
    tmp___5 = __ctype_b_loc();
    }
#line 443
    if ((int const   )*(*tmp___5 + c) & 16384) {
#line 445
      if (gl_search_mode) {
        {
#line 446
        search_addchar(c);
        }
      } else {
        {
#line 448
        gl_addchar(c);
        }
      }
    } else {
#line 452
      if (gl_search_mode) {
#line 454
        if (c == 27) {
          {
#line 456
          search_term();
#line 457
          c = 0;
          }
        } else
#line 454
        if (c == 14) {
          {
#line 456
          search_term();
#line 457
          c = 0;
          }
        } else
#line 454
        if (c == 16) {
          {
#line 456
          search_term();
#line 457
          c = 0;
          }
        } else
#line 459
        if (c == 8) {
          {
#line 461
          search_addchar(-1);
#line 462
          c = 0;
          }
        } else
#line 459
        if (c == 127) {
          {
#line 461
          search_addchar(-1);
#line 462
          c = 0;
          }
        } else
#line 464
        if (c != 18) {
#line 464
          if (c != 19) {
            {
#line 466
            search_term();
            }
          }
        }
      }
      {
#line 472
      if (c == 13) {
#line 472
        goto case_13;
      }
#line 472
      if (c == 10) {
#line 472
        goto case_13;
      }
#line 477
      if (c == 1) {
#line 477
        goto case_1;
      }
#line 480
      if (c == 2) {
#line 480
        goto case_2;
      }
#line 483
      if (c == 4) {
#line 483
        goto case_4;
      }
#line 496
      if (c == 5) {
#line 496
        goto case_5;
      }
#line 499
      if (c == 6) {
#line 499
        goto case_6;
      }
#line 503
      if (c == 127) {
#line 503
        goto case_127;
      }
#line 503
      if (c == 8) {
#line 503
        goto case_127;
      }
#line 506
      if (c == 9) {
#line 506
        goto case_9;
      }
#line 515
      if (c == 11) {
#line 515
        goto case_11;
      }
#line 518
      if (c == 12) {
#line 518
        goto case_12;
      }
#line 521
      if (c == 14) {
#line 521
        goto case_14;
      }
#line 527
      if (c == 15) {
#line 527
        goto case_15;
      }
#line 530
      if (c == 16) {
#line 530
        goto case_16;
      }
#line 536
      if (c == 18) {
#line 536
        goto case_18;
      }
#line 539
      if (c == 19) {
#line 539
        goto case_19;
      }
#line 542
      if (c == 20) {
#line 542
        goto case_20;
      }
#line 545
      if (c == 21) {
#line 545
        goto case_21;
      }
#line 548
      if (c == 25) {
#line 548
        goto case_25;
      }
#line 551
      if (c == 27) {
#line 551
        goto case_27;
      }
#line 591
      goto switch_default___0;
      case_13: /* CIL Label */ 
      case_10: /* CIL Label */ 
      {
#line 474
      gl_cleanup();
      }
#line 475
      return (gl_buf);
#line 476
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 478
      gl_fixup(gl_prompt, -1, 0);
      }
#line 479
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 481
      gl_fixup(gl_prompt, -1, gl_pos - 1);
      }
#line 482
      goto switch_break;
      case_4: /* CIL Label */ 
#line 484
      if (gl_cnt == 0) {
        {
#line 486
        gl_buf[0] = (char)0;
#line 487
        gl_cleanup();
#line 488
        gl_putc('\n');
        }
#line 489
        return (gl_buf);
      } else {
        {
#line 493
        gl_del(0);
        }
      }
#line 495
      goto switch_break;
      case_5: /* CIL Label */ 
      {
#line 497
      gl_fixup(gl_prompt, -1, gl_cnt);
      }
#line 498
      goto switch_break;
      case_6: /* CIL Label */ 
      {
#line 500
      gl_fixup(gl_prompt, -1, gl_pos + 1);
      }
#line 501
      goto switch_break;
      case_127: /* CIL Label */ 
      case_8: /* CIL Label */ 
      {
#line 504
      gl_del(-1);
      }
#line 505
      goto switch_break;
      case_9: /* CIL Label */ 
#line 507
      if (gl_tab_hook) {
        {
#line 509
        tmp = gl_pos;
#line 510
        tmp___0 = (*gl_strlen)(gl_prompt);
#line 510
        loc = (*gl_tab_hook)(gl_buf, (int )tmp___0, & tmp);
        }
#line 511
        if (loc >= 0) {
          {
#line 512
          gl_fixup(gl_prompt, loc, tmp);
          }
        } else
#line 511
        if (tmp != gl_pos) {
          {
#line 512
          gl_fixup(gl_prompt, loc, tmp);
          }
        }
      }
#line 514
      goto switch_break;
      case_11: /* CIL Label */ 
      {
#line 516
      gl_kill(gl_pos);
      }
#line 517
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 519
      gl_redraw();
      }
#line 520
      goto switch_break;
      case_14: /* CIL Label */ 
      {
#line 522
      tmp___1 = hist_next();
#line 522
      strcpy((char */* __restrict  */)(gl_buf), (char const   */* __restrict  */)tmp___1);
      }
#line 523
      if (gl_in_hook) {
        {
#line 524
        (*gl_in_hook)(gl_buf);
        }
      }
      {
#line 525
      gl_fixup(gl_prompt, 0, 1024);
      }
#line 526
      goto switch_break;
      case_15: /* CIL Label */ 
#line 528
      gl_overwrite = ! gl_overwrite;
#line 529
      goto switch_break;
      case_16: /* CIL Label */ 
      {
#line 531
      tmp___2 = hist_prev();
#line 531
      strcpy((char */* __restrict  */)(gl_buf), (char const   */* __restrict  */)tmp___2);
      }
#line 532
      if (gl_in_hook) {
        {
#line 533
        (*gl_in_hook)(gl_buf);
        }
      }
      {
#line 534
      gl_fixup(gl_prompt, 0, 1024);
      }
#line 535
      goto switch_break;
      case_18: /* CIL Label */ 
      {
#line 537
      search_back(1);
      }
#line 538
      goto switch_break;
      case_19: /* CIL Label */ 
      {
#line 540
      search_forw(1);
      }
#line 541
      goto switch_break;
      case_20: /* CIL Label */ 
      {
#line 543
      gl_transpose();
      }
#line 544
      goto switch_break;
      case_21: /* CIL Label */ 
      {
#line 546
      gl_kill(0);
      }
#line 547
      goto switch_break;
      case_25: /* CIL Label */ 
      {
#line 549
      gl_yank();
      }
#line 550
      goto switch_break;
      case_27: /* CIL Label */ 
      {
#line 552
      c = gl_getc();
      }
#line 553
      if (c == 91) {
        {
#line 555
        c = gl_getc();
        }
        {
#line 557
        if (c == 65) {
#line 557
          goto case_65;
        }
#line 563
        if (c == 66) {
#line 563
          goto case_66;
        }
#line 569
        if (c == 67) {
#line 569
          goto case_67;
        }
#line 572
        if (c == 68) {
#line 572
          goto case_68;
        }
#line 575
        goto switch_default;
        case_65: /* CIL Label */ 
        {
#line 558
        tmp___3 = hist_prev();
#line 558
        strcpy((char */* __restrict  */)(gl_buf), (char const   */* __restrict  */)tmp___3);
        }
#line 559
        if (gl_in_hook) {
          {
#line 560
          (*gl_in_hook)(gl_buf);
          }
        }
        {
#line 561
        gl_fixup(gl_prompt, 0, 1024);
        }
#line 562
        goto switch_break___0;
        case_66: /* CIL Label */ 
        {
#line 564
        tmp___4 = hist_next();
#line 564
        strcpy((char */* __restrict  */)(gl_buf), (char const   */* __restrict  */)tmp___4);
        }
#line 565
        if (gl_in_hook) {
          {
#line 566
          (*gl_in_hook)(gl_buf);
          }
        }
        {
#line 567
        gl_fixup(gl_prompt, 0, 1024);
        }
#line 568
        goto switch_break___0;
        case_67: /* CIL Label */ 
        {
#line 570
        gl_fixup(gl_prompt, -1, gl_pos + 1);
        }
#line 571
        goto switch_break___0;
        case_68: /* CIL Label */ 
        {
#line 573
        gl_fixup(gl_prompt, -1, gl_pos - 1);
        }
#line 574
        goto switch_break___0;
        switch_default: /* CIL Label */ 
        {
#line 576
        gl_putc('\a');
        }
#line 577
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
      } else
#line 580
      if (c == 102) {
        {
#line 582
        gl_word(1);
        }
      } else
#line 580
      if (c == 70) {
        {
#line 582
        gl_word(1);
        }
      } else
#line 584
      if (c == 98) {
        {
#line 586
        gl_word(-1);
        }
      } else
#line 584
      if (c == 66) {
        {
#line 586
        gl_word(-1);
        }
      } else {
        {
#line 589
        gl_putc('\a');
        }
      }
#line 590
      goto switch_break;
      switch_default___0: /* CIL Label */ 
#line 593
      if (c > 0) {
#line 595
        sig = 0;
#line 597
        if (c == (int )gl_intrc) {
#line 598
          sig = 2;
        }
#line 601
        if (c == (int )gl_quitc) {
#line 602
          sig = 3;
        }
#line 605
        if (c == (int )gl_suspc) {
#line 606
          sig = 20;
        } else
#line 605
        if (c == (int )gl_dsuspc) {
#line 606
          sig = 20;
        }
#line 608
        if (sig != 0) {
          {
#line 610
          gl_cleanup();
#line 611
          kill(0, sig);
#line 612
          gl_init();
#line 613
          gl_redraw();
#line 614
          c = 0;
          }
        }
      }
#line 618
      if (c > 0) {
        {
#line 619
        gl_putc('\a');
        }
      }
#line 620
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 624
  gl_cleanup();
#line 625
  gl_buf[0] = (char)0;
  }
#line 626
  return (gl_buf);
}
}
#line 629 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static void gl_addchar(int c ) 
{ 
  int i ;

  {
#line 636
  if (gl_cnt >= 1023) {
    {
#line 637
    gl_error((char *)"\n*** Error: my_getline(): input buffer overflow\n");
    }
  }
#line 638
  if (gl_overwrite == 0) {
#line 638
    goto _L;
  } else
#line 638
  if (gl_pos == gl_cnt) {
    _L: /* CIL Label */ 
#line 640
    i = gl_cnt;
    {
#line 640
    while (1) {
      while_continue: /* CIL Label */ ;
#line 640
      if (! (i >= gl_pos)) {
#line 640
        goto while_break;
      }
#line 641
      gl_buf[i + 1] = gl_buf[i];
#line 640
      i --;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 642
    gl_buf[gl_pos] = (char )c;
#line 643
    gl_fixup(gl_prompt, gl_pos, gl_pos + 1);
    }
  } else {
    {
#line 647
    gl_buf[gl_pos] = (char )c;
#line 648
    gl_extent = 1;
#line 649
    gl_fixup(gl_prompt, gl_pos, gl_pos + 1);
    }
  }
#line 651
  return;
}
}
#line 653 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static void gl_yank(void) 
{ 
  int i ;
  int len ;
  size_t tmp ;

  {
  {
#line 659
  tmp = strlen((char const   *)(gl_killbuf));
#line 659
  len = (int )tmp;
  }
#line 660
  if (len > 0) {
#line 662
    if (gl_overwrite == 0) {
#line 664
      if (gl_cnt + len >= 1023) {
        {
#line 665
        gl_error((char *)"\n*** Error: my_getline(): input buffer overflow\n");
        }
      }
#line 666
      i = gl_cnt;
      {
#line 666
      while (1) {
        while_continue: /* CIL Label */ ;
#line 666
        if (! (i >= gl_pos)) {
#line 666
          goto while_break;
        }
#line 667
        gl_buf[i + len] = gl_buf[i];
#line 666
        i --;
      }
      while_break: /* CIL Label */ ;
      }
#line 668
      i = 0;
      {
#line 668
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 668
        if (! (i < len)) {
#line 668
          goto while_break___0;
        }
#line 669
        gl_buf[gl_pos + i] = gl_killbuf[i];
#line 668
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 670
      gl_fixup(gl_prompt, gl_pos, gl_pos + len);
      }
    } else {
#line 674
      if (gl_pos + len > gl_cnt) {
#line 676
        if (gl_pos + len >= 1023) {
          {
#line 677
          gl_error((char *)"\n*** Error: my_getline(): input buffer overflow\n");
          }
        }
#line 678
        gl_buf[gl_pos + len] = (char)0;
      }
#line 680
      i = 0;
      {
#line 680
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 680
        if (! (i < len)) {
#line 680
          goto while_break___1;
        }
#line 681
        gl_buf[gl_pos + i] = gl_killbuf[i];
#line 680
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 682
      gl_extent = len;
#line 683
      gl_fixup(gl_prompt, gl_pos, gl_pos + len);
      }
    }
  } else {
    {
#line 687
    gl_putc('\a');
    }
  }
#line 688
  return;
}
}
#line 690 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static void gl_transpose(void) 
{ 
  int c ;

  {
#line 696
  if (gl_pos > 0) {
#line 696
    if (gl_cnt > gl_pos) {
      {
#line 698
      c = (int )gl_buf[gl_pos - 1];
#line 699
      gl_buf[gl_pos - 1] = gl_buf[gl_pos];
#line 700
      gl_buf[gl_pos] = (char )c;
#line 701
      gl_extent = 2;
#line 702
      gl_fixup(gl_prompt, gl_pos - 1, gl_pos);
      }
    } else {
      {
#line 705
      gl_putc('\a');
      }
    }
  } else {
    {
#line 705
    gl_putc('\a');
    }
  }
#line 706
  return;
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static void gl_del(int loc ) 
{ 
  int i ;

  {
#line 747
  if (loc == -1) {
#line 747
    if (gl_pos > 0) {
#line 747
      goto _L;
    } else {
#line 747
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 747
  if (loc == 0) {
#line 747
    if (gl_pos < gl_cnt) {
      _L: /* CIL Label */ 
#line 749
      i = gl_pos + loc;
      {
#line 749
      while (1) {
        while_continue: /* CIL Label */ ;
#line 749
        if (! (i < gl_cnt)) {
#line 749
          goto while_break;
        }
#line 750
        gl_buf[i] = gl_buf[i + 1];
#line 749
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 751
      gl_fixup(gl_prompt, gl_pos + loc, gl_pos + loc);
      }
    } else {
      {
#line 754
      gl_putc('\a');
      }
    }
  } else {
    {
#line 754
    gl_putc('\a');
    }
  }
#line 755
  return;
}
}
#line 757 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static void gl_kill(int pos ) 
{ 


  {
#line 762
  if (pos < gl_cnt) {
    {
#line 764
    strcpy((char */* __restrict  */)(gl_killbuf), (char const   */* __restrict  */)(gl_buf + pos));
#line 765
    gl_buf[pos] = (char )'\000';
#line 766
    gl_fixup(gl_prompt, pos, pos);
    }
  } else {
    {
#line 769
    gl_putc('\a');
    }
  }
#line 770
  return;
}
}
#line 772 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static void gl_word(int direction ) 
{ 
  int pos ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
#line 777
  pos = gl_pos;
#line 779
  if (direction > 0) {
    {
#line 781
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 781
      tmp = __ctype_b_loc();
      }
#line 781
      if ((int const   )*(*tmp + (int )gl_buf[pos]) & 8192) {
#line 781
        goto while_break;
      } else
#line 781
      if (! (pos < gl_cnt)) {
#line 781
        goto while_break;
      }
#line 782
      pos ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 783
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 783
      tmp___0 = __ctype_b_loc();
      }
#line 783
      if ((int const   )*(*tmp___0 + (int )gl_buf[pos]) & 8192) {
#line 783
        if (! (pos < gl_cnt)) {
#line 783
          goto while_break___0;
        }
      } else {
#line 783
        goto while_break___0;
      }
#line 784
      pos ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 788
    if (pos > 0) {
#line 789
      pos --;
    }
    {
#line 790
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 790
      tmp___1 = __ctype_b_loc();
      }
#line 790
      if ((int const   )*(*tmp___1 + (int )gl_buf[pos]) & 8192) {
#line 790
        if (! (pos > 0)) {
#line 790
          goto while_break___1;
        }
      } else {
#line 790
        goto while_break___1;
      }
#line 791
      pos --;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 792
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 792
      tmp___2 = __ctype_b_loc();
      }
#line 792
      if ((int const   )*(*tmp___2 + (int )gl_buf[pos]) & 8192) {
#line 792
        goto while_break___2;
      } else
#line 792
      if (! (pos > 0)) {
#line 792
        goto while_break___2;
      }
#line 793
      pos --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 794
    if (pos < gl_cnt) {
      {
#line 794
      tmp___3 = __ctype_b_loc();
      }
#line 794
      if ((int const   )*(*tmp___3 + (int )gl_buf[pos]) & 8192) {
#line 795
        pos ++;
      }
    }
  }
  {
#line 797
  gl_fixup(gl_prompt, -1, pos);
  }
#line 798
  return;
}
}
#line 800 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static void gl_redraw(void) 
{ 


  {
#line 804
  if (gl_init_done > 0) {
    {
#line 806
    gl_putc('\n');
#line 807
    gl_fixup(gl_prompt, -2, gl_pos);
    }
  }
#line 809
  return;
}
}
#line 827 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static int gl_shift  ;
#line 828 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static int off_right  ;
#line 829 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static int off_left  ;
#line 830 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static char last_prompt[80]  = {      (char )'\000'};
#line 811 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static void gl_fixup(char *prompt , int change , int cursor ) 
{ 
  int left ;
  int right ;
  int pad ;
  int backup ;
  int new_shift ;
  int extra ;
  int i ;
  int new_right ;
  int l1 ;
  int l2 ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 831
  left = 0;
#line 831
  right = -1;
#line 837
  new_right = -1;
#line 840
  if (change == -2) {
    {
#line 842
    off_left = 0;
#line 842
    off_right = off_left;
#line 842
    gl_shift = off_right;
#line 842
    gl_cnt = gl_shift;
#line 842
    gl_pos = gl_cnt;
#line 843
    gl_putc('\r');
#line 844
    gl_puts(prompt);
#line 845
    strcpy((char */* __restrict  */)(last_prompt), (char const   */* __restrict  */)prompt);
#line 846
    change = 0;
#line 847
    tmp = (*gl_strlen)(prompt);
#line 847
    gl_width = (int )((size_t )gl_termw - tmp);
    }
  } else {
    {
#line 849
    tmp___2 = strcmp((char const   *)prompt, (char const   *)(last_prompt));
    }
#line 849
    if (tmp___2 != 0) {
      {
#line 851
      tmp___0 = (*gl_strlen)(last_prompt);
#line 851
      l1 = (int )tmp___0;
#line 852
      tmp___1 = (*gl_strlen)(prompt);
#line 852
      l2 = (int )tmp___1;
#line 853
      gl_cnt = (gl_cnt + l1) - l2;
#line 854
      strcpy((char */* __restrict  */)(last_prompt), (char const   */* __restrict  */)prompt);
#line 855
      gl_putc('\r');
#line 856
      gl_puts(prompt);
#line 857
      gl_pos = gl_shift;
#line 858
      gl_width = gl_termw - l2;
#line 859
      change = 0;
      }
    }
  }
#line 861
  if (off_right) {
#line 861
    pad = gl_width - 1;
  } else {
#line 861
    pad = gl_cnt - gl_shift;
  }
#line 862
  backup = gl_pos - gl_shift;
#line 863
  if (change >= 0) {
    {
#line 865
    tmp___3 = strlen((char const   *)(gl_buf));
#line 865
    gl_cnt = (int )tmp___3;
    }
#line 866
    if (change > gl_cnt) {
#line 867
      change = gl_cnt;
    }
  }
#line 869
  if (cursor > gl_cnt) {
#line 871
    if (cursor != 1024) {
      {
#line 872
      gl_putc('\a');
      }
    }
#line 873
    cursor = gl_cnt;
  }
#line 875
  if (cursor < 0) {
    {
#line 877
    gl_putc('\a');
#line 878
    cursor = 0;
    }
  }
#line 880
  if (off_right) {
#line 881
    extra = 2;
  } else
#line 880
  if (off_left) {
#line 880
    if (cursor < (gl_shift + gl_width) - gl_scroll / 2) {
#line 881
      extra = 2;
    } else {
#line 883
      extra = 0;
    }
  } else {
#line 883
    extra = 0;
  }
#line 884
  new_shift = ((cursor + extra) + gl_scroll) - gl_width;
#line 885
  if (new_shift > 0) {
#line 887
    new_shift /= gl_scroll;
#line 888
    new_shift *= gl_scroll;
  } else {
#line 891
    new_shift = 0;
  }
#line 892
  if (new_shift != gl_shift) {
#line 894
    gl_shift = new_shift;
#line 895
    if (gl_shift) {
#line 895
      off_left = 1;
    } else {
#line 895
      off_left = 0;
    }
#line 896
    if (gl_cnt > (gl_shift + gl_width) - 1) {
#line 896
      off_right = 1;
    } else {
#line 896
      off_right = 0;
    }
#line 897
    left = gl_shift;
#line 898
    if (off_right) {
#line 898
      right = (gl_shift + gl_width) - 2;
    } else {
#line 898
      right = gl_cnt;
    }
#line 898
    new_right = right;
  } else
#line 900
  if (change >= 0) {
#line 902
    if (change < gl_shift + off_left) {
#line 904
      left = gl_shift;
    } else {
#line 908
      left = change;
#line 909
      backup = gl_pos - change;
    }
#line 911
    if (gl_cnt > (gl_shift + gl_width) - 1) {
#line 911
      off_right = 1;
    } else {
#line 911
      off_right = 0;
    }
#line 912
    if (off_right) {
#line 912
      right = (gl_shift + gl_width) - 2;
    } else {
#line 912
      right = gl_cnt;
    }
#line 913
    if (gl_extent) {
#line 913
      if (right > left + gl_extent) {
#line 913
        new_right = left + gl_extent;
      } else {
#line 913
        new_right = right;
      }
    } else {
#line 913
      new_right = right;
    }
  }
#line 916
  if (off_right) {
#line 916
    tmp___4 = gl_width - 1;
  } else {
#line 916
    tmp___4 = gl_cnt - gl_shift;
  }
#line 916
  pad -= tmp___4;
#line 917
  if (pad < 0) {
#line 917
    pad = 0;
  } else {
#line 917
    pad = pad;
  }
#line 918
  if (left <= right) {
#line 920
    i = 0;
    {
#line 920
    while (1) {
      while_continue: /* CIL Label */ ;
#line 920
      if (! (i < backup)) {
#line 920
        goto while_break;
      }
      {
#line 921
      gl_putc('\b');
#line 920
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 922
    if (left == gl_shift) {
#line 922
      if (off_left) {
        {
#line 924
        gl_putc('$');
#line 925
        left ++;
        }
      }
    }
#line 927
    i = left;
    {
#line 927
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 927
      if (! (i < new_right)) {
#line 927
        goto while_break___0;
      }
#line 928
      if (echo) {
        {
#line 930
        gl_putc((int )gl_buf[i]);
        }
      } else {
        {
#line 934
        gl_putc('*');
        }
      }
#line 927
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 936
    gl_pos = new_right;
#line 937
    if (off_right) {
#line 937
      if (new_right == right) {
        {
#line 939
        gl_putc('$');
#line 940
        gl_pos ++;
        }
      } else {
#line 937
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 944
      i = 0;
      {
#line 944
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 944
        if (! (i < pad)) {
#line 944
          goto while_break___1;
        }
        {
#line 945
        gl_putc(' ');
#line 944
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 946
      gl_pos += pad;
    }
  }
#line 949
  i = gl_pos - cursor;
#line 950
  if (i > 0) {
    {
#line 952
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 952
      tmp___5 = i;
#line 952
      i --;
#line 952
      if (! tmp___5) {
#line 952
        goto while_break___2;
      }
      {
#line 953
      gl_putc('\b');
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
#line 957
    i = gl_pos;
    {
#line 957
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 957
      if (! (i < cursor)) {
#line 957
        goto while_break___3;
      }
#line 958
      if (echo) {
        {
#line 960
        gl_putc((int )gl_buf[i]);
        }
      } else {
        {
#line 964
        gl_putc('*');
        }
      }
#line 957
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 967
  gl_pos = cursor;
#line 968
  return;
}
}
#line 970 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static int gl_tab(char *buf , int offset , int *loc ) 
{ 
  int i ;
  int count ;
  int len ;
  size_t tmp ;

  {
  {
#line 979
  tmp = strlen((char const   *)buf);
#line 979
  len = (int )tmp;
#line 980
  count = 8 - (offset + *loc) % 8;
#line 981
  i = len;
  }
  {
#line 981
  while (1) {
    while_continue: /* CIL Label */ ;
#line 981
    if (! (i >= *loc)) {
#line 981
      goto while_break;
    }
#line 982
    *(buf + (i + count)) = *(buf + i);
#line 981
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 983
  i = 0;
  {
#line 983
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 983
    if (! (i < count)) {
#line 983
      goto while_break___0;
    }
#line 984
    *(buf + (*loc + i)) = (char )' ';
#line 983
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 985
  i = *loc;
#line 986
  *loc = i + count;
#line 987
  return (i);
}
}
#line 992 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
void gl_strwidth(size_t (*func)(char * ) ) 
{ 


  {
#line 995
  if ((unsigned long )func != (unsigned long )((size_t (*)(char * ))0)) {
#line 997
    gl_strlen = (size_t (*)())func;
  }
#line 999
  return;
}
}
#line 1007 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static int hist_pos  =    0;
#line 1007 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static int hist_last  =    0;
#line 1008 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static char *hist_buf[100]  ;
#line 1010 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static void hist_init(void) 
{ 
  int i ;

  {
#line 1015
  hist_buf[0] = (char *)"";
#line 1016
  i = 1;
  {
#line 1016
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1016
    if (! (i < 100)) {
#line 1016
      goto while_break;
    }
#line 1017
    hist_buf[i] = (char *)0;
#line 1016
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1018
  return;
}
}
#line 1024 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static char *prev  =    (char *)0;
#line 1020 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
void gl_histadd(char *buf ) 
{ 
  char *p ;
  int len ;
  size_t tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 1025
  p = buf;
#line 1029
  if (gl_init_done < 0) {
    {
#line 1031
    hist_init();
#line 1032
    gl_init_done = 0;
    }
  }
  {
#line 1034
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1034
    if (! ((int )*p == 32)) {
#line 1034
      if (! ((int )*p == 9)) {
#line 1034
        if (! ((int )*p == 10)) {
#line 1034
          goto while_break;
        }
      }
    }
#line 1035
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1036
  if (*p) {
    {
#line 1038
    tmp = strlen((char const   *)buf);
#line 1038
    len = (int )tmp;
#line 1039
    tmp___0 = strchr((char const   *)p, '\n');
    }
#line 1039
    if (tmp___0) {
#line 1040
      len --;
    }
#line 1041
    if ((unsigned long )prev == (unsigned long )((char *)0)) {
#line 1041
      goto _L;
    } else {
      {
#line 1041
      tmp___1 = strlen((char const   *)prev);
      }
#line 1041
      if (tmp___1 != (size_t )len) {
#line 1041
        goto _L;
      } else {
        {
#line 1041
        tmp___2 = strncmp((char const   *)prev, (char const   *)buf, (size_t )len);
        }
#line 1041
        if (tmp___2 != 0) {
          _L: /* CIL Label */ 
          {
#line 1043
          hist_buf[hist_last] = hist_save(buf);
#line 1044
          prev = hist_buf[hist_last];
#line 1045
          hist_last = (hist_last + 1) % 100;
          }
#line 1046
          if (hist_buf[hist_last]) {
#line 1046
            if (*(hist_buf[hist_last])) {
              {
#line 1048
              free(hist_buf[hist_last]);
              }
            }
          }
#line 1050
          hist_buf[hist_last] = (char *)"";
        }
      }
    }
  }
#line 1053
  hist_pos = hist_last;
#line 1054
  return;
}
}
#line 1056 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static char *hist_prev(void) 
{ 
  char *p ;
  int next ;

  {
#line 1060
  p = (char *)0;
#line 1061
  next = ((hist_pos - 1) + 100) % 100;
#line 1063
  if ((unsigned long )hist_buf[hist_pos] != (unsigned long )((char *)0)) {
#line 1063
    if (next != hist_last) {
#line 1065
      hist_pos = next;
#line 1066
      p = hist_buf[hist_pos];
    }
  }
#line 1068
  if ((unsigned long )p == (unsigned long )((char *)0)) {
    {
#line 1070
    p = (char *)"";
#line 1071
    gl_putc('\a');
    }
  }
#line 1073
  return (p);
}
}
#line 1076 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static char *hist_next(void) 
{ 
  char *p ;

  {
#line 1080
  p = (char *)0;
#line 1082
  if (hist_pos != hist_last) {
#line 1084
    hist_pos = (hist_pos + 1) % 100;
#line 1085
    p = hist_buf[hist_pos];
  }
#line 1087
  if ((unsigned long )p == (unsigned long )((char *)0)) {
    {
#line 1089
    p = (char *)"";
#line 1090
    gl_putc('\a');
    }
  }
#line 1092
  return (p);
}
}
#line 1095 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static char *hist_save(char *p ) 
{ 
  char *s___0 ;
  int len ;
  size_t tmp ;
  char *nl ;
  char *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 1100
  s___0 = (char *)0;
#line 1101
  tmp = strlen((char const   *)p);
#line 1101
  len = (int )tmp;
#line 1102
  tmp___0 = strchr((char const   *)p, '\n');
#line 1102
  nl = tmp___0;
  }
#line 1104
  if (nl) {
    {
#line 1106
    tmp___1 = malloc(len);
#line 1106
    s___0 = (char *)tmp___1;
    }
#line 1106
    if ((unsigned long )s___0 != (unsigned long )((char *)0)) {
      {
#line 1108
      strncpy((char */* __restrict  */)s___0, (char const   */* __restrict  */)p,
              (size_t )(len - 1));
#line 1109
      *(s___0 + (len - 1)) = (char)0;
      }
    }
  } else {
    {
#line 1114
    tmp___2 = malloc(len + 1);
#line 1114
    s___0 = (char *)tmp___2;
    }
#line 1114
    if ((unsigned long )s___0 != (unsigned long )((char *)0)) {
      {
#line 1116
      strcpy((char */* __restrict  */)s___0, (char const   */* __restrict  */)p);
      }
    }
  }
#line 1119
  if ((unsigned long )s___0 == (unsigned long )((char *)0)) {
    {
#line 1120
    gl_error((char *)"\n*** Error: hist_save() failed on malloc\n");
    }
  }
#line 1121
  return (s___0);
}
}
#line 1126 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static char search_prompt[101]  ;
#line 1127 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static char search_string[100]  ;
#line 1128 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static int search_pos  =    0;
#line 1129 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static int search_forw_flg  =    0;
#line 1130 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static int search_last  =    0;
#line 1132 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static void search_update(int c ) 
{ 


  {
#line 1136
  if (c == 0) {
#line 1138
    search_pos = 0;
#line 1139
    search_string[0] = (char)0;
#line 1140
    search_prompt[0] = (char )'?';
#line 1141
    search_prompt[1] = (char )' ';
#line 1142
    search_prompt[2] = (char)0;
  } else
#line 1144
  if (c > 0) {
#line 1146
    search_string[search_pos] = (char )c;
#line 1147
    search_string[search_pos + 1] = (char)0;
#line 1148
    search_prompt[search_pos] = (char )c;
#line 1149
    search_prompt[search_pos + 1] = (char )'?';
#line 1150
    search_prompt[search_pos + 2] = (char )' ';
#line 1151
    search_prompt[search_pos + 3] = (char)0;
#line 1152
    search_pos ++;
  } else
#line 1156
  if (search_pos > 0) {
#line 1158
    search_pos --;
#line 1159
    search_string[search_pos] = (char)0;
#line 1160
    search_prompt[search_pos] = (char )'?';
#line 1161
    search_prompt[search_pos + 1] = (char )' ';
#line 1162
    search_prompt[search_pos + 2] = (char)0;
  } else {
    {
#line 1166
    gl_putc('\a');
#line 1167
    hist_pos = hist_last;
    }
  }
#line 1170
  return;
}
}
#line 1172 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static void search_addchar(int c ) 
{ 
  char *loc ;

  {
  {
#line 1178
  search_update(c);
  }
#line 1179
  if (c < 0) {
#line 1181
    if (search_pos > 0) {
#line 1183
      hist_pos = search_last;
    } else {
#line 1187
      gl_buf[0] = (char)0;
#line 1188
      hist_pos = hist_last;
    }
    {
#line 1190
    strcpy((char */* __restrict  */)(gl_buf), (char const   */* __restrict  */)hist_buf[hist_pos]);
    }
  }
  {
#line 1192
  loc = strstr((char const   *)(gl_buf), (char const   *)(search_string));
  }
#line 1192
  if ((unsigned long )loc != (unsigned long )((char *)0)) {
    {
#line 1194
    gl_fixup(search_prompt, 0, (int )(loc - gl_buf));
    }
  } else
#line 1196
  if (search_pos > 0) {
#line 1198
    if (search_forw_flg) {
      {
#line 1200
      search_forw(0);
      }
    } else {
      {
#line 1204
      search_back(0);
      }
    }
  } else {
    {
#line 1209
    gl_fixup(search_prompt, 0, 0);
    }
  }
#line 1211
  return;
}
}
#line 1213 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static void search_term(void) 
{ 


  {
#line 1216
  gl_search_mode = 0;
#line 1217
  if ((int )gl_buf[0] == 0) {
#line 1218
    hist_pos = hist_last;
  }
#line 1219
  if (gl_in_hook) {
    {
#line 1220
    (*gl_in_hook)(gl_buf);
    }
  }
  {
#line 1221
  gl_fixup(gl_prompt, 0, gl_pos);
  }
#line 1222
  return;
}
}
#line 1224 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static void search_back(int new_search ) 
{ 
  int found ;
  char *p ;
  char *loc ;

  {
#line 1228
  found = 0;
#line 1231
  search_forw_flg = 0;
#line 1232
  if (gl_search_mode == 0) {
    {
#line 1234
    hist_pos = hist_last;
#line 1234
    search_last = hist_pos;
#line 1235
    search_update(0);
#line 1236
    gl_search_mode = 1;
#line 1237
    gl_buf[0] = (char)0;
#line 1238
    gl_fixup(search_prompt, 0, 0);
    }
  } else
#line 1240
  if (search_pos > 0) {
    {
#line 1242
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1242
      if (! (! found)) {
#line 1242
        goto while_break;
      }
      {
#line 1244
      p = hist_prev();
      }
#line 1245
      if ((int )*p == 0) {
        {
#line 1247
        gl_buf[0] = (char)0;
#line 1248
        gl_fixup(search_prompt, 0, 0);
#line 1249
        found = 1;
        }
      } else {
        {
#line 1251
        loc = strstr((char const   *)p, (char const   *)(search_string));
        }
#line 1251
        if ((unsigned long )loc != (unsigned long )((char *)0)) {
          {
#line 1253
          strcpy((char */* __restrict  */)(gl_buf), (char const   */* __restrict  */)p);
#line 1254
          gl_fixup(search_prompt, 0, (int )(loc - p));
          }
#line 1255
          if (new_search) {
#line 1256
            search_last = hist_pos;
          }
#line 1257
          found = 1;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1263
    gl_putc('\a');
    }
  }
#line 1265
  return;
}
}
#line 1267 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
static void search_forw(int new_search ) 
{ 
  int found ;
  char *p ;
  char *loc ;

  {
#line 1271
  found = 0;
#line 1274
  search_forw_flg = 1;
#line 1275
  if (gl_search_mode == 0) {
    {
#line 1277
    hist_pos = hist_last;
#line 1277
    search_last = hist_pos;
#line 1278
    search_update(0);
#line 1279
    gl_search_mode = 1;
#line 1280
    gl_buf[0] = (char)0;
#line 1281
    gl_fixup(search_prompt, 0, 0);
    }
  } else
#line 1283
  if (search_pos > 0) {
    {
#line 1285
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1285
      if (! (! found)) {
#line 1285
        goto while_break;
      }
      {
#line 1287
      p = hist_next();
      }
#line 1288
      if ((int )*p == 0) {
        {
#line 1290
        gl_buf[0] = (char)0;
#line 1291
        gl_fixup(search_prompt, 0, 0);
#line 1292
        found = 1;
        }
      } else {
        {
#line 1294
        loc = strstr((char const   *)p, (char const   *)(search_string));
        }
#line 1294
        if ((unsigned long )loc != (unsigned long )((char *)0)) {
          {
#line 1296
          strcpy((char */* __restrict  */)(gl_buf), (char const   */* __restrict  */)p);
#line 1297
          gl_fixup(search_prompt, 0, (int )(loc - p));
          }
#line 1298
          if (new_search) {
#line 1299
            search_last = hist_pos;
          }
#line 1300
          found = 1;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1306
    gl_putc('\a');
    }
  }
#line 1308
  return;
}
}
#line 1312 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/getline/getline.c"
char *getlinenoecho(char *prompt ) 
{ 
  char *p ;

  {
  {
#line 1318
  echo = 0;
#line 1319
  p = my_getline(prompt);
#line 1320
  echo = 1;
  }
#line 1322
  return (p);
}
}
#line 86 "../include/Garmin.h"
void datumParams(short datum , double *a , double *es ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/gridutils.c"
void datumParams(short datum , double *a , double *es ) 
{ 
  double f ;

  {
#line 43
  f = 1.0 / (double )gEllipsoid[gDatum[datum].ellipsoid].invf;
#line 45
  *es = (double )2 * f - f * f;
#line 46
  *a = (double )gEllipsoid[gDatum[datum].ellipsoid].a;
#line 47
  return;
}
}
#line 57 "../include/Garmin.h"
void DegToUTM(double lat , double lon , char *zone , double *x , double *y ) ;
#line 58
void UTMtoDeg(short zone , short southernHemisphere , double x , double y , double *lat ,
              double *lon ) ;
#line 70
void toUPS(double lat , double lon , double *x , double *y ) ;
#line 71
void fromUPS(short southernHemisphere , double x , double y , double *lat , double *lon ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/utm.c"
static double const   lat0___0  =    (double const   )0.0;
#line 35 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/utm.c"
static double const   k0___0  =    (double const   )0.9996;
#line 41 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/utm.c"
void DegToUTM(double lat , double lon , char *zone , double *x , double *y ) 
{ 
  char nz ;
  double lon0___4 ;
  double tmp ;

  {
#line 47
  if (lat >= - 80.0) {
#line 47
    if (lat <= 84.0) {
#line 49
      nz = (char )(67 + (int )((short )(lat + 80.0)) / 8);
#line 52
      if ((int )nz > 72) {
#line 53
        nz = (char )((int )nz + 1);
      }
#line 54
      if ((int )nz > 78) {
#line 55
        nz = (char )((int )nz + 1);
      }
      {
#line 58
      tmp = floor(lon / 6.0);
#line 58
      lon0___4 = 6.0 * tmp + 3.0;
#line 59
      sprintf((char */* __restrict  */)zone, (char const   */* __restrict  */)"%02d\t%c",
              ((int )((short )lon0___4) + 183) / 6, (int )nz);
#line 61
      toTM(lat, lon, (double )lat0___0, lon0___4, (double )k0___0, x, y);
#line 64
      *x += 500000.0;
      }
#line 67
      if (lat < 0.0) {
#line 68
        *y = 10000000.0 + *y;
      }
    } else {
#line 47
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 72
    strcpy((char */* __restrict  */)zone, (char const   */* __restrict  */)"00\tx");
    }
#line 73
    if (lat > 0.0) {
#line 74
      if (lon < 0.0) {
#line 75
        *(zone + 3) = (char )'Y';
      } else {
#line 77
        *(zone + 3) = (char )'Z';
      }
    } else
#line 78
    if (lon < 0.0) {
#line 79
      *(zone + 3) = (char )'A';
    } else {
#line 81
      *(zone + 3) = (char )'B';
    }
    {
#line 82
    toUPS(lat, lon, x, y);
    }
  }
#line 84
  return;
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/utm.c"
void UTMtoDeg(short zone , short southernHemisphere , double x , double y , double *lat ,
              double *lon ) 
{ 
  double lon0___4 ;

  {
#line 96
  if ((int )zone != 0) {
#line 98
    lon0___4 = (double )(-183 + 6 * (int )zone);
#line 102
    if (southernHemisphere) {
#line 103
      y = 1.0e7 - y;
    }
    {
#line 104
    x -= 500000.0;
#line 106
    fromTM(x, y, (double )lat0___0, lon0___4, (double )k0___0, lat, lon);
    }
  } else {
    {
#line 109
    fromUPS(southernHemisphere, x, y, lat, lon);
    }
  }
  {
#line 110
  *lat = fabs(*lat);
  }
#line 111
  if (southernHemisphere) {
#line 112
    *lat = - *lat;
  }
#line 114
  return;
}
}
#line 775 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 100 "../include/Garmin.h"
char *toDMS(double a ) ;
#line 101
char *toDM(double a ) ;
#line 102
double DMStoDegrees(char *dms___0 ) ;
#line 103
double DMtoDegrees(char *dms___0 ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/dms.c"
static char dms[20]  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/dms.c"
char *toDMS(double a ) 
{ 
  short neg ;
  double d ;
  double m ;
  double s___0 ;

  {
#line 39
  neg = (short)0;
#line 43
  if (a < 0.0) {
#line 45
    a = - a;
#line 46
    neg = (short)1;
  }
#line 48
  d = (double )((int )a);
#line 49
  a = (a - d) * 60.0;
#line 50
  m = (double )((int )a);
#line 51
  s___0 = (a - m) * 60.0;
#line 53
  if (s___0 > 59.5) {
#line 55
    s___0 = 0.0;
#line 56
    m += 1.0;
  }
#line 58
  if (m > 59.5) {
#line 60
    m = 0.0;
#line 61
    d += 1.0;
  }
#line 63
  if (neg) {
#line 64
    d = - d;
  }
  {
#line 66
  sprintf((char */* __restrict  */)(dms), (char const   */* __restrict  */)"%.0f\260%02.0f\'%04.1f\"",
          d, m, s___0);
  }
#line 67
  return (dms);
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/dms.c"
double DMStoDegrees(char *dms___0 ) 
{ 
  int d ;
  int m ;
  double s___0 ;
  int tmp ;

  {
  {
#line 80
  sscanf((char const   */* __restrict  */)dms___0, (char const   */* __restrict  */)"%d%d%lf",
         & d, & m, & s___0);
#line 81
  tmp = abs(d);
#line 81
  s___0 = (double )tmp + ((double )m + s___0 / 60.0) / 60.0;
  }
#line 83
  if (d >= 0) {
#line 84
    return (s___0);
  } else {
#line 86
    return (- s___0);
  }
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/dms.c"
static char dm[13]  ;
#line 93 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/dms.c"
char *toDM(double a ) 
{ 
  short neg ;
  double d ;
  double m ;

  {
#line 96
  neg = (short)0;
#line 100
  if (a < 0.0) {
#line 102
    a = - a;
#line 103
    neg = (short)1;
  }
#line 106
  d = (double )((int )a);
#line 107
  m = (a - d) * 60.0;
#line 109
  if (m > 59.5) {
#line 111
    m = 0.0;
#line 112
    d += 1.0;
  }
#line 114
  if (neg) {
#line 115
    d = - d;
  }
  {
#line 117
  sprintf((char */* __restrict  */)(dm), (char const   */* __restrict  */)"%.0f\260%06.3f\'",
          d, m);
  }
#line 118
  return (dm);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/dms.c"
double DMtoDegrees(char *dms___0 ) 
{ 
  int d ;
  double m ;
  int tmp ;

  {
  {
#line 131
  sscanf((char const   */* __restrict  */)dms___0, (char const   */* __restrict  */)"%d%lf",
         & d, & m);
#line 132
  tmp = abs(d);
#line 132
  m = (double )tmp + m / 60.0;
  }
#line 134
  if (d >= 0) {
#line 135
    return (m);
  } else {
#line 137
    return (- m);
  }
}
}
#line 83 "../include/Garmin.h"
void GKKtoDeg(double x , double y , double *lat , double *lon ) ;
#line 84
void DegToGKK(double lat , double lon , double *x , double *y ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/gkk.c"
static double const   lat0___1  =    (double const   )0.0;
#line 61 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/gkk.c"
static double lon0___0  =    0.0;
#line 62 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/gkk.c"
static double const   k0___1  =    (double const   )1.0;
#line 68 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/gkk.c"
void DegToGKK(double lat , double lon , double *x , double *y ) 
{ 
  int zonenbr ;
  double tmp ;

  {
#line 76
  if (lat < 0.0) {
#line 78
    *x = 0.0;
#line 79
    *y = 0.0;
#line 80
    return;
  } else
#line 76
  if (lon < 0.0) {
#line 78
    *x = 0.0;
#line 79
    *y = 0.0;
#line 80
    return;
  } else
#line 76
  if (lon > 16.5) {
#line 78
    *x = 0.0;
#line 79
    *y = 0.0;
#line 80
    return;
  }
  {
#line 84
  tmp = floor(lon / 3.0 + 0.5);
#line 84
  zonenbr = (int )tmp;
#line 87
  lon0___0 = (double )zonenbr * 3.0;
#line 90
  toTM(lat, lon, (double )lat0___1, lon0___0, (double )k0___1, x, y);
#line 93
  *x += (double )zonenbr * 1000000.0 + 500000.0;
  }
#line 94
  return;
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/gkk.c"
void GKKtoDeg(double x , double y , double *lat , double *lon ) 
{ 
  double tmp ;
  double tmp___0 ;

  {
#line 105
  if (x > 5999999.0) {
#line 107
    *lat = (double )0;
#line 108
    *lon = (double )0;
#line 109
    return;
  } else
#line 105
  if (x < 0.0) {
#line 107
    *lat = (double )0;
#line 108
    *lon = (double )0;
#line 109
    return;
  } else
#line 105
  if (y < 0.0) {
#line 107
    *lat = (double )0;
#line 108
    *lon = (double )0;
#line 109
    return;
  } else
#line 105
  if (y > 9999999.0) {
#line 107
    *lat = (double )0;
#line 108
    *lon = (double )0;
#line 109
    return;
  }
  {
#line 113
  tmp = floor(x / 1000000.0);
#line 113
  lon0___0 = tmp * 3.0;
#line 116
  tmp___0 = floor(x / 1000000.0);
#line 116
  x -= tmp___0 * 1000000.0 + 500000.0;
#line 119
  fromTM(x, y, (double )lat0___1, lon0___0, (double )k0___1, lat, lon);
  }
#line 120
  return;
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 144 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 285 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 289
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 264
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 42 "../include/Garmin.h"
short getGPSMessage(void) ;
#line 43
void sendGPSMessage(BYTE *message___0 , short bytes ) ;
#line 44
int getGPSack(void) ;
#line 45
int naks ;
#line 48
void sendGPSInfo(FILE *ifile , short type ) ;
#line 50
int getGPSVersion(char **string___0 ) ;
#line 55
long dt2secs(char *dt___0 , int offset ) ;
#line 62
void KKJtoDeg(short zone , short southernHemisphere , double x , double y , double *lat ,
              double *lon ) ;
#line 78
void SEGtoDeg(double x , double y , double *lat , double *lon ) ;
#line 81
void ITMtoDeg(char *zone , double x , double y , double *lat , double *lon ) ;
#line 88
short GetLine(FILE *refNum___0 , char *line , short init ) ;
#line 94
int CheckGPS(void) ;
#line 95
void NotResponding(void) ;
#line 96
int serialOpen(enum PROTOCOL p ) ;
#line 97
void serialClose(void) ;
#line 98
void Error(char *txt ) ;
#line 133
BYTE almt[5] ;
#line 133
BYTE rtet[5] ;
#line 133
BYTE trkt[5] ;
#line 133
BYTE wptt[5] ;
#line 135
BYTE off1[5] ;
#line 145
enum FILE_FORMAT file_format ;
#line 146
int debugging ;
#line 147
int verbose ;
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/sendgpsinfo.c"
char *protocols ;
#line 47 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/sendgpsinfo.c"
static char fileData[256]  ;
#line 48 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/sendgpsinfo.c"
static BYTE newTrack  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/sendgpsinfo.c"
static int track_count  ;
#line 50 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/sendgpsinfo.c"
static BYTE message[520]  ;
#line 51 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/sendgpsinfo.c"
struct PREFS gFilePrefs  ;
#line 54
void mxmap_route(char *Datastring , int mrec ) ;
#line 55
char *mystrsep2(char **stringp , char *delim ) ;
#line 56
void strconvert(char *p ) ;
#line 59
static short records(FILE *ifile , short type ) ;
#line 60
static short doWaypoint(short type ) ;
#line 61
static short doTrack(void) ;
#line 62
static short doRoute(void) ;
#line 63
static short doAlmanac(void) ;
#line 64
static short sendRecords(short recs ) ;
#line 65
static void copyNumber(BYTE *p , long n ) ;
#line 66
static void copyFloat(BYTE *p , double d ) ;
#line 67
static char *field(char *str , short n ) ;
#line 68
static void cpystr(BYTE *p , char *q , short n ) ;
#line 69
static short getFileFormat(char *first , char *second ) ;
#line 70
static void cleanupDMS(char *s___0 ) ;
#line 73 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/sendgpsinfo.c"
struct __anonstruct_column_86 column  ;
#line 88 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/sendgpsinfo.c"
long sendGPSOff(void) 
{ 
  short err ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 96
  tmp = CheckGPS();
  }
#line 96
  if (! tmp) {
    {
#line 97
    NotResponding();
    }
  }
  {
#line 100
  tmp___0 = serialOpen((enum PROTOCOL )1);
#line 100
  err = (short )tmp___0;
  }
#line 100
  if ((int )err != 0) {
    {
#line 102
    sprintf((char */* __restrict  */)(gMessageStr), (char const   */* __restrict  */)"The port initialization of %s has failed.",
            gPrefs.Device);
#line 104
    Error(gMessageStr);
    }
#line 105
    return (99L);
  }
  {
#line 111
  sendGPSMessage(off1, (short)4);
#line 114
  serialClose();
#line 116
  printf((char const   */* __restrict  */)"GPS turned off successfully\n");
  }
#line 118
  return (0L);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/sendgpsinfo.c"
void sendGPSInfo(FILE *ifile , short type ) 
{ 
  short recs ;
  short processed ;
  short err ;
  short result ;
  char *rType ;
  BYTE *term ;
  char secondLine[256] ;
  int junk ;
  char *junk_str ;
  int tmp ;
  int tmp___0 ;
  short tmp___1 ;
  short tmp___2 ;
  short tmp___3 ;
  short tmp___4 ;
  short tmp___5 ;
  short tmp___6 ;
  short tmp___7 ;

  {
  {
#line 130
  processed = (short)0;
#line 131
  result = (short)1;
#line 139
  tmp = CheckGPS();
  }
#line 139
  if (! tmp) {
    {
#line 140
    NotResponding();
    }
  }
  {
#line 142
  junk = getGPSVersion(& junk_str);
#line 145
  tmp___0 = serialOpen((enum PROTOCOL )1);
#line 145
  err = (short )tmp___0;
  }
#line 145
  if ((int )err != 0) {
    {
#line 147
    sprintf((char */* __restrict  */)(gMessageStr), (char const   */* __restrict  */)"The port initialization of %s has failed.",
            gPrefs.Device);
#line 149
    Error(gMessageStr);
    }
#line 150
    return;
  }
  {
#line 153
  recs = records(ifile, type);
#line 154
  recs = (short )((int )recs - 1);
#line 157
  tmp___1 = sendRecords(recs);
  }
#line 157
  if ((int )tmp___1 == 0) {
    {
#line 159
    Error((char *)"GPS did not respond to send-request packet.\n");
    }
#line 160
    return;
  }
  {
#line 164
  rewind(ifile);
#line 165
  GetLine(ifile, fileData, (short)1);
#line 166
  GetLine(ifile, secondLine, (short)1);
#line 167
  rewind(ifile);
#line 169
  tmp___2 = getFileFormat(fileData, secondLine);
  }
#line 169
  if (! tmp___2) {
    {
#line 171
    Error((char *)"The file header format is incorrect.");
    }
#line 172
    return;
  }
  {
#line 175
  naks = 0;
#line 176
  InitBarGraph();
  }
  {
#line 196
  if ((int )type == 1) {
#line 196
    goto case_1;
  }
#line 247
  if ((int )type == 2) {
#line 247
    goto case_2;
  }
#line 267
  if ((int )type == 3) {
#line 267
    goto case_3;
  }
#line 181
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 183
  rType = (char *)"almanac";
#line 184
  term = almt;
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 185
    tmp___3 = GetLine(ifile, fileData, (short)0);
    }
#line 185
    if (tmp___3) {
#line 185
      if ((int )processed < (int )recs) {
#line 185
        if (! result) {
#line 185
          goto while_break;
        }
      } else {
#line 185
        goto while_break;
      }
    } else {
#line 185
      goto while_break;
    }
#line 188
    if ((int )fileData[0] == 65) {
      {
#line 190
      result = doAlmanac();
#line 191
      processed = (short )((int )processed + 1);
#line 191
      SetBarGraph((double )processed / (double )recs);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 194
  goto switch_break;
  case_1: /* CIL Label */ 
#line 197
  rType = (char *)"routes";
#line 198
  term = rtet;
#line 200
  if ((unsigned int )file_format != 3334U) {
    {
#line 202
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 202
      tmp___4 = GetLine(ifile, fileData, (short)0);
      }
#line 202
      if (tmp___4) {
#line 202
        if ((int )processed < (int )recs) {
#line 202
          if (! result) {
#line 202
            goto while_break___0;
          }
        } else {
#line 202
          goto while_break___0;
        }
      } else {
#line 202
        goto while_break___0;
      }
#line 205
      if ((int )fileData[0] == 82) {
        {
#line 207
        result = doRoute();
#line 208
        processed = (short )((int )processed + 1);
        }
      }
#line 210
      if ((int )fileData[0] == 87) {
        {
#line 212
        result = doWaypoint((short)1);
#line 213
        processed = (short )((int )processed + 1);
        }
      }
      {
#line 215
      SetBarGraph((double )processed / (double )recs);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 217
    goto switch_break;
  } else {
    {
#line 225
    sprintf((char */* __restrict  */)(fileData), (char const   */* __restrict  */)"R\t0\tMAYKO MXMAP\n");
#line 226
    result = doRoute();
    }
    {
#line 228
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 228
      tmp___5 = GetLine(ifile, fileData, (short)0);
      }
#line 228
      if (tmp___5) {
#line 228
        if (! result) {
#line 228
          goto while_break___1;
        }
      } else {
#line 228
        goto while_break___1;
      }
#line 230
      if ((int )fileData[0] == 0) {
#line 231
        goto while_break___1;
      }
      {
#line 232
      mxmap_route(fileData, (int )processed);
      }
#line 235
      if ((int )fileData[0] == 87) {
        {
#line 237
        result = doWaypoint((short)1);
#line 238
        processed = (short )((int )processed + 1);
        }
      }
      {
#line 240
      fileData[0] = (char )'\000';
#line 241
      SetBarGraph((double )processed / (double )recs);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 243
    recs = processed;
#line 244
    goto switch_break;
  }
  case_2: /* CIL Label */ 
#line 248
  rType = (char *)"track";
#line 249
  term = trkt;
#line 250
  newTrack = (BYTE )1;
#line 250
  track_count = (int )newTrack;
  {
#line 251
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 251
    tmp___6 = GetLine(ifile, fileData, (short)0);
    }
#line 251
    if (tmp___6) {
#line 251
      if ((int )processed < (int )recs) {
#line 251
        if (! result) {
#line 251
          goto while_break___2;
        }
      } else {
#line 251
        goto while_break___2;
      }
    } else {
#line 251
      goto while_break___2;
    }
#line 254
    if ((int )fileData[0] == 84) {
      {
#line 256
      result = doTrack();
#line 257
      processed = (short )((int )processed + 1);
#line 257
      SetBarGraph((double )processed / (double )recs);
      }
    } else {
#line 261
      newTrack = (BYTE )1;
#line 262
      track_count ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 265
  goto switch_break;
  case_3: /* CIL Label */ 
#line 268
  rType = (char *)"waypoint";
#line 269
  term = wptt;
  {
#line 270
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 270
    tmp___7 = GetLine(ifile, fileData, (short)0);
    }
#line 270
    if (tmp___7) {
#line 270
      if ((int )processed < (int )recs) {
#line 270
        if (! result) {
#line 270
          goto while_break___3;
        }
      } else {
#line 270
        goto while_break___3;
      }
    } else {
#line 270
      goto while_break___3;
    }
#line 273
    if ((int )fileData[0] == 87) {
      {
#line 275
      result = doWaypoint((short)3);
#line 276
      processed = (short )((int )processed + 1);
#line 276
      SetBarGraph((double )processed / (double )recs);
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 279
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 283
  CloseBarGraph();
  }
#line 286
  if (result) {
    {
#line 288
    sendGPSMessage(term, (short)4);
#line 291
    getGPSMessage();
#line 294
    sprintf((char */* __restrict  */)(gMessageStr), (char const   */* __restrict  */)"%d %s packets were successfully transferred to the GPS receiver.",
            (int )recs - naks, rType);
#line 297
    Message(gMessageStr);
    }
#line 298
    if (naks) {
      {
#line 300
      sprintf((char */* __restrict  */)(gMessageStr), (char const   */* __restrict  */)"%d packets were rejected.\n",
              naks);
#line 302
      Error(gMessageStr);
      }
    }
#line 304
    if (verbose) {
#line 304
      if (track_count) {
        {
#line 305
        printf((char const   */* __restrict  */)"%d tracks were transferred.\n", track_count);
        }
      }
    }
  }
  {
#line 309
  serialClose();
  }
#line 310
  return;
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/sendgpsinfo.c"
static char *month[12]  = 
#line 321
  {      (char *)"JAN",      (char *)"FEB",      (char *)"MAR",      (char *)"APR", 
        (char *)"MAY",      (char *)"JUN",      (char *)"JUL",      (char *)"AUG", 
        (char *)"SEP",      (char *)"OCT",      (char *)"NOV",      (char *)"DEC"};
#line 318 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/sendgpsinfo.c"
void mxmap_route(char *Datastring , int mrec ) 
{ 
  int i ;
  char *p ;
  char *r ;
  char xname[80] ;
  char xlat[10] ;
  char xlon[10] ;
  time_t t ;
  struct tm *ts ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 331
  time(& t);
#line 332
  ts = localtime((time_t const   *)(& t));
#line 334
  sprintf((char */* __restrict  */)(xname), (char const   */* __restrict  */)"MX%02d",
          mrec + 1);
#line 335
  p = Datastring;
#line 336
  r = mystrsep2(& p, (char *)",\n");
  }
#line 337
  if ((unsigned long )r != (unsigned long )((void *)0)) {
    {
#line 339
    strcpy((char */* __restrict  */)(xname), (char const   */* __restrict  */)r);
#line 340
    strconvert(xname);
    }
  }
  {
#line 343
  r = mystrsep2(& p, (char *)",\n");
#line 344
  strcpy((char */* __restrict  */)(xlat), (char const   */* __restrict  */)r);
#line 345
  r = mystrsep2(& p, (char *)",\n");
#line 346
  strcpy((char */* __restrict  */)(xlon), (char const   */* __restrict  */)r);
#line 351
  sprintf((char */* __restrict  */)Datastring, (char const   */* __restrict  */)"W\t%s\t",
          xname);
#line 360
  tmp = strlen((char const   *)Datastring);
#line 360
  i = (int )tmp;
#line 361
  sprintf((char */* __restrict  */)(Datastring + i), (char const   */* __restrict  */)"%2d-%s-%02d %02d:%02d\t",
          ts->tm_mday, month[ts->tm_mon], ts->tm_year, ts->tm_hour, ts->tm_min);
#line 365
  tmp___0 = strlen((char const   *)Datastring);
#line 365
  i = (int )tmp___0;
#line 366
  sprintf((char */* __restrict  */)(Datastring + i), (char const   */* __restrict  */)"12/31/1989 -8:00:00\t%s\t%s\n",
          xlat, xlon);
  }
#line 368
  return;
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/sendgpsinfo.c"
char *mystrsep2(char **stringp , char *delim ) 
{ 
  char *begin ;
  char *end ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 375
  tmp = strspn((char const   *)*stringp, (char const   *)delim);
#line 375
  begin = *stringp + tmp;
#line 376
  tmp___0 = strcspn((char const   *)*stringp, (char const   *)delim);
#line 376
  end = *stringp + tmp___0;
  }
#line 378
  if ((unsigned long )end == (unsigned long )*stringp) {
#line 379
    begin = (char *)((void *)0);
  }
#line 381
  if ((int )*end != 0) {
#line 382
    tmp___1 = end;
#line 382
    end ++;
#line 382
    *tmp___1 = (char )'\000';
  }
#line 383
  *stringp = end;
#line 385
  return (begin);
}
}
#line 388 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/sendgpsinfo.c"
void strconvert(char *p ) 
{ 
  char *dest ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 393
  dest = p;
  {
#line 394
  while (1) {
    while_continue: /* CIL Label */ ;
#line 394
    if (! *p) {
#line 394
      goto while_break;
    }
    {
#line 396
    tmp___1 = __ctype_b_loc();
    }
#line 396
    if (! ((int const   )*(*tmp___1 + (int )*p) & 8192)) {
      {
#line 398
      tmp___0 = __ctype_b_loc();
      }
#line 398
      if ((int const   )*(*tmp___0 + (int )*p) & 512) {
        {
#line 399
        tmp = toupper((int )*p);
#line 399
        *dest = (char )tmp;
        }
      } else {
#line 401
        *dest = *p;
      }
#line 402
      dest ++;
    }
#line 404
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 406
  *dest = (char )'\000';
#line 408
  return;
}
}
#line 479 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/sendgpsinfo.c"
static short doWaypoint(short type ) 
{ 
  double x ;
  double y ;
  short zone ;
  char finzone[5] ;
  char bgzone[5] ;
  char nsZone ;
  int pos ;
  char *s___0 ;
  struct __anonstruct_pkt_92 pkt ;
  char empty[1] ;
  char *tmp ;
  char date[20] ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  char *tmp___22 ;
  D100_Wpt_Type *d ;
  long tmp___23 ;
  long tmp___24 ;
  D101_Wpt_Type *d___0 ;
  long tmp___25 ;
  long tmp___26 ;
  D102_Wpt_Type *d___1 ;
  long tmp___27 ;
  long tmp___28 ;
  D103_Wpt_Type *d___2 ;
  long tmp___29 ;
  long tmp___30 ;
  D104_Wpt_Type *d___3 ;
  long tmp___31 ;
  long tmp___32 ;
  D105_Wpt_Type *d___4 ;
  long tmp___33 ;
  long tmp___34 ;
  D106_Wpt_Type *d___5 ;
  long tmp___35 ;
  long tmp___36 ;
  D107_Wpt_Type *d___6 ;
  long tmp___37 ;
  long tmp___38 ;
  D108_Wpt_Type *d___7 ;
  long tmp___39 ;
  long tmp___40 ;
  size_t tmp___41 ;
  size_t tmp___42 ;
  D109_Wpt_Type *d___8 ;
  long tmp___43 ;
  long tmp___44 ;
  size_t tmp___45 ;
  size_t tmp___46 ;
  D110_Wpt_Type *d___9 ;
  long tmp___47 ;
  long tmp___48 ;
  size_t tmp___49 ;
  size_t tmp___50 ;
  char *tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;
  char *tmp___54 ;
  char *tmp___55 ;
  char *tmp___56 ;
  char *tmp___57 ;
  char *tmp___58 ;
  char *tmp___59 ;
  char *tmp___60 ;
  char *tmp___61 ;
  int tmp___62 ;

  {
#line 511
  empty[0] = (char )'\000';
#line 513
  pkt.has.comment = 0U;
#line 513
  pkt.has.name = pkt.has.comment;
#line 513
  pkt.has.seconds = pkt.has.name;
#line 513
  pkt.has.altitude = pkt.has.seconds;
#line 518
  pkt.altitude = 1.01e24;
#line 519
  pkt.seconds = (long )(~ 0);
#line 520
  pkt.name = empty;
#line 520
  pkt.comment = pkt.name;
#line 522
  if (column.type >= 0) {
    {
#line 523
    tmp = field(fileData, (short )column.type);
#line 523
    pkt.type = *tmp;
    }
  }
#line 525
  if (column.date >= 0) {
    {
#line 528
    tmp___0 = field(fileData, (short )column.date);
#line 528
    strncpy((char */* __restrict  */)(date), (char const   */* __restrict  */)tmp___0,
            (size_t )19);
#line 529
    date[19] = (char)0;
#line 530
    pkt.seconds = dt2secs(date, (int )gFilePrefs.offset);
#line 531
    pkt.has.seconds = 1U;
    }
  }
#line 533
  if (column.altitude >= 0) {
    {
#line 533
    tmp___2 = field(fileData, (short )column.altitude);
#line 533
    tmp___3 = strstr((char const   *)tmp___2, "unknown");
    }
#line 533
    if (! tmp___3) {
      {
#line 536
      tmp___1 = field(fileData, (short )column.altitude);
#line 536
      pkt.altitude = atof((char const   *)tmp___1);
#line 537
      pkt.has.altitude = 1U;
      }
    }
  }
#line 540
  if (column.name >= 0) {
    {
#line 542
    pkt.name = field(fileData, (short )column.name);
#line 543
    pkt.has.name = 1U;
    }
  }
#line 546
  if (column.comment >= 0) {
    {
#line 548
    pkt.comment = field(fileData, (short )column.comment);
#line 549
    pkt.has.comment = 1U;
    }
  }
#line 552
  pos = column.position;
  {
#line 557
  if ((unsigned int )gFilePrefs.format == 0U) {
#line 557
    goto case_0;
  }
#line 563
  if ((unsigned int )gFilePrefs.format == 1U) {
#line 563
    goto case_1;
  }
#line 569
  if ((unsigned int )gFilePrefs.format == 2U) {
#line 569
    goto case_2;
  }
#line 573
  if ((unsigned int )gFilePrefs.format == 3U) {
#line 573
    goto case_3;
  }
#line 580
  if ((unsigned int )gFilePrefs.format == 6U) {
#line 580
    goto case_6;
  }
#line 586
  if ((unsigned int )gFilePrefs.format == 4U) {
#line 586
    goto case_4;
  }
#line 592
  if ((unsigned int )gFilePrefs.format == 5U) {
#line 592
    goto case_5;
  }
#line 598
  if ((unsigned int )gFilePrefs.format == 7U) {
#line 598
    goto case_7;
  }
#line 603
  if ((unsigned int )gFilePrefs.format == 8U) {
#line 603
    goto case_8;
  }
#line 608
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 558
  cleanupDMS(fileData);
#line 559
  tmp___4 = field(fileData, (short )pos);
#line 559
  pkt.latitude = DMStoDegrees(tmp___4);
#line 560
  tmp___5 = field(fileData, (short )(pos + 1));
#line 560
  pkt.longitude = DMStoDegrees(tmp___5);
  }
#line 561
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 564
  cleanupDMS(fileData);
#line 565
  tmp___6 = field(fileData, (short )pos);
#line 565
  pkt.latitude = DMtoDegrees(tmp___6);
#line 566
  tmp___7 = field(fileData, (short )(pos + 1));
#line 566
  pkt.longitude = DMtoDegrees(tmp___7);
  }
#line 567
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 570
  tmp___8 = field(fileData, (short )pos);
#line 570
  sscanf((char const   */* __restrict  */)tmp___8, (char const   */* __restrict  */)"%lf %lf",
         & pkt.latitude, & pkt.longitude);
  }
#line 571
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 574
  tmp___9 = field(fileData, (short )pos);
#line 574
  sscanf((char const   */* __restrict  */)tmp___9, (char const   */* __restrict  */)"%hd",
         & zone);
#line 575
  tmp___10 = field(fileData, (short )(pos + 1));
#line 575
  sscanf((char const   */* __restrict  */)tmp___10, (char const   */* __restrict  */)"%c",
         & nsZone);
#line 576
  tmp___11 = field(fileData, (short )(pos + 2));
#line 576
  sscanf((char const   */* __restrict  */)tmp___11, (char const   */* __restrict  */)"%lf %lf",
         & x, & y);
#line 577
  UTMtoDeg(zone, (short )((int )nsZone <= 77), x, y, & pkt.latitude, & pkt.longitude);
  }
#line 578
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 581
  tmp___12 = field(fileData, (short )pos);
#line 581
  sscanf((char const   */* __restrict  */)tmp___12, (char const   */* __restrict  */)"%s",
         finzone);
#line 582
  tmp___13 = field(fileData, (short )(pos + 2));
#line 582
  sscanf((char const   */* __restrict  */)tmp___13, (char const   */* __restrict  */)"%lf %lf",
         & x, & y);
#line 583
  KKJtoDeg((short)2, (short)0, x, y, & pkt.latitude, & pkt.longitude);
  }
#line 584
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 587
  tmp___14 = field(fileData, (short )pos);
#line 587
  sscanf((char const   */* __restrict  */)tmp___14, (char const   */* __restrict  */)"%s",
         bgzone);
#line 588
  tmp___15 = field(fileData, (short )(pos + 1));
#line 588
  sscanf((char const   */* __restrict  */)tmp___15, (char const   */* __restrict  */)"%lf %lf",
         & x, & y);
#line 589
  BNGtoDeg(bgzone, x, y, & pkt.latitude, & pkt.longitude);
  }
#line 590
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 593
  tmp___16 = field(fileData, (short )pos);
#line 593
  sscanf((char const   */* __restrict  */)tmp___16, (char const   */* __restrict  */)"%s",
         bgzone);
#line 594
  tmp___17 = field(fileData, (short )(pos + 1));
#line 594
  sscanf((char const   */* __restrict  */)tmp___17, (char const   */* __restrict  */)"%lf %lf",
         & x, & y);
#line 595
  ITMtoDeg(bgzone, x, y, & pkt.latitude, & pkt.longitude);
  }
#line 596
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 599
  tmp___18 = field(fileData, (short )pos);
#line 599
  sscanf((char const   */* __restrict  */)tmp___18, (char const   */* __restrict  */)"%lf %lf",
         & x, & y);
#line 600
  SEGtoDeg(x, y, & pkt.latitude, & pkt.longitude);
  }
#line 601
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 604
  tmp___19 = field(fileData, (short )pos);
#line 604
  sscanf((char const   */* __restrict  */)tmp___19, (char const   */* __restrict  */)"%lf %lf",
         & x, & y);
#line 605
  GKKtoDeg(x, y, & pkt.latitude, & pkt.longitude);
  }
#line 606
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 609
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 613
  translate((short)0, & pkt.latitude, & pkt.longitude, gFilePrefs.datum);
  }
#line 615
  if (column.name >= 0) {
    {
#line 619
    s___0 = strstr((char const   *)pkt.name, "\t");
    }
#line 619
    if (s___0) {
#line 620
      *s___0 = (char)0;
    }
    {
#line 621
    s___0 = pkt.name;
#line 622
    tmp___20 = strlen((char const   *)s___0);
#line 622
    s___0 += tmp___20;
    }
#line 623
    if ((int )*s___0 == 10) {
#line 624
      *s___0 = (char)0;
    }
    {
#line 625
    while (1) {
      while_continue: /* CIL Label */ ;
#line 625
      s___0 --;
#line 625
      if ((unsigned long )s___0 > (unsigned long )pkt.name) {
#line 625
        if (! ((int )*s___0 == 32)) {
#line 625
          goto while_break;
        }
      } else {
#line 625
        goto while_break;
      }
#line 626
      *s___0 = (char)0;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 629
  if (column.comment >= 0) {
    {
#line 633
    s___0 = strstr((char const   *)pkt.comment, "\t");
    }
#line 633
    if (s___0) {
#line 634
      *s___0 = (char)0;
    }
    {
#line 635
    s___0 = pkt.comment;
#line 636
    tmp___21 = strlen((char const   *)s___0);
#line 636
    s___0 += tmp___21;
    }
#line 637
    if ((int )*s___0 == 10) {
#line 638
      *s___0 = (char)0;
    }
    {
#line 639
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 639
      s___0 --;
#line 639
      if ((unsigned long )s___0 > (unsigned long )pkt.comment) {
#line 639
        if (! ((int )*s___0 == 32)) {
#line 639
          goto while_break___0;
        }
      } else {
#line 639
        goto while_break___0;
      }
#line 640
      *s___0 = (char)0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 643
  if (debugging > 1) {
    {
#line 645
    printf((char const   */* __restrict  */)"pkt: name=\"%s\"  comment=\"%s\"\n",
           pkt.name, pkt.comment);
    }
#line 646
    if (pkt.has.seconds) {
      {
#line 646
      tmp___22 = ctime((time_t const   *)(& pkt.seconds));
#line 646
      printf((char const   */* __restrict  */)"%s", tmp___22);
      }
    }
    {
#line 647
    printf((char const   */* __restrict  */)"latitude=%9.6f longitude=%9.6f altitude=%5.0f\n",
           pkt.latitude, pkt.longitude, pkt.altitude);
    }
  }
#line 654
  if ((int )type == 3) {
#line 655
    message[0] = (BYTE )35;
  } else {
#line 657
    message[0] = (BYTE )30;
  }
  {
#line 659
  tmp___61 = strstr((char const   *)protocols, "D100");
  }
#line 659
  if (tmp___61) {
    {
#line 661
    d = (D100_Wpt_Type *)(message + 2);
#line 664
    message[1] = (BYTE )sizeof(*d);
#line 667
    tmp___23 = deg2int(pkt.latitude);
#line 667
    copyNumber((BYTE *)(& d->posn.lat), tmp___23);
#line 668
    tmp___24 = deg2int(pkt.longitude);
#line 668
    copyNumber((BYTE *)(& d->posn.lon), tmp___24);
#line 669
    copyNumber((BYTE *)(& d->unused), pkt.seconds);
#line 670
    cpystr((unsigned char *)(& d->ident), pkt.name, (short)6);
#line 671
    cpystr((unsigned char *)(& d->cmnt), pkt.comment, (short)40);
    }
  } else {
    {
#line 673
    tmp___60 = strstr((char const   *)protocols, "D101");
    }
#line 673
    if (tmp___60) {
      {
#line 675
      d___0 = (D101_Wpt_Type *)(message + 2);
#line 678
      message[1] = (BYTE )sizeof(*d___0);
#line 680
      tmp___25 = deg2int(pkt.latitude);
#line 680
      copyNumber((BYTE *)(& d___0->posn.lat), tmp___25);
#line 681
      tmp___26 = deg2int(pkt.longitude);
#line 681
      copyNumber((BYTE *)(& d___0->posn.lon), tmp___26);
#line 682
      copyNumber((BYTE *)(& d___0->unused), pkt.seconds);
#line 683
      cpystr((unsigned char *)(& d___0->ident), pkt.name, (short)6);
#line 684
      cpystr((unsigned char *)(& d___0->cmnt), pkt.comment, (short)40);
      }
    } else {
      {
#line 686
      tmp___59 = strstr((char const   *)protocols, "D102");
      }
#line 686
      if (tmp___59) {
        {
#line 688
        d___1 = (D102_Wpt_Type *)(message + 2);
#line 691
        message[1] = (BYTE )sizeof(*d___1);
#line 693
        tmp___27 = deg2int(pkt.latitude);
#line 693
        copyNumber((BYTE *)(& d___1->posn.lat), tmp___27);
#line 694
        tmp___28 = deg2int(pkt.longitude);
#line 694
        copyNumber((BYTE *)(& d___1->posn.lon), tmp___28);
#line 695
        copyNumber((BYTE *)(& d___1->unused), pkt.seconds);
#line 696
        cpystr((unsigned char *)(& d___1->ident), pkt.name, (short)6);
#line 697
        cpystr((unsigned char *)(& d___1->cmnt), pkt.comment, (short)40);
        }
      } else {
        {
#line 699
        tmp___58 = strstr((char const   *)protocols, "D103");
        }
#line 699
        if (tmp___58) {
          {
#line 701
          d___2 = (D103_Wpt_Type *)(message + 2);
#line 704
          message[1] = (BYTE )sizeof(*d___2);
#line 706
          tmp___29 = deg2int(pkt.latitude);
#line 706
          copyNumber((BYTE *)(& d___2->posn.lat), tmp___29);
#line 707
          tmp___30 = deg2int(pkt.longitude);
#line 707
          copyNumber((BYTE *)(& d___2->posn.lon), tmp___30);
#line 708
          copyNumber((BYTE *)(& d___2->unused), pkt.seconds);
#line 709
          cpystr((unsigned char *)(& d___2->ident), pkt.name, (short)6);
#line 710
          cpystr((unsigned char *)(& d___2->cmnt), pkt.comment, (short)40);
          }
        } else {
          {
#line 712
          tmp___57 = strstr((char const   *)protocols, "D104");
          }
#line 712
          if (tmp___57) {
            {
#line 714
            d___3 = (D104_Wpt_Type *)(message + 2);
#line 717
            message[1] = (BYTE )sizeof(*d___3);
#line 719
            tmp___31 = deg2int(pkt.latitude);
#line 719
            copyNumber((BYTE *)(& d___3->posn.lat), tmp___31);
#line 720
            tmp___32 = deg2int(pkt.longitude);
#line 720
            copyNumber((BYTE *)(& d___3->posn.lon), tmp___32);
#line 721
            copyNumber((BYTE *)(& d___3->unused), pkt.seconds);
#line 722
            cpystr((unsigned char *)(& d___3->ident), pkt.name, (short)6);
#line 723
            cpystr((unsigned char *)(& d___3->cmnt), pkt.comment, (short)40);
            }
          } else {
            {
#line 725
            tmp___56 = strstr((char const   *)protocols, "D105");
            }
#line 725
            if (tmp___56) {
              {
#line 727
              d___4 = (D105_Wpt_Type *)(message + 2);
#line 730
              message[1] = (BYTE )sizeof(*d___4);
#line 732
              tmp___33 = deg2int(pkt.latitude);
#line 732
              copyNumber((BYTE *)(& d___4->posn.lat), tmp___33);
#line 733
              tmp___34 = deg2int(pkt.longitude);
#line 733
              copyNumber((BYTE *)(& d___4->posn.lon), tmp___34);
#line 735
              cpystr((unsigned char *)(& d___4->ident), pkt.name, (short)15);
              }
            } else {
              {
#line 738
              tmp___55 = strstr((char const   *)protocols, "D106");
              }
#line 738
              if (tmp___55) {
                {
#line 740
                d___5 = (D106_Wpt_Type *)(message + 2);
#line 743
                message[1] = (BYTE )sizeof(*d___5);
#line 745
                tmp___35 = deg2int(pkt.latitude);
#line 745
                copyNumber((BYTE *)(& d___5->posn.lat), tmp___35);
#line 746
                tmp___36 = deg2int(pkt.longitude);
#line 746
                copyNumber((BYTE *)(& d___5->posn.lon), tmp___36);
#line 748
                cpystr((unsigned char *)(& d___5->ident), pkt.name, (short)15);
                }
              } else {
                {
#line 751
                tmp___54 = strstr((char const   *)protocols, "D107");
                }
#line 751
                if (tmp___54) {
                  {
#line 753
                  d___6 = (D107_Wpt_Type *)(message + 2);
#line 756
                  message[1] = (BYTE )sizeof(*d___6);
#line 758
                  tmp___37 = deg2int(pkt.latitude);
#line 758
                  copyNumber((BYTE *)(& d___6->posn.lat), tmp___37);
#line 759
                  tmp___38 = deg2int(pkt.longitude);
#line 759
                  copyNumber((BYTE *)(& d___6->posn.lon), tmp___38);
#line 760
                  copyNumber((BYTE *)(& d___6->unused), pkt.seconds);
#line 761
                  cpystr((unsigned char *)(& d___6->ident), pkt.name, (short)6);
#line 762
                  cpystr((unsigned char *)(& d___6->cmnt), pkt.comment, (short)40);
                  }
                } else {
                  {
#line 764
                  tmp___53 = strstr((char const   *)protocols, "D108");
                  }
#line 764
                  if (tmp___53) {
                    {
#line 766
                    d___7 = (D108_Wpt_Type *)(message + 2);
#line 768
                    copyFloat((BYTE *)(& d___7->alt), pkt.altitude);
#line 769
                    tmp___39 = deg2int(pkt.latitude);
#line 769
                    copyNumber((BYTE *)(& d___7->posn.lat), tmp___39);
#line 770
                    tmp___40 = deg2int(pkt.longitude);
#line 770
                    copyNumber((BYTE *)(& d___7->posn.lon), tmp___40);
#line 772
                    s___0 = (char *)(& d___7->ident);
#line 773
                    strcpy((char */* __restrict  */)s___0, (char const   */* __restrict  */)pkt.name);
#line 774
                    tmp___41 = strlen((char const   *)s___0);
#line 774
                    s___0 += tmp___41 + 1UL;
#line 775
                    strcpy((char */* __restrict  */)s___0, (char const   */* __restrict  */)pkt.comment);
#line 776
                    tmp___42 = strlen((char const   *)s___0);
#line 776
                    s___0 += tmp___42 + 1UL;
#line 777
                    message[1] = (BYTE )(s___0 - (char *)d___7);
                    }
                  } else {
                    {
#line 779
                    tmp___52 = strstr((char const   *)protocols, "D109");
                    }
#line 779
                    if (tmp___52) {
                      {
#line 781
                      d___8 = (D109_Wpt_Type *)(message + 2);
#line 783
                      copyFloat((BYTE *)(& d___8->alt), pkt.altitude);
#line 784
                      tmp___43 = deg2int(pkt.latitude);
#line 784
                      copyNumber((BYTE *)(& d___8->posn.lat), tmp___43);
#line 785
                      tmp___44 = deg2int(pkt.longitude);
#line 785
                      copyNumber((BYTE *)(& d___8->posn.lon), tmp___44);
#line 787
                      s___0 = (char *)(& d___8->ident);
#line 788
                      strcpy((char */* __restrict  */)s___0, (char const   */* __restrict  */)pkt.name);
#line 789
                      tmp___45 = strlen((char const   *)s___0);
#line 789
                      s___0 += tmp___45 + 1UL;
#line 790
                      strcpy((char */* __restrict  */)s___0, (char const   */* __restrict  */)pkt.comment);
#line 791
                      tmp___46 = strlen((char const   *)s___0);
#line 791
                      s___0 += tmp___46 + 1UL;
#line 792
                      message[1] = (BYTE )(s___0 - (char *)d___8);
                      }
                    } else {
                      {
#line 794
                      tmp___51 = strstr((char const   *)protocols, "D110");
                      }
#line 794
                      if (tmp___51) {
                        {
#line 796
                        d___9 = (D110_Wpt_Type *)(message + 2);
#line 798
                        copyFloat((BYTE *)(& d___9->alt), pkt.altitude);
#line 799
                        tmp___47 = deg2int(pkt.latitude);
#line 799
                        copyNumber((BYTE *)(& d___9->posn.lat), tmp___47);
#line 800
                        tmp___48 = deg2int(pkt.longitude);
#line 800
                        copyNumber((BYTE *)(& d___9->posn.lon), tmp___48);
#line 801
                        copyNumber((BYTE *)(& d___9->time), pkt.seconds);
#line 802
                        s___0 = (char *)(& d___9->ident);
#line 803
                        strcpy((char */* __restrict  */)s___0, (char const   */* __restrict  */)pkt.name);
#line 804
                        tmp___49 = strlen((char const   *)s___0);
#line 804
                        s___0 += tmp___49 + 1UL;
#line 805
                        strcpy((char */* __restrict  */)s___0, (char const   */* __restrict  */)pkt.comment);
#line 806
                        tmp___50 = strlen((char const   *)s___0);
#line 806
                        s___0 += tmp___50 + 1UL;
#line 807
                        message[1] = (BYTE )(s___0 - (char *)d___9);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 812
  sendGPSMessage(message, (short )((int )message[1] + 2));
#line 815
  tmp___62 = getGPSack();
  }
#line 815
  return ((short )tmp___62);
}
}
#line 932 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/sendgpsinfo.c"
static short doTrack(void) 
{ 
  double latitude ;
  double longitude ;
  double x ;
  double y ;
  long lat ;
  long lon ;
  short zone ;
  char nsZone ;
  char bgzone[3] ;
  char finzone[5] ;
  int pos ;
  struct __anonstruct_pkt_99 pkt ;
  char empty[1] ;
  char date[20] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  D300_Trk_Point_Type *d ;
  long tmp___19 ;
  long tmp___20 ;
  char *tmp___21 ;
  D301_Trk_Point_Type *d___0 ;
  long tmp___22 ;
  long tmp___23 ;
  char *tmp___24 ;
  D302_Trk_Point_Type *d___1 ;
  long tmp___25 ;
  long tmp___26 ;
  char *tmp___27 ;
  short tmp___28 ;

  {
#line 963
  empty[0] = (char )'\000';
#line 965
  pkt.has.comment = 0U;
#line 965
  pkt.has.name = pkt.has.comment;
#line 965
  pkt.has.seconds = pkt.has.name;
#line 965
  pkt.has.altitude = pkt.has.seconds;
#line 970
  pkt.altitude = 1.01e24;
#line 971
  pkt.seconds = (long )(~ 0);
#line 972
  pkt.name = empty;
#line 972
  pkt.comment = pkt.name;
#line 974
  if (column.date >= 0) {
    {
#line 977
    tmp = field(fileData, (short )column.date);
#line 977
    strncpy((char */* __restrict  */)(date), (char const   */* __restrict  */)tmp,
            (size_t )19);
#line 978
    date[19] = (char)0;
#line 979
    pkt.seconds = dt2secs(date, (int )gFilePrefs.offset);
#line 980
    pkt.has.seconds = 1U;
    }
  }
#line 982
  if (column.altitude >= 0) {
    {
#line 982
    tmp___1 = field(fileData, (short )column.altitude);
#line 982
    tmp___2 = strstr((char const   *)tmp___1, "unknown");
    }
#line 982
    if (! tmp___2) {
      {
#line 985
      tmp___0 = field(fileData, (short )column.altitude);
#line 985
      pkt.altitude = atof((char const   *)tmp___0);
#line 986
      pkt.has.altitude = 1U;
      }
    }
  }
#line 989
  pos = column.position;
  {
#line 994
  if ((unsigned int )gFilePrefs.format == 0U) {
#line 994
    goto case_0;
  }
#line 1000
  if ((unsigned int )gFilePrefs.format == 1U) {
#line 1000
    goto case_1;
  }
#line 1006
  if ((unsigned int )gFilePrefs.format == 2U) {
#line 1006
    goto case_2;
  }
#line 1010
  if ((unsigned int )gFilePrefs.format == 3U) {
#line 1010
    goto case_3;
  }
#line 1017
  if ((unsigned int )gFilePrefs.format == 6U) {
#line 1017
    goto case_6;
  }
#line 1023
  if ((unsigned int )gFilePrefs.format == 4U) {
#line 1023
    goto case_4;
  }
#line 1029
  if ((unsigned int )gFilePrefs.format == 5U) {
#line 1029
    goto case_5;
  }
#line 1035
  if ((unsigned int )gFilePrefs.format == 7U) {
#line 1035
    goto case_7;
  }
#line 1040
  if ((unsigned int )gFilePrefs.format == 8U) {
#line 1040
    goto case_8;
  }
#line 1045
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 995
  cleanupDMS(fileData);
#line 996
  tmp___3 = field(fileData, (short )pos);
#line 996
  latitude = DMStoDegrees(tmp___3);
#line 997
  tmp___4 = field(fileData, (short )(pos + 1));
#line 997
  longitude = DMStoDegrees(tmp___4);
  }
#line 998
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1001
  cleanupDMS(fileData);
#line 1002
  tmp___5 = field(fileData, (short )pos);
#line 1002
  latitude = DMtoDegrees(tmp___5);
#line 1003
  tmp___6 = field(fileData, (short )(pos + 1));
#line 1003
  longitude = DMtoDegrees(tmp___6);
  }
#line 1004
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1007
  tmp___7 = field(fileData, (short )pos);
#line 1007
  sscanf((char const   */* __restrict  */)tmp___7, (char const   */* __restrict  */)"%lf %lf",
         & latitude, & longitude);
  }
#line 1008
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1011
  tmp___8 = field(fileData, (short )pos);
#line 1011
  sscanf((char const   */* __restrict  */)tmp___8, (char const   */* __restrict  */)"%hd",
         & zone);
#line 1012
  tmp___9 = field(fileData, (short )(pos + 1));
#line 1012
  sscanf((char const   */* __restrict  */)tmp___9, (char const   */* __restrict  */)"%c",
         & nsZone);
#line 1013
  tmp___10 = field(fileData, (short )(pos + 2));
#line 1013
  sscanf((char const   */* __restrict  */)tmp___10, (char const   */* __restrict  */)"%lf %lf",
         & x, & y);
#line 1014
  UTMtoDeg(zone, (short )((int )nsZone <= 77), x, y, & latitude, & longitude);
  }
#line 1015
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 1018
  tmp___11 = field(fileData, (short )pos);
#line 1018
  sscanf((char const   */* __restrict  */)tmp___11, (char const   */* __restrict  */)"%s",
         finzone);
#line 1019
  tmp___12 = field(fileData, (short )(pos + 2));
#line 1019
  sscanf((char const   */* __restrict  */)tmp___12, (char const   */* __restrict  */)"%lf %lf",
         & x, & y);
#line 1020
  KKJtoDeg((short)2, (short)0, x, y, & latitude, & longitude);
  }
#line 1021
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 1024
  tmp___13 = field(fileData, (short )pos);
#line 1024
  sscanf((char const   */* __restrict  */)tmp___13, (char const   */* __restrict  */)"%s",
         bgzone);
#line 1025
  tmp___14 = field(fileData, (short )(pos + 1));
#line 1025
  sscanf((char const   */* __restrict  */)tmp___14, (char const   */* __restrict  */)"%lf %lf",
         & x, & y);
#line 1026
  BNGtoDeg(bgzone, x, y, & latitude, & longitude);
  }
#line 1027
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 1030
  tmp___15 = field(fileData, (short )pos);
#line 1030
  sscanf((char const   */* __restrict  */)tmp___15, (char const   */* __restrict  */)"%s",
         bgzone);
#line 1031
  tmp___16 = field(fileData, (short )(pos + 1));
#line 1031
  sscanf((char const   */* __restrict  */)tmp___16, (char const   */* __restrict  */)"%lf %lf",
         & x, & y);
#line 1032
  ITMtoDeg(bgzone, x, y, & latitude, & longitude);
  }
#line 1033
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 1036
  tmp___17 = field(fileData, (short )pos);
#line 1036
  sscanf((char const   */* __restrict  */)tmp___17, (char const   */* __restrict  */)"%lf %lf",
         & x, & y);
#line 1037
  SEGtoDeg(x, y, & latitude, & longitude);
  }
#line 1038
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 1041
  tmp___18 = field(fileData, (short )pos);
#line 1041
  sscanf((char const   */* __restrict  */)tmp___18, (char const   */* __restrict  */)"%lf %lf",
         & x, & y);
#line 1042
  GKKtoDeg(x, y, & latitude, & longitude);
  }
#line 1043
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1046
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1050
  translate((short)0, & latitude, & longitude, gFilePrefs.datum);
#line 1051
  pkt.latitude = latitude;
#line 1052
  pkt.longitude = longitude;
#line 1055
  lat = deg2int(latitude);
#line 1056
  lon = deg2int(longitude);
#line 1059
  message[0] = (BYTE )34;
#line 1072
  tmp___21 = strstr((char const   *)protocols, "D300");
  }
#line 1072
  if (tmp___21) {
    {
#line 1074
    d = (D300_Trk_Point_Type *)(message + 2);
#line 1075
    copyNumber((BYTE *)(& d->time), pkt.seconds);
#line 1076
    tmp___19 = deg2int(pkt.latitude);
#line 1076
    copyNumber((BYTE *)(& d->posn.lat), tmp___19);
#line 1077
    tmp___20 = deg2int(pkt.longitude);
#line 1077
    copyNumber((BYTE *)(& d->posn.lon), tmp___20);
#line 1078
    d->new_trk = newTrack;
#line 1079
    message[1] = (BYTE )sizeof(*d);
    }
  }
  {
#line 1081
  tmp___24 = strstr((char const   *)protocols, "D301");
  }
#line 1081
  if (tmp___24) {
    {
#line 1083
    d___0 = (D301_Trk_Point_Type *)(message + 2);
#line 1084
    copyNumber((BYTE *)(& d___0->time), pkt.seconds);
#line 1085
    tmp___22 = deg2int(pkt.latitude);
#line 1085
    copyNumber((BYTE *)(& d___0->posn.lat), tmp___22);
#line 1086
    tmp___23 = deg2int(pkt.longitude);
#line 1086
    copyNumber((BYTE *)(& d___0->posn.lon), tmp___23);
    }
#line 1087
    if (pkt.has.altitude) {
      {
#line 1088
      copyFloat((BYTE *)(& d___0->alt), pkt.altitude);
      }
    }
#line 1089
    d___0->new_trk = newTrack;
#line 1090
    message[1] = (BYTE )sizeof(*d___0);
  }
  {
#line 1092
  tmp___27 = strstr((char const   *)protocols, "D302");
  }
#line 1092
  if (tmp___27) {
    {
#line 1094
    d___1 = (D302_Trk_Point_Type *)(message + 2);
#line 1095
    copyNumber((BYTE *)(& d___1->time), pkt.seconds);
#line 1096
    tmp___25 = deg2int(pkt.latitude);
#line 1096
    copyNumber((BYTE *)(& d___1->posn.lat), tmp___25);
#line 1097
    tmp___26 = deg2int(pkt.longitude);
#line 1097
    copyNumber((BYTE *)(& d___1->posn.lon), tmp___26);
    }
#line 1098
    if (pkt.has.altitude) {
      {
#line 1099
      copyFloat((BYTE *)(& d___1->alt), pkt.altitude);
      }
    }
#line 1100
    d___1->new_trk = newTrack;
#line 1101
    message[1] = (BYTE )sizeof(*d___1);
  }
  {
#line 1104
  newTrack = (BYTE )0;
#line 1107
  sendGPSMessage(message, (short )((int )message[1] + 2));
#line 1110
  tmp___28 = getGPSMessage();
  }
#line 1110
  return (tmp___28);
}
}
#line 1126 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/sendgpsinfo.c"
static short doRoute(void) 
{ 
  short route ;
  char *tmp ;
  char *tmp___0 ;
  short tmp___1 ;

  {
  {
#line 1132
  message[0] = (BYTE )'\035';
#line 1135
  message[1] = (BYTE )21;
#line 1138
  tmp = field(fileData, (short)1);
#line 1138
  sscanf((char const   */* __restrict  */)tmp, (char const   */* __restrict  */)"%hd",
         & route);
#line 1140
  message[2] = (BYTE )route;
#line 1141
  tmp___0 = field(fileData, (short)2);
#line 1141
  cpystr(message + 3, tmp___0, (short)20);
#line 1144
  sendGPSMessage(message, (short)23);
#line 1147
  tmp___1 = getGPSMessage();
  }
#line 1147
  return (tmp___1);
}
}
#line 1156 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/sendgpsinfo.c"
static short doAlmanac(void) 
{ 
  short i ;
  unsigned short x ;
  short tmp ;

  {
  {
#line 1163
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Uploading of almanac data is no longer supported.\n");
  }
#line 1165
  return ((short)0);
#line 1169
  message[0] = (BYTE )'\037';
#line 1172
  message[1] = (BYTE )42;
#line 1175
  i = (short)0;
  {
#line 1175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1175
    if (! ((int )i < 42)) {
#line 1175
      goto while_break;
    }
    {
#line 1177
    sscanf((char const   */* __restrict  */)((fileData + 2) + 3 * (int )i), (char const   */* __restrict  */)"%02hX",
           & x);
#line 1178
    message[(int )i + 2] = (BYTE )x;
#line 1175
    i = (short )((int )i + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1182
  sendGPSMessage(message, (short)44);
#line 1185
  tmp = getGPSMessage();
  }
#line 1185
  return (tmp);
}
}
#line 1192 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/sendgpsinfo.c"
static short records(FILE *ifile , short type ) 
{ 
  short n ;
  int tmp ;
  short tmp___0 ;

  {
  {
#line 1195
  n = (short)0;
#line 1198
  GetLine(ifile, fileData, (short)1);
  }
  {
#line 1201
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1201
    tmp___0 = GetLine(ifile, fileData, (short)0);
    }
#line 1201
    if (! tmp___0) {
#line 1201
      goto while_break;
    }
    {
#line 1203
    tmp = strncasecmp((char const   *)(fileData), "Type", (size_t )4);
    }
#line 1203
    if (tmp) {
      {
#line 1208
      if ((int )type == 0) {
#line 1208
        goto case_0;
      }
#line 1213
      if ((int )type == 1) {
#line 1213
        goto case_1;
      }
#line 1218
      if ((int )type == 2) {
#line 1218
        goto case_2;
      }
#line 1223
      if ((int )type == 3) {
#line 1223
        goto case_3;
      }
#line 1227
      goto switch_default;
      case_0: /* CIL Label */ 
#line 1209
      if ((int )fileData[0] == 65) {
#line 1210
        n = (short )((int )n + 1);
      }
#line 1211
      goto switch_break;
      case_1: /* CIL Label */ 
#line 1214
      if ((int )fileData[0] == 82) {
#line 1215
        n = (short )((int )n + 1);
      } else
#line 1214
      if ((int )fileData[0] == 87) {
#line 1215
        n = (short )((int )n + 1);
      }
#line 1216
      goto switch_break;
      case_2: /* CIL Label */ 
#line 1219
      if ((int )fileData[0] == 84) {
#line 1220
        n = (short )((int )n + 1);
      }
#line 1221
      goto switch_break;
      case_3: /* CIL Label */ 
#line 1224
      if ((int )fileData[0] == 87) {
#line 1225
        n = (short )((int )n + 1);
      }
#line 1226
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1229
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1235
  return (n);
}
}
#line 1243 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/sendgpsinfo.c"
static short sendRecords(short recs ) 
{ 
  short result ;

  {
  {
#line 1249
  message[0] = (BYTE )'\033';
#line 1252
  message[1] = (BYTE )'\002';
#line 1255
  message[2] = (BYTE )((int )recs % 256);
#line 1256
  message[3] = (BYTE )((int )recs / 256);
#line 1259
  sendGPSMessage(message, (short)4);
#line 1262
  result = getGPSMessage();
  }
#line 1263
  return (result);
}
}
#line 1270 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/sendgpsinfo.c"
static void copyNumber(BYTE *p , long n ) 
{ 
  BYTE *tmp ;
  BYTE *tmp___0 ;
  BYTE *tmp___1 ;

  {
#line 1273
  tmp = p;
#line 1273
  p ++;
#line 1273
  *tmp = (BYTE )(n & 255L);
#line 1274
  n >>= 8;
#line 1275
  tmp___0 = p;
#line 1275
  p ++;
#line 1275
  *tmp___0 = (BYTE )(n & 255L);
#line 1276
  n >>= 8;
#line 1277
  tmp___1 = p;
#line 1277
  p ++;
#line 1277
  *tmp___1 = (BYTE )(n & 255L);
#line 1278
  n >>= 8;
#line 1279
  *p = (BYTE )(n & 255L);
#line 1280
  return;
}
}
#line 1286 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/sendgpsinfo.c"
static void copyFloat(BYTE *p , double d ) 
{ 
  float f ;
  long *lp ;
  long n ;
  BYTE *tmp ;
  BYTE *tmp___0 ;
  BYTE *tmp___1 ;

  {
#line 1289
  f = (float )d;
#line 1290
  lp = (long *)(& f);
#line 1291
  n = *lp;
#line 1293
  tmp = p;
#line 1293
  p ++;
#line 1293
  *tmp = (BYTE )(n & 255L);
#line 1294
  n >>= 8;
#line 1295
  tmp___0 = p;
#line 1295
  p ++;
#line 1295
  *tmp___0 = (BYTE )(n & 255L);
#line 1296
  n >>= 8;
#line 1297
  tmp___1 = p;
#line 1297
  p ++;
#line 1297
  *tmp___1 = (BYTE )(n & 255L);
#line 1298
  n >>= 8;
#line 1299
  *p = (BYTE )(n & 255L);
#line 1300
  return;
}
}
#line 1307 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/sendgpsinfo.c"
static char *field(char *str , short n ) 
{ 
  short i ;
  char *a ;
  char buf[160] ;
  short tmp ;

  {
#line 1310
  i = (short)0;
#line 1311
  a = str;
  {
#line 1313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1313
    tmp = i;
#line 1313
    i = (short )((int )i + 1);
#line 1313
    if (! ((int )tmp < (int )n)) {
#line 1313
      goto while_break;
    }
    {
#line 1314
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1316
      if (! *a) {
        {
#line 1319
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"Input line should have at least %d tabs:\n%80s\n",
                (int )n - 1, str);
#line 1321
        Error(buf);
        }
      }
#line 1314
      a ++;
#line 1314
      if (! ((int )*a != 9)) {
#line 1314
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1325
  return (a + 1);
}
}
#line 1332 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/sendgpsinfo.c"
static void cpystr(BYTE *p , char *q , short n ) 
{ 
  BYTE *tmp ;
  char *tmp___0 ;
  BYTE *tmp___1 ;
  short tmp___2 ;

  {
  {
#line 1335
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1335
    if ((int )*q != 9) {
#line 1335
      if ((int )*q != 10) {
#line 1335
        if ((int )*q != 13) {
#line 1335
          if (! ((int )*q != 0)) {
#line 1335
            goto while_break;
          }
        } else {
#line 1335
          goto while_break;
        }
      } else {
#line 1335
        goto while_break;
      }
    } else {
#line 1335
      goto while_break;
    }
#line 1337
    tmp = p;
#line 1337
    p ++;
#line 1337
    tmp___0 = q;
#line 1337
    q ++;
#line 1337
    *tmp = (BYTE )*tmp___0;
#line 1338
    n = (short )((int )n - 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1340
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1340
    tmp___2 = n;
#line 1340
    n = (short )((int )n - 1);
#line 1340
    if (! ((int )tmp___2 > 0)) {
#line 1340
      goto while_break___0;
    }
#line 1341
    tmp___1 = p;
#line 1341
    p ++;
#line 1341
    *tmp___1 = (BYTE )' ';
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1342
  return;
}
}
#line 1384 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/sendgpsinfo.c"
static short getFileFormat(char *first , char *second ) 
{ 
  char fmt[10] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int i ;
  char *s___0 ;
  size_t tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;
  size_t tmp___17 ;
  int tmp___18 ;
  size_t tmp___19 ;
  int tmp___20 ;
  size_t tmp___21 ;
  int tmp___22 ;
  size_t tmp___23 ;
  int tmp___24 ;
  size_t tmp___25 ;
  int tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;

  {
  {
#line 1391
  tmp___28 = strstr((char const   *)first, "xmap");
  }
#line 1391
  if (tmp___28) {
#line 1393
    file_format = (enum FILE_FORMAT )3334;
#line 1394
    gFilePrefs.format = (enum FORMAT )2;
#line 1395
    gFilePrefs.offset = (double )0;
#line 1396
    gFilePrefs.datum = (short)100;
#line 1397
    if (verbose) {
      {
#line 1398
      printf((char const   */* __restrict  */)"Input file is in Mayko mXmap format.\n");
      }
    }
  } else {
    {
#line 1402
    sscanf((char const   */* __restrict  */)first, (char const   */* __restrict  */)"%7s",
           fmt);
#line 1403
    tmp = strcmp((char const   *)(fmt), "Format:");
    }
#line 1403
    if (tmp != 0) {
#line 1404
      return ((short)0);
    }
    {
#line 1407
    sscanf((char const   */* __restrict  */)(first + 8), (char const   */* __restrict  */)"%3s",
           fmt);
#line 1408
    tmp___8 = strcmp((char const   *)(fmt), "DMS");
    }
#line 1408
    if (tmp___8 == 0) {
#line 1409
      gFilePrefs.format = (enum FORMAT )0;
    } else {
      {
#line 1410
      tmp___7 = strcmp((char const   *)(fmt), "DMM");
      }
#line 1410
      if (tmp___7 == 0) {
#line 1411
        gFilePrefs.format = (enum FORMAT )1;
      } else {
        {
#line 1412
        tmp___6 = strcmp((char const   *)(fmt), "DDD");
        }
#line 1412
        if (tmp___6 == 0) {
#line 1413
          gFilePrefs.format = (enum FORMAT )2;
        } else {
          {
#line 1414
          tmp___5 = strcmp((char const   *)(fmt), "UTM");
          }
#line 1414
          if (tmp___5 == 0) {
#line 1415
            gFilePrefs.format = (enum FORMAT )3;
          } else {
            {
#line 1416
            tmp___4 = strcmp((char const   *)(fmt), "BNG");
            }
#line 1416
            if (tmp___4 == 0) {
#line 1417
              gFilePrefs.format = (enum FORMAT )4;
            } else {
              {
#line 1418
              tmp___3 = strcmp((char const   *)(fmt), "ITM");
              }
#line 1418
              if (tmp___3 == 0) {
#line 1419
                gFilePrefs.format = (enum FORMAT )5;
              } else {
                {
#line 1420
                tmp___2 = strcmp((char const   *)(fmt), "KKJ");
                }
#line 1420
                if (tmp___2 == 0) {
#line 1421
                  gFilePrefs.format = (enum FORMAT )6;
                } else {
                  {
#line 1422
                  tmp___1 = strcmp((char const   *)(fmt), "SEG");
                  }
#line 1422
                  if (tmp___1 == 0) {
#line 1423
                    gFilePrefs.format = (enum FORMAT )7;
                  } else {
                    {
#line 1424
                    tmp___0 = strcmp((char const   *)(fmt), "GKK");
                    }
#line 1424
                    if (tmp___0 == 0) {
#line 1425
                      gFilePrefs.format = (enum FORMAT )8;
                    } else {
#line 1427
                      return ((short)0);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    {
#line 1430
    sscanf((char const   */* __restrict  */)(first + 25), (char const   */* __restrict  */)"%lf",
           & gFilePrefs.offset);
    }
#line 1431
    if (gFilePrefs.offset < - 24.0) {
#line 1432
      return ((short)0);
    } else
#line 1431
    if (gFilePrefs.offset > 24.0) {
#line 1432
      return ((short)0);
    }
    {
#line 1435
    sscanf((char const   */* __restrict  */)(first + 43), (char const   */* __restrict  */)"%3hd",
           & gFilePrefs.datum);
    }
#line 1438
    if ((int )gFilePrefs.datum < 0) {
#line 1439
      return ((short)0);
    } else
#line 1438
    if ((int )gFilePrefs.datum > (int )nDatums) {
#line 1439
      return ((short)0);
    }
#line 1441
    if (! *second) {
#line 1442
      return ((short)0);
    }
#line 1448
    column.count = 0;
#line 1451
    s___0 = second;
    {
#line 1451
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1451
      if (! *s___0) {
#line 1451
        goto while_break;
      }
#line 1452
      if ((int )*s___0 == 9) {
#line 1452
        if (*(s___0 + 1)) {
#line 1453
          (column.count) ++;
        }
      }
#line 1451
      s___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1455
    s___0 = second;
#line 1456
    i = 0;
    {
#line 1456
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1456
      if (! (i < column.count)) {
#line 1456
        goto while_break___0;
      }
      {
#line 1458
      tmp___25 = strlen("type");
#line 1458
      tmp___26 = strncasecmp((char const   *)s___0, "type", tmp___25);
      }
#line 1458
      if (tmp___26 == 0) {
#line 1459
        column.type = i;
      } else {
        {
#line 1460
        tmp___23 = strlen("name");
#line 1460
        tmp___24 = strncasecmp((char const   *)s___0, "name", tmp___23);
        }
#line 1460
        if (tmp___24 == 0) {
#line 1461
          column.name = i;
        } else {
          {
#line 1462
          tmp___21 = strlen("comment");
#line 1462
          tmp___22 = strncasecmp((char const   *)s___0, "comment", tmp___21);
          }
#line 1462
          if (tmp___22 == 0) {
#line 1463
            column.comment = i;
          } else {
            {
#line 1464
            tmp___19 = strlen("date");
#line 1464
            tmp___20 = strncasecmp((char const   *)s___0, "date", tmp___19);
            }
#line 1464
            if (tmp___20 == 0) {
#line 1465
              column.date = i;
            } else {
              {
#line 1466
              tmp___17 = strlen("altitude");
#line 1466
              tmp___18 = strncasecmp((char const   *)s___0, "altitude", tmp___17);
              }
#line 1466
              if (tmp___18 == 0) {
#line 1467
                column.altitude = i;
              } else {
                {
#line 1468
                tmp___15 = strlen("latitude");
#line 1468
                tmp___16 = strncasecmp((char const   *)s___0, "latitude", tmp___15);
                }
#line 1468
                if (tmp___16 == 0) {
#line 1468
                  if ((unsigned int )gPrefs.format == 0U) {
#line 1472
                    column.position = i;
                  } else
#line 1468
                  if ((unsigned int )gPrefs.format == 1U) {
#line 1472
                    column.position = i;
                  } else
#line 1468
                  if ((unsigned int )gPrefs.format == 2U) {
#line 1472
                    column.position = i;
                  } else {
#line 1468
                    goto _L___1;
                  }
                } else {
                  _L___1: /* CIL Label */ 
                  {
#line 1473
                  tmp___13 = strlen("ze");
#line 1473
                  tmp___14 = strncasecmp((char const   *)s___0, "ze", tmp___13);
                  }
#line 1473
                  if (tmp___14 == 0) {
#line 1473
                    if ((unsigned int )gPrefs.format == 3U) {
#line 1475
                      column.position = i;
                    } else {
#line 1473
                      goto _L___0;
                    }
                  } else {
                    _L___0: /* CIL Label */ 
                    {
#line 1476
                    tmp___11 = strlen("zone");
#line 1476
                    tmp___12 = strncasecmp((char const   *)s___0, "zone", tmp___11);
                    }
#line 1476
                    if (tmp___12 == 0) {
#line 1476
                      if ((unsigned int )gPrefs.format == 4U) {
#line 1480
                        column.position = i;
                      } else
#line 1476
                      if ((unsigned int )gPrefs.format == 5U) {
#line 1480
                        column.position = i;
                      } else
#line 1476
                      if ((unsigned int )gPrefs.format == 6U) {
#line 1480
                        column.position = i;
                      } else {
#line 1476
                        goto _L;
                      }
                    } else {
                      _L: /* CIL Label */ 
                      {
#line 1481
                      tmp___9 = strlen("easting");
#line 1481
                      tmp___10 = strncasecmp((char const   *)s___0, "easting", tmp___9);
                      }
#line 1481
                      if (tmp___10 == 0) {
#line 1481
                        if ((unsigned int )gPrefs.format == 7U) {
#line 1485
                          column.position = i;
                        } else
#line 1481
                        if ((unsigned int )gPrefs.format == 8U) {
#line 1485
                          column.position = i;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      {
#line 1486
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1486
        tmp___27 = s___0;
#line 1486
        s___0 ++;
#line 1486
        if (! ((int )*tmp___27 != 9)) {
#line 1486
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1456
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1493
  return ((short)1);
}
}
#line 1500 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/sendgpsinfo.c"
static void cleanupDMS(char *s___0 ) 
{ 


  {
  {
#line 1503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1503
    s___0 ++;
#line 1503
    if (! *s___0) {
#line 1503
      goto while_break;
    }
#line 1504
    if ((int )*s___0 == -95) {
#line 1505
      *s___0 = (char )' ';
    } else
#line 1504
    if ((int )*s___0 == -80) {
#line 1505
      *s___0 = (char )' ';
    } else
#line 1504
    if ((int )*s___0 == 39) {
#line 1505
      *s___0 = (char )' ';
    } else
#line 1504
    if ((int )*s___0 == 34) {
#line 1505
      *s___0 = (char )' ';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1506
  return;
}
}
#line 3 "../include/Garmin.h"
static double const   Degree  =    (double const   )1.74532925199432957692e-2;
#line 63 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) cos)(double __x ) ;
#line 65
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sin)(double __x ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/tm.c"
static double M(double phi , double a , double es ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/tm.c"
void toTM(double lat , double lon , double lat0___5 , double lon0___4 , double k0___5 ,
          double *x , double *y ) 
{ 
  double m ;
  double et2 ;
  double n ;
  double t ;
  double c ;
  double A ;
  double a ;
  double m0 ;
  double es ;
  double lambda ;
  double phi ;
  double lambda0 ;
  double phi0 ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;

  {
  {
#line 54
  datumParams(gPrefs.datum, & a, & es);
#line 56
  lambda = lon * (double )Degree;
#line 57
  phi = lat * (double )Degree;
#line 59
  phi0 = lat0___5 * (double )Degree;
#line 60
  lambda0 = lon0___4 * (double )Degree;
#line 62
  m0 = M(phi0, a, es);
#line 63
  m = M(phi, a, es);
#line 65
  et2 = es / ((double )1 - es);
#line 67
  tmp = sin(phi);
#line 67
  tmp___0 = pow(tmp, 2.0);
#line 67
  tmp___1 = sqrt((double )1 - es * tmp___0);
#line 67
  n = a / tmp___1;
#line 68
  tmp___2 = tan(phi);
#line 68
  t = pow(tmp___2, 2.0);
#line 69
  tmp___3 = cos(phi);
#line 69
  tmp___4 = pow(tmp___3, 2.0);
#line 69
  c = et2 * tmp___4;
#line 70
  tmp___5 = cos(phi);
#line 70
  A = (lambda - lambda0) * tmp___5;
#line 71
  tmp___6 = pow(A, 5.0);
#line 71
  *x = (k0___5 * n) * ((A + (((((1.0 - t) + c) * A) * A) * A) / 6.0) + (((((5.0 - 18.0 * t) + t * t) + 72.0 * c) - 58.0 * et2) * tmp___6) / 120.0);
#line 75
  tmp___7 = tan(phi);
#line 75
  tmp___8 = pow(A, 4.0);
#line 75
  tmp___9 = pow(A, 6.0);
#line 75
  *y = k0___5 * ((m - m0) + (n * tmp___7) * (((A * A) / 2.0 + ((((5.0 - t) + 9.0 * c) + ((double )4 * c) * c) * tmp___8) / 24.0) + (((((61.0 - 58.0 * t) + t * t) + 600.0 * c) - 330.0 * et2) * tmp___9) / 720.0));
  }
#line 82
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/tm.c"
void fromTM(double x , double y , double lat0___5 , double lon0___4 , double k0___5 ,
            double *lat , double *lon ) 
{ 
  double a ;
  double m0 ;
  double es ;
  double et2 ;
  double m ;
  double e1 ;
  double mu ;
  double phi1 ;
  double c1 ;
  double t1 ;
  double n1 ;
  double r1 ;
  double d ;
  double phi0 ;
  double lambda0 ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  double tmp___15 ;
  double tmp___16 ;
  double tmp___17 ;
  double tmp___18 ;
  double tmp___19 ;
  double tmp___20 ;
  double tmp___21 ;
  double tmp___22 ;
  double tmp___23 ;

  {
  {
#line 95
  phi0 = lat0___5 * (double )Degree;
#line 96
  lambda0 = lon0___4 * (double )Degree;
#line 98
  datumParams(gFilePrefs.datum, & a, & es);
#line 100
  m0 = M(phi0, a, es);
#line 101
  et2 = es / (1.0 - es);
#line 102
  m = m0 + y / k0___5;
#line 104
  tmp = sqrt(1.0 - es);
#line 104
  tmp___0 = sqrt(1.0 - es);
#line 104
  e1 = (1.0 - tmp) / (1.0 + tmp___0);
#line 105
  mu = m / (a * (((1.0 - es / 4.0) - ((3.0 * es) * es) / 64.0) - (((5.0 * es) * es) * es) / 256.0));
#line 109
  tmp___1 = pow(e1, 3.0);
#line 109
  tmp___2 = sin(2.0 * mu);
#line 109
  tmp___3 = pow(e1, 4.0);
#line 109
  tmp___4 = sin(4.0 * mu);
#line 109
  tmp___5 = pow(e1, 3.0);
#line 109
  tmp___6 = sin(6.0 * mu);
#line 109
  tmp___7 = pow(e1, 4.0);
#line 109
  tmp___8 = sin(8.0 * mu);
#line 109
  phi1 = (((mu + ((3.0 * e1) / 2.0 - (27.0 * tmp___1) / 32.0) * tmp___2) + (((21.0 * e1) * e1) / 16.0 - (55.0 * tmp___3) / 32.0) * tmp___4) + ((151.0 * tmp___5) / 96.0) * tmp___6) + ((1097.0 * tmp___7) / 512.0) * tmp___8;
#line 116
  tmp___9 = cos(phi1);
#line 116
  tmp___10 = pow(tmp___9, 2.0);
#line 116
  c1 = et2 * tmp___10;
#line 117
  tmp___11 = tan(phi1);
#line 117
  t1 = pow(tmp___11, 2.0);
#line 118
  tmp___12 = sin(phi1);
#line 118
  tmp___13 = pow(tmp___12, 2.0);
#line 118
  tmp___14 = sqrt((double )1 - es * tmp___13);
#line 118
  n1 = a / tmp___14;
#line 119
  tmp___15 = sin(phi1);
#line 119
  tmp___16 = pow(tmp___15, 2.0);
#line 119
  tmp___17 = pow(1.0 - es * tmp___16, 1.5);
#line 119
  r1 = (a * (1.0 - es)) / tmp___17;
#line 120
  d = x / (n1 * k0___5);
#line 121
  tmp___18 = tan(phi1);
#line 121
  tmp___19 = pow(d, 4.0);
#line 121
  tmp___20 = pow(d, 6.0);
#line 121
  *lat = (phi1 - ((n1 * tmp___18) / r1) * (((d * d) / 2.0 - (((((5.0 + 3.0 * t1) + 10.0 * c1) - (4.0 * c1) * c1) - 9.0 * et2) * tmp___19) / 24.0) + ((((((61.0 + 90.0 * t1) + 298.0 * c1) + (45.0 * t1) * t1) - 252.0 * et2) - (3.0 * c1) * c1) * tmp___20) / 720.0)) / (double )Degree;
#line 130
  tmp___21 = pow(d, 3.0);
#line 130
  tmp___22 = pow(d, 5.0);
#line 130
  tmp___23 = cos(phi1);
#line 130
  *lon = (lambda0 + ((d - (((1.0 + 2.0 * t1) + c1) * tmp___21) / 6.0) + ((((((5.0 - 2.0 * c1) + 28.0 * t1) - (3.0 * c1) * c1) + 8.0 * et2) + (24.0 * t1) * t1) * tmp___22) / 120.0) / tmp___23) / (double )Degree;
  }
#line 135
  return;
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/tm.c"
static double M(double phi , double a , double es ) 
{ 
  double fix ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 146
  if (phi == 0.0) {
#line 147
    return (0.0);
  } else {
    {
#line 150
    tmp = sin(2.0 * phi);
#line 150
    tmp___0 = sin(4.0 * phi);
#line 150
    tmp___1 = sin(6.0 * phi);
#line 150
    fix = a * ((((((1.0 - es / 4.0) - ((3.0 * es) * es) / 64.0) - (((5.0 * es) * es) * es) / 256.0) * phi - (((3.0 * es) / 8.0 + ((3.0 * es) * es) / 32.0) + (((45.0 * es) * es) * es) / 1024.0) * tmp) + (((15.0 * es) * es) / 256.0 + (((45.0 * es) * es) * es) / 1024.0) * tmp___0) - ((((35.0 * es) * es) * es) / 3072.0) * tmp___1);
    }
#line 160
    return (fix);
  }
}
}
#line 41 "../include/Garmin.h"
long serialCharsAvail(void) ;
#line 45 "../include/Garmin.h"
int naks  ;
#line 135
BYTE test[5] ;
#line 1 "../include/util.h"
long TickCount(void) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/garmincomm.c"
int ttyfp ;
#line 42 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/garmincomm.c"
BYTE gGarminMessage[520]  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/garmincomm.c"
static unsigned char checksum  ;
#line 57 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/garmincomm.c"
void sendGPSMessage(BYTE *message___0 , short bytes ) 
{ 
  short i ;
  long n ;
  BYTE gGarminMessage___0[520] ;
  BYTE *p ;
  BYTE *tmp ;
  BYTE *tmp___0 ;
  BYTE *tmp___1 ;
  BYTE *tmp___2 ;
  BYTE *tmp___3 ;
  BYTE *tmp___4 ;
  BYTE *tmp___5 ;

  {
#line 63
  p = gGarminMessage___0;
#line 65
  checksum = (unsigned char)0;
#line 66
  tmp = p;
#line 66
  p ++;
#line 66
  *tmp = (BYTE )16;
#line 68
  i = (short)0;
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! ((int )i < (int )bytes)) {
#line 68
      goto while_break;
    }
#line 70
    tmp___0 = p;
#line 70
    p ++;
#line 70
    *tmp___0 = *(message___0 + i);
#line 71
    checksum = (unsigned char )((int )checksum - (int )*(message___0 + i));
#line 72
    if ((int )*(message___0 + i) == 16) {
#line 73
      tmp___1 = p;
#line 73
      p ++;
#line 73
      *tmp___1 = (BYTE )16;
    }
#line 68
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  tmp___2 = p;
#line 76
  p ++;
#line 76
  *tmp___2 = checksum;
#line 77
  if ((int )checksum == 16) {
#line 78
    tmp___3 = p;
#line 78
    p ++;
#line 78
    *tmp___3 = (BYTE )16;
  }
#line 79
  tmp___4 = p;
#line 79
  p ++;
#line 79
  *tmp___4 = (BYTE )16;
#line 80
  tmp___5 = p;
#line 80
  p ++;
#line 80
  *tmp___5 = (BYTE )3;
#line 81
  n = p - gGarminMessage___0;
#line 83
  if (debugging > 1) {
    {
#line 85
    printf((char const   */* __restrict  */)"  Sending  : ");
#line 86
    i = (short)0;
    }
    {
#line 86
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 86
      if (! ((long )i < n)) {
#line 86
        goto while_break___0;
      }
      {
#line 87
      printf((char const   */* __restrict  */)"%02X ", (int )*(gGarminMessage___0 + (int )i));
#line 86
      i = (short )((int )i + 1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 88
    printf((char const   */* __restrict  */)"\n");
    }
#line 89
    if ((int )bytes != (int )*(message___0 + 1) + 2) {
      {
#line 90
      Error((char *)"sendGPSMessage: invalid byte count\n");
      }
    } else
#line 89
    if ((int )bytes > 254) {
      {
#line 90
      Error((char *)"sendGPSMessage: invalid byte count\n");
      }
    }
  }
  {
#line 93
  write(ttyfp, (void const   *)(gGarminMessage___0), (size_t )n);
  }
#line 94
  return;
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/garmincomm.c"
int CheckGPS(void) 
{ 
  BYTE *p ;
  BYTE last ;
  BYTE c ;
  short err ;
  int igot ;
  short length ;
  long tttime ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  ssize_t tmp___2 ;
  BYTE *tmp___3 ;
  BYTE tmp___4 ;
  int i ;
  long tmp___5 ;

  {
  {
#line 107
  p = gGarminMessage;
#line 108
  last = (BYTE )0;
#line 112
  length = (short)0;
#line 114
  tmp = TickCount();
#line 114
  tttime = tmp;
#line 118
  tmp___0 = serialOpen((enum PROTOCOL )1);
#line 118
  err = (short )tmp___0;
  }
#line 118
  if ((int )err != 0) {
    {
#line 120
    sprintf((char */* __restrict  */)(gMessageStr), (char const   */* __restrict  */)"The initialization of port %s has failed.",
            gPrefs.Device);
#line 122
    Error(gMessageStr);
#line 123
    serialClose();
    }
#line 124
    return (0);
  }
#line 127
  if (debugging) {
    {
#line 128
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CheckGPS: sending test packet\n");
    }
  }
  {
#line 130
  sendGPSMessage(test, (short)4);
  }
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 140
    tmp___1 = TickCount();
    }
#line 140
    if (tmp___1 > tttime + 10L) {
      {
#line 142
      serialClose();
      }
#line 143
      return (0);
    }
    {
#line 146
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 146
      tmp___5 = serialCharsAvail();
      }
#line 146
      if (! tmp___5) {
#line 146
        goto while_break___0;
      }
      {
#line 148
      tmp___2 = read(ttyfp, (void *)(& c), (size_t )1);
#line 148
      igot = (int )tmp___2;
      }
#line 150
      if ((int )c == 16) {
#line 150
        if ((int )last == 16) {
#line 151
          last = (BYTE )0;
        } else {
#line 150
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 154
        if (! ((unsigned long )p < (unsigned long )(gGarminMessage + 520))) {
          {
#line 154
          __assert_fail("p < gGarminMessage + 520", "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/garmincomm.c",
                        154U, "CheckGPS");
          }
        }
#line 155
        tmp___3 = p;
#line 155
        p ++;
#line 155
        tmp___4 = c;
#line 155
        *tmp___3 = tmp___4;
#line 155
        last = tmp___4;
#line 156
        length = (short )((int )length + 1);
      }
#line 160
      if ((int )*(p - 1) == 3) {
#line 160
        if ((int )*(p - 2) == 16) {
#line 162
          if (debugging > 1) {
            {
#line 165
            printf((char const   */* __restrict  */)"  Receiving:   ");
#line 166
            i = 0;
            }
            {
#line 166
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 166
              if (! (i < (int )length)) {
#line 166
                goto while_break___1;
              }
              {
#line 167
              printf((char const   */* __restrict  */)"%02X ", (int )*(gGarminMessage + i));
#line 166
              i ++;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
            {
#line 168
            printf((char const   */* __restrict  */)"\n");
            }
          }
          {
#line 170
          serialClose();
          }
#line 171
          return (1);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 185
enum PROTOCOL mode ;
#line 182 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/garmincomm.c"
short getGPSMessage(void) 
{ 
  BYTE *p ;
  BYTE last ;
  BYTE c ;
  short length ;
  int igot ;
  long tttime ;
  long tmp ;
  long tmp___0 ;
  ssize_t tmp___1 ;
  BYTE *tmp___2 ;
  BYTE tmp___3 ;
  int i ;
  long tmp___4 ;

  {
  {
#line 187
  p = gGarminMessage;
#line 188
  last = (BYTE )0;
#line 190
  length = (short)0;
#line 192
  tmp = TickCount();
#line 192
  tttime = tmp;
#line 194
  checksum = (unsigned char)221;
  }
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 203
    tmp___0 = TickCount();
    }
#line 203
    if (tmp___0 > tttime + 10L) {
      {
#line 205
      CloseBarGraph();
#line 206
      Error((char *)"The GPS receiver is not responding.");
#line 207
      mode = (enum PROTOCOL )0;
      }
#line 208
      return ((short)0);
    }
    {
#line 211
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 211
      tmp___4 = serialCharsAvail();
      }
#line 211
      if (! tmp___4) {
#line 211
        goto while_break___0;
      }
#line 213
      if ((int )length >= 519) {
        {
#line 215
        Error((char *)"GPS receiver communication protocol error.");
#line 216
        mode = (enum PROTOCOL )0;
        }
#line 217
        return ((short)0);
      }
      {
#line 220
      tmp___1 = read(ttyfp, (void *)(& c), (size_t )1);
#line 220
      igot = (int )tmp___1;
      }
#line 222
      if ((int )c == 16) {
#line 222
        if ((int )last == 16) {
#line 223
          last = (BYTE )0;
        } else {
#line 222
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 226
        if (! ((unsigned long )p < (unsigned long )(gGarminMessage + 520))) {
          {
#line 226
          __assert_fail("p < gGarminMessage + 520", "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/garmincomm.c",
                        226U, "getGPSMessage");
          }
        }
#line 227
        tmp___2 = p;
#line 227
        p ++;
#line 227
        tmp___3 = c;
#line 227
        *tmp___2 = tmp___3;
#line 227
        last = tmp___3;
#line 228
        checksum = (unsigned char )((int )checksum + (int )c);
#line 229
        length = (short )((int )length + 1);
      }
#line 233
      if ((int )*(p - 1) == 3) {
#line 233
        if ((int )*(p - 2) == 16) {
#line 235
          if (debugging > 1) {
            {
#line 238
            printf((char const   */* __restrict  */)"  Receiving:   ");
#line 239
            i = 0;
            }
            {
#line 239
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 239
              if (! (i < (int )length)) {
#line 239
                goto while_break___1;
              }
              {
#line 240
              printf((char const   */* __restrict  */)"%02X ", (int )*(gGarminMessage + i));
#line 239
              i ++;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
            {
#line 241
            printf((char const   */* __restrict  */)"\n");
            }
#line 242
            if (debugging) {
#line 242
              if (checksum) {
                {
#line 243
                printf((char const   */* __restrict  */)"getGPSMessage: ########  checksum=%d is nonzero  #########\n",
                       (int )checksum);
                }
              }
            }
          }
#line 247
          return (length);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 256 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/garmincomm.c"
int getGPSack(void) 
{ 
  int n ;
  int trial ;
  short tmp ;

  {
#line 260
  trial = 0;
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 260
    if (! (trial < 3)) {
#line 260
      goto while_break;
    }
    {
#line 262
    tmp = getGPSMessage();
#line 262
    n = (int )tmp;
    }
#line 263
    if (n < 8) {
#line 263
      goto _L;
    } else
#line 263
    if ((int )gGarminMessage[0] != 16) {
#line 263
      goto _L;
    } else
#line 263
    if ((int )gGarminMessage[2] != n - 6) {
#line 263
      goto _L;
    } else
#line 263
    if (checksum) {
#line 263
      goto _L;
    } else
#line 263
    if ((int )gGarminMessage[n - 2] != 16) {
#line 263
      goto _L;
    } else
#line 263
    if ((int )gGarminMessage[n - 1] != 3) {
      _L: /* CIL Label */ 
#line 271
      if (debugging) {
        {
#line 272
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"GPSack: discarding invalid packet\n");
        }
      }
#line 273
      goto __Cont;
    }
#line 275
    if ((int )gGarminMessage[1] == 6) {
#line 276
      return (n);
    }
#line 277
    if ((int )gGarminMessage[1] == 21) {
#line 279
      naks ++;
#line 280
      return (0);
    }
#line 282
    if (debugging) {
      {
#line 283
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"GPSack: discarding packet type 0x%02X=%d, neither ACK nor NAK\n",
              (int )gGarminMessage[1], (int )gGarminMessage[1]);
      }
    }
    __Cont: /* CIL Label */ 
#line 260
    trial ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 287
  return (0);
}
}
#line 689 "/usr/include/stdio.h"
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 239 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 319
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) timegm)(struct tm *__tp ) ;
#line 460 "/usr/include/unistd.h"
extern int usleep(__useconds_t __useconds ) ;
#line 47 "../include/Garmin.h"
void getGPSInfo(FILE *refNum___0 , short type ) ;
#line 49
void saveFormat(char *fileData___1 , short type ) ;
#line 54
char *secs2dt(long secs , short offset ) ;
#line 61
void DegToKKJ(double lat , double lon , char *zone , double *x , double *y ) ;
#line 77
void DegToSEG(double lat , double lon , double *x , double *y ) ;
#line 80
void DegToITM(double lat , double lon , char *zone , double *x , double *y ) ;
#line 129
BYTE alm1[5] ;
#line 129
BYTE alm2[5] ;
#line 130
BYTE trk1[5] ;
#line 130
BYTE trk2[5] ;
#line 131
BYTE wpt1[5] ;
#line 131
BYTE wpt2[5] ;
#line 132
BYTE rte1[5] ;
#line 132
BYTE rte2[5] ;
#line 134
BYTE gid4[3] ;
#line 134
BYTE gid5[5] ;
#line 136
BYTE tim1[5] ;
#line 2 "../include/util.h"
void *xmalloc(int num ) ;
#line 56 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) asin)(double __x ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/getgpsinfo.c"
static short records___0  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/getgpsinfo.c"
static FILE *FileRefNum  ;
#line 50 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/getgpsinfo.c"
static char fileData___0[512]  ;
#line 51 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/getgpsinfo.c"
static int AlmanacSat  =    0;
#line 52 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/getgpsinfo.c"
char GPSVersionStr[255]  ;
#line 55 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/getgpsinfo.c"
static int xmap_route_nr  =    0;
#line 56 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/getgpsinfo.c"
static long xmap_time  =    0L;
#line 57 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/getgpsinfo.c"
static double xmap_lat  =    (double )0;
#line 58 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/getgpsinfo.c"
static double xmap_lon  =    (double )0;
#line 59 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/getgpsinfo.c"
static float xmap_speed  =    (float )0;
#line 60
static char *colorCodeToName(int code ) ;
#line 61
static void doTrackHeader(void) ;
#line 67
static void doWaypoint_xmap(void) ;
#line 68
static double distance(double lata , double lona , double latb , double lonb ) ;
#line 70
static void parseGPS(void) ;
#line 71
static void doWaypoint___0(void) ;
#line 72
static void doRouteName(void) ;
#line 73
static void doAlmanac___0(void) ;
#line 74
static long number(BYTE *p ) ;
#line 75
static char *string(short n , BYTE *p ) ;
#line 76
static void FileWrite(char *data ) ;
#line 77
static float tofloat(unsigned char *p ) ;
#line 78
static short toshort(unsigned char *p ) ;
#line 86 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/getgpsinfo.c"
void saveFormat(char *fileData___1 , short type ) 
{ 
  char format[4] ;
  time_t thistime ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;

  {
  {
#line 97
  if ((unsigned int )gPrefs.format == 0U) {
#line 97
    goto case_0;
  }
#line 100
  if ((unsigned int )gPrefs.format == 1U) {
#line 100
    goto case_1;
  }
#line 106
  if ((unsigned int )gPrefs.format == 2U) {
#line 106
    goto case_2;
  }
#line 109
  if ((unsigned int )gPrefs.format == 3U) {
#line 109
    goto case_3;
  }
#line 112
  if ((unsigned int )gPrefs.format == 6U) {
#line 112
    goto case_6;
  }
#line 115
  if ((unsigned int )gPrefs.format == 4U) {
#line 115
    goto case_4;
  }
#line 118
  if ((unsigned int )gPrefs.format == 5U) {
#line 118
    goto case_5;
  }
#line 121
  if ((unsigned int )gPrefs.format == 7U) {
#line 121
    goto case_7;
  }
#line 124
  if ((unsigned int )gPrefs.format == 8U) {
#line 124
    goto case_8;
  }
#line 103
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 98
  strcpy((char */* __restrict  */)(format), (char const   */* __restrict  */)"DMS");
  }
#line 99
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 101
  strcpy((char */* __restrict  */)(format), (char const   */* __restrict  */)"DMM");
  }
#line 102
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 104
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"format code not recognized - using DDD instead\n");
#line 105
  gPrefs.format = (enum FORMAT )2;
  }
  case_2: /* CIL Label */ 
  {
#line 107
  strcpy((char */* __restrict  */)(format), (char const   */* __restrict  */)"DDD");
  }
#line 108
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 110
  strcpy((char */* __restrict  */)(format), (char const   */* __restrict  */)"UTM");
  }
#line 111
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 113
  strcpy((char */* __restrict  */)(format), (char const   */* __restrict  */)"KKJ");
  }
#line 114
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 116
  strcpy((char */* __restrict  */)(format), (char const   */* __restrict  */)"BNG");
  }
#line 117
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 119
  strcpy((char */* __restrict  */)(format), (char const   */* __restrict  */)"ITM");
  }
#line 120
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 122
  strcpy((char */* __restrict  */)(format), (char const   */* __restrict  */)"SEG");
  }
#line 123
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 125
  strcpy((char */* __restrict  */)(format), (char const   */* __restrict  */)"GKK");
  }
#line 126
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 132
  if ((unsigned int )file_format == 3335U) {
#line 132
    goto case_3335;
  }
#line 132
  if ((unsigned int )file_format == 3334U) {
#line 132
    goto case_3335;
  }
#line 142
  if ((unsigned int )file_format == 3333U) {
#line 142
    goto case_3333;
  }
#line 129
  goto switch_break___0;
  case_3335: /* CIL Label */ 
  case_3334: /* CIL Label */ 
  {
#line 133
  time(& thistime);
  }
#line 134
  if ((int )type == 2) {
    {
#line 135
    tmp = ctime((time_t const   *)(& thistime));
#line 135
    sprintf((char */* __restrict  */)fileData___1, (char const   */* __restrict  */)"xmaplog 1.0 %s",
            tmp);
    }
  } else
#line 136
  if ((int )type == 1) {
    {
#line 137
    tmp___0 = ctime((time_t const   *)(& thistime));
#line 137
    sprintf((char */* __restrict  */)fileData___1, (char const   */* __restrict  */)"xmaproute 1.0 %s",
            tmp___0);
    }
  } else {
    {
#line 139
    tmp___1 = ctime((time_t const   *)(& thistime));
#line 139
    sprintf((char */* __restrict  */)fileData___1, (char const   */* __restrict  */)"unknown xmap format %s",
            tmp___1);
    }
  }
#line 140
  goto switch_break___0;
  case_3333: /* CIL Label */ 
  {
#line 155
  sprintf((char */* __restrict  */)fileData___1, (char const   */* __restrict  */)"Format: %s  UTC Offset: %6.2f hrs  Datum[%03d]: %s\n",
          format, gPrefs.offset, (int )gPrefs.datum, gDatum[gPrefs.datum].name);
  }
  {
#line 161
  if ((int )type == 3) {
#line 161
    goto case_3___0;
  }
#line 161
  if ((int )type == 1) {
#line 161
    goto case_3___0;
  }
#line 224
  if ((int )type == 2) {
#line 224
    goto case_2___0;
  }
#line 158
  goto switch_break___1;
  case_3___0: /* CIL Label */ 
  case_1___0: /* CIL Label */ 
  {
#line 163
  tmp___12 = strstr((char const   *)protocols, "A100 D100");
  }
#line 163
  if (tmp___12) {
    {
#line 164
    strcat((char */* __restrict  */)fileData___1, (char const   */* __restrict  */)"Type\tName\tComment                                     \t");
    }
  } else {
    {
#line 168
    tmp___11 = strstr((char const   *)protocols, "A100 D101");
    }
#line 168
    if (tmp___11) {
      {
#line 169
      strcat((char */* __restrict  */)fileData___1, (char const   */* __restrict  */)"Type\tName\tComment                                     \t");
      }
    } else {
      {
#line 173
      tmp___10 = strstr((char const   *)protocols, "A100 D102");
      }
#line 173
      if (tmp___10) {
        {
#line 174
        strcat((char */* __restrict  */)fileData___1, (char const   */* __restrict  */)"Type\tName\tComment                                     \t");
        }
      } else {
        {
#line 178
        tmp___9 = strstr((char const   *)protocols, "A100 D103");
        }
#line 178
        if (tmp___9) {
          {
#line 179
          strcat((char */* __restrict  */)fileData___1, (char const   */* __restrict  */)"Type\tName\tComment                                     \t");
          }
        } else {
          {
#line 183
          tmp___8 = strstr((char const   *)protocols, "A100 D104");
          }
#line 183
          if (tmp___8) {
            {
#line 184
            strcat((char */* __restrict  */)fileData___1, (char const   */* __restrict  */)"Type\tName\tComment                                     \t");
            }
          } else {
            {
#line 188
            tmp___7 = strstr((char const   *)protocols, "A100 D105");
            }
#line 188
            if (tmp___7) {
              {
#line 189
              strcat((char */* __restrict  */)fileData___1, (char const   */* __restrict  */)"Type\tName\tComment                                             \t");
              }
            } else {
              {
#line 193
              tmp___6 = strstr((char const   *)protocols, "A100 D106");
              }
#line 193
              if (tmp___6) {
                {
#line 194
                strcat((char */* __restrict  */)fileData___1, (char const   */* __restrict  */)"Type\tName\tComment                                             \t");
                }
              } else {
                {
#line 198
                tmp___5 = strstr((char const   *)protocols, "A100 D107");
                }
#line 198
                if (tmp___5) {
                  {
#line 199
                  strcat((char */* __restrict  */)fileData___1, (char const   */* __restrict  */)"Type\tName\tComment                                     \t");
                  }
                } else {
                  {
#line 203
                  tmp___4 = strstr((char const   *)protocols, "A100 D108");
                  }
#line 203
                  if (tmp___4) {
                    {
#line 204
                    strcat((char */* __restrict  */)fileData___1, (char const   */* __restrict  */)"Type\tName\tComment                                             \tAltitude\t");
                    }
                  } else {
                    {
#line 209
                    tmp___3 = strstr((char const   *)protocols, "A100 D109");
                    }
#line 209
                    if (tmp___3) {
                      {
#line 210
                      strcat((char */* __restrict  */)fileData___1, (char const   */* __restrict  */)"Type\tName\tComment                                             \tDate       \tAltitude\t");
                      }
                    } else {
                      {
#line 216
                      tmp___2 = strstr((char const   *)protocols, "A100 D110");
                      }
#line 216
                      if (tmp___2) {
                        {
#line 217
                        strcat((char */* __restrict  */)fileData___1, (char const   */* __restrict  */)"Type\tName\tComment                                             \tDate       \tAltitude\t");
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 223
  goto switch_break___1;
  case_2___0: /* CIL Label */ 
  {
#line 225
  tmp___15 = strstr((char const   *)protocols, "D300");
  }
#line 225
  if (tmp___15) {
    {
#line 226
    strcat((char */* __restrict  */)fileData___1, (char const   */* __restrict  */)"Type\tDate               \t");
    }
  } else {
    {
#line 229
    tmp___14 = strstr((char const   *)protocols, "D301");
    }
#line 229
    if (tmp___14) {
      {
#line 230
      strcat((char */* __restrict  */)fileData___1, (char const   */* __restrict  */)"Type\tDate               \tAltitude\t");
      }
    } else {
      {
#line 234
      tmp___13 = strstr((char const   *)protocols, "D302");
      }
#line 234
      if (tmp___13) {
        {
#line 235
        strcat((char */* __restrict  */)fileData___1, (char const   */* __restrict  */)"Type\tDate               \tAltitude\t");
        }
      }
    }
  }
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 245
  if ((unsigned int )gPrefs.format == 2U) {
#line 245
    goto case_2___1;
  }
#line 245
  if ((unsigned int )gPrefs.format == 1U) {
#line 245
    goto case_2___1;
  }
#line 245
  if ((unsigned int )gPrefs.format == 0U) {
#line 245
    goto case_2___1;
  }
#line 246
  if ((unsigned int )gPrefs.format == 3U) {
#line 246
    goto case_3___1;
  }
#line 249
  if ((unsigned int )gPrefs.format == 6U) {
#line 249
    goto case_6___0;
  }
#line 249
  if ((unsigned int )gPrefs.format == 5U) {
#line 249
    goto case_6___0;
  }
#line 249
  if ((unsigned int )gPrefs.format == 4U) {
#line 249
    goto case_6___0;
  }
#line 252
  if ((unsigned int )gPrefs.format == 8U) {
#line 252
    goto case_8___0;
  }
#line 252
  if ((unsigned int )gPrefs.format == 7U) {
#line 252
    goto case_8___0;
  }
#line 253
  goto switch_default___0;
  case_2___1: /* CIL Label */ 
  case_1___1: /* CIL Label */ 
  case_0___0: /* CIL Label */ 
  {
#line 245
  strcat((char */* __restrict  */)fileData___1, (char const   */* __restrict  */)"Latitude\tLongitude\t\n");
  }
#line 245
  goto switch_break___2;
  case_3___1: /* CIL Label */ 
  {
#line 246
  strcat((char */* __restrict  */)fileData___1, (char const   */* __restrict  */)"ZE\tZN\tEasting\tNorthing\t\n");
  }
#line 246
  goto switch_break___2;
  case_6___0: /* CIL Label */ 
  case_5___0: /* CIL Label */ 
  case_4___0: /* CIL Label */ 
  {
#line 249
  strcat((char */* __restrict  */)fileData___1, (char const   */* __restrict  */)"Zone\tEasting\tNorthing\t\n");
  }
#line 249
  goto switch_break___2;
  case_8___0: /* CIL Label */ 
  case_7___0: /* CIL Label */ 
  {
#line 252
  strcat((char */* __restrict  */)fileData___1, (char const   */* __restrict  */)"Easting\tNorthing\t\n");
  }
#line 252
  goto switch_break___2;
  switch_default___0: /* CIL Label */ ;
  switch_break___2: /* CIL Label */ ;
  }
#line 255
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 257
  return;
}
}
#line 272
unsigned short product_ID ;
#line 272
unsigned short software_version ;
#line 389 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/getgpsinfo.c"
static protocol_t historic_protocols[56]  = 
#line 389
  {      {(u_int16_t )7, (int16_t )0, (char *)"L001 A010 A100 D100 A200 D200 D100 A500 D500 A600 D600 A700 D700"}, 
        {(u_int16_t )25,
      (int16_t )0, (char *)"L001 A010 A100 D100 A200 D200 D100 A300 D300 A400 D400 A500 D500 A600 D600 A700 D700"}, 
        {(u_int16_t )13,
      (int16_t )0, (char *)"L001 A010 A100 D100 A200 D200 D100 A300 D300 A400 D400 A500 D500 A600 D600 A700 D700"}, 
        {(u_int16_t )14,
      (int16_t )0, (char *)"L001 A010 A100 D100 A200 D200 D100 A400 D400 A500 D500 A600 D600 A700 D700"}, 
        {(u_int16_t )15,
      (int16_t )0, (char *)"L001 A010 A100 D151 A200 D200 D151 A400 D151 A500 D500 A600 D600 A700 D700"}, 
        {(u_int16_t )18,
      (int16_t )0, (char *)"L001 A010 A100 D100 A200 D200 D100 A300 D300 A400 D400 A500 D500 A600 D600 A700 D700"}, 
        {(u_int16_t )20,
      (int16_t )0, (char *)"L002 A011 A100 D150 A200 D201 D150 A400 D450 A500 D550 A600 D600 A700 D700"}, 
        {(u_int16_t )22,
      (int16_t )0, (char *)"L001 A010 A100 D152 A200 D200 D152 A300 D300 A400 D152 A500 D500 A600 D600 A700 D700"}, 
        {(u_int16_t )23,
      (int16_t )0, (char *)"L001 A010 A100 D100 A200 D200 D100 A300 D300 A400 D400 A500 D500 A600 D600 A700 D700"}, 
        {(u_int16_t )24,
      (int16_t )0, (char *)"L001 A010 A100 D100 A200 D200 D100 A300 D300 A400 D400 A500 D500 A600 D600 A700 D700"}, 
        {(u_int16_t )29,
      (int16_t )0, (char *)"L001 A010 A100 D101 A200 D201 D101 A300 D300 A400 D101 A500 D500 A600 D600 A700 D700"}, 
        {(u_int16_t )29,
      (int16_t )400, (char *)"L001 A010 A100 D102 A200 D201 D102 A300 D300 A400 D102 A500 D500 A600 D600 A700 D700"}, 
        {(u_int16_t )31,
      (int16_t )0, (char *)"L001 A010 A100 D100 A200 D201 D100 A300 D300 A500 D500 A600 D600 A700 D700"}, 
        {(u_int16_t )33,
      (int16_t )0, (char *)"L002 A011 A100 D150 A200 D201 D150 A400 D450 A500 D550 A600 D600 A700 D700"}, 
        {(u_int16_t )34,
      (int16_t )0, (char *)"L002 A011 A100 D150 A200 D201 D150 A400 D450 A500 D550 A600 D600 A700 D700"}, 
        {(u_int16_t )35,
      (int16_t )0, (char *)"L001 A010 A100 D100 A200 D200 D100 A300 D300 A400 D400 A500 D500 A600 D600 A700 D700"}, 
        {(u_int16_t )36,
      (int16_t )0, (char *)"L001 A010 A100 D152 A200 D200 D152 A300 D300 A400 D152 A500 D500 A600 D600 A700 D700"}, 
        {(u_int16_t )36,
      (int16_t )300, (char *)"L001 A010 A100 D152 A200 D200 D152 A300 D300 A500 D500 A600 D600 A700 D700"}, 
        {(u_int16_t )39,
      (int16_t )0, (char *)"L001 A010 A100 D151 A200 D201 D151 A300 D300 A500 D500 A600 D600 A700 D700"}, 
        {(u_int16_t )41,
      (int16_t )0, (char *)"L001 A010 A100 D100 A200 D201 D100 A300 D300 A500 D500 A600 D600 A700 D700"}, 
        {(u_int16_t )42,
      (int16_t )0, (char *)"L001 A010 A100 D100 A200 D200 D100 A300 D300 A400 D400 A500 D500 A600 D600 A700 D700"}, 
        {(u_int16_t )44,
      (int16_t )0, (char *)"L001 A010 A100 D101 A200 D201 D101 A300 D300 A400 D101 A500 D500 A600 D600 A700 D700"}, 
        {(u_int16_t )45,
      (int16_t )0, (char *)"L001 A010 A100 D152 A200 D201 D152 A300 D300 A500 D500 A600 D600 A700 D700"}, 
        {(u_int16_t )47,
      (int16_t )0, (char *)"L001 A010 A100 D100 A200 D201 D100 A300 D300 A500 D500 A600 D600 A700 D700"}, 
        {(u_int16_t )48,
      (int16_t )0, (char *)"L001 A010 A100 D154 A200 D201 D154 A300 D300 A500 D501 A600 D600 A700 D700"}, 
        {(u_int16_t )49,
      (int16_t )0, (char *)"L001 A010 A100 D102 A200 D201 D102 A300 D300 A400 D102 A500 D501 A600 D600 A700 D700"}, 
        {(u_int16_t )50,
      (int16_t )0, (char *)"L001 A010 A100 D152 A200 D201 D152 A300 D300 A500 D501 A600 D600 A700 D700"}, 
        {(u_int16_t )52,
      (int16_t )0, (char *)"L002 A011 A100 D150 A200 D201 D150 A400 D450 A500 D550 A600 D600 A700 D700"}, 
        {(u_int16_t )53,
      (int16_t )0, (char *)"L001 A010 A100 D152 A200 D201 D152 A300 D300 A500 D501 A600 D600 A700 D700"}, 
        {(u_int16_t )55,
      (int16_t )0, (char *)"L001 A010 A100 D100 A200 D201 D100 A300 D300 A500 D500 A600 D600 A700 D700"}, 
        {(u_int16_t )56,
      (int16_t )0, (char *)"L001 A010 A100 D100 A200 D201 D100 A300 D300 A500 D500 A600 D600 A700 D700"}, 
        {(u_int16_t )59,
      (int16_t )0, (char *)"L001 A010 A100 D100 A200 D201 D100 A300 D300 A500 D500 A600 D600 A700 D700"}, 
        {(u_int16_t )61,
      (int16_t )0, (char *)"L001 A010 A100 D100 A200 D201 D100 A300 D300 A500 D500 A600 D600 A700 D700"}, 
        {(u_int16_t )62,
      (int16_t )0, (char *)"L001 A010 A100 D100 A200 D201 D100 A300 D300 A500 D500 A600 D600 A700 D700"}, 
        {(u_int16_t )64,
      (int16_t )0, (char *)"L002 A011 A100 D150 A200 D201 D150 A400 D450 A500 D551 A600 D600 A700 D700"}, 
        {(u_int16_t )71,
      (int16_t )0, (char *)"L001 A010 A100 D155 A200 D201 D155 A300 D300 A500 D501 A600 D600 A700 D700"}, 
        {(u_int16_t )72,
      (int16_t )0, (char *)"L001 A010 A100 D104 A200 D201 D104 A300 D300 A500 D501 A600 D600 A700 D700"}, 
        {(u_int16_t )73,
      (int16_t )0, (char *)"L001 A010 A100 D103 A200 D201 D103 A300 D300 A500 D501 A600 D600 A700 D700"}, 
        {(u_int16_t )74,
      (int16_t )0, (char *)"L001 A010 A100 D100 A200 D201 D100 A300 D300 A500 D500 A600 D600 A700 D700"}, 
        {(u_int16_t )76,
      (int16_t )0, (char *)"L001 A010 A100 D102 A200 D201 D102 A300 D300 A400 D102 A500 D501 A600 D600 A700 D700"}, 
        {(u_int16_t )77,
      (int16_t )0, (char *)"L001 A010 A100 D100 A200 D201 D100 A300 D300 A400 D400 A500 D501 A600 D600 A700 D700"}, 
        {(u_int16_t )77,
      (int16_t )301, (char *)"L001 A010 A100 D103 A200 D201 D103 A300 D300 A400 D403 A500 D501 A600 D600 A700 D700"}, 
        {(u_int16_t )77,
      (int16_t )350, (char *)"L001 A010 A100 D103 A200 D201 D103 A300 D300 A500 D501 A600 D600 A700 D700"}, 
        {(u_int16_t )77,
      (int16_t )361, (char *)"L001 A010 A100 D103 A200 D201 D103 A300 D300 A400 D403 A500 D501 A600 D600 A700 D700"}, 
        {(u_int16_t )87,
      (int16_t )0, (char *)"L001 A010 A100 D103 A200 D201 D103 A300 D300 A400 D403 A500 D501 A600 D600 A700 D700"}, 
        {(u_int16_t )88,
      (int16_t )0, (char *)"L001 A010 A100 D102 A200 D201 D102 A300 D300 A400 D102 A500 D501 A600 D600 A700 D700"}, 
        {(u_int16_t )95,
      (int16_t )0, (char *)"L001 A010 A100 D103 A200 D201 D103 A300 D300 A400 D403 A500 D501 A600 D600 A700 D700"}, 
        {(u_int16_t )96,
      (int16_t )0, (char *)"L001 A010 A100 D103 A200 D201 D103 A300 D300 A400 D403 A500 D501 A600 D600 A700 D700"}, 
        {(u_int16_t )97,
      (int16_t )0, (char *)"L001 A010 A100 D103 A200 D201 D103 A300 D300 A500 D501 A600 D600 A700 D700"}, 
        {(u_int16_t )98,
      (int16_t )0, (char *)"L002 A011 A100 D150 A200 D201 D150 A400 D450 A500 D551 A600 D600 A700 D700"}, 
        {(u_int16_t )100,
      (int16_t )0, (char *)"L001 A010 A100 D103 A200 D201 D103 A300 D300 A400 D403 A500 D501 A600 D600 A700 D700"}, 
        {(u_int16_t )105,
      (int16_t )0, (char *)"L001 A010 A100 D103 A200 D201 D103 A300 D300 A400 D403 A500 D501 A600 D600 A700 D700"}, 
        {(u_int16_t )106,
      (int16_t )0, (char *)"L001 A010 A100 D103 A200 D201 D103 A300 D300 A400 D403 A500 D501 A600 D600 A700 D700"}, 
        {(u_int16_t )112,
      (int16_t )0, (char *)"L001 A010 A100 D152 A200 D201 D152 A300 D300 A500 D501 A600 D600 A700 D700"}, 
        {(u_int16_t )179,
      (int16_t )0, (char *)"L001 A010 A100 D108 A201 D202 D108 D210 A301 D310 D301 A500 D501 A600 D600 A700 D700 A800 D800 A900 A902 A903"}, 
        {(u_int16_t )0,
      (short)0, (char *)0}};
#line 264 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/getgpsinfo.c"
int getGPSVersion(char **string___0 ) 
{ 
  char temp[255] ;
  short err ;
  int last ;
  int i ;
  BYTE *data ;
  int tmp ;
  short tmp___0 ;
  short tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  char *p ;
  BYTE *s___0 ;
  BYTE tag ;
  unsigned short udata ;
  int n ;
  void *tmp___6 ;
  short tmp___7 ;
  protocol_t *p___0 ;
  protocol_t *next ;
  long tmp___8 ;
  int tmp___9 ;

  {
  {
#line 270
  last = 0;
#line 271
  data = gGarminMessage + 3;
#line 274
  *string___0 = gMessageStr;
#line 275
  SetFrameBusy(1);
#line 278
  tmp___9 = CheckGPS();
  }
#line 278
  if (tmp___9) {
    {
#line 280
    usleep((__useconds_t )10000);
#line 281
    tmp = serialOpen((enum PROTOCOL )1);
#line 281
    err = (short )tmp;
    }
#line 281
    if ((int )err != 0) {
      {
#line 283
      sprintf((char */* __restrict  */)(gMessageStr), (char const   */* __restrict  */)"The port initialization of %s has failed.",
              gPrefs.Device);
#line 285
      Error(gMessageStr);
      }
#line 286
      return (1);
    }
#line 289
    if (debugging) {
      {
#line 290
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getGPSVersion: sending product data request\n");
      }
    }
    {
#line 293
    sendGPSMessage(gid4, (short)2);
#line 294
    getGPSack();
#line 296
    getGPSMessage();
#line 297
    sendGPSMessage(gid5, (short)4);
#line 307
    tmp___0 = toshort(data);
#line 307
    product_ID = (unsigned short )tmp___0;
#line 308
    tmp___1 = toshort(data + 2);
#line 308
    software_version = (unsigned short )tmp___1;
#line 311
    sprintf((char */* __restrict  */)(GPSVersionStr), (char const   */* __restrict  */)"Garmin %s",
            gGarminMessage + 7);
#line 312
    tmp___2 = strlen((char const   *)(GPSVersionStr));
#line 312
    GPSVersionStr[tmp___2 - 1UL] = (char )'\000';
#line 313
    i = 0;
    }
    {
#line 313
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 313
      tmp___3 = strlen((char const   *)(GPSVersionStr));
      }
#line 313
      if (! ((size_t )i <= tmp___3)) {
#line 313
        goto while_break;
      }
#line 315
      if ((int )GPSVersionStr[i] == 32) {
#line 316
        last = i;
      }
#line 313
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 318
    sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)" - V%s",
            & GPSVersionStr[last + 1]);
#line 319
    GPSVersionStr[last] = (char )'\000';
    }
    {
#line 320
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 320
      if (i > 0) {
        {
#line 320
        tmp___5 = strlen((char const   *)(GPSVersionStr));
        }
#line 320
        if (! ((int )GPSVersionStr[tmp___5 - 1UL] == 32)) {
#line 320
          goto while_break___0;
        }
      } else {
#line 320
        goto while_break___0;
      }
      {
#line 321
      tmp___4 = strlen((char const   *)(GPSVersionStr));
#line 321
      GPSVersionStr[tmp___4 - 1UL] = (char )'\000';
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 323
    sprintf((char */* __restrict  */)(GPSVersionStr), (char const   */* __restrict  */)"%s%s",
            GPSVersionStr, temp);
#line 325
    usleep((__useconds_t )10000);
#line 327
    tmp___8 = serialCharsAvail();
    }
#line 327
    if (tmp___8) {
      {
#line 331
      s___0 = data;
#line 335
      getGPSMessage();
#line 336
      n = (int )*(data + -1);
      }
#line 337
      if (n < 0) {
#line 338
        n = 0;
      }
      {
#line 339
      tmp___6 = xmalloc((5 * n) / 3 + 1);
#line 339
      protocols = (char *)tmp___6;
#line 339
      p = protocols;
      }
      {
#line 340
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 340
        if (! (n > 0)) {
#line 340
          goto while_break___1;
        }
        {
#line 342
        tag = *s___0;
#line 342
        tmp___7 = toshort(s___0 + 1);
#line 342
        udata = (unsigned short )tmp___7;
#line 344
        sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)" %c%03d",
                (int )tag, (int )udata);
#line 345
        s___0 += 3;
#line 345
        p += 5;
#line 340
        n -= 3;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 347
      *p = (char)0;
    } else {
#line 451
      p___0 = historic_protocols;
#line 453
      if (verbose) {
        {
#line 454
        printf((char const   */* __restrict  */)"checking historic protocols for product ID %d\n",
               (int )product_ID);
        }
      }
      {
#line 456
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 456
        if (! p___0->product_ID) {
#line 456
          goto while_break___2;
        }
#line 458
        if ((int )p___0->product_ID == (int )product_ID) {
          {
#line 459
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 461
            next = p___0 + 1;
#line 462
            if ((int )next->product_ID != (int )product_ID) {
#line 464
              goto found_protocol;
            } else
#line 462
            if ((int )software_version < (int )next->software_version) {
#line 464
              goto found_protocol;
            }
#line 465
            p___0 ++;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 467
        p___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 469
      printf((char const   */* __restrict  */)"Warning: device with product ID %d is unknown - assuming it\'s like a GPS II.\n",
             (int )product_ID);
#line 471
      p___0 = historic_protocols + 31;
      }
      found_protocol: 
#line 474
      protocols = p___0->protocol;
    }
    {
#line 476
    usleep((__useconds_t )60000);
    }
#line 478
    if (debugging) {
      {
#line 479
      printf((char const   */* __restrict  */)"product ID 0x%02x=%d, software version 0x%04x=%d, protocol string: \n%s\n",
             (int )product_ID, (int )product_ID, (int )software_version, (int )software_version,
             protocols);
      }
    }
    {
#line 482
    serialClose();
#line 484
    SetFrameBusy(0);
    }
  } else {
    {
#line 488
    sprintf((char */* __restrict  */)(GPSVersionStr), (char const   */* __restrict  */)"<GPS not responding>");
#line 490
    SetFrameBusy(0);
#line 491
    *string___0 = GPSVersionStr;
    }
#line 492
    return (1);
  }
#line 494
  *string___0 = GPSVersionStr;
#line 495
  return (0);
}
}
#line 502 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/getgpsinfo.c"
long getGPSTime(int var ) 
{ 
  short err ;
  struct tm *txx ;
  time_t clock___0 ;
  int tmp ;
  int tmp___0 ;
  short tmp___1 ;

  {
  {
#line 513
  tmp = CheckGPS();
  }
#line 513
  if (! tmp) {
    {
#line 514
    NotResponding();
    }
  }
  {
#line 517
  tmp___0 = serialOpen((enum PROTOCOL )1);
#line 517
  err = (short )tmp___0;
  }
#line 517
  if ((int )err != 0) {
    {
#line 519
    sprintf((char */* __restrict  */)(gMessageStr), (char const   */* __restrict  */)"The port initialization of %s has failed.",
            gPrefs.Device);
#line 521
    Error(gMessageStr);
    }
#line 522
    return (0L);
  }
#line 525
  if ((int )gPrefs.model == 121) {
    {
#line 528
    sendGPSMessage(tim1, (short)4);
#line 529
    getGPSack();
#line 530
    getGPSMessage();
    }
  } else {
    {
#line 536
    sendGPSMessage(tim1, (short)4);
#line 537
    getGPSack();
#line 538
    getGPSMessage();
#line 539
    getGPSack();
#line 540
    getGPSMessage();
    }
  }
  {
#line 547
  serialClose();
  }
#line 551
  if ((int )*(gGarminMessage + 1) != 14) {
#line 552
    return (-1L);
  }
  {
#line 555
  time(& clock___0);
#line 556
  txx = gmtime((time_t const   *)(& clock___0));
#line 559
  txx->tm_sec = (int )*(gGarminMessage + 10);
#line 560
  txx->tm_min = (int )*(gGarminMessage + 9);
#line 561
  txx->tm_hour = (int )*(gGarminMessage + 7);
#line 562
  tmp___1 = toshort(gGarminMessage + 5);
#line 562
  txx->tm_year = (int )tmp___1 - 1900;
#line 563
  txx->tm_mday = (int )*(gGarminMessage + 4);
#line 564
  txx->tm_mon = (int )*(gGarminMessage + 3) - 1;
#line 566
  clock___0 = timegm(txx);
  }
#line 567
  return (clock___0);
}
}
#line 574 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/getgpsinfo.c"
void getGPSInfo(FILE *refNum___0 , short type ) 
{ 
  short total ;
  short done ;
  BYTE *init ;
  BYTE *req ;
  short err ;
  char *rType ;
  int junk ;
  char *junk_str ;
  int tmp ;
  int tmp___0 ;
  short tmp___1 ;
  short tmp___2 ;

  {
  {
#line 581
  done = (short)0;
#line 589
  tmp = CheckGPS();
  }
#line 589
  if (! tmp) {
    {
#line 590
    NotResponding();
    }
  }
  {
#line 592
  junk = getGPSVersion(& junk_str);
#line 595
  tmp___0 = serialOpen((enum PROTOCOL )1);
#line 595
  err = (short )tmp___0;
  }
#line 595
  if ((int )err != 0) {
    {
#line 597
    sprintf((char */* __restrict  */)(gMessageStr), (char const   */* __restrict  */)"The port initialization of %s has failed.",
            gPrefs.Device);
#line 599
    Error(gMessageStr);
    }
#line 600
    return;
  }
  {
#line 603
  FileRefNum = refNum___0;
#line 604
  records___0 = (short)0;
#line 607
  saveFormat(fileData___0, type);
  }
#line 608
  if ((int )type != 0) {
    {
#line 609
    FileWrite(fileData___0);
    }
  }
  {
#line 616
  if ((int )type == 1) {
#line 616
    goto case_1;
  }
#line 617
  if ((int )type == 2) {
#line 617
    goto case_2;
  }
#line 618
  if ((int )type == 3) {
#line 618
    goto case_3;
  }
#line 614
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 615
  init = alm1;
#line 615
  req = alm2;
#line 615
  rType = (char *)"almanac";
#line 615
  goto switch_break;
  case_1: /* CIL Label */ 
#line 616
  init = rte1;
#line 616
  req = rte2;
#line 616
  rType = (char *)"routes";
#line 616
  goto switch_break;
  case_2: /* CIL Label */ 
#line 617
  init = trk1;
#line 617
  req = trk2;
#line 617
  rType = (char *)"track";
#line 617
  goto switch_break;
  case_3: /* CIL Label */ 
#line 618
  init = wpt1;
#line 618
  req = wpt2;
#line 618
  rType = (char *)"waypoint";
#line 618
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 621
  AlmanacSat = 0;
#line 624
  InitBarGraph();
#line 627
  sendGPSMessage(init, (short)4);
#line 628
  getGPSack();
#line 631
  tmp___1 = getGPSMessage();
  }
#line 631
  if ((int )tmp___1 == 0) {
    {
#line 633
    CloseBarGraph();
#line 634
    serialClose();
    }
#line 635
    return;
  }
  {
#line 637
  total = toshort(gGarminMessage + 3);
  }
#line 639
  if (verbose) {
    {
#line 641
    sprintf((char */* __restrict  */)(gMessageStr), (char const   */* __restrict  */)"GPS receiver will send %d packets.",
            (int )total);
#line 643
    Message(gMessageStr);
    }
  }
#line 645
  if ((int )total < 1) {
#line 646
    total = (short)1;
  }
  {
#line 650
  while (1) {
    while_continue: /* CIL Label */ ;
#line 650
    if (! (! done)) {
#line 650
      goto while_break;
    }
    {
#line 652
    sendGPSMessage(req, (short)4);
#line 653
    tmp___2 = getGPSMessage();
    }
#line 653
    if ((int )tmp___2 == 0) {
#line 654
      goto while_break;
    }
#line 655
    done = (short )((int )gGarminMessage[1] == 12);
#line 656
    if (! done) {
      {
#line 658
      parseGPS();
#line 659
      SetBarGraph((double )records___0 / (double )total);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 664
  CloseBarGraph();
#line 665
  serialClose();
  }
#line 666
  if (verbose) {
#line 666
    goto _L;
  } else
#line 666
  if (debugging) {
    _L: /* CIL Label */ 
    {
#line 668
    sprintf((char */* __restrict  */)(gMessageStr), (char const   */* __restrict  */)"%d %s packets were transferred from the GPS receiver.",
            (int )records___0, rType);
#line 671
    Message(gMessageStr);
    }
#line 672
    if (debugging) {
#line 672
      if (total) {
#line 672
        if ((int )records___0 != (int )total) {
          {
#line 674
          sprintf((char */* __restrict  */)(gMessageStr), (char const   */* __restrict  */)" (%d were expected.)",
                  (int )total);
#line 675
          Message(gMessageStr);
          }
        }
      }
    }
  }
#line 678
  return;
}
}
#line 684 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/getgpsinfo.c"
static void parseGPS(void) 
{ 


  {
  {
#line 690
  if ((int )gGarminMessage[1] == 29) {
#line 690
    goto case_29;
  }
#line 693
  if ((int )gGarminMessage[1] == 30) {
#line 693
    goto case_30;
  }
#line 699
  if ((int )gGarminMessage[1] == 31) {
#line 699
    goto case_31;
  }
#line 702
  if ((int )gGarminMessage[1] == 99) {
#line 702
    goto case_99;
  }
#line 705
  if ((int )gGarminMessage[1] == 34) {
#line 705
    goto case_34;
  }
#line 713
  if ((int )gGarminMessage[1] == 35) {
#line 713
    goto case_35;
  }
#line 716
  goto switch_default;
  case_29: /* CIL Label */ 
  {
#line 691
  doRouteName();
  }
#line 692
  goto switch_break;
  case_30: /* CIL Label */ 
#line 694
  if ((unsigned int )file_format == 3334U) {
    {
#line 695
    doWaypoint_xmap();
    }
  } else {
    {
#line 697
    doWaypoint___0();
    }
  }
#line 698
  goto switch_break;
  case_31: /* CIL Label */ 
  {
#line 700
  doAlmanac___0();
  }
#line 701
  goto switch_break;
  case_99: /* CIL Label */ 
  {
#line 703
  doTrackHeader();
  }
#line 704
  goto switch_break;
  case_34: /* CIL Label */ 
#line 706
  if ((unsigned int )file_format == 3334U) {
    {
#line 708
    doWaypoint___0();
    }
  } else {
    {
#line 711
    doWaypoint___0();
    }
  }
#line 712
  goto switch_break;
  case_35: /* CIL Label */ 
  {
#line 714
  doWaypoint___0();
  }
#line 715
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 717
  if (debugging) {
    {
#line 718
    printf((char const   */* __restrict  */)"parseGPS: unexpected package, packet ID 0x%02X=%d\n",
           (int )gGarminMessage[1], (int )gGarminMessage[1]);
    }
  }
#line 720
  return;
  switch_break: /* CIL Label */ ;
  }
#line 722
  records___0 = (short )((int )records___0 + 1);
#line 723
  return;
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/getgpsinfo.c"
static void doRouteName(void) 
{ 
  route_name_type rte ;
  char *d ;
  D201_Rte_Hdr_Type *d___0 ;
  D202_Rte_Hdr_Type *d___1 ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 740
  rte.cmnt = (char *)0;
#line 741
  rte.nmbr = (unsigned int )(~ 1);
#line 743
  tmp___1 = strstr((char const   *)protocols, "D200");
  }
#line 743
  if (tmp___1) {
#line 745
    d = (char *)(gGarminMessage + 3);
#line 746
    rte.nmbr = (unsigned int )*(d + 0);
  } else {
    {
#line 750
    tmp___0 = strstr((char const   *)protocols, "D201");
    }
#line 750
    if (tmp___0) {
#line 752
      d___0 = (D201_Rte_Hdr_Type *)(gGarminMessage + 3);
#line 754
      rte.nmbr = (unsigned int )d___0->nmbr;
#line 755
      rte.cmnt = (char *)(& d___0->cmnt);
    } else {
      {
#line 757
      tmp = strstr((char const   *)protocols, "D202");
      }
#line 757
      if (tmp) {
#line 759
        d___1 = (D202_Rte_Hdr_Type *)(gGarminMessage + 3);
#line 762
        rte.cmnt = (char *)(& d___1->rte_ident);
      }
    }
  }
#line 765
  if ((unsigned int )file_format == 3334U) {
#line 767
    if (rte.nmbr != 4294967294U) {
#line 768
      xmap_route_nr = (int )rte.nmbr;
    } else {
#line 770
      xmap_route_nr = 0;
    }
  } else {
    {
#line 774
    sprintf((char */* __restrict  */)(fileData___0), (char const   */* __restrict  */)"R\t");
#line 775
    FileWrite(fileData___0);
    }
#line 776
    if (rte.nmbr != 4294967294U) {
      {
#line 778
      sprintf((char */* __restrict  */)(fileData___0), (char const   */* __restrict  */)"%d\t",
              rte.nmbr);
#line 779
      FileWrite(fileData___0);
      }
    }
#line 781
    if (rte.cmnt) {
      {
#line 783
      sprintf((char */* __restrict  */)(fileData___0), (char const   */* __restrict  */)"%s\n",
              rte.cmnt);
#line 784
      FileWrite(fileData___0);
      }
    }
  }
#line 787
  return;
}
}
#line 789 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/getgpsinfo.c"
static void doTrackHeader(void) 
{ 
  struct __anonstruct_hdr_89 hdr ;
  D310_Trk_Hdr_Type *d ;
  char *tmp ;
  D311_Trk_Hdr_Type *d___0 ;
  short tmp___0 ;
  char *tmp___1 ;
  D312_Trk_Hdr_Type *d___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;

  {
  {
#line 806
  hdr.has.index = 0U;
#line 806
  hdr.has.ident = hdr.has.index;
#line 806
  hdr.has.color = hdr.has.ident;
#line 806
  hdr.has.dspl = hdr.has.color;
#line 811
  tmp = strstr((char const   *)protocols, "D310");
  }
#line 811
  if (tmp) {
#line 813
    d = (D310_Trk_Hdr_Type *)(gGarminMessage + 3);
#line 814
    hdr.dspl = d->dspl;
#line 815
    hdr.color = d->color;
#line 816
    hdr.ident = (char *)(& d->trk_ident);
#line 817
    hdr.has.ident = 1U;
#line 817
    hdr.has.color = hdr.has.ident;
#line 817
    hdr.has.dspl = hdr.has.color;
  }
  {
#line 819
  tmp___1 = strstr((char const   *)protocols, "D311");
  }
#line 819
  if (tmp___1) {
    {
#line 821
    d___0 = (D311_Trk_Hdr_Type *)(gGarminMessage + 3);
#line 822
    tmp___0 = toshort((BYTE *)(& d___0->index));
#line 822
    hdr.index = (int )tmp___0;
#line 823
    hdr.has.index = 1U;
    }
  }
  {
#line 825
  tmp___2 = strstr((char const   *)protocols, "D312");
  }
#line 825
  if (tmp___2) {
#line 827
    d___1 = (D312_Trk_Hdr_Type *)(gGarminMessage + 3);
#line 828
    hdr.dspl = d___1->dspl;
#line 829
    hdr.color = d___1->color;
#line 830
    hdr.ident = (char *)(& d___1->trk_ident);
#line 831
    hdr.has.ident = 1U;
#line 831
    hdr.has.color = hdr.has.ident;
#line 831
    hdr.has.dspl = hdr.has.color;
  }
  {
#line 837
  if ((unsigned int )file_format == 3335U) {
#line 837
    goto case_3335;
  }
#line 837
  if ((unsigned int )file_format == 3334U) {
#line 837
    goto case_3335;
  }
#line 839
  if ((unsigned int )file_format == 3333U) {
#line 839
    goto case_3333;
  }
#line 834
  goto switch_break;
  case_3335: /* CIL Label */ 
  case_3334: /* CIL Label */ 
#line 838
  goto switch_break;
  case_3333: /* CIL Label */ 
#line 840
  if (hdr.has.dspl) {
    {
#line 841
    tmp___3 = colorCodeToName((int )hdr.color);
    }
#line 841
    if (hdr.dspl) {
#line 841
      tmp___4 = "display";
    } else {
#line 841
      tmp___4 = "hide";
    }
    {
#line 841
    printf((char const   */* __restrict  */)"H\t%s\t%s\t%.51s\n", tmp___4, tmp___3,
           hdr.ident);
    }
  } else {
    {
#line 846
    printf((char const   */* __restrict  */)"H\t%d\n", hdr.index);
    }
  }
#line 847
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 849
  return;
}
}
#line 853 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/getgpsinfo.c"
static char *colorCodeToName(int code ) 
{ 
  char *color_name[18] ;

  {
#line 856
  color_name[0] = (char *)"black";
#line 856
  color_name[1] = (char *)"dark red";
#line 856
  color_name[2] = (char *)"dark green";
#line 856
  color_name[3] = (char *)"dark yellow";
#line 856
  color_name[4] = (char *)"dark blue";
#line 856
  color_name[5] = (char *)"dark magenta";
#line 856
  color_name[6] = (char *)"dark cyan";
#line 856
  color_name[7] = (char *)"light gray";
#line 856
  color_name[8] = (char *)"dark gray";
#line 856
  color_name[9] = (char *)"red";
#line 856
  color_name[10] = (char *)"green";
#line 856
  color_name[11] = (char *)"yellow";
#line 856
  color_name[12] = (char *)"blue";
#line 856
  color_name[13] = (char *)"magenta";
#line 856
  color_name[14] = (char *)"cyan";
#line 856
  color_name[15] = (char *)"white";
#line 856
  color_name[16] = (char *)"transparent";
#line 856
  color_name[17] = (char *)"default";
#line 876
  if (code == 31) {
#line 877
    return (color_name[17]);
  } else
#line 876
  if (code == 255) {
#line 877
    return (color_name[17]);
  }
#line 878
  if (code < 0) {
#line 878
    goto _L;
  } else
#line 878
  if (code > 16) {
    _L: /* CIL Label */ 
#line 880
    if (debugging) {
      {
#line 881
      printf((char const   */* __restrict  */)"colorCodeToName: unexpected color code 0x%02X=%d, assuming black\n",
             code, code);
      }
    }
#line 883
    code = 0;
  }
#line 885
  return (color_name[code]);
}
}
#line 1060 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/getgpsinfo.c"
static void doWaypoint_xmap(void) 
{ 
  double latitude ;
  double longitude ;
  long tmp ;
  long tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 1067
  printf((char const   */* __restrict  */)"route number %d\n", xmap_route_nr);
  }
#line 1069
  if (xmap_route_nr) {
#line 1070
    return;
  }
  {
#line 1073
  tmp = number(gGarminMessage + 9);
#line 1073
  latitude = int2deg(tmp);
#line 1074
  tmp___0 = number(gGarminMessage + 13);
#line 1074
  longitude = int2deg(tmp___0);
#line 1077
  translate((short)1, & latitude, & longitude, gPrefs.datum);
#line 1083
  tmp___1 = string((short)6, gGarminMessage + 3);
#line 1083
  sprintf((char */* __restrict  */)(fileData___0), (char const   */* __restrict  */)"%s,",
          tmp___1);
#line 1084
  FileWrite(fileData___0);
#line 1086
  sprintf((char */* __restrict  */)(fileData___0), (char const   */* __restrict  */)"%03.6f,%04.6f,0,,\n",
          latitude, longitude);
#line 1087
  FileWrite(fileData___0);
  }
#line 1089
  return;
}
}
#line 1093 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/getgpsinfo.c"
static double distance(double lata , double lona , double latb , double lonb ) 
{ 
  double l0 ;
  double l1 ;
  double b0 ;
  double b1 ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;

  {
  {
#line 1097
  l0 = lona * (3.14159265358979323846E0 / 180.0);
#line 1098
  l1 = lonb * (3.14159265358979323846E0 / 180.0);
#line 1099
  b0 = lata * (3.14159265358979323846E0 / 180.0);
#line 1100
  b1 = latb * (3.14159265358979323846E0 / 180.0);
#line 1102
  tmp = cos(b1);
#line 1102
  tmp___0 = cos(b0);
#line 1102
  tmp___1 = sin(0.5 * (l1 - l0));
#line 1102
  tmp___2 = sin(0.5 * (l1 - l0));
#line 1102
  tmp___3 = sin(0.5 * (b1 - b0));
#line 1102
  tmp___4 = sin(0.5 * (b1 - b0));
#line 1102
  tmp___5 = sqrt(((tmp * tmp___0) * tmp___1) * tmp___2 + tmp___3 * tmp___4);
#line 1102
  tmp___6 = asin(tmp___5);
  }
#line 1102
  return ((double )12742 * tmp___6);
}
}
#line 1110 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/getgpsinfo.c"
static void doWaypoint___0(void) 
{ 
  char zone[6] ;
  char *s___0 ;
  double x ;
  double y ;
  double x_dist ;
  double t_diff ;
  double x_speed ;
  struct __anonstruct_pkt_91 pkt ;
  char flag ;
  char Pid ;
  D100_Wpt_Type *d ;
  long tmp ;
  long tmp___0 ;
  D101_Wpt_Type *d___0 ;
  long tmp___1 ;
  long tmp___2 ;
  D102_Wpt_Type *d___1 ;
  long tmp___3 ;
  long tmp___4 ;
  D103_Wpt_Type *d___2 ;
  long tmp___5 ;
  long tmp___6 ;
  D104_Wpt_Type *d___3 ;
  long tmp___7 ;
  long tmp___8 ;
  D105_Wpt_Type *d___4 ;
  long tmp___9 ;
  long tmp___10 ;
  D106_Wpt_Type *d___5 ;
  long tmp___11 ;
  long tmp___12 ;
  D107_Wpt_Type *d___6 ;
  long tmp___13 ;
  long tmp___14 ;
  D108_Wpt_Type *d___7 ;
  long tmp___15 ;
  long tmp___16 ;
  float tmp___17 ;
  size_t tmp___18 ;
  D109_Wpt_Type *d___8 ;
  long tmp___19 ;
  long tmp___20 ;
  float tmp___21 ;
  size_t tmp___22 ;
  D110_Wpt_Type *d___9 ;
  long tmp___23 ;
  long tmp___24 ;
  float tmp___25 ;
  size_t tmp___26 ;
  long tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  D300_Trk_Point_Type *d___10 ;
  long tmp___39 ;
  long tmp___40 ;
  long tmp___41 ;
  char *tmp___42 ;
  D301_Trk_Point_Type *d___11 ;
  long tmp___43 ;
  long tmp___44 ;
  long tmp___45 ;
  float tmp___46 ;
  char *tmp___47 ;
  D302_Trk_Point_Type *d___12 ;
  long tmp___48 ;
  long tmp___49 ;
  long tmp___50 ;
  float tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;
  char *tmp___54 ;
  char *tmp___55 ;
  char *tmp___56 ;
  char *tmp___57 ;
  char *tmp___58 ;

  {
#line 1116
  x_dist = (double )0;
#line 1116
  t_diff = (double )0;
#line 1116
  x_speed = (double )0;
#line 1138
  pkt.has.comment = 0U;
#line 1138
  pkt.has.name = pkt.has.comment;
#line 1138
  pkt.has.seconds = pkt.has.name;
#line 1138
  pkt.has.altitude = pkt.has.seconds;
#line 1138
  pkt.new_trk = (char )pkt.has.altitude;
#line 1144
  Pid = (char )gGarminMessage[1];
  {
#line 1149
  if ((int )Pid == 35) {
#line 1149
    goto case_35;
  }
#line 1149
  if ((int )Pid == 30) {
#line 1149
    goto case_35;
  }
#line 1315
  if ((int )Pid == 34) {
#line 1315
    goto case_34;
  }
#line 1146
  goto switch_break;
  case_35: /* CIL Label */ 
  case_30: /* CIL Label */ 
  {
#line 1150
  flag = (char )'W';
#line 1154
  tmp___38 = strstr((char const   *)protocols, "D100");
  }
#line 1154
  if (tmp___38) {
    {
#line 1156
    d = (D100_Wpt_Type *)(gGarminMessage + 3);
#line 1166
    tmp = number((BYTE *)(& d->posn.lat));
#line 1166
    pkt.latitude = int2deg(tmp);
#line 1167
    tmp___0 = number((BYTE *)(& d->posn.lon));
#line 1167
    pkt.longitude = int2deg(tmp___0);
#line 1169
    sprintf((char */* __restrict  */)(pkt.name), (char const   */* __restrict  */)"%-6.6s",
            (char *)(& d->ident));
#line 1170
    pkt.comment = (char *)(& d->cmnt);
#line 1171
    pkt.has.comment = 1U;
#line 1171
    pkt.has.name = pkt.has.comment;
    }
  } else {
    {
#line 1173
    tmp___37 = strstr((char const   *)protocols, "D101");
    }
#line 1173
    if (tmp___37) {
      {
#line 1175
      d___0 = (D101_Wpt_Type *)(gGarminMessage + 3);
#line 1178
      tmp___1 = number((BYTE *)(& d___0->posn.lat));
#line 1178
      pkt.latitude = int2deg(tmp___1);
#line 1179
      tmp___2 = number((BYTE *)(& d___0->posn.lon));
#line 1179
      pkt.longitude = int2deg(tmp___2);
#line 1181
      sprintf((char */* __restrict  */)(pkt.name), (char const   */* __restrict  */)"%-6.6s",
              (char *)(& d___0->ident));
#line 1182
      pkt.comment = (char *)(& d___0->cmnt);
#line 1183
      pkt.has.comment = 1U;
#line 1183
      pkt.has.name = pkt.has.comment;
      }
    } else {
      {
#line 1185
      tmp___36 = strstr((char const   *)protocols, "D102");
      }
#line 1185
      if (tmp___36) {
        {
#line 1187
        d___1 = (D102_Wpt_Type *)(gGarminMessage + 3);
#line 1190
        tmp___3 = number((BYTE *)(& d___1->posn.lat));
#line 1190
        pkt.latitude = int2deg(tmp___3);
#line 1191
        tmp___4 = number((BYTE *)(& d___1->posn.lon));
#line 1191
        pkt.longitude = int2deg(tmp___4);
#line 1193
        sprintf((char */* __restrict  */)(pkt.name), (char const   */* __restrict  */)"%-6.6s",
                (char *)(& d___1->ident));
#line 1194
        pkt.comment = (char *)(& d___1->cmnt);
#line 1195
        pkt.has.comment = 1U;
#line 1195
        pkt.has.name = pkt.has.comment;
        }
      } else {
        {
#line 1197
        tmp___35 = strstr((char const   *)protocols, "D103");
        }
#line 1197
        if (tmp___35) {
          {
#line 1199
          d___2 = (D103_Wpt_Type *)(gGarminMessage + 3);
#line 1202
          tmp___5 = number((BYTE *)(& d___2->posn.lat));
#line 1202
          pkt.latitude = int2deg(tmp___5);
#line 1203
          tmp___6 = number((BYTE *)(& d___2->posn.lon));
#line 1203
          pkt.longitude = int2deg(tmp___6);
#line 1205
          sprintf((char */* __restrict  */)(pkt.name), (char const   */* __restrict  */)"%-6.6s",
                  (char *)(& d___2->ident));
#line 1206
          pkt.comment = (char *)(& d___2->cmnt);
#line 1207
          pkt.has.comment = 1U;
#line 1207
          pkt.has.name = pkt.has.comment;
          }
        } else {
          {
#line 1209
          tmp___34 = strstr((char const   *)protocols, "D104");
          }
#line 1209
          if (tmp___34) {
            {
#line 1211
            d___3 = (D104_Wpt_Type *)(gGarminMessage + 3);
#line 1214
            tmp___7 = number((BYTE *)(& d___3->posn.lat));
#line 1214
            pkt.latitude = int2deg(tmp___7);
#line 1215
            tmp___8 = number((BYTE *)(& d___3->posn.lon));
#line 1215
            pkt.longitude = int2deg(tmp___8);
#line 1217
            sprintf((char */* __restrict  */)(pkt.name), (char const   */* __restrict  */)"%-6.6s",
                    (char *)(& d___3->ident));
#line 1218
            pkt.comment = (char *)(& d___3->cmnt);
#line 1219
            pkt.has.comment = 1U;
#line 1219
            pkt.has.name = pkt.has.comment;
            }
          } else {
            {
#line 1221
            tmp___33 = strstr((char const   *)protocols, "D105");
            }
#line 1221
            if (tmp___33) {
              {
#line 1223
              d___4 = (D105_Wpt_Type *)(gGarminMessage + 3);
#line 1226
              tmp___9 = number((BYTE *)(& d___4->posn.lat));
#line 1226
              pkt.latitude = int2deg(tmp___9);
#line 1227
              tmp___10 = number((BYTE *)(& d___4->posn.lon));
#line 1227
              pkt.longitude = int2deg(tmp___10);
#line 1229
              sprintf((char */* __restrict  */)(pkt.name), (char const   */* __restrict  */)"%-15.15s",
                      (char *)(& d___4->ident));
#line 1231
              pkt.has.name = 1U;
              }
            } else {
              {
#line 1233
              tmp___32 = strstr((char const   *)protocols, "D106");
              }
#line 1233
              if (tmp___32) {
                {
#line 1235
                d___5 = (D106_Wpt_Type *)(gGarminMessage + 3);
#line 1238
                tmp___11 = number((BYTE *)(& d___5->posn.lat));
#line 1238
                pkt.latitude = int2deg(tmp___11);
#line 1239
                tmp___12 = number((BYTE *)(& d___5->posn.lon));
#line 1239
                pkt.longitude = int2deg(tmp___12);
#line 1241
                sprintf((char */* __restrict  */)(pkt.name), (char const   */* __restrict  */)"%-15.15s",
                        (char *)(& d___5->ident));
#line 1243
                pkt.has.name = 1U;
                }
              } else {
                {
#line 1245
                tmp___31 = strstr((char const   *)protocols, "D107");
                }
#line 1245
                if (tmp___31) {
                  {
#line 1247
                  d___6 = (D107_Wpt_Type *)(gGarminMessage + 3);
#line 1250
                  tmp___13 = number((BYTE *)(& d___6->posn.lat));
#line 1250
                  pkt.latitude = int2deg(tmp___13);
#line 1251
                  tmp___14 = number((BYTE *)(& d___6->posn.lon));
#line 1251
                  pkt.longitude = int2deg(tmp___14);
#line 1253
                  sprintf((char */* __restrict  */)(pkt.name), (char const   */* __restrict  */)"%-6.6s",
                          (char *)(& d___6->ident));
#line 1254
                  pkt.comment = (char *)(& d___6->cmnt);
#line 1255
                  pkt.has.comment = 1U;
#line 1255
                  pkt.has.name = pkt.has.comment;
                  }
                } else {
                  {
#line 1257
                  tmp___30 = strstr((char const   *)protocols, "D108");
                  }
#line 1257
                  if (tmp___30) {
                    {
#line 1259
                    d___7 = (D108_Wpt_Type *)(gGarminMessage + 3);
#line 1262
                    tmp___15 = number((BYTE *)(& d___7->posn.lat));
#line 1262
                    pkt.latitude = int2deg(tmp___15);
#line 1263
                    tmp___16 = number((BYTE *)(& d___7->posn.lon));
#line 1263
                    pkt.longitude = int2deg(tmp___16);
#line 1265
                    tmp___17 = tofloat((BYTE *)(& d___7->alt));
#line 1265
                    pkt.altitude = (double )tmp___17;
#line 1267
                    s___0 = (char *)(& d___7->ident);
#line 1269
                    sprintf((char */* __restrict  */)(pkt.name), (char const   */* __restrict  */)"%-15.15s",
                            s___0);
#line 1270
                    tmp___18 = strlen((char const   *)s___0);
#line 1270
                    s___0 += tmp___18 + 1UL;
#line 1272
                    pkt.comment = s___0;
#line 1273
                    pkt.has.comment = 1U;
#line 1273
                    pkt.has.name = pkt.has.comment;
#line 1273
                    pkt.has.altitude = pkt.has.name;
                    }
                  } else {
                    {
#line 1275
                    tmp___29 = strstr((char const   *)protocols, "D109");
                    }
#line 1275
                    if (tmp___29) {
                      {
#line 1277
                      d___8 = (D109_Wpt_Type *)(gGarminMessage + 3);
#line 1280
                      tmp___19 = number((BYTE *)(& d___8->posn.lat));
#line 1280
                      pkt.latitude = int2deg(tmp___19);
#line 1281
                      tmp___20 = number((BYTE *)(& d___8->posn.lon));
#line 1281
                      pkt.longitude = int2deg(tmp___20);
#line 1283
                      tmp___21 = tofloat((BYTE *)(& d___8->alt));
#line 1283
                      pkt.altitude = (double )tmp___21;
#line 1285
                      s___0 = (char *)(& d___8->ident);
#line 1287
                      sprintf((char */* __restrict  */)(pkt.name), (char const   */* __restrict  */)"%-15.15s",
                              s___0);
#line 1288
                      tmp___22 = strlen((char const   *)s___0);
#line 1288
                      s___0 += tmp___22 + 1UL;
#line 1290
                      pkt.comment = s___0;
#line 1291
                      pkt.has.comment = 1U;
#line 1291
                      pkt.has.name = pkt.has.comment;
#line 1291
                      pkt.has.altitude = pkt.has.name;
                      }
                    } else {
                      {
#line 1293
                      tmp___28 = strstr((char const   *)protocols, "D110");
                      }
#line 1293
                      if (tmp___28) {
                        {
#line 1295
                        d___9 = (D110_Wpt_Type *)(gGarminMessage + 3);
#line 1298
                        tmp___23 = number((BYTE *)(& d___9->posn.lat));
#line 1298
                        pkt.latitude = int2deg(tmp___23);
#line 1299
                        tmp___24 = number((BYTE *)(& d___9->posn.lon));
#line 1299
                        pkt.longitude = int2deg(tmp___24);
#line 1301
                        tmp___25 = tofloat((BYTE *)(& d___9->alt));
#line 1301
                        pkt.altitude = (double )tmp___25;
#line 1303
                        s___0 = (char *)(& d___9->ident);
#line 1305
                        sprintf((char */* __restrict  */)(pkt.name), (char const   */* __restrict  */)"%-15.15s",
                                s___0);
#line 1306
                        tmp___26 = strlen((char const   *)s___0);
#line 1306
                        s___0 += tmp___26 + 1UL;
#line 1308
                        pkt.comment = s___0;
#line 1310
                        tmp___27 = number((BYTE *)(& d___9->time));
#line 1310
                        pkt.seconds = (double )tmp___27;
#line 1311
                        pkt.has.seconds = 1U;
#line 1311
                        pkt.has.comment = pkt.has.seconds;
#line 1311
                        pkt.has.name = pkt.has.comment;
#line 1311
                        pkt.has.altitude = pkt.has.name;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 1313
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 1316
  flag = (char )'T';
#line 1317
  tmp___42 = strstr((char const   *)protocols, "D300");
  }
#line 1317
  if (tmp___42) {
    {
#line 1319
    d___10 = (D300_Trk_Point_Type *)(gGarminMessage + 3);
#line 1320
    tmp___39 = number((BYTE *)(& d___10->time));
#line 1320
    pkt.seconds = (double )tmp___39;
#line 1321
    tmp___40 = number((BYTE *)(& d___10->posn.lat));
#line 1321
    pkt.latitude = int2deg(tmp___40);
#line 1322
    tmp___41 = number((BYTE *)(& d___10->posn.lon));
#line 1322
    pkt.longitude = int2deg(tmp___41);
#line 1323
    pkt.new_trk = (char )d___10->new_trk;
#line 1324
    pkt.has.seconds = 1U;
    }
  }
  {
#line 1326
  tmp___47 = strstr((char const   *)protocols, "D301");
  }
#line 1326
  if (tmp___47) {
    {
#line 1328
    d___11 = (D301_Trk_Point_Type *)(gGarminMessage + 3);
#line 1329
    tmp___43 = number((BYTE *)(& d___11->time));
#line 1329
    pkt.seconds = (double )tmp___43;
#line 1330
    tmp___44 = number((BYTE *)(& d___11->posn.lat));
#line 1330
    pkt.latitude = int2deg(tmp___44);
#line 1331
    tmp___45 = number((BYTE *)(& d___11->posn.lon));
#line 1331
    pkt.longitude = int2deg(tmp___45);
#line 1332
    tmp___46 = tofloat((BYTE *)(& d___11->alt));
#line 1332
    pkt.altitude = (double )tmp___46;
#line 1333
    pkt.new_trk = (char )d___11->new_trk;
#line 1334
    pkt.has.altitude = 1U;
#line 1334
    pkt.has.seconds = pkt.has.altitude;
    }
  }
  {
#line 1336
  tmp___52 = strstr((char const   *)protocols, "D302");
  }
#line 1336
  if (tmp___52) {
    {
#line 1338
    d___12 = (D302_Trk_Point_Type *)(gGarminMessage + 3);
#line 1339
    tmp___48 = number((BYTE *)(& d___12->time));
#line 1339
    pkt.seconds = (double )tmp___48;
#line 1340
    tmp___49 = number((BYTE *)(& d___12->posn.lat));
#line 1340
    pkt.latitude = int2deg(tmp___49);
#line 1341
    tmp___50 = number((BYTE *)(& d___12->posn.lon));
#line 1341
    pkt.longitude = int2deg(tmp___50);
#line 1342
    tmp___51 = tofloat((BYTE *)(& d___12->alt));
#line 1342
    pkt.altitude = (double )tmp___51;
#line 1343
    pkt.new_trk = (char )d___12->new_trk;
#line 1344
    pkt.has.altitude = 1U;
#line 1344
    pkt.has.seconds = pkt.has.altitude;
    }
  }
#line 1346
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1351
  translate((short)1, & pkt.latitude, & pkt.longitude, gPrefs.datum);
  }
  {
#line 1357
  if ((unsigned int )file_format == 3335U) {
#line 1357
    goto case_3335;
  }
#line 1357
  if ((unsigned int )file_format == 3334U) {
#line 1357
    goto case_3335;
  }
#line 1426
  if ((unsigned int )file_format == 3333U) {
#line 1426
    goto case_3333;
  }
#line 1354
  goto switch_break___0;
  case_3335: /* CIL Label */ 
  case_3334: /* CIL Label */ 
  {
#line 1362
  if ((int )Pid == 30) {
#line 1362
    goto case_30___0;
  }
#line 1370
  if ((int )Pid == 34) {
#line 1370
    goto case_34___0;
  }
#line 1359
  goto switch_break___1;
  case_30___0: /* CIL Label */ 
  {
#line 1363
  sprintf((char */* __restrict  */)(fileData___0), (char const   */* __restrict  */)"%s,",
          pkt.name);
#line 1364
  FileWrite(fileData___0);
#line 1366
  sprintf((char */* __restrict  */)(fileData___0), (char const   */* __restrict  */)"%03.6f,%04.6f,0,,\n",
          pkt.latitude, pkt.longitude);
#line 1367
  FileWrite(fileData___0);
  }
#line 1368
  goto switch_break___1;
  case_34___0: /* CIL Label */ 
#line 1372
  if (pkt.new_trk) {
#line 1374
    xmap_lat = (double )0;
#line 1375
    xmap_lon = (double )0;
#line 1376
    xmap_time = 0L;
#line 1377
    if ((int )records___0 != 0) {
      {
#line 1378
      FileWrite((char *)"\n");
      }
    }
  }
#line 1383
  if (xmap_lat) {
    {
#line 1385
    x_dist = distance(pkt.latitude, pkt.longitude, xmap_lat, xmap_lon);
#line 1386
    t_diff = pkt.seconds - (double )xmap_time;
    }
#line 1387
    if (t_diff) {
#line 1388
      x_speed = (double )((float )(((x_dist / t_diff) * (double )3600) / 1.852));
    } else {
#line 1390
      x_speed = (double )xmap_speed;
    }
  }
  {
#line 1395
  sprintf((char */* __restrict  */)(fileData___0), (char const   */* __restrict  */)"1 %03.7f %04.7f ",
          pkt.latitude, pkt.longitude);
#line 1396
  FileWrite(fileData___0);
#line 1398
  sprintf((char */* __restrict  */)(fileData___0), (char const   */* __restrict  */)"%.1f %1.0f ",
          x_speed, pkt.altitude);
#line 1399
  FileWrite(fileData___0);
#line 1401
  tmp___53 = secs2dt((long )pkt.seconds, (short )gPrefs.offset);
#line 1401
  sprintf((char */* __restrict  */)(fileData___0), (char const   */* __restrict  */)"%s",
          tmp___53);
#line 1402
  FileWrite(fileData___0);
  }
#line 1404
  if (xmap_lat) {
#line 1404
    if ((unsigned int )file_format == 3335U) {
      {
#line 1406
      sprintf((char */* __restrict  */)(fileData___0), (char const   */* __restrict  */)" x%03.7f %04.7f",
              xmap_lat, xmap_lon);
#line 1407
      FileWrite(fileData___0);
#line 1408
      sprintf((char */* __restrict  */)(fileData___0), (char const   */* __restrict  */)" %06.7f",
              x_dist);
#line 1409
      FileWrite(fileData___0);
#line 1410
      sprintf((char */* __restrict  */)(fileData___0), (char const   */* __restrict  */)" -%d-",
              (int )t_diff);
#line 1411
      FileWrite(fileData___0);
#line 1412
      sprintf((char */* __restrict  */)(fileData___0), (char const   */* __restrict  */)" %.3f",
              x_speed);
#line 1413
      FileWrite(fileData___0);
      }
    }
  }
  {
#line 1416
  FileWrite((char *)"\n");
#line 1418
  xmap_lat = pkt.latitude;
#line 1419
  xmap_lon = pkt.longitude;
#line 1420
  xmap_time = number(gGarminMessage + 11);
#line 1421
  xmap_speed = (float )x_speed;
  }
#line 1422
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 1424
  goto switch_break___0;
  case_3333: /* CIL Label */ 
  {
#line 1428
  sprintf((char */* __restrict  */)(fileData___0), (char const   */* __restrict  */)"%c\t",
          (int )flag);
#line 1429
  FileWrite(fileData___0);
  }
#line 1432
  if (pkt.has.name) {
    {
#line 1434
    sprintf((char */* __restrict  */)(fileData___0), (char const   */* __restrict  */)"%s\t",
            pkt.name);
#line 1435
    FileWrite(fileData___0);
    }
  }
#line 1439
  if (pkt.has.comment) {
    {
#line 1441
    sprintf((char */* __restrict  */)(fileData___0), (char const   */* __restrict  */)"%-40s\t",
            pkt.comment);
#line 1442
    FileWrite(fileData___0);
    }
  }
#line 1446
  if (pkt.has.seconds) {
    {
#line 1448
    tmp___54 = secs2dt((long )pkt.seconds, (short )gPrefs.offset);
#line 1448
    sprintf((char */* __restrict  */)(fileData___0), (char const   */* __restrict  */)"%s\t",
            tmp___54);
#line 1449
    FileWrite(fileData___0);
    }
  }
#line 1453
  if (pkt.has.altitude) {
#line 1455
    if (pkt.altitude < 1.e24) {
#line 1456
      if (gPrefs.feet) {
        {
#line 1457
        sprintf((char */* __restrict  */)(fileData___0), (char const   */* __restrict  */)"%9.2f ft\t",
                pkt.altitude / .3048);
        }
      } else {
        {
#line 1459
        sprintf((char */* __restrict  */)(fileData___0), (char const   */* __restrict  */)"%9.2f m\t",
                pkt.altitude);
        }
      }
    } else {
      {
#line 1461
      sprintf((char */* __restrict  */)(fileData___0), (char const   */* __restrict  */)"unknown  \t");
      }
    }
    {
#line 1462
    FileWrite(fileData___0);
    }
  }
  {
#line 1468
  if ((unsigned int )gPrefs.format == 0U) {
#line 1468
    goto case_0;
  }
#line 1474
  if ((unsigned int )gPrefs.format == 1U) {
#line 1474
    goto case_1;
  }
#line 1480
  if ((unsigned int )gPrefs.format == 2U) {
#line 1480
    goto case_2;
  }
#line 1484
  if ((unsigned int )gPrefs.format == 3U) {
#line 1484
    goto case_3;
  }
#line 1489
  if ((unsigned int )gPrefs.format == 6U) {
#line 1489
    goto case_6;
  }
#line 1494
  if ((unsigned int )gPrefs.format == 4U) {
#line 1494
    goto case_4;
  }
#line 1499
  if ((unsigned int )gPrefs.format == 5U) {
#line 1499
    goto case_5;
  }
#line 1504
  if ((unsigned int )gPrefs.format == 7U) {
#line 1504
    goto case_7;
  }
#line 1509
  if ((unsigned int )gPrefs.format == 8U) {
#line 1509
    goto case_8;
  }
#line 1514
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1469
  tmp___55 = toDMS(pkt.latitude);
#line 1469
  sprintf((char */* __restrict  */)(fileData___0), (char const   */* __restrict  */)"%s\t",
          tmp___55);
#line 1470
  FileWrite(fileData___0);
#line 1471
  tmp___56 = toDMS(pkt.longitude);
#line 1471
  sprintf((char */* __restrict  */)(fileData___0), (char const   */* __restrict  */)"%s\n",
          tmp___56);
#line 1472
  FileWrite(fileData___0);
  }
#line 1473
  goto switch_break___2;
  case_1: /* CIL Label */ 
  {
#line 1475
  tmp___57 = toDM(pkt.latitude);
#line 1475
  sprintf((char */* __restrict  */)(fileData___0), (char const   */* __restrict  */)"%s\t",
          tmp___57);
#line 1476
  FileWrite(fileData___0);
#line 1477
  tmp___58 = toDM(pkt.longitude);
#line 1477
  sprintf((char */* __restrict  */)(fileData___0), (char const   */* __restrict  */)"%s\n",
          tmp___58);
#line 1478
  FileWrite(fileData___0);
  }
#line 1479
  goto switch_break___2;
  case_2: /* CIL Label */ 
  {
#line 1481
  sprintf((char */* __restrict  */)(fileData___0), (char const   */* __restrict  */)"%03.7f\t%04.7f\n",
          pkt.latitude, pkt.longitude);
#line 1482
  FileWrite(fileData___0);
  }
#line 1483
  goto switch_break___2;
  case_3: /* CIL Label */ 
  {
#line 1485
  DegToUTM(pkt.latitude, pkt.longitude, zone, & x, & y);
#line 1486
  sprintf((char */* __restrict  */)(fileData___0), (char const   */* __restrict  */)"%s\t%07.0f\t%07.0f\n",
          zone, x, y);
#line 1487
  FileWrite(fileData___0);
  }
#line 1488
  goto switch_break___2;
  case_6: /* CIL Label */ 
  {
#line 1490
  DegToKKJ(pkt.latitude, pkt.longitude, zone, & x, & y);
#line 1491
  sprintf((char */* __restrict  */)(fileData___0), (char const   */* __restrict  */)"%s\t%07.0f\t%07.0f\n",
          zone, x, y);
#line 1492
  FileWrite(fileData___0);
  }
#line 1493
  goto switch_break___2;
  case_4: /* CIL Label */ 
  {
#line 1495
  DegToBNG(pkt.latitude, pkt.longitude, zone, & x, & y);
#line 1496
  sprintf((char */* __restrict  */)(fileData___0), (char const   */* __restrict  */)"%s\t%05.0f\t%05.0f\n",
          zone, x, y);
#line 1497
  FileWrite(fileData___0);
  }
#line 1498
  goto switch_break___2;
  case_5: /* CIL Label */ 
  {
#line 1500
  DegToITM(pkt.latitude, pkt.longitude, zone, & x, & y);
#line 1501
  sprintf((char */* __restrict  */)(fileData___0), (char const   */* __restrict  */)"%s\t%05.0f\t%05.0f\n",
          zone, x, y);
#line 1502
  FileWrite(fileData___0);
  }
#line 1503
  goto switch_break___2;
  case_7: /* CIL Label */ 
  {
#line 1505
  DegToSEG(pkt.latitude, pkt.longitude, & x, & y);
#line 1506
  sprintf((char */* __restrict  */)(fileData___0), (char const   */* __restrict  */)"%07.0f\t%07.0f\n",
          x, y);
#line 1507
  FileWrite(fileData___0);
  }
#line 1508
  goto switch_break___2;
  case_8: /* CIL Label */ 
  {
#line 1510
  DegToGKK(pkt.latitude, pkt.longitude, & x, & y);
#line 1511
  sprintf((char */* __restrict  */)(fileData___0), (char const   */* __restrict  */)"%07.0f\t%07.0f\n",
          x, y);
#line 1512
  FileWrite(fileData___0);
  }
#line 1513
  goto switch_break___2;
  switch_default: /* CIL Label */ 
#line 1515
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 1517
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1519
  return;
}
}
#line 1527 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/getgpsinfo.c"
static void doAlmanac___0(void) 
{ 
  char temp[255] ;
  almanac_type pkt ;
  D500_Almanac_Type *d ;
  float tmp ;
  float tmp___0 ;
  float tmp___1 ;
  float tmp___2 ;
  float tmp___3 ;
  float tmp___4 ;
  float tmp___5 ;
  float tmp___6 ;
  float tmp___7 ;
  float tmp___8 ;
  D501_Almanac_Type *d___0 ;
  float tmp___9 ;
  float tmp___10 ;
  float tmp___11 ;
  float tmp___12 ;
  float tmp___13 ;
  float tmp___14 ;
  float tmp___15 ;
  float tmp___16 ;
  float tmp___17 ;
  float tmp___18 ;
  D550_Almanac_Type *d___1 ;
  float tmp___19 ;
  float tmp___20 ;
  float tmp___21 ;
  float tmp___22 ;
  float tmp___23 ;
  float tmp___24 ;
  float tmp___25 ;
  float tmp___26 ;
  float tmp___27 ;
  float tmp___28 ;
  D551_Almanac_Type *d___2 ;
  float tmp___29 ;
  float tmp___30 ;
  float tmp___31 ;
  float tmp___32 ;
  float tmp___33 ;
  float tmp___34 ;
  float tmp___35 ;
  float tmp___36 ;
  float tmp___37 ;
  float tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;

  {
  {
#line 1541
  pkt.hlth = ~ 1;
#line 1541
  pkt.svid = pkt.hlth;
#line 1543
  tmp___42 = strstr((char const   *)protocols, "D500");
  }
#line 1543
  if (tmp___42) {
    {
#line 1545
    d = (D500_Almanac_Type *)(gGarminMessage + 3);
#line 1548
    pkt.wn = toshort((BYTE *)(& d->wn));
#line 1549
    tmp = tofloat((BYTE *)(& d->toa));
#line 1549
    pkt.toa = (double )tmp;
#line 1550
    tmp___0 = tofloat((BYTE *)(& d->af0));
#line 1550
    pkt.af0 = (double )tmp___0;
#line 1551
    tmp___1 = tofloat((BYTE *)(& d->af1));
#line 1551
    pkt.af1 = (double )tmp___1;
#line 1552
    tmp___2 = tofloat((BYTE *)(& d->e));
#line 1552
    pkt.e = (double )tmp___2;
#line 1553
    tmp___3 = tofloat((BYTE *)(& d->sqrta));
#line 1553
    pkt.sqrta = (double )tmp___3;
#line 1554
    tmp___4 = tofloat((BYTE *)(& d->m0));
#line 1554
    pkt.m0 = (double )tmp___4;
#line 1555
    tmp___5 = tofloat((BYTE *)(& d->w));
#line 1555
    pkt.w = (double )tmp___5;
#line 1556
    tmp___6 = tofloat((BYTE *)(& d->omg0));
#line 1556
    pkt.omg0 = (double )tmp___6;
#line 1557
    tmp___7 = tofloat((BYTE *)(& d->odot));
#line 1557
    pkt.odot = (double )tmp___7;
#line 1558
    tmp___8 = tofloat((BYTE *)(& d->i));
#line 1558
    pkt.i = (double )tmp___8;
    }
  } else {
    {
#line 1561
    tmp___41 = strstr((char const   *)protocols, "D501");
    }
#line 1561
    if (tmp___41) {
      {
#line 1563
      d___0 = (D501_Almanac_Type *)(gGarminMessage + 3);
#line 1566
      pkt.wn = toshort((BYTE *)(& d___0->wn));
#line 1567
      tmp___9 = tofloat((BYTE *)(& d___0->toa));
#line 1567
      pkt.toa = (double )tmp___9;
#line 1568
      tmp___10 = tofloat((BYTE *)(& d___0->af0));
#line 1568
      pkt.af0 = (double )tmp___10;
#line 1569
      tmp___11 = tofloat((BYTE *)(& d___0->af1));
#line 1569
      pkt.af1 = (double )tmp___11;
#line 1570
      tmp___12 = tofloat((BYTE *)(& d___0->e));
#line 1570
      pkt.e = (double )tmp___12;
#line 1571
      tmp___13 = tofloat((BYTE *)(& d___0->sqrta));
#line 1571
      pkt.sqrta = (double )tmp___13;
#line 1572
      tmp___14 = tofloat((BYTE *)(& d___0->m0));
#line 1572
      pkt.m0 = (double )tmp___14;
#line 1573
      tmp___15 = tofloat((BYTE *)(& d___0->w));
#line 1573
      pkt.w = (double )tmp___15;
#line 1574
      tmp___16 = tofloat((BYTE *)(& d___0->omg0));
#line 1574
      pkt.omg0 = (double )tmp___16;
#line 1575
      tmp___17 = tofloat((BYTE *)(& d___0->odot));
#line 1575
      pkt.odot = (double )tmp___17;
#line 1576
      tmp___18 = tofloat((BYTE *)(& d___0->i));
#line 1576
      pkt.i = (double )tmp___18;
#line 1577
      pkt.hlth = (int )d___0->hlth;
      }
    } else {
      {
#line 1579
      tmp___40 = strstr((char const   *)protocols, "D550");
      }
#line 1579
      if (tmp___40) {
        {
#line 1581
        d___1 = (D550_Almanac_Type *)(gGarminMessage + 3);
#line 1583
        pkt.svid = (int )d___1->svid;
#line 1584
        pkt.wn = toshort((BYTE *)(& d___1->wn));
#line 1585
        tmp___19 = tofloat((BYTE *)(& d___1->toa));
#line 1585
        pkt.toa = (double )tmp___19;
#line 1586
        tmp___20 = tofloat((BYTE *)(& d___1->af0));
#line 1586
        pkt.af0 = (double )tmp___20;
#line 1587
        tmp___21 = tofloat((BYTE *)(& d___1->af1));
#line 1587
        pkt.af1 = (double )tmp___21;
#line 1588
        tmp___22 = tofloat((BYTE *)(& d___1->e));
#line 1588
        pkt.e = (double )tmp___22;
#line 1589
        tmp___23 = tofloat((BYTE *)(& d___1->sqrta));
#line 1589
        pkt.sqrta = (double )tmp___23;
#line 1590
        tmp___24 = tofloat((BYTE *)(& d___1->m0));
#line 1590
        pkt.m0 = (double )tmp___24;
#line 1591
        tmp___25 = tofloat((BYTE *)(& d___1->w));
#line 1591
        pkt.w = (double )tmp___25;
#line 1592
        tmp___26 = tofloat((BYTE *)(& d___1->omg0));
#line 1592
        pkt.omg0 = (double )tmp___26;
#line 1593
        tmp___27 = tofloat((BYTE *)(& d___1->odot));
#line 1593
        pkt.odot = (double )tmp___27;
#line 1594
        tmp___28 = tofloat((BYTE *)(& d___1->i));
#line 1594
        pkt.i = (double )tmp___28;
        }
      } else {
        {
#line 1597
        tmp___39 = strstr((char const   *)protocols, "D551");
        }
#line 1597
        if (tmp___39) {
          {
#line 1599
          d___2 = (D551_Almanac_Type *)(gGarminMessage + 3);
#line 1600
          pkt.svid = (int )d___2->svid;
#line 1601
          pkt.wn = toshort((BYTE *)(& d___2->wn));
#line 1602
          tmp___29 = tofloat((BYTE *)(& d___2->toa));
#line 1602
          pkt.toa = (double )tmp___29;
#line 1603
          tmp___30 = tofloat((BYTE *)(& d___2->af0));
#line 1603
          pkt.af0 = (double )tmp___30;
#line 1604
          tmp___31 = tofloat((BYTE *)(& d___2->af1));
#line 1604
          pkt.af1 = (double )tmp___31;
#line 1605
          tmp___32 = tofloat((BYTE *)(& d___2->e));
#line 1605
          pkt.e = (double )tmp___32;
#line 1606
          tmp___33 = tofloat((BYTE *)(& d___2->sqrta));
#line 1606
          pkt.sqrta = (double )tmp___33;
#line 1607
          tmp___34 = tofloat((BYTE *)(& d___2->m0));
#line 1607
          pkt.m0 = (double )tmp___34;
#line 1608
          tmp___35 = tofloat((BYTE *)(& d___2->w));
#line 1608
          pkt.w = (double )tmp___35;
#line 1609
          tmp___36 = tofloat((BYTE *)(& d___2->omg0));
#line 1609
          pkt.omg0 = (double )tmp___36;
#line 1610
          tmp___37 = tofloat((BYTE *)(& d___2->odot));
#line 1610
          pkt.odot = (double )tmp___37;
#line 1611
          tmp___38 = tofloat((BYTE *)(& d___2->i));
#line 1611
          pkt.i = (double )tmp___38;
#line 1612
          pkt.hlth = (int )d___2->hlth;
          }
        }
      }
    }
  }
#line 1617
  if (pkt.svid == -2) {
#line 1618
    AlmanacSat ++;
#line 1618
    pkt.svid = AlmanacSat;
  }
#line 1626
  if ((int )pkt.wn < 0) {
#line 1627
    return;
  }
  {
#line 1630
  sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"******** Week %d almanac for PRN-%02d ********\n",
          (int )pkt.wn, pkt.svid);
#line 1632
  FileWrite(temp);
#line 1633
  sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"ID:                         %02d\n",
          pkt.svid);
#line 1634
  FileWrite(temp);
#line 1635
  sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"Health:                     %03d\n",
          pkt.hlth);
#line 1636
  FileWrite(temp);
#line 1637
  sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"Eccentricity:              % 1.10E\n",
          pkt.e);
#line 1638
  FileWrite(temp);
#line 1639
  sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"Time of Applicability(x):  %10.2f\n",
          pkt.toa);
#line 1640
  FileWrite(temp);
#line 1641
  sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"Orbital Inclination(rad):  % 1.10f\n",
          pkt.i);
#line 1642
  FileWrite(temp);
#line 1643
  sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"Rate of Right Ascen(r/s):  % 1.10E\n",
          pkt.odot);
#line 1644
  FileWrite(temp);
#line 1645
  sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"SQRT(A)  (m^1/2):          % 1.10f\n",
          pkt.sqrta);
#line 1646
  FileWrite(temp);
#line 1647
  sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"Right Ascen at TOA(rad):   % 1.10E\n",
          pkt.omg0);
#line 1648
  FileWrite(temp);
#line 1649
  sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"Argument of Perigee(rad):  % 1.10f\n",
          pkt.w);
#line 1650
  FileWrite(temp);
#line 1651
  sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"Mean Anom(rad):            % 1.10E\n",
          pkt.m0);
#line 1652
  FileWrite(temp);
#line 1653
  sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"Af0(s):                    % 1.10E\n",
          pkt.af0);
#line 1654
  FileWrite(temp);
#line 1655
  sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"Af1(s/s):                  % 1.10E\n",
          pkt.af1);
#line 1656
  FileWrite(temp);
#line 1657
  sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"week:                       %d\n",
          (int )pkt.wn);
#line 1658
  FileWrite(temp);
#line 1659
  sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"\n");
#line 1660
  FileWrite(temp);
  }
#line 1662
  return;
}
}
#line 1671 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/getgpsinfo.c"
static char s[50]  ;
#line 1668 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/getgpsinfo.c"
static char *string(short n , BYTE *p ) 
{ 
  short i ;
  BYTE *tmp ;

  {
#line 1674
  i = (short)0;
  {
#line 1674
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1674
    if (! ((int )i < (int )n)) {
#line 1674
      goto while_break;
    }
#line 1675
    tmp = p;
#line 1675
    p ++;
#line 1675
    s[i] = (char )*tmp;
#line 1674
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 1676
  s[n] = (char )'\000';
#line 1678
  return (s);
}
}
#line 1685 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/getgpsinfo.c"
static long number(BYTE *p ) 
{ 
  long n ;

  {
#line 1690
  n = ((((((long )*(p + 3) << 8) + (long )*(p + 2)) << 8) + (long )*(p + 1)) << 8) + (long )*(p + 0);
#line 1692
  return (n);
}
}
#line 1699 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/getgpsinfo.c"
static float tofloat(unsigned char *p ) 
{ 
  float n ;
  long *lp ;

  {
#line 1703
  lp = (long *)(& n);
#line 1705
  *lp = ((((((long )*(p + 3) << 8) + (long )*(p + 2)) << 8) + (long )*(p + 1)) << 8) + (long )*(p + 0);
#line 1706
  return (n);
}
}
#line 1713 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/getgpsinfo.c"
static short toshort(unsigned char *p ) 
{ 
  short n ;

  {
#line 1718
  n = (short )(((int )((short )*(p + 1)) << 8) + (int )*(p + 0));
#line 1720
  return (n);
}
}
#line 1726 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/getgpsinfo.c"
static void FileWrite(char *data ) 
{ 


  {
  {
#line 1729
  fputs((char const   */* __restrict  */)data, (FILE */* __restrict  */)FileRefNum);
  }
#line 1730
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/calendar.c"
static long date2days(short mm , short dd , short yy ) ;
#line 39
static void days2date(long days , short *mm , short *dd , short *yy ) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/calendar.c"
static char dt[30]  ;
#line 51 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/calendar.c"
char *secs2dt(long secs , short offset ) 
{ 
  short mm ;
  short dd ;
  short yy ;
  short h ;
  short m ;
  short s___0 ;
  long days ;
  long rest ;

  {
  {
#line 58
  days = (secs + (long )((double )offset * 3600.0)) / 86400L;
#line 59
  rest = (secs + (long )((double )offset * 3600.0)) - (days * 24L) * 3600L;
#line 61
  days2date(days, & mm, & dd, & yy);
#line 63
  h = (short )(rest / 3600L);
#line 64
  m = (short )((rest - (long )h * 3600L) / 60L);
#line 65
  s___0 = (short )((rest - (long )h * 3600L) - (long )m * 60L);
#line 66
  sprintf((char */* __restrict  */)(dt), (char const   */* __restrict  */)"%02d/%02d/%04d %02d:%02d:%02d",
          (int )mm, (int )dd, (int )yy, (int )h, (int )m, (int )s___0);
  }
#line 68
  return (dt);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/calendar.c"
long dt2secs(char *dt___0 , int offset ) 
{ 
  int mm ;
  int dd ;
  int yy ;
  int h ;
  int m ;
  int s___0 ;
  long tmp ;

  {
  {
#line 80
  sscanf((char const   */* __restrict  */)dt___0, (char const   */* __restrict  */)"%d/%d/%d %d:%d:%d",
         & mm, & dd, & yy, & h, & m, & s___0);
#line 81
  tmp = date2days((short )mm, (short )dd, (short )yy);
  }
#line 81
  return ((((86400L * tmp + 3600L * (long )h) + 60L * (long )m) + (long )s___0) - (long )((double )offset * 3600.0));
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/calendar.c"
static long date2days(short mm , short dd , short yy ) 
{ 
  long jul ;
  short ja ;
  short jy ;
  short jm ;

  {
#line 95
  if ((int )yy < 0) {
#line 96
    yy = (short )((int )yy + 1);
  }
#line 97
  if ((int )mm > 2) {
#line 99
    jy = yy;
#line 100
    jm = (short )((int )mm + 1);
  } else {
#line 104
    jy = (short )((int )yy - 1);
#line 105
    jm = (short )((int )mm + 13);
  }
#line 107
  ja = (short )(0.01 * (double )jy);
#line 108
  jul = (((((long )(365.25 * (double )jy) + (long )(30.6001 * (double )jm)) + (long )dd) + 1720997L) - (long )ja) + (long )(0.25 * (double )ja);
#line 111
  return (jul - 2447892L);
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/calendar.c"
static void days2date(long days , short *mm , short *dd , short *yy ) 
{ 
  long ja ;
  long jalpha ;
  long jb ;
  long jc ;
  long jd ;
  long je ;

  {
#line 123
  jalpha = (long )(((double )((float )((days + 2447892L) - 1867216L)) - 0.25) / 36524.25);
#line 125
  ja = (((days + 2447892L) + 1L) + jalpha) - (long )(0.25 * (double )jalpha);
#line 126
  jb = ja + 1524L;
#line 127
  jc = (long )(6680.0 + (double )((long )(((double )(jb - 2439870L) - 122.1) / 365.25)));
#line 128
  jd = (long )(365.25 * (double )jc);
#line 129
  je = (long )((double )(jb - jd) / 30.6001);
#line 131
  *dd = (short )((jb - jd) - (long )((short )(30.6001 * (double )je)));
#line 132
  *mm = (short )(je - 1L);
#line 133
  if ((int )*mm > 12) {
#line 134
    *mm = (short )((int )*mm - 12);
  }
#line 135
  *yy = (short )(jc - 4715L);
#line 136
  if ((int )*mm > 2) {
#line 137
    *yy = (short )((int )*yy - 1);
  }
#line 138
  if ((int )*yy <= 0) {
#line 139
    *yy = (short )((int )*yy - 1);
  }
#line 140
  return;
}
}
#line 127 "../include/Garmin.h"
BYTE m1[4] ;
#line 127
BYTE m2[5] ;
#line 128
BYTE p1[5] ;
#line 128
BYTE p2[5] ;
#line 36 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/gpsmessage.c"
BYTE m1[4]  = {      (BYTE )'\376',      (BYTE )'\001',      (BYTE )' ',      (BYTE )'\000'};
#line 37 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/gpsmessage.c"
BYTE m2[5]  = {      (BYTE )'\006',      (BYTE )'\002',      (BYTE )'\377',      (BYTE )'\000', 
        (BYTE )'\000'};
#line 39 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/gpsmessage.c"
BYTE p1[5]  = {      (BYTE )'\006',      (BYTE )'\002',      (BYTE )'\033',      (BYTE )'\000', 
        (BYTE )'\000'};
#line 40 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/gpsmessage.c"
BYTE p2[5]  = {      (BYTE )'\006',      (BYTE )'\002',      (BYTE )'\f',      (BYTE )'\000', 
        (BYTE )'\000'};
#line 42 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/gpsmessage.c"
BYTE alm1[5]  = {      (BYTE )'\n',      (BYTE )'\002',      (BYTE )'\001',      (BYTE )'\000', 
        (BYTE )'\000'};
#line 43 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/gpsmessage.c"
BYTE alm2[5]  = {      (BYTE )'\006',      (BYTE )'\002',      (BYTE )'\037',      (BYTE )'\000', 
        (BYTE )'\000'};
#line 45 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/gpsmessage.c"
BYTE trk1[5]  = {      (BYTE )'\n',      (BYTE )'\002',      (BYTE )'\006',      (BYTE )'\000', 
        (BYTE )'\000'};
#line 46 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/gpsmessage.c"
BYTE trk2[5]  = {      (BYTE )'\006',      (BYTE )'\002',      (BYTE )'\"',      (BYTE )'\000', 
        (BYTE )'\000'};
#line 48 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/gpsmessage.c"
BYTE wpt1[5]  = {      (BYTE )'\n',      (BYTE )'\002',      (BYTE )'\a',      (BYTE )'\000', 
        (BYTE )'\000'};
#line 49 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/gpsmessage.c"
BYTE wpt2[5]  = {      (BYTE )'\006',      (BYTE )'\002',      (BYTE )'#',      (BYTE )'\000', 
        (BYTE )'\000'};
#line 51 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/gpsmessage.c"
BYTE rte1[5]  = {      (BYTE )'\n',      (BYTE )'\002',      (BYTE )'\004',      (BYTE )'\000', 
        (BYTE )'\000'};
#line 52 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/gpsmessage.c"
BYTE rte2[5]  = {      (BYTE )'\006',      (BYTE )'\002',      (BYTE )'\035',      (BYTE )'\000', 
        (BYTE )'\000'};
#line 54 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/gpsmessage.c"
BYTE test[5]  = {      (BYTE )'\034',      (BYTE )'\002',      (BYTE )'\000',      (BYTE )'\000', 
        (BYTE )'\000'};
#line 56 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/gpsmessage.c"
BYTE gid4[3]  = {      (BYTE )'\376',      (BYTE )'\000',      (BYTE )'\000'};
#line 57 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/gpsmessage.c"
BYTE gid5[5]  = {      (BYTE )'\006',      (BYTE )'\002',      (BYTE )'\377',      (BYTE )'\000', 
        (BYTE )'\000'};
#line 59 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/gpsmessage.c"
BYTE off1[5]  = {      (BYTE )'\n',      (BYTE )'\002',      (BYTE )'\b',      (BYTE )'\000', 
        (BYTE )'\000'};
#line 60 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/gpsmessage.c"
BYTE tim1[5]  = {      (BYTE )'\n',      (BYTE )'\002',      (BYTE )'\005',      (BYTE )'\000', 
        (BYTE )'\000'};
#line 62 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/gpsmessage.c"
BYTE almt[5]  = {      (BYTE )'\f',      (BYTE )'\002',      (BYTE )'\001',      (BYTE )'\000', 
        (BYTE )'\000'};
#line 63 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/gpsmessage.c"
BYTE rtet[5]  = {      (BYTE )'\f',      (BYTE )'\002',      (BYTE )'\004',      (BYTE )'\000', 
        (BYTE )'\000'};
#line 64 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/gpsmessage.c"
BYTE trkt[5]  = {      (BYTE )'\f',      (BYTE )'\002',      (BYTE )'\006',      (BYTE )'\000', 
        (BYTE )'\000'};
#line 65 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/gpsmessage.c"
BYTE wptt[5]  = {      (BYTE )'\f',      (BYTE )'\002',      (BYTE )'\a',      (BYTE )'\000', 
        (BYTE )'\000'};
#line 1 "../include/Garmin.h"
static double const   Pi  =    (double const   )3.14159265358979323846;
#line 3 "../include/Garmin.h"
static double const   Degree___0  =    (double const   )1.74532925199432957692e-2;
#line 35 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/ups.c"
static void calcPhi(double *phi , double e , double t ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/ups.c"
void toUPS(double lat , double lon , double *x , double *y ) 
{ 
  double a ;
  double t ;
  double e ;
  double es ;
  double rho ;
  double k0___5 ;
  double lambda ;
  double phi ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;

  {
  {
#line 46
  k0___5 = 0.994;
#line 47
  lambda = lon * (double )Degree___0;
#line 48
  tmp = fabs(lat * (double )Degree___0);
#line 48
  phi = tmp;
#line 50
  datumParams(gPrefs.datum, & a, & es);
#line 51
  e = sqrt(es);
#line 52
  tmp___0 = tan((double )(Pi / (double const   )4.0 - (double const   )(phi / 2.0)));
#line 52
  tmp___1 = sin(phi);
#line 52
  tmp___2 = sin(phi);
#line 52
  tmp___3 = pow((1.0 - e * tmp___1) / (1.0 + e * tmp___2), e / 2.0);
#line 52
  t = tmp___0 / tmp___3;
#line 54
  tmp___4 = pow(1.0 + e, 1.0 + e);
#line 54
  tmp___5 = pow(1.0 - e, 1.0 - e);
#line 54
  tmp___6 = sqrt(tmp___4 * tmp___5);
#line 54
  rho = (((2.0 * a) * k0___5) * t) / tmp___6;
#line 56
  tmp___7 = sin(lambda);
#line 56
  *x = rho * tmp___7;
#line 57
  tmp___8 = cos(lambda);
#line 57
  *y = rho * tmp___8;
  }
#line 59
  if (lat > 0.0) {
#line 60
    *y = - *y;
  }
#line 61
  *x += 2.0e6;
#line 62
  *y += 2.0e6;
#line 63
  return;
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/ups.c"
void fromUPS(short southernHemisphere , double x , double y , double *lat , double *lon ) 
{ 
  double a ;
  double es ;
  double e ;
  double t ;
  double rho ;
  double k0___5 ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
  {
#line 75
  k0___5 = 0.994;
#line 77
  datumParams(gFilePrefs.datum, & a, & es);
#line 78
  e = sqrt(es);
#line 81
  x -= 2.0e6;
#line 82
  y -= 2.0e6;
#line 84
  rho = sqrt(x * x + y * y);
#line 85
  tmp = pow(1.0 + e, 1.0 + e);
#line 85
  tmp___0 = pow(1.0 - e, 1.0 - e);
#line 85
  tmp___1 = sqrt(tmp * tmp___0);
#line 85
  t = (rho * tmp___1) / ((2.0 * a) * k0___5);
#line 89
  calcPhi(lat, e, t);
#line 90
  *lat /= (double )Degree___0;
  }
#line 92
  if (y != 0.0) {
    {
#line 93
    tmp___2 = fabs(x / y);
#line 93
    t = atan(tmp___2);
    }
  } else {
#line 96
    t = (double )(Pi / (double const   )2.0);
#line 97
    if (x < 0.0) {
#line 98
      t = - t;
    }
  }
#line 101
  if (! southernHemisphere) {
#line 102
    y = - y;
  }
#line 104
  if (y < 0.0) {
#line 105
    t = (double )(Pi - (double const   )t);
  }
#line 106
  if (x < 0.0) {
#line 107
    t = - t;
  }
#line 109
  *lon = t / (double )Degree___0;
#line 110
  return;
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/ups.c"
static void calcPhi(double *phi , double e , double t ) 
{ 
  double old ;
  double tmp ;
  short maxIterations ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  short tmp___5 ;

  {
  {
#line 119
  tmp = atan(t);
#line 119
  old = (double )(Pi / (double const   )2.0 - (double const   )(2.0 * tmp));
#line 120
  maxIterations = (short)20;
  }
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 122
    tmp___4 = fabs((*phi - old) / *phi);
    }
#line 122
    if (tmp___4 > 1.0e-8) {
#line 122
      tmp___5 = maxIterations;
#line 122
      maxIterations = (short )((int )maxIterations - 1);
#line 122
      if (! tmp___5) {
#line 122
        goto while_break;
      }
    } else {
#line 122
      goto while_break;
    }
    {
#line 124
    old = *phi;
#line 125
    tmp___0 = sin(*phi);
#line 125
    tmp___1 = sin(*phi);
#line 125
    tmp___2 = pow((1.0 - e * tmp___0) / (1.0 + e * tmp___1), e / 2.0);
#line 125
    tmp___3 = atan(t * tmp___2);
#line 125
    *phi = (double )(Pi / (double const   )2.0 - (double const   )(2.0 * tmp___3));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 129
  return;
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/itm.c"
static char const   *zoneID  =    "VWXYZQRSTULMNOPFGHJKABCDE";
#line 41 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/itm.c"
static double const   lat0___2  =    (double const   )53.4999886;
#line 42 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/itm.c"
static double const   lon0___1  =    (double const   )(- 8.0);
#line 43 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/itm.c"
static double const   k0___2  =    (double const   )1.000035;
#line 50 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/itm.c"
void DegToITM(double lat , double lon , char *zone , double *x , double *y ) 
{ 
  short X ;
  short Y ;

  {
  {
#line 55
  strcpy((char */* __restrict  */)zone, (char const   */* __restrict  */)"--");
#line 56
  toTM(lat, lon, (double )lat0___2, (double )lon0___1, (double )k0___2, x, y);
#line 59
  *x = floor((*x + 200000.0) + 0.5);
#line 60
  *y = floor((*y + 250000.0) + 0.5);
  }
#line 63
  if (*x < 0.0) {
#line 67
    *x = 0.0;
#line 68
    *y = 0.0;
#line 69
    return;
  } else
#line 63
  if (*x > 500000.0) {
#line 67
    *x = 0.0;
#line 68
    *y = 0.0;
#line 69
    return;
  } else
#line 63
  if (*y < 0.0) {
#line 67
    *x = 0.0;
#line 68
    *y = 0.0;
#line 69
    return;
  } else
#line 63
  if (*y > 500000.0) {
#line 67
    *x = 0.0;
#line 68
    *y = 0.0;
#line 69
    return;
  }
#line 72
  X = (short )((long )*x / 100000L);
#line 73
  Y = (short )((long )*y / 100000L);
#line 75
  *x = (double )((long )*x % 100000L);
#line 76
  *y = (double )((long )*y % 100000L);
#line 78
  *(zone + 0) = (char )'I';
#line 79
  *(zone + 1) = (char )*(zoneID + (5 * (int )Y + (int )X));
#line 80
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/itm.c"
void ITMtoDeg(char *zone , double x , double y , double *lat , double *lon ) 
{ 
  int n ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 92
  tmp = strcmp((char const   *)zone, "--");
  }
#line 92
  if (tmp == 0) {
#line 95
    *lat = 0.0;
#line 96
    *lon = 0.0;
#line 97
    return;
  } else
#line 92
  if (x < 0.0) {
#line 95
    *lat = 0.0;
#line 96
    *lon = 0.0;
#line 97
    return;
  } else
#line 92
  if (x > 100000.0) {
#line 95
    *lat = 0.0;
#line 96
    *lon = 0.0;
#line 97
    return;
  } else
#line 92
  if (y < 0.0) {
#line 95
    *lat = 0.0;
#line 96
    *lon = 0.0;
#line 97
    return;
  } else
#line 92
  if (y > 100000.0) {
#line 95
    *lat = 0.0;
#line 96
    *lon = 0.0;
#line 97
    return;
  }
  {
#line 100
  tmp___0 = strchr(zoneID, (int )*(zone + 1));
#line 100
  n = (int )(tmp___0 - (char *)zoneID);
#line 102
  x += (double )(n % 5) * 100000.0 - 200000.0;
#line 103
  y += (double )(n / 5) * 100000.0 - 250000.0;
#line 105
  fromTM(x, y, (double )lat0___2, (double )lon0___1, (double )k0___2, lat, lon);
  }
#line 106
  return;
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/kkj.c"
static double const   lat0___3  =    (double const   )0.0;
#line 36 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/kkj.c"
static double const   lon0___2  =    (double const   )27.0;
#line 37 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/kkj.c"
static double const   k0___3  =    (double const   )1.0;
#line 43 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/kkj.c"
void DegToKKJ(double lat , double lon , char *zone , double *x , double *y ) 
{ 


  {
  {
#line 46
  sprintf((char */* __restrict  */)zone, (char const   */* __restrict  */)"27E");
#line 47
  toTM(lat, lon, (double )lat0___3, (double )lon0___2, (double )k0___3, x, y);
#line 50
  *x += 500000.0;
  }
#line 51
  return;
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/kkj.c"
void KKJtoDeg(short zone , short southernHemisphere , double x , double y , double *lat ,
              double *lon ) 
{ 


  {
  {
#line 62
  x -= 500000.0;
#line 63
  fromTM(x, y, (double )lat0___3, (double )lon0___2, (double )k0___3, lat, lon);
  }
#line 64
  return;
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 675 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 146 "include/Garmin.h"
int debugging  ;
#line 147 "include/Garmin.h"
int verbose  ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 77 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) settimeofday)(struct timeval  const  *__tv ,
                                                                                   struct timezone  const  *__tz ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/main.c"
char cmd  =    (char )' ';
#line 44 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/main.c"
char what  =    (char )' ';
#line 45 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/main.c"
char *prog  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/main.c"
char *progname  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/main.c"
char *dowhat  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/main.c"
char FileName[4097]  ;
#line 48 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/main.c"
FILE *refNum  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/main.c"
enum PROTOCOL mode  =    (enum PROTOCOL )1;
#line 50 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/main.c"
enum FILE_FORMAT file_format  =    (enum FILE_FORMAT )3333;
#line 58 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/main.c"
void NotResponding(void) 
{ 


  {
  {
#line 61
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"GPS [%s] is not responding - ",
          gPrefs.Device);
#line 62
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"make sure it is on and set to GRMN/GRMN protocol.\n");
#line 63
  exit(1);
  }
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/main.c"
void PrintHeadLine(void) 
{ 


  {
  {
#line 73
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s (ASCII) - Version %s\nCopyright (c) %s by Carsten ",
          "GPStrans", "0.41", "2005");
#line 75
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Tschach (tschach@zedat.fu-berlin.de)\n");
#line 76
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Linux/KKJ mods by     Janne Sinkkonen <janne@iki.fi> (1996)\n");
#line 78
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Copyright (c) 2000 German Grid by Andreas Lange <andreas.lange@rhein-main.de>\n");
#line 80
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Copyright (c) 1998,2000 Mayko-mXmap mods by Matthias Kattanek <mattes@ugraf.com>\n");
#line 82
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Copyright (c) 2001 Development by Joao Seabra-CT2GNL <seabra@ci.AAC.uc.pt>\n");
#line 84
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Copyright (c) 2005 Development by Jim Van Zandt <jrvz@comcast.removeme.net>\n");
  }
#line 86
  return;
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/main.c"
void usage(void) 
{ 


  {
  {
#line 95
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s flag [filename]\n\n",
          progname);
#line 97
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Flags are:  -v   version:   information about program\n            --help          print this help text\n            --debug         add debug printouts\n            --verbose       increase verbosity\n            -p   port:      set serial I/O-Device\n            -s   setup:     set datum, format, offset device and model\n            -i   ident:     identify connected GPS\n            -o   off:       Turn off GPS Device\n            -t   time:      Get time from GPS (-ts will set time on host)\n\n            -d?  download:  r = route, t = track, w = waypoint, a = almanac\n            -u?  upload:    r = route, t = track, w = waypoint\n\n            -m   format:    data in Mayko-mXmap format\n\nIf no filename is entered, data will be written to stdout and read from stdin.\nSerial I/O-Device can also be set with the environment variable $GPSDEV.\n");
#line 121
  exit(1);
  }
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/main.c"
void ParseError(int err ) 
{ 


  {
  {
#line 134
  if (err == 1) {
#line 134
    goto case_1;
  }
#line 140
  if (err == 2) {
#line 140
    goto case_2;
  }
#line 146
  if (err == 3) {
#line 146
    goto case_3;
  }
#line 152
  if (err == 4) {
#line 152
    goto case_4;
  }
#line 159
  if (err == 5) {
#line 159
    goto case_5;
  }
#line 132
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 135
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"You have to specify at least one parameter.\n\n");
#line 136
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Start %s without any parameters to get usage ",
          progname);
#line 138
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"information.\n");
  }
#line 139
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 141
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"You have to specify one of \'-da -dr -dt -dw\'\n\n");
#line 142
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Start %s without any parameters to get usage ",
          progname);
#line 144
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"information.\n");
  }
#line 145
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 147
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"You have to specify one of \'-ur -ut -uw\'\n\n");
#line 148
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Start %s without any parameters to get usage ",
          progname);
#line 150
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"information.\n");
  }
#line 151
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 153
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"You have to specify a device name when using \'-p\'\n\n");
#line 155
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Start %s without any parameters to get usage ",
          progname);
#line 157
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"information.\n");
  }
#line 158
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 160
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t get time from GPS Receiver\n");
  }
#line 161
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 163
  fflush(stderr);
#line 164
  exit(1);
  }
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/main.c"
void HandleAbout(void) 
{ 


  {
  {
#line 174
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Parts of this program were taken from MacGPS by %s",
          "John F. Waers\n\n");
#line 177
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"If you\'ve any questions or bugs please send email to:\n\n");
#line 179
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%53s",
          "tschach@zedat.fu-berlin.de");
#line 180
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n\n");
#line 181
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The newest version can always be found at:\n\n");
#line 182
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%57s",
          "ftp.fu-berlin.de:/pub/unix/misc/gps");
#line 183
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n\n");
#line 185
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*******************************************************************************\n");
#line 187
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*   Permission to use, copy, modify, and distribute this software and its     *\n");
#line 189
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*   documentation for non-commercial purpose, is hereby granted without fee,  *\n");
#line 191
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*   providing that the copyright notice appears in all copies and that both   *\n");
#line 193
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*   the copyright notice and this permission notice appear in supporting      *\n");
#line 195
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*   documentation. I make no representations about the suitability of this    *\n");
#line 197
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*   software for any purpose. It is provides \"as is\" without express or       *\n");
#line 199
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*   implied warranty.                                                          *\n");
#line 201
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*******************************************************************************\n");
#line 203
  exit(0);
  }
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/main.c"
void InfoAboutGPS(void) 
{ 
  int status ;
  char *string___0 ;

  {
  {
#line 215
  status = getGPSVersion(& string___0);
#line 216
  printf((char const   */* __restrict  */)"Connected GPS [%s] is: %s\n", gPrefs.Device,
         string___0);
#line 217
  exit(status);
  }
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/main.c"
void TurnOffGPS(void) 
{ 


  {
  {
#line 227
  sendGPSOff();
#line 228
  exit(0);
  }
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/main.c"
void AdjustTime(char dowhat___0 , int m ) 
{ 
  long diffis ;
  time_t clock___0 ;
  time_t clockgps ;
  struct timeval tp ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  __uid_t tmp___2 ;

  {
  {
#line 242
  time(& clock___0);
#line 243
  clockgps = getGPSTime(m);
  }
#line 244
  if (clockgps == -1L) {
    {
#line 245
    ParseError(5);
    }
  }
  {
#line 247
  tmp = ctime((time_t const   *)(& clockgps));
#line 247
  printf((char const   */* __restrict  */)"Local time determine from GPS-Receiver is:  %s",
         tmp);
#line 249
  tmp___0 = ctime((time_t const   *)(& clock___0));
#line 249
  printf((char const   */* __restrict  */)"Local time on machine is:                   %s\n",
         tmp___0);
#line 251
  diffis = clockgps - clock___0;
  }
#line 252
  if (diffis < 0L) {
#line 253
    diffis *= -1L;
  }
  {
#line 254
  printf((char const   */* __restrict  */)"Time difference is %ld seconds.\n", diffis);
  }
#line 257
  if ((int )dowhat___0 == 115) {
    {
#line 259
    tmp___2 = getuid();
    }
#line 259
    if (tmp___2 == 0U) {
#line 261
      if (diffis <= 7200L) {
        {
#line 263
        clockgps = getGPSTime(m);
#line 264
        tp.tv_sec = clockgps;
#line 265
        tp.tv_usec = (__suseconds_t )5000;
#line 266
        settimeofday((struct timeval  const  *)(& tp), (struct timezone  const  *)((struct timezone *)((void *)0)));
#line 267
        tmp___1 = ctime((time_t const   *)(& clockgps));
#line 267
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nLocal time set to:  %s",
                tmp___1);
        }
      } else {
        {
#line 271
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nTime difference is > 2 hours - time not set\n");
        }
      }
    } else {
      {
#line 276
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nSorry, only root can set the time.\n");
      }
    }
  }
  {
#line 279
  exit(0);
  }
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/main.c"
void TerminateHandler(int sig ) 
{ 


  {
#line 290
  if (sig == 2) {
    {
#line 292
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nDon\'t touch me...but you\'ve pressed CTRL-C\n");
#line 293
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"It was your choice....exiting\n");
    }
  } else {
    {
#line 297
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nGotcha...somebody try to shoot me...but he missed !\n");
#line 299
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nBut okay, committing suicide....<argh!>\n");
    }
  }
  {
#line 301
  exit(0);
  }
}
}
#line 309 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/main.c"
int main(int argc , char **argv ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char **tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;

  {
  {
#line 315
  signal(15, & TerminateHandler);
#line 316
  signal(2, & TerminateHandler);
#line 319
  progname = *(argv + 0);
#line 320
  PrintHeadLine();
  }
#line 323
  if (argc <= 1) {
    {
#line 324
    usage();
    }
  }
  {
#line 327
  FileName[0] = (char )'\000';
#line 328
  InitPrefs();
#line 329
  tmp___0 = getenv("GPSDEV");
  }
#line 329
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
    {
#line 330
    tmp = getenv("GPSDEV");
#line 330
    sprintf((char */* __restrict  */)(gPrefs.Device), (char const   */* __restrict  */)"%s",
            tmp);
    }
  }
#line 333
  tmp___1 = argv;
#line 333
  argv ++;
#line 333
  prog = *tmp___1;
  {
#line 333
  while (1) {
    while_continue: /* CIL Label */ ;
#line 333
    argc --;
#line 333
    if (! argc) {
#line 333
      goto while_break;
    }
    {
#line 335
    tmp___5 = strstr((char const   *)*argv, "--debug");
    }
#line 335
    if (tmp___5) {
#line 336
      debugging ++;
    } else {
      {
#line 337
      tmp___4 = strcmp("--verbose", (char const   *)*argv);
      }
#line 337
      if (0 == tmp___4) {
#line 338
        verbose ++;
      } else {
        {
#line 339
        tmp___3 = strcmp("--help", (char const   *)*argv);
        }
#line 339
        if (0 == tmp___3) {
          {
#line 340
          usage();
          }
        } else
#line 341
        if ((int )*(*(argv + 0) + 0) == 45) {
          {
#line 345
          if ((int )*(*(argv + 0) + 1) == 100) {
#line 345
            goto case_100;
          }
#line 349
          if ((int )*(*(argv + 0) + 1) == 117) {
#line 349
            goto case_117;
          }
#line 353
          if ((int )*(*(argv + 0) + 1) == 112) {
#line 353
            goto case_112;
          }
#line 362
          if ((int )*(*(argv + 0) + 1) == 118) {
#line 362
            goto case_118;
          }
#line 365
          if ((int )*(*(argv + 0) + 1) == 105) {
#line 365
            goto case_105;
          }
#line 368
          if ((int )*(*(argv + 0) + 1) == 111) {
#line 368
            goto case_111;
          }
#line 371
          if ((int )*(*(argv + 0) + 1) == 115) {
#line 371
            goto case_115;
          }
#line 374
          if ((int )*(*(argv + 0) + 1) == 116) {
#line 374
            goto case_116;
          }
#line 379
          if ((int )*(*(argv + 0) + 1) == 109) {
#line 379
            goto case_109;
          }
#line 387
          if ((int )*(*(argv + 0) + 1) == 122) {
#line 387
            goto case_122;
          }
#line 343
          goto switch_break;
          case_100: /* CIL Label */ 
#line 346
          dowhat = *argv + 2;
#line 347
          cmd = (char )'d';
#line 348
          goto switch_break;
          case_117: /* CIL Label */ 
#line 350
          dowhat = *argv + 2;
#line 351
          cmd = (char )'u';
#line 352
          goto switch_break;
          case_112: /* CIL Label */ 
#line 354
          if (*(*(argv + 0) + 2)) {
            {
#line 355
            sprintf((char */* __restrict  */)(gPrefs.Device), (char const   */* __restrict  */)"%s",
                    *argv + 2);
            }
          } else {
#line 357
            argc --;
#line 357
            if (argc) {
              {
#line 358
              argv ++;
#line 358
              sprintf((char */* __restrict  */)(gPrefs.Device), (char const   */* __restrict  */)"%s",
                      *argv);
              }
            } else {
              {
#line 360
              usage();
              }
            }
          }
#line 361
          goto switch_break;
          case_118: /* CIL Label */ 
          {
#line 363
          HandleAbout();
          }
#line 364
          goto switch_break;
          case_105: /* CIL Label */ 
          {
#line 366
          InfoAboutGPS();
          }
#line 367
          goto switch_break;
          case_111: /* CIL Label */ 
          {
#line 369
          TurnOffGPS();
          }
#line 370
          goto switch_break;
          case_115: /* CIL Label */ 
          {
#line 372
          SetupProgram();
          }
#line 373
          goto switch_break;
          case_116: /* CIL Label */ 
          {
#line 375
          dowhat = *argv + 2;
#line 376
          AdjustTime(*dowhat, 0);
          }
#line 377
          goto switch_break;
          case_109: /* CIL Label */ 
#line 380
          if ((unsigned int )file_format == 3334U) {
#line 381
            file_format = (enum FILE_FORMAT )3335;
          } else {
#line 383
            file_format = (enum FILE_FORMAT )3334;
          }
#line 384
          if (verbose) {
            {
#line 385
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n... Mayko-mXmap format is enabled !\n");
            }
          }
#line 386
          goto switch_break;
          case_122: /* CIL Label */ 
#line 388
          gPrefs.model = (char )'y';
#line 389
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        } else {
          {
#line 394
          tmp___2 = strlen((char const   *)(FileName));
          }
#line 394
          if (tmp___2 == 0UL) {
            {
#line 396
            FileName[4096] = (char)0;
#line 397
            strncpy((char */* __restrict  */)(FileName), (char const   */* __restrict  */)*(argv + 0),
                    (size_t )4096);
            }
          }
        }
      }
    }
#line 333
    argv ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 403
  tmp___6 = strlen((char const   *)(gPrefs.Device));
  }
#line 403
  if (tmp___6 == 0UL) {
    {
#line 404
    ParseError(4);
    }
  }
#line 407
  if ((int )cmd != 32) {
#line 408
    what = *(dowhat + 0);
  }
  {
#line 412
  if ((int )cmd == 100) {
#line 412
    goto case_100___0;
  }
#line 447
  if ((int )cmd == 117) {
#line 447
    goto case_117___0;
  }
#line 479
  goto switch_default___1;
  case_100___0: /* CIL Label */ 
  {
#line 414
  tmp___7 = strlen((char const   *)(FileName));
  }
#line 414
  if (tmp___7 == 0UL) {
#line 415
    refNum = stdout;
  } else {
    {
#line 418
    refNum = fopen((char const   */* __restrict  */)(FileName), (char const   */* __restrict  */)"wt");
    }
#line 419
    if (! refNum) {
      {
#line 421
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open %s for writing.\n",
              FileName);
#line 423
      exit(1);
      }
    }
  }
  {
#line 429
  if ((int )what == 97) {
#line 429
    goto case_97;
  }
#line 432
  if ((int )what == 114) {
#line 432
    goto case_114;
  }
#line 435
  if ((int )what == 116) {
#line 435
    goto case_116___0;
  }
#line 438
  if ((int )what == 119) {
#line 438
    goto case_119;
  }
#line 441
  goto switch_default;
  case_97: /* CIL Label */ 
  {
#line 430
  getGPSInfo(refNum, (short)0);
  }
#line 431
  goto switch_break___1;
  case_114: /* CIL Label */ 
  {
#line 433
  getGPSInfo(refNum, (short)1);
  }
#line 434
  goto switch_break___1;
  case_116___0: /* CIL Label */ 
  {
#line 436
  getGPSInfo(refNum, (short)2);
  }
#line 437
  goto switch_break___1;
  case_119: /* CIL Label */ 
  {
#line 439
  getGPSInfo(refNum, (short)3);
  }
#line 440
  goto switch_break___1;
  switch_default: /* CIL Label */ 
  {
#line 442
  ParseError(2);
  }
#line 443
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 445
  goto switch_break___0;
  case_117___0: /* CIL Label */ 
  {
#line 449
  tmp___8 = strlen((char const   *)(FileName));
  }
#line 449
  if (tmp___8 == 0UL) {
#line 450
    refNum = stdin;
  } else {
    {
#line 453
    refNum = fopen((char const   */* __restrict  */)(FileName), (char const   */* __restrict  */)"rt");
    }
#line 454
    if (! refNum) {
      {
#line 456
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open %s for reading.\n",
              FileName);
#line 458
      exit(1);
      }
    }
  }
  {
#line 464
  if ((int )what == 114) {
#line 464
    goto case_114___0;
  }
#line 467
  if ((int )what == 116) {
#line 467
    goto case_116___1;
  }
#line 470
  if ((int )what == 119) {
#line 470
    goto case_119___0;
  }
#line 473
  goto switch_default___0;
  case_114___0: /* CIL Label */ 
  {
#line 465
  sendGPSInfo(refNum, (short)1);
  }
#line 466
  goto switch_break___2;
  case_116___1: /* CIL Label */ 
  {
#line 468
  sendGPSInfo(refNum, (short)2);
  }
#line 469
  goto switch_break___2;
  case_119___0: /* CIL Label */ 
  {
#line 471
  sendGPSInfo(refNum, (short)3);
  }
#line 472
  goto switch_break___2;
  switch_default___0: /* CIL Label */ 
  {
#line 474
  ParseError(3);
  }
#line 475
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 477
  goto switch_break___0;
  switch_default___1: /* CIL Label */ 
  {
#line 480
  ParseError(1);
  }
#line 481
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 483
  exit(0);
  }
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/datum.c"
short nDatums  =    (short)102;
#line 58 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/datum.c"
struct DATUM  const  gDatum[103]  = 
#line 58
  {      {(char *)"Adindan", (short)5, (short)-162, (short)-12, (short)206}, 
        {(char *)"Afgooye", (short)15, (short)-43, (short)-163, (short)45}, 
        {(char *)"Ain el Abd 1970", (short)14, (short)-150, (short)-251, (short)-2}, 
        {(char *)"Anna 1 Astro 1965", (short)2, (short)-491, (short)-22, (short)435}, 
        {(char *)"Arc 1950",
      (short)5, (short)-143, (short)-90, (short)-294}, 
        {(char *)"Arc 1960", (short)5, (short)-160, (short)-8, (short)-300}, 
        {(char *)"Ascension Island `58", (short)14, (short)-207, (short)107, (short)52}, 
        {(char *)"Astro B4 Sorol Atoll",
      (short)14, (short)114, (short)-116, (short)-333}, 
        {(char *)"Astro Beacon \"E\"", (short)14, (short)145, (short)75, (short)-272}, 
        {(char *)"Astro DOS 71/4",
      (short)14, (short)-320, (short)550, (short)-494}, 
        {(char *)"Astronomic Stn `52", (short)14, (short)124, (short)-234, (short)-25}, 
        {(char *)"Australian Geod `66",
      (short)2, (short)-133, (short)-48, (short)148}, 
        {(char *)"Australian Geod `84", (short)2, (short)-134, (short)-48, (short)149}, 
        {(char *)"Bellevue (IGN)",
      (short)14, (short)-127, (short)-769, (short)472}, 
        {(char *)"Bermuda 1957", (short)4, (short)-73, (short)213, (short)296}, 
        {(char *)"Bogota Observatory", (short)14, (short)307, (short)304, (short)-318}, 
        {(char *)"Campo Inchauspe",
      (short)14, (short)-148, (short)136, (short)90}, 
        {(char *)"Canton Astro 1966", (short)14, (short)298, (short)-304, (short)-375}, 
        {(char *)"Cape",
      (short)5, (short)-136, (short)-108, (short)-292}, 
        {(char *)"Cape Canaveral", (short)4, (short)-2, (short)150, (short)181}, 
        {(char *)"Carthage", (short)5, (short)-263, (short)6, (short)431}, 
        {(char *)"CH-1903", (short)3, (short)674, (short)15, (short)405}, 
        {(char *)"Chatham 1971", (short)14, (short)175, (short)-38, (short)113}, 
        {(char *)"Chua Astro", (short)14, (short)-134, (short)229, (short)-29}, 
        {(char *)"Corrego Alegre", (short)14, (short)-206, (short)172, (short)-6}, 
        {(char *)"Djakarta (Batavia)", (short)3, (short)-377, (short)681, (short)-50}, 
        {(char *)"DOS 1968",
      (short)14, (short)230, (short)-199, (short)-752}, 
        {(char *)"Easter Island 1967", (short)14, (short)211, (short)147, (short)111}, 
        {(char *)"European 1950",
      (short)14, (short)-87, (short)-98, (short)-121}, 
        {(char *)"European 1979", (short)14, (short)-86, (short)-98, (short)-119}, 
        {(char *)"Finland Hayford", (short)14, (short)-78, (short)-231, (short)-97}, 
        {(char *)"Gandajika Base", (short)14, (short)-133, (short)-321, (short)50}, 
        {(char *)"Geodetic Datum `49", (short)14, (short)84, (short)-22, (short)209}, 
        {(char *)"Guam 1963",
      (short)4, (short)-100, (short)-248, (short)259}, 
        {(char *)"GUX 1 Astro", (short)14, (short)252, (short)-209, (short)-751}, 
        {(char *)"Hjorsey 1955", (short)14, (short)-73, (short)46, (short)-86}, 
        {(char *)"Hong Kong 1963", (short)14, (short)-156, (short)-271, (short)-189}, 
        {(char *)"Indian Bangladesh",
      (short)6, (short)289, (short)734, (short)257}, 
        {(char *)"Indian Thailand", (short)6, (short)214, (short)836, (short)303}, 
        {(char *)"Ireland 1965", (short)1, (short)506, (short)-122, (short)611}, 
        {(char *)"ISTS 073 Astro `69", (short)14, (short)208, (short)-435, (short)-229}, 
        {(char *)"Johnston Island",
      (short)14, (short)191, (short)-77, (short)-204}, 
        {(char *)"Kandawala", (short)6, (short)-97, (short)787, (short)86}, 
        {(char *)"Kerguelen Island", (short)14, (short)145, (short)-187, (short)103}, 
        {(char *)"Kertau 1948",
      (short)7, (short)-11, (short)851, (short)5}, 
        {(char *)"L.C. 5 Astro", (short)4, (short)42, (short)124, (short)147}, 
        {(char *)"Liberia 1964", (short)5, (short)-90, (short)40, (short)88}, 
        {(char *)"Luzon Mindanao", (short)4, (short)-133, (short)-79, (short)-72}, 
        {(char *)"Luzon Philippines", (short)4, (short)-133, (short)-77, (short)-51}, 
        {(char *)"Mahe 1971",
      (short)5, (short)41, (short)-220, (short)-134}, 
        {(char *)"Marco Astro", (short)14, (short)-289, (short)-124, (short)60}, 
        {(char *)"Massawa", (short)3, (short)639, (short)405, (short)60}, 
        {(char *)"Merchich", (short)5, (short)31, (short)146, (short)47}, 
        {(char *)"Midway Astro 1961", (short)14, (short)912, (short)-58, (short)1227}, 
        {(char *)"Minna",
      (short)5, (short)-92, (short)-93, (short)122}, 
        {(char *)"NAD27 Alaska", (short)4, (short)-5, (short)135, (short)172}, 
        {(char *)"NAD27 Bahamas", (short)4, (short)-4, (short)154, (short)178}, 
        {(char *)"NAD27 Canada", (short)4, (short)-10, (short)158, (short)187}, 
        {(char *)"NAD27 Canal Zone", (short)4, (short)0, (short)125, (short)201}, 
        {(char *)"NAD27 Caribbean", (short)4, (short)-7, (short)152, (short)178}, 
        {(char *)"NAD27 Central", (short)4, (short)0, (short)125, (short)194}, 
        {(char *)"NAD27 CONUS", (short)4, (short)-8, (short)160, (short)176}, 
        {(char *)"NAD27 Cuba", (short)4, (short)-9, (short)152, (short)178}, 
        {(char *)"NAD27 Greenland", (short)4, (short)11, (short)114, (short)195}, 
        {(char *)"NAD27 Mexico", (short)4, (short)-12, (short)130, (short)190}, 
        {(char *)"NAD27 San Salvador", (short)4, (short)1, (short)140, (short)165}, 
        {(char *)"NAD83", (short)11, (short)0, (short)0, (short)0}, 
        {(char *)"Nahrwn Masirah Ilnd", (short)5, (short)-247, (short)-148, (short)369}, 
        {(char *)"Nahrwn Saudi Arbia",
      (short)5, (short)-231, (short)-196, (short)482}, 
        {(char *)"Nahrwn United Arab", (short)5, (short)-249, (short)-156, (short)381}, 
        {(char *)"Naparima BWI",
      (short)14, (short)-2, (short)374, (short)172}, 
        {(char *)"Observatorio 1966", (short)14, (short)-425, (short)-169, (short)81}, 
        {(char *)"Old Egyptian",
      (short)12, (short)-130, (short)110, (short)-13}, 
        {(char *)"Old Hawaiian", (short)4, (short)61, (short)-285, (short)-181}, 
        {(char *)"Oman", (short)5, (short)-346, (short)-1, (short)224}, 
        {(char *)"Ord Srvy Grt Britn", (short)0, (short)375, (short)-111, (short)431}, 
        {(char *)"Pico De Las Nieves",
      (short)14, (short)-307, (short)-92, (short)127}, 
        {(char *)"Pitcairn Astro 1967", (short)14, (short)185, (short)165, (short)42}, 
        {(char *)"Prov So Amrican `56",
      (short)14, (short)-288, (short)175, (short)-376}, 
        {(char *)"Prov So Chilean `63", (short)14, (short)16, (short)196, (short)93}, 
        {(char *)"Puerto Rico",
      (short)4, (short)11, (short)72, (short)-101}, 
        {(char *)"Qatar National", (short)14, (short)-128, (short)-283, (short)22}, 
        {(char *)"Qornoq", (short)14, (short)164, (short)138, (short)-189}, 
        {(char *)"Reunion", (short)14, (short)94, (short)-948, (short)-1262}, 
        {(char *)"Rome 1940", (short)14, (short)-225, (short)-65, (short)9}, 
        {(char *)"RT 90", (short)3, (short)498, (short)-36, (short)568}, 
        {(char *)"Santo (DOS)", (short)14, (short)170, (short)42, (short)84}, 
        {(char *)"Sao Braz", (short)14, (short)-203, (short)141, (short)53}, 
        {(char *)"Sapper Hill 1943", (short)14, (short)-355, (short)16, (short)74}, 
        {(char *)"Schwarzeck", (short)21, (short)616, (short)97, (short)-251}, 
        {(char *)"South American `69", (short)16, (short)-57, (short)1, (short)-41}, 
        {(char *)"South Asia", (short)8, (short)7, (short)-10, (short)-26}, 
        {(char *)"Southeast Base", (short)14, (short)-499, (short)-249, (short)314}, 
        {(char *)"Southwest Base", (short)14, (short)-104, (short)167, (short)-38}, 
        {(char *)"Timbalai 1948", (short)6, (short)-689, (short)691, (short)-46}, 
        {(char *)"Tokyo", (short)3, (short)-128, (short)481, (short)664}, 
        {(char *)"Tristan Astro 1968", (short)14, (short)-632, (short)438, (short)-609}, 
        {(char *)"Viti Levu 1916",
      (short)5, (short)51, (short)391, (short)-36}, 
        {(char *)"Wake-Eniwetok `60", (short)13, (short)101, (short)52, (short)-39}, 
        {(char *)"WGS 72", (short)19, (short)0, (short)0, (short)5}, 
        {(char *)"WGS 84", (short)20, (short)0, (short)0, (short)0}, 
        {(char *)"Zanderij", (short)14, (short)-265, (short)120, (short)-358}, 
        {(char *)"Potsdam", (short)3, (short)606, (short)23, (short)413}};
#line 165 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/datum.c"
struct ELLIPSOID  const  gEllipsoid[23]  = 
#line 165
  {      {(char *)"Airy 1830", 6377563.396, 299.3249646}, 
        {(char *)"Modified Airy", 6377340.189, 299.3249646}, 
        {(char *)"Australian National", 6378160.0, 298.25}, 
        {(char *)"Bessel 1841", 6377397.155, 299.1528128}, 
        {(char *)"Clarke 1866", 6378206.4, 294.9786982}, 
        {(char *)"Clarke 1880", 6378249.145, 293.465}, 
        {(char *)"Everest (India 1830)", 6377276.345, 300.8017}, 
        {(char *)"Everest (1948)", 6377304.063, 300.8017}, 
        {(char *)"Modified Fischer 1960", 6378155.0, 298.3}, 
        {(char *)"Everest (Pakistan)", 6377309.613, 300.8017}, 
        {(char *)"Indonesian 1974", 6378160.0, 298.247}, 
        {(char *)"GRS 80", 6378137.0, 298.257222101}, 
        {(char *)"Helmert 1906", 6378200.0, 298.3}, 
        {(char *)"Hough 1960", 6378270.0, 297.0}, 
        {(char *)"International 1924", 6378388.0, 297.0}, 
        {(char *)"Krassovsky 1940", 6378245.0, 298.3}, 
        {(char *)"South American 1969", 6378160.0, 298.25}, 
        {(char *)"Everest (Malaysia 1969)", 6377295.664, 300.8017}, 
        {(char *)"Everest (Sabah Sarawak)", 6377298.556, 300.8017}, 
        {(char *)"WGS 72", 6378135.0, 298.26}, 
        {(char *)"WGS 84", 6378137.0, 298.257223563}, 
        {(char *)"Bessel 1841 (Namibia)", 6377483.865, 299.1528128}, 
        {(char *)"Everest (India 1956)", 6377301.243, 300.8017}};
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/garminserial.c"
int ttyfp  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/garminserial.c"
struct termio ttyset  ;
#line 53 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/garminserial.c"
int serialOpen(enum PROTOCOL p ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 58
  ttyfp = open((char const   *)(gPrefs.Device), 2);
  }
#line 61
  if (ttyfp < 0) {
#line 62
    return (-1);
  }
  {
#line 63
  tmp = ioctl(ttyfp, 21509UL, & ttyset);
  }
#line 63
  if (tmp < 0) {
#line 64
    return (-1);
  }
  {
#line 69
  if ((unsigned int )p == 1U) {
#line 69
    goto case_1;
  }
#line 73
  if ((unsigned int )p == 2U) {
#line 73
    goto case_2;
  }
#line 77
  goto switch_default;
  case_1: /* CIL Label */ 
#line 70
  ttyset.c_cflag = (unsigned short)13;
#line 71
  ttyset.c_cflag = (unsigned short )((int )ttyset.c_cflag | 2048);
#line 72
  goto switch_break;
  case_2: /* CIL Label */ 
#line 74
  ttyset.c_cflag = (unsigned short)12;
#line 75
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 78
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 85
  ttyset.c_cflag = (unsigned short )((int )ttyset.c_cflag | 176);
#line 88
  ttyset.c_lflag = (ushort )0;
#line 88
  ttyset.c_oflag = ttyset.c_lflag;
#line 88
  ttyset.c_iflag = ttyset.c_oflag;
#line 89
  ttyset.c_oflag = (unsigned short)32;
#line 92
  tmp___0 = ioctl(ttyfp, 21512UL, & ttyset);
  }
#line 92
  if (tmp___0 < 0) {
#line 93
    return (-1);
  }
#line 95
  return (0);
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/garminserial.c"
long serialCharsAvail(void) 
{ 
  int count ;

  {
  {
#line 107
  ioctl(ttyfp, 21531UL, & count);
  }
#line 108
  return ((long )count);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/gps/garminserial.c"
void serialClose(void) 
{ 


  {
  {
#line 118
  close(ttyfp);
  }
#line 119
  return;
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/util.c"
char gMessageStr[255]  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/util.c"
unsigned short product_ID  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/util.c"
unsigned short software_version  ;
#line 38 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/util.c"
char *protocols  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/util.c"
short GetLine(FILE *refNum___0 , char *line , short init ) 
{ 
  int tmp ;

  {
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 49
    tmp = feof(refNum___0);
    }
#line 49
    if (tmp) {
#line 49
      goto while_break;
    }
    {
#line 51
    fgets((char */* __restrict  */)line, 256, (FILE */* __restrict  */)refNum___0);
    }
#line 52
    if ((int )*line != 35) {
#line 53
      return ((short)1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  *line = (char )'\000';
#line 56
  return ((short)0);
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/util.c"
void Message(char *txt ) 
{ 


  {
  {
#line 66
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"INFO:  %s\n",
          txt);
#line 67
  fflush(stderr);
  }
#line 68
  return;
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/util.c"
void Error(char *txt ) 
{ 


  {
  {
#line 77
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR:  %s\n",
          txt);
#line 78
  fflush(stderr);
#line 79
  exit(1);
  }
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/util.c"
long TickCount(void) 
{ 
  time_t count ;

  {
  {
#line 91
  time(& count);
  }
#line 92
  return (count);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/util.c"
void *xmalloc(int num ) 
{ 
  void *p ;

  {
  {
#line 104
  p = malloc((size_t )num);
  }
#line 105
  if (! p) {
    {
#line 106
    Error((char *)"out of memory");
    }
  }
#line 107
  return (p);
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/seg.c"
static double const   lat0___4  =    (double const   )0.0;
#line 36 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/seg.c"
static double const   lon0___3  =    (double const   )15.808277777778;
#line 38 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/seg.c"
static double const   k0___4  =    (double const   )1.0;
#line 43 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/seg.c"
void DegToSEG(double lat , double lon , double *x , double *y ) 
{ 


  {
  {
#line 46
  toTM(lat, lon, (double )lat0___4, (double )lon0___3, (double )k0___4, x, y);
#line 49
  *y = floor(*y + 0.5);
#line 50
  *x = floor(*x + 1500000.5);
  }
#line 54
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/gpstrans-0.41/src/grid/seg.c"
void SEGtoDeg(double x , double y , double *lat , double *lon ) 
{ 


  {
  {
#line 63
  x -= 1500000.0;
#line 65
  fromTM(x, y, (double )lat0___4, (double )lon0___3, (double )k0___4, lat, lon);
  }
#line 66
  return;
}
}
