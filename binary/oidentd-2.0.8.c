/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 220 "/usr/include/unistd.h"
typedef __ssize_t ssize_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned char u_int8_t;
#line 201 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short u_int16_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 43 "/usr/include/x86_64-linux-gnu/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 162 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   unsigned long __ss_align ;
   char __ss_padding[128UL - 2UL * sizeof(unsigned long )] ;
};
#line 224 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_in;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_30 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_30 __in6_u ;
};
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 137 "./oidentd.h"
enum __anonenum_bool_31 {
    false = 0,
    true = 1
} ;
#line 137 "./oidentd.h"
typedef enum __anonenum_bool_31 bool;
#line 38 "./oidentd_netlink.h"
struct tcpdiag_sockid {
   u_int16_t tcpdiag_sport ;
   u_int16_t tcpdiag_dport ;
   u_int32_t tcpdiag_src[4] ;
   u_int32_t tcpdiag_dst[4] ;
   u_int32_t tcpdiag_if ;
   u_int32_t tcpdiag_cookie[2] ;
};
#line 50 "./oidentd_netlink.h"
struct tcpdiagreq {
   u_int8_t tcpdiag_family ;
   u_int8_t tcpdiag_src_len ;
   u_int8_t tcpdiag_dst_len ;
   u_int8_t tcpdiag_ext ;
   struct tcpdiag_sockid id ;
   u_int32_t tcpdiag_states ;
   u_int32_t tcpdiag_dbs ;
};
#line 60 "./oidentd_netlink.h"
struct tcpdiagmsg {
   u_int8_t tcpdiag_family ;
   u_int8_t tcpdiag_state ;
   u_int8_t tcpdiag_timer ;
   u_int8_t tcpdiag_retrans ;
   struct tcpdiag_sockid id ;
   u_int32_t tcpdiag_expires ;
   u_int32_t tcpdiag_rqueue ;
   u_int32_t tcpdiag_wqueue ;
   u_int32_t tcpdiag_uid ;
   u_int32_t tcpdiag_inode ;
};
#line 73 "./oidentd_netlink.h"
struct sockaddr_nl {
   sa_family_t nl_family ;
   unsigned short nl_pad ;
   u_int32_t nl_pid ;
   u_int32_t nl_groups ;
};
#line 80 "./oidentd_netlink.h"
struct nlmsghdr {
   u_int32_t nlmsg_len ;
   u_int16_t nlmsg_type ;
   u_int16_t nlmsg_flags ;
   u_int32_t nlmsg_seq ;
   u_int32_t nlmsg_pid ;
};
#line 462 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/os.c"
struct __anonstruct_req_32 {
   struct nlmsghdr nlh ;
   struct tcpdiagreq r ;
};
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 232 "/usr/include/unistd.h"
typedef __gid_t gid_t;
#line 237 "/usr/include/unistd.h"
typedef __uid_t uid_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_18 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_18 fd_set;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_in6;
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 42 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 30 "./oidentd_util.h"
struct list {
   struct list *next ;
   void *data ;
};
#line 30 "./oidentd_util.h"
typedef struct list list_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 40 "./oidentd_user_db.h"
struct port_range {
   in_port_t min ;
   in_port_t max ;
};
#line 40 "./oidentd_user_db.h"
struct user_cap {
   struct port_range *lport ;
   struct port_range *fport ;
   struct sockaddr_storage *src ;
   struct sockaddr_storage *dest ;
   u_int16_t caps ;
   u_int16_t action ;
   u_int8_t num_replies ;
   char **force_data ;
};
#line 55 "./oidentd_user_db.h"
struct user_info {
   uid_t user ;
   list_t *cap_list ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_16 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_16 __sigset_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 34 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 92 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag sigjmp_buf[1];
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 99 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_cfg_scan.c"
struct yy_buffer_state;
#line 99 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_cfg_scan.c"
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#line 150 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_cfg_scan.c"
typedef unsigned int yy_size_t;
#line 153 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_cfg_scan.c"
struct yy_buffer_state {
   FILE *yy_input_file ;
   char *yy_ch_buf ;
   char *yy_buf_pos ;
   yy_size_t yy_buf_size ;
   int yy_n_chars ;
   int yy_is_our_buffer ;
   int yy_is_interactive ;
   int yy_at_bol ;
   int yy_fill_buffer ;
   int yy_buffer_status ;
};
#line 276 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_cfg_scan.c"
typedef unsigned char YY_CHAR;
#line 278 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_cfg_scan.c"
typedef int yy_state_type;
#line 60 "./oidentd_cfg_parse.y"
union YYSTYPE {
   int value ;
   char *string ;
};
#line 60 "./oidentd_cfg_parse.y"
typedef union YYSTYPE YYSTYPE;
#line 280 "oidentd_cfg_parse.c"
union yyalloc {
   short yyss ;
   YYSTYPE yyvs ;
};
#line 332 "oidentd_cfg_parse.c"
typedef signed char yysigned_char;
#line 257 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 184
extern ssize_t sendmsg(int __fd , struct msghdr  const  *__message , int __flags ) ;
#line 202
extern ssize_t recvmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 375
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 142 "./oidentd.h"
int k_open(void) ;
#line 159
bool core_init(void) ;
#line 161
int get_user4(in_port_t lport , in_port_t fport , struct sockaddr_storage *laddr ,
              struct sockaddr_storage *faddr ) ;
#line 166
int get_user6(in_port_t lport , in_port_t fport , struct sockaddr_storage *laddr ,
              struct sockaddr_storage *faddr ) ;
#line 35 "./oidentd_util.h"
int ( /* format attribute */  o_log)(int priority , char const   *fmt  , ...) ;
#line 29 "./oidentd_inet_util.h"
void get_ip(struct sockaddr_storage *ss , char *buf , size_t len ) ;
#line 32
int ( /* format attribute */  sockprintf)(int fd , char const   *fmt  , ...) ;
#line 48
void sin_setv4(in_addr_t addr___0 , struct sockaddr_storage *ss ) ;
#line 51
size_t sin_addr_len(struct sockaddr_storage  const  *ss  __attribute__((__unused__)) ) ;
#line 53
void *sin_addr(struct sockaddr_storage *ss ) ;
#line 24 "./oidentd_masq.h"
int find_masq_entry(struct sockaddr_storage *host , char *user , size_t user_len ,
                    char *os , size_t os_len ) ;
#line 30
int fwd_request(int sock , in_port_t real_lport , in_port_t masq_lport , in_port_t real_fport ,
                struct sockaddr_storage *mrelay ) ;
#line 38
int masq(int sock , in_port_t lport , in_port_t fport , struct sockaddr_storage *laddr ,
         struct sockaddr_storage *faddr ) ;
#line 37 "./oidentd_options.h"
bool opt_enabled(u_int32_t option ) ;
#line 52 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/os.c"
static int netlink_sock  ;
#line 53
struct sockaddr_storage proxy ;
#line 55
static int lookup_tcp_diag(struct sockaddr_storage *src_addr , struct sockaddr_storage *dst_addr ,
                           in_port_t src_port , in_port_t dst_port ) ;
#line 61 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/os.c"
FILE *masq_fp  ;
#line 62 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/os.c"
bool netfilter  ;
#line 70 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/os.c"
bool core_init(void) 
{ 
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 72
  masq_fp = fopen((char const   */* __restrict  */)"/proc/net/ip_masquerade", (char const   */* __restrict  */)"r");
  }
#line 73
  if ((unsigned long )masq_fp == (unsigned long )((void *)0)) {
    {
#line 74
    tmp = __errno_location();
    }
#line 74
    if (*tmp != 2) {
      {
#line 75
      while (1) {
        while_continue: /* CIL Label */ ;
#line 75
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 76
      return ((bool )0);
    }
    {
#line 79
    masq_fp = fopen((char const   */* __restrict  */)"/proc/net/ip_conntrack", (char const   */* __restrict  */)"r");
    }
#line 80
    if ((unsigned long )masq_fp == (unsigned long )((void *)0)) {
      {
#line 81
      tmp___0 = __errno_location();
      }
#line 81
      if (*tmp___0 != 2) {
        {
#line 82
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 82
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 83
        return ((bool )0);
      }
      {
#line 85
      masq_fp = fopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"r");
      }
    }
#line 88
    netfilter = (bool )1;
  } else {
#line 90
    netfilter = (bool )0;
  }
#line 94
  return ((bool )1);
}
}
#line 105 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/os.c"
int get_user6(in_port_t lport , in_port_t fport , struct sockaddr_storage *laddr ,
              struct sockaddr_storage *faddr ) 
{ 
  FILE *fp ;
  char buf[1024] ;
  int uid___0 ;
  int tmp ;
  struct in6_addr remote6 ;
  struct in6_addr local6 ;
  u_int32_t portl_temp ;
  u_int32_t portf_temp ;
  in_port_t portl ;
  in_port_t portf ;
  int uid___1 ;
  int ret ;
  u_long inode ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
#line 113
  if (netlink_sock != -1) {
    {
#line 114
    tmp = lookup_tcp_diag(laddr, faddr, lport, fport);
#line 114
    uid___0 = tmp;
    }
#line 116
    if (uid___0 != -1) {
#line 117
      return (uid___0);
    }
  }
  {
#line 120
  lport = ntohs(lport);
#line 121
  fport = ntohs(fport);
#line 123
  fp = fopen((char const   */* __restrict  */)"/proc/net/tcp6", (char const   */* __restrict  */)"r");
  }
#line 124
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 125
    while (1) {
      while_continue: /* CIL Label */ ;
#line 125
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 126
    return (-1);
  }
  {
#line 130
  fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)fp);
  }
  {
#line 132
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 132
    tmp___4 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)fp);
    }
#line 132
    if (! tmp___4) {
#line 132
      goto while_break___0;
    }
    {
#line 143
    ret = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%*d: %8x%8x%8x%8x:%x %8x%8x%8x%8x:%x %*x %*X:%*X %*x:%*X %*x %d %*d %lu",
                 & local6.__in6_u.__u6_addr32[0], & local6.__in6_u.__u6_addr32[1],
                 & local6.__in6_u.__u6_addr32[2], & local6.__in6_u.__u6_addr32[3],
                 & portl_temp, & remote6.__in6_u.__u6_addr32[0], & remote6.__in6_u.__u6_addr32[1],
                 & remote6.__in6_u.__u6_addr32[2], & remote6.__in6_u.__u6_addr32[3],
                 & portf_temp, & uid___1, & inode);
    }
#line 151
    if (ret != 12) {
#line 152
      goto while_continue___0;
    }
    {
#line 154
    portl = (in_port_t )portl_temp;
#line 155
    portf = (in_port_t )portf_temp;
#line 157
    tmp___0 = sin_addr(laddr);
#line 157
    tmp___1 = memcmp((void const   *)(& local6), (void const   *)tmp___0, sizeof(local6));
    }
#line 157
    if (! tmp___1) {
      {
#line 157
      tmp___2 = sin_addr(faddr);
#line 157
      tmp___3 = memcmp((void const   *)(& remote6), (void const   *)tmp___2, sizeof(remote6));
      }
#line 157
      if (! tmp___3) {
#line 157
        if ((int )portl == (int )lport) {
#line 157
          if ((int )portf == (int )fport) {
            {
#line 162
            fclose(fp);
            }
#line 164
            if (inode == 0UL) {
#line 164
              if (uid___1 == 0) {
#line 165
                return (-1);
              }
            }
#line 167
            return (uid___1);
          }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 171
  fclose(fp);
  }
#line 172
  return (-1);
}
}
#line 182 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/os.c"
int get_user4(in_port_t lport , in_port_t fport , struct sockaddr_storage *laddr ,
              struct sockaddr_storage *faddr ) 
{ 
  int uid___0 ;
  FILE *fp ;
  char buf[1024] ;
  u_int32_t inode ;
  in_addr_t laddr4 ;
  in_addr_t faddr4 ;
  int ret ;
  u_int32_t portl_temp ;
  u_int32_t portf_temp ;
  in_port_t portl ;
  in_port_t portf ;
  in_addr_t local ;
  in_addr_t remote ;
  bool tmp ;
  char *tmp___0 ;

  {
#line 194
  if (netlink_sock != -1) {
    {
#line 195
    uid___0 = lookup_tcp_diag(laddr, faddr, lport, fport);
    }
#line 197
    if (uid___0 != -1) {
#line 198
      return (uid___0);
    }
  }
  {
#line 201
  laddr4 = ((struct sockaddr_in *)laddr)->sin_addr.s_addr;
#line 202
  faddr4 = ((struct sockaddr_in *)faddr)->sin_addr.s_addr;
#line 204
  lport = ntohs(lport);
#line 205
  fport = ntohs(fport);
#line 207
  fp = fopen((char const   */* __restrict  */)"/proc/net/tcp", (char const   */* __restrict  */)"r");
  }
#line 208
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 209
    while (1) {
      while_continue: /* CIL Label */ ;
#line 209
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 210
    return (-1);
  }
  {
#line 214
  fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)fp);
  }
  {
#line 220
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 220
    tmp___0 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)fp);
    }
#line 220
    if (! tmp___0) {
#line 220
      goto while_break___0;
    }
    {
#line 229
    ret = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%*d: %x:%x %x:%x %*x %*x:%*x %*x:%*x %*x %d %*d %u",
                 & local, & portl_temp, & remote, & portf_temp, & uid___0, & inode);
    }
#line 233
    if (ret != 6) {
#line 234
      goto while_continue___0;
    }
    {
#line 236
    portl = (in_port_t )portl_temp;
#line 237
    portf = (in_port_t )portf_temp;
#line 239
    tmp = opt_enabled((u_int32_t )(1 << 6));
    }
#line 239
    if (tmp) {
#line 240
      if (faddr4 == ((struct sockaddr_in *)(& proxy))->sin_addr.s_addr) {
#line 240
        if (remote != ((struct sockaddr_in *)(& proxy))->sin_addr.s_addr) {
#line 240
          if ((int )lport == (int )portl) {
#line 240
            if ((int )fport == (int )portf) {
#line 245
              goto out_success;
            }
          }
        }
      }
    }
#line 249
    if (local == laddr4) {
#line 249
      if (remote == faddr4) {
#line 249
        if ((int )portl == (int )lport) {
#line 249
          if ((int )portf == (int )fport) {
#line 254
            goto out_success;
          }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 258
  fclose(fp);
  }
#line 259
  return (-1);
  out_success: 
  {
#line 262
  fclose(fp);
  }
#line 270
  if (inode == 0U) {
#line 270
    if (uid___0 == 0) {
#line 271
      return (-1);
    }
  }
#line 273
  return (uid___0);
}
}
#line 283 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/os.c"
int masq(int sock , in_port_t lport , in_port_t fport , struct sockaddr_storage *laddr ,
         struct sockaddr_storage *faddr ) 
{ 
  char buf[2048] ;
  char os[24] ;
  char proto[16] ;
  in_port_t mport ;
  in_port_t nport ;
  in_port_t masq_lport ;
  in_port_t masq_fport ;
  char user[512] ;
  in_addr_t remoten ;
  in_addr_t localm ;
  in_addr_t remotem ;
  struct sockaddr_storage ss ;
  int ret ;
  u_int32_t mport_temp ;
  u_int32_t masq_lport_temp ;
  u_int32_t masq_fport_temp ;
  int l1 ;
  int l2 ;
  int l3 ;
  int l4 ;
  int r1 ;
  int r2 ;
  int r3 ;
  int r4 ;
  int nl1 ;
  int nl2 ;
  int nl3 ;
  int nl4 ;
  int nr1 ;
  int nr2 ;
  int nr3 ;
  int nr4 ;
  u_int32_t nport_temp ;
  u_int32_t mport_temp___0 ;
  in_addr_t localn ;
  u_int32_t masq_lport_temp___0 ;
  u_int32_t masq_fport_temp___0 ;
  int tmp ;
  bool tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  char ipbuf[46] ;
  int tmp___3 ;
  bool tmp___4 ;
  char ipbuf___0[46] ;
  char *tmp___5 ;

  {
#line 298
  if ((int )faddr->ss_family != 2) {
#line 299
    return (-1);
  }
  {
#line 301
  lport = ntohs(lport);
#line 302
  fport = ntohs(fport);
  }
#line 305
  if ((unsigned long )masq_fp == (unsigned long )((void *)0)) {
#line 306
    return (-1);
  }
  {
#line 309
  rewind(masq_fp);
  }
#line 311
  if (! netfilter) {
    {
#line 313
    fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)masq_fp);
    }
  }
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 316
    tmp___5 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)masq_fp);
    }
#line 316
    if (! tmp___5) {
#line 316
      goto while_break;
    }
#line 330
    if (! netfilter) {
      {
#line 335
      ret = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%15s %X:%X %X:%X %X %*X %*d %*d %*u",
                   proto, & localm, & masq_lport_temp, & remotem, & masq_fport_temp,
                   & mport_temp);
      }
#line 339
      if (ret != 6) {
#line 340
        goto while_continue;
      }
#line 342
      mport = (in_port_t )mport_temp;
#line 343
      masq_lport = (in_port_t )masq_lport_temp;
#line 344
      masq_fport = (in_port_t )masq_fport_temp;
    } else {
      {
#line 354
      ret = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%15s %*d %*d ESTABLISHED src=%d.%d.%d.%d dst=%d.%d.%d.%d sport=%d dport=%d src=%d.%d.%d.%d dst=%d.%d.%d.%d sport=%d dport=%d",
                   proto, & l1, & l2, & l3, & l4, & r1, & r2, & r3, & r4, & masq_lport_temp___0,
                   & masq_fport_temp___0, & nl1, & nl2, & nl3, & nl4, & nr1, & nr2,
                   & nr3, & nr4, & nport_temp, & mport_temp___0);
      }
#line 361
      if (ret != 21) {
        {
#line 362
        ret = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%15s %*d %*d ESTABLISHED src=%d.%d.%d.%d dst=%d.%d.%d.%d sport=%d dport=%d packets=%*d bytes=%*d src=%d.%d.%d.%d dst=%d.%d.%d.%d sport=%d dport=%d",
                     proto, & l1, & l2, & l3, & l4, & r1, & r2, & r3, & r4, & masq_lport_temp___0,
                     & masq_fport_temp___0, & nl1, & nl2, & nl3, & nl4, & nr1, & nr2,
                     & nr3, & nr4, & nport_temp, & mport_temp___0);
        }
      }
#line 370
      if (ret != 21) {
#line 371
        goto while_continue;
      }
#line 373
      masq_lport = (in_port_t )masq_lport_temp___0;
#line 374
      masq_fport = (in_port_t )masq_fport_temp___0;
#line 376
      nport = (in_port_t )nport_temp;
#line 377
      mport = (in_port_t )mport_temp___0;
#line 379
      localm = (in_addr_t )((((l1 << 24) | (l2 << 16)) | (l3 << 8)) | l4);
#line 380
      remotem = (in_addr_t )((((r1 << 24) | (r2 << 16)) | (r3 << 8)) | r4);
#line 382
      localn = (in_addr_t )((((nl1 << 24) | (nl2 << 16)) | (nl3 << 8)) | nl4);
#line 383
      remoten = (in_addr_t )((((nr1 << 24) | (nr2 << 16)) | (nr3 << 8)) | nr4);
#line 385
      if (remotem != localn) {
#line 386
        remotem = localn;
      }
    }
    {
#line 389
    tmp = strcasecmp((char const   *)(proto), "tcp");
    }
#line 389
    if (tmp) {
#line 390
      goto while_continue;
    }
#line 392
    if ((int )mport != (int )lport) {
#line 393
      goto while_continue;
    }
#line 395
    if ((int )masq_fport != (int )fport) {
#line 396
      goto while_continue;
    }
    {
#line 398
    tmp___1 = ntohl(((struct sockaddr_in *)faddr)->sin_addr.s_addr);
    }
#line 398
    if (remotem != tmp___1) {
      {
#line 399
      tmp___0 = opt_enabled((u_int32_t )(1 << 6));
      }
#line 399
      if (! tmp___0) {
#line 400
        goto while_continue;
      }
#line 402
      if (((struct sockaddr_in *)faddr)->sin_addr.s_addr != ((struct sockaddr_in *)(& proxy))->sin_addr.s_addr) {
#line 403
        goto while_continue;
      }
#line 405
      if (remotem == ((struct sockaddr_in *)(& proxy))->sin_addr.s_addr) {
#line 406
        goto while_continue;
      }
    }
    {
#line 409
    tmp___2 = htonl(localm);
#line 409
    sin_setv4(tmp___2, & ss);
#line 411
    tmp___4 = opt_enabled((u_int32_t )(1 << 5));
    }
#line 411
    if (tmp___4) {
      {
#line 414
      tmp___3 = fwd_request(sock, lport, masq_lport, fport, & ss);
      }
#line 414
      if (tmp___3 == 0) {
#line 415
        goto out_success;
      }
      {
#line 417
      get_ip(& ss, ipbuf, sizeof(ipbuf));
      }
      {
#line 419
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 419
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 422
    ret = find_masq_entry(& ss, user, sizeof(user), os, sizeof(os));
    }
#line 423
    if (ret == 0) {
      {
#line 426
      sockprintf(sock, "%d , %d : USERID : %s : %s\r\n", (int )lport, (int )fport,
                 os, user);
#line 429
      get_ip(faddr, ipbuf___0, sizeof(ipbuf___0));
#line 431
      o_log(6, "[%s] (Masqueraded) Successful lookup: %d , %d : %s", ipbuf___0, (int )lport,
            (int )fport, user);
      }
#line 435
      goto out_success;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 439
  return (-1);
  out_success: 
#line 442
  return (0);
}
}
#line 456 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/os.c"
static int lookup_tcp_diag(struct sockaddr_storage *src_addr , struct sockaddr_storage *dst_addr ,
                           in_port_t src_port , in_port_t dst_port ) 
{ 
  struct sockaddr_nl nladdr ;
  struct __anonstruct_req_32 req ;
  size_t addr_len ;
  size_t tmp ;
  struct iovec iov[1] ;
  struct msghdr msghdr ;
  char buf[8192] ;
  void *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  ssize_t tmp___3 ;
  ssize_t ret ;
  size_t uret ;
  struct nlmsghdr *h ;
  int *tmp___4 ;
  int *tmp___5 ;
  struct tcpdiagmsg *r ;
  void *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;

  {
  {
#line 466
  tmp = sin_addr_len((struct sockaddr_storage  const  *)dst_addr);
#line 466
  addr_len = tmp;
#line 471
  memset((void *)(& nladdr), 0, sizeof(nladdr));
#line 472
  nladdr.nl_family = (sa_family_t )16;
#line 474
  req.nlh.nlmsg_len = (u_int32_t )sizeof(req);
#line 475
  req.nlh.nlmsg_type = (u_int16_t )18;
#line 476
  req.nlh.nlmsg_flags = (u_int16_t )1;
#line 477
  req.nlh.nlmsg_pid = (u_int32_t )0;
#line 478
  req.nlh.nlmsg_seq = (u_int32_t )1;
#line 480
  memset((void *)(& req.r), 0, sizeof(req.r));
#line 482
  req.r.tcpdiag_states = ~ 0U;
#line 483
  req.r.tcpdiag_family = (u_int8_t )dst_addr->ss_family;
#line 484
  tmp___0 = sin_addr(dst_addr);
#line 484
  memcpy((void */* __restrict  */)(& req.r.id.tcpdiag_dst), (void const   */* __restrict  */)tmp___0,
         addr_len);
#line 485
  tmp___1 = sin_addr(src_addr);
#line 485
  memcpy((void */* __restrict  */)(& req.r.id.tcpdiag_src), (void const   */* __restrict  */)tmp___1,
         addr_len);
#line 486
  req.r.id.tcpdiag_dport = dst_port;
#line 487
  req.r.id.tcpdiag_sport = src_port;
#line 488
  req.r.id.tcpdiag_cookie[0] = ~ 0U;
#line 489
  req.r.id.tcpdiag_cookie[1] = ~ 0U;
#line 491
  iov[0].iov_base = (void *)(& req);
#line 492
  iov[0].iov_len = sizeof(req);
#line 494
  msghdr.msg_name = (void *)(& nladdr);
#line 495
  msghdr.msg_namelen = (socklen_t )sizeof(nladdr);
#line 496
  msghdr.msg_iov = iov;
#line 497
  msghdr.msg_iovlen = (size_t )1;
#line 498
  msghdr.msg_control = (void *)0;
#line 499
  msghdr.msg_controllen = (size_t )0;
#line 500
  msghdr.msg_flags = 0;
#line 502
  tmp___3 = sendmsg(netlink_sock, (struct msghdr  const  *)(& msghdr), 0);
  }
#line 502
  if (tmp___3 < 0L) {
    {
#line 503
    tmp___2 = __errno_location();
    }
#line 503
    if (*tmp___2 == 111) {
      {
#line 504
      close(netlink_sock);
#line 505
      netlink_sock = -1;
      }
    }
#line 508
    return (-1);
  }
#line 511
  iov[0].iov_base = (void *)(buf);
#line 512
  iov[0].iov_len = sizeof(buf);
  {
#line 514
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 519
    msghdr.msg_name = (void *)(& nladdr);
#line 520
    msghdr.msg_namelen = (socklen_t )sizeof(nladdr);
#line 521
    msghdr.msg_iov = iov;
#line 522
    msghdr.msg_iovlen = (size_t )1;
#line 523
    msghdr.msg_control = (void *)0;
#line 524
    msghdr.msg_controllen = (size_t )0;
#line 525
    msghdr.msg_flags = 0;
#line 527
    ret = recvmsg(netlink_sock, & msghdr, 0);
    }
#line 528
    if (ret < 0L) {
      {
#line 529
      tmp___4 = __errno_location();
      }
#line 529
      if (*tmp___4 == 4) {
#line 530
        goto while_continue;
      } else {
        {
#line 529
        tmp___5 = __errno_location();
        }
#line 529
        if (*tmp___5 == 11) {
#line 530
          goto while_continue;
        }
      }
#line 532
      return (-1);
    }
#line 535
    if (ret == 0L) {
#line 536
      return (-1);
    }
#line 538
    h = (struct nlmsghdr *)(buf);
#line 540
    uret = (size_t )ret;
    {
#line 541
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 541
      if (uret > 0UL) {
#line 541
        if ((unsigned long )h->nlmsg_len >= sizeof(struct nlmsghdr )) {
#line 541
          if (! ((size_t )h->nlmsg_len <= uret)) {
#line 541
            goto while_break___0;
          }
        } else {
#line 541
          goto while_break___0;
        }
      } else {
#line 541
        goto while_break___0;
      }
#line 544
      if (h->nlmsg_seq != 1U) {
#line 545
        uret -= (size_t )(((h->nlmsg_len + 4U) - 1U) & 4294967292U);
#line 545
        h = (struct nlmsghdr *)((char *)h + (((h->nlmsg_len + 4U) - 1U) & 4294967292U));
#line 546
        goto while_continue___0;
      }
#line 549
      if ((int )h->nlmsg_type == 3) {
#line 550
        return (-1);
      } else
#line 549
      if ((int )h->nlmsg_type == 2) {
#line 550
        return (-1);
      }
#line 552
      r = (struct tcpdiagmsg *)((void *)((char *)h + (((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL)));
#line 554
      if ((int )r->id.tcpdiag_dport == (int )dst_port) {
#line 554
        if ((int )r->id.tcpdiag_sport == (int )src_port) {
          {
#line 554
          tmp___6 = sin_addr(dst_addr);
#line 554
          tmp___7 = memcmp((void const   *)(r->id.tcpdiag_dst), (void const   *)tmp___6,
                           addr_len);
          }
#line 554
          if (! tmp___7) {
            {
#line 554
            tmp___8 = sin_addr(src_addr);
#line 554
            tmp___9 = memcmp((void const   *)(r->id.tcpdiag_src), (void const   *)tmp___8,
                             addr_len);
            }
#line 554
            if (! tmp___9) {
#line 559
              if (r->tcpdiag_inode == 0U) {
#line 559
                if (r->tcpdiag_uid == 0U) {
#line 560
                  return (-1);
                }
              }
#line 562
              return ((int )r->tcpdiag_uid);
            }
          }
        }
      }
#line 565
      return (-1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 568
    if (msghdr.msg_flags & 32) {
#line 569
      return (-1);
    } else
#line 568
    if (uret != 0UL) {
#line 569
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 572
  return (-1);
}
}
#line 579 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/os.c"
int k_open(void) 
{ 


  {
  {
#line 580
  netlink_sock = socket(16, 2, 4);
  }
#line 581
  return (0);
}
}
#line 432 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 324 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srandom)(unsigned int __seed ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 181 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 127 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 141
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getpeername)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 379 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 171 "./oidentd.h"
int read_config(char const   *path ) ;
#line 36 "./oidentd_util.h"
int drop_privs(uid_t new_uid , gid_t new_gid ) ;
#line 37
int go_background(void) ;
#line 51
char *xstrncpy(char *dest , char const   *src , size_t n ) ;
#line 52
char *xstrdup(char const   *string ) ;
#line 60
int random_seed(void) ;
#line 25 "./oidentd_inet_util.h"
int *setup_listen(struct sockaddr_storage *listen_addr , in_port_t listen_port___0 ) ;
#line 30
int get_hostname(struct sockaddr_storage *addr___0 , char *hostbuf , size_t len ) ;
#line 33
ssize_t sock_read(int sock , char *buf , size_t len ) ;
#line 49
void sin_extractv4(void *in6 , struct in_addr *in4 ) ;
#line 54
in_port_t sin_port(struct sockaddr_storage  const  *ss ) ;
#line 62 "./oidentd_user_db.h"
void user_db_destroy(void) ;
#line 67
int get_ident(struct passwd  const  *pwd , in_port_t lport , in_port_t fport , struct sockaddr_storage *laddr ,
              struct sockaddr_storage *faddr , char *reply , size_t len ) ;
#line 39 "./oidentd_options.h"
int get_options(int argc , char * const  *argv ) ;
#line 52 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd.c"
static  __attribute__((__noreturn__)) void sig_segv(int unused  __attribute__((__unused__)) ) ;
#line 53
static void sig_child(int sig ) ;
#line 54
static  __attribute__((__noreturn__)) void sig_alarm(int unused  __attribute__((__unused__)) ) ;
#line 55
static void sig_hup(int unused  __attribute__((__unused__)) ) ;
#line 57
static void copy_pw(struct passwd  const  *pw , struct passwd *pwd ) ;
#line 58
static void free_pw(struct passwd *pw ) ;
#line 60
static void seed_prng(void) ;
#line 62
static int service_request(int insock , int outsock ) ;
#line 64 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd.c"
u_int32_t timeout  =    (u_int32_t )30;
#line 65 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd.c"
u_int32_t connection_limit  ;
#line 66 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd.c"
u_int32_t current_connections  =    (u_int32_t )0;
#line 68 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd.c"
uid_t uid  ;
#line 69 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd.c"
gid_t gid  ;
#line 71 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd.c"
char *ret_os  ;
#line 72 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd.c"
char *failuser  ;
#line 73 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd.c"
char *config_file  ;
#line 75 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd.c"
in_port_t listen_port  ;
#line 76 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd.c"
struct sockaddr_storage *addr  ;
#line 78 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd.c"
int main(int argc , char **argv ) 
{ 
  int *listen_fds ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  uint16_t tmp___5 ;
  bool tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  bool tmp___13 ;
  fd_set rfds ;
  int ret ;
  size_t fdlen ;
  int __d0 ;
  int __d1 ;
  int fd ;
  size_t tmp___14 ;
  size_t i ;
  int connectfd ;
  size_t idx ;
  __pid_t tmp___15 ;

  {
  {
#line 79
  listen_fds = (int *)((void *)0);
#line 81
  tmp = get_options(argc, (char * const  *)argv);
  }
#line 81
  if (tmp != 0) {
    {
#line 82
    exit(-1);
    }
  }
  {
#line 84
  openlog("oidentd", 11, 3 << 3);
#line 86
  tmp___0 = read_config((char const   *)config_file);
  }
#line 86
  if (tmp___0 != 0) {
    {
#line 87
    o_log(6, "Error reading configuration file");
#line 88
    exit(-1);
    }
  }
  {
#line 91
  tmp___1 = core_init();
  }
#line 91
  if (! tmp___1) {
    {
#line 92
    o_log(6, "Error initializing core");
#line 93
    exit(-1);
    }
  }
  {
#line 96
  tmp___2 = random_seed();
  }
#line 96
  if (tmp___2 != 0) {
    {
#line 97
    o_log(6, "Error seeding random number generator");
#line 98
    exit(-1);
    }
  }
  {
#line 101
  tmp___3 = opt_enabled((u_int32_t )(1 << 10));
  }
#line 101
  if (! tmp___3) {
    {
#line 101
    tmp___4 = go_background();
    }
#line 101
    if (tmp___4 == -1) {
      {
#line 102
      o_log(6, "Fatal: Error creating daemon process");
#line 103
      exit(-1);
      }
    }
  }
  {
#line 106
  tmp___6 = opt_enabled((u_int32_t )(1 << 12));
  }
#line 106
  if (! tmp___6) {
    {
#line 107
    tmp___5 = htons(listen_port);
#line 107
    listen_fds = setup_listen(addr, tmp___5);
    }
#line 108
    if ((unsigned long )listen_fds == (unsigned long )((void *)0)) {
      {
#line 109
      o_log(6, "Fatal: Unable to setup listening socket");
#line 110
      exit(-1);
      }
    } else
#line 108
    if (*(listen_fds + 0) == -1) {
      {
#line 109
      o_log(6, "Fatal: Unable to setup listening socket");
#line 110
      exit(-1);
      }
    }
  }
  {
#line 114
  tmp___9 = k_open();
  }
#line 114
  if (tmp___9 != 0) {
    {
#line 115
    tmp___7 = __errno_location();
#line 115
    tmp___8 = strerror(*tmp___7);
#line 115
    o_log(6, "Fatal: Can\'t open kmem device: %s", tmp___8);
#line 116
    exit(-1);
    }
  }
  {
#line 119
  tmp___10 = drop_privs(uid, gid);
  }
#line 119
  if (tmp___10 == -1) {
    {
#line 120
    o_log(6, "Fatal: Couldn\'t drop privileges");
#line 121
    exit(-1);
    }
  }
  {
#line 133
  signal(14, & sig_alarm);
#line 134
  signal(17, & sig_child);
#line 135
  signal(1, & sig_hup);
#line 136
  signal(11, & sig_segv);
#line 138
  tmp___13 = opt_enabled((u_int32_t )(1 << 12));
  }
#line 138
  if (tmp___13) {
    {
#line 139
    tmp___11 = fileno(stdout);
#line 139
    tmp___12 = fileno(stdin);
#line 139
    service_request(tmp___12, tmp___11);
#line 140
    exit(0);
    }
  }
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 146
    fdlen = (size_t )0;
    {
#line 148
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 148
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& rfds.fds_bits[0]): "memory");
#line 148
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 150
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 151
      tmp___14 = fdlen;
#line 151
      fdlen ++;
#line 151
      fd = *(listen_fds + tmp___14);
#line 152
      rfds.fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
#line 150
      if (! (*(listen_fds + fdlen) != -1)) {
#line 150
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 155
    ret = select(*(listen_fds + (fdlen - 1UL)) + 1, (fd_set */* __restrict  */)(& rfds),
                 (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)((void *)0),
                 (struct timeval */* __restrict  */)((void *)0));
    }
#line 156
    if (ret > 0) {
#line 159
      i = (size_t )0;
      {
#line 159
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 159
        if (! (i < fdlen)) {
#line 159
          goto while_break___2;
        }
#line 160
        if ((rfds.fds_bits[*(listen_fds + i) / (8 * (int )sizeof(__fd_mask ))] & (1L << *(listen_fds + i) % (8 * (int )sizeof(__fd_mask )))) != 0L) {
          {
#line 163
          connectfd = accept(*(listen_fds + i), (struct sockaddr */* __restrict  */)((void *)0),
                             (socklen_t */* __restrict  */)((void *)0));
          }
#line 164
          if (connectfd == -1) {
            {
#line 165
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 165
              goto while_break___3;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 166
            goto __Cont;
          }
#line 169
          if (current_connections >= connection_limit) {
            {
#line 170
            close(connectfd);
            }
#line 171
            goto __Cont;
          }
          {
#line 174
          current_connections ++;
#line 176
          tmp___15 = fork();
          }
#line 176
          if (tmp___15 == 0) {
#line 179
            idx = (size_t )0;
            {
#line 179
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 179
              if (! (*(listen_fds + idx) != -1)) {
#line 179
                goto while_break___4;
              }
              {
#line 180
              close(*(listen_fds + idx));
#line 179
              idx ++;
              }
            }
            while_break___4: /* CIL Label */ ;
            }
            {
#line 182
            free((void *)listen_fds);
#line 183
            alarm(timeout);
#line 184
            seed_prng();
#line 185
            service_request(connectfd, connectfd);
#line 187
            exit(0);
            }
          }
          {
#line 190
          close(connectfd);
          }
        }
        __Cont: /* CIL Label */ 
#line 159
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 196
  exit(0);
  }
}
}
#line 217 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd.c"
static socklen_t socklen  =    (socklen_t )sizeof(struct sockaddr_storage );
#line 203 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd.c"
static int service_request(int insock , int outsock ) 
{ 
  int len ;
  int ret ;
  int con_uid ;
  int lport_temp ;
  int fport_temp ;
  in_port_t lport ;
  in_port_t fport ;
  char line[128] ;
  char suser[512] ;
  char host_buf[256] ;
  char ip_buf[46] ;
  struct sockaddr_storage laddr ;
  struct sockaddr_storage laddr6 ;
  struct sockaddr_storage faddr ;
  struct sockaddr_storage faddr6 ;
  struct passwd *pw ;
  struct passwd pwd ;
  int tmp ;
  int tmp___0 ;
  struct in_addr in4 ;
  struct in6_addr  const  *__a ;
  uint32_t tmp___1 ;
  int tmp___2 ;
  in_port_t tmp___3 ;
  int tmp___4 ;
  ssize_t tmp___5 ;
  char const   *tmp___7 ;
  bool tmp___8 ;
  uint16_t tmp___9 ;
  uint16_t tmp___10 ;
  uint16_t tmp___11 ;
  uint16_t tmp___12 ;
  uint16_t tmp___13 ;
  uint16_t tmp___14 ;
  int tmp___15 ;
  bool tmp___16 ;
  char const   *tmp___18 ;
  bool tmp___19 ;
  char const   *tmp___21 ;
  bool tmp___22 ;
  char const   *tmp___24 ;
  bool tmp___25 ;

  {
  {
#line 219
  tmp = getpeername(insock, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& faddr)),
                    (socklen_t */* __restrict  */)(& socklen));
  }
#line 219
  if (tmp != 0) {
    {
#line 220
    while (1) {
      while_continue: /* CIL Label */ ;
#line 220
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 221
    return (-1);
  }
  {
#line 224
  tmp___0 = getsockname(insock, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& laddr)),
                        (socklen_t */* __restrict  */)(& socklen));
  }
#line 224
  if (tmp___0 != 0) {
    {
#line 225
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 225
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 226
    return (-1);
  }
#line 230
  laddr6 = laddr;
#line 231
  faddr6 = faddr;
#line 234
  if ((int )laddr.ss_family == 10) {
#line 234
    __a = (struct in6_addr  const  *)(& ((struct sockaddr_in6 *)(& laddr))->sin6_addr);
#line 234
    if (__a->__in6_u.__u6_addr32[0] == 0U) {
#line 234
      if (__a->__in6_u.__u6_addr32[1] == 0U) {
        {
#line 234
        tmp___1 = htonl((uint32_t )65535);
        }
#line 234
        if (__a->__in6_u.__u6_addr32[2] == tmp___1) {
#line 234
          tmp___2 = 1;
        } else {
#line 234
          tmp___2 = 0;
        }
      } else {
#line 234
        tmp___2 = 0;
      }
    } else {
#line 234
      tmp___2 = 0;
    }
#line 234
    if (tmp___2) {
      {
#line 238
      sin_extractv4((void *)(& ((struct sockaddr_in6 *)(& laddr))->sin6_addr), & in4);
#line 239
      sin_setv4(in4.s_addr, & laddr);
#line 241
      sin_extractv4((void *)(& ((struct sockaddr_in6 *)(& faddr))->sin6_addr), & in4);
#line 242
      sin_setv4(in4.s_addr, & faddr);
      }
    }
  }
  {
#line 246
  tmp___3 = sin_port((struct sockaddr_storage  const  *)(& faddr));
#line 246
  fport = htons(tmp___3);
#line 247
  get_ip(& faddr, ip_buf, sizeof(ip_buf));
#line 249
  tmp___4 = get_hostname(& faddr, host_buf, sizeof(host_buf));
  }
#line 249
  if (tmp___4 != 0) {
    {
#line 250
    o_log(6, "Connection from %s:%d", ip_buf, (int )fport);
#line 251
    xstrncpy(host_buf, (char const   *)(ip_buf), sizeof(host_buf));
    }
  } else {
    {
#line 253
    o_log(6, "Connection from %s (%s):%d", host_buf, ip_buf, (int )fport);
    }
  }
  {
#line 255
  tmp___5 = sock_read(insock, line, sizeof(line));
#line 255
  len = (int )tmp___5;
  }
#line 256
  if (len <= 0) {
#line 257
    return (-1);
  }
  {
#line 259
  len = sscanf((char const   */* __restrict  */)(line), (char const   */* __restrict  */)"%d , %d",
               & lport_temp, & fport_temp);
  }
#line 260
  if (len < 2) {
    {
#line 261
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 261
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 262
    return (0);
  }
#line 265
  if (lport_temp >= 1) {
#line 265
    if ((lport_temp & 65535) == lport_temp) {
#line 265
      if (fport_temp >= 1) {
#line 265
        if (! ((fport_temp & 65535) == fport_temp)) {
#line 265
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 266
        tmp___8 = opt_enabled((u_int32_t )(1 << 3));
        }
#line 266
        if (tmp___8) {
#line 266
          tmp___7 = "UNKNOWN-ERROR";
        } else {
#line 266
          tmp___7 = "INVALID-PORT";
        }
        {
#line 266
        sockprintf(outsock, "%d,%d:ERROR:%s\r\n", lport_temp, fport_temp, tmp___7);
        }
        {
#line 269
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 269
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 272
        return (0);
      }
    } else {
#line 265
      goto _L___0;
    }
  } else {
#line 265
    goto _L___0;
  }
#line 275
  lport = (in_port_t )lport_temp;
#line 276
  fport = (in_port_t )fport_temp;
#line 279
  con_uid = -1;
#line 289
  if (con_uid == -1) {
#line 289
    if ((int )laddr.ss_family == 2) {
      {
#line 290
      tmp___9 = htons(fport);
#line 290
      tmp___10 = htons(lport);
#line 290
      con_uid = get_user4(tmp___10, tmp___9, & laddr, & faddr);
      }
    }
  }
#line 293
  if (con_uid == -1) {
#line 293
    if ((int )laddr6.ss_family == 10) {
      {
#line 294
      tmp___11 = htons(fport);
#line 294
      tmp___12 = htons(lport);
#line 294
      con_uid = get_user6(tmp___12, tmp___11, & laddr6, & faddr6);
      }
    }
  }
  {
#line 297
  tmp___16 = opt_enabled((u_int32_t )(1 << 4));
  }
#line 297
  if (tmp___16) {
#line 298
    if (con_uid == -1) {
#line 298
      if ((int )laddr.ss_family == 2) {
        {
#line 299
        tmp___13 = htons(fport);
#line 299
        tmp___14 = htons(lport);
#line 299
        tmp___15 = masq(insock, tmp___14, tmp___13, & laddr, & faddr);
        }
#line 299
        if (tmp___15 == 0) {
#line 300
          return (0);
        }
      }
    }
  }
#line 303
  if (con_uid == -1) {
#line 304
    if ((unsigned long )failuser != (unsigned long )((void *)0)) {
      {
#line 305
      sockprintf(outsock, "%d,%d:USERID:%s:%s\r\n", (int )lport, (int )fport, ret_os,
                 failuser);
#line 308
      o_log(6, "[%s] Failed lookup: %d , %d : (returned %s)", host_buf, (int )lport,
            (int )fport, failuser);
      }
    } else {
      {
#line 311
      tmp___19 = opt_enabled((u_int32_t )(1 << 3));
      }
#line 311
      if (tmp___19) {
#line 311
        tmp___18 = "UNKNOWN-ERROR";
      } else {
#line 311
        tmp___18 = "NO-USER";
      }
      {
#line 311
      sockprintf(outsock, "%d,%d:ERROR:%s\r\n", (int )lport, (int )fport, tmp___18);
#line 314
      o_log(6, "[%s] %d , %d : ERROR : NO-USER", host_buf, (int )lport, (int )fport);
      }
    }
#line 318
    return (0);
  }
  {
#line 321
  pw = getpwuid((__uid_t )con_uid);
  }
#line 322
  if ((unsigned long )pw == (unsigned long )((void *)0)) {
    {
#line 323
    tmp___22 = opt_enabled((u_int32_t )(1 << 3));
    }
#line 323
    if (tmp___22) {
#line 323
      tmp___21 = "UNKNOWN-ERROR";
    } else {
#line 323
      tmp___21 = "NO-USER";
    }
    {
#line 323
    sockprintf(outsock, "%d,%d:ERROR:%s\r\n", (int )lport, (int )fport, tmp___21);
    }
    {
#line 326
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 326
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 327
    return (0);
  } else {
    {
#line 329
    copy_pw((struct passwd  const  *)pw, & pwd);
    }
  }
  {
#line 331
  ret = get_ident((struct passwd  const  *)(& pwd), lport, fport, & laddr, & faddr,
                  suser, sizeof(suser));
  }
#line 332
  if (ret == -1) {
    {
#line 333
    tmp___25 = opt_enabled((u_int32_t )(1 << 3));
    }
#line 333
    if (tmp___25) {
#line 333
      tmp___24 = "UNKNOWN-ERROR";
    } else {
#line 333
      tmp___24 = "HIDDEN-USER";
    }
    {
#line 333
    sockprintf(outsock, "%d,%d:ERROR:%s\r\n", (int )lport, (int )fport, tmp___24);
#line 336
    o_log(6, "[%s] %d , %d : HIDDEN-USER (%s)", host_buf, (int )lport, (int )fport,
          pwd.pw_name);
    }
#line 339
    goto out;
  }
  {
#line 342
  sockprintf(outsock, "%d,%d:USERID:%s:%s\r\n", (int )lport, (int )fport, ret_os,
             suser);
#line 345
  o_log(6, "[%s] Successful lookup: %d , %d : %s (%s)", host_buf, (int )lport, (int )fport,
        pwd.pw_name, suser);
  }
  out: 
  {
#line 349
  free_pw(& pwd);
  }
#line 350
  return (0);
}
}
#line 357 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd.c"
static void copy_pw(struct passwd  const  *pw , struct passwd *pwd ) 
{ 


  {
  {
#line 358
  pwd->pw_name = xstrdup((char const   *)pw->pw_name);
#line 359
  pwd->pw_uid = (__uid_t )pw->pw_uid;
#line 360
  pwd->pw_gid = (__gid_t )pw->pw_gid;
#line 361
  pwd->pw_dir = xstrdup((char const   *)pw->pw_dir);
  }
#line 362
  return;
}
}
#line 368 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd.c"
static void free_pw(struct passwd *pw ) 
{ 


  {
  {
#line 369
  free((void *)pw->pw_name);
#line 370
  free((void *)pw->pw_dir);
  }
#line 371
  return;
}
}
#line 377
static  __attribute__((__noreturn__)) void sig_segv(int unused  __attribute__((__unused__)) ) ;
#line 377 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd.c"
static void sig_segv(int unused  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 378
  o_log(6, "Caught SIGSEGV");
#line 379
  exit(-1);
  }
}
}
#line 386 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd.c"
static void sig_child(int sig ) 
{ 
  __pid_t tmp ;

  {
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 387
    tmp = waitpid(-1, & sig, 1);
    }
#line 387
    if (! (tmp > 0)) {
#line 387
      goto while_break;
    }
#line 388
    current_connections --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 390
  signal(17, & sig_child);
  }
#line 391
  return;
}
}
#line 397
static  __attribute__((__noreturn__)) void sig_alarm(int unused  __attribute__((__unused__)) ) ;
#line 397 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd.c"
static void sig_alarm(int unused  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 398
  o_log(6, "Timeout for request -- Closing connection");
#line 399
  exit(0);
  }
}
}
#line 406 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd.c"
static void sig_hup(int unused  __attribute__((__unused__)) ) 
{ 
  int tmp ;

  {
  {
#line 407
  user_db_destroy();
#line 409
  tmp = read_config("/etc/oidentd.conf");
  }
#line 409
  if (tmp != 0) {
    {
#line 410
    o_log(6, "Error parsing configuration file");
#line 411
    exit(-1);
    }
  }
#line 413
  return;
}
}
#line 419 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd.c"
static void seed_prng(void) 
{ 
  struct timeval tv ;

  {
  {
#line 422
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 423
  srandom((unsigned int )(tv.tv_sec ^ (tv.tv_usec << 11)));
  }
#line 424
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 603
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 700
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 717
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
#line 779
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 399
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vasprintf)(char ** __restrict  __ptr ,
                                                                              char const   * __restrict  __f ,
                                                                              __gnuc_va_list __arg ) ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 374
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(unsigned long __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 190 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 116 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 111 "/usr/include/grp.h"
extern struct group *getgrnam(char const   *__name ) ;
#line 201
extern int initgroups(char const   *__user , __gid_t __group ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 214
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 312
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 45 "./oidentd_util.h"
FILE *safe_open(struct passwd  const  *pw , char const   *filename ) ;
#line 47
void *xmalloc(size_t size ) ;
#line 48
void *xcalloc(size_t nmemb , size_t size ) ;
#line 49
void *xrealloc(void *ptr , size_t len ) ;
#line 54
list_t *list_prepend(list_t **list , void *new_data ) ;
#line 55
void list_destroy(list_t *list , void (*free_data)(void * ) ) ;
#line 57
int find_user(char const   *temp_user , uid_t *uid___0 ) ;
#line 58
int find_group(char const   *temp_group , gid_t *gid___0 ) ;
#line 61
__inline int randval(int i ) ;
#line 60 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_util.c"
int random_seed(void) 
{ 
  struct timeval tv ;
  int tmp ;

  {
  {
#line 63
  tmp = gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
  }
#line 63
  if (tmp) {
#line 64
    return (-1);
  }
  {
#line 66
  srand((u_int32_t )(tv.tv_sec ^ tv.tv_usec));
  }
#line 67
  return (0);
}
}
#line 78 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_util.c"
__inline int randval(int i ) 
{ 
  int tmp ;

  {
  {
#line 80
  tmp = rand();
  }
#line 80
  return ((int )(((double )i * (double )tmp) / ((double )2147483647 + 1.0)));
}
}
#line 88 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_util.c"
int find_user(char const   *temp_user , uid_t *uid___0 ) 
{ 
  struct passwd *pw ;
  char *end ;
  u_int32_t temp_uid ;
  unsigned long tmp ;

  {
  {
#line 91
  pw = getpwnam(temp_user);
  }
#line 92
  if ((unsigned long )pw == (unsigned long )((void *)0)) {
    {
#line 94
    tmp = strtoul((char const   */* __restrict  */)temp_user, (char **/* __restrict  */)(& end),
                  10);
#line 94
    temp_uid = (u_int32_t )tmp;
    }
#line 96
    if ((int )*end != 0) {
#line 97
      return (-1);
    } else {
#line 99
      *uid___0 = temp_uid;
    }
  } else {
#line 101
    *uid___0 = pw->pw_uid;
  }
#line 103
  return (0);
}
}
#line 111 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_util.c"
int find_group(char const   *temp_group , gid_t *gid___0 ) 
{ 
  struct group *gr ;
  char *end ;
  u_int32_t temp_gid ;
  unsigned long tmp ;

  {
  {
#line 114
  gr = getgrnam(temp_group);
  }
#line 115
  if ((unsigned long )gr == (unsigned long )((void *)0)) {
    {
#line 117
    tmp = strtoul((char const   */* __restrict  */)temp_group, (char **/* __restrict  */)(& end),
                  10);
#line 117
    temp_gid = (u_int32_t )tmp;
    }
#line 119
    if ((int )*end != 0) {
#line 120
      return (-1);
    } else {
#line 122
      *gid___0 = temp_gid;
    }
  } else {
#line 124
    *gid___0 = gr->gr_gid;
  }
#line 126
  return (0);
}
}
#line 134 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_util.c"
int drop_privs(uid_t new_uid , gid_t new_gid ) 
{ 
  int tmp ;
  bool tmp___0 ;
  struct passwd *pw ;
  gid_t my_gid ;
  int ret ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;

  {
  {
#line 136
  tmp___0 = opt_enabled((u_int32_t )(1 << 2));
  }
#line 136
  if (tmp___0) {
    {
#line 137
    tmp = setgid(new_gid);
    }
#line 137
    if (tmp != 0) {
      {
#line 138
      while (1) {
        while_continue: /* CIL Label */ ;
#line 138
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 139
      return (-1);
    }
  }
  {
#line 143
  tmp___3 = opt_enabled((u_int32_t )(1 << 1));
  }
#line 143
  if (tmp___3) {
    {
#line 148
    pw = getpwuid(new_uid);
    }
#line 149
    if ((unsigned long )pw == (unsigned long )((void *)0)) {
      {
#line 150
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 150
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 151
      return (-1);
    }
    {
#line 154
    tmp___1 = opt_enabled((u_int32_t )(1 << 2));
    }
#line 154
    if (tmp___1) {
#line 155
      my_gid = new_gid;
    } else {
#line 157
      my_gid = pw->pw_gid;
    }
    {
#line 159
    ret = initgroups((char const   *)pw->pw_name, my_gid);
    }
#line 161
    if (ret != 0) {
      {
#line 162
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 162
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 164
      return (-1);
    }
    {
#line 167
    tmp___2 = setuid(new_uid);
    }
#line 167
    if (tmp___2 != 0) {
      {
#line 168
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 168
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 169
      return (-1);
    }
  }
#line 173
  return (0);
}
}
#line 186 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_util.c"
FILE *safe_open(struct passwd  const  *pw , char const   *filename ) 
{ 
  size_t len ;
  char *path ;
  struct stat st ;
  FILE *fp ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 192
  tmp = strlen((char const   *)pw->pw_dir);
#line 192
  tmp___0 = strlen(filename);
#line 192
  len = (tmp + tmp___0) + 2UL;
#line 194
  tmp___1 = xmalloc(len);
#line 194
  path = (char *)tmp___1;
#line 195
  snprintf((char */* __restrict  */)path, len, (char const   */* __restrict  */)"%s/%s",
           pw->pw_dir, filename);
#line 197
  tmp___2 = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& st));
  }
#line 197
  if (tmp___2 != 0) {
#line 198
    goto out_fail;
  }
#line 200
  if (st.st_uid != (__uid_t )pw->pw_uid) {
    {
#line 201
    o_log(2, "Refused to read %s during request for %s (owner is UID %d)", path, pw->pw_name,
          st.st_uid);
    }
#line 205
    goto out_fail;
  }
  {
#line 208
  fp = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"r");
  }
#line 209
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 210
    tmp___3 = __errno_location();
    }
#line 210
    if (*tmp___3 != 2) {
      {
#line 211
      while (1) {
        while_continue: /* CIL Label */ ;
#line 211
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 213
    goto out_fail;
  }
  {
#line 216
  tmp___4 = fileno(fp);
#line 216
  tmp___5 = fstat(tmp___4, & st);
  }
#line 216
  if (tmp___5 != 0) {
    {
#line 217
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 217
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 219
    fclose(fp);
    }
#line 220
    goto out_fail;
  }
#line 223
  if (st.st_uid != (__uid_t )pw->pw_uid) {
    {
#line 224
    o_log(2, "Refused to read \"%s\" during request for %s (owner is UID %u)", path,
          pw->pw_name, st.st_uid);
#line 228
    fclose(fp);
    }
#line 229
    goto out_fail;
  }
  {
#line 232
  free((void *)path);
  }
#line 233
  return (fp);
  out_fail: 
  {
#line 236
  free((void *)path);
  }
#line 237
  return ((FILE *)((void *)0));
}
}
#line 244 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_util.c"
int go_background(void) 
{ 
  int fd ;
  __pid_t tmp ;
  __pid_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 247
  tmp = fork();
  }
  {
#line 248
  if (tmp == -1) {
#line 248
    goto case_neg_1;
  }
#line 250
  if (tmp == 0) {
#line 250
    goto case_0;
  }
#line 252
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 249
  return (-1);
  case_0: /* CIL Label */ 
#line 251
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 253
  _exit(0);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 256
  tmp___0 = setsid();
  }
#line 256
  if (tmp___0 == -1) {
    {
#line 257
    while (1) {
      while_continue: /* CIL Label */ ;
#line 257
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 258
    return (-1);
  }
  {
#line 261
  tmp___1 = chdir("/");
  }
#line 261
  if (tmp___1 != 0) {
    {
#line 262
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 262
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 263
    return (-1);
  }
  {
#line 266
  umask((__mode_t )18);
#line 268
  fd = open("/dev/null", 2);
  }
#line 269
  if (fd == -1) {
    {
#line 270
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 270
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 271
    return (-1);
  }
  {
#line 274
  dup2(fd, 0);
#line 275
  dup2(fd, 1);
#line 276
  dup2(fd, 2);
  }
#line 278
  return (0);
}
}
#line 285 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_util.c"
void *xmalloc(size_t size ) 
{ 
  void *ret ;
  void *tmp ;

  {
  {
#line 286
  tmp = malloc(size);
#line 286
  ret = tmp;
  }
#line 288
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    {
#line 289
    while (1) {
      while_continue: /* CIL Label */ ;
#line 289
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 290
    exit(-1);
    }
  }
#line 293
  return (ret);
}
}
#line 300 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_util.c"
void *xcalloc(size_t nmemb , size_t size ) 
{ 
  void *ret ;
  void *tmp ;

  {
  {
#line 301
  tmp = calloc(nmemb, size);
#line 301
  ret = tmp;
  }
#line 303
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    {
#line 304
    while (1) {
      while_continue: /* CIL Label */ ;
#line 304
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 305
    exit(-1);
    }
  }
#line 308
  return (ret);
}
}
#line 315 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_util.c"
void *xrealloc(void *ptr , size_t len ) 
{ 
  void *ret ;
  void *tmp ;

  {
  {
#line 316
  tmp = realloc(ptr, len);
#line 316
  ret = tmp;
  }
#line 318
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    {
#line 319
    while (1) {
      while_continue: /* CIL Label */ ;
#line 319
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 320
    exit(-1);
    }
  }
#line 323
  return (ret);
}
}
#line 331 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_util.c"
char *xstrncpy(char *dest , char const   *src , size_t n ) 
{ 
  char *ret ;
  char *tmp ;
  char tmp___0 ;
  char const   *tmp___1 ;

  {
#line 332
  ret = dest;
#line 334
  if (n == 0UL) {
#line 335
    return (dest);
  }
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    n --;
#line 337
    if (n > 0UL) {
#line 337
      tmp = dest;
#line 337
      dest ++;
#line 337
      tmp___1 = src;
#line 337
      src ++;
#line 337
      tmp___0 = (char )*tmp___1;
#line 337
      *tmp = tmp___0;
#line 337
      if (! ((int )tmp___0 != 0)) {
#line 337
        goto while_break;
      }
    } else {
#line 337
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 339
  *dest = (char )'\000';
#line 341
  return (ret);
}
}
#line 349 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_util.c"
char *xstrdup(char const   *string ) 
{ 
  char *ret ;

  {
#line 352
  if ((unsigned long )string == (unsigned long )((void *)0)) {
#line 353
    return ((char *)((void *)0));
  }
  {
#line 355
  ret = strdup(string);
  }
#line 357
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    {
#line 358
    while (1) {
      while_continue: /* CIL Label */ ;
#line 358
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 359
    exit(-1);
    }
  }
#line 362
  return (ret);
}
}
#line 370 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_util.c"
list_t *list_prepend(list_t **list , void *new_data ) 
{ 
  list_t *new_entry ;
  void *tmp ;

  {
  {
#line 371
  tmp = xmalloc(sizeof(list_t ));
#line 371
  new_entry = (list_t *)tmp;
#line 373
  new_entry->next = *list;
#line 374
  new_entry->data = new_data;
#line 375
  *list = new_entry;
  }
#line 377
  return (*list);
}
}
#line 384 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_util.c"
void list_destroy(list_t *list , void (*free_data)(void * ) ) 
{ 
  list_t *cur ;
  list_t *next ;

  {
#line 385
  cur = list;
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;
#line 387
    if (! ((unsigned long )cur != (unsigned long )((void *)0))) {
#line 387
      goto while_break;
    }
#line 388
    next = cur->next;
#line 390
    if ((unsigned long )free_data != (unsigned long )((void *)0)) {
      {
#line 391
      (*free_data)(cur->data);
      }
    }
    {
#line 393
    free((void *)cur);
#line 395
    cur = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 397
  return;
}
}
#line 403 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_util.c"
int ( /* format attribute */  o_log)(int priority , char const   *fmt  , ...) 
{ 
  va_list ap ;
  ssize_t ret ;
  char *buf ;
  bool tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 408
  tmp = opt_enabled((u_int32_t )(1 << 9));
  }
#line 408
  if (tmp) {
#line 408
    if (priority != 2) {
#line 409
      return (0);
    }
  }
#line 411
  if (priority == 7) {
    {
#line 411
    tmp___0 = opt_enabled((u_int32_t )(1 << 8));
    }
#line 411
    if (! tmp___0) {
#line 412
      return (0);
    }
  }
  {
#line 414
  __builtin_va_start(ap, fmt);
#line 415
  tmp___1 = vasprintf((char **/* __restrict  */)(& buf), (char const   */* __restrict  */)fmt,
                      ap);
#line 415
  ret = (ssize_t )tmp___1;
#line 416
  __builtin_va_end(ap);
#line 418
  tmp___2 = opt_enabled((u_int32_t )(1 << 11));
  }
#line 418
  if (tmp___2) {
    {
#line 419
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            buf);
    }
  } else {
    {
#line 418
    tmp___3 = fileno(stderr);
#line 418
    tmp___4 = isatty(tmp___3);
    }
#line 418
    if (tmp___4) {
      {
#line 419
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              buf);
      }
    } else {
      {
#line 421
      syslog(priority, "%s", buf);
      }
    }
  }
  {
#line 423
  free((void *)buf);
  }
#line 424
  return ((int )ret);
}
}
#line 58 "./oidentd_inet_util.h"
bool sin_equal(struct sockaddr_storage *ss1 , struct sockaddr_storage *ss2 ) ;
#line 60 "./oidentd_user_db.h"
struct user_info *user_db_lookup(uid_t uid___0 ) ;
#line 61
__inline void user_db_add(struct user_info *user_info ) ;
#line 63
void user_db_cap_destroy_data(void *data ) ;
#line 64
void user_db_set_default(struct user_info *user_info ) ;
#line 65
struct user_info *user_db_create_default(void) ;
#line 75
list_t *user_db_get_pref_list(struct passwd  const  *pw ) ;
#line 45 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_user_db.c"
int parser_mode  ;
#line 46 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_user_db.c"
struct user_cap *pref_cap  ;
#line 48 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_user_db.c"
static list_t *user_hash[32]  ;
#line 49 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_user_db.c"
struct user_info *default_user  ;
#line 51
__inline static u_char *select_reply(struct user_cap  const  *user ) ;
#line 52
__inline static void db_destroy_user_cb(void *data ) ;
#line 54
static bool port_match(in_port_t port , struct port_range  const  *cap_ports ) ;
#line 55
static bool addr_match(struct sockaddr_storage *addr___0 , struct sockaddr_storage *cap_addr ) ;
#line 58
__inline static bool user_db_have_cap(struct user_cap  const  *user_cap , u_int16_t cap_flag ) ;
#line 61
static bool user_db_can_reply(struct user_cap  const  *user_cap , char const   *reply ,
                              uid_t con_uid , in_port_t fport ) ;
#line 66
static struct user_cap *user_db_cap_lookup(struct user_info *user_info , in_port_t lport ,
                                           in_port_t fport , struct sockaddr_storage *laddr ,
                                           struct sockaddr_storage *faddr ) ;
#line 72
static struct user_cap *user_db_get_pref(struct passwd  const  *pw , in_port_t lport ,
                                         in_port_t fport , struct sockaddr_storage *laddr ,
                                         struct sockaddr_storage *faddr ) ;
#line 85
static void random_ident(char *buf , size_t len ) ;
#line 85 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_user_db.c"
static char const   valid[63]  = 
#line 85
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F', 
        (char const   )'G',      (char const   )'H',      (char const   )'I',      (char const   )'J', 
        (char const   )'K',      (char const   )'L',      (char const   )'M',      (char const   )'N', 
        (char const   )'O',      (char const   )'P',      (char const   )'Q',      (char const   )'R', 
        (char const   )'S',      (char const   )'T',      (char const   )'U',      (char const   )'V', 
        (char const   )'W',      (char const   )'X',      (char const   )'Y',      (char const   )'Z', 
        (char const   )'a',      (char const   )'b',      (char const   )'c',      (char const   )'d', 
        (char const   )'e',      (char const   )'f',      (char const   )'g',      (char const   )'h', 
        (char const   )'i',      (char const   )'j',      (char const   )'k',      (char const   )'l', 
        (char const   )'m',      (char const   )'n',      (char const   )'o',      (char const   )'p', 
        (char const   )'q',      (char const   )'r',      (char const   )'s',      (char const   )'t', 
        (char const   )'u',      (char const   )'v',      (char const   )'w',      (char const   )'x', 
        (char const   )'y',      (char const   )'z',      (char const   )'\000'};
#line 83 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_user_db.c"
static void random_ident(char *buf , size_t len ) 
{ 
  size_t i ;
  int tmp ;

  {
#line 88
  i = (size_t )0;
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! (i < len - 1UL)) {
#line 88
      goto while_break;
    }
    {
#line 89
    tmp = randval((int )(sizeof(valid) - 1UL));
#line 89
    *(buf + i) = (char )valid[tmp];
#line 88
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  *(buf + i) = (char )'\000';
#line 92
  return;
}
}
#line 98 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_user_db.c"
__inline static u_char *select_reply(struct user_cap  const  *user ) 
{ 
  int tmp ;

  {
  {
#line 99
  tmp = randval((int )user->num_replies);
  }
#line 99
  return ((u_char *)*(user->force_data + tmp));
}
}
#line 106 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_user_db.c"
__inline static void numeric_ident(uid_t con_uid , char *buf , size_t len ) 
{ 


  {
  {
#line 107
  snprintf((char */* __restrict  */)buf, len, (char const   */* __restrict  */)"%u",
           con_uid);
  }
#line 108
  return;
}
}
#line 115 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_user_db.c"
__inline static void random_ident_numeric(char *buf , size_t len ) 
{ 
  int tmp ;

  {
  {
#line 116
  tmp = randval(100000);
#line 116
  snprintf((char */* __restrict  */)buf, len, (char const   */* __restrict  */)"%s%u",
           "user", tmp);
  }
#line 117
  return;
}
}
#line 123 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_user_db.c"
__inline static bool user_db_have_cap(struct user_cap  const  *user_cap , u_int16_t cap_flag ) 
{ 


  {
#line 126
  return ((bool )(((int const   )user_cap->caps & (int const   )cap_flag) != 0));
}
}
#line 134 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_user_db.c"
int get_ident(struct passwd  const  *pwd , in_port_t lport , in_port_t fport , struct sockaddr_storage *laddr ,
              struct sockaddr_storage *faddr , char *reply , size_t len ) 
{ 
  struct user_cap *user_cap ;
  struct user_cap *user_pref ;
  uid_t cur_uid ;
  struct user_info *tmp ;
  u_char *tmp___0 ;
  size_t tmp___1 ;
  u_int16_t caps ;
  bool tmp___2 ;
  char *temp_reply ;
  u_char *tmp___3 ;
  bool ret ;
  size_t tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;

  {
  {
#line 144
  cur_uid = (uid_t )pwd->pw_uid;
#line 146
  tmp = user_db_lookup(cur_uid);
#line 146
  user_cap = user_db_cap_lookup(tmp, lport, fport, laddr, faddr);
  }
#line 149
  if ((unsigned long )user_cap == (unsigned long )((void *)0)) {
    {
#line 150
    user_cap = user_db_cap_lookup(default_user, lport, fport, laddr, faddr);
    }
  }
#line 152
  if ((int )user_cap->action == 3) {
    {
#line 154
    if ((int )user_cap->caps == 1 << 8) {
#line 154
      goto case_exp;
    }
#line 158
    if ((int )user_cap->caps == 1 << 4) {
#line 158
      goto case_exp___0;
    }
#line 162
    if ((int )user_cap->caps == 1 << 5) {
#line 162
      goto case_exp___1;
    }
#line 166
    if ((int )user_cap->caps == 1 << 7) {
#line 166
      goto case_exp___2;
    }
#line 170
    if ((int )user_cap->caps == 1 << 6) {
#line 170
      goto case_exp___3;
    }
#line 153
    goto switch_break;
    case_exp: /* CIL Label */ 
    {
#line 155
    tmp___0 = select_reply((struct user_cap  const  *)user_cap);
#line 155
    xstrncpy(reply, (char const   *)tmp___0, len);
    }
#line 156
    goto switch_break;
    case_exp___0: /* CIL Label */ 
#line 159
    return (-1);
#line 160
    goto switch_break;
    case_exp___1: /* CIL Label */ 
#line 163
    if (12UL < len) {
#line 163
      tmp___1 = (size_t )12;
    } else {
#line 163
      tmp___1 = len;
    }
    {
#line 163
    random_ident(reply, tmp___1);
    }
#line 164
    goto switch_break;
    case_exp___2: /* CIL Label */ 
    {
#line 167
    numeric_ident((uid_t )pwd->pw_uid, reply, len);
    }
#line 168
    goto switch_break;
    case_exp___3: /* CIL Label */ 
    {
#line 171
    random_ident_numeric(reply, len);
    }
#line 172
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 175
    return (0);
  }
  {
#line 178
  user_pref = user_db_get_pref(pwd, lport, fport, laddr, faddr);
  }
#line 179
  if ((unsigned long )user_pref != (unsigned long )((void *)0)) {
#line 180
    caps = user_pref->caps;
    {
#line 183
    if ((int )caps == 1 << 4) {
#line 183
      goto case_exp___4;
    }
#line 191
    if ((int )caps == 1 << 8) {
#line 191
      goto case_exp___5;
    }
#line 205
    if ((int )caps == 1 << 5) {
#line 205
      goto case_exp___6;
    }
#line 213
    if ((int )caps == 1 << 7) {
#line 213
      goto case_exp___7;
    }
#line 221
    if ((int )caps == 1 << 6) {
#line 221
      goto case_exp___8;
    }
#line 182
    goto switch_break___0;
    case_exp___4: /* CIL Label */ 
    {
#line 184
    tmp___2 = user_db_have_cap((struct user_cap  const  *)user_cap, (u_int16_t )(1 << 4));
    }
#line 184
    if ((unsigned int )tmp___2 == 1U) {
      {
#line 185
      user_db_cap_destroy_data((void *)user_pref);
      }
#line 186
      return (-1);
    }
#line 189
    goto switch_break___0;
    case_exp___5: /* CIL Label */ 
    {
#line 193
    tmp___3 = select_reply((struct user_cap  const  *)user_pref);
#line 193
    temp_reply = (char *)tmp___3;
#line 196
    ret = user_db_can_reply((struct user_cap  const  *)user_cap, (char const   *)temp_reply,
                            cur_uid, fport);
    }
#line 197
    if ((unsigned int )ret == 1U) {
      {
#line 198
      xstrncpy(reply, (char const   *)temp_reply, len);
      }
#line 199
      goto out_success;
    }
#line 202
    goto switch_break___0;
    case_exp___6: /* CIL Label */ 
    {
#line 206
    tmp___5 = user_db_have_cap((struct user_cap  const  *)user_cap, (u_int16_t )(1 << 5));
    }
#line 206
    if ((unsigned int )tmp___5 == 1U) {
#line 207
      if (12UL < len) {
#line 207
        tmp___4 = (size_t )12;
      } else {
#line 207
        tmp___4 = len;
      }
      {
#line 207
      random_ident(reply, tmp___4);
      }
#line 208
      goto out_success;
    }
#line 211
    goto switch_break___0;
    case_exp___7: /* CIL Label */ 
    {
#line 214
    tmp___6 = user_db_have_cap((struct user_cap  const  *)user_cap, (u_int16_t )(1 << 7));
    }
#line 214
    if ((unsigned int )tmp___6 == 1U) {
      {
#line 215
      numeric_ident((uid_t )pwd->pw_uid, reply, len);
      }
#line 216
      goto out_success;
    }
#line 219
    goto switch_break___0;
    case_exp___8: /* CIL Label */ 
    {
#line 222
    tmp___7 = user_db_have_cap((struct user_cap  const  *)user_cap, (u_int16_t )(1 << 6));
    }
#line 222
    if ((unsigned int )tmp___7 == 1U) {
      {
#line 223
      random_ident_numeric(reply, len);
      }
#line 224
      goto out_success;
    }
#line 227
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 230
    user_db_cap_destroy_data((void *)user_pref);
    }
  }
  {
#line 233
  xstrncpy(reply, (char const   *)pwd->pw_name, len);
  }
#line 234
  return (0);
  out_success: 
  {
#line 237
  user_db_cap_destroy_data((void *)user_pref);
  }
#line 238
  return (0);
}
}
#line 246 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_user_db.c"
void user_db_cap_destroy_data(void *data ) 
{ 
  struct user_cap *user_cap ;
  size_t i ;

  {
#line 247
  user_cap = (struct user_cap *)data;
#line 250
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 251
    return;
  }
  {
#line 253
  free((void *)user_cap->lport);
#line 254
  free((void *)user_cap->fport);
#line 255
  free((void *)user_cap->src);
#line 256
  free((void *)user_cap->dest);
#line 258
  i = (size_t )0;
  }
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    if (! (i < (size_t )user_cap->num_replies)) {
#line 258
      goto while_break;
    }
    {
#line 259
    free((void *)*(user_cap->force_data + i));
#line 258
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 261
  free((void *)user_cap->force_data);
  }
#line 262
  return;
}
}
#line 269 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_user_db.c"
__inline static void db_destroy_user_cb(void *data ) 
{ 
  struct user_info *user_info ;

  {
  {
#line 270
  user_info = (struct user_info *)data;
#line 272
  list_destroy(user_info->cap_list, & user_db_cap_destroy_data);
  }
#line 273
  return;
}
}
#line 279 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_user_db.c"
__inline void user_db_add(struct user_info *user_info ) 
{ 


  {
  {
#line 280
  list_prepend(& user_hash[user_info->user % 32U], (void *)user_info);
  }
#line 281
  return;
}
}
#line 287 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_user_db.c"
void user_db_destroy(void) 
{ 
  size_t i ;

  {
#line 290
  i = (size_t )0;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 290
    if (! (i < 32UL)) {
#line 290
      goto while_break;
    }
#line 291
    if ((unsigned long )user_hash[i] != (unsigned long )((void *)0)) {
      {
#line 292
      list_destroy(user_hash[i], & db_destroy_user_cb);
#line 293
      user_hash[i] = (list_t *)((void *)0);
      }
    }
#line 290
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 297
  db_destroy_user_cb((void *)default_user);
#line 298
  default_user = (struct user_info *)((void *)0);
  }
#line 299
  return;
}
}
#line 307 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_user_db.c"
static bool user_db_can_reply(struct user_cap  const  *user_cap , char const   *reply ,
                              uid_t con_uid , in_port_t fport ) 
{ 
  struct passwd *pw ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
  {
#line 314
  pw = getpwnam(reply);
  }
#line 315
  if ((unsigned long )pw != (unsigned long )((void *)0)) {
#line 320
    if (pw->pw_uid == con_uid) {
#line 321
      return ((bool )1);
    }
    {
#line 323
    tmp = user_db_have_cap(user_cap, (u_int16_t )(1 << 2));
    }
#line 323
    if ((unsigned int )tmp == 0U) {
      {
#line 324
      o_log(6, "User %s tried to masquerade as user %s", reply, pw->pw_name);
      }
#line 327
      return ((bool )0);
    }
  }
  {
#line 331
  tmp___0 = user_db_have_cap(user_cap, (u_int16_t )(1 << 1));
  }
#line 331
  if ((unsigned int )tmp___0 == 0U) {
#line 332
    return ((bool )0);
  }
#line 334
  if ((int )fport < 1024) {
    {
#line 334
    tmp___1 = user_db_have_cap(user_cap, (u_int16_t )(1 << 3));
    }
#line 334
    if ((unsigned int )tmp___1 == 0U) {
#line 337
      return ((bool )0);
    }
  }
#line 340
  return ((bool )1);
}
}
#line 347 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_user_db.c"
struct user_info *user_db_lookup(uid_t uid___0 ) 
{ 
  list_t *cur ;
  struct user_info *user_info ;

  {
#line 350
  cur = user_hash[uid___0 % 32U];
  {
#line 351
  while (1) {
    while_continue: /* CIL Label */ ;
#line 351
    if (! ((unsigned long )cur != (unsigned long )((void *)0))) {
#line 351
      goto while_break;
    }
#line 352
    user_info = (struct user_info *)cur->data;
#line 354
    if (user_info->user == uid___0) {
#line 355
      return (user_info);
    }
#line 357
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 360
  return ((struct user_info *)((void *)0));
}
}
#line 367 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_user_db.c"
static struct user_cap *user_db_cap_lookup(struct user_info *user_info , in_port_t lport ,
                                           in_port_t fport , struct sockaddr_storage *laddr ,
                                           struct sockaddr_storage *faddr ) 
{ 
  list_t *cur ;
  struct user_cap *user_cap ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;

  {
#line 375
  if ((unsigned long )user_info == (unsigned long )((void *)0)) {
#line 376
    return ((struct user_cap *)((void *)0));
  }
#line 378
  cur = user_info->cap_list;
  {
#line 378
  while (1) {
    while_continue: /* CIL Label */ ;
#line 378
    if (! ((unsigned long )cur != (unsigned long )((void *)0))) {
#line 378
      goto while_break;
    }
    {
#line 379
    user_cap = (struct user_cap *)cur->data;
#line 381
    tmp = port_match(lport, (struct port_range  const  *)user_cap->lport);
    }
#line 381
    if ((unsigned int )tmp == 0U) {
#line 382
      goto __Cont;
    }
    {
#line 384
    tmp___0 = port_match(fport, (struct port_range  const  *)user_cap->fport);
    }
#line 384
    if ((unsigned int )tmp___0 == 0U) {
#line 385
      goto __Cont;
    }
    {
#line 387
    tmp___1 = addr_match(laddr, user_cap->src);
    }
#line 387
    if ((unsigned int )tmp___1 == 0U) {
#line 388
      goto __Cont;
    }
    {
#line 390
    tmp___2 = addr_match(faddr, user_cap->dest);
    }
#line 390
    if ((unsigned int )tmp___2 == 0U) {
#line 391
      goto __Cont;
    }
#line 393
    return (user_cap);
    __Cont: /* CIL Label */ 
#line 378
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 396
  return ((struct user_cap *)((void *)0));
}
}
#line 404 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_user_db.c"
struct user_info *user_db_create_default(void) 
{ 
  struct user_info *temp_default ;
  struct user_cap *cur_cap___0 ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 408
  tmp = xmalloc(sizeof(struct user_info ));
#line 408
  temp_default = (struct user_info *)tmp;
#line 409
  temp_default->cap_list = (list_t *)((void *)0);
#line 411
  tmp___0 = xcalloc((size_t )1, sizeof(struct user_cap ));
#line 411
  cur_cap___0 = (struct user_cap *)tmp___0;
#line 412
  list_prepend(& temp_default->cap_list, (void *)cur_cap___0);
  }
#line 414
  return (temp_default);
}
}
#line 421 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_user_db.c"
void user_db_set_default(struct user_info *user_info ) 
{ 


  {
#line 422
  if ((unsigned long )default_user != (unsigned long )((void *)0)) {
    {
#line 423
    list_destroy(default_user->cap_list, & user_db_cap_destroy_data);
#line 424
    free((void *)default_user);
    }
  }
#line 427
  default_user = user_info;
#line 428
  return;
}
}
#line 434 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_user_db.c"
static struct user_cap *user_db_get_pref(struct passwd  const  *pw , in_port_t lport ,
                                         in_port_t fport , struct sockaddr_storage *laddr ,
                                         struct sockaddr_storage *faddr ) 
{ 
  list_t *cap_list ;
  list_t *cur ;
  struct user_cap *cur_cap___0 ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;

  {
  {
#line 443
  cap_list = user_db_get_pref_list(pw);
#line 445
  cur = cap_list;
  }
  {
#line 445
  while (1) {
    while_continue: /* CIL Label */ ;
#line 445
    if (! ((unsigned long )cur != (unsigned long )((void *)0))) {
#line 445
      goto while_break;
    }
    {
#line 446
    cur_cap___0 = (struct user_cap *)cur->data;
#line 448
    tmp = port_match(lport, (struct port_range  const  *)cur_cap___0->lport);
    }
#line 448
    if ((unsigned int )tmp == 0U) {
#line 449
      goto __Cont;
    }
    {
#line 451
    tmp___0 = port_match(fport, (struct port_range  const  *)cur_cap___0->fport);
    }
#line 451
    if ((unsigned int )tmp___0 == 0U) {
#line 452
      goto __Cont;
    }
    {
#line 454
    tmp___1 = addr_match(laddr, cur_cap___0->src);
    }
#line 454
    if ((unsigned int )tmp___1 == 0U) {
#line 455
      goto __Cont;
    }
    {
#line 457
    tmp___2 = addr_match(faddr, cur_cap___0->dest);
    }
#line 457
    if ((unsigned int )tmp___2 == 0U) {
#line 458
      goto __Cont;
    }
    {
#line 463
    cur->data = (void *)0;
#line 465
    list_destroy(cap_list, & user_db_cap_destroy_data);
    }
#line 466
    return (cur_cap___0);
    __Cont: /* CIL Label */ 
#line 445
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 469
  list_destroy(cap_list, & user_db_cap_destroy_data);
  }
#line 470
  return ((struct user_cap *)((void *)0));
}
}
#line 478 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_user_db.c"
static bool addr_match(struct sockaddr_storage *addr___0 , struct sockaddr_storage *cap_addr ) 
{ 
  bool tmp ;

  {
#line 481
  if ((unsigned long )cap_addr == (unsigned long )((void *)0)) {
#line 482
    return ((bool )1);
  }
  {
#line 484
  tmp = sin_equal(addr___0, cap_addr);
  }
#line 484
  return (tmp);
}
}
#line 492 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_user_db.c"
static bool port_match(in_port_t port , struct port_range  const  *cap_ports ) 
{ 


  {
#line 493
  if ((unsigned long )cap_ports == (unsigned long )((void *)0)) {
#line 494
    return ((bool )1);
  }
#line 496
  if ((int )port >= (int )cap_ports->min) {
#line 496
    if ((int )port <= (int )cap_ports->max) {
#line 497
      return ((bool )1);
    }
  }
#line 499
  return ((bool )0);
}
}
#line 59 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int __sigsetjmp(struct __jmp_buf_tag *__env ,
                                                     int __savemask ) ;
#line 102
extern  __attribute__((__nothrow__, __noreturn__)) void siglongjmp(struct __jmp_buf_tag *__env ,
                                                                   int __val ) ;
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 137 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 28 "./oidentd_inet_util.h"
int get_addr(char const   * const  hostname , struct sockaddr_storage *addr___0 ) ;
#line 50
size_t sin_len(struct sockaddr_storage  const  *ss  __attribute__((__unused__)) ) ;
#line 52
void sin_copy(struct sockaddr_storage *ss1 , struct sockaddr_storage  const  *ss2 ) ;
#line 55
void sin_set_port(in_port_t port , struct sockaddr_storage *ss ) ;
#line 47 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_masq.c"
struct sockaddr_storage proxy  ;
#line 51 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_masq.c"
static sigjmp_buf timebuf  ;
#line 52 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_masq.c"
static int fsock  ;
#line 54 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_masq.c"
in_port_t fwdport  ;
#line 58
static  __attribute__((__noreturn__)) void fwd_alarm(int sig ) ;
#line 59
static bool blank_line(char const   *buf ) ;
#line 67 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_masq.c"
static bool blank_line(char const   *buf ) 
{ 
  char const   *p ;

  {
#line 70
  p = buf;
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (! ((int const   )*p != 0)) {
#line 70
      goto while_break;
    }
#line 71
    if ((int const   )*p != 32) {
#line 71
      if ((int const   )*p != 9) {
#line 72
        return ((bool )0);
      }
    }
#line 70
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  return ((bool )1);
}
}
#line 83 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_masq.c"
int find_masq_entry(struct sockaddr_storage *host , char *user , size_t user_len ,
                    char *os , size_t os_len ) 
{ 
  FILE *fp ;
  struct sockaddr_storage addr___0 ;
  u_int32_t line_num ;
  char buf[4096] ;
  int *tmp ;
  struct sockaddr_storage stemp ;
  char *p ;
  char *temp ;
  bool tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  in_addr_t mask ;
  in_addr_t mask2 ;
  char *end ;
  unsigned long tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;

  {
  {
#line 117
  fp = fopen((char const   */* __restrict  */)"/etc/oidentd_masq.conf", (char const   */* __restrict  */)"r");
  }
#line 118
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 119
    tmp = __errno_location();
    }
#line 119
    if (*tmp != 17) {
      {
#line 120
      while (1) {
        while_continue: /* CIL Label */ ;
#line 120
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 121
    return (-1);
  }
#line 124
  line_num = (u_int32_t )0;
  {
#line 126
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 126
    tmp___8 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)fp);
    }
#line 126
    if (! ((unsigned long )tmp___8 != (unsigned long )((void *)0))) {
#line 126
      goto while_break___0;
    }
    {
#line 130
    line_num ++;
#line 131
    p = strchr((char const   *)(buf), '\n');
    }
#line 132
    if ((unsigned long )p == (unsigned long )((void *)0)) {
      {
#line 133
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 133
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 134
      goto failure;
    }
#line 136
    *p = (char )'\000';
#line 138
    if ((int )buf[0] == 35) {
#line 139
      goto while_continue___0;
    }
    {
#line 141
    tmp___0 = blank_line((char const   *)(buf));
    }
#line 141
    if ((unsigned int )tmp___0 == 1U) {
#line 142
      goto while_continue___0;
    }
    {
#line 144
    p = strchr((char const   *)(buf), '\r');
    }
#line 145
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 146
      *p = (char )'\000';
    }
    {
#line 148
    p = strtok((char */* __restrict  */)(buf), (char const   */* __restrict  */)" \t");
    }
#line 149
    if ((unsigned long )p == (unsigned long )((void *)0)) {
      {
#line 150
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 150
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 151
      goto failure;
    }
    {
#line 154
    temp = strchr((char const   *)p, '/');
    }
#line 155
    if ((unsigned long )temp != (unsigned long )((void *)0)) {
#line 156
      tmp___1 = temp;
#line 156
      temp ++;
#line 156
      *tmp___1 = (char )'\000';
    }
    {
#line 158
    tmp___2 = get_addr((char const   */* const  */)p, & stemp);
    }
#line 158
    if (tmp___2 == -1) {
      {
#line 159
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 159
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 160
      goto failure;
    }
    {
#line 163
    sin_copy(& addr___0, (struct sockaddr_storage  const  *)(& stemp));
    }
#line 165
    if ((int )stemp.ss_family == 2) {
#line 165
      if ((unsigned long )temp != (unsigned long )((void *)0)) {
        {
#line 169
        tmp___3 = strtoul((char const   */* __restrict  */)temp, (char **/* __restrict  */)(& end),
                          10);
#line 169
        mask = (in_addr_t )tmp___3;
        }
#line 171
        if ((int )*end != 0) {
          {
#line 172
          tmp___4 = get_addr((char const   */* const  */)temp, & stemp);
          }
#line 172
          if (tmp___4 == -1) {
            {
#line 173
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 173
              goto while_break___4;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 176
            goto failure;
          }
#line 179
          mask2 = ((struct sockaddr_in *)(& stemp))->sin_addr.s_addr;
        } else {
#line 181
          if (mask < 1U) {
#line 181
            goto _L;
          } else
#line 181
          if (mask > 31U) {
            _L: /* CIL Label */ 
            {
#line 182
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 182
              goto while_break___5;
            }
            while_break___5: /* CIL Label */ ;
            }
#line 185
            goto failure;
          }
          {
#line 188
          mask2 = htonl((uint32_t )(~ ((1 << (32U - mask)) - 1)));
          }
        }
#line 191
        ((struct sockaddr_in *)(& addr___0))->sin_addr.s_addr &= mask2;
#line 192
        ((struct sockaddr_in *)host)->sin_addr.s_addr &= mask2;
      }
    }
    {
#line 195
    tmp___5 = sin_equal(& addr___0, host);
    }
#line 195
    if ((unsigned int )tmp___5 == 0U) {
#line 196
      goto while_continue___0;
    }
    {
#line 198
    p = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t");
    }
#line 199
    if ((unsigned long )p == (unsigned long )((void *)0)) {
      {
#line 200
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 200
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 201
      goto failure;
    }
    {
#line 204
    tmp___6 = strlen((char const   *)p);
    }
#line 204
    if (tmp___6 >= user_len) {
      {
#line 205
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 205
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 208
      goto failure;
    }
    {
#line 211
    xstrncpy(user, (char const   *)p, user_len);
#line 213
    p = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t");
    }
#line 214
    if ((unsigned long )p == (unsigned long )((void *)0)) {
      {
#line 215
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 215
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 217
      goto failure;
    }
    {
#line 220
    tmp___7 = strlen((char const   *)p);
    }
#line 220
    if (tmp___7 >= os_len) {
      {
#line 221
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 221
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 224
      goto failure;
    }
    {
#line 227
    xstrncpy(os, (char const   *)p, os_len);
#line 229
    fclose(fp);
    }
#line 230
    return (0);
  }
  while_break___0: /* CIL Label */ ;
  }
  failure: 
  {
#line 234
  fclose(fp);
  }
#line 235
  return (-1);
}
}
#line 243 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_masq.c"
int fwd_request(int sock , in_port_t real_lport , in_port_t masq_lport , in_port_t real_fport ,
                struct sockaddr_storage *mrelay ) 
{ 
  char ipbuf[46] ;
  char user[512] ;
  char buf[1024] ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  char *p ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 253
  fsock = socket((int )mrelay->ss_family, 1, 0);
  }
#line 254
  if (fsock == -1) {
    {
#line 255
    while (1) {
      while_continue: /* CIL Label */ ;
#line 255
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 256
    return (-1);
  }
  {
#line 259
  sin_set_port(fwdport, mrelay);
#line 261
  tmp = __sigsetjmp((struct __jmp_buf_tag *)(timebuf), 1);
  }
#line 261
  if (tmp != 0) {
    {
#line 262
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 262
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 263
    return (-1);
  }
  {
#line 266
  signal(14, & fwd_alarm);
#line 273
  alarm(5U);
#line 275
  tmp___0 = sin_len((struct sockaddr_storage  const  *)mrelay);
#line 275
  tmp___1 = connect(fsock, (struct sockaddr  const  *)((struct sockaddr *)mrelay),
                    (socklen_t )tmp___0);
  }
#line 275
  if (tmp___1 != 0) {
    {
#line 276
    get_ip(mrelay, ipbuf, sizeof(ipbuf));
    }
    {
#line 278
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 278
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 280
    goto out_fail;
  }
  {
#line 283
  tmp___2 = sockprintf(fsock, "%d , %d\r\n", (int )masq_lport, (int )real_fport);
  }
#line 283
  if (tmp___2 < 1) {
    {
#line 284
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 284
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 285
    goto out_fail;
  }
  {
#line 288
  tmp___3 = sock_read(fsock, buf, sizeof(buf));
  }
#line 288
  if (tmp___3 < 1L) {
    {
#line 289
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 289
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 290
    goto out_fail;
  }
  {
#line 297
  alarm(0U);
#line 298
  close(fsock);
#line 300
  get_ip(mrelay, ipbuf, sizeof(ipbuf));
#line 302
  tmp___5 = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%*d , %*d : USERID :%*[^:]:%511s",
                   user);
  }
#line 302
  if (tmp___5 != 1) {
    {
#line 303
    tmp___4 = strchr((char const   *)(buf), '\r');
#line 303
    p = tmp___4;
    }
#line 305
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 306
      *p = (char )'\000';
    }
    {
#line 308
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 308
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 309
    return (-1);
  }
  {
#line 312
  sockprintf(sock, "%d , %d : USERID : %s : %s\r\n", (int )real_lport, (int )real_fport,
             ret_os, user);
#line 315
  o_log(6, "[%s] Successful lookup (by forward): %d (%d) , %d : %s", ipbuf, (int )real_lport,
        (int )masq_lport, (int )real_fport, user);
  }
#line 319
  return (0);
  out_fail: 
  {
#line 322
  alarm(0U);
#line 323
  close(fsock);
  }
#line 324
  return (-1);
}
}
#line 331
static  __attribute__((__noreturn__)) void fwd_alarm(int sig ) ;
#line 331 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_masq.c"
static void fwd_alarm(int sig ) 
{ 


  {
  {
#line 332
  o_log(6, "Forward timed out");
#line 333
  close(fsock);
#line 334
  siglongjmp((struct __jmp_buf_tag *)(timebuf), sig);
  }
}
}
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 709 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 101 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_cfg_scan.c"
int yyleng  ;
#line 102
FILE *yyin ;
#line 102
FILE *yyout ;
#line 210 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_cfg_scan.c"
static YY_BUFFER_STATE yy_current_buffer  =    (YY_BUFFER_STATE )0;
#line 220 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_cfg_scan.c"
static char yy_hold_char  ;
#line 222 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_cfg_scan.c"
static int yy_n_chars  ;
#line 228 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_cfg_scan.c"
static char *yy_c_buf_p  =    (char *)0;
#line 229 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_cfg_scan.c"
static int yy_init  =    1;
#line 230 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_cfg_scan.c"
static int yy_start  =    0;
#line 235 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_cfg_scan.c"
static int yy_did_buffer_switch_on_eof  ;
#line 237
void yyrestart(FILE *input_file ) ;
#line 239
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer ) ;
#line 240
void yy_load_buffer_state(void) ;
#line 241
YY_BUFFER_STATE yy_create_buffer(FILE *file , int size ) ;
#line 242
void yy_delete_buffer(YY_BUFFER_STATE b ) ;
#line 243
void yy_init_buffer(YY_BUFFER_STATE b , FILE *file ) ;
#line 244
void yy_flush_buffer(YY_BUFFER_STATE b ) ;
#line 247
YY_BUFFER_STATE yy_scan_buffer(char *base , yy_size_t size ) ;
#line 248
YY_BUFFER_STATE yy_scan_string(char const   *yy_str ) ;
#line 249
YY_BUFFER_STATE yy_scan_bytes(char const   *bytes , int len ) ;
#line 251
static void *yy_flex_alloc(yy_size_t size ) ;
#line 252
static void *yy_flex_realloc(void *ptr , yy_size_t size )  __attribute__((__unused__)) ;
#line 253
static void yy_flex_free(void *ptr ) ;
#line 277 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_cfg_scan.c"
FILE *yyin  =    (FILE *)0;
#line 277 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_cfg_scan.c"
FILE *yyout  =    (FILE *)0;
#line 279 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_cfg_scan.c"
char *yytext  ;
#line 282
static yy_state_type yy_get_previous_state(void) ;
#line 283
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) ;
#line 284
static int yy_get_next_buffer(void) ;
#line 285
static void yy_fatal_error(char const   *msg ) ;
#line 299 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_cfg_scan.c"
static short const   yy_accept[132]  = 
#line 299
  {      (short const   )0,      (short const   )0,      (short const   )0,      (short const   )24, 
        (short const   )24,      (short const   )0,      (short const   )0,      (short const   )38, 
        (short const   )35,      (short const   )2,      (short const   )29,      (short const   )22, 
        (short const   )3,      (short const   )36,      (short const   )35,      (short const   )35, 
        (short const   )35,      (short const   )35,      (short const   )35,      (short const   )35, 
        (short const   )35,      (short const   )35,      (short const   )35,      (short const   )35, 
        (short const   )35,      (short const   )1,      (short const   )24,      (short const   )25, 
        (short const   )34,      (short const   )28,      (short const   )27,      (short const   )37, 
        (short const   )35,      (short const   )2,      (short const   )3,      (short const   )3, 
        (short const   )35,      (short const   )23,      (short const   )35,      (short const   )35, 
        (short const   )35,      (short const   )35,      (short const   )35,      (short const   )35, 
        (short const   )35,      (short const   )35,      (short const   )35,      (short const   )35, 
        (short const   )35,      (short const   )35,      (short const   )7,      (short const   )35, 
        (short const   )24,      (short const   )25,      (short const   )25,      (short const   )26, 
        (short const   )34,      (short const   )33,      (short const   )30,      (short const   )32, 
        (short const   )33,      (short const   )35,      (short const   )35,      (short const   )35, 
        (short const   )35,      (short const   )35,      (short const   )35,      (short const   )35, 
        (short const   )35,      (short const   )35,      (short const   )35,      (short const   )35, 
        (short const   )35,      (short const   )35,      (short const   )35,      (short const   )35, 
        (short const   )35,      (short const   )30,      (short const   )31,      (short const   )35, 
        (short const   )35,      (short const   )12,      (short const   )35,      (short const   )35, 
        (short const   )8,      (short const   )35,      (short const   )14,      (short const   )35, 
        (short const   )35,      (short const   )35,      (short const   )35,      (short const   )35, 
        (short const   )4,      (short const   )30,      (short const   )31,      (short const   )11, 
        (short const   )35,      (short const   )13,      (short const   )9,      (short const   )35, 
        (short const   )10,      (short const   )35,      (short const   )35,      (short const   )21, 
        (short const   )18,      (short const   )35,      (short const   )6,      (short const   )35, 
        (short const   )15,      (short const   )35,      (short const   )5,      (short const   )16, 
        (short const   )35,      (short const   )35,      (short const   )35,      (short const   )35, 
        (short const   )35,      (short const   )35,      (short const   )35,      (short const   )19, 
        (short const   )35,      (short const   )35,      (short const   )35,      (short const   )35, 
        (short const   )35,      (short const   )35,      (short const   )35,      (short const   )35, 
        (short const   )35,      (short const   )17,      (short const   )20,      (short const   )0};
#line 318 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_cfg_scan.c"
static int const   yy_ec[256]  = 
#line 318
  {      (int const   )0,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )2,      (int const   )1,      (int const   )4,      (int const   )5, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )6,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )7, 
        (int const   )8,      (int const   )8,      (int const   )8,      (int const   )8, 
        (int const   )8,      (int const   )8,      (int const   )8,      (int const   )8, 
        (int const   )9,      (int const   )9,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )12,      (int const   )13,      (int const   )14, 
        (int const   )15,      (int const   )16,      (int const   )17,      (int const   )18, 
        (int const   )19,      (int const   )20,      (int const   )1,      (int const   )1, 
        (int const   )21,      (int const   )22,      (int const   )23,      (int const   )24, 
        (int const   )25,      (int const   )1,      (int const   )26,      (int const   )27, 
        (int const   )28,      (int const   )29,      (int const   )30,      (int const   )31, 
        (int const   )32,      (int const   )33,      (int const   )1,      (int const   )1, 
        (int const   )10,      (int const   )1,      (int const   )1,      (int const   )11, 
        (int const   )1,      (int const   )12,      (int const   )13,      (int const   )14, 
        (int const   )15,      (int const   )16,      (int const   )17,      (int const   )18, 
        (int const   )19,      (int const   )20,      (int const   )1,      (int const   )1, 
        (int const   )21,      (int const   )22,      (int const   )23,      (int const   )24, 
        (int const   )25,      (int const   )1,      (int const   )26,      (int const   )27, 
        (int const   )28,      (int const   )29,      (int const   )30,      (int const   )31, 
        (int const   )32,      (int const   )33,      (int const   )1,      (int const   )34, 
        (int const   )1,      (int const   )35,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1};
#line 350 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_cfg_scan.c"
static int const   yy_meta[36]  = 
#line 350
  {      (int const   )0,      (int const   )1,      (int const   )2,      (int const   )3, 
        (int const   )4,      (int const   )1,      (int const   )5,      (int const   )1, 
        (int const   )6,      (int const   )6,      (int const   )4,      (int const   )1, 
        (int const   )6,      (int const   )6,      (int const   )6,      (int const   )6, 
        (int const   )6,      (int const   )6,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )2,      (int const   )2};
#line 358 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_cfg_scan.c"
static short const   yy_base[146]  = 
#line 358
  {      (short const   )0,      (short const   )0,      (short const   )0,      (short const   )33, 
        (short const   )34,      (short const   )38,      (short const   )40,      (short const   )204, 
        (short const   )0,      (short const   )201,      (short const   )205,      (short const   )205, 
        (short const   )36,      (short const   )196,      (short const   )180,      (short const   )184, 
        (short const   )21,      (short const   )178,      (short const   )178,      (short const   )172, 
        (short const   )167,      (short const   )37,      (short const   )170,      (short const   )170, 
        (short const   )166,      (short const   )205,      (short const   )0,      (short const   )45, 
        (short const   )0,      (short const   )205,      (short const   )205,      (short const   )46, 
        (short const   )0,      (short const   )190,      (short const   )54,      (short const   )0, 
        (short const   )185,      (short const   )205,      (short const   )169,      (short const   )40, 
        (short const   )163,      (short const   )164,      (short const   )163,      (short const   )162, 
        (short const   )170,      (short const   )160,      (short const   )161,      (short const   )159, 
        (short const   )156,      (short const   )156,      (short const   )0,      (short const   )163, 
        (short const   )0,      (short const   )52,      (short const   )54,      (short const   )205, 
        (short const   )0,      (short const   )205,      (short const   )170,      (short const   )205, 
        (short const   )0,      (short const   )171,      (short const   )0,      (short const   )152, 
        (short const   )163,      (short const   )141,      (short const   )159,      (short const   )146, 
        (short const   )149,      (short const   )157,      (short const   )153,      (short const   )142, 
        (short const   )151,      (short const   )151,      (short const   )144,      (short const   )140, 
        (short const   )137,      (short const   )154,      (short const   )0,      (short const   )127, 
        (short const   )128,      (short const   )0,      (short const   )136,      (short const   )123, 
        (short const   )0,      (short const   )134,      (short const   )0,      (short const   )112, 
        (short const   )109,      (short const   )110,      (short const   )95,      (short const   )107, 
        (short const   )0,      (short const   )205,      (short const   )205,      (short const   )0, 
        (short const   )101,      (short const   )0,      (short const   )0,      (short const   )95, 
        (short const   )0,      (short const   )95,      (short const   )88,      (short const   )0, 
        (short const   )93,      (short const   )75,      (short const   )0,      (short const   )73, 
        (short const   )75,      (short const   )50,      (short const   )0,      (short const   )0, 
        (short const   )62,      (short const   )63,      (short const   )57,      (short const   )53, 
        (short const   )60,      (short const   )60,      (short const   )57,      (short const   )0, 
        (short const   )47,      (short const   )60,      (short const   )49,      (short const   )47, 
        (short const   )48,      (short const   )49,      (short const   )42,      (short const   )53, 
        (short const   )38,      (short const   )0,      (short const   )0,      (short const   )205, 
        (short const   )89,      (short const   )95,      (short const   )101,      (short const   )107, 
        (short const   )113,      (short const   )119,      (short const   )125,      (short const   )131, 
        (short const   )137,      (short const   )143,      (short const   )149,      (short const   )59, 
        (short const   )155,      (short const   )58};
#line 378 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_cfg_scan.c"
static short const   yy_def[146]  = 
#line 378
  {      (short const   )0,      (short const   )131,      (short const   )1,      (short const   )132, 
        (short const   )132,      (short const   )133,      (short const   )133,      (short const   )131, 
        (short const   )134,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )135,      (short const   )136,      (short const   )134,      (short const   )134, 
        (short const   )134,      (short const   )134,      (short const   )134,      (short const   )134, 
        (short const   )134,      (short const   )134,      (short const   )134,      (short const   )134, 
        (short const   )134,      (short const   )131,      (short const   )137,      (short const   )138, 
        (short const   )139,      (short const   )131,      (short const   )131,      (short const   )140, 
        (short const   )134,      (short const   )131,      (short const   )135,      (short const   )141, 
        (short const   )142,      (short const   )131,      (short const   )134,      (short const   )134, 
        (short const   )134,      (short const   )134,      (short const   )134,      (short const   )134, 
        (short const   )134,      (short const   )134,      (short const   )134,      (short const   )134, 
        (short const   )134,      (short const   )134,      (short const   )134,      (short const   )134, 
        (short const   )137,      (short const   )138,      (short const   )138,      (short const   )131, 
        (short const   )139,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )143,      (short const   )142,      (short const   )144,      (short const   )134, 
        (short const   )134,      (short const   )134,      (short const   )134,      (short const   )134, 
        (short const   )134,      (short const   )134,      (short const   )134,      (short const   )134, 
        (short const   )134,      (short const   )134,      (short const   )134,      (short const   )134, 
        (short const   )134,      (short const   )131,      (short const   )145,      (short const   )134, 
        (short const   )134,      (short const   )134,      (short const   )134,      (short const   )134, 
        (short const   )134,      (short const   )134,      (short const   )134,      (short const   )134, 
        (short const   )134,      (short const   )134,      (short const   )134,      (short const   )134, 
        (short const   )134,      (short const   )131,      (short const   )131,      (short const   )134, 
        (short const   )134,      (short const   )134,      (short const   )134,      (short const   )134, 
        (short const   )134,      (short const   )134,      (short const   )134,      (short const   )134, 
        (short const   )134,      (short const   )134,      (short const   )134,      (short const   )134, 
        (short const   )134,      (short const   )134,      (short const   )134,      (short const   )134, 
        (short const   )134,      (short const   )134,      (short const   )134,      (short const   )134, 
        (short const   )134,      (short const   )134,      (short const   )134,      (short const   )134, 
        (short const   )134,      (short const   )134,      (short const   )134,      (short const   )134, 
        (short const   )134,      (short const   )134,      (short const   )134,      (short const   )134, 
        (short const   )134,      (short const   )134,      (short const   )134,      (short const   )0, 
        (short const   )131,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )131,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )131,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )131,      (short const   )131};
#line 398 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_cfg_scan.c"
static short const   yy_nxt[241]  = 
#line 398
  {      (short const   )0,      (short const   )8,      (short const   )9,      (short const   )10, 
        (short const   )11,      (short const   )12,      (short const   )8,      (short const   )13, 
        (short const   )8,      (short const   )8,      (short const   )8,      (short const   )8, 
        (short const   )14,      (short const   )8,      (short const   )8,      (short const   )15, 
        (short const   )8,      (short const   )16,      (short const   )17,      (short const   )18, 
        (short const   )8,      (short const   )19,      (short const   )8,      (short const   )20, 
        (short const   )8,      (short const   )8,      (short const   )21,      (short const   )22, 
        (short const   )23,      (short const   )24,      (short const   )8,      (short const   )8, 
        (short const   )8,      (short const   )8,      (short const   )25,      (short const   )25, 
        (short const   )10,      (short const   )10,      (short const   )35,      (short const   )27, 
        (short const   )27,      (short const   )29,      (short const   )30,      (short const   )29, 
        (short const   )30,      (short const   )40,      (short const   )41,      (short const   )42, 
        (short const   )31,      (short const   )47,      (short const   )31,      (short const   )54, 
        (short const   )55,      (short const   )48,      (short const   )58,      (short const   )59, 
        (short const   )35,      (short const   )64,      (short const   )131,      (short const   )131, 
        (short const   )54,      (short const   )55,      (short const   )113,      (short const   )65, 
        (short const   )94,      (short const   )78,      (short const   )130,      (short const   )129, 
        (short const   )128,      (short const   )127,      (short const   )35,      (short const   )35, 
        (short const   )126,      (short const   )125,      (short const   )124,      (short const   )114, 
        (short const   )123,      (short const   )122,      (short const   )60,      (short const   )121, 
        (short const   )120,      (short const   )119,      (short const   )118,      (short const   )117, 
        (short const   )116,      (short const   )115,      (short const   )112,      (short const   )111, 
        (short const   )35,      (short const   )35,      (short const   )26,      (short const   )26, 
        (short const   )26,      (short const   )26,      (short const   )26,      (short const   )26, 
        (short const   )28,      (short const   )28,      (short const   )28,      (short const   )28, 
        (short const   )28,      (short const   )28,      (short const   )32,      (short const   )110, 
        (short const   )109,      (short const   )32,      (short const   )32,      (short const   )32, 
        (short const   )34,      (short const   )34,      (short const   )108,      (short const   )34, 
        (short const   )34,      (short const   )34,      (short const   )36,      (short const   )107, 
        (short const   )106,      (short const   )36,      (short const   )36,      (short const   )36, 
        (short const   )52,      (short const   )52,      (short const   )105,      (short const   )52, 
        (short const   )104,      (short const   )52,      (short const   )53,      (short const   )53, 
        (short const   )103,      (short const   )53,      (short const   )53,      (short const   )53, 
        (short const   )56,      (short const   )56,      (short const   )102,      (short const   )101, 
        (short const   )56,      (short const   )56,      (short const   )57,      (short const   )57, 
        (short const   )100,      (short const   )57,      (short const   )57,      (short const   )57, 
        (short const   )35,      (short const   )35,      (short const   )99,      (short const   )35, 
        (short const   )35,      (short const   )35,      (short const   )61,      (short const   )98, 
        (short const   )97,      (short const   )61,      (short const   )61,      (short const   )61, 
        (short const   )62,      (short const   )96,      (short const   )95,      (short const   )62, 
        (short const   )62,      (short const   )62,      (short const   )93,      (short const   )92, 
        (short const   )91,      (short const   )90,      (short const   )89,      (short const   )88, 
        (short const   )87,      (short const   )86,      (short const   )85,      (short const   )84, 
        (short const   )83,      (short const   )82,      (short const   )81,      (short const   )80, 
        (short const   )79,      (short const   )62,      (short const   )77,      (short const   )76, 
        (short const   )75,      (short const   )74,      (short const   )73,      (short const   )72, 
        (short const   )71,      (short const   )70,      (short const   )69,      (short const   )68, 
        (short const   )67,      (short const   )66,      (short const   )63,      (short const   )62, 
        (short const   )33,      (short const   )51,      (short const   )50,      (short const   )49, 
        (short const   )46,      (short const   )45,      (short const   )44,      (short const   )43, 
        (short const   )39,      (short const   )38,      (short const   )37,      (short const   )33, 
        (short const   )131,      (short const   )7,      (short const   )131,      (short const   )131, 
        (short const   )131,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )131,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )131,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )131,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )131,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )131,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )131,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )131,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )131};
#line 428 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_cfg_scan.c"
static short const   yy_chk[241]  = 
#line 428
  {      (short const   )0,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )3,      (short const   )4,      (short const   )12,      (short const   )3, 
        (short const   )4,      (short const   )5,      (short const   )5,      (short const   )6, 
        (short const   )6,      (short const   )16,      (short const   )16,      (short const   )16, 
        (short const   )5,      (short const   )21,      (short const   )6,      (short const   )27, 
        (short const   )27,      (short const   )21,      (short const   )31,      (short const   )31, 
        (short const   )34,      (short const   )39,      (short const   )53,      (short const   )53, 
        (short const   )54,      (short const   )54,      (short const   )109,      (short const   )39, 
        (short const   )145,      (short const   )143,      (short const   )128,      (short const   )127, 
        (short const   )126,      (short const   )125,      (short const   )12,      (short const   )12, 
        (short const   )124,      (short const   )123,      (short const   )122,      (short const   )109, 
        (short const   )121,      (short const   )120,      (short const   )31,      (short const   )118, 
        (short const   )117,      (short const   )116,      (short const   )115,      (short const   )114, 
        (short const   )113,      (short const   )112,      (short const   )108,      (short const   )107, 
        (short const   )34,      (short const   )34,      (short const   )132,      (short const   )132, 
        (short const   )132,      (short const   )132,      (short const   )132,      (short const   )132, 
        (short const   )133,      (short const   )133,      (short const   )133,      (short const   )133, 
        (short const   )133,      (short const   )133,      (short const   )134,      (short const   )105, 
        (short const   )104,      (short const   )134,      (short const   )134,      (short const   )134, 
        (short const   )135,      (short const   )135,      (short const   )102,      (short const   )135, 
        (short const   )135,      (short const   )135,      (short const   )136,      (short const   )101, 
        (short const   )99,      (short const   )136,      (short const   )136,      (short const   )136, 
        (short const   )137,      (short const   )137,      (short const   )96,      (short const   )137, 
        (short const   )91,      (short const   )137,      (short const   )138,      (short const   )138, 
        (short const   )90,      (short const   )138,      (short const   )138,      (short const   )138, 
        (short const   )139,      (short const   )139,      (short const   )89,      (short const   )88, 
        (short const   )139,      (short const   )139,      (short const   )140,      (short const   )140, 
        (short const   )87,      (short const   )140,      (short const   )140,      (short const   )140, 
        (short const   )141,      (short const   )141,      (short const   )85,      (short const   )141, 
        (short const   )141,      (short const   )141,      (short const   )142,      (short const   )83, 
        (short const   )82,      (short const   )142,      (short const   )142,      (short const   )142, 
        (short const   )144,      (short const   )80,      (short const   )79,      (short const   )144, 
        (short const   )144,      (short const   )144,      (short const   )77,      (short const   )76, 
        (short const   )75,      (short const   )74,      (short const   )73,      (short const   )72, 
        (short const   )71,      (short const   )70,      (short const   )69,      (short const   )68, 
        (short const   )67,      (short const   )66,      (short const   )65,      (short const   )64, 
        (short const   )63,      (short const   )61,      (short const   )58,      (short const   )51, 
        (short const   )49,      (short const   )48,      (short const   )47,      (short const   )46, 
        (short const   )45,      (short const   )44,      (short const   )43,      (short const   )42, 
        (short const   )41,      (short const   )40,      (short const   )38,      (short const   )36, 
        (short const   )33,      (short const   )24,      (short const   )23,      (short const   )22, 
        (short const   )20,      (short const   )19,      (short const   )18,      (short const   )17, 
        (short const   )15,      (short const   )14,      (short const   )13,      (short const   )9, 
        (short const   )7,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )131,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )131,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )131,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )131,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )131,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )131,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )131,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )131,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )131};
#line 458 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_cfg_scan.c"
static yy_state_type yy_last_accepting_state  ;
#line 459 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_cfg_scan.c"
static char *yy_last_accepting_cpos  ;
#line 174 "./oidentd.h"
int yylex(void) ;
#line 75 "y.tab.h"
YYSTYPE yylval ;
#line 47 "oidentd_cfg_scan.l"
static char *string_buf  ;
#line 48 "oidentd_cfg_scan.l"
static size_t str_idx  ;
#line 49 "oidentd_cfg_scan.l"
static size_t max_slen  ;
#line 51
static char get_esc_char(char c ) ;
#line 53 "oidentd_cfg_scan.l"
u_int32_t current_line  ;
#line 676 "oidentd_cfg_scan.c"
int yylex(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  register YY_CHAR yy_c ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  u_int32_t result ;
  unsigned long tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  u_int32_t result___0 ;
  unsigned long tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;
  size_t len ;
  char *p ;
  void *tmp___10 ;
  size_t tmp___11 ;
  char *tmp___12 ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___13 ;

  {
#line 679
  yy_cp = (char *)((void *)0);
#line 679
  yy_bp = (char *)((void *)0);
#line 687
  if (yy_init) {
#line 689
    yy_init = 0;
#line 695
    if (! yy_start) {
#line 696
      yy_start = 1;
    }
#line 698
    if (! yyin) {
#line 699
      yyin = stdin;
    }
#line 701
    if (! yyout) {
#line 702
      yyout = stdout;
    }
#line 704
    if (! yy_current_buffer) {
      {
#line 705
      yy_current_buffer = yy_create_buffer(yyin, 16384);
      }
    }
    {
#line 708
    yy_load_buffer_state();
    }
  }
  {
#line 711
  while (1) {
    while_continue: /* CIL Label */ ;
#line 713
    yy_cp = yy_c_buf_p;
#line 716
    *yy_cp = yy_hold_char;
#line 721
    yy_bp = yy_cp;
#line 723
    yy_current_state = yy_start;
    yy_match: 
    {
#line 725
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 727
      yy_c = (YY_CHAR )yy_ec[(unsigned int )((unsigned char )*yy_cp)];
#line 728
      if (yy_accept[yy_current_state]) {
#line 730
        yy_last_accepting_state = yy_current_state;
#line 731
        yy_last_accepting_cpos = yy_cp;
      }
      {
#line 733
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 733
        if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 733
          goto while_break___1;
        }
#line 735
        yy_current_state = (int )yy_def[yy_current_state];
#line 736
        if (yy_current_state >= 132) {
#line 737
          yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 739
      yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 740
      yy_cp ++;
#line 725
      if (! ((int const   )yy_base[yy_current_state] != 205)) {
#line 725
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    yy_find_action: 
#line 745
    yy_act = (int )yy_accept[yy_current_state];
#line 746
    if (yy_act == 0) {
#line 748
      yy_cp = yy_last_accepting_cpos;
#line 749
      yy_current_state = yy_last_accepting_state;
#line 750
      yy_act = (int )yy_accept[yy_current_state];
    }
#line 753
    yytext = yy_bp;
#line 753
    yyleng = (int )(yy_cp - yy_bp);
#line 753
    yy_hold_char = *yy_cp;
#line 753
    *yy_cp = (char )'\000';
#line 753
    yy_c_buf_p = yy_cp;
    do_action: 
    {
#line 761
    if (yy_act == 0) {
#line 761
      goto case_0;
    }
#line 768
    if (yy_act == 1) {
#line 768
      goto case_1;
    }
#line 90
    if (yy_act == 2) {
#line 90 "oidentd_cfg_scan.l"
      goto case_2;
    }
#line 94
    if (yy_act == 3) {
#line 94
      goto case_3;
    }
#line 98
    if (yy_act == 4) {
#line 98
      goto case_4;
    }
#line 102
    if (yy_act == 5) {
#line 102
      goto case_5;
    }
#line 106
    if (yy_act == 6) {
#line 106
      goto case_6;
    }
#line 110
    if (yy_act == 7) {
#line 110
      goto case_7;
    }
#line 114
    if (yy_act == 8) {
#line 114
      goto case_8;
    }
#line 118
    if (yy_act == 9) {
#line 118
      goto case_9;
    }
#line 122
    if (yy_act == 10) {
#line 122
      goto case_10;
    }
#line 126
    if (yy_act == 11) {
#line 126
      goto case_11;
    }
#line 131
    if (yy_act == 12) {
#line 131
      goto case_12;
    }
#line 136
    if (yy_act == 13) {
#line 136
      goto case_13;
    }
#line 140
    if (yy_act == 14) {
#line 140
      goto case_14;
    }
#line 145
    if (yy_act == 15) {
#line 145
      goto case_15;
    }
#line 150
    if (yy_act == 16) {
#line 150
      goto case_16;
    }
#line 155
    if (yy_act == 17) {
#line 155
      goto case_17;
    }
#line 160
    if (yy_act == 18) {
#line 160
      goto case_18;
    }
#line 165
    if (yy_act == 19) {
#line 165
      goto case_19;
    }
#line 170
    if (yy_act == 20) {
#line 170
      goto case_20;
    }
#line 175
    if (yy_act == 21) {
#line 175
      goto case_21;
    }
#line 179
    if (yy_act == 22) {
#line 179
      goto case_22;
    }
#line 187
    if (yy_act == 23) {
#line 187
      goto case_23;
    }
#line 189
    if (yy_act == 24) {
#line 189
      goto case_24;
    }
#line 193
    if (yy_act == 25) {
#line 193
      goto case_25;
    }
#line 197
    if (yy_act == 26) {
#line 197
      goto case_26;
    }
#line 201
    if (yy_act == 27) {
#line 201
      goto case_27;
    }
#line 210
    if (yy_act == 28) {
#line 210
      goto case_28;
    }
#line 220
    if (yy_act == 29) {
#line 220
      goto case_29;
    }
#line 224
    if (yy_act == 30) {
#line 224
      goto case_30;
    }
#line 247
    if (yy_act == 31) {
#line 247
      goto case_31;
    }
#line 260
    if (yy_act == 32) {
#line 260
      goto case_32;
    }
#line 270
    if (yy_act == 33) {
#line 270
      goto case_33;
    }
#line 279
    if (yy_act == 34) {
#line 279
      goto case_34;
    }
#line 292
    if (yy_act == 35) {
#line 292
      goto case_35;
    }
#line 297
    if (yy_act == 36) {
#line 297
      goto case_36;
    }
#line 301
    if (yy_act == 37) {
#line 301
      goto case_37;
    }
#line 1099
    if (yy_act == 41) {
#line 1099 "oidentd_cfg_scan.c"
      goto case_41;
    }
#line 1099
    if (yy_act == 40) {
#line 1099
      goto case_41;
    }
#line 1099
    if (yy_act == 39) {
#line 1099
      goto case_41;
    }
#line 1102
    if (yy_act == 38) {
#line 1102
      goto case_38;
    }
#line 1224
    goto switch_default;
    case_0: /* CIL Label */ 
#line 763
    *yy_cp = yy_hold_char;
#line 764
    yy_cp = yy_last_accepting_cpos;
#line 765
    yy_current_state = yy_last_accepting_state;
#line 766
    goto yy_find_action;
    case_1: /* CIL Label */ 
#line 87 "oidentd_cfg_scan.l"
    return ((int )*(yytext + 0));
#line 89
    goto switch_break;
    case_2: /* CIL Label */ ;
#line 93
    goto switch_break;
    case_3: /* CIL Label */ ;
#line 97
    goto switch_break;
    case_4: /* CIL Label */ 
#line 99
    return (258);
#line 101
    goto switch_break;
    case_5: /* CIL Label */ 
#line 103
    return (259);
#line 105
    goto switch_break;
    case_6: /* CIL Label */ 
#line 107
    return (260);
#line 109
    goto switch_break;
    case_7: /* CIL Label */ 
#line 111
    return (262);
#line 113
    goto switch_break;
    case_8: /* CIL Label */ 
#line 115
    return (261);
#line 117
    goto switch_break;
    case_9: /* CIL Label */ 
#line 119
    return (263);
#line 121
    goto switch_break;
    case_10: /* CIL Label */ 
#line 123
    return (264);
#line 125
    goto switch_break;
    case_11: /* CIL Label */ 
#line 127
    yylval.value = 1;
#line 128
    return (267);
#line 130
    goto switch_break;
    case_12: /* CIL Label */ 
#line 132
    yylval.value = 0;
#line 133
    return (267);
#line 135
    goto switch_break;
    case_13: /* CIL Label */ 
#line 137
    return (265);
#line 139
    goto switch_break;
    case_14: /* CIL Label */ 
#line 141
    yylval.value = 1 << 4;
#line 142
    return (268);
#line 144
    goto switch_break;
    case_15: /* CIL Label */ 
#line 146
    yylval.value = 1 << 5;
#line 147
    return (268);
#line 149
    goto switch_break;
    case_16: /* CIL Label */ 
#line 151
    yylval.value = 1 << 7;
#line 152
    return (268);
#line 154
    goto switch_break;
    case_17: /* CIL Label */ 
#line 156
    yylval.value = 1 << 6;
#line 157
    return (268);
#line 159
    goto switch_break;
    case_18: /* CIL Label */ 
#line 161
    yylval.value = 1 << 1;
#line 162
    return (268);
#line 164
    goto switch_break;
    case_19: /* CIL Label */ 
#line 166
    yylval.value = 1 << 2;
#line 167
    return (268);
#line 169
    goto switch_break;
    case_20: /* CIL Label */ 
#line 171
    yylval.value = 1 << 3;
#line 172
    return (268);
#line 174
    goto switch_break;
    case_21: /* CIL Label */ 
#line 176
    return (266);
#line 178
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 180
    tmp = xmalloc((size_t )256);
#line 180
    string_buf = (char *)tmp;
#line 181
    str_idx = (size_t )0;
#line 182
    max_slen = (size_t )256;
#line 184
    yy_start = 5;
    }
#line 186
    goto switch_break;
    case_23: /* CIL Label */ 
#line 187
    yy_start = 3;
#line 188
    goto switch_break;
    case_24: /* CIL Label */ ;
#line 192
    goto switch_break;
    case_25: /* CIL Label */ ;
#line 196
    goto switch_break;
    case_26: /* CIL Label */ 
#line 198
    yy_start = 1;
#line 200
    goto switch_break;
    case_27: /* CIL Label */ 
    {
#line 202
    tmp___0 = str_idx;
#line 202
    str_idx ++;
#line 202
    *(string_buf + tmp___0) = (char )'\000';
#line 203
    tmp___1 = xrealloc((void *)string_buf, str_idx);
#line 203
    string_buf = (char *)tmp___1;
#line 204
    yylval.string = string_buf;
#line 206
    yy_start = 1;
    }
#line 207
    return (269);
#line 209
    goto switch_break;
    case_28: /* CIL Label */ 
#line 211
    if (parser_mode == 1) {
      {
#line 212
      o_log(6, "[line %u] Error: Unterminated string constant", current_line);
      }
    }
    {
#line 216
    free((void *)string_buf);
    }
#line 217
    return (-1);
#line 219
    goto switch_break;
    case_29: /* CIL Label */ 
#line 221
    current_line ++;
#line 223
    goto switch_break;
    case_30: /* CIL Label */ 
    {
#line 227
    tmp___2 = strtoul((char const   */* __restrict  */)(yytext + 1), (char **/* __restrict  */)((void *)0),
                      8);
#line 227
    result = (u_int32_t )tmp___2;
    }
#line 229
    if (result > 255U) {
#line 230
      if (parser_mode == 1) {
        {
#line 231
        o_log(6, "[line %u] Bad escape sequence: \"%s\"\n", current_line, yytext);
        }
      }
      {
#line 235
      free((void *)string_buf);
      }
#line 236
      return (-1);
    }
#line 239
    if (str_idx >= max_slen - 1UL) {
      {
#line 240
      max_slen += 256UL;
#line 241
      tmp___3 = xrealloc((void *)string_buf, max_slen);
#line 241
      string_buf = (char *)tmp___3;
      }
    }
#line 244
    tmp___4 = str_idx;
#line 244
    str_idx ++;
#line 244
    *(string_buf + tmp___4) = (char )result;
#line 246
    goto switch_break;
    case_31: /* CIL Label */ 
    {
#line 250
    tmp___5 = strtoul((char const   */* __restrict  */)(yytext + 2), (char **/* __restrict  */)((void *)0),
                      16);
#line 250
    result___0 = (u_int32_t )tmp___5;
    }
#line 252
    if (str_idx >= max_slen - 2UL) {
      {
#line 253
      max_slen += 256UL;
#line 254
      tmp___6 = xrealloc((void *)string_buf, max_slen);
#line 254
      string_buf = (char *)tmp___6;
      }
    }
#line 257
    tmp___7 = str_idx;
#line 257
    str_idx ++;
#line 257
    *(string_buf + tmp___7) = (char )result___0;
#line 259
    goto switch_break;
    case_32: /* CIL Label */ 
#line 261
    if (parser_mode == 1) {
      {
#line 262
      o_log(6, "[line %u] Error: Bad escape sequence: \"%s\"\n", current_line, yytext);
      }
    }
    {
#line 266
    free((void *)string_buf);
    }
#line 267
    return (-1);
#line 269
    goto switch_break;
    case_33: /* CIL Label */ 
#line 271
    if (str_idx >= max_slen - 2UL) {
      {
#line 272
      max_slen += 256UL;
#line 273
      tmp___8 = xrealloc((void *)string_buf, max_slen);
#line 273
      string_buf = (char *)tmp___8;
      }
    }
    {
#line 276
    tmp___9 = str_idx;
#line 276
    str_idx ++;
#line 276
    *(string_buf + tmp___9) = get_esc_char(*(yytext + 1));
    }
#line 278
    goto switch_break;
    case_34: /* CIL Label */ 
#line 280
    len = (size_t )yyleng;
#line 281
    p = yytext;
#line 283
    if (str_idx + len >= max_slen - 1UL) {
      {
#line 284
      max_slen += len + 1UL;
#line 285
      tmp___10 = xrealloc((void *)string_buf, max_slen);
#line 285
      string_buf = (char *)tmp___10;
      }
    }
    {
#line 288
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 288
      if (! ((int )*p != 0)) {
#line 288
        goto while_break___2;
      }
#line 289
      tmp___11 = str_idx;
#line 289
      str_idx ++;
#line 289
      tmp___12 = p;
#line 289
      p ++;
#line 289
      *(string_buf + tmp___11) = *tmp___12;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 291
    goto switch_break;
    case_35: /* CIL Label */ 
    {
#line 293
    yylval.string = xstrdup((char const   *)yytext);
    }
#line 294
    return (269);
#line 296
    goto switch_break;
    case_36: /* CIL Label */ 
#line 298
    return ((int )*(yytext + 0));
#line 300
    goto switch_break;
    case_37: /* CIL Label */ 
    {
#line 301
    fwrite((void const   */* __restrict  */)yytext, (size_t )yyleng, (size_t )1, (FILE */* __restrict  */)yyout);
    }
#line 302
    goto switch_break;
    case_41: /* CIL Label */ 
    case_40: /* CIL Label */ 
    case_39: /* CIL Label */ 
#line 1100 "oidentd_cfg_scan.c"
    return (0);
    case_38: /* CIL Label */ 
#line 1105
    yy_amount_of_matched_text = (int )(yy_cp - yytext) - 1;
#line 1108
    *yy_cp = yy_hold_char;
#line 1111
    if (yy_current_buffer->yy_buffer_status == 0) {
#line 1122
      yy_n_chars = yy_current_buffer->yy_n_chars;
#line 1123
      yy_current_buffer->yy_input_file = yyin;
#line 1124
      yy_current_buffer->yy_buffer_status = 1;
    }
#line 1134
    if ((unsigned long )yy_c_buf_p <= (unsigned long )(yy_current_buffer->yy_ch_buf + yy_n_chars)) {
      {
#line 1138
      yy_c_buf_p = yytext + yy_amount_of_matched_text;
#line 1140
      yy_current_state = yy_get_previous_state();
#line 1151
      yy_next_state = yy_try_NUL_trans(yy_current_state);
#line 1153
      yy_bp = yytext + 0;
      }
#line 1155
      if (yy_next_state) {
#line 1158
        yy_c_buf_p ++;
#line 1158
        yy_cp = yy_c_buf_p;
#line 1159
        yy_current_state = yy_next_state;
#line 1160
        goto yy_match;
      } else {
#line 1165
        yy_cp = yy_c_buf_p;
#line 1166
        goto yy_find_action;
      }
    } else {
      {
#line 1170
      tmp___13 = yy_get_next_buffer();
      }
      {
#line 1172
      if (tmp___13 == 1) {
#line 1172
        goto case_1___0;
      }
#line 1201
      if (tmp___13 == 0) {
#line 1201
        goto case_0___0;
      }
#line 1211
      if (tmp___13 == 2) {
#line 1211
        goto case_2___0;
      }
#line 1170
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
#line 1174
      yy_did_buffer_switch_on_eof = 0;
#line 1187
      yy_c_buf_p = yytext + 0;
#line 1189
      yy_act = (38 + (yy_start - 1) / 2) + 1;
#line 1190
      goto do_action;
#line 1198
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
      {
#line 1202
      yy_c_buf_p = yytext + yy_amount_of_matched_text;
#line 1205
      yy_current_state = yy_get_previous_state();
#line 1207
      yy_cp = yy_c_buf_p;
#line 1208
      yy_bp = yytext + 0;
      }
#line 1209
      goto yy_match;
      case_2___0: /* CIL Label */ 
      {
#line 1212
      yy_c_buf_p = yy_current_buffer->yy_ch_buf + yy_n_chars;
#line 1215
      yy_current_state = yy_get_previous_state();
#line 1217
      yy_cp = yy_c_buf_p;
#line 1218
      yy_bp = yytext + 0;
      }
#line 1219
      goto yy_find_action;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1221
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1225
    yy_fatal_error("fatal flex scanner internal error--no action found");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1240 "oidentd_cfg_scan.c"
static int yy_get_next_buffer(void) 
{ 
  register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int num_to_read ;
  YY_BUFFER_STATE b ;
  int yy_c_buf_p_offset ;
  int new_size ;
  void *tmp___1 ;
  int c ;
  int n ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;

  {
#line 1242
  dest = yy_current_buffer->yy_ch_buf;
#line 1243
  source = yytext;
#line 1247
  if ((unsigned long )yy_c_buf_p > (unsigned long )(yy_current_buffer->yy_ch_buf + (yy_n_chars + 1))) {
    {
#line 1248
    yy_fatal_error("fatal flex scanner internal error--end of buffer missed");
    }
  }
#line 1251
  if (yy_current_buffer->yy_fill_buffer == 0) {
#line 1253
    if (yy_c_buf_p - yytext == 1L) {
#line 1258
      return (1);
    } else {
#line 1266
      return (2);
    }
  }
#line 1273
  number_to_move = (int )(yy_c_buf_p - yytext) - 1;
#line 1275
  i = 0;
  {
#line 1275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1275
    if (! (i < number_to_move)) {
#line 1275
      goto while_break;
    }
#line 1276
    tmp = dest;
#line 1276
    dest ++;
#line 1276
    tmp___0 = source;
#line 1276
    source ++;
#line 1276
    *tmp = *tmp___0;
#line 1275
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1278
  if (yy_current_buffer->yy_buffer_status == 2) {
#line 1282
    yy_n_chars = 0;
#line 1282
    yy_current_buffer->yy_n_chars = yy_n_chars;
  } else {
#line 1286
    num_to_read = (int )((yy_current_buffer->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    {
#line 1289
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1289
      if (! (num_to_read <= 0)) {
#line 1289
        goto while_break___0;
      }
#line 1297
      b = yy_current_buffer;
#line 1299
      yy_c_buf_p_offset = (int )(yy_c_buf_p - b->yy_ch_buf);
#line 1302
      if (b->yy_is_our_buffer) {
#line 1304
        new_size = (int )(b->yy_buf_size * 2U);
#line 1306
        if (new_size <= 0) {
#line 1307
          b->yy_buf_size += b->yy_buf_size / 8U;
        } else {
#line 1309
          b->yy_buf_size *= 2U;
        }
        {
#line 1311
        tmp___1 = yy_flex_realloc((void *)b->yy_ch_buf, b->yy_buf_size + 2U);
#line 1311
        b->yy_ch_buf = (char *)tmp___1;
        }
      } else {
#line 1318
        b->yy_ch_buf = (char *)0;
      }
#line 1320
      if (! b->yy_ch_buf) {
        {
#line 1321
        yy_fatal_error("fatal error - scanner input buffer overflow");
        }
      }
#line 1324
      yy_c_buf_p = b->yy_ch_buf + yy_c_buf_p_offset;
#line 1326
      num_to_read = (int )((yy_current_buffer->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1331
    if (num_to_read > 8192) {
#line 1332
      num_to_read = 8192;
    }
#line 1335
    if (yy_current_buffer->yy_is_interactive) {
#line 1335
      c = '*';
#line 1335
      n = 0;
      {
#line 1335
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1335
        if (n < num_to_read) {
          {
#line 1335
          c = _IO_getc(yyin);
          }
#line 1335
          if (c != -1) {
#line 1335
            if (! (c != 10)) {
#line 1335
              goto while_break___1;
            }
          } else {
#line 1335
            goto while_break___1;
          }
        } else {
#line 1335
          goto while_break___1;
        }
#line 1335
        *((yy_current_buffer->yy_ch_buf + number_to_move) + n) = (char )c;
#line 1335
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1335
      if (c == 10) {
#line 1335
        tmp___2 = n;
#line 1335
        n ++;
#line 1335
        *((yy_current_buffer->yy_ch_buf + number_to_move) + tmp___2) = (char )c;
      }
#line 1335
      if (c == -1) {
        {
#line 1335
        tmp___3 = ferror(yyin);
        }
#line 1335
        if (tmp___3) {
          {
#line 1335
          yy_fatal_error("input in flex scanner failed");
          }
        }
      }
#line 1335
      yy_n_chars = n;
    } else {
      {
#line 1335
      tmp___4 = fread((void */* __restrict  */)(yy_current_buffer->yy_ch_buf + number_to_move),
                      (size_t )1, (size_t )num_to_read, (FILE */* __restrict  */)yyin);
#line 1335
      yy_n_chars = (int )tmp___4;
      }
#line 1335
      if (yy_n_chars == 0) {
        {
#line 1335
        tmp___5 = ferror(yyin);
        }
#line 1335
        if (tmp___5) {
          {
#line 1335
          yy_fatal_error("input in flex scanner failed");
          }
        }
      }
    }
#line 1338
    yy_current_buffer->yy_n_chars = yy_n_chars;
  }
#line 1341
  if (yy_n_chars == 0) {
#line 1343
    if (number_to_move == 0) {
      {
#line 1345
      ret_val = 1;
#line 1346
      yyrestart(yyin);
      }
    } else {
#line 1351
      ret_val = 2;
#line 1352
      yy_current_buffer->yy_buffer_status = 2;
    }
  } else {
#line 1358
    ret_val = 0;
  }
#line 1360
  yy_n_chars += number_to_move;
#line 1361
  *(yy_current_buffer->yy_ch_buf + yy_n_chars) = (char)0;
#line 1362
  *(yy_current_buffer->yy_ch_buf + (yy_n_chars + 1)) = (char)0;
#line 1364
  yytext = yy_current_buffer->yy_ch_buf + 0;
#line 1366
  return (ret_val);
}
}
#line 1372 "oidentd_cfg_scan.c"
static yy_state_type yy_get_previous_state(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  int tmp ;

  {
#line 1377
  yy_current_state = yy_start;
#line 1379
  yy_cp = yytext + 0;
  {
#line 1379
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1379
    if (! ((unsigned long )yy_cp < (unsigned long )yy_c_buf_p)) {
#line 1379
      goto while_break;
    }
#line 1381
    if (*yy_cp) {
#line 1381
      tmp = yy_ec[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 1381
      tmp = (int const   )1;
    }
#line 1381
    yy_c = (YY_CHAR )tmp;
#line 1382
    if (yy_accept[yy_current_state]) {
#line 1384
      yy_last_accepting_state = yy_current_state;
#line 1385
      yy_last_accepting_cpos = yy_cp;
    }
    {
#line 1387
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1387
      if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1387
        goto while_break___0;
      }
#line 1389
      yy_current_state = (int )yy_def[yy_current_state];
#line 1390
      if (yy_current_state >= 132) {
#line 1391
        yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1393
    yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1379
    yy_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1396
  return (yy_current_state);
}
}
#line 1407 "oidentd_cfg_scan.c"
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) 
{ 
  register int yy_is_jam ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  int tmp ;

  {
#line 1414
  yy_cp = yy_c_buf_p;
#line 1416
  yy_c = (YY_CHAR )1;
#line 1417
  if (yy_accept[yy_current_state]) {
#line 1419
    yy_last_accepting_state = yy_current_state;
#line 1420
    yy_last_accepting_cpos = yy_cp;
  }
  {
#line 1422
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1422
    if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1422
      goto while_break;
    }
#line 1424
    yy_current_state = (int )yy_def[yy_current_state];
#line 1425
    if (yy_current_state >= 132) {
#line 1426
      yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1428
  yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1429
  yy_is_jam = yy_current_state == 131;
#line 1431
  if (yy_is_jam) {
#line 1431
    tmp = 0;
  } else {
#line 1431
    tmp = yy_current_state;
  }
#line 1431
  return (tmp);
}
}
#line 1555 "oidentd_cfg_scan.c"
void yyrestart(FILE *input_file ) 
{ 


  {
#line 1561
  if (! yy_current_buffer) {
    {
#line 1562
    yy_current_buffer = yy_create_buffer(yyin, 16384);
    }
  }
  {
#line 1564
  yy_init_buffer(yy_current_buffer, input_file);
#line 1565
  yy_load_buffer_state();
  }
#line 1566
  return;
}
}
#line 1570 "oidentd_cfg_scan.c"
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer ) 
{ 


  {
#line 1576
  if ((unsigned long )yy_current_buffer == (unsigned long )new_buffer) {
#line 1577
    return;
  }
#line 1579
  if (yy_current_buffer) {
#line 1582
    *yy_c_buf_p = yy_hold_char;
#line 1583
    yy_current_buffer->yy_buf_pos = yy_c_buf_p;
#line 1584
    yy_current_buffer->yy_n_chars = yy_n_chars;
  }
  {
#line 1587
  yy_current_buffer = new_buffer;
#line 1588
  yy_load_buffer_state();
#line 1595
  yy_did_buffer_switch_on_eof = 1;
  }
#line 1596
  return;
}
}
#line 1600 "oidentd_cfg_scan.c"
void yy_load_buffer_state(void) 
{ 


  {
#line 1605
  yy_n_chars = yy_current_buffer->yy_n_chars;
#line 1606
  yy_c_buf_p = yy_current_buffer->yy_buf_pos;
#line 1606
  yytext = yy_c_buf_p;
#line 1607
  yyin = yy_current_buffer->yy_input_file;
#line 1608
  yy_hold_char = *yy_c_buf_p;
#line 1609
  return;
}
}
#line 1613 "oidentd_cfg_scan.c"
YY_BUFFER_STATE yy_create_buffer(FILE *file , int size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 1622
  tmp = yy_flex_alloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 1622
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1623
  if (! b) {
    {
#line 1624
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");
    }
  }
  {
#line 1626
  b->yy_buf_size = (yy_size_t )size;
#line 1631
  tmp___0 = yy_flex_alloc(b->yy_buf_size + 2U);
#line 1631
  b->yy_ch_buf = (char *)tmp___0;
  }
#line 1632
  if (! b->yy_ch_buf) {
    {
#line 1633
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");
    }
  }
  {
#line 1635
  b->yy_is_our_buffer = 1;
#line 1637
  yy_init_buffer(b, file);
  }
#line 1639
  return (b);
}
}
#line 1644 "oidentd_cfg_scan.c"
void yy_delete_buffer(YY_BUFFER_STATE b ) 
{ 


  {
#line 1650
  if (! b) {
#line 1651
    return;
  }
#line 1653
  if ((unsigned long )b == (unsigned long )yy_current_buffer) {
#line 1654
    yy_current_buffer = (YY_BUFFER_STATE )0;
  }
#line 1656
  if (b->yy_is_our_buffer) {
    {
#line 1657
    yy_flex_free((void *)b->yy_ch_buf);
    }
  }
  {
#line 1659
  yy_flex_free((void *)b);
  }
#line 1660
  return;
}
}
#line 1665 "oidentd_cfg_scan.c"
void yy_init_buffer(YY_BUFFER_STATE b , FILE *file ) 
{ 


  {
  {
#line 1674
  yy_flush_buffer(b);
#line 1676
  b->yy_input_file = file;
#line 1677
  b->yy_fill_buffer = 1;
#line 1683
  b->yy_is_interactive = 0;
  }
#line 1688
  return;
}
}
#line 1692 "oidentd_cfg_scan.c"
void yy_flush_buffer(YY_BUFFER_STATE b ) 
{ 


  {
#line 1699
  if (! b) {
#line 1700
    return;
  }
#line 1702
  b->yy_n_chars = 0;
#line 1708
  *(b->yy_ch_buf + 0) = (char)0;
#line 1709
  *(b->yy_ch_buf + 1) = (char)0;
#line 1711
  b->yy_buf_pos = b->yy_ch_buf + 0;
#line 1713
  b->yy_at_bol = 1;
#line 1714
  b->yy_buffer_status = 0;
#line 1716
  if ((unsigned long )b == (unsigned long )yy_current_buffer) {
    {
#line 1717
    yy_load_buffer_state();
    }
  }
#line 1718
  return;
}
}
#line 1723 "oidentd_cfg_scan.c"
YY_BUFFER_STATE yy_scan_buffer(char *base , yy_size_t size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 1732
  if (size < 2U) {
#line 1736
    return ((YY_BUFFER_STATE )0);
  } else
#line 1732
  if ((int )*(base + (size - 2U)) != 0) {
#line 1736
    return ((YY_BUFFER_STATE )0);
  } else
#line 1732
  if ((int )*(base + (size - 1U)) != 0) {
#line 1736
    return ((YY_BUFFER_STATE )0);
  }
  {
#line 1738
  tmp = yy_flex_alloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 1738
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1739
  if (! b) {
    {
#line 1740
    yy_fatal_error("out of dynamic memory in yy_scan_buffer()");
    }
  }
  {
#line 1742
  b->yy_buf_size = size - 2U;
#line 1743
  tmp___0 = base;
#line 1743
  b->yy_ch_buf = tmp___0;
#line 1743
  b->yy_buf_pos = tmp___0;
#line 1744
  b->yy_is_our_buffer = 0;
#line 1745
  b->yy_input_file = (FILE *)0;
#line 1746
  b->yy_n_chars = (int )b->yy_buf_size;
#line 1747
  b->yy_is_interactive = 0;
#line 1748
  b->yy_at_bol = 1;
#line 1749
  b->yy_fill_buffer = 0;
#line 1750
  b->yy_buffer_status = 0;
#line 1752
  yy_switch_to_buffer(b);
  }
#line 1754
  return (b);
}
}
#line 1761 "oidentd_cfg_scan.c"
YY_BUFFER_STATE yy_scan_string(char const   *yy_str ) 
{ 
  int len ;
  YY_BUFFER_STATE tmp ;

  {
#line 1768
  len = 0;
  {
#line 1768
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1768
    if (! *(yy_str + len)) {
#line 1768
      goto while_break;
    }
#line 1768
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1771
  tmp = yy_scan_bytes(yy_str, len);
  }
#line 1771
  return (tmp);
}
}
#line 1778 "oidentd_cfg_scan.c"
YY_BUFFER_STATE yy_scan_bytes(char const   *bytes , int len ) 
{ 
  YY_BUFFER_STATE b ;
  char *buf ;
  yy_size_t n ;
  int i ;
  void *tmp ;
  char tmp___0 ;

  {
  {
#line 1791
  n = (yy_size_t )(len + 2);
#line 1792
  tmp = yy_flex_alloc(n);
#line 1792
  buf = (char *)tmp;
  }
#line 1793
  if (! buf) {
    {
#line 1794
    yy_fatal_error("out of dynamic memory in yy_scan_bytes()");
    }
  }
#line 1796
  i = 0;
  {
#line 1796
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1796
    if (! (i < len)) {
#line 1796
      goto while_break;
    }
#line 1797
    *(buf + i) = (char )*(bytes + i);
#line 1796
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1799
  tmp___0 = (char)0;
#line 1799
  *(buf + (len + 1)) = tmp___0;
#line 1799
  *(buf + len) = tmp___0;
#line 1801
  b = yy_scan_buffer(buf, n);
  }
#line 1802
  if (! b) {
    {
#line 1803
    yy_fatal_error("bad buffer in yy_scan_bytes()");
    }
  }
#line 1808
  b->yy_is_our_buffer = 1;
#line 1810
  return (b);
}
}
#line 1872 "oidentd_cfg_scan.c"
static void yy_fatal_error(char const   *msg ) 
{ 


  {
  {
#line 1878
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
#line 1879
  exit(2);
  }
}
}
#line 1936 "oidentd_cfg_scan.c"
static void *yy_flex_alloc(yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 1942
  tmp = malloc((size_t )size);
  }
#line 1942
  return (tmp);
}
}
#line 1946
static void *yy_flex_realloc(void *ptr , yy_size_t size )  __attribute__((__unused__)) ;
#line 1946 "oidentd_cfg_scan.c"
static void *yy_flex_realloc(void *ptr , yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 1960
  tmp = realloc((void *)((char *)ptr), (size_t )size);
  }
#line 1960
  return (tmp);
}
}
#line 1964 "oidentd_cfg_scan.c"
static void yy_flex_free(void *ptr ) 
{ 


  {
  {
#line 1970
  free(ptr);
  }
#line 1971
  return;
}
}
#line 307 "oidentd_cfg_scan.l"
static char get_esc_char(char c ) 
{ 


  {
  {
#line 309
  if ((int )c == 110) {
#line 309
    goto case_110;
  }
#line 312
  if ((int )c == 116) {
#line 312
    goto case_116;
  }
#line 315
  if ((int )c == 114) {
#line 315
    goto case_114;
  }
#line 318
  if ((int )c == 102) {
#line 318
    goto case_102;
  }
#line 321
  if ((int )c == 98) {
#line 321
    goto case_98;
  }
#line 324
  if ((int )c == 118) {
#line 324
    goto case_118;
  }
#line 327
  if ((int )c == 97) {
#line 327
    goto case_97;
  }
#line 330
  if ((int )c == 101) {
#line 330
    goto case_101;
  }
#line 308
  goto switch_break;
  case_110: /* CIL Label */ 
#line 310
  return ((char )'\n');
  case_116: /* CIL Label */ 
#line 313
  return ((char )'\t');
  case_114: /* CIL Label */ 
#line 316
  return ((char )'\r');
  case_102: /* CIL Label */ 
#line 319
  return ((char )'\f');
  case_98: /* CIL Label */ 
#line 322
  return ((char )'\b');
  case_118: /* CIL Label */ 
#line 325
  return ((char )'\v');
  case_97: /* CIL Label */ 
#line 328
  return ((char )'\a');
  case_101: /* CIL Label */ 
#line 331
  return ((char )'\033');
  switch_break: /* CIL Label */ ;
  }
#line 334
  return (c);
}
}
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 173 "./oidentd.h"
int yyparse(void) ;
#line 27 "./oidentd_inet_util.h"
int get_port(char const   *name , in_port_t *port ) ;
#line 48 "oidentd_cfg_parse.y"
static FILE *open_user_config(struct passwd  const  *pw ) ;
#line 49
static int extract_port_range(char const   *token , struct port_range *range ) ;
#line 50
static void free_cap_entries(struct user_cap *free_cap ) ;
#line 51
static void yyerror(char const   *err ) ;
#line 53 "oidentd_cfg_parse.y"
static struct user_info *cur_user  ;
#line 54 "oidentd_cfg_parse.y"
static struct user_cap *cur_cap  ;
#line 55 "oidentd_cfg_parse.y"
list_t *pref_list  ;
#line 57 "oidentd_cfg_parse.y"
u_int16_t default_caps  ;
#line 359 "oidentd_cfg_parse.c"
static unsigned char const   yytranslate[270]  = 
#line 359 "oidentd_cfg_parse.c"
  {      (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )15, 
        (unsigned char const   )2,      (unsigned char const   )16,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )3,      (unsigned char const   )4, 
        (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )7,      (unsigned char const   )8, 
        (unsigned char const   )9,      (unsigned char const   )10,      (unsigned char const   )11,      (unsigned char const   )12, 
        (unsigned char const   )13,      (unsigned char const   )14};
#line 459 "oidentd_cfg_parse.c"
static unsigned char const   yyr1[46]  = 
#line 459
  {      (unsigned char const   )0,      (unsigned char const   )17,      (unsigned char const   )18,      (unsigned char const   )18, 
        (unsigned char const   )19,      (unsigned char const   )20,      (unsigned char const   )19,      (unsigned char const   )21, 
        (unsigned char const   )21,      (unsigned char const   )23,      (unsigned char const   )22,      (unsigned char const   )25, 
        (unsigned char const   )24,      (unsigned char const   )26,      (unsigned char const   )26,      (unsigned char const   )28, 
        (unsigned char const   )27,      (unsigned char const   )29,      (unsigned char const   )29,      (unsigned char const   )29, 
        (unsigned char const   )29,      (unsigned char const   )30,      (unsigned char const   )30,      (unsigned char const   )30, 
        (unsigned char const   )31,      (unsigned char const   )31,      (unsigned char const   )31,      (unsigned char const   )32, 
        (unsigned char const   )33,      (unsigned char const   )34,      (unsigned char const   )35,      (unsigned char const   )36, 
        (unsigned char const   )36,      (unsigned char const   )37,      (unsigned char const   )37,      (unsigned char const   )38, 
        (unsigned char const   )38,      (unsigned char const   )38,      (unsigned char const   )39,      (unsigned char const   )39, 
        (unsigned char const   )39,      (unsigned char const   )39,      (unsigned char const   )40,      (unsigned char const   )40, 
        (unsigned char const   )41,      (unsigned char const   )41};
#line 469 "oidentd_cfg_parse.c"
static unsigned char const   yyr2[46]  = 
#line 469
  {      (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )2, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )5,      (unsigned char const   )0, 
        (unsigned char const   )6,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )5,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )2, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )1, 
        (unsigned char const   )2,      (unsigned char const   )3,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )4,      (unsigned char const   )5,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )1,      (unsigned char const   )1};
#line 481 "oidentd_cfg_parse.c"
static unsigned char const   yydefact[85]  = 
#line 481
  {      (unsigned char const   )2,      (unsigned char const   )5,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )9,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )4, 
        (unsigned char const   )8,      (unsigned char const   )7,      (unsigned char const   )11,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )24, 
        (unsigned char const   )25,      (unsigned char const   )21,      (unsigned char const   )22,      (unsigned char const   )6, 
        (unsigned char const   )0,      (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )29, 
        (unsigned char const   )27,      (unsigned char const   )28,      (unsigned char const   )30,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )26,      (unsigned char const   )23, 
        (unsigned char const   )15,      (unsigned char const   )15,      (unsigned char const   )13,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )44,      (unsigned char const   )45,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )15, 
        (unsigned char const   )10,      (unsigned char const   )14,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )42,      (unsigned char const   )43, 
        (unsigned char const   )38,      (unsigned char const   )40,      (unsigned char const   )39,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )41,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )36,      (unsigned char const   )31,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )35, 
        (unsigned char const   )37,      (unsigned char const   )17,      (unsigned char const   )32,      (unsigned char const   )34, 
        (unsigned char const   )19,      (unsigned char const   )18,      (unsigned char const   )0,      (unsigned char const   )33, 
        (unsigned char const   )20};
#line 495 "oidentd_cfg_parse.c"
static yysigned_char const   yydefgoto[25]  = 
#line 495
  {      (yysigned_char const   )-1,      (yysigned_char const   )1,      (yysigned_char const   )5,      (yysigned_char const   )6, 
        (yysigned_char const   )7,      (yysigned_char const   )8,      (yysigned_char const   )11,      (yysigned_char const   )9, 
        (yysigned_char const   )24,      (yysigned_char const   )37,      (yysigned_char const   )38,      (yysigned_char const   )39, 
        (yysigned_char const   )51,      (yysigned_char const   )17,      (yysigned_char const   )18,      (yysigned_char const   )19, 
        (yysigned_char const   )20,      (yysigned_char const   )21,      (yysigned_char const   )22,      (yysigned_char const   )68, 
        (yysigned_char const   )69,      (yysigned_char const   )70,      (yysigned_char const   )23,      (yysigned_char const   )42, 
        (yysigned_char const   )43};
#line 505 "oidentd_cfg_parse.c"
static yysigned_char const   yypact[85]  = 
#line 505
  {      (yysigned_char const   )-66,      (yysigned_char const   )49,      (yysigned_char const   )-66,      (yysigned_char const   )-5, 
        (yysigned_char const   )-66,      (yysigned_char const   )-66,      (yysigned_char const   )39,      (yysigned_char const   )-66, 
        (yysigned_char const   )-66,      (yysigned_char const   )-66,      (yysigned_char const   )-66,      (yysigned_char const   )-3, 
        (yysigned_char const   )11,      (yysigned_char const   )25,      (yysigned_char const   )36,      (yysigned_char const   )37, 
        (yysigned_char const   )48,      (yysigned_char const   )19,      (yysigned_char const   )4,      (yysigned_char const   )51, 
        (yysigned_char const   )-66,      (yysigned_char const   )18,      (yysigned_char const   )-66,      (yysigned_char const   )-66, 
        (yysigned_char const   )46,      (yysigned_char const   )-66,      (yysigned_char const   )43,      (yysigned_char const   )-66, 
        (yysigned_char const   )-66,      (yysigned_char const   )-66,      (yysigned_char const   )-66,      (yysigned_char const   )43, 
        (yysigned_char const   )43,      (yysigned_char const   )50,      (yysigned_char const   )-66,      (yysigned_char const   )-66, 
        (yysigned_char const   )-66,      (yysigned_char const   )52,      (yysigned_char const   )-66,      (yysigned_char const   )34, 
        (yysigned_char const   )53,      (yysigned_char const   )-66,      (yysigned_char const   )55,      (yysigned_char const   )54, 
        (yysigned_char const   )56,      (yysigned_char const   )57,      (yysigned_char const   )43,      (yysigned_char const   )58, 
        (yysigned_char const   )-66,      (yysigned_char const   )-66,      (yysigned_char const   )60,      (yysigned_char const   )-66, 
        (yysigned_char const   )61,      (yysigned_char const   )5,      (yysigned_char const   )-66,      (yysigned_char const   )-66, 
        (yysigned_char const   )-66,      (yysigned_char const   )-66,      (yysigned_char const   )-66,      (yysigned_char const   )62, 
        (yysigned_char const   )-66,      (yysigned_char const   )45,      (yysigned_char const   )45,      (yysigned_char const   )45, 
        (yysigned_char const   )64,      (yysigned_char const   )-66,      (yysigned_char const   )47,      (yysigned_char const   )67, 
        (yysigned_char const   )12,      (yysigned_char const   )63,      (yysigned_char const   )-66,      (yysigned_char const   )13, 
        (yysigned_char const   )20,      (yysigned_char const   )45,      (yysigned_char const   )68,      (yysigned_char const   )-66, 
        (yysigned_char const   )-66,      (yysigned_char const   )-66,      (yysigned_char const   )-66,      (yysigned_char const   )-66, 
        (yysigned_char const   )-66,      (yysigned_char const   )-66,      (yysigned_char const   )21,      (yysigned_char const   )-66, 
        (yysigned_char const   )-66};
#line 519 "oidentd_cfg_parse.c"
static yysigned_char const   yypgoto[25]  = 
#line 519
  {      (yysigned_char const   )-66,      (yysigned_char const   )-66,      (yysigned_char const   )-66,      (yysigned_char const   )-66, 
        (yysigned_char const   )-66,      (yysigned_char const   )-66,      (yysigned_char const   )-66,      (yysigned_char const   )-66, 
        (yysigned_char const   )-66,      (yysigned_char const   )27,      (yysigned_char const   )-29,      (yysigned_char const   )-66, 
        (yysigned_char const   )-66,      (yysigned_char const   )-18,      (yysigned_char const   )32,      (yysigned_char const   )-66, 
        (yysigned_char const   )65,      (yysigned_char const   )-66,      (yysigned_char const   )66,      (yysigned_char const   )-58, 
        (yysigned_char const   )-66,      (yysigned_char const   )-65,      (yysigned_char const   )-66,      (yysigned_char const   )-66, 
        (yysigned_char const   )-30};
#line 531 "oidentd_cfg_parse.c"
static unsigned char const   yytable[88]  = 
#line 531
  {      (unsigned char const   )33,      (unsigned char const   )44,      (unsigned char const   )45,      (unsigned char const   )78, 
        (unsigned char const   )71,      (unsigned char const   )72,      (unsigned char const   )78,      (unsigned char const   )78, 
        (unsigned char const   )49,      (unsigned char const   )10,      (unsigned char const   )13,      (unsigned char const   )13, 
        (unsigned char const   )25,      (unsigned char const   )16,      (unsigned char const   )16,      (unsigned char const   )82, 
        (unsigned char const   )59,      (unsigned char const   )78,      (unsigned char const   )49,      (unsigned char const   )32, 
        (unsigned char const   )63,      (unsigned char const   )52,      (unsigned char const   )66,      (unsigned char const   )66, 
        (unsigned char const   )67,      (unsigned char const   )67,      (unsigned char const   )26,      (unsigned char const   )16, 
        (unsigned char const   )77,      (unsigned char const   )80,      (unsigned char const   )66,      (unsigned char const   )66, 
        (unsigned char const   )67,      (unsigned char const   )67,      (unsigned char const   )31,      (unsigned char const   )64, 
        (unsigned char const   )81,      (unsigned char const   )84,      (unsigned char const   )50,      (unsigned char const   )27, 
        (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )15,      (unsigned char const   )16, 
        (unsigned char const   )12,      (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )15, 
        (unsigned char const   )16,      (unsigned char const   )2,      (unsigned char const   )28,      (unsigned char const   )29, 
        (unsigned char const   )3,      (unsigned char const   )4,      (unsigned char const   )40,      (unsigned char const   )66, 
        (unsigned char const   )41,      (unsigned char const   )67,      (unsigned char const   )74,      (unsigned char const   )15, 
        (unsigned char const   )75,      (unsigned char const   )36,      (unsigned char const   )30,      (unsigned char const   )47, 
        (unsigned char const   )0,      (unsigned char const   )46,      (unsigned char const   )0,      (unsigned char const   )54, 
        (unsigned char const   )48,      (unsigned char const   )55,      (unsigned char const   )56,      (unsigned char const   )53, 
        (unsigned char const   )57,      (unsigned char const   )58,      (unsigned char const   )60,      (unsigned char const   )61, 
        (unsigned char const   )62,      (unsigned char const   )79,      (unsigned char const   )65,      (unsigned char const   )73, 
        (unsigned char const   )76,      (unsigned char const   )0,      (unsigned char const   )83,      (unsigned char const   )0, 
        (unsigned char const   )34,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )35};
#line 544 "oidentd_cfg_parse.c"
static yysigned_char const   yycheck[88]  = 
#line 544
  {      (yysigned_char const   )18,      (yysigned_char const   )31,      (yysigned_char const   )32,      (yysigned_char const   )68, 
        (yysigned_char const   )62,      (yysigned_char const   )63,      (yysigned_char const   )71,      (yysigned_char const   )72, 
        (yysigned_char const   )37,      (yysigned_char const   )14,      (yysigned_char const   )6,      (yysigned_char const   )6, 
        (yysigned_char const   )15,      (yysigned_char const   )9,      (yysigned_char const   )9,      (yysigned_char const   )73, 
        (yysigned_char const   )46,      (yysigned_char const   )82,      (yysigned_char const   )47,      (yysigned_char const   )15, 
        (yysigned_char const   )15,      (yysigned_char const   )39,      (yysigned_char const   )10,      (yysigned_char const   )10, 
        (yysigned_char const   )12,      (yysigned_char const   )12,      (yysigned_char const   )15,      (yysigned_char const   )9, 
        (yysigned_char const   )16,      (yysigned_char const   )16,      (yysigned_char const   )10,      (yysigned_char const   )10, 
        (yysigned_char const   )12,      (yysigned_char const   )12,      (yysigned_char const   )15,      (yysigned_char const   )53, 
        (yysigned_char const   )16,      (yysigned_char const   )16,      (yysigned_char const   )4,      (yysigned_char const   )14, 
        (yysigned_char const   )6,      (yysigned_char const   )7,      (yysigned_char const   )8,      (yysigned_char const   )9, 
        (yysigned_char const   )5,      (yysigned_char const   )6,      (yysigned_char const   )7,      (yysigned_char const   )8, 
        (yysigned_char const   )9,      (yysigned_char const   )0,      (yysigned_char const   )14,      (yysigned_char const   )14, 
        (yysigned_char const   )3,      (yysigned_char const   )4,      (yysigned_char const   )11,      (yysigned_char const   )10, 
        (yysigned_char const   )13,      (yysigned_char const   )12,      (yysigned_char const   )11,      (yysigned_char const   )8, 
        (yysigned_char const   )13,      (yysigned_char const   )15,      (yysigned_char const   )14,      (yysigned_char const   )36, 
        (yysigned_char const   )-1,      (yysigned_char const   )15,      (yysigned_char const   )-1,      (yysigned_char const   )14, 
        (yysigned_char const   )16,      (yysigned_char const   )14,      (yysigned_char const   )16,      (yysigned_char const   )39, 
        (yysigned_char const   )16,      (yysigned_char const   )16,      (yysigned_char const   )16,      (yysigned_char const   )15, 
        (yysigned_char const   )15,      (yysigned_char const   )14,      (yysigned_char const   )16,      (yysigned_char const   )15, 
        (yysigned_char const   )13,      (yysigned_char const   )-1,      (yysigned_char const   )14,      (yysigned_char const   )-1, 
        (yysigned_char const   )19,      (yysigned_char const   )-1,      (yysigned_char const   )-1,      (yysigned_char const   )21};
#line 559 "oidentd_cfg_parse.c"
static unsigned char const   yystos[85]  = 
#line 559
  {      (unsigned char const   )0,      (unsigned char const   )18,      (unsigned char const   )0,      (unsigned char const   )3, 
        (unsigned char const   )4,      (unsigned char const   )19,      (unsigned char const   )20,      (unsigned char const   )21, 
        (unsigned char const   )22,      (unsigned char const   )24,      (unsigned char const   )14,      (unsigned char const   )23, 
        (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )7,      (unsigned char const   )8, 
        (unsigned char const   )9,      (unsigned char const   )30,      (unsigned char const   )31,      (unsigned char const   )32, 
        (unsigned char const   )33,      (unsigned char const   )34,      (unsigned char const   )35,      (unsigned char const   )39, 
        (unsigned char const   )25,      (unsigned char const   )15,      (unsigned char const   )15,      (unsigned char const   )14, 
        (unsigned char const   )14,      (unsigned char const   )14,      (unsigned char const   )14,      (unsigned char const   )15, 
        (unsigned char const   )15,      (unsigned char const   )30,      (unsigned char const   )33,      (unsigned char const   )35, 
        (unsigned char const   )15,      (unsigned char const   )26,      (unsigned char const   )27,      (unsigned char const   )28, 
        (unsigned char const   )11,      (unsigned char const   )13,      (unsigned char const   )40,      (unsigned char const   )41, 
        (unsigned char const   )41,      (unsigned char const   )41,      (unsigned char const   )15,      (unsigned char const   )26, 
        (unsigned char const   )16,      (unsigned char const   )27,      (unsigned char const   )4,      (unsigned char const   )29, 
        (unsigned char const   )30,      (unsigned char const   )31,      (unsigned char const   )14,      (unsigned char const   )14, 
        (unsigned char const   )16,      (unsigned char const   )16,      (unsigned char const   )16,      (unsigned char const   )41, 
        (unsigned char const   )16,      (unsigned char const   )15,      (unsigned char const   )15,      (unsigned char const   )15, 
        (unsigned char const   )30,      (unsigned char const   )16,      (unsigned char const   )10,      (unsigned char const   )12, 
        (unsigned char const   )36,      (unsigned char const   )37,      (unsigned char const   )38,      (unsigned char const   )36, 
        (unsigned char const   )36,      (unsigned char const   )15,      (unsigned char const   )11,      (unsigned char const   )13, 
        (unsigned char const   )13,      (unsigned char const   )16,      (unsigned char const   )38,      (unsigned char const   )14, 
        (unsigned char const   )16,      (unsigned char const   )16,      (unsigned char const   )36,      (unsigned char const   )14, 
        (unsigned char const   )16};
#line 919 "oidentd_cfg_parse.c"
static void yydestruct(char const   *yymsg , int yytype , YYSTYPE *yyvaluep ) 
{ 


  {
#line 932
  if (! yymsg) {
#line 933
    yymsg = "Deleting";
  }
  {
#line 939
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 940
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 942
  return;
}
}
#line 964 "oidentd_cfg_parse.c"
int yychar  ;
#line 967 "oidentd_cfg_parse.c"
YYSTYPE yylval  ;
#line 970 "oidentd_cfg_parse.c"
int yynerrs  ;
#line 987 "oidentd_cfg_parse.c"
int yyparse(void) 
{ 
  int yystate ;
  int yyn ;
  int yyresult ;
  int yyerrstatus ;
  int yytoken ;
  short yyssa[200] ;
  short *yyss ;
  short *yyssp ;
  YYSTYPE yyvsa[200] ;
  YYSTYPE *yyvs ;
  YYSTYPE *yyvsp ;
  unsigned long yystacksize ;
  YYSTYPE yyval ;
  int yylen ;
  unsigned long yysize ;
  short *yyss1 ;
  union yyalloc *yyptr ;
  void *tmp ;
  unsigned long yynewbytes ;
  unsigned long yynewbytes___0 ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  struct user_info *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  void *tmp___10 ;
  int tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;

  {
#line 1003
  yytoken = 0;
#line 1015
  yyss = yyssa;
#line 1020
  yyvs = yyvsa;
#line 1027
  yystacksize = 200UL;
#line 1040
  yystate = 0;
#line 1041
  yyerrstatus = 0;
#line 1042
  yynerrs = 0;
#line 1043
  yychar = -2;
#line 1050
  yyssp = yyss;
#line 1051
  yyvsp = yyvs;
#line 1053
  goto yysetstate;
  yynewstate: 
#line 1062
  yyssp ++;
  yysetstate: 
#line 1065
  *yyssp = (short )yystate;
#line 1067
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1070
    yysize = (unsigned long )((yyssp - yyss) + 1L);
#line 1099
    if (10000UL <= yystacksize) {
#line 1100
      goto yyexhaustedlab;
    }
#line 1101
    yystacksize *= 2UL;
#line 1102
    if (10000UL < yystacksize) {
#line 1103
      yystacksize = 10000UL;
    }
    {
#line 1106
    yyss1 = yyss;
#line 1107
    tmp = malloc(yystacksize * (sizeof(short ) + sizeof(YYSTYPE )) + (sizeof(union yyalloc ) - 1UL));
#line 1107
    yyptr = (union yyalloc *)tmp;
    }
#line 1109
    if (! yyptr) {
#line 1110
      goto yyexhaustedlab;
    }
    {
#line 1111
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1111
      __builtin_memcpy((void *)(& yyptr->yyss), (void const   *)yyss, yysize * sizeof(*yyss));
#line 1111
      yyss = & yyptr->yyss;
#line 1111
      yynewbytes = yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1UL);
#line 1111
      yyptr += yynewbytes / sizeof(*yyptr);
      }
#line 1111
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1112
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1112
      __builtin_memcpy((void *)(& yyptr->yyvs), (void const   *)yyvs, yysize * sizeof(*yyvs));
#line 1112
      yyvs = & yyptr->yyvs;
#line 1112
      yynewbytes___0 = yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1UL);
#line 1112
      yyptr += yynewbytes___0 / sizeof(*yyptr);
      }
#line 1112
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1115
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
#line 1116
      free((void *)yyss1);
      }
    }
#line 1121
    yyssp = (yyss + yysize) - 1;
#line 1122
    yyvsp = (yyvs + yysize) - 1;
#line 1128
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1129
      goto yyabortlab;
    }
  }
#line 1134
  goto yybackup;
  yybackup: 
#line 1147
  yyn = (int )yypact[yystate];
#line 1148
  if (yyn == -66) {
#line 1149
    goto yydefault;
  }
#line 1154
  if (yychar == -2) {
    {
#line 1157
    yychar = yylex();
    }
  }
#line 1160
  if (yychar <= 0) {
#line 1162
    yytoken = 0;
#line 1162
    yychar = yytoken;
  } else
#line 1167
  if ((unsigned int )yychar <= 269U) {
#line 1167
    yytoken = (int )yytranslate[yychar];
  } else {
#line 1167
    yytoken = 2;
  }
#line 1173
  yyn += yytoken;
#line 1174
  if (yyn < 0) {
#line 1175
    goto yydefault;
  } else
#line 1174
  if (87 < yyn) {
#line 1175
    goto yydefault;
  } else
#line 1174
  if ((int const   )yycheck[yyn] != (int const   )yytoken) {
#line 1175
    goto yydefault;
  }
#line 1176
  yyn = (int )yytable[yyn];
#line 1177
  if (yyn <= 0) {
#line 1179
    if (yyn == 0) {
#line 1180
      goto yyerrlab;
    } else
#line 1179
    if (yyn == -1) {
#line 1180
      goto yyerrlab;
    }
#line 1181
    yyn = - yyn;
#line 1182
    goto yyreduce;
  }
#line 1185
  if (yyn == 2) {
#line 1186
    goto yyacceptlab;
  }
#line 1192
  if (yychar != 0) {
#line 1193
    yychar = -2;
  }
#line 1195
  yyvsp ++;
#line 1195
  *yyvsp = yylval;
#line 1200
  if (yyerrstatus) {
#line 1201
    yyerrstatus --;
  }
#line 1203
  yystate = yyn;
#line 1204
  goto yynewstate;
  yydefault: 
#line 1211
  yyn = (int )yydefact[yystate];
#line 1212
  if (yyn == 0) {
#line 1213
    goto yyerrlab;
  }
#line 1214
  goto yyreduce;
  yyreduce: 
#line 1222
  yylen = (int )yyr2[yyn];
#line 1232
  yyval = *(yyvsp + (1 - yylen));
  {
#line 1238
  if (yyn == 5) {
#line 1238
    goto case_5;
  }
#line 102
  if (yyn == 6) {
#line 102 "oidentd_cfg_parse.y"
    goto case_6;
  }
#line 104
  if (yyn == 9) {
#line 104
    goto case_9;
  }
#line 122
  if (yyn == 11) {
#line 122
    goto case_11;
  }
#line 152
  if (yyn == 12) {
#line 152
    goto case_12;
  }
#line 155
  if (yyn == 15) {
#line 155
    goto case_15;
  }
#line 168
  if (yyn == 16) {
#line 168
    goto case_16;
  }
#line 170
  if (yyn == 17) {
#line 170
    goto case_17;
  }
#line 177
  if (yyn == 27) {
#line 177
    goto case_27;
  }
#line 218
  if (yyn == 28) {
#line 218
    goto case_28;
  }
#line 235
  if (yyn == 29) {
#line 235
    goto case_29;
  }
#line 254
  if (yyn == 30) {
#line 254
    goto case_30;
  }
#line 271
  if (yyn == 33) {
#line 271
    goto case_33;
  }
#line 287
  if (yyn == 34) {
#line 287
    goto case_34;
  }
#line 293
  if (yyn == 35) {
#line 293
    goto case_35;
  }
#line 300
  if (yyn == 37) {
#line 300
    goto case_37;
  }
#line 311
  if (yyn == 42) {
#line 311
    goto case_42;
  }
#line 330
  if (yyn == 43) {
#line 330
    goto case_43;
  }
#line 338
  if (yyn == 44) {
#line 338
    goto case_44;
  }
#line 351
  goto switch_default;
  case_5: /* CIL Label */ 
#line 91
  if (parser_mode != 0) {
    {
#line 92
    o_log(6, "[line %d] This construct is valid only for user configuration files",
          current_line);
    }
#line 94
    goto yyabortlab;
  }
  {
#line 97
  tmp___0 = xcalloc((size_t )1, sizeof(struct user_cap ));
#line 97
  cur_cap = (struct user_cap *)tmp___0;
#line 98
  cur_cap->caps = default_caps;
  }
#line 100
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 100
  list_prepend(& pref_list, (void *)cur_cap);
  }
#line 102
  goto switch_break;
  case_9: /* CIL Label */ 
#line 112
  if (parser_mode != 1) {
#line 113
    goto yyabortlab;
  }
  {
#line 115
  tmp___1 = xmalloc(sizeof(struct user_info ));
#line 115
  cur_user = (struct user_info *)tmp___1;
#line 116
  cur_user->cap_list = (list_t *)((void *)0);
#line 118
  user_db_set_default(cur_user);
  }
#line 120
  goto switch_break;
  case_11: /* CIL Label */ 
#line 124
  if (parser_mode != 1) {
    {
#line 125
    free((void *)(yyvsp + 0)->string);
    }
#line 126
    goto yyabortlab;
  }
  {
#line 129
  tmp___2 = xmalloc(sizeof(struct user_info ));
#line 129
  cur_user = (struct user_info *)tmp___2;
#line 130
  cur_user->cap_list = (list_t *)((void *)0);
#line 132
  tmp___3 = find_user((char const   *)(yyvsp + 0)->string, & cur_user->user);
  }
#line 132
  if (tmp___3 == -1) {
    {
#line 133
    o_log(6, "[line %u] Invalid user: \"%s\"", current_line, (yyvsp + 0)->string);
#line 134
    free((void *)(yyvsp + 0)->string);
#line 135
    free_cap_entries(cur_cap);
    }
#line 136
    goto yyabortlab;
  }
  {
#line 139
  tmp___4 = user_db_lookup(cur_user->user);
  }
#line 139
  if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
    {
#line 140
    o_log(6, "[line %u] User \"%s\" already has a capability entry", current_line,
          (yyvsp + 0)->string);
#line 143
    free((void *)(yyvsp + 0)->string);
#line 144
    free_cap_entries(cur_cap);
    }
#line 145
    goto yyabortlab;
  }
  {
#line 148
  free((void *)(yyvsp + 0)->string);
  }
#line 150
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 151
  user_db_add(cur_user);
  }
#line 153
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 163
  tmp___5 = xcalloc((size_t )1, sizeof(struct user_cap ));
#line 163
  cur_cap = (struct user_cap *)tmp___5;
#line 164
  cur_cap->caps = default_caps;
  }
#line 166
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 166
  list_prepend(& cur_user->cap_list, (void *)cur_cap);
  }
#line 168
  goto switch_break;
  case_17: /* CIL Label */ 
#line 172
  if ((unsigned long )cur_user == (unsigned long )default_user) {
#line 173
    default_caps = cur_cap->caps;
  }
#line 175
  goto switch_break;
  case_27: /* CIL Label */ 
  {
#line 201
  tmp___6 = xmalloc(sizeof(struct sockaddr_storage ));
#line 201
  cur_cap->dest = (struct sockaddr_storage *)tmp___6;
#line 203
  tmp___7 = get_addr((char const   */* const  */)(yyvsp + 0)->string, cur_cap->dest);
  }
#line 203
  if (tmp___7 == -1) {
#line 204
    if (parser_mode == 1) {
      {
#line 205
      o_log(6, "[line %u]: Bad address: \"%s\"", current_line, (yyvsp + 0)->string);
      }
    }
    {
#line 209
    free((void *)(yyvsp + 0)->string);
#line 210
    free_cap_entries(cur_cap);
    }
#line 211
    goto yyabortlab;
  }
  {
#line 214
  free((void *)(yyvsp + 0)->string);
  }
#line 216
  goto switch_break;
  case_28: /* CIL Label */ 
  {
#line 220
  tmp___8 = xmalloc(sizeof(struct port_range ));
#line 220
  cur_cap->fport = (struct port_range *)tmp___8;
#line 222
  tmp___9 = extract_port_range((char const   *)(yyvsp + 0)->string, cur_cap->fport);
  }
#line 222
  if (tmp___9 == -1) {
#line 223
    if (parser_mode == 1) {
      {
#line 224
      o_log(6, "[line %u] Bad port: \"%s\"", current_line, (yyvsp + 0)->string);
      }
    }
    {
#line 226
    free((void *)(yyvsp + 0)->string);
#line 227
    free_cap_entries(cur_cap);
    }
#line 228
    goto yyabortlab;
  }
  {
#line 231
  free((void *)(yyvsp + 0)->string);
  }
#line 233
  goto switch_break;
  case_29: /* CIL Label */ 
  {
#line 237
  tmp___10 = xmalloc(sizeof(struct sockaddr_storage ));
#line 237
  cur_cap->src = (struct sockaddr_storage *)tmp___10;
#line 239
  tmp___11 = get_addr((char const   */* const  */)(yyvsp + 0)->string, cur_cap->src);
  }
#line 239
  if (tmp___11 == -1) {
#line 240
    if (parser_mode == 1) {
      {
#line 241
      o_log(6, "[line %u]: Bad address: \"%s\"", current_line, (yyvsp + 0)->string);
      }
    }
    {
#line 245
    free((void *)(yyvsp + 0)->string);
#line 246
    free_cap_entries(cur_cap);
    }
#line 247
    goto yyabortlab;
  }
  {
#line 250
  free((void *)(yyvsp + 0)->string);
  }
#line 252
  goto switch_break;
  case_30: /* CIL Label */ 
  {
#line 256
  tmp___12 = xmalloc(sizeof(struct port_range ));
#line 256
  cur_cap->lport = (struct port_range *)tmp___12;
#line 258
  tmp___13 = extract_port_range((char const   *)(yyvsp + 0)->string, cur_cap->lport);
  }
#line 258
  if (tmp___13 == -1) {
#line 259
    if (parser_mode == 1) {
      {
#line 260
      o_log(6, "[line %u] Bad port: \"%s\"", current_line, (yyvsp + 0)->string);
      }
    }
    {
#line 262
    free((void *)(yyvsp + 0)->string);
#line 263
    free_cap_entries(cur_cap);
    }
#line 264
    goto yyabortlab;
  }
  {
#line 267
  free((void *)(yyvsp + 0)->string);
  }
#line 269
  goto switch_break;
  case_33: /* CIL Label */ 
  {
#line 279
  cur_cap->caps = (u_int16_t )(1 << 8);
#line 280
  cur_cap->action = (u_int16_t )3;
#line 281
  cur_cap->num_replies = (u_int8_t )((int )cur_cap->num_replies + 1);
#line 281
  tmp___14 = xrealloc((void *)cur_cap->force_data, (unsigned long )cur_cap->num_replies * sizeof(u_char *));
#line 281
  cur_cap->force_data = (char **)tmp___14;
#line 283
  *(cur_cap->force_data + ((int )cur_cap->num_replies - 1)) = (yyvsp + 0)->string;
  }
#line 285
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 287
  cur_cap->num_replies = (u_int8_t )((int )cur_cap->num_replies + 1);
#line 287
  tmp___15 = xrealloc((void *)cur_cap->force_data, (unsigned long )cur_cap->num_replies * sizeof(u_char *));
#line 287
  cur_cap->force_data = (char **)tmp___15;
#line 289
  *(cur_cap->force_data + ((int )cur_cap->num_replies - 1)) = (yyvsp + 0)->string;
  }
#line 291
  goto switch_break;
  case_35: /* CIL Label */ 
#line 295
  cur_cap->caps = (u_int16_t )(yyvsp + 0)->value;
#line 296
  cur_cap->action = (u_int16_t )3;
#line 298
  goto switch_break;
  case_37: /* CIL Label */ 
#line 302
  if ((yyvsp + -1)->value == 1) {
#line 303
    cur_cap->caps = (u_int16_t )((int )cur_cap->caps | (yyvsp + 0)->value);
  } else {
#line 305
    cur_cap->caps = (u_int16_t )((int )cur_cap->caps & ~ (yyvsp + 0)->value);
  }
#line 307
  cur_cap->action = (u_int16_t )(yyvsp + -1)->value;
#line 309
  goto switch_break;
  case_42: /* CIL Label */ 
  {
#line 323
  cur_cap->caps = (u_int16_t )(1 << 8);
#line 324
  cur_cap->num_replies = (u_int8_t )((int )cur_cap->num_replies + 1);
#line 324
  tmp___16 = xrealloc((void *)cur_cap->force_data, (unsigned long )cur_cap->num_replies * sizeof(u_char *));
#line 324
  cur_cap->force_data = (char **)tmp___16;
#line 326
  *(cur_cap->force_data + ((int )cur_cap->num_replies - 1)) = (yyvsp + 0)->string;
  }
#line 328
  goto switch_break;
  case_43: /* CIL Label */ 
#line 330
  if ((int )cur_cap->num_replies < 20) {
    {
#line 331
    cur_cap->num_replies = (u_int8_t )((int )cur_cap->num_replies + 1);
#line 331
    tmp___17 = xrealloc((void *)cur_cap->force_data, (unsigned long )cur_cap->num_replies * sizeof(u_char *));
#line 331
    cur_cap->force_data = (char **)tmp___17;
#line 333
    *(cur_cap->force_data + ((int )cur_cap->num_replies - 1)) = (yyvsp + 0)->string;
    }
  }
#line 336
  goto switch_break;
  case_44: /* CIL Label */ 
#line 340
  if ((yyvsp + 0)->value == 1 << 1) {
    {
#line 342
    free_cap_entries(cur_cap);
    }
#line 343
    goto yyabortlab;
  } else
#line 340
  if ((yyvsp + 0)->value == 1 << 2) {
    {
#line 342
    free_cap_entries(cur_cap);
    }
#line 343
    goto yyabortlab;
  } else
#line 340
  if ((yyvsp + 0)->value == 1 << 3) {
    {
#line 342
    free_cap_entries(cur_cap);
    }
#line 343
    goto yyabortlab;
  }
#line 346
  cur_cap->caps = (u_int16_t )(yyvsp + 0)->value;
#line 348
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 351
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1490 "oidentd_cfg_parse.c"
  yyvsp -= yylen;
#line 1491
  yyssp -= yylen;
#line 1496
  yyvsp ++;
#line 1496
  *yyvsp = yyval;
#line 1503
  yyn = (int )yyr1[yyn];
#line 1505
  yystate = (int )((int const   )yypgoto[yyn - 17] + (int const   )*yyssp);
#line 1506
  if (0 <= yystate) {
#line 1506
    if (yystate <= 87) {
#line 1506
      if ((int const   )yycheck[yystate] == (int const   )*yyssp) {
#line 1507
        yystate = (int )yytable[yystate];
      } else {
#line 1509
        yystate = (int )yydefgoto[yyn - 17];
      }
    } else {
#line 1509
      yystate = (int )yydefgoto[yyn - 17];
    }
  } else {
#line 1509
    yystate = (int )yydefgoto[yyn - 17];
  }
#line 1511
  goto yynewstate;
  yyerrlab: 
#line 1519
  if (! yyerrstatus) {
    {
#line 1521
    yynerrs ++;
#line 1625
    yyerror("syntax error");
    }
  }
#line 1630
  if (yyerrstatus == 3) {
#line 1635
    if (yychar <= 0) {
#line 1638
      if (yychar == 0) {
#line 1639
        goto yyabortlab;
      }
    } else {
      {
#line 1643
      yydestruct("Error: discarding", yytoken, & yylval);
#line 1644
      yychar = -2;
      }
    }
  }
#line 1650
  goto yyerrlab1;
#line 1664
  yyvsp -= yylen;
#line 1665
  yyssp -= yylen;
#line 1666
  yystate = (int )*yyssp;
#line 1667
  goto yyerrlab1;
  yyerrlab1: 
#line 1674
  yyerrstatus = 3;
  {
#line 1676
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1678
    yyn = (int )yypact[yystate];
#line 1679
    if (yyn != -66) {
#line 1681
      yyn ++;
#line 1682
      if (0 <= yyn) {
#line 1682
        if (yyn <= 87) {
#line 1682
          if ((int const   )yycheck[yyn] == 1) {
#line 1684
            yyn = (int )yytable[yyn];
#line 1685
            if (0 < yyn) {
#line 1686
              goto while_break___1;
            }
          }
        }
      }
    }
#line 1691
    if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 1692
      goto yyabortlab;
    }
    {
#line 1695
    yydestruct("Error: popping", (int )yystos[yystate], yyvsp);
#line 1696
    yyvsp --;
#line 1696
    yyssp --;
#line 1697
    yystate = (int )*yyssp;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1701
  if (yyn == 2) {
#line 1702
    goto yyacceptlab;
  }
#line 1704
  yyvsp ++;
#line 1704
  *yyvsp = yylval;
#line 1710
  yystate = yyn;
#line 1711
  goto yynewstate;
  yyacceptlab: 
#line 1718
  yyresult = 0;
#line 1719
  goto yyreturn;
  yyabortlab: 
#line 1725
  yyresult = 1;
#line 1726
  goto yyreturn;
  yyexhaustedlab: 
  {
#line 1733
  yyerror("memory exhausted");
#line 1734
  yyresult = 2;
  }
  yyreturn: 
#line 1739
  if (yychar != 0) {
#line 1739
    if (yychar != -2) {
      {
#line 1740
      yydestruct("Cleanup: discarding lookahead", yytoken, & yylval);
      }
    }
  }
  {
#line 1742
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1742
    if (! ((unsigned long )yyssp != (unsigned long )yyss)) {
#line 1742
      goto while_break___2;
    }
    {
#line 1744
    yydestruct("Cleanup: popping", (int )yystos[*yyssp], yyvsp);
#line 1746
    yyvsp --;
#line 1746
    yyssp --;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1749
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
#line 1750
    free((void *)yyss);
    }
  }
#line 1752
  return (yyresult);
}
}
#line 358 "oidentd_cfg_parse.y"
int read_config(char const   *path ) 
{ 
  FILE *fp ;
  int ret ;
  struct user_info *temp_default ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  struct user_info *temp_default___0 ;

  {
  {
#line 362
  fp = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"r");
  }
#line 363
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 364
    tmp___0 = __errno_location();
    }
#line 364
    if (*tmp___0 == 2) {
      {
#line 371
      tmp = strcmp(path, "/etc/oidentd.conf");
      }
#line 371
      if (! tmp) {
        {
#line 374
        temp_default = user_db_create_default();
#line 375
        user_db_set_default(temp_default);
        }
#line 376
        return (0);
      }
    }
    {
#line 380
    tmp___1 = __errno_location();
#line 380
    tmp___2 = strerror(*tmp___1);
#line 380
    o_log(6, "Error opening config file: %s: %s", path, tmp___2);
    }
#line 382
    return (-1);
  }
  {
#line 385
  yyrestart(fp);
#line 386
  current_line = (u_int32_t )1;
#line 387
  parser_mode = 1;
#line 388
  ret = yyparse();
#line 390
  fclose(fp);
  }
#line 396
  if ((unsigned long )default_user == (unsigned long )((void *)0)) {
    {
#line 399
    temp_default___0 = user_db_create_default();
#line 400
    user_db_set_default(temp_default___0);
    }
  }
#line 403
  return (ret);
}
}
#line 411 "oidentd_cfg_parse.y"
static FILE *open_user_config(struct passwd  const  *pw ) 
{ 
  FILE *fp ;

  {
  {
#line 414
  fp = safe_open(pw, ".oidentd.conf");
  }
#line 415
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 416
    return ((FILE *)((void *)0));
  }
  {
#line 418
  yyrestart(fp);
#line 419
  current_line = (u_int32_t )1;
#line 420
  parser_mode = 0;
  }
#line 422
  return (fp);
}
}
#line 429 "oidentd_cfg_parse.y"
list_t *user_db_get_pref_list(struct passwd  const  *pw ) 
{ 
  FILE *fp ;
  int ret ;

  {
  {
#line 433
  fp = open_user_config(pw);
  }
#line 434
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 435
    return ((list_t *)((void *)0));
  }
  {
#line 437
  cur_cap = (struct user_cap *)((void *)0);
#line 438
  pref_list = (list_t *)((void *)0);
#line 440
  ret = yyparse();
#line 441
  fclose(fp);
  }
#line 443
  if (ret != 0) {
    {
#line 444
    list_destroy(pref_list, & user_db_cap_destroy_data);
    }
#line 445
    return ((list_t *)((void *)0));
  }
#line 448
  return (pref_list);
}
}
#line 451 "oidentd_cfg_parse.y"
static void yyerror(char const   *err ) 
{ 


  {
#line 453
  if (parser_mode == 0) {
    {
#line 454
    free_cap_entries(cur_cap);
    }
  } else {
    {
#line 456
    o_log(6, "[line %u] %s", current_line, err);
    }
  }
#line 457
  return;
}
}
#line 463 "oidentd_cfg_parse.y"
static int extract_port_range(char const   *token , struct port_range *range ) 
{ 
  char *p ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 466
  p = strchr(token, ':');
  }
#line 467
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 468
    tmp = p;
#line 468
    p ++;
#line 468
    *tmp = (char )'\000';
  }
#line 470
  if ((int const   )*token == 0) {
#line 471
    range->min = (in_port_t )1;
  } else {
    {
#line 472
    tmp___0 = get_port(token, & range->min);
    }
#line 472
    if (tmp___0 == -1) {
#line 473
      return (-1);
    }
  }
#line 475
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 476
    range->max = range->min;
  } else
#line 478
  if ((int )*p == 0) {
#line 479
    range->max = (in_port_t )65535;
  } else {
    {
#line 480
    tmp___1 = get_port((char const   *)p, & range->max);
    }
#line 480
    if (tmp___1 == -1) {
#line 481
      return (-1);
    }
  }
#line 484
  return (0);
}
}
#line 487 "oidentd_cfg_parse.y"
static void free_cap_entries(struct user_cap *free_cap ) 
{ 


  {
  {
#line 488
  user_db_cap_destroy_data((void *)free_cap);
  }
#line 490
  if ((unsigned long )free_cap != (unsigned long )cur_cap) {
    {
#line 491
    free((void *)cur_cap);
    }
  }
  {
#line 493
  free((void *)free_cap);
#line 494
  free((void *)cur_user);
#line 496
  cur_cap = (struct user_cap *)((void *)0);
#line 497
  cur_user = (struct user_info *)((void *)0);
#line 498
  pref_list = (list_t *)((void *)0);
  }
#line 499
  return;
}
}
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 123 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  * __restrict  __addr ,
                                                                           socklen_t __len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 290 "/usr/include/netdb.h"
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 662
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 677
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , int __flags ) ;
#line 64 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) inet_ntop)(int __af ,
                                                                                          void const   * __restrict  __cp ,
                                                                                          char * __restrict  __buf ,
                                                                                          socklen_t __len ) ;
#line 34 "./oidentd_inet_util.h"
ssize_t sock_write(int sock , void *buf , size_t len ) ;
#line 45
void sin_setv6(struct in6_addr *sin6 , struct sockaddr_storage *ss ) ;
#line 56
__inline bool sin4_equal(struct sockaddr_storage *ss1 , struct sockaddr_storage *ss2 ) ;
#line 57
__inline bool sin6_equal(struct sockaddr_storage *ss1 , struct sockaddr_storage *ss2 ) ;
#line 45 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_inet_util.c"
static int setup_bind(struct addrinfo  const  *ai , in_port_t listen_port___0 ) ;
#line 47 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_inet_util.c"
static int setup_bind(struct addrinfo  const  *ai , in_port_t listen_port___0 ) 
{ 
  int ret ;
  int one ;
  int listenfd ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 49
  one = 1;
#line 52
  listenfd = socket((int )ai->ai_family, 1, 0);
  }
#line 53
  if (listenfd == -1) {
    {
#line 54
    tmp = __errno_location();
    }
#line 54
    if (*tmp != 97) {
      {
#line 55
      while (1) {
        while_continue: /* CIL Label */ ;
#line 55
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 56
    return (-1);
  }
  {
#line 61
  if (ai->ai_family == 10) {
#line 61
    goto case_10;
  }
#line 66
  if (ai->ai_family == 2) {
#line 66
    goto case_2;
  }
#line 59
  goto switch_break;
  case_10: /* CIL Label */ 
#line 62
  ((struct sockaddr_in6 *)ai->ai_addr)->sin6_port = listen_port___0;
#line 63
  goto switch_break;
  case_2: /* CIL Label */ 
#line 67
  ((struct sockaddr_in *)ai->ai_addr)->sin_port = listen_port___0;
#line 68
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 71
  ret = setsockopt(listenfd, 1, 2, (void const   *)(& one), (socklen_t )sizeof(one));
  }
#line 72
  if (ret != 0) {
    {
#line 73
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 73
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 74
    return (-1);
  }
  {
#line 77
  ret = bind(listenfd, (struct sockaddr  const  */* __restrict  */)ai->ai_addr, (socklen_t )ai->ai_addrlen);
  }
#line 78
  if (ret != 0) {
    {
#line 79
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 79
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 80
    return (-1);
  }
  {
#line 83
  tmp___0 = listen(listenfd, 128);
  }
#line 83
  if (tmp___0 != 0) {
    {
#line 84
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 84
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 85
    return (-1);
  }
#line 88
  return (listenfd);
}
}
#line 95 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_inet_util.c"
int *setup_listen(struct sockaddr_storage *listen_addr , in_port_t listen_port___0 ) 
{ 
  int ret ;
  int *bound_fds ;
  u_char listen_port_str[64] ;
  struct addrinfo hints ;
  struct addrinfo *res ;
  struct addrinfo *cur ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  size_t bound_addr ;
  size_t fdlen ;
  void *tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;

  {
#line 101
  if ((unsigned long )listen_addr != (unsigned long )((void *)0)) {
    {
#line 102
    tmp = xcalloc((size_t )1, sizeof(struct addrinfo ));
#line 102
    cur = (struct addrinfo *)tmp;
#line 104
    cur->ai_family = (int )listen_addr->ss_family;
    }
    {
#line 108
    if (cur->ai_family == 10) {
#line 108
      goto case_10;
    }
#line 112
    if (cur->ai_family == 2) {
#line 112
      goto case_2;
    }
#line 106
    goto switch_break;
    case_10: /* CIL Label */ 
#line 109
    cur->ai_addrlen = (socklen_t )sizeof(struct sockaddr_in6 );
#line 110
    goto switch_break;
    case_2: /* CIL Label */ 
#line 113
    cur->ai_addrlen = (socklen_t )sizeof(struct sockaddr_in );
#line 114
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 117
    tmp___0 = xmalloc((size_t )cur->ai_addrlen);
#line 117
    cur->ai_addr = (struct sockaddr *)tmp___0;
#line 118
    memcpy((void */* __restrict  */)cur->ai_addr, (void const   */* __restrict  */)listen_addr,
           (size_t )cur->ai_addrlen);
#line 120
    ret = setup_bind((struct addrinfo  const  *)cur, listen_port___0);
#line 121
    free((void *)cur->ai_addr);
#line 122
    free((void *)cur);
#line 123
    free((void *)listen_addr);
    }
#line 125
    if (ret == -1) {
#line 126
      return ((int *)((void *)0));
    }
    {
#line 128
    tmp___1 = xmalloc(2UL * sizeof(int ));
#line 128
    bound_fds = (int *)tmp___1;
#line 129
    *(bound_fds + 0) = ret;
#line 130
    *(bound_fds + 1) = -1;
    }
#line 132
    return (bound_fds);
  }
  {
#line 135
  memset((void *)(& hints), 0, sizeof(hints));
#line 136
  hints.ai_family = 0;
#line 137
  hints.ai_flags = 1;
#line 138
  hints.ai_socktype = 1;
#line 140
  snprintf((char */* __restrict  */)(listen_port_str), sizeof(listen_port_str), (char const   */* __restrict  */)"%d",
           (int )listen_port___0);
#line 142
  ret = getaddrinfo((char const   */* __restrict  */)((void *)0), (char const   */* __restrict  */)(listen_port_str),
                    (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& res));
  }
#line 143
  if (ret != 0) {
    {
#line 144
    while (1) {
      while_continue: /* CIL Label */ ;
#line 144
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 145
    return ((int *)((void *)0));
  }
#line 148
  cur = res;
#line 149
  if ((unsigned long )cur != (unsigned long )((void *)0)) {
    {
#line 150
    bound_addr = (size_t )0;
#line 151
    fdlen = (size_t )4;
#line 153
    tmp___2 = xmalloc(fdlen * sizeof(int ));
#line 153
    bound_fds = (int *)tmp___2;
    }
    {
#line 155
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 156
      ret = setup_bind((struct addrinfo  const  *)cur, listen_port___0);
      }
#line 157
      if (ret == -1) {
#line 158
        goto bind_next;
      }
#line 160
      if (bound_addr >= fdlen - 1UL) {
        {
#line 161
        fdlen += 4UL;
#line 162
        tmp___3 = xrealloc((void *)bound_fds, fdlen * sizeof(int ));
#line 162
        bound_fds = (int *)tmp___3;
        }
      }
#line 165
      tmp___4 = bound_addr;
#line 165
      bound_addr ++;
#line 165
      *(bound_fds + tmp___4) = ret;
      bind_next: 
#line 168
      cur = cur->ai_next;
#line 155
      if (! ((unsigned long )cur != (unsigned long )((void *)0))) {
#line 155
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 171
    tmp___5 = bound_addr;
#line 171
    bound_addr ++;
#line 171
    *(bound_fds + tmp___5) = -1;
#line 172
    tmp___6 = xrealloc((void *)bound_fds, bound_addr * sizeof(int ));
#line 172
    bound_fds = (int *)tmp___6;
#line 173
    freeaddrinfo(res);
    }
  } else {
#line 175
    return ((int *)((void *)0));
  }
#line 177
  return (bound_fds);
}
}
#line 184 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_inet_util.c"
ssize_t sock_read(int sock , char *buf , size_t len ) 
{ 
  char c ;
  size_t i ;
  ssize_t ret ;
  char *tmp ;
  int *tmp___0 ;

  {
#line 189
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 190
    return ((ssize_t )-1);
  }
#line 192
  i = (size_t )1;
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 192
    if (! (i < len)) {
#line 192
      goto while_break;
    }
    top: 
    {
#line 194
    ret = read(sock, (void *)(& c), (size_t )1);
    }
#line 195
    if (ret == 1L) {
#line 196
      tmp = buf;
#line 196
      buf ++;
#line 196
      *tmp = c;
#line 197
      if ((int )c == 10) {
#line 198
        goto while_break;
      }
    } else
#line 199
    if (ret == 0L) {
#line 200
      if (i == 1UL) {
#line 201
        return ((ssize_t )0);
      } else {
#line 203
        goto while_break;
      }
    } else {
      {
#line 205
      tmp___0 = __errno_location();
      }
#line 205
      if (*tmp___0 == 4) {
#line 206
        goto top;
      }
#line 208
      return ((ssize_t )-1);
    }
#line 192
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 212
  *buf = (char )'\000';
#line 213
  return ((ssize_t )i);
}
}
#line 221 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_inet_util.c"
ssize_t sock_write(int sock , void *buf , size_t len ) 
{ 
  ssize_t n ;
  ssize_t written ;
  int *tmp ;

  {
#line 222
  written = (ssize_t )0;
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 224
    if (! (len > 0UL)) {
#line 224
      goto while_break;
    }
    {
#line 225
    n = write(sock, (void const   *)buf, len);
    }
#line 226
    if (n == -1L) {
      {
#line 227
      tmp = __errno_location();
      }
#line 227
      if (*tmp == 4) {
#line 228
        goto while_continue;
      }
#line 229
      return ((ssize_t )-1);
    }
#line 232
    written += n;
#line 233
    len -= (size_t )n;
#line 234
    buf = (void *)((char *)buf + n);
  }
  while_break: /* CIL Label */ ;
  }
#line 237
  return (written);
}
}
#line 244 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_inet_util.c"
int ( /* format attribute */  sockprintf)(int fd , char const   *fmt  , ...) 
{ 
  va_list ap ;
  char *buf ;
  ssize_t ret ;
  int tmp ;

  {
  {
#line 249
  __builtin_va_start(ap, fmt);
#line 250
  tmp = vasprintf((char **/* __restrict  */)(& buf), (char const   */* __restrict  */)fmt,
                  ap);
#line 250
  ret = (ssize_t )tmp;
#line 251
  __builtin_va_end(ap);
#line 253
  ret = sock_write(fd, (void *)buf, (size_t )ret);
#line 254
  free((void *)buf);
  }
#line 256
  return ((int )ret);
}
}
#line 263 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_inet_util.c"
int get_hostname(struct sockaddr_storage *addr___0 , char *hostbuf , size_t len ) 
{ 
  int ret ;

  {
  {
#line 269
  ret = getnameinfo((struct sockaddr  const  */* __restrict  */)((struct sockaddr *)addr___0),
                    (socklen_t )sizeof(struct sockaddr_storage ), (char */* __restrict  */)hostbuf,
                    (socklen_t )len, (char */* __restrict  */)((void *)0), (socklen_t )0,
                    8);
  }
#line 272
  return (ret);
}
}
#line 279 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_inet_util.c"
int get_port(char const   *name , in_port_t *port ) 
{ 
  struct servent *servent ;
  char *end ;
  long temp_port ;

  {
  {
#line 282
  servent = getservbyname(name, "tcp");
  }
#line 283
  if ((unsigned long )servent != (unsigned long )((void *)0)) {
    {
#line 284
    *port = ntohs((uint16_t )servent->s_port);
    }
  } else {
    {
#line 289
    temp_port = strtol((char const   */* __restrict  */)name, (char **/* __restrict  */)(& end),
                       10);
    }
#line 291
    if ((int )*end != 0) {
#line 292
      return (-1);
    }
#line 294
    if (temp_port >= 1L) {
#line 294
      if (! ((temp_port & 65535L) == temp_port)) {
#line 295
        return (-1);
      }
    } else {
#line 295
      return (-1);
    }
#line 297
    *port = (in_port_t )temp_port;
  }
#line 300
  return (0);
}
}
#line 307 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_inet_util.c"
int get_addr(char const   * const  hostname , struct sockaddr_storage *addr___0 ) 
{ 
  struct addrinfo *res ;
  size_t len ;
  int tmp ;

  {
  {
#line 311
  tmp = getaddrinfo((char const   */* __restrict  */)hostname, (char const   */* __restrict  */)((void *)0),
                    (struct addrinfo  const  */* __restrict  */)((void *)0), (struct addrinfo **/* __restrict  */)(& res));
  }
#line 311
  if (tmp != 0) {
#line 312
    return (-1);
  }
  {
#line 315
  if ((int )(res->ai_addr)->sa_family == 2) {
#line 315
    goto case_2;
  }
#line 319
  if ((int )(res->ai_addr)->sa_family == 10) {
#line 319
    goto case_10;
  }
#line 323
  goto switch_default;
  case_2: /* CIL Label */ 
#line 316
  len = sizeof(struct sockaddr_in );
#line 317
  goto switch_break;
  case_10: /* CIL Label */ 
#line 320
  len = sizeof(struct sockaddr_in6 );
#line 321
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 324
  goto out_fail;
  switch_break: /* CIL Label */ ;
  }
#line 327
  if (len < (size_t )res->ai_addrlen) {
#line 328
    goto out_fail;
  }
  {
#line 330
  memcpy((void */* __restrict  */)addr___0, (void const   */* __restrict  */)res->ai_addr,
         (size_t )res->ai_addrlen);
#line 331
  freeaddrinfo(res);
  }
#line 333
  return (0);
  out_fail: 
  {
#line 336
  freeaddrinfo(res);
  }
#line 337
  return (-1);
}
}
#line 345 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_inet_util.c"
void *sin_addr(struct sockaddr_storage *ss ) 
{ 


  {
#line 347
  if ((int )ss->ss_family == 10) {
#line 348
    return ((void *)(& ((struct sockaddr_in6 *)ss)->sin6_addr));
  }
#line 351
  return ((void *)(& ((struct sockaddr_in *)ss)->sin_addr));
}
}
#line 358 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_inet_util.c"
void get_ip(struct sockaddr_storage *ss , char *buf , size_t len ) 
{ 
  void *tmp ;

  {
  {
#line 362
  tmp = sin_addr(ss);
#line 362
  inet_ntop((int )ss->ss_family, (void const   */* __restrict  */)tmp, (char */* __restrict  */)buf,
            (socklen_t )len);
  }
#line 363
  return;
}
}
#line 370 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_inet_util.c"
__inline bool sin4_equal(struct sockaddr_storage *ss1 , struct sockaddr_storage *ss2 ) 
{ 


  {
#line 373
  if (((struct sockaddr_in *)ss1)->sin_addr.s_addr == ((struct sockaddr_in *)ss2)->sin_addr.s_addr) {
#line 374
    return ((bool )1);
  }
#line 376
  return ((bool )0);
}
}
#line 384 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_inet_util.c"
void sin_setv4(in_addr_t addr___0 , struct sockaddr_storage *ss ) 
{ 


  {
  {
#line 385
  memset((void *)ss, 0, sizeof(struct sockaddr_storage ));
#line 386
  ss->ss_family = (sa_family_t )2;
#line 387
  memcpy((void */* __restrict  */)(& ((struct sockaddr_in *)ss)->sin_addr), (void const   */* __restrict  */)(& addr___0),
         sizeof(struct sockaddr_in ));
  }
#line 388
  return;
}
}
#line 392 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_inet_util.c"
__inline bool sin6_equal(struct sockaddr_storage *ss1 , struct sockaddr_storage *ss2 ) 
{ 
  struct in6_addr  const  *__a ;
  struct in6_addr  const  *__b ;
  int tmp ;

  {
#line 395
  __a = (struct in6_addr  const  *)(& ((struct sockaddr_in6 *)ss1)->sin6_addr);
#line 395
  __b = (struct in6_addr  const  *)(& ((struct sockaddr_in6 *)ss2)->sin6_addr);
#line 395
  if (__a->__in6_u.__u6_addr32[0] == __b->__in6_u.__u6_addr32[0]) {
#line 395
    if (__a->__in6_u.__u6_addr32[1] == __b->__in6_u.__u6_addr32[1]) {
#line 395
      if (__a->__in6_u.__u6_addr32[2] == __b->__in6_u.__u6_addr32[2]) {
#line 395
        if (__a->__in6_u.__u6_addr32[3] == __b->__in6_u.__u6_addr32[3]) {
#line 395
          tmp = 1;
        } else {
#line 395
          tmp = 0;
        }
      } else {
#line 395
        tmp = 0;
      }
    } else {
#line 395
      tmp = 0;
    }
  } else {
#line 395
    tmp = 0;
  }
#line 395
  return ((bool )tmp);
}
}
#line 403 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_inet_util.c"
void sin_setv6(struct in6_addr *sin6 , struct sockaddr_storage *ss ) 
{ 


  {
  {
#line 404
  memset((void *)ss, 0, sizeof(struct sockaddr_storage ));
#line 405
  ss->ss_family = (sa_family_t )10;
#line 406
  memcpy((void */* __restrict  */)(& ((struct sockaddr_in6 *)ss)->sin6_addr), (void const   */* __restrict  */)sin6,
         sizeof(struct sockaddr_in6 ));
  }
#line 407
  return;
}
}
#line 415 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_inet_util.c"
size_t sin_len(struct sockaddr_storage  const  *ss  __attribute__((__unused__)) ) 
{ 


  {
#line 417
  if ((int const   )ss->ss_family == 10) {
#line 418
    return (sizeof(struct sockaddr_in6 ));
  }
#line 421
  return (sizeof(struct sockaddr_in ));
}
}
#line 429 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_inet_util.c"
size_t sin_addr_len(struct sockaddr_storage  const  *ss  __attribute__((__unused__)) ) 
{ 


  {
#line 431
  if ((int const   )ss->ss_family == 10) {
#line 432
    return (sizeof(struct in6_addr ));
  }
#line 435
  return (sizeof(struct in_addr ));
}
}
#line 442 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_inet_util.c"
void sin_copy(struct sockaddr_storage *ss1 , struct sockaddr_storage  const  *ss2 ) 
{ 
  size_t tmp ;

  {
  {
#line 445
  memset((void *)ss1, 0, sizeof(struct sockaddr_storage ));
#line 446
  tmp = sin_len(ss2);
#line 446
  memcpy((void */* __restrict  */)ss1, (void const   */* __restrict  */)ss2, tmp);
  }
#line 447
  return;
}
}
#line 453 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_inet_util.c"
in_port_t sin_port(struct sockaddr_storage  const  *ss ) 
{ 


  {
#line 455
  if ((int const   )ss->ss_family == 10) {
#line 456
    return (((struct sockaddr_in6 *)ss)->sin6_port);
  }
#line 459
  return (((struct sockaddr_in *)ss)->sin_port);
}
}
#line 466 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_inet_util.c"
void sin_set_port(in_port_t port , struct sockaddr_storage *ss ) 
{ 


  {
#line 468
  if ((int )ss->ss_family == 10) {
#line 469
    ((struct sockaddr_in6 *)ss)->sin6_port = port;
  }
#line 472
  ((struct sockaddr_in *)ss)->sin_port = port;
#line 473
  return;
}
}
#line 479 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_inet_util.c"
bool sin_equal(struct sockaddr_storage *ss1 , struct sockaddr_storage *ss2 ) 
{ 
  bool tmp ;
  bool tmp___0 ;

  {
#line 483
  if ((int )ss1->ss_family == 10) {
    {
#line 484
    tmp = sin6_equal(ss1, ss2);
    }
#line 484
    return (tmp);
  }
  {
#line 487
  tmp___0 = sin4_equal(ss1, ss2);
  }
#line 487
  return (tmp___0);
}
}
#line 494 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_inet_util.c"
void sin_extractv4(void *in6 , struct in_addr *in4 ) 
{ 


  {
  {
#line 497
  memcpy((void */* __restrict  */)in4, (void const   */* __restrict  */)((char *)in6 + 12),
         sizeof(struct in_addr ));
  }
#line 498
  return;
}
}
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 38 "./oidentd_options.h"
__inline void disable_opt(u_int32_t option ) ;
#line 60 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_options.c"
static void print_usage(void) ;
#line 61
static void print_version(void) ;
#line 62
__inline static void enable_opt(u_int32_t option ) ;
#line 64 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_options.c"
static struct option  const  longopts[22]  = 
#line 64
  {      {"address", 1, (int *)0, 'a'}, 
        {"charset", 1, (int *)0, 'c'}, 
        {"config", 1, (int *)0, 'C'}, 
        {"debug", 0, (int *)0, 'd'}, 
        {"error", 0, (int *)0, 'e'}, 
        {"group", 1, (int *)0, 'g'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"foreground", 0, (int *)0, 'i'}, 
        {"stdio", 0, (int *)0, 'I'}, 
        {"limit", 1, (int *)0, 'l'}, 
        {"other", 2, (int *)0, 'o'}, 
        {"port", 1, (int *)0, 'p'}, 
        {"quiet", 0, (int *)0, 'q'}, 
        {"reply", 1, (int *)0, 'r'}, 
        {"nosyslog", 0, (int *)0, 'S'}, 
        {"timeout", 1, (int *)0, 't'}, 
        {"user", 1, (int *)0, 'u'}, 
        {"version", 0, (int *)0, 'v'}, 
        {"forward", 2, (int *)0, 'f'}, 
        {"masquerade", 0, (int *)0, 'm'}, 
        {"proxy", 1, (int *)0, 'P'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 94 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_options.c"
static u_int32_t flags  ;
#line 100 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_options.c"
bool opt_enabled(u_int32_t option ) 
{ 


  {
#line 101
  return ((bool )((flags & option) != 0U));
}
}
#line 108 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_options.c"
__inline static void enable_opt(u_int32_t option ) 
{ 


  {
#line 109
  flags |= option;
#line 110
  return;
}
}
#line 116 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_options.c"
__inline void disable_opt(u_int32_t option ) 
{ 


  {
#line 117
  flags &= ~ option;
#line 118
  return;
}
}
#line 125 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_options.c"
int get_options(int argc , char * const  *argv ) 
{ 
  int opt ;
  char *temp_os ;
  char *charset ;
  int tmp ;
  int tmp___0 ;
  struct sockaddr_storage *temp_ss ;
  void *tmp___1 ;
  int tmp___2 ;
  char const   *p ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  u_int32_t temp_limit ;
  char *end ;
  unsigned long tmp___6 ;
  char *p___0 ;
  int tmp___7 ;
  char *end___0 ;
  unsigned long tmp___8 ;
  int tmp___9 ;
  size_t len ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  void *tmp___12 ;
  bool tmp___13 ;
  bool tmp___14 ;
  int tmp___15 ;
  bool tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  bool tmp___19 ;

  {
  {
#line 128
  charset = (char *)((void *)0);
#line 131
  tmp = get_port("113", & fwdport);
  }
#line 131
  if (tmp == -1) {
    {
#line 132
    o_log(6, "Fatal: Bad port: \"%s\"", "113");
    }
#line 133
    return (-1);
  }
  {
#line 135
  fwdport = htons(fwdport);
#line 138
  connection_limit = 4294967295U;
#line 140
  config_file = xstrdup("/etc/oidentd.conf");
#line 141
  temp_os = xstrdup("UNIX");
#line 143
  tmp___0 = get_port("113", & listen_port);
  }
#line 143
  if (tmp___0 == -1) {
    {
#line 144
    o_log(6, "Fatal: Bad port: \"%s\"", "113");
    }
#line 145
    return (-1);
  }
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 148
    opt = getopt_long(argc, argv, "a:c:C:def::g:hiIl:mo::p:P:qr:St:u:Uv", longopts,
                      (int *)((void *)0));
    }
#line 148
    if (! (opt != -1)) {
#line 148
      goto while_break;
    }
    {
#line 150
    if (opt == 97) {
#line 150
      goto case_97;
    }
#line 164
    if (opt == 99) {
#line 164
      goto case_99;
    }
#line 170
    if (opt == 67) {
#line 170
      goto case_67;
    }
#line 176
    if (opt == 100) {
#line 176
      goto case_100;
    }
#line 180
    if (opt == 101) {
#line 180
      goto case_101;
    }
#line 185
    if (opt == 102) {
#line 185
      goto case_102;
    }
#line 204
    if (opt == 109) {
#line 204
      goto case_109;
    }
#line 209
    if (opt == 80) {
#line 209
      goto case_80;
    }
#line 220
    if (opt == 103) {
#line 220
      goto case_103;
    }
#line 229
    if (opt == 73) {
#line 229
      goto case_73;
    }
#line 234
    if (opt == 105) {
#line 234
      goto case_105;
    }
#line 238
    if (opt == 108) {
#line 238
      goto case_108;
    }
#line 252
    if (opt == 111) {
#line 252
      goto case_111;
    }
#line 273
    if (opt == 112) {
#line 273
      goto case_112;
    }
#line 280
    if (opt == 113) {
#line 280
      goto case_113;
    }
#line 284
    if (opt == 114) {
#line 284
      goto case_114;
    }
#line 290
    if (opt == 83) {
#line 290
      goto case_83;
    }
#line 294
    if (opt == 116) {
#line 294
      goto case_116;
    }
#line 306
    if (opt == 117) {
#line 306
      goto case_117;
    }
#line 320
    if (opt == 118) {
#line 320
      goto case_118;
    }
#line 325
    goto switch_default;
    case_97: /* CIL Label */ 
    {
#line 151
    tmp___1 = xmalloc(sizeof(struct sockaddr_storage ));
#line 151
    temp_ss = (struct sockaddr_storage *)tmp___1;
#line 154
    tmp___2 = get_addr((char const   */* const  */)optarg, temp_ss);
    }
#line 154
    if (tmp___2 == -1) {
      {
#line 155
      o_log(6, "Fatal: Unknown host: \"%s\"", optarg);
#line 156
      free((void *)temp_ss);
      }
#line 157
      return (-1);
    }
#line 160
    addr = temp_ss;
#line 161
    goto switch_break;
    case_99: /* CIL Label */ 
#line 165
    if ((unsigned long )charset != (unsigned long )((void *)0)) {
      {
#line 166
      free((void *)charset);
      }
    }
    {
#line 167
    charset = xstrdup((char const   *)optarg);
    }
#line 168
    goto switch_break;
    case_67: /* CIL Label */ 
#line 171
    if ((unsigned long )config_file != (unsigned long )((void *)0)) {
      {
#line 172
      free((void *)config_file);
      }
    }
    {
#line 173
    config_file = xstrdup((char const   *)optarg);
    }
#line 174
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 177
    enable_opt((u_int32_t )(1 << 8));
    }
#line 178
    goto switch_break;
    case_101: /* CIL Label */ 
    {
#line 181
    enable_opt((u_int32_t )(1 << 3));
    }
#line 182
    goto switch_break;
    case_102: /* CIL Label */ 
#line 189
    if ((unsigned long )optarg == (unsigned long )((void *)0)) {
#line 190
      p = "113";
    } else {
#line 192
      p = (char const   *)optarg;
    }
    {
#line 194
    tmp___3 = get_port(p, & fwdport);
    }
#line 194
    if (tmp___3 == -1) {
      {
#line 195
      o_log(6, "Fatal: Bad port: \"%s\"", p);
      }
#line 196
      return (-1);
    }
    {
#line 198
    fwdport = htons(fwdport);
#line 200
    enable_opt((u_int32_t )(1 << 5));
    }
#line 201
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 205
    enable_opt((u_int32_t )(1 << 4));
    }
#line 206
    goto switch_break;
    case_80: /* CIL Label */ 
    {
#line 211
    tmp___4 = get_addr((char const   */* const  */)optarg, & proxy);
    }
#line 211
    if (tmp___4 == -1) {
      {
#line 212
      o_log(6, "Fatal: Unknown host: \"%s\"", optarg);
      }
#line 213
      return (-1);
    }
    {
#line 216
    enable_opt((u_int32_t )(1 << 6));
    }
#line 217
    goto switch_break;
    case_103: /* CIL Label */ 
    {
#line 221
    enable_opt((u_int32_t )(1 << 2));
#line 222
    tmp___5 = find_group((char const   *)optarg, & gid);
    }
#line 222
    if (tmp___5 == -1) {
      {
#line 223
      o_log(6, "Fatal: Unknown group: \"%s\"", optarg);
      }
#line 224
      return (-1);
    }
#line 226
    goto switch_break;
    case_73: /* CIL Label */ 
    {
#line 230
    enable_opt((u_int32_t )((1 << 12) | (1 << 10)));
    }
#line 231
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 235
    enable_opt((u_int32_t )(1 << 10));
    }
#line 236
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 243
    tmp___6 = strtoul((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& end),
                      10);
#line 243
    temp_limit = (u_int32_t )tmp___6;
    }
#line 244
    if ((int )*end != 0) {
      {
#line 245
      o_log(6, "Fatal: Not a valid number: \"%s\"", optarg);
      }
#line 246
      return (-1);
    }
#line 249
    connection_limit = temp_limit;
    case_111: /* CIL Label */ 
#line 253
    if ((unsigned long )temp_os != (unsigned long )((void *)0)) {
      {
#line 254
      free((void *)temp_os);
      }
    }
#line 256
    if ((unsigned long )optarg != (unsigned long )((void *)0)) {
      {
#line 259
      temp_os = xstrdup((char const   *)optarg);
#line 261
      p___0 = strchr((char const   *)temp_os, '\n');
      }
#line 262
      if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
#line 263
        *p___0 = (char )'\000';
      }
      {
#line 265
      p___0 = strchr((char const   *)temp_os, '\r');
      }
#line 266
      if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
#line 267
        *p___0 = (char )'\000';
      }
    } else {
      {
#line 269
      temp_os = xstrdup("OTHER");
      }
    }
#line 271
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 274
    tmp___7 = get_port((char const   *)optarg, & listen_port);
    }
#line 274
    if (tmp___7 == -1) {
      {
#line 275
      o_log(6, "Fatal: Bad port: \"%s\"", optarg);
      }
#line 276
      return (-1);
    }
#line 278
    goto switch_break;
    case_113: /* CIL Label */ 
    {
#line 281
    enable_opt((u_int32_t )(1 << 9));
    }
#line 282
    goto switch_break;
    case_114: /* CIL Label */ 
#line 285
    if ((unsigned long )failuser != (unsigned long )((void *)0)) {
      {
#line 286
      free((void *)failuser);
      }
    }
    {
#line 287
    failuser = xstrdup((char const   *)optarg);
    }
#line 288
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 291
    enable_opt((u_int32_t )(1 << 11));
    }
#line 292
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 298
    tmp___8 = strtoul((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& end___0),
                      10);
#line 298
    timeout = (u_int32_t )tmp___8;
    }
#line 299
    if ((int )*end___0 != 0) {
      {
#line 300
      o_log(6, "Fatal: Bad timeout value: \"%s\"", optarg);
      }
#line 301
      return (-1);
    }
#line 303
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 307
    enable_opt((u_int32_t )(1 << 1));
#line 308
    tmp___9 = find_user((char const   *)optarg, & uid);
    }
#line 308
    if (tmp___9 == -1) {
      {
#line 309
      o_log(6, "Fatal: Unknown user: \"%s\"", optarg);
      }
#line 310
      return (-1);
    }
#line 312
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 321
    print_version();
    }
#line 322
    return (-1);
    switch_default: /* CIL Label */ 
    {
#line 326
    print_usage();
    }
#line 327
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 331
  if ((unsigned long )charset != (unsigned long )((void *)0)) {
    {
#line 332
    tmp___10 = strlen((char const   *)temp_os);
#line 332
    tmp___11 = strlen((char const   *)charset);
#line 332
    len = (tmp___10 + tmp___11) + 4UL;
#line 334
    tmp___12 = xmalloc(len);
#line 334
    ret_os = (char *)tmp___12;
#line 335
    snprintf((char */* __restrict  */)ret_os, len, (char const   */* __restrict  */)"%s , %s",
             temp_os, charset);
#line 336
    free((void *)temp_os);
#line 337
    free((void *)charset);
    }
  } else {
#line 339
    ret_os = temp_os;
  }
  {
#line 341
  tmp___13 = opt_enabled((u_int32_t )(1 << 8));
  }
#line 341
  if (tmp___13) {
    {
#line 341
    tmp___14 = opt_enabled((u_int32_t )(1 << 9));
    }
#line 341
    if (tmp___14) {
      {
#line 342
      o_log(6, "Fatal: The debug and quiet flags are incompatible");
      }
#line 343
      return (-1);
    }
  }
  {
#line 350
  tmp___16 = opt_enabled((u_int32_t )(1 << 1));
  }
#line 350
  if (! tmp___16) {
    {
#line 351
    tmp___15 = find_user("nobody", & uid);
    }
#line 351
    if (tmp___15 == -1) {
      {
#line 352
      o_log(6, "user \"nobody\" does not exist. Using %u as default UID", 65534);
#line 356
      uid = (uid_t )65534;
      }
    }
  }
  {
#line 364
  tmp___19 = opt_enabled((u_int32_t )(1 << 2));
  }
#line 364
  if (! tmp___19) {
    {
#line 365
    tmp___18 = find_group("nobody", & gid);
    }
#line 365
    if (tmp___18 == -1) {
      {
#line 366
      tmp___17 = find_group("nogroup", & gid);
      }
#line 366
      if (tmp___17 == -1) {
        {
#line 367
        o_log(6, "Groups \"nobody\" and \"nogroup\" do not exist. Using %u as default GID",
              65534);
#line 371
        gid = (gid_t )65534;
        }
      }
    }
  }
#line 376
  return (0);
}
}
#line 379 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_options.c"
static void print_usage(void) 
{ 
  char usage[1544] ;

  {
  {
#line 380
  usage[0] = (char )'\n';
#line 380
  usage[1] = (char )'U';
#line 380
  usage[2] = (char )'s';
#line 380
  usage[3] = (char )'a';
#line 380
  usage[4] = (char )'g';
#line 380
  usage[5] = (char )'e';
#line 380
  usage[6] = (char )':';
#line 380
  usage[7] = (char )' ';
#line 380
  usage[8] = (char )'o';
#line 380
  usage[9] = (char )'i';
#line 380
  usage[10] = (char )'d';
#line 380
  usage[11] = (char )'e';
#line 380
  usage[12] = (char )'n';
#line 380
  usage[13] = (char )'t';
#line 380
  usage[14] = (char )'d';
#line 380
  usage[15] = (char )' ';
#line 380
  usage[16] = (char )'[';
#line 380
  usage[17] = (char )'o';
#line 380
  usage[18] = (char )'p';
#line 380
  usage[19] = (char )'t';
#line 380
  usage[20] = (char )'i';
#line 380
  usage[21] = (char )'o';
#line 380
  usage[22] = (char )'n';
#line 380
  usage[23] = (char )'s';
#line 380
  usage[24] = (char )']';
#line 380
  usage[25] = (char )'\n';
#line 380
  usage[26] = (char )'-';
#line 380
  usage[27] = (char )'a';
#line 380
  usage[28] = (char )' ';
#line 380
  usage[29] = (char )'o';
#line 380
  usage[30] = (char )'r';
#line 380
  usage[31] = (char )' ';
#line 380
  usage[32] = (char )'-';
#line 380
  usage[33] = (char )'-';
#line 380
  usage[34] = (char )'a';
#line 380
  usage[35] = (char )'d';
#line 380
  usage[36] = (char )'d';
#line 380
  usage[37] = (char )'r';
#line 380
  usage[38] = (char )'e';
#line 380
  usage[39] = (char )'s';
#line 380
  usage[40] = (char )'s';
#line 380
  usage[41] = (char )' ';
#line 380
  usage[42] = (char )'<';
#line 380
  usage[43] = (char )'a';
#line 380
  usage[44] = (char )'d';
#line 380
  usage[45] = (char )'d';
#line 380
  usage[46] = (char )'r';
#line 380
  usage[47] = (char )'e';
#line 380
  usage[48] = (char )'s';
#line 380
  usage[49] = (char )'s';
#line 380
  usage[50] = (char )'>';
#line 380
  usage[51] = (char )' ';
#line 380
  usage[52] = (char )' ';
#line 380
  usage[53] = (char )' ';
#line 380
  usage[54] = (char )' ';
#line 380
  usage[55] = (char )'B';
#line 380
  usage[56] = (char )'i';
#line 380
  usage[57] = (char )'n';
#line 380
  usage[58] = (char )'d';
#line 380
  usage[59] = (char )' ';
#line 380
  usage[60] = (char )'t';
#line 380
  usage[61] = (char )'o';
#line 380
  usage[62] = (char )' ';
#line 380
  usage[63] = (char )'<';
#line 380
  usage[64] = (char )'a';
#line 380
  usage[65] = (char )'d';
#line 380
  usage[66] = (char )'d';
#line 380
  usage[67] = (char )'r';
#line 380
  usage[68] = (char )'e';
#line 380
  usage[69] = (char )'s';
#line 380
  usage[70] = (char )'s';
#line 380
  usage[71] = (char )'>';
#line 380
  usage[72] = (char )'\n';
#line 380
  usage[73] = (char )'-';
#line 380
  usage[74] = (char )'c';
#line 380
  usage[75] = (char )' ';
#line 380
  usage[76] = (char )'o';
#line 380
  usage[77] = (char )'r';
#line 380
  usage[78] = (char )' ';
#line 380
  usage[79] = (char )'-';
#line 380
  usage[80] = (char )'-';
#line 380
  usage[81] = (char )'c';
#line 380
  usage[82] = (char )'h';
#line 380
  usage[83] = (char )'a';
#line 380
  usage[84] = (char )'r';
#line 380
  usage[85] = (char )'s';
#line 380
  usage[86] = (char )'e';
#line 380
  usage[87] = (char )'t';
#line 380
  usage[88] = (char )' ';
#line 380
  usage[89] = (char )'<';
#line 380
  usage[90] = (char )'c';
#line 380
  usage[91] = (char )'h';
#line 380
  usage[92] = (char )'a';
#line 380
  usage[93] = (char )'r';
#line 380
  usage[94] = (char )'s';
#line 380
  usage[95] = (char )'e';
#line 380
  usage[96] = (char )'t';
#line 380
  usage[97] = (char )'>';
#line 380
  usage[98] = (char )' ';
#line 380
  usage[99] = (char )' ';
#line 380
  usage[100] = (char )' ';
#line 380
  usage[101] = (char )' ';
#line 380
  usage[102] = (char )'S';
#line 380
  usage[103] = (char )'p';
#line 380
  usage[104] = (char )'e';
#line 380
  usage[105] = (char )'c';
#line 380
  usage[106] = (char )'i';
#line 380
  usage[107] = (char )'f';
#line 380
  usage[108] = (char )'y';
#line 380
  usage[109] = (char )' ';
#line 380
  usage[110] = (char )'a';
#line 380
  usage[111] = (char )'n';
#line 380
  usage[112] = (char )' ';
#line 380
  usage[113] = (char )'a';
#line 380
  usage[114] = (char )'l';
#line 380
  usage[115] = (char )'t';
#line 380
  usage[116] = (char )'e';
#line 380
  usage[117] = (char )'r';
#line 380
  usage[118] = (char )'n';
#line 380
  usage[119] = (char )'a';
#line 380
  usage[120] = (char )'t';
#line 380
  usage[121] = (char )'e';
#line 380
  usage[122] = (char )' ';
#line 380
  usage[123] = (char )'c';
#line 380
  usage[124] = (char )'h';
#line 380
  usage[125] = (char )'a';
#line 380
  usage[126] = (char )'r';
#line 380
  usage[127] = (char )'s';
#line 380
  usage[128] = (char )'e';
#line 380
  usage[129] = (char )'t';
#line 380
  usage[130] = (char )'\n';
#line 380
  usage[131] = (char )'-';
#line 380
  usage[132] = (char )'C';
#line 380
  usage[133] = (char )' ';
#line 380
  usage[134] = (char )'o';
#line 380
  usage[135] = (char )'r';
#line 380
  usage[136] = (char )' ';
#line 380
  usage[137] = (char )'-';
#line 380
  usage[138] = (char )'-';
#line 380
  usage[139] = (char )'c';
#line 380
  usage[140] = (char )'o';
#line 380
  usage[141] = (char )'n';
#line 380
  usage[142] = (char )'f';
#line 380
  usage[143] = (char )'i';
#line 380
  usage[144] = (char )'g';
#line 380
  usage[145] = (char )' ';
#line 380
  usage[146] = (char )'<';
#line 380
  usage[147] = (char )'c';
#line 380
  usage[148] = (char )'o';
#line 380
  usage[149] = (char )'n';
#line 380
  usage[150] = (char )'f';
#line 380
  usage[151] = (char )'i';
#line 380
  usage[152] = (char )'g';
#line 380
  usage[153] = (char )' ';
#line 380
  usage[154] = (char )'f';
#line 380
  usage[155] = (char )'i';
#line 380
  usage[156] = (char )'l';
#line 380
  usage[157] = (char )'e';
#line 380
  usage[158] = (char )'>';
#line 380
  usage[159] = (char )' ';
#line 380
  usage[160] = (char )'U';
#line 380
  usage[161] = (char )'s';
#line 380
  usage[162] = (char )'e';
#line 380
  usage[163] = (char )' ';
#line 380
  usage[164] = (char )'t';
#line 380
  usage[165] = (char )'h';
#line 380
  usage[166] = (char )'e';
#line 380
  usage[167] = (char )' ';
#line 380
  usage[168] = (char )'s';
#line 380
  usage[169] = (char )'p';
#line 380
  usage[170] = (char )'e';
#line 380
  usage[171] = (char )'c';
#line 380
  usage[172] = (char )'i';
#line 380
  usage[173] = (char )'f';
#line 380
  usage[174] = (char )'e';
#line 380
  usage[175] = (char )'d';
#line 380
  usage[176] = (char )' ';
#line 380
  usage[177] = (char )'f';
#line 380
  usage[178] = (char )'i';
#line 380
  usage[179] = (char )'l';
#line 380
  usage[180] = (char )'e';
#line 380
  usage[181] = (char )' ';
#line 380
  usage[182] = (char )'i';
#line 380
  usage[183] = (char )'n';
#line 380
  usage[184] = (char )'s';
#line 380
  usage[185] = (char )'t';
#line 380
  usage[186] = (char )'e';
#line 380
  usage[187] = (char )'a';
#line 380
  usage[188] = (char )'d';
#line 380
  usage[189] = (char )' ';
#line 380
  usage[190] = (char )'o';
#line 380
  usage[191] = (char )'f';
#line 380
  usage[192] = (char )' ';
#line 380
  usage[193] = (char )'/';
#line 380
  usage[194] = (char )'e';
#line 380
  usage[195] = (char )'t';
#line 380
  usage[196] = (char )'c';
#line 380
  usage[197] = (char )'/';
#line 380
  usage[198] = (char )'o';
#line 380
  usage[199] = (char )'i';
#line 380
  usage[200] = (char )'d';
#line 380
  usage[201] = (char )'e';
#line 380
  usage[202] = (char )'n';
#line 380
  usage[203] = (char )'t';
#line 380
  usage[204] = (char )'d';
#line 380
  usage[205] = (char )'.';
#line 380
  usage[206] = (char )'c';
#line 380
  usage[207] = (char )'o';
#line 380
  usage[208] = (char )'n';
#line 380
  usage[209] = (char )'f';
#line 380
  usage[210] = (char )'\n';
#line 380
  usage[211] = (char )'-';
#line 380
  usage[212] = (char )'d';
#line 380
  usage[213] = (char )' ';
#line 380
  usage[214] = (char )'o';
#line 380
  usage[215] = (char )'r';
#line 380
  usage[216] = (char )' ';
#line 380
  usage[217] = (char )'-';
#line 380
  usage[218] = (char )'-';
#line 380
  usage[219] = (char )'d';
#line 380
  usage[220] = (char )'e';
#line 380
  usage[221] = (char )'b';
#line 380
  usage[222] = (char )'u';
#line 380
  usage[223] = (char )'g';
#line 380
  usage[224] = (char )' ';
#line 380
  usage[225] = (char )' ';
#line 380
  usage[226] = (char )' ';
#line 380
  usage[227] = (char )' ';
#line 380
  usage[228] = (char )' ';
#line 380
  usage[229] = (char )' ';
#line 380
  usage[230] = (char )' ';
#line 380
  usage[231] = (char )' ';
#line 380
  usage[232] = (char )' ';
#line 380
  usage[233] = (char )' ';
#line 380
  usage[234] = (char )' ';
#line 380
  usage[235] = (char )' ';
#line 380
  usage[236] = (char )' ';
#line 380
  usage[237] = (char )' ';
#line 380
  usage[238] = (char )' ';
#line 380
  usage[239] = (char )' ';
#line 380
  usage[240] = (char )'E';
#line 380
  usage[241] = (char )'n';
#line 380
  usage[242] = (char )'a';
#line 380
  usage[243] = (char )'b';
#line 380
  usage[244] = (char )'l';
#line 380
  usage[245] = (char )'e';
#line 380
  usage[246] = (char )' ';
#line 380
  usage[247] = (char )'d';
#line 380
  usage[248] = (char )'e';
#line 380
  usage[249] = (char )'b';
#line 380
  usage[250] = (char )'u';
#line 380
  usage[251] = (char )'g';
#line 380
  usage[252] = (char )'g';
#line 380
  usage[253] = (char )'i';
#line 380
  usage[254] = (char )'n';
#line 380
  usage[255] = (char )'g';
#line 380
  usage[256] = (char )'\n';
#line 380
  usage[257] = (char )'-';
#line 380
  usage[258] = (char )'e';
#line 380
  usage[259] = (char )' ';
#line 380
  usage[260] = (char )'o';
#line 380
  usage[261] = (char )'r';
#line 380
  usage[262] = (char )' ';
#line 380
  usage[263] = (char )'-';
#line 380
  usage[264] = (char )'-';
#line 380
  usage[265] = (char )'e';
#line 380
  usage[266] = (char )'r';
#line 380
  usage[267] = (char )'r';
#line 380
  usage[268] = (char )'o';
#line 380
  usage[269] = (char )'r';
#line 380
  usage[270] = (char )' ';
#line 380
  usage[271] = (char )' ';
#line 380
  usage[272] = (char )' ';
#line 380
  usage[273] = (char )' ';
#line 380
  usage[274] = (char )' ';
#line 380
  usage[275] = (char )' ';
#line 380
  usage[276] = (char )' ';
#line 380
  usage[277] = (char )' ';
#line 380
  usage[278] = (char )' ';
#line 380
  usage[279] = (char )' ';
#line 380
  usage[280] = (char )' ';
#line 380
  usage[281] = (char )' ';
#line 380
  usage[282] = (char )' ';
#line 380
  usage[283] = (char )' ';
#line 380
  usage[284] = (char )' ';
#line 380
  usage[285] = (char )' ';
#line 380
  usage[286] = (char )'R';
#line 380
  usage[287] = (char )'e';
#line 380
  usage[288] = (char )'t';
#line 380
  usage[289] = (char )'u';
#line 380
  usage[290] = (char )'r';
#line 380
  usage[291] = (char )'n';
#line 380
  usage[292] = (char )' ';
#line 380
  usage[293] = (char )'\"';
#line 380
  usage[294] = (char )'U';
#line 380
  usage[295] = (char )'N';
#line 380
  usage[296] = (char )'K';
#line 380
  usage[297] = (char )'N';
#line 380
  usage[298] = (char )'O';
#line 380
  usage[299] = (char )'W';
#line 380
  usage[300] = (char )'N';
#line 380
  usage[301] = (char )'-';
#line 380
  usage[302] = (char )'E';
#line 380
  usage[303] = (char )'R';
#line 380
  usage[304] = (char )'R';
#line 380
  usage[305] = (char )'O';
#line 380
  usage[306] = (char )'R';
#line 380
  usage[307] = (char )'\"';
#line 380
  usage[308] = (char )' ';
#line 380
  usage[309] = (char )'f';
#line 380
  usage[310] = (char )'o';
#line 380
  usage[311] = (char )'r';
#line 380
  usage[312] = (char )' ';
#line 380
  usage[313] = (char )'a';
#line 380
  usage[314] = (char )'l';
#line 380
  usage[315] = (char )'l';
#line 380
  usage[316] = (char )' ';
#line 380
  usage[317] = (char )'e';
#line 380
  usage[318] = (char )'r';
#line 380
  usage[319] = (char )'r';
#line 380
  usage[320] = (char )'o';
#line 380
  usage[321] = (char )'r';
#line 380
  usage[322] = (char )'s';
#line 380
  usage[323] = (char )'\n';
#line 380
  usage[324] = (char )'-';
#line 380
  usage[325] = (char )'f';
#line 380
  usage[326] = (char )' ';
#line 380
  usage[327] = (char )'o';
#line 380
  usage[328] = (char )'r';
#line 380
  usage[329] = (char )' ';
#line 380
  usage[330] = (char )'-';
#line 380
  usage[331] = (char )'-';
#line 380
  usage[332] = (char )'f';
#line 380
  usage[333] = (char )'o';
#line 380
  usage[334] = (char )'r';
#line 380
  usage[335] = (char )'w';
#line 380
  usage[336] = (char )'a';
#line 380
  usage[337] = (char )'r';
#line 380
  usage[338] = (char )'d';
#line 380
  usage[339] = (char )' ';
#line 380
  usage[340] = (char )'[';
#line 380
  usage[341] = (char )'<';
#line 380
  usage[342] = (char )'p';
#line 380
  usage[343] = (char )'o';
#line 380
  usage[344] = (char )'r';
#line 380
  usage[345] = (char )'t';
#line 380
  usage[346] = (char )'>';
#line 380
  usage[347] = (char )']';
#line 380
  usage[348] = (char )' ';
#line 380
  usage[349] = (char )' ';
#line 380
  usage[350] = (char )' ';
#line 380
  usage[351] = (char )' ';
#line 380
  usage[352] = (char )' ';
#line 380
  usage[353] = (char )'F';
#line 380
  usage[354] = (char )'o';
#line 380
  usage[355] = (char )'r';
#line 380
  usage[356] = (char )'w';
#line 380
  usage[357] = (char )'a';
#line 380
  usage[358] = (char )'r';
#line 380
  usage[359] = (char )'d';
#line 380
  usage[360] = (char )' ';
#line 380
  usage[361] = (char )'r';
#line 380
  usage[362] = (char )'e';
#line 380
  usage[363] = (char )'q';
#line 380
  usage[364] = (char )'u';
#line 380
  usage[365] = (char )'e';
#line 380
  usage[366] = (char )'s';
#line 380
  usage[367] = (char )'t';
#line 380
  usage[368] = (char )'s';
#line 380
  usage[369] = (char )' ';
#line 380
  usage[370] = (char )'f';
#line 380
  usage[371] = (char )'o';
#line 380
  usage[372] = (char )'r';
#line 380
  usage[373] = (char )' ';
#line 380
  usage[374] = (char )'m';
#line 380
  usage[375] = (char )'a';
#line 380
  usage[376] = (char )'s';
#line 380
  usage[377] = (char )'q';
#line 380
  usage[378] = (char )'u';
#line 380
  usage[379] = (char )'e';
#line 380
  usage[380] = (char )'r';
#line 380
  usage[381] = (char )'a';
#line 380
  usage[382] = (char )'d';
#line 380
  usage[383] = (char )'e';
#line 380
  usage[384] = (char )'d';
#line 380
  usage[385] = (char )' ';
#line 380
  usage[386] = (char )'h';
#line 380
  usage[387] = (char )'o';
#line 380
  usage[388] = (char )'s';
#line 380
  usage[389] = (char )'t';
#line 380
  usage[390] = (char )'s';
#line 380
  usage[391] = (char )' ';
#line 380
  usage[392] = (char )'t';
#line 380
  usage[393] = (char )'o';
#line 380
  usage[394] = (char )' ';
#line 380
  usage[395] = (char )'t';
#line 380
  usage[396] = (char )'h';
#line 380
  usage[397] = (char )'e';
#line 380
  usage[398] = (char )' ';
#line 380
  usage[399] = (char )'h';
#line 380
  usage[400] = (char )'o';
#line 380
  usage[401] = (char )'s';
#line 380
  usage[402] = (char )'t';
#line 380
  usage[403] = (char )' ';
#line 380
  usage[404] = (char )'o';
#line 380
  usage[405] = (char )'n';
#line 380
  usage[406] = (char )' ';
#line 380
  usage[407] = (char )'p';
#line 380
  usage[408] = (char )'o';
#line 380
  usage[409] = (char )'r';
#line 380
  usage[410] = (char )'t';
#line 380
  usage[411] = (char )' ';
#line 380
  usage[412] = (char )'<';
#line 380
  usage[413] = (char )'p';
#line 380
  usage[414] = (char )'o';
#line 380
  usage[415] = (char )'r';
#line 380
  usage[416] = (char )'t';
#line 380
  usage[417] = (char )'>';
#line 380
  usage[418] = (char )'\n';
#line 380
  usage[419] = (char )'-';
#line 380
  usage[420] = (char )'m';
#line 380
  usage[421] = (char )' ';
#line 380
  usage[422] = (char )'o';
#line 380
  usage[423] = (char )'r';
#line 380
  usage[424] = (char )' ';
#line 380
  usage[425] = (char )'-';
#line 380
  usage[426] = (char )'-';
#line 380
  usage[427] = (char )'m';
#line 380
  usage[428] = (char )'a';
#line 380
  usage[429] = (char )'s';
#line 380
  usage[430] = (char )'q';
#line 380
  usage[431] = (char )'u';
#line 380
  usage[432] = (char )'e';
#line 380
  usage[433] = (char )'r';
#line 380
  usage[434] = (char )'a';
#line 380
  usage[435] = (char )'d';
#line 380
  usage[436] = (char )'e';
#line 380
  usage[437] = (char )' ';
#line 380
  usage[438] = (char )' ';
#line 380
  usage[439] = (char )' ';
#line 380
  usage[440] = (char )' ';
#line 380
  usage[441] = (char )' ';
#line 380
  usage[442] = (char )' ';
#line 380
  usage[443] = (char )' ';
#line 380
  usage[444] = (char )' ';
#line 380
  usage[445] = (char )' ';
#line 380
  usage[446] = (char )' ';
#line 380
  usage[447] = (char )' ';
#line 380
  usage[448] = (char )'E';
#line 380
  usage[449] = (char )'n';
#line 380
  usage[450] = (char )'a';
#line 380
  usage[451] = (char )'b';
#line 380
  usage[452] = (char )'l';
#line 380
  usage[453] = (char )'e';
#line 380
  usage[454] = (char )' ';
#line 380
  usage[455] = (char )'s';
#line 380
  usage[456] = (char )'u';
#line 380
  usage[457] = (char )'p';
#line 380
  usage[458] = (char )'p';
#line 380
  usage[459] = (char )'o';
#line 380
  usage[460] = (char )'r';
#line 380
  usage[461] = (char )'t';
#line 380
  usage[462] = (char )' ';
#line 380
  usage[463] = (char )'f';
#line 380
  usage[464] = (char )'o';
#line 380
  usage[465] = (char )'r';
#line 380
  usage[466] = (char )' ';
#line 380
  usage[467] = (char )'I';
#line 380
  usage[468] = (char )'P';
#line 380
  usage[469] = (char )' ';
#line 380
  usage[470] = (char )'m';
#line 380
  usage[471] = (char )'a';
#line 380
  usage[472] = (char )'s';
#line 380
  usage[473] = (char )'q';
#line 380
  usage[474] = (char )'u';
#line 380
  usage[475] = (char )'e';
#line 380
  usage[476] = (char )'r';
#line 380
  usage[477] = (char )'a';
#line 380
  usage[478] = (char )'d';
#line 380
  usage[479] = (char )'i';
#line 380
  usage[480] = (char )'n';
#line 380
  usage[481] = (char )'g';
#line 380
  usage[482] = (char )'\n';
#line 380
  usage[483] = (char )'-';
#line 380
  usage[484] = (char )'P';
#line 380
  usage[485] = (char )' ';
#line 380
  usage[486] = (char )'o';
#line 380
  usage[487] = (char )'r';
#line 380
  usage[488] = (char )' ';
#line 380
  usage[489] = (char )'-';
#line 380
  usage[490] = (char )'-';
#line 380
  usage[491] = (char )'p';
#line 380
  usage[492] = (char )'r';
#line 380
  usage[493] = (char )'o';
#line 380
  usage[494] = (char )'x';
#line 380
  usage[495] = (char )'y';
#line 380
  usage[496] = (char )' ';
#line 380
  usage[497] = (char )'<';
#line 380
  usage[498] = (char )'h';
#line 380
  usage[499] = (char )'o';
#line 380
  usage[500] = (char )'s';
#line 380
  usage[501] = (char )'t';
#line 380
  usage[502] = (char )'>';
#line 380
  usage[503] = (char )' ';
#line 380
  usage[504] = (char )' ';
#line 380
  usage[505] = (char )' ';
#line 380
  usage[506] = (char )' ';
#line 380
  usage[507] = (char )' ';
#line 380
  usage[508] = (char )' ';
#line 380
  usage[509] = (char )' ';
#line 380
  usage[510] = (char )' ';
#line 380
  usage[511] = (char )' ';
#line 380
  usage[512] = (char )'<';
#line 380
  usage[513] = (char )'h';
#line 380
  usage[514] = (char )'o';
#line 380
  usage[515] = (char )'s';
#line 380
  usage[516] = (char )'t';
#line 380
  usage[517] = (char )'>';
#line 380
  usage[518] = (char )' ';
#line 380
  usage[519] = (char )'a';
#line 380
  usage[520] = (char )'c';
#line 380
  usage[521] = (char )'t';
#line 380
  usage[522] = (char )'s';
#line 380
  usage[523] = (char )' ';
#line 380
  usage[524] = (char )'a';
#line 380
  usage[525] = (char )'s';
#line 380
  usage[526] = (char )' ';
#line 380
  usage[527] = (char )'a';
#line 380
  usage[528] = (char )' ';
#line 380
  usage[529] = (char )'p';
#line 380
  usage[530] = (char )'r';
#line 380
  usage[531] = (char )'o';
#line 380
  usage[532] = (char )'x';
#line 380
  usage[533] = (char )'y';
#line 380
  usage[534] = (char )',';
#line 380
  usage[535] = (char )' ';
#line 380
  usage[536] = (char )'f';
#line 380
  usage[537] = (char )'o';
#line 380
  usage[538] = (char )'r';
#line 380
  usage[539] = (char )'w';
#line 380
  usage[540] = (char )'a';
#line 380
  usage[541] = (char )'r';
#line 380
  usage[542] = (char )'d';
#line 380
  usage[543] = (char )'i';
#line 380
  usage[544] = (char )'n';
#line 380
  usage[545] = (char )'g';
#line 380
  usage[546] = (char )' ';
#line 380
  usage[547] = (char )'c';
#line 380
  usage[548] = (char )'o';
#line 380
  usage[549] = (char )'n';
#line 380
  usage[550] = (char )'n';
#line 380
  usage[551] = (char )'e';
#line 380
  usage[552] = (char )'c';
#line 380
  usage[553] = (char )'t';
#line 380
  usage[554] = (char )'i';
#line 380
  usage[555] = (char )'o';
#line 380
  usage[556] = (char )'n';
#line 380
  usage[557] = (char )'s';
#line 380
  usage[558] = (char )' ';
#line 380
  usage[559] = (char )'t';
#line 380
  usage[560] = (char )'o';
#line 380
  usage[561] = (char )' ';
#line 380
  usage[562] = (char )'u';
#line 380
  usage[563] = (char )'s';
#line 380
  usage[564] = (char )'\n';
#line 380
  usage[565] = (char )'-';
#line 380
  usage[566] = (char )'g';
#line 380
  usage[567] = (char )' ';
#line 380
  usage[568] = (char )'o';
#line 380
  usage[569] = (char )'r';
#line 380
  usage[570] = (char )' ';
#line 380
  usage[571] = (char )'-';
#line 380
  usage[572] = (char )'-';
#line 380
  usage[573] = (char )'g';
#line 380
  usage[574] = (char )'r';
#line 380
  usage[575] = (char )'o';
#line 380
  usage[576] = (char )'u';
#line 380
  usage[577] = (char )'p';
#line 380
  usage[578] = (char )' ';
#line 380
  usage[579] = (char )'<';
#line 380
  usage[580] = (char )'g';
#line 380
  usage[581] = (char )'r';
#line 380
  usage[582] = (char )'o';
#line 380
  usage[583] = (char )'u';
#line 380
  usage[584] = (char )'p';
#line 380
  usage[585] = (char )'>';
#line 380
  usage[586] = (char )' ';
#line 380
  usage[587] = (char )' ';
#line 380
  usage[588] = (char )' ';
#line 380
  usage[589] = (char )' ';
#line 380
  usage[590] = (char )' ';
#line 380
  usage[591] = (char )' ';
#line 380
  usage[592] = (char )' ';
#line 380
  usage[593] = (char )' ';
#line 380
  usage[594] = (char )'R';
#line 380
  usage[595] = (char )'u';
#line 380
  usage[596] = (char )'n';
#line 380
  usage[597] = (char )' ';
#line 380
  usage[598] = (char )'w';
#line 380
  usage[599] = (char )'i';
#line 380
  usage[600] = (char )'t';
#line 380
  usage[601] = (char )'h';
#line 380
  usage[602] = (char )' ';
#line 380
  usage[603] = (char )'s';
#line 380
  usage[604] = (char )'p';
#line 380
  usage[605] = (char )'e';
#line 380
  usage[606] = (char )'c';
#line 380
  usage[607] = (char )'i';
#line 380
  usage[608] = (char )'f';
#line 380
  usage[609] = (char )'i';
#line 380
  usage[610] = (char )'e';
#line 380
  usage[611] = (char )'d';
#line 380
  usage[612] = (char )' ';
#line 380
  usage[613] = (char )'g';
#line 380
  usage[614] = (char )'r';
#line 380
  usage[615] = (char )'o';
#line 380
  usage[616] = (char )'u';
#line 380
  usage[617] = (char )'p';
#line 380
  usage[618] = (char )' ';
#line 380
  usage[619] = (char )'o';
#line 380
  usage[620] = (char )'r';
#line 380
  usage[621] = (char )' ';
#line 380
  usage[622] = (char )'G';
#line 380
  usage[623] = (char )'I';
#line 380
  usage[624] = (char )'D';
#line 380
  usage[625] = (char )'\n';
#line 380
  usage[626] = (char )'-';
#line 380
  usage[627] = (char )'i';
#line 380
  usage[628] = (char )' ';
#line 380
  usage[629] = (char )'o';
#line 380
  usage[630] = (char )'r';
#line 380
  usage[631] = (char )' ';
#line 380
  usage[632] = (char )'-';
#line 380
  usage[633] = (char )'-';
#line 380
  usage[634] = (char )'f';
#line 380
  usage[635] = (char )'o';
#line 380
  usage[636] = (char )'r';
#line 380
  usage[637] = (char )'e';
#line 380
  usage[638] = (char )'g';
#line 380
  usage[639] = (char )'r';
#line 380
  usage[640] = (char )'o';
#line 380
  usage[641] = (char )'u';
#line 380
  usage[642] = (char )'n';
#line 380
  usage[643] = (char )'d';
#line 380
  usage[644] = (char )' ';
#line 380
  usage[645] = (char )' ';
#line 380
  usage[646] = (char )' ';
#line 380
  usage[647] = (char )' ';
#line 380
  usage[648] = (char )' ';
#line 380
  usage[649] = (char )' ';
#line 380
  usage[650] = (char )' ';
#line 380
  usage[651] = (char )' ';
#line 380
  usage[652] = (char )' ';
#line 380
  usage[653] = (char )' ';
#line 380
  usage[654] = (char )' ';
#line 380
  usage[655] = (char )'D';
#line 380
  usage[656] = (char )'o';
#line 380
  usage[657] = (char )'n';
#line 380
  usage[658] = (char )'\'';
#line 380
  usage[659] = (char )'t';
#line 380
  usage[660] = (char )' ';
#line 380
  usage[661] = (char )'r';
#line 380
  usage[662] = (char )'u';
#line 380
  usage[663] = (char )'n';
#line 380
  usage[664] = (char )' ';
#line 380
  usage[665] = (char )'a';
#line 380
  usage[666] = (char )'s';
#line 380
  usage[667] = (char )' ';
#line 380
  usage[668] = (char )'a';
#line 380
  usage[669] = (char )' ';
#line 380
  usage[670] = (char )'d';
#line 380
  usage[671] = (char )'a';
#line 380
  usage[672] = (char )'e';
#line 380
  usage[673] = (char )'m';
#line 380
  usage[674] = (char )'o';
#line 380
  usage[675] = (char )'n';
#line 380
  usage[676] = (char )'\n';
#line 380
  usage[677] = (char )'-';
#line 380
  usage[678] = (char )'I';
#line 380
  usage[679] = (char )' ';
#line 380
  usage[680] = (char )'o';
#line 380
  usage[681] = (char )'r';
#line 380
  usage[682] = (char )' ';
#line 380
  usage[683] = (char )'-';
#line 380
  usage[684] = (char )'-';
#line 380
  usage[685] = (char )'s';
#line 380
  usage[686] = (char )'t';
#line 380
  usage[687] = (char )'d';
#line 380
  usage[688] = (char )'i';
#line 380
  usage[689] = (char )'o';
#line 380
  usage[690] = (char )' ';
#line 380
  usage[691] = (char )' ';
#line 380
  usage[692] = (char )' ';
#line 380
  usage[693] = (char )' ';
#line 380
  usage[694] = (char )' ';
#line 380
  usage[695] = (char )' ';
#line 380
  usage[696] = (char )' ';
#line 380
  usage[697] = (char )' ';
#line 380
  usage[698] = (char )' ';
#line 380
  usage[699] = (char )' ';
#line 380
  usage[700] = (char )' ';
#line 380
  usage[701] = (char )' ';
#line 380
  usage[702] = (char )' ';
#line 380
  usage[703] = (char )' ';
#line 380
  usage[704] = (char )' ';
#line 380
  usage[705] = (char )' ';
#line 380
  usage[706] = (char )'S';
#line 380
  usage[707] = (char )'e';
#line 380
  usage[708] = (char )'r';
#line 380
  usage[709] = (char )'v';
#line 380
  usage[710] = (char )'i';
#line 380
  usage[711] = (char )'c';
#line 380
  usage[712] = (char )'e';
#line 380
  usage[713] = (char )' ';
#line 380
  usage[714] = (char )'a';
#line 380
  usage[715] = (char )' ';
#line 380
  usage[716] = (char )'s';
#line 380
  usage[717] = (char )'i';
#line 380
  usage[718] = (char )'n';
#line 380
  usage[719] = (char )'g';
#line 380
  usage[720] = (char )'l';
#line 380
  usage[721] = (char )'e';
#line 380
  usage[722] = (char )' ';
#line 380
  usage[723] = (char )'c';
#line 380
  usage[724] = (char )'l';
#line 380
  usage[725] = (char )'i';
#line 380
  usage[726] = (char )'e';
#line 380
  usage[727] = (char )'n';
#line 380
  usage[728] = (char )'t';
#line 380
  usage[729] = (char )' ';
#line 380
  usage[730] = (char )'c';
#line 380
  usage[731] = (char )'o';
#line 380
  usage[732] = (char )'n';
#line 380
  usage[733] = (char )'n';
#line 380
  usage[734] = (char )'e';
#line 380
  usage[735] = (char )'c';
#line 380
  usage[736] = (char )'t';
#line 380
  usage[737] = (char )'e';
#line 380
  usage[738] = (char )'d';
#line 380
  usage[739] = (char )' ';
#line 380
  usage[740] = (char )'t';
#line 380
  usage[741] = (char )'o';
#line 380
  usage[742] = (char )' ';
#line 380
  usage[743] = (char )'s';
#line 380
  usage[744] = (char )'t';
#line 380
  usage[745] = (char )'d';
#line 380
  usage[746] = (char )'i';
#line 380
  usage[747] = (char )'n';
#line 380
  usage[748] = (char )'/';
#line 380
  usage[749] = (char )'s';
#line 380
  usage[750] = (char )'t';
#line 380
  usage[751] = (char )'d';
#line 380
  usage[752] = (char )'o';
#line 380
  usage[753] = (char )'u';
#line 380
  usage[754] = (char )'t';
#line 380
  usage[755] = (char )' ';
#line 380
  usage[756] = (char )'t';
#line 380
  usage[757] = (char )'h';
#line 380
  usage[758] = (char )'e';
#line 380
  usage[759] = (char )'n';
#line 380
  usage[760] = (char )' ';
#line 380
  usage[761] = (char )'e';
#line 380
  usage[762] = (char )'x';
#line 380
  usage[763] = (char )'i';
#line 380
  usage[764] = (char )'t';
#line 380
  usage[765] = (char )' ';
#line 380
  usage[766] = (char )'(';
#line 380
  usage[767] = (char )'u';
#line 380
  usage[768] = (char )'s';
#line 380
  usage[769] = (char )'e';
#line 380
  usage[770] = (char )' ';
#line 380
  usage[771] = (char )'w';
#line 380
  usage[772] = (char )'h';
#line 380
  usage[773] = (char )'e';
#line 380
  usage[774] = (char )'n';
#line 380
  usage[775] = (char )' ';
#line 380
  usage[776] = (char )'o';
#line 380
  usage[777] = (char )'i';
#line 380
  usage[778] = (char )'d';
#line 380
  usage[779] = (char )'e';
#line 380
  usage[780] = (char )'n';
#line 380
  usage[781] = (char )'t';
#line 380
  usage[782] = (char )'d';
#line 380
  usage[783] = (char )' ';
#line 380
  usage[784] = (char )'i';
#line 380
  usage[785] = (char )'s';
#line 380
  usage[786] = (char )' ';
#line 380
  usage[787] = (char )'r';
#line 380
  usage[788] = (char )'u';
#line 380
  usage[789] = (char )'n';
#line 380
  usage[790] = (char )'n';
#line 380
  usage[791] = (char )'i';
#line 380
  usage[792] = (char )'n';
#line 380
  usage[793] = (char )'g';
#line 380
  usage[794] = (char )' ';
#line 380
  usage[795] = (char )'f';
#line 380
  usage[796] = (char )'r';
#line 380
  usage[797] = (char )'o';
#line 380
  usage[798] = (char )'m';
#line 380
  usage[799] = (char )' ';
#line 380
  usage[800] = (char )'i';
#line 380
  usage[801] = (char )'n';
#line 380
  usage[802] = (char )'e';
#line 380
  usage[803] = (char )'t';
#line 380
  usage[804] = (char )'d';
#line 380
  usage[805] = (char )'/';
#line 380
  usage[806] = (char )'x';
#line 380
  usage[807] = (char )'i';
#line 380
  usage[808] = (char )'n';
#line 380
  usage[809] = (char )'e';
#line 380
  usage[810] = (char )'t';
#line 380
  usage[811] = (char )'d';
#line 380
  usage[812] = (char )'/';
#line 380
  usage[813] = (char )'e';
#line 380
  usage[814] = (char )'t';
#line 380
  usage[815] = (char )'c';
#line 380
  usage[816] = (char )')';
#line 380
  usage[817] = (char )'.';
#line 380
  usage[818] = (char )'\n';
#line 380
  usage[819] = (char )'-';
#line 380
  usage[820] = (char )'l';
#line 380
  usage[821] = (char )' ';
#line 380
  usage[822] = (char )'o';
#line 380
  usage[823] = (char )'r';
#line 380
  usage[824] = (char )' ';
#line 380
  usage[825] = (char )'-';
#line 380
  usage[826] = (char )'-';
#line 380
  usage[827] = (char )'l';
#line 380
  usage[828] = (char )'i';
#line 380
  usage[829] = (char )'m';
#line 380
  usage[830] = (char )'i';
#line 380
  usage[831] = (char )'t';
#line 380
  usage[832] = (char )' ';
#line 380
  usage[833] = (char )'<';
#line 380
  usage[834] = (char )'n';
#line 380
  usage[835] = (char )'u';
#line 380
  usage[836] = (char )'m';
#line 380
  usage[837] = (char )'b';
#line 380
  usage[838] = (char )'e';
#line 380
  usage[839] = (char )'r';
#line 380
  usage[840] = (char )'>';
#line 380
  usage[841] = (char )' ';
#line 380
  usage[842] = (char )' ';
#line 380
  usage[843] = (char )' ';
#line 380
  usage[844] = (char )' ';
#line 380
  usage[845] = (char )' ';
#line 380
  usage[846] = (char )' ';
#line 380
  usage[847] = (char )' ';
#line 380
  usage[848] = (char )'L';
#line 380
  usage[849] = (char )'i';
#line 380
  usage[850] = (char )'m';
#line 380
  usage[851] = (char )'i';
#line 380
  usage[852] = (char )'t';
#line 380
  usage[853] = (char )' ';
#line 380
  usage[854] = (char )'t';
#line 380
  usage[855] = (char )'h';
#line 380
  usage[856] = (char )'e';
#line 380
  usage[857] = (char )' ';
#line 380
  usage[858] = (char )'n';
#line 380
  usage[859] = (char )'u';
#line 380
  usage[860] = (char )'m';
#line 380
  usage[861] = (char )'b';
#line 380
  usage[862] = (char )'e';
#line 380
  usage[863] = (char )'r';
#line 380
  usage[864] = (char )' ';
#line 380
  usage[865] = (char )'o';
#line 380
  usage[866] = (char )'f';
#line 380
  usage[867] = (char )' ';
#line 380
  usage[868] = (char )'o';
#line 380
  usage[869] = (char )'p';
#line 380
  usage[870] = (char )'e';
#line 380
  usage[871] = (char )'n';
#line 380
  usage[872] = (char )' ';
#line 380
  usage[873] = (char )'c';
#line 380
  usage[874] = (char )'o';
#line 380
  usage[875] = (char )'n';
#line 380
  usage[876] = (char )'n';
#line 380
  usage[877] = (char )'e';
#line 380
  usage[878] = (char )'c';
#line 380
  usage[879] = (char )'t';
#line 380
  usage[880] = (char )'i';
#line 380
  usage[881] = (char )'o';
#line 380
  usage[882] = (char )'n';
#line 380
  usage[883] = (char )'s';
#line 380
  usage[884] = (char )' ';
#line 380
  usage[885] = (char )'t';
#line 380
  usage[886] = (char )'o';
#line 380
  usage[887] = (char )' ';
#line 380
  usage[888] = (char )'t';
#line 380
  usage[889] = (char )'h';
#line 380
  usage[890] = (char )'e';
#line 380
  usage[891] = (char )' ';
#line 380
  usage[892] = (char )'s';
#line 380
  usage[893] = (char )'p';
#line 380
  usage[894] = (char )'e';
#line 380
  usage[895] = (char )'c';
#line 380
  usage[896] = (char )'i';
#line 380
  usage[897] = (char )'f';
#line 380
  usage[898] = (char )'i';
#line 380
  usage[899] = (char )'e';
#line 380
  usage[900] = (char )'d';
#line 380
  usage[901] = (char )' ';
#line 380
  usage[902] = (char )'n';
#line 380
  usage[903] = (char )'u';
#line 380
  usage[904] = (char )'m';
#line 380
  usage[905] = (char )'b';
#line 380
  usage[906] = (char )'e';
#line 380
  usage[907] = (char )'r';
#line 380
  usage[908] = (char )'\n';
#line 380
  usage[909] = (char )'-';
#line 380
  usage[910] = (char )'o';
#line 380
  usage[911] = (char )' ';
#line 380
  usage[912] = (char )'o';
#line 380
  usage[913] = (char )'r';
#line 380
  usage[914] = (char )' ';
#line 380
  usage[915] = (char )'-';
#line 380
  usage[916] = (char )'-';
#line 380
  usage[917] = (char )'o';
#line 380
  usage[918] = (char )'t';
#line 380
  usage[919] = (char )'h';
#line 380
  usage[920] = (char )'e';
#line 380
  usage[921] = (char )'r';
#line 380
  usage[922] = (char )' ';
#line 380
  usage[923] = (char )'[';
#line 380
  usage[924] = (char )'<';
#line 380
  usage[925] = (char )'o';
#line 380
  usage[926] = (char )'s';
#line 380
  usage[927] = (char )'>';
#line 380
  usage[928] = (char )']';
#line 380
  usage[929] = (char )' ';
#line 380
  usage[930] = (char )' ';
#line 380
  usage[931] = (char )' ';
#line 380
  usage[932] = (char )' ';
#line 380
  usage[933] = (char )' ';
#line 380
  usage[934] = (char )' ';
#line 380
  usage[935] = (char )' ';
#line 380
  usage[936] = (char )' ';
#line 380
  usage[937] = (char )' ';
#line 380
  usage[938] = (char )'R';
#line 380
  usage[939] = (char )'e';
#line 380
  usage[940] = (char )'t';
#line 380
  usage[941] = (char )'u';
#line 380
  usage[942] = (char )'r';
#line 380
  usage[943] = (char )'n';
#line 380
  usage[944] = (char )' ';
#line 380
  usage[945] = (char )'<';
#line 380
  usage[946] = (char )'o';
#line 380
  usage[947] = (char )'s';
#line 380
  usage[948] = (char )'>';
#line 380
  usage[949] = (char )' ';
#line 380
  usage[950] = (char )'i';
#line 380
  usage[951] = (char )'n';
#line 380
  usage[952] = (char )'s';
#line 380
  usage[953] = (char )'t';
#line 380
  usage[954] = (char )'e';
#line 380
  usage[955] = (char )'a';
#line 380
  usage[956] = (char )'d';
#line 380
  usage[957] = (char )' ';
#line 380
  usage[958] = (char )'o';
#line 380
  usage[959] = (char )'f';
#line 380
  usage[960] = (char )' ';
#line 380
  usage[961] = (char )'t';
#line 380
  usage[962] = (char )'h';
#line 380
  usage[963] = (char )'e';
#line 380
  usage[964] = (char )' ';
#line 380
  usage[965] = (char )'o';
#line 380
  usage[966] = (char )'p';
#line 380
  usage[967] = (char )'e';
#line 380
  usage[968] = (char )'r';
#line 380
  usage[969] = (char )'a';
#line 380
  usage[970] = (char )'t';
#line 380
  usage[971] = (char )'i';
#line 380
  usage[972] = (char )'n';
#line 380
  usage[973] = (char )'g';
#line 380
  usage[974] = (char )' ';
#line 380
  usage[975] = (char )'s';
#line 380
  usage[976] = (char )'y';
#line 380
  usage[977] = (char )'s';
#line 380
  usage[978] = (char )'t';
#line 380
  usage[979] = (char )'e';
#line 380
  usage[980] = (char )'m';
#line 380
  usage[981] = (char )'.';
#line 380
  usage[982] = (char )' ';
#line 380
  usage[983] = (char )' ';
#line 380
  usage[984] = (char )'U';
#line 380
  usage[985] = (char )'s';
#line 380
  usage[986] = (char )'e';
#line 380
  usage[987] = (char )'s';
#line 380
  usage[988] = (char )' ';
#line 380
  usage[989] = (char )'\"';
#line 380
  usage[990] = (char )'O';
#line 380
  usage[991] = (char )'T';
#line 380
  usage[992] = (char )'H';
#line 380
  usage[993] = (char )'E';
#line 380
  usage[994] = (char )'R';
#line 380
  usage[995] = (char )'\"';
#line 380
  usage[996] = (char )' ';
#line 380
  usage[997] = (char )'i';
#line 380
  usage[998] = (char )'f';
#line 380
  usage[999] = (char )' ';
#line 380
  usage[1000] = (char )'n';
#line 380
  usage[1001] = (char )'o';
#line 380
  usage[1002] = (char )' ';
#line 380
  usage[1003] = (char )'a';
#line 380
  usage[1004] = (char )'r';
#line 380
  usage[1005] = (char )'g';
#line 380
  usage[1006] = (char )'u';
#line 380
  usage[1007] = (char )'m';
#line 380
  usage[1008] = (char )'e';
#line 380
  usage[1009] = (char )'n';
#line 380
  usage[1010] = (char )'t';
#line 380
  usage[1011] = (char )' ';
#line 380
  usage[1012] = (char )'i';
#line 380
  usage[1013] = (char )'s';
#line 380
  usage[1014] = (char )' ';
#line 380
  usage[1015] = (char )'g';
#line 380
  usage[1016] = (char )'i';
#line 380
  usage[1017] = (char )'v';
#line 380
  usage[1018] = (char )'e';
#line 380
  usage[1019] = (char )'n';
#line 380
  usage[1020] = (char )'.';
#line 380
  usage[1021] = (char )'\n';
#line 380
  usage[1022] = (char )'-';
#line 380
  usage[1023] = (char )'p';
#line 380
  usage[1024] = (char )' ';
#line 380
  usage[1025] = (char )'o';
#line 380
  usage[1026] = (char )'r';
#line 380
  usage[1027] = (char )' ';
#line 380
  usage[1028] = (char )'-';
#line 380
  usage[1029] = (char )'-';
#line 380
  usage[1030] = (char )'p';
#line 380
  usage[1031] = (char )'o';
#line 380
  usage[1032] = (char )'r';
#line 380
  usage[1033] = (char )'t';
#line 380
  usage[1034] = (char )' ';
#line 380
  usage[1035] = (char )'<';
#line 380
  usage[1036] = (char )'p';
#line 380
  usage[1037] = (char )'o';
#line 380
  usage[1038] = (char )'r';
#line 380
  usage[1039] = (char )'t';
#line 380
  usage[1040] = (char )'>';
#line 380
  usage[1041] = (char )' ';
#line 380
  usage[1042] = (char )' ';
#line 380
  usage[1043] = (char )' ';
#line 380
  usage[1044] = (char )' ';
#line 380
  usage[1045] = (char )' ';
#line 380
  usage[1046] = (char )' ';
#line 380
  usage[1047] = (char )' ';
#line 380
  usage[1048] = (char )' ';
#line 380
  usage[1049] = (char )' ';
#line 380
  usage[1050] = (char )' ';
#line 380
  usage[1051] = (char )'L';
#line 380
  usage[1052] = (char )'i';
#line 380
  usage[1053] = (char )'s';
#line 380
  usage[1054] = (char )'t';
#line 380
  usage[1055] = (char )'e';
#line 380
  usage[1056] = (char )'n';
#line 380
  usage[1057] = (char )' ';
#line 380
  usage[1058] = (char )'f';
#line 380
  usage[1059] = (char )'o';
#line 380
  usage[1060] = (char )'r';
#line 380
  usage[1061] = (char )' ';
#line 380
  usage[1062] = (char )'c';
#line 380
  usage[1063] = (char )'o';
#line 380
  usage[1064] = (char )'n';
#line 380
  usage[1065] = (char )'n';
#line 380
  usage[1066] = (char )'e';
#line 380
  usage[1067] = (char )'c';
#line 380
  usage[1068] = (char )'t';
#line 380
  usage[1069] = (char )'i';
#line 380
  usage[1070] = (char )'o';
#line 380
  usage[1071] = (char )'n';
#line 380
  usage[1072] = (char )'s';
#line 380
  usage[1073] = (char )' ';
#line 380
  usage[1074] = (char )'o';
#line 380
  usage[1075] = (char )'n';
#line 380
  usage[1076] = (char )' ';
#line 380
  usage[1077] = (char )'s';
#line 380
  usage[1078] = (char )'p';
#line 380
  usage[1079] = (char )'e';
#line 380
  usage[1080] = (char )'c';
#line 380
  usage[1081] = (char )'i';
#line 380
  usage[1082] = (char )'f';
#line 380
  usage[1083] = (char )'i';
#line 380
  usage[1084] = (char )'e';
#line 380
  usage[1085] = (char )'d';
#line 380
  usage[1086] = (char )' ';
#line 380
  usage[1087] = (char )'p';
#line 380
  usage[1088] = (char )'o';
#line 380
  usage[1089] = (char )'r';
#line 380
  usage[1090] = (char )'t';
#line 380
  usage[1091] = (char )'\n';
#line 380
  usage[1092] = (char )'-';
#line 380
  usage[1093] = (char )'q';
#line 380
  usage[1094] = (char )' ';
#line 380
  usage[1095] = (char )'o';
#line 380
  usage[1096] = (char )'r';
#line 380
  usage[1097] = (char )' ';
#line 380
  usage[1098] = (char )'-';
#line 380
  usage[1099] = (char )'-';
#line 380
  usage[1100] = (char )'q';
#line 380
  usage[1101] = (char )'u';
#line 380
  usage[1102] = (char )'i';
#line 380
  usage[1103] = (char )'e';
#line 380
  usage[1104] = (char )'t';
#line 380
  usage[1105] = (char )' ';
#line 380
  usage[1106] = (char )' ';
#line 380
  usage[1107] = (char )' ';
#line 380
  usage[1108] = (char )' ';
#line 380
  usage[1109] = (char )' ';
#line 380
  usage[1110] = (char )' ';
#line 380
  usage[1111] = (char )' ';
#line 380
  usage[1112] = (char )' ';
#line 380
  usage[1113] = (char )' ';
#line 380
  usage[1114] = (char )' ';
#line 380
  usage[1115] = (char )' ';
#line 380
  usage[1116] = (char )' ';
#line 380
  usage[1117] = (char )' ';
#line 380
  usage[1118] = (char )' ';
#line 380
  usage[1119] = (char )' ';
#line 380
  usage[1120] = (char )' ';
#line 380
  usage[1121] = (char )'S';
#line 380
  usage[1122] = (char )'u';
#line 380
  usage[1123] = (char )'p';
#line 380
  usage[1124] = (char )'p';
#line 380
  usage[1125] = (char )'r';
#line 380
  usage[1126] = (char )'e';
#line 380
  usage[1127] = (char )'s';
#line 380
  usage[1128] = (char )'s';
#line 380
  usage[1129] = (char )' ';
#line 380
  usage[1130] = (char )'n';
#line 380
  usage[1131] = (char )'o';
#line 380
  usage[1132] = (char )'r';
#line 380
  usage[1133] = (char )'m';
#line 380
  usage[1134] = (char )'a';
#line 380
  usage[1135] = (char )'l';
#line 380
  usage[1136] = (char )' ';
#line 380
  usage[1137] = (char )'l';
#line 380
  usage[1138] = (char )'o';
#line 380
  usage[1139] = (char )'g';
#line 380
  usage[1140] = (char )'g';
#line 380
  usage[1141] = (char )'i';
#line 380
  usage[1142] = (char )'n';
#line 380
  usage[1143] = (char )'g';
#line 380
  usage[1144] = (char )'\n';
#line 380
  usage[1145] = (char )'-';
#line 380
  usage[1146] = (char )'S';
#line 380
  usage[1147] = (char )' ';
#line 380
  usage[1148] = (char )'o';
#line 380
  usage[1149] = (char )'r';
#line 380
  usage[1150] = (char )' ';
#line 380
  usage[1151] = (char )'-';
#line 380
  usage[1152] = (char )'-';
#line 380
  usage[1153] = (char )'n';
#line 380
  usage[1154] = (char )'o';
#line 380
  usage[1155] = (char )'s';
#line 380
  usage[1156] = (char )'y';
#line 380
  usage[1157] = (char )'s';
#line 380
  usage[1158] = (char )'l';
#line 380
  usage[1159] = (char )'o';
#line 380
  usage[1160] = (char )'g';
#line 380
  usage[1161] = (char )' ';
#line 380
  usage[1162] = (char )' ';
#line 380
  usage[1163] = (char )' ';
#line 380
  usage[1164] = (char )' ';
#line 380
  usage[1165] = (char )' ';
#line 380
  usage[1166] = (char )' ';
#line 380
  usage[1167] = (char )' ';
#line 380
  usage[1168] = (char )' ';
#line 380
  usage[1169] = (char )' ';
#line 380
  usage[1170] = (char )' ';
#line 380
  usage[1171] = (char )' ';
#line 380
  usage[1172] = (char )' ';
#line 380
  usage[1173] = (char )' ';
#line 380
  usage[1174] = (char )'W';
#line 380
  usage[1175] = (char )'r';
#line 380
  usage[1176] = (char )'i';
#line 380
  usage[1177] = (char )'t';
#line 380
  usage[1178] = (char )'e';
#line 380
  usage[1179] = (char )' ';
#line 380
  usage[1180] = (char )'m';
#line 380
  usage[1181] = (char )'e';
#line 380
  usage[1182] = (char )'s';
#line 380
  usage[1183] = (char )'s';
#line 380
  usage[1184] = (char )'a';
#line 380
  usage[1185] = (char )'g';
#line 380
  usage[1186] = (char )'e';
#line 380
  usage[1187] = (char )'s';
#line 380
  usage[1188] = (char )' ';
#line 380
  usage[1189] = (char )'t';
#line 380
  usage[1190] = (char )'o';
#line 380
  usage[1191] = (char )' ';
#line 380
  usage[1192] = (char )'s';
#line 380
  usage[1193] = (char )'t';
#line 380
  usage[1194] = (char )'d';
#line 380
  usage[1195] = (char )'e';
#line 380
  usage[1196] = (char )'r';
#line 380
  usage[1197] = (char )'r';
#line 380
  usage[1198] = (char )' ';
#line 380
  usage[1199] = (char )'n';
#line 380
  usage[1200] = (char )'o';
#line 380
  usage[1201] = (char )'t';
#line 380
  usage[1202] = (char )' ';
#line 380
  usage[1203] = (char )'s';
#line 380
  usage[1204] = (char )'y';
#line 380
  usage[1205] = (char )'s';
#line 380
  usage[1206] = (char )'l';
#line 380
  usage[1207] = (char )'o';
#line 380
  usage[1208] = (char )'g';
#line 380
  usage[1209] = (char )'\n';
#line 380
  usage[1210] = (char )'-';
#line 380
  usage[1211] = (char )'t';
#line 380
  usage[1212] = (char )' ';
#line 380
  usage[1213] = (char )'o';
#line 380
  usage[1214] = (char )'r';
#line 380
  usage[1215] = (char )' ';
#line 380
  usage[1216] = (char )'-';
#line 380
  usage[1217] = (char )'-';
#line 380
  usage[1218] = (char )'t';
#line 380
  usage[1219] = (char )'i';
#line 380
  usage[1220] = (char )'m';
#line 380
  usage[1221] = (char )'e';
#line 380
  usage[1222] = (char )'o';
#line 380
  usage[1223] = (char )'u';
#line 380
  usage[1224] = (char )'t';
#line 380
  usage[1225] = (char )' ';
#line 380
  usage[1226] = (char )'<';
#line 380
  usage[1227] = (char )'s';
#line 380
  usage[1228] = (char )'e';
#line 380
  usage[1229] = (char )'c';
#line 380
  usage[1230] = (char )'o';
#line 380
  usage[1231] = (char )'n';
#line 380
  usage[1232] = (char )'d';
#line 380
  usage[1233] = (char )'s';
#line 380
  usage[1234] = (char )'>';
#line 380
  usage[1235] = (char )' ';
#line 380
  usage[1236] = (char )' ';
#line 380
  usage[1237] = (char )' ';
#line 380
  usage[1238] = (char )' ';
#line 380
  usage[1239] = (char )'W';
#line 380
  usage[1240] = (char )'a';
#line 380
  usage[1241] = (char )'i';
#line 380
  usage[1242] = (char )'t';
#line 380
  usage[1243] = (char )' ';
#line 380
  usage[1244] = (char )'f';
#line 380
  usage[1245] = (char )'o';
#line 380
  usage[1246] = (char )'r';
#line 380
  usage[1247] = (char )' ';
#line 380
  usage[1248] = (char )'<';
#line 380
  usage[1249] = (char )'s';
#line 380
  usage[1250] = (char )'e';
#line 380
  usage[1251] = (char )'c';
#line 380
  usage[1252] = (char )'o';
#line 380
  usage[1253] = (char )'n';
#line 380
  usage[1254] = (char )'d';
#line 380
  usage[1255] = (char )'s';
#line 380
  usage[1256] = (char )'>';
#line 380
  usage[1257] = (char )' ';
#line 380
  usage[1258] = (char )'b';
#line 380
  usage[1259] = (char )'e';
#line 380
  usage[1260] = (char )'f';
#line 380
  usage[1261] = (char )'o';
#line 380
  usage[1262] = (char )'r';
#line 380
  usage[1263] = (char )'e';
#line 380
  usage[1264] = (char )' ';
#line 380
  usage[1265] = (char )'c';
#line 380
  usage[1266] = (char )'l';
#line 380
  usage[1267] = (char )'o';
#line 380
  usage[1268] = (char )'s';
#line 380
  usage[1269] = (char )'i';
#line 380
  usage[1270] = (char )'n';
#line 380
  usage[1271] = (char )'g';
#line 380
  usage[1272] = (char )' ';
#line 380
  usage[1273] = (char )'c';
#line 380
  usage[1274] = (char )'o';
#line 380
  usage[1275] = (char )'n';
#line 380
  usage[1276] = (char )'n';
#line 380
  usage[1277] = (char )'e';
#line 380
  usage[1278] = (char )'c';
#line 380
  usage[1279] = (char )'t';
#line 380
  usage[1280] = (char )'i';
#line 380
  usage[1281] = (char )'o';
#line 380
  usage[1282] = (char )'n';
#line 380
  usage[1283] = (char )'\n';
#line 380
  usage[1284] = (char )'-';
#line 380
  usage[1285] = (char )'u';
#line 380
  usage[1286] = (char )' ';
#line 380
  usage[1287] = (char )'o';
#line 380
  usage[1288] = (char )'r';
#line 380
  usage[1289] = (char )' ';
#line 380
  usage[1290] = (char )'-';
#line 380
  usage[1291] = (char )'-';
#line 380
  usage[1292] = (char )'u';
#line 380
  usage[1293] = (char )'s';
#line 380
  usage[1294] = (char )'e';
#line 380
  usage[1295] = (char )'r';
#line 380
  usage[1296] = (char )' ';
#line 380
  usage[1297] = (char )'<';
#line 380
  usage[1298] = (char )'u';
#line 380
  usage[1299] = (char )'s';
#line 380
  usage[1300] = (char )'e';
#line 380
  usage[1301] = (char )'r';
#line 380
  usage[1302] = (char )'>';
#line 380
  usage[1303] = (char )' ';
#line 380
  usage[1304] = (char )' ';
#line 380
  usage[1305] = (char )' ';
#line 380
  usage[1306] = (char )' ';
#line 380
  usage[1307] = (char )' ';
#line 380
  usage[1308] = (char )' ';
#line 380
  usage[1309] = (char )' ';
#line 380
  usage[1310] = (char )' ';
#line 380
  usage[1311] = (char )' ';
#line 380
  usage[1312] = (char )' ';
#line 380
  usage[1313] = (char )'R';
#line 380
  usage[1314] = (char )'u';
#line 380
  usage[1315] = (char )'n';
#line 380
  usage[1316] = (char )' ';
#line 380
  usage[1317] = (char )'a';
#line 380
  usage[1318] = (char )'s';
#line 380
  usage[1319] = (char )' ';
#line 380
  usage[1320] = (char )'s';
#line 380
  usage[1321] = (char )'p';
#line 380
  usage[1322] = (char )'e';
#line 380
  usage[1323] = (char )'c';
#line 380
  usage[1324] = (char )'i';
#line 380
  usage[1325] = (char )'f';
#line 380
  usage[1326] = (char )'i';
#line 380
  usage[1327] = (char )'e';
#line 380
  usage[1328] = (char )'d';
#line 380
  usage[1329] = (char )' ';
#line 380
  usage[1330] = (char )'u';
#line 380
  usage[1331] = (char )'s';
#line 380
  usage[1332] = (char )'e';
#line 380
  usage[1333] = (char )'r';
#line 380
  usage[1334] = (char )' ';
#line 380
  usage[1335] = (char )'o';
#line 380
  usage[1336] = (char )'r';
#line 380
  usage[1337] = (char )' ';
#line 380
  usage[1338] = (char )'U';
#line 380
  usage[1339] = (char )'I';
#line 380
  usage[1340] = (char )'D';
#line 380
  usage[1341] = (char )'\n';
#line 380
  usage[1342] = (char )'-';
#line 380
  usage[1343] = (char )'v';
#line 380
  usage[1344] = (char )' ';
#line 380
  usage[1345] = (char )'o';
#line 380
  usage[1346] = (char )'r';
#line 380
  usage[1347] = (char )' ';
#line 380
  usage[1348] = (char )'-';
#line 380
  usage[1349] = (char )'-';
#line 380
  usage[1350] = (char )'v';
#line 380
  usage[1351] = (char )'e';
#line 380
  usage[1352] = (char )'r';
#line 380
  usage[1353] = (char )'s';
#line 380
  usage[1354] = (char )'i';
#line 380
  usage[1355] = (char )'o';
#line 380
  usage[1356] = (char )'n';
#line 380
  usage[1357] = (char )' ';
#line 380
  usage[1358] = (char )' ';
#line 380
  usage[1359] = (char )' ';
#line 380
  usage[1360] = (char )' ';
#line 380
  usage[1361] = (char )' ';
#line 380
  usage[1362] = (char )' ';
#line 380
  usage[1363] = (char )' ';
#line 380
  usage[1364] = (char )' ';
#line 380
  usage[1365] = (char )' ';
#line 380
  usage[1366] = (char )' ';
#line 380
  usage[1367] = (char )' ';
#line 380
  usage[1368] = (char )' ';
#line 380
  usage[1369] = (char )' ';
#line 380
  usage[1370] = (char )' ';
#line 380
  usage[1371] = (char )'D';
#line 380
  usage[1372] = (char )'i';
#line 380
  usage[1373] = (char )'s';
#line 380
  usage[1374] = (char )'p';
#line 380
  usage[1375] = (char )'l';
#line 380
  usage[1376] = (char )'a';
#line 380
  usage[1377] = (char )'y';
#line 380
  usage[1378] = (char )' ';
#line 380
  usage[1379] = (char )'v';
#line 380
  usage[1380] = (char )'e';
#line 380
  usage[1381] = (char )'r';
#line 380
  usage[1382] = (char )'s';
#line 380
  usage[1383] = (char )'i';
#line 380
  usage[1384] = (char )'o';
#line 380
  usage[1385] = (char )'n';
#line 380
  usage[1386] = (char )' ';
#line 380
  usage[1387] = (char )'i';
#line 380
  usage[1388] = (char )'n';
#line 380
  usage[1389] = (char )'f';
#line 380
  usage[1390] = (char )'o';
#line 380
  usage[1391] = (char )'r';
#line 380
  usage[1392] = (char )'m';
#line 380
  usage[1393] = (char )'a';
#line 380
  usage[1394] = (char )'t';
#line 380
  usage[1395] = (char )'i';
#line 380
  usage[1396] = (char )'o';
#line 380
  usage[1397] = (char )'n';
#line 380
  usage[1398] = (char )' ';
#line 380
  usage[1399] = (char )'a';
#line 380
  usage[1400] = (char )'n';
#line 380
  usage[1401] = (char )'d';
#line 380
  usage[1402] = (char )' ';
#line 380
  usage[1403] = (char )'e';
#line 380
  usage[1404] = (char )'x';
#line 380
  usage[1405] = (char )'i';
#line 380
  usage[1406] = (char )'t';
#line 380
  usage[1407] = (char )'\n';
#line 380
  usage[1408] = (char )'-';
#line 380
  usage[1409] = (char )'r';
#line 380
  usage[1410] = (char )' ';
#line 380
  usage[1411] = (char )'o';
#line 380
  usage[1412] = (char )'r';
#line 380
  usage[1413] = (char )' ';
#line 380
  usage[1414] = (char )'-';
#line 380
  usage[1415] = (char )'-';
#line 380
  usage[1416] = (char )'r';
#line 380
  usage[1417] = (char )'e';
#line 380
  usage[1418] = (char )'p';
#line 380
  usage[1419] = (char )'l';
#line 380
  usage[1420] = (char )'y';
#line 380
  usage[1421] = (char )' ';
#line 380
  usage[1422] = (char )'<';
#line 380
  usage[1423] = (char )'s';
#line 380
  usage[1424] = (char )'t';
#line 380
  usage[1425] = (char )'r';
#line 380
  usage[1426] = (char )'i';
#line 380
  usage[1427] = (char )'n';
#line 380
  usage[1428] = (char )'g';
#line 380
  usage[1429] = (char )'>';
#line 380
  usage[1430] = (char )' ';
#line 380
  usage[1431] = (char )' ';
#line 380
  usage[1432] = (char )' ';
#line 380
  usage[1433] = (char )' ';
#line 380
  usage[1434] = (char )' ';
#line 380
  usage[1435] = (char )' ';
#line 380
  usage[1436] = (char )' ';
#line 380
  usage[1437] = (char )'I';
#line 380
  usage[1438] = (char )'f';
#line 380
  usage[1439] = (char )' ';
#line 380
  usage[1440] = (char )'a';
#line 380
  usage[1441] = (char )' ';
#line 380
  usage[1442] = (char )'q';
#line 380
  usage[1443] = (char )'u';
#line 380
  usage[1444] = (char )'e';
#line 380
  usage[1445] = (char )'r';
#line 380
  usage[1446] = (char )'y';
#line 380
  usage[1447] = (char )' ';
#line 380
  usage[1448] = (char )'f';
#line 380
  usage[1449] = (char )'a';
#line 380
  usage[1450] = (char )'i';
#line 380
  usage[1451] = (char )'l';
#line 380
  usage[1452] = (char )'s';
#line 380
  usage[1453] = (char )',';
#line 380
  usage[1454] = (char )' ';
#line 380
  usage[1455] = (char )'p';
#line 380
  usage[1456] = (char )'r';
#line 380
  usage[1457] = (char )'e';
#line 380
  usage[1458] = (char )'t';
#line 380
  usage[1459] = (char )'e';
#line 380
  usage[1460] = (char )'n';
#line 380
  usage[1461] = (char )'d';
#line 380
  usage[1462] = (char )' ';
#line 380
  usage[1463] = (char )'i';
#line 380
  usage[1464] = (char )'t';
#line 380
  usage[1465] = (char )' ';
#line 380
  usage[1466] = (char )'s';
#line 380
  usage[1467] = (char )'u';
#line 380
  usage[1468] = (char )'c';
#line 380
  usage[1469] = (char )'c';
#line 380
  usage[1470] = (char )'e';
#line 380
  usage[1471] = (char )'e';
#line 380
  usage[1472] = (char )'d';
#line 380
  usage[1473] = (char )'e';
#line 380
  usage[1474] = (char )'d';
#line 380
  usage[1475] = (char )',';
#line 380
  usage[1476] = (char )' ';
#line 380
  usage[1477] = (char )'r';
#line 380
  usage[1478] = (char )'e';
#line 380
  usage[1479] = (char )'t';
#line 380
  usage[1480] = (char )'u';
#line 380
  usage[1481] = (char )'r';
#line 380
  usage[1482] = (char )'n';
#line 380
  usage[1483] = (char )'i';
#line 380
  usage[1484] = (char )'n';
#line 380
  usage[1485] = (char )'g';
#line 380
  usage[1486] = (char )' ';
#line 380
  usage[1487] = (char )'<';
#line 380
  usage[1488] = (char )'s';
#line 380
  usage[1489] = (char )'t';
#line 380
  usage[1490] = (char )'r';
#line 380
  usage[1491] = (char )'i';
#line 380
  usage[1492] = (char )'n';
#line 380
  usage[1493] = (char )'g';
#line 380
  usage[1494] = (char )'>';
#line 380
  usage[1495] = (char )'\n';
#line 380
  usage[1496] = (char )'-';
#line 380
  usage[1497] = (char )'h';
#line 380
  usage[1498] = (char )' ';
#line 380
  usage[1499] = (char )'o';
#line 380
  usage[1500] = (char )'r';
#line 380
  usage[1501] = (char )' ';
#line 380
  usage[1502] = (char )'-';
#line 380
  usage[1503] = (char )'-';
#line 380
  usage[1504] = (char )'h';
#line 380
  usage[1505] = (char )'e';
#line 380
  usage[1506] = (char )'l';
#line 380
  usage[1507] = (char )'p';
#line 380
  usage[1508] = (char )' ';
#line 380
  usage[1509] = (char )' ';
#line 380
  usage[1510] = (char )' ';
#line 380
  usage[1511] = (char )' ';
#line 380
  usage[1512] = (char )' ';
#line 380
  usage[1513] = (char )' ';
#line 380
  usage[1514] = (char )' ';
#line 380
  usage[1515] = (char )' ';
#line 380
  usage[1516] = (char )' ';
#line 380
  usage[1517] = (char )' ';
#line 380
  usage[1518] = (char )' ';
#line 380
  usage[1519] = (char )' ';
#line 380
  usage[1520] = (char )' ';
#line 380
  usage[1521] = (char )' ';
#line 380
  usage[1522] = (char )' ';
#line 380
  usage[1523] = (char )' ';
#line 380
  usage[1524] = (char )' ';
#line 380
  usage[1525] = (char )'T';
#line 380
  usage[1526] = (char )'h';
#line 380
  usage[1527] = (char )'i';
#line 380
  usage[1528] = (char )'s';
#line 380
  usage[1529] = (char )' ';
#line 380
  usage[1530] = (char )'h';
#line 380
  usage[1531] = (char )'e';
#line 380
  usage[1532] = (char )'l';
#line 380
  usage[1533] = (char )'p';
#line 380
  usage[1534] = (char )' ';
#line 380
  usage[1535] = (char )'m';
#line 380
  usage[1536] = (char )'e';
#line 380
  usage[1537] = (char )'s';
#line 380
  usage[1538] = (char )'s';
#line 380
  usage[1539] = (char )'a';
#line 380
  usage[1540] = (char )'g';
#line 380
  usage[1541] = (char )'e';
#line 380
  usage[1542] = (char )'\n';
#line 380
  usage[1543] = (char )'\000';
#line 413
  print_version();
#line 414
  printf((char const   */* __restrict  */)"%s", usage);
  }
#line 415
  return;
}
}
#line 417 "/home/wheatley/newnew/temp/oidentd-2.0.8/src/oidentd_options.c"
static void print_version(void) 
{ 


  {
  {
#line 418
  printf((char const   */* __restrict  */)"%s\n", "oidentd 2.0.8");
#line 419
  printf((char const   */* __restrict  */)"Written by %s <%s>\n", "Ryan McCabe", "ryan@numb.org");
#line 420
  printf((char const   */* __restrict  */)"%s\n", "http://dev.ojnk.net");
  }
#line 421
  return;
}
}
