/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 61 "/usr/include/signal.h"
typedef __pid_t pid_t;
#line 67 "/usr/include/signal.h"
typedef __uid_t uid_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 44 "/usr/include/x86_64-linux-gnu/sys/stat.h"
typedef __dev_t dev_t;
#line 49 "/usr/include/x86_64-linux-gnu/sys/stat.h"
typedef __gid_t gid_t;
#line 55 "/usr/include/x86_64-linux-gnu/sys/stat.h"
typedef __ino_t ino_t;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 132 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
typedef int BOOL;
#line 141 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
typedef unsigned long ULONG;
#line 142
struct COLUMN;
#line 142 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
typedef struct COLUMN COLUMN;
#line 157 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
struct __anonstruct_ARGS_65 {
   int count ;
   char **table ;
};
#line 157 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
typedef struct __anonstruct_ARGS_65 ARGS;
#line 173
struct PROC;
#line 173 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
typedef struct PROC PROC;
#line 175 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
struct PROC {
   PROC *next ;
   PROC *nextThread ;
   PROC *owner ;
   BOOL isValid ;
   BOOL isAncient ;
   BOOL isNew ;
   BOOL isActive ;
   BOOL isChanged ;
   BOOL isShown ;
   BOOL hasCommand ;
   BOOL isThread ;
   ULONG liveCounter ;
   ULONG runOrder ;
   time_t lastSavedTime ;
   time_t lastActiveTime ;
   time_t lastSyncTime ;
   time_t deathTime ;
   uid_t uid ;
   gid_t gid ;
   pid_t pid ;
   pthread_t tid ;
   pid_t parentPid ;
   pid_t processGroup ;
   pid_t sessionId ;
   dev_t ttyDevice ;
   pid_t ttyProcessGroup ;
   int state ;
   int processor ;
   int exitSignal ;
   ULONG flags ;
   long minorFaults ;
   long majorFaults ;
   long childMinorFaults ;
   long childMajorFaults ;
   long userRunTime ;
   long systemRunTime ;
   long childUserRunTime ;
   long childSystemRunTime ;
   long nice ;
   long priority ;
   long realTimePriority ;
   long timeout ;
   long itRealValue ;
   long virtualSize ;
   long rss ;
   long rssLimit ;
   long policy ;
   time_t startTimeClock ;
   ULONG startTimeTicks ;
   ULONG firstCpuTime ;
   ULONG startCode ;
   ULONG endCode ;
   ULONG startStack ;
   ULONG esp ;
   ULONG eip ;
   ULONG waitChan ;
   ULONG signal ;
   ULONG sigBlock ;
   ULONG sigIgnore ;
   ULONG sigCatch ;
   ULONG pagesSwapped ;
   ULONG childPagesSwapped ;
   int percentCpu ;
   int percentMemory ;
   int openFiles ;
   int threadCount ;
   int commandLength ;
   int environmentLength ;
   int cwdPathLength ;
   int rootPathLength ;
   int execPathLength ;
   char *command ;
   char *environment ;
   char *cwdPath ;
   char *rootPath ;
   char *execPath ;
   char *stdioPaths[3] ;
   char program[34] ;
   char commandBuffer[130] ;
   char waitChanSymbol[34] ;
   char states[18] ;
   long cpuTable[102] ;
   int oldState ;
   int oldFlags ;
   long oldMinorFaults ;
   long oldMajorFaults ;
   long oldUserRunTime ;
   long oldSystemRunTime ;
   ULONG oldStartTimeTicks ;
   ULONG oldEndCode ;
   ULONG oldEsp ;
   ULONG oldEip ;
   ULONG oldWaitChan ;
};
#line 291 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
typedef int JUSTIFY;
#line 301 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
struct __anonstruct_VALUE_66 {
   int type ;
   long intVal ;
   char const   *strVal ;
   COLUMN *column ;
};
#line 301 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
typedef struct __anonstruct_VALUE_66 VALUE;
#line 324 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
typedef unsigned int USEFLAG;
#line 348 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
struct COLUMN {
   char *name ;
   char *heading ;
   int minWidth ;
   int initWidth ;
   int width ;
   JUSTIFY justify ;
   USEFLAG useFlag ;
   char const   *(*showFunc)(PROC const   *proc ) ;
   int (*sortFunc)(PROC const   *proc1 , PROC const   *proc2 ) ;
   void (*evalFunc)(PROC const   *proc , VALUE *retval ) ;
   BOOL (*testFunc)(PROC const   *proc ) ;
};
#line 369 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
typedef int MACRO_TYPE;
#line 382
struct DISPLAY;
#line 382 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
typedef struct DISPLAY DISPLAY;
#line 384 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
struct DISPLAY {
   BOOL (*open)(DISPLAY * ) ;
   BOOL (*defineColor)(DISPLAY * , int  , char const   * , char const   * , int  ) ;
   void (*createWindow)(DISPLAY * ) ;
   void (*close)(DISPLAY * ) ;
   void (*setColor)(DISPLAY * , int  ) ;
   void (*refresh)(DISPLAY * ) ;
   void (*beginPage)(DISPLAY * ) ;
   void (*putChar)(DISPLAY * , int  ) ;
   void (*putString)(DISPLAY * , char const   * ) ;
   void (*putBuffer)(DISPLAY * , char const   * , int  ) ;
   void (*endPage)(DISPLAY * ) ;
   BOOL (*eventWait)(DISPLAY * , int  ) ;
   BOOL (*inputReady)(DISPLAY * ) ;
   int (*readChar)(DISPLAY * ) ;
   void (*ringBell)(DISPLAY * ) ;
   int (*getRows)(DISPLAY * ) ;
   int (*getCols)(DISPLAY * ) ;
   BOOL (*doesScroll)(DISPLAY * ) ;
};
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 46 "/home/june/repo/benchmarks/collector/temp/ips-4.0/expr.h"
typedef int OP;
#line 82 "/home/june/repo/benchmarks/collector/temp/ips-4.0/expr.h"
typedef int TOKEN;
#line 124
struct NODE;
#line 124 "/home/june/repo/benchmarks/collector/temp/ips-4.0/expr.h"
typedef struct NODE NODE;
#line 126 "/home/june/repo/benchmarks/collector/temp/ips-4.0/expr.h"
struct NODE {
   OP op ;
   NODE *child[3] ;
   COLUMN *column ;
   char *strVal ;
   long intVal ;
};
#line 139 "/home/june/repo/benchmarks/collector/temp/ips-4.0/expr.h"
struct __anonstruct_TREE_43 {
   char *expr ;
   char *modExpr ;
   char *cp ;
   TOKEN token ;
   char *tokenStr ;
   long tokenInt ;
   BOOL rescanToken ;
   NODE *root ;
   PROC const   *proc ;
   int depth ;
   BOOL failed ;
};
#line 139 "/home/june/repo/benchmarks/collector/temp/ips-4.0/expr.h"
typedef struct __anonstruct_TREE_43 TREE;
#line 23 "/home/june/repo/benchmarks/collector/temp/ips-4.0/color.c"
struct __anonstruct_ColorData_44 {
   char const   *foreground ;
   char const   *background ;
   int flags ;
};
#line 23 "/home/june/repo/benchmarks/collector/temp/ips-4.0/color.c"
typedef struct __anonstruct_ColorData_44 ColorData;
#line 36 "/home/june/repo/benchmarks/collector/temp/ips-4.0/color.c"
struct __anonstruct_RowColor_45 {
   int colorId ;
   TREE tree ;
};
#line 36 "/home/june/repo/benchmarks/collector/temp/ips-4.0/color.c"
typedef struct __anonstruct_RowColor_45 RowColor;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_48 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_48 fd_set;
#line 27 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ttydisplay.c"
struct __anonstruct_COLOR_INFO_67 {
   char const   *name ;
   short foreground ;
   short background ;
};
#line 27 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ttydisplay.c"
typedef struct __anonstruct_COLOR_INFO_67 COLOR_INFO;
#line 66 "/usr/include/X11/X.h"
typedef unsigned long XID;
#line 74 "/usr/include/X11/X.h"
typedef unsigned long Atom;
#line 76 "/usr/include/X11/X.h"
typedef unsigned long VisualID;
#line 77 "/usr/include/X11/X.h"
typedef unsigned long Time;
#line 96 "/usr/include/X11/X.h"
typedef XID Window;
#line 97 "/usr/include/X11/X.h"
typedef XID Drawable;
#line 100 "/usr/include/X11/X.h"
typedef XID Font;
#line 102 "/usr/include/X11/X.h"
typedef XID Pixmap;
#line 104 "/usr/include/X11/X.h"
typedef XID Colormap;
#line 106 "/usr/include/X11/X.h"
typedef XID KeySym;
#line 92 "/usr/include/X11/Xlib.h"
typedef char *XPointer;
#line 160 "/usr/include/X11/Xlib.h"
struct _XExtData {
   int number ;
   struct _XExtData *next ;
   int (*free_private)(struct _XExtData *extension ) ;
   XPointer private_data ;
};
#line 160 "/usr/include/X11/Xlib.h"
typedef struct _XExtData XExtData;
#line 193 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGCValues_16 {
   int function ;
   unsigned long plane_mask ;
   unsigned long foreground ;
   unsigned long background ;
   int line_width ;
   int line_style ;
   int cap_style ;
   int join_style ;
   int fill_style ;
   int fill_rule ;
   int arc_mode ;
   Pixmap tile ;
   Pixmap stipple ;
   int ts_x_origin ;
   int ts_y_origin ;
   Font font ;
   int subwindow_mode ;
   int graphics_exposures ;
   int clip_x_origin ;
   int clip_y_origin ;
   Pixmap clip_mask ;
   int dash_offset ;
   char dashes ;
};
#line 193 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGCValues_16 XGCValues;
#line 226
struct _XGC;
#line 226 "/usr/include/X11/Xlib.h"
typedef struct _XGC *GC;
#line 239 "/usr/include/X11/Xlib.h"
struct __anonstruct_Visual_17 {
   XExtData *ext_data ;
   VisualID visualid ;
   int class ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   int bits_per_rgb ;
   int map_entries ;
};
#line 239 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Visual_17 Visual;
#line 255 "/usr/include/X11/Xlib.h"
struct __anonstruct_Depth_18 {
   int depth ;
   int nvisuals ;
   Visual *visuals ;
};
#line 255 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Depth_18 Depth;
#line 267
struct _XDisplay;
#line 269 "/usr/include/X11/Xlib.h"
struct __anonstruct_Screen_19 {
   XExtData *ext_data ;
   struct _XDisplay *display ;
   Window root ;
   int width ;
   int height ;
   int mwidth ;
   int mheight ;
   int ndepths ;
   Depth *depths ;
   int root_depth ;
   Visual *root_visual ;
   GC default_gc ;
   Colormap cmap ;
   unsigned long white_pixel ;
   unsigned long black_pixel ;
   int max_maps ;
   int min_maps ;
   int backing_store ;
   int save_unders ;
   long root_input_mask ;
};
#line 269 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Screen_19 Screen;
#line 292 "/usr/include/X11/Xlib.h"
struct __anonstruct_ScreenFormat_20 {
   XExtData *ext_data ;
   int depth ;
   int bits_per_pixel ;
   int scanline_pad ;
};
#line 292 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_ScreenFormat_20 ScreenFormat;
#line 422 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColor_26 {
   unsigned long pixel ;
   unsigned short red ;
   unsigned short green ;
   unsigned short blue ;
   char flags ;
   char pad ;
};
#line 422 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColor_26 XColor;
#line 499 "/usr/include/X11/Xlib.h"
typedef struct _XDisplay Display;
#line 502
struct _XPrivate;
#line 503
struct _XrmHashBucketRec;
#line 505 "/usr/include/X11/Xlib.h"
struct __anonstruct__XPrivDisplay_35 {
   XExtData *ext_data ;
   struct _XPrivate *private1 ;
   int fd ;
   int private2 ;
   int proto_major_version ;
   int proto_minor_version ;
   char *vendor ;
   XID private3 ;
   XID private4 ;
   XID private5 ;
   int private6 ;
   XID (*resource_alloc)(struct _XDisplay * ) ;
   int byte_order ;
   int bitmap_unit ;
   int bitmap_pad ;
   int bitmap_bit_order ;
   int nformats ;
   ScreenFormat *pixmap_format ;
   int private8 ;
   int release ;
   struct _XPrivate *private9 ;
   struct _XPrivate *private10 ;
   int qlen ;
   unsigned long last_request_read ;
   unsigned long request ;
   XPointer private11 ;
   XPointer private12 ;
   XPointer private13 ;
   XPointer private14 ;
   unsigned int max_request_size ;
   struct _XrmHashBucketRec *db ;
   int (*private15)(struct _XDisplay * ) ;
   char *display_name ;
   int default_screen ;
   int nscreens ;
   Screen *screens ;
   unsigned long motion_buffer ;
   unsigned long private16 ;
   int min_keycode ;
   int max_keycode ;
   XPointer private17 ;
   XPointer private18 ;
   int private19 ;
   char *xdefaults ;
};
#line 505 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct__XPrivDisplay_35 *_XPrivDisplay;
#line 569 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeyEvent_36 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int keycode ;
   int same_screen ;
};
#line 569 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeyEvent_36 XKeyEvent;
#line 587 "/usr/include/X11/Xlib.h"
struct __anonstruct_XButtonEvent_37 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int button ;
   int same_screen ;
};
#line 587 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XButtonEvent_37 XButtonEvent;
#line 605 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMotionEvent_38 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   char is_hint ;
   int same_screen ;
};
#line 605 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMotionEvent_38 XMotionEvent;
#line 622 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCrossingEvent_39 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   int mode ;
   int detail ;
   int same_screen ;
   int focus ;
   unsigned int state ;
};
#line 622 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCrossingEvent_39 XCrossingEvent;
#line 646 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFocusChangeEvent_40 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int mode ;
   int detail ;
};
#line 646 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFocusChangeEvent_40 XFocusChangeEvent;
#line 665 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeymapEvent_41 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   char key_vector[32] ;
};
#line 665 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeymapEvent_41 XKeymapEvent;
#line 674 "/usr/include/X11/Xlib.h"
struct __anonstruct_XExposeEvent_42 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
};
#line 674 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XExposeEvent_42 XExposeEvent;
#line 685 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGraphicsExposeEvent_43 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
   int major_code ;
   int minor_code ;
};
#line 685 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGraphicsExposeEvent_43 XGraphicsExposeEvent;
#line 698 "/usr/include/X11/Xlib.h"
struct __anonstruct_XNoExposeEvent_44 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int major_code ;
   int minor_code ;
};
#line 698 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XNoExposeEvent_44 XNoExposeEvent;
#line 708 "/usr/include/X11/Xlib.h"
struct __anonstruct_XVisibilityEvent_45 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int state ;
};
#line 708 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XVisibilityEvent_45 XVisibilityEvent;
#line 717 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCreateWindowEvent_46 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   int override_redirect ;
};
#line 717 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCreateWindowEvent_46 XCreateWindowEvent;
#line 730 "/usr/include/X11/Xlib.h"
struct __anonstruct_XDestroyWindowEvent_47 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
};
#line 730 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XDestroyWindowEvent_47 XDestroyWindowEvent;
#line 739 "/usr/include/X11/Xlib.h"
struct __anonstruct_XUnmapEvent_48 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int from_configure ;
};
#line 739 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XUnmapEvent_48 XUnmapEvent;
#line 749 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapEvent_49 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int override_redirect ;
};
#line 749 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapEvent_49 XMapEvent;
#line 759 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapRequestEvent_50 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
};
#line 759 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapRequestEvent_50 XMapRequestEvent;
#line 768 "/usr/include/X11/Xlib.h"
struct __anonstruct_XReparentEvent_51 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   Window parent ;
   int x ;
   int y ;
   int override_redirect ;
};
#line 768 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XReparentEvent_51 XReparentEvent;
#line 780 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureEvent_52 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int override_redirect ;
};
#line 780 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureEvent_52 XConfigureEvent;
#line 794 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGravityEvent_53 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
};
#line 794 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGravityEvent_53 XGravityEvent;
#line 804 "/usr/include/X11/Xlib.h"
struct __anonstruct_XResizeRequestEvent_54 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int width ;
   int height ;
};
#line 804 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XResizeRequestEvent_54 XResizeRequestEvent;
#line 813 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureRequestEvent_55 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int detail ;
   unsigned long value_mask ;
};
#line 813 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureRequestEvent_55 XConfigureRequestEvent;
#line 828 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateEvent_56 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int place ;
};
#line 828 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateEvent_56 XCirculateEvent;
#line 838 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateRequestEvent_57 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int place ;
};
#line 838 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateRequestEvent_57 XCirculateRequestEvent;
#line 848 "/usr/include/X11/Xlib.h"
struct __anonstruct_XPropertyEvent_58 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom atom ;
   Time time ;
   int state ;
};
#line 848 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XPropertyEvent_58 XPropertyEvent;
#line 859 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionClearEvent_59 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom selection ;
   Time time ;
};
#line 859 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionClearEvent_59 XSelectionClearEvent;
#line 869 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionRequestEvent_60 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window owner ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 869 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionRequestEvent_60 XSelectionRequestEvent;
#line 882 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionEvent_61 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 882 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionEvent_61 XSelectionEvent;
#line 894 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColormapEvent_62 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Colormap colormap ;
   int new ;
   int state ;
};
#line 894 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColormapEvent_62 XColormapEvent;
#line 909 "/usr/include/X11/Xlib.h"
union __anonunion_data_64 {
   char b[20] ;
   short s[10] ;
   long l[5] ;
};
#line 909 "/usr/include/X11/Xlib.h"
struct __anonstruct_XClientMessageEvent_63 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom message_type ;
   int format ;
   union __anonunion_data_64 data ;
};
#line 909 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XClientMessageEvent_63 XClientMessageEvent;
#line 924 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMappingEvent_65 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int request ;
   int first_keycode ;
   int count ;
};
#line 924 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMappingEvent_65 XMappingEvent;
#line 936 "/usr/include/X11/Xlib.h"
struct __anonstruct_XErrorEvent_66 {
   int type ;
   Display *display ;
   XID resourceid ;
   unsigned long serial ;
   unsigned char error_code ;
   unsigned char request_code ;
   unsigned char minor_code ;
};
#line 936 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XErrorEvent_66 XErrorEvent;
#line 946 "/usr/include/X11/Xlib.h"
struct __anonstruct_XAnyEvent_67 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
};
#line 946 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XAnyEvent_67 XAnyEvent;
#line 960 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEvent_68 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
};
#line 960 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEvent_68 XGenericEvent;
#line 970 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEventCookie_69 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
   unsigned int cookie ;
   void *data ;
};
#line 970 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEventCookie_69 XGenericEventCookie;
#line 985 "/usr/include/X11/Xlib.h"
union _XEvent {
   int type ;
   XAnyEvent xany ;
   XKeyEvent xkey ;
   XButtonEvent xbutton ;
   XMotionEvent xmotion ;
   XCrossingEvent xcrossing ;
   XFocusChangeEvent xfocus ;
   XExposeEvent xexpose ;
   XGraphicsExposeEvent xgraphicsexpose ;
   XNoExposeEvent xnoexpose ;
   XVisibilityEvent xvisibility ;
   XCreateWindowEvent xcreatewindow ;
   XDestroyWindowEvent xdestroywindow ;
   XUnmapEvent xunmap ;
   XMapEvent xmap ;
   XMapRequestEvent xmaprequest ;
   XReparentEvent xreparent ;
   XConfigureEvent xconfigure ;
   XGravityEvent xgravity ;
   XResizeRequestEvent xresizerequest ;
   XConfigureRequestEvent xconfigurerequest ;
   XCirculateEvent xcirculate ;
   XCirculateRequestEvent xcirculaterequest ;
   XPropertyEvent xproperty ;
   XSelectionClearEvent xselectionclear ;
   XSelectionRequestEvent xselectionrequest ;
   XSelectionEvent xselection ;
   XColormapEvent xcolormap ;
   XClientMessageEvent xclient ;
   XMappingEvent xmapping ;
   XErrorEvent xerror ;
   XKeymapEvent xkeymap ;
   XGenericEvent xgeneric ;
   XGenericEventCookie xcookie ;
   long pad[24] ;
};
#line 985 "/usr/include/X11/Xlib.h"
typedef union _XEvent XEvent;
#line 1029 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCharStruct_70 {
   short lbearing ;
   short rbearing ;
   short width ;
   short ascent ;
   short descent ;
   unsigned short attributes ;
};
#line 1029 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCharStruct_70 XCharStruct;
#line 1042 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFontProp_71 {
   Atom name ;
   unsigned long card32 ;
};
#line 1042 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFontProp_71 XFontProp;
#line 1047 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFontStruct_72 {
   XExtData *ext_data ;
   Font fid ;
   unsigned int direction ;
   unsigned int min_char_or_byte2 ;
   unsigned int max_char_or_byte2 ;
   unsigned int min_byte1 ;
   unsigned int max_byte1 ;
   int all_chars_exist ;
   unsigned int default_char ;
   int n_properties ;
   XFontProp *properties ;
   XCharStruct min_bounds ;
   XCharStruct max_bounds ;
   XCharStruct *per_char ;
   int ascent ;
   int descent ;
};
#line 1047 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFontStruct_72 XFontStruct;
#line 81 "/usr/include/X11/Xutil.h"
struct __anonstruct_min_aspect_95 {
   int x ;
   int y ;
};
#line 81 "/usr/include/X11/Xutil.h"
struct __anonstruct_XSizeHints_94 {
   long flags ;
   int x ;
   int y ;
   int width ;
   int height ;
   int min_width ;
   int min_height ;
   int max_width ;
   int max_height ;
   int width_inc ;
   int height_inc ;
   struct __anonstruct_min_aspect_95 min_aspect ;
   struct __anonstruct_min_aspect_95 max_aspect ;
   int base_width ;
   int base_height ;
   int win_gravity ;
};
#line 81 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XSizeHints_94 XSizeHints;
#line 119 "/usr/include/X11/Xutil.h"
struct __anonstruct_XWMHints_96 {
   long flags ;
   int input ;
   int initial_state ;
   Pixmap icon_pixmap ;
   Window icon_window ;
   int icon_x ;
   int icon_y ;
   Pixmap icon_mask ;
   XID window_group ;
};
#line 119 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XWMHints_96 XWMHints;
#line 231 "/usr/include/X11/Xutil.h"
struct _XComposeStatus {
   XPointer compose_ptr ;
   int chars_matched ;
};
#line 231 "/usr/include/X11/Xutil.h"
typedef struct _XComposeStatus XComposeStatus;
#line 43 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
typedef short CELL;
#line 58
struct LINE;
#line 58 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
typedef struct LINE LINE;
#line 60 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
struct LINE {
   int beginUpdate ;
   int endUpdate ;
   int clearCount ;
   int usedCount ;
   int alloc ;
   CELL data[1] ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 150 "/usr/include/curses.h"
typedef unsigned long chtype;
#line 357
struct screen;
#line 357 "/usr/include/curses.h"
typedef struct screen SCREEN;
#line 358
struct _win_st;
#line 358 "/usr/include/curses.h"
typedef struct _win_st WINDOW;
#line 360 "/usr/include/curses.h"
typedef chtype attr_t;
#line 405
struct ldat;
#line 407 "/usr/include/curses.h"
struct pdat {
   short _pad_y ;
   short _pad_x ;
   short _pad_top ;
   short _pad_left ;
   short _pad_bottom ;
   short _pad_right ;
};
#line 407 "/usr/include/curses.h"
struct _win_st {
   short _cury ;
   short _curx ;
   short _maxy ;
   short _maxx ;
   short _begy ;
   short _begx ;
   short _flags ;
   attr_t _attrs ;
   chtype _bkgd ;
   _Bool _notimeout ;
   _Bool _clear ;
   _Bool _leaveok ;
   _Bool _scroll ;
   _Bool _idlok ;
   _Bool _idcok ;
   _Bool _immed ;
   _Bool _sync ;
   _Bool _use_keypad ;
   int _delay ;
   struct ldat *_line ;
   short _regtop ;
   short _regbottom ;
   int _parx ;
   int _pary ;
   WINDOW *_parent ;
   struct pdat _pad ;
   short _yoffset ;
};
#line 25 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cursesdisplay.c"
struct __anonstruct_COLOR_INFO_68 {
   char const   *name ;
   short index ;
};
#line 25 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cursesdisplay.c"
typedef struct __anonstruct_COLOR_INFO_68 COLOR_INFO___0;
#line 25 "/home/june/repo/benchmarks/collector/temp/ips-4.0/macro.c"
struct MACRO;
#line 25 "/home/june/repo/benchmarks/collector/temp/ips-4.0/macro.c"
typedef struct MACRO MACRO;
#line 27 "/home/june/repo/benchmarks/collector/temp/ips-4.0/macro.c"
struct MACRO {
   MACRO *next ;
   char *name ;
   char **values ;
   int count ;
   char buf[1] ;
};
#line 42 "/home/june/repo/benchmarks/collector/temp/ips-4.0/macro.c"
struct __anonstruct_MACRO_HEADER_43 {
   char *define ;
   BOOL words ;
   MACRO *list ;
};
#line 42 "/home/june/repo/benchmarks/collector/temp/ips-4.0/macro.c"
typedef struct __anonstruct_MACRO_HEADER_43 MACRO_HEADER;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 42 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 36 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
union __anonunion_id_45 {
   uid_t uid ;
   gid_t gid ;
};
#line 36 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
struct __anonstruct_NAME_44 {
   union __anonunion_id_45 id ;
   char name[18] ;
};
#line 36 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
typedef struct __anonstruct_NAME_44 NAME;
#line 52 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
struct __anonstruct_DEVICE_46 {
   dev_t id ;
   dev_t dev ;
   ino_t inode ;
   char name[34] ;
};
#line 52 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
typedef struct __anonstruct_DEVICE_46 DEVICE;
#line 94
struct TEMPSTR;
#line 94 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
typedef struct TEMPSTR TEMPSTR;
#line 96 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
struct TEMPSTR {
   TEMPSTR *next ;
   char buf[16384] ;
};
#line 126
struct SHARED_STR;
#line 126 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
typedef struct SHARED_STR SHARED_STR;
#line 128 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
struct SHARED_STR {
   long magic ;
   int tableIndex ;
   int count ;
   int len ;
   SHARED_STR *next ;
   char buf[4] ;
};
#line 88 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
struct __anonstruct_OPTION_43 {
   char *name ;
   int id ;
};
#line 88 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
typedef struct __anonstruct_OPTION_43 OPTION;
#line 21 "/home/june/repo/benchmarks/collector/temp/ips-4.0/sort.c"
typedef int SORT_TYPE;
#line 32 "/home/june/repo/benchmarks/collector/temp/ips-4.0/sort.c"
struct __anonstruct_SORT_ITEM_44 {
   SORT_TYPE type ;
   COLUMN *column ;
   TREE *tree ;
};
#line 32 "/home/june/repo/benchmarks/collector/temp/ips-4.0/sort.c"
typedef struct __anonstruct_SORT_ITEM_44 SORT_ITEM;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 603 "/usr/include/unistd.h"
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 681
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 433 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
int showCount  ;
#line 434 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
COLUMN *showList[50]  ;
#line 440 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
ULONG startUptime  ;
#line 441 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
time_t startTime  ;
#line 442 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
time_t currentTime  ;
#line 443 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
long totalMemoryClicks  ;
#line 444 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
long ticksPerSecond  ;
#line 445 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
long pageSize  ;
#line 446 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
ULONG liveCounter  ;
#line 447 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
int newCpuIndex  ;
#line 448 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
int oldCpuIndex  ;
#line 449 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
BOOL ancientFlag  ;
#line 450 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
BOOL showThreads  ;
#line 451 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
BOOL noCopy  ;
#line 452 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
BOOL noSelf  ;
#line 453 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
BOOL noRoot  ;
#line 454 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
BOOL noHeader  ;
#line 455 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
BOOL isInfoShown  ;
#line 456 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
BOOL myProcs  ;
#line 457 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
BOOL activeOnly  ;
#line 458 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
BOOL clearScreen  ;
#line 459 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
BOOL isLooping  ;
#line 460 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
BOOL isRunning  ;
#line 461 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
BOOL isFrozen  ;
#line 462 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
BOOL isUpdateForced  ;
#line 463 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
BOOL isRefreshNeeded  ;
#line 464 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
BOOL isVertical  ;
#line 465 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
BOOL isTopMode  ;
#line 466 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
BOOL isTopAuto  ;
#line 467 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
BOOL useOpenFiles  ;
#line 468 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
BOOL useCurrentDirectory  ;
#line 469 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
BOOL useRootDirectory  ;
#line 470 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
BOOL useExecInode  ;
#line 471 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
BOOL useDeviceNames  ;
#line 472 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
BOOL useUserNames  ;
#line 473 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
BOOL useGroupNames  ;
#line 474 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
BOOL useInitSleep  ;
#line 475 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
BOOL useCommand  ;
#line 476 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
BOOL useSelf  ;
#line 477 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
BOOL useEnvironment  ;
#line 478 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
BOOL useWaitChan  ;
#line 479 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
BOOL useThreads  ;
#line 480 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
BOOL useStdioTable[3]  ;
#line 481 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
pid_t myPid  ;
#line 482 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
uid_t myUid  ;
#line 483 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
gid_t myGid  ;
#line 484 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
dev_t nullDevice  ;
#line 485 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
ino_t nullInode  ;
#line 486 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
int procAllocCount  ;
#line 487 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
int deathTime  ;
#line 488 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
int activeTime  ;
#line 489 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
int pidCount  ;
#line 490 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
int userCount  ;
#line 491 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
int groupCount  ;
#line 492 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
int programCount  ;
#line 493 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
int outputWidth  ;
#line 494 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
int outputHeight  ;
#line 495 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
int separation  ;
#line 496 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
int sleepTimeMs  ;
#line 497 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
int syncTime  ;
#line 498 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
int initSleepTime  ;
#line 499 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
int topCount  ;
#line 500 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
int percentSeconds  ;
#line 501 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
int scrollSeconds  ;
#line 502 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
int overlapLines  ;
#line 503 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
int skipCount  ;
#line 504 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
int procShowCount  ;
#line 505 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
int procTotalCount  ;
#line 506 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
int threadShowCount  ;
#line 507 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
int threadTotalCount  ;
#line 508 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
int infoColorId  ;
#line 509 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
int headerColorId  ;
#line 510 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
PROC *processList  ;
#line 511 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
PROC *freeProcessList  ;
#line 512 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
char *geometry  ;
#line 513 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
char *fontName  ;
#line 514 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
char *foregroundName  ;
#line 515 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
char *backgroundName  ;
#line 516 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
char *displayName  ;
#line 517
char const   *displayType ;
#line 518 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
char emptyString[4]  ;
#line 519
char rootString[4] ;
#line 520 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
pid_t pidList[100]  ;
#line 521 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
uid_t userList[100]  ;
#line 522 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
gid_t groupList[100]  ;
#line 523 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
char programList[20][34]  ;
#line 534
void FreeTempStrings(void) ;
#line 539
void DefaultAllOptions(void) ;
#line 543
BOOL ParseSystemInitFile(void) ;
#line 544
BOOL ParseUserInitFile(void) ;
#line 546
BOOL ParseOptions(ARGS *ap , int depth ) ;
#line 547
BOOL ExpandOptionName(char const   *name , int depth ) ;
#line 552
USEFLAG GetConditionUseFlags(void) ;
#line 553
USEFLAG GetSortingUseFlags(void) ;
#line 560
BOOL InitializeProcessData(void) ;
#line 561
BOOL InitializeDisplay(void) ;
#line 566
void ScanProcesses(void) ;
#line 569
void InitialProcessScan(void) ;
#line 571
void ShowSelectedProcesses(void) ;
#line 591
void WaitForCommands(long milliSeconds ) ;
#line 594
BOOL MacroExists(MACRO_TYPE type , char const   *name ) ;
#line 613
void InitializeColors(void) ;
#line 620
USEFLAG GetRowColorUseFlags(void) ;
#line 622
BOOL DpySetDisplay(char const   *type ) ;
#line 629
void DpyClose(void) ;
#line 640
int DpyGetRows(void) ;
#line 641
int DpyGetCols(void) ;
#line 642
BOOL DpyDoesScroll(void) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/ips-4.0/main.c"
BOOL useCurses  ;
#line 51 "/home/june/repo/benchmarks/collector/temp/ips-4.0/main.c"
BOOL useX11  ;
#line 98 "/home/june/repo/benchmarks/collector/temp/ips-4.0/main.c"
DISPLAY *display  ;
#line 106 "/home/june/repo/benchmarks/collector/temp/ips-4.0/main.c"
char const   *displayType  =    "tty";
#line 108 "/home/june/repo/benchmarks/collector/temp/ips-4.0/main.c"
char rootString[4]  = {      (char )'/',      (char )'\000'};
#line 118
static void GetTerminalSize(void) ;
#line 119
static void SetUseFlags(void) ;
#line 120
static void VerifyDescriptors(void) ;
#line 121
static void HandleSigPipe(int arg ) ;
#line 124 "/home/june/repo/benchmarks/collector/temp/ips-4.0/main.c"
int main(int argc , char **argv ) 
{ 
  ARGS *ap ;
  ARGS args ;
  BOOL tmp ;
  BOOL tmp___0 ;
  int tmp___1 ;
  BOOL tmp___2 ;
  BOOL tmp___3 ;
  BOOL tmp___4 ;
  BOOL tmp___5 ;
  BOOL tmp___6 ;
  BOOL tmp___7 ;
  BOOL tmp___8 ;
  int tmp___9 ;

  {
  {
#line 135
  VerifyDescriptors();
#line 137
  ap = & args;
#line 138
  argv ++;
#line 138
  ap->table = argv;
#line 139
  argc --;
#line 139
  ap->count = argc;
#line 141
  myPid = getpid();
#line 142
  myUid = getuid();
#line 143
  myGid = getgid();
#line 145
  DpySetDisplay((char const   *)((void *)0));
#line 147
  InitializeColors();
#line 149
  DefaultAllOptions();
#line 154
  tmp = ParseSystemInitFile();
  }
#line 154
  if (! tmp) {
#line 155
    return (1);
  }
#line 162
  if (ap->count > 0) {
    {
#line 162
    tmp___1 = strcmp((char const   *)*(ap->table + 0), "-noinit");
    }
#line 162
    if (tmp___1 == 0) {
#line 164
      (ap->table) ++;
#line 165
      (ap->count) --;
    } else {
#line 162
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 167
    tmp___0 = ParseUserInitFile();
    }
#line 167
    if (! tmp___0) {
#line 168
      return (1);
    }
  }
  {
#line 173
  tmp___2 = MacroExists(0, "SysInit");
  }
#line 173
  if (tmp___2) {
    {
#line 173
    tmp___3 = ExpandOptionName("SysInit", 0);
    }
#line 173
    if (! tmp___3) {
      {
#line 176
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Problem expanding system initial macro \"%s\"\n",
              "SysInit");
      }
#line 180
      return (1);
    }
  }
  {
#line 183
  tmp___4 = MacroExists(0, "UserInit");
  }
#line 183
  if (tmp___4) {
    {
#line 183
    tmp___5 = ExpandOptionName("UserInit", 0);
    }
#line 183
    if (! tmp___5) {
      {
#line 186
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Problem expanding system initial macro \"%s\"\n",
              "UserInit");
      }
#line 190
      return (1);
    }
  }
  {
#line 198
  tmp___6 = ParseOptions(ap, 0);
  }
#line 198
  if (! tmp___6) {
#line 199
    return (1);
  }
  {
#line 205
  SetUseFlags();
#line 210
  tmp___7 = InitializeProcessData();
  }
#line 210
  if (! tmp___7) {
#line 211
    return (1);
  }
  {
#line 216
  signal(13, & HandleSigPipe);
#line 221
  tmp___8 = InitializeDisplay();
  }
#line 221
  if (! tmp___8) {
#line 222
    return (1);
  }
  {
#line 229
  InitialProcessScan();
#line 235
  isRunning = 1;
  }
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 237
    if (! isRunning) {
#line 237
      goto while_break;
    }
    {
#line 242
    FreeTempStrings();
    }
#line 248
    if (! isFrozen) {
      {
#line 249
      ScanProcesses();
      }
    } else
#line 248
    if (isUpdateForced) {
      {
#line 249
      ScanProcesses();
      }
    }
    {
#line 251
    isUpdateForced = 0;
#line 256
    GetTerminalSize();
#line 261
    ShowSelectedProcesses();
    }
#line 266
    if (! isLooping) {
#line 267
      goto while_break;
    }
#line 273
    if (isFrozen) {
#line 273
      tmp___9 = 600000;
    } else {
#line 273
      tmp___9 = sleepTimeMs;
    }
    {
#line 273
    WaitForCommands((long )tmp___9);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 279
  DpyClose();
  }
#line 281
  return (0);
}
}
#line 290 "/home/june/repo/benchmarks/collector/temp/ips-4.0/main.c"
static void SetUseFlags(void) 
{ 
  int i ;
  USEFLAG flags ;
  USEFLAG tmp ;
  USEFLAG tmp___0 ;
  USEFLAG tmp___1 ;

  {
#line 296
  flags = (USEFLAG )0;
#line 301
  i = 0;
  {
#line 301
  while (1) {
    while_continue: /* CIL Label */ ;
#line 301
    if (! (i < showCount)) {
#line 301
      goto while_break;
    }
#line 302
    flags |= (showList[i])->useFlag;
#line 301
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 307
  tmp = GetSortingUseFlags();
#line 307
  flags |= tmp;
#line 312
  tmp___0 = GetConditionUseFlags();
#line 312
  flags |= tmp___0;
#line 317
  tmp___1 = GetRowColorUseFlags();
#line 317
  flags |= tmp___1;
  }
#line 322
  if (flags & 1U) {
#line 323
    useInitSleep = 1;
  }
#line 325
  if (flags & 4096U) {
#line 326
    useUserNames = 1;
  }
#line 328
  if (flags & 8192U) {
#line 329
    useGroupNames = 1;
  }
#line 331
  if (flags & 2U) {
#line 332
    useDeviceNames = 1;
  }
#line 334
  if (flags & 4U) {
#line 335
    useOpenFiles = 1;
  }
#line 337
  if (flags & 8U) {
#line 338
    useCurrentDirectory = 1;
  }
#line 340
  if (flags & 1024U) {
#line 341
    useRootDirectory = 1;
  }
#line 343
  if (flags & 2048U) {
#line 344
    useExecInode = 1;
  }
#line 346
  if (flags & 16U) {
#line 347
    useCommand = 1;
  }
#line 349
  if (flags & 32U) {
#line 350
    useSelf = 1;
  }
#line 352
  if (flags & 512U) {
#line 353
    useEnvironment = 1;
  }
#line 355
  if (flags & 16384U) {
#line 356
    useWaitChan = 1;
  }
#line 358
  if (flags & 32768U) {
#line 359
    useThreads = 1;
  }
#line 361
  if (flags & 64U) {
#line 362
    useStdioTable[0] = 1;
  }
#line 364
  if (flags & 128U) {
#line 365
    useStdioTable[1] = 1;
  }
#line 367
  if (flags & 256U) {
#line 368
    useStdioTable[2] = 1;
  }
#line 369
  return;
}
}
#line 375 "/home/june/repo/benchmarks/collector/temp/ips-4.0/main.c"
static void GetTerminalSize(void) 
{ 
  BOOL tmp ;

  {
  {
#line 378
  outputWidth = DpyGetCols();
#line 379
  outputHeight = DpyGetRows();
  }
#line 381
  if (outputWidth <= 0) {
#line 382
    outputWidth = 1;
  }
#line 384
  if (outputHeight <= 0) {
#line 385
    outputHeight = 1;
  }
#line 391
  if (isTopAuto) {
    {
#line 393
    topCount = outputHeight;
#line 395
    tmp = DpyDoesScroll();
    }
#line 395
    if (tmp) {
#line 396
      topCount --;
    }
#line 398
    if (! noHeader) {
#line 399
      topCount --;
    }
#line 401
    if (isInfoShown) {
#line 402
      topCount --;
    }
#line 404
    if (topCount <= 0) {
#line 405
      topCount = 1;
    }
  }
#line 407
  return;
}
}
#line 416 "/home/june/repo/benchmarks/collector/temp/ips-4.0/main.c"
static void VerifyDescriptors(void) 
{ 
  struct stat statBuf ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 421
  tmp = fstat(0, & statBuf);
  }
#line 421
  if (tmp < 0) {
    {
#line 425
    _exit(99);
    }
  } else {
    {
#line 421
    tmp___0 = fstat(1, & statBuf);
    }
#line 421
    if (tmp___0 < 0) {
      {
#line 425
      _exit(99);
      }
    } else {
      {
#line 421
      tmp___1 = fstat(2, & statBuf);
      }
#line 421
      if (tmp___1 < 0) {
        {
#line 425
        _exit(99);
        }
      }
    }
  }
#line 427
  return;
}
}
#line 433 "/home/june/repo/benchmarks/collector/temp/ips-4.0/main.c"
static void HandleSigPipe(int arg ) 
{ 


  {
  {
#line 436
  _exit(2);
  }
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 530 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
char *AllocateSharedString(char const   *str , int len ) ;
#line 531
void FreeSharedString(char *str ) ;
#line 535
void *AllocMemory(int len ) ;
#line 556
void UpdateProcessCounts(void) ;
#line 559
PROC *FindProcess(pid_t pid , pthread_t tid ) ;
#line 567
void CheckActiveProcess(PROC *proc ) ;
#line 568
void RemoveDeadProcesses(void) ;
#line 586
void CalculateCpuPercentage(PROC *proc ) ;
#line 587
void UpdateTimes(void) ;
#line 588
void SetCommandLine(PROC *proc , char const   *str , int len ) ;
#line 589
BOOL SetSharedString(char **saveStr , int *saveLen , char const   *str , int len ) ;
#line 598
void GetTimeOfDay(struct timeval *retTimeVal ) ;
#line 600
long ElapsedMilliSeconds(struct timeval  const  *oldTime , struct timeval  const  *newTime ) ;
#line 606
ULONG GetRunOrder(PROC const   *proc ) ;
#line 607
time_t GetLastActiveTime(PROC const   *proc ) ;
#line 608
BOOL GetIsActive(PROC const   *proc ) ;
#line 609
int GetState(PROC const   *proc ) ;
#line 610
void BuildStates(PROC *proc ) ;
#line 611
int PickBestState(int state1 , int state2 ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/ips-4.0/proc.c"
static long elapsedMilliseconds  ;
#line 17 "/home/june/repo/benchmarks/collector/temp/ips-4.0/proc.c"
static struct timeval currentTimeval  ;
#line 18 "/home/june/repo/benchmarks/collector/temp/ips-4.0/proc.c"
static struct timeval baseTimeval  ;
#line 19 "/home/june/repo/benchmarks/collector/temp/ips-4.0/proc.c"
static struct timeval cpuSampleTimes[102]  ;
#line 25
static void ScanDeadProcesses(BOOL isThread ) ;
#line 26
static BOOL IsProcessRemovable(PROC *proc ) ;
#line 27
static void FreeProcess(PROC *proc ) ;
#line 28
static void RemoveOwnerThread(PROC *proc ) ;
#line 29
static BOOL AppendState(PROC *proc , short *countTable , int state ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/ips-4.0/proc.c"
void InitialProcessScan(void) 
{ 


  {
#line 41
  if (initSleepTime <= 0) {
#line 42
    return;
  }
#line 44
  if (activeOnly) {
    {
#line 46
    ScanProcesses();
#line 48
    sleep((unsigned int )initSleepTime);
    }
  } else
#line 44
  if (useInitSleep) {
    {
#line 46
    ScanProcesses();
#line 48
    sleep((unsigned int )initSleepTime);
    }
  }
#line 50
  return;
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/ips-4.0/proc.c"
PROC *FindProcess(pid_t pid , pthread_t tid ) 
{ 
  PROC *proc ;
  int index___0 ;
  void *tmp ;
  PROC *mainProc ;
  PROC *tmp___0 ;

  {
#line 73
  proc = processList;
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! proc) {
#line 73
      goto while_break;
    }
#line 75
    if (proc->pid == pid) {
#line 75
      if (proc->tid == tid) {
#line 78
        return (proc);
      }
    }
#line 73
    proc = proc->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  proc = freeProcessList;
#line 88
  if (proc) {
#line 90
    freeProcessList = proc->next;
  } else {
    {
#line 94
    tmp = AllocMemory((int )sizeof(PROC ));
#line 94
    proc = (PROC *)tmp;
#line 96
    procAllocCount ++;
    }
  }
#line 102
  proc->next = (PROC *)((void *)0);
#line 103
  proc->nextThread = (PROC *)((void *)0);
#line 104
  proc->owner = (PROC *)((void *)0);
#line 105
  proc->pid = pid;
#line 106
  proc->tid = tid;
#line 107
  proc->isThread = tid != 0xffffffffffffffffUL;
#line 108
  proc->isNew = 1;
#line 109
  proc->isValid = 0;
#line 110
  proc->isActive = 0;
#line 111
  proc->isShown = 0;
#line 112
  proc->hasCommand = 0;
#line 113
  proc->isChanged = 1;
#line 114
  proc->isAncient = ancientFlag;
#line 115
  proc->state = ' ';
#line 116
  proc->states[0] = (char )'\000';
#line 117
  proc->deathTime = (time_t )0;
#line 118
  proc->startTimeTicks = (ULONG )0;
#line 119
  proc->startTimeClock = (time_t )0;
#line 120
  proc->firstCpuTime = (ULONG )0;
#line 121
  proc->lastSavedTime = (time_t )0;
#line 122
  proc->lastActiveTime = (time_t )0;
#line 123
  proc->lastSyncTime = (time_t )0;
#line 124
  proc->liveCounter = (ULONG )0;
#line 125
  proc->percentCpu = 0;
#line 126
  proc->percentMemory = 0;
#line 127
  proc->threadCount = 0;
#line 128
  proc->runOrder = (ULONG )0;
#line 129
  proc->openFiles = 0;
#line 130
  proc->endCode = (ULONG )0;
#line 131
  proc->oldSystemRunTime = 0L;
#line 132
  proc->oldUserRunTime = 0L;
#line 133
  proc->policy = 0L;
#line 134
  proc->realTimePriority = 0L;
#line 135
  proc->commandLength = 0;
#line 136
  proc->environmentLength = 0;
#line 137
  proc->rootPathLength = 0;
#line 138
  proc->cwdPathLength = 0;
#line 139
  proc->execPathLength = 0;
#line 140
  proc->command = proc->commandBuffer;
#line 141
  proc->environment = emptyString;
#line 142
  proc->rootPath = emptyString;
#line 143
  proc->cwdPath = emptyString;
#line 144
  proc->execPath = emptyString;
#line 145
  proc->stdioPaths[0] = emptyString;
#line 146
  proc->stdioPaths[1] = emptyString;
#line 147
  proc->stdioPaths[2] = emptyString;
#line 148
  proc->program[0] = (char )'\000';
#line 149
  proc->waitChanSymbol[0] = (char )'\000';
#line 154
  index___0 = 0;
  {
#line 154
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 154
    if (! (index___0 < 102)) {
#line 154
      goto while_break___0;
    }
#line 156
    proc->cpuTable[index___0] = 0L;
#line 154
    index___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 162
  proc->next = processList;
#line 163
  processList = proc;
#line 169
  if (tid != 0xffffffffffffffffUL) {
    {
#line 171
    tmp___0 = FindProcess(pid, (pthread_t )-1);
#line 171
    mainProc = tmp___0;
#line 173
    proc->owner = mainProc;
#line 174
    proc->nextThread = mainProc->nextThread;
#line 175
    mainProc->nextThread = proc;
    }
  }
#line 178
  return (proc);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/ips-4.0/proc.c"
void RemoveDeadProcesses(void) 
{ 


  {
  {
#line 192
  ScanDeadProcesses(1);
#line 193
  ScanDeadProcesses(0);
  }
#line 194
  return;
}
}
#line 202 "/home/june/repo/benchmarks/collector/temp/ips-4.0/proc.c"
static void ScanDeadProcesses(BOOL isThread ) 
{ 
  PROC *proc ;
  PROC *prevProc ;
  PROC *nextProc ;
  BOOL tmp ;

  {
#line 209
  prevProc = (PROC *)((void *)0);
#line 211
  proc = processList;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    if (! proc) {
#line 211
      goto while_break;
    }
#line 217
    nextProc = proc->next;
#line 222
    if (proc->isThread != isThread) {
#line 224
      prevProc = proc;
#line 226
      goto __Cont;
    }
    {
#line 233
    tmp = IsProcessRemovable(proc);
    }
#line 233
    if (! tmp) {
#line 235
      prevProc = proc;
#line 237
      goto __Cont;
    }
#line 245
    if (prevProc) {
#line 246
      prevProc->next = nextProc;
    } else {
#line 248
      processList = nextProc;
    }
    {
#line 254
    RemoveOwnerThread(proc);
#line 260
    FreeProcess(proc);
    }
    __Cont: /* CIL Label */ 
#line 211
    proc = nextProc;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  return;
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/ips-4.0/proc.c"
static BOOL IsProcessRemovable(PROC *proc ) 
{ 


  {
#line 276
  if (proc->liveCounter == liveCounter) {
#line 277
    return (0);
  }
  {
#line 284
  proc->state = ' ';
#line 285
  proc->oldState = ' ';
#line 286
  proc->states[0] = (char )'\000';
#line 287
  proc->oldUserRunTime = proc->userRunTime;
#line 288
  proc->oldSystemRunTime = proc->systemRunTime;
#line 289
  proc->percentCpu = 0;
#line 290
  proc->percentMemory = 0;
#line 291
  proc->pagesSwapped = (ULONG )0;
#line 292
  proc->virtualSize = 0L;
#line 293
  proc->rss = 0L;
#line 299
  CalculateCpuPercentage(proc);
  }
#line 306
  if (proc->deathTime == 0L) {
#line 308
    proc->deathTime = currentTime;
#line 309
    proc->lastActiveTime = currentTime;
#line 310
    proc->runOrder = liveCounter;
  }
#line 317
  if (deathTime > 0) {
#line 317
    if (currentTime <= proc->deathTime + (time_t )deathTime) {
#line 320
      return (0);
    }
  }
#line 327
  if (! proc->isThread) {
#line 327
    if ((unsigned long )proc->nextThread != (unsigned long )((PROC *)0)) {
#line 328
      return (0);
    }
  }
#line 333
  return (1);
}
}
#line 340 "/home/june/repo/benchmarks/collector/temp/ips-4.0/proc.c"
static void RemoveOwnerThread(PROC *proc ) 
{ 
  PROC *testProc ;

  {
#line 348
  if (! proc->isThread) {
#line 349
    return;
  } else
#line 348
  if ((unsigned long )proc->owner == (unsigned long )((PROC *)0)) {
#line 349
    return;
  }
#line 354
  testProc = (proc->owner)->nextThread;
#line 356
  if ((unsigned long )testProc == (unsigned long )proc) {
#line 358
    (proc->owner)->nextThread = proc->nextThread;
#line 360
    return;
  }
  {
#line 363
  while (1) {
    while_continue: /* CIL Label */ ;
#line 363
    if (! testProc) {
#line 363
      goto while_break;
    }
#line 365
    if ((unsigned long )testProc->nextThread == (unsigned long )proc) {
#line 367
      testProc->nextThread = proc->nextThread;
#line 369
      return;
    }
#line 372
    testProc = testProc->nextThread;
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  return;
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/ips-4.0/proc.c"
static void FreeProcess(PROC *proc ) 
{ 


  {
#line 388
  proc->next = (PROC *)0;
#line 389
  proc->owner = (PROC *)0;
#line 390
  proc->nextThread = (PROC *)0;
#line 391
  proc->isValid = 0;
#line 392
  proc->pid = 0;
#line 393
  proc->tid = (pthread_t )0;
#line 394
  proc->state = ' ';
#line 395
  proc->states[0] = (char )'\000';
#line 400
  if ((unsigned long )proc->command != (unsigned long )(proc->commandBuffer)) {
    {
#line 402
    free((void *)proc->command);
#line 403
    proc->command = proc->commandBuffer;
    }
  }
  {
#line 406
  proc->commandLength = 0;
#line 408
  FreeSharedString(proc->environment);
#line 409
  proc->environment = emptyString;
#line 410
  proc->environmentLength = 0;
#line 412
  FreeSharedString(proc->cwdPath);
#line 413
  proc->cwdPath = emptyString;
#line 414
  proc->cwdPathLength = 0;
#line 416
  FreeSharedString(proc->rootPath);
#line 417
  proc->rootPath = emptyString;
#line 418
  proc->rootPathLength = 0;
#line 420
  FreeSharedString(proc->execPath);
#line 421
  proc->execPath = emptyString;
#line 422
  proc->execPathLength = 0;
#line 424
  FreeSharedString(proc->stdioPaths[0]);
#line 425
  FreeSharedString(proc->stdioPaths[1]);
#line 426
  FreeSharedString(proc->stdioPaths[2]);
#line 428
  proc->stdioPaths[0] = emptyString;
#line 429
  proc->stdioPaths[1] = emptyString;
#line 430
  proc->stdioPaths[2] = emptyString;
#line 435
  proc->next = freeProcessList;
#line 436
  freeProcessList = proc;
  }
#line 437
  return;
}
}
#line 446 "/home/june/repo/benchmarks/collector/temp/ips-4.0/proc.c"
void CheckActiveProcess(PROC *proc ) 
{ 
  BOOL isActive ;
  int tmp ;

  {
#line 455
  if (proc->state == 82) {
#line 455
    tmp = 1;
  } else
#line 455
  if (proc->state == 68) {
#line 455
    tmp = 1;
  } else {
#line 455
    tmp = 0;
  }
#line 455
  isActive = tmp;
#line 457
  if (isActive) {
#line 459
    proc->lastActiveTime = currentTime;
#line 460
    proc->runOrder = liveCounter;
  }
  {
#line 466
  CalculateCpuPercentage(proc);
  }
#line 468
  if (totalMemoryClicks > 0L) {
#line 470
    proc->percentMemory = (int )((proc->rss * 1000L) / totalMemoryClicks);
  }
#line 474
  proc->isChanged = 0;
#line 481
  if (proc->isNew) {
#line 481
    goto _L;
  } else
#line 481
  if (proc->userRunTime != proc->oldUserRunTime) {
#line 481
    goto _L;
  } else
#line 481
  if (proc->systemRunTime != proc->oldSystemRunTime) {
#line 481
    goto _L;
  } else
#line 481
  if (proc->state != proc->oldState) {
#line 481
    goto _L;
  } else
#line 481
  if (proc->flags != (ULONG )proc->oldFlags) {
#line 481
    goto _L;
  } else
#line 481
  if (proc->minorFaults != proc->oldMinorFaults) {
#line 481
    goto _L;
  } else
#line 481
  if (proc->majorFaults != proc->oldMajorFaults) {
#line 481
    goto _L;
  } else
#line 481
  if (proc->startTimeTicks != proc->oldStartTimeTicks) {
#line 481
    goto _L;
  } else
#line 481
  if (proc->endCode != proc->oldEndCode) {
#line 481
    goto _L;
  } else
#line 481
  if (proc->esp != proc->oldEsp) {
#line 481
    goto _L;
  } else
#line 481
  if (proc->eip != proc->oldEip) {
#line 481
    goto _L;
  } else
#line 481
  if (proc->waitChan != proc->oldWaitChan) {
    _L: /* CIL Label */ 
#line 494
    proc->isChanged = 1;
#line 495
    proc->isNew = 0;
#line 496
    proc->isAncient = ancientFlag;
#line 497
    proc->lastActiveTime = currentTime;
#line 498
    proc->lastSavedTime = currentTime;
#line 499
    proc->runOrder = liveCounter;
#line 500
    proc->oldState = proc->state;
#line 501
    proc->oldFlags = (int )proc->flags;
#line 502
    proc->oldMinorFaults = proc->minorFaults;
#line 503
    proc->oldMajorFaults = proc->majorFaults;
#line 504
    proc->oldUserRunTime = proc->userRunTime;
#line 505
    proc->oldSystemRunTime = proc->systemRunTime;
#line 506
    proc->oldStartTimeTicks = proc->startTimeTicks;
#line 507
    proc->oldEndCode = proc->endCode;
#line 508
    proc->oldEsp = proc->esp;
#line 509
    proc->oldEip = proc->eip;
#line 510
    proc->oldWaitChan = proc->waitChan;
  }
#line 518
  if (! proc->isAncient) {
#line 518
    if (currentTime <= proc->lastSavedTime + (time_t )activeTime) {
#line 521
      isActive = 1;
    }
  }
#line 524
  if (isActive) {
#line 525
    proc->isAncient = 0;
  }
#line 527
  proc->isActive = isActive;
#line 528
  return;
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/ips-4.0/proc.c"
void CalculateCpuPercentage(PROC *proc ) 
{ 
  long oldCpuTime ;
  long ticksUsed ;
  double percentage ;

  {
#line 547
  proc->cpuTable[newCpuIndex] = proc->userRunTime + proc->systemRunTime;
#line 552
  proc->percentCpu = 0;
#line 554
  if (elapsedMilliseconds <= 0L) {
#line 555
    return;
  }
#line 562
  oldCpuTime = proc->cpuTable[oldCpuIndex];
#line 564
  if ((ULONG )oldCpuTime < proc->firstCpuTime) {
#line 565
    oldCpuTime = (long )proc->firstCpuTime;
  }
#line 567
  ticksUsed = proc->cpuTable[newCpuIndex] - oldCpuTime;
#line 569
  if (ticksUsed <= 0L) {
#line 570
    return;
  }
#line 577
  percentage = (double )ticksUsed;
#line 578
  percentage *= (double )1000;
#line 579
  percentage *= (double )10000;
#line 580
  percentage /= (double )ticksPerSecond;
#line 581
  percentage /= (double )elapsedMilliseconds;
#line 583
  proc->percentCpu = (int )percentage;
#line 584
  return;
}
}
#line 593 "/home/june/repo/benchmarks/collector/temp/ips-4.0/proc.c"
void UpdateTimes(void) 
{ 
  int tempIndex ;
  int tempIndex___0 ;

  {
  {
#line 599
  liveCounter ++;
#line 601
  GetTimeOfDay(& currentTimeval);
#line 603
  currentTime = currentTimeval.tv_sec;
  }
#line 608
  if (baseTimeval.tv_sec == 0L) {
#line 610
    baseTimeval = currentTimeval;
#line 611
    cpuSampleTimes[0] = currentTimeval;
#line 612
    cpuSampleTimes[1] = currentTimeval;
#line 613
    oldCpuIndex = 0;
#line 614
    newCpuIndex = 1;
  }
  {
#line 621
  elapsedMilliseconds = ElapsedMilliSeconds((struct timeval  const  *)(& baseTimeval),
                                            (struct timeval  const  *)(& currentTimeval));
  }
#line 627
  if (elapsedMilliseconds * 5L >= 1000L) {
#line 629
    tempIndex = (newCpuIndex + 1) % 102;
#line 631
    if (tempIndex != oldCpuIndex) {
#line 633
      newCpuIndex = tempIndex;
#line 638
      baseTimeval = currentTimeval;
    }
  }
#line 645
  cpuSampleTimes[newCpuIndex] = currentTimeval;
  {
#line 651
  while (1) {
    while_continue: /* CIL Label */ ;
#line 651
    if (! (oldCpuIndex != newCpuIndex)) {
#line 651
      goto while_break;
    }
#line 653
    tempIndex___0 = (oldCpuIndex + 1) % 102;
#line 655
    if (tempIndex___0 == newCpuIndex) {
#line 656
      goto while_break;
    }
    {
#line 658
    elapsedMilliseconds = ElapsedMilliSeconds((struct timeval  const  *)(& cpuSampleTimes[tempIndex___0]),
                                              (struct timeval  const  *)(& currentTimeval));
    }
#line 661
    if (elapsedMilliseconds < (long )(percentSeconds * 1000)) {
#line 662
      goto while_break;
    }
#line 664
    oldCpuIndex = tempIndex___0;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 672
  elapsedMilliseconds = ElapsedMilliSeconds((struct timeval  const  *)(& cpuSampleTimes[oldCpuIndex]),
                                            (struct timeval  const  *)(& currentTimeval));
  }
#line 674
  return;
}
}
#line 686 "/home/june/repo/benchmarks/collector/temp/ips-4.0/proc.c"
void UpdateProcessCounts(void) 
{ 
  PROC const   *proc ;

  {
#line 691
  procShowCount = 0;
#line 692
  threadShowCount = 0;
#line 697
  proc = (PROC const   *)processList;
  {
#line 697
  while (1) {
    while_continue: /* CIL Label */ ;
#line 697
    if (! proc) {
#line 697
      goto while_break;
    }
#line 702
    if (proc->isThread) {
#line 704
      if (proc->isShown) {
#line 705
        threadShowCount ++;
      }
#line 707
      goto __Cont;
    }
#line 714
    if (proc->isShown) {
#line 715
      procShowCount ++;
    }
#line 723
    if (proc->threadCount <= 1) {
#line 723
      goto _L;
    } else
#line 723
    if (! useThreads) {
#line 723
      if (! showThreads) {
        _L: /* CIL Label */ 
#line 726
        if (proc->isShown) {
#line 727
          threadShowCount ++;
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 697
    proc = (PROC const   *)proc->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 730
  return;
}
}
#line 738 "/home/june/repo/benchmarks/collector/temp/ips-4.0/proc.c"
void SetCommandLine(PROC *proc , char const   *str , int len ) 
{ 
  int tmp ;
  void *tmp___0 ;

  {
#line 744
  if (len == 0) {
#line 744
    if (proc->commandLength == 0) {
#line 745
      return;
    }
  }
#line 751
  if (len == proc->commandLength) {
#line 751
    if ((int const   )*(str + 0) == (int const   )*(proc->command + 0)) {
#line 751
      if ((int const   )*(str + (len - 1)) == (int const   )*(proc->command + (len - 1))) {
        {
#line 751
        tmp = memcmp((void const   *)str, (void const   *)proc->command, (size_t )len);
        }
#line 751
        if (tmp == 0) {
#line 756
          return;
        }
      }
    }
  }
#line 763
  if ((unsigned long )proc->command != (unsigned long )(proc->commandBuffer)) {
    {
#line 764
    free((void *)proc->command);
    }
  }
#line 766
  proc->command = proc->commandBuffer;
#line 773
  if (len > 128) {
    {
#line 774
    tmp___0 = AllocMemory(len + 1);
#line 774
    proc->command = (char *)tmp___0;
    }
  }
  {
#line 779
  memcpy((void */* __restrict  */)proc->command, (void const   */* __restrict  */)str,
         (size_t )len);
#line 780
  *(proc->command + len) = (char )'\000';
#line 781
  proc->commandLength = len;
  }
#line 782
  return;
}
}
#line 792 "/home/june/repo/benchmarks/collector/temp/ips-4.0/proc.c"
BOOL SetSharedString(char **saveStr , int *saveLen , char const   *str , int len ) 
{ 
  char *oldStr ;
  int oldLen ;
  int tmp ;

  {
#line 798
  oldStr = *saveStr;
#line 799
  oldLen = *saveLen;
#line 805
  if (oldLen == 0) {
#line 805
    if (len == 0) {
#line 806
      return (1);
    }
  }
#line 812
  if (oldLen == len) {
#line 812
    if ((int )*(oldStr + 0) == (int )*(str + 0)) {
#line 812
      if ((int )*(oldStr + (len - 1)) == (int )*(str + (len - 1))) {
        {
#line 812
        tmp = memcmp((void const   *)oldStr, (void const   *)str, (size_t )len);
        }
#line 812
        if (tmp == 0) {
#line 817
          return (1);
        }
      }
    }
  }
  {
#line 824
  FreeSharedString(oldStr);
#line 826
  *saveStr = AllocateSharedString(str, len);
#line 827
  *saveLen = len;
  }
#line 829
  if ((unsigned long )*saveStr != (unsigned long )((void *)0)) {
#line 830
    return (1);
  }
#line 836
  *saveStr = emptyString;
#line 837
  *saveLen = 0;
#line 839
  return (0);
}
}
#line 846 "/home/june/repo/benchmarks/collector/temp/ips-4.0/proc.c"
ULONG GetRunOrder(PROC const   *proc ) 
{ 
  ULONG runOrder ;

  {
#line 849
  runOrder = (ULONG )proc->runOrder;
#line 851
  if (! useThreads) {
#line 851
    if (! showThreads) {
#line 852
      return (runOrder);
    }
  }
#line 854
  if (proc->isThread) {
#line 855
    return (runOrder);
  } else
#line 854
  if (proc->threadCount == 1) {
#line 855
    return (runOrder);
  }
#line 857
  proc = (PROC const   *)proc->nextThread;
  {
#line 857
  while (1) {
    while_continue: /* CIL Label */ ;
#line 857
    if (! proc) {
#line 857
      goto while_break;
    }
#line 859
    if (runOrder < (ULONG )proc->runOrder) {
#line 860
      runOrder = (ULONG )proc->runOrder;
    }
#line 857
    proc = (PROC const   *)proc->nextThread;
  }
  while_break: /* CIL Label */ ;
  }
#line 863
  return (runOrder);
}
}
#line 870 "/home/june/repo/benchmarks/collector/temp/ips-4.0/proc.c"
time_t GetLastActiveTime(PROC const   *proc ) 
{ 
  time_t lastActiveTime ;

  {
#line 873
  lastActiveTime = (time_t )proc->lastActiveTime;
#line 875
  if (! useThreads) {
#line 875
    if (! showThreads) {
#line 876
      return (lastActiveTime);
    }
  }
#line 878
  if (proc->isThread) {
#line 879
    return (lastActiveTime);
  } else
#line 878
  if (proc->threadCount == 1) {
#line 879
    return (lastActiveTime);
  }
#line 881
  proc = (PROC const   *)proc->nextThread;
  {
#line 881
  while (1) {
    while_continue: /* CIL Label */ ;
#line 881
    if (! proc) {
#line 881
      goto while_break;
    }
#line 883
    if (lastActiveTime < (time_t )proc->lastActiveTime) {
#line 884
      lastActiveTime = (time_t )proc->lastActiveTime;
    }
#line 881
    proc = (PROC const   *)proc->nextThread;
  }
  while_break: /* CIL Label */ ;
  }
#line 887
  return (lastActiveTime);
}
}
#line 894 "/home/june/repo/benchmarks/collector/temp/ips-4.0/proc.c"
BOOL GetIsActive(PROC const   *proc ) 
{ 


  {
#line 897
  if (proc->isActive) {
#line 898
    return (1);
  }
#line 900
  if (! useThreads) {
#line 900
    if (! showThreads) {
#line 901
      return (0);
    }
  }
#line 903
  if (proc->isThread) {
#line 904
    return (0);
  } else
#line 903
  if (proc->threadCount == 1) {
#line 904
    return (0);
  }
#line 906
  proc = (PROC const   *)proc->nextThread;
  {
#line 906
  while (1) {
    while_continue: /* CIL Label */ ;
#line 906
    if (! proc) {
#line 906
      goto while_break;
    }
#line 908
    if (proc->isActive) {
#line 909
      return (1);
    }
#line 906
    proc = (PROC const   *)proc->nextThread;
  }
  while_break: /* CIL Label */ ;
  }
#line 912
  return (0);
}
}
#line 920 "/home/june/repo/benchmarks/collector/temp/ips-4.0/proc.c"
int GetState(PROC const   *proc ) 
{ 
  int state ;

  {
#line 923
  state = (int )proc->state;
#line 925
  if (! useThreads) {
#line 925
    if (! showThreads) {
#line 926
      return (state);
    }
  }
#line 928
  if (proc->isThread) {
#line 929
    return (state);
  } else
#line 928
  if (proc->threadCount == 1) {
#line 929
    return (state);
  }
#line 931
  proc = (PROC const   *)proc->nextThread;
  {
#line 931
  while (1) {
    while_continue: /* CIL Label */ ;
#line 931
    if (! proc) {
#line 931
      goto while_break;
    }
    {
#line 933
    state = PickBestState(state, (int )proc->state);
#line 931
    proc = (PROC const   *)proc->nextThread;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 936
  return (state);
}
}
#line 944 "/home/june/repo/benchmarks/collector/temp/ips-4.0/proc.c"
void BuildStates(PROC *proc ) 
{ 
  int state ;
  PROC *threadProc ;
  short countTable[128] ;

  {
#line 955
  proc->states[0] = (char )proc->state;
#line 956
  proc->states[1] = (char )'\000';
#line 958
  if (! useThreads) {
#line 958
    if (! showThreads) {
#line 959
      return;
    }
  }
#line 961
  if (proc->isThread) {
#line 962
    return;
  } else
#line 961
  if (proc->threadCount == 1) {
#line 962
    return;
  }
  {
#line 968
  memset((void *)(countTable), 0, 128UL * sizeof(short ));
#line 970
  threadProc = proc->nextThread;
  }
  {
#line 970
  while (1) {
    while_continue: /* CIL Label */ ;
#line 970
    if (! threadProc) {
#line 970
      goto while_break;
    }
#line 973
    countTable[threadProc->state & 127] = (short )((int )countTable[threadProc->state & 127] + 1);
#line 970
    threadProc = threadProc->nextThread;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 979
  proc->states[0] = (char )'\000';
#line 981
  AppendState(proc, countTable, 'R');
#line 982
  AppendState(proc, countTable, 'D');
#line 983
  AppendState(proc, countTable, 'S');
#line 984
  AppendState(proc, countTable, 'T');
#line 989
  state = ' ';
  }
  {
#line 989
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 989
    if (! (state < 128)) {
#line 989
      goto while_break___0;
    }
    {
#line 990
    AppendState(proc, countTable, state);
#line 989
    state ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 991
  return;
}
}
#line 998 "/home/june/repo/benchmarks/collector/temp/ips-4.0/proc.c"
static BOOL AppendState(PROC *proc , short *countTable , int state ) 
{ 
  int count ;
  int len ;
  char buf___3[20] ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
#line 1005
  count = (int )*(countTable + state);
#line 1007
  if (count == 0) {
#line 1008
    return (1);
  }
  {
#line 1010
  *(countTable + state) = (short)0;
#line 1012
  tmp = strlen((char const   *)(proc->states));
#line 1012
  len = (int )tmp;
  }
#line 1014
  if (count == 1) {
#line 1016
    if (len >= 16) {
#line 1017
      return (0);
    }
#line 1019
    tmp___0 = len;
#line 1019
    len ++;
#line 1019
    proc->states[tmp___0] = (char )state;
#line 1020
    proc->states[len] = (char )'\000';
#line 1022
    return (1);
  }
  {
#line 1025
  sprintf((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)"%c%d",
          state, count);
#line 1027
  tmp___1 = strlen((char const   *)(buf___3));
  }
#line 1027
  if ((size_t )len + tmp___1 >= 16UL) {
#line 1028
    return (0);
  }
  {
#line 1030
  strcpy((char */* __restrict  */)(& proc->states[len]), (char const   */* __restrict  */)(buf___3));
  }
#line 1032
  return (1);
}
}
#line 562 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
void TopPage(void) ;
#line 563
void BottomPage(void) ;
#line 564
void NextPage(void) ;
#line 565
void PreviousPage(void) ;
#line 590
void ResetScrollTime(void) ;
#line 592
BOOL ReadCommands(void) ;
#line 637
BOOL DpyInputReady(void) ;
#line 638
int DpyReadChar(void) ;
#line 639
void DpyRingBell(void) ;
#line 643
BOOL DpyEventWait(int milliSeconds ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/ips-4.0/commands.c"
static double numberValue  ;
#line 17 "/home/june/repo/benchmarks/collector/temp/ips-4.0/commands.c"
static double scaleValue  ;
#line 18 "/home/june/repo/benchmarks/collector/temp/ips-4.0/commands.c"
static BOOL isNumberSeen  ;
#line 19 "/home/june/repo/benchmarks/collector/temp/ips-4.0/commands.c"
static BOOL isPeriodSeen  ;
#line 25
static void ClearParsedNumber(void) ;
#line 26
static double GetParsedNumber(double value ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/ips-4.0/commands.c"
void WaitForCommands(long milliSeconds ) 
{ 
  long remainingMilliSeconds ;
  long elapsedMilliSeconds ;
  struct timeval beginTime ;
  BOOL tmp ;
  BOOL tmp___0 ;

  {
#line 45
  if (milliSeconds <= 0L) {
    {
#line 47
    DpyEventWait(0);
#line 48
    ReadCommands();
    }
#line 50
    return;
  }
  {
#line 57
  GetTimeOfDay(& beginTime);
#line 59
  remainingMilliSeconds = milliSeconds;
  }
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 74
    tmp = DpyEventWait((int )remainingMilliSeconds);
    }
#line 74
    if (tmp) {
#line 75
      milliSeconds = 0L;
    }
    {
#line 82
    tmp___0 = ReadCommands();
    }
#line 82
    if (tmp___0) {
#line 83
      goto while_break;
    }
    {
#line 90
    elapsedMilliSeconds = ElapsedMilliSeconds((struct timeval  const  *)(& beginTime),
                                              (struct timeval  const  *)((void *)0));
    }
#line 96
    if (elapsedMilliSeconds < 0L) {
#line 97
      goto while_break;
    }
#line 102
    remainingMilliSeconds = milliSeconds - elapsedMilliSeconds;
#line 66
    if (! (remainingMilliSeconds > 0L)) {
#line 66
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  return;
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/ips-4.0/commands.c"
BOOL ReadCommands(void) 
{ 
  BOOL isWakeup ;
  BOOL isClear ;
  BOOL isError ;
  int ch ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  BOOL tmp___5 ;

  {
#line 122
  isWakeup = 0;
#line 123
  isClear = 0;
#line 124
  isError = 0;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 129
    tmp___5 = DpyInputReady();
    }
#line 129
    if (! tmp___5) {
#line 129
      goto while_break;
    }
    {
#line 131
    ch = DpyReadChar();
    }
#line 133
    if (ch == -1) {
#line 134
      goto while_break;
    }
    {
#line 139
    if (ch == 27) {
#line 139
      goto case_27;
    }
#line 139
    if (ch == 113) {
#line 139
      goto case_27;
    }
#line 151
    if (ch == 32) {
#line 151
      goto case_32;
    }
#line 151
    if (ch == 10) {
#line 151
      goto case_32;
    }
#line 151
    if (ch == 13) {
#line 151
      goto case_32;
    }
#line 161
    if (ch == 97) {
#line 161
      goto case_97;
    }
#line 173
    if (ch == 116) {
#line 173
      goto case_116;
    }
#line 183
    if (ch == 104) {
#line 183
      goto case_104;
    }
#line 192
    if (ch == 102) {
#line 192
      goto case_102;
    }
#line 202
    if (ch == 105) {
#line 202
      goto case_105;
    }
#line 211
    if (ch == 98) {
#line 211
      goto case_98;
    }
#line 221
    if (ch == 110) {
#line 221
      goto case_110;
    }
#line 231
    if (ch == 111) {
#line 231
      goto case_111;
    }
#line 242
    if (ch == 112) {
#line 242
      goto case_112;
    }
#line 252
    if (ch == 115) {
#line 252
      goto case_115;
    }
#line 264
    if (ch == 8) {
#line 264
      goto case_8;
    }
#line 264
    if (ch == 127) {
#line 264
      goto case_8;
    }
#line 272
    if (ch == 114) {
#line 272
      goto case_114;
    }
#line 282
    if (ch == 46) {
#line 282
      goto case_46;
    }
#line 300
    goto switch_default;
    case_27: /* CIL Label */ 
    case_113: /* CIL Label */ 
#line 143
    isRunning = 0;
#line 144
    isWakeup = 1;
#line 145
    isClear = 1;
#line 147
    goto switch_break;
    case_32: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
#line 155
    isWakeup = 1;
#line 156
    isUpdateForced = 1;
#line 157
    isClear = 1;
#line 159
    goto switch_break;
    case_97: /* CIL Label */ 
    {
#line 165
    tmp = GetParsedNumber((double )30);
#line 165
    scrollSeconds = (int )tmp;
    }
#line 168
    if (isInfoShown) {
#line 169
      isWakeup = 1;
    }
#line 171
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 177
    TopPage();
#line 178
    isWakeup = 1;
#line 179
    isClear = 1;
    }
#line 181
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 187
    tmp___0 = GetParsedNumber((double )noHeader);
#line 187
    noHeader = tmp___0 == (double )0;
#line 188
    isWakeup = 1;
    }
#line 190
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 196
    tmp___1 = GetParsedNumber((double )(! isFrozen));
#line 196
    isFrozen = tmp___1 != (double )0;
#line 197
    ResetScrollTime();
#line 198
    isWakeup = 1;
    }
#line 200
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 206
    tmp___2 = GetParsedNumber((double )(! isInfoShown));
#line 206
    isInfoShown = tmp___2 != (double )0;
#line 207
    isWakeup = 1;
    }
#line 209
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 215
    BottomPage();
#line 216
    isWakeup = 1;
#line 217
    isClear = 1;
    }
#line 219
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 225
    NextPage();
#line 226
    isWakeup = 1;
#line 227
    isClear = 1;
    }
#line 229
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 235
    tmp___3 = GetParsedNumber((double )1);
#line 235
    overlapLines = (int )tmp___3;
#line 238
    isWakeup = 1;
    }
#line 240
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 246
    PreviousPage();
#line 247
    isWakeup = 1;
#line 248
    isClear = 1;
    }
#line 250
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 256
    tmp___4 = GetParsedNumber((double )10);
#line 256
    sleepTimeMs = (int )(1000.0 * tmp___4);
#line 259
    isWakeup = 1;
    }
#line 261
    goto switch_break;
    case_8: /* CIL Label */ 
    case_127: /* CIL Label */ 
#line 268
    isClear = 1;
#line 270
    goto switch_break;
    case_114: /* CIL Label */ 
#line 276
    isRefreshNeeded = 1;
#line 277
    isWakeup = 1;
#line 278
    isClear = 1;
#line 280
    goto switch_break;
    case_46: /* CIL Label */ 
#line 286
    if (isPeriodSeen) {
#line 287
      isError = 1;
    }
#line 289
    isPeriodSeen = 1;
#line 291
    if (! isNumberSeen) {
#line 293
      isNumberSeen = 1;
#line 294
      numberValue = 0.0;
#line 295
      scaleValue = 1.0;
    }
#line 298
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 305
    if (ch < 48) {
#line 307
      isError = 1;
#line 308
      goto switch_break;
    } else
#line 305
    if (ch > 57) {
#line 307
      isError = 1;
#line 308
      goto switch_break;
    }
#line 314
    if (! isNumberSeen) {
#line 316
      isNumberSeen = 1;
#line 317
      numberValue = 0.0;
#line 318
      scaleValue = 1.0;
    }
#line 321
    numberValue = numberValue * 10.0 + (double )(ch - 48);
#line 323
    if (isPeriodSeen) {
#line 324
      scaleValue *= 10.0;
    }
#line 326
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 333
  if (isError) {
    {
#line 334
    DpyRingBell();
    }
  }
#line 339
  if (isError) {
    {
#line 340
    ClearParsedNumber();
    }
  } else
#line 339
  if (isClear) {
    {
#line 340
    ClearParsedNumber();
    }
  }
#line 345
  return (isWakeup);
}
}
#line 355 "/home/june/repo/benchmarks/collector/temp/ips-4.0/commands.c"
static double GetParsedNumber(double value ) 
{ 


  {
#line 358
  if (isNumberSeen) {
#line 359
    value = numberValue / scaleValue;
  }
  {
#line 361
  ClearParsedNumber();
  }
#line 363
  return (value);
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/ips-4.0/commands.c"
static void ClearParsedNumber(void) 
{ 


  {
#line 373
  numberValue = (double )0;
#line 374
  scaleValue = (double )0;
#line 375
  isNumberSeen = 0;
#line 376
  isPeriodSeen = 0;
#line 377
  return;
}
}
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 614 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
int AllocateColor(char const   *color ) ;
#line 615
BOOL DefineColors(void) ;
#line 617
void ClearRowColorConditions(void) ;
#line 618
BOOL ParseRowColorCondition(char const   *color , char const   *condition ) ;
#line 619
int EvaluateRowColor(PROC const   *proc ) ;
#line 625
BOOL DpyDefineColor(int colorId , char const   *foreground___0 , char const   *background___0 ,
                    int flags ) ;
#line 158 "/home/june/repo/benchmarks/collector/temp/ips-4.0/expr.h"
BOOL ParseTree(TREE *tree , char const   *str , int depth ) ;
#line 159
VALUE EvaluateNode(TREE *tree , NODE const   *node ) ;
#line 160
USEFLAG GetNodeUseFlags(NODE const   *node ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/ips-4.0/color.c"
static int colorCount  ;
#line 50 "/home/june/repo/benchmarks/collector/temp/ips-4.0/color.c"
static ColorData colorTable[20]  ;
#line 56 "/home/june/repo/benchmarks/collector/temp/ips-4.0/color.c"
static int rowColorCount  ;
#line 57 "/home/june/repo/benchmarks/collector/temp/ips-4.0/color.c"
static RowColor rowColorTable[50]  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/ips-4.0/color.c"
void InitializeColors(void) 
{ 


  {
#line 68
  colorTable[0].foreground = "";
#line 69
  colorTable[0].background = "";
#line 70
  colorTable[0].flags = 0;
#line 72
  colorCount = 1;
#line 73
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/ips-4.0/color.c"
int AllocateColor(char const   *color ) 
{ 
  char *dupColor ;
  char *slash ;
  char const   *foreground___0 ;
  char const   *background___0 ;
  char const   *flagsString ;
  ColorData *pair ;
  int colorFlags ;
  int colorId ;
  char *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 102
  dupColor = strdup(color);
  }
#line 104
  if ((unsigned long )dupColor == (unsigned long )((char *)0)) {
#line 105
    return (-1);
  }
  {
#line 107
  foreground___0 = (char const   *)dupColor;
#line 108
  background___0 = "";
#line 109
  flagsString = "";
#line 111
  slash = strchr((char const   *)dupColor, '/');
  }
#line 113
  if (slash) {
#line 115
    tmp = slash;
#line 115
    slash ++;
#line 115
    *tmp = (char )'\000';
#line 116
    background___0 = (char const   *)slash;
  }
#line 119
  if (slash) {
    {
#line 120
    slash = strchr((char const   *)slash, '/');
    }
  }
#line 122
  if (slash) {
#line 124
    tmp___0 = slash;
#line 124
    slash ++;
#line 124
    *tmp___0 = (char )'\000';
#line 125
    flagsString = (char const   *)slash;
  }
#line 131
  colorFlags = 0;
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    if (! *flagsString) {
#line 133
      goto while_break;
    }
#line 135
    tmp___1 = flagsString;
#line 135
    flagsString ++;
    {
#line 137
    if ((int const   )*tmp___1 == 117) {
#line 137
      goto case_117;
    }
#line 141
    if ((int const   )*tmp___1 == 98) {
#line 141
      goto case_98;
    }
#line 145
    goto switch_default;
    case_117: /* CIL Label */ 
#line 138
    colorFlags |= 2;
#line 139
    goto switch_break;
    case_98: /* CIL Label */ 
#line 142
    colorFlags |= 1;
#line 143
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 146
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 153
  tmp___2 = strcmp(foreground___0, "default");
  }
#line 153
  if (tmp___2 == 0) {
#line 154
    foreground___0 = "";
  }
  {
#line 156
  tmp___3 = strcmp(background___0, "default");
  }
#line 156
  if (tmp___3 == 0) {
#line 157
    background___0 = "";
  }
#line 162
  colorId = 0;
  {
#line 162
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 162
    if (! (colorId < colorCount)) {
#line 162
      goto while_break___0;
    }
    {
#line 164
    pair = & colorTable[colorId];
#line 166
    tmp___4 = strcmp(pair->foreground, foreground___0);
    }
#line 166
    if (tmp___4 == 0) {
      {
#line 166
      tmp___5 = strcmp(pair->background, background___0);
      }
#line 166
      if (tmp___5 == 0) {
#line 166
        if (pair->flags == colorFlags) {
#line 170
          return (colorId);
        }
      }
    }
#line 162
    colorId ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 178
  if (colorCount >= 20) {
    {
#line 180
    free((void *)dupColor);
    }
#line 182
    return (-1);
  }
#line 185
  pair = & colorTable[colorCount];
#line 187
  pair->foreground = foreground___0;
#line 188
  pair->background = background___0;
#line 189
  pair->flags = colorFlags;
#line 191
  tmp___6 = colorCount;
#line 191
  colorCount ++;
#line 191
  return (tmp___6);
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/ips-4.0/color.c"
BOOL DefineColors(void) 
{ 
  int colorId ;
  ColorData const   *colorData ;
  BOOL tmp ;

  {
#line 205
  colorId = 0;
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 205
    if (! (colorId < colorCount)) {
#line 205
      goto while_break;
    }
    {
#line 207
    colorData = (ColorData const   *)(& colorTable[colorId]);
#line 209
    tmp = DpyDefineColor(colorId, (char const   *)colorData->foreground, (char const   *)colorData->background,
                         (int )colorData->flags);
    }
#line 209
    if (! tmp) {
#line 212
      return (0);
    }
#line 205
    colorId ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 216
  return (1);
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/ips-4.0/color.c"
void ClearRowColorConditions(void) 
{ 


  {
#line 227
  rowColorCount = 0;
#line 228
  return;
}
}
#line 236 "/home/june/repo/benchmarks/collector/temp/ips-4.0/color.c"
BOOL ParseRowColorCondition(char const   *color , char const   *condition ) 
{ 
  RowColor *rowColor ;
  BOOL tmp ;

  {
#line 241
  if (rowColorCount >= 50) {
#line 242
    return (0);
  }
  {
#line 244
  rowColor = & rowColorTable[rowColorCount];
#line 246
  rowColor->colorId = AllocateColor(color);
  }
#line 248
  if (rowColor->colorId == -1) {
#line 249
    return (0);
  }
  {
#line 251
  tmp = ParseTree(& rowColor->tree, condition, 0);
  }
#line 251
  if (! tmp) {
#line 252
    return (0);
  }
#line 254
  rowColorCount ++;
#line 256
  return (1);
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/ips-4.0/color.c"
USEFLAG GetRowColorUseFlags(void) 
{ 
  USEFLAG useFlags ;
  int index___0 ;
  USEFLAG tmp ;

  {
#line 266
  useFlags = (USEFLAG )0;
#line 269
  index___0 = 0;
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    if (! (index___0 < rowColorCount)) {
#line 269
      goto while_break;
    }
    {
#line 271
    tmp = GetNodeUseFlags((NODE const   *)rowColorTable[index___0].tree.root);
#line 271
    useFlags |= tmp;
#line 269
    index___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 274
  return (useFlags);
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/ips-4.0/color.c"
int EvaluateRowColor(PROC const   *proc ) 
{ 
  int colorId ;
  int index___0 ;
  BOOL isWanted ;
  RowColor *rowColor ;
  VALUE value ;

  {
#line 285
  colorId = 0;
#line 291
  index___0 = 0;
  {
#line 291
  while (1) {
    while_continue: /* CIL Label */ ;
#line 291
    if (! (index___0 < rowColorCount)) {
#line 291
      goto while_break;
    }
    {
#line 293
    isWanted = 0;
#line 295
    rowColor = & rowColorTable[index___0];
#line 297
    rowColor->tree.proc = proc;
#line 299
    value = EvaluateNode(& rowColor->tree, (NODE const   *)rowColor->tree.root);
    }
#line 301
    if (value.type == 2) {
#line 303
      isWanted = value.intVal != 0L;
    } else
#line 301
    if (value.type == 5) {
#line 303
      isWanted = value.intVal != 0L;
    } else
#line 305
    if (value.type == 3) {
#line 307
      isWanted = (int const   )*(value.strVal) != 0;
    }
#line 310
    if (isWanted) {
#line 311
      colorId = rowColor->colorId;
    }
#line 291
    index___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 314
  return (colorId);
}
}
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 336
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setvbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ,
                                                                              int __modes ,
                                                                              size_t __n ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 580
extern int putchar(int __c ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 779 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 645 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
DISPLAY *GetTtyDisplay(void) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ttydisplay.c"
static COLOR_INFO const   colorInfoTable[9]  = 
#line 40 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ttydisplay.c"
  {      {"black", (short)30, (short)40}, 
        {"red", (short)31, (short)41}, 
        {"green", (short)32, (short)42}, 
        {"yellow", (short)33, (short)43}, 
        {"blue", (short)34, (short)44}, 
        {"magenta", (short)35, (short)45}, 
        {"cyan", (short)36, (short)46}, 
        {"white", (short)37, (short)47}, 
        {(char const   *)((void *)0), (short)0, (short)0}};
#line 62
static BOOL TtyOpen(DISPLAY *display___2 ) ;
#line 63
static BOOL TtyDefineColor(DISPLAY *display___2 , int colorId , char const   *foreground___0 ,
                           char const   *background___0 , int colorFlags ) ;
#line 64
static void TtyCreateWindow(DISPLAY *display___2 ) ;
#line 65
static void TtyClose(DISPLAY *display___2 ) ;
#line 66
static void TtySetColor(DISPLAY *display___2 , int colorId ) ;
#line 67
static void TtyRefresh(DISPLAY *display___2 ) ;
#line 68
static void TtyBeginPage(DISPLAY *display___2 ) ;
#line 69
static void TtyPutChar(DISPLAY *display___2 , int ch ) ;
#line 70
static void TtyPutString(DISPLAY *display___2 , char const   *str ) ;
#line 71
static void TtyPutBuffer(DISPLAY *display___2 , char const   *str , int len ) ;
#line 72
static void TtyEndPage(DISPLAY *display___2 ) ;
#line 73
static BOOL TtyEventWait(DISPLAY *display___2 , int milliSeconds ) ;
#line 74
static BOOL TtyInputReady(DISPLAY *display___2 ) ;
#line 75
static int TtyReadChar(DISPLAY *display___2 ) ;
#line 76
static void TtyRingBell(DISPLAY *display___2 ) ;
#line 77
static int TtyGetRows(DISPLAY *display___2 ) ;
#line 78
static int TtyGetCols(DISPLAY *display___2 ) ;
#line 79
static BOOL TtyDoesScroll(DISPLAY *display___2 ) ;
#line 82 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ttydisplay.c"
static DISPLAY ttyDisplay  = 
#line 82
     {& TtyOpen, & TtyDefineColor, & TtyCreateWindow, & TtyClose, & TtySetColor, & TtyRefresh,
    & TtyBeginPage, & TtyPutChar, & TtyPutString, & TtyPutBuffer, & TtyEndPage, & TtyEventWait,
    & TtyInputReady, & TtyReadChar, & TtyRingBell, & TtyGetRows, & TtyGetCols, & TtyDoesScroll};
#line 96 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ttydisplay.c"
static int foregroundColorTable[20]  ;
#line 97 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ttydisplay.c"
static int backgroundColorTable[20]  ;
#line 98 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ttydisplay.c"
static int flagsColorTable[20]  ;
#line 104 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ttydisplay.c"
static int currentColorId  ;
#line 105 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ttydisplay.c"
static int currentForegroundIndex  ;
#line 106 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ttydisplay.c"
static int currentBackgroundIndex  ;
#line 107 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ttydisplay.c"
static int currentColorFlags  ;
#line 113 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ttydisplay.c"
static BOOL shown  ;
#line 114 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ttydisplay.c"
static BOOL sizeChanged  ;
#line 115 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ttydisplay.c"
static int rows  =    99999;
#line 116 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ttydisplay.c"
static int cols  =    80;
#line 118
static void HandleResize(int arg ) ;
#line 119
static void GetTerminalSize___0(void) ;
#line 120
static int FindColorNameIndex(char const   *name ) ;
#line 126 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ttydisplay.c"
DISPLAY *GetTtyDisplay(void) 
{ 


  {
#line 129
  return (& ttyDisplay);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ttydisplay.c"
static BOOL TtyOpen(DISPLAY *display___2 ) 
{ 
  int colorId ;
  int tmp ;

  {
  {
#line 145
  tmp = isatty(1);
  }
#line 145
  if (tmp) {
    {
#line 147
    signal(28, & HandleResize);
#line 149
    GetTerminalSize___0();
    }
  }
  {
#line 155
  setvbuf((FILE */* __restrict  */)stdout, (char */* __restrict  */)((void *)0), 0,
          (size_t )8192);
#line 157
  shown = 0;
#line 162
  colorId = 0;
  }
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (! (colorId < 20)) {
#line 162
      goto while_break;
    }
#line 164
    foregroundColorTable[colorId] = -1;
#line 165
    backgroundColorTable[colorId] = -1;
#line 166
    flagsColorTable[colorId] = 0;
#line 162
    colorId ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 169
  currentColorId = 0;
#line 170
  currentForegroundIndex = -1;
#line 171
  currentBackgroundIndex = -1;
#line 172
  currentColorFlags = 0;
#line 174
  return (1);
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ttydisplay.c"
static void TtyCreateWindow(DISPLAY *display___2 ) 
{ 


  {
#line 185
  return;
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ttydisplay.c"
static void TtyClose(DISPLAY *display___2 ) 
{ 


  {
  {
#line 194
  fflush(stdout);
  }
#line 195
  return;
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ttydisplay.c"
static BOOL TtyDefineColor(DISPLAY *display___2 , int colorId , char const   *foreground___0 ,
                           char const   *background___0 , int colorFlags ) 
{ 
  int foregroundIndex ;
  int backgroundIndex ;

  {
#line 206
  foregroundIndex = -1;
#line 207
  backgroundIndex = -1;
#line 212
  if (colorId < 0) {
#line 213
    return (0);
  } else
#line 212
  if (colorId >= 20) {
#line 213
    return (0);
  }
#line 218
  if (colorFlags & -4) {
#line 219
    return (0);
  }
#line 225
  if (*foreground___0) {
    {
#line 227
    foregroundIndex = FindColorNameIndex(foreground___0);
    }
#line 229
    if (foregroundIndex < 0) {
#line 230
      return (0);
    }
  }
#line 237
  if (*background___0) {
    {
#line 239
    backgroundIndex = FindColorNameIndex(background___0);
    }
#line 241
    if (backgroundIndex < 0) {
#line 242
      return (0);
    }
  }
#line 249
  if (foregroundIndex > 7) {
#line 249
    goto _L;
  } else
#line 249
  if (backgroundIndex > 7) {
    _L: /* CIL Label */ 
#line 249
    if (colorFlags & 1) {
#line 252
      return (0);
    }
  }
#line 259
  foregroundColorTable[colorId] = foregroundIndex;
#line 260
  backgroundColorTable[colorId] = backgroundIndex;
#line 261
  flagsColorTable[colorId] = colorFlags;
#line 264
  return (1);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ttydisplay.c"
static int FindColorNameIndex(char const   *name ) 
{ 
  int index___0 ;
  int tmp ;
  char const   *tmp___0 ;

  {
#line 279
  if ((int const   )*name == 0) {
#line 280
    return (-1);
  }
#line 285
  index___0 = 0;
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 285
    if (! colorInfoTable[index___0].name) {
#line 285
      goto while_break;
    }
    {
#line 287
    tmp = strcmp(name, (char const   *)colorInfoTable[index___0].name);
    }
#line 287
    if (tmp == 0) {
#line 288
      return (index___0);
    }
#line 285
    index___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 295
  index___0 = 0;
  {
#line 297
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 297
    if ((int const   )*name >= 48) {
#line 297
      if (! ((int const   )*name <= 57)) {
#line 297
        goto while_break___0;
      }
    } else {
#line 297
      goto while_break___0;
    }
#line 298
    tmp___0 = name;
#line 298
    name ++;
#line 298
    index___0 = index___0 * 10 + (int )((int const   )*tmp___0 - 48);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 303
  if (*name) {
#line 304
    return (-1);
  } else
#line 303
  if (index___0 < 0) {
#line 304
    return (-1);
  } else
#line 303
  if (index___0 > 255) {
#line 304
    return (-1);
  }
#line 306
  return (index___0);
}
}
#line 313 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ttydisplay.c"
static void TtySetColor(DISPLAY *display___2 , int colorId ) 
{ 
  int foregroundIndex ;
  int backgroundIndex ;
  int colorFlags ;
  char *cp ;
  char *endIntroCp ;
  char buffer[64] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;

  {
#line 323
  if (colorId < 0) {
#line 324
    return;
  } else
#line 323
  if (colorId >= 20) {
#line 324
    return;
  }
#line 326
  if (colorId == currentColorId) {
#line 327
    return;
  }
#line 329
  currentColorId = colorId;
#line 331
  foregroundIndex = foregroundColorTable[colorId];
#line 332
  backgroundIndex = backgroundColorTable[colorId];
#line 333
  colorFlags = flagsColorTable[colorId];
#line 335
  if (foregroundIndex == currentForegroundIndex) {
#line 335
    if (backgroundIndex == currentBackgroundIndex) {
#line 335
      if (colorFlags == currentColorFlags) {
#line 339
        return;
      }
    }
  }
#line 342
  currentForegroundIndex = foregroundIndex;
#line 343
  currentBackgroundIndex = backgroundIndex;
#line 344
  currentColorFlags = colorFlags;
#line 349
  cp = buffer;
#line 350
  tmp = cp;
#line 350
  cp ++;
#line 350
  *tmp = (char )'\033';
#line 351
  tmp___0 = cp;
#line 351
  cp ++;
#line 351
  *tmp___0 = (char )'[';
#line 352
  endIntroCp = cp;
#line 357
  if (foregroundIndex < 0) {
#line 358
    tmp___1 = cp;
#line 358
    cp ++;
#line 358
    *tmp___1 = (char )'0';
  } else
#line 357
  if (backgroundIndex < 0) {
#line 358
    tmp___1 = cp;
#line 358
    cp ++;
#line 358
    *tmp___1 = (char )'0';
  }
#line 363
  if (currentColorFlags & 2) {
#line 365
    if ((unsigned long )cp != (unsigned long )endIntroCp) {
#line 366
      tmp___2 = cp;
#line 366
      cp ++;
#line 366
      *tmp___2 = (char )';';
    }
#line 368
    tmp___3 = cp;
#line 368
    cp ++;
#line 368
    *tmp___3 = (char )'4';
  }
#line 371
  if (currentColorFlags & 1) {
#line 373
    if ((unsigned long )cp != (unsigned long )endIntroCp) {
#line 374
      tmp___4 = cp;
#line 374
      cp ++;
#line 374
      *tmp___4 = (char )';';
    }
#line 376
    tmp___5 = cp;
#line 376
    cp ++;
#line 376
    *tmp___5 = (char )'1';
  }
#line 382
  if (foregroundIndex >= 0) {
#line 384
    if ((unsigned long )cp != (unsigned long )endIntroCp) {
#line 385
      tmp___6 = cp;
#line 385
      cp ++;
#line 385
      *tmp___6 = (char )';';
    }
#line 391
    if (foregroundIndex > 7) {
      {
#line 392
      sprintf((char */* __restrict  */)cp, (char const   */* __restrict  */)"38;5;%d",
              foregroundIndex);
      }
    } else {
      {
#line 394
      sprintf((char */* __restrict  */)cp, (char const   */* __restrict  */)"%d",
              (int const   )colorInfoTable[foregroundIndex].foreground);
      }
    }
    {
#line 396
    tmp___7 = strlen((char const   *)cp);
#line 396
    cp += tmp___7;
    }
  }
#line 402
  if (backgroundIndex >= 0) {
#line 404
    if ((unsigned long )cp != (unsigned long )endIntroCp) {
#line 405
      tmp___8 = cp;
#line 405
      cp ++;
#line 405
      *tmp___8 = (char )';';
    }
#line 411
    if (backgroundIndex > 7) {
      {
#line 412
      sprintf((char */* __restrict  */)cp, (char const   */* __restrict  */)"48;5;%d",
              backgroundIndex);
      }
    } else {
      {
#line 414
      sprintf((char */* __restrict  */)cp, (char const   */* __restrict  */)"%d",
              (int const   )colorInfoTable[backgroundIndex].background);
      }
    }
    {
#line 416
    tmp___9 = strlen((char const   *)cp);
#line 416
    cp += tmp___9;
    }
  }
  {
#line 422
  tmp___10 = cp;
#line 422
  cp ++;
#line 422
  *tmp___10 = (char )'m';
#line 423
  *cp = (char )'\000';
#line 425
  fputs((char const   */* __restrict  */)(buffer), (FILE */* __restrict  */)stdout);
  }
#line 426
  return;
}
}
#line 429 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ttydisplay.c"
static void TtyRefresh(DISPLAY *display___2 ) 
{ 


  {
#line 432
  return;
}
}
#line 435 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ttydisplay.c"
static void TtyBeginPage(DISPLAY *display___2 ) 
{ 


  {
#line 438
  if (clearScreen) {
    {
#line 439
    fputs((char const   */* __restrict  */)"\033[H\033[2J", (FILE */* __restrict  */)stdout);
    }
  } else
#line 440
  if (shown) {
    {
#line 441
    putchar('\n');
    }
  }
#line 442
  return;
}
}
#line 445 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ttydisplay.c"
static void TtyPutChar(DISPLAY *display___2 , int ch ) 
{ 


  {
#line 452
  if (ch == 10) {
    {
#line 453
    TtySetColor(display___2, 0);
    }
  }
  {
#line 455
  putchar(ch);
#line 457
  shown = 1;
  }
#line 458
  return;
}
}
#line 461 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ttydisplay.c"
static void TtyPutString(DISPLAY *display___2 , char const   *str ) 
{ 


  {
  {
#line 464
  fputs((char const   */* __restrict  */)str, (FILE */* __restrict  */)stdout);
  }
#line 465
  return;
}
}
#line 468 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ttydisplay.c"
static void TtyPutBuffer(DISPLAY *display___2 , char const   *str , int len ) 
{ 
  int tmp ;

  {
  {
#line 471
  while (1) {
    while_continue: /* CIL Label */ ;
#line 471
    tmp = len;
#line 471
    len --;
#line 471
    if (! (tmp > 0)) {
#line 471
      goto while_break;
    }
    {
#line 473
    putchar((int )*str);
#line 474
    str ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 476
  return;
}
}
#line 479 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ttydisplay.c"
static void TtyEndPage(DISPLAY *display___2 ) 
{ 


  {
  {
#line 482
  fflush(stdout);
  }
#line 483
  return;
}
}
#line 491 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ttydisplay.c"
static BOOL TtyEventWait(DISPLAY *display___2 , int milliSeconds ) 
{ 
  struct timeval timeOut ;

  {
#line 496
  if (milliSeconds <= 0) {
#line 497
    return (0);
  }
  {
#line 499
  timeOut.tv_sec = (__time_t )(milliSeconds / 1000);
#line 500
  timeOut.tv_usec = (__suseconds_t )((milliSeconds % 1000) * 1000);
#line 502
  select(0, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)((void *)0),
         (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& timeOut));
  }
#line 504
  return (0);
}
}
#line 512 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ttydisplay.c"
static BOOL TtyInputReady(DISPLAY *display___2 ) 
{ 


  {
#line 515
  return (0);
}
}
#line 523 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ttydisplay.c"
static int TtyReadChar(DISPLAY *display___2 ) 
{ 


  {
#line 526
  return (-1);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ttydisplay.c"
static void TtyRingBell(DISPLAY *display___2 ) 
{ 


  {
  {
#line 533
  fflush(stdout);
#line 534
  fputc('\a', stderr);
#line 535
  fflush(stderr);
  }
#line 536
  return;
}
}
#line 539 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ttydisplay.c"
static int TtyGetRows(DISPLAY *display___2 ) 
{ 


  {
#line 542
  if (sizeChanged) {
    {
#line 543
    GetTerminalSize___0();
    }
  }
#line 545
  return (rows);
}
}
#line 549 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ttydisplay.c"
static int TtyGetCols(DISPLAY *display___2 ) 
{ 


  {
#line 552
  if (sizeChanged) {
    {
#line 553
    GetTerminalSize___0();
    }
  }
#line 555
  return (cols);
}
}
#line 559 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ttydisplay.c"
static BOOL TtyDoesScroll(DISPLAY *display___2 ) 
{ 


  {
#line 562
  return (1);
}
}
#line 571 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ttydisplay.c"
static void HandleResize(int arg ) 
{ 


  {
  {
#line 574
  sizeChanged = 1;
#line 576
  signal(28, & HandleResize);
  }
#line 577
  return;
}
}
#line 583 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ttydisplay.c"
static void GetTerminalSize___0(void) 
{ 
  struct winsize size ;
  int tmp ;

  {
  {
#line 588
  sizeChanged = 0;
#line 590
  tmp = ioctl(1, 21523UL, & size);
  }
#line 590
  if (tmp < 0) {
#line 591
    return;
  }
#line 593
  rows = (int )size.ws_row;
#line 594
  cols = (int )size.ws_col;
#line 596
  if (rows <= 0) {
#line 597
    rows = 1;
  }
#line 599
  if (cols <= 0) {
#line 600
    cols = 1;
  }
#line 601
  return;
}
}
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 545 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
BOOL ParseFile(char const   *name , BOOL isOptional ) ;
#line 595
BOOL DefineMacro(MACRO_TYPE type , char const   *name , char const   *str ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/ips-4.0/file.c"
static char *ReadLine(FILE *fp ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/ips-4.0/file.c"
BOOL ParseUserInitFile(void) 
{ 
  char const   *home ;
  char *fullName ;
  BOOL result ;
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 39
  tmp = getenv("HOME");
#line 39
  home = (char const   *)tmp;
  }
#line 41
  if ((unsigned long )home == (unsigned long )((void *)0)) {
#line 42
    return (1);
  }
  {
#line 44
  tmp___0 = strlen(home);
#line 44
  tmp___1 = AllocMemory((int )((tmp___0 + sizeof(".ipsrc")) + 2UL));
#line 44
  fullName = (char *)tmp___1;
#line 46
  strcpy((char */* __restrict  */)fullName, (char const   */* __restrict  */)home);
#line 47
  strcat((char */* __restrict  */)fullName, (char const   */* __restrict  */)"/");
#line 48
  strcat((char */* __restrict  */)fullName, (char const   */* __restrict  */)".ipsrc");
#line 53
  result = ParseFile((char const   *)fullName, 1);
#line 55
  free((void *)fullName);
  }
#line 57
  return (result);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/ips-4.0/file.c"
BOOL ParseSystemInitFile(void) 
{ 
  BOOL tmp ;

  {
  {
#line 71
  tmp = ParseFile("/usr/local/lib/ips.init", 1);
  }
#line 71
  return (tmp);
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/ips-4.0/file.c"
BOOL ParseFile(char const   *name , BOOL isOptional ) 
{ 
  FILE *fp ;
  char *cp ;
  char *cmd ;
  BOOL status ;
  MACRO_TYPE macroType ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  BOOL tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;

  {
#line 89
  status = 1;
#line 95
  if (isOptional) {
    {
#line 95
    tmp = access(name, 0);
    }
#line 95
    if (tmp != 0) {
      {
#line 95
      tmp___0 = __errno_location();
      }
#line 95
      if (*tmp___0 == 2) {
#line 96
        return (1);
      }
    }
  }
  {
#line 102
  tmp___3 = access(name, 4);
  }
#line 102
  if (tmp___3 != 0) {
    {
#line 104
    tmp___1 = __errno_location();
#line 104
    tmp___2 = strerror(*tmp___1);
#line 104
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot access \"%s\" for reading: %s\n",
            name, tmp___2);
    }
#line 107
    return (0);
  }
  {
#line 110
  fp = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"r");
  }
#line 112
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 114
    tmp___4 = __errno_location();
#line 114
    tmp___5 = strerror(*tmp___4);
#line 114
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open \"%s\" for reading: %s\n",
            name, tmp___5);
    }
#line 117
    return (0);
  }
  {
#line 124
  cmd = ReadLine(fp);
  }
#line 126
  if ((unsigned long )cmd == (unsigned long )((void *)0)) {
    {
#line 128
    fclose(fp);
#line 130
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The file \"%s\" does not begin with \"%s\".\n",
            name, "#ips#");
    }
#line 134
    return (0);
  } else {
    {
#line 126
    tmp___6 = strcmp((char const   *)cmd, "#ips#");
    }
#line 126
    if (tmp___6 != 0) {
      {
#line 128
      fclose(fp);
#line 130
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The file \"%s\" does not begin with \"%s\".\n",
              name, "#ips#");
      }
#line 134
      return (0);
    }
  }
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 142
    cmd = ReadLine(fp);
    }
#line 144
    if ((unsigned long )cmd == (unsigned long )((void *)0)) {
#line 145
      goto while_break;
    }
    {
#line 147
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 147
      if (! ((int )*cmd == 32)) {
#line 147
        if (! ((int )*cmd == 9)) {
#line 147
          goto while_break___0;
        }
      }
#line 148
      cmd ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 153
    if ((int )*cmd == 35) {
#line 154
      goto while_continue;
    } else
#line 153
    if ((int )*cmd == 0) {
#line 154
      goto while_continue;
    }
#line 156
    cp = cmd;
    {
#line 158
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 158
      if ((int )*cp != 0) {
#line 158
        if ((int )*cp == 32) {
#line 158
          goto while_break___1;
        } else
#line 158
        if ((int )*cp == 9) {
#line 158
          goto while_break___1;
        }
      } else {
#line 158
        goto while_break___1;
      }
#line 159
      cp ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 161
    if (*cp) {
#line 162
      tmp___7 = cp;
#line 162
      cp ++;
#line 162
      *tmp___7 = (char )'\000';
    }
    {
#line 164
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 164
      if (! ((int )*cp == 32)) {
#line 164
        if (! ((int )*cp == 9)) {
#line 164
          goto while_break___2;
        }
      }
#line 165
      cp ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 170
    macroType = -1;
#line 172
    tmp___10 = strcmp((char const   *)cmd, "option");
    }
#line 172
    if (tmp___10 == 0) {
#line 173
      macroType = 0;
    } else {
      {
#line 174
      tmp___9 = strcmp((char const   *)cmd, "column");
      }
#line 174
      if (tmp___9 == 0) {
#line 175
        macroType = 1;
      } else {
        {
#line 176
        tmp___8 = strcmp((char const   *)cmd, "expr");
        }
#line 176
        if (tmp___8 == 0) {
#line 177
          macroType = 2;
        }
      }
    }
#line 179
    if (macroType != -1) {
#line 181
      cmd = cp;
      {
#line 183
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 183
        if ((int )*cp != 0) {
#line 183
          if ((int )*cp == 32) {
#line 183
            goto while_break___3;
          } else
#line 183
          if ((int )*cp == 9) {
#line 183
            goto while_break___3;
          }
        } else {
#line 183
          goto while_break___3;
        }
#line 184
        cp ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 186
      if (*cp) {
#line 187
        tmp___11 = cp;
#line 187
        cp ++;
#line 187
        *tmp___11 = (char )'\000';
      }
      {
#line 189
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 189
        if (! ((int )*cp == 32)) {
#line 189
          if (! ((int )*cp == 9)) {
#line 189
            goto while_break___4;
          }
        }
#line 190
        cp ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 192
      tmp___12 = DefineMacro(macroType, (char const   *)cmd, (char const   *)cp);
      }
#line 192
      if (! tmp___12) {
#line 193
        status = 0;
      }
#line 195
      goto while_continue;
    }
    {
#line 201
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Unknown command \"%s\"\n",
            name, cmd);
#line 203
    status = 0;
    }
#line 205
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 208
  tmp___15 = ferror(fp);
  }
#line 208
  if (tmp___15) {
    {
#line 210
    tmp___13 = __errno_location();
#line 210
    tmp___14 = strerror(*tmp___13);
#line 210
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error reading \"%s\": %s\n",
            name, tmp___14);
#line 213
    fclose(fp);
    }
#line 215
    return (0);
  }
  {
#line 218
  fclose(fp);
  }
#line 220
  return (status);
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/ips-4.0/file.c"
static char *buf  ;
#line 236 "/home/june/repo/benchmarks/collector/temp/ips-4.0/file.c"
static int avail  ;
#line 237 "/home/june/repo/benchmarks/collector/temp/ips-4.0/file.c"
static int used  ;
#line 231 "/home/june/repo/benchmarks/collector/temp/ips-4.0/file.c"
static char *ReadLine(FILE *fp ) 
{ 
  char *tmpBuf ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;

  {
#line 239
  used = 0;
  {
#line 241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 246
    if (used + 100 > avail) {
#line 248
      if (avail == 0) {
        {
#line 249
        tmp = malloc((size_t )100);
#line 249
        tmpBuf = (char *)tmp;
        }
      } else {
        {
#line 251
        tmp___0 = realloc((void *)buf, (size_t )(avail + 100));
#line 251
        tmpBuf = (char *)tmp___0;
        }
      }
#line 253
      if ((unsigned long )tmpBuf == (unsigned long )((void *)0)) {
        {
#line 255
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot allocate memory\n");
        }
#line 257
        return ((char *)((void *)0));
      }
#line 260
      buf = tmpBuf;
#line 261
      avail += 100;
    }
    {
#line 268
    tmp___1 = fgets((char */* __restrict  */)(buf + used), avail - used, (FILE */* __restrict  */)fp);
    }
#line 268
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 270
      if (used) {
#line 271
        return (buf);
      }
#line 273
      return ((char *)((void *)0));
    }
    {
#line 279
    tmp___2 = strlen((char const   *)(buf + used));
#line 279
    used = (int )((size_t )used + tmp___2);
    }
#line 285
    if (used > 0) {
#line 285
      if ((int )*(buf + (used - 1)) != 10) {
#line 286
        goto while_continue;
      }
    }
#line 291
    used --;
#line 291
    *(buf + used) = (char )'\000';
#line 297
    if (used > 0) {
#line 297
      if ((int )*(buf + (used - 1)) == 92) {
#line 299
        *(buf + (used - 1)) = (char )' ';
#line 301
        goto while_continue;
      }
    }
#line 307
    return (buf);
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 1406 "/usr/include/X11/Xlib.h"
extern XFontStruct *XLoadQueryFont(Display * , char const   * ) ;
#line 1495
extern Display *XOpenDisplay(char const   * ) ;
#line 1596
extern GC XCreateGC(Display * , Drawable  , unsigned long  , XGCValues * ) ;
#line 1633
extern Window XCreateSimpleWindow(Display * , Window  , int  , int  , unsigned int  ,
                                  unsigned int  , unsigned int  , unsigned long  ,
                                  unsigned long  ) ;
#line 2000
extern int XAllocNamedColor(Display * , Colormap  , char const   * , XColor * , XColor * ) ;
#line 2022
extern int XBell(Display * , int  ) ;
#line 2157
extern int XClearArea(Display * , Window  , int  , int  , unsigned int  , unsigned int  ,
                      int  ) ;
#line 2167
extern int XClearWindow(Display * , Window  ) ;
#line 2172
extern int XCloseDisplay(Display * ) ;
#line 2354
extern int XDrawLine(Display * , Drawable  , GC  , int  , int  , int  , int  ) ;
#line 2416
extern int XDrawString(Display * , Drawable  , GC  , int  , int  , char const   * ,
                       int  ) ;
#line 2460
extern int XEventsQueued(Display * , int  ) ;
#line 2501
extern int XFillRectangle(Display * , Drawable  , GC  , int  , int  , unsigned int  ,
                          unsigned int  ) ;
#line 2519
extern int XFlush(Display * ) ;
#line 2818
extern int XMapWindow(Display * , Window  ) ;
#line 2853
extern int XNextEvent(Display * , XEvent * ) ;
#line 2869
extern int XParseGeometry(char const   * , int * , int * , unsigned int * , unsigned int * ) ;
#line 2877
extern int XPeekEvent(Display * , XEvent * ) ;
#line 3141
extern int XSelectInput(Display * , Window  , long  ) ;
#line 3166
extern int XSetBackground(Display * , GC  , unsigned long  ) ;
#line 3227
extern int XSetFont(Display * , GC  , Font  ) ;
#line 3239
extern int XSetForeground(Display * , GC  , unsigned long  ) ;
#line 3421
extern int XSync(Display * , int  ) ;
#line 534 "/usr/include/X11/Xutil.h"
extern int XLookupString(XKeyEvent * , char * , int  , KeySym * , XComposeStatus * ) ;
#line 617
extern int XSetStandardProperties(Display * , Window  , char const   * , char const   * ,
                                  Pixmap  , char ** , int  , XSizeHints * ) ;
#line 641
extern int XSetWMHints(Display * , Window  , XWMHints * ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 536 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
void *ReallocMemory(void *oldBuffer , int len ) ;
#line 647
DISPLAY *GetX11Display(void) ;
#line 88 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static BOOL X11Open(DISPLAY *ipsDisplay ) ;
#line 89
static BOOL X11DefineColor(DISPLAY *ipsDisplay , int colorId , char const   *foregroundName___0 ,
                           char const   *backgroundName___0 , int colorFlags ) ;
#line 90
static void X11CreateWindow(DISPLAY *ipsDisplay ) ;
#line 91
static void X11Close(DISPLAY *ipsDisplay ) ;
#line 92
static void X11SetColor(DISPLAY *ipsDisplay , int colorId ) ;
#line 93
static void X11Refresh(DISPLAY *ipsDisplay ) ;
#line 94
static void X11BeginPage(DISPLAY *ipsDisplay ) ;
#line 95
static void X11PutChar(DISPLAY *ipsDisplay , int ch ) ;
#line 96
static void X11PutString(DISPLAY *ipsDisplay , char const   *str ) ;
#line 97
static void X11PutBuffer(DISPLAY *ipsDisplay , char const   *str , int len ) ;
#line 98
static void X11EndPage(DISPLAY *ipsDisplay ) ;
#line 99
static BOOL X11EventWait(DISPLAY *ipsDisplay , int milliSeconds ) ;
#line 100
static BOOL X11InputReady(DISPLAY *ipsDisplay ) ;
#line 101
static int X11ReadChar(DISPLAY *ipsDisplay ) ;
#line 102
static void X11RingBell(DISPLAY *ipsDisplay ) ;
#line 103
static int X11GetRows(DISPLAY *ipsDisplay ) ;
#line 104
static int X11GetCols(DISPLAY *ipsDisplay ) ;
#line 105
static BOOL X11DoesScroll(DISPLAY *ipsDisplay ) ;
#line 108 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static DISPLAY x11Display  = 
#line 108
     {& X11Open, & X11DefineColor, & X11CreateWindow, & X11Close, & X11SetColor, & X11Refresh,
    & X11BeginPage, & X11PutChar, & X11PutString, & X11PutBuffer, & X11EndPage, & X11EventWait,
    & X11InputReady, & X11ReadChar, & X11RingBell, & X11GetRows, & X11GetCols, & X11DoesScroll};
#line 120 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static Display *display___0  ;
#line 121 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static int screen  ;
#line 122 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static Window rootWid  ;
#line 123 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static Window mainWid  ;
#line 124 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static GC textGC  ;
#line 125 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static GC clearGC  ;
#line 126 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static XFontStruct *font  ;
#line 127 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static Colormap colorMap  ;
#line 128 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static long black  ;
#line 129 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static long white  ;
#line 130 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static long foreground  ;
#line 131 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static long background  ;
#line 132 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static int charWidth  ;
#line 133 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static int charHeight  ;
#line 134 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static int charAscent  ;
#line 135 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static int mainWidth  ;
#line 136 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static int mainHeight  ;
#line 137 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static int textRow  ;
#line 138 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static int textCol  ;
#line 139 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static int rows___0  ;
#line 140 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static int cols___0  ;
#line 141 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static int inputCount  ;
#line 142 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static BOOL isMapped  ;
#line 143 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static BOOL isRedrawNeeded  ;
#line 144 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static LINE *lines[500]  ;
#line 145 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static char inputBuffer[128]  ;
#line 152 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static int currentColorId___0  ;
#line 153 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static long currentForegroundPixel  ;
#line 154 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static long currentBackgroundPixel  ;
#line 155 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static int currentColorFlags___0  ;
#line 156 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static long foregroundColorTable___0[20]  ;
#line 157 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static long backgroundColorTable___0[20]  ;
#line 158 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static int colorFlagsTable[20]  ;
#line 164
static void DoEvent(XEvent *event ) ;
#line 165
static void DoKeyPress(XKeyEvent *kp ) ;
#line 166
static void DoConfigure(XConfigureEvent *cp ) ;
#line 167
static void StoreCharacter(int row , int col , int ch ) ;
#line 168
static void StoreEndOfLine(int row , int col ) ;
#line 169
static void SetColor(int colorId ) ;
#line 170
static void UpdateWindow(void) ;
#line 171
static void UpdateRow(int row ) ;
#line 172
static void DrawText(int textX , int textY , char const   *buffer , int count ) ;
#line 173
static void ClearWindow(void) ;
#line 174
static LINE *GetLine(int row ) ;
#line 180 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
DISPLAY *GetX11Display(void) 
{ 


  {
#line 183
  return (& x11Display);
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static BOOL X11Open(DISPLAY *ipsDisplay ) 
{ 
  XColor cellColor ;
  XColor nameColor ;
  int colorId ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 201
  display___0 = XOpenDisplay((char const   *)displayName);
  }
#line 203
  if ((unsigned long )display___0 == (unsigned long )((void *)0)) {
#line 204
    return (0);
  }
  {
#line 206
  screen = ((_XPrivDisplay )display___0)->default_screen;
#line 207
  rootWid = (((_XPrivDisplay )display___0)->screens + screen)->root;
#line 212
  font = XLoadQueryFont(display___0, (char const   *)fontName);
  }
#line 217
  if ((unsigned long )font == (unsigned long )((void *)0)) {
    {
#line 217
    tmp = strcmp((char const   *)fontName, "fixed");
    }
#line 217
    if (tmp != 0) {
      {
#line 218
      font = XLoadQueryFont(display___0, "fixed");
      }
    }
  }
#line 220
  if ((unsigned long )font == (unsigned long )((void *)0)) {
    {
#line 222
    XCloseDisplay(display___0);
#line 224
    display___0 = (Display *)((void *)0);
    }
#line 226
    return (0);
  }
  {
#line 233
  charAscent = font->ascent;
#line 234
  charHeight = charAscent + font->descent;
#line 235
  charWidth = (int )font->max_bounds.width;
#line 240
  black = (long )(((_XPrivDisplay )display___0)->screens + screen)->black_pixel;
#line 241
  white = (long )(((_XPrivDisplay )display___0)->screens + screen)->white_pixel;
#line 243
  colorMap = (((_XPrivDisplay )display___0)->screens + screen)->cmap;
#line 245
  foreground = black;
#line 246
  background = white;
#line 248
  tmp___0 = XAllocNamedColor(display___0, colorMap, (char const   *)foregroundName,
                             & cellColor, & nameColor);
  }
#line 248
  if (tmp___0) {
#line 251
    foreground = (long )cellColor.pixel;
  }
  {
#line 254
  tmp___1 = XAllocNamedColor(display___0, colorMap, (char const   *)backgroundName,
                             & cellColor, & nameColor);
  }
#line 254
  if (tmp___1) {
#line 257
    background = (long )cellColor.pixel;
  }
#line 263
  currentColorId___0 = 0;
#line 264
  currentForegroundPixel = foreground;
#line 265
  currentBackgroundPixel = background;
#line 266
  currentColorFlags___0 = 0;
#line 268
  colorId = 0;
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 268
    if (! (colorId < 20)) {
#line 268
      goto while_break;
    }
#line 270
    foregroundColorTable___0[colorId] = foreground;
#line 271
    backgroundColorTable___0[colorId] = background;
#line 272
    colorFlagsTable[colorId] = 0;
#line 268
    colorId ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 278
  textGC = XCreateGC(display___0, rootWid, 0UL, (XGCValues *)((void *)0));
#line 280
  XSetForeground(display___0, textGC, (unsigned long )foreground);
#line 281
  XSetBackground(display___0, textGC, (unsigned long )background);
#line 282
  XSetFont(display___0, textGC, font->fid);
#line 284
  clearGC = XCreateGC(display___0, rootWid, 0UL, (XGCValues *)((void *)0));
#line 286
  XSetForeground(display___0, clearGC, (unsigned long )background);
#line 291
  XSync(display___0, 0);
  }
#line 296
  return (1);
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static void X11CreateWindow(DISPLAY *ipsDisplay ) 
{ 
  XSizeHints sizeHints ;
  XWMHints wmHints ;
  XEvent event ;
  int displayWidth ;
  int displayHeight ;
  int parsedFlags ;
  int parsedX ;
  int parsedY ;
  unsigned int tryCols ;
  unsigned int tryRows ;

  {
  {
#line 321
  parsedFlags = XParseGeometry((char const   *)geometry, & parsedX, & parsedY, & tryCols,
                               & tryRows);
  }
#line 324
  if ((parsedFlags & 4) == 0) {
#line 325
    tryCols = 150U;
  }
#line 327
  if ((parsedFlags & 8) == 0) {
#line 328
    tryRows = 50U;
  }
#line 330
  if (tryCols < 20U) {
#line 331
    tryCols = 20U;
  }
#line 333
  if (tryCols > 2000U) {
#line 334
    tryCols = 2000U;
  }
#line 336
  if (tryRows < 3U) {
#line 337
    tryRows = 3U;
  }
#line 339
  if (tryRows > 500U) {
#line 340
    tryRows = 500U;
  }
#line 346
  displayWidth = (((_XPrivDisplay )display___0)->screens + screen)->width;
#line 347
  displayHeight = (((_XPrivDisplay )display___0)->screens + screen)->height;
#line 349
  mainWidth = (int )((unsigned int )charWidth * tryCols + 8U);
#line 350
  mainHeight = (int )((unsigned int )charHeight * tryRows + 8U);
#line 352
  if (mainWidth > displayWidth) {
#line 353
    mainWidth = displayWidth;
  }
#line 355
  if (mainHeight > displayHeight) {
#line 356
    mainHeight = displayHeight;
  }
#line 358
  sizeHints.flags = (((1L << 1) | (1L << 4)) | (1L << 6)) | (1L << 8);
#line 359
  sizeHints.width = mainWidth;
#line 360
  sizeHints.height = mainHeight;
#line 361
  sizeHints.width_inc = charWidth;
#line 362
  sizeHints.height_inc = charHeight;
#line 363
  sizeHints.min_width = 8;
#line 364
  sizeHints.min_height = 8;
#line 365
  sizeHints.base_width = 8;
#line 366
  sizeHints.base_height = 8;
#line 373
  if ((parsedFlags & 1) != 0) {
#line 373
    if ((parsedFlags & 2) != 0) {
#line 375
      sizeHints.flags |= 1L;
#line 376
      sizeHints.x = parsedX;
#line 377
      sizeHints.y = parsedY;
    }
  }
  {
#line 380
  mainWid = XCreateSimpleWindow(display___0, rootWid, 0, 0, (unsigned int )mainWidth,
                                (unsigned int )mainHeight, 0U, 0UL, (unsigned long )background);
#line 383
  XSelectInput(display___0, mainWid, (1L | (1L << 15)) | (1L << 17));
#line 386
  XSetStandardProperties(display___0, mainWid, "ips", "ips", (Pixmap )0L, (char **)"",
                         0, & sizeHints);
#line 389
  wmHints.flags = 1L;
#line 390
  wmHints.input = 1;
#line 392
  XSetWMHints(display___0, mainWid, & wmHints);
#line 397
  XMapWindow(display___0, mainWid);
#line 399
  isMapped = 0;
  }
  {
#line 401
  while (1) {
    while_continue: /* CIL Label */ ;
#line 401
    if (! (! isMapped)) {
#line 401
      goto while_break;
    }
    {
#line 403
    XNextEvent(display___0, & event);
#line 404
    DoEvent(& event);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 406
  return;
}
}
#line 412 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static void X11Close(DISPLAY *ipsDisplay ) 
{ 


  {
#line 415
  if (display___0) {
    {
#line 416
    XCloseDisplay(display___0);
    }
  }
#line 418
  display___0 = (Display *)((void *)0);
#line 419
  return;
}
}
#line 429 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static BOOL X11DefineColor(DISPLAY *ipsDisplay , int colorId , char const   *foregroundName___0 ,
                           char const   *backgroundName___0 , int colorFlags ) 
{ 
  long foregroundPixel ;
  long backgroundPixel ;
  XColor cellColor ;
  XColor nameColor ;
  int tmp ;
  int tmp___0 ;

  {
#line 434
  foregroundPixel = foreground;
#line 435
  backgroundPixel = background;
#line 439
  if (colorId < 0) {
#line 440
    return (0);
  } else
#line 439
  if (colorId >= 20) {
#line 440
    return (0);
  }
#line 445
  if (colorFlags & -4) {
#line 446
    return (0);
  }
#line 452
  if (*foregroundName___0) {
    {
#line 454
    tmp = XAllocNamedColor(display___0, colorMap, foregroundName___0, & cellColor,
                           & nameColor);
    }
#line 454
    if (! tmp) {
#line 457
      return (0);
    }
#line 460
    foregroundPixel = (long )cellColor.pixel;
  }
#line 463
  if (*backgroundName___0) {
    {
#line 465
    tmp___0 = XAllocNamedColor(display___0, colorMap, backgroundName___0, & cellColor,
                               & nameColor);
    }
#line 465
    if (! tmp___0) {
#line 468
      return (0);
    }
#line 471
    backgroundPixel = (long )cellColor.pixel;
  }
#line 477
  foregroundColorTable___0[colorId] = foregroundPixel;
#line 478
  backgroundColorTable___0[colorId] = backgroundPixel;
#line 479
  colorFlagsTable[colorId] = colorFlags;
#line 481
  return (1);
}
}
#line 488 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static void X11SetColor(DISPLAY *ipsDisplay , int colorId ) 
{ 


  {
#line 491
  if (colorId < 0) {
#line 492
    colorId = 0;
  } else
#line 491
  if (colorId > 20) {
#line 492
    colorId = 0;
  }
#line 494
  currentColorId___0 = colorId;
#line 495
  return;
}
}
#line 498 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static void X11Refresh(DISPLAY *ipsDisplay ) 
{ 


  {
#line 501
  isRedrawNeeded = 1;
#line 502
  return;
}
}
#line 505 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static void X11BeginPage(DISPLAY *ipsDisplay ) 
{ 


  {
#line 511
  if (isRedrawNeeded) {
    {
#line 512
    ClearWindow();
    }
  }
#line 517
  textRow = 0;
#line 518
  textCol = 0;
#line 519
  return;
}
}
#line 527 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static void X11PutChar(DISPLAY *ipsDisplay , int ch ) 
{ 
  int spaceCount ;
  int tmp ;

  {
  {
#line 537
  if (ch == 0) {
#line 537
    goto case_0;
  }
#line 540
  if (ch == 10) {
#line 540
    goto case_10;
  }
#line 547
  if (ch == 9) {
#line 547
    goto case_9;
  }
#line 555
  goto switch_default;
  case_0: /* CIL Label */ 
#line 538
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 541
  StoreEndOfLine(textRow, textCol);
#line 542
  textCol = 0;
#line 543
  textRow ++;
  }
#line 545
  goto switch_break;
  case_9: /* CIL Label */ 
#line 548
  spaceCount = 8 - (textCol + 1) % 8;
  {
#line 550
  while (1) {
    while_continue: /* CIL Label */ ;
#line 550
    tmp = spaceCount;
#line 550
    spaceCount --;
#line 550
    if (! (tmp > 0)) {
#line 550
      goto while_break;
    }
    {
#line 551
    X11PutChar(ipsDisplay, ' ');
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 553
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 556
  StoreCharacter(textRow, textCol, ch);
#line 557
  textCol ++;
  }
#line 559
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 561
  return;
}
}
#line 564 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static void X11PutString(DISPLAY *ipsDisplay , char const   *str ) 
{ 
  char const   *tmp ;

  {
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    if (! *str) {
#line 567
      goto while_break;
    }
    {
#line 568
    tmp = str;
#line 568
    str ++;
#line 568
    X11PutChar(ipsDisplay, (int )*tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 569
  return;
}
}
#line 572 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static void X11PutBuffer(DISPLAY *ipsDisplay , char const   *str , int len ) 
{ 
  char const   *tmp ;
  int tmp___0 ;

  {
  {
#line 575
  while (1) {
    while_continue: /* CIL Label */ ;
#line 575
    tmp___0 = len;
#line 575
    len --;
#line 575
    if (! (tmp___0 > 0)) {
#line 575
      goto while_break;
    }
    {
#line 576
    tmp = str;
#line 576
    str ++;
#line 576
    X11PutChar(ipsDisplay, (int )*tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 577
  return;
}
}
#line 583 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static void X11EndPage(DISPLAY *ipsDisplay ) 
{ 


  {
  {
#line 589
  while (1) {
    while_continue: /* CIL Label */ ;
#line 589
    if (! (textRow <= rows___0)) {
#line 589
      goto while_break;
    }
    {
#line 591
    StoreEndOfLine(textRow, textCol);
#line 592
    textCol = 0;
#line 593
    textRow ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 599
  UpdateWindow();
#line 600
  XFlush(display___0);
  }
#line 601
  return;
}
}
#line 609 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static BOOL X11EventWait(DISPLAY *ipsDisplay , int milliSeconds ) 
{ 
  XEvent event ;
  struct timeval timeOut ;
  fd_set readFds ;
  int fd ;
  int tmp ;
  int __d0 ;
  int __d1 ;
  int tmp___0 ;

  {
  {
#line 620
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 620
    tmp = XEventsQueued(display___0, 2);
    }
#line 620
    if (! (tmp > 0)) {
#line 620
      goto while_break;
    }
    {
#line 622
    XNextEvent(display___0, & event);
#line 623
    DoEvent(& event);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 629
  if (milliSeconds <= 0) {
#line 630
    return (isRedrawNeeded);
  }
#line 635
  fd = ((_XPrivDisplay )display___0)->fd;
  {
#line 637
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 637
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& readFds.__fds_bits[0]): "memory");
#line 637
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 638
  readFds.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
#line 640
  timeOut.tv_sec = (__time_t )(milliSeconds / 1000);
#line 641
  timeOut.tv_usec = (__suseconds_t )((milliSeconds % 1000) * 1000);
#line 643
  select(fd + 1, (fd_set */* __restrict  */)(& readFds), (fd_set */* __restrict  */)((void *)0),
         (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& timeOut));
  }
  {
#line 648
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 648
    tmp___0 = XEventsQueued(display___0, 2);
    }
#line 648
    if (! (tmp___0 > 0)) {
#line 648
      goto while_break___1;
    }
    {
#line 650
    XNextEvent(display___0, & event);
#line 651
    DoEvent(& event);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 657
  return (isRedrawNeeded);
}
}
#line 665 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static BOOL X11InputReady(DISPLAY *ipsDisplay ) 
{ 
  XEvent event ;
  int tmp ;

  {
#line 670
  if (inputCount > 0) {
#line 671
    return (1);
  }
  {
#line 673
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 675
    tmp = XEventsQueued(display___0, 2);
    }
#line 675
    if (tmp <= 0) {
#line 676
      return (0);
    }
    {
#line 678
    XPeekEvent(display___0, & event);
    }
#line 680
    if (event.type == 2) {
#line 681
      return (1);
    }
    {
#line 683
    XNextEvent(display___0, & event);
#line 685
    DoEvent(& event);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 688
  return (0);
}
}
#line 696 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static int X11ReadChar(DISPLAY *ipsDisplay ) 
{ 
  XEvent event ;
  int ch ;
  int tmp ;

  {
  {
#line 706
  while (1) {
    while_continue: /* CIL Label */ ;
#line 706
    if (! (inputCount == 0)) {
      {
#line 706
      tmp = XEventsQueued(display___0, 2);
      }
#line 706
      if (! (tmp > 0)) {
#line 706
        goto while_break;
      }
    }
    {
#line 709
    XNextEvent(display___0, & event);
#line 711
    DoEvent(& event);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 717
  ch = (int )inputBuffer[0];
#line 718
  inputCount --;
#line 720
  if (inputCount > 0) {
    {
#line 721
    memmove((void *)(inputBuffer), (void const   *)(inputBuffer + 1), (size_t )inputCount);
    }
  }
#line 723
  return (ch);
}
}
#line 727 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static int X11GetRows(DISPLAY *ipsDisplay ) 
{ 


  {
#line 730
  return (rows___0);
}
}
#line 734 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static int X11GetCols(DISPLAY *ipsDisplay ) 
{ 


  {
#line 737
  return (cols___0);
}
}
#line 741 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static void X11RingBell(DISPLAY *ipsDisplay ) 
{ 


  {
  {
#line 744
  XBell(display___0, 0);
#line 745
  XFlush(display___0);
  }
#line 746
  return;
}
}
#line 749 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static BOOL X11DoesScroll(DISPLAY *ipsDisplay ) 
{ 


  {
#line 752
  return (0);
}
}
#line 759 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static void DoEvent(XEvent *event ) 
{ 


  {
  {
#line 764
  if (event->type == 12) {
#line 764
    goto case_12;
  }
#line 770
  if (event->type == 19) {
#line 770
    goto case_19;
  }
#line 775
  if (event->type == 18) {
#line 775
    goto case_18;
  }
#line 780
  if (event->type == 2) {
#line 780
    goto case_2;
  }
#line 785
  if (event->type == 22) {
#line 785
    goto case_22;
  }
#line 762
  goto switch_break;
  case_12: /* CIL Label */ 
#line 765
  isMapped = 1;
#line 766
  isRedrawNeeded = 1;
#line 768
  goto switch_break;
  case_19: /* CIL Label */ 
#line 771
  isMapped = 1;
#line 773
  goto switch_break;
  case_18: /* CIL Label */ 
#line 776
  isMapped = 0;
#line 778
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 781
  DoKeyPress(& event->xkey);
  }
#line 783
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 786
  DoConfigure(& event->xconfigure);
  }
#line 788
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 790
  return;
}
}
#line 798 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static void DoKeyPress(XKeyEvent *kp ) 
{ 
  KeySym keySym ;
  int len ;
  char buf___3[12] ;
  int tmp ;

  {
  {
#line 808
  len = XLookupString(kp, buf___3, (int )sizeof(buf___3), & keySym, (XComposeStatus *)((void *)0));
  }
#line 813
  if (len != 1) {
#line 814
    return;
  } else
#line 813
  if (keySym >= 65505UL) {
#line 813
    if (keySym <= 65518UL) {
#line 814
      return;
    } else {
#line 813
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 813
  if (keySym >= 65025UL) {
#line 813
    if (keySym <= 65043UL) {
#line 814
      return;
    } else {
#line 813
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 813
  if (keySym == 65406UL) {
#line 814
    return;
  } else
#line 813
  if (keySym == 65407UL) {
#line 814
    return;
  }
#line 819
  if ((unsigned long )inputCount < sizeof(inputBuffer)) {
#line 820
    tmp = inputCount;
#line 820
    inputCount ++;
#line 820
    inputBuffer[tmp] = buf___3[0];
  } else {
    {
#line 822
    XBell(display___0, 0);
    }
  }
#line 823
  return;
}
}
#line 831 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static void DoConfigure(XConfigureEvent *cp ) 
{ 
  int newRows ;
  int newCols ;

  {
#line 837
  mainHeight = cp->height;
#line 838
  mainWidth = cp->width;
#line 840
  newRows = (mainHeight - 8) / charHeight;
#line 841
  newCols = (mainWidth - 8) / charWidth;
#line 843
  if (newRows > 500) {
#line 844
    newRows = 500;
  }
#line 846
  if (newCols > 2000) {
#line 847
    newCols = 2000;
  }
#line 849
  if (rows___0 != newRows) {
#line 851
    rows___0 = newRows;
#line 852
    cols___0 = newCols;
#line 853
    isRedrawNeeded = 1;
  } else
#line 849
  if (cols___0 != newCols) {
#line 851
    rows___0 = newRows;
#line 852
    cols___0 = newCols;
#line 853
    isRedrawNeeded = 1;
  }
#line 855
  return;
}
}
#line 863 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static void StoreCharacter(int row , int col , int ch ) 
{ 
  LINE *line ;
  CELL cell ;

  {
#line 873
  if (row < 0) {
#line 874
    return;
  } else
#line 873
  if (row >= rows___0) {
#line 874
    return;
  } else
#line 873
  if (col < 0) {
#line 874
    return;
  } else
#line 873
  if (col >= cols___0) {
#line 874
    return;
  }
  {
#line 879
  line = GetLine(row);
#line 884
  cell = (CELL )((ch << 8) | currentColorId___0);
  }
#line 889
  if (col >= line->usedCount) {
#line 891
    line->usedCount = col + 1;
#line 893
    if (line->endUpdate == 0) {
#line 894
      line->beginUpdate = col;
    }
#line 896
    line->endUpdate = col + 1;
#line 897
    line->data[col] = cell;
#line 899
    return;
  }
#line 905
  if ((int )line->data[col] != (int )cell) {
#line 907
    if (line->endUpdate == 0) {
#line 908
      line->beginUpdate = col;
    }
#line 910
    if (col >= line->endUpdate) {
#line 911
      line->endUpdate = col + 1;
    }
#line 913
    line->data[col] = cell;
  }
#line 915
  return;
}
}
#line 923 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static void StoreEndOfLine(int row , int col ) 
{ 
  LINE *line ;
  int tmp ;

  {
#line 932
  if (row < 0) {
#line 933
    return;
  } else
#line 932
  if (row >= rows___0) {
#line 933
    return;
  } else
#line 932
  if (col < 0) {
#line 933
    return;
  } else
#line 932
  if (col >= cols___0) {
#line 933
    return;
  }
  {
#line 938
  while (1) {
    while_continue: /* CIL Label */ ;
#line 938
    if (! (col < cols___0)) {
#line 938
      goto while_break;
    }
    {
#line 939
    tmp = col;
#line 939
    col ++;
#line 939
    StoreCharacter(row, tmp, ' ');
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 944
  line = GetLine(row);
  }
#line 957
  return;
}
}
#line 963 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static void UpdateWindow(void) 
{ 
  int row ;

  {
#line 968
  row = 0;
  {
#line 968
  while (1) {
    while_continue: /* CIL Label */ ;
#line 968
    if (! (row < rows___0)) {
#line 968
      goto while_break;
    }
    {
#line 969
    UpdateRow(row);
#line 968
    row ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 970
  return;
}
}
#line 976 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static void UpdateRow(int row ) 
{ 
  LINE *line ;
  CELL const   *cell ;
  int drawCount ;
  int textX ;
  int textY ;
  int clearX ;
  int clearY ;
  int colorId ;
  int runCount ;
  char buffer[512] ;

  {
  {
#line 990
  line = GetLine(row);
#line 995
  drawCount = line->endUpdate - line->beginUpdate;
#line 1000
  textX = 4 + charWidth * line->beginUpdate;
#line 1001
  textY = (4 + charAscent) + charHeight * row;
#line 1002
  cell = (CELL const   *)(& line->data[line->beginUpdate]);
  }
  {
#line 1007
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1007
    if (! (drawCount > 0)) {
#line 1007
      goto while_break;
    }
    {
#line 1013
    colorId = (int )((int const   )*cell & 255);
#line 1015
    SetColor(colorId);
#line 1022
    runCount = 0;
    }
    {
#line 1024
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1024
      if (runCount < drawCount) {
#line 1024
        if ((unsigned long )runCount < sizeof(buffer)) {
#line 1024
          if (! (((int const   )*cell & 255) == (int const   )colorId)) {
#line 1024
            goto while_break___0;
          }
        } else {
#line 1024
          goto while_break___0;
        }
      } else {
#line 1024
        goto while_break___0;
      }
#line 1027
      buffer[runCount] = (char )((int const   )*cell >> 8);
#line 1028
      cell ++;
#line 1029
      runCount ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1035
    DrawText(textX, textY, (char const   *)(buffer), runCount);
#line 1040
    textX += charWidth * runCount;
#line 1041
    drawCount -= runCount;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1047
  if (line->clearCount > 0) {
    {
#line 1049
    clearX = 4 + charWidth * line->usedCount;
#line 1050
    clearY = 4 + charHeight * row;
#line 1052
    XClearArea(display___0, mainWid, clearX, clearY, (unsigned int )(charWidth * line->clearCount),
               (unsigned int )charHeight, 0);
    }
  }
#line 1059
  line->beginUpdate = 0;
#line 1060
  line->endUpdate = 0;
#line 1061
  line->clearCount = 0;
#line 1062
  return;
}
}
#line 1068 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static void DrawText(int textX , int textY , char const   *buffer , int count ) 
{ 


  {
#line 1074
  if (currentBackgroundPixel == background) {
    {
#line 1076
    XClearArea(display___0, mainWid, textX, textY - charAscent, (unsigned int )(charWidth * count),
               (unsigned int )charHeight, 0);
    }
  } else {
    {
#line 1081
    XFillRectangle(display___0, mainWid, clearGC, textX, textY - charAscent, (unsigned int )(charWidth * count),
                   (unsigned int )charHeight);
    }
  }
  {
#line 1088
  XDrawString(display___0, mainWid, textGC, textX, textY, buffer, count);
  }
#line 1094
  if (currentColorFlags___0 & 1) {
    {
#line 1096
    XDrawString(display___0, mainWid, textGC, textX + 1, textY, buffer, count);
    }
  }
#line 1102
  if (currentColorFlags___0 & 2) {
    {
#line 1104
    XDrawLine(display___0, mainWid, textGC, textX, textY, (textX + charWidth * count) - 1,
              textY);
    }
  }
#line 1107
  return;
}
}
#line 1113 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static void SetColor(int colorId ) 
{ 
  long foregroundPixel ;
  long backgroundPixel ;

  {
#line 1123
  if (colorId < 0) {
#line 1124
    colorId = 0;
  } else
#line 1123
  if (colorId >= 20) {
#line 1124
    colorId = 0;
  }
#line 1126
  foregroundPixel = foregroundColorTable___0[colorId];
#line 1127
  backgroundPixel = backgroundColorTable___0[colorId];
#line 1133
  if (foregroundPixel != currentForegroundPixel) {
    {
#line 1134
    XSetForeground(display___0, textGC, (unsigned long )foregroundPixel);
    }
  }
#line 1136
  if (backgroundPixel != currentBackgroundPixel) {
    {
#line 1138
    XSetBackground(display___0, textGC, (unsigned long )backgroundPixel);
#line 1139
    XSetForeground(display___0, clearGC, (unsigned long )backgroundPixel);
    }
  }
#line 1145
  currentForegroundPixel = foregroundPixel;
#line 1146
  currentBackgroundPixel = backgroundPixel;
#line 1147
  currentColorFlags___0 = colorFlagsTable[colorId];
#line 1148
  return;
}
}
#line 1156 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static void ClearWindow(void) 
{ 
  LINE *line ;
  int row ;

  {
#line 1165
  row = 0;
  {
#line 1165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1165
    if (! (row < rows___0)) {
#line 1165
      goto while_break;
    }
    {
#line 1167
    line = GetLine(row);
#line 1169
    line->beginUpdate = 0;
#line 1170
    line->endUpdate = 0;
#line 1171
    line->usedCount = 0;
#line 1172
    line->clearCount = 0;
#line 1165
    row ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1178
  XClearWindow(display___0, mainWid);
#line 1183
  isRedrawNeeded = 0;
  }
#line 1184
  return;
}
}
#line 1192 "/home/june/repo/benchmarks/collector/temp/ips-4.0/x11display.c"
static LINE *GetLine(int row ) 
{ 
  LINE *line ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1200
  if (row < 0) {
    {
#line 1202
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Illegal row number\n");
#line 1204
    exit(1);
    }
  } else
#line 1200
  if (row >= rows___0) {
    {
#line 1202
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Illegal row number\n");
#line 1204
    exit(1);
    }
  }
#line 1210
  line = lines[row];
#line 1216
  if ((unsigned long )line == (unsigned long )((void *)0)) {
    {
#line 1218
    tmp = AllocMemory((int )(sizeof(LINE ) + (unsigned long )cols___0 * sizeof(CELL )));
#line 1218
    line = (LINE *)tmp;
#line 1220
    lines[row] = line;
#line 1222
    line->beginUpdate = 0;
#line 1223
    line->endUpdate = 0;
#line 1224
    line->clearCount = 0;
#line 1225
    line->usedCount = 0;
#line 1226
    line->alloc = cols___0;
    }
#line 1228
    return (line);
  }
#line 1235
  if (line->alloc >= cols___0) {
#line 1236
    return (line);
  }
  {
#line 1244
  tmp___0 = ReallocMemory((void *)line, (int )(sizeof(LINE ) + (unsigned long )(cols___0 + 20) * sizeof(CELL )));
#line 1244
  line = (LINE *)tmp___0;
#line 1247
  lines[row] = line;
#line 1249
  line->alloc = cols___0 + 20;
  }
#line 1251
  return (line);
}
}
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 214
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) seekdir)(DIR *__dirp ,
                                                                                               long __pos ) ;
#line 846 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 619
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 809
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2), __leaf__)) readlink)(char const   * __restrict  __path ,
                                                                                                     char * __restrict  __buf ,
                                                                                                     size_t __len ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 542 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
ULONG GetUptime(void) ;
#line 548
long GetDecimalNumber(char const   **cpp ) ;
#line 555
void SortProcesses(void) ;
#line 570
BOOL IsShownProcess(PROC const   *proc ) ;
#line 575
void CollectUserNames(void) ;
#line 576
void CollectGroupNames(void) ;
#line 577
void CollectDeviceNames(void) ;
#line 578
void CollectStaticSystemInfo(void) ;
#line 579
void CollectDynamicSystemInfo(void) ;
#line 597
void MakePrintable(char *cp , int len ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/ips-4.0/linux.c"
static DIR *procDir  ;
#line 38
static void ExamineProcessId(pid_t pid , pthread_t tid ) ;
#line 39
static void GetProcessCommandLine(PROC *proc ) ;
#line 40
static void GetProcessEnvironment(PROC *proc ) ;
#line 41
static void GetProcessOpenFileCount(PROC *proc ) ;
#line 42
static void GetProcessCurrentDirectory(PROC *proc ) ;
#line 43
static void GetProcessRootDirectory(PROC *proc ) ;
#line 44
static void GetProcessExecInode(PROC *proc ) ;
#line 45
static void GetProcessStdioDescriptors(PROC *proc ) ;
#line 46
static void GetProcessWaitSymbol(PROC *proc ) ;
#line 47
static void ScanThreads(PROC *proc ) ;
#line 48
static BOOL IsCopyAllowed(PROC const   *proc ) ;
#line 50
static BOOL ReadLinkPath(char const   *name , char **retpath , int *retpathlength ) ;
#line 58 "/home/june/repo/benchmarks/collector/temp/ips-4.0/linux.c"
BOOL InitializeProcessData(void) 
{ 


  {
  {
#line 61
  CollectStaticSystemInfo();
  }
#line 63
  if (useUserNames) {
    {
#line 64
    CollectUserNames();
    }
  }
#line 66
  if (useGroupNames) {
    {
#line 67
    CollectGroupNames();
    }
  }
#line 69
  if (useDeviceNames) {
    {
#line 70
    CollectDeviceNames();
    }
  }
  {
#line 75
  procDir = opendir("/proc");
  }
#line 77
  if ((unsigned long )procDir == (unsigned long )((void *)0)) {
    {
#line 79
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open %s\n",
            "/proc");
    }
#line 81
    return (0);
  }
#line 84
  ancientFlag = 1;
#line 86
  return (1);
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/ips-4.0/linux.c"
void CollectStaticSystemInfo(void) 
{ 
  char const   *cp ;
  int fd ;
  int cc ;
  char buf___3[256] ;
  ssize_t tmp ;
  char *tmp___0 ;
  long tmp___1 ;

  {
  {
#line 105
  ticksPerSecond = sysconf(2);
  }
#line 107
  if (ticksPerSecond <= 0L) {
#line 108
    ticksPerSecond = 100L;
  }
  {
#line 113
  pageSize = sysconf(30);
  }
#line 115
  if (pageSize <= 0L) {
#line 116
    pageSize = 4096L;
  }
  {
#line 121
  fd = open("/proc/meminfo", 0);
  }
#line 123
  if (fd < 0) {
#line 124
    return;
  }
  {
#line 126
  tmp = read(fd, (void *)(buf___3), sizeof(buf___3) - 1UL);
#line 126
  cc = (int )tmp;
#line 128
  close(fd);
  }
#line 130
  if (cc <= 0) {
#line 131
    return;
  }
  {
#line 133
  buf___3[cc] = (char )'\000';
#line 135
  tmp___0 = strstr((char const   *)(buf___3), "MemTotal:");
#line 135
  cp = (char const   *)tmp___0;
  }
#line 137
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 138
    return;
  }
  {
#line 140
  cp += 9;
#line 142
  tmp___1 = GetDecimalNumber(& cp);
#line 142
  totalMemoryClicks = tmp___1 / (pageSize / 1024L);
#line 148
  startUptime = GetUptime();
#line 149
  startTime = time((time_t *)((void *)0));
  }
#line 150
  return;
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/ips-4.0/linux.c"
void CollectDynamicSystemInfo(void) 
{ 
  struct dirent  const  *dp ;
  char const   *cp ;
  int fd ;
  int cc ;
  char buf___3[256] ;
  ssize_t tmp ;
  char *tmp___0 ;
  long tmp___1 ;
  struct dirent *tmp___2 ;

  {
  {
#line 171
  fd = open("/proc/loadavg", 0);
  }
#line 173
  if (fd < 0) {
#line 174
    return;
  }
  {
#line 176
  tmp = read(fd, (void *)(buf___3), sizeof(buf___3) - 1UL);
#line 176
  cc = (int )tmp;
#line 178
  close(fd);
  }
#line 180
  if (cc <= 0) {
#line 181
    return;
  }
  {
#line 183
  buf___3[cc] = (char )'\000';
#line 188
  tmp___0 = strchr((char const   *)(buf___3), '/');
#line 188
  cp = (char const   *)tmp___0;
  }
#line 190
  if ((unsigned long )cp == (unsigned long )((char const   *)0)) {
#line 191
    return;
  }
  {
#line 193
  cp ++;
#line 195
  tmp___1 = GetDecimalNumber(& cp);
#line 195
  threadTotalCount = (int )tmp___1;
#line 201
  procTotalCount = 0;
#line 203
  seekdir(procDir, 0L);
  }
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 205
    tmp___2 = readdir(procDir);
#line 205
    dp = (struct dirent  const  *)tmp___2;
    }
#line 205
    if (! ((unsigned long )dp != (unsigned long )((void *)0))) {
#line 205
      goto while_break;
    }
#line 207
    cp = (char const   *)(dp->d_name);
    {
#line 209
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 209
      if ((int const   )*cp >= 48) {
#line 209
        if (! ((int const   )*cp <= 57)) {
#line 209
          goto while_break___0;
        }
      } else {
#line 209
        goto while_break___0;
      }
#line 210
      cp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 212
    if ((int const   )*cp == 0) {
#line 213
      procTotalCount ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  return;
}
}
#line 223 "/home/june/repo/benchmarks/collector/temp/ips-4.0/linux.c"
ULONG GetUptime(void) 
{ 
  char const   *cp ;
  int fd ;
  int cc ;
  ULONG intVal ;
  ULONG fracVal ;
  ULONG fracScale ;
  char buf___3[128] ;
  ssize_t tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 234
  fd = open("/proc/uptime", 0);
  }
#line 236
  if (fd < 0) {
#line 237
    return ((ULONG )0);
  }
  {
#line 239
  tmp = read(fd, (void *)(buf___3), sizeof(buf___3) - 1UL);
#line 239
  cc = (int )tmp;
#line 241
  close(fd);
  }
#line 243
  if (cc <= 0) {
#line 244
    return ((ULONG )0);
  }
#line 246
  buf___3[cc] = (char )'\000';
#line 248
  cp = (char const   *)(buf___3);
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if (! ((int const   )*cp == 32)) {
#line 250
      if (! ((int const   )*cp == 9)) {
#line 250
        goto while_break;
      }
    }
#line 251
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  intVal = (ULONG )0;
#line 254
  fracVal = (ULONG )0;
#line 255
  fracScale = (ULONG )1;
  {
#line 257
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 257
    if ((int const   )*cp >= 48) {
#line 257
      if (! ((int const   )*cp <= 57)) {
#line 257
        goto while_break___0;
      }
    } else {
#line 257
      goto while_break___0;
    }
#line 258
    tmp___0 = cp;
#line 258
    cp ++;
#line 258
    intVal = (intVal * 10UL + (ULONG )*tmp___0) - 48UL;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 260
  if ((int const   )*cp == 46) {
#line 261
    cp ++;
  }
  {
#line 263
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 263
    if ((int const   )*cp >= 48) {
#line 263
      if (! ((int const   )*cp <= 57)) {
#line 263
        goto while_break___1;
      }
    } else {
#line 263
      goto while_break___1;
    }
#line 265
    tmp___1 = cp;
#line 265
    cp ++;
#line 265
    fracVal = (fracVal * 10UL + (ULONG )*tmp___1) - 48UL;
#line 266
    fracScale *= 10UL;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 269
  if ((int const   )*cp != 32) {
#line 269
    if ((int const   )*cp != 10) {
#line 270
      return ((ULONG )0);
    }
  }
#line 272
  return (intVal * (ULONG )ticksPerSecond + (fracVal * (ULONG )ticksPerSecond) / fracScale);
}
}
#line 279 "/home/june/repo/benchmarks/collector/temp/ips-4.0/linux.c"
void ScanProcesses(void) 
{ 
  struct dirent  const  *dp ;
  char const   *name ;
  pid_t pid ;
  int i ;
  char const   *tmp ;
  struct dirent *tmp___0 ;

  {
  {
#line 287
  UpdateTimes();
#line 289
  CollectDynamicSystemInfo();
  }
#line 294
  if (useSelf) {
    {
#line 295
    ExamineProcessId(myPid, (pthread_t )-1);
    }
  }
#line 302
  if (pidCount == 0) {
    {
#line 304
    seekdir(procDir, 0L);
    }
    {
#line 306
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 306
      tmp___0 = readdir(procDir);
#line 306
      dp = (struct dirent  const  *)tmp___0;
      }
#line 306
      if (! ((unsigned long )dp != (unsigned long )((void *)0))) {
#line 306
        goto while_break;
      }
#line 308
      name = (char const   *)(dp->d_name);
#line 310
      pid = 0;
      {
#line 312
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 312
        if ((int const   )*name >= 48) {
#line 312
          if (! ((int const   )*name <= 57)) {
#line 312
            goto while_break___0;
          }
        } else {
#line 312
          goto while_break___0;
        }
#line 313
        tmp = name;
#line 313
        name ++;
#line 313
        pid = (pid * 10 + (pid_t )*tmp) - 48;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 315
      if (*name) {
#line 316
        goto while_continue;
      }
#line 318
      if (pid != myPid) {
        {
#line 319
        ExamineProcessId(pid, (pthread_t )-1);
        }
      } else
#line 318
      if (! useSelf) {
        {
#line 319
        ExamineProcessId(pid, (pthread_t )-1);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 324
    i = 0;
    {
#line 324
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 324
      if (! (i < pidCount)) {
#line 324
        goto while_break___1;
      }
#line 326
      if (pidList[i] != myPid) {
        {
#line 327
        ExamineProcessId(pidList[i], (pthread_t )-1);
        }
      } else
#line 326
      if (! useSelf) {
        {
#line 327
        ExamineProcessId(pidList[i], (pthread_t )-1);
        }
      }
#line 324
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 331
  RemoveDeadProcesses();
#line 333
  SortProcesses();
#line 335
  UpdateProcessCounts();
#line 337
  ancientFlag = 0;
  }
#line 338
  return;
}
}
#line 348 "/home/june/repo/benchmarks/collector/temp/ips-4.0/linux.c"
static void ExamineProcessId(pid_t pid , pthread_t tid ) 
{ 
  PROC *proc ;
  int fd ;
  int cc ;
  int i ;
  char *begName ;
  char *endName ;
  char const   *cp ;
  long ticksFromStart ;
  long secondsFromStart ;
  BOOL okSkip ;
  struct stat statBuf ;
  char buf___3[512] ;
  char name[80] ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  long tmp___14 ;
  long tmp___15 ;
  long tmp___16 ;
  long tmp___17 ;
  long tmp___18 ;
  long tmp___19 ;
  long tmp___20 ;
  long tmp___21 ;
  long tmp___22 ;
  long tmp___23 ;
  long tmp___24 ;
  long tmp___25 ;
  long tmp___26 ;
  long tmp___27 ;
  long tmp___28 ;
  BOOL tmp___29 ;

  {
  {
#line 365
  proc = FindProcess(pid, tid);
#line 367
  proc->isValid = 0;
#line 368
  proc->isShown = 0;
  }
#line 370
  if (pid != myPid) {
#line 370
    tmp = 1;
  } else
#line 370
  if (! useSelf) {
#line 370
    tmp = 1;
  } else {
#line 370
    tmp = 0;
  }
#line 370
  okSkip = tmp;
#line 372
  if (okSkip) {
#line 372
    if (noSelf) {
#line 372
      if (pid == myPid) {
#line 373
        return;
      }
    }
  }
#line 375
  if (proc->isThread) {
    {
#line 376
    sprintf((char */* __restrict  */)(name), (char const   */* __restrict  */)"%s/%ld/task/%ld/stat",
            "/proc", (long )pid, (long )tid);
    }
  } else {
    {
#line 378
    sprintf((char */* __restrict  */)(name), (char const   */* __restrict  */)"%s/%ld/stat",
            "/proc", (long )pid);
    }
  }
  {
#line 380
  fd = open((char const   *)(name), 0);
  }
#line 382
  if (fd < 0) {
    {
#line 384
    tmp___0 = __errno_location();
    }
#line 384
    if (*tmp___0 != 2) {
      {
#line 385
      perror((char const   *)(name));
      }
    }
#line 387
    return;
  }
  {
#line 390
  tmp___1 = fstat(fd, & statBuf);
  }
#line 390
  if (tmp___1 < 0) {
    {
#line 392
    close(fd);
    }
#line 394
    return;
  }
#line 397
  proc->deathTime = (time_t )0;
#line 399
  if (okSkip) {
#line 401
    if (myProcs) {
#line 401
      if (statBuf.st_uid != myUid) {
        {
#line 403
        close(fd);
        }
#line 405
        return;
      }
    }
#line 408
    if (noRoot) {
#line 408
      if (statBuf.st_uid == 0U) {
#line 409
        return;
      }
    }
#line 411
    if (userCount > 0) {
#line 413
      i = 0;
      {
#line 413
      while (1) {
        while_continue: /* CIL Label */ ;
#line 413
        if (! (i < userCount)) {
#line 413
          goto while_break;
        }
#line 415
        if (statBuf.st_uid == userList[i]) {
#line 416
          goto while_break;
        }
#line 413
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 419
      if (i == userCount) {
        {
#line 421
        close(fd);
        }
#line 423
        return;
      }
    }
#line 427
    if (groupCount > 0) {
#line 429
      i = 0;
      {
#line 429
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 429
        if (! (i < groupCount)) {
#line 429
          goto while_break___0;
        }
#line 431
        if (statBuf.st_gid == groupList[i]) {
#line 432
          goto while_break___0;
        }
#line 429
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 435
      if (i == groupCount) {
        {
#line 437
        close(fd);
        }
#line 439
        return;
      }
    }
  }
  {
#line 444
  proc->uid = statBuf.st_uid;
#line 445
  proc->gid = statBuf.st_gid;
#line 450
  tmp___2 = read(fd, (void *)(buf___3), sizeof(buf___3));
#line 450
  cc = (int )tmp___2;
  }
#line 452
  if (cc < 0) {
    {
#line 454
    close(fd);
    }
#line 456
    return;
  }
  {
#line 459
  close(fd);
  }
#line 461
  if ((unsigned long )cc == sizeof(buf___3)) {
    {
#line 463
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"status buffer overflow");
    }
#line 465
    return;
  }
  {
#line 468
  buf___3[cc] = (char )'\000';
#line 474
  begName = strchr((char const   *)(buf___3), '(');
  }
#line 476
  if ((unsigned long )begName == (unsigned long )((void *)0)) {
    {
#line 478
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot find start of program name\n");
    }
#line 480
    return;
  }
  {
#line 483
  tmp___3 = begName;
#line 483
  begName ++;
#line 483
  *tmp___3 = (char )'\000';
#line 490
  endName = strchr((char const   *)begName, ')');
  }
#line 492
  if ((unsigned long )endName == (unsigned long )((void *)0)) {
    {
#line 494
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot find end of program name\n");
    }
#line 496
    return;
  }
  {
#line 499
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 499
    tmp___4 = strchr((char const   *)(endName + 1), ')');
#line 499
    cp = (char const   *)tmp___4;
    }
#line 499
    if (! ((unsigned long )cp != (unsigned long )((void *)0))) {
#line 499
      goto while_break___1;
    }
#line 500
    endName = begName + (cp - (char const   *)begName);
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 502
  MakePrintable(begName, (int )(endName - begName));
#line 504
  tmp___5 = endName;
#line 504
  endName ++;
#line 504
  *tmp___5 = (char )'\000';
#line 506
  strncpy((char */* __restrict  */)(proc->program), (char const   */* __restrict  */)begName,
          (size_t )32);
#line 508
  proc->program[32] = (char )'\000';
#line 514
  cp = (char const   *)endName;
  }
  {
#line 516
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 516
    if (! ((int const   )*cp == 32)) {
#line 516
      if (! ((int const   )*cp == 9)) {
#line 516
        goto while_break___2;
      }
    }
#line 517
    cp ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 519
  if ((int const   )*cp == 0) {
    {
#line 521
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad proc state character\n");
    }
#line 523
    return;
  } else
#line 519
  if ((int const   )*cp == 10) {
    {
#line 521
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad proc state character\n");
    }
#line 523
    return;
  } else
#line 519
  if ((int const   )*cp >= 48) {
#line 519
    if ((int const   )*cp <= 57) {
      {
#line 521
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad proc state character\n");
      }
#line 523
      return;
    }
  }
  {
#line 526
  tmp___6 = cp;
#line 526
  cp ++;
#line 526
  proc->state = (int )*tmp___6;
#line 527
  proc->states[0] = (char )proc->state;
#line 528
  proc->states[1] = (char )'\000';
#line 529
  tmp___7 = GetDecimalNumber(& cp);
#line 529
  proc->parentPid = (pid_t )tmp___7;
#line 530
  tmp___8 = GetDecimalNumber(& cp);
#line 530
  proc->processGroup = (pid_t )tmp___8;
#line 531
  tmp___9 = GetDecimalNumber(& cp);
#line 531
  proc->sessionId = (pid_t )tmp___9;
#line 532
  tmp___10 = GetDecimalNumber(& cp);
#line 532
  proc->ttyDevice = (dev_t )tmp___10;
#line 533
  tmp___11 = GetDecimalNumber(& cp);
#line 533
  proc->ttyProcessGroup = (pid_t )tmp___11;
#line 534
  tmp___12 = GetDecimalNumber(& cp);
#line 534
  proc->flags = (ULONG )tmp___12;
#line 535
  proc->minorFaults = GetDecimalNumber(& cp);
#line 536
  proc->childMinorFaults = GetDecimalNumber(& cp);
#line 537
  proc->majorFaults = GetDecimalNumber(& cp);
#line 538
  proc->childMajorFaults = GetDecimalNumber(& cp);
#line 539
  proc->userRunTime = GetDecimalNumber(& cp);
#line 540
  proc->systemRunTime = GetDecimalNumber(& cp);
#line 541
  proc->childUserRunTime = GetDecimalNumber(& cp);
#line 542
  proc->childSystemRunTime = GetDecimalNumber(& cp);
#line 543
  proc->priority = GetDecimalNumber(& cp);
#line 544
  proc->nice = GetDecimalNumber(& cp);
#line 545
  tmp___13 = GetDecimalNumber(& cp);
#line 545
  proc->threadCount = (int )tmp___13;
#line 546
  proc->itRealValue = GetDecimalNumber(& cp);
#line 547
  tmp___14 = GetDecimalNumber(& cp);
#line 547
  proc->startTimeTicks = (ULONG )tmp___14;
#line 548
  proc->virtualSize = GetDecimalNumber(& cp);
#line 549
  proc->rss = GetDecimalNumber(& cp);
#line 550
  proc->rssLimit = GetDecimalNumber(& cp);
#line 551
  tmp___15 = GetDecimalNumber(& cp);
#line 551
  proc->startCode = (ULONG )tmp___15;
#line 552
  tmp___16 = GetDecimalNumber(& cp);
#line 552
  proc->endCode = (ULONG )tmp___16;
#line 553
  tmp___17 = GetDecimalNumber(& cp);
#line 553
  proc->startStack = (ULONG )tmp___17;
#line 554
  tmp___18 = GetDecimalNumber(& cp);
#line 554
  proc->esp = (ULONG )tmp___18;
#line 555
  tmp___19 = GetDecimalNumber(& cp);
#line 555
  proc->eip = (ULONG )tmp___19;
#line 556
  tmp___20 = GetDecimalNumber(& cp);
#line 556
  proc->signal = (ULONG )tmp___20;
#line 557
  tmp___21 = GetDecimalNumber(& cp);
#line 557
  proc->sigBlock = (ULONG )tmp___21;
#line 558
  tmp___22 = GetDecimalNumber(& cp);
#line 558
  proc->sigIgnore = (ULONG )tmp___22;
#line 559
  tmp___23 = GetDecimalNumber(& cp);
#line 559
  proc->sigCatch = (ULONG )tmp___23;
#line 560
  tmp___24 = GetDecimalNumber(& cp);
#line 560
  proc->waitChan = (ULONG )tmp___24;
#line 561
  tmp___25 = GetDecimalNumber(& cp);
#line 561
  proc->pagesSwapped = (ULONG )tmp___25;
#line 562
  tmp___26 = GetDecimalNumber(& cp);
#line 562
  proc->childPagesSwapped = (ULONG )tmp___26;
#line 563
  tmp___27 = GetDecimalNumber(& cp);
#line 563
  proc->exitSignal = (int )tmp___27;
#line 564
  tmp___28 = GetDecimalNumber(& cp);
#line 564
  proc->processor = (int )tmp___28;
#line 565
  proc->realTimePriority = GetDecimalNumber(& cp);
#line 566
  proc->policy = GetDecimalNumber(& cp);
#line 575
  ticksFromStart = (long )(proc->startTimeTicks - startUptime);
  }
#line 577
  if (ticksFromStart >= 0L) {
#line 578
    secondsFromStart = ticksFromStart / ticksPerSecond;
  } else {
#line 580
    secondsFromStart = - (- ticksFromStart / ticksPerSecond);
  }
#line 586
  proc->startTimeClock = startTime + secondsFromStart;
#line 592
  if (proc->isNew) {
#line 593
    proc->firstCpuTime = (ULONG )(proc->userRunTime + proc->systemRunTime);
  }
  {
#line 598
  CheckActiveProcess(proc);
  }
#line 606
  if (proc->isChanged) {
#line 606
    goto _L;
  } else
#line 606
  if (proc->lastSyncTime + (time_t )syncTime <= currentTime) {
    _L: /* CIL Label */ 
    {
#line 609
    proc->lastSyncTime = currentTime;
#line 611
    GetProcessOpenFileCount(proc);
#line 612
    GetProcessStdioDescriptors(proc);
#line 613
    GetProcessCurrentDirectory(proc);
#line 614
    GetProcessRootDirectory(proc);
#line 615
    GetProcessExecInode(proc);
#line 616
    GetProcessCommandLine(proc);
#line 617
    GetProcessEnvironment(proc);
#line 618
    GetProcessWaitSymbol(proc);
    }
  }
  {
#line 621
  proc->liveCounter = liveCounter;
#line 622
  proc->isValid = 1;
#line 624
  tmp___29 = IsShownProcess((PROC const   *)proc);
  }
#line 624
  if (tmp___29) {
#line 625
    proc->isShown = 1;
  }
#line 631
  if (showThreads) {
    {
#line 632
    ScanThreads(proc);
    }
  } else
#line 631
  if (useThreads) {
    {
#line 632
    ScanThreads(proc);
    }
  }
  {
#line 637
  BuildStates(proc);
  }
#line 638
  return;
}
}
#line 644 "/home/june/repo/benchmarks/collector/temp/ips-4.0/linux.c"
static void ScanThreads(PROC *proc ) 
{ 
  DIR *dir ;
  struct dirent  const  *dp ;
  char const   *cp ;
  pthread_t tid ;
  char name[80] ;
  char const   *tmp ;
  struct dirent *tmp___0 ;

  {
#line 657
  if (proc->isThread) {
#line 658
    return;
  } else
#line 657
  if (proc->threadCount <= 1) {
#line 658
    return;
  }
  {
#line 664
  sprintf((char */* __restrict  */)(name), (char const   */* __restrict  */)"%s/%ld/task",
          "/proc", (long )proc->pid);
#line 666
  dir = opendir((char const   *)(name));
  }
#line 668
  if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 669
    return;
  }
  {
#line 671
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 671
    tmp___0 = readdir(dir);
#line 671
    dp = (struct dirent  const  *)tmp___0;
    }
#line 671
    if (! ((unsigned long )dp != (unsigned long )((void *)0))) {
#line 671
      goto while_break;
    }
#line 673
    cp = (char const   *)(dp->d_name);
#line 675
    tid = (pthread_t )0;
    {
#line 677
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 677
      if ((int const   )*cp >= 48) {
#line 677
        if (! ((int const   )*cp <= 57)) {
#line 677
          goto while_break___0;
        }
      } else {
#line 677
        goto while_break___0;
      }
#line 678
      tmp = cp;
#line 678
      cp ++;
#line 678
      tid = tid * 10UL + (pthread_t )((int const   )*tmp - 48);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 680
    if ((int const   )*cp == 0) {
      {
#line 681
      ExamineProcessId(proc->pid, tid);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 684
  closedir(dir);
  }
#line 685
  return;
}
}
#line 691 "/home/june/repo/benchmarks/collector/temp/ips-4.0/linux.c"
static void GetProcessWaitSymbol(PROC *proc ) 
{ 
  int fd ;
  int len ;
  char name[80] ;
  ssize_t tmp ;

  {
#line 702
  if (! useWaitChan) {
#line 704
    proc->waitChanSymbol[0] = (char )'\000';
#line 706
    return;
  } else
#line 702
  if (proc->waitChan == 0UL) {
#line 704
    proc->waitChanSymbol[0] = (char )'\000';
#line 706
    return;
  }
  {
#line 713
  sprintf((char */* __restrict  */)(name), (char const   */* __restrict  */)"%s/%ld/waitChan",
          "/proc", (long )proc->pid);
#line 715
  fd = open((char const   *)(name), 0);
#line 716
  len = -1;
  }
#line 718
  if (fd >= 0) {
    {
#line 720
    tmp = read(fd, (void *)(proc->waitChanSymbol), (size_t )33);
#line 720
    len = (int )tmp;
#line 722
    close(fd);
    }
  }
#line 728
  if (len < 0) {
#line 730
    proc->waitChanSymbol[0] = (char )'-';
#line 731
    proc->waitChanSymbol[1] = (char )'\000';
#line 733
    return;
  }
#line 741
  if (len > 32) {
#line 743
    len = 32;
#line 744
    proc->waitChanSymbol[31] = (char )'|';
  }
  {
#line 750
  proc->waitChanSymbol[len] = (char )'\000';
#line 752
  MakePrintable(proc->waitChanSymbol, len);
  }
#line 753
  return;
}
}
#line 763 "/home/june/repo/benchmarks/collector/temp/ips-4.0/linux.c"
static void GetProcessCommandLine(PROC *proc ) 
{ 
  int fd ;
  int len ;
  char name[80] ;
  char buffer[10242] ;
  BOOL tmp ;
  ssize_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 771
  len = 0;
#line 773
  if (! useCommand) {
#line 775
    proc->hasCommand = 0;
#line 776
    proc->commandLength = 0;
#line 777
    *(proc->command + 0) = (char )'\000';
#line 779
    return;
  }
  {
#line 782
  proc->hasCommand = 1;
#line 788
  tmp = IsCopyAllowed((PROC const   *)proc);
  }
#line 788
  if (tmp) {
    {
#line 790
    SetCommandLine(proc, (char const   *)(proc->owner)->command, (proc->owner)->commandLength);
    }
#line 792
    return;
  }
  {
#line 799
  sprintf((char */* __restrict  */)(name), (char const   */* __restrict  */)"%s/%ld/cmdline",
          "/proc", (long )proc->pid);
#line 801
  fd = open((char const   *)(name), 0);
  }
#line 803
  if (fd >= 0) {
    {
#line 805
    tmp___0 = read(fd, (void *)(buffer), (size_t )10241);
#line 805
    len = (int )tmp___0;
#line 807
    close(fd);
    }
  }
#line 815
  if (fd < 0) {
#line 815
    goto _L;
  } else
#line 815
  if (len <= 0) {
    _L: /* CIL Label */ 
    {
#line 817
    proc->hasCommand = 0;
#line 818
    tmp___1 = strlen((char const   *)(proc->program));
#line 818
    len = (int )tmp___1;
#line 820
    buffer[0] = (char )'(';
#line 821
    memcpy((void */* __restrict  */)(& buffer[1]), (void const   */* __restrict  */)(proc->program),
           (size_t )len);
#line 822
    buffer[len + 1] = (char )')';
#line 824
    len += 2;
    }
  }
#line 832
  if (len > 10240) {
#line 834
    len = 10240;
#line 835
    buffer[10239] = (char )'|';
  }
  {
#line 841
  buffer[len] = (char )'\000';
#line 843
  MakePrintable(buffer, len);
#line 848
  SetCommandLine(proc, (char const   *)(buffer), len);
  }
#line 849
  return;
}
}
#line 858 "/home/june/repo/benchmarks/collector/temp/ips-4.0/linux.c"
static void GetProcessEnvironment(PROC *proc ) 
{ 
  int fd ;
  int len ;
  char name[80] ;
  char buffer[20482] ;
  BOOL tmp ;
  ssize_t tmp___0 ;

  {
#line 866
  if (! useEnvironment) {
#line 867
    return;
  }
  {
#line 873
  tmp = IsCopyAllowed((PROC const   *)proc);
  }
#line 873
  if (tmp) {
    {
#line 875
    SetSharedString(& proc->environment, & proc->environmentLength, (char const   *)(proc->owner)->environment,
                    (proc->owner)->environmentLength);
    }
#line 878
    return;
  }
  {
#line 885
  sprintf((char */* __restrict  */)(name), (char const   */* __restrict  */)"%s/%ld/environ",
          "/proc", (long )proc->pid);
#line 887
  fd = open((char const   *)(name), 0);
#line 889
  len = 0;
  }
#line 891
  if (fd >= 0) {
    {
#line 893
    tmp___0 = read(fd, (void *)(buffer), (size_t )20481);
#line 893
    len = (int )tmp___0;
#line 895
    close(fd);
    }
  }
#line 902
  if (fd < 0) {
    {
#line 904
    FreeSharedString(proc->environment);
#line 906
    proc->environment = emptyString;
#line 907
    proc->environmentLength = 0;
    }
#line 909
    return;
  } else
#line 902
  if (len <= 0) {
    {
#line 904
    FreeSharedString(proc->environment);
#line 906
    proc->environment = emptyString;
#line 907
    proc->environmentLength = 0;
    }
#line 909
    return;
  }
#line 917
  if (len > 20480) {
#line 919
    len = 20480;
#line 920
    buffer[20479] = (char )'|';
  }
  {
#line 926
  buffer[len] = (char )'\000';
#line 928
  MakePrintable(buffer, len);
#line 933
  SetSharedString(& proc->environment, & proc->environmentLength, (char const   *)(buffer),
                  len);
  }
#line 935
  return;
}
}
#line 944 "/home/june/repo/benchmarks/collector/temp/ips-4.0/linux.c"
static void GetProcessOpenFileCount(PROC *proc ) 
{ 
  DIR *dir ;
  struct dirent  const  *dp ;
  char const   *cp ;
  int count ;
  char name[80] ;
  BOOL tmp ;
  struct dirent *tmp___0 ;

  {
#line 953
  proc->openFiles = -1;
#line 955
  if (! useOpenFiles) {
#line 956
    return;
  }
  {
#line 962
  tmp = IsCopyAllowed((PROC const   *)proc);
  }
#line 962
  if (tmp) {
#line 964
    proc->openFiles = (proc->owner)->openFiles;
#line 966
    return;
  }
  {
#line 973
  sprintf((char */* __restrict  */)(name), (char const   */* __restrict  */)"%s/%ld/fd",
          "/proc", (long )proc->pid);
#line 975
  dir = opendir((char const   *)(name));
  }
#line 977
  if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 978
    return;
  }
#line 980
  count = 0;
  {
#line 982
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 982
    tmp___0 = readdir(dir);
#line 982
    dp = (struct dirent  const  *)tmp___0;
    }
#line 982
    if (! ((unsigned long )dp != (unsigned long )((void *)0))) {
#line 982
      goto while_break;
    }
#line 984
    cp = (char const   *)(dp->d_name);
    {
#line 986
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 986
      if ((int const   )*cp >= 48) {
#line 986
        if (! ((int const   )*cp <= 57)) {
#line 986
          goto while_break___0;
        }
      } else {
#line 986
        goto while_break___0;
      }
#line 987
      cp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 989
    if ((int const   )*cp == 0) {
#line 990
      count ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 993
  closedir(dir);
#line 995
  proc->openFiles = count;
  }
#line 996
  return;
}
}
#line 1005 "/home/june/repo/benchmarks/collector/temp/ips-4.0/linux.c"
static void GetProcessCurrentDirectory(PROC *proc ) 
{ 
  char name[80] ;
  BOOL tmp ;

  {
#line 1010
  if (! useCurrentDirectory) {
#line 1011
    return;
  }
  {
#line 1017
  tmp = IsCopyAllowed((PROC const   *)proc);
  }
#line 1017
  if (tmp) {
    {
#line 1019
    SetSharedString(& proc->cwdPath, & proc->cwdPathLength, (char const   *)(proc->owner)->cwdPath,
                    (proc->owner)->cwdPathLength);
    }
#line 1022
    return;
  }
  {
#line 1025
  sprintf((char */* __restrict  */)(name), (char const   */* __restrict  */)"%s/%ld/cwd",
          "/proc", (long )proc->pid);
#line 1027
  ReadLinkPath((char const   *)(name), & proc->cwdPath, & proc->cwdPathLength);
  }
#line 1028
  return;
}
}
#line 1037 "/home/june/repo/benchmarks/collector/temp/ips-4.0/linux.c"
static void GetProcessRootDirectory(PROC *proc ) 
{ 
  char name[80] ;
  BOOL tmp ;

  {
#line 1042
  if (! useRootDirectory) {
#line 1043
    return;
  }
  {
#line 1049
  tmp = IsCopyAllowed((PROC const   *)proc);
  }
#line 1049
  if (tmp) {
    {
#line 1051
    SetSharedString(& proc->rootPath, & proc->rootPathLength, (char const   *)(proc->owner)->rootPath,
                    (proc->owner)->rootPathLength);
    }
#line 1054
    return;
  }
  {
#line 1057
  sprintf((char */* __restrict  */)(name), (char const   */* __restrict  */)"%s/%ld/root",
          "/proc", (long )proc->pid);
#line 1059
  ReadLinkPath((char const   *)(name), & proc->rootPath, & proc->rootPathLength);
  }
#line 1060
  return;
}
}
#line 1069 "/home/june/repo/benchmarks/collector/temp/ips-4.0/linux.c"
static void GetProcessExecInode(PROC *proc ) 
{ 
  char name[80] ;
  BOOL tmp ;

  {
#line 1074
  if (! useExecInode) {
#line 1075
    return;
  }
  {
#line 1081
  tmp = IsCopyAllowed((PROC const   *)proc);
  }
#line 1081
  if (tmp) {
    {
#line 1083
    SetSharedString(& proc->execPath, & proc->execPathLength, (char const   *)(proc->owner)->execPath,
                    (proc->owner)->execPathLength);
    }
#line 1086
    return;
  }
  {
#line 1089
  sprintf((char */* __restrict  */)(name), (char const   */* __restrict  */)"%s/%ld/exe",
          "/proc", (long )proc->pid);
#line 1091
  ReadLinkPath((char const   *)(name), & proc->execPath, & proc->execPathLength);
  }
#line 1092
  return;
}
}
#line 1101 "/home/june/repo/benchmarks/collector/temp/ips-4.0/linux.c"
static void GetProcessStdioDescriptors(PROC *proc ) 
{ 
  int fd ;
  int dummy ;
  char name[80] ;
  size_t tmp ;
  BOOL tmp___0 ;

  {
#line 1108
  fd = 0;
  {
#line 1108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1108
    if (! (fd <= 2)) {
#line 1108
      goto while_break;
    }
#line 1110
    if (! useStdioTable[fd]) {
#line 1111
      goto __Cont;
    }
    {
#line 1117
    tmp___0 = IsCopyAllowed((PROC const   *)proc);
    }
#line 1117
    if (tmp___0) {
      {
#line 1119
      tmp = strlen((char const   *)(proc->owner)->stdioPaths[fd]);
#line 1119
      SetSharedString(& proc->stdioPaths[fd], & dummy, (char const   *)(proc->owner)->stdioPaths[fd],
                      (int )tmp);
      }
#line 1123
      goto __Cont;
    }
    {
#line 1126
    sprintf((char */* __restrict  */)(name), (char const   */* __restrict  */)"%s/%ld/fd/%d",
            "/proc", (long )proc->pid, fd);
#line 1128
    ReadLinkPath((char const   *)(name), & proc->stdioPaths[fd], & dummy);
    }
    __Cont: /* CIL Label */ 
#line 1108
    fd ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1130
  return;
}
}
#line 1140 "/home/june/repo/benchmarks/collector/temp/ips-4.0/linux.c"
static BOOL ReadLinkPath(char const   *name , char **retpath , int *retpathlength ) 
{ 
  char *newPath ;
  char *oldPath ;
  int len ;
  int oldLength ;
  char buffer[1024] ;
  ssize_t tmp ;
  int tmp___0 ;

  {
  {
#line 1152
  oldPath = *retpath;
#line 1153
  oldLength = *retpathlength;
#line 1158
  tmp = readlink((char const   */* __restrict  */)name, (char */* __restrict  */)(buffer),
                 sizeof(buffer));
#line 1158
  len = (int )tmp;
  }
#line 1160
  if (len <= 0) {
    {
#line 1162
    FreeSharedString(oldPath);
#line 1164
    *retpath = emptyString;
#line 1165
    *retpathlength = 0;
    }
#line 1167
    return (0);
  } else
#line 1160
  if ((unsigned long )len == sizeof(buffer)) {
    {
#line 1162
    FreeSharedString(oldPath);
#line 1164
    *retpath = emptyString;
#line 1165
    *retpathlength = 0;
    }
#line 1167
    return (0);
  }
#line 1170
  buffer[len] = (char )'\000';
#line 1175
  if (len == oldLength) {
    {
#line 1175
    tmp___0 = strcmp((char const   *)oldPath, (char const   *)(buffer));
    }
#line 1175
    if (tmp___0 == 0) {
#line 1176
      return (1);
    }
  }
  {
#line 1181
  FreeSharedString(oldPath);
#line 1183
  *retpath = emptyString;
#line 1184
  *retpathlength = 0;
#line 1189
  newPath = AllocateSharedString((char const   *)(buffer), len);
  }
#line 1191
  if ((unsigned long )newPath == (unsigned long )((void *)0)) {
#line 1192
    return (0);
  }
#line 1197
  *retpath = newPath;
#line 1198
  *retpathlength = len;
#line 1200
  return (1);
}
}
#line 1208 "/home/june/repo/benchmarks/collector/temp/ips-4.0/linux.c"
static BOOL IsCopyAllowed(PROC const   *proc ) 
{ 
  int tmp ;

  {
#line 1211
  if (noCopy) {
#line 1212
    return (0);
  }
#line 1214
  if (proc->isThread) {
#line 1214
    if ((unsigned long )proc->owner != (unsigned long )((PROC */* const  */)0)) {
#line 1214
      tmp = 1;
    } else {
#line 1214
      tmp = 0;
    }
  } else {
#line 1214
    tmp = 0;
  }
#line 1214
  return (tmp);
}
}
#line 1222 "/home/june/repo/benchmarks/collector/temp/ips-4.0/linux.c"
int PickBestState(int state1 , int state2 ) 
{ 


  {
#line 1225
  if (state1 == 82) {
#line 1226
    return ('R');
  } else
#line 1225
  if (state2 == 82) {
#line 1226
    return ('R');
  }
#line 1228
  if (state1 == 68) {
#line 1229
    return ('D');
  } else
#line 1228
  if (state2 == 68) {
#line 1229
    return ('D');
  }
#line 1231
  if (state1 == 83) {
#line 1232
    return ('S');
  } else
#line 1231
  if (state2 == 83) {
#line 1232
    return ('S');
  }
#line 1234
  return (state1);
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 587 "/usr/include/curses.h"
extern int cbreak(void) ;
#line 611
extern int endwin(void) ;
#line 622
extern _Bool has_colors(void) ;
#line 634
extern int init_pair(short  , short  , short  ) ;
#line 706
extern SCREEN *newterm(char const   * , FILE * , FILE * ) ;
#line 707
extern WINDOW *newwin(int  , int  , int  , int  ) ;
#line 711
extern int noecho(void) ;
#line 745
extern SCREEN *set_term(SCREEN * ) ;
#line 764
extern int start_color(void) ;
#line 785
extern int waddch(WINDOW * , chtype const    ) ;
#line 788
extern int waddnstr(WINDOW * , char const   * , int  ) ;
#line 802
extern int wclrtobot(WINDOW * ) ;
#line 824
extern int wmove(WINDOW * , int  , int  ) ;
#line 829
extern int wrefresh(WINDOW * ) ;
#line 890
extern int assume_default_colors(int  , int  ) ;
#line 895
extern int resize_term(int  , int  ) ;
#line 899
extern int use_default_colors(void) ;
#line 1384
extern WINDOW *curscr ;
#line 1386
extern WINDOW *stdscr ;
#line 1388
extern int COLORS ;
#line 1389
extern int COLOR_PAIRS ;
#line 1390
extern int COLS ;
#line 1392
extern int LINES ;
#line 646 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
DISPLAY *GetCursesDisplay(void) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cursesdisplay.c"
static COLOR_INFO___0 const   colorInfoTable___0[9]  = 
#line 36 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cursesdisplay.c"
  {      {"black", (short)0}, 
        {"red", (short)1}, 
        {"green", (short)2}, 
        {"yellow", (short)3}, 
        {"blue", (short)4}, 
        {"magenta", (short)5}, 
        {"cyan", (short)6}, 
        {"white", (short)7}, 
        {(char const   *)((void *)0), (short)0}};
#line 51
static BOOL CursesOpen(DISPLAY *display___2 ) ;
#line 52
static BOOL CursesDefineColor(DISPLAY *display___2 , int colorId , char const   *foreground___0 ,
                              char const   *background___0 , int colorFlags ) ;
#line 53
static void CursesCreateWindow(DISPLAY *display___2 ) ;
#line 54
static void CursesClose(DISPLAY *display___2 ) ;
#line 55
static void CursesSetColor(DISPLAY *display___2 , int colorId ) ;
#line 56
static void CursesRefresh(DISPLAY *display___2 ) ;
#line 57
static void CursesBeginPage(DISPLAY *display___2 ) ;
#line 58
static void CursesPutChar(DISPLAY *display___2 , int ch ) ;
#line 59
static void CursesPutString(DISPLAY *display___2 , char const   *str ) ;
#line 60
static void CursesPutBuffer(DISPLAY *display___2 , char const   *str , int len ) ;
#line 61
static void CursesEndPage(DISPLAY *display___2 ) ;
#line 62
static BOOL CursesEventWait(DISPLAY *display___2 , int milliSeconds ) ;
#line 63
static BOOL CursesInputReady(DISPLAY *display___2 ) ;
#line 64
static int CursesReadChar(DISPLAY *display___2 ) ;
#line 65
static void CursesRingBell(DISPLAY *display___2 ) ;
#line 66
static int CursesGetRows(DISPLAY *display___2 ) ;
#line 67
static int CursesGetCols(DISPLAY *display___2 ) ;
#line 68
static BOOL CursesDoesScroll(DISPLAY *display___2 ) ;
#line 71 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cursesdisplay.c"
static DISPLAY cursesDisplay  = 
#line 71
     {& CursesOpen, & CursesDefineColor, & CursesCreateWindow, & CursesClose, & CursesSetColor,
    & CursesRefresh, & CursesBeginPage, & CursesPutChar, & CursesPutString, & CursesPutBuffer,
    & CursesEndPage, & CursesEventWait, & CursesInputReady, & CursesReadChar, & CursesRingBell,
    & CursesGetRows, & CursesGetCols, & CursesDoesScroll};
#line 84 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cursesdisplay.c"
static WINDOW *mainWindow  ;
#line 90 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cursesdisplay.c"
static BOOL sizeChanged___0  ;
#line 96 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cursesdisplay.c"
static int attributeTable[20]  ;
#line 102
static void HandleResize___0(int arg ) ;
#line 103
static void GetTerminalSize___1(void) ;
#line 104
static int FindColorNameIndex___0(char const   *name ) ;
#line 110 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cursesdisplay.c"
DISPLAY *GetCursesDisplay(void) 
{ 


  {
#line 113
  return (& cursesDisplay);
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cursesdisplay.c"
static BOOL CursesOpen(DISPLAY *display___2 ) 
{ 
  SCREEN *screen___0 ;
  _Bool tmp ;
  int tmp___0 ;

  {
  {
#line 125
  screen___0 = newterm((char const   *)((void *)0), stdout, stdin);
  }
#line 127
  if ((unsigned long )screen___0 == (unsigned long )((void *)0)) {
#line 128
    return (0);
  }
  {
#line 130
  set_term(screen___0);
#line 132
  cbreak();
#line 133
  noecho();
#line 135
  tmp = has_colors();
  }
#line 135
  if (tmp) {
    {
#line 137
    start_color();
#line 138
    use_default_colors();
    }
  }
  {
#line 141
  mainWindow = newwin(0, 0, 0, 0);
#line 147
  tmp___0 = isatty(1);
  }
#line 147
  if (tmp___0) {
    {
#line 149
    signal(28, & HandleResize___0);
#line 151
    GetTerminalSize___1();
    }
  }
#line 154
  return (1);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cursesdisplay.c"
static void CursesCreateWindow(DISPLAY *display___2 ) 
{ 


  {
#line 165
  return;
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cursesdisplay.c"
static void CursesClose(DISPLAY *display___2 ) 
{ 


  {
  {
#line 174
  wrefresh(stdscr);
#line 175
  endwin();
  }
#line 176
  return;
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cursesdisplay.c"
static BOOL CursesDefineColor(DISPLAY *display___2 , int colorId , char const   *foreground___0 ,
                              char const   *background___0 , int colorFlags ) 
{ 
  int foregroundIndex ;
  int backgroundIndex ;
  int attribute ;
  int status ;
  _Bool tmp ;

  {
#line 187
  foregroundIndex = -1;
#line 188
  backgroundIndex = -1;
#line 189
  attribute = 0;
#line 192
  if (colorId < 0) {
#line 195
    return (0);
  } else
#line 192
  if (colorId >= 20) {
#line 195
    return (0);
  } else {
    {
#line 192
    tmp = has_colors();
    }
#line 192
    if (tmp) {
#line 192
      if (colorId >= COLOR_PAIRS) {
#line 195
        return (0);
      }
    } else {
#line 195
      return (0);
    }
  }
#line 201
  if (colorFlags & -4) {
#line 202
    return (0);
  }
#line 208
  if (*foreground___0) {
    {
#line 210
    foregroundIndex = FindColorNameIndex___0(foreground___0);
    }
#line 212
    if (foregroundIndex < 0) {
#line 213
      return (0);
    }
  }
#line 220
  if (*background___0) {
    {
#line 222
    backgroundIndex = FindColorNameIndex___0(background___0);
    }
#line 224
    if (backgroundIndex < 0) {
#line 225
      return (0);
    }
  }
#line 232
  if (colorId == 0) {
    {
#line 233
    status = assume_default_colors(foregroundIndex, backgroundIndex);
    }
  } else {
    {
#line 235
    status = init_pair((short )colorId, (short )foregroundIndex, (short )backgroundIndex);
    }
  }
#line 237
  if (status == -1) {
#line 238
    return (0);
  }
#line 243
  if (colorFlags & 2) {
#line 244
    attribute = (int )((unsigned long )attribute | (1UL << 17));
  }
#line 246
  if (colorFlags & 1) {
#line 247
    attribute = (int )((unsigned long )attribute | (1UL << 21));
  }
#line 249
  attribute = (int )((unsigned long )attribute | ((chtype )colorId << 8));
#line 251
  attributeTable[colorId] = attribute;
#line 253
  return (1);
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cursesdisplay.c"
static int FindColorNameIndex___0(char const   *name ) 
{ 
  int index___0 ;
  int tmp ;
  char const   *tmp___0 ;

  {
#line 268
  if ((int const   )*name == 0) {
#line 269
    return (-1);
  }
#line 274
  index___0 = 0;
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 274
    if (! colorInfoTable___0[index___0].name) {
#line 274
      goto while_break;
    }
    {
#line 276
    tmp = strcmp(name, (char const   *)colorInfoTable___0[index___0].name);
    }
#line 276
    if (tmp == 0) {
#line 278
      index___0 = (int )colorInfoTable___0[index___0].index;
#line 280
      if (index___0 >= COLORS) {
#line 281
        return (-1);
      }
#line 283
      return (index___0);
    }
#line 274
    index___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 291
  index___0 = 0;
  {
#line 293
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 293
    if ((int const   )*name >= 48) {
#line 293
      if (! ((int const   )*name <= 57)) {
#line 293
        goto while_break___0;
      }
    } else {
#line 293
      goto while_break___0;
    }
#line 294
    tmp___0 = name;
#line 294
    name ++;
#line 294
    index___0 = index___0 * 10 + (int )((int const   )*tmp___0 - 48);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 299
  if (*name) {
#line 300
    return (-1);
  } else
#line 299
  if (index___0 < 0) {
#line 300
    return (-1);
  } else
#line 299
  if (index___0 >= COLORS) {
#line 300
    return (-1);
  }
#line 302
  return (index___0);
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cursesdisplay.c"
static void CursesSetColor(DISPLAY *display___2 , int colorId ) 
{ 


  {
#line 309
  if (colorId < 0) {
#line 312
    return;
  } else
#line 309
  if (colorId >= 20) {
#line 312
    return;
  } else
#line 309
  if (colorId >= COLOR_PAIRS) {
#line 312
    return;
  }
#line 315
  if (mainWindow) {
#line 315
    mainWindow->_attrs = (attr_t )attributeTable[colorId];
  }
#line 316
  return;
}
}
#line 319 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cursesdisplay.c"
static void CursesRefresh(DISPLAY *display___2 ) 
{ 


  {
  {
#line 322
  wrefresh(curscr);
  }
#line 323
  return;
}
}
#line 326 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cursesdisplay.c"
static void CursesBeginPage(DISPLAY *display___2 ) 
{ 


  {
  {
#line 329
  wmove(mainWindow, 0, 0);
  }
#line 330
  return;
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cursesdisplay.c"
static void CursesPutChar(DISPLAY *display___2 , int ch ) 
{ 


  {
  {
#line 336
  waddch(mainWindow, (chtype const   )ch);
  }
#line 337
  return;
}
}
#line 340 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cursesdisplay.c"
static void CursesPutString(DISPLAY *display___2 , char const   *str ) 
{ 


  {
  {
#line 343
  waddnstr(mainWindow, str, -1);
  }
#line 344
  return;
}
}
#line 347 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cursesdisplay.c"
static void CursesPutBuffer(DISPLAY *display___2 , char const   *str , int len ) 
{ 
  int tmp ;

  {
  {
#line 350
  while (1) {
    while_continue: /* CIL Label */ ;
#line 350
    tmp = len;
#line 350
    len --;
#line 350
    if (! (tmp > 0)) {
#line 350
      goto while_break;
    }
    {
#line 352
    waddch(mainWindow, (chtype const   )*str);
#line 353
    str ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 355
  return;
}
}
#line 358 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cursesdisplay.c"
static void CursesEndPage(DISPLAY *display___2 ) 
{ 


  {
  {
#line 361
  wclrtobot(mainWindow);
#line 362
  wmove(mainWindow, 0, 0);
#line 363
  wrefresh(mainWindow);
  }
#line 364
  return;
}
}
#line 372 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cursesdisplay.c"
static BOOL CursesEventWait(DISPLAY *display___2 , int milliSeconds ) 
{ 
  struct timeval timeOut ;
  fd_set readFds ;
  int __d0 ;
  int __d1 ;

  {
#line 378
  if (milliSeconds <= 0) {
#line 379
    return (sizeChanged___0);
  }
  {
#line 381
  while (1) {
    while_continue: /* CIL Label */ ;
#line 381
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& readFds.__fds_bits[0]): "memory");
#line 381
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 382
  readFds.__fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << 0 % (8 * (int )sizeof(__fd_mask ));
#line 384
  timeOut.tv_sec = (__time_t )(milliSeconds / 1000);
#line 385
  timeOut.tv_usec = (__suseconds_t )((milliSeconds % 1000) * 1000);
#line 387
  select(1, (fd_set */* __restrict  */)(& readFds), (fd_set */* __restrict  */)((void *)0),
         (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& timeOut));
  }
#line 389
  return (sizeChanged___0);
}
}
#line 396 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cursesdisplay.c"
static BOOL CursesInputReady(DISPLAY *display___2 ) 
{ 
  struct timeval timeOut ;
  fd_set readFds ;
  int __d0 ;
  int __d1 ;
  int tmp ;

  {
  {
#line 402
  while (1) {
    while_continue: /* CIL Label */ ;
#line 402
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& readFds.__fds_bits[0]): "memory");
#line 402
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 403
  readFds.__fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << 0 % (8 * (int )sizeof(__fd_mask ));
#line 405
  timeOut.tv_sec = (__time_t )0;
#line 406
  timeOut.tv_usec = (__suseconds_t )0;
#line 408
  tmp = select(1, (fd_set */* __restrict  */)(& readFds), (fd_set */* __restrict  */)((void *)0),
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& timeOut));
  }
#line 408
  return (tmp > 0);
}
}
#line 415 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cursesdisplay.c"
static int CursesReadChar(DISPLAY *display___2 ) 
{ 
  char data ;
  ssize_t tmp ;

  {
  {
#line 420
  tmp = read(0, (void *)(& data), (size_t )1);
  }
#line 420
  if (tmp < 1L) {
#line 421
    return (-1);
  }
#line 423
  return ((int )data & 255);
}
}
#line 427 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cursesdisplay.c"
static void CursesRingBell(DISPLAY *display___2 ) 
{ 


  {
  {
#line 430
  fflush(stdout);
#line 431
  fputc('\a', stderr);
#line 432
  fflush(stderr);
  }
#line 433
  return;
}
}
#line 436 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cursesdisplay.c"
static int CursesGetRows(DISPLAY *display___2 ) 
{ 


  {
#line 439
  if (sizeChanged___0) {
    {
#line 440
    GetTerminalSize___1();
    }
  }
#line 442
  return (LINES);
}
}
#line 452 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cursesdisplay.c"
static int CursesGetCols(DISPLAY *display___2 ) 
{ 


  {
#line 455
  if (sizeChanged___0) {
    {
#line 456
    GetTerminalSize___1();
    }
  }
#line 458
  return (COLS - 1);
}
}
#line 462 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cursesdisplay.c"
static BOOL CursesDoesScroll(DISPLAY *display___2 ) 
{ 


  {
#line 465
  return (0);
}
}
#line 474 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cursesdisplay.c"
static void HandleResize___0(int arg ) 
{ 


  {
  {
#line 477
  sizeChanged___0 = 1;
#line 479
  signal(28, & HandleResize___0);
  }
#line 480
  return;
}
}
#line 487 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cursesdisplay.c"
static void GetTerminalSize___1(void) 
{ 
  struct winsize size ;
  int rows___1 ;
  int cols___1 ;
  int tmp ;

  {
  {
#line 494
  sizeChanged___0 = 0;
#line 496
  tmp = ioctl(1, 21523UL, & size);
  }
#line 496
  if (tmp < 0) {
#line 497
    return;
  }
#line 499
  rows___1 = (int )size.ws_row;
#line 500
  cols___1 = (int )size.ws_col;
#line 502
  if (rows___1 <= 0) {
#line 503
    rows___1 = 1;
  }
#line 505
  if (cols___1 <= 0) {
#line 506
    cols___1 = 1;
  }
#line 511
  if (rows___1 != LINES) {
    {
#line 512
    resize_term(rows___1, cols___1);
    }
  } else
#line 511
  if (cols___1 != COLS) {
    {
#line 512
    resize_term(rows___1, cols___1);
    }
  }
#line 513
  return;
}
}
#line 264 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 532 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
char *AllocTempString(int len ) ;
#line 533
char *CopyTempString(char const   *oldcp ) ;
#line 540
void DefaultColumns(void) ;
#line 541
void DefaultColumnWidths(void) ;
#line 573
COLUMN *FindColumn(char const   *name ) ;
#line 574
void ListColumns(void) ;
#line 582
char const   *FindUserName(uid_t uid ) ;
#line 583
char const   *FindGroupName(gid_t gid ) ;
#line 584
char const   *FindDeviceName(dev_t devid ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowPid(PROC const   *proc ) ;
#line 38
static int SortPid(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 38
static void EvalPid(PROC const   *proc , VALUE *val ) ;
#line 38
static BOOL TestPid(PROC const   *proc ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnPid  = 
#line 38
     {(char *)"pid", (char *)"Pid", (int )(sizeof("Pid") - 1UL), 5, 5, 1, (USEFLAG )0,
    & ShowPid, & SortPid, & EvalPid, & TestPid};
#line 41
static char const   *ShowTid(PROC const   *proc ) ;
#line 41
static int SortTid(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 41
static void EvalTid(PROC const   *proc , VALUE *val ) ;
#line 41
static BOOL TestTid(PROC const   *proc ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnTid  = 
#line 41
     {(char *)"tid", (char *)"Tid", (int )(sizeof("Tid") - 1UL), 5, 5, 1, (USEFLAG )0,
    & ShowTid, & SortTid, & EvalTid, & TestTid};
#line 44
static char const   *ShowState(PROC const   *proc ) ;
#line 44
static int SortState(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 44
static void EvalState(PROC const   *proc , VALUE *val ) ;
#line 44
static BOOL TestState(PROC const   *proc ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnState  = 
#line 44
     {(char *)"state", (char *)"Stat", (int )(sizeof("Stat") - 1UL), 4, 4, 2, (USEFLAG )0,
    & ShowState, & SortState, & EvalState, & TestState};
#line 47
static char const   *ShowThreadCount(PROC const   *proc ) ;
#line 47
static int SortThreadCount(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 47
static void EvalThreadCount(PROC const   *proc , VALUE *val ) ;
#line 47
static BOOL TestThreadCount(PROC const   *proc ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnThreadCount  = 
#line 47
     {(char *)"threads", (char *)"Threads", (int )(sizeof("Threads") - 1UL), 7, 7, 1,
    (USEFLAG )0, & ShowThreadCount, & SortThreadCount, & EvalThreadCount, & TestThreadCount};
#line 50
static char const   *ShowParentPid(PROC const   *proc ) ;
#line 50
static int SortParentPid(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 50
static void EvalParentPid(PROC const   *proc , VALUE *val ) ;
#line 50
static BOOL TestParentPid(PROC const   *proc ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnParentPid  = 
#line 50
     {(char *)"parentpid", (char *)"PPid", (int )(sizeof("PPid") - 1UL), 5, 5, 1, (USEFLAG )0,
    & ShowParentPid, & SortParentPid, & EvalParentPid, & TestParentPid};
#line 53
static char const   *ShowSystemTime(PROC const   *proc ) ;
#line 53
static int SortSystemTime(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 53
static void EvalSystemTime(PROC const   *proc , VALUE *val ) ;
#line 53
static BOOL TestSystemTime(PROC const   *proc ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnSystemTime  = 
#line 53
     {(char *)"systemtime", (char *)"System Time", (int )(sizeof("System Time") - 1UL),
    10, 10, 1, (USEFLAG )0, & ShowSystemTime, & SortSystemTime, & EvalSystemTime,
    & TestSystemTime};
#line 56
static char const   *ShowUserTime(PROC const   *proc ) ;
#line 56
static int SortUserTime(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 56
static void EvalUserTime(PROC const   *proc , VALUE *val ) ;
#line 56
static BOOL TestUserTime(PROC const   *proc ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnUserTime  = 
#line 56
     {(char *)"usertime", (char *)"User Time", (int )(sizeof("User Time") - 1UL), 10,
    10, 1, (USEFLAG )0, & ShowUserTime, & SortUserTime, & EvalUserTime, & TestUserTime};
#line 59
static char const   *ShowRunTime(PROC const   *proc ) ;
#line 59
static int SortRunTime(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 59
static void EvalRunTime(PROC const   *proc , VALUE *val ) ;
#line 59
static BOOL TestRunTime(PROC const   *proc ) ;
#line 59 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnRunTime  = 
#line 59
     {(char *)"runtime", (char *)"Runtime", (int )(sizeof("Runtime") - 1UL), 10, 10,
    1, (USEFLAG )0, & ShowRunTime, & SortRunTime, & EvalRunTime, & TestRunTime};
#line 62
static char const   *ShowChildRunTime(PROC const   *proc ) ;
#line 62
static int SortChildRunTime(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 62
static void EvalChildRunTime(PROC const   *proc , VALUE *val ) ;
#line 62
static BOOL TestChildRunTime(PROC const   *proc ) ;
#line 62 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnChildRunTime  = 
#line 62
     {(char *)"childruntime", (char *)"ChildRuntime", (int )(sizeof("ChildRuntime") - 1UL),
    10, 10, 1, (USEFLAG )0, & ShowChildRunTime, & SortChildRunTime, & EvalChildRunTime,
    & TestChildRunTime};
#line 65
static char const   *ShowPageSwaps(PROC const   *proc ) ;
#line 65
static int SortPageSwaps(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 65
static void EvalPageSwaps(PROC const   *proc , VALUE *val ) ;
#line 65
static BOOL TestPageSwaps(PROC const   *proc ) ;
#line 65 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnPageSwaps  = 
#line 65
     {(char *)"pageswaps", (char *)"PageSwaps", (int )(sizeof("PageSwaps") - 1UL), 10,
    10, 1, (USEFLAG )0, & ShowPageSwaps, & SortPageSwaps, & EvalPageSwaps, & TestPageSwaps};
#line 68
static char const   *ShowPolicy(PROC const   *proc ) ;
#line 68
static int SortPolicy(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 68
static void EvalPolicy(PROC const   *proc , VALUE *val ) ;
#line 68
static BOOL TestPolicy(PROC const   *proc ) ;
#line 68 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnPolicy  = 
#line 68
     {(char *)"policy", (char *)"Policy", (int )(sizeof("Policy") - 1UL), 6, 6, 1, (USEFLAG )0,
    & ShowPolicy, & SortPolicy, & EvalPolicy, & TestPolicy};
#line 71
static char const   *ShowPriority(PROC const   *proc ) ;
#line 71
static int SortPriority(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 71
static void EvalPriority(PROC const   *proc , VALUE *val ) ;
#line 71
static BOOL TestPriority(PROC const   *proc ) ;
#line 71 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnPriority  = 
#line 71
     {(char *)"priority", (char *)"Pri", (int )(sizeof("Pri") - 1UL), 3, 3, 1, (USEFLAG )0,
    & ShowPriority, & SortPriority, & EvalPriority, & TestPriority};
#line 74
static char const   *ShowRealTimePriority(PROC const   *proc ) ;
#line 74
static int SortRealTimePriority(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 74
static void EvalRealTimePriority(PROC const   *proc , VALUE *val ) ;
#line 74
static BOOL TestRealTimePriority(PROC const   *proc ) ;
#line 74 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnRealTimePriority  = 
#line 74
     {(char *)"realtimepriority", (char *)"RTPri", (int )(sizeof("RTPri") - 1UL), 5,
    5, 1, (USEFLAG )0, & ShowRealTimePriority, & SortRealTimePriority, & EvalRealTimePriority,
    & TestRealTimePriority};
#line 77
static char const   *ShowChildPageSwaps(PROC const   *proc ) ;
#line 77
static int SortChildPageSwaps(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 77
static void EvalChildPageSwaps(PROC const   *proc , VALUE *val ) ;
#line 77
static BOOL TestChildPageSwaps(PROC const   *proc ) ;
#line 77 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnChildPageSwaps  = 
#line 77
     {(char *)"childpageswaps", (char *)"ChildPgSwp", (int )(sizeof("ChildPgSwp") - 1UL),
    10, 10, 1, (USEFLAG )0, & ShowChildPageSwaps, & SortChildPageSwaps, & EvalChildPageSwaps,
    & TestChildPageSwaps};
#line 80
static char const   *ShowEip(PROC const   *proc ) ;
#line 80
static int SortEip(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 80
static void EvalEip(PROC const   *proc , VALUE *val ) ;
#line 80
static BOOL TestEip(PROC const   *proc ) ;
#line 80 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnEip  = 
#line 80
     {(char *)"eip", (char *)"EIP", (int )(sizeof("EIP") - 1UL), 16, 16, 1, (USEFLAG )0,
    & ShowEip, & SortEip, & EvalEip, & TestEip};
#line 83
static char const   *ShowEsp(PROC const   *proc ) ;
#line 83
static int SortEsp(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 83
static void EvalEsp(PROC const   *proc , VALUE *val ) ;
#line 83
static BOOL TestEsp(PROC const   *proc ) ;
#line 83 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnEsp  = 
#line 83
     {(char *)"esp", (char *)"ESP", (int )(sizeof("ESP") - 1UL), 16, 16, 1, (USEFLAG )0,
    & ShowEsp, & SortEsp, & EvalEsp, & TestEsp};
#line 86
static char const   *ShowWaitChannel(PROC const   *proc ) ;
#line 86
static int SortWaitChannel(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 86
static void EvalWaitChannel(PROC const   *proc , VALUE *val ) ;
#line 86
static BOOL TestWaitChannel(PROC const   *proc ) ;
#line 86 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnWaitChannel  = 
#line 86
     {(char *)"waitchannel", (char *)"WaitChan", (int )(sizeof("WaitChan") - 1UL), 16,
    16, 1, (USEFLAG )0, & ShowWaitChannel, & SortWaitChannel, & EvalWaitChannel, & TestWaitChannel};
#line 89
static char const   *ShowWaitSymbol(PROC const   *proc ) ;
#line 89
static int SortWaitSymbol(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 89
static void EvalWaitSymbol(PROC const   *proc , VALUE *val ) ;
#line 89
static BOOL TestWaitSymbol(PROC const   *proc ) ;
#line 89 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnWaitSymbol  = 
#line 89
     {(char *)"waitsymbol", (char *)"WaitSymbol", (int )(sizeof("WaitSymbol") - 1UL),
    16, 16, 0, (USEFLAG )16384, & ShowWaitSymbol, & SortWaitSymbol, & EvalWaitSymbol,
    & TestWaitSymbol};
#line 92
static char const   *ShowProgram(PROC const   *proc ) ;
#line 92
static int SortProgram(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 92
static void EvalProgram(PROC const   *proc , VALUE *val ) ;
#line 92
static BOOL TestProgram(PROC const   *proc ) ;
#line 92 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnProgram  = 
#line 92
     {(char *)"program", (char *)"Program", (int )(sizeof("Program") - 1UL), 12, 12,
    0, (USEFLAG )0, & ShowProgram, & SortProgram, & EvalProgram, & TestProgram};
#line 95
static char const   *ShowCommand(PROC const   *proc ) ;
#line 95
static int SortCommand(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 95
static void EvalCommand(PROC const   *proc , VALUE *val ) ;
#line 95
static BOOL TestCommand(PROC const   *proc ) ;
#line 95 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnCommand  = 
#line 95
     {(char *)"command", (char *)"Command", (int )(sizeof("Command") - 1UL), 20, 20,
    0, (USEFLAG )16, & ShowCommand, & SortCommand, & EvalCommand, & TestCommand};
#line 98
static char const   *ShowEnvironment(PROC const   *proc ) ;
#line 98
static int SortEnvironment(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 98
static void EvalEnvironment(PROC const   *proc , VALUE *val ) ;
#line 98
static BOOL TestEnvironment(PROC const   *proc ) ;
#line 98 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnEnvironment  = 
#line 98
     {(char *)"environment", (char *)"Environment", (int )(sizeof("Environment") - 1UL),
    25, 25, 0, (USEFLAG )512, & ShowEnvironment, & SortEnvironment, & EvalEnvironment,
    & TestEnvironment};
#line 101
static char const   *ShowProcessGroup(PROC const   *proc ) ;
#line 101
static int SortProcessGroup(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 101
static void EvalProcessGroup(PROC const   *proc , VALUE *val ) ;
#line 101
static BOOL TestProcessGroup(PROC const   *proc ) ;
#line 101 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnProcessGroup  = 
#line 101
     {(char *)"processgroup", (char *)"PGrp", (int )(sizeof("PGrp") - 1UL), 5, 5, 1,
    (USEFLAG )0, & ShowProcessGroup, & SortProcessGroup, & EvalProcessGroup, & TestProcessGroup};
#line 104
static char const   *ShowTtyProcessGroup(PROC const   *proc ) ;
#line 104
static int SortTtyProcessGroup(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 104
static void EvalTtyProcessGroup(PROC const   *proc , VALUE *val ) ;
#line 104
static BOOL TestTtyProcessGroup(PROC const   *proc ) ;
#line 104 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnTtyProcessGroup  = 
#line 104
     {(char *)"ttyprocessgroup", (char *)"TtyPG", (int )(sizeof("TtyPG") - 1UL), 5,
    5, 1, (USEFLAG )0, & ShowTtyProcessGroup, & SortTtyProcessGroup, & EvalTtyProcessGroup,
    & TestTtyProcessGroup};
#line 107
static char const   *ShowIdleTime(PROC const   *proc ) ;
#line 107
static int SortIdleTime(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 107
static void EvalIdleTime(PROC const   *proc , VALUE *val ) ;
#line 107
static BOOL TestIdleTime(PROC const   *proc ) ;
#line 107 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnIdleTime  = 
#line 107
     {(char *)"idletime", (char *)"Idle", (int )(sizeof("Idle") - 1UL), 8, 8, 1, (USEFLAG )1,
    & ShowIdleTime, & SortIdleTime, & EvalIdleTime, & TestIdleTime};
#line 110
static char const   *ShowDeadTime(PROC const   *proc ) ;
#line 110
static int SortDeadTime(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 110
static void EvalDeadTime(PROC const   *proc , VALUE *val ) ;
#line 110
static BOOL TestDeadTime(PROC const   *proc ) ;
#line 110 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnDeadTime  = 
#line 110
     {(char *)"deadtime", (char *)"Dead", (int )(sizeof("Dead") - 1UL), 8, 8, 1, (USEFLAG )0,
    & ShowDeadTime, & SortDeadTime, & EvalDeadTime, & TestDeadTime};
#line 113
static char const   *ShowTtyName(PROC const   *proc ) ;
#line 113
static int SortTtyName(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 113
static void EvalTtyName(PROC const   *proc , VALUE *val ) ;
#line 113
static BOOL TestTtyName(PROC const   *proc ) ;
#line 113 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnTtyName  = 
#line 113
     {(char *)"ttyname", (char *)"TtyName", (int )(sizeof("TtyName") - 1UL), 8, 8, 0,
    (USEFLAG )2, & ShowTtyName, & SortTtyName, & EvalTtyName, & TestTtyName};
#line 116
static char const   *ShowTtyDevice(PROC const   *proc ) ;
#line 116
static int SortTtyDevice(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 116
static void EvalTtyDevice(PROC const   *proc , VALUE *val ) ;
#line 116
static BOOL TestTtyDevice(PROC const   *proc ) ;
#line 116 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnTtyDevice  = 
#line 116
     {(char *)"ttydevice", (char *)"TtyD", (int )(sizeof("TtyD") - 1UL), 4, 4, 1, (USEFLAG )0,
    & ShowTtyDevice, & SortTtyDevice, & EvalTtyDevice, & TestTtyDevice};
#line 119
static char const   *ShowUserName(PROC const   *proc ) ;
#line 119
static int SortUserName(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 119
static void EvalUserName(PROC const   *proc , VALUE *val ) ;
#line 119
static BOOL TestUserName(PROC const   *proc ) ;
#line 119 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnUserName  = 
#line 119
     {(char *)"user", (char *)"User", (int )(sizeof("User") - 1UL), 8, 8, 0, (USEFLAG )4096,
    & ShowUserName, & SortUserName, & EvalUserName, & TestUserName};
#line 122
static char const   *ShowUserId(PROC const   *proc ) ;
#line 122
static int SortUserId(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 122
static void EvalUserId(PROC const   *proc , VALUE *val ) ;
#line 122
static BOOL TestUserId(PROC const   *proc ) ;
#line 122 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnUserId  = 
#line 122
     {(char *)"uid", (char *)"Uid", (int )(sizeof("Uid") - 1UL), 5, 5, 1, (USEFLAG )0,
    & ShowUserId, & SortUserId, & EvalUserId, & TestUserId};
#line 125
static char const   *ShowGroupName(PROC const   *proc ) ;
#line 125
static int SortGroupName(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 125
static void EvalGroupName(PROC const   *proc , VALUE *val ) ;
#line 125
static BOOL TestGroupName(PROC const   *proc ) ;
#line 125 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnGroupName  = 
#line 125
     {(char *)"group", (char *)"Group", (int )(sizeof("Group") - 1UL), 8, 8, 0, (USEFLAG )8192,
    & ShowGroupName, & SortGroupName, & EvalGroupName, & TestGroupName};
#line 128
static char const   *ShowGroupId(PROC const   *proc ) ;
#line 128
static int SortGroupId(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 128
static void EvalGroupId(PROC const   *proc , VALUE *val ) ;
#line 128
static BOOL TestGroupId(PROC const   *proc ) ;
#line 128 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnGroupId  = 
#line 128
     {(char *)"gid", (char *)"Gid", (int )(sizeof("Gid") - 1UL), 5, 5, 1, (USEFLAG )0,
    & ShowGroupId, & SortGroupId, & EvalGroupId, & TestGroupId};
#line 131
static char const   *ShowPercentCpu(PROC const   *proc ) ;
#line 131
static int SortPercentCpu(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 131
static void EvalPercentCpu(PROC const   *proc , VALUE *val ) ;
#line 131
static BOOL TestPercentCpu(PROC const   *proc ) ;
#line 131 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnPercentCpu  = 
#line 131
     {(char *)"percentcpu", (char *)"%Cpu", (int )(sizeof("%Cpu") - 1UL), 6, 6, 1, (USEFLAG )1,
    & ShowPercentCpu, & SortPercentCpu, & EvalPercentCpu, & TestPercentCpu};
#line 134
static char const   *ShowPercentMemory(PROC const   *proc ) ;
#line 134
static int SortPercentMemory(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 134
static void EvalPercentMemory(PROC const   *proc , VALUE *val ) ;
#line 134
static BOOL TestPercentMemory(PROC const   *proc ) ;
#line 134 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnPercentMemory  = 
#line 134
     {(char *)"percentmemory", (char *)"%Mem", (int )(sizeof("%Mem") - 1UL), 4, 4, 1,
    (USEFLAG )0, & ShowPercentMemory, & SortPercentMemory, & EvalPercentMemory, & TestPercentMemory};
#line 137
static char const   *ShowRss(PROC const   *proc ) ;
#line 137
static int SortRss(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 137
static void EvalRss(PROC const   *proc , VALUE *val ) ;
#line 137
static BOOL TestRss(PROC const   *proc ) ;
#line 137 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnRss  = 
#line 137
     {(char *)"residentsetsize", (char *)"Rss", (int )(sizeof("Rss") - 1UL), 5, 5, 1,
    (USEFLAG )0, & ShowRss, & SortRss, & EvalRss, & TestRss};
#line 140
static char const   *ShowStartTime(PROC const   *proc ) ;
#line 140
static int SortStartTime(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 140
static void EvalStartTime(PROC const   *proc , VALUE *val ) ;
#line 140
static BOOL TestStartTime(PROC const   *proc ) ;
#line 140 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnStartTime  = 
#line 140
     {(char *)"starttime", (char *)"Start Time", (int )(sizeof("Start Time") - 1UL),
    10, 10, 0, (USEFLAG )0, & ShowStartTime, & SortStartTime, & EvalStartTime, & TestStartTime};
#line 143
static char const   *ShowAge(PROC const   *proc ) ;
#line 143
static int SortAge(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 143
static void EvalAge(PROC const   *proc , VALUE *val ) ;
#line 143
static BOOL TestAge(PROC const   *proc ) ;
#line 143 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnAge  = 
#line 143
     {(char *)"age", (char *)"Age", (int )(sizeof("Age") - 1UL), 8, 8, 1, (USEFLAG )0,
    & ShowAge, & SortAge, & EvalAge, & TestAge};
#line 146
static char const   *ShowFlags(PROC const   *proc ) ;
#line 146
static int SortFlags(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 146
static void EvalFlags(PROC const   *proc , VALUE *val ) ;
#line 146
static BOOL TestFlags(PROC const   *proc ) ;
#line 146 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnFlags  = 
#line 146
     {(char *)"flags", (char *)"Flags", (int )(sizeof("Flags") - 1UL), 8, 8, 1, (USEFLAG )0,
    & ShowFlags, & SortFlags, & EvalFlags, & TestFlags};
#line 149
static char const   *ShowPageFaults(PROC const   *proc ) ;
#line 149
static int SortPageFaults(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 149
static void EvalPageFaults(PROC const   *proc , VALUE *val ) ;
#line 149
static BOOL TestPageFaults(PROC const   *proc ) ;
#line 149 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnPageFaults  = 
#line 149
     {(char *)"pagefaults", (char *)"Faults", (int )(sizeof("Faults") - 1UL), 10, 10,
    1, (USEFLAG )0, & ShowPageFaults, & SortPageFaults, & EvalPageFaults, & TestPageFaults};
#line 152
static char const   *ShowMinorPageFaults(PROC const   *proc ) ;
#line 152
static int SortMinorPageFaults(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 152
static void EvalMinorPageFaults(PROC const   *proc , VALUE *val ) ;
#line 152
static BOOL TestMinorPageFaults(PROC const   *proc ) ;
#line 152 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnMinorPageFaults  = 
#line 152
     {(char *)"minorpagefaults", (char *)"MinorFault", (int )(sizeof("MinorFault") - 1UL),
    10, 10, 1, (USEFLAG )0, & ShowMinorPageFaults, & SortMinorPageFaults, & EvalMinorPageFaults,
    & TestMinorPageFaults};
#line 155
static char const   *ShowMajorPageFaults(PROC const   *proc ) ;
#line 155
static int SortMajorPageFaults(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 155
static void EvalMajorPageFaults(PROC const   *proc , VALUE *val ) ;
#line 155
static BOOL TestMajorPageFaults(PROC const   *proc ) ;
#line 155 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnMajorPageFaults  = 
#line 155
     {(char *)"majorpagefaults", (char *)"MajorFault", (int )(sizeof("MajorFault") - 1UL),
    10, 10, 1, (USEFLAG )0, & ShowMajorPageFaults, & SortMajorPageFaults, & EvalMajorPageFaults,
    & TestMajorPageFaults};
#line 158
static char const   *ShowSignalCatch(PROC const   *proc ) ;
#line 158
static int SortSignalCatch(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 158
static void EvalSignalCatch(PROC const   *proc , VALUE *val ) ;
#line 158
static BOOL TestSignalCatch(PROC const   *proc ) ;
#line 158 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnSignalCatch  = 
#line 158
     {(char *)"signalcatch", (char *)"SigCatch", (int )(sizeof("SigCatch") - 1UL), 8,
    8, 1, (USEFLAG )0, & ShowSignalCatch, & SortSignalCatch, & EvalSignalCatch, & TestSignalCatch};
#line 161
static char const   *ShowSignalIgnore(PROC const   *proc ) ;
#line 161
static int SortSignalIgnore(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 161
static void EvalSignalIgnore(PROC const   *proc , VALUE *val ) ;
#line 161
static BOOL TestSignalIgnore(PROC const   *proc ) ;
#line 161 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnSignalIgnore  = 
#line 161
     {(char *)"signalignore", (char *)"SigIgnor", (int )(sizeof("SigIgnor") - 1UL),
    8, 8, 1, (USEFLAG )0, & ShowSignalIgnore, & SortSignalIgnore, & EvalSignalIgnore,
    & TestSignalIgnore};
#line 164
static char const   *ShowSignalBlock(PROC const   *proc ) ;
#line 164
static int SortSignalBlock(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 164
static void EvalSignalBlock(PROC const   *proc , VALUE *val ) ;
#line 164
static BOOL TestSignalBlock(PROC const   *proc ) ;
#line 164 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnSignalBlock  = 
#line 164
     {(char *)"signalblock", (char *)"SigBlock", (int )(sizeof("SigBlock") - 1UL), 8,
    8, 1, (USEFLAG )0, & ShowSignalBlock, & SortSignalBlock, & EvalSignalBlock, & TestSignalBlock};
#line 167
static char const   *ShowOpenFileCount(PROC const   *proc ) ;
#line 167
static int SortOpenFileCount(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 167
static void EvalOpenFileCount(PROC const   *proc , VALUE *val ) ;
#line 167
static BOOL TestOpenFileCount(PROC const   *proc ) ;
#line 167 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnOpenFileCount  = 
#line 167
     {(char *)"openfiles", (char *)"Files", (int )(sizeof("Files") - 1UL), 5, 5, 1,
    (USEFLAG )4, & ShowOpenFileCount, & SortOpenFileCount, & EvalOpenFileCount, & TestOpenFileCount};
#line 170
static char const   *ShowRunOrder(PROC const   *proc ) ;
#line 170
static int SortRunOrder(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 170
static void EvalRunOrder(PROC const   *proc , VALUE *val ) ;
#line 170
static BOOL TestRunOrder(PROC const   *proc ) ;
#line 170 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnRunOrder  = 
#line 170
     {(char *)"runorder", (char *)"RunOrder", (int )(sizeof("RunOrder") - 1UL), 10,
    10, 1, (USEFLAG )0, & ShowRunOrder, & SortRunOrder, & EvalRunOrder, & TestRunOrder};
#line 173
static char const   *ShowCurrentDirectory(PROC const   *proc ) ;
#line 173
static int SortCurrentDirectory(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 173
static void EvalCurrentDirectory(PROC const   *proc , VALUE *val ) ;
#line 173
static BOOL TestCurrentDirectory(PROC const   *proc ) ;
#line 173 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnCurrentDirectory  = 
#line 173
     {(char *)"currentdirectory", (char *)"Current Dir", (int )(sizeof("Current Dir") - 1UL),
    25, 25, 0, (USEFLAG )8, & ShowCurrentDirectory, & SortCurrentDirectory, & EvalCurrentDirectory,
    & TestCurrentDirectory};
#line 176
static char const   *ShowRootDirectory(PROC const   *proc ) ;
#line 176
static int SortRootDirectory(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 176
static void EvalRootDirectory(PROC const   *proc , VALUE *val ) ;
#line 176
static BOOL TestRootDirectory(PROC const   *proc ) ;
#line 176 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnRootDirectory  = 
#line 176
     {(char *)"rootdirectory", (char *)"Root Dir", (int )(sizeof("Root Dir") - 1UL),
    25, 25, 0, (USEFLAG )1024, & ShowRootDirectory, & SortRootDirectory, & EvalRootDirectory,
    & TestRootDirectory};
#line 179
static char const   *ShowExecutable(PROC const   *proc ) ;
#line 179
static int SortExecutable(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 179
static void EvalExecutable(PROC const   *proc , VALUE *val ) ;
#line 179
static BOOL TestExecutable(PROC const   *proc ) ;
#line 179 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnExecutable  = 
#line 179
     {(char *)"executable", (char *)"Executable", (int )(sizeof("Executable") - 1UL),
    25, 25, 0, (USEFLAG )2048, & ShowExecutable, & SortExecutable, & EvalExecutable,
    & TestExecutable};
#line 182
static char const   *ShowSummary(PROC const   *proc ) ;
#line 182
static int SortSummary(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 182
static void EvalSummary(PROC const   *proc , VALUE *val ) ;
#line 182
static BOOL TestSummary(PROC const   *proc ) ;
#line 182 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnSummary  = 
#line 182
     {(char *)"summary", (char *)"Summary", (int )(sizeof("Summary") - 1UL), 14, 14,
    0, (USEFLAG )0, & ShowSummary, & SortSummary, & EvalSummary, & TestSummary};
#line 185
static char const   *ShowNice(PROC const   *proc ) ;
#line 185
static int SortNice(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 185
static void EvalNice(PROC const   *proc , VALUE *val ) ;
#line 185
static BOOL TestNice(PROC const   *proc ) ;
#line 185 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnNice  = 
#line 185
     {(char *)"nice", (char *)"Nic", (int )(sizeof("Nic") - 1UL), 3, 3, 1, (USEFLAG )0,
    & ShowNice, & SortNice, & EvalNice, & TestNice};
#line 188
static char const   *ShowSize(PROC const   *proc ) ;
#line 188
static int SortSize(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 188
static void EvalSize(PROC const   *proc , VALUE *val ) ;
#line 188
static BOOL TestSize(PROC const   *proc ) ;
#line 188 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnSize  = 
#line 188
     {(char *)"size", (char *)"Size", (int )(sizeof("Size") - 1UL), 5, 5, 1, (USEFLAG )0,
    & ShowSize, & SortSize, & EvalSize, & TestSize};
#line 191
static char const   *ShowRealTimer(PROC const   *proc ) ;
#line 191
static int SortRealTimer(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 191
static void EvalRealTimer(PROC const   *proc , VALUE *val ) ;
#line 191
static BOOL TestRealTimer(PROC const   *proc ) ;
#line 191 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnRealTimer  = 
#line 191
     {(char *)"realtimer", (char *)"RealTimer", (int )(sizeof("RealTimer") - 1UL), 10,
    10, 1, (USEFLAG )0, & ShowRealTimer, & SortRealTimer, & EvalRealTimer, & TestRealTimer};
#line 194
static char const   *ShowStdin(PROC const   *proc ) ;
#line 194
static int SortStdin(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 194
static void EvalStdin(PROC const   *proc , VALUE *val ) ;
#line 194
static BOOL TestStdin(PROC const   *proc ) ;
#line 194 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnStdin  = 
#line 194
     {(char *)"stdin", (char *)"Stdin", (int )(sizeof("Stdin") - 1UL), 20, 20, 0, (USEFLAG )64,
    & ShowStdin, & SortStdin, & EvalStdin, & TestStdin};
#line 197
static char const   *ShowStdout(PROC const   *proc ) ;
#line 197
static int SortStdout(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 197
static void EvalStdout(PROC const   *proc , VALUE *val ) ;
#line 197
static BOOL TestStdout(PROC const   *proc ) ;
#line 197 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnStdout  = 
#line 197
     {(char *)"stdout", (char *)"Stdout", (int )(sizeof("Stdout") - 1UL), 20, 20, 0,
    (USEFLAG )128, & ShowStdout, & SortStdout, & EvalStdout, & TestStdout};
#line 200
static char const   *ShowStderr(PROC const   *proc ) ;
#line 200
static int SortStderr(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 200
static void EvalStderr(PROC const   *proc , VALUE *val ) ;
#line 200
static BOOL TestStderr(PROC const   *proc ) ;
#line 200 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnStderr  = 
#line 200
     {(char *)"stderr", (char *)"Stderr", (int )(sizeof("Stderr") - 1UL), 20, 20, 0,
    (USEFLAG )256, & ShowStderr, & SortStderr, & EvalStderr, & TestStderr};
#line 203
static char const   *ShowStdio(PROC const   *proc ) ;
#line 203
static int SortStdio(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 203
static void EvalStdio(PROC const   *proc , VALUE *val ) ;
#line 203
static BOOL TestStdio(PROC const   *proc ) ;
#line 203 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnStdio  = 
#line 203
     {(char *)"stdio", (char *)"Stdio", (int )(sizeof("Stdio") - 1UL), 5, 5, 2, 448U,
    & ShowStdio, & SortStdio, & EvalStdio, & TestStdio};
#line 206
static char const   *ShowActive(PROC const   *proc ) ;
#line 206
static int SortActive(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 206
static void EvalActive(PROC const   *proc , VALUE *val ) ;
#line 206
static BOOL TestActive(PROC const   *proc ) ;
#line 206 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnActive  = 
#line 206
     {(char *)"active", (char *)"Active", (int )(sizeof("Active") - 1UL), 5, 5, 2, (USEFLAG )1,
    & ShowActive, & SortActive, & EvalActive, & TestActive};
#line 209
static char const   *ShowProcessor(PROC const   *proc ) ;
#line 209
static int SortProcessor(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 209
static void EvalProcessor(PROC const   *proc , VALUE *val ) ;
#line 209
static BOOL TestProcessor(PROC const   *proc ) ;
#line 209 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnProcessor  = 
#line 209
     {(char *)"processor", (char *)"Proc", (int )(sizeof("Proc") - 1UL), 4, 4, 1, (USEFLAG )0,
    & ShowProcessor, & SortProcessor, & EvalProcessor, & TestProcessor};
#line 212
static char const   *ShowStates(PROC const   *proc ) ;
#line 212
static int SortStates(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 212
static void EvalStates(PROC const   *proc , VALUE *val ) ;
#line 212
static BOOL TestStates(PROC const   *proc ) ;
#line 212 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN ColumnStates  = 
#line 212
     {(char *)"states", (char *)"States", (int )(sizeof("States") - 1UL), 10, 10, 0,
    (USEFLAG )32768, & ShowStates, & SortStates, & EvalStates, & TestStates};
#line 220 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN *columnTable[60]  = 
#line 220
  {      & ColumnPid,      & ColumnTid,      & ColumnState,      & ColumnParentPid, 
        & ColumnSystemTime,      & ColumnUserTime,      & ColumnRunTime,      & ColumnChildRunTime, 
        & ColumnPageSwaps,      & ColumnChildPageSwaps,      & ColumnEip,      & ColumnEsp, 
        & ColumnWaitChannel,      & ColumnWaitSymbol,      & ColumnProgram,      & ColumnCommand, 
        & ColumnEnvironment,      & ColumnProcessGroup,      & ColumnTtyProcessGroup,      & ColumnThreadCount, 
        & ColumnIdleTime,      & ColumnDeadTime,      & ColumnTtyName,      & ColumnTtyDevice, 
        & ColumnUserName,      & ColumnGroupName,      & ColumnUserId,      & ColumnGroupId, 
        & ColumnPercentCpu,      & ColumnPercentMemory,      & ColumnRss,      & ColumnStartTime, 
        & ColumnAge,      & ColumnFlags,      & ColumnPageFaults,      & ColumnMinorPageFaults, 
        & ColumnMajorPageFaults,      & ColumnSignalCatch,      & ColumnSignalIgnore,      & ColumnSignalBlock, 
        & ColumnOpenFileCount,      & ColumnRunOrder,      & ColumnCurrentDirectory,      & ColumnRootDirectory, 
        & ColumnExecutable,      & ColumnSummary,      & ColumnNice,      & ColumnPriority, 
        & ColumnRealTimePriority,      & ColumnPolicy,      & ColumnProcessor,      & ColumnSize, 
        & ColumnRealTimer,      & ColumnStdin,      & ColumnStdout,      & ColumnStderr, 
        & ColumnStdio,      & ColumnActive,      & ColumnStates,      (COLUMN *)((void *)0)};
#line 288 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static COLUMN *defaultColumns[8]  = 
#line 288
  {      & ColumnPid,      & ColumnParentPid,      & ColumnTtyName,      & ColumnUserName, 
        & ColumnSummary,      & ColumnRunTime,      & ColumnCommand,      (COLUMN *)((void *)0)};
#line 304 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char showBuffer[256]  ;
#line 310
static void TicksToString(char *buf___3 , long ticks ) ;
#line 316 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
void DefaultColumnWidths(void) 
{ 
  COLUMN **columnPtr ;
  COLUMN *column ;

  {
#line 322
  columnPtr = columnTable;
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;
#line 322
    if (! *columnPtr) {
#line 322
      goto while_break;
    }
#line 324
    column = *columnPtr;
#line 326
    column->width = column->initWidth;
#line 322
    columnPtr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 328
  return;
}
}
#line 334 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
void ListColumns(void) 
{ 
  COLUMN **columnPtr ;
  COLUMN const   *column ;

  {
  {
#line 340
  printf((char const   */* __restrict  */)"Column Name          Displayed As    Width\n");
#line 341
  printf((char const   */* __restrict  */)"-----------          ------------    -----\n");
#line 343
  columnPtr = columnTable;
  }
  {
#line 343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 343
    if (! *columnPtr) {
#line 343
      goto while_break;
    }
    {
#line 345
    column = (COLUMN const   *)*columnPtr;
#line 347
    printf((char const   */* __restrict  */)"%-20s %-15s %3d\n", column->name, column->heading,
           column->width);
#line 343
    columnPtr ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 351
  printf((char const   */* __restrict  */)"\n");
#line 352
  printf((char const   */* __restrict  */)"Note: Column names may be abbreviated.  They are used in\n");
#line 353
  printf((char const   */* __restrict  */)"several ways: displaying, sorting, and for the cond option.\n");
  }
#line 354
  return;
}
}
#line 360 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
void DefaultColumns(void) 
{ 
  COLUMN **src ;
  COLUMN **dest ;
  COLUMN **tmp ;
  COLUMN **tmp___0 ;

  {
#line 366
  dest = showList;
#line 367
  src = defaultColumns;
#line 368
  showCount = 0;
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! *src) {
#line 370
      goto while_break;
    }
#line 372
    tmp = dest;
#line 372
    dest ++;
#line 372
    tmp___0 = src;
#line 372
    src ++;
#line 372
    *tmp = *tmp___0;
#line 373
    showCount ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 375
  return;
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
COLUMN *FindColumn(char const   *name ) 
{ 
  COLUMN **columnPtr ;
  COLUMN *column ;
  COLUMN *match ;
  int count ;
  int len ;
  int nameLength ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 393
  match = (COLUMN *)((void *)0);
#line 394
  count = 0;
#line 396
  tmp = strlen(name);
#line 396
  nameLength = (int )tmp;
#line 398
  columnPtr = columnTable;
  }
  {
#line 398
  while (1) {
    while_continue: /* CIL Label */ ;
#line 398
    if (! *columnPtr) {
#line 398
      goto while_break;
    }
    {
#line 400
    column = *columnPtr;
#line 402
    tmp___0 = strlen((char const   *)column->name);
#line 402
    len = (int )tmp___0;
    }
#line 404
    if (len < nameLength) {
#line 406
      goto __Cont;
    } else {
      {
#line 404
      tmp___1 = memcmp((void const   *)name, (void const   *)column->name, (size_t )nameLength);
      }
#line 404
      if (tmp___1 != 0) {
#line 406
        goto __Cont;
      }
    }
#line 408
    if (len == nameLength) {
#line 409
      return (column);
    }
#line 411
    match = column;
#line 412
    count ++;
    __Cont: /* CIL Label */ 
#line 398
    columnPtr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 415
  if (count == 1) {
#line 416
    return (match);
  }
#line 418
  return ((COLUMN *)((void *)0));
}
}
#line 428 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortPid(PROC const   *proc1 , PROC const   *proc2 ) 
{ 


  {
#line 431
  return ((int )(proc1->pid - proc2->pid));
}
}
#line 435 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortTid(PROC const   *proc1 , PROC const   *proc2 ) 
{ 


  {
#line 438
  if (proc1->tid == 0xffffffffffffffffUL) {
#line 438
    if (proc2->tid != 0xffffffffffffffffUL) {
#line 439
      return (-1);
    }
  }
#line 441
  if (proc1->tid != 0xffffffffffffffffUL) {
#line 441
    if (proc2->tid == 0xffffffffffffffffUL) {
#line 442
      return (1);
    }
  }
#line 444
  if (proc1->tid == (pthread_t const   )proc1->pid) {
#line 444
    if (proc2->tid != (pthread_t const   )proc2->pid) {
#line 445
      return (-1);
    }
  }
#line 447
  if (proc1->tid != (pthread_t const   )proc1->pid) {
#line 447
    if (proc2->tid == (pthread_t const   )proc2->pid) {
#line 448
      return (1);
    }
  }
#line 450
  if (proc1->tid < proc2->tid) {
#line 451
    return (-1);
  }
#line 453
  if (proc1->tid > proc2->tid) {
#line 454
    return (1);
  }
#line 456
  return (0);
}
}
#line 460 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortState(PROC const   *proc1 , PROC const   *proc2 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 463
  tmp = GetState(proc1);
#line 463
  tmp___0 = GetState(proc2);
  }
#line 463
  return (tmp - tmp___0);
}
}
#line 467 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortStates(PROC const   *proc1 , PROC const   *proc2 ) 
{ 
  int tmp ;

  {
  {
#line 470
  tmp = strcmp((char const   *)(proc1->states), (char const   *)(proc2->states));
  }
#line 470
  return (tmp);
}
}
#line 474 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortParentPid(PROC const   *proc1 , PROC const   *proc2 ) 
{ 


  {
#line 477
  return ((int )(proc1->parentPid - proc2->parentPid));
}
}
#line 481 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortThreadCount(PROC const   *proc1 , PROC const   *proc2 ) 
{ 


  {
#line 484
  return ((int )(proc1->threadCount - proc2->threadCount));
}
}
#line 488 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortSystemTime(PROC const   *proc1 , PROC const   *proc2 ) 
{ 


  {
#line 491
  return ((int )(proc1->systemRunTime - proc2->systemRunTime));
}
}
#line 495 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortUserTime(PROC const   *proc1 , PROC const   *proc2 ) 
{ 


  {
#line 498
  return ((int )(proc1->userRunTime - proc2->userRunTime));
}
}
#line 502 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortRunTime(PROC const   *proc1 , PROC const   *proc2 ) 
{ 


  {
#line 505
  return ((int )((proc1->systemRunTime + proc1->userRunTime) - (proc2->systemRunTime + proc2->userRunTime)));
}
}
#line 509 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortChildRunTime(PROC const   *proc1 , PROC const   *proc2 ) 
{ 


  {
#line 512
  return ((int )((proc1->childSystemRunTime + proc1->childUserRunTime) - (proc2->childSystemRunTime + proc2->childUserRunTime)));
}
}
#line 517 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortPageSwaps(PROC const   *proc1 , PROC const   *proc2 ) 
{ 


  {
#line 520
  return ((int )(proc1->pagesSwapped - proc2->pagesSwapped));
}
}
#line 524 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortChildPageSwaps(PROC const   *proc1 , PROC const   *proc2 ) 
{ 


  {
#line 527
  return ((int )(proc1->childPagesSwapped - proc2->childPagesSwapped));
}
}
#line 531 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortEip(PROC const   *proc1 , PROC const   *proc2 ) 
{ 


  {
#line 534
  return ((int )(proc1->eip - proc2->eip));
}
}
#line 538 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortEsp(PROC const   *proc1 , PROC const   *proc2 ) 
{ 


  {
#line 541
  return ((int )(proc1->esp - proc2->esp));
}
}
#line 545 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortWaitChannel(PROC const   *proc1 , PROC const   *proc2 ) 
{ 


  {
#line 548
  return ((int )(proc1->waitChan - proc2->waitChan));
}
}
#line 552 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortWaitSymbol(PROC const   *proc1 , PROC const   *proc2 ) 
{ 
  int tmp ;

  {
  {
#line 555
  tmp = strcmp((char const   *)(proc1->waitChanSymbol), (char const   *)(proc2->waitChanSymbol));
  }
#line 555
  return (tmp);
}
}
#line 559 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortProgram(PROC const   *proc1 , PROC const   *proc2 ) 
{ 
  int tmp ;

  {
  {
#line 562
  tmp = strcmp((char const   *)(proc1->program), (char const   *)(proc2->program));
  }
#line 562
  return (tmp);
}
}
#line 566 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortCommand(PROC const   *proc1 , PROC const   *proc2 ) 
{ 
  int tmp ;

  {
  {
#line 569
  tmp = strcmp((char const   *)proc1->command, (char const   *)proc2->command);
  }
#line 569
  return (tmp);
}
}
#line 573 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortEnvironment(PROC const   *proc1 , PROC const   *proc2 ) 
{ 
  int tmp ;

  {
  {
#line 576
  tmp = strcmp((char const   *)proc1->environment, (char const   *)proc2->environment);
  }
#line 576
  return (tmp);
}
}
#line 580 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortProcessGroup(PROC const   *proc1 , PROC const   *proc2 ) 
{ 


  {
#line 583
  return ((int )(proc1->processGroup - proc2->processGroup));
}
}
#line 587 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortTtyProcessGroup(PROC const   *proc1 , PROC const   *proc2 ) 
{ 


  {
#line 590
  return ((int )(proc1->ttyProcessGroup - proc2->ttyProcessGroup));
}
}
#line 594 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortIdleTime(PROC const   *proc1 , PROC const   *proc2 ) 
{ 
  time_t tmp ;
  time_t tmp___0 ;

  {
  {
#line 597
  tmp = GetLastActiveTime(proc2);
#line 597
  tmp___0 = GetLastActiveTime(proc1);
  }
#line 597
  return ((int )(tmp - tmp___0));
}
}
#line 601 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortDeadTime(PROC const   *proc1 , PROC const   *proc2 ) 
{ 


  {
#line 604
  return ((int )(proc2->deathTime - proc1->deathTime));
}
}
#line 608 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortTtyName(PROC const   *proc1 , PROC const   *proc2 ) 
{ 
  char const   *name1 ;
  char const   *name2 ;
  int tmp ;

  {
#line 614
  if (proc1->ttyDevice == proc2->ttyDevice) {
#line 615
    return (0);
  }
  {
#line 617
  name1 = FindDeviceName((dev_t )proc1->ttyDevice);
#line 618
  name2 = FindDeviceName((dev_t )proc2->ttyDevice);
  }
#line 620
  if (name1) {
#line 620
    if (name2) {
      {
#line 621
      tmp = strcmp(name1, name2);
      }
#line 621
      return (tmp);
    }
  }
#line 623
  if (! name1) {
#line 623
    if (name2) {
#line 624
      return (-1);
    }
  }
#line 626
  if (name1) {
#line 626
    if (! name2) {
#line 627
      return (1);
    }
  }
#line 629
  return ((int )((long )proc1->ttyDevice - (long )proc2->ttyDevice));
}
}
#line 633 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortTtyDevice(PROC const   *proc1 , PROC const   *proc2 ) 
{ 


  {
#line 636
  return ((int )((long )proc1->ttyDevice - (long )proc2->ttyDevice));
}
}
#line 640 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortUserName(PROC const   *proc1 , PROC const   *proc2 ) 
{ 
  char const   *name1 ;
  char const   *name2 ;
  int tmp ;

  {
#line 646
  if (proc1->uid == proc2->uid) {
#line 647
    return (0);
  }
  {
#line 649
  name1 = FindUserName((uid_t )proc1->uid);
#line 650
  name2 = FindUserName((uid_t )proc2->uid);
  }
#line 652
  if (name1) {
#line 652
    if (name2) {
      {
#line 653
      tmp = strcmp(name1, name2);
      }
#line 653
      return (tmp);
    }
  }
#line 655
  if (! name1) {
#line 655
    if (name2) {
#line 656
      return (-1);
    }
  }
#line 658
  if (name1) {
#line 658
    if (! name2) {
#line 659
      return (1);
    }
  }
#line 661
  return ((int )((long )proc1->uid - (long )proc2->uid));
}
}
#line 665 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortUserId(PROC const   *proc1 , PROC const   *proc2 ) 
{ 


  {
#line 668
  return ((int )((long )proc1->uid - (long )proc2->uid));
}
}
#line 672 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortGroupName(PROC const   *proc1 , PROC const   *proc2 ) 
{ 
  char const   *name1 ;
  char const   *name2 ;
  int tmp ;

  {
#line 678
  if (proc1->gid == proc2->gid) {
#line 679
    return (0);
  }
  {
#line 681
  name1 = FindGroupName((gid_t )proc1->gid);
#line 682
  name2 = FindGroupName((gid_t )proc2->gid);
  }
#line 684
  if (name1) {
#line 684
    if (name2) {
      {
#line 685
      tmp = strcmp(name1, name2);
      }
#line 685
      return (tmp);
    }
  }
#line 687
  if (! name1) {
#line 687
    if (name2) {
#line 688
      return (-1);
    }
  }
#line 690
  if (name1) {
#line 690
    if (! name2) {
#line 691
      return (1);
    }
  }
#line 693
  return ((int )((long )proc1->gid - (long )proc2->gid));
}
}
#line 697 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortGroupId(PROC const   *proc1 , PROC const   *proc2 ) 
{ 


  {
#line 700
  return ((int )((long )proc1->gid - (long )proc2->gid));
}
}
#line 704 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortPercentCpu(PROC const   *proc1 , PROC const   *proc2 ) 
{ 


  {
#line 707
  return ((int )(proc1->percentCpu - proc2->percentCpu));
}
}
#line 711 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortPercentMemory(PROC const   *proc1 , PROC const   *proc2 ) 
{ 


  {
#line 714
  return ((int )(proc1->percentMemory - proc2->percentMemory));
}
}
#line 718 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortRss(PROC const   *proc1 , PROC const   *proc2 ) 
{ 


  {
#line 721
  return ((int )(proc1->rss - proc2->rss));
}
}
#line 725 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortStartTime(PROC const   *proc1 , PROC const   *proc2 ) 
{ 


  {
#line 728
  return ((int )(proc1->startTimeTicks - proc2->startTimeTicks));
}
}
#line 732 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortAge(PROC const   *proc1 , PROC const   *proc2 ) 
{ 


  {
#line 735
  return ((int )(proc2->startTimeTicks - proc1->startTimeTicks));
}
}
#line 739 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortFlags(PROC const   *proc1 , PROC const   *proc2 ) 
{ 


  {
#line 742
  return ((int )(proc1->flags - proc2->flags));
}
}
#line 746 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortPageFaults(PROC const   *proc1 , PROC const   *proc2 ) 
{ 


  {
#line 749
  return ((int )((proc1->minorFaults + proc1->majorFaults) - (proc2->minorFaults + proc2->majorFaults)));
}
}
#line 754 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortMinorPageFaults(PROC const   *proc1 , PROC const   *proc2 ) 
{ 


  {
#line 757
  return ((int )(proc1->minorFaults - proc2->minorFaults));
}
}
#line 761 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortMajorPageFaults(PROC const   *proc1 , PROC const   *proc2 ) 
{ 


  {
#line 764
  return ((int )(proc1->majorFaults - proc2->majorFaults));
}
}
#line 768 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortSignalCatch(PROC const   *proc1 , PROC const   *proc2 ) 
{ 


  {
#line 771
  return ((int )(proc1->sigCatch - proc2->sigCatch));
}
}
#line 775 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortSignalIgnore(PROC const   *proc1 , PROC const   *proc2 ) 
{ 


  {
#line 778
  return ((int )(proc1->sigIgnore - proc2->sigIgnore));
}
}
#line 782 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortSignalBlock(PROC const   *proc1 , PROC const   *proc2 ) 
{ 


  {
#line 785
  return ((int )(proc1->sigBlock - proc2->sigBlock));
}
}
#line 789 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortOpenFileCount(PROC const   *proc1 , PROC const   *proc2 ) 
{ 


  {
#line 792
  if (proc1->openFiles < proc2->openFiles) {
#line 793
    return (-1);
  }
#line 795
  if (proc1->openFiles > proc2->openFiles) {
#line 796
    return (1);
  }
#line 798
  return (0);
}
}
#line 802 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortRunOrder(PROC const   *proc1 , PROC const   *proc2 ) 
{ 
  ULONG runOrder1 ;
  ULONG tmp ;
  ULONG runOrder2 ;
  ULONG tmp___0 ;

  {
  {
#line 805
  tmp = GetRunOrder(proc1);
#line 805
  runOrder1 = tmp;
#line 806
  tmp___0 = GetRunOrder(proc2);
#line 806
  runOrder2 = tmp___0;
  }
#line 808
  if (runOrder1 < runOrder2) {
#line 809
    return (-1);
  }
#line 811
  if (runOrder1 > runOrder2) {
#line 812
    return (1);
  }
#line 814
  return (0);
}
}
#line 818 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortCurrentDirectory(PROC const   *proc1 , PROC const   *proc2 ) 
{ 
  int tmp ;

  {
  {
#line 821
  tmp = strcmp((char const   *)proc1->cwdPath, (char const   *)proc2->cwdPath);
  }
#line 821
  return (tmp);
}
}
#line 825 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortRootDirectory(PROC const   *proc1 , PROC const   *proc2 ) 
{ 
  int tmp ;

  {
  {
#line 828
  tmp = strcmp((char const   *)proc1->rootPath, (char const   *)proc2->rootPath);
  }
#line 828
  return (tmp);
}
}
#line 832 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortExecutable(PROC const   *proc1 , PROC const   *proc2 ) 
{ 
  int tmp ;

  {
  {
#line 835
  tmp = strcmp((char const   *)proc1->execPath, (char const   *)proc2->execPath);
  }
#line 835
  return (tmp);
}
}
#line 839 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortStdin(PROC const   *proc1 , PROC const   *proc2 ) 
{ 
  int tmp ;

  {
  {
#line 842
  tmp = strcmp((char const   *)proc1->stdioPaths[0], (char const   *)proc2->stdioPaths[0]);
  }
#line 842
  return (tmp);
}
}
#line 846 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortStdout(PROC const   *proc1 , PROC const   *proc2 ) 
{ 
  int tmp ;

  {
  {
#line 849
  tmp = strcmp((char const   *)proc1->stdioPaths[1], (char const   *)proc2->stdioPaths[1]);
  }
#line 849
  return (tmp);
}
}
#line 853 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortStderr(PROC const   *proc1 , PROC const   *proc2 ) 
{ 
  int tmp ;

  {
  {
#line 856
  tmp = strcmp((char const   *)proc1->stdioPaths[2], (char const   *)proc2->stdioPaths[2]);
  }
#line 856
  return (tmp);
}
}
#line 860 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortStdio(PROC const   *proc1 , PROC const   *proc2 ) 
{ 
  char buf___3[8] ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 865
  tmp = ShowStdio(proc1);
#line 865
  strcpy((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)tmp);
#line 867
  tmp___0 = ShowStdio(proc2);
#line 867
  tmp___1 = strcmp((char const   *)(buf___3), tmp___0);
  }
#line 867
  return (tmp___1);
}
}
#line 871 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortSummary(PROC const   *proc1 , PROC const   *proc2 ) 
{ 
  char buf___3[30] ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 876
  tmp = ShowSummary(proc1);
#line 876
  strcpy((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)tmp);
#line 878
  tmp___0 = ShowSummary(proc2);
#line 878
  tmp___1 = strcmp((char const   *)(buf___3), tmp___0);
  }
#line 878
  return (tmp___1);
}
}
#line 882 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortPriority(PROC const   *proc1 , PROC const   *proc2 ) 
{ 


  {
#line 885
  if (proc1->priority < proc2->priority) {
#line 886
    return (-1);
  }
#line 888
  if (proc1->priority > proc2->priority) {
#line 889
    return (1);
  }
#line 891
  return (0);
}
}
#line 895 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortPolicy(PROC const   *proc1 , PROC const   *proc2 ) 
{ 


  {
#line 898
  if (proc1->policy < proc2->policy) {
#line 899
    return (-1);
  }
#line 901
  if (proc1->policy > proc2->policy) {
#line 902
    return (1);
  }
#line 904
  return (0);
}
}
#line 908 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortRealTimePriority(PROC const   *proc1 , PROC const   *proc2 ) 
{ 


  {
#line 911
  if (proc1->realTimePriority < proc2->realTimePriority) {
#line 912
    return (-1);
  }
#line 914
  if (proc1->realTimePriority > proc2->realTimePriority) {
#line 915
    return (1);
  }
#line 917
  return (0);
}
}
#line 921 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortNice(PROC const   *proc1 , PROC const   *proc2 ) 
{ 


  {
#line 924
  if (proc1->nice < proc2->nice) {
#line 925
    return (-1);
  }
#line 927
  if (proc1->nice > proc2->nice) {
#line 928
    return (1);
  }
#line 930
  return (0);
}
}
#line 934 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortProcessor(PROC const   *proc1 , PROC const   *proc2 ) 
{ 


  {
#line 937
  if (proc1->processor < proc2->processor) {
#line 938
    return (-1);
  }
#line 940
  if (proc1->processor > proc2->processor) {
#line 941
    return (1);
  }
#line 943
  return (0);
}
}
#line 947 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortSize(PROC const   *proc1 , PROC const   *proc2 ) 
{ 


  {
#line 950
  if (proc1->virtualSize < proc2->virtualSize) {
#line 951
    return (-1);
  }
#line 953
  if (proc1->virtualSize > proc2->virtualSize) {
#line 954
    return (1);
  }
#line 956
  return (0);
}
}
#line 960 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortRealTimer(PROC const   *proc1 , PROC const   *proc2 ) 
{ 


  {
#line 963
  if (proc1->itRealValue < proc2->itRealValue) {
#line 964
    return (-1);
  }
#line 966
  if (proc1->itRealValue > proc2->itRealValue) {
#line 967
    return (1);
  }
#line 969
  return (0);
}
}
#line 973 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static int SortActive(PROC const   *proc1 , PROC const   *proc2 ) 
{ 
  BOOL isActive1 ;
  BOOL tmp ;
  BOOL isActive2 ;
  BOOL tmp___0 ;

  {
  {
#line 976
  tmp = GetIsActive(proc1);
#line 976
  isActive1 = tmp;
#line 977
  tmp___0 = GetIsActive(proc2);
#line 977
  isActive2 = tmp___0;
  }
#line 979
  if (! isActive1) {
#line 979
    if (isActive2) {
#line 980
      return (-1);
    }
  }
#line 982
  if (isActive1) {
#line 982
    if (! isActive2) {
#line 983
      return (1);
    }
  }
#line 985
  return (0);
}
}
#line 993 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalPid(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 996
  val->type = 2;
#line 997
  val->intVal = (long )proc->pid;
#line 998
  return;
}
}
#line 1001 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalTid(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1004
  val->type = 2;
#line 1005
  val->intVal = (long )proc->tid;
#line 1006
  return;
}
}
#line 1009 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalState(PROC const   *proc , VALUE *val ) 
{ 
  char *cp ;
  int tmp ;

  {
  {
#line 1014
  cp = AllocTempString(2);
#line 1015
  tmp = GetState(proc);
#line 1015
  *(cp + 0) = (char )tmp;
#line 1016
  *(cp + 1) = (char )'\000';
#line 1018
  val->type = 3;
#line 1019
  val->strVal = (char const   *)cp;
  }
#line 1020
  return;
}
}
#line 1023 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalStates(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1026
  val->type = 3;
#line 1027
  val->strVal = (char const   *)(proc->states);
#line 1028
  return;
}
}
#line 1031 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalParentPid(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1034
  val->type = 2;
#line 1035
  val->intVal = (long )proc->parentPid;
#line 1036
  return;
}
}
#line 1039 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalThreadCount(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1042
  val->type = 2;
#line 1043
  val->intVal = (long )proc->threadCount;
#line 1044
  return;
}
}
#line 1047 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalSystemTime(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1050
  val->type = 2;
#line 1051
  val->intVal = (long )proc->systemRunTime;
#line 1052
  return;
}
}
#line 1055 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalUserTime(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1058
  val->type = 2;
#line 1059
  val->intVal = (long )proc->userRunTime;
#line 1060
  return;
}
}
#line 1063 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalRunTime(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1066
  val->type = 2;
#line 1067
  val->intVal = (long )(proc->systemRunTime + proc->userRunTime);
#line 1068
  return;
}
}
#line 1071 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalChildRunTime(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1074
  val->type = 2;
#line 1075
  val->intVal = (long )(proc->childSystemRunTime + proc->childUserRunTime);
#line 1076
  return;
}
}
#line 1079 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalPageSwaps(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1082
  val->type = 2;
#line 1083
  val->intVal = (long )proc->pagesSwapped;
#line 1084
  return;
}
}
#line 1087 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalChildPageSwaps(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1090
  val->type = 2;
#line 1091
  val->intVal = (long )proc->childPagesSwapped;
#line 1092
  return;
}
}
#line 1095 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalEip(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1098
  val->type = 2;
#line 1099
  val->intVal = (long )proc->eip;
#line 1100
  return;
}
}
#line 1103 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalEsp(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1106
  val->type = 2;
#line 1107
  val->intVal = (long )proc->eip;
#line 1108
  return;
}
}
#line 1111 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalWaitChannel(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1114
  val->type = 2;
#line 1115
  val->intVal = (long )proc->waitChan;
#line 1116
  return;
}
}
#line 1119 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalWaitSymbol(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1122
  val->type = 3;
#line 1123
  val->strVal = (char const   *)(proc->waitChanSymbol);
#line 1124
  return;
}
}
#line 1127 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalProgram(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1130
  val->type = 3;
#line 1131
  val->strVal = (char const   *)(proc->program);
#line 1132
  return;
}
}
#line 1135 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalCommand(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1138
  val->type = 3;
#line 1139
  val->strVal = (char const   *)proc->command;
#line 1140
  return;
}
}
#line 1143 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalEnvironment(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1146
  val->type = 3;
#line 1147
  val->strVal = (char const   *)proc->environment;
#line 1148
  return;
}
}
#line 1151 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalProcessGroup(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1154
  val->type = 2;
#line 1155
  val->intVal = (long )proc->processGroup;
#line 1156
  return;
}
}
#line 1159 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalTtyProcessGroup(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1162
  val->type = 2;
#line 1163
  val->intVal = (long )proc->ttyProcessGroup;
#line 1164
  return;
}
}
#line 1167 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalIdleTime(PROC const   *proc , VALUE *val ) 
{ 
  time_t tmp ;

  {
  {
#line 1170
  val->type = 2;
#line 1171
  tmp = GetLastActiveTime(proc);
#line 1171
  val->intVal = (currentTime - tmp) / 60L;
  }
#line 1172
  return;
}
}
#line 1175 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalDeadTime(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1178
  val->type = 2;
#line 1179
  val->intVal = 0L;
#line 1181
  if (proc->deathTime > 0L) {
#line 1182
    val->intVal = (currentTime - (time_t )proc->deathTime) / 60L;
  }
#line 1183
  return;
}
}
#line 1186 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalTtyName(PROC const   *proc , VALUE *val ) 
{ 


  {
  {
#line 1189
  val->type = 3;
#line 1190
  val->strVal = FindDeviceName((dev_t )proc->ttyDevice);
  }
#line 1192
  if ((unsigned long )val->strVal == (unsigned long )((void *)0)) {
#line 1193
    val->strVal = "";
  }
#line 1194
  return;
}
}
#line 1197 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalTtyDevice(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1200
  val->type = 2;
#line 1201
  val->intVal = (long )proc->ttyDevice;
#line 1202
  return;
}
}
#line 1205 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalUserName(PROC const   *proc , VALUE *val ) 
{ 


  {
  {
#line 1208
  val->type = 3;
#line 1209
  val->strVal = FindUserName((uid_t )proc->uid);
  }
#line 1211
  if ((unsigned long )val->strVal == (unsigned long )((void *)0)) {
#line 1212
    val->strVal = "";
  }
#line 1213
  return;
}
}
#line 1216 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalGroupName(PROC const   *proc , VALUE *val ) 
{ 


  {
  {
#line 1219
  val->type = 3;
#line 1220
  val->strVal = FindGroupName((gid_t )proc->uid);
  }
#line 1222
  if ((unsigned long )val->strVal == (unsigned long )((void *)0)) {
#line 1223
    val->strVal = "";
  }
#line 1224
  return;
}
}
#line 1227 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalUserId(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1230
  val->type = 2;
#line 1231
  val->intVal = (long )proc->uid;
#line 1232
  return;
}
}
#line 1235 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalGroupId(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1238
  val->type = 2;
#line 1239
  val->intVal = (long )proc->gid;
#line 1240
  return;
}
}
#line 1243 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalPercentCpu(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1246
  val->type = 2;
#line 1247
  val->intVal = (long )proc->percentCpu;
#line 1248
  return;
}
}
#line 1251 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalPercentMemory(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1254
  val->type = 2;
#line 1255
  val->intVal = (long )proc->percentMemory;
#line 1256
  return;
}
}
#line 1259 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalRss(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1262
  val->type = 2;
#line 1263
  val->intVal = (long )(proc->rss * 4L);
#line 1264
  return;
}
}
#line 1267 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalStartTime(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1270
  val->type = 2;
#line 1271
  val->intVal = (long )proc->startTimeClock;
#line 1272
  return;
}
}
#line 1275 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalAge(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1278
  val->type = 2;
#line 1279
  val->intVal = currentTime - (time_t )proc->startTimeClock;
#line 1281
  if (val->intVal < 0L) {
#line 1282
    val->intVal = 0L;
  }
#line 1283
  return;
}
}
#line 1286 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalFlags(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1289
  val->type = 2;
#line 1290
  val->intVal = (long )proc->flags;
#line 1291
  return;
}
}
#line 1294 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalPageFaults(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1297
  val->type = 2;
#line 1298
  val->intVal = (long )(proc->minorFaults + proc->majorFaults);
#line 1299
  return;
}
}
#line 1302 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalMinorPageFaults(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1305
  val->type = 2;
#line 1306
  val->intVal = (long )proc->minorFaults;
#line 1307
  return;
}
}
#line 1310 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalMajorPageFaults(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1313
  val->type = 2;
#line 1314
  val->intVal = (long )proc->majorFaults;
#line 1315
  return;
}
}
#line 1318 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalSignalCatch(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1321
  val->type = 2;
#line 1322
  val->intVal = (long )proc->sigCatch;
#line 1323
  return;
}
}
#line 1326 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalSignalIgnore(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1329
  val->type = 2;
#line 1330
  val->intVal = (long )proc->sigIgnore;
#line 1331
  return;
}
}
#line 1334 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalSignalBlock(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1337
  val->type = 2;
#line 1338
  val->intVal = (long )proc->sigBlock;
#line 1339
  return;
}
}
#line 1342 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalOpenFileCount(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1345
  val->type = 2;
#line 1346
  val->intVal = (long )proc->openFiles;
#line 1347
  return;
}
}
#line 1350 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalRunOrder(PROC const   *proc , VALUE *val ) 
{ 
  ULONG tmp ;

  {
  {
#line 1353
  val->type = 2;
#line 1354
  tmp = GetRunOrder(proc);
#line 1354
  val->intVal = (long )tmp;
  }
#line 1355
  return;
}
}
#line 1358 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalCurrentDirectory(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1361
  val->type = 3;
#line 1362
  val->strVal = (char const   *)proc->cwdPath;
#line 1363
  return;
}
}
#line 1366 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalRootDirectory(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1369
  val->type = 3;
#line 1370
  val->strVal = (char const   *)proc->rootPath;
#line 1371
  return;
}
}
#line 1374 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalExecutable(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1377
  val->type = 3;
#line 1378
  val->strVal = (char const   *)proc->execPath;
#line 1379
  return;
}
}
#line 1382 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalStdin(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1385
  val->type = 3;
#line 1386
  val->strVal = (char const   *)proc->stdioPaths[0];
#line 1387
  return;
}
}
#line 1390 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalStdout(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1393
  val->type = 3;
#line 1394
  val->strVal = (char const   *)proc->stdioPaths[1];
#line 1395
  return;
}
}
#line 1398 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalStderr(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1401
  val->type = 3;
#line 1402
  val->strVal = (char const   *)proc->stdioPaths[2];
#line 1403
  return;
}
}
#line 1406 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalStdio(PROC const   *proc , VALUE *val ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;

  {
  {
#line 1409
  val->type = 3;
#line 1410
  tmp = ShowStdio(proc);
#line 1410
  tmp___0 = CopyTempString(tmp);
#line 1410
  val->strVal = (char const   *)tmp___0;
  }
#line 1411
  return;
}
}
#line 1414 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalSummary(PROC const   *proc , VALUE *val ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;

  {
  {
#line 1417
  val->type = 3;
#line 1418
  tmp = ShowSummary(proc);
#line 1418
  tmp___0 = CopyTempString(tmp);
#line 1418
  val->strVal = (char const   *)tmp___0;
  }
#line 1419
  return;
}
}
#line 1422 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalPolicy(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1425
  val->type = 2;
#line 1426
  val->intVal = (long )proc->policy;
#line 1427
  return;
}
}
#line 1430 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalPriority(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1433
  val->type = 2;
#line 1434
  val->intVal = (long )proc->priority;
#line 1435
  return;
}
}
#line 1438 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalRealTimePriority(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1441
  val->type = 2;
#line 1442
  val->intVal = (long )proc->realTimePriority;
#line 1443
  return;
}
}
#line 1446 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalNice(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1449
  val->type = 2;
#line 1450
  val->intVal = (long )proc->nice;
#line 1451
  return;
}
}
#line 1454 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalProcessor(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1457
  val->type = 2;
#line 1458
  val->intVal = (long )proc->processor;
#line 1459
  return;
}
}
#line 1462 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalSize(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1465
  val->type = 2;
#line 1466
  val->intVal = (long )((proc->virtualSize + 1023L) / 1024L);
#line 1467
  return;
}
}
#line 1470 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalRealTimer(PROC const   *proc , VALUE *val ) 
{ 


  {
#line 1473
  val->type = 2;
#line 1474
  val->intVal = (long )proc->itRealValue;
#line 1475
  return;
}
}
#line 1478 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void EvalActive(PROC const   *proc , VALUE *val ) 
{ 
  BOOL tmp ;

  {
  {
#line 1481
  val->type = 5;
#line 1482
  tmp = GetIsActive(proc);
#line 1482
  val->intVal = (long )tmp;
  }
#line 1483
  return;
}
}
#line 1492 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestPid(PROC const   *proc ) 
{ 


  {
#line 1495
  return (proc->pid != 0);
}
}
#line 1499 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestTid(PROC const   *proc ) 
{ 


  {
#line 1502
  return (proc->tid != 0xffffffffffffffffUL);
}
}
#line 1506 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestState(PROC const   *proc ) 
{ 
  int state ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1509
  tmp = GetState(proc);
#line 1509
  state = tmp;
  }
#line 1511
  if (state != 90) {
#line 1511
    if (state != 32) {
#line 1511
      tmp___0 = 1;
    } else {
#line 1511
      tmp___0 = 0;
    }
  } else {
#line 1511
    tmp___0 = 0;
  }
#line 1511
  return (tmp___0);
}
}
#line 1515 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestStates(PROC const   *proc ) 
{ 
  BOOL tmp ;

  {
  {
#line 1523
  tmp = TestState(proc);
  }
#line 1523
  return (tmp);
}
}
#line 1527 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestThreadCount(PROC const   *proc ) 
{ 


  {
#line 1530
  return (proc->threadCount > 1);
}
}
#line 1534 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestParentPid(PROC const   *proc ) 
{ 
  int tmp ;

  {
#line 1537
  if (proc->parentPid) {
#line 1537
    if (proc->parentPid != 1) {
#line 1537
      tmp = 1;
    } else {
#line 1537
      tmp = 0;
    }
  } else {
#line 1537
    tmp = 0;
  }
#line 1537
  return (tmp);
}
}
#line 1541 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestSystemTime(PROC const   *proc ) 
{ 


  {
#line 1544
  return (proc->systemRunTime != 0L);
}
}
#line 1548 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestUserTime(PROC const   *proc ) 
{ 


  {
#line 1551
  return (proc->userRunTime != 0L);
}
}
#line 1555 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestRunTime(PROC const   *proc ) 
{ 
  int tmp ;

  {
#line 1558
  if (proc->systemRunTime != 0L) {
#line 1558
    tmp = 1;
  } else
#line 1558
  if (proc->userRunTime != 0L) {
#line 1558
    tmp = 1;
  } else {
#line 1558
    tmp = 0;
  }
#line 1558
  return (tmp);
}
}
#line 1562 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestChildRunTime(PROC const   *proc ) 
{ 
  int tmp ;

  {
#line 1565
  if (proc->childSystemRunTime != 0L) {
#line 1565
    tmp = 1;
  } else
#line 1565
  if (proc->childUserRunTime != 0L) {
#line 1565
    tmp = 1;
  } else {
#line 1565
    tmp = 0;
  }
#line 1565
  return (tmp);
}
}
#line 1569 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestPageSwaps(PROC const   *proc ) 
{ 


  {
#line 1572
  return (proc->pagesSwapped != 0UL);
}
}
#line 1576 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestChildPageSwaps(PROC const   *proc ) 
{ 


  {
#line 1579
  return (proc->childPagesSwapped != 0UL);
}
}
#line 1583 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestEip(PROC const   *proc ) 
{ 


  {
#line 1586
  return (proc->eip != 0UL);
}
}
#line 1590 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestEsp(PROC const   *proc ) 
{ 


  {
#line 1593
  return (proc->esp != 0UL);
}
}
#line 1597 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestWaitChannel(PROC const   *proc ) 
{ 


  {
#line 1600
  return (proc->waitChan != 0UL);
}
}
#line 1604 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestWaitSymbol(PROC const   *proc ) 
{ 


  {
#line 1607
  return ((int )proc->waitChanSymbol[0] != 0);
}
}
#line 1611 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestProgram(PROC const   *proc ) 
{ 


  {
#line 1614
  return ((int )proc->program[0] != 0);
}
}
#line 1618 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestCommand(PROC const   *proc ) 
{ 


  {
#line 1621
  return ((BOOL )proc->hasCommand);
}
}
#line 1625 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestEnvironment(PROC const   *proc ) 
{ 


  {
#line 1628
  return ((int )*(proc->environment + 0) != 0);
}
}
#line 1632 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestProcessGroup(PROC const   *proc ) 
{ 


  {
#line 1635
  return (proc->processGroup != 0);
}
}
#line 1639 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestTtyProcessGroup(PROC const   *proc ) 
{ 
  int tmp ;

  {
#line 1642
  if (proc->ttyProcessGroup != 0) {
#line 1642
    if (proc->ttyProcessGroup != -1) {
#line 1642
      tmp = 1;
    } else {
#line 1642
      tmp = 0;
    }
  } else {
#line 1642
    tmp = 0;
  }
#line 1642
  return (tmp);
}
}
#line 1646 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestIdleTime(PROC const   *proc ) 
{ 
  time_t tmp ;

  {
  {
#line 1649
  tmp = GetLastActiveTime(proc);
  }
#line 1649
  return (tmp != currentTime);
}
}
#line 1653 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestDeadTime(PROC const   *proc ) 
{ 


  {
#line 1656
  return (proc->deathTime != 0L);
}
}
#line 1660 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestTtyName(PROC const   *proc ) 
{ 
  int tmp ;

  {
#line 1663
  if (proc->ttyDevice != 0UL) {
#line 1663
    if (proc->ttyDevice != 0xffffffffffffffffUL) {
#line 1663
      tmp = 1;
    } else {
#line 1663
      tmp = 0;
    }
  } else {
#line 1663
    tmp = 0;
  }
#line 1663
  return (tmp);
}
}
#line 1667 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestTtyDevice(PROC const   *proc ) 
{ 
  int tmp ;

  {
#line 1670
  if (proc->ttyDevice != 0UL) {
#line 1670
    if (proc->ttyDevice != 0xffffffffffffffffUL) {
#line 1670
      tmp = 1;
    } else {
#line 1670
      tmp = 0;
    }
  } else {
#line 1670
    tmp = 0;
  }
#line 1670
  return (tmp);
}
}
#line 1674 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestUserName(PROC const   *proc ) 
{ 
  char const   *tmp ;

  {
  {
#line 1677
  tmp = FindUserName((uid_t )proc->uid);
  }
#line 1677
  return ((unsigned long )tmp != (unsigned long )((void *)0));
}
}
#line 1681 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestGroupName(PROC const   *proc ) 
{ 
  char const   *tmp ;

  {
  {
#line 1684
  tmp = FindGroupName((gid_t )proc->gid);
  }
#line 1684
  return ((unsigned long )tmp != (unsigned long )((void *)0));
}
}
#line 1688 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestUserId(PROC const   *proc ) 
{ 


  {
#line 1691
  return (proc->uid != 0U);
}
}
#line 1695 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestGroupId(PROC const   *proc ) 
{ 


  {
#line 1698
  return (proc->gid != 0U);
}
}
#line 1702 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestPercentCpu(PROC const   *proc ) 
{ 


  {
#line 1705
  return (proc->percentCpu != 0);
}
}
#line 1709 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestPercentMemory(PROC const   *proc ) 
{ 


  {
#line 1712
  return (proc->percentMemory != 0);
}
}
#line 1716 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestRss(PROC const   *proc ) 
{ 


  {
#line 1719
  return (proc->rss != 0L);
}
}
#line 1723 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestStartTime(PROC const   *proc ) 
{ 


  {
#line 1726
  return (proc->startTimeTicks != 0UL);
}
}
#line 1730 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestAge(PROC const   *proc ) 
{ 


  {
#line 1733
  return (proc->startTimeClock < (time_t const   )currentTime);
}
}
#line 1737 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestFlags(PROC const   *proc ) 
{ 


  {
#line 1740
  return (proc->flags != 0UL);
}
}
#line 1744 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestPageFaults(PROC const   *proc ) 
{ 
  int tmp ;

  {
#line 1747
  if (proc->minorFaults != 0L) {
#line 1747
    tmp = 1;
  } else
#line 1747
  if (proc->majorFaults != 0L) {
#line 1747
    tmp = 1;
  } else {
#line 1747
    tmp = 0;
  }
#line 1747
  return (tmp);
}
}
#line 1751 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestMinorPageFaults(PROC const   *proc ) 
{ 


  {
#line 1754
  return (proc->minorFaults != 0L);
}
}
#line 1758 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestMajorPageFaults(PROC const   *proc ) 
{ 


  {
#line 1761
  return (proc->majorFaults != 0L);
}
}
#line 1765 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestSignalCatch(PROC const   *proc ) 
{ 


  {
#line 1768
  return (proc->sigCatch != 0UL);
}
}
#line 1772 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestSignalIgnore(PROC const   *proc ) 
{ 


  {
#line 1775
  return (proc->sigIgnore != 0UL);
}
}
#line 1779 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestSignalBlock(PROC const   *proc ) 
{ 


  {
#line 1782
  return (proc->sigBlock != 0UL);
}
}
#line 1786 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestOpenFileCount(PROC const   *proc ) 
{ 


  {
#line 1789
  return (proc->openFiles > 0);
}
}
#line 1793 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestRunOrder(PROC const   *proc ) 
{ 
  ULONG tmp ;

  {
  {
#line 1796
  tmp = GetRunOrder(proc);
  }
#line 1796
  return (tmp > 0UL);
}
}
#line 1800 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestCurrentDirectory(PROC const   *proc ) 
{ 


  {
#line 1803
  return ((unsigned long )proc->cwdPath != (unsigned long )(emptyString));
}
}
#line 1807 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestRootDirectory(PROC const   *proc ) 
{ 


  {
#line 1810
  return ((unsigned long )proc->rootPath != (unsigned long )(emptyString));
}
}
#line 1814 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestExecutable(PROC const   *proc ) 
{ 


  {
#line 1817
  return ((unsigned long )proc->execPath != (unsigned long )(emptyString));
}
}
#line 1821 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestStdin(PROC const   *proc ) 
{ 


  {
#line 1824
  return ((unsigned long )proc->stdioPaths[0] != (unsigned long )(emptyString));
}
}
#line 1828 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestStdout(PROC const   *proc ) 
{ 


  {
#line 1831
  return ((unsigned long )proc->stdioPaths[1] != (unsigned long )(emptyString));
}
}
#line 1835 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestStderr(PROC const   *proc ) 
{ 


  {
#line 1838
  return ((unsigned long )proc->stdioPaths[2] != (unsigned long )(emptyString));
}
}
#line 1842 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestStdio(PROC const   *proc ) 
{ 
  int tmp ;

  {
#line 1845
  if ((unsigned long )proc->stdioPaths[0] != (unsigned long )((char *)0)) {
#line 1845
    tmp = 1;
  } else
#line 1845
  if ((unsigned long )proc->stdioPaths[1] != (unsigned long )((char *)0)) {
#line 1845
    tmp = 1;
  } else
#line 1845
  if ((unsigned long )proc->stdioPaths[2] != (unsigned long )((char *)0)) {
#line 1845
    tmp = 1;
  } else {
#line 1845
    tmp = 0;
  }
#line 1845
  return (tmp);
}
}
#line 1851 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestSummary(PROC const   *proc ) 
{ 


  {
#line 1854
  return (1);
}
}
#line 1858 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestPolicy(PROC const   *proc ) 
{ 


  {
#line 1861
  return (proc->policy != 0L);
}
}
#line 1865 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestPriority(PROC const   *proc ) 
{ 


  {
#line 1868
  return (proc->priority != 0L);
}
}
#line 1872 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestRealTimePriority(PROC const   *proc ) 
{ 


  {
#line 1875
  return (proc->realTimePriority != 0L);
}
}
#line 1879 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestNice(PROC const   *proc ) 
{ 


  {
#line 1882
  return (proc->nice != 0L);
}
}
#line 1886 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestProcessor(PROC const   *proc ) 
{ 


  {
#line 1889
  return (proc->processor != 0);
}
}
#line 1893 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestSize(PROC const   *proc ) 
{ 


  {
#line 1896
  return (proc->virtualSize != 0L);
}
}
#line 1900 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestRealTimer(PROC const   *proc ) 
{ 


  {
#line 1903
  return (proc->itRealValue != 0L);
}
}
#line 1907 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static BOOL TestActive(PROC const   *proc ) 
{ 
  BOOL tmp ;

  {
  {
#line 1910
  tmp = GetIsActive(proc);
  }
#line 1910
  return (tmp);
}
}
#line 1922 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowPid(PROC const   *proc ) 
{ 


  {
  {
#line 1925
  sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%ld",
          (long )proc->pid);
  }
#line 1927
  return ((char const   *)(showBuffer));
}
}
#line 1931 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowTid(PROC const   *proc ) 
{ 


  {
#line 1934
  if (proc->tid == 0xffffffffffffffffUL) {
#line 1935
    return ("-");
  }
  {
#line 1937
  sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%ld",
          (long )proc->tid);
  }
#line 1939
  return ((char const   *)(showBuffer));
}
}
#line 1943 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowState(PROC const   *proc ) 
{ 
  int tmp ;

  {
  {
#line 1946
  tmp = GetState(proc);
#line 1946
  showBuffer[0] = (char )tmp;
#line 1947
  showBuffer[1] = (char )'\000';
  }
#line 1949
  return ((char const   *)(showBuffer));
}
}
#line 1953 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowStates(PROC const   *proc ) 
{ 


  {
#line 1956
  return ((char const   *)(proc->states));
}
}
#line 1960 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowThreadCount(PROC const   *proc ) 
{ 


  {
  {
#line 1963
  sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%d",
          proc->threadCount);
  }
#line 1965
  return ((char const   *)(showBuffer));
}
}
#line 1969 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowParentPid(PROC const   *proc ) 
{ 


  {
  {
#line 1972
  sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%ld",
          (long )proc->parentPid);
  }
#line 1974
  return ((char const   *)(showBuffer));
}
}
#line 1978 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowSystemTime(PROC const   *proc ) 
{ 


  {
  {
#line 1981
  TicksToString(showBuffer, (long )proc->systemRunTime);
  }
#line 1983
  return ((char const   *)(showBuffer));
}
}
#line 1987 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowUserTime(PROC const   *proc ) 
{ 


  {
  {
#line 1990
  TicksToString(showBuffer, (long )proc->userRunTime);
  }
#line 1992
  return ((char const   *)(showBuffer));
}
}
#line 1996 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowRunTime(PROC const   *proc ) 
{ 


  {
  {
#line 1999
  TicksToString(showBuffer, (long )(proc->systemRunTime + proc->userRunTime));
  }
#line 2001
  return ((char const   *)(showBuffer));
}
}
#line 2005 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowChildRunTime(PROC const   *proc ) 
{ 


  {
  {
#line 2008
  TicksToString(showBuffer, (long )(proc->childSystemRunTime + proc->childUserRunTime));
  }
#line 2010
  return ((char const   *)(showBuffer));
}
}
#line 2014 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowPageSwaps(PROC const   *proc ) 
{ 


  {
  {
#line 2017
  sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%ld",
          proc->pagesSwapped);
  }
#line 2019
  return ((char const   *)(showBuffer));
}
}
#line 2023 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowChildPageSwaps(PROC const   *proc ) 
{ 


  {
  {
#line 2026
  sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%ld",
          proc->childPagesSwapped);
  }
#line 2028
  return ((char const   *)(showBuffer));
}
}
#line 2032 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowEip(PROC const   *proc ) 
{ 


  {
  {
#line 2035
  sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%016lx",
          proc->eip);
  }
#line 2037
  return ((char const   *)(showBuffer));
}
}
#line 2041 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowEsp(PROC const   *proc ) 
{ 


  {
  {
#line 2044
  sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%016lx",
          proc->esp);
  }
#line 2046
  return ((char const   *)(showBuffer));
}
}
#line 2050 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowWaitChannel(PROC const   *proc ) 
{ 


  {
#line 2053
  if (proc->waitChan == 0UL) {
#line 2054
    return ("");
  }
  {
#line 2056
  sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%016lx",
          proc->waitChan);
  }
#line 2058
  return ((char const   *)(showBuffer));
}
}
#line 2062 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowWaitSymbol(PROC const   *proc ) 
{ 


  {
#line 2065
  return ((char const   *)(proc->waitChanSymbol));
}
}
#line 2069 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowProgram(PROC const   *proc ) 
{ 


  {
#line 2072
  return ((char const   *)(proc->program));
}
}
#line 2076 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowCommand(PROC const   *proc ) 
{ 


  {
#line 2079
  return ((char const   *)proc->command);
}
}
#line 2083 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowEnvironment(PROC const   *proc ) 
{ 


  {
#line 2086
  return ((char const   *)proc->environment);
}
}
#line 2090 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowProcessGroup(PROC const   *proc ) 
{ 


  {
  {
#line 2093
  sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%ld",
          (long )proc->processGroup);
  }
#line 2095
  return ((char const   *)(showBuffer));
}
}
#line 2099 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowTtyProcessGroup(PROC const   *proc ) 
{ 


  {
  {
#line 2102
  sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%ld",
          (long )proc->ttyProcessGroup);
  }
#line 2104
  return ((char const   *)(showBuffer));
}
}
#line 2108 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowIdleTime(PROC const   *proc ) 
{ 
  char *cp ;
  long idle ;
  char *tmp ;
  time_t tmp___0 ;

  {
#line 2114
  cp = showBuffer;
#line 2116
  if (proc->isAncient) {
#line 2117
    tmp = cp;
#line 2117
    cp ++;
#line 2117
    *tmp = (char )'+';
  }
  {
#line 2119
  tmp___0 = GetLastActiveTime(proc);
#line 2119
  idle = (currentTime - tmp___0) / 60L;
  }
#line 2121
  if (idle < 60L) {
    {
#line 2122
    sprintf((char */* __restrict  */)cp, (char const   */* __restrict  */)"%ld", idle);
    }
  } else {
    {
#line 2124
    sprintf((char */* __restrict  */)cp, (char const   */* __restrict  */)"%ld:%02ld",
            idle / 60L, idle % 60L);
    }
  }
#line 2126
  return ((char const   *)(showBuffer));
}
}
#line 2130 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowDeadTime(PROC const   *proc ) 
{ 
  char *cp ;
  long minutes ;

  {
#line 2136
  if (proc->deathTime == 0L) {
#line 2137
    return ("-");
  }
#line 2139
  cp = showBuffer;
#line 2141
  minutes = (currentTime - (time_t )proc->deathTime) / 60L;
#line 2143
  if (minutes < 60L) {
    {
#line 2144
    sprintf((char */* __restrict  */)cp, (char const   */* __restrict  */)"%ld", minutes);
    }
  } else {
    {
#line 2146
    sprintf((char */* __restrict  */)cp, (char const   */* __restrict  */)"%ld:%02ld",
            minutes / 60L, minutes % 60L);
    }
  }
#line 2148
  return ((char const   *)(showBuffer));
}
}
#line 2152 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowTtyName(PROC const   *proc ) 
{ 
  char const   *name ;

  {
  {
#line 2157
  name = FindDeviceName((dev_t )proc->ttyDevice);
  }
#line 2159
  if ((unsigned long )name != (unsigned long )((void *)0)) {
#line 2160
    return (name);
  }
  {
#line 2162
  sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%lx",
          (long )proc->ttyDevice);
  }
#line 2164
  return ((char const   *)(showBuffer));
}
}
#line 2168 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowTtyDevice(PROC const   *proc ) 
{ 


  {
  {
#line 2171
  sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%lx",
          (long )proc->ttyDevice);
  }
#line 2173
  return ((char const   *)(showBuffer));
}
}
#line 2177 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowUserName(PROC const   *proc ) 
{ 
  char const   *name ;

  {
  {
#line 2182
  name = FindUserName((uid_t )proc->uid);
  }
#line 2184
  if (name) {
#line 2185
    return (name);
  }
  {
#line 2187
  sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%ld",
          (long )proc->uid);
  }
#line 2189
  return ((char const   *)(showBuffer));
}
}
#line 2193 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowGroupName(PROC const   *proc ) 
{ 
  char const   *name ;

  {
  {
#line 2198
  name = FindGroupName((gid_t )proc->gid);
  }
#line 2200
  if (name) {
#line 2201
    return (name);
  }
  {
#line 2203
  sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%ld",
          (long )proc->gid);
  }
#line 2205
  return ((char const   *)(showBuffer));
}
}
#line 2209 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowUserId(PROC const   *proc ) 
{ 


  {
  {
#line 2212
  sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%ld",
          (long )proc->uid);
  }
#line 2214
  return ((char const   *)(showBuffer));
}
}
#line 2218 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowGroupId(PROC const   *proc ) 
{ 


  {
  {
#line 2221
  sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%ld",
          (long )proc->gid);
  }
#line 2223
  return ((char const   *)(showBuffer));
}
}
#line 2227 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowPercentCpu(PROC const   *proc ) 
{ 


  {
  {
#line 2230
  sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%d.%02d",
          proc->percentCpu / 100, proc->percentCpu % 100);
  }
#line 2233
  return ((char const   *)(showBuffer));
}
}
#line 2237 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowPercentMemory(PROC const   *proc ) 
{ 


  {
  {
#line 2240
  sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%d.%d",
          proc->percentMemory / 10, proc->percentMemory % 10);
  }
#line 2243
  return ((char const   *)(showBuffer));
}
}
#line 2247 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowRss(PROC const   *proc ) 
{ 


  {
  {
#line 2250
  sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%ld",
          proc->rss * 4L);
  }
#line 2252
  return ((char const   *)(showBuffer));
}
}
#line 2256 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowStartTime(PROC const   *proc ) 
{ 
  int procAgeDays ;
  char *cp ;

  {
  {
#line 2266
  cp = ctime(& proc->startTimeClock);
#line 2273
  memcpy((void */* __restrict  */)(showBuffer), (void const   */* __restrict  */)(cp + 11),
         (size_t )5);
#line 2274
  showBuffer[5] = (char )'\000';
#line 2276
  procAgeDays = (int )((currentTime - (time_t )proc->startTimeClock) / 86400L);
  }
#line 2279
  if (procAgeDays > 0) {
    {
#line 2280
    sprintf((char */* __restrict  */)(showBuffer + 5), (char const   */* __restrict  */)"-%dd",
            procAgeDays);
    }
  }
#line 2282
  return ((char const   *)(showBuffer));
}
}
#line 2286 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowAge(PROC const   *proc ) 
{ 
  long minutes ;
  long hours ;
  long days ;

  {
#line 2293
  minutes = (currentTime - (time_t )proc->startTimeClock) / 60L;
#line 2295
  if (minutes < 0L) {
#line 2296
    minutes = 0L;
  }
#line 2298
  hours = minutes / 60L;
#line 2299
  minutes %= 60L;
#line 2301
  days = hours / 24L;
#line 2302
  hours %= 24L;
#line 2304
  if (days) {
    {
#line 2305
    sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%ldd%02ld:%02ld",
            days, hours, minutes);
    }
  } else
#line 2306
  if (hours) {
    {
#line 2307
    sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%ld:%02ld",
            hours, minutes);
    }
  } else {
    {
#line 2309
    sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%ld",
            minutes);
    }
  }
#line 2311
  return ((char const   *)(showBuffer));
}
}
#line 2315 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowFlags(PROC const   *proc ) 
{ 


  {
  {
#line 2318
  sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%lx",
          proc->flags);
  }
#line 2320
  return ((char const   *)(showBuffer));
}
}
#line 2324 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowPageFaults(PROC const   *proc ) 
{ 


  {
  {
#line 2327
  sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%ld",
          proc->minorFaults + proc->majorFaults);
  }
#line 2329
  return ((char const   *)(showBuffer));
}
}
#line 2333 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowMinorPageFaults(PROC const   *proc ) 
{ 


  {
  {
#line 2336
  sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%ld",
          proc->minorFaults);
  }
#line 2338
  return ((char const   *)(showBuffer));
}
}
#line 2342 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowMajorPageFaults(PROC const   *proc ) 
{ 


  {
  {
#line 2345
  sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%ld",
          proc->majorFaults);
  }
#line 2347
  return ((char const   *)(showBuffer));
}
}
#line 2351 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowSignalCatch(PROC const   *proc ) 
{ 


  {
  {
#line 2354
  sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%08lx",
          proc->sigCatch);
  }
#line 2356
  return ((char const   *)(showBuffer));
}
}
#line 2360 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowSignalIgnore(PROC const   *proc ) 
{ 


  {
  {
#line 2363
  sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%08lx",
          proc->sigIgnore);
  }
#line 2365
  return ((char const   *)(showBuffer));
}
}
#line 2369 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowSignalBlock(PROC const   *proc ) 
{ 


  {
  {
#line 2372
  sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%08lx",
          proc->sigBlock);
  }
#line 2374
  return ((char const   *)(showBuffer));
}
}
#line 2378 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowOpenFileCount(PROC const   *proc ) 
{ 


  {
#line 2381
  if (proc->openFiles < 0) {
#line 2382
    return ("-");
  }
  {
#line 2384
  sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%d",
          proc->openFiles);
  }
#line 2386
  return ((char const   *)(showBuffer));
}
}
#line 2390 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowRunOrder(PROC const   *proc ) 
{ 
  ULONG tmp ;

  {
  {
#line 2393
  tmp = GetRunOrder(proc);
#line 2393
  sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%lu",
          tmp);
  }
#line 2395
  return ((char const   *)(showBuffer));
}
}
#line 2399 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowCurrentDirectory(PROC const   *proc ) 
{ 


  {
#line 2402
  return ((char const   *)proc->cwdPath);
}
}
#line 2406 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowRootDirectory(PROC const   *proc ) 
{ 


  {
#line 2409
  return ((char const   *)proc->rootPath);
}
}
#line 2413 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowExecutable(PROC const   *proc ) 
{ 


  {
#line 2416
  return ((char const   *)proc->execPath);
}
}
#line 2420 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowStdin(PROC const   *proc ) 
{ 


  {
#line 2423
  return ((char const   *)proc->stdioPaths[0]);
}
}
#line 2427 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowStdout(PROC const   *proc ) 
{ 


  {
#line 2430
  return ((char const   *)proc->stdioPaths[1]);
}
}
#line 2434 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowStderr(PROC const   *proc ) 
{ 


  {
#line 2437
  return ((char const   *)proc->stdioPaths[2]);
}
}
#line 2441 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowStdio(PROC const   *proc ) 
{ 
  char *path ;
  char *tag ;
  int fd ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 2448
  strcpy((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"---");
#line 2453
  fd = 0;
  }
  {
#line 2453
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2453
    if (! (fd <= 2)) {
#line 2453
      goto while_break;
    }
#line 2455
    path = proc->stdioPaths[fd];
#line 2456
    tag = & showBuffer[fd];
#line 2461
    if ((int )*path == 0) {
#line 2462
      goto __Cont;
    }
    {
#line 2467
    tmp = memcmp((void const   *)path, (void const   *)"pipe:", (size_t )5);
    }
#line 2467
    if (tmp == 0) {
#line 2469
      *tag = (char )'P';
#line 2471
      goto __Cont;
    }
    {
#line 2477
    tmp___0 = memcmp((void const   *)path, (void const   *)"socket:", (size_t )7);
    }
#line 2477
    if (tmp___0 == 0) {
#line 2479
      *tag = (char )'S';
#line 2481
      goto __Cont;
    }
    {
#line 2487
    tmp___1 = strcmp((char const   *)path, "/dev/null");
    }
#line 2487
    if (tmp___1 == 0) {
#line 2489
      *tag = (char )'N';
#line 2491
      goto __Cont;
    }
    {
#line 2497
    tmp___2 = memcmp((void const   *)path, (void const   *)"/dev/tty", (size_t )8);
    }
#line 2497
    if (tmp___2 == 0) {
#line 2501
      *tag = (char )'T';
#line 2503
      goto __Cont;
    } else {
      {
#line 2497
      tmp___3 = memcmp((void const   *)path, (void const   *)"/dev/pts/", (size_t )9);
      }
#line 2497
      if (tmp___3 == 0) {
#line 2501
        *tag = (char )'T';
#line 2503
        goto __Cont;
      } else {
        {
#line 2497
        tmp___4 = memcmp((void const   *)path, (void const   *)"/dev/vc/", (size_t )8);
        }
#line 2497
        if (tmp___4 == 0) {
#line 2501
          *tag = (char )'T';
#line 2503
          goto __Cont;
        }
      }
    }
#line 2509
    *tag = (char )'F';
    __Cont: /* CIL Label */ 
#line 2453
    fd ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2512
  return ((char const   *)(showBuffer));
}
}
#line 2516 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowSummary(PROC const   *proc ) 
{ 
  int state ;
  int tmp ;
  long age ;
  char *cp ;
  BOOL tmp___0 ;

  {
  {
#line 2519
  tmp = GetState(proc);
#line 2519
  state = tmp;
#line 2523
  cp = showBuffer;
#line 2524
  strcpy((char */* __restrict  */)cp, (char const   */* __restrict  */)"--------------");
  }
#line 2526
  if (proc->deathTime != 0L) {
#line 2527
    *(cp + 0) = (char )'-';
  } else
#line 2528
  if (state == 82) {
#line 2531
    *(cp + 0) = (char )state;
  } else
#line 2528
  if (state == 90) {
#line 2531
    *(cp + 0) = (char )state;
  } else
#line 2528
  if (state == 84) {
#line 2531
    *(cp + 0) = (char )state;
  } else
#line 2528
  if (state == 68) {
#line 2531
    *(cp + 0) = (char )state;
  } else {
    {
#line 2533
    tmp___0 = GetIsActive(proc);
    }
#line 2533
    if (tmp___0) {
#line 2534
      *(cp + 0) = (char )'A';
    } else {
#line 2536
      *(cp + 0) = (char )'I';
    }
  }
#line 2538
  if (proc->rss == 0L) {
#line 2538
    if (proc->virtualSize != 0L) {
#line 2538
      if (state != 90) {
#line 2539
        *(cp + 1) = (char )'W';
      }
    }
  }
#line 2541
  if (proc->nice > 0L) {
#line 2542
    *(cp + 2) = (char )'N';
  } else
#line 2543
  if (proc->nice < 0L) {
#line 2544
    *(cp + 2) = (char )'H';
  }
#line 2546
  if (proc->sessionId == proc->pid) {
#line 2547
    *(cp + 3) = (char )'S';
  }
#line 2549
  if (proc->processGroup == proc->pid) {
#line 2550
    *(cp + 4) = (char )'P';
  }
#line 2552
  if (proc->ttyDevice != 0UL) {
#line 2552
    if (proc->ttyDevice != 0xffffffffffffffffUL) {
#line 2553
      *(cp + 5) = (char )'T';
    }
  }
#line 2555
  if (proc->ttyProcessGroup == proc->processGroup) {
#line 2556
    *(cp + 6) = (char )'F';
  }
#line 2558
  if (proc->parentPid == 1) {
#line 2559
    *(cp + 7) = (char )'I';
  }
#line 2561
  if (proc->sigIgnore & 1UL) {
#line 2562
    *(cp + 8) = (char )'H';
  } else
#line 2563
  if (proc->sigCatch & 1UL) {
#line 2564
    *(cp + 8) = (char )'h';
  }
#line 2566
  if (proc->sigIgnore & (unsigned long const   )(1 << 14)) {
#line 2567
    *(cp + 9) = (char )'T';
  } else
#line 2568
  if (proc->sigCatch & (unsigned long const   )(1 << 14)) {
#line 2569
    *(cp + 9) = (char )'t';
  }
#line 2571
  if (proc->uid == (uid_t const   )myUid) {
#line 2572
    *(cp + 10) = (char )'U';
  }
#line 2574
  if (proc->gid == (gid_t const   )myGid) {
#line 2575
    *(cp + 11) = (char )'G';
  }
#line 2577
  if (proc->uid == 0U) {
#line 2578
    *(cp + 12) = (char )'R';
  } else
#line 2579
  if (proc->uid < 100U) {
#line 2580
    *(cp + 12) = (char )'S';
  }
#line 2582
  age = currentTime - (time_t )proc->startTimeClock;
#line 2584
  if (age >= 604800L) {
#line 2585
    *(cp + 13) = (char )'W';
  } else
#line 2586
  if (age >= 86400L) {
#line 2587
    *(cp + 13) = (char )'D';
  } else
#line 2588
  if (age >= 3600L) {
#line 2589
    *(cp + 13) = (char )'H';
  } else
#line 2590
  if (age >= 600L) {
#line 2591
    *(cp + 13) = (char )'T';
  } else
#line 2592
  if (age >= 300L) {
#line 2593
    *(cp + 13) = (char )'F';
  } else
#line 2594
  if (age >= 60L) {
#line 2595
    *(cp + 13) = (char )'M';
  } else {
#line 2597
    *(cp + 13) = (char )'N';
  }
#line 2599
  return ((char const   *)(showBuffer));
}
}
#line 2603 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowPolicy(PROC const   *proc ) 
{ 


  {
  {
#line 2606
  sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%ld",
          proc->policy);
  }
#line 2608
  return ((char const   *)(showBuffer));
}
}
#line 2612 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowPriority(PROC const   *proc ) 
{ 


  {
  {
#line 2615
  sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%ld",
          proc->priority);
  }
#line 2617
  return ((char const   *)(showBuffer));
}
}
#line 2621 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowRealTimePriority(PROC const   *proc ) 
{ 


  {
  {
#line 2624
  sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%ld",
          proc->realTimePriority);
  }
#line 2626
  return ((char const   *)(showBuffer));
}
}
#line 2630 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowNice(PROC const   *proc ) 
{ 


  {
  {
#line 2633
  sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%ld",
          proc->nice);
  }
#line 2635
  return ((char const   *)(showBuffer));
}
}
#line 2639 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowProcessor(PROC const   *proc ) 
{ 


  {
  {
#line 2642
  sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%ld",
          (long )proc->processor);
  }
#line 2644
  return ((char const   *)(showBuffer));
}
}
#line 2648 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowSize(PROC const   *proc ) 
{ 


  {
  {
#line 2651
  sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%ld",
          (proc->virtualSize + 1023L) / 1024L);
  }
#line 2653
  return ((char const   *)(showBuffer));
}
}
#line 2657 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowRealTimer(PROC const   *proc ) 
{ 
  long intPart ;
  long fracPart ;

  {
#line 2663
  intPart = (long )(proc->itRealValue / (long const   )ticksPerSecond);
#line 2664
  fracPart = (long )(proc->itRealValue % (long const   )ticksPerSecond);
#line 2666
  if (fracPart) {
    {
#line 2668
    sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%ld.%02ld",
            intPart, (fracPart * 100L) / ticksPerSecond);
    }
  } else {
    {
#line 2671
    sprintf((char */* __restrict  */)(showBuffer), (char const   */* __restrict  */)"%ld",
            intPart);
    }
  }
#line 2673
  return ((char const   *)(showBuffer));
}
}
#line 2677 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static char const   *ShowActive(PROC const   *proc ) 
{ 
  char const   *tmp___0 ;
  BOOL tmp___1 ;

  {
  {
#line 2680
  tmp___1 = GetIsActive(proc);
  }
#line 2680
  if (tmp___1) {
#line 2680
    tmp___0 = "active";
  } else {
#line 2680
    tmp___0 = "idle";
  }
#line 2680
  return (tmp___0);
}
}
#line 2690 "/home/june/repo/benchmarks/collector/temp/ips-4.0/columns.c"
static void TicksToString(char *buf___3 , long ticks ) 
{ 
  int hundreths ;
  int seconds ;
  int minutes ;
  long hours ;

  {
#line 2698
  hundreths = (int )(ticks % ticksPerSecond);
#line 2699
  ticks /= ticksPerSecond;
#line 2701
  seconds = (int )(ticks % 60L);
#line 2702
  ticks /= 60L;
#line 2704
  minutes = (int )(ticks % 60L);
#line 2705
  ticks /= 60L;
#line 2707
  hours = ticks;
#line 2709
  if (hours > 0L) {
    {
#line 2711
    sprintf((char */* __restrict  */)buf___3, (char const   */* __restrict  */)"%ld:%02d:%02d.%02d",
            hours, minutes, seconds, hundreths);
    }
  } else
#line 2714
  if (minutes > 0) {
    {
#line 2715
    sprintf((char */* __restrict  */)buf___3, (char const   */* __restrict  */)"%d:%02d.%02d",
            minutes, seconds, hundreths);
    }
  } else {
    {
#line 2717
    sprintf((char */* __restrict  */)buf___3, (char const   */* __restrict  */)"%d.%02d",
            seconds, hundreths);
    }
  }
#line 2718
  return;
}
}
#line 529 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
BOOL PatternMatch(char const   *text , char const   *pattern ) ;
#line 550
void ClearCondition(void) ;
#line 551
BOOL ParseCondition(char const   *str ) ;
#line 596
BOOL ExpandMacro(MACRO_TYPE type , char const   *name , ARGS *retargs ) ;
#line 603
BOOL CompareValues(VALUE const   leftVal , VALUE const   rightVal , int *result ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
static BOOL condFlag  ;
#line 38 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
static TREE condTree  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
static NODE badNode  ;
#line 40 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
static VALUE badValue  ;
#line 46
static NODE *ParseAlternation(TREE *tree ) ;
#line 47
static NODE *ParseOrOr(TREE *tree ) ;
#line 48
static NODE *ParseAndAnd(TREE *tree ) ;
#line 49
static NODE *ParseRelation(TREE *tree ) ;
#line 50
static NODE *ParseSum(TREE *tree ) ;
#line 51
static NODE *ParseProduct(TREE *tree ) ;
#line 52
static NODE *ParseOr(TREE *tree ) ;
#line 53
static NODE *ParseAnd(TREE *tree ) ;
#line 54
static NODE *ParseShift(TREE *tree ) ;
#line 55
static NODE *ParseUnary(TREE *tree ) ;
#line 56
static NODE *ParseTerm(TREE *tree ) ;
#line 57
static NODE *ParseSymbol(TREE *tree , char *str ) ;
#line 58
static NODE *ParseMacro(TREE *tree , char *str ) ;
#line 59
static NODE *ParseFunction(TREE *tree , char *str ) ;
#line 60
static NODE *NewNode(TREE *tree , OP op , NODE *left , NODE *right ) ;
#line 61
static NODE *BadNode(TREE *tree , char *message ) ;
#line 62
static TOKEN ParseNewToken(TREE *tree ) ;
#line 63
static TOKEN ParseToken(TREE *tree ) ;
#line 64
static TOKEN ParseNumber(TREE *tree ) ;
#line 65
static TOKEN BadToken(TREE *tree , char *msg ) ;
#line 66
static VALUE EvaluateComparison(TREE *tree , NODE const   *node ) ;
#line 67
static VALUE EvaluateFunction(TREE *tree , NODE const   *node ) ;
#line 68
static BOOL ConvertType(VALUE val , int type , VALUE *retval ) ;
#line 70
static VALUE FunctionMatch(TREE *tree , VALUE arg1 , VALUE arg2 ) ;
#line 71
static VALUE FunctionMin(TREE *tree , VALUE arg1 , VALUE arg2 ) ;
#line 72
static VALUE FunctionMax(TREE *tree , VALUE arg1 , VALUE arg2 ) ;
#line 73
static VALUE FunctionStrlen(TREE *tree , VALUE arg ) ;
#line 74
static VALUE FunctionAbs(TREE *tree , VALUE arg ) ;
#line 75
static VALUE FunctionStr(TREE *tree , VALUE arg ) ;
#line 76
static VALUE FunctionCmp(TREE *tree , VALUE arg1 , VALUE arg2 ) ;
#line 77
static VALUE FunctionMy(TREE *tree , NODE const   *node ) ;
#line 85 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
BOOL IsShownProcess(PROC const   *proc ) 
{ 
  TREE *tree ;
  int i ;
  VALUE value ;
  int tmp ;
  BOOL tmp___0 ;

  {
#line 96
  if (proc->isThread) {
#line 96
    if (! showThreads) {
#line 97
      return (0);
    }
  }
#line 103
  if (showThreads) {
#line 103
    if (! proc->isThread) {
#line 103
      if (proc->threadCount > 1) {
#line 104
        return (0);
      }
    }
  }
#line 111
  if (showThreads) {
#line 111
    if (proc->isThread) {
#line 111
      if (proc->threadCount <= 1) {
#line 112
        return (0);
      }
    }
  }
#line 114
  if (myProcs) {
#line 114
    if (proc->uid != (uid_t const   )myUid) {
#line 115
      return (0);
    }
  }
#line 117
  if (noSelf) {
#line 117
    if (proc->pid == (pid_t const   )myPid) {
#line 118
      return (0);
    }
  }
#line 120
  if (pidCount) {
#line 122
    i = 0;
    {
#line 122
    while (1) {
      while_continue: /* CIL Label */ ;
#line 122
      if (! (i < pidCount)) {
#line 122
        goto while_break;
      }
#line 124
      if (pidList[i] == (pid_t )proc->pid) {
#line 125
        goto while_break;
      }
#line 122
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 128
    if (i == pidCount) {
#line 129
      return (0);
    }
  }
#line 132
  if (userCount) {
#line 134
    i = 0;
    {
#line 134
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 134
      if (! (i < userCount)) {
#line 134
        goto while_break___0;
      }
#line 136
      if (userList[i] == (uid_t )proc->uid) {
#line 137
        goto while_break___0;
      }
#line 134
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 140
    if (i == userCount) {
#line 141
      return (0);
    }
  }
#line 144
  if (groupCount) {
#line 146
    i = 0;
    {
#line 146
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 146
      if (! (i < groupCount)) {
#line 146
        goto while_break___1;
      }
#line 148
      if (groupList[i] == (gid_t )proc->gid) {
#line 149
        goto while_break___1;
      }
#line 146
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 152
    if (i == groupCount) {
#line 153
      return (0);
    }
  }
#line 156
  if (programCount) {
#line 158
    i = 0;
    {
#line 158
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 158
      if (! (i < programCount)) {
#line 158
        goto while_break___2;
      }
      {
#line 160
      tmp = strcmp((char const   *)(programList[i]), (char const   *)(proc->program));
      }
#line 160
      if (tmp == 0) {
#line 161
        goto while_break___2;
      }
#line 158
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 164
    if (i == programCount) {
#line 165
      return (0);
    }
  }
#line 168
  if (activeOnly) {
    {
#line 168
    tmp___0 = GetIsActive(proc);
    }
#line 168
    if (! tmp___0) {
#line 169
      return (0);
    }
  }
#line 171
  if (! condFlag) {
#line 172
    return (1);
  }
  {
#line 174
  tree = & condTree;
#line 175
  tree->proc = proc;
#line 177
  value = EvaluateNode(tree, (NODE const   *)tree->root);
  }
#line 179
  if (value.type == 2) {
#line 180
    return (value.intVal != 0L);
  } else
#line 179
  if (value.type == 5) {
#line 180
    return (value.intVal != 0L);
  }
#line 182
  if (value.type == 3) {
#line 183
    return ((int const   )*(value.strVal) != 0);
  }
#line 185
  return (0);
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
USEFLAG GetConditionUseFlags(void) 
{ 
  USEFLAG tmp ;

  {
#line 197
  if (! condFlag) {
#line 198
    return ((USEFLAG )0);
  }
  {
#line 200
  tmp = GetNodeUseFlags((NODE const   *)condTree.root);
  }
#line 200
  return (tmp);
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
USEFLAG GetNodeUseFlags(NODE const   *node ) 
{ 
  int i ;
  USEFLAG flags ;
  USEFLAG tmp ;

  {
#line 214
  flags = (USEFLAG )0;
  {
#line 223
  if (node->op == 6) {
#line 223
    goto case_6;
  }
#line 223
  if (node->op == 5) {
#line 223
    goto case_6;
  }
#line 223
  if (node->op == 4) {
#line 223
    goto case_6;
  }
#line 227
  if (node->op == 28) {
#line 227
    goto case_28;
  }
#line 231
  goto switch_default;
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 224
  flags |= (node->column)->useFlag;
#line 225
  goto switch_break;
  case_28: /* CIL Label */ 
#line 228
  if (node->intVal == 61L) {
#line 229
    flags |= 32U;
  }
  switch_default: /* CIL Label */ 
#line 232
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 238
  i = 0;
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 238
    if (! (i < 3)) {
#line 238
      goto while_break;
    }
#line 240
    if (node->child[i]) {
      {
#line 241
      tmp = GetNodeUseFlags((NODE const   *)node->child[i]);
#line 241
      flags |= tmp;
      }
    }
#line 238
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 247
  return (flags);
}
}
#line 255 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
VALUE EvaluateNode(TREE *tree , NODE const   *node ) 
{ 
  NODE *left ;
  NODE *right ;
  int leftType ;
  int rightType ;
  int valType ;
  VALUE value ;
  VALUE leftVal ;
  VALUE rightVal ;
  char const   *cp ;
  BOOL tmp ;
  char *tmp___0 ;
  VALUE tmp___1 ;
  VALUE tmp___2 ;
  BOOL tmp___3 ;
  BOOL tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 268
  if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 269
    return (badValue);
  }
#line 271
  left = node->child[0];
#line 272
  right = node->child[1];
#line 274
  leftType = 1;
#line 275
  rightType = 1;
#line 276
  valType = 1;
  {
#line 284
  if (node->op == 1) {
#line 284
    goto case_1;
  }
#line 290
  if (node->op == 21) {
#line 290
    goto case_21;
  }
#line 290
  if (node->op == 18) {
#line 290
    goto case_21;
  }
#line 301
  if (node->op == 27) {
#line 301
    goto case_27;
  }
#line 301
  if (node->op == 19) {
#line 301
    goto case_27;
  }
#line 301
  if (node->op == 17) {
#line 301
    goto case_27;
  }
#line 301
  if (node->op == 16) {
#line 301
    goto case_27;
  }
#line 301
  if (node->op == 15) {
#line 301
    goto case_27;
  }
#line 301
  if (node->op == 14) {
#line 301
    goto case_27;
  }
#line 301
  if (node->op == 13) {
#line 301
    goto case_27;
  }
#line 308
  if (node->op == 2) {
#line 308
    goto case_2;
  }
#line 308
  if (node->op == 3) {
#line 308
    goto case_2;
  }
#line 314
  if (node->op == 22) {
#line 314
    goto case_22;
  }
#line 318
  if (node->op == 23) {
#line 318
    goto case_23;
  }
#line 324
  if (node->op == 24) {
#line 324
    goto case_24;
  }
#line 330
  if (node->op == 6) {
#line 330
    goto case_6;
  }
#line 336
  if (node->op == 4) {
#line 336
    goto case_4;
  }
#line 341
  if (node->op == 5) {
#line 341
    goto case_5;
  }
#line 374
  if (node->op == 12) {
#line 374
    goto case_12;
  }
#line 374
  if (node->op == 11) {
#line 374
    goto case_12;
  }
#line 374
  if (node->op == 10) {
#line 374
    goto case_12;
  }
#line 374
  if (node->op == 9) {
#line 374
    goto case_12;
  }
#line 374
  if (node->op == 8) {
#line 374
    goto case_12;
  }
#line 374
  if (node->op == 7) {
#line 374
    goto case_12;
  }
#line 377
  if (node->op == 28) {
#line 377
    goto case_28;
  }
#line 380
  goto switch_default;
  case_1: /* CIL Label */ 
#line 285
  leftType = 5;
#line 286
  valType = 5;
#line 287
  goto switch_break;
  case_21: /* CIL Label */ 
  case_18: /* CIL Label */ 
#line 291
  leftType = 2;
#line 292
  valType = 2;
#line 293
  goto switch_break;
  case_27: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_17: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_15: /* CIL Label */ 
  case_14: /* CIL Label */ 
  case_13: /* CIL Label */ 
#line 302
  leftType = 2;
#line 303
  rightType = 2;
#line 304
  valType = 2;
#line 305
  goto switch_break;
  case_2: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 309
  leftType = 5;
#line 310
  rightType = 5;
#line 311
  valType = 5;
#line 312
  goto switch_break;
  case_22: /* CIL Label */ 
#line 315
  leftType = 5;
#line 316
  goto switch_break;
  case_23: /* CIL Label */ 
#line 319
  value.type = 3;
#line 320
  value.strVal = (char const   *)node->strVal;
#line 322
  return (value);
  case_24: /* CIL Label */ 
#line 325
  value.type = 2;
#line 326
  value.intVal = (long )node->intVal;
#line 328
  return (value);
  case_6: /* CIL Label */ 
  {
#line 331
  value.type = 5;
#line 332
  tmp = (*((node->column)->testFunc))(tree->proc);
#line 332
  value.intVal = (long )tmp;
  }
#line 334
  return (value);
  case_4: /* CIL Label */ 
  {
#line 337
  (*((node->column)->evalFunc))(tree->proc, & value);
  }
#line 339
  return (value);
  case_5: /* CIL Label */ 
  {
#line 342
  cp = (*((node->column)->showFunc))(tree->proc);
  }
#line 352
  if ((unsigned long )cp != (unsigned long )(tree->proc)->command) {
#line 352
    if ((unsigned long )cp != (unsigned long )(tree->proc)->environment) {
#line 352
      if ((unsigned long )cp != (unsigned long )((tree->proc)->program)) {
        {
#line 356
        tmp___0 = CopyTempString(cp);
#line 356
        cp = (char const   *)tmp___0;
        }
      }
    }
  }
#line 364
  value.type = 3;
#line 365
  value.strVal = cp;
#line 367
  return (value);
  case_12: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  {
#line 375
  tmp___1 = EvaluateComparison(tree, node);
  }
#line 375
  return (tmp___1);
  case_28: /* CIL Label */ 
  {
#line 378
  tmp___2 = EvaluateFunction(tree, node);
  }
#line 378
  return (tmp___2);
  switch_default: /* CIL Label */ 
#line 381
  return (badValue);
  switch_break: /* CIL Label */ ;
  }
#line 387
  leftVal.type = 1;
#line 388
  leftVal.intVal = 0L;
#line 389
  leftVal.strVal = (char const   *)0;
#line 390
  leftVal.column = (COLUMN *)0;
#line 392
  rightVal.type = 1;
#line 393
  rightVal.intVal = 0L;
#line 394
  rightVal.strVal = (char const   *)0;
#line 395
  rightVal.column = (COLUMN *)0;
#line 401
  if (leftType != 1) {
    {
#line 403
    leftVal = EvaluateNode(tree, (NODE const   *)left);
#line 405
    tmp___3 = ConvertType(leftVal, leftType, & leftVal);
    }
#line 405
    if (! tmp___3) {
#line 406
      return (badValue);
    }
  }
#line 409
  if (rightType != 1) {
    {
#line 411
    rightVal = EvaluateNode(tree, (NODE const   *)right);
#line 413
    tmp___4 = ConvertType(rightVal, rightType, & rightVal);
    }
#line 413
    if (! tmp___4) {
#line 414
      return (badValue);
    }
  }
#line 417
  value.type = valType;
  {
#line 425
  if (node->op == 19) {
#line 425
    goto case_19___0;
  }
#line 429
  if (node->op == 20) {
#line 429
    goto case_20;
  }
#line 433
  if (node->op == 27) {
#line 433
    goto case_27___0;
  }
#line 437
  if (node->op == 21) {
#line 437
    goto case_21___0;
  }
#line 441
  if (node->op == 18) {
#line 441
    goto case_18___0;
  }
#line 445
  if (node->op == 13) {
#line 445
    goto case_13___0;
  }
#line 449
  if (node->op == 14) {
#line 449
    goto case_14___0;
  }
#line 453
  if (node->op == 15) {
#line 453
    goto case_15___0;
  }
#line 457
  if (node->op == 16) {
#line 457
    goto case_16___0;
  }
#line 464
  if (node->op == 17) {
#line 464
    goto case_17___0;
  }
#line 471
  if (node->op == 1) {
#line 471
    goto case_1___0;
  }
#line 475
  if (node->op == 2) {
#line 475
    goto case_2___0;
  }
#line 479
  if (node->op == 3) {
#line 479
    goto case_3___0;
  }
#line 483
  if (node->op == 22) {
#line 483
    goto case_22___0;
  }
#line 491
  goto switch_default___0;
  case_19___0: /* CIL Label */ 
#line 426
  value.intVal = leftVal.intVal & rightVal.intVal;
#line 427
  goto switch_break___0;
  case_20: /* CIL Label */ 
#line 430
  value.intVal = leftVal.intVal | rightVal.intVal;
#line 431
  goto switch_break___0;
  case_27___0: /* CIL Label */ 
#line 434
  value.intVal = leftVal.intVal ^ rightVal.intVal;
#line 435
  goto switch_break___0;
  case_21___0: /* CIL Label */ 
#line 438
  value.intVal = ~ leftVal.intVal;
#line 439
  goto switch_break___0;
  case_18___0: /* CIL Label */ 
#line 442
  value.intVal = - leftVal.intVal;
#line 443
  goto switch_break___0;
  case_13___0: /* CIL Label */ 
#line 446
  value.intVal = leftVal.intVal + rightVal.intVal;
#line 447
  goto switch_break___0;
  case_14___0: /* CIL Label */ 
#line 450
  value.intVal = leftVal.intVal - rightVal.intVal;
#line 451
  goto switch_break___0;
  case_15___0: /* CIL Label */ 
#line 454
  value.intVal = leftVal.intVal * rightVal.intVal;
#line 455
  goto switch_break___0;
  case_16___0: /* CIL Label */ 
#line 458
  if (rightVal.intVal == 0L) {
#line 459
    return (badValue);
  }
#line 461
  value.intVal = leftVal.intVal / rightVal.intVal;
#line 462
  goto switch_break___0;
  case_17___0: /* CIL Label */ 
#line 465
  if (rightVal.intVal == 0L) {
#line 466
    return (badValue);
  }
#line 468
  value.intVal = leftVal.intVal % rightVal.intVal;
#line 469
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 472
  value.intVal = (long )(! leftVal.intVal);
#line 473
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 476
  if (leftVal.intVal) {
#line 476
    if (rightVal.intVal) {
#line 476
      tmp___5 = 1;
    } else {
#line 476
      tmp___5 = 0;
    }
  } else {
#line 476
    tmp___5 = 0;
  }
#line 476
  value.intVal = (long )tmp___5;
#line 477
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 480
  if (leftVal.intVal) {
#line 480
    tmp___6 = 1;
  } else
#line 480
  if (rightVal.intVal) {
#line 480
    tmp___6 = 1;
  } else {
#line 480
    tmp___6 = 0;
  }
#line 480
  value.intVal = (long )tmp___6;
#line 481
  goto switch_break___0;
  case_22___0: /* CIL Label */ 
#line 484
  if (leftVal.intVal != 0L) {
    {
#line 485
    value = EvaluateNode(tree, (NODE const   *)right);
    }
  } else {
    {
#line 487
    value = EvaluateNode(tree, (NODE const   *)node->child[2]);
    }
  }
#line 489
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 492
  return (badValue);
  switch_break___0: /* CIL Label */ ;
  }
#line 495
  return (value);
}
}
#line 502 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
static VALUE EvaluateFunction(TREE *tree , NODE const   *node ) 
{ 
  VALUE value ;
  VALUE arg1 ;
  VALUE arg2 ;
  VALUE tmp ;
  VALUE tmp___0 ;
  VALUE tmp___1 ;
  VALUE tmp___2 ;
  VALUE tmp___3 ;
  VALUE tmp___4 ;
  VALUE tmp___5 ;
  VALUE tmp___6 ;

  {
#line 509
  if (node->op != 28) {
#line 510
    return (badValue);
  }
#line 517
  if (node->intVal == 61L) {
    {
#line 518
    tmp = FunctionMy(tree, (NODE const   *)node->child[0]);
    }
#line 518
    return (tmp);
  }
  {
#line 525
  if (node->intVal % 10L == 2L) {
#line 525
    goto case_2;
  }
#line 526
  if (node->intVal % 10L == 1L) {
#line 526
    goto case_1;
  }
#line 527
  if (node->intVal % 10L == 0L) {
#line 527
    goto case_0;
  }
#line 529
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 525
  arg2 = EvaluateNode(tree, (NODE const   *)node->child[1]);
  }
  case_1: /* CIL Label */ 
  {
#line 526
  arg1 = EvaluateNode(tree, (NODE const   *)node->child[0]);
  }
  case_0: /* CIL Label */ 
#line 527
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 530
  return (badValue);
  switch_break: /* CIL Label */ ;
  }
  {
#line 538
  if (node->intVal == 12L) {
#line 538
    goto case_12;
  }
#line 541
  if (node->intVal == 32L) {
#line 541
    goto case_32;
  }
#line 544
  if (node->intVal == 42L) {
#line 544
    goto case_42;
  }
#line 547
  if (node->intVal == 21L) {
#line 547
    goto case_21;
  }
#line 550
  if (node->intVal == 51L) {
#line 550
    goto case_51;
  }
#line 553
  if (node->intVal == 81L) {
#line 553
    goto case_81;
  }
#line 556
  if (node->intVal == 72L) {
#line 556
    goto case_72;
  }
#line 559
  goto switch_default___0;
  case_12: /* CIL Label */ 
  {
#line 539
  tmp___0 = FunctionMatch(tree, arg1, arg2);
  }
#line 539
  return (tmp___0);
  case_32: /* CIL Label */ 
  {
#line 542
  tmp___1 = FunctionMin(tree, arg1, arg2);
  }
#line 542
  return (tmp___1);
  case_42: /* CIL Label */ 
  {
#line 545
  tmp___2 = FunctionMax(tree, arg1, arg2);
  }
#line 545
  return (tmp___2);
  case_21: /* CIL Label */ 
  {
#line 548
  tmp___3 = FunctionStrlen(tree, arg1);
  }
#line 548
  return (tmp___3);
  case_51: /* CIL Label */ 
  {
#line 551
  tmp___4 = FunctionAbs(tree, arg1);
  }
#line 551
  return (tmp___4);
  case_81: /* CIL Label */ 
  {
#line 554
  tmp___5 = FunctionStr(tree, arg1);
  }
#line 554
  return (tmp___5);
  case_72: /* CIL Label */ 
  {
#line 557
  tmp___6 = FunctionCmp(tree, arg1, arg2);
  }
#line 557
  return (tmp___6);
  switch_default___0: /* CIL Label */ 
#line 560
  return (badValue);
  switch_break___0: /* CIL Label */ ;
  }
#line 563
  return (value);
}
}
#line 571 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
static VALUE FunctionMatch(TREE *tree , VALUE arg1 , VALUE arg2 ) 
{ 
  VALUE value ;
  char buf1[sizeof(long ) * 3UL + 2UL] ;
  char buf2[sizeof(long ) * 3UL + 2UL] ;
  BOOL tmp ;

  {
#line 581
  if (arg1.type == 5) {
    {
#line 583
    sprintf((char */* __restrict  */)(buf1), (char const   */* __restrict  */)"%ld",
            arg1.intVal);
#line 584
    arg1.type = 3;
#line 585
    arg1.strVal = (char const   *)(buf1);
    }
  } else
#line 581
  if (arg1.type == 2) {
    {
#line 583
    sprintf((char */* __restrict  */)(buf1), (char const   */* __restrict  */)"%ld",
            arg1.intVal);
#line 584
    arg1.type = 3;
#line 585
    arg1.strVal = (char const   *)(buf1);
    }
  }
#line 588
  if (arg2.type == 5) {
    {
#line 590
    sprintf((char */* __restrict  */)(buf2), (char const   */* __restrict  */)"%ld",
            arg2.intVal);
#line 591
    arg2.type = 3;
#line 592
    arg2.strVal = (char const   *)(buf2);
    }
  } else
#line 588
  if (arg2.type == 2) {
    {
#line 590
    sprintf((char */* __restrict  */)(buf2), (char const   */* __restrict  */)"%ld",
            arg2.intVal);
#line 591
    arg2.type = 3;
#line 592
    arg2.strVal = (char const   *)(buf2);
    }
  }
#line 598
  if (arg1.type != 3) {
#line 599
    return (badValue);
  } else
#line 598
  if (arg2.type != 3) {
#line 599
    return (badValue);
  }
  {
#line 604
  value.type = 5;
#line 605
  tmp = PatternMatch(arg1.strVal, arg2.strVal);
#line 605
  value.intVal = (long )tmp;
  }
#line 607
  return (value);
}
}
#line 615 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
static VALUE FunctionMin(TREE *tree , VALUE arg1 , VALUE arg2 ) 
{ 
  VALUE value ;

  {
#line 623
  if (arg1.type != 5) {
#line 623
    if (arg1.type != 2) {
#line 626
      return (badValue);
    } else {
#line 623
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 623
  if (arg2.type != 5) {
#line 623
    if (arg2.type != 2) {
#line 626
      return (badValue);
    }
  }
#line 629
  value.type = 2;
#line 630
  if (arg1.intVal < arg2.intVal) {
#line 630
    value.intVal = arg1.intVal;
  } else {
#line 630
    value.intVal = arg2.intVal;
  }
#line 632
  return (value);
}
}
#line 640 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
static VALUE FunctionMax(TREE *tree , VALUE arg1 , VALUE arg2 ) 
{ 
  VALUE value ;

  {
#line 648
  if (arg1.type != 5) {
#line 648
    if (arg1.type != 2) {
#line 651
      return (badValue);
    } else {
#line 648
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 648
  if (arg2.type != 5) {
#line 648
    if (arg2.type != 2) {
#line 651
      return (badValue);
    }
  }
#line 654
  value.type = 2;
#line 655
  if (arg1.intVal > arg2.intVal) {
#line 655
    value.intVal = arg1.intVal;
  } else {
#line 655
    value.intVal = arg2.intVal;
  }
#line 657
  return (value);
}
}
#line 665 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
static VALUE FunctionAbs(TREE *tree , VALUE arg ) 
{ 
  VALUE value ;

  {
#line 670
  if (arg.type != 5) {
#line 670
    if (arg.type != 2) {
#line 671
      return (badValue);
    }
  }
#line 673
  value.type = 2;
#line 674
  if (arg.intVal < 0L) {
#line 674
    value.intVal = - arg.intVal;
  } else {
#line 674
    value.intVal = arg.intVal;
  }
#line 676
  return (value);
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
static VALUE FunctionStr(TREE *tree , VALUE arg ) 
{ 
  VALUE value ;
  char buf___3[sizeof(long ) * 3UL + 2UL] ;
  char *tmp ;

  {
#line 689
  if (arg.type == 3) {
#line 690
    return (arg);
  }
#line 692
  if (arg.type != 5) {
#line 692
    if (arg.type != 2) {
#line 693
      return (badValue);
    }
  }
#line 695
  value.type = 3;
#line 701
  if (arg.intVal == 0L) {
#line 702
    value.strVal = "0";
  } else
#line 703
  if (arg.intVal == 1L) {
#line 704
    value.strVal = "1";
  } else
#line 705
  if (arg.intVal == -1L) {
#line 706
    value.strVal = "-1";
  } else {
    {
#line 709
    sprintf((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)"%ld",
            arg.intVal);
#line 710
    tmp = CopyTempString((char const   *)(buf___3));
#line 710
    value.strVal = (char const   *)tmp;
    }
  }
#line 713
  return (value);
}
}
#line 720 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
static VALUE FunctionStrlen(TREE *tree , VALUE arg ) 
{ 
  VALUE value ;
  char buf___3[sizeof(long ) * 3UL + 2UL] ;
  size_t tmp ;

  {
#line 729
  if (arg.type == 5) {
    {
#line 731
    sprintf((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)"%ld",
            arg.intVal);
#line 732
    arg.type = 3;
#line 733
    arg.strVal = (char const   *)(buf___3);
    }
  } else
#line 729
  if (arg.type == 2) {
    {
#line 731
    sprintf((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)"%ld",
            arg.intVal);
#line 732
    arg.type = 3;
#line 733
    arg.strVal = (char const   *)(buf___3);
    }
  }
#line 739
  if (arg.type != 3) {
#line 740
    return (badValue);
  }
  {
#line 745
  value.type = 2;
#line 746
  tmp = strlen(arg.strVal);
#line 746
  value.intVal = (long )tmp;
  }
#line 748
  return (value);
}
}
#line 756 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
static VALUE FunctionCmp(TREE *tree , VALUE arg1 , VALUE arg2 ) 
{ 
  VALUE value ;
  char buf1[sizeof(long ) * 3UL + 2UL] ;
  char buf2[sizeof(long ) * 3UL + 2UL] ;
  int tmp ;

  {
#line 766
  if (arg1.type == 5) {
#line 766
    goto _L___0;
  } else
#line 766
  if (arg1.type == 2) {
    _L___0: /* CIL Label */ 
#line 766
    if (arg2.type == 5) {
#line 766
      goto _L;
    } else
#line 766
    if (arg2.type == 2) {
      _L: /* CIL Label */ 
#line 769
      value.type = 2;
#line 770
      value.intVal = 0L;
#line 772
      if (arg1.intVal < arg2.intVal) {
#line 773
        value.intVal = -1L;
      }
#line 775
      if (arg1.intVal > arg2.intVal) {
#line 776
        value.intVal = 1L;
      }
#line 778
      return (value);
    }
  }
#line 784
  if (arg1.type == 5) {
    {
#line 786
    sprintf((char */* __restrict  */)(buf1), (char const   */* __restrict  */)"%ld",
            arg1.intVal);
#line 787
    arg1.type = 3;
#line 788
    arg1.strVal = (char const   *)(buf1);
    }
  } else
#line 784
  if (arg1.type == 2) {
    {
#line 786
    sprintf((char */* __restrict  */)(buf1), (char const   */* __restrict  */)"%ld",
            arg1.intVal);
#line 787
    arg1.type = 3;
#line 788
    arg1.strVal = (char const   *)(buf1);
    }
  }
#line 791
  if (arg2.type == 5) {
    {
#line 793
    sprintf((char */* __restrict  */)(buf2), (char const   */* __restrict  */)"%ld",
            arg2.intVal);
#line 794
    arg2.type = 3;
#line 795
    arg2.strVal = (char const   *)(buf2);
    }
  } else
#line 791
  if (arg2.type == 2) {
    {
#line 793
    sprintf((char */* __restrict  */)(buf2), (char const   */* __restrict  */)"%ld",
            arg2.intVal);
#line 794
    arg2.type = 3;
#line 795
    arg2.strVal = (char const   *)(buf2);
    }
  }
#line 801
  if (arg1.type != 3) {
#line 802
    return (badValue);
  } else
#line 801
  if (arg2.type != 3) {
#line 802
    return (badValue);
  }
  {
#line 807
  value.type = 2;
#line 808
  tmp = strcmp(arg1.strVal, arg2.strVal);
#line 808
  value.intVal = (long )tmp;
  }
#line 810
  if (value.intVal < 0L) {
#line 811
    value.intVal = -1L;
  }
#line 813
  if (value.intVal > 0L) {
#line 814
    value.intVal = 1L;
  }
#line 816
  return (value);
}
}
#line 825 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
static VALUE FunctionMy(TREE *tree , NODE const   *node ) 
{ 
  PROC const   *savedProc ;
  PROC *proc ;
  int savedUid ;
  int savedGid ;
  VALUE value ;

  {
  {
#line 840
  proc = FindProcess(myPid, (pthread_t )-1);
#line 842
  savedUid = (int )proc->uid;
#line 843
  savedGid = (int )proc->gid;
#line 845
  proc->uid = myUid;
#line 846
  proc->gid = myGid;
#line 848
  savedProc = tree->proc;
#line 849
  tree->proc = (PROC const   *)proc;
#line 855
  value = EvaluateNode(tree, node);
#line 861
  proc->uid = (uid_t )savedUid;
#line 862
  proc->gid = (gid_t )savedGid;
#line 864
  tree->proc = savedProc;
  }
#line 866
  return (value);
}
}
#line 875 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
static VALUE EvaluateComparison(TREE *tree , NODE const   *node ) 
{ 
  int compare ;
  VALUE leftVal ;
  VALUE rightVal ;
  VALUE value ;
  BOOL tmp ;

  {
  {
#line 883
  leftVal = EvaluateNode(tree, (NODE const   *)node->child[0]);
  }
#line 885
  if (leftVal.type == 0) {
#line 886
    return (badValue);
  }
  {
#line 888
  rightVal = EvaluateNode(tree, (NODE const   *)node->child[1]);
  }
#line 890
  if (rightVal.type == 0) {
#line 891
    return (badValue);
  }
  {
#line 893
  tmp = CompareValues((VALUE const   )leftVal, (VALUE const   )rightVal, & compare);
  }
#line 893
  if (! tmp) {
#line 894
    return (badValue);
  }
#line 900
  value.type = 5;
  {
#line 904
  if (node->op == 7) {
#line 904
    goto case_7;
  }
#line 908
  if (node->op == 8) {
#line 908
    goto case_8;
  }
#line 912
  if (node->op == 9) {
#line 912
    goto case_9;
  }
#line 916
  if (node->op == 10) {
#line 916
    goto case_10;
  }
#line 920
  if (node->op == 11) {
#line 920
    goto case_11;
  }
#line 924
  if (node->op == 12) {
#line 924
    goto case_12;
  }
#line 928
  goto switch_default;
  case_7: /* CIL Label */ 
#line 905
  value.intVal = (long )(compare == 0);
#line 906
  goto switch_break;
  case_8: /* CIL Label */ 
#line 909
  value.intVal = (long )(compare != 0);
#line 910
  goto switch_break;
  case_9: /* CIL Label */ 
#line 913
  value.intVal = (long )(compare < 0);
#line 914
  goto switch_break;
  case_10: /* CIL Label */ 
#line 917
  value.intVal = (long )(compare <= 0);
#line 918
  goto switch_break;
  case_11: /* CIL Label */ 
#line 921
  value.intVal = (long )(compare > 0);
#line 922
  goto switch_break;
  case_12: /* CIL Label */ 
#line 925
  value.intVal = (long )(compare >= 0);
#line 926
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 929
  return (badValue);
  switch_break: /* CIL Label */ ;
  }
#line 932
  return (value);
}
}
#line 942 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
BOOL CompareValues(VALUE const   leftVal , VALUE const   rightVal , int *result ) 
{ 
  int compare ;

  {
#line 945
  compare = 0;
  {
#line 952
  if (leftVal.type * 10 + rightVal.type == 55) {
#line 952
    goto case_55;
  }
#line 952
  if (leftVal.type * 10 + rightVal.type == 52) {
#line 952
    goto case_55;
  }
#line 952
  if (leftVal.type * 10 + rightVal.type == 25) {
#line 952
    goto case_55;
  }
#line 952
  if (leftVal.type * 10 + rightVal.type == 22) {
#line 952
    goto case_55;
  }
#line 961
  if (leftVal.type * 10 + rightVal.type == 33) {
#line 961
    goto case_33;
  }
#line 966
  goto switch_default;
  case_55: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_25: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 953
  if (leftVal.intVal < rightVal.intVal) {
#line 954
    compare = -1;
  }
#line 956
  if (leftVal.intVal > rightVal.intVal) {
#line 957
    compare = 1;
  }
#line 959
  goto switch_break;
  case_33: /* CIL Label */ 
  {
#line 962
  compare = strcmp((char const   *)leftVal.strVal, (char const   *)rightVal.strVal);
  }
#line 964
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 967
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 970
  *result = compare;
#line 972
  return (1);
}
}
#line 980 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
static BOOL ConvertType(VALUE val , int type , VALUE *retval ) 
{ 
  char const   *cp ;
  long intVal ;
  BOOL isNeg ;
  char const   *tmp ;

  {
#line 990
  if (val.type == type) {
#line 992
    *retval = val;
#line 994
    return (1);
  }
  {
#line 1003
  if (val.type * 10 + type == 35) {
#line 1003
    goto case_35;
  }
#line 1008
  if (val.type * 10 + type == 25) {
#line 1008
    goto case_25;
  }
#line 1013
  if (val.type * 10 + type == 52) {
#line 1013
    goto case_52;
  }
#line 1018
  if (val.type * 10 + type == 32) {
#line 1018
    goto case_32;
  }
#line 1061
  goto switch_default;
  case_35: /* CIL Label */ 
#line 1004
  retval->type = 5;
#line 1005
  retval->intVal = (long )((int const   )*(val.strVal + 0) != 0);
#line 1006
  goto switch_break;
  case_25: /* CIL Label */ 
#line 1009
  retval->type = 5;
#line 1010
  retval->intVal = (long )(val.intVal != 0L);
#line 1011
  goto switch_break;
  case_52: /* CIL Label */ 
#line 1014
  retval->type = 2;
#line 1015
  retval->intVal = val.intVal;
#line 1016
  goto switch_break;
  case_32: /* CIL Label */ 
#line 1019
  cp = val.strVal;
#line 1021
  intVal = 0L;
#line 1022
  isNeg = 0;
  {
#line 1024
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1024
    if (! ((int const   )*cp == 32)) {
#line 1024
      if (! ((int const   )*cp == 9)) {
#line 1024
        goto while_break;
      }
    }
#line 1025
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1027
  if ((int const   )*cp == 45) {
#line 1029
    cp ++;
#line 1030
    isNeg = 1;
  }
#line 1033
  if ((int const   )*cp >= 48) {
#line 1033
    if (! ((int const   )*cp <= 57)) {
#line 1035
      *retval = badValue;
#line 1037
      return (0);
    }
  } else {
#line 1035
    *retval = badValue;
#line 1037
    return (0);
  }
  {
#line 1040
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1040
    if ((int const   )*cp >= 48) {
#line 1040
      if (! ((int const   )*cp <= 57)) {
#line 1040
        goto while_break___0;
      }
    } else {
#line 1040
      goto while_break___0;
    }
#line 1041
    tmp = cp;
#line 1041
    cp ++;
#line 1041
    intVal = (intVal * 10L + (long )*tmp) - 48L;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1043
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1043
    if (! ((int const   )*cp == 32)) {
#line 1043
      if (! ((int const   )*cp == 9)) {
#line 1043
        goto while_break___1;
      }
    }
#line 1044
    cp ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1046
  if (*cp) {
#line 1048
    *retval = badValue;
#line 1050
    return (0);
  }
#line 1053
  if (isNeg) {
#line 1054
    intVal = - intVal;
  }
#line 1056
  retval->intVal = intVal;
#line 1057
  retval->type = 2;
#line 1059
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1062
  *retval = badValue;
#line 1064
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 1067
  return (1);
}
}
#line 1075 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
void ClearCondition(void) 
{ 


  {
#line 1078
  condFlag = 0;
#line 1079
  return;
}
}
#line 1089 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
BOOL ParseCondition(char const   *str ) 
{ 
  TREE treeData ;
  BOOL tmp ;

  {
  {
#line 1094
  tmp = ParseTree(& treeData, str, 0);
  }
#line 1094
  if (! tmp) {
#line 1095
    return (0);
  }
#line 1097
  condTree = treeData;
#line 1098
  condFlag = 1;
#line 1100
  return (1);
}
}
#line 1109 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
BOOL ParseTree(TREE *tree , char const   *str , int depth ) 
{ 
  int len ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  TOKEN tmp___2 ;

  {
  {
#line 1114
  badValue.type = 0;
#line 1115
  badValue.strVal = "";
#line 1116
  badValue.intVal = 0L;
#line 1117
  badValue.column = (COLUMN *)((void *)0);
#line 1119
  tmp = strlen(str);
#line 1119
  len = (int )tmp;
#line 1121
  tmp___0 = malloc((size_t )(len + 1));
#line 1121
  tree->expr = (char *)tmp___0;
#line 1122
  tmp___1 = malloc((size_t )(len + 1));
#line 1122
  tree->modExpr = (char *)tmp___1;
  }
#line 1124
  if ((unsigned long )tree->expr == (unsigned long )((void *)0)) {
    {
#line 1126
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot allocate condition expression\n");
    }
#line 1128
    return (0);
  } else
#line 1124
  if ((unsigned long )tree->modExpr == (unsigned long )((void *)0)) {
    {
#line 1126
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot allocate condition expression\n");
    }
#line 1128
    return (0);
  }
  {
#line 1131
  memcpy((void */* __restrict  */)tree->expr, (void const   */* __restrict  */)str,
         (size_t )(len + 1));
#line 1132
  memcpy((void */* __restrict  */)tree->modExpr, (void const   */* __restrict  */)str,
         (size_t )(len + 1));
#line 1134
  tree->cp = tree->expr;
#line 1135
  tree->failed = 0;
#line 1136
  tree->root = (NODE *)((void *)0);
#line 1137
  tree->token = 0;
#line 1138
  tree->rescanToken = 0;
#line 1139
  tree->tokenStr = (char *)"";
#line 1140
  tree->tokenInt = 0L;
#line 1141
  tree->depth = depth;
#line 1146
  tree->root = ParseAlternation(tree);
#line 1148
  tmp___2 = ParseToken(tree);
  }
#line 1148
  if (tmp___2 != 1) {
#line 1150
    if (! tree->failed) {
      {
#line 1151
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad expression\n");
      }
    }
#line 1153
    tree->failed = 1;
  }
#line 1156
  if (tree->failed) {
#line 1157
    return (0);
  }
#line 1159
  return (1);
}
}
#line 1167 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
static NODE *ParseAlternation(TREE *tree ) 
{ 
  NODE *top ;
  NODE *right ;
  NODE *altRight ;
  TOKEN token ;
  NODE *tmp ;

  {
  {
#line 1175
  top = ParseOrOr(tree);
#line 1177
  token = ParseToken(tree);
  }
#line 1179
  if (token != 27) {
#line 1181
    tree->rescanToken = 1;
#line 1183
    return (top);
  }
  {
#line 1186
  right = ParseOrOr(tree);
#line 1188
  token = ParseToken(tree);
  }
#line 1190
  if (token != 28) {
    {
#line 1192
    tree->rescanToken = 1;
#line 1194
    tmp = BadNode(tree, (char *)"Missing colon in conditional");
    }
#line 1194
    return (tmp);
  }
  {
#line 1197
  altRight = ParseOrOr(tree);
#line 1199
  top = NewNode(tree, 3, top, right);
#line 1201
  top->child[2] = altRight;
  }
#line 1203
  return (top);
}
}
#line 1210 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
static NODE *ParseOrOr(TREE *tree ) 
{ 
  NODE *top ;
  NODE *right ;
  TOKEN token ;

  {
  {
#line 1217
  top = ParseAndAnd(tree);
  }
  {
#line 1219
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1221
    token = ParseToken(tree);
    }
#line 1223
    if (token != 11) {
#line 1225
      tree->rescanToken = 1;
#line 1227
      return (top);
    }
    {
#line 1230
    right = ParseAndAnd(tree);
#line 1232
    top = NewNode(tree, 3, top, right);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1240 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
static NODE *ParseAndAnd(TREE *tree ) 
{ 
  NODE *top ;
  NODE *right ;
  TOKEN token ;

  {
  {
#line 1247
  top = ParseRelation(tree);
  }
  {
#line 1249
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1251
    token = ParseToken(tree);
    }
#line 1253
    if (token != 10) {
#line 1255
      tree->rescanToken = 1;
#line 1257
      return (top);
    }
    {
#line 1260
    right = ParseRelation(tree);
#line 1262
    top = NewNode(tree, 2, top, right);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1270 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
static NODE *ParseRelation(TREE *tree ) 
{ 
  NODE *top ;
  NODE *right ;
  TOKEN token ;
  OP op ;
  NODE *tmp ;

  {
  {
#line 1278
  top = ParseSum(tree);
#line 1280
  token = ParseToken(tree);
  }
  {
#line 1284
  if (token == 12) {
#line 1284
    goto case_12;
  }
#line 1288
  if (token == 13) {
#line 1288
    goto case_13;
  }
#line 1292
  if (token == 14) {
#line 1292
    goto case_14;
  }
#line 1296
  if (token == 15) {
#line 1296
    goto case_15;
  }
#line 1300
  if (token == 16) {
#line 1300
    goto case_16;
  }
#line 1304
  if (token == 17) {
#line 1304
    goto case_17;
  }
#line 1308
  goto switch_default;
  case_12: /* CIL Label */ 
#line 1285
  op = 7;
#line 1286
  goto switch_break;
  case_13: /* CIL Label */ 
#line 1289
  op = 8;
#line 1290
  goto switch_break;
  case_14: /* CIL Label */ 
#line 1293
  op = 9;
#line 1294
  goto switch_break;
  case_15: /* CIL Label */ 
#line 1297
  op = 10;
#line 1298
  goto switch_break;
  case_16: /* CIL Label */ 
#line 1301
  op = 11;
#line 1302
  goto switch_break;
  case_17: /* CIL Label */ 
#line 1305
  op = 12;
#line 1306
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1309
  tree->rescanToken = 1;
#line 1311
  return (top);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1314
  right = ParseSum(tree);
#line 1316
  tmp = NewNode(tree, op, top, right);
  }
#line 1316
  return (tmp);
}
}
#line 1323 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
static NODE *ParseSum(TREE *tree ) 
{ 
  NODE *top ;
  NODE *right ;
  TOKEN token ;
  OP op ;

  {
  {
#line 1331
  top = ParseProduct(tree);
  }
  {
#line 1336
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1338
    token = ParseToken(tree);
    }
    {
#line 1342
    if (token == 19) {
#line 1342
      goto case_19;
    }
#line 1346
    if (token == 20) {
#line 1346
      goto case_20;
    }
#line 1350
    goto switch_default;
    case_19: /* CIL Label */ 
#line 1343
    op = 13;
#line 1344
    goto switch_break;
    case_20: /* CIL Label */ 
#line 1347
    op = 14;
#line 1348
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1351
    tree->rescanToken = 1;
#line 1353
    return (top);
    switch_break: /* CIL Label */ ;
    }
    {
#line 1356
    right = ParseProduct(tree);
#line 1357
    top = NewNode(tree, op, top, right);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1365 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
static NODE *ParseProduct(TREE *tree ) 
{ 
  NODE *top ;
  NODE *right ;
  TOKEN token ;
  OP op ;

  {
  {
#line 1373
  top = ParseOr(tree);
  }
  {
#line 1378
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1380
    token = ParseToken(tree);
    }
    {
#line 1384
    if (token == 21) {
#line 1384
      goto case_21;
    }
#line 1388
    if (token == 22) {
#line 1388
      goto case_22;
    }
#line 1392
    if (token == 23) {
#line 1392
      goto case_23;
    }
#line 1396
    goto switch_default;
    case_21: /* CIL Label */ 
#line 1385
    op = 15;
#line 1386
    goto switch_break;
    case_22: /* CIL Label */ 
#line 1389
    op = 16;
#line 1390
    goto switch_break;
    case_23: /* CIL Label */ 
#line 1393
    op = 17;
#line 1394
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1397
    tree->rescanToken = 1;
#line 1399
    return (top);
    switch_break: /* CIL Label */ ;
    }
    {
#line 1402
    right = ParseOr(tree);
#line 1403
    top = NewNode(tree, op, top, right);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1411 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
static NODE *ParseOr(TREE *tree ) 
{ 
  NODE *top ;
  TOKEN token ;
  NODE *tmp ;

  {
  {
#line 1417
  top = ParseAnd(tree);
  }
  {
#line 1422
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1424
    token = ParseToken(tree);
    }
#line 1426
    if (token != 25) {
#line 1428
      tree->rescanToken = 1;
#line 1430
      return (top);
    }
    {
#line 1433
    tmp = ParseAnd(tree);
#line 1433
    top = NewNode(tree, 20, top, tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1441 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
static NODE *ParseAnd(TREE *tree ) 
{ 
  NODE *top ;
  NODE *right ;
  TOKEN token ;

  {
  {
#line 1448
  top = ParseShift(tree);
  }
  {
#line 1453
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1455
    token = ParseToken(tree);
    }
    {
#line 1459
    if (token == 24) {
#line 1459
      goto case_24;
    }
#line 1464
    if (token == 26) {
#line 1464
      goto case_26;
    }
#line 1469
    goto switch_default;
    case_24: /* CIL Label */ 
    {
#line 1460
    right = ParseShift(tree);
#line 1461
    top = NewNode(tree, 19, top, right);
    }
#line 1462
    goto switch_break;
    case_26: /* CIL Label */ 
    {
#line 1465
    right = ParseShift(tree);
#line 1466
    top = NewNode(tree, 27, top, right);
    }
#line 1467
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1470
    tree->rescanToken = 1;
#line 1472
    return (top);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1481 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
static NODE *ParseShift(TREE *tree ) 
{ 
  NODE *top ;
  TOKEN token ;
  OP op ;
  NODE *tmp ;
  NODE *tmp___0 ;

  {
  {
#line 1488
  top = ParseUnary(tree);
#line 1490
  token = ParseToken(tree);
  }
  {
#line 1494
  if (token == 29) {
#line 1494
    goto case_29;
  }
#line 1498
  if (token == 30) {
#line 1498
    goto case_30;
  }
#line 1502
  goto switch_default;
  case_29: /* CIL Label */ 
#line 1495
  op = 25;
#line 1496
  goto switch_break;
  case_30: /* CIL Label */ 
#line 1499
  op = 26;
#line 1500
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1503
  tree->rescanToken = 1;
#line 1505
  return (top);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1508
  tmp = ParseUnary(tree);
#line 1508
  tmp___0 = NewNode(tree, 25, top, tmp);
  }
#line 1508
  return (tmp___0);
}
}
#line 1515 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
static NODE *ParseUnary(TREE *tree ) 
{ 
  TOKEN tmp ;
  NODE *tmp___0 ;
  NODE *tmp___1 ;
  NODE *tmp___2 ;
  NODE *tmp___3 ;
  NODE *tmp___4 ;
  NODE *tmp___5 ;
  NODE *tmp___6 ;

  {
  {
#line 1518
  tmp = ParseToken(tree);
  }
  {
#line 1520
  if (tmp == 20) {
#line 1520
    goto case_20;
  }
#line 1523
  if (tmp == 8) {
#line 1523
    goto case_8;
  }
#line 1526
  if (tmp == 9) {
#line 1526
    goto case_9;
  }
#line 1530
  goto switch_default;
  case_20: /* CIL Label */ 
  {
#line 1521
  tmp___0 = ParseUnary(tree);
#line 1521
  tmp___1 = NewNode(tree, 18, tmp___0, (NODE *)((void *)0));
  }
#line 1521
  return (tmp___1);
  case_8: /* CIL Label */ 
  {
#line 1524
  tmp___2 = ParseUnary(tree);
#line 1524
  tmp___3 = NewNode(tree, 1, tmp___2, (NODE *)((void *)0));
  }
#line 1524
  return (tmp___3);
  case_9: /* CIL Label */ 
  {
#line 1527
  tmp___4 = ParseUnary(tree);
#line 1527
  tmp___5 = NewNode(tree, 21, tmp___4, (NODE *)((void *)0));
  }
#line 1527
  return (tmp___5);
  switch_default: /* CIL Label */ 
  {
#line 1531
  tree->rescanToken = 1;
#line 1533
  tmp___6 = ParseTerm(tree);
  }
#line 1533
  return (tmp___6);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1541 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
static NODE *ParseTerm(TREE *tree ) 
{ 
  TOKEN token ;
  NODE *node ;
  NODE *tmp ;
  NODE *tmp___0 ;
  NODE *tmp___1 ;
  NODE *tmp___2 ;
  NODE *tmp___3 ;

  {
  {
#line 1547
  token = ParseToken(tree);
  }
  {
#line 1551
  if (token == 2) {
#line 1551
    goto case_2;
  }
#line 1554
  if (token == 18) {
#line 1554
    goto case_18;
  }
#line 1561
  if (token == 3) {
#line 1561
    goto case_3;
  }
#line 1568
  if (token == 6) {
#line 1568
    goto case_6;
  }
#line 1581
  if (token == 7) {
#line 1581
    goto case_7;
  }
#line 1584
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 1552
  tmp = ParseSymbol(tree, tree->tokenStr);
  }
#line 1552
  return (tmp);
  case_18: /* CIL Label */ 
  {
#line 1555
  node = NewNode(tree, 23, (NODE *)((void *)0), (NODE *)((void *)0));
#line 1557
  node->strVal = tree->tokenStr;
  }
#line 1559
  return (node);
  case_3: /* CIL Label */ 
  {
#line 1562
  node = NewNode(tree, 24, (NODE *)((void *)0), (NODE *)((void *)0));
#line 1564
  node->intVal = tree->tokenInt;
  }
#line 1566
  return (node);
  case_6: /* CIL Label */ 
  {
#line 1569
  node = ParseAlternation(tree);
#line 1571
  token = ParseToken(tree);
  }
#line 1573
  if (token == 7) {
#line 1574
    return (node);
  }
#line 1576
  if (token == 1) {
    {
#line 1577
    tmp___0 = BadNode(tree, (char *)"Bad expression");
    }
#line 1577
    return (tmp___0);
  }
  {
#line 1579
  tmp___1 = BadNode(tree, (char *)"Bad expression");
  }
#line 1579
  return (tmp___1);
  case_7: /* CIL Label */ 
  {
#line 1582
  tmp___2 = BadNode(tree, (char *)"Unbalanced parenthesis");
  }
#line 1582
  return (tmp___2);
  switch_default: /* CIL Label */ 
  {
#line 1585
  tmp___3 = BadNode(tree, (char *)"Missing term");
  }
#line 1585
  return (tmp___3);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1595 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
static NODE *ParseSymbol(TREE *tree , char *str ) 
{ 
  TOKEN token ;
  NODE *node ;
  COLUMN *column ;
  OP op ;
  NODE *tmp ;
  NODE *tmp___0 ;
  NODE *tmp___1 ;
  NODE *tmp___2 ;
  NODE *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 1603
  token = ParseToken(tree);
  }
#line 1609
  if (token == 6) {
    {
#line 1611
    tree->rescanToken = 1;
#line 1613
    tmp = ParseFunction(tree, str);
    }
#line 1613
    return (tmp);
  }
#line 1620
  if ((int )*str >= 65) {
#line 1620
    if ((int )*str <= 90) {
      {
#line 1622
      tree->rescanToken = 1;
#line 1624
      tmp___0 = ParseMacro(tree, str);
      }
#line 1624
      return (tmp___0);
    }
  }
  {
#line 1631
  column = FindColumn((char const   *)str);
  }
#line 1633
  if ((unsigned long )column == (unsigned long )((void *)0)) {
#line 1635
    if (! tree->failed) {
      {
#line 1637
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown column \"%s\"\n",
              str);
#line 1639
      tree->failed = 1;
      }
    }
    {
#line 1642
    tmp___1 = BadNode(tree, (char *)"");
    }
#line 1642
    return (tmp___1);
  }
#line 1649
  if (token != 5) {
    {
#line 1651
    tree->rescanToken = 1;
#line 1653
    node = NewNode(tree, 4, (NODE *)((void *)0), (NODE *)((void *)0));
#line 1655
    node->column = column;
    }
#line 1657
    return (node);
  }
  {
#line 1665
  token = ParseToken(tree);
  }
#line 1667
  if (token != 2) {
    {
#line 1668
    tmp___2 = BadNode(tree, (char *)"Missing column qualifier");
    }
#line 1668
    return (tmp___2);
  }
  {
#line 1670
  tmp___6 = strcmp((char const   *)tree->tokenStr, "base");
  }
#line 1670
  if (tmp___6 == 0) {
#line 1671
    op = 4;
  } else {
    {
#line 1672
    tmp___5 = strcmp((char const   *)tree->tokenStr, "show");
    }
#line 1672
    if (tmp___5 == 0) {
#line 1673
      op = 5;
    } else {
      {
#line 1674
      tmp___4 = strcmp((char const   *)tree->tokenStr, "test");
      }
#line 1674
      if (tmp___4 == 0) {
#line 1675
        op = 6;
      } else {
        {
#line 1678
        tmp___3 = BadNode(tree, (char *)"Illegal column qualifier");
        }
#line 1678
        return (tmp___3);
      }
    }
  }
  {
#line 1684
  node = NewNode(tree, op, (NODE *)((void *)0), (NODE *)((void *)0));
#line 1686
  node->column = column;
  }
#line 1688
  return (node);
}
}
#line 1696 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
static NODE *ParseFunction(TREE *tree , char *str ) 
{ 
  NODE *node ;
  int func ;
  int argCount ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  NODE *tmp___7 ;
  NODE *tmp___8 ;
  TOKEN tmp___9 ;
  NODE *tmp___10 ;
  NODE *tmp___11 ;
  TOKEN tmp___12 ;
  NODE *tmp___13 ;
  TOKEN tmp___14 ;
  NODE *tmp___15 ;
  NODE *tmp___16 ;

  {
  {
#line 1704
  func = 0;
#line 1709
  tmp = strcmp((char const   *)str, "match");
  }
#line 1709
  if (tmp == 0) {
#line 1710
    func = 12;
  }
  {
#line 1712
  tmp___0 = strcmp((char const   *)str, "strlen");
  }
#line 1712
  if (tmp___0 == 0) {
#line 1713
    func = 21;
  }
  {
#line 1715
  tmp___1 = strcmp((char const   *)str, "min");
  }
#line 1715
  if (tmp___1 == 0) {
#line 1716
    func = 32;
  }
  {
#line 1718
  tmp___2 = strcmp((char const   *)str, "max");
  }
#line 1718
  if (tmp___2 == 0) {
#line 1719
    func = 42;
  }
  {
#line 1721
  tmp___3 = strcmp((char const   *)str, "abs");
  }
#line 1721
  if (tmp___3 == 0) {
#line 1722
    func = 51;
  }
  {
#line 1724
  tmp___4 = strcmp((char const   *)str, "str");
  }
#line 1724
  if (tmp___4 == 0) {
#line 1725
    func = 81;
  }
  {
#line 1727
  tmp___5 = strcmp((char const   *)str, "my");
  }
#line 1727
  if (tmp___5 == 0) {
#line 1728
    func = 61;
  }
  {
#line 1730
  tmp___6 = strcmp((char const   *)str, "cmp");
  }
#line 1730
  if (tmp___6 == 0) {
#line 1731
    func = 72;
  }
#line 1736
  if (func == 0) {
    {
#line 1738
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown function \"%s\"\n",
            str);
#line 1740
    tree->failed = 1;
#line 1742
    tmp___7 = BadNode(tree, (char *)"");
    }
#line 1742
    return (tmp___7);
  }
  {
#line 1745
  tmp___9 = ParseToken(tree);
  }
#line 1745
  if (tmp___9 != 6) {
    {
#line 1746
    tmp___8 = BadNode(tree, (char *)"Bad function call format\n");
    }
#line 1746
    return (tmp___8);
  }
  {
#line 1748
  node = NewNode(tree, 28, (NODE *)((void *)0), (NODE *)((void *)0));
#line 1750
  node->intVal = (long )func;
#line 1755
  argCount = func % 10;
  }
#line 1757
  if (argCount > 3) {
    {
#line 1758
    tmp___10 = BadNode(tree, (char *)"Too many function arguments");
    }
#line 1758
    return (tmp___10);
  }
#line 1760
  i = 0;
  {
#line 1760
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1760
    if (! (i < argCount)) {
#line 1760
      goto while_break;
    }
#line 1762
    if (i > 0) {
      {
#line 1762
      tmp___12 = ParseToken(tree);
      }
#line 1762
      if (tmp___12 != 4) {
        {
#line 1764
        tree->rescanToken = 1;
#line 1766
        tmp___11 = BadNode(tree, (char *)"Not enough arguments for function");
        }
#line 1766
        return (tmp___11);
      }
    }
    {
#line 1770
    node->child[i] = ParseAlternation(tree);
#line 1760
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1777
  if (func == 61) {
    {
#line 1783
    if ((node->child[0])->op == 6) {
#line 1783
      goto case_6;
    }
#line 1783
    if ((node->child[0])->op == 5) {
#line 1783
      goto case_6;
    }
#line 1783
    if ((node->child[0])->op == 4) {
#line 1783
      goto case_6;
    }
#line 1786
    goto switch_default;
    case_6: /* CIL Label */ 
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
#line 1784
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1787
    tmp___13 = BadNode(tree, (char *)"Function \"my\" only uses columns");
    }
#line 1787
    return (tmp___13);
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 1795
  tmp___14 = ParseToken(tree);
  }
  {
#line 1797
  if (tmp___14 == 4) {
#line 1797
    goto case_4___0;
  }
#line 1800
  if (tmp___14 == 7) {
#line 1800
    goto case_7;
  }
#line 1803
  goto switch_default___0;
  case_4___0: /* CIL Label */ 
  {
#line 1798
  tmp___15 = BadNode(tree, (char *)"Too many function arguments");
  }
#line 1798
  return (tmp___15);
  case_7: /* CIL Label */ 
#line 1801
  return (node);
  switch_default___0: /* CIL Label */ 
  {
#line 1804
  tmp___16 = BadNode(tree, (char *)"Missing right parenthesis in function call");
  }
#line 1804
  return (tmp___16);
  switch_break___0: /* CIL Label */ ;
  }
}
}
#line 1814 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
static NODE *ParseMacro(TREE *tree , char *str ) 
{ 
  TREE subTree ;
  ARGS args ;
  NODE *tmp ;
  NODE *tmp___0 ;
  BOOL tmp___1 ;
  NODE *tmp___2 ;
  NODE *tmp___3 ;
  BOOL tmp___4 ;

  {
#line 1820
  if (tree->depth >= 20) {
    {
#line 1821
    tmp = BadNode(tree, (char *)"Too many levels of expression macros");
    }
#line 1821
    return (tmp);
  }
  {
#line 1823
  tmp___1 = ExpandMacro(2, (char const   *)str, & args);
  }
#line 1823
  if (! tmp___1) {
    {
#line 1824
    tmp___0 = BadNode(tree, (char *)"Macro expansion failed");
    }
#line 1824
    return (tmp___0);
  }
#line 1826
  if (args.count != 1) {
    {
#line 1827
    tmp___2 = BadNode(tree, (char *)"Expression macro isn\'t one string");
    }
#line 1827
    return (tmp___2);
  }
  {
#line 1833
  tmp___4 = ParseTree(& subTree, (char const   *)*(args.table + 0), tree->depth + 1);
  }
#line 1833
  if (! tmp___4) {
    {
#line 1835
    tree->failed = 1;
#line 1837
    tmp___3 = BadNode(tree, (char *)"");
    }
#line 1837
    return (tmp___3);
  }
#line 1840
  return (subTree.root);
}
}
#line 1848 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
static TOKEN ParseToken(TREE *tree ) 
{ 


  {
#line 1851
  if (! tree->rescanToken) {
    {
#line 1852
    tree->token = ParseNewToken(tree);
    }
  }
#line 1854
  tree->rescanToken = 0;
#line 1856
  return (tree->token);
}
}
#line 1863 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
static TOKEN ParseNewToken(TREE *tree ) 
{ 
  int ch ;
  char *tmp ;
  TOKEN tmp___0 ;
  TOKEN tmp___1 ;
  TOKEN tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 1868
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1868
    if (! ((int )*(tree->cp) == 32)) {
#line 1868
      if (! ((int )*(tree->cp) == 9)) {
#line 1868
        goto while_break;
      }
    }
#line 1869
    (tree->cp) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1871
  tree->tokenStr = tree->modExpr + (tree->cp - tree->expr);
#line 1872
  tree->tokenInt = 0L;
#line 1877
  tmp = tree->cp;
#line 1877
  (tree->cp) ++;
#line 1877
  ch = (int )*tmp;
  {
#line 1881
  if (ch == 33) {
#line 1881
    goto case_33;
  }
#line 1889
  if (ch == 46) {
#line 1889
    goto case_46;
  }
#line 1892
  if (ch == 44) {
#line 1892
    goto case_44;
  }
#line 1895
  if (ch == 126) {
#line 1895
    goto case_126;
  }
#line 1898
  if (ch == 94) {
#line 1898
    goto case_94;
  }
#line 1901
  if (ch == 40) {
#line 1901
    goto case_40;
  }
#line 1904
  if (ch == 41) {
#line 1904
    goto case_41;
  }
#line 1907
  if (ch == 38) {
#line 1907
    goto case_38;
  }
#line 1915
  if (ch == 124) {
#line 1915
    goto case_124;
  }
#line 1923
  if (ch == 43) {
#line 1923
    goto case_43;
  }
#line 1926
  if (ch == 45) {
#line 1926
    goto case_45;
  }
#line 1929
  if (ch == 42) {
#line 1929
    goto case_42;
  }
#line 1932
  if (ch == 47) {
#line 1932
    goto case_47;
  }
#line 1935
  if (ch == 37) {
#line 1935
    goto case_37;
  }
#line 1938
  if (ch == 63) {
#line 1938
    goto case_63;
  }
#line 1941
  if (ch == 58) {
#line 1941
    goto case_58;
  }
#line 1944
  if (ch == 60) {
#line 1944
    goto case_60;
  }
#line 1959
  if (ch == 62) {
#line 1959
    goto case_62;
  }
#line 1974
  if (ch == 61) {
#line 1974
    goto case_61;
  }
#line 1980
  if (ch == 0) {
#line 1980
    goto case_0;
  }
#line 1986
  if (ch == 34) {
#line 1986
    goto case_34;
  }
#line 1986
  if (ch == 39) {
#line 1986
    goto case_34;
  }
#line 2006
  goto switch_default;
  case_33: /* CIL Label */ 
#line 1882
  if ((int )*(tree->cp) != 61) {
#line 1883
    return (8);
  }
#line 1885
  (tree->cp) ++;
#line 1887
  return (13);
  case_46: /* CIL Label */ 
#line 1890
  return (5);
  case_44: /* CIL Label */ 
#line 1893
  return (4);
  case_126: /* CIL Label */ 
#line 1896
  return (9);
  case_94: /* CIL Label */ 
#line 1899
  return (26);
  case_40: /* CIL Label */ 
#line 1902
  return (6);
  case_41: /* CIL Label */ 
#line 1905
  return (7);
  case_38: /* CIL Label */ 
#line 1908
  if ((int )*(tree->cp) != 38) {
#line 1909
    return (24);
  }
#line 1911
  (tree->cp) ++;
#line 1913
  return (10);
  case_124: /* CIL Label */ 
#line 1916
  if ((int )*(tree->cp) != 124) {
#line 1917
    return (25);
  }
#line 1919
  (tree->cp) ++;
#line 1921
  return (11);
  case_43: /* CIL Label */ 
#line 1924
  return (19);
  case_45: /* CIL Label */ 
#line 1927
  return (20);
  case_42: /* CIL Label */ 
#line 1930
  return (21);
  case_47: /* CIL Label */ 
#line 1933
  return (22);
  case_37: /* CIL Label */ 
#line 1936
  return (23);
  case_63: /* CIL Label */ 
#line 1939
  return (27);
  case_58: /* CIL Label */ 
#line 1942
  return (28);
  case_60: /* CIL Label */ 
#line 1945
  if ((int )*(tree->cp) == 60) {
#line 1947
    (tree->cp) ++;
#line 1949
    return (29);
  }
#line 1952
  if ((int )*(tree->cp) != 61) {
#line 1953
    return (14);
  }
#line 1955
  (tree->cp) ++;
#line 1957
  return (15);
  case_62: /* CIL Label */ 
#line 1960
  if ((int )*(tree->cp) == 62) {
#line 1962
    (tree->cp) ++;
#line 1964
    return (30);
  }
#line 1967
  if ((int )*(tree->cp) != 61) {
#line 1968
    return (16);
  }
#line 1970
  (tree->cp) ++;
#line 1972
  return (17);
  case_61: /* CIL Label */ 
#line 1975
  if ((int )*(tree->cp) == 61) {
#line 1976
    (tree->cp) ++;
  }
#line 1978
  return (12);
  case_0: /* CIL Label */ 
#line 1981
  (tree->cp) --;
#line 1983
  return (1);
  case_34: /* CIL Label */ 
  case_39: /* CIL Label */ 
#line 1987
  (tree->tokenStr) ++;
  {
#line 1989
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1989
    if (! ((int )*(tree->cp) != ch)) {
#line 1989
      goto while_break___0;
    }
#line 1991
    if (*(tree->cp)) {
#line 1993
      (tree->cp) ++;
#line 1994
      goto while_continue___0;
    }
    {
#line 1997
    tmp___0 = BadToken(tree, (char *)"Unterminated string");
    }
#line 1997
    return (tmp___0);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2000
  *(tree->modExpr + (tree->cp - tree->expr)) = (char )'\000';
#line 2002
  (tree->cp) ++;
#line 2004
  return (18);
  switch_default: /* CIL Label */ 
#line 2007
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2013
  if (ch >= 48) {
#line 2013
    if (ch <= 57) {
      {
#line 2015
      (tree->cp) --;
#line 2016
      tmp___1 = ParseNumber(tree);
      }
#line 2016
      return (tmp___1);
    }
  }
#line 2022
  if (ch >= 97) {
#line 2022
    if (! (ch <= 122)) {
#line 2022
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2022
  if (ch >= 65) {
#line 2022
    if (! (ch <= 90)) {
      {
#line 2023
      tmp___2 = BadToken(tree, (char *)"Illegal token");
      }
#line 2023
      return (tmp___2);
    }
  } else {
    {
#line 2023
    tmp___2 = BadToken(tree, (char *)"Illegal token");
    }
#line 2023
    return (tmp___2);
  }
  {
#line 2028
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2028
    if (ch >= 97) {
#line 2028
      if (! (ch <= 122)) {
#line 2028
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 2028
    if (ch >= 65) {
#line 2028
      if (! (ch <= 90)) {
#line 2028
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 2028
    if (ch >= 48) {
#line 2028
      if (! (ch <= 57)) {
#line 2028
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2028
    if (! (ch == 95)) {
#line 2028
      goto while_break___1;
    }
#line 2029
    tmp___3 = tree->cp;
#line 2029
    (tree->cp) ++;
#line 2029
    ch = (int )*tmp___3;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2031
  (tree->cp) --;
#line 2032
  *(tree->modExpr + (tree->cp - tree->expr)) = (char )'\000';
#line 2034
  return (2);
}
}
#line 2044 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
static TOKEN ParseNumber(TREE *tree ) 
{ 
  long value ;
  int ch ;
  char *tmp ;
  TOKEN tmp___0 ;
  char *tmp___1 ;
  TOKEN tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  TOKEN tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  TOKEN tmp___8 ;

  {
#line 2050
  value = 0L;
#line 2051
  tmp = tree->cp;
#line 2051
  (tree->cp) ++;
#line 2051
  ch = (int )*tmp;
#line 2053
  if (ch >= 48) {
#line 2053
    if (! (ch <= 57)) {
      {
#line 2055
      (tree->cp) --;
#line 2057
      tmp___0 = BadToken(tree, (char *)"Number expected");
      }
#line 2057
      return (tmp___0);
    }
  } else {
    {
#line 2055
    (tree->cp) --;
#line 2057
    tmp___0 = BadToken(tree, (char *)"Number expected");
    }
#line 2057
    return (tmp___0);
  }
#line 2063
  if (ch != 48) {
    {
#line 2065
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2065
      if (ch >= 48) {
#line 2065
        if (! (ch <= 57)) {
#line 2065
          goto while_break;
        }
      } else {
#line 2065
        goto while_break;
      }
#line 2067
      value = (value * 10L + (long )ch) - 48L;
#line 2068
      tmp___1 = tree->cp;
#line 2068
      (tree->cp) ++;
#line 2068
      ch = (int )*tmp___1;
    }
    while_break: /* CIL Label */ ;
    }
#line 2071
    (tree->cp) --;
#line 2073
    if (ch >= 97) {
#line 2073
      if (ch <= 122) {
        {
#line 2074
        tmp___2 = BadToken(tree, (char *)"Bad decimal number");
        }
#line 2074
        return (tmp___2);
      } else {
#line 2073
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 2073
    if (ch >= 65) {
#line 2073
      if (ch <= 90) {
        {
#line 2074
        tmp___2 = BadToken(tree, (char *)"Bad decimal number");
        }
#line 2074
        return (tmp___2);
      } else {
#line 2073
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2073
    if (ch >= 48) {
#line 2073
      if (ch <= 57) {
        {
#line 2074
        tmp___2 = BadToken(tree, (char *)"Bad decimal number");
        }
#line 2074
        return (tmp___2);
      } else {
#line 2073
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2073
    if (ch == 95) {
      {
#line 2074
      tmp___2 = BadToken(tree, (char *)"Bad decimal number");
      }
#line 2074
      return (tmp___2);
    }
#line 2076
    tree->tokenInt = value;
#line 2078
    return (3);
  }
#line 2085
  tmp___3 = tree->cp;
#line 2085
  (tree->cp) ++;
#line 2085
  ch = (int )*tmp___3;
#line 2087
  if (ch != 120) {
#line 2087
    if (ch != 88) {
      {
#line 2089
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2089
        if (ch >= 48) {
#line 2089
          if (! (ch <= 55)) {
#line 2089
            goto while_break___0;
          }
        } else {
#line 2089
          goto while_break___0;
        }
#line 2091
        value = (value * 8L + (long )ch) - 48L;
#line 2092
        tmp___4 = tree->cp;
#line 2092
        (tree->cp) ++;
#line 2092
        ch = (int )*tmp___4;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2095
      (tree->cp) --;
#line 2097
      if (ch >= 97) {
#line 2097
        if (ch <= 122) {
          {
#line 2098
          tmp___5 = BadToken(tree, (char *)"Bad octal number");
          }
#line 2098
          return (tmp___5);
        } else {
#line 2097
          goto _L___4;
        }
      } else
      _L___4: /* CIL Label */ 
#line 2097
      if (ch >= 65) {
#line 2097
        if (ch <= 90) {
          {
#line 2098
          tmp___5 = BadToken(tree, (char *)"Bad octal number");
          }
#line 2098
          return (tmp___5);
        } else {
#line 2097
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 2097
      if (ch >= 48) {
#line 2097
        if (ch <= 57) {
          {
#line 2098
          tmp___5 = BadToken(tree, (char *)"Bad octal number");
          }
#line 2098
          return (tmp___5);
        } else {
#line 2097
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 2097
      if (ch == 95) {
        {
#line 2098
        tmp___5 = BadToken(tree, (char *)"Bad octal number");
        }
#line 2098
        return (tmp___5);
      }
#line 2100
      tree->tokenInt = value;
#line 2102
      return (3);
    }
  }
#line 2108
  tmp___6 = tree->cp;
#line 2108
  (tree->cp) ++;
#line 2108
  ch = (int )*tmp___6;
  {
#line 2110
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2110
    if (ch >= 97) {
#line 2110
      if (! (ch <= 102)) {
#line 2110
        goto _L___7;
      }
    } else
    _L___7: /* CIL Label */ 
#line 2110
    if (ch >= 65) {
#line 2110
      if (! (ch <= 70)) {
#line 2110
        goto _L___6;
      }
    } else
    _L___6: /* CIL Label */ 
#line 2110
    if (ch >= 48) {
#line 2110
      if (! (ch <= 57)) {
#line 2110
        goto while_break___1;
      }
    } else {
#line 2110
      goto while_break___1;
    }
#line 2112
    value *= 16L;
#line 2114
    if (ch >= 48) {
#line 2114
      if (ch <= 57) {
#line 2115
        value += (long )(ch - 48);
      } else {
#line 2114
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 2116
    if (ch >= 97) {
#line 2116
      if (ch <= 122) {
#line 2117
        value += (long )((ch - 97) + 10);
      } else {
#line 2119
        value += (long )((ch - 65) + 10);
      }
    } else {
#line 2119
      value += (long )((ch - 65) + 10);
    }
#line 2121
    tmp___7 = tree->cp;
#line 2121
    (tree->cp) ++;
#line 2121
    ch = (int )*tmp___7;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2124
  (tree->cp) --;
#line 2126
  if (ch >= 97) {
#line 2126
    if (ch <= 122) {
      {
#line 2127
      tmp___8 = BadToken(tree, (char *)"Bad hex number");
      }
#line 2127
      return (tmp___8);
    } else {
#line 2126
      goto _L___10;
    }
  } else
  _L___10: /* CIL Label */ 
#line 2126
  if (ch >= 65) {
#line 2126
    if (ch <= 90) {
      {
#line 2127
      tmp___8 = BadToken(tree, (char *)"Bad hex number");
      }
#line 2127
      return (tmp___8);
    } else {
#line 2126
      goto _L___9;
    }
  } else
  _L___9: /* CIL Label */ 
#line 2126
  if (ch >= 48) {
#line 2126
    if (ch <= 57) {
      {
#line 2127
      tmp___8 = BadToken(tree, (char *)"Bad hex number");
      }
#line 2127
      return (tmp___8);
    } else {
#line 2126
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 2126
  if (ch == 95) {
    {
#line 2127
    tmp___8 = BadToken(tree, (char *)"Bad hex number");
    }
#line 2127
    return (tmp___8);
  }
#line 2129
  tree->tokenInt = value;
#line 2131
  return (3);
}
}
#line 2139 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
static TOKEN BadToken(TREE *tree , char *msg ) 
{ 


  {
#line 2142
  if (! tree->failed) {
    {
#line 2144
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            msg);
#line 2146
    tree->failed = 1;
    }
  }
#line 2149
  return (0);
}
}
#line 2157 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
static NODE *NewNode(TREE *tree , OP op , NODE *left , NODE *right ) 
{ 
  NODE *node ;
  void *tmp ;
  NODE *tmp___0 ;

  {
  {
#line 2162
  tmp = malloc(sizeof(NODE ));
#line 2162
  node = (NODE *)tmp;
  }
#line 2164
  if ((unsigned long )node == (unsigned long )((void *)0)) {
    {
#line 2165
    tmp___0 = BadNode(tree, (char *)"Cannot allocate memory");
    }
#line 2165
    return (tmp___0);
  }
#line 2167
  if (op == 0) {
#line 2168
    tree->failed = 1;
  }
#line 2170
  node->op = op;
#line 2171
  node->child[0] = left;
#line 2172
  node->child[1] = right;
#line 2173
  node->child[2] = (NODE *)((void *)0);
#line 2174
  node->column = (COLUMN *)((void *)0);
#line 2175
  node->strVal = (char *)"";
#line 2176
  node->intVal = 0L;
#line 2178
  return (node);
}
}
#line 2187 "/home/june/repo/benchmarks/collector/temp/ips-4.0/cond.c"
static NODE *BadNode(TREE *tree , char *message ) 
{ 


  {
#line 2190
  if (! tree->failed) {
    {
#line 2192
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            message);
#line 2194
    tree->failed = 1;
    }
  }
#line 2197
  badNode.op = 0;
#line 2198
  badNode.strVal = (char *)"";
#line 2200
  return (& badNode);
}
}
#line 572 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
void ListMacros(void) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/ips-4.0/macro.c"
static MACRO_HEADER macroLists[3]  = {      {(char *)"option", 1, (MACRO *)((void *)0)}, 
        {(char *)"column", 1, (MACRO *)((void *)0)}, 
        {(char *)"expr", 0, (MACRO *)((void *)0)}};
#line 65
static MACRO_HEADER *FindMacroHeader(MACRO_TYPE type ) ;
#line 66
static MACRO *FindMacro(MACRO_HEADER *head , char const   *name ) ;
#line 73 "/home/june/repo/benchmarks/collector/temp/ips-4.0/macro.c"
BOOL MacroExists(MACRO_TYPE type , char const   *name ) 
{ 
  MACRO_HEADER *head ;
  MACRO *tmp ;

  {
  {
#line 78
  head = FindMacroHeader(type);
  }
#line 80
  if ((unsigned long )head == (unsigned long )((void *)0)) {
#line 81
    return (0);
  }
  {
#line 83
  tmp = FindMacro(head, name);
  }
#line 83
  return ((unsigned long )tmp != (unsigned long )((MACRO *)0));
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/ips-4.0/macro.c"
BOOL ExpandMacro(MACRO_TYPE type , char const   *name , ARGS *retargs ) 
{ 
  MACRO_HEADER *head ;
  MACRO *macro ;

  {
#line 98
  retargs->table = (char **)((void *)0);
#line 99
  retargs->count = 0;
#line 101
  if ((int const   )*name >= 65) {
#line 101
    if (! ((int const   )*name <= 90)) {
      {
#line 103
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Macro name \"%s\" is not upper case\n",
              name);
      }
#line 105
      return (0);
    }
  } else {
    {
#line 103
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Macro name \"%s\" is not upper case\n",
            name);
    }
#line 105
    return (0);
  }
  {
#line 108
  head = FindMacroHeader(type);
  }
#line 110
  if ((unsigned long )head == (unsigned long )((void *)0)) {
#line 111
    return (0);
  }
  {
#line 113
  macro = FindMacro(head, name);
  }
#line 115
  if ((unsigned long )macro == (unsigned long )((MACRO *)0)) {
    {
#line 117
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Macro name \"%s\" is undefined\n",
            name);
    }
#line 119
    return (0);
  }
#line 122
  retargs->table = macro->values;
#line 123
  retargs->count = macro->count;
#line 125
  return (1);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/ips-4.0/macro.c"
BOOL DefineMacro(MACRO_TYPE type , char const   *name , char const   *str ) 
{ 
  MACRO_HEADER *head ;
  MACRO *macro ;
  char *bp ;
  char const   *word ;
  int wordCount ;
  int size ;
  int i ;
  int wordLengths[1000] ;
  char const   *words[1000] ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;

  {
#line 150
  if ((int const   )*name == 0) {
    {
#line 152
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing macro name for define\n");
    }
#line 154
    return (0);
  }
#line 157
  if ((int const   )*name >= 65) {
#line 157
    if (! ((int const   )*name <= 90)) {
      {
#line 159
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Macro name \"%s\" is not upper case\n",
              name);
      }
#line 162
      return (0);
    }
  } else {
    {
#line 159
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Macro name \"%s\" is not upper case\n",
            name);
    }
#line 162
    return (0);
  }
  {
#line 165
  tmp = strlen(name);
  }
#line 165
  if (tmp > 16UL) {
    {
#line 167
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Macro name \"%s\" is too long\n",
            name);
    }
#line 169
    return (0);
  }
  {
#line 172
  head = FindMacroHeader(type);
  }
#line 174
  if ((unsigned long )head == (unsigned long )((void *)0)) {
#line 175
    return (0);
  }
  {
#line 177
  tmp___0 = strlen(name);
#line 177
  size = (int )((sizeof(MACRO ) + tmp___0) + 1UL);
#line 179
  wordCount = 0;
  }
#line 185
  if (head->words) {
    {
#line 187
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 189
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 189
        if (! ((int const   )*str == 32)) {
#line 189
          if (! ((int const   )*str == 9)) {
#line 189
            goto while_break___0;
          }
        }
#line 190
        str ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 192
      if ((int const   )*str == 0) {
#line 193
        goto while_break;
      }
#line 195
      if (wordCount >= 1000) {
        {
#line 197
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Too many words defined for macro \"%s\"\n",
                name);
        }
#line 201
        return (0);
      }
#line 204
      word = str;
      {
#line 206
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 206
        if ((int const   )*str != 0) {
#line 206
          if ((int const   )*str == 32) {
#line 206
            goto while_break___1;
          } else
#line 206
          if ((int const   )*str == 9) {
#line 206
            goto while_break___1;
          }
        } else {
#line 206
          goto while_break___1;
        }
#line 207
        str ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 209
      words[wordCount] = word;
#line 210
      wordLengths[wordCount] = (int )(str - word);
#line 212
      size += wordLengths[wordCount] + 1;
#line 214
      wordCount ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 219
    if (wordCount >= 1000) {
      {
#line 221
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Too many words defined for macro \"%s\"\n",
              name);
      }
#line 225
      return (0);
    }
    {
#line 228
    words[wordCount] = str;
#line 229
    tmp___1 = strlen(str);
#line 229
    wordLengths[wordCount] = (int )tmp___1;
#line 231
    size += wordLengths[wordCount] + 1;
#line 233
    wordCount ++;
    }
  }
  {
#line 236
  size = (int )((unsigned long )size + sizeof(char *) * (unsigned long )(wordCount + 1));
#line 238
  tmp___2 = malloc((size_t )size);
#line 238
  macro = (MACRO *)tmp___2;
  }
#line 240
  if ((unsigned long )macro == (unsigned long )((void *)0)) {
    {
#line 242
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot allocate macro structure\n");
    }
#line 244
    return (0);
  }
  {
#line 247
  bp = macro->buf;
#line 249
  macro->values = (char **)bp;
#line 251
  bp += sizeof(char *) * (unsigned long )(wordCount + 1);
#line 253
  macro->name = bp;
#line 255
  strcpy((char */* __restrict  */)bp, (char const   */* __restrict  */)name);
#line 257
  tmp___3 = strlen((char const   *)bp);
#line 257
  bp += tmp___3 + 1UL;
#line 259
  i = 0;
  }
  {
#line 259
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 259
    if (! (i < wordCount)) {
#line 259
      goto while_break___2;
    }
    {
#line 261
    *(macro->values + i) = bp;
#line 263
    memcpy((void */* __restrict  */)bp, (void const   */* __restrict  */)words[i],
           (size_t )wordLengths[i]);
#line 265
    bp += wordLengths[i];
#line 267
    tmp___4 = bp;
#line 267
    bp ++;
#line 267
    *tmp___4 = (char )'\000';
#line 259
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 270
  *(macro->values + wordCount) = (char *)((void *)0);
#line 272
  macro->count = wordCount;
#line 274
  macro->next = head->list;
#line 275
  head->list = macro;
#line 277
  return (1);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/ips-4.0/macro.c"
static MACRO *FindMacro(MACRO_HEADER *head , char const   *name ) 
{ 
  MACRO *macro ;
  int tmp ;

  {
#line 286
  macro = head->list;
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 286
    if (! macro) {
#line 286
      goto while_break;
    }
    {
#line 288
    tmp = strcmp(name, (char const   *)macro->name);
    }
#line 288
    if (tmp == 0) {
#line 289
      return (macro);
    }
#line 286
    macro = macro->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 292
  return ((MACRO *)0);
}
}
#line 300 "/home/june/repo/benchmarks/collector/temp/ips-4.0/macro.c"
static MACRO_HEADER *FindMacroHeader(MACRO_TYPE type ) 
{ 


  {
#line 303
  if (type < 0) {
    {
#line 305
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Illegal macro type %d\n",
            type);
    }
#line 307
    return ((MACRO_HEADER *)((void *)0));
  } else
#line 303
  if (type >= 3) {
    {
#line 305
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Illegal macro type %d\n",
            type);
    }
#line 307
    return ((MACRO_HEADER *)((void *)0));
  }
#line 310
  return (& macroLists[type]);
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/ips-4.0/macro.c"
void ListMacros(void) 
{ 
  MACRO_TYPE type ;
  MACRO_HEADER const   *head ;
  MACRO const   *macro ;
  int i ;

  {
  {
#line 326
  printf((char const   */* __restrict  */)"%s\n", "#ips#");
#line 327
  printf((char const   */* __restrict  */)"# System initialization file is \"%s\".\n",
         "/usr/local/lib/ips.init");
#line 329
  type = 0;
  }
  {
#line 329
  while (1) {
    while_continue: /* CIL Label */ ;
#line 329
    if (! (type < 3)) {
#line 329
      goto while_break;
    }
#line 331
    head = (MACRO_HEADER const   *)(& macroLists[type]);
#line 333
    macro = (MACRO const   *)head->list;
    {
#line 333
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 333
      if (! macro) {
#line 333
        goto while_break___0;
      }
      {
#line 335
      printf((char const   */* __restrict  */)"%s %s", head->define, macro->name);
#line 337
      i = 0;
      }
      {
#line 337
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 337
        if (! (i < (int )macro->count)) {
#line 337
          goto while_break___1;
        }
        {
#line 338
        printf((char const   */* __restrict  */)" %s", *(macro->values + i));
#line 337
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 340
      printf((char const   */* __restrict  */)"\n");
#line 333
      macro = (MACRO const   *)macro->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 329
    type ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 343
  return;
}
}
#line 78 "/usr/include/pwd.h"
extern void endpwent(void) ;
#line 84
extern struct passwd *getpwent(void) ;
#line 71 "/usr/include/grp.h"
extern void endgrent(void) ;
#line 77
extern struct group *getgrent(void) ;
#line 263 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 537 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
char *CopyString(char const   *str ) ;
#line 538
void ReplaceString(char **variable , char const   *newValue ) ;
#line 549
double GetFloatingNumber(char const   **cpp ) ;
#line 580
uid_t FindUserId(char const   *name ) ;
#line 581
gid_t FindGroupId(char const   *name ) ;
#line 585
char const   *FindDeviceFromInode(dev_t dev , ino_t inode ) ;
#line 64 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
static int userNameCount  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
static int userNameAvail  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
static NAME *userNameTable  ;
#line 72 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
static int groupNameCount  ;
#line 73 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
static int groupNameAvail  ;
#line 74 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
static NAME *groupNameTable  ;
#line 80 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
static BOOL devNameCollected  ;
#line 81 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
static int devNameCount  ;
#line 82 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
static int devNameAvail  ;
#line 83 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
static DEVICE *devNameTable  ;
#line 106 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
static int tempStrAvail  ;
#line 113 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
static TEMPSTR *tempStrList  ;
#line 139 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
static SHARED_STR *sharedTable[101]  ;
#line 151
static void DeviceNameRecursion(char *pathBuffer , int usedLength , int maxDepth ) ;
#line 161 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
char *AllocateSharedString(char const   *str , int len ) 
{ 
  int begCh ;
  int midCh ;
  int endCh ;
  int tableIndex ;
  SHARED_STR *entry ;
  int tmp ;
  void *tmp___0 ;

  {
#line 170
  if (len < 0) {
#line 171
    return ((char *)((void *)0));
  }
#line 173
  if (len == 0) {
#line 174
    return (emptyString);
  }
#line 176
  if (len == 1) {
#line 176
    if ((int const   )*str == 47) {
#line 177
      return (rootString);
    }
  }
#line 182
  begCh = (int )*(str + 0);
#line 183
  midCh = (int )*(str + len / 2);
#line 184
  endCh = (int )*(str + (len - 1));
#line 190
  tableIndex = ((len + (begCh << 16)) + (midCh << 20)) + (endCh << 24);
#line 191
  tableIndex = (int )((unsigned int )tableIndex % 101U);
#line 198
  entry = sharedTable[tableIndex];
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    if (! entry) {
#line 198
      goto while_break;
    }
#line 200
    if (entry->len != len) {
#line 201
      goto __Cont;
    } else
#line 200
    if ((int )entry->buf[0] != begCh) {
#line 201
      goto __Cont;
    }
#line 203
    if ((int )entry->buf[len / 2] != midCh) {
#line 204
      goto __Cont;
    }
#line 206
    if ((int )entry->buf[len - 1] != endCh) {
#line 207
      goto __Cont;
    }
    {
#line 209
    tmp = memcmp((void const   *)(entry->buf), (void const   *)str, (size_t )len);
    }
#line 209
    if (tmp != 0) {
#line 210
      goto __Cont;
    }
#line 216
    (entry->count) ++;
#line 218
    return (entry->buf);
    __Cont: /* CIL Label */ 
#line 198
    entry = entry->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 226
  tmp___0 = malloc(sizeof(SHARED_STR ) + (unsigned long )len);
#line 226
  entry = (SHARED_STR *)tmp___0;
  }
#line 228
  if ((unsigned long )entry == (unsigned long )((void *)0)) {
#line 229
    return ((char *)((void *)0));
  }
  {
#line 231
  entry->next = sharedTable[tableIndex];
#line 232
  sharedTable[tableIndex] = entry;
#line 234
  entry->magic = 749712759L;
#line 235
  entry->tableIndex = tableIndex;
#line 236
  entry->count = 1;
#line 237
  entry->len = len;
#line 239
  memcpy((void */* __restrict  */)(entry->buf), (void const   */* __restrict  */)str,
         (size_t )len);
#line 241
  entry->buf[len] = (char )'\000';
  }
#line 243
  return (entry->buf);
}
}
#line 252 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
void FreeSharedString(char *str ) 
{ 
  SHARED_STR *entry ;
  SHARED_STR *prev ;
  int tableIndex ;

  {
#line 259
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 260
    return;
  } else
#line 259
  if ((unsigned long )str == (unsigned long )(emptyString)) {
#line 260
    return;
  } else
#line 259
  if ((unsigned long )str == (unsigned long )(rootString)) {
#line 260
    return;
  }
#line 266
  entry = (SHARED_STR *)(str - (int )(((SHARED_STR *)0)->buf));
#line 268
  tableIndex = entry->tableIndex;
#line 270
  if (entry->magic != 749712759L) {
    {
#line 273
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Freeing bad shared string header\n");
#line 275
    exit(1);
    }
  } else
#line 270
  if (tableIndex < 0) {
    {
#line 273
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Freeing bad shared string header\n");
#line 275
    exit(1);
    }
  } else
#line 270
  if (tableIndex >= 101) {
    {
#line 273
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Freeing bad shared string header\n");
#line 275
    exit(1);
    }
  } else
#line 270
  if (entry->len < 0) {
    {
#line 273
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Freeing bad shared string header\n");
#line 275
    exit(1);
    }
  }
#line 282
  (entry->count) --;
#line 284
  if (entry->count > 0) {
#line 285
    return;
  }
#line 292
  prev = sharedTable[tableIndex];
#line 294
  if ((unsigned long )prev == (unsigned long )entry) {
    {
#line 296
    sharedTable[tableIndex] = entry->next;
#line 298
    free((void *)((char *)entry));
    }
#line 300
    return;
  }
  {
#line 307
  while (1) {
    while_continue: /* CIL Label */ ;
#line 307
    if (! prev) {
#line 307
      goto while_break;
    }
#line 309
    if ((unsigned long )prev->next != (unsigned long )entry) {
#line 311
      prev = prev->next;
#line 313
      goto while_continue;
    }
    {
#line 316
    prev->next = entry->next;
#line 318
    free((void *)((char *)entry));
    }
#line 320
    return;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 323
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Freeing unknown shared string\n");
#line 324
  exit(1);
  }
}
}
#line 334 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
char *AllocTempString(int len ) 
{ 
  TEMPSTR *head ;
  char *cp ;
  void *tmp ;

  {
#line 340
  if (len <= 0) {
    {
#line 342
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Allocating bad length %d\n",
            len);
#line 344
    exit(1);
    }
  } else
#line 340
  if (len > 512) {
    {
#line 342
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Allocating bad length %d\n",
            len);
#line 344
    exit(1);
    }
  }
#line 347
  if (len > tempStrAvail) {
    {
#line 349
    tmp = AllocMemory((int )sizeof(TEMPSTR ));
#line 349
    head = (TEMPSTR *)tmp;
#line 351
    head->next = tempStrList;
#line 352
    tempStrList = head;
#line 354
    tempStrAvail = 16384;
    }
  }
#line 357
  cp = & tempStrList->buf[16384 - tempStrAvail];
#line 358
  tempStrAvail -= len;
#line 360
  return (cp);
}
}
#line 369 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
char *CopyTempString(char const   *oldcp ) 
{ 
  char *cp ;
  int len ;
  size_t tmp ;

  {
  {
#line 375
  tmp = strlen(oldcp);
#line 375
  len = (int )(tmp + 1UL);
#line 377
  cp = AllocTempString(len);
#line 379
  memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)oldcp, (size_t )len);
  }
#line 381
  return (cp);
}
}
#line 388 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
void FreeTempStrings(void) 
{ 
  TEMPSTR *head ;

  {
  {
#line 393
  while (1) {
    while_continue: /* CIL Label */ ;
#line 393
    if (! tempStrList) {
#line 393
      goto while_break;
    }
    {
#line 395
    head = tempStrList;
#line 396
    tempStrList = head->next;
#line 398
    free((void *)((char *)head));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 401
  tempStrAvail = 0;
#line 402
  return;
}
}
#line 409 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
void *AllocMemory(int len ) 
{ 
  void *buffer ;
  void *tmp ;

  {
  {
#line 414
  tmp = malloc((size_t )len);
#line 414
  buffer = tmp;
  }
#line 416
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
    {
#line 418
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to allocate %d bytes\n",
            len);
#line 420
    exit(1);
    }
  }
#line 423
  return (buffer);
}
}
#line 431 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
void *ReallocMemory(void *oldBuffer , int len ) 
{ 
  char *buffer ;
  void *tmp ;

  {
  {
#line 436
  tmp = realloc(oldBuffer, (size_t )len);
#line 436
  buffer = (char *)tmp;
  }
#line 438
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
    {
#line 440
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to reallocate %d bytes\n",
            len);
#line 442
    exit(1);
    }
  }
#line 445
  return ((void *)buffer);
}
}
#line 453 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
char *CopyString(char const   *str ) 
{ 
  char *newStr ;
  int len ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 459
  tmp = strlen(str);
#line 459
  len = (int )(tmp + 1UL);
#line 461
  tmp___0 = AllocMemory(len);
#line 461
  newStr = (char *)tmp___0;
#line 463
  memcpy((void */* __restrict  */)newStr, (void const   */* __restrict  */)str, (size_t )len);
  }
#line 465
  return (newStr);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
void ReplaceString(char **variable , char const   *newValue ) 
{ 


  {
  {
#line 476
  free((void *)*variable);
#line 478
  *variable = (char *)((void *)0);
  }
#line 480
  if (newValue) {
    {
#line 481
    *variable = CopyString(newValue);
    }
  }
#line 482
  return;
}
}
#line 489 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
void MakePrintable(char *cp , int len ) 
{ 
  int ch ;
  int tmp ;

  {
  {
#line 494
  while (1) {
    while_continue: /* CIL Label */ ;
#line 494
    tmp = len;
#line 494
    len --;
#line 494
    if (! (tmp > 0)) {
#line 494
      goto while_break;
    }
#line 496
    ch = (int )*cp;
#line 498
    if (ch == 0) {
#line 499
      *cp = (char )' ';
    } else
#line 500
    if (ch < 32) {
#line 501
      *cp = (char )'?';
    } else
#line 500
    if (ch >= 127) {
#line 501
      *cp = (char )'?';
    }
#line 503
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 505
  return;
}
}
#line 518 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
BOOL PatternMatch(char const   *text , char const   *pattern ) 
{ 
  char const   *retryPat ;
  char const   *retryTxt ;
  int ch ;
  BOOL isFound ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 526
  retryPat = (char const   *)((void *)0);
#line 527
  retryTxt = (char const   *)((void *)0);
  {
#line 529
  while (1) {
    while_continue: /* CIL Label */ ;
#line 529
    if (! *text) {
#line 529
      if (! *pattern) {
#line 529
        goto while_break;
      }
    }
#line 531
    tmp = pattern;
#line 531
    pattern ++;
#line 531
    ch = (int )*tmp;
    {
#line 535
    if (ch == 42) {
#line 535
      goto case_42;
    }
#line 540
    if (ch == 91) {
#line 540
      goto case_91;
    }
#line 565
    if (ch == 63) {
#line 565
      goto case_63;
    }
#line 571
    if (ch == 92) {
#line 571
      goto case_92;
    }
#line 581
    goto switch_default;
    case_42: /* CIL Label */ 
#line 536
    retryPat = pattern;
#line 537
    retryTxt = text;
#line 538
    goto switch_break;
    case_91: /* CIL Label */ 
#line 541
    isFound = 0;
    {
#line 543
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 543
      tmp___1 = pattern;
#line 543
      pattern ++;
#line 543
      ch = (int )*tmp___1;
#line 543
      if (! (ch != 93)) {
#line 543
        goto while_break___0;
      }
#line 545
      if (ch == 92) {
#line 546
        tmp___0 = pattern;
#line 546
        pattern ++;
#line 546
        ch = (int )*tmp___0;
      }
#line 548
      if (ch == 0) {
#line 549
        return (0);
      }
#line 551
      if ((int const   )*text == (int const   )ch) {
#line 552
        isFound = 1;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 555
    if (! isFound) {
#line 557
      pattern = retryPat;
#line 558
      retryTxt ++;
#line 558
      text = retryTxt;
    }
    case_63: /* CIL Label */ 
#line 566
    tmp___2 = text;
#line 566
    text ++;
#line 566
    if ((int const   )*tmp___2 == 0) {
#line 567
      return (0);
    }
#line 569
    goto switch_break;
    case_92: /* CIL Label */ 
#line 572
    tmp___3 = pattern;
#line 572
    pattern ++;
#line 572
    ch = (int )*tmp___3;
#line 574
    if (ch == 0) {
#line 575
      return (0);
    }
    switch_default: /* CIL Label */ 
#line 582
    if ((int const   )*text == (int const   )ch) {
#line 584
      if (*text) {
#line 585
        text ++;
      }
#line 587
      goto switch_break;
    }
#line 590
    if (*text) {
#line 592
      pattern = retryPat;
#line 593
      retryTxt ++;
#line 593
      text = retryTxt;
#line 594
      goto switch_break;
    }
#line 597
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 600
    if ((unsigned long )pattern == (unsigned long )((void *)0)) {
#line 601
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 604
  return (1);
}
}
#line 612 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
void CollectUserNames(void) 
{ 
  struct passwd  const  *pwd ;
  NAME *name ;
  void *tmp ;
  int tmp___0 ;
  struct passwd *tmp___1 ;

  {
#line 618
  if (userNameCount > 0) {
#line 619
    return;
  }
  {
#line 621
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 621
    tmp___1 = getpwent();
#line 621
    pwd = (struct passwd  const  *)tmp___1;
    }
#line 621
    if (! ((unsigned long )pwd != (unsigned long )((void *)0))) {
#line 621
      goto while_break;
    }
#line 623
    if (userNameCount >= userNameAvail) {
      {
#line 625
      userNameAvail += 1000;
#line 627
      tmp = realloc((void *)userNameTable, (unsigned long )userNameAvail * sizeof(NAME ));
#line 627
      userNameTable = (NAME *)tmp;
      }
#line 630
      if ((unsigned long )userNameTable == (unsigned long )((void *)0)) {
        {
#line 632
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot allocate memory\n");
#line 633
        exit(1);
        }
      }
    }
    {
#line 637
    tmp___0 = userNameCount;
#line 637
    userNameCount ++;
#line 637
    name = userNameTable + tmp___0;
#line 639
    name->id.uid = (uid_t )pwd->pw_uid;
#line 640
    strncpy((char */* __restrict  */)(name->name), (char const   */* __restrict  */)pwd->pw_name,
            (size_t )16);
#line 641
    name->name[16] = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 644
  endpwent();
  }
#line 645
  return;
}
}
#line 652 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
char const   *FindUserName(uid_t uid ) 
{ 
  NAME const   *user ;
  int count ;
  int tmp ;

  {
#line 658
  user = (NAME const   *)userNameTable;
#line 659
  count = userNameCount;
  {
#line 661
  while (1) {
    while_continue: /* CIL Label */ ;
#line 661
    tmp = count;
#line 661
    count --;
#line 661
    if (! (tmp > 0)) {
#line 661
      goto while_break;
    }
#line 663
    if (user->id.uid == (uid_t const   )uid) {
#line 664
      return ((char const   *)(user->name));
    }
#line 666
    user ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 669
  return ((char const   *)((void *)0));
}
}
#line 677 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
uid_t FindUserId(char const   *name ) 
{ 
  NAME const   *user ;
  int count ;
  int tmp ;
  int tmp___0 ;

  {
#line 683
  user = (NAME const   *)userNameTable;
#line 684
  count = userNameCount;
  {
#line 686
  while (1) {
    while_continue: /* CIL Label */ ;
#line 686
    tmp___0 = count;
#line 686
    count --;
#line 686
    if (! (tmp___0 > 0)) {
#line 686
      goto while_break;
    }
    {
#line 688
    tmp = strcmp((char const   *)(user->name), name);
    }
#line 688
    if (tmp == 0) {
#line 689
      return ((uid_t )user->id.uid);
    }
#line 691
    user ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 694
  return ((uid_t )-1);
}
}
#line 702 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
void CollectGroupNames(void) 
{ 
  struct group  const  *grp ;
  NAME *name ;
  void *tmp ;
  int tmp___0 ;
  struct group *tmp___1 ;

  {
#line 708
  if (groupNameCount > 0) {
#line 709
    return;
  }
  {
#line 711
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 711
    tmp___1 = getgrent();
#line 711
    grp = (struct group  const  *)tmp___1;
    }
#line 711
    if (! ((unsigned long )grp != (unsigned long )((void *)0))) {
#line 711
      goto while_break;
    }
#line 713
    if (groupNameCount >= groupNameAvail) {
      {
#line 715
      groupNameAvail += 1000;
#line 717
      tmp = realloc((void *)groupNameTable, (unsigned long )groupNameAvail * sizeof(NAME ));
#line 717
      groupNameTable = (NAME *)tmp;
      }
#line 720
      if ((unsigned long )groupNameTable == (unsigned long )((void *)0)) {
        {
#line 722
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot allocate memory\n");
#line 723
        exit(1);
        }
      }
    }
    {
#line 727
    tmp___0 = groupNameCount;
#line 727
    groupNameCount ++;
#line 727
    name = groupNameTable + tmp___0;
#line 729
    name->id.gid = (gid_t )grp->gr_gid;
#line 730
    strncpy((char */* __restrict  */)(name->name), (char const   */* __restrict  */)grp->gr_name,
            (size_t )16);
#line 731
    name->name[16] = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 734
  endgrent();
  }
#line 735
  return;
}
}
#line 742 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
char const   *FindGroupName(gid_t gid ) 
{ 
  NAME const   *group ;
  int count ;
  int tmp ;

  {
#line 748
  group = (NAME const   *)groupNameTable;
#line 749
  count = groupNameCount;
  {
#line 751
  while (1) {
    while_continue: /* CIL Label */ ;
#line 751
    tmp = count;
#line 751
    count --;
#line 751
    if (! (tmp > 0)) {
#line 751
      goto while_break;
    }
#line 753
    if (group->id.gid == (gid_t const   )gid) {
#line 754
      return ((char const   *)(group->name));
    }
#line 756
    group ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 759
  return ((char const   *)((void *)0));
}
}
#line 767 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
gid_t FindGroupId(char const   *name ) 
{ 
  NAME const   *group ;
  int count ;
  int tmp ;
  int tmp___0 ;

  {
#line 773
  group = (NAME const   *)groupNameTable;
#line 774
  count = groupNameCount;
  {
#line 776
  while (1) {
    while_continue: /* CIL Label */ ;
#line 776
    tmp___0 = count;
#line 776
    count --;
#line 776
    if (! (tmp___0 > 0)) {
#line 776
      goto while_break;
    }
    {
#line 778
    tmp = strcmp((char const   *)(group->name), name);
    }
#line 778
    if (tmp == 0) {
#line 779
      return ((gid_t )group->id.gid);
    }
#line 781
    group ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 784
  return ((gid_t )-1);
}
}
#line 792 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
void CollectDeviceNames(void) 
{ 
  char pathBuffer[514] ;
  size_t tmp ;

  {
#line 797
  if (devNameCollected) {
#line 798
    return;
  }
  {
#line 800
  strcpy((char */* __restrict  */)(pathBuffer), (char const   */* __restrict  */)"/dev");
#line 802
  tmp = strlen((char const   *)(pathBuffer));
#line 802
  DeviceNameRecursion(pathBuffer, (int )tmp, 3);
#line 804
  devNameCollected = 1;
  }
#line 805
  return;
}
}
#line 812 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
static void DeviceNameRecursion(char *pathBuffer , int usedLength , int maxDepth ) 
{ 
  DIR *dir ;
  struct dirent  const  *dp ;
  DEVICE *device ;
  int len ;
  struct stat statBuf ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  struct dirent *tmp___4 ;

  {
#line 821
  if (maxDepth <= 0) {
#line 822
    return;
  }
  {
#line 827
  dir = opendir((char const   *)pathBuffer);
  }
#line 829
  if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 830
    return;
  }
  {
#line 832
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 832
    tmp___4 = readdir(dir);
#line 832
    dp = (struct dirent  const  *)tmp___4;
    }
#line 832
    if (! ((unsigned long )dp != (unsigned long )((void *)0))) {
#line 832
      goto while_break;
    }
    {
#line 838
    tmp = strlen((char const   *)(dp->d_name));
#line 838
    len = (int )tmp;
    }
#line 840
    if (usedLength + len >= 512) {
#line 841
      goto while_break;
    }
#line 846
    if (len == 1) {
#line 846
      if ((int )dp->d_name[0] == 46) {
#line 847
        goto while_continue;
      }
    }
#line 849
    if (len == 2) {
#line 849
      if ((int )dp->d_name[0] == 46) {
#line 849
        if ((int )dp->d_name[1] == 46) {
#line 852
          goto while_continue;
        }
      }
    }
    {
#line 858
    *(pathBuffer + usedLength) = (char )'/';
#line 859
    strcpy((char */* __restrict  */)((pathBuffer + usedLength) + 1), (char const   */* __restrict  */)(dp->d_name));
#line 861
    tmp___0 = lstat((char const   */* __restrict  */)pathBuffer, (struct stat */* __restrict  */)(& statBuf));
    }
#line 861
    if (tmp___0 < 0) {
#line 862
      goto while_continue;
    }
#line 868
    if ((statBuf.st_mode & 61440U) == 16384U) {
      {
#line 870
      DeviceNameRecursion(pathBuffer, (usedLength + len) + 1, maxDepth - 1);
      }
#line 873
      goto while_continue;
    }
#line 880
    if (! ((statBuf.st_mode & 61440U) == 8192U)) {
#line 881
      goto while_continue;
    }
    {
#line 886
    tmp___1 = strcmp((char const   *)pathBuffer, "/dev/null");
    }
#line 886
    if (tmp___1 == 0) {
#line 888
      nullDevice = statBuf.st_dev;
#line 889
      nullInode = statBuf.st_ino;
    }
#line 896
    if (devNameCount >= devNameAvail) {
      {
#line 898
      devNameAvail += 1000;
#line 900
      tmp___2 = realloc((void *)devNameTable, (unsigned long )devNameAvail * sizeof(DEVICE ));
#line 900
      devNameTable = (DEVICE *)tmp___2;
      }
#line 903
      if ((unsigned long )devNameTable == (unsigned long )((void *)0)) {
        {
#line 905
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot allocate memory\n");
#line 906
        exit(1);
        }
      }
    }
    {
#line 914
    tmp___3 = devNameCount;
#line 914
    devNameCount ++;
#line 914
    device = devNameTable + tmp___3;
#line 916
    device->id = statBuf.st_rdev;
#line 917
    device->dev = statBuf.st_dev;
#line 918
    device->inode = statBuf.st_ino;
#line 920
    strncpy((char */* __restrict  */)(device->name), (char const   */* __restrict  */)(pathBuffer + sizeof("/dev")),
            (size_t )32);
#line 923
    device->name[32] = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 926
  closedir(dir);
  }
#line 927
  return;
}
}
#line 934 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
char const   *FindDeviceName(dev_t devid ) 
{ 
  DEVICE const   *device ;
  int count ;
  int tmp ;

  {
#line 940
  if (devid <= 0UL) {
#line 941
    return ("-");
  }
#line 943
  device = (DEVICE const   *)devNameTable;
#line 944
  count = devNameCount;
  {
#line 946
  while (1) {
    while_continue: /* CIL Label */ ;
#line 946
    tmp = count;
#line 946
    count --;
#line 946
    if (! (tmp > 0)) {
#line 946
      goto while_break;
    }
#line 948
    if (device->id == (dev_t const   )devid) {
#line 949
      return ((char const   *)(device->name));
    }
#line 951
    device ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 954
  return ((char const   *)((void *)0));
}
}
#line 962 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
char const   *FindDeviceFromInode(dev_t dev , ino_t inode ) 
{ 
  DEVICE const   *device ;
  int count ;
  int tmp ;

  {
#line 968
  device = (DEVICE const   *)devNameTable;
#line 969
  count = devNameCount;
  {
#line 971
  while (1) {
    while_continue: /* CIL Label */ ;
#line 971
    tmp = count;
#line 971
    count --;
#line 971
    if (! (tmp > 0)) {
#line 971
      goto while_break;
    }
#line 973
    if (device->dev == (dev_t const   )dev) {
#line 973
      if (device->inode == (ino_t const   )inode) {
#line 974
        return ((char const   *)(device->name));
      }
    }
#line 976
    device ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 979
  return ((char const   *)((void *)0));
}
}
#line 989 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
long GetDecimalNumber(char const   **cpp ) 
{ 
  long value ;
  BOOL isNeg ;
  char const   *cp ;
  char const   *tmp ;

  {
#line 996
  cp = *cpp;
#line 998
  isNeg = 0;
  {
#line 1000
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1000
    if (! ((int const   )*cp == 32)) {
#line 1000
      if (! ((int const   )*cp == 9)) {
#line 1000
        goto while_break;
      }
    }
#line 1001
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1003
  if ((int const   )*cp == 45) {
#line 1005
    isNeg = 1;
#line 1006
    cp ++;
  }
#line 1009
  value = 0L;
  {
#line 1011
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1011
    if ((int const   )*cp >= 48) {
#line 1011
      if (! ((int const   )*cp <= 57)) {
#line 1011
        goto while_break___0;
      }
    } else {
#line 1011
      goto while_break___0;
    }
#line 1012
    tmp = cp;
#line 1012
    cp ++;
#line 1012
    value = (value * 10L + (long )*tmp) - 48L;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1014
  if (isNeg) {
#line 1015
    value = - value;
  }
#line 1017
  *cpp = cp;
#line 1019
  return (value);
}
}
#line 1029 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
double GetFloatingNumber(char const   **cpp ) 
{ 
  double value ;
  double scale ;
  BOOL isNeg ;
  char const   *cp ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 1037
  cp = *cpp;
#line 1039
  isNeg = 0;
  {
#line 1041
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1041
    if (! ((int const   )*cp == 32)) {
#line 1041
      if (! ((int const   )*cp == 9)) {
#line 1041
        goto while_break;
      }
    }
#line 1042
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1044
  if ((int const   )*cp == 45) {
#line 1046
    isNeg = 1;
#line 1047
    cp ++;
  }
#line 1050
  value = 0.0;
#line 1051
  scale = 1.0;
  {
#line 1053
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1053
    if ((int const   )*cp >= 48) {
#line 1053
      if (! ((int const   )*cp <= 57)) {
#line 1053
        goto while_break___0;
      }
    } else {
#line 1053
      goto while_break___0;
    }
#line 1054
    tmp = cp;
#line 1054
    cp ++;
#line 1054
    value = (value * (double )10 + (double )*tmp) - (double )48;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1056
  if ((int const   )*cp == 46) {
#line 1057
    cp ++;
  }
  {
#line 1059
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1059
    if ((int const   )*cp >= 48) {
#line 1059
      if (! ((int const   )*cp <= 57)) {
#line 1059
        goto while_break___1;
      }
    } else {
#line 1059
      goto while_break___1;
    }
#line 1061
    tmp___0 = cp;
#line 1061
    cp ++;
#line 1061
    value = (value * 10.0 + (double )*tmp___0) - (double )48;
#line 1062
    scale *= 10.0;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1065
  value /= scale;
#line 1067
  if (isNeg) {
#line 1068
    value = - value;
  }
#line 1070
  *cpp = cp;
#line 1072
  return (value);
}
}
#line 1082 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
long ElapsedMilliSeconds(struct timeval  const  *oldTime , struct timeval  const  *newTime ) 
{ 
  long elapsedSeconds ;
  long elapsedMicroSeconds ;
  struct timeval currentTime___0 ;

  {
#line 1093
  if (oldTime->tv_sec == 0L) {
#line 1094
    return (0L);
  }
#line 1099
  if ((unsigned long )newTime == (unsigned long )((void *)0)) {
    {
#line 1101
    GetTimeOfDay(& currentTime___0);
#line 1102
    newTime = (struct timeval  const  *)(& currentTime___0);
    }
  }
#line 1105
  elapsedSeconds = (long )(newTime->tv_sec - oldTime->tv_sec);
#line 1106
  elapsedMicroSeconds = (long )(newTime->tv_usec - oldTime->tv_usec);
#line 1108
  if (elapsedMicroSeconds < 0L) {
#line 1110
    elapsedMicroSeconds += 1000000L;
#line 1111
    elapsedSeconds --;
  }
#line 1114
  if (elapsedSeconds < 0L) {
#line 1115
    return (0L);
  }
#line 1117
  return (elapsedSeconds * 1000L + elapsedMicroSeconds / 1000L);
}
}
#line 1124 "/home/june/repo/benchmarks/collector/temp/ips-4.0/utils.c"
void GetTimeOfDay(struct timeval *retTimeVal ) 
{ 
  int tmp ;

  {
  {
#line 1127
  tmp = gettimeofday((struct timeval */* __restrict  */)retTimeVal, (__timezone_ptr_t )((void *)0));
  }
#line 1127
  if (tmp == 0) {
#line 1128
    return;
  }
  {
#line 1130
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot get time of day\n");
#line 1132
  exit(1);
  }
}
}
#line 554 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
void ClearSorting(void) ;
#line 557
BOOL AppendColumnSort(ARGS *ap , BOOL reverse ) ;
#line 558
BOOL AppendExpressionSort(ARGS *ap , BOOL reverse ) ;
#line 593
int ExpandArguments(ARGS *ap , char **table , int tableLen ) ;
#line 95 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
static OPTION option_table[59]  = 
#line 95 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
  {      {(char *)"col", 1}, 
        {(char *)"addcol", 2}, 
        {(char *)"remcol", 3}, 
        {(char *)"sep", 4}, 
        {(char *)"width", 5}, 
        {(char *)"sleep", 6}, 
        {(char *)"noself", 7}, 
        {(char *)"my", 9}, 
        {(char *)"active", 10}, 
        {(char *)"noroot", 11}, 
        {(char *)"clear", 12}, 
        {(char *)"read", 13}, 
        {(char *)"sort", 14}, 
        {(char *)"revsort", 15}, 
        {(char *)"sortexpr", 16}, 
        {(char *)"revsortexpr", 36}, 
        {(char *)"nosort", 17}, 
        {(char *)"loop", 18}, 
        {(char *)"once", 41}, 
        {(char *)"curses", 39}, 
        {(char *)"x11", 40}, 
        {(char *)"vert", 35}, 
        {(char *)"initsleep", 19}, 
        {(char *)"cond", 20}, 
        {(char *)"top", 21}, 
        {(char *)"noheader", 22}, 
        {(char *)"pid", 23}, 
        {(char *)"user", 24}, 
        {(char *)"group", 34}, 
        {(char *)"program", 38}, 
        {(char *)"h", 25}, 
        {(char *)"help", 25}, 
        {(char *)"?", 25}, 
        {(char *)"listcolumns", 26}, 
        {(char *)"end", 27}, 
        {(char *)"noinit", 28}, 
        {(char *)"activetime", 29}, 
        {(char *)"deathtime", 49}, 
        {(char *)"listmacros", 30}, 
        {(char *)"version", 31}, 
        {(char *)"default", 32}, 
        {(char *)"synctime", 33}, 
        {(char *)"colwidth", 37}, 
        {(char *)"display", 42}, 
        {(char *)"font", 43}, 
        {(char *)"foreground", 44}, 
        {(char *)"background", 45}, 
        {(char *)"scroll", 46}, 
        {(char *)"overlap", 47}, 
        {(char *)"info", 48}, 
        {(char *)"geometry", 50}, 
        {(char *)"showthreads", 51}, 
        {(char *)"usethreads", 52}, 
        {(char *)"nocopy", 53}, 
        {(char *)"infocolor", 54}, 
        {(char *)"headercolor", 55}, 
        {(char *)"rowcolor", 56}, 
        {(char *)"percentseconds", 57}, 
        {(char *)((void *)0), 0}};
#line 162
static BOOL ReadFile(ARGS *ap ) ;
#line 163
static BOOL SetSleepTime(ARGS *ap ) ;
#line 164
static BOOL SetActiveTime(ARGS *ap ) ;
#line 165
static BOOL SetDeathTime(ARGS *ap ) ;
#line 166
static BOOL SetSyncTime(ARGS *ap ) ;
#line 167
static BOOL SetTopCount(ARGS *ap ) ;
#line 168
static BOOL SetInitTime(ARGS *ap ) ;
#line 169
static BOOL SetCondition(ARGS *ap ) ;
#line 170
static BOOL SetSeparation(ARGS *ap ) ;
#line 171
static BOOL SetWidth(ARGS *ap ) ;
#line 172
static BOOL SetColumns(ARGS *ap ) ;
#line 173
static BOOL SetColumnWidth(ARGS *ap ) ;
#line 174
static BOOL SetPids(ARGS *ap ) ;
#line 175
static BOOL SetUsers(ARGS *ap ) ;
#line 176
static BOOL SetGroups(ARGS *ap ) ;
#line 177
static BOOL SetPrograms(ARGS *ap ) ;
#line 178
static BOOL SetFont(ARGS *ap ) ;
#line 179
static BOOL SetGeometry(ARGS *ap ) ;
#line 180
static BOOL SetForeground(ARGS *ap ) ;
#line 181
static BOOL SetBackground(ARGS *ap ) ;
#line 182
static BOOL SetDisplay(ARGS *ap ) ;
#line 183
static BOOL SetScrollTime(ARGS *ap ) ;
#line 184
static BOOL SetOverlapLines(ARGS *ap ) ;
#line 185
static BOOL SetInfoColor(ARGS *ap ) ;
#line 186
static BOOL SetHeaderColor(ARGS *ap ) ;
#line 187
static BOOL SetDefault(ARGS *ap ) ;
#line 188
static BOOL AddColumns(ARGS *ap ) ;
#line 189
static BOOL RemoveColumns(ARGS *ap ) ;
#line 190
static BOOL SetRowColorCondition(ARGS *ap ) ;
#line 191
static BOOL SetPercentSeconds(ARGS *ap ) ;
#line 193
static void DefaultOneOption(int id ) ;
#line 194
static void PrintUsage(void) ;
#line 195
static void PrintVersion(void) ;
#line 203 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
BOOL ParseOptions(ARGS *ap , int depth ) 
{ 
  OPTION const   *option ;
  char const   *str ;
  BOOL status ;
  BOOL isSuccess ;
  char **tmp ;
  BOOL tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 211
  isSuccess = 1;
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
#line 213
    tmp___2 = ap->count;
#line 213
    (ap->count) --;
#line 213
    if (! (tmp___2 > 0)) {
#line 213
      goto while_break;
    }
#line 215
    tmp = ap->table;
#line 215
    (ap->table) ++;
#line 215
    str = (char const   *)*tmp;
#line 222
    if ((int const   )*str != 45) {
      {
#line 224
      tmp___0 = ExpandOptionName(str, depth);
      }
#line 224
      if (! tmp___0) {
#line 225
        return (0);
      }
#line 227
      goto while_continue;
    }
#line 233
    str ++;
#line 235
    option = (OPTION const   *)(option_table);
    {
#line 237
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 237
      if (option->name) {
        {
#line 237
        tmp___1 = strcmp((char const   *)option->name, str);
        }
#line 237
        if (! (tmp___1 != 0)) {
#line 237
          goto while_break___0;
        }
      } else {
#line 237
        goto while_break___0;
      }
#line 238
      option ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 240
    status = 1;
    {
#line 244
    if (option->id == 1) {
#line 244
      goto case_1;
    }
#line 248
    if (option->id == 2) {
#line 248
      goto case_2;
    }
#line 252
    if (option->id == 3) {
#line 252
      goto case_3;
    }
#line 256
    if (option->id == 4) {
#line 256
      goto case_4;
    }
#line 260
    if (option->id == 5) {
#line 260
      goto case_5;
    }
#line 264
    if (option->id == 6) {
#line 264
      goto case_6;
    }
#line 268
    if (option->id == 29) {
#line 268
      goto case_29;
    }
#line 272
    if (option->id == 49) {
#line 272
      goto case_49;
    }
#line 276
    if (option->id == 33) {
#line 276
      goto case_33;
    }
#line 280
    if (option->id == 37) {
#line 280
      goto case_37;
    }
#line 284
    if (option->id == 21) {
#line 284
      goto case_21;
    }
#line 288
    if (option->id == 19) {
#line 288
      goto case_19;
    }
#line 292
    if (option->id == 20) {
#line 292
      goto case_20;
    }
#line 296
    if (option->id == 7) {
#line 296
      goto case_7;
    }
#line 300
    if (option->id == 11) {
#line 300
      goto case_11;
    }
#line 304
    if (option->id == 22) {
#line 304
      goto case_22;
    }
#line 308
    if (option->id == 48) {
#line 308
      goto case_48;
    }
#line 312
    if (option->id == 51) {
#line 312
      goto case_51;
    }
#line 316
    if (option->id == 52) {
#line 316
      goto case_52;
    }
#line 320
    if (option->id == 53) {
#line 320
      goto case_53;
    }
#line 323
    if (option->id == 9) {
#line 323
      goto case_9;
    }
#line 327
    if (option->id == 10) {
#line 327
      goto case_10;
    }
#line 331
    if (option->id == 12) {
#line 331
      goto case_12;
    }
#line 335
    if (option->id == 13) {
#line 335
      goto case_13;
    }
#line 339
    if (option->id == 14) {
#line 339
      goto case_14;
    }
#line 343
    if (option->id == 15) {
#line 343
      goto case_15;
    }
#line 347
    if (option->id == 16) {
#line 347
      goto case_16;
    }
#line 351
    if (option->id == 36) {
#line 351
      goto case_36;
    }
#line 355
    if (option->id == 17) {
#line 355
      goto case_17;
    }
#line 359
    if (option->id == 32) {
#line 359
      goto case_32;
    }
#line 363
    if (option->id == 41) {
#line 363
      goto case_41;
    }
#line 368
    if (option->id == 18) {
#line 368
      goto case_18;
    }
#line 373
    if (option->id == 39) {
#line 373
      goto case_39;
    }
#line 378
    if (option->id == 40) {
#line 378
      goto case_40;
    }
#line 383
    if (option->id == 35) {
#line 383
      goto case_35;
    }
#line 387
    if (option->id == 23) {
#line 387
      goto case_23;
    }
#line 391
    if (option->id == 24) {
#line 391
      goto case_24;
    }
#line 395
    if (option->id == 34) {
#line 395
      goto case_34;
    }
#line 399
    if (option->id == 38) {
#line 399
      goto case_38;
    }
#line 403
    if (option->id == 50) {
#line 403
      goto case_50;
    }
#line 407
    if (option->id == 43) {
#line 407
      goto case_43;
    }
#line 411
    if (option->id == 44) {
#line 411
      goto case_44;
    }
#line 415
    if (option->id == 45) {
#line 415
      goto case_45;
    }
#line 419
    if (option->id == 42) {
#line 419
      goto case_42;
    }
#line 423
    if (option->id == 57) {
#line 423
      goto case_57;
    }
#line 427
    if (option->id == 46) {
#line 427
      goto case_46;
    }
#line 431
    if (option->id == 47) {
#line 431
      goto case_47;
    }
#line 435
    if (option->id == 54) {
#line 435
      goto case_54;
    }
#line 439
    if (option->id == 55) {
#line 439
      goto case_55;
    }
#line 443
    if (option->id == 56) {
#line 443
      goto case_56;
    }
#line 447
    if (option->id == 25) {
#line 447
      goto case_25;
    }
#line 451
    if (option->id == 26) {
#line 451
      goto case_26;
    }
#line 455
    if (option->id == 30) {
#line 455
      goto case_30;
    }
#line 459
    if (option->id == 31) {
#line 459
      goto case_31;
    }
#line 463
    if (option->id == 27) {
#line 463
      goto case_27;
    }
#line 466
    if (option->id == 28) {
#line 466
      goto case_28;
    }
#line 473
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 245
    status = SetColumns(ap);
    }
#line 246
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 249
    status = AddColumns(ap);
    }
#line 250
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 253
    status = RemoveColumns(ap);
    }
#line 254
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 257
    status = SetSeparation(ap);
    }
#line 258
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 261
    status = SetWidth(ap);
    }
#line 262
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 265
    status = SetSleepTime(ap);
    }
#line 266
    goto switch_break;
    case_29: /* CIL Label */ 
    {
#line 269
    status = SetActiveTime(ap);
    }
#line 270
    goto switch_break;
    case_49: /* CIL Label */ 
    {
#line 273
    status = SetDeathTime(ap);
    }
#line 274
    goto switch_break;
    case_33: /* CIL Label */ 
    {
#line 277
    status = SetSyncTime(ap);
    }
#line 278
    goto switch_break;
    case_37: /* CIL Label */ 
    {
#line 281
    status = SetColumnWidth(ap);
    }
#line 282
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 285
    status = SetTopCount(ap);
    }
#line 286
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 289
    status = SetInitTime(ap);
    }
#line 290
    goto switch_break;
    case_20: /* CIL Label */ 
    {
#line 293
    status = SetCondition(ap);
    }
#line 294
    goto switch_break;
    case_7: /* CIL Label */ 
#line 297
    noSelf = 1;
#line 298
    goto switch_break;
    case_11: /* CIL Label */ 
#line 301
    noRoot = 1;
#line 302
    goto switch_break;
    case_22: /* CIL Label */ 
#line 305
    noHeader = 1;
#line 306
    goto switch_break;
    case_48: /* CIL Label */ 
#line 309
    isInfoShown = 1;
#line 310
    goto switch_break;
    case_51: /* CIL Label */ 
#line 313
    showThreads = 1;
#line 314
    goto switch_break;
    case_52: /* CIL Label */ 
#line 317
    useThreads = 1;
#line 318
    goto switch_break;
    case_53: /* CIL Label */ 
#line 321
    noCopy = 1;
    case_9: /* CIL Label */ 
#line 324
    myProcs = 1;
#line 325
    goto switch_break;
    case_10: /* CIL Label */ 
#line 328
    activeOnly = 1;
#line 329
    goto switch_break;
    case_12: /* CIL Label */ 
#line 332
    clearScreen = 1;
#line 333
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 336
    status = ReadFile(ap);
    }
#line 337
    goto switch_break;
    case_14: /* CIL Label */ 
    {
#line 340
    status = AppendColumnSort(ap, 0);
    }
#line 341
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 344
    status = AppendColumnSort(ap, 1);
    }
#line 345
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 348
    status = AppendExpressionSort(ap, 0);
    }
#line 349
    goto switch_break;
    case_36: /* CIL Label */ 
    {
#line 352
    status = AppendExpressionSort(ap, 1);
    }
#line 353
    goto switch_break;
    case_17: /* CIL Label */ 
    {
#line 356
    ClearSorting();
    }
#line 357
    goto switch_break;
    case_32: /* CIL Label */ 
    {
#line 360
    status = SetDefault(ap);
    }
#line 361
    goto switch_break;
    case_41: /* CIL Label */ 
#line 364
    isLooping = 0;
#line 365
    displayType = "tty";
#line 366
    goto switch_break;
    case_18: /* CIL Label */ 
#line 369
    isLooping = 1;
#line 370
    displayType = "tty";
#line 371
    goto switch_break;
    case_39: /* CIL Label */ 
#line 374
    isLooping = 1;
#line 375
    displayType = "curses";
#line 376
    goto switch_break;
    case_40: /* CIL Label */ 
#line 379
    isLooping = 1;
#line 380
    displayType = "x11";
#line 381
    goto switch_break;
    case_35: /* CIL Label */ 
#line 384
    isVertical = 1;
#line 385
    goto switch_break;
    case_23: /* CIL Label */ 
    {
#line 388
    status = SetPids(ap);
    }
#line 389
    goto switch_break;
    case_24: /* CIL Label */ 
    {
#line 392
    status = SetUsers(ap);
    }
#line 393
    goto switch_break;
    case_34: /* CIL Label */ 
    {
#line 396
    status = SetGroups(ap);
    }
#line 397
    goto switch_break;
    case_38: /* CIL Label */ 
    {
#line 400
    status = SetPrograms(ap);
    }
#line 401
    goto switch_break;
    case_50: /* CIL Label */ 
    {
#line 404
    status = SetGeometry(ap);
    }
#line 405
    goto switch_break;
    case_43: /* CIL Label */ 
    {
#line 408
    status = SetFont(ap);
    }
#line 409
    goto switch_break;
    case_44: /* CIL Label */ 
    {
#line 412
    status = SetForeground(ap);
    }
#line 413
    goto switch_break;
    case_45: /* CIL Label */ 
    {
#line 416
    status = SetBackground(ap);
    }
#line 417
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 420
    status = SetDisplay(ap);
    }
#line 421
    goto switch_break;
    case_57: /* CIL Label */ 
    {
#line 424
    status = SetPercentSeconds(ap);
    }
#line 425
    goto switch_break;
    case_46: /* CIL Label */ 
    {
#line 428
    status = SetScrollTime(ap);
    }
#line 429
    goto switch_break;
    case_47: /* CIL Label */ 
    {
#line 432
    status = SetOverlapLines(ap);
    }
#line 433
    goto switch_break;
    case_54: /* CIL Label */ 
    {
#line 436
    status = SetInfoColor(ap);
    }
#line 437
    goto switch_break;
    case_55: /* CIL Label */ 
    {
#line 440
    status = SetHeaderColor(ap);
    }
#line 441
    goto switch_break;
    case_56: /* CIL Label */ 
    {
#line 444
    status = SetRowColorCondition(ap);
    }
#line 445
    goto switch_break;
    case_25: /* CIL Label */ 
    {
#line 448
    PrintUsage();
    }
#line 449
    goto switch_break;
    case_26: /* CIL Label */ 
    {
#line 452
    ListColumns();
#line 453
    exit(0);
    }
    case_30: /* CIL Label */ 
    {
#line 456
    ListMacros();
#line 457
    exit(0);
    }
    case_31: /* CIL Label */ 
    {
#line 460
    PrintVersion();
#line 461
    exit(0);
    }
    case_27: /* CIL Label */ 
#line 464
    goto switch_break;
    case_28: /* CIL Label */ 
    {
#line 467
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The -noinit option can only be used as the first command line argument\n");
#line 470
    status = 0;
    }
#line 471
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 474
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown option -%s\n",
            str);
#line 475
    status = 0;
    }
#line 476
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 479
    if (! status) {
#line 480
      isSuccess = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 483
  return (isSuccess);
}
}
#line 492 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
BOOL ExpandOptionName(char const   *name , int depth ) 
{ 
  ARGS args ;
  char upName[18] ;
  size_t tmp ;
  BOOL tmp___0 ;
  BOOL tmp___1 ;

  {
#line 498
  if (depth > 20) {
    {
#line 500
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Too many levels of option macros\n");
    }
#line 502
    return (0);
  }
  {
#line 505
  tmp = strlen(name);
  }
#line 505
  if (tmp > 16UL) {
    {
#line 507
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Macro name \"%c%s\" is too long\n",
            ((int const   )*name + 65) - 97, name + 1);
    }
#line 510
    return (0);
  }
#line 517
  if (depth == 0) {
#line 517
    if ((int const   )*name >= 97) {
#line 517
      if ((int const   )*name <= 122) {
        {
#line 519
        strcpy((char */* __restrict  */)(upName), (char const   */* __restrict  */)name);
#line 521
        upName[0] = (char )((int )upName[0] + -32);
#line 523
        name = (char const   *)(upName);
        }
      }
    }
  }
#line 526
  if ((int const   )*name >= 97) {
#line 526
    if ((int const   )*name <= 122) {
      {
#line 528
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option macro \"%s\" must be upper case\n",
              name);
      }
#line 531
      return (0);
    }
  }
#line 534
  if ((int const   )*name >= 65) {
#line 534
    if (! ((int const   )*name <= 90)) {
      {
#line 536
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"String value \"%s\" is not a macro name\n",
              name);
      }
#line 539
      return (0);
    }
  } else {
    {
#line 536
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"String value \"%s\" is not a macro name\n",
            name);
    }
#line 539
    return (0);
  }
  {
#line 542
  tmp___0 = ExpandMacro(0, name, & args);
  }
#line 542
  if (! tmp___0) {
#line 543
    return (0);
  }
  {
#line 545
  tmp___1 = ParseOptions(& args, depth + 1);
  }
#line 545
  return (tmp___1);
}
}
#line 555 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
int ExpandArguments(ARGS *ap , char **table , int tableLen ) 
{ 
  char *name ;
  int count ;
  int subCount ;
  ARGS args ;
  char **tmp ;
  char **tmp___0 ;
  BOOL tmp___1 ;

  {
#line 563
  count = 0;
  {
#line 565
  while (1) {
    while_continue: /* CIL Label */ ;
#line 565
    if (ap->count > 0) {
#line 565
      if (! ((int )*(*(ap->table)) != 45)) {
#line 565
        goto while_break;
      }
    } else {
#line 565
      goto while_break;
    }
#line 567
    tmp = ap->table;
#line 567
    (ap->table) ++;
#line 567
    name = *tmp;
#line 568
    (ap->count) --;
#line 573
    if (tableLen <= 0) {
      {
#line 575
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Too many arguments\n");
      }
#line 577
      return (-1);
    }
#line 584
    if ((int )*name >= 65) {
#line 584
      if (! ((int )*name <= 90)) {
#line 584
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 586
      tmp___0 = table;
#line 586
      table ++;
#line 586
      *tmp___0 = name;
#line 587
      tableLen --;
#line 588
      count ++;
#line 590
      goto while_continue;
    }
    {
#line 597
    tmp___1 = ExpandMacro(1, (char const   *)name, & args);
    }
#line 597
    if (! tmp___1) {
#line 598
      return (-1);
    }
    {
#line 604
    subCount = ExpandArguments(& args, table, tableLen);
    }
#line 606
    if (subCount < 0) {
#line 607
      return (-1);
    }
#line 613
    table += subCount;
#line 614
    tableLen -= subCount;
#line 615
    count += subCount;
  }
  while_break: /* CIL Label */ ;
  }
#line 618
  return (count);
}
}
#line 625 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
static BOOL SetSeparation(ARGS *ap ) 
{ 
  char const   *str ;
  char **tmp ;
  long tmp___0 ;

  {
#line 630
  if (ap->count <= 0) {
    {
#line 632
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing separation argument\n");
    }
#line 634
    return (0);
  } else
#line 630
  if ((int )*(*(ap->table)) == 45) {
    {
#line 632
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing separation argument\n");
    }
#line 634
    return (0);
  }
  {
#line 637
  (ap->count) --;
#line 638
  tmp = ap->table;
#line 638
  (ap->table) ++;
#line 638
  str = (char const   *)*tmp;
#line 640
  tmp___0 = GetDecimalNumber(& str);
#line 640
  separation = (int )tmp___0;
  }
#line 642
  if (*str) {
    {
#line 644
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad separation argument\n");
    }
#line 646
    return (0);
  } else
#line 642
  if (separation < 0) {
    {
#line 644
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad separation argument\n");
    }
#line 646
    return (0);
  } else
#line 642
  if (separation > 20) {
    {
#line 644
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad separation argument\n");
    }
#line 646
    return (0);
  }
#line 649
  return (1);
}
}
#line 657 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
static BOOL ReadFile(ARGS *ap ) 
{ 
  char **tmp ;
  BOOL tmp___0 ;

  {
#line 660
  if (ap->count <= 0) {
    {
#line 662
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing file argument\n");
    }
#line 664
    return (0);
  } else
#line 660
  if ((int )*(*(ap->table)) == 45) {
    {
#line 662
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing file argument\n");
    }
#line 664
    return (0);
  }
  {
#line 667
  (ap->count) --;
#line 669
  tmp = ap->table;
#line 669
  (ap->table) ++;
#line 669
  tmp___0 = ParseFile((char const   *)*tmp, 0);
  }
#line 669
  return (tmp___0);
}
}
#line 677 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
static BOOL SetDefault(ARGS *ap ) 
{ 
  OPTION *option ;
  char *name ;
  char **tmp ;
  int tmp___0 ;

  {
#line 686
  if (ap->count <= 0) {
    {
#line 688
    DefaultAllOptions();
    }
#line 690
    return (1);
  } else
#line 686
  if ((int )*(*(ap->table)) == 45) {
    {
#line 688
    DefaultAllOptions();
    }
#line 690
    return (1);
  }
  {
#line 696
  while (1) {
    while_continue: /* CIL Label */ ;
#line 696
    if (ap->count > 0) {
#line 696
      if (! ((int )*(*(ap->table)) != 45)) {
#line 696
        goto while_break;
      }
    } else {
#line 696
      goto while_break;
    }
#line 698
    (ap->count) --;
#line 699
    tmp = ap->table;
#line 699
    (ap->table) ++;
#line 699
    name = *tmp;
#line 701
    option = option_table;
    {
#line 703
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 703
      if (option->name) {
        {
#line 703
        tmp___0 = strcmp((char const   *)option->name, (char const   *)name);
        }
#line 703
        if (! (tmp___0 != 0)) {
#line 703
          goto while_break___0;
        }
      } else {
#line 703
        goto while_break___0;
      }
#line 704
      option ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 706
    if ((unsigned long )option->name == (unsigned long )((void *)0)) {
      {
#line 708
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Undefined option name \"%s\"\n",
              name);
      }
#line 710
      return (0);
    }
    {
#line 713
    DefaultOneOption(option->id);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 716
  return (1);
}
}
#line 725 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
void DefaultAllOptions(void) 
{ 
  int id ;

  {
#line 730
  id = 0;
  {
#line 730
  while (1) {
    while_continue: /* CIL Label */ ;
#line 730
    if (! (id <= 57)) {
#line 730
      goto while_break;
    }
    {
#line 731
    DefaultOneOption(id);
#line 730
    id ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 732
  return;
}
}
#line 740 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
static void DefaultOneOption(int id ) 
{ 


  {
  {
#line 747
  if (id == 3) {
#line 747
    goto case_3;
  }
#line 747
  if (id == 2) {
#line 747
    goto case_3;
  }
#line 747
  if (id == 1) {
#line 747
    goto case_3;
  }
#line 751
  if (id == 4) {
#line 751
    goto case_4;
  }
#line 755
  if (id == 5) {
#line 755
    goto case_5;
  }
#line 759
  if (id == 6) {
#line 759
    goto case_6;
  }
#line 763
  if (id == 48) {
#line 763
    goto case_48;
  }
#line 767
  if (id == 7) {
#line 767
    goto case_7;
  }
#line 771
  if (id == 9) {
#line 771
    goto case_9;
  }
#line 775
  if (id == 51) {
#line 775
    goto case_51;
  }
#line 779
  if (id == 52) {
#line 779
    goto case_52;
  }
#line 783
  if (id == 53) {
#line 783
    goto case_53;
  }
#line 786
  if (id == 10) {
#line 786
    goto case_10;
  }
#line 790
  if (id == 11) {
#line 790
    goto case_11;
  }
#line 794
  if (id == 12) {
#line 794
    goto case_12;
  }
#line 802
  if (id == 17) {
#line 802
    goto case_17;
  }
#line 802
  if (id == 36) {
#line 802
    goto case_17;
  }
#line 802
  if (id == 16) {
#line 802
    goto case_17;
  }
#line 802
  if (id == 15) {
#line 802
    goto case_17;
  }
#line 802
  if (id == 14) {
#line 802
    goto case_17;
  }
#line 806
  if (id == 18) {
#line 806
    goto case_18;
  }
#line 810
  if (id == 35) {
#line 810
    goto case_35;
  }
#line 814
  if (id == 19) {
#line 814
    goto case_19;
  }
#line 818
  if (id == 20) {
#line 818
    goto case_20;
  }
#line 822
  if (id == 21) {
#line 822
    goto case_21;
  }
#line 826
  if (id == 22) {
#line 826
    goto case_22;
  }
#line 830
  if (id == 23) {
#line 830
    goto case_23;
  }
#line 834
  if (id == 24) {
#line 834
    goto case_24;
  }
#line 838
  if (id == 34) {
#line 838
    goto case_34;
  }
#line 842
  if (id == 38) {
#line 842
    goto case_38;
  }
#line 846
  if (id == 29) {
#line 846
    goto case_29;
  }
#line 850
  if (id == 49) {
#line 850
    goto case_49;
  }
#line 854
  if (id == 33) {
#line 854
    goto case_33;
  }
#line 858
  if (id == 37) {
#line 858
    goto case_37;
  }
#line 862
  if (id == 50) {
#line 862
    goto case_50;
  }
#line 866
  if (id == 43) {
#line 866
    goto case_43;
  }
#line 870
  if (id == 44) {
#line 870
    goto case_44;
  }
#line 874
  if (id == 45) {
#line 874
    goto case_45;
  }
#line 878
  if (id == 42) {
#line 878
    goto case_42;
  }
#line 882
  if (id == 57) {
#line 882
    goto case_57;
  }
#line 886
  if (id == 46) {
#line 886
    goto case_46;
  }
#line 890
  if (id == 47) {
#line 890
    goto case_47;
  }
#line 894
  if (id == 54) {
#line 894
    goto case_54;
  }
#line 898
  if (id == 55) {
#line 898
    goto case_55;
  }
#line 902
  if (id == 56) {
#line 902
    goto case_56;
  }
#line 906
  goto switch_default;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 748
  DefaultColumns();
  }
#line 749
  goto switch_break;
  case_4: /* CIL Label */ 
#line 752
  separation = 2;
#line 753
  goto switch_break;
  case_5: /* CIL Label */ 
#line 756
  outputWidth = 80;
#line 757
  goto switch_break;
  case_6: /* CIL Label */ 
#line 760
  sleepTimeMs = 10000;
#line 761
  goto switch_break;
  case_48: /* CIL Label */ 
#line 764
  isInfoShown = 0;
#line 765
  goto switch_break;
  case_7: /* CIL Label */ 
#line 768
  noSelf = 0;
#line 769
  goto switch_break;
  case_9: /* CIL Label */ 
#line 772
  myProcs = 0;
#line 773
  goto switch_break;
  case_51: /* CIL Label */ 
#line 776
  showThreads = 0;
#line 777
  goto switch_break;
  case_52: /* CIL Label */ 
#line 780
  useThreads = 0;
#line 781
  goto switch_break;
  case_53: /* CIL Label */ 
#line 784
  noCopy = 0;
  case_10: /* CIL Label */ 
#line 787
  activeOnly = 0;
#line 788
  goto switch_break;
  case_11: /* CIL Label */ 
#line 791
  noRoot = 0;
#line 792
  goto switch_break;
  case_12: /* CIL Label */ 
#line 795
  clearScreen = 0;
#line 796
  goto switch_break;
  case_17: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_15: /* CIL Label */ 
  case_14: /* CIL Label */ 
  {
#line 803
  ClearSorting();
  }
#line 804
  goto switch_break;
  case_18: /* CIL Label */ 
#line 807
  isLooping = 0;
#line 808
  goto switch_break;
  case_35: /* CIL Label */ 
#line 811
  isVertical = 0;
#line 812
  goto switch_break;
  case_19: /* CIL Label */ 
#line 815
  initSleepTime = 1;
#line 816
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 819
  ClearCondition();
  }
#line 820
  goto switch_break;
  case_21: /* CIL Label */ 
#line 823
  topCount = 0;
#line 824
  goto switch_break;
  case_22: /* CIL Label */ 
#line 827
  noHeader = 0;
#line 828
  goto switch_break;
  case_23: /* CIL Label */ 
#line 831
  pidCount = 0;
#line 832
  goto switch_break;
  case_24: /* CIL Label */ 
#line 835
  userCount = 0;
#line 836
  goto switch_break;
  case_34: /* CIL Label */ 
#line 839
  groupCount = 0;
#line 840
  goto switch_break;
  case_38: /* CIL Label */ 
#line 843
  programCount = 0;
#line 844
  goto switch_break;
  case_29: /* CIL Label */ 
#line 847
  activeTime = 60;
#line 848
  goto switch_break;
  case_49: /* CIL Label */ 
#line 851
  deathTime = 30;
#line 852
  goto switch_break;
  case_33: /* CIL Label */ 
#line 855
  syncTime = 300;
#line 856
  goto switch_break;
  case_37: /* CIL Label */ 
  {
#line 859
  DefaultColumnWidths();
  }
#line 860
  goto switch_break;
  case_50: /* CIL Label */ 
  {
#line 863
  ReplaceString(& geometry, "150x50");
  }
#line 864
  goto switch_break;
  case_43: /* CIL Label */ 
  {
#line 867
  ReplaceString(& fontName, "fixed");
  }
#line 868
  goto switch_break;
  case_44: /* CIL Label */ 
  {
#line 871
  ReplaceString(& foregroundName, "black");
  }
#line 872
  goto switch_break;
  case_45: /* CIL Label */ 
  {
#line 875
  ReplaceString(& backgroundName, "white");
  }
#line 876
  goto switch_break;
  case_42: /* CIL Label */ 
  {
#line 879
  ReplaceString(& displayName, (char const   *)((void *)0));
  }
#line 880
  goto switch_break;
  case_57: /* CIL Label */ 
#line 883
  percentSeconds = 10;
#line 884
  goto switch_break;
  case_46: /* CIL Label */ 
#line 887
  scrollSeconds = 30;
#line 888
  goto switch_break;
  case_47: /* CIL Label */ 
#line 891
  overlapLines = 1;
#line 892
  goto switch_break;
  case_54: /* CIL Label */ 
#line 895
  infoColorId = 0;
#line 896
  goto switch_break;
  case_55: /* CIL Label */ 
#line 899
  headerColorId = 0;
#line 900
  goto switch_break;
  case_56: /* CIL Label */ 
  {
#line 903
  ClearRowColorConditions();
  }
#line 904
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 907
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 909
  return;
}
}
#line 915 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
static BOOL SetCondition(ARGS *ap ) 
{ 
  char const   *str ;
  char **tmp ;
  BOOL tmp___0 ;

  {
#line 920
  if (ap->count <= 0) {
    {
#line 922
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing condition expression\n");
    }
#line 924
    return (0);
  } else
#line 920
  if ((int )*(*(ap->table)) == 45) {
    {
#line 922
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing condition expression\n");
    }
#line 924
    return (0);
  }
  {
#line 927
  (ap->count) --;
#line 928
  tmp = ap->table;
#line 928
  (ap->table) ++;
#line 928
  str = (char const   *)*tmp;
#line 930
  tmp___0 = ParseCondition(str);
  }
#line 930
  return (tmp___0);
}
}
#line 938 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
static BOOL SetSleepTime(ARGS *ap ) 
{ 
  char const   *str ;
  char **tmp ;
  double tmp___0 ;

  {
#line 943
  if (ap->count <= 0) {
    {
#line 945
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing sleep time argument\n");
    }
#line 947
    return (0);
  } else
#line 943
  if ((int )*(*(ap->table)) == 45) {
    {
#line 945
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing sleep time argument\n");
    }
#line 947
    return (0);
  }
  {
#line 950
  (ap->count) --;
#line 951
  tmp = ap->table;
#line 951
  (ap->table) ++;
#line 951
  str = (char const   *)*tmp;
#line 953
  tmp___0 = GetFloatingNumber(& str);
#line 953
  sleepTimeMs = (int )(tmp___0 * 1000.0);
  }
#line 955
  if (*str) {
    {
#line 957
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad sleep time argument\n");
    }
#line 959
    return (0);
  } else
#line 955
  if (sleepTimeMs < 0) {
    {
#line 957
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad sleep time argument\n");
    }
#line 959
    return (0);
  }
#line 962
  return (1);
}
}
#line 969 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
static BOOL SetActiveTime(ARGS *ap ) 
{ 
  char const   *str ;
  char **tmp ;
  long tmp___0 ;

  {
#line 974
  if (ap->count <= 0) {
    {
#line 976
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing active time argument\n");
    }
#line 978
    return (0);
  } else
#line 974
  if ((int )*(*(ap->table)) == 45) {
    {
#line 976
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing active time argument\n");
    }
#line 978
    return (0);
  }
  {
#line 981
  (ap->count) --;
#line 982
  tmp = ap->table;
#line 982
  (ap->table) ++;
#line 982
  str = (char const   *)*tmp;
#line 984
  tmp___0 = GetDecimalNumber(& str);
#line 984
  activeTime = (int )tmp___0;
  }
#line 986
  if (*str) {
    {
#line 988
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad active time argument\n");
    }
#line 990
    return (0);
  } else
#line 986
  if (activeTime < 0) {
    {
#line 988
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad active time argument\n");
    }
#line 990
    return (0);
  }
#line 993
  return (1);
}
}
#line 1000 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
static BOOL SetDeathTime(ARGS *ap ) 
{ 
  char const   *str ;
  char **tmp ;
  long tmp___0 ;

  {
#line 1005
  if (ap->count <= 0) {
    {
#line 1007
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing death time argument\n");
    }
#line 1009
    return (0);
  } else
#line 1005
  if ((int )*(*(ap->table)) == 45) {
    {
#line 1007
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing death time argument\n");
    }
#line 1009
    return (0);
  }
  {
#line 1012
  (ap->count) --;
#line 1013
  tmp = ap->table;
#line 1013
  (ap->table) ++;
#line 1013
  str = (char const   *)*tmp;
#line 1015
  tmp___0 = GetDecimalNumber(& str);
#line 1015
  deathTime = (int )tmp___0;
  }
#line 1017
  if (*str) {
    {
#line 1019
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad death time argument\n");
    }
#line 1021
    return (0);
  } else
#line 1017
  if (deathTime < 0) {
    {
#line 1019
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad death time argument\n");
    }
#line 1021
    return (0);
  }
#line 1024
  return (1);
}
}
#line 1031 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
static BOOL SetSyncTime(ARGS *ap ) 
{ 
  char const   *str ;
  char **tmp ;
  long tmp___0 ;

  {
#line 1036
  if (ap->count <= 0) {
    {
#line 1038
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing sync time argument\n");
    }
#line 1040
    return (0);
  } else
#line 1036
  if ((int )*(*(ap->table)) == 45) {
    {
#line 1038
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing sync time argument\n");
    }
#line 1040
    return (0);
  }
  {
#line 1043
  (ap->count) --;
#line 1044
  tmp = ap->table;
#line 1044
  (ap->table) ++;
#line 1044
  str = (char const   *)*tmp;
#line 1046
  tmp___0 = GetDecimalNumber(& str);
#line 1046
  syncTime = (int )tmp___0;
  }
#line 1048
  if (*str) {
    {
#line 1050
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad sync time argument\n");
    }
#line 1052
    return (0);
  } else
#line 1048
  if (syncTime < 0) {
    {
#line 1050
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad sync time argument\n");
    }
#line 1052
    return (0);
  }
#line 1055
  return (1);
}
}
#line 1064 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
static BOOL SetTopCount(ARGS *ap ) 
{ 
  char const   *str ;
  char **tmp ;
  long tmp___0 ;

  {
#line 1069
  isTopMode = 1;
#line 1071
  if (ap->count <= 0) {
#line 1071
    goto _L;
  } else
#line 1071
  if ((int )*(*(ap->table)) == 45) {
    _L: /* CIL Label */ 
#line 1073
    topCount = outputHeight - 1;
#line 1075
    if (! noHeader) {
#line 1076
      topCount --;
    }
#line 1078
    if (isInfoShown) {
#line 1079
      topCount --;
    }
#line 1081
    if (topCount <= 0) {
#line 1082
      topCount = 1;
    }
#line 1084
    isTopAuto = 1;
#line 1086
    return (1);
  }
  {
#line 1089
  (ap->count) --;
#line 1090
  tmp = ap->table;
#line 1090
  (ap->table) ++;
#line 1090
  str = (char const   *)*tmp;
#line 1092
  tmp___0 = GetDecimalNumber(& str);
#line 1092
  topCount = (int )tmp___0;
  }
#line 1094
  if (*str) {
    {
#line 1096
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad top argument\n");
    }
#line 1098
    return (0);
  } else
#line 1094
  if (topCount < 0) {
    {
#line 1096
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad top argument\n");
    }
#line 1098
    return (0);
  }
#line 1101
  isTopAuto = 0;
#line 1103
  return (1);
}
}
#line 1110 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
static BOOL SetPids(ARGS *ap ) 
{ 
  char const   *str ;
  pid_t pid ;
  int i ;
  char **tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 1117
  if (ap->count <= 0) {
    {
#line 1119
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing pid argument\n");
    }
#line 1121
    return (0);
  } else
#line 1117
  if ((int )*(*(ap->table)) == 45) {
    {
#line 1119
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing pid argument\n");
    }
#line 1121
    return (0);
  }
  {
#line 1124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1124
    if (ap->count > 0) {
#line 1124
      if (! ((int )*(*(ap->table)) != 45)) {
#line 1124
        goto while_break;
      }
    } else {
#line 1124
      goto while_break;
    }
    {
#line 1126
    (ap->count) --;
#line 1127
    tmp = ap->table;
#line 1127
    (ap->table) ++;
#line 1127
    str = (char const   *)*tmp;
#line 1129
    tmp___0 = GetDecimalNumber(& str);
#line 1129
    pid = (pid_t )tmp___0;
    }
#line 1131
    if (*str) {
      {
#line 1133
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad pid argument\n");
      }
#line 1135
      return (0);
    } else
#line 1131
    if ((long )pid <= 0L) {
      {
#line 1133
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad pid argument\n");
      }
#line 1135
      return (0);
    }
#line 1138
    i = 0;
    {
#line 1138
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1138
      if (! (i < pidCount)) {
#line 1138
        goto while_break___0;
      }
#line 1140
      if (pidList[i] == pid) {
#line 1141
        goto while_break___0;
      }
#line 1138
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1144
    if (i < pidCount) {
#line 1145
      goto while_continue;
    }
#line 1147
    if (pidCount >= 100) {
      {
#line 1149
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Too many pids specified\n");
      }
#line 1151
      return (0);
    }
#line 1154
    tmp___1 = pidCount;
#line 1154
    pidCount ++;
#line 1154
    pidList[tmp___1] = pid;
  }
  while_break: /* CIL Label */ ;
  }
#line 1157
  return (1);
}
}
#line 1164 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
static BOOL SetUsers(ARGS *ap ) 
{ 
  char const   *str ;
  uid_t uid ;
  int i ;
  char **tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1171
  CollectUserNames();
  }
#line 1173
  if (ap->count <= 0) {
    {
#line 1175
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing user argument\n");
    }
#line 1177
    return (0);
  } else
#line 1173
  if ((int )*(*(ap->table)) == 45) {
    {
#line 1175
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing user argument\n");
    }
#line 1177
    return (0);
  }
  {
#line 1180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1180
    if (ap->count > 0) {
#line 1180
      if (! ((int )*(*(ap->table)) != 45)) {
#line 1180
        goto while_break;
      }
    } else {
#line 1180
      goto while_break;
    }
#line 1182
    (ap->count) --;
#line 1183
    tmp = ap->table;
#line 1183
    (ap->table) ++;
#line 1183
    str = (char const   *)*tmp;
#line 1185
    if ((int const   )*str >= 48) {
#line 1185
      if ((int const   )*str <= 57) {
        {
#line 1187
        tmp___0 = GetDecimalNumber(& str);
#line 1187
        uid = (uid_t )tmp___0;
        }
#line 1189
        if (*str) {
          {
#line 1191
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad uid argument\n");
          }
#line 1193
          return (0);
        }
      } else {
#line 1185
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 1198
      uid = FindUserId(str);
      }
#line 1200
      if (uid == 4294967295U) {
        {
#line 1202
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown user \"%s\"\n",
                str);
        }
#line 1204
        return (0);
      }
    }
#line 1208
    i = 0;
    {
#line 1208
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1208
      if (! (i < userCount)) {
#line 1208
        goto while_break___0;
      }
#line 1210
      if (userList[i] == uid) {
#line 1211
        goto while_break___0;
      }
#line 1208
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1214
    if (i < userCount) {
#line 1215
      goto while_continue;
    }
#line 1217
    if (userCount >= 100) {
      {
#line 1219
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Too many users specified\n");
      }
#line 1221
      return (0);
    }
#line 1224
    tmp___1 = userCount;
#line 1224
    userCount ++;
#line 1224
    userList[tmp___1] = uid;
  }
  while_break: /* CIL Label */ ;
  }
#line 1227
  return (1);
}
}
#line 1234 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
static BOOL SetGroups(ARGS *ap ) 
{ 
  char const   *str ;
  gid_t gid ;
  int i ;
  char **tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1241
  CollectGroupNames();
  }
#line 1243
  if (ap->count <= 0) {
    {
#line 1245
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing group argument\n");
    }
#line 1247
    return (0);
  } else
#line 1243
  if ((int )*(*(ap->table)) == 45) {
    {
#line 1245
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing group argument\n");
    }
#line 1247
    return (0);
  }
  {
#line 1250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1250
    if (ap->count > 0) {
#line 1250
      if (! ((int )*(*(ap->table)) != 45)) {
#line 1250
        goto while_break;
      }
    } else {
#line 1250
      goto while_break;
    }
#line 1252
    (ap->count) --;
#line 1253
    tmp = ap->table;
#line 1253
    (ap->table) ++;
#line 1253
    str = (char const   *)*tmp;
#line 1255
    if ((int const   )*str >= 48) {
#line 1255
      if ((int const   )*str <= 57) {
        {
#line 1257
        tmp___0 = GetDecimalNumber(& str);
#line 1257
        gid = (gid_t )tmp___0;
        }
#line 1259
        if (*str) {
          {
#line 1261
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad gid argument\n");
          }
#line 1263
          return (0);
        }
      } else {
#line 1255
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 1268
      gid = FindGroupId(str);
      }
#line 1270
      if (gid == 4294967295U) {
        {
#line 1272
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown group \"%s\"\n",
                str);
        }
#line 1274
        return (0);
      }
    }
#line 1278
    i = 0;
    {
#line 1278
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1278
      if (! (i < groupCount)) {
#line 1278
        goto while_break___0;
      }
#line 1280
      if (groupList[i] == gid) {
#line 1281
        goto while_break___0;
      }
#line 1278
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1284
    if (i < groupCount) {
#line 1285
      goto while_continue;
    }
#line 1287
    if (groupCount >= 100) {
      {
#line 1289
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Too many groups specified\n");
      }
#line 1291
      return (0);
    }
#line 1294
    tmp___1 = groupCount;
#line 1294
    groupCount ++;
#line 1294
    groupList[tmp___1] = gid;
  }
  while_break: /* CIL Label */ ;
  }
#line 1297
  return (1);
}
}
#line 1304 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
static BOOL SetPrograms(ARGS *ap ) 
{ 
  char *str ;
  int i ;
  char **tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1310
  if (ap->count <= 0) {
    {
#line 1312
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing program argument\n");
    }
#line 1314
    return (0);
  } else
#line 1310
  if ((int )*(*(ap->table)) == 45) {
    {
#line 1312
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing program argument\n");
    }
#line 1314
    return (0);
  }
  {
#line 1317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1317
    if (ap->count > 0) {
#line 1317
      if (! ((int )*(*(ap->table)) != 45)) {
#line 1317
        goto while_break;
      }
    } else {
#line 1317
      goto while_break;
    }
    {
#line 1319
    (ap->count) --;
#line 1320
    tmp = ap->table;
#line 1320
    (ap->table) ++;
#line 1320
    str = *tmp;
#line 1326
    tmp___0 = strlen((char const   *)str);
    }
#line 1326
    if (tmp___0 > 32UL) {
#line 1327
      goto while_continue;
    }
#line 1329
    i = 0;
    {
#line 1329
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1329
      if (! (i < programCount)) {
#line 1329
        goto while_break___0;
      }
      {
#line 1331
      tmp___1 = strcmp((char const   *)str, (char const   *)(programList[i]));
      }
#line 1331
      if (tmp___1 == 0) {
#line 1332
        goto while_break___0;
      }
#line 1329
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1335
    if (i < programCount) {
#line 1336
      goto while_continue;
    }
#line 1338
    if (programCount >= 20) {
      {
#line 1340
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Too many programss specified\n");
      }
#line 1342
      return (0);
    }
    {
#line 1345
    tmp___2 = programCount;
#line 1345
    programCount ++;
#line 1345
    strcpy((char */* __restrict  */)(programList[tmp___2]), (char const   */* __restrict  */)str);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1348
  return (1);
}
}
#line 1355 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
static BOOL SetInitTime(ARGS *ap ) 
{ 
  char const   *str ;
  char **tmp ;
  long tmp___0 ;

  {
#line 1360
  if (ap->count <= 0) {
    {
#line 1362
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing init time argument\n");
    }
#line 1364
    return (0);
  } else
#line 1360
  if ((int )*(*(ap->table)) == 45) {
    {
#line 1362
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing init time argument\n");
    }
#line 1364
    return (0);
  }
  {
#line 1367
  (ap->count) --;
#line 1368
  tmp = ap->table;
#line 1368
  (ap->table) ++;
#line 1368
  str = (char const   *)*tmp;
#line 1370
  tmp___0 = GetDecimalNumber(& str);
#line 1370
  initSleepTime = (int )tmp___0;
  }
#line 1372
  if (*str) {
    {
#line 1374
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad init time argument\n");
    }
#line 1376
    return (0);
  } else
#line 1372
  if (initSleepTime < 0) {
    {
#line 1374
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad init time argument\n");
    }
#line 1376
    return (0);
  }
#line 1379
  return (1);
}
}
#line 1386 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
static BOOL SetWidth(ARGS *ap ) 
{ 
  char const   *str ;
  char **tmp ;
  long tmp___0 ;

  {
#line 1391
  if (ap->count <= 0) {
    {
#line 1393
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing width argument\n");
    }
#line 1395
    return (0);
  } else
#line 1391
  if ((int )*(*(ap->table)) == 45) {
    {
#line 1393
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing width argument\n");
    }
#line 1395
    return (0);
  }
  {
#line 1398
  (ap->count) --;
#line 1399
  tmp = ap->table;
#line 1399
  (ap->table) ++;
#line 1399
  str = (char const   *)*tmp;
#line 1401
  tmp___0 = GetDecimalNumber(& str);
#line 1401
  outputWidth = (int )tmp___0;
  }
#line 1403
  if (*str) {
    {
#line 1405
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad width argument\n");
    }
#line 1407
    return (0);
  } else
#line 1403
  if (outputWidth <= 0) {
    {
#line 1405
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad width argument\n");
    }
#line 1407
    return (0);
  }
#line 1410
  if (outputWidth > 31744) {
#line 1411
    outputWidth = 31744;
  }
#line 1413
  return (1);
}
}
#line 1421 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
static BOOL SetColumnWidth(ARGS *ap ) 
{ 
  COLUMN *column ;
  char const   *name ;
  char const   *str ;
  int width ;
  char **tmp ;
  char **tmp___0 ;
  long tmp___1 ;

  {
#line 1429
  if (ap->count <= 0) {
    {
#line 1431
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing Column name\n");
    }
#line 1433
    return (0);
  } else
#line 1429
  if ((int )*(*(ap->table)) == 45) {
    {
#line 1431
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing Column name\n");
    }
#line 1433
    return (0);
  }
  {
#line 1436
  (ap->count) --;
#line 1437
  tmp = ap->table;
#line 1437
  (ap->table) ++;
#line 1437
  name = (char const   *)*tmp;
#line 1442
  column = FindColumn(name);
  }
#line 1444
  if ((unsigned long )column == (unsigned long )((void *)0)) {
    {
#line 1446
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad column name %s\n",
            name);
    }
#line 1448
    return (0);
  }
#line 1455
  if (ap->count <= 0) {
#line 1457
    column->width = column->initWidth;
#line 1459
    return (1);
  } else
#line 1455
  if ((int )*(*(ap->table)) == 45) {
#line 1457
    column->width = column->initWidth;
#line 1459
    return (1);
  }
  {
#line 1466
  (ap->count) --;
#line 1467
  tmp___0 = ap->table;
#line 1467
  (ap->table) ++;
#line 1467
  str = (char const   *)*tmp___0;
#line 1469
  tmp___1 = GetDecimalNumber(& str);
#line 1469
  width = (int )tmp___1;
  }
#line 1471
  if (*str) {
    {
#line 1473
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad column width argument\n");
    }
#line 1475
    return (0);
  } else
#line 1471
  if (width <= 0) {
    {
#line 1473
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad column width argument\n");
    }
#line 1475
    return (0);
  }
#line 1478
  if (width > 31744) {
#line 1479
    width = 31744;
  }
#line 1481
  column->width = width;
#line 1483
  return (1);
}
}
#line 1490 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
static BOOL SetColumns(ARGS *ap ) 
{ 
  BOOL tmp ;

  {
  {
#line 1493
  showCount = 0;
#line 1495
  tmp = AddColumns(ap);
  }
#line 1495
  return (tmp);
}
}
#line 1505 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
static BOOL AddColumns(ARGS *ap ) 
{ 
  char const   *name ;
  COLUMN *column ;
  int count ;
  int i ;
  int j ;
  int pos ;
  char *table[1000] ;
  char const   *tmp ;
  int tmp___0 ;

  {
  {
#line 1516
  count = ExpandArguments(ap, table, 1000);
  }
#line 1518
  if (count < 0) {
#line 1519
    return (0);
  }
#line 1524
  pos = showCount;
#line 1530
  i = 0;
  {
#line 1530
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1530
    if (! (i < count)) {
#line 1530
      goto while_break;
    }
#line 1532
    name = (char const   *)table[i];
#line 1539
    if ((int const   )*name >= 48) {
#line 1539
      if ((int const   )*name <= 57) {
#line 1541
        pos = 0;
        {
#line 1543
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1543
          if ((int const   )*name >= 48) {
#line 1543
            if (! ((int const   )*name <= 57)) {
#line 1543
              goto while_break___0;
            }
          } else {
#line 1543
            goto while_break___0;
          }
#line 1544
          tmp = name;
#line 1544
          name ++;
#line 1544
          pos = (pos * 10 + (int )*tmp) - 48;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1546
        if (*name) {
          {
#line 1548
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad column position argument\n");
          }
#line 1550
          return (0);
        } else
#line 1546
        if (pos < 0) {
          {
#line 1548
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad column position argument\n");
          }
#line 1550
          return (0);
        }
#line 1553
        pos --;
#line 1555
        goto __Cont;
      }
    }
    {
#line 1561
    column = FindColumn(name);
    }
#line 1563
    if ((unsigned long )column == (unsigned long )((void *)0)) {
      {
#line 1565
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad column name %s\n",
              name);
      }
#line 1567
      return (0);
    }
#line 1573
    j = 0;
    {
#line 1573
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1573
      if (! (j < showCount)) {
#line 1573
        goto while_break___1;
      }
#line 1575
      if ((unsigned long )column == (unsigned long )showList[j]) {
        {
#line 1577
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1577
          if (! (j < showCount)) {
#line 1577
            goto while_break___2;
          }
#line 1579
          showList[j] = showList[j + 1];
#line 1580
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1583
        showCount --;
      }
#line 1573
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1595
    if (pos < 0) {
#line 1596
      pos = 0;
    }
#line 1598
    if (pos > showCount) {
#line 1599
      pos = showCount;
    }
#line 1601
    j = showCount;
    {
#line 1601
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1601
      if (! (j > pos)) {
#line 1601
        goto while_break___3;
      }
#line 1602
      showList[j] = showList[j - 1];
#line 1601
      j --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1604
    tmp___0 = pos;
#line 1604
    pos ++;
#line 1604
    showList[tmp___0] = column;
#line 1605
    showCount ++;
#line 1605
    showList[showCount] = (COLUMN *)((void *)0);
    __Cont: /* CIL Label */ 
#line 1530
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1608
  return (1);
}
}
#line 1615 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
static BOOL RemoveColumns(ARGS *ap ) 
{ 
  char const   *name ;
  COLUMN *column ;
  int count ;
  int i ;
  int j ;
  char *table[1000] ;

  {
  {
#line 1625
  count = ExpandArguments(ap, table, 1000);
  }
#line 1627
  if (count < 0) {
#line 1628
    return (0);
  }
#line 1630
  i = 0;
  {
#line 1630
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1630
    if (! (i < count)) {
#line 1630
      goto while_break;
    }
    {
#line 1632
    name = (char const   *)table[i];
#line 1634
    column = FindColumn(name);
    }
#line 1636
    if ((unsigned long )column == (unsigned long )((void *)0)) {
      {
#line 1638
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad column name %s\n",
              name);
      }
#line 1640
      return (0);
    }
#line 1643
    j = 0;
    {
#line 1643
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1643
      if (! (j < showCount)) {
#line 1643
        goto while_break___0;
      }
#line 1645
      if ((unsigned long )column == (unsigned long )showList[j]) {
        {
#line 1647
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1647
          if (! (j < showCount)) {
#line 1647
            goto while_break___1;
          }
#line 1649
          showList[j] = showList[j + 1];
#line 1650
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1653
        showCount --;
      }
#line 1643
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1630
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1658
  return (1);
}
}
#line 1665 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
static BOOL SetFont(ARGS *ap ) 
{ 
  char *str ;
  char **tmp ;

  {
#line 1670
  if (ap->count <= 0) {
    {
#line 1672
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing font argument\n");
    }
#line 1674
    return (0);
  } else
#line 1670
  if ((int )*(*(ap->table)) == 45) {
    {
#line 1672
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing font argument\n");
    }
#line 1674
    return (0);
  }
  {
#line 1677
  (ap->count) --;
#line 1678
  tmp = ap->table;
#line 1678
  (ap->table) ++;
#line 1678
  str = *tmp;
#line 1680
  ReplaceString(& fontName, (char const   *)str);
  }
#line 1682
  return (1);
}
}
#line 1689 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
static BOOL SetGeometry(ARGS *ap ) 
{ 
  char *str ;
  char **tmp ;

  {
#line 1694
  if (ap->count <= 0) {
    {
#line 1696
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing geometry argument\n");
    }
#line 1698
    return (0);
  } else
#line 1694
  if ((int )*(*(ap->table)) == 45) {
    {
#line 1696
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing geometry argument\n");
    }
#line 1698
    return (0);
  }
  {
#line 1701
  (ap->count) --;
#line 1702
  tmp = ap->table;
#line 1702
  (ap->table) ++;
#line 1702
  str = *tmp;
#line 1704
  ReplaceString(& geometry, (char const   *)str);
  }
#line 1706
  return (1);
}
}
#line 1713 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
static BOOL SetForeground(ARGS *ap ) 
{ 
  char *str ;
  char **tmp ;

  {
#line 1718
  if (ap->count <= 0) {
    {
#line 1720
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing foreground argument\n");
    }
#line 1722
    return (0);
  } else
#line 1718
  if ((int )*(*(ap->table)) == 45) {
    {
#line 1720
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing foreground argument\n");
    }
#line 1722
    return (0);
  }
  {
#line 1725
  (ap->count) --;
#line 1726
  tmp = ap->table;
#line 1726
  (ap->table) ++;
#line 1726
  str = *tmp;
#line 1728
  ReplaceString(& foregroundName, (char const   *)str);
  }
#line 1730
  return (1);
}
}
#line 1737 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
static BOOL SetBackground(ARGS *ap ) 
{ 
  char *str ;
  char **tmp ;

  {
#line 1742
  if (ap->count <= 0) {
    {
#line 1744
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing background argument\n");
    }
#line 1746
    return (0);
  } else
#line 1742
  if ((int )*(*(ap->table)) == 45) {
    {
#line 1744
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing background argument\n");
    }
#line 1746
    return (0);
  }
  {
#line 1749
  (ap->count) --;
#line 1750
  tmp = ap->table;
#line 1750
  (ap->table) ++;
#line 1750
  str = *tmp;
#line 1752
  ReplaceString(& backgroundName, (char const   *)str);
  }
#line 1754
  return (1);
}
}
#line 1761 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
static BOOL SetDisplay(ARGS *ap ) 
{ 
  char *str ;
  char **tmp ;

  {
#line 1766
  if (ap->count <= 0) {
    {
#line 1768
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing display argument\n");
    }
#line 1770
    return (0);
  } else
#line 1766
  if ((int )*(*(ap->table)) == 45) {
    {
#line 1768
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing display argument\n");
    }
#line 1770
    return (0);
  }
  {
#line 1773
  (ap->count) --;
#line 1774
  tmp = ap->table;
#line 1774
  (ap->table) ++;
#line 1774
  str = *tmp;
#line 1776
  ReplaceString(& displayName, (char const   *)str);
  }
#line 1778
  return (1);
}
}
#line 1785 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
static BOOL SetPercentSeconds(ARGS *ap ) 
{ 
  char const   *str ;
  char **tmp ;
  long tmp___0 ;

  {
#line 1790
  if (ap->count <= 0) {
    {
#line 1792
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing cpu percentage argument\n");
    }
#line 1794
    return (0);
  } else
#line 1790
  if ((int )*(*(ap->table)) == 45) {
    {
#line 1792
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing cpu percentage argument\n");
    }
#line 1794
    return (0);
  }
  {
#line 1797
  (ap->count) --;
#line 1798
  tmp = ap->table;
#line 1798
  (ap->table) ++;
#line 1798
  str = (char const   *)*tmp;
#line 1800
  tmp___0 = GetDecimalNumber(& str);
#line 1800
  percentSeconds = (int )tmp___0;
  }
#line 1802
  if (*str) {
    {
#line 1804
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad cpu percentage argument\n");
    }
#line 1806
    return (0);
  } else
#line 1802
  if (percentSeconds < 0) {
    {
#line 1804
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad cpu percentage argument\n");
    }
#line 1806
    return (0);
  } else
#line 1802
  if (percentSeconds > 20) {
    {
#line 1804
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad cpu percentage argument\n");
    }
#line 1806
    return (0);
  }
#line 1809
  return (1);
}
}
#line 1816 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
static BOOL SetScrollTime(ARGS *ap ) 
{ 
  char const   *str ;
  char **tmp ;
  long tmp___0 ;

  {
#line 1821
  if (ap->count <= 0) {
    {
#line 1823
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing scroll time argument\n");
    }
#line 1825
    return (0);
  } else
#line 1821
  if ((int )*(*(ap->table)) == 45) {
    {
#line 1823
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing scroll time argument\n");
    }
#line 1825
    return (0);
  }
  {
#line 1828
  (ap->count) --;
#line 1829
  tmp = ap->table;
#line 1829
  (ap->table) ++;
#line 1829
  str = (char const   *)*tmp;
#line 1831
  tmp___0 = GetDecimalNumber(& str);
#line 1831
  scrollSeconds = (int )tmp___0;
  }
#line 1833
  if (*str) {
    {
#line 1835
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad scroll time argument\n");
    }
#line 1837
    return (0);
  } else
#line 1833
  if (scrollSeconds < 0) {
    {
#line 1835
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad scroll time argument\n");
    }
#line 1837
    return (0);
  }
#line 1840
  return (1);
}
}
#line 1847 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
static BOOL SetOverlapLines(ARGS *ap ) 
{ 
  char const   *str ;
  char **tmp ;
  long tmp___0 ;

  {
#line 1852
  if (ap->count <= 0) {
    {
#line 1854
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing overlap argument\n");
    }
#line 1856
    return (0);
  } else
#line 1852
  if ((int )*(*(ap->table)) == 45) {
    {
#line 1854
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing overlap argument\n");
    }
#line 1856
    return (0);
  }
  {
#line 1859
  (ap->count) --;
#line 1860
  tmp = ap->table;
#line 1860
  (ap->table) ++;
#line 1860
  str = (char const   *)*tmp;
#line 1862
  tmp___0 = GetDecimalNumber(& str);
#line 1862
  overlapLines = (int )tmp___0;
  }
#line 1864
  if (*str) {
    {
#line 1866
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad overlap argument\n");
    }
#line 1868
    return (0);
  } else
#line 1864
  if (overlapLines < 0) {
    {
#line 1866
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad overlap argument\n");
    }
#line 1868
    return (0);
  }
#line 1871
  return (1);
}
}
#line 1878 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
static BOOL SetInfoColor(ARGS *ap ) 
{ 
  char const   *color ;
  int colorId ;
  char **tmp ;

  {
#line 1884
  if (ap->count <= 0) {
    {
#line 1886
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing information color argument\n");
    }
#line 1888
    return (0);
  } else
#line 1884
  if ((int )*(*(ap->table)) == 45) {
    {
#line 1886
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing information color argument\n");
    }
#line 1888
    return (0);
  }
  {
#line 1891
  (ap->count) --;
#line 1892
  tmp = ap->table;
#line 1892
  (ap->table) ++;
#line 1892
  color = (char const   *)*tmp;
#line 1894
  colorId = AllocateColor(color);
  }
#line 1896
  if (colorId == -1) {
    {
#line 1898
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot allocate information color\n");
    }
#line 1900
    return (0);
  }
#line 1903
  infoColorId = colorId;
#line 1905
  return (1);
}
}
#line 1912 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
static BOOL SetHeaderColor(ARGS *ap ) 
{ 
  char const   *color ;
  int colorId ;
  char **tmp ;

  {
#line 1918
  if (ap->count <= 0) {
    {
#line 1920
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing header color argument\n");
    }
#line 1922
    return (0);
  } else
#line 1918
  if ((int )*(*(ap->table)) == 45) {
    {
#line 1920
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing header color argument\n");
    }
#line 1922
    return (0);
  }
  {
#line 1925
  (ap->count) --;
#line 1926
  tmp = ap->table;
#line 1926
  (ap->table) ++;
#line 1926
  color = (char const   *)*tmp;
#line 1928
  colorId = AllocateColor(color);
  }
#line 1930
  if (colorId == -1) {
    {
#line 1932
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot allocate header color\n");
    }
#line 1934
    return (0);
  }
#line 1937
  headerColorId = colorId;
#line 1939
  return (1);
}
}
#line 1946 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
static BOOL SetRowColorCondition(ARGS *ap ) 
{ 
  char *color ;
  char *condition ;
  char **tmp ;
  char **tmp___0 ;
  BOOL tmp___1 ;

  {
#line 1952
  if (ap->count <= 0) {
    {
#line 1954
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing color\n");
    }
#line 1956
    return (0);
  } else
#line 1952
  if ((int )*(*(ap->table)) == 45) {
    {
#line 1954
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing color\n");
    }
#line 1956
    return (0);
  }
#line 1959
  (ap->count) --;
#line 1960
  tmp = ap->table;
#line 1960
  (ap->table) ++;
#line 1960
  color = *tmp;
#line 1962
  if (ap->count <= 0) {
    {
#line 1964
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing condition\n");
    }
#line 1966
    return (0);
  } else
#line 1962
  if ((int )*(*(ap->table)) == 45) {
    {
#line 1964
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing condition\n");
    }
#line 1966
    return (0);
  }
  {
#line 1969
  (ap->count) --;
#line 1970
  tmp___0 = ap->table;
#line 1970
  (ap->table) ++;
#line 1970
  condition = *tmp___0;
#line 1972
  tmp___1 = ParseRowColorCondition((char const   *)color, (char const   *)condition);
  }
#line 1972
  return (tmp___1);
}
}
#line 1979 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
static char const   * const  usage_text[67]  = 
#line 1979
  {      (char const   */* const  */)"Usage: ips <show-options> <condition-options> <other-options> <macro-names>",      (char const   */* const  */)"",      (char const   */* const  */)"<show-options> specify how to display the output:",      (char const   */* const  */)"  -col <col> ...           Set columns as the display list", 
        (char const   */* const  */)"  -addcol <col> ...        Add columns to display list",      (char const   */* const  */)"  -remcol <col> ...        Remove columns from display list",      (char const   */* const  */)"  -sort <col> ...          Add columns to sorting list as normal sort",      (char const   */* const  */)"  -revsort <col> ...       Add columns to sorting list as reverse sort", 
        (char const   */* const  */)"  -sortexpr <expr>         Add expression to sorting list as normal sort",      (char const   */* const  */)"  -revsortexpr <expr>      Add expression to sorting list as reverse sort",      (char const   */* const  */)"  -nosort                  Clear the sorting list",      (char const   */* const  */)"  -sep <count>             Set the separation between columns", 
        (char const   */* const  */)"  -width <size>            Set the total width of output for all columns",      (char const   */* const  */)"  -colwidth <col> [width]  Set (or default) the width for one column",      (char const   */* const  */)"  -noheader                Suppress display of header line",      (char const   */* const  */)"  -vert                    Output status in vertical format (multi-line)", 
        (char const   */* const  */)"  -clear                   Clear screen before displaying status in dumb display",      (char const   */* const  */)"  -info                    Show information line when in loop mode",      (char const   */* const  */)"  -scroll <seconds>        Set time between scrolling display when looping",      (char const   */* const  */)"  -overlap <count>         Set number of overlapped lines when scrolling", 
        (char const   */* const  */)"  -once                    Display status once only in dumb display (default)",      (char const   */* const  */)"  -loop                    Display status repeatedly in dumb display",      (char const   */* const  */)"  -curses                  Display status repeatedly in tty using curses",      (char const   */* const  */)"  -x11                     Display status repeatedly in new X11 window", 
        (char const   */* const  */)"  -display <name>          Set display name for X11 (default NULL)",      (char const   */* const  */)"  -geometry <string>       Set window geometry for X11 (default \"150x50\")",      (char const   */* const  */)"  -font <name>             Set font name for X11 (default \"fixed\")",      (char const   */* const  */)"  -foreground <color>      Set foreground color for X11 (default \"black\")", 
        (char const   */* const  */)"  -background <color>      Set background color for X11 (default \"white\")",      (char const   */* const  */)"  -headercolor <colors>    Set colors for header line",      (char const   */* const  */)"  -infocolor <colors>      Set colors for info line",      (char const   */* const  */)"  -rowcolor <colors> <cond>  Set colors for rows satisfying condition", 
        (char const   */* const  */)"",      (char const   */* const  */)"<condition-options> restrict which processes can be displayed:",      (char const   */* const  */)"  -noself                  Do not show the ips process itself",      (char const   */* const  */)"  -noroot                  Do not show processes owned by root", 
        (char const   */* const  */)"  -my                      Show processes with my own user id",      (char const   */* const  */)"  -pid <pid> ...           Show specified process ids",      (char const   */* const  */)"  -user <user> ...         Show specified user names or ids",      (char const   */* const  */)"  -group <group> ...       Show specified group names or ids", 
        (char const   */* const  */)"  -program <program> ...   Show specified program names",      (char const   */* const  */)"  -active                  Show active processes",      (char const   */* const  */)"  -activetime <seconds>    Set number of seconds processes remain active",      (char const   */* const  */)"  -deathtime <seconds>     Set number of seconds to show dead processes", 
        (char const   */* const  */)"  -top [count]             Show number of processes from the top or what fits",      (char const   */* const  */)"  -cond <expr>             Show processes for which the expression is nonzero",      (char const   */* const  */)"  -showthreads             Show threads instead of just processes",      (char const   */* const  */)"", 
        (char const   */* const  */)"<other-options> are:",      (char const   */* const  */)"  -sleep <seconds>         Set the sleep interval between loops",      (char const   */* const  */)"  -initsleep <seconds>     Set the initial sleep time for active checks",      (char const   */* const  */)"  -synctime <seconds>      Synchronize with some status at least this often", 
        (char const   */* const  */)"  -usethreads              Use thread information for process status",      (char const   */* const  */)"  -percentseconds <seconds>  Set seconds for cpu percentages (0 to 20)",      (char const   */* const  */)"  -read <filename>         Read definitions from the specified filename",      (char const   */* const  */)"  -noinit                  Don\'t read \"~/.ipsrc\" (must be first option)", 
        (char const   */* const  */)"  -end                     Used to end argument lists if needed",      (char const   */* const  */)"  -help                    Display this message and exit",      (char const   */* const  */)"  -listcolumns             Display the list of allowable columns and exit",      (char const   */* const  */)"  -listmacros              Display the list of defined macros and exit", 
        (char const   */* const  */)"  -version                 Display version information and exit",      (char const   */* const  */)"  -default [name] ...      Set specified options back to their default values",      (char const   */* const  */)"",      (char const   */* const  */)"<macro-names> are a list of macros (defined in the initialization files)", 
        (char const   */* const  */)"which are to be expanded into options.  The first character of each macro",      (char const   */* const  */)"name is converted to upper case for convenience.",      (char const   */* const  */)((void *)0)};
#line 2051 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
static void PrintUsage(void) 
{ 
  char const   * const  *text ;

  {
#line 2056
  text = usage_text;
  {
#line 2056
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2056
    if (! *text) {
#line 2056
      goto while_break;
    }
    {
#line 2057
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            *text);
#line 2056
    text ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2059
  exit(1);
  }
}
}
#line 2063 "/home/june/repo/benchmarks/collector/temp/ips-4.0/options.c"
static void PrintVersion(void) 
{ 


  {
  {
#line 2066
  printf((char const   */* __restrict  */)"Version:   %s\n", "4.0");
#line 2067
  printf((char const   */* __restrict  */)"Built on:  %s\n", "Mar  4 2016");
#line 2068
  printf((char const   */* __restrict  */)"Author:    %s\n", "David I. Bell");
#line 2069
  printf((char const   */* __restrict  */)"Email:     %s\n", "dbell@canb.auug.org.au");
  }
#line 2070
  return;
}
}
#line 623 "/home/june/repo/benchmarks/collector/temp/ips-4.0/ips.h"
BOOL DpyOpen(void) ;
#line 628
void DpyCreateWindow(void) ;
#line 630
void DpySetColor(int colorId ) ;
#line 631
void DpyRefresh(void) ;
#line 632
void DpyBeginPage(void) ;
#line 633
void DpyChar(int ch ) ;
#line 634
void DpyString(char const   *str ) ;
#line 635
void DpyBuffer(char const   *buffer , int length ) ;
#line 636
void DpyEndPage(void) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/ips-4.0/display.c"
static DISPLAY *display___1  ;
#line 25 "/home/june/repo/benchmarks/collector/temp/ips-4.0/display.c"
BOOL DpySetDisplay(char const   *type ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 28
  if ((unsigned long )type == (unsigned long )((void *)0)) {
    {
#line 29
    display___1 = GetTtyDisplay();
    }
  } else {
    {
#line 28
    tmp___1 = strcmp(type, "tty");
    }
#line 28
    if (tmp___1 == 0) {
      {
#line 29
      display___1 = GetTtyDisplay();
      }
    } else {
      {
#line 30
      tmp___0 = strcmp(type, "curses");
      }
#line 30
      if (tmp___0 == 0) {
        {
#line 31
        display___1 = GetCursesDisplay();
        }
      } else {
        {
#line 33
        tmp = strcmp(type, "x11");
        }
#line 33
        if (tmp == 0) {
          {
#line 34
          display___1 = GetX11Display();
          }
        } else {
          {
#line 38
          display___1 = GetTtyDisplay();
          }
#line 40
          return (0);
        }
      }
    }
  }
#line 43
  return (1);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/ips-4.0/display.c"
BOOL DpyOpen(void) 
{ 
  BOOL tmp ;

  {
  {
#line 50
  tmp = (*(display___1->open))(display___1);
  }
#line 50
  return (tmp);
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/ips-4.0/display.c"
BOOL DpyDefineColor(int colorId , char const   *foreground___0 , char const   *background___0 ,
                    int flags ) 
{ 
  BOOL tmp ;

  {
  {
#line 57
  tmp = (*(display___1->defineColor))(display___1, colorId, foreground___0, background___0,
                                      flags);
  }
#line 57
  return (tmp);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/ips-4.0/display.c"
void DpyCreateWindow(void) 
{ 


  {
  {
#line 64
  (*(display___1->createWindow))(display___1);
  }
#line 65
  return;
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/ips-4.0/display.c"
void DpyClose(void) 
{ 


  {
  {
#line 71
  (*(display___1->close))(display___1);
  }
#line 72
  return;
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/ips-4.0/display.c"
void DpySetColor(int colorId ) 
{ 


  {
  {
#line 78
  (*(display___1->setColor))(display___1, colorId);
  }
#line 79
  return;
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/ips-4.0/display.c"
void DpyRefresh(void) 
{ 


  {
  {
#line 85
  (*(display___1->refresh))(display___1);
  }
#line 86
  return;
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/ips-4.0/display.c"
void DpyBeginPage(void) 
{ 


  {
  {
#line 92
  (*(display___1->beginPage))(display___1);
  }
#line 93
  return;
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/ips-4.0/display.c"
void DpyChar(int ch ) 
{ 


  {
  {
#line 99
  (*(display___1->putChar))(display___1, ch);
  }
#line 100
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/ips-4.0/display.c"
void DpyString(char const   *str ) 
{ 


  {
  {
#line 106
  (*(display___1->putString))(display___1, str);
  }
#line 107
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/ips-4.0/display.c"
void DpyBuffer(char const   *buffer , int length ) 
{ 


  {
  {
#line 113
  (*(display___1->putBuffer))(display___1, buffer, length);
  }
#line 114
  return;
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/ips-4.0/display.c"
void DpyEndPage(void) 
{ 


  {
  {
#line 120
  (*(display___1->endPage))(display___1);
  }
#line 121
  return;
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/ips-4.0/display.c"
BOOL DpyEventWait(int milliSeconds ) 
{ 
  BOOL tmp ;

  {
  {
#line 133
  tmp = (*(display___1->eventWait))(display___1, milliSeconds);
  }
#line 133
  return (tmp);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/ips-4.0/display.c"
BOOL DpyInputReady(void) 
{ 
  BOOL tmp ;

  {
  {
#line 140
  tmp = (*(display___1->inputReady))(display___1);
  }
#line 140
  return (tmp);
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/ips-4.0/display.c"
int DpyReadChar(void) 
{ 
  int tmp ;

  {
  {
#line 147
  tmp = (*(display___1->readChar))(display___1);
  }
#line 147
  return (tmp);
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/ips-4.0/display.c"
void DpyRingBell(void) 
{ 


  {
  {
#line 154
  (*(display___1->ringBell))(display___1);
  }
#line 155
  return;
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/ips-4.0/display.c"
int DpyGetRows(void) 
{ 
  int tmp ;

  {
  {
#line 161
  tmp = (*(display___1->getRows))(display___1);
  }
#line 161
  return (tmp);
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/ips-4.0/display.c"
int DpyGetCols(void) 
{ 
  int tmp ;

  {
  {
#line 168
  tmp = (*(display___1->getCols))(display___1);
  }
#line 168
  return (tmp);
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/ips-4.0/display.c"
BOOL DpyDoesScroll(void) 
{ 
  BOOL tmp ;

  {
  {
#line 175
  tmp = (*(display___1->doesScroll))(display___1);
  }
#line 175
  return (tmp);
}
}
#line 17 "/home/june/repo/benchmarks/collector/temp/ips-4.0/show.c"
static int headerWidth  ;
#line 18 "/home/june/repo/benchmarks/collector/temp/ips-4.0/show.c"
static BOOL isShown  ;
#line 19 "/home/june/repo/benchmarks/collector/temp/ips-4.0/show.c"
static BOOL haveScrollTime  ;
#line 20 "/home/june/repo/benchmarks/collector/temp/ips-4.0/show.c"
static struct timeval lastScrollTime  ;
#line 26
static void ShowVerticalProcessStatus(PROC const   *proc ) ;
#line 27
static char const   *ReturnInfoString(void) ;
#line 28
static char const   *ReturnHeaderString(void) ;
#line 29
static char const   *ReturnProcessString(PROC const   *proc ) ;
#line 30
static BOOL CanShowColumn(COLUMN const   *column , int col ) ;
#line 31
static int GetSkipCountDelta(void) ;
#line 32
static int GetUsefulRows(void) ;
#line 33
static int GetPageCount(void) ;
#line 34
static int GetShowCount(void) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/ips-4.0/show.c"
BOOL InitializeDisplay(void) 
{ 
  COLUMN **columnPtr ;
  COLUMN const   *column ;
  int len ;
  BOOL tmp ;
  BOOL tmp___0 ;
  BOOL tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 52
  tmp = DpySetDisplay(displayType);
  }
#line 52
  if (! tmp) {
    {
#line 54
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Display type \"%s\" is not available\n",
            displayType);
    }
#line 57
    return (0);
  }
  {
#line 63
  tmp___0 = DpyOpen();
  }
#line 63
  if (! tmp___0) {
    {
#line 65
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to open display type \"%s\"\n",
            displayType);
    }
#line 68
    return (0);
  }
  {
#line 74
  tmp___1 = DefineColors();
  }
#line 74
  if (! tmp___1) {
    {
#line 76
    DpyClose();
#line 78
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to define colors\n");
    }
#line 80
    return (0);
  }
  {
#line 86
  DpyCreateWindow();
#line 88
  headerWidth = 0;
  }
#line 90
  if (noHeader) {
#line 91
    return (1);
  } else
#line 90
  if (! isVertical) {
#line 91
    return (1);
  }
#line 97
  columnPtr = showList;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! *columnPtr) {
#line 97
      goto while_break;
    }
    {
#line 99
    column = (COLUMN const   *)*columnPtr;
#line 101
    tmp___2 = strlen((char const   *)column->heading);
#line 101
    len = (int )tmp___2;
    }
#line 103
    if (len > headerWidth) {
#line 104
      headerWidth = len;
    }
#line 97
    columnPtr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  return (1);
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/ips-4.0/show.c"
void ShowSelectedProcesses(void) 
{ 
  PROC const   *proc ;
  int seenCount ;
  int skippedCount ;
  int usefulRows ;
  struct timeval newScrollTime ;
  long tmp ;
  BOOL tmp___0 ;
  char const   *tmp___1 ;
  BOOL tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;

  {
#line 126
  isShown = 0;
#line 127
  seenCount = 0;
#line 128
  skippedCount = 0;
#line 133
  if (! isFrozen) {
#line 133
    if (scrollSeconds > 0) {
      {
#line 133
      tmp___0 = DpyDoesScroll();
      }
#line 133
      if (! tmp___0) {
        {
#line 135
        GetTimeOfDay(& newScrollTime);
        }
#line 137
        if (haveScrollTime) {
          {
#line 137
          tmp = ElapsedMilliSeconds((struct timeval  const  *)(& lastScrollTime),
                                    (struct timeval  const  *)(& newScrollTime));
          }
#line 137
          if (tmp / 1000L > (long )scrollSeconds) {
            {
#line 141
            NextPage();
            }
          }
        }
#line 144
        if (! haveScrollTime) {
#line 146
          haveScrollTime = 1;
#line 147
          lastScrollTime = newScrollTime;
        }
      }
    }
  }
#line 154
  if (isRefreshNeeded) {
    {
#line 156
    DpyRefresh();
#line 158
    isRefreshNeeded = 0;
    }
  }
  {
#line 164
  DpySetColor(0);
#line 166
  DpyBeginPage();
  }
#line 171
  if (isLooping) {
#line 171
    if (isInfoShown) {
      {
#line 173
      DpySetColor(infoColorId);
#line 174
      tmp___1 = ReturnInfoString();
#line 174
      DpyString(tmp___1);
#line 175
      DpyChar('\n');
#line 176
      DpySetColor(0);
      }
    }
  }
  {
#line 183
  tmp___2 = DpyDoesScroll();
  }
#line 183
  if (tmp___2) {
#line 184
    usefulRows = 0;
  } else {
    {
#line 186
    usefulRows = GetUsefulRows();
    }
  }
#line 191
  proc = (PROC const   *)processList;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! proc) {
#line 191
      goto while_break;
    }
#line 196
    if (usefulRows) {
#line 196
      if (seenCount >= usefulRows) {
#line 197
        goto while_break;
      }
    }
#line 203
    if (topCount) {
#line 203
      if (seenCount >= topCount) {
#line 204
        goto while_break;
      }
    }
#line 209
    if (! proc->isShown) {
#line 210
      goto __Cont;
    }
#line 215
    if (skippedCount < skipCount) {
#line 217
      skippedCount ++;
#line 219
      goto __Cont;
    }
#line 227
    if (seenCount == 0) {
#line 229
      if (! noHeader) {
#line 229
        if (! isVertical) {
          {
#line 231
          DpySetColor(headerColorId);
#line 232
          tmp___3 = ReturnHeaderString();
#line 232
          DpyString(tmp___3);
#line 233
          DpyChar('\n');
#line 234
          DpySetColor(0);
          }
        }
      }
    }
    {
#line 242
    tmp___4 = EvaluateRowColor(proc);
#line 242
    DpySetColor(tmp___4);
    }
#line 248
    if (isVertical) {
      {
#line 249
      ShowVerticalProcessStatus(proc);
      }
    } else {
      {
#line 252
      tmp___5 = ReturnProcessString(proc);
#line 252
      DpyString(tmp___5);
#line 253
      DpyChar('\n');
      }
    }
#line 256
    seenCount ++;
#line 257
    isShown = 1;
    __Cont: /* CIL Label */ 
#line 191
    proc = (PROC const   *)proc->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 263
  DpySetColor(0);
#line 265
  DpyEndPage();
  }
#line 266
  return;
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/ips-4.0/show.c"
static char buf___0[257]  ;
#line 272 "/home/june/repo/benchmarks/collector/temp/ips-4.0/show.c"
static char const   *ReturnInfoString(void) 
{ 
  int delta ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 278
  delta = GetSkipCountDelta();
  }
#line 280
  if (isFrozen) {
#line 280
    tmp = "  FROZEN";
  } else {
#line 280
    tmp = "";
  }
  {
#line 280
  tmp___0 = GetPageCount();
#line 280
  tmp___1 = GetShowCount();
#line 280
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"[Procs: %d  Threads: %d  Shown: %d  Sleep: %g  Scroll: %d  Overlap: %d  Page: %d/%d%s]",
          procTotalCount, threadTotalCount, tmp___1, (double )sleepTimeMs / 1000.0,
          scrollSeconds, overlapLines, skipCount / delta + 1, tmp___0, tmp);
  }
#line 287
  return ((char const   *)(buf___0));
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/ips-4.0/show.c"
static char buf___1[31745]  ;
#line 297 "/home/june/repo/benchmarks/collector/temp/ips-4.0/show.c"
static char const   *ReturnHeaderString(void) 
{ 
  COLUMN **columnPtr ;
  COLUMN const   *column ;
  int col ;
  int len ;
  int padding ;
  int tmp ;
  char *cp ;
  char *bufCp ;
  COLUMN **tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  COLUMN **tmp___8 ;
  BOOL tmp___9 ;

  {
#line 310
  bufCp = buf___1;
#line 311
  col = 0;
#line 312
  padding = 0;
#line 313
  columnPtr = showList;
#line 314
  tmp___0 = columnPtr;
#line 314
  columnPtr ++;
#line 314
  column = (COLUMN const   *)*tmp___0;
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 316
    tmp___9 = CanShowColumn(column, col);
    }
#line 316
    if (! tmp___9) {
#line 316
      goto while_break;
    }
    {
#line 318
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 318
      tmp___2 = padding;
#line 318
      padding --;
#line 318
      if (! (tmp___2 > 0)) {
#line 318
        goto while_break___0;
      }
#line 319
      tmp___1 = bufCp;
#line 319
      bufCp ++;
#line 319
      *tmp___1 = (char )' ';
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 321
    cp = (char *)column->heading;
#line 323
    tmp___3 = strlen((char const   *)cp);
#line 323
    len = (int )tmp___3;
    }
#line 325
    if (len > (int )column->width) {
#line 326
      len = (int )column->width;
    }
#line 328
    padding = (int )(column->width - (int const   )len);
#line 330
    if (column->justify == 1) {
      {
#line 332
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 332
        tmp___5 = padding;
#line 332
        padding --;
#line 332
        if (! (tmp___5 > 0)) {
#line 332
          goto while_break___1;
        }
#line 333
        tmp___4 = bufCp;
#line 333
        bufCp ++;
#line 333
        *tmp___4 = (char )' ';
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 336
    if (column->justify == 2) {
#line 338
      tmp = padding / 2;
#line 339
      padding -= tmp;
      {
#line 341
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 341
        tmp___7 = tmp;
#line 341
        tmp --;
#line 341
        if (! (tmp___7 > 0)) {
#line 341
          goto while_break___2;
        }
#line 342
        tmp___6 = bufCp;
#line 342
        bufCp ++;
#line 342
        *tmp___6 = (char )' ';
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    {
#line 345
    memcpy((void */* __restrict  */)bufCp, (void const   */* __restrict  */)cp, (size_t )len);
#line 346
    bufCp += len;
#line 348
    col += (int )(column->width + (int const   )separation);
    }
#line 350
    if (padding < 0) {
#line 351
      padding = 0;
    }
#line 353
    padding += separation;
#line 354
    tmp___8 = columnPtr;
#line 354
    columnPtr ++;
#line 354
    column = (COLUMN const   *)*tmp___8;
  }
  while_break: /* CIL Label */ ;
  }
#line 357
  *bufCp = (char )'\000';
#line 359
  return ((char const   *)(buf___1));
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/ips-4.0/show.c"
static char buf___2[31745]  ;
#line 369 "/home/june/repo/benchmarks/collector/temp/ips-4.0/show.c"
static char const   *ReturnProcessString(PROC const   *proc ) 
{ 
  COLUMN **columnPtr ;
  COLUMN *column ;
  BOOL overflow ;
  int len ;
  int padding ;
  int tmp ;
  int col ;
  int goalCol ;
  char const   *value ;
  char *bufCp ;
  COLUMN **tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  COLUMN **tmp___4 ;
  BOOL tmp___5 ;

  {
#line 384
  bufCp = buf___2;
#line 385
  col = 0;
#line 386
  goalCol = 0;
#line 387
  columnPtr = showList;
#line 388
  tmp___0 = columnPtr;
#line 388
  columnPtr ++;
#line 388
  column = *tmp___0;
  {
#line 390
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 390
    tmp___5 = CanShowColumn((COLUMN const   *)column, goalCol);
    }
#line 390
    if (! tmp___5) {
#line 390
      goto while_break;
    }
    {
#line 395
    value = (*(column->showFunc))(proc);
#line 397
    tmp___1 = strlen(value);
#line 397
    len = (int )tmp___1;
#line 403
    padding = column->width - len;
    }
#line 405
    if (padding < 0) {
#line 406
      padding = 0;
    }
#line 412
    overflow = 0;
#line 419
    if (*columnPtr) {
#line 419
      if (len > column->width) {
#line 421
        len = column->width - 1;
#line 422
        overflow = 1;
#line 423
        padding = 0;
      }
    }
#line 431
    if (goalCol + len > outputWidth) {
#line 433
      len = (outputWidth - goalCol) - 1;
#line 434
      overflow = 1;
#line 435
      padding = 0;
    }
#line 438
    if (len < 0) {
#line 439
      len = 0;
    }
#line 445
    if (padding > 0) {
#line 447
      if (column->justify == 1) {
#line 449
        goalCol += padding;
#line 450
        padding = 0;
      }
#line 453
      if (column->justify == 2) {
#line 455
        tmp = padding / 2;
#line 456
        padding -= tmp;
#line 457
        goalCol += tmp;
      }
    }
    {
#line 465
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 465
      if (! (col < goalCol)) {
#line 465
        goto while_break___0;
      }
#line 467
      col ++;
#line 468
      tmp___2 = bufCp;
#line 468
      bufCp ++;
#line 468
      *tmp___2 = (char )' ';
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 474
    memcpy((void */* __restrict  */)bufCp, (void const   */* __restrict  */)value,
           (size_t )len);
#line 476
    bufCp += len;
#line 477
    goalCol += len;
#line 478
    col += len;
    }
#line 483
    if (overflow) {
#line 485
      tmp___3 = bufCp;
#line 485
      bufCp ++;
#line 485
      *tmp___3 = (char )'|';
#line 486
      goalCol ++;
#line 487
      col ++;
    }
#line 494
    if (padding > 0) {
#line 495
      goalCol += padding;
    }
#line 500
    goalCol += separation;
#line 502
    tmp___4 = columnPtr;
#line 502
    columnPtr ++;
#line 502
    column = *tmp___4;
  }
  while_break: /* CIL Label */ ;
  }
#line 505
  *bufCp = (char )'\000';
#line 507
  return ((char const   *)(buf___2));
}
}
#line 518 "/home/june/repo/benchmarks/collector/temp/ips-4.0/show.c"
static BOOL CanShowColumn(COLUMN const   *column , int col ) 
{ 


  {
#line 521
  if ((unsigned long )column == (unsigned long )((void *)0)) {
#line 522
    return (0);
  }
#line 524
  if (column->justify == 0) {
#line 525
    return (col + (int )column->minWidth <= outputWidth);
  }
#line 527
  return (col + (int )column->width <= outputWidth);
}
}
#line 538 "/home/june/repo/benchmarks/collector/temp/ips-4.0/show.c"
static void ShowVerticalProcessStatus(PROC const   *proc ) 
{ 
  COLUMN **columnPtr ;
  COLUMN const   *column ;
  int columnWidth ;
  int len ;
  char *cp ;
  char const   *str ;
  char buf___3[128] ;
  size_t tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
#line 552
  if (isShown) {
    {
#line 553
    DpyChar('\n');
    }
  }
#line 560
  if (noHeader) {
#line 561
    columnWidth = outputWidth;
  } else {
#line 563
    columnWidth = ((outputWidth - headerWidth) - separation) - 1;
  }
#line 565
  if (columnWidth <= 0) {
#line 566
    columnWidth = 1;
  }
#line 571
  columnPtr = showList;
  {
#line 571
  while (1) {
    while_continue: /* CIL Label */ ;
#line 571
    if (! *columnPtr) {
#line 571
      goto while_break;
    }
#line 573
    column = (COLUMN const   *)*columnPtr;
#line 581
    if (! noHeader) {
      {
#line 583
      cp = buf___3;
#line 585
      tmp = strlen((char const   *)column->heading);
#line 585
      len = (int )tmp;
#line 586
      memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)column->heading,
             (size_t )len);
#line 587
      cp += len;
#line 589
      tmp___0 = cp;
#line 589
      cp ++;
#line 589
      *tmp___0 = (char )':';
#line 591
      len = (headerWidth + separation) - len;
      }
#line 593
      if (len > 0) {
        {
#line 595
        memset((void *)cp, ' ', (size_t )len);
#line 596
        cp += len;
        }
      }
      {
#line 599
      *cp = (char )'\000';
#line 601
      DpyString((char const   *)(buf___3));
      }
    }
    {
#line 607
    str = (*(column->showFunc))(proc);
#line 609
    tmp___1 = strlen(str);
#line 609
    len = (int )tmp___1;
    }
#line 616
    if (len > columnWidth) {
      {
#line 618
      DpyBuffer(str, columnWidth - 1);
#line 619
      DpyString("|\n");
      }
    } else {
      {
#line 623
      DpyString(str);
#line 624
      DpyChar('\n');
      }
    }
#line 571
    columnPtr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 627
  return;
}
}
#line 635 "/home/june/repo/benchmarks/collector/temp/ips-4.0/show.c"
void NextPage(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 642
  tmp = GetUsefulRows();
#line 642
  tmp___0 = GetShowCount();
  }
#line 642
  if (skipCount + tmp >= tmp___0) {
    {
#line 644
    TopPage();
    }
#line 646
    return;
  }
  {
#line 649
  tmp___1 = GetSkipCountDelta();
#line 649
  skipCount += tmp___1;
#line 651
  haveScrollTime = 0;
  }
#line 652
  return;
}
}
#line 660 "/home/june/repo/benchmarks/collector/temp/ips-4.0/show.c"
void PreviousPage(void) 
{ 
  int tmp ;

  {
  {
#line 663
  tmp = GetSkipCountDelta();
#line 663
  skipCount -= tmp;
  }
#line 665
  if (skipCount < 0) {
    {
#line 666
    BottomPage();
    }
  }
#line 668
  haveScrollTime = 0;
#line 669
  return;
}
}
#line 676 "/home/june/repo/benchmarks/collector/temp/ips-4.0/show.c"
void TopPage(void) 
{ 


  {
#line 679
  skipCount = 0;
#line 680
  haveScrollTime = 0;
#line 681
  return;
}
}
#line 688 "/home/june/repo/benchmarks/collector/temp/ips-4.0/show.c"
void BottomPage(void) 
{ 
  int delta ;
  int modulo ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 698
  tmp = GetShowCount();
#line 698
  tmp___0 = GetUsefulRows();
#line 698
  skipCount = tmp - tmp___0;
  }
#line 704
  if (skipCount <= 0) {
#line 706
    skipCount = 0;
#line 707
    haveScrollTime = 0;
#line 709
    return;
  }
  {
#line 716
  delta = GetSkipCountDelta();
#line 718
  modulo = skipCount % delta;
  }
#line 720
  if (modulo > 0) {
#line 721
    skipCount += delta - modulo;
  }
#line 723
  haveScrollTime = 0;
#line 724
  return;
}
}
#line 731 "/home/june/repo/benchmarks/collector/temp/ips-4.0/show.c"
void ResetScrollTime(void) 
{ 


  {
#line 734
  haveScrollTime = 0;
#line 735
  return;
}
}
#line 744 "/home/june/repo/benchmarks/collector/temp/ips-4.0/show.c"
static int GetSkipCountDelta(void) 
{ 
  int count ;
  int tmp ;

  {
  {
#line 749
  tmp = GetUsefulRows();
#line 749
  count = tmp - overlapLines;
  }
#line 751
  if (count <= 0) {
#line 752
    count = 1;
  }
#line 754
  return (count);
}
}
#line 763 "/home/june/repo/benchmarks/collector/temp/ips-4.0/show.c"
static int GetUsefulRows(void) 
{ 
  int count ;

  {
  {
#line 768
  count = DpyGetRows();
  }
#line 770
  if (! noHeader) {
#line 771
    count --;
  }
#line 773
  if (isInfoShown) {
#line 774
    count --;
  }
#line 776
  if (count <= 0) {
#line 777
    count = 1;
  }
#line 779
  return (count);
}
}
#line 786 "/home/june/repo/benchmarks/collector/temp/ips-4.0/show.c"
static int GetPageCount(void) 
{ 
  int skip ;
  int delta ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 796
  tmp = GetShowCount();
#line 796
  tmp___0 = GetUsefulRows();
#line 796
  skip = tmp - tmp___0;
  }
#line 801
  if (skip <= 0) {
#line 802
    return (1);
  }
  {
#line 808
  delta = GetSkipCountDelta();
  }
#line 810
  return (1 + (skip + (delta - 1)) / delta);
}
}
#line 819 "/home/june/repo/benchmarks/collector/temp/ips-4.0/show.c"
static int GetShowCount(void) 
{ 
  int count ;

  {
#line 824
  if (showThreads) {
#line 825
    count = threadShowCount;
  } else {
#line 827
    count = procShowCount;
  }
#line 829
  if (topCount) {
#line 829
    if (count > topCount) {
#line 830
      count = topCount;
    }
  }
#line 832
  return (count);
}
}
#line 765 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/ips-4.0/sort.c"
static int sortCount  ;
#line 44 "/home/june/repo/benchmarks/collector/temp/ips-4.0/sort.c"
static SORT_ITEM sortTable[50]  ;
#line 50 "/home/june/repo/benchmarks/collector/temp/ips-4.0/sort.c"
static int procSortSize  ;
#line 51 "/home/june/repo/benchmarks/collector/temp/ips-4.0/sort.c"
static PROC **procSortTable  ;
#line 57
static int SortFunction(void const   *e1 , void const   *e2 ) ;
#line 58
static int CompareSortingItems(PROC const   *proc1 , PROC const   *proc2 ) ;
#line 66 "/home/june/repo/benchmarks/collector/temp/ips-4.0/sort.c"
USEFLAG GetSortingUseFlags(void) 
{ 
  SORT_ITEM const   *item ;
  USEFLAG flags ;
  USEFLAG tmp ;

  {
#line 72
  flags = (USEFLAG )0;
#line 74
  item = (SORT_ITEM const   *)(sortTable);
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! ((unsigned long )item < (unsigned long )(& sortTable[sortCount]))) {
#line 74
      goto while_break;
    }
    {
#line 79
    if (item->type == 2) {
#line 79
      goto case_2;
    }
#line 79
    if (item->type == 1) {
#line 79
      goto case_2;
    }
#line 85
    if (item->type == 4) {
#line 85
      goto case_4;
    }
#line 85
    if (item->type == 3) {
#line 85
      goto case_4;
    }
#line 90
    goto switch_default;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 80
    flags |= (item->column)->useFlag;
#line 82
    goto switch_break;
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
    {
#line 86
    tmp = GetNodeUseFlags((NODE const   *)(item->tree)->root);
#line 86
    flags |= tmp;
    }
#line 88
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 91
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 74
    item ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  return (flags);
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/ips-4.0/sort.c"
void ClearSorting(void) 
{ 


  {
#line 105
  sortCount = 0;
#line 106
  return;
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/ips-4.0/sort.c"
BOOL AppendColumnSort(ARGS *ap , BOOL reverse ) 
{ 
  SORT_TYPE type ;
  SORT_ITEM *item ;
  char const   *name ;
  COLUMN *column ;
  int count ;
  int i ;
  char *table[1000] ;

  {
#line 125
  if (reverse) {
#line 125
    type = 2;
  } else {
#line 125
    type = 1;
  }
  {
#line 127
  count = ExpandArguments(ap, table, 1000);
  }
#line 129
  if (count < 0) {
#line 130
    return (0);
  }
#line 132
  i = 0;
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 132
    if (! (i < count)) {
#line 132
      goto while_break;
    }
#line 134
    if (sortCount >= 50) {
      {
#line 136
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Too many sort items\n");
      }
#line 138
      return (0);
    }
    {
#line 141
    name = (char const   *)table[i];
#line 143
    column = FindColumn(name);
    }
#line 145
    if ((unsigned long )column == (unsigned long )((void *)0)) {
      {
#line 147
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad sorting column name %s\n",
              name);
      }
#line 149
      return (0);
    }
#line 152
    item = & sortTable[sortCount];
#line 154
    item->type = type;
#line 155
    item->column = column;
#line 156
    item->tree = (TREE *)((void *)0);
#line 158
    sortCount ++;
#line 132
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  return (1);
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/ips-4.0/sort.c"
BOOL AppendExpressionSort(ARGS *ap , BOOL reverse ) 
{ 
  SORT_TYPE type ;
  SORT_ITEM *item ;
  char *str ;
  char **tmp ;
  void *tmp___0 ;
  BOOL tmp___1 ;

  {
#line 176
  if (reverse) {
#line 176
    type = 4;
  } else {
#line 176
    type = 3;
  }
#line 178
  if (ap->count <= 0) {
    {
#line 180
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing sort expression\n");
    }
#line 182
    return (0);
  }
#line 185
  (ap->count) --;
#line 186
  tmp = ap->table;
#line 186
  (ap->table) ++;
#line 186
  str = *tmp;
#line 188
  if (sortCount >= 50) {
    {
#line 190
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Too many sort items\n");
    }
#line 192
    return (0);
  }
  {
#line 195
  item = & sortTable[sortCount];
#line 197
  item->type = type;
#line 198
  item->column = (COLUMN *)((void *)0);
#line 199
  tmp___0 = malloc(sizeof(TREE ));
#line 199
  item->tree = (TREE *)tmp___0;
  }
#line 201
  if ((unsigned long )item->tree == (unsigned long )((void *)0)) {
    {
#line 203
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot allocate memory\n");
    }
#line 205
    return (0);
  }
  {
#line 208
  tmp___1 = ParseTree(item->tree, (char const   *)str, 0);
  }
#line 208
  if (! tmp___1) {
#line 209
    return (0);
  }
#line 211
  sortCount ++;
#line 213
  return (1);
}
}
#line 220 "/home/june/repo/benchmarks/collector/temp/ips-4.0/sort.c"
void SortProcesses(void) 
{ 
  int count ;
  PROC *proc ;
  PROC **procPtr ;
  void *tmp ;
  int tmp___0 ;

  {
#line 231
  if (procAllocCount >= procSortSize) {
    {
#line 233
    procSortSize = procAllocCount + 100;
#line 235
    tmp = realloc((void *)procSortTable, sizeof(PROC *) * (unsigned long )(procSortSize + 1));
#line 235
    procSortTable = (PROC **)tmp;
    }
#line 238
    if ((unsigned long )procSortTable == (unsigned long )((void *)0)) {
      {
#line 240
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot allocate memory\n");
#line 241
      exit(1);
      }
    }
  }
#line 248
  count = 0;
#line 250
  proc = processList;
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if (! proc) {
#line 250
      goto while_break;
    }
#line 251
    tmp___0 = count;
#line 251
    count ++;
#line 251
    *(procSortTable + tmp___0) = proc;
#line 250
    proc = proc->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 253
  *(procSortTable + count) = (PROC *)0;
#line 258
  qsort((void *)procSortTable, (size_t )count, sizeof(PROC *), & SortFunction);
#line 264
  procPtr = procSortTable;
#line 266
  processList = *procPtr;
  }
  {
#line 268
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 268
    if (! *procPtr) {
#line 268
      goto while_break___0;
    }
#line 270
    (*(procPtr + 0))->next = *(procPtr + 1);
#line 271
    procPtr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 273
  return;
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/ips-4.0/sort.c"
static int SortFunction(void const   *e1 , void const   *e2 ) 
{ 
  PROC const   **procPtr1 ;
  PROC const   **procPtr2 ;
  PROC const   *proc1 ;
  PROC const   *proc2 ;
  int status ;

  {
#line 291
  procPtr1 = (PROC const   **)e1;
#line 292
  procPtr2 = (PROC const   **)e2;
#line 294
  proc1 = *procPtr1;
#line 295
  proc2 = *procPtr2;
#line 301
  if (! proc1->isShown) {
#line 301
    goto _L;
  } else
#line 301
  if (! proc2->isShown) {
    _L: /* CIL Label */ 
#line 303
    if (proc1->isShown) {
#line 304
      return (-1);
    }
#line 306
    if (proc2->isShown) {
#line 307
      return (1);
    }
#line 309
    return (0);
  }
  {
#line 316
  status = CompareSortingItems(proc1, proc2);
  }
#line 318
  if (status != 0) {
#line 319
    return (status);
  }
#line 325
  if (proc1->pid < proc2->pid) {
#line 326
    return (-1);
  }
#line 328
  if (proc1->pid > proc2->pid) {
#line 329
    return (1);
  }
#line 335
  if (proc1->tid == 0xffffffffffffffffUL) {
#line 335
    if (proc2->tid != 0xffffffffffffffffUL) {
#line 336
      return (-1);
    }
  }
#line 338
  if (proc1->tid != 0xffffffffffffffffUL) {
#line 338
    if (proc2->tid == 0xffffffffffffffffUL) {
#line 339
      return (1);
    }
  }
#line 341
  if (proc1->tid == (pthread_t const   )proc1->pid) {
#line 341
    if (proc2->tid != (pthread_t const   )proc2->pid) {
#line 342
      return (-1);
    }
  }
#line 344
  if (proc1->tid != (pthread_t const   )proc1->pid) {
#line 344
    if (proc2->tid == (pthread_t const   )proc2->pid) {
#line 345
      return (1);
    }
  }
#line 347
  if (proc1->tid < proc2->tid) {
#line 348
    return (-1);
  }
#line 350
  if (proc1->tid > proc2->tid) {
#line 351
    return (1);
  }
#line 357
  if (proc1->startTimeTicks > proc2->startTimeTicks) {
#line 358
    return (-1);
  }
#line 360
  if (proc1->startTimeTicks < proc2->startTimeTicks) {
#line 361
    return (-1);
  }
#line 363
  return (0);
}
}
#line 373 "/home/june/repo/benchmarks/collector/temp/ips-4.0/sort.c"
static int CompareSortingItems(PROC const   *proc1 , PROC const   *proc2 ) 
{ 
  SORT_ITEM *item ;
  TREE *tree ;
  int status ;
  VALUE value1 ;
  VALUE value2 ;
  int tmp ;
  BOOL tmp___0 ;

  {
#line 382
  if ((unsigned long )proc1 == (unsigned long )proc2) {
#line 383
    return (0);
  }
#line 385
  item = sortTable;
  {
#line 385
  while (1) {
    while_continue: /* CIL Label */ ;
#line 385
    if (! ((unsigned long )item < (unsigned long )(& sortTable[sortCount]))) {
#line 385
      goto while_break;
    }
    {
#line 389
    if (item->type == 1) {
#line 389
      goto case_1;
    }
#line 394
    if (item->type == 2) {
#line 394
      goto case_2;
    }
#line 400
    if (item->type == 4) {
#line 400
      goto case_4;
    }
#line 400
    if (item->type == 3) {
#line 400
      goto case_4;
    }
#line 416
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 390
    status = (*((item->column)->sortFunc))(proc1, proc2);
    }
#line 392
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 395
    tmp = (*((item->column)->sortFunc))(proc1, proc2);
#line 395
    status = - tmp;
    }
#line 397
    goto switch_break;
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
    {
#line 401
    tree = item->tree;
#line 402
    tree->proc = proc1;
#line 403
    value1 = EvaluateNode(tree, (NODE const   *)tree->root);
#line 405
    tree->proc = proc2;
#line 406
    value2 = EvaluateNode(tree, (NODE const   *)tree->root);
#line 408
    tmp___0 = CompareValues((VALUE const   )value1, (VALUE const   )value2, & status);
    }
#line 408
    if (! tmp___0) {
#line 409
      return (0);
    }
#line 411
    if (item->type == 4) {
#line 412
      status = - status;
    }
#line 414
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 417
    status = 0;
#line 418
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 421
    if (status != 0) {
#line 422
      return (status);
    }
#line 385
    item ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 425
  return (0);
}
}
