/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 90 "/usr/include/stdio.h"
typedef __off_t off_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 16 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_read.h"
typedef unsigned int puredb_u32_t;
#line 23 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_read.h"
struct PureDB_ {
   unsigned char *map ;
   int fd ;
   puredb_u32_t size ;
};
#line 23 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_read.h"
typedef struct PureDB_ PureDB;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 23 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_write.h"
struct Hash1_ {
   puredb_u32_t hash ;
   puredb_u32_t offset_data ;
};
#line 23 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_write.h"
typedef struct Hash1_ Hash1;
#line 28 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_write.h"
struct Hash0_ {
   Hash1 *hash1_list ;
   size_t hash1_list_size ;
};
#line 28 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_write.h"
typedef struct Hash0_ Hash0;
#line 33 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_write.h"
struct PureDBW_ {
   FILE *fpindex ;
   FILE *fpdata ;
   char *file_index ;
   char *file_data ;
   char *file_final ;
   puredb_u32_t data_offset_counter ;
   puredb_u32_t offset_first_data ;
   Hash0 hash_table0[256] ;
};
#line 33 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_write.h"
typedef struct PureDBW_ PureDBW;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 36 "/usr/include/x86_64-linux-gnu/sys/poll.h"
typedef unsigned long nfds_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 162 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   unsigned long __ss_align ;
   char __ss_padding[128UL - 2UL * sizeof(unsigned long )] ;
};
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_in;
#line 90
struct sockaddr_in6;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_63 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_63 __in6_u ;
};
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 39 "/usr/include/shadow.h"
struct spwd {
   char *sp_namp ;
   char *sp_pwdp ;
   long sp_lstchg ;
   long sp_min ;
   long sp_max ;
   long sp_warn ;
   long sp_inact ;
   long sp_expire ;
   unsigned long sp_flag ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 48 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino_t ino_t;
#line 60 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
#line 42 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 31 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-quotacheck.c"
struct Node_ {
   ino_t inode ;
   dev_t device ;
};
#line 31 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-quotacheck.c"
typedef struct Node_ Node;
#line 38 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/bsd-glob.h"
struct __anonstruct_glob_t_89 {
   unsigned long gl_maxfiles ;
   int gl_maxdepth ;
   int gl_pathc ;
   int gl_matchc ;
   int gl_offs ;
   int gl_flags ;
   char **gl_pathv ;
   struct stat **gl_statv ;
   int (*gl_errfunc)(char const   * , int  ) ;
   void (*gl_closedir)(void * ) ;
   struct dirent *(*gl_readdir)(void * ) ;
   void *(*gl_opendir)(char const   * ) ;
   int (*gl_lstat)(char const   * , struct stat * ) ;
   int (*gl_stat)(char const   * , struct stat * ) ;
};
#line 38 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/bsd-glob.h"
typedef struct __anonstruct_glob_t_89 glob_t;
#line 98 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/bsd-glob.c"
typedef unsigned short Char;
#line 112 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/bsd-glob.c"
struct glob_lim {
   size_t glim_malloc ;
   size_t glim_stat ;
   size_t glim_readdir ;
};
#line 118 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/bsd-glob.c"
struct glob_path_stat {
   char *gps_path ;
   struct stat *gps_stat ;
};
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 48 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/alt_arc4random.c"
struct alt_arc4_stream {
   unsigned char i ;
   unsigned char j ;
   unsigned char s[256] ;
};
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 43 "/usr/include/x86_64-linux-gnu/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 224 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 242 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
#line 22 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/privsep_p.h"
enum PrivSepCmd_ {
    PRIVSEPCMD_NONE = 0,
    PRIVSEPCMD_ANSWER_ERROR = 1,
    PRIVSEPCMD_ANSWER_FD = 2,
    PRIVSEPCMD_BINDRESPORT = 3,
    PRIVSEPCMD_ANSWER_BINDRESPORT = 4
} ;
#line 22 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/privsep_p.h"
typedef enum PrivSepCmd_ PrivSepCmd;
#line 32 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/privsep_p.h"
struct PrivSepQuery_BindResPort_ {
   PrivSepCmd cmd ;
   int protocol ;
   struct sockaddr_storage ss ;
};
#line 32 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/privsep_p.h"
typedef struct PrivSepQuery_BindResPort_ PrivSepQuery_BindResPort;
#line 44 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/privsep_p.h"
struct PrivSepQuery_Cmd_ {
   PrivSepCmd cmd ;
};
#line 44 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/privsep_p.h"
typedef struct PrivSepQuery_Cmd_ PrivSepQuery_Cmd;
#line 48 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/privsep_p.h"
union PrivSepQuery_ {
   PrivSepQuery_BindResPort bindresport ;
   PrivSepQuery_Cmd cmd ;
};
#line 48 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/privsep_p.h"
typedef union PrivSepQuery_ PrivSepQuery;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 163 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt64_t;
#line 167 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt64_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 22 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef int __sig_atomic_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_14 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_14 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_15 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_15 fd_set;
#line 40 "/usr/include/signal.h"
typedef __sig_atomic_t sig_atomic_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_29 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_30 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_31 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_32 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_33 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_34 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_35 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_28 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_29 _kill ;
   struct __anonstruct__timer_30 _timer ;
   struct __anonstruct__rt_31 _rt ;
   struct __anonstruct__sigchld_32 _sigchld ;
   struct __anonstruct__sigfault_33 _sigfault ;
   struct __anonstruct__sigpoll_34 _sigpoll ;
   struct __anonstruct__sigsys_35 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_27 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_28 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_27 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_47 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_47 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/resource.h"
enum __rlimit_resource {
    RLIMIT_CPU = 0,
    RLIMIT_FSIZE = 1,
    RLIMIT_DATA = 2,
    RLIMIT_STACK = 3,
    RLIMIT_CORE = 4,
    __RLIMIT_RSS = 5,
    RLIMIT_NOFILE = 7,
    __RLIMIT_OFILE = 7,
    RLIMIT_AS = 9,
    __RLIMIT_NPROC = 6,
    __RLIMIT_MEMLOCK = 8,
    __RLIMIT_LOCKS = 10,
    __RLIMIT_SIGPENDING = 11,
    __RLIMIT_MSGQUEUE = 12,
    __RLIMIT_NICE = 13,
    __RLIMIT_RTPRIO = 14,
    __RLIMIT_RTTIME = 15,
    __RLIMIT_NLIMITS = 16,
    __RLIM_NLIMITS = 16
} ;
#line 131 "/usr/include/x86_64-linux-gnu/bits/resource.h"
typedef __rlim_t rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 38 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef enum __rlimit_resource __rlimit_resource_t;
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 58 "/usr/include/x86_64-linux-gnu/bits/statvfs.h"
struct statvfs64 {
   unsigned long f_bsize ;
   unsigned long f_frsize ;
   __fsblkcnt64_t f_blocks ;
   __fsblkcnt64_t f_bfree ;
   __fsblkcnt64_t f_bavail ;
   __fsfilcnt64_t f_files ;
   __fsfilcnt64_t f_ffree ;
   __fsfilcnt64_t f_favail ;
   unsigned long f_fsid ;
   unsigned long f_flag ;
   unsigned long f_namemax ;
   int __f_spare[6] ;
};
#line 37 "/usr/include/utime.h"
struct utimbuf {
   __time_t actime ;
   __time_t modtime ;
};
#line 69 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
struct _code {
   char *c_name ;
   int c_val ;
};
#line 69 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
typedef struct _code CODE;
#line 269 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.h"
struct AuthResult_ {
   int auth_ok ;
   uid_t uid ;
   gid_t gid ;
   char const   *dir ;
   int slow_tilde_expansion ;
   void *backend_data ;
};
#line 269 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.h"
typedef struct AuthResult_ AuthResult;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 57 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd_p.h"
struct reply {
   struct reply *next ;
   char line[1] ;
};
#line 245 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd_p.h"
struct Authentication_ {
   char const   *name ;
   void (*parse)(char const   * const  file ) ;
   void (*check)(AuthResult * const  result , char const   *account , char const   *password ,
                 struct sockaddr_storage  const  * const  sa , struct sockaddr_storage  const  * const  peer ) ;
   void (*exit)(void) ;
};
#line 245 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd_p.h"
typedef struct Authentication_ Authentication;
#line 284 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd_p.h"
struct Authentications_ {
   Authentication const   *auth ;
   char *conf_file ;
   struct Authentications_ *next ;
};
#line 284 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd_p.h"
typedef struct Authentications_ Authentications;
#line 292 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd_p.h"
struct DLHandler_ {
   int clientfd ;
   void *tls_clientfd ;
   int xferfd ;
   int f ;
   void *tls_fd ;
   off_t file_size ;
   size_t dlmap_size ;
   off_t cur_pos ;
   off_t chunk_size ;
   off_t min_chunk_size ;
   off_t default_chunk_size ;
   off_t max_chunk_size ;
   off_t dlmap_pos ;
   off_t dlmap_fdpos ;
   off_t total_downloaded ;
   size_t sizeof_map ;
   unsigned char *map ;
   unsigned char *map_data ;
   int ascii_mode ;
   double min_sleep ;
   double max_sleep ;
   unsigned long bandwidth ;
   struct pollfd pfds_f_in ;
};
#line 292 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd_p.h"
typedef struct DLHandler_ DLHandler;
#line 318 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd_p.h"
struct ULHandler_ {
   unsigned char *buf ;
   size_t sizeof_buf ;
   int clientfd ;
   void *tls_clientfd ;
   int xferfd ;
   void *tls_fd ;
   int f ;
   off_t cur_pos ;
   off_t chunk_size ;
   off_t min_chunk_size ;
   off_t default_chunk_size ;
   off_t max_chunk_size ;
   off_t total_uploaded ;
   int ascii_mode ;
   double min_sleep ;
   double max_sleep ;
   unsigned long bandwidth ;
   off_t max_filesize ;
   unsigned long idletime ;
   struct pollfd pfds[2] ;
   struct pollfd pfds_command ;
};
#line 318 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd_p.h"
typedef struct ULHandler_ ULHandler;
#line 6 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/dynamic.h"
struct IPTrack_ {
   struct sockaddr_storage ip ;
   pid_t pid ;
};
#line 6 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/dynamic.h"
typedef struct IPTrack_ IPTrack;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 58 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-pw.h"
struct PWInfo_ {
   char *login ;
   char *pwd ;
   uid_t uid ;
   gid_t gid ;
   char *home ;
   char *gecos ;
   unsigned long bw_dl ;
   unsigned long bw_ul ;
   int has_bw_dl ;
   int has_bw_ul ;
   unsigned long long quota_files ;
   unsigned long long quota_size ;
   int has_quota_files ;
   int has_quota_size ;
   unsigned int ul_ratio ;
   unsigned int dl_ratio ;
   int has_ul_ratio ;
   int has_dl_ratio ;
   char *allow_local_ip ;
   char *deny_local_ip ;
   char *allow_client_ip ;
   char *deny_client_ip ;
   unsigned int time_begin ;
   unsigned int time_end ;
   int has_time ;
   int has_per_user_max ;
   unsigned int per_user_max ;
};
#line 58 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-pw.h"
typedef struct PWInfo_ PWInfo;
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 353
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off_t __offset ) ;
#line 76
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
#line 35 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_read.h"
int puredb_open(PureDB * const  db , char const   *dbfile ) ;
#line 37
int puredb_close(PureDB * const  db ) ;
#line 39
int puredb_find(PureDB * const  db , char const   * const  tofind , size_t const   tofind_len ,
                off_t * const  retpos , size_t * const  retlen ) ;
#line 43
int puredb_find_s(PureDB * const  db , char const   * const  tofind , off_t * const  retpos ,
                  size_t * const  retlen ) ;
#line 46
void *puredb_read(PureDB * const  db , off_t const   offset , size_t const   len ) ;
#line 9 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_read.c"
static puredb_u32_t puredb_hash(char const   * const  msg , size_t len ) 
{ 
  puredb_u32_t j ;

  {
#line 11
  j = 5381U;
  {
#line 13
  while (1) {
    while_continue: /* CIL Label */ ;
#line 13
    if (! (len != 0UL)) {
#line 13
      goto while_break;
    }
#line 14
    len --;
#line 15
    j += j << 5;
#line 16
    j ^= (unsigned int )((unsigned char )*(msg + len));
  }
  while_break: /* CIL Label */ ;
  }
#line 18
  j &= 4294967295U;
#line 20
  return (j);
}
}
#line 23 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_read.c"
static ssize_t safe_read___0(int const   fd , void * const  buf_ , size_t maxlen ) 
{ 
  unsigned char *buf___1 ;
  ssize_t readnb ;
  int *tmp ;

  {
#line 25
  buf___1 = (unsigned char *)buf_;
  {
#line 28
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 29
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 29
      readnb = read((int )fd, (void *)buf___1, maxlen);
      }
#line 29
      if (readnb < 0L) {
        {
#line 29
        tmp = __errno_location();
        }
#line 29
        if (! (*tmp == 4)) {
#line 29
          goto while_break___0;
        }
      } else {
#line 29
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 31
    if (readnb < 0L) {
#line 32
      return (readnb);
    } else
#line 31
    if (readnb > (ssize_t )maxlen) {
#line 32
      return (readnb);
    }
#line 34
    if (readnb == 0L) {
      ret: 
#line 36
      return (buf___1 - (unsigned char *)buf_);
    }
#line 38
    maxlen -= (size_t )readnb;
#line 39
    buf___1 += readnb;
#line 28
    if (! (maxlen > 0UL)) {
#line 28
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 41
  goto ret;
}
}
#line 44 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_read.c"
static int read_be_long(PureDB const   * const  db , puredb_u32_t const   offset ,
                        puredb_u32_t * const  result ) 
{ 
  unsigned char mapoffsetbuf[4] ;
  unsigned char *mapoffset ;
  __off_t tmp ;
  ssize_t tmp___0 ;

  {
#line 52
  if ((unsigned long )db->map != (unsigned long )((void *)0)) {
#line 53
    mapoffset = (unsigned char *)(db->map + offset);
  } else {
    {
#line 57
    tmp = lseek((int )db->fd, (__off_t )offset, 0);
    }
#line 57
    if (tmp == -1L) {
#line 58
      return (-1);
    }
    {
#line 60
    tmp___0 = safe_read___0(db->fd, (void */* const  */)(mapoffsetbuf), sizeof(mapoffsetbuf));
    }
#line 60
    if (tmp___0 != (ssize_t )sizeof(mapoffsetbuf)) {
#line 62
      return (-1);
    }
#line 64
    mapoffset = mapoffsetbuf;
  }
#line 66
  *result = (puredb_u32_t )(((((int )*(mapoffset + 0) << 24) | ((int )*(mapoffset + 1) << 16)) | ((int )*(mapoffset + 2) << 8)) | (int )*(mapoffset + 3));
#line 69
  return (0);
}
}
#line 72 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_read.c"
static int read_memcmp(PureDB const   * const  db , puredb_u32_t const   offset ,
                       unsigned char const   *str , puredb_u32_t const   len ) 
{ 
  unsigned char *mapoffsetbuf ;
  int cmp ;
  int tmp ;
  void *tmp___0 ;
  __off_t tmp___1 ;
  ssize_t tmp___2 ;
  int tmp___3 ;

  {
#line 79
  if ((unsigned long )db->map != (unsigned long )((void *)0)) {
    {
#line 80
    tmp = memcmp((void const   *)(db->map + offset), (void const   *)str, (size_t )len);
    }
#line 80
    return (tmp != 0);
  }
  {
#line 83
  tmp___0 = __builtin_alloca((unsigned long )len);
#line 83
  mapoffsetbuf = (unsigned char *)tmp___0;
  }
#line 83
  if ((unsigned long )mapoffsetbuf == (unsigned long )((void *)0)) {
#line 84
    return (-2);
  }
  {
#line 86
  tmp___1 = lseek((int )db->fd, (__off_t )offset, 0);
  }
#line 86
  if (tmp___1 == -1L) {
    err: 
    {
#line 88
    while (1) {
      while_continue: /* CIL Label */ ;
#line 88
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 89
    return (-2);
  }
  {
#line 91
  tmp___2 = safe_read___0(db->fd, (void */* const  */)mapoffsetbuf, (size_t )len);
  }
#line 91
  if (tmp___2 != (ssize_t )len) {
#line 92
    goto err;
  }
  {
#line 94
  tmp___3 = memcmp((void const   *)mapoffsetbuf, (void const   *)str, (size_t )len);
#line 94
  cmp = tmp___3 != 0;
  }
  {
#line 95
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 95
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 97
  return (cmp);
}
}
#line 100 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_read.c"
int puredb_open(PureDB * const  db , char const   *dbfile ) 
{ 
  struct stat st ;
  int tmp ;
  int tmp___0 ;
  puredb_u32_t tmp___1 ;
  unsigned char *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 104
  db->map = (unsigned char *)((void *)0);
#line 105
  tmp = open(dbfile, 0);
#line 105
  db->fd = tmp;
  }
#line 105
  if (tmp == -1) {
#line 106
    return (-1);
  }
  {
#line 108
  tmp___0 = fstat(db->fd, & st);
  }
#line 108
  if (tmp___0 < 0) {
    {
#line 112
    close(db->fd);
    }
#line 114
    return (-2);
  } else
#line 108
  if (st.st_size > 4294967295L) {
    {
#line 112
    close(db->fd);
    }
#line 114
    return (-2);
  } else {
#line 108
    tmp___1 = (puredb_u32_t )st.st_size;
#line 108
    db->size = tmp___1;
#line 108
    if ((size_t )tmp___1 < (257UL * sizeof(puredb_u32_t ) + sizeof("PDB2")) - 1UL) {
      {
#line 112
      close(db->fd);
      }
#line 114
      return (-2);
    }
  }
  {
#line 117
  tmp___3 = mmap((void *)0, (size_t )db->size, 1, 1, db->fd, (off_t )0);
#line 117
  tmp___2 = (unsigned char *)tmp___3;
#line 117
  db->map = tmp___2;
  }
#line 117
  if ((unsigned long )((char *)tmp___2) == (unsigned long )((char *)((void *)-1))) {
#line 121
    db->map = (unsigned char *)((void *)0);
  }
  {
#line 139
  tmp___4 = read_memcmp((PureDB const   */* const  */)db, (puredb_u32_t const   )0U,
                        (unsigned char const   *)"PDB2", (puredb_u32_t const   )(sizeof("PDB2") - 1UL));
  }
#line 139
  if (tmp___4 != 0) {
#line 143
    return (-3);
  }
#line 145
  return (0);
}
}
#line 148 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_read.c"
int puredb_find(PureDB * const  db , char const   * const  tofind , size_t const   tofind_len ,
                off_t * const  retpos , size_t * const  retlen ) 
{ 
  puredb_u32_t hash ;
  puredb_u32_t scanned_hash ;
  puredb_u32_t hash0 ;
  puredb_u32_t hash1 ;
  puredb_u32_t hash1e ;
  puredb_u32_t lastslot ;
  puredb_u32_t slotlo ;
  puredb_u32_t slothi ;
  puredb_u32_t sno ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  puredb_u32_t data ;
  puredb_u32_t key_size ;
  puredb_u32_t data_size ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 162
  *retpos = (off_t )-1;
#line 163
  *retlen = (size_t )0U;
#line 164
  hash = puredb_hash(tofind, (size_t )tofind_len);
#line 165
  hash0 = (puredb_u32_t )((sizeof("PDB2") - 1UL) + (unsigned long )(hash & 255U) * sizeof(puredb_u32_t ));
  }
#line 168
  if ((unsigned long )hash0 + sizeof(puredb_u32_t ) * 2UL > (unsigned long )db->size) {
#line 169
    return (-2);
  }
  {
#line 171
  tmp = read_be_long((PureDB const   */* const  */)db, (puredb_u32_t const   )hash0,
                     (puredb_u32_t */* const  */)(& hash1));
  }
#line 171
  if (tmp < 0) {
#line 172
    return (-3);
  }
  {
#line 174
  tmp___0 = read_be_long((PureDB const   */* const  */)db, (puredb_u32_t const   )((unsigned long )hash0 + sizeof(puredb_u32_t )),
                         (puredb_u32_t */* const  */)(& hash1e));
  }
#line 174
  if (tmp___0 < 0) {
#line 175
    return (-3);
  }
#line 177
  if (hash1e <= hash1) {
#line 178
    return (-2);
  }
#line 180
  if (hash1 == 0U) {
#line 181
    return (-1);
  }
#line 183
  if (hash1 > db->size) {
#line 184
    return (-2);
  }
#line 186
  lastslot = (puredb_u32_t )((unsigned long )(hash1e - hash1) / (sizeof(puredb_u32_t ) + sizeof(puredb_u32_t )));
#line 187
  if (lastslot <= 0U) {
#line 188
    return (-2);
  }
#line 190
  lastslot --;
#line 192
  slotlo = 0U;
#line 193
  slothi = lastslot;
#line 194
  sno = slothi / 2U;
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if (! (slotlo <= slothi)) {
#line 195
      goto while_break;
    }
    {
#line 196
    tmp___1 = read_be_long((PureDB const   */* const  */)db, (puredb_u32_t const   )((unsigned long )hash1 + (unsigned long )sno * (sizeof(puredb_u32_t ) + sizeof(puredb_u32_t ))),
                           (puredb_u32_t */* const  */)(& scanned_hash));
    }
#line 196
    if (tmp___1 < 0) {
#line 199
      return (-3);
    }
#line 201
    if (scanned_hash == hash) {
      {
#line 202
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 202
        if (! (sno > 0U)) {
#line 202
          goto while_break___0;
        }
        {
#line 203
        sno --;
#line 204
        tmp___2 = read_be_long((PureDB const   */* const  */)db, (puredb_u32_t const   )((unsigned long )hash1 + (unsigned long )sno * (sizeof(puredb_u32_t ) + sizeof(puredb_u32_t ))),
                               (puredb_u32_t */* const  */)(& scanned_hash));
        }
#line 204
        if (tmp___2 < 0) {
#line 207
          return (-3);
        }
#line 209
        if (scanned_hash != hash) {
#line 210
          sno ++;
#line 211
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 214
      hash1 = (puredb_u32_t )((unsigned long )hash1 + (unsigned long )sno * (sizeof(puredb_u32_t ) + sizeof(puredb_u32_t )));
#line 215
      goto shortcut;
    }
#line 217
    if (scanned_hash > hash) {
#line 218
      if (sno <= 0U) {
#line 219
        goto while_break;
      }
#line 221
      slothi = sno - 1U;
    } else {
#line 223
      if (sno >= lastslot) {
#line 224
        goto while_break;
      }
#line 226
      slotlo = sno + 1U;
    }
#line 228
    sno = (slothi + slotlo) / 2U;
  }
  while_break: /* CIL Label */ ;
  }
#line 230
  hash1 = (puredb_u32_t )((unsigned long )hash1 + (unsigned long )sno * (sizeof(puredb_u32_t ) + sizeof(puredb_u32_t )));
  {
#line 232
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 233
    tmp___3 = read_be_long((PureDB const   */* const  */)db, (puredb_u32_t const   )hash1,
                           (puredb_u32_t */* const  */)(& scanned_hash));
    }
#line 233
    if (tmp___3 < 0) {
#line 234
      return (-3);
    }
#line 236
    if (scanned_hash > hash) {
#line 237
      return (-1);
    }
#line 239
    if (scanned_hash == hash) {
      shortcut: 
      {
#line 245
      tmp___4 = read_be_long((PureDB const   */* const  */)db, (puredb_u32_t const   )(hash1 + 4U),
                             (puredb_u32_t */* const  */)(& data));
      }
#line 245
      if (tmp___4 < 0) {
#line 246
        return (-3);
      }
#line 248
      if (data > db->size) {
#line 249
        return (-2);
      }
      {
#line 251
      tmp___5 = read_be_long((PureDB const   */* const  */)db, (puredb_u32_t const   )data,
                             (puredb_u32_t */* const  */)(& key_size));
      }
#line 251
      if (tmp___5 < 0) {
#line 252
        return (-3);
      }
#line 254
      if (key_size != (puredb_u32_t )tofind_len) {
#line 255
        goto trynext;
      }
      {
#line 257
      tmp___6 = read_memcmp((PureDB const   */* const  */)db, (puredb_u32_t const   )((unsigned long )data + sizeof(puredb_u32_t )),
                            (unsigned char const   *)tofind, (puredb_u32_t const   )tofind_len);
      }
#line 257
      if (tmp___6 != 0) {
#line 259
        goto trynext;
      }
      {
#line 261
      data = (puredb_u32_t )((unsigned long )data + (sizeof(puredb_u32_t ) + (unsigned long )tofind_len));
#line 262
      tmp___7 = read_be_long((PureDB const   */* const  */)db, (puredb_u32_t const   )data,
                             (puredb_u32_t */* const  */)(& data_size));
      }
#line 262
      if (tmp___7 < 0) {
#line 263
        return (-3);
      }
#line 265
      data = (puredb_u32_t )((unsigned long )data + sizeof(puredb_u32_t ));
#line 266
      *retpos = (off_t )data;
#line 267
      *retlen = (size_t )data_size;
#line 269
      return (0);
    }
    trynext: 
#line 272
    hash1 = (puredb_u32_t )((unsigned long )hash1 + (sizeof(puredb_u32_t ) + sizeof(puredb_u32_t )));
#line 273
    if (lastslot == 0U) {
#line 274
      goto while_break___1;
    }
#line 276
    lastslot --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 279
  return (-1);
}
}
#line 282 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_read.c"
int puredb_find_s(PureDB * const  db , char const   * const  tofind , off_t * const  retpos ,
                  size_t * const  retlen ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 285
  tmp = strlen((char const   *)tofind);
#line 285
  tmp___0 = puredb_find(db, tofind, (size_t const   )tmp, retpos, retlen);
  }
#line 285
  return (tmp___0);
}
}
#line 288 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_read.c"
void *puredb_read(PureDB * const  db , off_t const   offset , size_t const   len ) 
{ 
  void *buf___1 ;
  __off_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 292
  buf___1 = malloc((size_t )(len + 1UL));
  }
#line 292
  if ((unsigned long )buf___1 == (unsigned long )((void *)0)) {
#line 293
    return ((void *)0);
  }
#line 296
  if ((unsigned long )db->map != (unsigned long )((void *)0)) {
    {
#line 297
    memcpy((void */* __restrict  */)buf___1, (void const   */* __restrict  */)(db->map + offset),
           (size_t )len);
    }
  } else {
    {
#line 301
    tmp = lseek(db->fd, (__off_t )offset, 0);
    }
#line 301
    if (tmp == -1L) {
      {
#line 303
      free(buf___1);
      }
#line 304
      return ((void *)0);
    } else {
      {
#line 301
      tmp___0 = safe_read___0((int const   )db->fd, (void */* const  */)buf___1, (size_t )len);
      }
#line 301
      if (tmp___0 != (ssize_t )len) {
        {
#line 303
        free(buf___1);
        }
#line 304
        return ((void *)0);
      }
    }
  }
#line 307
  *((unsigned char *)buf___1 + len) = (unsigned char)0;
#line 309
  return (buf___1);
}
}
#line 312 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_read.c"
int puredb_close(PureDB * const  db ) 
{ 
  int ret ;

  {
#line 314
  ret = 0;
#line 317
  if ((unsigned long )db->map != (unsigned long )((void *)0)) {
    {
#line 319
    munmap((void *)db->map, (size_t )db->size);
#line 321
    db->map = (unsigned char *)((void *)0);
    }
  }
#line 329
  if (db->fd != -1) {
    {
#line 330
    ret = close(db->fd);
#line 331
    db->fd = -1;
    }
  }
#line 334
  return (ret);
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 695
extern int puts(char const   *__s ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 826 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 44 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_write.h"
int puredbw_open(PureDBW * const  dbw , char const   * const  file_index , char const   * const  file_data ,
                 char const   * const  file_final ) ;
#line 49
int puredbw_close(PureDBW * const  dbw ) ;
#line 51
void puredbw_free(PureDBW * const  dbw ) ;
#line 57
int puredbw_add_s(PureDBW * const  dbw , char const   * const  key , char const   * const  content ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 12 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/regression.c"
int main(void) 
{ 
  char key[42] ;
  char data[42] ;
  unsigned long long curkey ;
  unsigned long long nbrec ;
  PureDBW dbw ;
  PureDB db ;
  off_t retpos ;
  size_t retlen ;
  char *founddata ;
  int pass ;
  unsigned int seed ;
  unsigned int randomrounds ;
  int tmp ;
  time_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  void *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  {
#line 16
  curkey = 0ULL;
#line 17
  nbrec = 0ULL;
#line 23
  pass = 0;
#line 24
  seed = 0U;
#line 25
  randomrounds = 42000U;
#line 27
  printf((char const   */* __restrict  */)"Starting regression tests\n\nDatabase creation (wait) ... ");
#line 28
  fflush(stdout);
#line 29
  tmp = puredbw_open((PureDBW */* const  */)(& dbw), (char const   */* const  */)"puredb.index",
                     (char const   */* const  */)"puredb.data", (char const   */* const  */)"puredb.pdb");
  }
#line 29
  if (tmp != 0) {
    {
#line 30
    perror("Can\'t create the database");
    }
#line 31
    goto end;
  }
  {
#line 33
  tmp___0 = time((time_t *)((void *)0));
#line 33
  seed = (unsigned int )tmp___0;
#line 34
  srand(seed);
  }
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 36
    tmp___1 = rand();
#line 36
    curkey += (unsigned long long )(tmp___1 & 20479);
#line 37
    snprintf((char */* __restrict  */)(key), sizeof(key), (char const   */* __restrict  */)"%llu",
             curkey);
#line 38
    snprintf((char */* __restrict  */)(data), sizeof(data), (char const   */* __restrict  */)"%llu",
             curkey ^ 5124095577148911ULL);
#line 39
    tmp___2 = puredbw_add_s((PureDBW */* const  */)(& dbw), (char const   */* const  */)(key),
                            (char const   */* const  */)(data));
    }
#line 39
    if (tmp___2 != 0) {
#line 40
      goto end;
    }
#line 42
    nbrec ++;
#line 35
    if (! (curkey < 4294967280ULL)) {
#line 35
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 44
  tmp___3 = puredbw_close((PureDBW */* const  */)(& dbw));
  }
#line 44
  if (tmp___3 != 0) {
#line 45
    goto end;
  }
#line 47
  pass ++;
  end: 
  {
#line 49
  puredbw_free((PureDBW */* const  */)(& dbw));
  }
#line 50
  if (pass == 0) {
    {
#line 51
    puts("Failure :(");
#line 52
    unlink("puredb.index");
#line 53
    unlink("puredb.data");
#line 54
    unlink("puredb.pdb");
    }
#line 55
    return (-1);
  } else {
    {
#line 57
    printf((char const   */* __restrict  */)"Success! %llu records have been written\n",
           nbrec);
#line 58
    pass = 0;
    }
  }
  {
#line 60
  printf((char const   */* __restrict  */)"Database lookups (wait) ... ");
#line 61
  fflush(stdout);
#line 62
  tmp___4 = puredb_open((PureDB */* const  */)(& db), "puredb.pdb");
  }
#line 62
  if (tmp___4 != 0) {
    {
#line 63
    perror("Can\'t open the database");
    }
#line 64
    goto end2;
  }
  {
#line 66
  curkey = 0ULL;
#line 67
  srand(seed);
  }
  {
#line 68
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 69
    tmp___5 = rand();
#line 69
    curkey += (unsigned long long )(tmp___5 & 20479);
#line 70
    snprintf((char */* __restrict  */)(key), sizeof(key), (char const   */* __restrict  */)"%llu",
             curkey);
#line 71
    snprintf((char */* __restrict  */)(data), sizeof(data), (char const   */* __restrict  */)"%llu",
             curkey ^ 5124095577148911ULL);
#line 72
    tmp___6 = puredb_find_s((PureDB */* const  */)(& db), (char const   */* const  */)(key),
                            (off_t */* const  */)(& retpos), (size_t */* const  */)(& retlen));
    }
#line 72
    if (tmp___6 != 0) {
      {
#line 73
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The key wasn\'t found\n");
      }
#line 74
      goto end2;
    }
    {
#line 76
    tmp___8 = puredb_read((PureDB */* const  */)(& db), (off_t const   )retpos, (size_t const   )retlen);
#line 76
    founddata = (char *)tmp___8;
    }
#line 76
    if ((unsigned long )founddata != (unsigned long )((void *)0)) {
      {
#line 77
      tmp___7 = strcmp((char const   *)founddata, (char const   *)(data));
      }
#line 77
      if (tmp___7 != 0) {
        {
#line 78
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong data\n");
        }
#line 79
        goto end2;
      }
#line 81
      if ((unsigned long )founddata != (unsigned long )((void *)0)) {
        {
#line 81
        free((void *)founddata);
        }
      }
    }
#line 68
    if (! (curkey < 4294967280ULL)) {
#line 68
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 84
  printf((char const   */* __restrict  */)"also trying non-existent data ... ");
#line 85
  fflush(stdout);
  }
  {
#line 86
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 87
    curkey <<= 1;
#line 88
    tmp___9 = rand();
#line 88
    curkey ^= (unsigned long long )tmp___9;
#line 89
    snprintf((char */* __restrict  */)(key), sizeof(key), (char const   */* __restrict  */)"%llu",
             curkey);
#line 90
    tmp___11 = puredb_find_s((PureDB */* const  */)(& db), (char const   */* const  */)(key),
                             (off_t */* const  */)(& retpos), (size_t */* const  */)(& retlen));
    }
#line 90
    if (tmp___11 == 0) {
      {
#line 91
      tmp___10 = puredb_read((PureDB */* const  */)(& db), (off_t const   )retpos,
                             (size_t const   )retlen);
#line 91
      founddata = (char *)tmp___10;
      }
#line 92
      if ((unsigned long )founddata != (unsigned long )((void *)0)) {
        {
#line 92
        free((void *)founddata);
        }
      }
    }
#line 94
    randomrounds --;
#line 86
    if (! (randomrounds > 0U)) {
#line 86
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 96
  pass ++;
  end2: 
  {
#line 98
  tmp___12 = puredb_close((PureDB */* const  */)(& db));
  }
#line 98
  if (tmp___12 != 0) {
    {
#line 99
    perror("The database couldn\'t be properly closed");
    }
  }
  {
#line 101
  unlink("puredb.pdb");
  }
#line 102
  if (pass == 0) {
    {
#line 103
    puts("Failure :(");
    }
#line 104
    return (-1);
  } else {
    {
#line 106
    puts("Success!");
    }
  }
#line 109
  return (0);
}
}
#line 180 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 765
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 956 "/usr/include/unistd.h"
extern int fsync(int __fd ) ;
#line 377 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 53 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_write.h"
int puredbw_add(PureDBW * const  dbw , char const   * const  key , size_t const   key_len ,
                char const   * const  content , size_t const   content_len ) ;
#line 26 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_write.c"
static puredb_u32_t puredbw_hash(char const   * const  msg , size_t len ) 
{ 
  puredb_u32_t j ;

  {
#line 28
  j = 5381U;
  {
#line 30
  while (1) {
    while_continue: /* CIL Label */ ;
#line 30
    if (! (len != 0UL)) {
#line 30
      goto while_break;
    }
#line 31
    len --;
#line 32
    j += j << 5;
#line 33
    j ^= (unsigned int )((unsigned char )*(msg + len));
  }
  while_break: /* CIL Label */ ;
  }
#line 35
  j &= 4294967295U;
#line 37
  return (j);
}
}
#line 40 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_write.c"
int puredbw_open(PureDBW * const  dbw , char const   * const  file_index , char const   * const  file_data ,
                 char const   * const  file_final ) 
{ 
  int z ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  FILE *tmp___2 ;
  FILE *tmp___3 ;
  size_t tmp___4 ;

  {
#line 45
  dbw->file_index = (char *)((void *)0);
#line 46
  dbw->file_data = (char *)((void *)0);
#line 47
  dbw->file_final = (char *)((void *)0);
#line 48
  dbw->fpindex = (FILE *)((void *)0);
#line 49
  dbw->fpdata = (FILE *)((void *)0);
#line 51
  z = (int )(sizeof(dbw->hash_table0) / sizeof(dbw->hash_table0[0]) - 1UL);
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    dbw->hash_table0[z].hash1_list = (Hash1 *)((void *)0);
#line 55
    dbw->hash_table0[z].hash1_list_size = (size_t )0U;
#line 56
    z --;
#line 53
    if (! (z >= 0)) {
#line 53
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 59
  tmp = strdup((char const   *)file_index);
#line 59
  dbw->file_index = tmp;
  }
#line 59
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 65
    return (-1);
  } else {
    {
#line 59
    tmp___0 = strdup((char const   *)file_data);
#line 59
    dbw->file_data = tmp___0;
    }
#line 59
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 65
      return (-1);
    } else {
      {
#line 59
      tmp___1 = strdup((char const   *)file_final);
#line 59
      dbw->file_final = tmp___1;
      }
#line 59
      if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 65
        return (-1);
      } else {
        {
#line 59
        tmp___2 = fopen((char const   */* __restrict  */)file_index, (char const   */* __restrict  */)"wb");
#line 59
        dbw->fpindex = tmp___2;
        }
#line 59
        if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 65
          return (-1);
        } else {
          {
#line 59
          tmp___3 = fopen((char const   */* __restrict  */)file_data, (char const   */* __restrict  */)"w+b");
#line 59
          dbw->fpdata = tmp___3;
          }
#line 59
          if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
#line 65
            return (-1);
          }
        }
      }
    }
  }
  {
#line 67
  dbw->data_offset_counter = 0U;
#line 68
  dbw->offset_first_data = (puredb_u32_t )((sizeof("PDB2") - 1UL) + (1UL + sizeof(dbw->hash_table0) / sizeof(dbw->hash_table0[0])) * sizeof(puredb_u32_t ));
#line 72
  tmp___4 = fwrite((void const   */* __restrict  */)"PDB2", (size_t )1U, sizeof("PDB2") - 1UL,
                   (FILE */* __restrict  */)dbw->fpindex);
  }
#line 72
  if (tmp___4 != sizeof("PDB2") - 1UL) {
#line 75
    return (-1);
  }
#line 77
  return (0);
}
}
#line 80 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_write.c"
int puredbw_add(PureDBW * const  dbw , char const   * const  key , size_t const   key_len ,
                char const   * const  content , size_t const   content_len ) 
{ 
  puredb_u32_t hash ;
  puredb_u32_t tmp ;
  puredb_u32_t hash_hi ;
  Hash0 *hash0 ;
  Hash1 *hash1 ;
  Hash1 *tmp___0 ;
  void *tmp___1 ;
  Hash1 *newpnt ;
  void *tmp___2 ;
  puredb_u32_t key_len_ ;
  uint32_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  puredb_u32_t content_len_ ;
  uint32_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;

  {
  {
#line 84
  tmp = puredbw_hash(key, (size_t )key_len);
#line 84
  hash = tmp;
#line 85
  hash_hi = hash & 255U;
#line 86
  hash0 = & dbw->hash_table0[hash_hi];
  }
#line 89
  if ((unsigned long )hash0->hash1_list == (unsigned long )((void *)0)) {
    {
#line 90
    hash0->hash1_list_size = sizeof(Hash1 );
#line 91
    tmp___1 = malloc(hash0->hash1_list_size);
#line 91
    tmp___0 = (Hash1 *)tmp___1;
#line 91
    hash0->hash1_list = tmp___0;
    }
#line 91
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 92
      return (-1);
    }
  } else {
    {
#line 97
    hash0->hash1_list_size += sizeof(Hash1 );
#line 98
    tmp___2 = realloc((void *)hash0->hash1_list, hash0->hash1_list_size);
#line 98
    newpnt = (Hash1 *)tmp___2;
    }
#line 98
    if ((unsigned long )newpnt == (unsigned long )((void *)0)) {
#line 100
      return (-1);
    }
#line 102
    hash0->hash1_list = newpnt;
  }
  {
#line 104
  dbw->offset_first_data = (puredb_u32_t )((unsigned long )dbw->offset_first_data + (sizeof(puredb_u32_t ) + sizeof(puredb_u32_t )));
#line 105
  hash1 = (Hash1 *)((void *)(((unsigned char *)hash0->hash1_list + hash0->hash1_list_size) - sizeof(Hash1 )));
#line 107
  hash1->hash = hash;
#line 108
  hash1->offset_data = dbw->data_offset_counter;
#line 109
  dbw->data_offset_counter = (puredb_u32_t )((unsigned long )dbw->data_offset_counter + (((sizeof(puredb_u32_t ) + sizeof(puredb_u32_t )) + (unsigned long )key_len) + (unsigned long )content_len));
#line 112
  tmp___3 = htonl((puredb_u32_t )key_len);
#line 112
  key_len_ = tmp___3;
#line 113
  tmp___4 = fwrite((void const   */* __restrict  */)(& key_len_), sizeof(key_len_),
                   (size_t )1U, (FILE */* __restrict  */)dbw->fpdata);
  }
#line 113
  if (tmp___4 != 1UL) {
#line 115
    return (-1);
  }
  {
#line 118
  tmp___5 = fwrite((void const   */* __restrict  */)key, (size_t )1U, (size_t )key_len,
                   (FILE */* __restrict  */)dbw->fpdata);
  }
#line 118
  if (tmp___5 != (size_t )key_len) {
#line 119
    return (-1);
  }
  {
#line 122
  tmp___6 = htonl((puredb_u32_t )content_len);
#line 122
  content_len_ = tmp___6;
#line 123
  tmp___7 = fwrite((void const   */* __restrict  */)(& content_len_), sizeof(content_len_),
                   (size_t )1U, (FILE */* __restrict  */)dbw->fpdata);
  }
#line 123
  if (tmp___7 != 1UL) {
#line 125
    return (-1);
  }
  {
#line 128
  tmp___8 = fwrite((void const   */* __restrict  */)content, (size_t )1U, (size_t )content_len,
                   (FILE */* __restrict  */)dbw->fpdata);
  }
#line 128
  if (tmp___8 != (size_t )content_len) {
#line 131
    return (-1);
  }
#line 134
  return (0);
}
}
#line 137 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_write.c"
int puredbw_add_s(PureDBW * const  dbw , char const   * const  key , char const   * const  content ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 140
  tmp = strlen((char const   *)content);
#line 140
  tmp___0 = strlen((char const   *)key);
#line 140
  tmp___1 = puredbw_add(dbw, key, (size_t const   )tmp___0, content, (size_t const   )tmp);
  }
#line 140
  return (tmp___1);
}
}
#line 143 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_write.c"
static int hash1_cmp_hook(void const   * const  a , void const   * const  b ) 
{ 
  puredb_u32_t ha ;
  puredb_u32_t hb ;

  {
#line 145
  ha = (puredb_u32_t )((Hash1 const   *)a)->hash;
#line 146
  hb = (puredb_u32_t )((Hash1 const   *)b)->hash;
#line 148
  if (ha < hb) {
#line 149
    return (-1);
  } else
#line 150
  if (ha > hb) {
#line 151
    return (1);
  }
#line 153
  ha = (puredb_u32_t )((Hash1 const   *)a)->offset_data;
#line 154
  hb = (puredb_u32_t )((Hash1 const   *)b)->offset_data;
#line 155
  if (ha < hb) {
#line 156
    return (-1);
  } else
#line 157
  if (ha > hb) {
#line 158
    return (1);
  }
#line 160
  return (0);
}
}
#line 163 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_write.c"
static int writekeys(PureDBW * const  dbw ) 
{ 
  int hash_cnt ;
  Hash0 const   *hash0 ;
  puredb_u32_t offset ;
  puredb_u32_t offset_ ;
  uint32_t tmp ;
  size_t tmp___0 ;
  puredb_u32_t null_ ;
  uint32_t tmp___1 ;
  size_t tmp___2 ;
  Hash1 *hash1 ;
  size_t list_size ;
  puredb_u32_t null____0 ;
  uint32_t tmp___3 ;
  size_t tmp___4 ;
  puredb_u32_t hash_ ;
  uint32_t tmp___5 ;
  size_t tmp___6 ;
  puredb_u32_t offset_data_ ;
  uint32_t tmp___7 ;
  size_t tmp___8 ;

  {
#line 165
  hash_cnt = (int )(sizeof(dbw->hash_table0) / sizeof(dbw->hash_table0[0]));
#line 167
  hash0 = (Hash0 const   *)(dbw->hash_table0);
#line 169
  offset = (puredb_u32_t )(((1UL + sizeof(dbw->hash_table0) / sizeof(dbw->hash_table0[0])) * sizeof(puredb_u32_t ) + sizeof("PDB2")) - 1UL);
  {
#line 172
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 174
    tmp = htonl(offset);
#line 174
    offset_ = tmp;
#line 176
    tmp___0 = fwrite((void const   */* __restrict  */)(& offset_), sizeof(offset_),
                     (size_t )1U, (FILE */* __restrict  */)dbw->fpindex);
    }
#line 176
    if (tmp___0 != 1UL) {
#line 179
      return (-1);
    }
#line 182
    if (hash0->hash1_list_size <= 0UL) {
#line 183
      offset = (puredb_u32_t )((unsigned long )offset + sizeof(puredb_u32_t ));
#line 184
      dbw->offset_first_data = (puredb_u32_t )((unsigned long )dbw->offset_first_data + sizeof(puredb_u32_t ));
    } else {
#line 186
      offset = (puredb_u32_t )((size_t const   )offset + (hash0->hash1_list_size / (size_t const   )sizeof(Hash1 )) * (size_t const   )(sizeof(puredb_u32_t ) + sizeof(puredb_u32_t )));
    }
#line 189
    hash0 ++;
#line 190
    hash_cnt --;
#line 172
    if (! (hash_cnt != 0)) {
#line 172
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 193
  tmp___1 = htonl(offset);
#line 193
  null_ = tmp___1;
#line 194
  tmp___2 = fwrite((void const   */* __restrict  */)(& null_), sizeof(null_), (size_t )1U,
                   (FILE */* __restrict  */)dbw->fpindex);
  }
#line 194
  if (tmp___2 != 1UL) {
#line 196
    return (-1);
  }
#line 200
  hash_cnt = (int )(sizeof(dbw->hash_table0) / sizeof(dbw->hash_table0[0]));
#line 201
  hash0 = (Hash0 const   *)(dbw->hash_table0);
  {
#line 202
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 203
    hash1 = (Hash1 *)hash0->hash1_list;
#line 204
    list_size = (size_t )hash0->hash1_list_size;
#line 206
    if ((unsigned long )hash1 == (unsigned long )((void *)0)) {
      {
#line 207
      tmp___3 = htonl((uint32_t )((hash0 - (Hash0 const   *)(dbw->hash_table0)) + 1L));
#line 207
      null____0 = tmp___3;
#line 210
      tmp___4 = fwrite((void const   */* __restrict  */)(& null____0), sizeof(null____0),
                       (size_t )1U, (FILE */* __restrict  */)dbw->fpindex);
      }
#line 210
      if (tmp___4 != 1UL) {
#line 212
        return (-1);
      }
#line 214
      goto next;
    }
    {
#line 216
    qsort((void *)hash1, (size_t )(hash0->hash1_list_size / (size_t const   )sizeof(Hash1 )),
          sizeof(Hash1 ), (int (*)(void const   * , void const   * ))(& hash1_cmp_hook));
    }
    {
#line 218
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 220
      tmp___5 = htonl(hash1->hash);
#line 220
      hash_ = tmp___5;
#line 222
      tmp___6 = fwrite((void const   */* __restrict  */)(& hash_), sizeof(hash_),
                       (size_t )1U, (FILE */* __restrict  */)dbw->fpindex);
      }
#line 222
      if (tmp___6 != 1UL) {
#line 224
        return (-1);
      }
      {
#line 228
      tmp___7 = htonl(hash1->offset_data + dbw->offset_first_data);
#line 228
      offset_data_ = tmp___7;
#line 231
      tmp___8 = fwrite((void const   */* __restrict  */)(& offset_data_), sizeof(offset_data_),
                       (size_t )1U, (FILE */* __restrict  */)dbw->fpindex);
      }
#line 231
      if (tmp___8 != 1UL) {
#line 233
        return (-1);
      }
#line 236
      hash1 ++;
#line 237
      list_size -= sizeof(Hash1 );
#line 218
      if (! (list_size > 0UL)) {
#line 218
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    next: 
#line 240
    hash0 ++;
#line 241
    hash_cnt --;
#line 202
    if (! (hash_cnt != 0)) {
#line 202
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 244
  return (0);
}
}
#line 247 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_write.c"
static int freestructs(PureDBW * const  dbw ) 
{ 
  Hash0 *hash0 ;
  int hash0_cnt ;

  {
#line 249
  hash0 = dbw->hash_table0;
#line 250
  hash0_cnt = (int )(sizeof(dbw->hash_table0) / sizeof(dbw->hash_table0[0]));
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 253
    free((void *)hash0->hash1_list);
#line 254
    hash0->hash1_list = (Hash1 *)((void *)0);
#line 255
    hash0 ++;
#line 256
    hash0_cnt --;
    }
#line 252
    if (! (hash0_cnt > 0)) {
#line 252
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 259
  return (0);
}
}
#line 262 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_write.c"
static int mergefiles(PureDBW * const  dbw ) 
{ 
  size_t readnb ;
  char buf___1[4096] ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 267
  rewind(dbw->fpdata);
  }
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 268
    readnb = fread((void */* __restrict  */)(buf___1), (size_t )1U, sizeof(buf___1),
                   (FILE */* __restrict  */)dbw->fpdata);
    }
#line 268
    if (! (readnb > 0UL)) {
#line 268
      goto while_break;
    }
    {
#line 270
    tmp = fwrite((void const   */* __restrict  */)(buf___1), (size_t )1U, readnb,
                 (FILE */* __restrict  */)dbw->fpindex);
    }
#line 270
    if (tmp != readnb) {
#line 271
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 274
  tmp___0 = fclose(dbw->fpdata);
  }
#line 274
  if (tmp___0 != 0) {
#line 275
    return (-1);
  }
  {
#line 277
  dbw->fpdata = (FILE *)((void *)0);
#line 278
  fflush(dbw->fpindex);
#line 280
  tmp___1 = fileno(dbw->fpindex);
#line 280
  fsync(tmp___1);
#line 282
  tmp___2 = fclose(dbw->fpindex);
  }
#line 282
  if (tmp___2 != 0) {
#line 283
    return (-1);
  }
  {
#line 285
  dbw->fpindex = (FILE *)((void *)0);
#line 286
  unlink((char const   *)dbw->file_data);
#line 287
  tmp___4 = rename((char const   *)dbw->file_index, (char const   *)dbw->file_final);
  }
#line 287
  if (tmp___4 < 0) {
    {
#line 289
    unlink((char const   *)dbw->file_final);
#line 290
    tmp___3 = rename((char const   *)dbw->file_index, (char const   *)dbw->file_final);
    }
#line 290
    if (tmp___3 < 0) {
#line 291
      return (-1);
    }
  }
#line 295
  return (0);
}
}
#line 298 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_write.c"
static void freeall(PureDBW * const  dbw ) 
{ 


  {
#line 300
  if ((unsigned long )dbw->fpindex != (unsigned long )((void *)0)) {
    {
#line 301
    fclose(dbw->fpindex);
#line 302
    dbw->fpindex = (FILE *)((void *)0);
    }
  }
#line 304
  if ((unsigned long )dbw->fpdata != (unsigned long )((void *)0)) {
    {
#line 305
    fclose(dbw->fpdata);
#line 306
    dbw->fpdata = (FILE *)((void *)0);
    }
  }
  {
#line 308
  free((void *)dbw->file_index);
#line 309
  dbw->file_index = (char *)((void *)0);
#line 310
  free((void *)dbw->file_data);
#line 311
  dbw->file_data = (char *)((void *)0);
#line 312
  free((void *)dbw->file_final);
#line 313
  dbw->file_final = (char *)((void *)0);
  }
#line 314
  return;
}
}
#line 316 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_write.c"
void puredbw_free(PureDBW * const  dbw ) 
{ 


  {
  {
#line 318
  freestructs(dbw);
#line 319
  freeall(dbw);
  }
#line 320
  return;
}
}
#line 322 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_write.c"
int puredbw_close(PureDBW * const  dbw ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 324
  tmp = writekeys(dbw);
  }
#line 324
  if (tmp != 0) {
#line 325
    return (-1);
  }
  {
#line 327
  freestructs(dbw);
#line 328
  tmp___0 = mergefiles(dbw);
  }
#line 328
  if (tmp___0 != 0) {
#line 329
    return (-1);
  }
  {
#line 331
  freeall(dbw);
  }
#line 333
  return (0);
}
}
#line 26 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_write.c"
static puredb_u32_t puredbw_hash___0(char const   * const  msg , size_t len ) 
{ 
  puredb_u32_t j ;

  {
#line 28
  j = 5381U;
  {
#line 30
  while (1) {
    while_continue: /* CIL Label */ ;
#line 30
    if (! (len != 0UL)) {
#line 30
      goto while_break;
    }
#line 31
    len --;
#line 32
    j += j << 5;
#line 33
    j ^= (unsigned int )((unsigned char )*(msg + len));
  }
  while_break: /* CIL Label */ ;
  }
#line 35
  j &= 4294967295U;
#line 37
  return (j);
}
}
#line 143 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_write.c"
static int hash1_cmp_hook___0(void const   * const  a , void const   * const  b ) 
{ 
  puredb_u32_t ha ;
  puredb_u32_t hb ;

  {
#line 145
  ha = (puredb_u32_t )((Hash1 const   *)a)->hash;
#line 146
  hb = (puredb_u32_t )((Hash1 const   *)b)->hash;
#line 148
  if (ha < hb) {
#line 149
    return (-1);
  } else
#line 150
  if (ha > hb) {
#line 151
    return (1);
  }
#line 153
  ha = (puredb_u32_t )((Hash1 const   *)a)->offset_data;
#line 154
  hb = (puredb_u32_t )((Hash1 const   *)b)->offset_data;
#line 155
  if (ha < hb) {
#line 156
    return (-1);
  } else
#line 157
  if (ha > hb) {
#line 158
    return (1);
  }
#line 160
  return (0);
}
}
#line 163 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_write.c"
static int writekeys___0(PureDBW * const  dbw ) 
{ 
  int hash_cnt ;
  Hash0 const   *hash0 ;
  puredb_u32_t offset ;
  puredb_u32_t offset_ ;
  uint32_t tmp ;
  size_t tmp___0 ;
  puredb_u32_t null_ ;
  uint32_t tmp___1 ;
  size_t tmp___2 ;
  Hash1 *hash1 ;
  size_t list_size ;
  puredb_u32_t null____0 ;
  uint32_t tmp___3 ;
  size_t tmp___4 ;
  puredb_u32_t hash_ ;
  uint32_t tmp___5 ;
  size_t tmp___6 ;
  puredb_u32_t offset_data_ ;
  uint32_t tmp___7 ;
  size_t tmp___8 ;

  {
#line 165
  hash_cnt = (int )(sizeof(dbw->hash_table0) / sizeof(dbw->hash_table0[0]));
#line 167
  hash0 = (Hash0 const   *)(dbw->hash_table0);
#line 169
  offset = (puredb_u32_t )(((1UL + sizeof(dbw->hash_table0) / sizeof(dbw->hash_table0[0])) * sizeof(puredb_u32_t ) + sizeof("PDB2")) - 1UL);
  {
#line 172
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 174
    tmp = htonl(offset);
#line 174
    offset_ = tmp;
#line 176
    tmp___0 = fwrite((void const   */* __restrict  */)(& offset_), sizeof(offset_),
                     (size_t )1U, (FILE */* __restrict  */)dbw->fpindex);
    }
#line 176
    if (tmp___0 != 1UL) {
#line 179
      return (-1);
    }
#line 182
    if (hash0->hash1_list_size <= 0UL) {
#line 183
      offset = (puredb_u32_t )((unsigned long )offset + sizeof(puredb_u32_t ));
#line 184
      dbw->offset_first_data = (puredb_u32_t )((unsigned long )dbw->offset_first_data + sizeof(puredb_u32_t ));
    } else {
#line 186
      offset = (puredb_u32_t )((size_t const   )offset + (hash0->hash1_list_size / (size_t const   )sizeof(Hash1 )) * (size_t const   )(sizeof(puredb_u32_t ) + sizeof(puredb_u32_t )));
    }
#line 189
    hash0 ++;
#line 190
    hash_cnt --;
#line 172
    if (! (hash_cnt != 0)) {
#line 172
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 193
  tmp___1 = htonl(offset);
#line 193
  null_ = tmp___1;
#line 194
  tmp___2 = fwrite((void const   */* __restrict  */)(& null_), sizeof(null_), (size_t )1U,
                   (FILE */* __restrict  */)dbw->fpindex);
  }
#line 194
  if (tmp___2 != 1UL) {
#line 196
    return (-1);
  }
#line 200
  hash_cnt = (int )(sizeof(dbw->hash_table0) / sizeof(dbw->hash_table0[0]));
#line 201
  hash0 = (Hash0 const   *)(dbw->hash_table0);
  {
#line 202
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 203
    hash1 = (Hash1 *)hash0->hash1_list;
#line 204
    list_size = (size_t )hash0->hash1_list_size;
#line 206
    if ((unsigned long )hash1 == (unsigned long )((void *)0)) {
      {
#line 207
      tmp___3 = htonl((uint32_t )((hash0 - (Hash0 const   *)(dbw->hash_table0)) + 1L));
#line 207
      null____0 = tmp___3;
#line 210
      tmp___4 = fwrite((void const   */* __restrict  */)(& null____0), sizeof(null____0),
                       (size_t )1U, (FILE */* __restrict  */)dbw->fpindex);
      }
#line 210
      if (tmp___4 != 1UL) {
#line 212
        return (-1);
      }
#line 214
      goto next;
    }
    {
#line 216
    qsort((void *)hash1, (size_t )(hash0->hash1_list_size / (size_t const   )sizeof(Hash1 )),
          sizeof(Hash1 ), (int (*)(void const   * , void const   * ))(& hash1_cmp_hook___0));
    }
    {
#line 218
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 220
      tmp___5 = htonl(hash1->hash);
#line 220
      hash_ = tmp___5;
#line 222
      tmp___6 = fwrite((void const   */* __restrict  */)(& hash_), sizeof(hash_),
                       (size_t )1U, (FILE */* __restrict  */)dbw->fpindex);
      }
#line 222
      if (tmp___6 != 1UL) {
#line 224
        return (-1);
      }
      {
#line 228
      tmp___7 = htonl(hash1->offset_data + dbw->offset_first_data);
#line 228
      offset_data_ = tmp___7;
#line 231
      tmp___8 = fwrite((void const   */* __restrict  */)(& offset_data_), sizeof(offset_data_),
                       (size_t )1U, (FILE */* __restrict  */)dbw->fpindex);
      }
#line 231
      if (tmp___8 != 1UL) {
#line 233
        return (-1);
      }
#line 236
      hash1 ++;
#line 237
      list_size -= sizeof(Hash1 );
#line 218
      if (! (list_size > 0UL)) {
#line 218
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    next: 
#line 240
    hash0 ++;
#line 241
    hash_cnt --;
#line 202
    if (! (hash_cnt != 0)) {
#line 202
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 244
  return (0);
}
}
#line 247 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_write.c"
static int freestructs___0(PureDBW * const  dbw ) 
{ 
  Hash0 *hash0 ;
  int hash0_cnt ;

  {
#line 249
  hash0 = dbw->hash_table0;
#line 250
  hash0_cnt = (int )(sizeof(dbw->hash_table0) / sizeof(dbw->hash_table0[0]));
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 253
    free((void *)hash0->hash1_list);
#line 254
    hash0->hash1_list = (Hash1 *)((void *)0);
#line 255
    hash0 ++;
#line 256
    hash0_cnt --;
    }
#line 252
    if (! (hash0_cnt > 0)) {
#line 252
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 259
  return (0);
}
}
#line 262 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_write.c"
static int mergefiles___0(PureDBW * const  dbw ) 
{ 
  size_t readnb ;
  char buf___1[4096] ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 267
  rewind(dbw->fpdata);
  }
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 268
    readnb = fread((void */* __restrict  */)(buf___1), (size_t )1U, sizeof(buf___1),
                   (FILE */* __restrict  */)dbw->fpdata);
    }
#line 268
    if (! (readnb > 0UL)) {
#line 268
      goto while_break;
    }
    {
#line 270
    tmp = fwrite((void const   */* __restrict  */)(buf___1), (size_t )1U, readnb,
                 (FILE */* __restrict  */)dbw->fpindex);
    }
#line 270
    if (tmp != readnb) {
#line 271
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 274
  tmp___0 = fclose(dbw->fpdata);
  }
#line 274
  if (tmp___0 != 0) {
#line 275
    return (-1);
  }
  {
#line 277
  dbw->fpdata = (FILE *)((void *)0);
#line 278
  fflush(dbw->fpindex);
#line 280
  tmp___1 = fileno(dbw->fpindex);
#line 280
  fsync(tmp___1);
#line 282
  tmp___2 = fclose(dbw->fpindex);
  }
#line 282
  if (tmp___2 != 0) {
#line 283
    return (-1);
  }
  {
#line 285
  dbw->fpindex = (FILE *)((void *)0);
#line 286
  unlink((char const   *)dbw->file_data);
#line 287
  tmp___4 = rename((char const   *)dbw->file_index, (char const   *)dbw->file_final);
  }
#line 287
  if (tmp___4 < 0) {
    {
#line 289
    unlink((char const   *)dbw->file_final);
#line 290
    tmp___3 = rename((char const   *)dbw->file_index, (char const   *)dbw->file_final);
    }
#line 290
    if (tmp___3 < 0) {
#line 291
      return (-1);
    }
  }
#line 295
  return (0);
}
}
#line 298 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_write.c"
static void freeall___0(PureDBW * const  dbw ) 
{ 


  {
#line 300
  if ((unsigned long )dbw->fpindex != (unsigned long )((void *)0)) {
    {
#line 301
    fclose(dbw->fpindex);
#line 302
    dbw->fpindex = (FILE *)((void *)0);
    }
  }
#line 304
  if ((unsigned long )dbw->fpdata != (unsigned long )((void *)0)) {
    {
#line 305
    fclose(dbw->fpdata);
#line 306
    dbw->fpdata = (FILE *)((void *)0);
    }
  }
  {
#line 308
  free((void *)dbw->file_index);
#line 309
  dbw->file_index = (char *)((void *)0);
#line 310
  free((void *)dbw->file_data);
#line 311
  dbw->file_data = (char *)((void *)0);
#line 312
  free((void *)dbw->file_final);
#line 313
  dbw->file_final = (char *)((void *)0);
  }
#line 314
  return;
}
}
#line 9 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_read.c"
static puredb_u32_t puredb_hash___0(char const   * const  msg , size_t len ) 
{ 
  puredb_u32_t j ;

  {
#line 11
  j = 5381U;
  {
#line 13
  while (1) {
    while_continue: /* CIL Label */ ;
#line 13
    if (! (len != 0UL)) {
#line 13
      goto while_break;
    }
#line 14
    len --;
#line 15
    j += j << 5;
#line 16
    j ^= (unsigned int )((unsigned char )*(msg + len));
  }
  while_break: /* CIL Label */ ;
  }
#line 18
  j &= 4294967295U;
#line 20
  return (j);
}
}
#line 23 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_read.c"
static ssize_t safe_read___1(int const   fd , void * const  buf_ , size_t maxlen ) 
{ 
  unsigned char *buf___1 ;
  ssize_t readnb ;
  int *tmp ;

  {
#line 25
  buf___1 = (unsigned char *)buf_;
  {
#line 28
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 29
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 29
      readnb = read((int )fd, (void *)buf___1, maxlen);
      }
#line 29
      if (readnb < 0L) {
        {
#line 29
        tmp = __errno_location();
        }
#line 29
        if (! (*tmp == 4)) {
#line 29
          goto while_break___0;
        }
      } else {
#line 29
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 31
    if (readnb < 0L) {
#line 32
      return (readnb);
    } else
#line 31
    if (readnb > (ssize_t )maxlen) {
#line 32
      return (readnb);
    }
#line 34
    if (readnb == 0L) {
      ret: 
#line 36
      return (buf___1 - (unsigned char *)buf_);
    }
#line 38
    maxlen -= (size_t )readnb;
#line 39
    buf___1 += readnb;
#line 28
    if (! (maxlen > 0UL)) {
#line 28
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 41
  goto ret;
}
}
#line 44 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_read.c"
static int read_be_long___0(PureDB const   * const  db , puredb_u32_t const   offset ,
                            puredb_u32_t * const  result ) 
{ 
  unsigned char mapoffsetbuf[4] ;
  unsigned char *mapoffset ;
  __off_t tmp ;
  ssize_t tmp___0 ;

  {
#line 52
  if ((unsigned long )db->map != (unsigned long )((void *)0)) {
#line 53
    mapoffset = (unsigned char *)(db->map + offset);
  } else {
    {
#line 57
    tmp = lseek((int )db->fd, (__off_t )offset, 0);
    }
#line 57
    if (tmp == -1L) {
#line 58
      return (-1);
    }
    {
#line 60
    tmp___0 = safe_read___1(db->fd, (void */* const  */)(mapoffsetbuf), sizeof(mapoffsetbuf));
    }
#line 60
    if (tmp___0 != (ssize_t )sizeof(mapoffsetbuf)) {
#line 62
      return (-1);
    }
#line 64
    mapoffset = mapoffsetbuf;
  }
#line 66
  *result = (puredb_u32_t )(((((int )*(mapoffset + 0) << 24) | ((int )*(mapoffset + 1) << 16)) | ((int )*(mapoffset + 2) << 8)) | (int )*(mapoffset + 3));
#line 69
  return (0);
}
}
#line 72 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_read.c"
static int read_memcmp___0(PureDB const   * const  db , puredb_u32_t const   offset ,
                           unsigned char const   *str , puredb_u32_t const   len ) 
{ 
  unsigned char *mapoffsetbuf ;
  int cmp ;
  int tmp ;
  void *tmp___0 ;
  __off_t tmp___1 ;
  ssize_t tmp___2 ;
  int tmp___3 ;

  {
#line 79
  if ((unsigned long )db->map != (unsigned long )((void *)0)) {
    {
#line 80
    tmp = memcmp((void const   *)(db->map + offset), (void const   *)str, (size_t )len);
    }
#line 80
    return (tmp != 0);
  }
  {
#line 83
  tmp___0 = __builtin_alloca((unsigned long )len);
#line 83
  mapoffsetbuf = (unsigned char *)tmp___0;
  }
#line 83
  if ((unsigned long )mapoffsetbuf == (unsigned long )((void *)0)) {
#line 84
    return (-2);
  }
  {
#line 86
  tmp___1 = lseek((int )db->fd, (__off_t )offset, 0);
  }
#line 86
  if (tmp___1 == -1L) {
    err: 
    {
#line 88
    while (1) {
      while_continue: /* CIL Label */ ;
#line 88
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 89
    return (-2);
  }
  {
#line 91
  tmp___2 = safe_read___1(db->fd, (void */* const  */)mapoffsetbuf, (size_t )len);
  }
#line 91
  if (tmp___2 != (ssize_t )len) {
#line 92
    goto err;
  }
  {
#line 94
  tmp___3 = memcmp((void const   *)mapoffsetbuf, (void const   *)str, (size_t )len);
#line 94
  cmp = tmp___3 != 0;
  }
  {
#line 95
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 95
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 97
  return (cmp);
}
}
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/poll.h"
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
#line 7 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/safe_rw.h"
ssize_t safe_write(int const   fd , void const   * const  buf_ , size_t count___1 ,
                   int const   timeout ) ;
#line 10
ssize_t safe_read(int const   fd , void * const  buf_ , size_t count___1 ) ;
#line 12
ssize_t safe_read_partial(int const   fd , void * const  buf_ , size_t const   max_count ) ;
#line 11 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/safe_rw.c"
ssize_t safe_write(int const   fd , void const   * const  buf_ , size_t count___1 ,
                   int const   timeout ) 
{ 
  struct pollfd pfd ;
  char const   *buf___1 ;
  ssize_t written ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
#line 16
  buf___1 = (char const   *)buf_;
#line 19
  pfd.fd = (int )fd;
#line 20
  pfd.events = (short)4;
  {
#line 22
  while (1) {
    while_continue: /* CIL Label */ ;
#line 22
    if (! (count___1 > 0UL)) {
#line 22
      goto while_break;
    }
    {
#line 23
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 23
      written = write((int )fd, (void const   *)buf___1, count___1);
      }
#line 23
      if (! (written <= 0L)) {
#line 23
        goto while_break___0;
      }
      {
#line 24
      tmp___2 = __errno_location();
      }
#line 24
      if (*tmp___2 == 11) {
        {
#line 25
        tmp___0 = poll(& pfd, (nfds_t )1, (int )timeout);
        }
#line 25
        if (tmp___0 == 0) {
          {
#line 26
          tmp = __errno_location();
#line 26
          *tmp = 110;
          }
#line 27
          goto ret;
        }
      } else {
        {
#line 29
        tmp___1 = __errno_location();
        }
#line 29
        if (*tmp___1 != 4) {
#line 30
          goto ret;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 33
    buf___1 += written;
#line 34
    count___1 -= (size_t )written;
  }
  while_break: /* CIL Label */ ;
  }
  ret: 
#line 37
  return (buf___1 - (char const   *)buf_);
}
}
#line 40 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/safe_rw.c"
ssize_t safe_read(int const   fd , void * const  buf_ , size_t count___1 ) 
{ 
  unsigned char *buf___1 ;
  ssize_t readnb ;
  int *tmp ;

  {
#line 43
  buf___1 = (unsigned char *)buf_;
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 47
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 47
      readnb = read((int )fd, (void *)buf___1, count___1);
      }
#line 47
      if (readnb < 0L) {
        {
#line 47
        tmp = __errno_location();
        }
#line 47
        if (! (*tmp == 4)) {
#line 47
          goto while_break___0;
        }
      } else {
#line 47
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 49
    if (readnb < 0L) {
#line 50
      return (readnb);
    }
#line 52
    if (readnb == 0L) {
#line 53
      goto while_break;
    }
#line 55
    count___1 -= (size_t )readnb;
#line 56
    buf___1 += readnb;
#line 46
    if (! (count___1 > 0UL)) {
#line 46
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 59
  return (buf___1 - (unsigned char *)buf_);
}
}
#line 62 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/safe_rw.c"
ssize_t safe_read_partial(int const   fd , void * const  buf_ , size_t const   max_count ) 
{ 
  unsigned char *buf___1 ;
  ssize_t readnb ;
  int *tmp ;

  {
#line 65
  buf___1 = (unsigned char *)buf_;
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 68
    readnb = read((int )fd, (void *)buf___1, (size_t )max_count);
    }
#line 68
    if (readnb < 0L) {
      {
#line 68
      tmp = __errno_location();
      }
#line 68
      if (! (*tmp == 4)) {
#line 68
        goto while_break;
      }
    } else {
#line 68
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  return (readnb);
}
}
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 383 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.h"
unsigned int daemons(in_port_t const   server_port ) ;
#line 12 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/daemons.c"
static unsigned int count(in_port_t server_port , char const   * const  file ) 
{ 
  int f ;
  int r ;
  int c ;
  int b ;
  int e ;
  unsigned int d ;
  char buf___1[2049] ;
  ssize_t tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;

  {
  {
#line 17
  b = 0;
#line 18
  e = 0;
#line 19
  d = 0U;
#line 22
  f = open((char const   *)file, 0);
  }
#line 22
  if (f == -1) {
#line 23
    return (0U);
  }
#line 25
  buf___1[2048] = (char)0;
  {
#line 27
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 28
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 28
      tmp = read(f, (void *)(buf___1 + e), (size_t )(2048U - (unsigned int )e));
#line 28
      r = (int )tmp;
      }
#line 28
      if ((ssize_t )r < 0L) {
        {
#line 28
        tmp___0 = __errno_location();
        }
#line 28
        if (! (*tmp___0 == 4)) {
#line 28
          goto while_break___0;
        }
      } else {
#line 28
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 30
    if ((ssize_t )r <= 0L) {
#line 31
      goto while_break;
    }
#line 33
    e += r;
#line 39
    c = b;
    {
#line 40
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 40
      if (c < e) {
#line 40
        if (! ((int )buf___1[c] != 10)) {
#line 40
          goto while_break___1;
        }
      } else {
#line 40
        goto while_break___1;
      }
#line 41
      c ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 43
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 43
      if (! (c < e)) {
#line 43
        goto while_break___2;
      }
#line 44
      tmp___1 = c;
#line 44
      c ++;
#line 44
      buf___1[tmp___1] = (char)0;
      {
#line 45
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 45
        if (b < c) {
#line 45
          if ((int )buf___1[b] != 58) {
#line 45
            if (! ((int )buf___1[b] != 10)) {
#line 45
              goto while_break___3;
            }
          } else {
#line 45
            goto while_break___3;
          }
        } else {
#line 45
          goto while_break___3;
        }
#line 46
        b ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 48
      if (b < c) {
#line 48
        if ((int )buf___1[b] == 58) {
#line 49
          b ++;
          {
#line 50
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 50
            if (b < e) {
#line 50
              if (! ((int )buf___1[b] != 58)) {
#line 50
                goto while_break___4;
              }
            } else {
#line 50
              goto while_break___4;
            }
#line 51
            b ++;
          }
          while_break___4: /* CIL Label */ ;
          }
          {
#line 53
          b ++;
#line 54
          tmp___3 = strtoul((char const   */* __restrict  */)(buf___1 + b), (char **/* __restrict  */)((void *)0),
                            16);
          }
#line 54
          if (tmp___3 == (unsigned long )server_port) {
            {
#line 56
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 56
              if (b < e) {
#line 56
                if (! ((int )buf___1[b] != 58)) {
#line 56
                  goto while_break___5;
                }
              } else {
#line 56
                goto while_break___5;
              }
#line 57
              b ++;
            }
            while_break___5: /* CIL Label */ ;
            }
#line 59
            if ((int )buf___1[b] == 58) {
#line 60
              b ++;
              {
#line 61
              while (1) {
                while_continue___6: /* CIL Label */ ;
#line 61
                if (b < e) {
#line 61
                  if (! ((int )buf___1[b] != 32)) {
#line 61
                    goto while_break___6;
                  }
                } else {
#line 61
                  goto while_break___6;
                }
#line 62
                b ++;
              }
              while_break___6: /* CIL Label */ ;
              }
#line 64
              if ((int )buf___1[b] == 32) {
                {
#line 65
                b ++;
#line 66
                tmp___2 = strtoul((char const   */* __restrict  */)(buf___1 + b),
                                  (char **/* __restrict  */)((void *)0), 16);
                }
#line 66
                if (tmp___2 == 1UL) {
#line 67
                  d ++;
                }
              }
            }
          }
        }
      }
#line 73
      b = c;
      {
#line 74
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 74
        if (c < e) {
#line 74
          if (! ((int )buf___1[c] != 10)) {
#line 74
            goto while_break___7;
          }
        } else {
#line 74
          goto while_break___7;
        }
#line 75
        c ++;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 78
    if (e > b) {
      {
#line 79
      memmove((void *)(buf___1), (void const   *)(buf___1 + b), (size_t )(e - b));
      }
    }
#line 81
    e -= b;
#line 82
    b = 0;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 84
  close(f);
  }
#line 86
  return (d);
}
}
#line 89 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/daemons.c"
unsigned int daemons(in_port_t const   server_port ) 
{ 
  unsigned int nbcnx ;
  unsigned int tmp ;

  {
  {
#line 93
  nbcnx = count((in_port_t )server_port, (char const   */* const  */)"/proc/net/tcp");
#line 94
  tmp = count((in_port_t )server_port, (char const   */* const  */)"/proc/net/tcp6");
#line 94
  nbcnx += tmp;
  }
#line 96
  return (nbcnx);
}
}
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 603 "/usr/include/unistd.h"
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 879
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                                                  size_t __len ) ;
#line 47 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-mrtginfo.c"
static char buf[1025]  ;
#line 14 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-mrtginfo.c"
static char const   *uptime(void) 
{ 
  int f ;
  ssize_t r ;
  unsigned long u ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 49
  f = open("/proc/uptime", 0);
  }
#line 49
  if (f == -1) {
#line 50
    return ("?");
  }
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 52
    r = read(f, (void *)(buf), sizeof(buf) - 1UL);
    }
#line 52
    if (r < 0L) {
      {
#line 52
      tmp = __errno_location();
      }
#line 52
      if (! (*tmp == 4)) {
#line 52
        goto while_break;
      }
    } else {
#line 52
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  if (r <= 0L) {
    {
#line 54
    close(f);
    }
#line 55
    return ("?");
  }
  {
#line 57
  close(f);
#line 58
  u = strtoul((char const   */* __restrict  */)(buf), (char **/* __restrict  */)((void *)0),
              10);
#line 59
  tmp___0 = snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%lu days, %lu:%02lu:%02lu",
                     u / 86400UL, (u / 3600UL) % 24UL, (u / 60UL) % 60UL, u % 60UL);
  }
#line 59
  if (tmp___0 >= (int )sizeof(buf)) {
    {
#line 63
    _exit(1);
    }
  }
#line 65
  return ((char const   *)(buf));
}
}
#line 71 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-mrtginfo.c"
static char buf___0[1025]  ;
#line 69 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-mrtginfo.c"
static char const   *name(void) 
{ 
  int tmp ;

  {
  {
#line 73
  tmp = gethostname(buf___0, sizeof(buf___0) - 1UL);
  }
#line 73
  if (tmp != 0) {
#line 74
    return ("?");
  }
#line 76
  return ((char const   *)(buf___0));
}
}
#line 114 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ipstack.h"
in_port_t *storage_port(struct sockaddr_storage  const  * const  ss ) ;
#line 115
in_port_t *storage_port6(struct sockaddr_storage  const  * const  ss ) ;
#line 116
struct in_addr *storage_sin_addr(struct sockaddr_storage  const  * const  ss ) ;
#line 117
struct in6_addr *storage_sin_addr6(struct sockaddr_storage  const  * const  ss ) ;
#line 183 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ipstack.c"
in_port_t *storage_port(struct sockaddr_storage  const  * const  ss ) 
{ 
  struct sockaddr_in *si ;

  {
#line 185
  si = (struct sockaddr_in *)ss;
#line 187
  return (& si->sin_port);
}
}
#line 190 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ipstack.c"
in_port_t *storage_port6(struct sockaddr_storage  const  * const  ss ) 
{ 
  struct sockaddr_in6 *si ;

  {
#line 192
  si = (struct sockaddr_in6 *)ss;
#line 194
  return (& si->sin6_port);
}
}
#line 197 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ipstack.c"
struct in_addr *storage_sin_addr(struct sockaddr_storage  const  * const  ss ) 
{ 
  struct sockaddr_in *si ;

  {
#line 199
  si = (struct sockaddr_in *)ss;
#line 201
  return (& si->sin_addr);
}
}
#line 204 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ipstack.c"
struct in6_addr *storage_sin_addr6(struct sockaddr_storage  const  * const  ss ) 
{ 
  struct sockaddr_in6 *si ;

  {
#line 206
  si = (struct sockaddr_in6 *)ss;
#line 208
  return (& si->sin6_addr);
}
}
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 929 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getusershell)(void) ;
#line 930
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) endusershell)(void) ;
#line 931
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) setusershell)(void) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 72 "/usr/include/pwd.h"
extern void setpwent(void) ;
#line 78
extern void endpwent(void) ;
#line 84
extern struct passwd *getpwent(void) ;
#line 86 "/usr/include/shadow.h"
extern struct spwd *getspnam(char const   *__name ) ;
#line 689 "/usr/include/stdio.h"
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) putenv)(char *__string ) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getegid)(void) ;
#line 700
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 710
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) seteuid)(__uid_t __uid ) ;
#line 717
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
#line 727
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setegid)(__gid_t __gid ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 944 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chroot)(char const   *__path ) ;
#line 1016
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ftruncate)(int __fd ,
                                                                                __off_t __length ) ;
#line 205 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 293
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) tzset)(void) ;
#line 297 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchmod)(int __fd ,
                                                                             __mode_t __mode ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 116
extern struct passwd *getpwnam(char const   *__name ) ;
#line 111 "/usr/include/grp.h"
extern struct group *getgrnam(char const   *__name ) ;
#line 180
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgroups)(size_t __n ,
                                                                                __gid_t const   *__groups ) ;
#line 201
extern int initgroups(char const   *__user , __gid_t __group ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 17 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-quotacheck.c"
static uid_t uid  ;
#line 18 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-quotacheck.c"
static gid_t gid  ;
#line 19 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-quotacheck.c"
static char const   *startpath  ;
#line 20 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-quotacheck.c"
static unsigned long long total_size  ;
#line 21 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-quotacheck.c"
static unsigned long long total_files  ;
#line 22 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-quotacheck.c"
static signed char isroot  ;
#line 23 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-quotacheck.c"
static char default_tz_for_putenv___0[13]  = 
#line 23
  {      (char )'T',      (char )'Z',      (char )'=',      (char )'U', 
        (char )'T',      (char )'C',      (char )'+',      (char )'0', 
        (char )'0',      (char )':',      (char )'0',      (char )'0', 
        (char )'\000'};
#line 36 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-quotacheck.c"
Node *nodes  ;
#line 37 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-quotacheck.c"
size_t nodes_size  ;
#line 39 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-quotacheck.c"
static void oom(void) 
{ 


  {
  {
#line 41
  fputs((char const   */* __restrict  */)"Out of memory error!\n", (FILE */* __restrict  */)stderr);
#line 42
  exit(1);
  }
}
}
#line 45 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-quotacheck.c"
static int init_tz(void) 
{ 
  char stbuf[10] ;
  struct tm *tm ;
  time_t now ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 52
  tzset();
#line 55
  time(& now);
#line 56
  tm = localtime((time_t const   *)(& now));
  }
#line 56
  if ((unsigned long )tm == (unsigned long )((void *)0)) {
#line 58
    return (-1);
  } else {
    {
#line 56
    tmp = strftime((char */* __restrict  */)(stbuf), sizeof(stbuf), (char const   */* __restrict  */)"%z",
                   (struct tm  const  */* __restrict  */)tm);
    }
#line 56
    if (tmp != 5UL) {
#line 58
      return (-1);
    }
  }
#line 60
  if ((int )stbuf[0] == 45) {
#line 60
    tmp___0 = '+';
  } else {
#line 60
    tmp___0 = '-';
  }
  {
#line 60
  snprintf((char */* __restrict  */)(default_tz_for_putenv___0), sizeof(default_tz_for_putenv___0),
           (char const   */* __restrict  */)"TZ=UTC%c%c%c:%c%c", tmp___0, (int )stbuf[1],
           (int )stbuf[2], (int )stbuf[3], (int )stbuf[4]);
#line 63
  putenv(default_tz_for_putenv___0);
  }
#line 65
  return (0);
}
}
#line 68 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-quotacheck.c"
static int traversal(char const   * const  s___0 ) 
{ 
  DIR *d ;
  struct dirent *de ;
  struct stat st ;
  size_t slen ;
  Node *nodes_pnt ;
  size_t nodes_cnt ;
  int fd ;
  char *buf___1 ;
  size_t sizeof_buf ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  Node *new_nodes ;
  void *tmp___3 ;
  Node *node ;
  size_t tmp___4 ;
  size_t wanted_sizeof_buf ;
  int tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 74
  nodes_pnt = nodes;
#line 75
  nodes_cnt = nodes_size;
#line 77
  buf___1 = (char *)((void *)0);
#line 78
  sizeof_buf = (size_t )0U;
#line 80
  fd = open((char const   *)s___0, 65536);
  }
#line 80
  if (fd == -1) {
    {
#line 81
    tmp = __errno_location();
    }
#line 81
    if (*tmp != 13) {
#line 82
      return (-1);
    }
    {
#line 84
    tmp___0 = fstat(fd, & st);
    }
#line 84
    if (tmp___0 != 0) {
      {
#line 85
      close(fd);
      }
#line 86
      return (-1);
    } else
#line 84
    if (! ((st.st_mode & 61440U) == 16384U)) {
      {
#line 85
      close(fd);
      }
#line 86
      return (-1);
    } else
#line 84
    if (st.st_uid != uid) {
      {
#line 85
      close(fd);
      }
#line 86
      return (-1);
    }
    {
#line 88
    fchmod(fd, st.st_mode | 320U);
#line 89
    close(fd);
#line 90
    fd = open((char const   *)s___0, 65536);
    }
#line 90
    if (fd == -1) {
#line 91
      return (-1);
    }
  }
  {
#line 94
  tmp___1 = fstat(fd, & st);
  }
#line 94
  if (tmp___1 != 0) {
    {
#line 95
    close(fd);
    }
#line 96
    return (-1);
  } else
#line 94
  if (! ((st.st_mode & 61440U) == 16384U)) {
    {
#line 95
    close(fd);
    }
#line 96
    return (-1);
  }
#line 98
  if ((st.st_mode & 320U) != 320U) {
#line 98
    if (st.st_uid == uid) {
      {
#line 99
      fchmod(fd, st.st_mode | 320U);
      }
    }
  }
  {
#line 101
  close(fd);
  }
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (! (nodes_cnt > 0UL)) {
#line 102
      goto while_break;
    }
#line 103
    if (nodes_pnt->inode == st.st_ino) {
#line 103
      if (nodes_pnt->device == st.st_dev) {
#line 104
        return (-1);
      }
    }
#line 106
    nodes_pnt ++;
#line 107
    nodes_cnt -= sizeof(*nodes_pnt);
  }
  while_break: /* CIL Label */ ;
  }
#line 109
  if ((unsigned long )nodes == (unsigned long )((void *)0)) {
    {
#line 110
    tmp___2 = malloc(sizeof(*nodes));
#line 110
    nodes = (Node *)tmp___2;
    }
#line 110
    if ((unsigned long )nodes == (unsigned long )((void *)0)) {
      {
#line 111
      oom();
      }
    }
  } else {
    {
#line 116
    tmp___3 = realloc((void *)nodes, nodes_size + sizeof(*nodes_pnt));
#line 116
    new_nodes = (Node *)tmp___3;
    }
#line 116
    if ((unsigned long )new_nodes == (unsigned long )((void *)0)) {
      {
#line 118
      oom();
      }
    }
#line 120
    nodes = new_nodes;
  }
  {
#line 123
  node = (Node *)((void *)((unsigned char *)nodes + nodes_size));
#line 126
  node->inode = st.st_ino;
#line 127
  node->device = st.st_dev;
#line 129
  nodes_size += sizeof(*nodes_pnt);
#line 130
  d = opendir((char const   *)s___0);
  }
#line 130
  if ((unsigned long )d == (unsigned long )((void *)0)) {
#line 131
    return (-1);
  }
  {
#line 133
  tmp___4 = strlen((char const   *)s___0);
#line 133
  slen = tmp___4 + 2UL;
  }
  {
#line 134
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 134
    de = readdir(d);
    }
#line 134
    if (! ((unsigned long )de != (unsigned long )((void *)0))) {
#line 134
      goto while_break___0;
    }
#line 137
    if ((int )de->d_name[0] == 46) {
#line 137
      if ((int )de->d_name[1] == 0) {
#line 140
        goto while_continue___0;
      } else {
#line 137
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 137
    if ((int )de->d_name[0] == 46) {
#line 137
      if ((int )de->d_name[1] == 46) {
#line 137
        if ((int )de->d_name[2] == 0) {
#line 140
          goto while_continue___0;
        }
      }
    }
    {
#line 142
    tmp___5 = strcmp((char const   *)(de->d_name), ".ftpquota");
    }
#line 142
    if (tmp___5 == 0) {
#line 143
      goto while_continue___0;
    }
    {
#line 145
    tmp___6 = strlen((char const   *)(de->d_name));
#line 145
    wanted_sizeof_buf = slen + tmp___6;
    }
#line 146
    if (wanted_sizeof_buf > sizeof_buf) {
      {
#line 147
      tmp___7 = realloc((void *)buf___1, wanted_sizeof_buf);
#line 147
      buf___1 = (char *)tmp___7;
      }
#line 147
      if ((unsigned long )buf___1 == (unsigned long )((void *)0)) {
        {
#line 148
        oom();
        }
      }
#line 150
      sizeof_buf = wanted_sizeof_buf;
    }
    {
#line 152
    snprintf((char */* __restrict  */)buf___1, sizeof_buf, (char const   */* __restrict  */)"%s/%s",
             s___0, de->d_name);
#line 153
    tmp___9 = stat((char const   */* __restrict  */)buf___1, (struct stat */* __restrict  */)(& st));
    }
#line 153
    if (tmp___9 == 0) {
#line 154
      if ((st.st_mode & 61440U) == 16384U) {
        {
#line 155
        tmp___8 = traversal((char const   */* const  */)buf___1);
        }
#line 155
        if (tmp___8 == 0) {
#line 156
          total_files ++;
        }
      } else
#line 158
      if ((st.st_mode & 61440U) == 32768U) {
#line 159
        total_size += (unsigned long long )st.st_size;
#line 160
        total_files ++;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 164
  free((void *)buf___1);
#line 165
  closedir(d);
  }
#line 167
  return (0);
}
}
#line 170 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-quotacheck.c"
static void help(void) 
{ 


  {
  {
#line 172
  puts("\nUsage:\n\npure-quotacheck -u <user> -d <directory> [-g <group>]\n\n-d <directory>: start from this directory\n-g <group/gid>: scan the directory under this gid\n-h: help\n-u <user/uid>: scan the directory under this uid\n");
#line 178
  exit(0);
  }
}
}
#line 181 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-quotacheck.c"
static int doinitsupgroups(char const   *user , uid_t const   uid___0 , gid_t const   gid___0 ) 
{ 
  int tmp ;
  struct passwd  const  *lpwd ;
  struct passwd *tmp___0 ;

  {
  {
#line 185
  tmp = setgroups((size_t )1U, & gid___0);
  }
#line 185
  if (tmp != 0) {
#line 186
    return (-1);
  }
#line 192
  if ((unsigned long )user == (unsigned long )((void *)0)) {
    {
#line 193
    tmp___0 = getpwuid((__uid_t )uid___0);
#line 193
    lpwd = (struct passwd  const  *)tmp___0;
    }
#line 195
    if ((unsigned long )lpwd != (unsigned long )((void *)0)) {
#line 195
      if ((unsigned long )lpwd->pw_name != (unsigned long )((void *)0)) {
#line 196
        user = (char const   *)lpwd->pw_name;
      } else {
#line 198
        return (-1);
      }
    } else {
#line 198
      return (-1);
    }
  }
  {
#line 201
  initgroups(user, (__gid_t )gid___0);
  }
#line 211
  return (0);
}
}
#line 214 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-quotacheck.c"
static int changeuidgid(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 216
  tmp = setgid(gid);
  }
#line 216
  if (tmp) {
#line 218
    return (-1);
  } else {
    {
#line 216
    tmp___0 = setegid(gid);
    }
#line 216
    if (tmp___0) {
#line 218
      return (-1);
    } else {
      {
#line 216
      tmp___1 = setuid(uid);
      }
#line 216
      if (tmp___1) {
#line 218
        return (-1);
      } else {
        {
#line 216
        tmp___2 = seteuid(uid);
        }
#line 216
        if (tmp___2) {
#line 218
          return (-1);
        } else {
          {
#line 216
          tmp___3 = chdir("/");
          }
#line 216
          if (tmp___3) {
#line 218
            return (-1);
          }
        }
      }
    }
  }
#line 220
  return (0);
}
}
#line 223 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-quotacheck.c"
static int writequota(char const   * const  quota_file ) 
{ 
  int err ;
  int fd ;
  struct flock lock ;
  ssize_t towrite ;
  struct stat st ;
  char buf___1[84] ;
  char const   *bufpnt ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  ssize_t tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;

  {
  {
#line 225
  err = -1;
#line 231
  bufpnt = (char const   *)(buf___1);
#line 233
  fd = open("/", 65536);
  }
#line 233
  if (fd == -1) {
#line 234
    return (-1);
  }
  {
#line 236
  tmp = fstat(fd, & st);
  }
#line 236
  if (tmp != 0) {
    {
#line 237
    close(fd);
    }
#line 238
    return (-1);
  } else
#line 236
  if (! ((st.st_mode & 61440U) == 16384U)) {
    {
#line 237
    close(fd);
    }
#line 238
    return (-1);
  }
#line 240
  if ((st.st_mode & 448U) != 448U) {
#line 240
    if (st.st_uid == uid) {
      {
#line 241
      fchmod(fd, st.st_mode | 448U);
      }
    }
  }
  {
#line 243
  close(fd);
#line 244
  fd = open((char const   *)quota_file, 131138, (mode_t )384);
  }
#line 244
  if (fd == -1) {
#line 246
    return (-1);
  }
  {
#line 248
  lock.l_whence = (short)0;
#line 249
  lock.l_start = (off_t )0;
#line 250
  lock.l_len = (off_t )0;
#line 251
  lock.l_pid = getpid();
#line 252
  lock.l_type = (short)1;
  }
  {
#line 253
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 253
    tmp___1 = fcntl(fd, 7, & lock);
    }
#line 253
    if (! (tmp___1 < 0)) {
#line 253
      goto while_break;
    }
    {
#line 254
    tmp___0 = __errno_location();
    }
#line 254
    if (*tmp___0 != 4) {
#line 255
      goto byenounlock;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 258
  tmp___2 = snprintf((char */* __restrict  */)(buf___1), sizeof(buf___1), (char const   */* __restrict  */)"%llu %llu\n",
                     total_files, total_size);
  }
#line 258
  if (tmp___2 >= (int )sizeof(buf___1)) {
#line 261
    goto bye;
  } else {
    {
#line 258
    tmp___3 = ftruncate(fd, (off_t )0);
    }
#line 258
    if (tmp___3 != 0) {
#line 261
      goto bye;
    }
  }
  {
#line 263
  tmp___4 = strlen((char const   *)(buf___1));
#line 263
  towrite = (ssize_t )tmp___4;
#line 264
  tmp___5 = safe_write((int const   )fd, (void const   */* const  */)bufpnt, (size_t )towrite,
                       (int const   )-1);
#line 264
  err = - (tmp___5 != towrite);
  }
  bye: 
#line 266
  lock.l_type = (short)2;
  {
#line 267
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 267
    tmp___6 = fcntl(fd, 6, & lock);
    }
#line 267
    if (tmp___6 < 0) {
      {
#line 267
      tmp___7 = __errno_location();
      }
#line 267
      if (! (*tmp___7 == 4)) {
#line 267
        goto while_break___0;
      }
    } else {
#line 267
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  byenounlock: 
  {
#line 269
  close(fd);
  }
#line 271
  return (err);
}
}
#line 12 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/daemons.c"
static unsigned int count___0(in_port_t server_port , char const   * const  file ) 
{ 
  int f ;
  int r ;
  int c ;
  int b ;
  int e ;
  unsigned int d ;
  char buf___1[2049] ;
  ssize_t tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;

  {
  {
#line 17
  b = 0;
#line 18
  e = 0;
#line 19
  d = 0U;
#line 22
  f = open((char const   *)file, 0);
  }
#line 22
  if (f == -1) {
#line 23
    return (0U);
  }
#line 25
  buf___1[2048] = (char)0;
  {
#line 27
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 28
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 28
      tmp = read(f, (void *)(buf___1 + e), (size_t )(2048U - (unsigned int )e));
#line 28
      r = (int )tmp;
      }
#line 28
      if ((ssize_t )r < 0L) {
        {
#line 28
        tmp___0 = __errno_location();
        }
#line 28
        if (! (*tmp___0 == 4)) {
#line 28
          goto while_break___0;
        }
      } else {
#line 28
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 30
    if ((ssize_t )r <= 0L) {
#line 31
      goto while_break;
    }
#line 33
    e += r;
#line 39
    c = b;
    {
#line 40
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 40
      if (c < e) {
#line 40
        if (! ((int )buf___1[c] != 10)) {
#line 40
          goto while_break___1;
        }
      } else {
#line 40
        goto while_break___1;
      }
#line 41
      c ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 43
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 43
      if (! (c < e)) {
#line 43
        goto while_break___2;
      }
#line 44
      tmp___1 = c;
#line 44
      c ++;
#line 44
      buf___1[tmp___1] = (char)0;
      {
#line 45
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 45
        if (b < c) {
#line 45
          if ((int )buf___1[b] != 58) {
#line 45
            if (! ((int )buf___1[b] != 10)) {
#line 45
              goto while_break___3;
            }
          } else {
#line 45
            goto while_break___3;
          }
        } else {
#line 45
          goto while_break___3;
        }
#line 46
        b ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 48
      if (b < c) {
#line 48
        if ((int )buf___1[b] == 58) {
#line 49
          b ++;
          {
#line 50
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 50
            if (b < e) {
#line 50
              if (! ((int )buf___1[b] != 58)) {
#line 50
                goto while_break___4;
              }
            } else {
#line 50
              goto while_break___4;
            }
#line 51
            b ++;
          }
          while_break___4: /* CIL Label */ ;
          }
          {
#line 53
          b ++;
#line 54
          tmp___3 = strtoul((char const   */* __restrict  */)(buf___1 + b), (char **/* __restrict  */)((void *)0),
                            16);
          }
#line 54
          if (tmp___3 == (unsigned long )server_port) {
            {
#line 56
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 56
              if (b < e) {
#line 56
                if (! ((int )buf___1[b] != 58)) {
#line 56
                  goto while_break___5;
                }
              } else {
#line 56
                goto while_break___5;
              }
#line 57
              b ++;
            }
            while_break___5: /* CIL Label */ ;
            }
#line 59
            if ((int )buf___1[b] == 58) {
#line 60
              b ++;
              {
#line 61
              while (1) {
                while_continue___6: /* CIL Label */ ;
#line 61
                if (b < e) {
#line 61
                  if (! ((int )buf___1[b] != 32)) {
#line 61
                    goto while_break___6;
                  }
                } else {
#line 61
                  goto while_break___6;
                }
#line 62
                b ++;
              }
              while_break___6: /* CIL Label */ ;
              }
#line 64
              if ((int )buf___1[b] == 32) {
                {
#line 65
                b ++;
#line 66
                tmp___2 = strtoul((char const   */* __restrict  */)(buf___1 + b),
                                  (char **/* __restrict  */)((void *)0), 16);
                }
#line 66
                if (tmp___2 == 1UL) {
#line 67
                  d ++;
                }
              }
            }
          }
        }
      }
#line 73
      b = c;
      {
#line 74
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 74
        if (c < e) {
#line 74
          if (! ((int )buf___1[c] != 10)) {
#line 74
            goto while_break___7;
          }
        } else {
#line 74
          goto while_break___7;
        }
#line 75
        c ++;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 78
    if (e > b) {
      {
#line 79
      memmove((void *)(buf___1), (void const   *)(buf___1 + b), (size_t )(e - b));
      }
    }
#line 81
    e -= b;
#line 82
    b = 0;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 84
  close(f);
  }
#line 86
  return (d);
}
}
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 263 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 398 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.h"
void simplify(char *subdir ) ;
#line 91 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/bsd-glob.h"
int glob(char const   *pattern , int flags , int (*errfunc)(char const   * , int  ) ,
         glob_t *pglob ) ;
#line 93
int sglob(char *pattern , int flags , int (*errfunc)(char const   * , int  ) , glob_t *pglob ,
          unsigned long maxfiles , int maxdepth ) ;
#line 95
void globfree(glob_t *pglob ) ;
#line 123 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/bsd-glob.c"
static int compare(void const   *p , void const   *q ) ;
#line 124
static int compare_gps(void const   *_p , void const   *_q ) ;
#line 125
static int g_Ctoc(Char const   *str , char *buf___1 , unsigned int len ) ;
#line 126
static int g_lstat(Char *fn , struct stat *sb , glob_t *pglob ) ;
#line 127
static DIR *g_opendir(Char *str , glob_t *pglob ) ;
#line 128
static Char *g_strchr(Char const   *str , int ch ) ;
#line 129
static int g_stat(Char *fn , struct stat *sb , glob_t *pglob ) ;
#line 130
static int glob0(Char const   *pattern , glob_t *pglob , struct glob_lim *limitp ) ;
#line 131
static int glob1(Char *pattern , Char *pattern_last , glob_t *pglob , struct glob_lim *limitp ,
                 int recursion ) ;
#line 132
static int glob2(Char *pathbuf , Char *pathbuf_last , Char *pathend , Char *pathend_last ,
                 Char *pattern , Char *pattern_last , glob_t *pglob , struct glob_lim *limitp ,
                 int recursion ) ;
#line 134
static int glob3(Char *pathbuf , Char *pathbuf_last , Char *pathend , Char *pathend_last ,
                 Char *pattern , Char *restpattern , Char *restpattern_last , glob_t *pglob ,
                 struct glob_lim *limitp , int recursion ) ;
#line 136
static int globextend(Char const   *path , glob_t *pglob , struct glob_lim *limitp ,
                      struct stat *sb ) ;
#line 138
static int globexp1(Char const   *pattern , glob_t *pglob , struct glob_lim *limitp ,
                    int recursion ) ;
#line 139
static int globexp2(Char const   *ptr , Char const   *pattern , glob_t *pglob , struct glob_lim *limitp ,
                    int recursion ) ;
#line 141
static int match(Char *name___0 , Char *pat , Char *patend , int recur ) ;
#line 143 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/bsd-glob.c"
static int glob_(char const   *pattern , int flags , int (*errfunc)(char const   * ,
                                                                    int  ) , glob_t *pglob ,
                 unsigned long maxfiles , int maxdepth ) 
{ 
  unsigned char const   *patnext ;
  int c ;
  Char *bufnext ;
  Char *bufend ;
  Char patbuf[4096] ;
  struct glob_lim limit ;
  size_t tmp ;
  Char *tmp___0 ;
  unsigned char const   *tmp___1 ;
  unsigned char const   *tmp___2 ;
  Char *tmp___3 ;
  Char *tmp___4 ;
  unsigned char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 150
  limit.glim_malloc = (size_t )0;
#line 150
  limit.glim_stat = (size_t )0;
#line 150
  limit.glim_readdir = (size_t )0;
#line 152
  tmp = strlen(pattern);
  }
#line 152
  if (tmp >= 4096UL) {
#line 153
    return (-3);
  }
#line 155
  pglob->gl_maxdepth = maxdepth;
#line 156
  pglob->gl_maxfiles = maxfiles;
#line 157
  patnext = (unsigned char const   *)((unsigned char *)pattern);
#line 158
  if (! (flags & 1)) {
#line 159
    pglob->gl_pathc = 0;
#line 160
    pglob->gl_pathv = (char **)((void *)0);
#line 161
    pglob->gl_statv = (struct stat **)((void *)0);
#line 162
    if (! (flags & 2)) {
#line 163
      pglob->gl_offs = 0;
    }
  }
#line 166
  pglob->gl_flags = flags & -257;
#line 167
  pglob->gl_errfunc = errfunc;
#line 168
  pglob->gl_matchc = 0;
#line 170
  if (pglob->gl_offs < 0) {
#line 173
    return (-1);
  } else
#line 170
  if (pglob->gl_pathc < 0) {
#line 173
    return (-1);
  } else
#line 170
  if (pglob->gl_offs >= 2147483647) {
#line 173
    return (-1);
  } else
#line 170
  if (pglob->gl_pathc >= 2147483647) {
#line 173
    return (-1);
  } else
#line 170
  if (pglob->gl_pathc >= (2147483647 - pglob->gl_offs) - 1) {
#line 173
    return (-1);
  }
#line 175
  bufnext = patbuf;
#line 176
  bufend = (bufnext + 4096) - 1;
#line 177
  if (flags & 4096) {
    {
#line 178
    while (1) {
      while_continue: /* CIL Label */ ;
#line 178
      if ((unsigned long )bufnext < (unsigned long )bufend) {
#line 178
        tmp___1 = patnext;
#line 178
        patnext ++;
#line 178
        c = (int )*tmp___1;
#line 178
        if (! (c != 0)) {
#line 178
          goto while_break;
        }
      } else {
#line 178
        goto while_break;
      }
#line 179
      tmp___0 = bufnext;
#line 179
      bufnext ++;
#line 179
      *tmp___0 = (Char )c;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 183
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 183
      if ((unsigned long )bufnext < (unsigned long )bufend) {
#line 183
        tmp___5 = patnext;
#line 183
        patnext ++;
#line 183
        c = (int )*tmp___5;
#line 183
        if (! (c != 0)) {
#line 183
          goto while_break___0;
        }
      } else {
#line 183
        goto while_break___0;
      }
#line 184
      if (c == 92) {
#line 185
        tmp___2 = patnext;
#line 185
        patnext ++;
#line 185
        c = (int )*tmp___2;
#line 185
        if (c == 0) {
#line 186
          c = '\\';
#line 187
          patnext --;
        }
#line 189
        tmp___3 = bufnext;
#line 189
        bufnext ++;
#line 189
        *tmp___3 = (Char )(c | 16384);
      } else {
#line 191
        tmp___4 = bufnext;
#line 191
        bufnext ++;
#line 191
        *tmp___4 = (Char )c;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 195
  *bufnext = (Char )'\000';
#line 197
  if (flags & 128) {
    {
#line 198
    tmp___6 = globexp1((Char const   *)(patbuf), pglob, & limit, 0);
    }
#line 198
    return (tmp___6);
  } else {
    {
#line 200
    tmp___7 = glob0((Char const   *)(patbuf), pglob, & limit);
    }
#line 200
    return (tmp___7);
  }
}
}
#line 204 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/bsd-glob.c"
int glob(char const   *pattern , int flags , int (*errfunc)(char const   * , int  ) ,
         glob_t *pglob ) 
{ 
  int tmp ;

  {
  {
#line 208
  tmp = glob_(pattern, flags, errfunc, pglob, 0xffffffffffffffffUL, 0);
  }
#line 208
  return (tmp);
}
}
#line 211 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/bsd-glob.c"
int sglob(char *pattern , int flags , int (*errfunc)(char const   * , int  ) , glob_t *pglob ,
          unsigned long maxfiles , int maxdepth ) 
{ 
  int tmp ;

  {
  {
#line 215
  simplify(pattern);
#line 216
  tmp = glob_((char const   *)pattern, flags, errfunc, pglob, maxfiles, maxdepth);
  }
#line 216
  return (tmp);
}
}
#line 224 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/bsd-glob.c"
static int globexp1(Char const   *pattern , glob_t *pglob , struct glob_lim *limitp ,
                    int recursion ) 
{ 
  Char const   *ptr ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  Char *tmp___2 ;
  int tmp___3 ;

  {
#line 228
  ptr = pattern;
#line 230
  if (pglob->gl_maxdepth > 0) {
#line 230
    if (recursion > pglob->gl_maxdepth) {
      {
#line 231
      tmp = __errno_location();
#line 231
      *tmp = 0;
      }
#line 232
      return (0);
    }
  }
#line 235
  if ((int const   )*(pattern + 0) == 123) {
#line 235
    if ((int const   )*(pattern + 1) == 125) {
#line 235
      if ((int const   )*(pattern + 2) == 0) {
        {
#line 236
        tmp___0 = glob0(pattern, pglob, limitp);
        }
#line 236
        return (tmp___0);
      }
    }
  }
  {
#line 238
  tmp___2 = g_strchr(ptr, '{');
#line 238
  ptr = (Char const   *)tmp___2;
  }
#line 238
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
    {
#line 239
    tmp___1 = globexp2(ptr, pattern, pglob, limitp, recursion + 1);
    }
#line 239
    return (tmp___1);
  }
  {
#line 241
  tmp___3 = glob0(pattern, pglob, limitp);
  }
#line 241
  return (tmp___3);
}
}
#line 249 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/bsd-glob.c"
static int globexp2(Char const   *ptr , Char const   *pattern , glob_t *pglob , struct glob_lim *limitp ,
                    int recursion ) 
{ 
  int i ;
  int rv ;
  Char *lm ;
  Char *ls ;
  Char const   *pe ;
  Char const   *pm ;
  Char const   *pl ;
  Char patbuf[4096] ;
  Char *tmp ;
  Char const   *tmp___0 ;
  Char const   *tmp___1 ;
  int tmp___2 ;
  Char const   *tmp___3 ;
  Char *tmp___4 ;
  Char const   *tmp___5 ;
  Char *tmp___6 ;
  Char tmp___7 ;
  Char const   *tmp___8 ;

  {
#line 259
  lm = patbuf;
#line 259
  pm = pattern;
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
#line 259
    if (! ((unsigned long )pm != (unsigned long )ptr)) {
#line 259
      goto while_break;
    }
#line 259
    tmp = lm;
#line 259
    lm ++;
#line 259
    tmp___0 = pm;
#line 259
    pm ++;
#line 259
    *tmp = (Char )*tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 261
  *lm = (Char )'\000';
#line 262
  ls = lm;
#line 265
  i = 0;
#line 265
  ptr ++;
#line 265
  pe = ptr;
  {
#line 265
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 265
    if (! *pe) {
#line 265
      goto while_break___0;
    }
#line 266
    if ((int const   )*pe == 91) {
#line 268
      tmp___1 = pe;
#line 268
      pe ++;
#line 268
      pm = tmp___1;
      {
#line 268
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 268
        if ((int const   )*pe != 93) {
#line 268
          if (! ((int const   )*pe != 0)) {
#line 268
            goto while_break___1;
          }
        } else {
#line 268
          goto while_break___1;
        }
#line 268
        pe ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 270
      if ((int const   )*pe == 0) {
#line 275
        pe = pm;
      }
    } else
#line 277
    if ((int const   )*pe == 123) {
#line 278
      i ++;
    } else
#line 279
    if ((int const   )*pe == 125) {
#line 280
      if (i == 0) {
#line 281
        goto while_break___0;
      }
#line 283
      i --;
    }
#line 265
    pe ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 288
  if (i != 0) {
    {
#line 289
    tmp___2 = glob0((Char const   *)(patbuf), pglob, limitp);
    }
#line 289
    return (tmp___2);
  } else
#line 288
  if ((int const   )*pe == 0) {
    {
#line 289
    tmp___2 = glob0((Char const   *)(patbuf), pglob, limitp);
    }
#line 289
    return (tmp___2);
  }
#line 291
  i = 0;
#line 291
  pm = ptr;
#line 291
  pl = pm;
  {
#line 291
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 291
    if (! ((unsigned long )pm <= (unsigned long )pe)) {
#line 291
      goto while_break___2;
    }
    {
#line 293
    if ((int const   )*pm == 91) {
#line 293
      goto case_91;
    }
#line 306
    if ((int const   )*pm == 123) {
#line 306
      goto case_123;
    }
#line 310
    if ((int const   )*pm == 125) {
#line 310
      goto case_125;
    }
#line 316
    if ((int const   )*pm == 44) {
#line 316
      goto case_44;
    }
#line 341
    goto switch_default;
    case_91: /* CIL Label */ 
#line 295
    tmp___3 = pm;
#line 295
    pm ++;
#line 295
    pl = tmp___3;
    {
#line 295
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 295
      if ((int const   )*pm != 93) {
#line 295
        if (! ((int const   )*pm != 0)) {
#line 295
          goto while_break___3;
        }
      } else {
#line 295
        goto while_break___3;
      }
#line 295
      pm ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 297
    if ((int const   )*pm == 0) {
#line 302
      pm = pl;
    }
#line 304
    goto switch_break;
    case_123: /* CIL Label */ 
#line 307
    i ++;
#line 308
    goto switch_break;
    case_125: /* CIL Label */ 
#line 311
    if (i) {
#line 312
      i --;
#line 313
      goto switch_break;
    }
    case_44: /* CIL Label */ 
#line 317
    if (i) {
#line 317
      if ((int const   )*pm == 44) {
#line 318
        goto switch_break;
      } else {
#line 317
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 321
      lm = ls;
      {
#line 321
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 321
        if (! ((unsigned long )pl < (unsigned long )pm)) {
#line 321
          goto while_break___4;
        }
#line 321
        tmp___4 = lm;
#line 321
        lm ++;
#line 321
        tmp___5 = pl;
#line 321
        pl ++;
#line 321
        *tmp___4 = (Char )*tmp___5;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 328
      pl = pe + 1;
      {
#line 328
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 328
        tmp___6 = lm;
#line 328
        lm ++;
#line 328
        tmp___8 = pl;
#line 328
        pl ++;
#line 328
        tmp___7 = (Char )*tmp___8;
#line 328
        *tmp___6 = tmp___7;
#line 328
        if (! ((int )tmp___7 != 0)) {
#line 328
          goto while_break___5;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 332
      rv = globexp1((Char const   *)(patbuf), pglob, limitp, recursion + 1);
      }
#line 333
      if (rv) {
#line 333
        if (rv != -3) {
#line 334
          return (rv);
        }
      }
#line 337
      pl = pm + 1;
    }
#line 339
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 342
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 291
    pm ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 345
  return (0);
}
}
#line 355 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/bsd-glob.c"
static int glob0(Char const   *pattern , glob_t *pglob , struct glob_lim *limitp ) 
{ 
  Char const   *qpatnext ;
  int c ;
  int err ;
  int oldpathc ;
  Char *bufnext ;
  Char patbuf[4096] ;
  Char *tmp ;
  Char *tmp___0 ;
  Char *tmp___1 ;
  Char *tmp___2 ;
  Char const   *tmp___3 ;
  Char *tmp___4 ;
  Char *tmp___5 ;
  Char *tmp___6 ;
  Char const   *tmp___7 ;
  Char *tmp___8 ;
  Char *tmp___9 ;
  Char *tmp___10 ;
  Char *tmp___11 ;
  Char const   *tmp___12 ;
  int tmp___13 ;
  struct glob_path_stat *path_stat ;
  int i ;
  int n ;
  int o ;
  void *tmp___14 ;

  {
#line 362
  qpatnext = pattern;
#line 363
  oldpathc = pglob->gl_pathc;
#line 364
  bufnext = patbuf;
  {
#line 367
  while (1) {
    while_continue: /* CIL Label */ ;
#line 367
    tmp___12 = qpatnext;
#line 367
    qpatnext ++;
#line 367
    c = (int )*tmp___12;
#line 367
    if (! (c != 0)) {
#line 367
      goto while_break;
    }
    {
#line 369
    if (c == 91) {
#line 369
      goto case_91;
    }
#line 399
    if (c == 63) {
#line 399
      goto case_63;
    }
#line 403
    if (c == 42) {
#line 403
      goto case_42;
    }
#line 412
    goto switch_default;
    case_91: /* CIL Label */ 
#line 370
    c = (int )*qpatnext;
#line 371
    if (c == 33) {
#line 372
      qpatnext ++;
    }
#line 374
    if ((int const   )*qpatnext == 0) {
#line 374
      goto _L;
    } else {
      {
#line 374
      tmp___0 = g_strchr(qpatnext + 1, ']');
      }
#line 374
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
        _L: /* CIL Label */ 
#line 376
        tmp = bufnext;
#line 376
        bufnext ++;
#line 376
        *tmp = (Char )'[';
#line 377
        if (c == 33) {
#line 378
          qpatnext --;
        }
#line 380
        goto switch_break;
      }
    }
#line 382
    tmp___1 = bufnext;
#line 382
    bufnext ++;
#line 382
    *tmp___1 = (Char )32859;
#line 383
    if (c == 33) {
#line 384
      tmp___2 = bufnext;
#line 384
      bufnext ++;
#line 384
      *tmp___2 = (Char )32801;
    }
#line 386
    tmp___3 = qpatnext;
#line 386
    qpatnext ++;
#line 386
    c = (int )*tmp___3;
    {
#line 387
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 388
      tmp___4 = bufnext;
#line 388
      bufnext ++;
#line 388
      *tmp___4 = (Char )(c & 255);
#line 389
      if ((int const   )*qpatnext == 45) {
#line 389
        c = (int )*(qpatnext + 1);
#line 389
        if (c != 93) {
#line 391
          tmp___5 = bufnext;
#line 391
          bufnext ++;
#line 391
          *tmp___5 = (Char )32813;
#line 392
          tmp___6 = bufnext;
#line 392
          bufnext ++;
#line 392
          *tmp___6 = (Char )(c & 255);
#line 393
          qpatnext += 2;
        }
      }
#line 387
      tmp___7 = qpatnext;
#line 387
      qpatnext ++;
#line 387
      c = (int )*tmp___7;
#line 387
      if (! (c != 93)) {
#line 387
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 396
    pglob->gl_flags |= 256;
#line 397
    tmp___8 = bufnext;
#line 397
    bufnext ++;
#line 397
    *tmp___8 = (Char )32861;
#line 398
    goto switch_break;
    case_63: /* CIL Label */ 
#line 400
    pglob->gl_flags |= 256;
#line 401
    tmp___9 = bufnext;
#line 401
    bufnext ++;
#line 401
    *tmp___9 = (Char )32831;
#line 402
    goto switch_break;
    case_42: /* CIL Label */ 
#line 404
    pglob->gl_flags |= 256;
#line 408
    if ((unsigned long )bufnext == (unsigned long )(patbuf)) {
#line 409
      tmp___10 = bufnext;
#line 409
      bufnext ++;
#line 409
      *tmp___10 = (Char )32810;
    } else
#line 408
    if ((int )*(bufnext + -1) != 32810) {
#line 409
      tmp___10 = bufnext;
#line 409
      bufnext ++;
#line 409
      *tmp___10 = (Char )32810;
    }
#line 411
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 413
    tmp___11 = bufnext;
#line 413
    bufnext ++;
#line 413
    *tmp___11 = (Char )(c & 255);
#line 414
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 417
  *bufnext = (Char )'\000';
#line 419
  err = glob1(patbuf, (patbuf + 4096) - 1, pglob, limitp, 1);
  }
#line 419
  if (err != 0) {
#line 420
    return (err);
  }
#line 429
  if (pglob->gl_pathc == oldpathc) {
#line 430
    if (pglob->gl_flags & 16) {
      {
#line 433
      tmp___13 = globextend(pattern, pglob, limitp, (struct stat *)((void *)0));
      }
#line 433
      return (tmp___13);
    } else
#line 430
    if (pglob->gl_flags & 512) {
#line 430
      if (! (pglob->gl_flags & 256)) {
        {
#line 433
        tmp___13 = globextend(pattern, pglob, limitp, (struct stat *)((void *)0));
        }
#line 433
        return (tmp___13);
      } else {
#line 435
        return (-3);
      }
    } else {
#line 435
      return (-3);
    }
  }
#line 438
  if (! (pglob->gl_flags & 32)) {
#line 439
    if (pglob->gl_flags & 16384) {
      {
#line 443
      n = pglob->gl_pathc - oldpathc;
#line 444
      o = pglob->gl_offs + oldpathc;
#line 446
      tmp___14 = calloc((size_t )n, sizeof(*path_stat));
#line 446
      path_stat = (struct glob_path_stat *)tmp___14;
      }
#line 446
      if ((unsigned long )path_stat == (unsigned long )((void *)0)) {
#line 447
        return (-1);
      }
#line 449
      i = 0;
      {
#line 449
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 449
        if (! (i < n)) {
#line 449
          goto while_break___1;
        }
#line 450
        (path_stat + i)->gps_path = *(pglob->gl_pathv + (o + i));
#line 451
        (path_stat + i)->gps_stat = *(pglob->gl_statv + (o + i));
#line 449
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 453
      qsort((void *)path_stat, (size_t )n, sizeof(*path_stat), & compare_gps);
#line 454
      i = 0;
      }
      {
#line 454
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 454
        if (! (i < n)) {
#line 454
          goto while_break___2;
        }
#line 455
        *(pglob->gl_pathv + (o + i)) = (path_stat + i)->gps_path;
#line 456
        *(pglob->gl_statv + (o + i)) = (path_stat + i)->gps_stat;
#line 454
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 458
      free((void *)path_stat);
      }
    } else {
      {
#line 460
      qsort((void *)((pglob->gl_pathv + pglob->gl_offs) + oldpathc), (size_t )(pglob->gl_pathc - oldpathc),
            sizeof(char *), & compare);
      }
    }
  }
#line 465
  return (0);
}
}
#line 468 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/bsd-glob.c"
static int compare(void const   *p , void const   *q ) 
{ 
  int tmp ;

  {
  {
#line 471
  tmp = strcmp((char const   *)*((char **)p), (char const   *)*((char **)q));
  }
#line 471
  return (tmp);
}
}
#line 474 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/bsd-glob.c"
static int compare_gps(void const   *_p , void const   *_q ) 
{ 
  struct glob_path_stat  const  *p ;
  struct glob_path_stat  const  *q ;
  int tmp ;

  {
  {
#line 477
  p = (struct glob_path_stat  const  *)_p;
#line 478
  q = (struct glob_path_stat  const  *)_q;
#line 480
  tmp = strcmp((char const   *)p->gps_path, (char const   *)q->gps_path);
  }
#line 480
  return (tmp);
}
}
#line 483 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/bsd-glob.c"
static int glob1(Char *pattern , Char *pattern_last , glob_t *pglob , struct glob_lim *limitp ,
                 int recursion ) 
{ 
  Char pathbuf[4096] ;
  int tmp ;

  {
#line 490
  if ((int )*pattern == 0) {
#line 491
    return (0);
  }
  {
#line 493
  tmp = glob2(pathbuf, (pathbuf + 4096) - 1, pathbuf, (pathbuf + 4096) - 1, pattern,
              pattern_last, pglob, limitp, recursion);
  }
#line 493
  return (tmp);
}
}
#line 503 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/bsd-glob.c"
static int glob2(Char *pathbuf , Char *pathbuf_last , Char *pathend , Char *pathend_last ,
                 Char *pattern , Char *pattern_last , glob_t *pglob , struct glob_lim *limitp ,
                 int recursion ) 
{ 
  struct stat sb ;
  Char *p ;
  Char *q ;
  int anymeta ;
  int *tmp ;
  Char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  Char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  Char *tmp___6 ;
  Char *tmp___7 ;
  Char *tmp___8 ;
  Char *tmp___9 ;
  int tmp___10 ;

  {
#line 516
  anymeta = 0;
  {
#line 516
  while (1) {
    while_continue: /* CIL Label */ ;
#line 517
    if ((int )*pattern == 0) {
#line 518
      *pathend = (Char )'\000';
#line 519
      tmp___1 = limitp->glim_stat;
#line 519
      (limitp->glim_stat) ++;
#line 519
      if (tmp___1 >= pglob->gl_maxfiles) {
        {
#line 520
        tmp = __errno_location();
#line 520
        *tmp = 0;
#line 521
        tmp___0 = pathend;
#line 521
        pathend ++;
#line 521
        *tmp___0 = (Char )'/';
#line 522
        *pathend = (Char )'\000';
        }
#line 523
        return (-1);
      }
      {
#line 525
      tmp___2 = g_lstat(pathbuf, & sb, pglob);
      }
#line 525
      if (tmp___2) {
#line 526
        return (0);
      }
#line 528
      if (pglob->gl_flags & 8) {
#line 528
        if ((int )*(pathend + -1) != 47) {
#line 528
          if ((sb.st_mode & 61440U) == 16384U) {
#line 528
            goto _L;
          } else
#line 528
          if ((sb.st_mode & 61440U) == 40960U) {
            {
#line 528
            tmp___4 = g_stat(pathbuf, & sb, pglob);
            }
#line 528
            if (tmp___4 == 0) {
#line 528
              if ((sb.st_mode & 61440U) == 16384U) {
                _L: /* CIL Label */ 
#line 534
                if ((unsigned long )(pathend + 1) > (unsigned long )pathend_last) {
#line 535
                  return (1);
                }
#line 537
                tmp___3 = pathend;
#line 537
                pathend ++;
#line 537
                *tmp___3 = (Char )'/';
#line 538
                *pathend = (Char )'\000';
              }
            }
          }
        }
      }
      {
#line 540
      (pglob->gl_matchc) ++;
#line 541
      tmp___5 = globextend((Char const   *)pathbuf, pglob, limitp, & sb);
      }
#line 541
      return (tmp___5);
    }
#line 545
    q = pathend;
#line 546
    p = pattern;
    {
#line 547
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 547
      if ((int )*p != 0) {
#line 547
        if (! ((int )*p != 47)) {
#line 547
          goto while_break___0;
        }
      } else {
#line 547
        goto while_break___0;
      }
#line 548
      if (((int )*p & 32768) != 0) {
#line 549
        anymeta = 1;
      }
#line 551
      if ((unsigned long )(q + 1) > (unsigned long )pathend_last) {
#line 552
        return (1);
      }
#line 554
      tmp___6 = q;
#line 554
      q ++;
#line 554
      tmp___7 = p;
#line 554
      p ++;
#line 554
      *tmp___6 = *tmp___7;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 557
    if (! anymeta) {
#line 558
      pathend = q;
#line 559
      pattern = p;
      {
#line 560
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 560
        if (! ((int )*pattern == 47)) {
#line 560
          goto while_break___1;
        }
#line 561
        if ((unsigned long )(pathend + 1) > (unsigned long )pathend_last) {
#line 562
          return (1);
        }
#line 564
        tmp___8 = pathend;
#line 564
        pathend ++;
#line 564
        tmp___9 = pattern;
#line 564
        pattern ++;
#line 564
        *tmp___8 = *tmp___9;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      {
#line 568
      tmp___10 = glob3(pathbuf, pathbuf_last, pathend, pathend_last, pattern, p, pattern_last,
                       pglob, limitp, recursion + 1);
      }
#line 568
      return (tmp___10);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 576 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/bsd-glob.c"
static int glob3(Char *pathbuf , Char *pathbuf_last , Char *pathend , Char *pathend_last ,
                 Char *pattern , Char *restpattern , Char *restpattern_last , glob_t *pglob ,
                 struct glob_lim *limitp , int recursion ) 
{ 
  struct dirent *dp ;
  DIR *dirp ;
  int err ;
  char buf___1[4096] ;
  struct dirent *(*readdirfunc)(void * ) ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  unsigned char *sc ;
  Char *dc ;
  int *tmp___3 ;
  Char *tmp___4 ;
  size_t tmp___5 ;
  Char *tmp___6 ;
  Char tmp___7 ;
  unsigned char *tmp___8 ;
  int tmp___9 ;

  {
#line 594
  if ((unsigned long )pathend > (unsigned long )pathend_last) {
#line 595
    return (1);
  }
  {
#line 597
  *pathend = (Char )'\000';
#line 598
  tmp = __errno_location();
#line 598
  *tmp = 0;
  }
#line 600
  if (recursion >= pglob->gl_maxdepth) {
#line 601
    return (-1);
  }
  {
#line 603
  dirp = g_opendir(pathbuf, pglob);
  }
#line 603
  if ((unsigned long )dirp == (unsigned long )((void *)0)) {
#line 605
    if (pglob->gl_errfunc) {
      {
#line 606
      tmp___0 = g_Ctoc((Char const   *)pathbuf, buf___1, (unsigned int )sizeof(buf___1));
      }
#line 606
      if (tmp___0) {
#line 607
        return (-2);
      }
      {
#line 609
      tmp___1 = __errno_location();
#line 609
      tmp___2 = (*(pglob->gl_errfunc))((char const   *)(buf___1), *tmp___1);
      }
#line 609
      if (tmp___2) {
#line 611
        return (-2);
      } else
#line 609
      if (pglob->gl_flags & 4) {
#line 611
        return (-2);
      }
    }
#line 614
    return (0);
  }
#line 617
  err = 0;
#line 620
  if (pglob->gl_flags & 64) {
#line 621
    readdirfunc = pglob->gl_readdir;
  } else {
#line 623
    readdirfunc = (struct dirent *(*)(void * ))(& readdir);
  }
  {
#line 625
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 625
    dp = (*readdirfunc)((void *)dirp);
    }
#line 625
    if (! dp) {
#line 625
      goto while_break;
    }
#line 629
    tmp___5 = limitp->glim_readdir;
#line 629
    (limitp->glim_readdir) ++;
#line 629
    if (tmp___5 >= pglob->gl_maxfiles) {
      {
#line 630
      tmp___3 = __errno_location();
#line 630
      *tmp___3 = 0;
#line 631
      tmp___4 = pathend;
#line 631
      pathend ++;
#line 631
      *tmp___4 = (Char )'/';
#line 632
      *pathend = (Char )'\000';
#line 633
      err = -1;
      }
#line 634
      goto while_break;
    }
#line 638
    if ((int )dp->d_name[0] == 46) {
#line 638
      if ((int )*pattern != 46) {
#line 639
        goto while_continue;
      }
    }
#line 641
    dc = pathend;
#line 642
    sc = (unsigned char *)(dp->d_name);
    {
#line 643
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 643
      if ((unsigned long )dc < (unsigned long )pathend_last) {
#line 643
        tmp___6 = dc;
#line 643
        dc ++;
#line 643
        tmp___8 = sc;
#line 643
        sc ++;
#line 643
        tmp___7 = (Char )*tmp___8;
#line 643
        *tmp___6 = tmp___7;
#line 643
        if (! ((int )tmp___7 != 0)) {
#line 643
          goto while_break___0;
        }
      } else {
#line 643
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 645
    if ((unsigned long )dc >= (unsigned long )pathend_last) {
#line 646
      *dc = (Char )'\000';
#line 647
      err = 1;
#line 648
      goto while_break;
    }
    {
#line 651
    tmp___9 = match(pathend, pattern, restpattern, pglob->gl_maxdepth);
    }
#line 651
    if (! tmp___9) {
#line 652
      *pathend = (Char )'\000';
#line 653
      goto while_continue;
    }
    {
#line 655
    dc --;
#line 655
    err = glob2(pathbuf, pathbuf_last, dc, pathend_last, restpattern, restpattern_last,
                pglob, limitp, recursion);
    }
#line 657
    if (err) {
#line 658
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 662
  if (pglob->gl_flags & 64) {
    {
#line 663
    (*(pglob->gl_closedir))((void *)dirp);
    }
  } else {
    {
#line 665
    closedir(dirp);
    }
  }
#line 667
  return (err);
}
}
#line 684 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/bsd-glob.c"
static int globextend(Char const   *path , glob_t *pglob , struct glob_lim *limitp ,
                      struct stat *sb ) 
{ 
  char **pathv ;
  ssize_t i ;
  size_t newn ;
  size_t len ;
  char *copy ;
  Char const   *p ;
  struct stat **statv ;
  void *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  struct stat *tmp___2 ;
  void *tmp___3 ;
  Char const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;

  {
#line 691
  copy = (char *)((void *)0);
#line 695
  newn = (size_t )((2 + pglob->gl_pathc) + pglob->gl_offs);
#line 696
  if (pglob->gl_offs >= 2147483647) {
#line 696
    goto nospace;
  } else
#line 696
  if (pglob->gl_pathc >= 2147483647) {
#line 696
    goto nospace;
  } else
#line 696
  if (newn >= 2147483647UL) {
#line 696
    goto nospace;
  } else
#line 696
  if (0xffffffffffffffffUL / sizeof(*pathv) <= newn) {
#line 696
    goto nospace;
  } else
#line 696
  if (0xffffffffffffffffUL / sizeof(*statv) <= newn) {
    nospace: 
#line 702
    i = (ssize_t )pglob->gl_offs;
    {
#line 702
    while (1) {
      while_continue: /* CIL Label */ ;
#line 702
      if (! (i < (ssize_t )(newn - 2UL))) {
#line 702
        goto while_break;
      }
#line 703
      if (pglob->gl_pathv) {
#line 703
        if (*(pglob->gl_pathv + i)) {
          {
#line 704
          free((void *)*(pglob->gl_pathv + i));
          }
        }
      }
#line 706
      if ((pglob->gl_flags & 16384) != 0) {
#line 706
        if (pglob->gl_pathv) {
#line 706
          if (*(pglob->gl_pathv + i)) {
            {
#line 708
            free((void *)*(pglob->gl_statv + i));
            }
          }
        }
      }
#line 702
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 711
    if (pglob->gl_pathv) {
      {
#line 712
      free((void *)pglob->gl_pathv);
#line 713
      pglob->gl_pathv = (char **)((void *)0);
      }
    }
#line 715
    if (pglob->gl_statv) {
      {
#line 716
      free((void *)pglob->gl_statv);
#line 717
      pglob->gl_statv = (struct stat **)((void *)0);
      }
    }
#line 719
    return (-1);
  }
  {
#line 722
  tmp = realloc((void *)pglob->gl_pathv, newn * sizeof(*pathv));
#line 722
  pathv = (char **)tmp;
  }
#line 723
  if ((unsigned long )pathv == (unsigned long )((void *)0)) {
#line 724
    goto nospace;
  }
#line 726
  if ((unsigned long )pglob->gl_pathv == (unsigned long )((void *)0)) {
#line 726
    if (pglob->gl_offs > 0) {
#line 728
      pathv += pglob->gl_offs;
#line 729
      i = (ssize_t )pglob->gl_offs;
      {
#line 729
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 729
        i --;
#line 729
        if (! (i >= 0L)) {
#line 729
          goto while_break___0;
        }
#line 730
        pathv --;
#line 730
        *pathv = (char *)((void *)0);
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 733
  pglob->gl_pathv = pathv;
#line 735
  if ((pglob->gl_flags & 16384) != 0) {
    {
#line 736
    tmp___0 = realloc((void *)pglob->gl_statv, newn * sizeof(*statv));
#line 736
    statv = (struct stat **)tmp___0;
    }
#line 737
    if ((unsigned long )statv == (unsigned long )((void *)0)) {
#line 738
      goto nospace;
    }
#line 740
    if ((unsigned long )pglob->gl_statv == (unsigned long )((void *)0)) {
#line 740
      if (pglob->gl_offs > 0) {
#line 742
        statv += pglob->gl_offs;
#line 743
        i = (ssize_t )pglob->gl_offs;
        {
#line 743
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 743
          i --;
#line 743
          if (! (i >= 0L)) {
#line 743
            goto while_break___1;
          }
#line 744
          statv --;
#line 744
          *statv = (struct stat *)((void *)0);
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
#line 747
    pglob->gl_statv = statv;
#line 748
    if ((unsigned long )sb == (unsigned long )((void *)0)) {
#line 749
      *(statv + (pglob->gl_offs + pglob->gl_pathc)) = (struct stat *)((void *)0);
    } else {
#line 751
      limitp->glim_malloc += sizeof(*(*statv));
#line 752
      if (limitp->glim_malloc >= 65536UL) {
        {
#line 753
        tmp___1 = __errno_location();
#line 753
        *tmp___1 = 0;
        }
#line 754
        return (-1);
      }
      {
#line 756
      tmp___3 = malloc(sizeof(*(*statv)));
#line 756
      tmp___2 = (struct stat *)tmp___3;
#line 756
      *(statv + (pglob->gl_offs + pglob->gl_pathc)) = tmp___2;
      }
#line 756
      if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 758
        goto copy_error;
      }
      {
#line 760
      memcpy((void */* __restrict  */)*(statv + (pglob->gl_offs + pglob->gl_pathc)),
             (void const   */* __restrict  */)sb, sizeof(*sb));
      }
    }
#line 763
    *(statv + ((pglob->gl_offs + pglob->gl_pathc) + 1)) = (struct stat *)((void *)0);
  }
#line 766
  p = path;
  {
#line 766
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 766
    tmp___4 = p;
#line 766
    p ++;
#line 766
    if (! *tmp___4) {
#line 766
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 768
  len = (size_t )(p - path);
#line 769
  limitp->glim_malloc += len;
#line 770
  tmp___7 = malloc(len);
#line 770
  copy = (char *)tmp___7;
  }
#line 770
  if ((unsigned long )copy != (unsigned long )((void *)0)) {
    {
#line 771
    tmp___5 = g_Ctoc(path, copy, (unsigned int )len);
    }
#line 771
    if (tmp___5) {
      {
#line 772
      free((void *)copy);
      }
#line 773
      return (-1);
    }
#line 775
    tmp___6 = pglob->gl_pathc;
#line 775
    (pglob->gl_pathc) ++;
#line 775
    *(pathv + (pglob->gl_offs + tmp___6)) = copy;
  }
#line 777
  *(pathv + (pglob->gl_offs + pglob->gl_pathc)) = (char *)((void *)0);
#line 779
  if (newn * sizeof(*pathv) + limitp->glim_malloc > 65536UL) {
    {
#line 780
    tmp___8 = __errno_location();
#line 780
    *tmp___8 = 0;
    }
#line 781
    return (-1);
  }
  copy_error: 
#line 784
  if ((unsigned long )copy == (unsigned long )((void *)0)) {
#line 784
    tmp___9 = -1;
  } else {
#line 784
    tmp___9 = 0;
  }
#line 784
  return (tmp___9);
}
}
#line 791 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/bsd-glob.c"
static int match(Char *name___0 , Char *pat , Char *patend , int recur ) 
{ 
  int ok ;
  int negate_range ;
  Char c ;
  Char k ;
  int tmp ;
  Char *tmp___0 ;
  int tmp___1 ;
  Char *tmp___2 ;
  Char *tmp___3 ;
  Char *tmp___4 ;
  Char *tmp___5 ;
  Char *tmp___6 ;

  {
#line 797
  tmp = recur;
#line 797
  recur --;
#line 797
  if (tmp == 0) {
#line 798
    return (-1);
  }
  {
#line 800
  while (1) {
    while_continue: /* CIL Label */ ;
#line 800
    if (! ((unsigned long )pat < (unsigned long )patend)) {
#line 800
      goto while_break;
    }
#line 801
    tmp___0 = pat;
#line 801
    pat ++;
#line 801
    c = *tmp___0;
    {
#line 803
    if (((int )c & 65535) == 32810) {
#line 803
      goto case_32810;
    }
#line 816
    if (((int )c & 65535) == 32831) {
#line 816
      goto case_32831;
    }
#line 821
    if (((int )c & 65535) == 32859) {
#line 821
      goto case_32859;
    }
#line 843
    goto switch_default;
    case_32810: /* CIL Label */ 
    {
#line 804
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 804
      if ((unsigned long )pat < (unsigned long )patend) {
#line 804
        if (! (((int )*pat & 65535) == 32810)) {
#line 804
          goto while_break___0;
        }
      } else {
#line 804
        goto while_break___0;
      }
#line 805
      pat ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 807
    if ((unsigned long )pat == (unsigned long )patend) {
#line 808
      return (1);
    }
    {
#line 810
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 811
      tmp___1 = match(name___0, pat, patend, recur);
      }
#line 811
      if (tmp___1) {
#line 812
        return (1);
      }
#line 810
      tmp___2 = name___0;
#line 810
      name___0 ++;
#line 810
      if (! ((int )*tmp___2 != 0)) {
#line 810
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 815
    return (0);
    case_32831: /* CIL Label */ 
#line 817
    tmp___3 = name___0;
#line 817
    name___0 ++;
#line 817
    if ((int )*tmp___3 == 0) {
#line 818
      return (0);
    }
#line 820
    goto switch_break;
    case_32859: /* CIL Label */ 
#line 822
    ok = 0;
#line 823
    tmp___4 = name___0;
#line 823
    name___0 ++;
#line 823
    k = *tmp___4;
#line 823
    if ((int )k == 0) {
#line 824
      return (0);
    }
#line 826
    negate_range = ((int )*pat & 65535) == 32801;
#line 826
    if (negate_range != 0) {
#line 827
      pat ++;
    }
    {
#line 829
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 829
      tmp___5 = pat;
#line 829
      pat ++;
#line 829
      c = *tmp___5;
#line 829
      if (! (((int )c & 65535) != 32861)) {
#line 829
        goto while_break___2;
      }
#line 830
      if (((int )*pat & 65535) == 32813) {
#line 831
        if ((int )c <= (int )k) {
#line 831
          if ((int )k <= (int )*(pat + 1)) {
#line 832
            ok = 1;
          }
        }
#line 834
        pat += 2;
      } else
#line 835
      if ((int )c == (int )k) {
#line 836
        ok = 1;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 839
    if (ok == negate_range) {
#line 840
      return (0);
    }
#line 842
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 844
    tmp___6 = name___0;
#line 844
    name___0 ++;
#line 844
    if ((int )*tmp___6 != (int )c) {
#line 845
      return (0);
    }
#line 847
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 850
  return ((int )*name___0 == 0);
}
}
#line 854 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/bsd-glob.c"
void globfree(glob_t *pglob ) 
{ 
  int i ;
  char **pp ;
  int tmp ;

  {
#line 860
  if ((unsigned long )pglob->gl_pathv != (unsigned long )((void *)0)) {
#line 861
    pp = pglob->gl_pathv + pglob->gl_offs;
#line 862
    i = pglob->gl_pathc;
    {
#line 862
    while (1) {
      while_continue: /* CIL Label */ ;
#line 862
      tmp = i;
#line 862
      i --;
#line 862
      if (! tmp) {
#line 862
        goto while_break;
      }
#line 863
      if (*pp) {
        {
#line 864
        free((void *)*pp);
        }
      }
#line 862
      pp ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 867
    free((void *)pglob->gl_pathv);
#line 868
    pglob->gl_pathv = (char **)((void *)0);
    }
  }
#line 870
  if ((unsigned long )pglob->gl_statv != (unsigned long )((void *)0)) {
#line 871
    i = 0;
    {
#line 871
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 871
      if (! (i < pglob->gl_pathc)) {
#line 871
        goto while_break___0;
      }
#line 872
      if ((unsigned long )*(pglob->gl_statv + i) != (unsigned long )((void *)0)) {
        {
#line 873
        free((void *)*(pglob->gl_statv + i));
        }
      }
#line 871
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 876
    free((void *)pglob->gl_statv);
#line 877
    pglob->gl_statv = (struct stat **)((void *)0);
    }
  }
#line 879
  return;
}
}
#line 881 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/bsd-glob.c"
static DIR *g_opendir(Char *str , glob_t *pglob ) 
{ 
  char buf___1[4096] ;
  int tmp ;
  void *tmp___0 ;
  DIR *tmp___1 ;

  {
#line 886
  if (! *str) {
#line 887
    buf___1[0] = (char )'.';
#line 888
    buf___1[1] = (char)0;
  } else {
    {
#line 890
    tmp = g_Ctoc((Char const   *)str, buf___1, (unsigned int )sizeof(buf___1));
    }
#line 890
    if (tmp) {
#line 891
      return ((DIR *)((void *)0));
    }
  }
#line 895
  if (pglob->gl_flags & 64) {
    {
#line 896
    tmp___0 = (*(pglob->gl_opendir))((char const   *)(buf___1));
    }
#line 896
    return ((DIR *)tmp___0);
  }
  {
#line 899
  tmp___1 = opendir((char const   *)(buf___1));
  }
#line 899
  return (tmp___1);
}
}
#line 902 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/bsd-glob.c"
static int g_lstat(Char *fn , struct stat *sb , glob_t *pglob ) 
{ 
  char buf___1[4096] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 907
  tmp = g_Ctoc((Char const   *)fn, buf___1, (unsigned int )sizeof(buf___1));
  }
#line 907
  if (tmp) {
#line 908
    return (-1);
  }
#line 910
  if (pglob->gl_flags & 64) {
    {
#line 911
    tmp___0 = (*(pglob->gl_lstat))((char const   *)(buf___1), sb);
    }
#line 911
    return (tmp___0);
  }
  {
#line 913
  tmp___1 = lstat((char const   */* __restrict  */)(buf___1), (struct stat */* __restrict  */)sb);
  }
#line 913
  return (tmp___1);
}
}
#line 916 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/bsd-glob.c"
static int g_stat(Char *fn , struct stat *sb , glob_t *pglob ) 
{ 
  char buf___1[4096] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 921
  tmp = g_Ctoc((Char const   *)fn, buf___1, (unsigned int )sizeof(buf___1));
  }
#line 921
  if (tmp) {
#line 922
    return (-1);
  }
#line 924
  if (pglob->gl_flags & 64) {
    {
#line 925
    tmp___0 = (*(pglob->gl_stat))((char const   *)(buf___1), sb);
    }
#line 925
    return (tmp___0);
  }
  {
#line 927
  tmp___1 = stat((char const   */* __restrict  */)(buf___1), (struct stat */* __restrict  */)sb);
  }
#line 927
  return (tmp___1);
}
}
#line 930 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/bsd-glob.c"
static Char *g_strchr(Char const   *str , int ch ) 
{ 
  Char const   *tmp ;

  {
  {
#line 933
  while (1) {
    while_continue: /* CIL Label */ ;
#line 934
    if ((int const   )*str == (int const   )ch) {
#line 935
      return ((Char *)str);
    }
#line 933
    tmp = str;
#line 933
    str ++;
#line 933
    if (! *tmp) {
#line 933
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 938
  return ((Char *)((void *)0));
}
}
#line 941 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/bsd-glob.c"
static int g_Ctoc(Char const   *str , char *buf___1 , unsigned int len ) 
{ 
  char *tmp ;
  char tmp___0 ;
  Char const   *tmp___1 ;
  unsigned int tmp___2 ;

  {
  {
#line 944
  while (1) {
    while_continue: /* CIL Label */ ;
#line 944
    tmp___2 = len;
#line 944
    len --;
#line 944
    if (! tmp___2) {
#line 944
      goto while_break;
    }
#line 945
    tmp = buf___1;
#line 945
    buf___1 ++;
#line 945
    tmp___1 = str;
#line 945
    str ++;
#line 945
    tmp___0 = (char )*tmp___1;
#line 945
    *tmp = tmp___0;
#line 945
    if ((int )tmp___0 == 0) {
#line 946
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 949
  return (1);
}
}
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 17 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/alt_arc4random.h"
unsigned int alt_arc4random(void) ;
#line 18
void alt_arc4random_stir(void) ;
#line 19
void alt_arc4random_addrandom(unsigned char *dat , int datlen ) ;
#line 20
unsigned int alt_arc4random_uniform(unsigned int upper_bound ) ;
#line 21
void alt_arc4random_buf(void *_buf , size_t n ) ;
#line 25
int alt_arc4random_close(void) ;
#line 54 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/alt_arc4random.c"
static int rs_initialized  ;
#line 55 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/alt_arc4random.c"
static struct alt_arc4_stream rs  ;
#line 56 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/alt_arc4random.c"
static pid_t alt_arc4_stir_pid  ;
#line 57 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/alt_arc4random.c"
static int alt_arc4_count  ;
#line 58 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/alt_arc4random.c"
static int random_data_source_fd  =    -1;
#line 59
static unsigned char alt_arc4_getbyte(void) ;
#line 72
static int alt_arc4_random_dev_open(void) ;
#line 72 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/alt_arc4random.c"
static char const   * const  devices[4]  = {      (char const   */* const  */)"/dev/arandom",      (char const   */* const  */)"/dev/urandom",      (char const   */* const  */)"/dev/random",      (char const   */* const  */)((void *)0)};
#line 69 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/alt_arc4random.c"
static int alt_arc4_random_dev_open(void) 
{ 
  char const   * const  *device ;
  int tmp ;
  int tmp___0 ;

  {
#line 75
  device = devices;
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 78
    tmp___0 = access((char const   *)*device, 4);
    }
#line 78
    if (tmp___0 == 0) {
      {
#line 79
      tmp = open((char const   *)*device, 0);
      }
#line 79
      return (tmp);
    }
#line 81
    device ++;
#line 77
    if (! ((unsigned long )*device != (unsigned long )((void *)0))) {
#line 77
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  return (-1);
}
}
#line 87 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/alt_arc4random.c"
static void alt_arc4_init(void) 
{ 
  int n ;

  {
#line 92
  n = 0;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! (n < 256)) {
#line 92
      goto while_break;
    }
#line 93
    rs.s[n] = (unsigned char )n;
#line 92
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  rs.i = (unsigned char)0;
#line 96
  rs.j = (unsigned char)0;
#line 98
  if (random_data_source_fd != -1) {
#line 99
    return;
  }
  {
#line 101
  random_data_source_fd = alt_arc4_random_dev_open();
  }
#line 102
  return;
}
}
#line 104 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/alt_arc4random.c"
static void alt_arc4_addrandom(unsigned char *dat , int datlen ) 
{ 
  int n ;
  unsigned char si ;

  {
#line 110
  rs.i = (unsigned char )((int )rs.i - 1);
#line 111
  n = 0;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! (n < 256)) {
#line 111
      goto while_break;
    }
#line 112
    rs.i = (unsigned char )((int )rs.i + 1);
#line 113
    si = rs.s[rs.i];
#line 114
    rs.j = (unsigned char )(((int )rs.j + (int )si) + (int )*(dat + n % datlen));
#line 115
    rs.s[rs.i] = rs.s[rs.j];
#line 116
    rs.s[rs.j] = si;
#line 111
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  rs.j = rs.i;
#line 119
  return;
}
}
#line 121 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/alt_arc4random.c"
static void alt_arc4_stir(void) 
{ 
  int i ;
  unsigned char rnd[128] ;

  {
#line 127
  if (! rs_initialized) {
    {
#line 128
    alt_arc4_init();
#line 129
    rs_initialized = 1;
    }
  }
#line 132
  if (random_data_source_fd != -1) {
    {
#line 133
    safe_read((int const   )random_data_source_fd, (void */* const  */)(rnd), sizeof(rnd));
    }
  } else {
    {
#line 136
    _exit(1);
    }
  }
  {
#line 163
  alt_arc4_addrandom(rnd, (int )sizeof(rnd));
#line 169
  i = 0;
  }
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (! (i < 256)) {
#line 169
      goto while_break;
    }
    {
#line 170
    alt_arc4_getbyte();
#line 169
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 172
  alt_arc4_count = 1600000;
#line 173
  return;
}
}
#line 175 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/alt_arc4random.c"
static void alt_arc4_stir_if_needed(void) 
{ 
  pid_t pid ;
  __pid_t tmp ;

  {
  {
#line 178
  tmp = getpid();
#line 178
  pid = tmp;
  }
#line 180
  if (alt_arc4_count <= 0) {
    {
#line 181
    alt_arc4_stir_pid = pid;
#line 182
    alt_arc4_stir();
    }
  } else
#line 180
  if (! rs_initialized) {
    {
#line 181
    alt_arc4_stir_pid = pid;
#line 182
    alt_arc4_stir();
    }
  } else
#line 180
  if (alt_arc4_stir_pid != pid) {
    {
#line 181
    alt_arc4_stir_pid = pid;
#line 182
    alt_arc4_stir();
    }
  }
#line 184
  return;
}
}
#line 186 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/alt_arc4random.c"
static unsigned char alt_arc4_getbyte(void) 
{ 
  unsigned char si ;
  unsigned char sj ;

  {
#line 191
  rs.i = (unsigned char )((int )rs.i + 1);
#line 192
  si = rs.s[rs.i];
#line 193
  rs.j = (unsigned char )((int )rs.j + (int )si);
#line 194
  sj = rs.s[rs.j];
#line 195
  rs.s[rs.i] = sj;
#line 196
  rs.s[rs.j] = si;
#line 198
  return (rs.s[((int )si + (int )sj) & 255]);
}
}
#line 201 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/alt_arc4random.c"
static unsigned int alt_arc4_getword(void) 
{ 
  unsigned int val ;
  unsigned char tmp ;
  unsigned char tmp___0 ;
  unsigned char tmp___1 ;
  unsigned char tmp___2 ;

  {
  {
#line 205
  tmp = alt_arc4_getbyte();
#line 205
  val = (unsigned int )tmp << 24;
#line 206
  tmp___0 = alt_arc4_getbyte();
#line 206
  val |= (unsigned int )tmp___0 << 16;
#line 207
  tmp___1 = alt_arc4_getbyte();
#line 207
  val |= (unsigned int )tmp___1 << 8;
#line 208
  tmp___2 = alt_arc4_getbyte();
#line 208
  val |= (unsigned int )tmp___2;
  }
#line 210
  return (val);
}
}
#line 213 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/alt_arc4random.c"
void alt_arc4random_stir(void) 
{ 


  {
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 216
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 217
  alt_arc4_stir();
  }
  {
#line 218
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 218
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 219
  return;
}
}
#line 221 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/alt_arc4random.c"
int alt_arc4random_close(void) 
{ 
  int ret ;
  int tmp ;

  {
#line 224
  ret = -1;
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 226
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 227
  if (random_data_source_fd != -1) {
    {
#line 227
    tmp = close(random_data_source_fd);
    }
#line 227
    if (tmp == 0) {
#line 228
      random_data_source_fd = -1;
#line 229
      ret = 0;
    }
  }
  {
#line 231
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 231
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 233
  return (ret);
}
}
#line 236 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/alt_arc4random.c"
void alt_arc4random_addrandom(unsigned char *dat , int datlen ) 
{ 


  {
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
#line 239
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 240
  if (! rs_initialized) {
    {
#line 241
    alt_arc4_stir();
    }
  }
  {
#line 243
  alt_arc4_addrandom(dat, datlen);
  }
  {
#line 244
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 244
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 245
  return;
}
}
#line 247 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/alt_arc4random.c"
unsigned int alt_arc4random(void) 
{ 
  unsigned int val ;

  {
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 252
  alt_arc4_count -= 4;
#line 253
  alt_arc4_stir_if_needed();
#line 254
  val = alt_arc4_getword();
  }
  {
#line 255
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 255
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 257
  return (val);
}
}
#line 260 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/alt_arc4random.c"
void alt_arc4random_buf(void *_buf , size_t n ) 
{ 
  unsigned char *buf___1 ;
  size_t tmp ;

  {
#line 263
  buf___1 = (unsigned char *)_buf;
  {
#line 264
  while (1) {
    while_continue: /* CIL Label */ ;
#line 264
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 265
  alt_arc4_stir_if_needed();
  }
  {
#line 266
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 266
    tmp = n;
#line 266
    n --;
#line 266
    if (! tmp) {
#line 266
      goto while_break___0;
    }
#line 267
    alt_arc4_count --;
#line 267
    if (alt_arc4_count <= 0) {
      {
#line 268
      alt_arc4_stir();
      }
    }
    {
#line 270
    *(buf___1 + n) = alt_arc4_getbyte();
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 272
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 272
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 273
  return;
}
}
#line 285 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/alt_arc4random.c"
unsigned int alt_arc4random_uniform(unsigned int upper_bound ) 
{ 
  unsigned int r ;
  unsigned int min ;

  {
#line 290
  if (upper_bound < 2U) {
#line 291
    return (0U);
  }
#line 295
  min = (unsigned int )(4294967296UL % (unsigned long )upper_bound);
  {
#line 312
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 313
    r = alt_arc4random();
    }
#line 314
    if (r >= min) {
#line 315
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 319
  return (r % upper_bound);
}
}
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 756 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 119
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socketpair)(int __domain ,
                                                                                 int __type ,
                                                                                 int __protocol ,
                                                                                 int *__fds ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  * __restrict  __addr ,
                                                                           socklen_t __len ) ;
#line 149
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 156
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 184
extern ssize_t sendmsg(int __fd , struct msghdr  const  *__message , int __flags ) ;
#line 202
extern ssize_t recvmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 379 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 175 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void closelog(void) ;
#line 391 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.h"
void setprocessname(char const   * const  title ) ;
#line 99 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
signed char no_syslog ;
#line 73 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/privsep_p.h"
static int psfd  =    -1;
#line 74 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/privsep_p.h"
static uid_t privsep_uid  ;
#line 6 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/privsep.h"
int privsep_sendfd(int const   psfd___0 , int const   fd ) ;
#line 7
int privsep_recvfd(int const   psfd___0 ) ;
#line 9
int privsep_init(void) ;
#line 11
int privsep_bindresport(int const   protocol , struct sockaddr_storage  const  ss ) ;
#line 15 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/privsep.c"
static int privsep_sendcmd(int const   psfd___0 , void const   * const  cmdarg , size_t const   cmdarg_len ) 
{ 
  ssize_t sent ;
  int *tmp ;

  {
  {
#line 20
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 20
    sent = send((int )psfd___0, (void const   *)cmdarg, (size_t )cmdarg_len, 0);
    }
#line 20
    if (sent == -1L) {
      {
#line 20
      tmp = __errno_location();
      }
#line 20
      if (! (*tmp == 4)) {
#line 20
        goto while_break;
      }
    } else {
#line 20
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 22
  if (sent != (ssize_t )cmdarg_len) {
#line 23
    return (-1);
  }
#line 25
  return (0);
}
}
#line 28 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/privsep.c"
static int privsep_recvcmd(int const   psfd___0 , void * const  cmdarg , size_t const   cmdarg_len ) 
{ 
  ssize_t received ;
  int *tmp ;

  {
  {
#line 33
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 33
    received = recv((int )psfd___0, (void *)cmdarg, (size_t )cmdarg_len, 0);
    }
#line 33
    if (received == -1L) {
      {
#line 33
      tmp = __errno_location();
      }
#line 33
      if (! (*tmp == 4)) {
#line 33
        goto while_break;
      }
    } else {
#line 33
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 35
  if (received != (ssize_t )cmdarg_len) {
#line 36
    return (-1);
  }
#line 38
  return (0);
}
}
#line 41 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/privsep.c"
int privsep_sendfd(int const   psfd___0 , int const   fd ) 
{ 
  char *buf___1 ;
  int *fdptr ;
  struct cmsghdr *cmsg ;
  struct msghdr msg ;
  struct iovec vec ;
  size_t sizeof_buf ;
  size_t sizeof_buf_ ;
  PrivSepCmd fodder ;
  ssize_t sent ;
  void *tmp ;
  int *tmp___0 ;

  {
#line 48
  sizeof_buf = (((sizeof(*fdptr) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL));
#line 49
  sizeof_buf_ = sizeof_buf;
#line 50
  fodder = (PrivSepCmd )2;
#line 53
  if (sizeof_buf_ < sizeof(*cmsg)) {
#line 54
    sizeof_buf_ = sizeof(*cmsg);
  }
  {
#line 56
  tmp = __builtin_alloca(sizeof_buf_);
#line 56
  buf___1 = (char *)tmp;
  }
#line 56
  if ((unsigned long )buf___1 == (unsigned long )((void *)0)) {
#line 57
    return (-1);
  }
  {
#line 59
  memset((void *)(& msg), 0, sizeof(msg));
#line 60
  vec.iov_base = (void *)(& fodder);
#line 61
  vec.iov_len = sizeof(fodder);
#line 62
  msg.msg_name = (void *)0;
#line 63
  msg.msg_namelen = (socklen_t )0;
#line 64
  msg.msg_iov = & vec;
#line 65
  msg.msg_iovlen = (size_t )1U;
#line 66
  msg.msg_control = (void *)buf___1;
#line 67
  msg.msg_controllen = sizeof_buf;
#line 68
  msg.msg_flags = 0;
  }
#line 69
  if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 69
    cmsg = (struct cmsghdr *)msg.msg_control;
  } else {
#line 69
    cmsg = (struct cmsghdr *)0;
  }
#line 69
  if ((unsigned long )cmsg == (unsigned long )((void *)0)) {
    {
#line 70
    while (1) {
      while_continue: /* CIL Label */ ;
#line 70
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 71
    return (-1);
  }
#line 73
  cmsg->cmsg_len = (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + sizeof(fd);
#line 74
  cmsg->cmsg_level = 1;
#line 75
  cmsg->cmsg_type = 1;
#line 76
  fdptr = (int *)((void *)(cmsg->__cmsg_data));
#line 76
  if ((unsigned long )fdptr == (unsigned long )((void *)0)) {
    {
#line 77
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 77
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 78
    return (-1);
  }
#line 80
  *fdptr = (int )fd;
#line 81
  msg.msg_controllen = cmsg->cmsg_len;
  {
#line 82
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 82
    sent = sendmsg((int )psfd___0, (struct msghdr  const  *)(& msg), 0);
    }
#line 82
    if (sent == -1L) {
      {
#line 82
      tmp___0 = __errno_location();
      }
#line 82
      if (! (*tmp___0 == 4)) {
#line 82
        goto while_break___1;
      }
    } else {
#line 82
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 83
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 83
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 84
  if (sent != (ssize_t )sizeof(fodder)) {
#line 85
    return (-1);
  }
#line 87
  return (0);
}
}
#line 90 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/privsep.c"
int privsep_recvfd(int const   psfd___0 ) 
{ 
  char *buf___1 ;
  int *fdptr ;
  struct cmsghdr *cmsg ;
  struct msghdr msg ;
  struct iovec vec ;
  size_t sizeof_buf ;
  size_t sizeof_buf_ ;
  PrivSepCmd fodder ;
  ssize_t received ;
  void *tmp ;
  int *tmp___0 ;

  {
#line 97
  sizeof_buf = (((sizeof(*fdptr) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL));
#line 98
  sizeof_buf_ = sizeof_buf;
#line 99
  fodder = (PrivSepCmd )0;
#line 102
  if (sizeof_buf_ < sizeof(*cmsg)) {
#line 103
    sizeof_buf_ = sizeof(*cmsg);
  }
  {
#line 105
  tmp = __builtin_alloca(sizeof_buf_);
#line 105
  buf___1 = (char *)tmp;
  }
#line 105
  if ((unsigned long )buf___1 == (unsigned long )((void *)0)) {
#line 106
    return (-1);
  }
  {
#line 108
  memset((void *)(& msg), 0, sizeof(msg));
#line 109
  vec.iov_base = (void *)(& fodder);
#line 110
  vec.iov_len = sizeof(fodder);
#line 111
  msg.msg_name = (void *)0;
#line 112
  msg.msg_namelen = (socklen_t )0;
#line 113
  msg.msg_iov = & vec;
#line 114
  msg.msg_iovlen = (size_t )1U;
#line 115
  msg.msg_control = (void *)buf___1;
#line 116
  msg.msg_controllen = sizeof_buf;
#line 117
  msg.msg_flags = 0;
  }
#line 118
  if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 118
    cmsg = (struct cmsghdr *)msg.msg_control;
  } else {
#line 118
    cmsg = (struct cmsghdr *)0;
  }
#line 118
  if ((unsigned long )cmsg == (unsigned long )((void *)0)) {
#line 118
    goto _L;
  } else {
#line 118
    fdptr = (int *)((void *)(cmsg->__cmsg_data));
#line 118
    if ((unsigned long )fdptr == (unsigned long )((void *)0)) {
      _L: /* CIL Label */ 
      {
#line 120
      while (1) {
        while_continue: /* CIL Label */ ;
#line 120
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 121
      return (-1);
    }
  }
#line 123
  *fdptr = -1;
  {
#line 124
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 124
    received = recvmsg((int )psfd___0, & msg, 0);
    }
#line 124
    if (received == -1L) {
      {
#line 124
      tmp___0 = __errno_location();
      }
#line 124
      if (! (*tmp___0 == 4)) {
#line 124
        goto while_break___0;
      }
    } else {
#line 124
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 127
  if (msg.msg_flags & 32) {
#line 127
    goto _L___0;
  } else
#line 127
  if (msg.msg_flags & 8) {
    _L___0: /* CIL Label */ 
    {
#line 128
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 128
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 129
    return (-1);
  }
#line 132
  if (received != (ssize_t )sizeof(fodder)) {
#line 132
    goto _L___1;
  } else
#line 132
  if ((unsigned int )fodder != 2U) {
#line 132
    goto _L___1;
  } else {
#line 132
    if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 132
      cmsg = (struct cmsghdr *)msg.msg_control;
    } else {
#line 132
      cmsg = (struct cmsghdr *)0;
    }
#line 132
    if ((unsigned long )cmsg == (unsigned long )((void *)0)) {
#line 132
      goto _L___1;
    } else {
#line 132
      fdptr = (int *)((void *)(cmsg->__cmsg_data));
#line 132
      if ((unsigned long )fdptr == (unsigned long )((void *)0)) {
        _L___1: /* CIL Label */ 
        {
#line 136
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 136
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 137
        return (-1);
      }
    }
  }
#line 139
  return (*fdptr);
}
}
#line 142 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/privsep.c"
static void privsep_unpriv_user(void) 
{ 
  int tmp ;

  {
  {
#line 144
  tmp = seteuid(privsep_uid);
  }
#line 144
  if (tmp != 0) {
    {
#line 145
    _exit(1);
    }
  }
#line 147
  return;
}
}
#line 149 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/privsep.c"
static void privsep_priv_user(void) 
{ 
  int tmp ;

  {
  {
#line 151
  tmp = seteuid((uid_t )0);
  }
#line 151
  if (tmp != 0) {
    {
#line 152
    _exit(1);
    }
  }
#line 154
  return;
}
}
#line 190
static int privsep_privpart_bindresport(int const   psfd___0 , PrivSepQuery const   * const  query ) ;
#line 190 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/privsep.c"
static in_port_t const   portlist[10]  = 
#line 190
  {      (in_port_t const   )20,      (in_port_t const   )2U,      (in_port_t const   )3U,      (in_port_t const   )4U, 
        (in_port_t const   )5U,      (in_port_t const   )6U,      (in_port_t const   )10U,      (in_port_t const   )14U, 
        (in_port_t const   )16U,      (in_port_t const   )0U};
#line 187 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/privsep.c"
static int privsep_privpart_bindresport(int const   psfd___0 , PrivSepQuery const   * const  query ) 
{ 
  in_port_t const   *portlistpnt ;
  int fd ;
  int on ;
  int ret ;
  in_port_t *tmp ;
  in_port_t *tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 191
  portlistpnt = portlist;
#line 193
  on = 1;
#line 196
  fd = socket((int )query->bindresport.protocol, 1, 6);
  }
#line 196
  if (fd == -1) {
#line 198
    goto bye;
  }
  {
#line 201
  setsockopt(fd, 1, 15, (void const   *)((char *)(& on)), (socklen_t )sizeof(on));
#line 205
  privsep_priv_user();
  }
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (query->bindresport.protocol == 10) {
      {
#line 208
      tmp = storage_port6((struct sockaddr_storage  const  */* const  */)(& query->bindresport.ss));
#line 208
      *tmp = htons((uint16_t )*portlistpnt);
      }
    } else {
      {
#line 210
      tmp___0 = storage_port((struct sockaddr_storage  const  */* const  */)(& query->bindresport.ss));
#line 210
      *tmp___0 = htons((uint16_t )*portlistpnt);
      }
    }
#line 212
    if ((int const   )query->bindresport.ss.ss_family == 2) {
#line 212
      tmp___1 = sizeof(struct sockaddr_in );
    } else {
#line 212
      tmp___1 = sizeof(struct sockaddr_in6 );
    }
    {
#line 212
    tmp___2 = bind(fd, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& query->bindresport.ss)),
                   (socklen_t )tmp___1);
    }
#line 212
    if (tmp___2 == 0) {
#line 214
      goto while_break;
    }
#line 219
    if ((int const   )*portlistpnt == 0) {
#line 220
      goto while_break;
    }
#line 222
    portlistpnt ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 225
  privsep_unpriv_user();
  }
  bye: 
  {
#line 228
  ret = privsep_sendfd(psfd___0, (int const   )fd);
#line 229
  tmp___3 = close(fd);
#line 229
  ret |= tmp___3;
  }
#line 231
  return (ret);
}
}
#line 234 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/privsep.c"
int privsep_bindresport(int const   protocol , struct sockaddr_storage  const  ss ) 
{ 
  PrivSepQuery query ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 238
  query.bindresport.cmd = (PrivSepCmd )3;
#line 239
  query.bindresport.protocol = (int )protocol;
#line 240
  query.bindresport.ss = (struct sockaddr_storage )ss;
#line 241
  tmp = privsep_sendcmd((int const   )psfd, (void const   */* const  */)(& query),
                        (size_t const   )sizeof(query));
  }
#line 241
  if (tmp != 0) {
#line 242
    return (-1);
  }
  {
#line 244
  tmp___0 = privsep_recvfd((int const   )psfd);
  }
#line 244
  return (tmp___0);
}
}
#line 247 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/privsep.c"
static int privsep_privpart_waitcmd(int const   psfd___0 ) 
{ 
  PrivSepQuery query ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 251
  tmp = privsep_recvcmd(psfd___0, (void */* const  */)(& query), (size_t const   )sizeof(query));
  }
#line 251
  if (tmp != 0) {
#line 252
    return (-1);
  }
  {
#line 259
  if ((unsigned int )query.cmd.cmd == 3U) {
#line 259
    goto case_3;
  }
#line 261
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 260
  tmp___0 = privsep_privpart_bindresport(psfd___0, (PrivSepQuery const   */* const  */)(& query));
  }
#line 260
  return (tmp___0);
  switch_default: /* CIL Label */ 
#line 262
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 265
  return (0);
}
}
#line 268 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/privsep.c"
static int privsep_privpart_main(void) 
{ 
  int ret ;

  {
  {
#line 272
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 272
    ret = privsep_privpart_waitcmd((int const   )psfd);
    }
#line 272
    if (! (ret == 0)) {
#line 272
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 274
  if (ret != 1) {
#line 275
    return (-1);
  }
#line 277
  return (0);
}
}
#line 280 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/privsep.c"
static int privsep_privpart_closejunk(void) 
{ 
  int ret ;

  {
#line 282
  ret = 0;
#line 298
  if ((int )no_syslog == 0) {
    {
#line 299
    closelog();
    }
  }
  {
#line 302
  close(0);
#line 303
  close(1);
  }
#line 305
  return (ret);
}
}
#line 308 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/privsep.c"
static void privsep_init_privsep_user(void) 
{ 
  char const   *privsep_users[3] ;
  char const   **privsep_user ;
  struct passwd *pw ;
  int tmp ;

  {
#line 310
  privsep_users[0] = "_pure-ftpd";
#line 310
  privsep_users[1] = "pure-ftpd";
#line 310
  privsep_users[2] = (char const   *)((void *)0);
#line 313
  privsep_user = privsep_users;
#line 314
  pw = (struct passwd *)((void *)0);
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if (! ((unsigned long )*privsep_user != (unsigned long )((void *)0))) {
#line 316
      goto while_break;
    }
    {
#line 317
    pw = getpwnam(*privsep_user);
    }
#line 317
    if ((unsigned long )pw != (unsigned long )((void *)0)) {
#line 318
      goto while_break;
    }
#line 320
    privsep_user ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 322
  if ((unsigned long )pw == (unsigned long )((void *)0)) {
#line 323
    return;
  }
  {
#line 325
  privsep_uid = pw->pw_uid;
#line 327
  tmp = setgroups((size_t )1U, (__gid_t const   *)(& pw->pw_gid));
  }
#line 327
  if (tmp != 0) {
    {
#line 327
    _exit(1);
    }
  }
#line 333
  return;
}
}
#line 335 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/privsep.c"
int privsep_init(void) 
{ 
  int sv[2] ;
  pid_t pid ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 340
  tmp = socketpair(1, 1, 0, (int *)(sv));
  }
#line 340
  if (tmp != 0) {
#line 341
    return (-1);
  }
  {
#line 343
  pid = fork();
  }
#line 343
  if (pid == -1) {
    {
#line 344
    close(sv[0]);
#line 345
    close(sv[1]);
    }
#line 347
    return (-1);
  }
#line 349
  if (pid != 0) {
    {
#line 350
    close(sv[0]);
#line 351
    psfd = sv[1];
    }
#line 353
    return (0);
  }
  {
#line 355
  close(sv[1]);
#line 356
  psfd = sv[0];
#line 357
  setprocessname((char const   */* const  */)"pure-ftpd (PRIV)");
#line 358
  privsep_privpart_closejunk();
#line 359
  privsep_init_privsep_user();
#line 360
  privsep_unpriv_user();
#line 361
  tmp___0 = privsep_privpart_main();
#line 361
  _exit(tmp___0);
  }
#line 363
  return (-1);
}
}
#line 325 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.h"
int pureftpd_start(int argc , char **argv , char const   *home_directory_ ) ;
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 390 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 164
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   * __restrict  __nptr ,
                                                                                                char ** __restrict  __endptr ) ;
#line 183
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 214
extern  __attribute__((__nothrow__)) unsigned long long ( __attribute__((__nonnull__(1),
__leaf__)) strtoull)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                     int __base ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 324 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srandom)(unsigned int __seed ) ;
#line 515
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 951
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) getloadavg)(double *__loadavg ,
                                                                                                 int __nelem ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 315
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 218
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigfillset)(sigset_t *__set ) ;
#line 221
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 224
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigdelset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 248
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 432 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 460
extern int usleep(__useconds_t __useconds ) ;
#line 473
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chown)(char const   *__file ,
                                                                                            __uid_t __owner ,
                                                                                            __gid_t __group ) ;
#line 511
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 545
extern char **environ ;
#line 619
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 689
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getgroups)(int __size ,
                                                                                __gid_t *__list ) ;
#line 779
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 790
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) link)(char const   *__from ,
                                                                                             char const   *__to ) ;
#line 809
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2), __leaf__)) readlink)(char const   * __restrict  __path ,
                                                                                                     char * __restrict  __buf ,
                                                                                                     size_t __len ) ;
#line 835
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) rmdir)(char const   *__path ) ;
#line 978
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getpagesize)(void)  __attribute__((__const__)) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 239 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 319
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) timegm)(struct tm *__tp ) ;
#line 284 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 312
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 321
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 238 "/usr/include/fcntl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) posix_fadvise)(int __fd ,
                                                                                    off_t __offset ,
                                                                                    off_t __len ,
                                                                                    int __advise ) ;
#line 127 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
#line 141
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getpeername)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 261
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) shutdown)(int __fd ,
                                                                               int __how ) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 375
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 69 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit  const  *__rlimits ) ;
#line 58 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_pton)(int __af ,
                                                                                char const   * __restrict  __cp ,
                                                                                void * __restrict  __buf ) ;
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 677
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , int __flags ) ;
#line 65 "/usr/include/x86_64-linux-gnu/sys/statvfs.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) statvfs64)(char const   * __restrict  __file ,
                                                                                                  struct statvfs64 * __restrict  __buf ) ;
#line 45 "/usr/include/utime.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) utime)(char const   *__file ,
                                                                                            struct utimbuf  const  *__file_times ) ;
#line 74 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
CODE prioritynames[13]  = 
#line 74 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
  {      {(char *)"alert", 1}, 
        {(char *)"crit", 2}, 
        {(char *)"debug", 7}, 
        {(char *)"emerg", 0}, 
        {(char *)"err", 3}, 
        {(char *)"error", 3}, 
        {(char *)"info", 6}, 
        {(char *)"none", 16}, 
        {(char *)"notice", 5}, 
        {(char *)"panic", 0}, 
        {(char *)"warn", 4}, 
        {(char *)"warning", 4}, 
        {(char *)((void *)0), -1}};
#line 122 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
CODE facilitynames[23]  = 
#line 122
  {      {(char *)"auth", 4 << 3}, 
        {(char *)"authpriv", 10 << 3}, 
        {(char *)"cron", 9 << 3}, 
        {(char *)"daemon", 3 << 3}, 
        {(char *)"ftp", 11 << 3}, 
        {(char *)"kern", 0}, 
        {(char *)"lpr", 6 << 3}, 
        {(char *)"mail", 2 << 3}, 
        {(char *)"mark", 24 << 3}, 
        {(char *)"news", 7 << 3}, 
        {(char *)"security", 4 << 3}, 
        {(char *)"syslog", 5 << 3}, 
        {(char *)"user", 1 << 3}, 
        {(char *)"uucp", 8 << 3}, 
        {(char *)"local0", 16 << 3}, 
        {(char *)"local1", 17 << 3}, 
        {(char *)"local2", 18 << 3}, 
        {(char *)"local3", 19 << 3}, 
        {(char *)"local4", 20 << 3}, 
        {(char *)"local5", 21 << 3}, 
        {(char *)"local6", 22 << 3}, 
        {(char *)"local7", 23 << 3}, 
        {(char *)((void *)0), -1}};
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 329 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.h"
extern void parser(void) ;
#line 330
void stripctrl(char * const  buf___1 , size_t len ) ;
#line 331
void dobanner(int const   type___0 ) ;
#line 332
void douser(char const   *username ) ;
#line 333
void dopass(char *password ) ;
#line 334
void docwd(char const   *dir ) ;
#line 335
void doretr(char *name___0 ) ;
#line 336
void dorest(char const   *name___0 ) ;
#line 337
void dodele(char *name___0 ) ;
#line 338
void dostor(char *name___0 , int const   append , int const   autorename___0 ) ;
#line 339
void domkd(char *name___0 ) ;
#line 340
void dormd(char *name___0 ) ;
#line 341
void domdtm(char const   *name___0 ) ;
#line 342
void dosize(char const   *name___0 ) ;
#line 343
void doeprt(char *p ) ;
#line 344
void doport(char const   *arg ) ;
#line 345
void doport2(struct sockaddr_storage a , unsigned int p ) ;
#line 347
void doesta(void) ;
#line 348
void doestp(void) ;
#line 349
void doallo(off_t const   size ) ;
#line 351
void dopasv(int psvtype ) ;
#line 352
void doopts(char *args ) ;
#line 353
void dochmod(char *name___0 , mode_t mode ) ;
#line 354
void doutime(char *name___0 , char const   * const  wanted_time ) ;
#line 355
void error(int n , char const   *msg ) ;
#line 356
void domode(char const   *arg ) ;
#line 357
void dostru(char const   *arg ) ;
#line 358
void dotype(char const   *arg ) ;
#line 359
void donoop(void) ;
#line 360
void dornfr(char *name___0 ) ;
#line 361
void dornto(char *name___0 ) ;
#line 362
void dostou(void) ;
#line 363
void dofeat(void) ;
#line 364
void domlst(char const   * const  file ) ;
#line 365
void dositetime(void) ;
#line 366
int ul_check_free_space(char const   *name___0 , double const   min_space ) ;
#line 368
void disablesignals(void) ;
#line 372
void opendata(void) ;
#line 373
void closedata(void) ;
#line 374
void client_fflush(void) ;
#line 375
void ( /* format attribute */  client_printf)(char const   * const  format  , ...) ;
#line 377
void ( /* format attribute */  addreply)(int const   code , char const   * const  line___1 
                                         , ...) ;
#line 379
void addreply_noformat(int const   code , char const   * const  line___1 ) ;
#line 380
void doreply(void) ;
#line 384
void ( /* format attribute */  logfile)(int const   crit , char const   *format  , ...) ;
#line 386
char *skip_telnet_controls(char const   *str ) ;
#line 387
 __attribute__((__noreturn__)) void ( /* format attribute */  die)(int const   err ,
                                                                   int const   priority ,
                                                                   char const   * const  format 
                                                                   , ...) ;
#line 389
 __attribute__((__noreturn__)) void die_mem(void) ;
#line 390
 __attribute__((__noreturn__)) void _EXIT(int const   status ) ;
#line 392
int modernformat(char const   *file , char *target , size_t target_size , char const   * const  prefix ) ;
#line 395
extern char const   *getgroup(gid_t const   gid ) ;
#line 396
extern char const   *getname(uid_t const   uid ) ;
#line 397
unsigned int zrand(void) ;
#line 399
int checkprintable(char const   *s___0 ) ;
#line 400
void delete_atomic_file(void) ;
#line 404
void usleep2(unsigned long const   microsec ) ;
#line 4 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/log_unix.h"
extern void pw_unix_check(AuthResult * const  result , char const   *account , char const   *password ,
                          struct sockaddr_storage  const  * const  sa , struct sockaddr_storage  const  * const  peer ) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 49 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd_p.h"
static sig_atomic_t volatile   stop_server  ;
#line 50 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd_p.h"
static char const   *standalone_port  =    "21";
#line 51 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd_p.h"
static char const   *standalone_ip  ;
#line 52 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd_p.h"
static unsigned int volatile   nb_children  ;
#line 53 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd_p.h"
static int volatile   listenfd  =    (int volatile   )-1;
#line 54 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd_p.h"
static int volatile   listenfd6  =    (int volatile   )-1;
#line 62 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd_p.h"
static char const   *GETOPT_OPTIONS  =    "0146Aa:bc:BC:dDeEf:g:GhHiI:jk:Kl:L:Mm:Np:P:rRsS:u:U:V:wWxXzZ";
#line 112 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd_p.h"
static struct option long_options[47]  = 
#line 112
  {      {"notruncate", 0, (int *)((void *)0), '0'}, 
        {"logpid", 0, (int *)((void *)0), '1'}, 
        {"ipv4only", 0, (int *)((void *)0), '4'}, 
        {"ipv6only", 0, (int *)((void *)0), '6'}, 
        {"chrooteveryone", 0, (int *)((void *)0), 'A'}, 
        {"trustedgid", 1, (int *)((void *)0), 'a'}, 
        {"brokenclientscompatibility", 0, (int *)((void *)0), 'b'}, 
        {"daemonize", 0, (int *)((void *)0), 'B'}, 
        {"maxclientsperip", 1, (int *)((void *)0), 'C'}, 
        {"maxclientsnumber", 1, (int *)((void *)0), 'c'}, 
        {"verboselog", 0, (int *)((void *)0), 'd'}, 
        {"displaydotfiles", 0, (int *)((void *)0), 'D'}, 
        {"anonymousonly", 0, (int *)((void *)0), 'e'}, 
        {"noanonymous", 0, (int *)((void *)0), 'E'}, 
        {"syslogfacility", 1, (int *)((void *)0), 'f'}, 
        {"pidfile", 1, (int *)((void *)0), 'g'}, 
        {"norename", 0, (int *)((void *)0), 'G'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"dontresolve", 0, (int *)((void *)0), 'H'}, 
        {"maxidletime", 1, (int *)((void *)0), 'I'}, 
        {"anonymouscantupload", 0, (int *)((void *)0), 'i'}, 
        {"createhomedir", 0, (int *)((void *)0), 'j'}, 
        {"keepallfiles", 0, (int *)((void *)0), 'K'}, 
        {"maxdiskusagepct", 1, (int *)((void *)0), 'k'}, 
        {"login", 1, (int *)((void *)0), 'l'}, 
        {"limitrecursion", 1, (int *)((void *)0), 'L'}, 
        {"anonymouscancreatedirs", 0, (int *)((void *)0), 'M'}, 
        {"maxload", 1, (int *)((void *)0), 'm'}, 
        {"natmode", 0, (int *)((void *)0), 'N'}, 
        {"passiveportrange", 1, (int *)((void *)0), 'p'}, 
        {"forcepassiveip", 1, (int *)((void *)0), 'P'}, 
        {"autorename", 0, (int *)((void *)0), 'r'}, 
        {"nochmod", 0, (int *)((void *)0), 'R'}, 
        {"antiwarez", 0, (int *)((void *)0), 's'}, 
        {"bind", 1, (int *)((void *)0), 'S'}, 
        {"anonymousbandwidth", 1, (int *)((void *)0), 't'}, 
        {"userbandwidth", 1, (int *)((void *)0), 'T'}, 
        {"umask", 1, (int *)((void *)0), 'U'}, 
        {"minuid", 1, (int *)((void *)0), 'u'}, 
        {"trustedip", 1, (int *)((void *)0), 'V'}, 
        {"allowuserfxp", 0, (int *)((void *)0), 'w'}, 
        {"allowanonymousfxp", 0, (int *)((void *)0), 'W'}, 
        {"prohibitdotfileswrite", 0, (int *)((void *)0), 'x'}, 
        {"prohibitdotfilesread", 0, (int *)((void *)0), 'X'}, 
        {"allowdotfiles", 0, (int *)((void *)0), 'z'}, 
        {"customerproof", 0, (int *)((void *)0), 'Z'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 225 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd_p.h"
static sigset_t old_sigmask  ;
#line 229 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd_p.h"
static char **argv0  ;
#line 230 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd_p.h"
static size_t argv_lth  ;
#line 255 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd_p.h"
static Authentication auth_list[2]  = {      {"unix", (void (*)(char const   * const  file ))((void *)0), & pw_unix_check,
      (void (*)(void))((void *)0)}, 
        {(char const   *)((void *)0), (void (*)(char const   * const  file ))((void *)0),
      (void (*)(AuthResult * const  result , char const   *account , char const   *password ,
                struct sockaddr_storage  const  * const  sa , struct sockaddr_storage  const  * const  peer ))((void *)0),
      (void (*)(void))((void *)0)}};
#line 290 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd_p.h"
static Authentications *first_authentications  ;
#line 290 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd_p.h"
static Authentications *last_authentications  ;
#line 356 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd_p.h"
static struct reply *firstreply  ;
#line 357 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd_p.h"
static struct reply *lastreply  ;
#line 11 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/dynamic.h"
void iptrack_delete_pid(pid_t const   pid ) ;
#line 12
unsigned int iptrack_get(struct sockaddr_storage  const  * const  ip ) ;
#line 13
void iptrack_free(void) ;
#line 14
void iptrack_add(struct sockaddr_storage  const  * const  ip , pid_t const   pid ) ;
#line 12 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
char default_tz_for_putenv[13]  = 
#line 12 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
  {      (char )'T',      (char )'Z',      (char )'=',      (char )'U', 
        (char )'T',      (char )'C',      (char )'+',      (char )'0', 
        (char )'0',      (char )':',      (char )'0',      (char )'0', 
        (char )'\000'};
#line 13 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
unsigned long long downloaded  ;
#line 14 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
unsigned long long uploaded  ;
#line 15 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
signed char anon_only  ;
#line 16 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
struct sockaddr_storage *trustedip  ;
#line 17 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
signed char volatile   logging  ;
#line 22 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
unsigned long throttling_bandwidth_dl  ;
#line 23 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
unsigned long throttling_bandwidth_ul  ;
#line 24 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
signed char allowfxp  ;
#line 25 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
signed char passive  ;
#line 26 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
int clientfd  =    0;
#line 27 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
int datafd  =    -1;
#line 28 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
struct sockaddr_storage ctrlconn  ;
#line 29 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
signed char v6ready  ;
#line 30 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
signed char no_ipv4  ;
#line 31 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
unsigned long const   cmdsize  =    (size_t const   )4112U;
#line 32 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
char cmd[4128U]  ;
#line 33 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
char wd[4097U]  ;
#line 34 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
char *root_directory  ;
#line 35 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
signed char loggedin  ;
#line 36 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
char account[128U]  ;
#line 37 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
char *renamefrom  ;
#line 38 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
in_port_t serverport  ;
#line 39 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
signed char userchroot  ;
#line 40 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
signed char chrooted  ;
#line 41 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
uid_t chroot_trustedgid  ;
#line 42 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
signed char broken_client_compat  ;
#line 43 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
uid_t warez  ;
#line 44 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
signed char debug  ;
#line 45 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
signed char guest  ;
#line 46 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
uid_t useruid  ;
#line 47 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
signed char candownload  ;
#line 48 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
double load  ;
#line 49 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
time_t noopidle  =    (time_t )-1;
#line 50 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
unsigned int firstport  =    1024U;
#line 51 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
unsigned int lastport  =    65535U;
#line 52 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
signed char dot_write_ok  =    (signed char)1;
#line 53 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
signed char dot_read_ok  =    (signed char)1;
#line 54 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
signed char dot_read_anon_ok  ;
#line 56 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
signed char type  =    (signed char)1;
#line 65 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
off_t restartat  ;
#line 66 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
unsigned long idletime  =    900UL;
#line 67 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
double idletime_noop  ;
#line 68 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
signed char resolve_hostnames  =    (signed char)1;
#line 69 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
int allow_anon_mkdir  ;
#line 70 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
unsigned int max_ls_files  =    10000U;
#line 71 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
unsigned int max_ls_depth  =    5U;
#line 72 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
char *fortunes_file  ;
#line 73 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
char host[1025]  ;
#line 74 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
int replycode  ;
#line 75 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
signed char force_ls_a  ;
#line 76 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
struct sockaddr_storage peer  ;
#line 77 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
struct sockaddr_storage force_passive_ip  ;
#line 78 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
char const   *force_passive_ip_s  ;
#line 79 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
in_port_t peerdataport  ;
#line 80 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
double maxload  ;
#line 81 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
unsigned int maxusers  =    50U;
#line 86 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
int volatile   xferfd  =    (int volatile   )-1;
#line 88 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
unsigned int maxip  ;
#line 91 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
signed char standalone  ;
#line 93 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
signed char epsv_all  ;
#line 94 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
double maxdiskusagepct  ;
#line 95 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
signed char disallow_passive  ;
#line 96 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
mode_t u_mask  =    (mode_t )91;
#line 97 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
mode_t u_mask_d  =    (mode_t )18;
#line 98 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
signed char state_needs_update  =    (signed char)1;
#line 99 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
signed char no_syslog  ;
#line 100 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
int syslog_facility  =    11 << 3;
#line 101 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
signed char autorename  ;
#line 102 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
signed char anon_noupload  ;
#line 103 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
signed char nochmod  ;
#line 104 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
signed char keepallfiles  ;
#line 107 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
signed char modern_listings  ;
#line 111 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
signed char daemonize  ;
#line 127 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
signed char create_home  ;
#line 128 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
signed char disallow_rename  ;
#line 129 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
signed char no_truncate  ;
#line 131 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
size_t page_size  ;
#line 132 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
int log_pid  ;
#line 147 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
char const   *months[12]  = 
#line 147
  {      "Jan",      "Feb",      "Mar",      "Apr", 
        "May",      "Jun",      "Jul",      "Aug", 
        "Sep",      "Oct",      "Nov",      "Dec"};
#line 154 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
AuthResult authresult  ;
#line 155 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
time_t session_start_time  ;
#line 158 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
char const   *pid_file  =    "/var/run/pure-ftpd.pid";
#line 161 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
signed char be_customer_proof  ;
#line 170 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
char *atomic_prefix  ;
#line 185 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
void *tls_cnx  ;
#line 186 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
void *tls_data_cnx  ;
#line 194 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/globals.h"
unsigned long cwd_failures  ;
#line 42 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void disablesignals(void) 
{ 
  sigset_t sigs ;
  int tmp ;

  {
  {
#line 46
  sigfillset(& sigs);
#line 47
  tmp = sigprocmask(0, (sigset_t const   */* __restrict  */)(& sigs), (sigset_t */* __restrict  */)(& old_sigmask));
  }
#line 47
  if (tmp < 0) {
    {
#line 48
    _EXIT((int const   )1);
    }
  }
#line 50
  return;
}
}
#line 52 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static void enablesignals(void) 
{ 
  int tmp ;

  {
  {
#line 54
  tmp = sigprocmask(2, (sigset_t const   */* __restrict  */)(& old_sigmask), (sigset_t */* __restrict  */)((void *)0));
  }
#line 54
  if (tmp < 0) {
    {
#line 55
    _EXIT((int const   )1);
    }
  }
#line 57
  return;
}
}
#line 59 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void usleep2(unsigned long const   microsec ) 
{ 


  {
  {
#line 61
  disablesignals();
#line 62
  usleep((__useconds_t )microsec);
#line 63
  enablesignals();
  }
#line 64
  return;
}
}
#line 89 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static ssize_t safe_nonblock_write(int const   fd , void * const  tls_fd , void const   *buf_ ,
                                   size_t count___1 ) 
{ 
  ssize_t written ;
  char const   *buf___1 ;
  struct pollfd pfd ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 93
  buf___1 = (char const   *)buf_;
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if (! (count___1 > 0UL)) {
#line 96
      goto while_break;
    }
    {
#line 97
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 98
      if ((unsigned long )tls_fd == (unsigned long )((void *)0)) {
        {
#line 99
        written = write((int )fd, (void const   *)buf___1, count___1);
        }
      } else {
        {
#line 107
        abort();
        }
      }
#line 110
      if (written > 0L) {
#line 111
        goto while_break___0;
      }
      {
#line 113
      tmp___2 = __errno_location();
      }
#line 113
      if (*tmp___2 == 11) {
#line 113
        goto _L;
      } else {
        {
#line 113
        tmp___3 = __errno_location();
        }
#line 113
        if (*tmp___3 == 11) {
          _L: /* CIL Label */ 
          {
#line 114
          pfd.fd = (int )fd;
#line 115
          pfd.events = (short)28;
#line 116
          pfd.revents = (short)0;
#line 117
          tmp___0 = poll(& pfd, (nfds_t )1U, (int )(idletime * 1000UL));
          }
#line 117
          if (tmp___0 <= 0) {
            {
#line 120
            tmp = __errno_location();
#line 120
            *tmp = 32;
            }
#line 121
            return ((ssize_t )-1);
          } else
#line 117
          if (((int )pfd.revents & 24) != 0) {
            {
#line 120
            tmp = __errno_location();
#line 120
            *tmp = 32;
            }
#line 121
            return ((ssize_t )-1);
          } else
#line 117
          if (((int )pfd.revents & 4) == 0) {
            {
#line 120
            tmp = __errno_location();
#line 120
            *tmp = 32;
            }
#line 121
            return ((ssize_t )-1);
          }
        } else {
          {
#line 123
          tmp___1 = __errno_location();
          }
#line 123
          if (*tmp___1 != 4) {
#line 124
            return ((ssize_t )-1);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 127
    buf___1 += written;
#line 128
    count___1 -= (size_t )written;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  return ((ssize_t )0);
}
}
#line 133 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static void overlapcpy(char *d , char const   *s___0 ) 
{ 
  char *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! ((int const   )*s___0 != 0)) {
#line 135
      goto while_break;
    }
#line 136
    tmp = d;
#line 136
    d ++;
#line 136
    tmp___0 = s___0;
#line 136
    s___0 ++;
#line 136
    *tmp = (char )*tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 138
  *d = (char)0;
#line 139
  return;
}
}
#line 141 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static void safe_fd_set(int const   fd , fd_set * const  fds ) 
{ 


  {
#line 143
  if (fd == -1) {
#line 144
    return;
  }
#line 146
  fds->fds_bits[fd / (int const   )(8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (int const   )(8 * (int )sizeof(__fd_mask ));
#line 147
  return;
}
}
#line 149 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static int safe_fd_isset(int const   fd , fd_set const   * const  fds ) 
{ 


  {
#line 151
  if (fd == -1) {
#line 152
    return (0);
  }
#line 154
  return ((fds->fds_bits[fd / (int const   )(8 * (int )sizeof(__fd_mask ))] & (1L << fd % (int const   )(8 * (int )sizeof(__fd_mask )))) != 0L);
}
}
#line 157 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static int init_tz___0(void) 
{ 
  char stbuf[10] ;
  struct tm *tm ;
  time_t now ;
  time_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 161
  tmp = time((time_t *)((void *)0));
#line 161
  now = tmp;
#line 164
  tzset();
#line 167
  tm = localtime((time_t const   *)(& now));
  }
#line 167
  if ((unsigned long )tm != (unsigned long )((void *)0)) {
    {
#line 167
    tmp___1 = strftime((char */* __restrict  */)(stbuf), sizeof(stbuf), (char const   */* __restrict  */)"%z",
                       (struct tm  const  */* __restrict  */)tm);
    }
#line 167
    if (tmp___1 == 5UL) {
#line 169
      if ((int )stbuf[0] == 45) {
#line 169
        tmp___0 = '+';
      } else {
#line 169
        tmp___0 = '-';
      }
      {
#line 169
      snprintf((char */* __restrict  */)(default_tz_for_putenv), sizeof(default_tz_for_putenv),
               (char const   */* __restrict  */)"TZ=UTC%c%c%c:%c%c", tmp___0, (int )stbuf[1],
               (int )stbuf[2], (int )stbuf[3], (int )stbuf[4]);
      }
    }
  }
  {
#line 173
  putenv(default_tz_for_putenv);
#line 175
  localtime((time_t const   *)(& now));
#line 176
  gmtime((time_t const   *)(& now));
  }
#line 178
  return (0);
}
}
#line 181 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void simplify(char *subdir ) 
{ 
  char *a ;
  int tmp ;
  int tmp___0 ;
  char *nextcomponent ;
  size_t tmp___1 ;

  {
#line 185
  if ((unsigned long )subdir == (unsigned long )((void *)0)) {
#line 186
    return;
  } else
#line 185
  if ((int )*subdir == 0) {
#line 186
    return;
  }
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 188
    a = strstr((char const   *)subdir, "//");
    }
#line 188
    if (! ((unsigned long )a != (unsigned long )((void *)0))) {
#line 188
      goto while_break;
    }
    {
#line 189
    overlapcpy(a, (char const   *)(a + 1));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 191
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 191
    a = strstr((char const   *)subdir, "/./");
    }
#line 191
    if (! ((unsigned long )a != (unsigned long )((void *)0))) {
#line 191
      goto while_break___0;
    }
    {
#line 192
    overlapcpy(a, (char const   *)(a + 2));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 194
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 194
    tmp = strncmp((char const   *)subdir, "../", (size_t )3);
    }
#line 194
    if (! (tmp == 0)) {
#line 194
      goto while_break___1;
    }
#line 195
    subdir += 3;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 197
  a = strstr((char const   *)subdir, "/../");
  }
#line 198
  if ((unsigned long )a != (unsigned long )((void *)0)) {
#line 199
    if ((unsigned long )a == (unsigned long )subdir) {
      {
#line 200
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 200
        tmp___0 = strncmp((char const   *)subdir, "/../", (size_t )4);
        }
#line 200
        if (! (tmp___0 == 0)) {
#line 200
          goto while_break___2;
        }
        {
#line 201
        overlapcpy(subdir, (char const   *)(subdir + 3));
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 203
      a = strstr((char const   *)subdir, "/../");
      }
    }
    {
#line 205
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 205
      if (! ((unsigned long )a != (unsigned long )((void *)0))) {
#line 205
        goto while_break___3;
      }
#line 206
      nextcomponent = a + 4;
#line 207
      if ((unsigned long )a != (unsigned long )subdir) {
#line 207
        if ((int )*a == 47) {
#line 208
          a --;
        }
      }
      {
#line 210
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 210
        if ((unsigned long )a != (unsigned long )subdir) {
#line 210
          if (! ((int )*a != 47)) {
#line 210
            goto while_break___4;
          }
        } else {
#line 210
          goto while_break___4;
        }
#line 211
        a --;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 213
      if ((int )*a == 47) {
#line 214
        a ++;
      }
      {
#line 216
      overlapcpy(a, (char const   *)nextcomponent);
#line 217
      a = strstr((char const   *)subdir, "/../");
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 220
  a = subdir;
#line 221
  if ((int )*a == 46) {
#line 222
    a ++;
#line 223
    if ((int )*a == 0) {
#line 224
      return;
    }
#line 226
    if ((int )*a == 47) {
      {
#line 227
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 227
        if (! ((int )*a == 47)) {
#line 227
          goto while_break___5;
        }
#line 228
        a ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 230
      overlapcpy(subdir, (char const   *)a);
      }
    }
  }
#line 233
  if ((int )*a == 0) {
#line 234
    return;
  }
  {
#line 236
  tmp___1 = strlen((char const   *)subdir);
#line 236
  a = (subdir + tmp___1) - 1UL;
  }
#line 237
  if ((int )*a != 46) {
#line 238
    return;
  } else
#line 237
  if ((unsigned long )a == (unsigned long )subdir) {
#line 238
    return;
  }
#line 240
  a --;
#line 241
  if ((int )*a == 47) {
#line 242
    *(a + 1) = (char)0;
#line 243
    return;
  } else
#line 241
  if ((unsigned long )a == (unsigned long )subdir) {
#line 242
    *(a + 1) = (char)0;
#line 243
    return;
  }
#line 245
  if ((int )*a != 46) {
#line 246
    return;
  } else
#line 245
  if ((unsigned long )a == (unsigned long )subdir) {
#line 246
    return;
  }
#line 248
  a --;
#line 249
  if ((int )*a != 47) {
#line 250
    return;
  }
  {
#line 252
  *a = (char)0;
#line 253
  a = strrchr((char const   *)subdir, '/');
  }
#line 253
  if ((unsigned long )a == (unsigned long )((void *)0)) {
#line 254
    *subdir = (char )'/';
#line 255
    *(subdir + 1) = (char)0;
#line 256
    return;
  }
#line 258
  *(a + 1) = (char)0;
#line 259
  return;
}
}
#line 261 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
int checkprintable(char const   *s___0 ) 
{ 
  int ret ;
  unsigned char c ;

  {
#line 263
  ret = 0;
  {
#line 266
  while (1) {
    while_continue: /* CIL Label */ ;
#line 266
    c = (unsigned char )*s___0;
#line 266
    if (! ((unsigned int )c != 0U)) {
#line 266
      goto while_break;
    }
#line 267
    if ((int )c == 127) {
#line 268
      ret --;
#line 269
      goto while_break;
    } else
#line 267
    if ((unsigned int )c < 32U) {
#line 268
      ret --;
#line 269
      goto while_break;
    }
#line 271
    s___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 274
  return (ret);
}
}
#line 277 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
char *skip_telnet_controls(char const   *str ) 
{ 


  {
#line 279
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 280
    return ((char *)((void *)0));
  }
  {
#line 282
  while (1) {
    while_continue: /* CIL Label */ ;
#line 282
    if ((int const   )*str != 0) {
#line 282
      if (! ((unsigned int )((unsigned char )*str) >= 240U)) {
#line 282
        goto while_break;
      }
    } else {
#line 282
      goto while_break;
    }
#line 283
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 285
  return ((char *)str);
}
}
#line 288
 __attribute__((__noreturn__)) void _EXIT(int const   status ) ;
#line 288 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void _EXIT(int const   status ) 
{ 


  {
  {
#line 290
  delete_atomic_file();
#line 294
  _exit((int )status);
  }
}
}
#line 297 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static char replybuf[16584UL]  ;
#line 298 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static char *replybuf_pos  =    replybuf;
#line 299 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static size_t replybuf_left  ;
#line 301 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static void client_init_reply_buf(void) 
{ 


  {
#line 303
  replybuf_pos = replybuf;
#line 304
  replybuf_left = sizeof(replybuf) - 1UL;
#line 305
  return;
}
}
#line 307 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void client_fflush(void) 
{ 


  {
#line 309
  if ((unsigned long )replybuf_pos == (unsigned long )(replybuf)) {
#line 310
    return;
  }
  {
#line 312
  safe_write((int const   )clientfd, (void const   */* const  */)(replybuf), (size_t )(replybuf_pos - replybuf),
             (int const   )-1);
#line 313
  client_init_reply_buf();
  }
#line 314
  return;
}
}
#line 316 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void ( /* format attribute */  client_printf)(char const   * const  format  , ...) 
{ 
  va_list va ;
  char buf___1[4146UL] ;
  size_t len ;
  int vlen ;

  {
  {
#line 323
  __builtin_va_start(va, format);
#line 324
  vlen = vsnprintf((char */* __restrict  */)(buf___1), sizeof(buf___1), (char const   */* __restrict  */)format,
                   va);
  }
#line 325
  if (vlen < 0) {
    {
#line 326
    buf___1[4145UL] = (char)0;
#line 327
    len = strlen((char const   *)(buf___1));
    }
  } else
#line 325
  if ((size_t )vlen >= sizeof(buf___1)) {
    {
#line 326
    buf___1[4145UL] = (char)0;
#line 327
    len = strlen((char const   *)(buf___1));
    }
  } else {
#line 329
    len = (size_t )vlen;
  }
#line 331
  if (len >= replybuf_left) {
    {
#line 332
    client_fflush();
    }
  }
#line 334
  if (len > replybuf_left) {
    {
#line 335
    abort();
    }
  }
  {
#line 337
  memcpy((void */* __restrict  */)replybuf_pos, (void const   */* __restrict  */)(buf___1),
         len);
#line 338
  replybuf_pos += len;
#line 339
  replybuf_left -= len;
#line 341
  __builtin_va_end(va);
  }
#line 342
  return;
}
}
#line 344
 __attribute__((__noreturn__)) void ( /* format attribute */  die)(int const   err ,
                                                                   int const   priority ,
                                                                   char const   * const  format 
                                                                   , ...) ;
#line 344 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void ( /* format attribute */  die)(int const   err , int const   priority , char const   * const  format 
                                    , ...) 
{ 
  va_list va ;
  char line___1[4608U] ;

  {
  {
#line 349
  disablesignals();
#line 350
  __builtin_va_start(va, format);
#line 351
  vsnprintf((char */* __restrict  */)(line___1), sizeof(line___1), (char const   */* __restrict  */)format,
            va);
#line 352
  __builtin_va_end(va);
#line 361
  client_printf((char const   */* const  */)"%d %s\r\n", err, line___1);
#line 362
  client_fflush();
#line 364
  logfile(priority, "%s", line___1);
#line 365
  _EXIT(- priority - 1);
  }
}
}
#line 368
 __attribute__((__noreturn__)) void die_mem(void) ;
#line 368 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void die_mem(void) 
{ 


  {
  {
#line 370
  die((int const   )421, (int const   )3, (char const   */* const  */)"Out of memory");
  }
}
}
#line 373 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static void sigalarm(int sig ) 
{ 


  {
  {
#line 376
  disablesignals();
#line 377
  die((int const   )421, (int const   )6, (char const   */* const  */)"Timeout");
  }
}
}
#line 381 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static void sigchild(int sig ) 
{ 
  int olderrno ;
  int *tmp ;
  pid_t pid ;
  int *tmp___0 ;

  {
  {
#line 383
  tmp = __errno_location();
#line 383
  olderrno = *tmp;
  }
  {
#line 388
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 388
    pid = waitpid(-1, (int *)((void *)0), 1);
    }
#line 388
    if (! (pid > 0)) {
#line 388
      goto while_break;
    }
#line 389
    if (nb_children > (unsigned int volatile   )0U) {
#line 390
      nb_children -= (unsigned int volatile   )1;
    }
    {
#line 395
    iptrack_delete_pid((pid_t const   )pid);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 408
  tmp___0 = __errno_location();
#line 408
  *tmp___0 = olderrno;
  }
#line 409
  return;
}
}
#line 412 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static void sigterm_client(int sig ) 
{ 


  {
  {
#line 416
  disablesignals();
#line 417
  _EXIT((int const   )0);
  }
}
}
#line 421 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static void sigterm(int sig ) 
{ 
  int olderrno ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 423
  tmp = __errno_location();
#line 423
  olderrno = *tmp;
#line 426
  stop_server = (sig_atomic_t volatile   )1;
  }
#line 427
  if (listenfd != (int volatile   )-1) {
    {
#line 428
    shutdown((int )listenfd, 2);
#line 429
    close((int )listenfd);
    }
  }
#line 431
  if (listenfd6 != (int volatile   )-1) {
    {
#line 432
    shutdown((int )listenfd6, 2);
#line 433
    close((int )listenfd6);
    }
  }
  {
#line 435
  tmp___0 = __errno_location();
#line 435
  *tmp___0 = olderrno;
  }
#line 436
  return;
}
}
#line 438 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static void set_cloexec_flag(int const   fd ) 
{ 


  {
  {
#line 440
  fcntl((int )fd, 2, 1);
  }
#line 441
  return;
}
}
#line 444 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static void clearargs(int argc , char **argv ) 
{ 
  int i ;
  char *first ;
  char *next ;
  size_t tmp ;
  size_t tmp___0 ;
  char **new_environ ;
  unsigned int env_nb ;
  void *tmp___1 ;

  {
#line 449
  first = (char *)((void *)0);
#line 450
  next = (char *)((void *)0);
#line 452
  i = 0;
  {
#line 452
  while (1) {
    while_continue: /* CIL Label */ ;
#line 452
    if (! (i < argc)) {
#line 452
      goto while_break;
    }
#line 453
    if ((unsigned long )first == (unsigned long )((void *)0)) {
#line 454
      first = *(argv + i);
    }
#line 456
    if ((unsigned long )next == (unsigned long )((void *)0)) {
      {
#line 457
      tmp = strlen((char const   *)*(argv + i));
#line 457
      next = *(argv + i) + tmp;
      }
    } else
#line 456
    if ((unsigned long )*(argv + i) == (unsigned long )(next + 1)) {
      {
#line 457
      tmp = strlen((char const   *)*(argv + i));
#line 457
      next = *(argv + i) + tmp;
      }
    }
#line 452
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 460
  i = 0;
  {
#line 460
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 460
    if (! ((unsigned long )*(environ + i) != (unsigned long )((void *)0))) {
#line 460
      goto while_break___0;
    }
#line 461
    if ((unsigned long )first == (unsigned long )((void *)0)) {
#line 462
      first = *(argv + i);
    }
#line 464
    if ((unsigned long )next == (unsigned long )((void *)0)) {
      {
#line 465
      tmp___0 = strlen((char const   *)*(argv + i));
#line 465
      next = *(argv + i) + tmp___0;
      }
    } else
#line 464
    if ((unsigned long )*(argv + i) == (unsigned long )(next + 1)) {
      {
#line 465
      tmp___0 = strlen((char const   *)*(argv + i));
#line 465
      next = *(argv + i) + tmp___0;
      }
    }
#line 460
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 468
  if ((unsigned long )first == (unsigned long )((void *)0)) {
#line 469
    return;
  } else
#line 468
  if ((unsigned long )next == (unsigned long )((void *)0)) {
#line 469
    return;
  }
#line 471
  argv_lth = (size_t )(next - first);
#line 472
  argv0 = argv;
#line 473
  if ((unsigned long )environ != (unsigned long )((void *)0)) {
#line 475
    env_nb = 0U;
    {
#line 477
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 477
      if (! ((unsigned long )*(environ + env_nb) != (unsigned long )((void *)0))) {
#line 477
        goto while_break___1;
      }
#line 478
      env_nb ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 480
    tmp___1 = malloc((unsigned long )(1U + env_nb) * sizeof(char *));
#line 480
    new_environ = (char **)tmp___1;
    }
#line 480
    if ((unsigned long )new_environ == (unsigned long )((void *)0)) {
      {
#line 481
      abort();
      }
    }
#line 483
    *(new_environ + env_nb) = (char *)((void *)0);
    {
#line 484
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 484
      if (! (env_nb > 0U)) {
#line 484
        goto while_break___2;
      }
      {
#line 485
      env_nb --;
#line 486
      *(new_environ + env_nb) = strdup((char const   *)*(environ + env_nb));
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 488
    environ = new_environ;
  }
#line 495
  return;
}
}
#line 497 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void setprocessname(char const   * const  title ) 
{ 
  size_t tmp ;

  {
#line 503
  if ((unsigned long )argv0 != (unsigned long )((void *)0)) {
    {
#line 503
    tmp = strlen((char const   *)title);
    }
#line 503
    if (argv_lth > tmp - 2UL) {
      {
#line 504
      memset((void *)*(argv0 + 0), 0, argv_lth);
#line 505
      strncpy((char */* __restrict  */)*(argv0 + 0), (char const   */* __restrict  */)title,
              argv_lth - 2UL);
#line 506
      *(argv0 + 1) = (char *)((void *)0);
      }
    }
  }
#line 516
  return;
}
}
#line 523 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static int checkvalidaddr(struct sockaddr_storage  const  * const  addr ) 
{ 
  struct in6_addr *tmp ;
  struct in6_addr  const  *__a ;
  struct in6_addr *tmp___0 ;
  int tmp___1 ;
  struct in_addr *tmp___2 ;
  uint32_t tmp___3 ;
  struct in_addr *tmp___4 ;
  uint32_t tmp___5 ;
  struct in_addr *tmp___6 ;
  uint32_t tmp___7 ;
  struct in_addr *tmp___8 ;
  uint32_t tmp___9 ;
  struct in_addr *tmp___10 ;
  uint32_t tmp___11 ;

  {
#line 525
  if ((unsigned long )addr == (unsigned long )((void *)0)) {
#line 526
    return (0);
  }
#line 532
  if ((int const   )addr->ss_family == 10) {
    {
#line 533
    tmp = storage_sin_addr6((struct sockaddr_storage  const  */* const  */)addr);
    }
#line 534
    if ((int const   )*((uint8_t const   *)tmp + 0) == 255) {
#line 535
      return (0);
    } else {
      {
#line 534
      tmp___0 = storage_sin_addr6((struct sockaddr_storage  const  */* const  */)addr);
#line 534
      __a = (struct in6_addr  const  *)tmp___0;
      }
#line 534
      if (__a->__in6_u.__u6_addr32[0] == 0U) {
#line 534
        if (__a->__in6_u.__u6_addr32[1] == 0U) {
#line 534
          if (__a->__in6_u.__u6_addr32[2] == 0U) {
#line 534
            if (__a->__in6_u.__u6_addr32[3] == 0U) {
#line 534
              tmp___1 = 1;
            } else {
#line 534
              tmp___1 = 0;
            }
          } else {
#line 534
            tmp___1 = 0;
          }
        } else {
#line 534
          tmp___1 = 0;
        }
      } else {
#line 534
        tmp___1 = 0;
      }
#line 534
      if (tmp___1) {
#line 535
        return (0);
      }
    }
#line 537
    return (1);
  } else
#line 538
  if ((int const   )addr->ss_family == 2) {
    {
#line 539
    tmp___2 = storage_sin_addr((struct sockaddr_storage  const  */* const  */)addr);
#line 539
    tmp___3 = ntohl(tmp___2->s_addr);
    }
#line 539
    if (tmp___3 == 0U) {
#line 544
      return (0);
    } else {
      {
#line 539
      tmp___4 = storage_sin_addr((struct sockaddr_storage  const  */* const  */)addr);
#line 539
      tmp___5 = ntohl(tmp___4->s_addr);
      }
#line 539
      if (tmp___5 == 4294967295U) {
#line 544
        return (0);
      } else {
        {
#line 539
        tmp___6 = storage_sin_addr((struct sockaddr_storage  const  */* const  */)addr);
#line 539
        tmp___7 = ntohl(tmp___6->s_addr);
        }
#line 539
        if (tmp___7 == 4294967295U) {
#line 544
          return (0);
        } else {
          {
#line 539
          tmp___8 = storage_sin_addr((struct sockaddr_storage  const  */* const  */)addr);
#line 539
          tmp___9 = ntohl(tmp___8->s_addr);
          }
#line 539
          if ((tmp___9 & 4026531840U) == 3758096384U) {
#line 544
            return (0);
          } else {
            {
#line 539
            tmp___10 = storage_sin_addr((struct sockaddr_storage  const  */* const  */)addr);
#line 539
            tmp___11 = ntohl(tmp___10->s_addr);
            }
#line 539
            if ((tmp___11 & 4026531840U) == 4026531840U) {
#line 544
              return (0);
            }
          }
        }
      }
    }
#line 546
    return (1);
  }
#line 548
  return (0);
}
}
#line 553 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static void fourinsix(struct sockaddr_storage *v6 ) 
{ 
  struct sockaddr_storage v4 ;
  struct in6_addr  const  *__a ;
  struct in6_addr *tmp ;
  uint32_t tmp___0 ;
  int tmp___1 ;
  struct in_addr *tmp___2 ;
  struct in6_addr *tmp___3 ;
  struct in_addr *tmp___4 ;
  in_port_t *tmp___5 ;
  in_port_t *tmp___6 ;

  {
#line 558
  if ((int )v6ready == 0) {
#line 559
    return;
  } else
#line 558
  if ((int )v6->ss_family != 10) {
#line 559
    return;
  } else {
    {
#line 558
    tmp = storage_sin_addr6((struct sockaddr_storage  const  */* const  */)v6);
#line 558
    __a = (struct in6_addr  const  *)tmp;
    }
#line 558
    if (__a->__in6_u.__u6_addr32[0] == 0U) {
#line 558
      if (__a->__in6_u.__u6_addr32[1] == 0U) {
        {
#line 558
        tmp___0 = htonl((uint32_t )65535);
        }
#line 558
        if (__a->__in6_u.__u6_addr32[2] == tmp___0) {
#line 558
          tmp___1 = 1;
        } else {
#line 558
          tmp___1 = 0;
        }
      } else {
#line 558
        tmp___1 = 0;
      }
    } else {
#line 558
      tmp___1 = 0;
    }
#line 558
    if (tmp___1 == 0) {
#line 559
      return;
    }
  }
  {
#line 561
  memset((void *)(& v4), 0, sizeof(v4));
#line 562
  v4.ss_family = (sa_family_t )2;
#line 563
  tmp___3 = storage_sin_addr6((struct sockaddr_storage  const  */* const  */)v6);
#line 563
  tmp___4 = storage_sin_addr((struct sockaddr_storage  const  */* const  */)(& v4));
#line 563
  memcpy((void */* __restrict  */)(& tmp___4->s_addr), (void const   */* __restrict  */)((unsigned char *)(& tmp___3->__in6_u.__u6_addr8) + 12),
         sizeof(tmp___2->s_addr));
#line 566
  tmp___5 = storage_port((struct sockaddr_storage  const  */* const  */)(& v4));
#line 566
  tmp___6 = storage_port6((struct sockaddr_storage  const  */* const  */)v6);
#line 566
  *tmp___5 = *tmp___6;
#line 568
  *v6 = v4;
  }
#line 569
  return;
}
}
#line 573 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static int addrcmp(struct sockaddr_storage  const  * const  s1 , struct sockaddr_storage  const  * const  s2 ) 
{ 
  struct in6_addr  const  *__a ;
  struct in6_addr *tmp ;
  struct in6_addr  const  *__b ;
  struct in6_addr *tmp___0 ;
  int tmp___1 ;
  struct in_addr *tmp___2 ;
  struct in_addr *tmp___3 ;

  {
#line 576
  if ((int const   )s1->ss_family == 10) {
#line 577
    if ((int const   )s2->ss_family != 10) {
#line 578
      return (1);
    }
    {
#line 580
    tmp = storage_sin_addr6((struct sockaddr_storage  const  */* const  */)s1);
#line 580
    __a = (struct in6_addr  const  *)tmp;
#line 580
    tmp___0 = storage_sin_addr6((struct sockaddr_storage  const  */* const  */)s2);
#line 580
    __b = (struct in6_addr  const  *)tmp___0;
    }
#line 580
    if (__a->__in6_u.__u6_addr32[0] == __b->__in6_u.__u6_addr32[0]) {
#line 580
      if (__a->__in6_u.__u6_addr32[1] == __b->__in6_u.__u6_addr32[1]) {
#line 580
        if (__a->__in6_u.__u6_addr32[2] == __b->__in6_u.__u6_addr32[2]) {
#line 580
          if (__a->__in6_u.__u6_addr32[3] == __b->__in6_u.__u6_addr32[3]) {
#line 580
            tmp___1 = 1;
          } else {
#line 580
            tmp___1 = 0;
          }
        } else {
#line 580
          tmp___1 = 0;
        }
      } else {
#line 580
        tmp___1 = 0;
      }
    } else {
#line 580
      tmp___1 = 0;
    }
#line 580
    if (tmp___1) {
#line 581
      return (0);
    } else {
#line 583
      return (1);
    }
  } else
#line 585
  if ((int const   )s1->ss_family == 2) {
#line 586
    if ((int const   )s2->ss_family != 2) {
#line 587
      return (1);
    }
    {
#line 589
    tmp___2 = storage_sin_addr((struct sockaddr_storage  const  */* const  */)s1);
#line 589
    tmp___3 = storage_sin_addr((struct sockaddr_storage  const  */* const  */)s2);
    }
#line 589
    if (tmp___2->s_addr == tmp___3->s_addr) {
#line 590
      return (0);
    } else {
#line 592
      return (1);
    }
  }
#line 595
  return (-1);
}
}
#line 598 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static int generic_aton(char const   *src , struct sockaddr_storage *a ) 
{ 
  struct in6_addr *tmp ;
  int tmp___0 ;
  struct in_addr *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 600
  tmp = storage_sin_addr6((struct sockaddr_storage  const  */* const  */)a);
#line 600
  tmp___0 = inet_pton(10, (char const   */* __restrict  */)src, (void */* __restrict  */)(& tmp->__in6_u.__u6_addr8));
  }
#line 600
  if (tmp___0 > 0) {
#line 601
    a->ss_family = (sa_family_t )10;
#line 602
    return (0);
  }
  {
#line 604
  tmp___1 = storage_sin_addr((struct sockaddr_storage  const  */* const  */)a);
#line 604
  tmp___2 = inet_pton(2, (char const   */* __restrict  */)src, (void */* __restrict  */)(& tmp___1->s_addr));
  }
#line 604
  if (tmp___2 > 0) {
#line 605
    a->ss_family = (sa_family_t )2;
#line 606
    return (0);
  }
  {
#line 608
  memset((void *)a, 0, sizeof(*a));
  }
#line 610
  return (-1);
}
}
#line 613 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void ( /* format attribute */  logfile)(int const   crit , char const   *format  , ...) 
{ 
  char const   *urgency ;
  va_list va ;
  char line___1[4608U] ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 623
  if ((int )no_syslog != 0) {
#line 624
    return;
  }
  {
#line 626
  __builtin_va_start(va, format);
#line 627
  vsnprintf((char */* __restrict  */)(line___1), sizeof(line___1), (char const   */* __restrict  */)format,
            va);
#line 628
  __builtin_va_end(va);
  }
  {
#line 630
  if (crit == 6) {
#line 630
    goto case_6;
  }
#line 633
  if (crit == 4) {
#line 633
    goto case_4;
  }
#line 636
  if (crit == 3) {
#line 636
    goto case_3;
  }
#line 639
  if (crit == 5) {
#line 639
    goto case_5;
  }
#line 642
  if (crit == 7) {
#line 642
    goto case_7;
  }
#line 645
  goto switch_default;
  case_6: /* CIL Label */ 
#line 631
  urgency = "[INFO] ";
#line 632
  goto switch_break;
  case_4: /* CIL Label */ 
#line 634
  urgency = "[WARNING] ";
#line 635
  goto switch_break;
  case_3: /* CIL Label */ 
#line 637
  urgency = "[ERROR] ";
#line 638
  goto switch_break;
  case_5: /* CIL Label */ 
#line 640
  urgency = "[NOTICE] ";
#line 641
  goto switch_break;
  case_7: /* CIL Label */ 
#line 643
  urgency = "[DEBUG] ";
#line 644
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 646
  urgency = "";
  switch_break: /* CIL Label */ ;
  }
#line 651
  if ((int )host[0] != 0) {
#line 651
    tmp = (char const   *)(host);
  } else {
#line 651
    tmp = "?";
  }
#line 651
  if ((int )loggedin != 0) {
#line 651
    if ((int )account[0] != 0) {
#line 651
      tmp___0 = (char const   *)(account);
    } else {
#line 651
      tmp___0 = "?";
    }
  } else {
#line 651
    tmp___0 = "?";
  }
  {
#line 651
  syslog((int )crit, "(%s@%s) %s%s", tmp___0, tmp, urgency, line___1);
  }
#line 659
  return;
}
}
#line 667 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static unsigned int open_max(void) 
{ 
  long z ;
  long tmp ;

  {
  {
#line 671
  tmp = sysconf(4);
#line 671
  z = tmp;
  }
#line 671
  if (z < 0L) {
    {
#line 672
    perror("_SC_OPEN_MAX");
#line 673
    _EXIT((int const   )1);
    }
  }
#line 675
  return ((unsigned int )z);
}
}
#line 712 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static void addreply_newline(char const   * const  str , size_t const   size ) 
{ 
  struct reply *newline ;
  void *tmp ;

  {
  {
#line 716
  tmp = malloc((unsigned long )(& ((struct reply *)0)->line) + (unsigned long )size);
#line 716
  newline = (struct reply *)tmp;
  }
#line 716
  if ((unsigned long )newline == (unsigned long )((void *)0)) {
    {
#line 718
    die_mem();
    }
  }
#line 720
  if ((unsigned long )firstreply == (unsigned long )((void *)0)) {
#line 721
    firstreply = newline;
  } else {
#line 723
    lastreply->next = newline;
  }
  {
#line 725
  newline->next = (struct reply *)((void *)0);
#line 726
  lastreply = newline;
#line 727
  memcpy((void */* __restrict  */)(newline->line), (void const   */* __restrict  */)str,
         (size_t )size);
  }
#line 728
  return;
}
}
#line 730 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void addreply_noformat(int const   code , char const   * const  line___1 ) 
{ 
  size_t tmp ;

  {
#line 732
  if (code != 0) {
#line 733
    replycode = (int )code;
  }
  {
#line 735
  tmp = strlen((char const   *)line___1);
#line 735
  addreply_newline(line___1, (size_t const   )(tmp + 1UL));
  }
#line 736
  return;
}
}
#line 738 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void ( /* format attribute */  addreply)(int const   code , char const   * const  line___1 
                                         , ...) 
{ 
  char *a ;
  char *b ;
  va_list ap ;
  int last ;
  char buf___1[4146UL] ;

  {
#line 746
  if (code != 0) {
#line 747
    replycode = (int )code;
  }
  {
#line 749
  __builtin_va_start(ap, line___1);
#line 750
  vsnprintf((char */* __restrict  */)(buf___1), sizeof(buf___1), (char const   */* __restrict  */)line___1,
            ap);
#line 751
  __builtin_va_end(ap);
#line 752
  last = 0;
#line 753
  a = buf___1;
  }
  {
#line 754
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 755
    b = strchr((char const   *)a, '\n');
    }
#line 756
    if ((unsigned long )b != (unsigned long )((void *)0)) {
#line 757
      *b = (char)0;
    } else {
#line 759
      b = a;
      {
#line 760
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 760
        if (! ((int )*b != 0)) {
#line 760
          goto while_break___0;
        }
#line 761
        b ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 763
      last ++;
    }
    {
#line 765
    addreply_newline((char const   */* const  */)a, (size_t const   )((size_t )(b - a) + 1UL));
    }
#line 766
    if (last != 0) {
#line 767
      goto while_break;
    }
#line 769
    a = b + 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 771
  return;
}
}
#line 773 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void doreply(void) 
{ 
  struct reply *scannedentry ;
  struct reply *nextentry ;
  int tmp ;
  int tmp___0 ;

  {
#line 778
  scannedentry = firstreply;
#line 778
  if ((unsigned long )scannedentry == (unsigned long )((void *)0)) {
#line 779
    return;
  }
  {
#line 781
  while (1) {
    while_continue: /* CIL Label */ ;
#line 782
    nextentry = scannedentry->next;
#line 793
    if ((unsigned long )nextentry == (unsigned long )((void *)0)) {
#line 793
      tmp = ' ';
    } else {
#line 793
      tmp = '-';
    }
    {
#line 793
    client_printf((char const   */* const  */)"%3d%c%s\r\n", replycode, tmp, scannedentry->line);
    }
#line 797
    if ((int volatile   )logging > (int volatile   )1) {
#line 798
      if ((unsigned long )nextentry == (unsigned long )((void *)0)) {
#line 798
        tmp___0 = ' ';
      } else {
#line 798
        tmp___0 = '-';
      }
      {
#line 798
      logfile((int const   )7, "%3d%c%s", replycode, tmp___0, scannedentry->line);
      }
    }
#line 781
    scannedentry = nextentry;
#line 781
    if (! ((unsigned long )scannedentry != (unsigned long )((void *)0))) {
#line 781
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 802
  client_fflush();
#line 803
  scannedentry = firstreply;
  }
  {
#line 804
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 805
    nextentry = scannedentry->next;
#line 806
    free((void *)scannedentry);
#line 804
    scannedentry = nextentry;
    }
#line 804
    if (! ((unsigned long )scannedentry != (unsigned long )((void *)0))) {
#line 804
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 808
  lastreply = (struct reply *)((void *)0);
#line 808
  firstreply = lastreply;
#line 809
  return;
}
}
#line 815 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static int checknamesanity(char const   *name___0 , int dot_ok ) 
{ 
  char const   *namepnt ;

  {
#line 826
  if ((unsigned long )name___0 == (unsigned long )((void *)0)) {
#line 827
    return (-1);
  } else
#line 826
  if ((int const   )*name___0 == 0) {
#line 827
    return (-1);
  }
#line 830
  if ((int const   )*(name___0 + 0) == 46) {
#line 830
    if ((int const   )*(name___0 + 1) == 0) {
#line 831
      return (0);
    } else
#line 830
    if ((int const   )*(name___0 + 1) == 46) {
#line 830
      if ((int const   )*(name___0 + 2) == 0) {
#line 831
        return (0);
      }
    }
  }
#line 833
  namepnt = name___0;
  {
#line 852
  while (1) {
    while_continue: /* CIL Label */ ;
#line 852
    if (! ((int const   )*namepnt != 0)) {
#line 852
      goto while_break;
    }
#line 854
    if ((int const   )*namepnt == 127) {
#line 855
      return (-1);
    } else
#line 854
    if ((unsigned int )((unsigned char )*namepnt) < 32U) {
#line 855
      return (-1);
    } else
#line 854
    if ((int const   )*namepnt == 92) {
#line 855
      return (-1);
    }
#line 858
    if (dot_ok == 0) {
#line 859
      if ((int const   )*namepnt == 47) {
#line 860
        namepnt ++;
      } else
#line 861
      if ((unsigned long )namepnt != (unsigned long )name___0) {
#line 862
        namepnt ++;
#line 863
        goto while_continue;
      }
#line 865
      if ((int const   )*(namepnt + 0) == 0) {
#line 866
        return (0);
      }
#line 868
      if ((int const   )*(namepnt + 0) == 46) {
#line 869
        if ((int const   )*(namepnt + 1) == 0) {
#line 870
          return (0);
        }
#line 872
        if ((int const   )*(namepnt + 1) == 46) {
#line 873
          if ((int const   )*(namepnt + 2) == 0) {
#line 874
            return (0);
          }
#line 876
          if ((int const   )*(namepnt + 2) != 47) {
#line 877
            return (-1);
          }
        } else
#line 879
        if ((int const   )*(namepnt + 1) != 47) {
#line 880
          return (-1);
        }
      }
#line 883
      if ((unsigned long )namepnt != (unsigned long )name___0) {
#line 884
        goto while_continue;
      }
    }
#line 887
    namepnt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 889
  return (0);
}
}
#line 892 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static void do_ipv6_port(char *p , char delim ) 
{ 
  char *deb ;
  struct sockaddr_storage a ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 897
  deb = p;
  {
#line 898
  while (1) {
    while_continue: /* CIL Label */ ;
#line 898
    if (*p) {
      {
#line 898
      tmp = strchr("0123456789abcdefABCDEF:", (int )*p);
      }
#line 898
      if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 898
        goto while_break;
      }
    } else {
#line 898
      goto while_break;
    }
#line 899
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 901
  if ((int )*p != (int )delim) {
#line 901
    goto nope;
  } else {
    {
#line 901
    tmp___0 = atoi((char const   *)(p + 1));
    }
#line 901
    if (tmp___0 == 0) {
      nope: 
      {
#line 903
      close(datafd);
#line 904
      datafd = -1;
#line 905
      addreply_noformat((int const   )501, (char const   */* const  */)"Syntax error in IP address");
      }
#line 906
      return;
    }
  }
  {
#line 908
  tmp___1 = p;
#line 908
  p ++;
#line 908
  *tmp___1 = (char)0;
#line 909
  tmp___2 = generic_aton((char const   *)deb, & a);
  }
#line 909
  if (tmp___2 != 0) {
#line 910
    goto nope;
  }
  {
#line 912
  tmp___3 = atoi((char const   *)p);
#line 912
  doport2(a, (unsigned int )tmp___3);
  }
#line 913
  return;
}
}
#line 916 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void doesta(void) 
{ 
  struct sockaddr_storage dataconn ;
  socklen_t socksize ;
  char hbuf[1025] ;
  char pbuf[32] ;
  int tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 923
  if ((int )passive != 0) {
    {
#line 924
    addreply_noformat((int const   )520, (char const   */* const  */)"Active mode is disabled");
    }
#line 925
    return;
  } else
#line 923
  if (datafd == -1) {
    {
#line 924
    addreply_noformat((int const   )520, (char const   */* const  */)"Active mode is disabled");
    }
#line 925
    return;
  }
#line 927
  if (xferfd == (int volatile   )-1) {
    {
#line 928
    opendata();
    }
#line 929
    if (xferfd == (int volatile   )-1) {
      {
#line 930
      addreply_noformat((int const   )425, (char const   */* const  */)"Can\'t create the data socket");
      }
#line 931
      return;
    }
  }
  {
#line 934
  socksize = (socklen_t )sizeof(dataconn);
#line 935
  tmp = getsockname((int )xferfd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& dataconn)),
                    (socklen_t */* __restrict  */)(& socksize));
  }
#line 935
  if (tmp < 0) {
    {
#line 939
    addreply_noformat((int const   )425, (char const   */* const  */)"Unable to identify the local data socket");
#line 940
    closedata();
    }
#line 941
    return;
  } else {
#line 935
    if ((int )dataconn.ss_family == 2) {
#line 935
      tmp___0 = sizeof(struct sockaddr_in );
    } else {
#line 935
      tmp___0 = sizeof(struct sockaddr_in6 );
    }
    {
#line 935
    tmp___1 = getnameinfo((struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& dataconn)),
                          (socklen_t )tmp___0, (char */* __restrict  */)(hbuf), (socklen_t )sizeof(hbuf),
                          (char */* __restrict  */)(pbuf), (socklen_t )sizeof(pbuf),
                          3);
    }
#line 935
    if (tmp___1 != 0) {
      {
#line 939
      addreply_noformat((int const   )425, (char const   */* const  */)"Unable to identify the local data socket");
#line 940
      closedata();
      }
#line 941
      return;
    }
  }
#line 943
  if ((int )dataconn.ss_family == 10) {
#line 943
    tmp___2 = '2';
  } else {
#line 943
    tmp___2 = '1';
  }
  {
#line 943
  addreply((int const   )225, (char const   */* const  */)"Connected from (|%c|%s|%s|)",
           tmp___2, hbuf, pbuf);
  }
#line 945
  return;
}
}
#line 947 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void doestp(void) 
{ 
  struct sockaddr_storage dataconn ;
  socklen_t socksize ;
  char hbuf[1025] ;
  char pbuf[32] ;
  int tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 954
  if ((int )passive == 0) {
    {
#line 955
    addreply_noformat((int const   )520, (char const   */* const  */)"Unable to open a passive connection");
    }
#line 956
    return;
  } else
#line 954
  if (datafd == -1) {
    {
#line 955
    addreply_noformat((int const   )520, (char const   */* const  */)"Unable to open a passive connection");
    }
#line 956
    return;
  }
#line 958
  if (xferfd == (int volatile   )-1) {
    {
#line 959
    opendata();
    }
#line 960
    if (xferfd == (int volatile   )-1) {
      {
#line 961
      addreply_noformat((int const   )425, (char const   */* const  */)"Can\'t create the data socket");
      }
#line 962
      return;
    }
  }
  {
#line 965
  socksize = (socklen_t )sizeof(dataconn);
#line 966
  tmp = getpeername((int )xferfd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& dataconn)),
                    (socklen_t */* __restrict  */)(& socksize));
  }
#line 966
  if (tmp < 0) {
    {
#line 970
    addreply_noformat((int const   )425, (char const   */* const  */)"Unable to identify the local data socket");
#line 971
    closedata();
    }
#line 972
    return;
  } else {
#line 966
    if ((int )dataconn.ss_family == 2) {
#line 966
      tmp___0 = sizeof(struct sockaddr_in );
    } else {
#line 966
      tmp___0 = sizeof(struct sockaddr_in6 );
    }
    {
#line 966
    tmp___1 = getnameinfo((struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& dataconn)),
                          (socklen_t )tmp___0, (char */* __restrict  */)(hbuf), (socklen_t )sizeof(hbuf),
                          (char */* __restrict  */)(pbuf), (socklen_t )sizeof(pbuf),
                          3);
    }
#line 966
    if (tmp___1 != 0) {
      {
#line 970
      addreply_noformat((int const   )425, (char const   */* const  */)"Unable to identify the local data socket");
#line 971
      closedata();
      }
#line 972
      return;
    }
  }
#line 974
  if ((int )dataconn.ss_family == 10) {
#line 974
    tmp___2 = '2';
  } else {
#line 974
    tmp___2 = '1';
  }
  {
#line 974
  addreply((int const   )225, (char const   */* const  */)"Connected to (|%c|%s|%s|)",
           tmp___2, hbuf, pbuf);
  }
#line 976
  return;
}
}
#line 979 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void doeprt(char *p ) 
{ 
  char delim ;
  int family ;
  char *tmp ;
  unsigned short const   **tmp___0 ;
  unsigned int a1 ;
  unsigned int a2 ;
  unsigned int a3 ;
  unsigned int a4 ;
  unsigned int port ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  unsigned short const   **tmp___5 ;
  struct sockaddr_storage a ;
  struct in_addr *tmp___6 ;

  {
  {
#line 984
  tmp = p;
#line 984
  p ++;
#line 984
  delim = *tmp;
#line 985
  family = atoi((char const   *)p);
  }
  {
#line 986
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 986
    tmp___0 = __ctype_b_loc();
    }
#line 986
    if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*p)) & 2048)) {
#line 986
      goto while_break;
    }
#line 987
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 989
  if ((int )*p == (int )delim) {
#line 990
    p ++;
  } else {
    {
#line 992
    addreply_noformat((int const   )501, (char const   */* const  */)"Syntax error in IP address");
    }
#line 993
    return;
  }
#line 995
  if (family == 2) {
#line 995
    if (v6ready) {
      {
#line 996
      do_ipv6_port(p, delim);
      }
#line 997
      return;
    }
  }
#line 999
  if (family != 1) {
#line 1000
    if (v6ready) {
      {
#line 1001
      addreply_noformat((int const   )522, (char const   */* const  */)"Only IPv4 and IPv6 are supported (1,2)");
      }
    } else {
      {
#line 1003
      addreply_noformat((int const   )522, (char const   */* const  */)"Only IPv4 is supported (1)");
      }
    }
#line 1005
    return;
  }
  {
#line 1009
  port = 0U;
#line 1013
  tmp___1 = sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%u,%u,%u,%u",
                   & a1, & a2, & a3, & a4);
  }
#line 1013
  if (tmp___1 != 4) {
    {
#line 1013
    tmp___2 = sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%u.%u.%u.%u",
                     & a1, & a2, & a3, & a4);
    }
#line 1013
    if (tmp___2 != 4) {
      {
#line 1017
      addreply_noformat((int const   )501, (char const   */* const  */)"Syntax error in IP address");
      }
#line 1018
      return;
    } else {
#line 1013
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1013
  if (a1 > 255U) {
    {
#line 1017
    addreply_noformat((int const   )501, (char const   */* const  */)"Syntax error in IP address");
    }
#line 1018
    return;
  } else
#line 1013
  if (a2 > 255U) {
    {
#line 1017
    addreply_noformat((int const   )501, (char const   */* const  */)"Syntax error in IP address");
    }
#line 1018
    return;
  } else
#line 1013
  if (a3 > 255U) {
    {
#line 1017
    addreply_noformat((int const   )501, (char const   */* const  */)"Syntax error in IP address");
    }
#line 1018
    return;
  } else
#line 1013
  if (a4 > 255U) {
    {
#line 1017
    addreply_noformat((int const   )501, (char const   */* const  */)"Syntax error in IP address");
    }
#line 1018
    return;
  } else
#line 1013
  if ((((a1 | a2) | a3) | a4) == 0U) {
    {
#line 1017
    addreply_noformat((int const   )501, (char const   */* const  */)"Syntax error in IP address");
    }
#line 1018
    return;
  }
  {
#line 1020
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1020
    if (*p) {
      {
#line 1020
      tmp___3 = strchr("0123456789.,", (int )*p);
      }
#line 1020
      if (! tmp___3) {
#line 1020
        goto while_break___0;
      }
    } else {
#line 1020
      goto while_break___0;
    }
#line 1021
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1023
  if ((int )*p == (int )delim) {
    {
#line 1024
    p ++;
#line 1024
    tmp___4 = atoi((char const   *)p);
#line 1024
    port = (unsigned int )tmp___4;
    }
    {
#line 1025
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1025
      if (*p) {
        {
#line 1025
        tmp___5 = __ctype_b_loc();
        }
#line 1025
        if (! ((int const   )*(*tmp___5 + (int )((unsigned char )*p)) & 2048)) {
#line 1025
          goto while_break___1;
        }
      } else {
#line 1025
        goto while_break___1;
      }
#line 1026
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1029
  if ((int )*p != (int )delim) {
    {
#line 1030
    addreply_noformat((int const   )501, (char const   */* const  */)"Syntax error in IP address");
    }
#line 1031
    return;
  } else
#line 1029
  if (port > 65535U) {
    {
#line 1030
    addreply_noformat((int const   )501, (char const   */* const  */)"Syntax error in IP address");
    }
#line 1031
    return;
  } else
#line 1029
  if (port <= 0U) {
    {
#line 1030
    addreply_noformat((int const   )501, (char const   */* const  */)"Syntax error in IP address");
    }
#line 1031
    return;
  } else {
    {
#line 1035
    memset((void *)(& a), 0, sizeof(a));
#line 1036
    a.ss_family = (sa_family_t )2;
#line 1037
    tmp___6 = storage_sin_addr((struct sockaddr_storage  const  */* const  */)(& a));
#line 1037
    tmp___6->s_addr = htonl((((a1 << 24) | (a2 << 16)) | (a3 << 8)) | a4);
#line 1040
    doport2(a, port);
    }
  }
#line 1043
  return;
}
}
#line 1045 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void stripctrl(char * const  buf___1 , size_t len ) 
{ 


  {
#line 1047
  if (len <= 0UL) {
#line 1048
    return;
  }
  {
#line 1050
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1051
    len --;
#line 1052
    if ((int )*(buf___1 + len) == 127) {
#line 1052
      goto _L;
    } else
#line 1052
    if ((unsigned int )((unsigned char )*(buf___1 + len)) < 32U) {
      _L: /* CIL Label */ 
#line 1052
      if ((int )*(buf___1 + len) != 0) {
#line 1052
        if ((int )*(buf___1 + len) != 10) {
#line 1054
          *(buf___1 + len) = (char )'_';
        }
      }
    }
#line 1050
    if (! (len != 0UL)) {
#line 1050
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1057
  return;
}
}
#line 1066 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void dobanner(int const   type___0 ) 
{ 
  char buffer[512] ;
  FILE *msg ;
  size_t buflen ;
  unsigned int nblines ;
  char *tmp ;

  {
#line 1071
  nblines = 100U;
  {
#line 1074
  if (type___0 == 0) {
#line 1074
    goto case_0;
  }
#line 1083
  if (type___0 == 1) {
#line 1083
    goto case_1;
  }
#line 1088
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1075
  msg = fopen((char const   */* __restrict  */)".banner", (char const   */* __restrict  */)"r");
  }
#line 1075
  if ((unsigned long )msg == (unsigned long )((void *)0)) {
#line 1080
    return;
  }
#line 1082
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1084
  msg = fopen((char const   */* __restrict  */)".message", (char const   */* __restrict  */)"r");
  }
#line 1084
  if ((unsigned long )msg == (unsigned long )((void *)0)) {
#line 1085
    return;
  }
#line 1087
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1089
  return;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1092
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1092
    tmp = fgets((char */* __restrict  */)(buffer), (int )sizeof(buffer), (FILE */* __restrict  */)msg);
    }
#line 1092
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 1092
      if (! (nblines > 0U)) {
#line 1092
        goto while_break;
      }
    } else {
#line 1092
      goto while_break;
    }
    {
#line 1093
    nblines --;
#line 1094
    buflen = strlen((char const   *)(buffer));
    }
#line 1094
    if (buflen > 0UL) {
#line 1095
      buflen --;
      {
#line 1096
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1096
        if (! ((int )buffer[buflen] == 10)) {
#line 1096
          if (! ((int )buffer[buflen] == 13)) {
#line 1096
            goto while_break___0;
          }
        }
#line 1097
        buffer[buflen] = (char)0;
#line 1098
        if (buflen == 0UL) {
#line 1099
          goto while_break___0;
        }
#line 1101
        buflen --;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1103
      stripctrl((char */* const  */)(buffer), buflen);
      }
    }
    {
#line 1105
    addreply_noformat((int const   )0, (char const   */* const  */)(buffer));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1107
  fclose(msg);
  }
#line 1108
  return;
}
}
#line 1114 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
int modernformat(char const   *file , char *target , size_t target_size , char const   * const  prefix ) 
{ 
  char link_target[4097U] ;
  char const   *ft ;
  char const   *ftx ;
  struct tm *t ;
  struct stat st ;
  int ret ;
  int tmp ;
  struct stat sts ;
  int tmp___0 ;
  ssize_t sx ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1119
  ftx = "";
#line 1122
  ret = 0;
#line 1124
  tmp = lstat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
  }
#line 1124
  if (tmp != 0) {
#line 1125
    return (-1);
  } else {
    {
#line 1124
    t = gmtime((time_t const   *)(& st.st_mtim.tv_sec));
    }
#line 1124
    if (! t) {
#line 1125
      return (-1);
    }
  }
#line 1128
  if ((int )broken_client_compat != 0) {
#line 1128
    if ((st.st_mode & 61440U) == 40960U) {
      {
#line 1135
      tmp___0 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& sts));
      }
#line 1135
      if (tmp___0 == 0) {
#line 1135
        if (! ((sts.st_mode & 61440U) == 40960U)) {
#line 1136
          st = sts;
        }
      }
    }
  }
#line 1140
  if ((st.st_mode & 61440U) == 32768U) {
#line 1141
    ft = "file";
  } else
#line 1142
  if ((st.st_mode & 61440U) == 16384U) {
#line 1143
    ret = 1;
#line 1144
    ft = "dir";
#line 1145
    if ((int const   )*file == 46) {
#line 1146
      if ((int const   )*(file + 1) == 46) {
#line 1146
        if ((int const   )*(file + 2) == 0) {
#line 1147
          ft = "pdir";
        } else {
#line 1146
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1148
      if ((int const   )*(file + 1) == 0) {
#line 1149
        ft = "cdir";
      }
    } else
#line 1151
    if ((int const   )*file == 47) {
#line 1151
      if ((int const   )*(file + 1) == 0) {
#line 1152
        ft = "pdir";
      }
    }
  } else
#line 1154
  if ((st.st_mode & 61440U) == 40960U) {
    {
#line 1157
    ft = "OS.unix=symlink";
#line 1158
    sx = readlink((char const   */* __restrict  */)file, (char */* __restrict  */)(link_target),
                  sizeof(link_target) - 1UL);
    }
#line 1158
    if (sx > 0L) {
      {
#line 1159
      link_target[sx] = (char)0;
#line 1160
      tmp___1 = strpbrk((char const   *)(link_target), "\r\n;");
      }
#line 1160
      if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 1161
        ftx = (char const   *)(link_target);
#line 1162
        ft = "OS.unix=slink:";
      }
    }
  } else {
#line 1166
    ft = "unknown";
  }
#line 1168
  if ((int )guest != 0) {
#line 1169
    if (ret) {
#line 1169
      tmp___2 = 'd';
    } else {
#line 1169
      tmp___2 = 'e';
    }
    {
#line 1169
    tmp___3 = snprintf((char */* __restrict  */)target, target_size, (char const   */* __restrict  */)"%stype=%s%s;siz%c=%llu;modify=%04d%02d%02d%02d%02d%02d;UNIX.mode=0%o;unique=%xg%llx; %s",
                       prefix, ft, ftx, tmp___2, (unsigned long long )st.st_size,
                       t->tm_year + 1900, t->tm_mon + 1, t->tm_mday, t->tm_hour, t->tm_min,
                       t->tm_sec, st.st_mode & 4095U, (unsigned int )st.st_dev, (unsigned long long )st.st_ino,
                       file);
    }
#line 1169
    if (tmp___3 >= (int )target_size) {
      {
#line 1181
      _EXIT((int const   )1);
      }
    }
  } else {
#line 1184
    if (ret) {
#line 1184
      tmp___4 = 'd';
    } else {
#line 1184
      tmp___4 = 'e';
    }
    {
#line 1184
    tmp___5 = snprintf((char */* __restrict  */)target, target_size, (char const   */* __restrict  */)"%stype=%s;siz%c=%llu;modify=%04d%02d%02d%02d%02d%02d;UNIX.mode=0%o;UNIX.uid=%lld;UNIX.gid=%lld;unique=%xg%llx; %s",
                       prefix, ft, tmp___4, (unsigned long long )st.st_size, t->tm_year + 1900,
                       t->tm_mon + 1, t->tm_mday, t->tm_hour, t->tm_min, t->tm_sec,
                       st.st_mode & 4095U, (unsigned long long )st.st_uid, (unsigned long long )st.st_gid,
                       (unsigned int )st.st_dev, (unsigned long long )st.st_ino, file);
    }
#line 1184
    if (tmp___5 >= (int )target_size) {
      {
#line 1198
      _EXIT((int const   )1);
      }
    }
  }
#line 1201
  return (ret);
}
}
#line 1206 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void domlst(char const   * const  file ) 
{ 
  char line___1[4352U] ;
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 1208
  line___1[0] = (char )'B';
#line 1208
  line___1[1] = (char )'e';
#line 1208
  line___1[2] = (char )'g';
#line 1208
  line___1[3] = (char )'i';
#line 1208
  line___1[4] = (char )'n';
#line 1208
  line___1[5] = (char )'\r';
#line 1208
  line___1[6] = (char )'\n';
#line 1208
  line___1[7] = (char )'\000';
#line 1208
  tmp = 8U;
  {
#line 1208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1208
    if (tmp >= 4352U) {
#line 1208
      goto while_break;
    }
#line 1208
    line___1[tmp] = (char)0;
#line 1208
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1210
  tmp___0 = modernformat((char const   *)file, line___1 + (sizeof("Begin\r\n") - 1UL),
                         sizeof(line___1) - (sizeof("Begin\r\n") - 1UL), (char const   */* const  */)" ");
  }
#line 1210
  if (tmp___0 >= 0) {
    {
#line 1212
    addreply_noformat((int const   )0, (char const   */* const  */)(line___1));
#line 1213
    addreply_noformat((int const   )250, (char const   */* const  */)"End.");
    }
  } else {
    {
#line 1215
    addreply_noformat((int const   )550, (char const   */* const  */)"Can\'t check for file existence");
    }
  }
#line 1217
  return;
}
}
#line 1219 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void donoop(void) 
{ 


  {
  {
#line 1224
  addreply_noformat((int const   )200, (char const   */* const  */)"Zzz...");
  }
#line 1226
  return;
}
}
#line 1228 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void doallo(off_t const   size ) 
{ 
  int ret ;
  int tmp ;

  {
#line 1230
  ret = -1;
#line 1235
  if (size <= 0L) {
#line 1236
    ret = 0;
  } else {
    {
#line 1237
    tmp = ul_check_free_space((char const   *)(wd), (double const   )((double )size));
    }
#line 1237
    if (tmp != 0) {
#line 1238
      ret = 0;
    }
  }
#line 1249
  if (ret == 0) {
    {
#line 1253
    addreply_noformat((int const   )200, (char const   */* const  */)"A L\'HUILE");
    }
  } else {
    {
#line 1256
    addreply_noformat((int const   )552, (char const   */* const  */)"Disk full - please upload later");
    }
  }
#line 1258
  return;
}
}
#line 1262 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void dositetime(void) 
{ 
  char tmp[64] ;
  struct tm  const  *tm ;
  time_t now ;
  struct tm *tmp___0 ;

  {
  {
#line 1268
  now = time((time_t *)((void *)0));
  }
#line 1268
  if (now == -1L) {
    {
#line 1269
    addreply_noformat((int const   )451, (char const   */* const  */)"time()");
    }
#line 1270
    return;
  } else {
    {
#line 1268
    tmp___0 = localtime((time_t const   *)(& now));
#line 1268
    tm = (struct tm  const  *)tmp___0;
    }
#line 1268
    if ((unsigned long )tm == (unsigned long )((void *)0)) {
      {
#line 1269
      addreply_noformat((int const   )451, (char const   */* const  */)"time()");
      }
#line 1270
      return;
    }
  }
  {
#line 1272
  strftime((char */* __restrict  */)(tmp), sizeof(tmp), (char const   */* __restrict  */)"%Y-%m-%d %H:%M:%S",
           (struct tm  const  */* __restrict  */)tm);
#line 1273
  addreply_noformat((int const   )211, (char const   */* const  */)(tmp));
  }
#line 1274
  return;
}
}
#line 1276 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static int doinitsupgroups___0(char const   *user , uid_t const   uid___0 , gid_t const   gid___0 ) 
{ 
  int tmp ;
  struct passwd  const  *lpwd ;
  struct passwd *tmp___0 ;

  {
  {
#line 1280
  tmp = setgroups((size_t )1U, & gid___0);
  }
#line 1280
  if (tmp != 0) {
#line 1281
    return (-1);
  }
#line 1287
  if ((unsigned long )user == (unsigned long )((void *)0)) {
    {
#line 1288
    tmp___0 = getpwuid((__uid_t )uid___0);
#line 1288
    lpwd = (struct passwd  const  *)tmp___0;
    }
#line 1290
    if ((unsigned long )lpwd != (unsigned long )((void *)0)) {
#line 1290
      if ((unsigned long )lpwd->pw_name != (unsigned long )((void *)0)) {
#line 1291
        user = (char const   *)lpwd->pw_name;
      } else {
#line 1293
        return (0);
      }
    } else {
#line 1293
      return (0);
    }
  }
  {
#line 1296
  initgroups(user, (__gid_t )gid___0);
  }
#line 1306
  return (0);
}
}
#line 1309 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void douser(char const   *username ) 
{ 
  struct passwd *pw ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *hd ;
  size_t rd_len ;
  void *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;

  {
#line 1311
  pw = (struct passwd *)((void *)0);
#line 1313
  if (loggedin) {
#line 1314
    if (username) {
#line 1315
      if (! guest) {
        {
#line 1316
        addreply_noformat((int const   )530, (char const   */* const  */)"You\'re already logged in");
        }
      } else
#line 1317
      if ((int )broken_client_compat != 0) {
        {
#line 1318
        addreply_noformat((int const   )331, (char const   */* const  */)"Any password will work");
        }
      } else {
        {
#line 1320
        addreply_noformat((int const   )230, (char const   */* const  */)"Anonymous user logged in");
#line 1321
        dot_read_ok = dot_read_anon_ok;
#line 1322
        dot_write_ok = (signed char)0;
        }
      }
    }
#line 1325
    return;
  }
#line 1327
  if ((int )anon_only <= 0) {
#line 1327
    if ((unsigned long )username != (unsigned long )((void *)0)) {
#line 1327
      if ((int const   )*username != 0) {
#line 1327
        if ((int )anon_only < 0) {
          {
#line 1330
          strncpy((char */* __restrict  */)(account), (char const   */* __restrict  */)username,
                  sizeof(account) - 1UL);
#line 1331
          account[sizeof(account) - 1UL] = (char)0;
#line 1332
          addreply((int const   )331, (char const   */* const  */)"User %s OK. Password required",
                   account);
#line 1333
          loggedin = (signed char)0;
          }
        } else {
          {
#line 1327
          tmp___11 = strcasecmp(username, "ftp");
          }
#line 1327
          if (tmp___11) {
            {
#line 1327
            tmp___12 = strcasecmp(username, "anonymous");
            }
#line 1327
            if (tmp___12) {
              {
#line 1330
              strncpy((char */* __restrict  */)(account), (char const   */* __restrict  */)username,
                      sizeof(account) - 1UL);
#line 1331
              account[sizeof(account) - 1UL] = (char)0;
#line 1332
              addreply((int const   )331, (char const   */* const  */)"User %s OK. Password required",
                       account);
#line 1333
              loggedin = (signed char)0;
              }
            } else {
#line 1327
              goto _L___2;
            }
          } else {
#line 1327
            goto _L___2;
          }
        }
      } else {
#line 1327
        goto _L___2;
      }
    } else {
#line 1327
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 1334
  if ((int )anon_only < 0) {
#line 1335
    if ((int )broken_client_compat != 0) {
      {
#line 1336
      addreply((int const   )331, (char const   */* const  */)"User %s OK. Password required",
               username);
      }
#line 1337
      return;
    } else {
      {
#line 1339
      die((int const   )530, (int const   )7, (char const   */* const  */)"This is a private system - No anonymous login");
      }
    }
  } else {
#line 1346
    if ((int )chrooted != 0) {
      {
#line 1347
      die((int const   )421, (int const   )7, (char const   */* const  */)"We can\'t do that in the current session");
      }
    }
    {
#line 1382
    pw = getpwnam("ftp");
    }
#line 1382
    if ((unsigned long )pw == (unsigned long )((void *)0)) {
#line 1382
      goto cantsec;
    } else
#line 1382
    if (pw->pw_uid == 0U) {
#line 1382
      goto cantsec;
    } else
#line 1382
    if (pw->pw_gid == 0U) {
#line 1382
      goto cantsec;
    } else {
      {
#line 1382
      tmp = doinitsupgroups___0("ftp", (uid_t const   )((uid_t )-1), (gid_t const   )pw->pw_gid);
      }
#line 1382
      if (tmp != 0) {
#line 1382
        goto cantsec;
      } else {
        {
#line 1382
        tmp___0 = setgid(pw->pw_gid);
        }
#line 1382
        if (tmp___0) {
#line 1382
          goto cantsec;
        } else {
          {
#line 1382
          tmp___1 = setegid(pw->pw_gid);
          }
#line 1382
          if (tmp___1) {
            cantsec: 
            {
#line 1387
            die((int const   )421, (int const   )3, (char const   */* const  */)"Unable to set up secure anonymous FTP");
            }
          }
        }
      }
    }
#line 1404
    if ((unsigned long )pw->pw_dir == (unsigned long )((void *)0)) {
#line 1405
      goto cantsec;
    } else
#line 1404
    if ((int )*(pw->pw_dir) != 47) {
#line 1405
      goto cantsec;
    }
    {
#line 1407
    hd = strstr((char const   *)pw->pw_dir, "/./");
    }
#line 1407
    if ((unsigned long )hd != (unsigned long )((void *)0)) {
      {
#line 1408
      rd_len = (size_t )(hd - pw->pw_dir) + sizeof("/");
#line 1409
      tmp___2 = malloc(rd_len);
#line 1409
      root_directory = (char *)tmp___2;
      }
#line 1409
      if ((unsigned long )root_directory == (unsigned long )((void *)0)) {
#line 1410
        goto cantsec;
      }
      {
#line 1412
      memcpy((void */* __restrict  */)root_directory, (void const   */* __restrict  */)pw->pw_dir,
             rd_len);
#line 1413
      *(root_directory + (rd_len - 1UL)) = (char)0;
#line 1414
      hd += 2;
      }
    } else {
      {
#line 1416
      tmp___3 = strlen((char const   *)pw->pw_dir);
#line 1416
      rd_len = tmp___3 + sizeof("/");
#line 1417
      tmp___4 = malloc(rd_len);
#line 1417
      root_directory = (char *)tmp___4;
      }
#line 1417
      if ((unsigned long )root_directory == (unsigned long )((void *)0)) {
#line 1418
        goto cantsec;
      }
      {
#line 1420
      snprintf((char */* __restrict  */)root_directory, rd_len, (char const   */* __restrict  */)"%s/",
               pw->pw_dir);
#line 1421
      hd = (char *)"/";
      }
    }
    {
#line 1423
    tmp___5 = chdir((char const   *)root_directory);
    }
#line 1423
    if (tmp___5) {
      {
#line 1424
      die((int const   )421, (int const   )3, (char const   */* const  */)"Can\'t change directory to %s [%s]",
          root_directory, hd);
      }
#line 1426
      goto cantsec;
    } else {
      {
#line 1423
      tmp___6 = chroot((char const   *)root_directory);
      }
#line 1423
      if (tmp___6) {
        {
#line 1424
        die((int const   )421, (int const   )3, (char const   */* const  */)"Can\'t change directory to %s [%s]",
            root_directory, hd);
        }
#line 1426
        goto cantsec;
      } else {
        {
#line 1423
        tmp___7 = chdir((char const   *)hd);
        }
#line 1423
        if (tmp___7) {
          {
#line 1424
          die((int const   )421, (int const   )3, (char const   */* const  */)"Can\'t change directory to %s [%s]",
              root_directory, hd);
          }
#line 1426
          goto cantsec;
        }
      }
    }
    {
#line 1428
    logfile((int const   )6, "Anonymous user logged in");
    }
#line 1443
    if ((unsigned long )pw == (unsigned long )((void *)0)) {
#line 1444
      goto cantsec;
    }
    {
#line 1446
    chrooted = (signed char)1;
#line 1447
    authresult.uid = pw->pw_uid;
#line 1448
    authresult.gid = pw->pw_gid;
#line 1449
    tmp___8 = strdup((char const   *)pw->pw_dir);
#line 1449
    authresult.dir = (char const   *)tmp___8;
    }
#line 1449
    if ((unsigned long )authresult.dir == (unsigned long )((void *)0)) {
      {
#line 1450
      die_mem();
      }
    }
#line 1464
    if (authresult.uid > 0U) {
      {
#line 1466
      tmp___9 = setuid(authresult.uid);
      }
#line 1466
      if (tmp___9 != 0) {
#line 1467
        goto cantsec;
      } else {
        {
#line 1466
        tmp___10 = seteuid(authresult.uid);
        }
#line 1466
        if (tmp___10 != 0) {
#line 1467
          goto cantsec;
        }
      }
    }
    {
#line 1481
    dobanner((int const   )0);
    }
#line 1484
    if ((int )broken_client_compat != 0) {
      {
#line 1485
      addreply_noformat((int const   )331, (char const   */* const  */)"Any password will work");
      }
    } else {
      {
#line 1487
      addreply_noformat((int const   )230, (char const   */* const  */)"Anonymous user logged in");
      }
    }
    {
#line 1489
    dot_write_ok = (signed char)0;
#line 1490
    dot_read_ok = dot_read_anon_ok;
#line 1491
    strncpy((char */* __restrict  */)(account), (char const   */* __restrict  */)"ftp",
            sizeof(account) - 1UL);
#line 1492
    account[sizeof(account) - 1UL] = (char)0;
#line 1503
    guest = (signed char)1;
#line 1503
    loggedin = guest;
    }
  }
  {
#line 1508
  tmp___13 = getcwd(wd, sizeof(wd) - 1UL);
  }
#line 1508
  if ((unsigned long )tmp___13 == (unsigned long )((void *)0)) {
#line 1509
    wd[0] = (char )'/';
#line 1510
    wd[1] = (char)0;
  }
#line 1515
  return;
}
}
#line 1517 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static AuthResult pw_check(char const   *account___0 , char const   *password , struct sockaddr_storage  const  * const  sa ,
                           struct sockaddr_storage  const  * const  peer___0 ) 
{ 
  Authentications *auth_scan ;
  AuthResult result ;

  {
#line 1521
  auth_scan = first_authentications;
#line 1524
  result.auth_ok = -1;
  {
#line 1525
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1525
    if (! ((unsigned long )auth_scan != (unsigned long )((void *)0))) {
#line 1525
      goto while_break;
    }
    {
#line 1544
    result.backend_data = (void *)0;
#line 1545
    (*((auth_scan->auth)->check))((AuthResult */* const  */)(& result), account___0,
                                  password, sa, peer___0);
    }
#line 1546
    if (result.auth_ok < 0) {
#line 1547
      goto while_break;
    } else
#line 1548
    if (result.auth_ok > 0) {
#line 1591
      return (result);
    }
#line 1593
    auth_scan = auth_scan->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1596
  return (result);
}
}
#line 1604 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static int check_trustedgroup(uid_t const   uid___0 , gid_t const   gid___0 ) 
{ 
  gid_t *alloca_suppgroups ;
  int n ;
  int n2 ;
  int result ;
  void *tmp ;

  {
#line 1609
  result = 0;
#line 1611
  if (uid___0 == 0U) {
#line 1612
    return (1);
  }
#line 1614
  if ((int )userchroot == 2) {
#line 1615
    return (0);
  }
#line 1617
  if (gid___0 == (gid_t const   )chroot_trustedgid) {
#line 1618
    return (1);
  }
  {
#line 1621
  n = getgroups(0, (__gid_t *)((void *)0));
  }
#line 1621
  if (n <= 0) {
#line 1622
    return (0);
  }
  {
#line 1624
  tmp = __builtin_alloca((unsigned long )n * sizeof(*alloca_suppgroups));
#line 1624
  alloca_suppgroups = (gid_t *)tmp;
  }
#line 1624
  if ((unsigned long )alloca_suppgroups == (unsigned long )((void *)0)) {
    {
#line 1626
    die_mem();
    }
  }
  {
#line 1628
  n2 = getgroups(n, alloca_suppgroups);
  }
#line 1630
  if (n2 < n) {
#line 1631
    n = n2;
  }
#line 1633
  result = 0;
  {
#line 1634
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1634
    if (! (n != 0)) {
#line 1634
      goto while_break;
    }
#line 1635
    n --;
#line 1636
    if (*(alloca_suppgroups + n) == chroot_trustedgid) {
#line 1637
      result = 1;
#line 1638
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1641
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1641
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1644
  return (result);
}
}
#line 1651 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static int create_home_and_chdir(char const   * const  home ) 
{ 
  char *pathcomp ;
  char *z ;
  size_t len ;
  char delim ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1656
  delim = (char )'/';
#line 1658
  if ((unsigned long )home == (unsigned long )((void *)0)) {
#line 1659
    return (-1);
  } else
#line 1658
  if ((int const   )*home != 47) {
#line 1659
    return (-1);
  }
  {
#line 1661
  tmp = chdir((char const   *)home);
  }
#line 1661
  if (tmp == 0) {
#line 1662
    return (0);
  }
#line 1664
  if ((int )create_home == 0) {
#line 1665
    return (-1);
  }
  {
#line 1667
  tmp___0 = strlen((char const   *)home);
#line 1667
  len = tmp___0 + 1UL;
  }
#line 1668
  if (len < 2UL) {
#line 1669
    return (-1);
  } else
#line 1668
  if ((int const   )*home != (int const   )delim) {
#line 1669
    return (-1);
  }
  {
#line 1671
  tmp___1 = __builtin_alloca(len);
#line 1671
  pathcomp = (char *)tmp___1;
  }
#line 1671
  if ((unsigned long )pathcomp == (unsigned long )((void *)0)) {
#line 1672
    return (-1);
  }
  {
#line 1674
  memcpy((void */* __restrict  */)pathcomp, (void const   */* __restrict  */)home,
         len);
#line 1675
  z = pathcomp;
  }
  {
#line 1676
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1677
    z ++;
#line 1678
    if ((int )*z == 0) {
#line 1679
      goto while_break;
    }
#line 1681
    if ((int )*z == (int )delim) {
#line 1682
      *z = (char)0;
#line 1683
      if ((int )*(z + 1) == 0) {
#line 1684
        goto while_break;
      }
      {
#line 1686
      mkdir((char const   *)pathcomp, (mode_t )493);
#line 1687
      *z = delim;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1690
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1690
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1691
  mkdir((char const   *)home, (mode_t )448);
#line 1692
  tmp___2 = chdir((char const   *)home);
  }
#line 1692
  if (tmp___2 != 0) {
#line 1693
    return (-1);
  }
  {
#line 1695
  tmp___3 = chmod((char const   *)home, 511U & ~ u_mask_d);
  }
#line 1695
  if (tmp___3 < 0) {
#line 1697
    return (-1);
  } else {
    {
#line 1695
    tmp___4 = chown((char const   *)home, authresult.uid, authresult.gid);
    }
#line 1695
    if (tmp___4 < 0) {
#line 1697
      return (-1);
    }
  }
  {
#line 1700
  tmp___5 = chdir((char const   *)home);
  }
#line 1700
  return (tmp___5);
}
}
#line 1703 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static void randomsleep(unsigned int t ) 
{ 
  unsigned int tmp ;

  {
  {
#line 1704
  tmp = zrand();
#line 1704
  usleep2((unsigned long const   )((unsigned long )tmp % 3000000UL));
#line 1705
  usleep2((unsigned long const   )((unsigned long )t * 3000000UL));
  }
#line 1706
  return;
}
}
#line 1710 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static unsigned int tapping  ;
#line 1708 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void dopass(char *password ) 
{ 
  char *hd ;
  char volatile   *password_ ;
  char volatile   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t rd_len ;
  size_t tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;

  {
#line 1725
  if ((int )loggedin != 0) {
#line 1726
    if ((int )guest != 0) {
      {
#line 1727
      addreply_noformat((int const   )230, (char const   */* const  */)"Any password will work");
      }
    } else {
      {
#line 1732
      addreply_noformat((int const   )530, (char const   */* const  */)"We can\'t do that in the current session");
      }
    }
#line 1734
    return;
  }
#line 1736
  if ((int )account[0] == 0) {
    {
#line 1737
    addreply_noformat((int const   )530, (char const   */* const  */)"Please tell me who you are");
    }
#line 1738
    return;
  }
  {
#line 1740
  authresult = pw_check((char const   *)(account), (char const   *)password, (struct sockaddr_storage  const  */* const  */)(& ctrlconn),
                        (struct sockaddr_storage  const  */* const  */)(& peer));
#line 1743
  password_ = (char volatile   *)password;
  }
  {
#line 1745
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1745
    if (! ((int volatile   )*password_ != (int volatile   )0)) {
#line 1745
      goto while_break;
    }
#line 1746
    tmp = password_;
#line 1746
    password_ ++;
#line 1746
    *tmp = (char volatile   )0;
  }
  while_break: /* CIL Label */ ;
  }
#line 1749
  if (authresult.auth_ok != 1) {
    {
#line 1750
    tapping ++;
#line 1751
    randomsleep(tapping);
#line 1752
    addreply_noformat((int const   )530, (char const   */* const  */)"Login authentication failed");
#line 1753
    doreply();
    }
#line 1754
    if (tapping > 5U) {
      {
#line 1755
      logfile((int const   )3, "Too many authentication failures");
#line 1756
      _EXIT((int const   )1);
      }
    }
    {
#line 1758
    logfile((int const   )4, "Authentication failed for user [%s]", account);
    }
#line 1759
    return;
  }
#line 1761
  if (authresult.uid < useruid) {
    {
#line 1762
    logfile((int const   )4, "Can\'t login as [%s]: account disabled", account);
#line 1763
    randomsleep(tapping);
    }
#line 1764
    if (tapping >= 5U) {
      {
#line 1765
      addreply_noformat((int const   )530, (char const   */* const  */)"Login authentication failed");
#line 1766
      doreply();
#line 1767
      _EXIT((int const   )1);
      }
    }
    {
#line 1769
    addreply_noformat((int const   )530, (char const   */* const  */)"Sorry, but I can\'t trust you");
#line 1770
    doreply();
    }
#line 1771
    return;
  }
  {
#line 1783
  getname((uid_t const   )authresult.uid);
#line 1784
  getgroup((gid_t const   )authresult.gid);
#line 1786
  tmp___0 = doinitsupgroups___0((char const   *)(account), (uid_t const   )((uid_t )-1),
                                (gid_t const   )authresult.gid);
  }
#line 1786
  if (tmp___0 != 0) {
    {
#line 1796
    die((int const   )421, (int const   )4, (char const   */* const  */)"Sorry, but I can\'t trust you");
    }
  }
  {
#line 1801
  root_directory = strdup(authresult.dir);
  }
#line 1801
  if ((unsigned long )root_directory == (unsigned long )((void *)0)) {
    {
#line 1802
    die_mem();
    }
  }
  {
#line 1804
  hd = strstr((char const   *)root_directory, "/./");
  }
#line 1805
  if ((unsigned long )hd != (unsigned long )((void *)0)) {
#line 1806
    if ((int )chrooted != 0) {
      {
#line 1807
      die((int const   )421, (int const   )7, (char const   */* const  */)"We can\'t do that in the current session");
      }
    }
    {
#line 1809
    tmp___1 = create_home_and_chdir((char const   */* const  */)root_directory);
    }
#line 1809
    if (tmp___1) {
      {
#line 1810
      die((int const   )421, (int const   )3, (char const   */* const  */)"Home directory not available - aborting");
      }
    }
    {
#line 1812
    hd ++;
#line 1812
    *hd = (char)0;
#line 1813
    hd ++;
#line 1814
    tmp___2 = chroot((char const   *)root_directory);
    }
#line 1814
    if (tmp___2) {
      {
#line 1815
      die((int const   )421, (int const   )3, (char const   */* const  */)"Home directory not available - aborting");
      }
    } else {
      {
#line 1814
      tmp___3 = chdir((char const   *)hd);
      }
#line 1814
      if (tmp___3) {
        {
#line 1815
        die((int const   )421, (int const   )3, (char const   */* const  */)"Home directory not available - aborting");
        }
      }
    }
#line 1817
    chrooted = (signed char)1;
  } else {
    {
#line 1829
    free((void *)root_directory);
#line 1830
    root_directory = (char *)"/";
#line 1831
    tmp___4 = create_home_and_chdir((char const   */* const  */)authresult.dir);
    }
#line 1831
    if (tmp___4) {
      {
#line 1832
      die((int const   )421, (int const   )3, (char const   */* const  */)"Home directory not available - aborting");
      }
    }
  }
  {
#line 1835
  tmp___5 = getcwd(wd, sizeof(wd) - 1UL);
  }
#line 1835
  if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
#line 1836
    wd[0] = (char )'/';
#line 1837
    wd[1] = (char)0;
  }
  {
#line 1840
  tmp___6 = setgid(authresult.gid);
  }
#line 1840
  if (tmp___6) {
    {
#line 1841
    _EXIT((int const   )1);
    }
  } else {
    {
#line 1840
    tmp___7 = setegid(authresult.gid);
    }
#line 1840
    if (tmp___7) {
      {
#line 1841
      _EXIT((int const   )1);
      }
    }
  }
  {
#line 1844
  tmp___8 = check_trustedgroup((uid_t const   )authresult.uid, (gid_t const   )authresult.gid);
  }
#line 1844
  if (tmp___8 != 0) {
#line 1845
    userchroot = (signed char)0;
#line 1846
    dot_read_ok = (signed char)1;
#line 1846
    dot_write_ok = dot_read_ok;
#line 1847
    keepallfiles = (signed char)0;
  }
#line 1860
  if ((int )loggedin == 0) {
#line 1861
    candownload = (signed char)1;
  }
#line 1922
  if ((int )guest == 0) {
#line 1922
    if ((int )allowfxp == 1) {
      {
#line 1923
      addreply_noformat((int const   )0, (char const   */* const  */)"This server supports FXP transfers");
      }
    }
  }
#line 1930
  if ((int )userchroot != 0) {
#line 1930
    if ((int )chrooted == 0) {
      {
#line 1931
      tmp___9 = chdir((char const   *)(wd));
      }
#line 1931
      if (tmp___9) {
        {
#line 1932
        die((int const   )421, (int const   )3, (char const   */* const  */)"Unable to set up a secure chroot() jail");
        }
      } else {
        {
#line 1931
        tmp___10 = chroot((char const   *)(wd));
        }
#line 1931
        if (tmp___10) {
          {
#line 1932
          die((int const   )421, (int const   )3, (char const   */* const  */)"Unable to set up a secure chroot() jail");
          }
        }
      }
      {
#line 1934
      chrooted = (signed char)1;
#line 1941
      tmp___11 = strlen((char const   *)(wd));
#line 1941
      rd_len = tmp___11 + sizeof("/");
#line 1943
      tmp___12 = malloc(rd_len);
#line 1943
      root_directory = (char *)tmp___12;
      }
#line 1943
      if ((unsigned long )root_directory == (unsigned long )((void *)0)) {
        {
#line 1944
        die_mem();
        }
      }
      {
#line 1946
      snprintf((char */* __restrict  */)root_directory, rd_len, (char const   */* __restrict  */)"%s/",
               wd);
#line 1948
      wd[0] = (char )'/';
#line 1949
      wd[1] = (char)0;
#line 1950
      tmp___13 = chdir((char const   *)(wd));
      }
#line 1950
      if (tmp___13) {
        {
#line 1951
        _EXIT((int const   )1);
        }
      }
      {
#line 1958
      addreply((int const   )230, (char const   */* const  */)"OK. Current restricted directory is %s",
               wd);
      }
    } else {
      {
#line 1966
      addreply((int const   )230, (char const   */* const  */)"OK. Current directory is %s",
               wd);
      }
    }
  } else {
    {
#line 1966
    addreply((int const   )230, (char const   */* const  */)"OK. Current directory is %s",
             wd);
    }
  }
  {
#line 1971
  disablesignals();
#line 1973
  tmp___14 = setuid(authresult.uid);
  }
#line 1973
  if (tmp___14 != 0) {
    {
#line 1974
    _EXIT((int const   )1);
    }
  } else {
    {
#line 1973
    tmp___15 = seteuid(authresult.uid);
    }
#line 1973
    if (tmp___15 != 0) {
      {
#line 1974
      _EXIT((int const   )1);
      }
    }
  }
  {
#line 1984
  enablesignals();
#line 1986
  logfile((int const   )6, "%s is now logged in", account);
#line 1997
  loggedin = (signed char)1;
#line 1998
  tmp___16 = getcwd(wd, sizeof(wd) - 1UL);
  }
#line 1998
  if ((unsigned long )tmp___16 == (unsigned long )((void *)0)) {
#line 1999
    wd[0] = (char )'/';
#line 2000
    wd[1] = (char)0;
  }
  {
#line 2003
  dobanner((int const   )0);
  }
#line 2011
  return;
}
}
#line 2013 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void docwd(char const   *dir ) 
{ 
  char const   *where ;
  char buffer[4352U] ;
  struct passwd  const  *pw ;
  char const   *tmp ;
  char *bufpnt ;
  size_t s___0 ;
  char const   *dirscan ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  struct passwd *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t dir_len ;
  size_t tmp___10 ;
  size_t wd_len ;
  size_t tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;

  {
#line 2021
  if ((int )loggedin == 0) {
#line 2022
    goto kaboom;
  }
#line 2029
  where = dir;
#line 2030
  if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 2031
    dir = "~";
  } else
#line 2030
  if ((int const   )*dir == 0) {
#line 2031
    dir = "~";
  }
#line 2033
  if ((int const   )*dir == 126) {
#line 2036
    if ((int const   )*(dir + 1) == 0) {
#line 2037
      if ((int )chrooted != 0) {
#line 2037
        tmp = "/";
      } else {
#line 2037
        tmp = authresult.dir;
      }
      {
#line 2037
      strncpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)tmp,
              sizeof(buffer));
#line 2039
      buffer[sizeof(buffer) - 1UL] = (char)0;
#line 2040
      where = (char const   *)(buffer);
      }
    } else {
#line 2042
      bufpnt = buffer;
#line 2043
      s___0 = sizeof(buffer);
#line 2044
      dirscan = dir + 1;
      {
#line 2046
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2046
        if ((int const   )*dirscan != 0) {
#line 2046
          if (! ((int const   )*dirscan != 47)) {
#line 2046
            goto while_break;
          }
        } else {
#line 2046
          goto while_break;
        }
#line 2047
        s___0 --;
#line 2047
        if (s___0 <= 0UL) {
#line 2048
          goto kaboom;
        }
#line 2050
        tmp___0 = bufpnt;
#line 2050
        bufpnt ++;
#line 2050
        tmp___1 = dirscan;
#line 2050
        dirscan ++;
#line 2050
        *tmp___0 = (char )*tmp___1;
      }
      while_break: /* CIL Label */ ;
      }
#line 2052
      *bufpnt = (char)0;
#line 2053
      if ((int )buffer[0] == 0) {
#line 2054
        if ((int )chrooted != 0) {
#line 2054
          tmp___2 = "/";
        } else {
#line 2054
          tmp___2 = authresult.dir;
        }
        {
#line 2054
        snprintf((char */* __restrict  */)(buffer), sizeof(buffer), (char const   */* __restrict  */)"%s%s",
                 tmp___2, dirscan);
#line 2056
        where = (char const   *)(buffer);
        }
      } else
#line 2057
      if (authresult.slow_tilde_expansion == 0) {
#line 2058
        if (! ((int )chrooted != 0)) {
#line 2058
          if (! ((int )guest != 0)) {
            {
#line 2058
            tmp___3 = getpwnam((char const   *)(buffer));
#line 2058
            pw = (struct passwd  const  *)tmp___3;
            }
#line 2058
            if (! ((unsigned long )pw == (unsigned long )((void *)0))) {
#line 2058
              if (! ((unsigned long )pw->pw_dir == (unsigned long )((void *)0))) {
                {
#line 2062
                snprintf((char */* __restrict  */)(buffer), sizeof(buffer), (char const   */* __restrict  */)"%s%s",
                         pw->pw_dir, dirscan);
#line 2063
                where = (char const   *)(buffer);
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 2068
  tmp___4 = checknamesanity(where, (int )dot_read_ok);
  }
#line 2068
  if (tmp___4 != 0) {
    {
#line 2069
    addreply((int const   )553, (char const   */* const  */)"Prohibited file name: %s",
             where);
    }
#line 2070
    return;
  }
  {
#line 2072
  tmp___8 = chdir(where);
  }
#line 2072
  if (tmp___8 != 0) {
    {
#line 2086
    tmp___5 = __errno_location();
#line 2086
    tmp___6 = strerror(*tmp___5);
#line 2086
    tmp___7 = snprintf((char */* __restrict  */)(buffer), sizeof(buffer), (char const   */* __restrict  */)"Can\'t change directory to %s: %s",
                       dir, tmp___6);
    }
#line 2086
    if (tmp___7 >= (int )sizeof(buffer)) {
      {
#line 2089
      _EXIT((int const   )1);
      }
    }
    {
#line 2091
    logfile((int const   )6, "%s", buffer);
#line 2092
    addreply((int const   )550, (char const   */* const  */)"%s", buffer);
    }
#line 2096
    if (cwd_failures >= 50UL) {
      {
#line 2097
      _EXIT((int const   )1);
      }
    }
    {
#line 2099
    usleep2((unsigned long const   )(cwd_failures * 100000UL));
#line 2100
    cwd_failures ++;
    }
#line 2104
    return;
  }
  {
#line 2112
  cwd_failures = 0UL;
#line 2113
  dobanner((int const   )1);
#line 2115
  tmp___13 = getcwd(wd, sizeof(wd) - 1UL);
  }
#line 2115
  if ((unsigned long )tmp___13 == (unsigned long )((void *)0)) {
#line 2116
    if ((int const   )*dir == 47) {
      {
#line 2117
      tmp___9 = snprintf((char */* __restrict  */)(wd), sizeof(wd), (char const   */* __restrict  */)"%s",
                         dir);
      }
#line 2117
      if (tmp___9 >= (int )sizeof(wd)) {
        {
#line 2118
        _EXIT((int const   )1);
        }
      }
    } else {
      {
#line 2121
      tmp___10 = strlen(dir);
#line 2121
      dir_len = tmp___10;
#line 2122
      tmp___11 = strlen((char const   *)(wd));
#line 2122
      wd_len = tmp___11;
      }
#line 2123
      if (sizeof(wd) < (((dir_len + sizeof("/")) - 1UL) + wd_len) + 1UL) {
        kaboom: 
        {
#line 2125
        die((int const   )421, (int const   )3, (char const   */* const  */)"Path too long");
        }
      }
      {
#line 2127
      tmp___12 = strcat((char */* __restrict  */)(wd), (char const   */* __restrict  */)"/");
#line 2127
      strcat((char */* __restrict  */)tmp___12, (char const   */* __restrict  */)dir);
      }
    }
  }
  {
#line 2135
  addreply((int const   )250, (char const   */* const  */)"OK. Current directory is %s",
           wd);
  }
#line 2137
  return;
}
}
#line 2139 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
unsigned int zrand(void) 
{ 
  unsigned int tmp ;

  {
  {
#line 2141
  tmp = alt_arc4random();
  }
#line 2141
  return (tmp);
}
}
#line 2144 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static void keepalive(int const   fd , int keep ) 
{ 


  {
  {
#line 2148
  setsockopt((int )fd, 1, 9, (void const   *)((char *)(& keep)), (socklen_t )sizeof(keep));
  }
#line 2151
  return;
}
}
#line 2157 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void dopasv(int psvtype ) 
{ 
  struct sockaddr_storage dataconn ;
  unsigned long a ;
  unsigned int p ;
  int on ;
  unsigned int firstporttried ;
  unsigned int tmp ;
  int tmp___0 ;
  in_port_t *tmp___1 ;
  in_port_t *tmp___2 ;
  unsigned long tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  struct in_addr *tmp___6 ;
  uint32_t tmp___7 ;
  struct in_addr *tmp___8 ;
  uint32_t tmp___9 ;

  {
#line 2160
  a = 0UL;
#line 2165
  if ((int )loggedin == 0) {
    {
#line 2166
    addreply_noformat((int const   )530, (char const   */* const  */)"You aren\'t logged in");
    }
#line 2167
    return;
  }
#line 2169
  if (datafd != -1) {
    {
#line 2170
    close(datafd);
#line 2171
    datafd = -1;
    }
  }
  {
#line 2173
  fourinsix(& ctrlconn);
  }
#line 2174
  if ((int )ctrlconn.ss_family == 10) {
#line 2174
    if (psvtype == 0) {
      {
#line 2175
      addreply_noformat((int const   )425, (char const   */* const  */)"You cannot use PASV on IPv6 connections. Use EPSV instead.");
      }
#line 2176
      return;
    }
  }
  {
#line 2178
  tmp = zrand();
#line 2178
  firstporttried = firstport + tmp % ((lastport - firstport) + 1U);
#line 2179
  p = firstporttried;
#line 2180
  datafd = socket((int )ctrlconn.ss_family, 1, 6);
  }
#line 2181
  if (datafd == -1) {
    {
#line 2182
    error(425, "Unable to open a passive connection");
    }
#line 2183
    return;
  }
  {
#line 2185
  on = 1;
#line 2186
  tmp___0 = setsockopt(datafd, 1, 2, (void const   *)((char *)(& on)), (socklen_t )sizeof(on));
  }
#line 2186
  if (tmp___0 < 0) {
    {
#line 2188
    error(421, "setsockopt");
    }
#line 2189
    return;
  }
#line 2191
  dataconn = ctrlconn;
  {
#line 2192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2193
    if ((int )dataconn.ss_family == 10) {
      {
#line 2194
      tmp___1 = storage_port6((struct sockaddr_storage  const  */* const  */)(& dataconn));
#line 2194
      *tmp___1 = htons((uint16_t )p);
      }
    } else {
      {
#line 2196
      tmp___2 = storage_port((struct sockaddr_storage  const  */* const  */)(& dataconn));
#line 2196
      *tmp___2 = htons((uint16_t )p);
      }
    }
#line 2198
    if ((int )dataconn.ss_family == 2) {
#line 2198
      tmp___3 = sizeof(struct sockaddr_in );
    } else {
#line 2198
      tmp___3 = sizeof(struct sockaddr_in6 );
    }
    {
#line 2198
    tmp___4 = bind(datafd, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& dataconn)),
                   (socklen_t )tmp___3);
    }
#line 2198
    if (tmp___4 == 0) {
#line 2200
      goto while_break;
    }
#line 2202
    p --;
#line 2203
    if (p < firstport) {
#line 2204
      p = lastport;
    }
#line 2206
    if (p == firstporttried) {
      {
#line 2207
      close(datafd);
#line 2208
      datafd = -1;
#line 2209
      addreply_noformat((int const   )425, (char const   */* const  */)"All reserved TCP ports are busy");
      }
#line 2210
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2213
  alarm((unsigned int )idletime);
#line 2214
  tmp___5 = listen(datafd, 8);
  }
#line 2214
  if (tmp___5 < 0) {
    {
#line 2215
    close(datafd);
#line 2216
    datafd = -1;
#line 2217
    error(425, "Unable to identify the local data socket");
    }
#line 2218
    return;
  }
  {
#line 2221
  if (psvtype == 0) {
#line 2221
    goto case_0;
  }
#line 2243
  if (psvtype == 1) {
#line 2243
    goto case_1;
  }
#line 2246
  if (psvtype == 2) {
#line 2246
    goto case_2;
  }
#line 2249
  goto switch_default;
  case_0: /* CIL Label */ 
#line 2222
  if ((int )force_passive_ip.ss_family == 0) {
    {
#line 2223
    tmp___6 = storage_sin_addr((struct sockaddr_storage  const  */* const  */)(& dataconn));
#line 2223
    tmp___7 = ntohl(tmp___6->s_addr);
#line 2223
    a = (unsigned long )tmp___7;
    }
  } else
#line 2224
  if ((int )force_passive_ip.ss_family == 10) {
    {
#line 2225
    close(datafd);
#line 2226
    datafd = -1;
#line 2227
    addreply_noformat((int const   )425, (char const   */* const  */)"Please use an IPv6-conformant client with EPSV support");
    }
#line 2228
    return;
  } else
#line 2229
  if ((int )force_passive_ip.ss_family == 2) {
    {
#line 2230
    tmp___8 = storage_sin_addr((struct sockaddr_storage  const  */* const  */)(& force_passive_ip));
#line 2230
    tmp___9 = ntohl(tmp___8->s_addr);
#line 2230
    a = (unsigned long )tmp___9;
    }
  } else {
    {
#line 2232
    _EXIT((int const   )1);
    }
  }
  {
#line 2239
  addreply((int const   )227, (char const   */* const  */)"Entering Passive Mode (%lu,%lu,%lu,%lu,%u,%u)",
           (a >> 24) & 255UL, (a >> 16) & 255UL, (a >> 8) & 255UL, a & 255UL, (p >> 8) & 255U,
           p & 255U);
  }
#line 2242
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 2244
  addreply((int const   )229, (char const   */* const  */)"Extended Passive mode OK (|||%u|)",
           p);
  }
#line 2245
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 2247
  addreply((int const   )227, (char const   */* const  */)"%u", p);
  }
#line 2248
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 2250
  _EXIT((int const   )1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 2252
  passive = (signed char)1;
#line 2253
  return;
}
}
#line 2255 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void doport(char const   *arg ) 
{ 
  unsigned int a1 ;
  unsigned int a2 ;
  unsigned int a3 ;
  unsigned int a4 ;
  unsigned int p1 ;
  unsigned int p2 ;
  struct sockaddr_storage a ;
  int tmp ;
  struct in_addr *tmp___0 ;

  {
  {
#line 2260
  tmp = sscanf((char const   */* __restrict  */)arg, (char const   */* __restrict  */)"%u,%u,%u,%u,%u,%u",
               & a1, & a2, & a3, & a4, & p1, & p2);
  }
#line 2260
  if (tmp != 6) {
    {
#line 2265
    addreply_noformat((int const   )501, (char const   */* const  */)"Syntax error in IP address");
    }
#line 2266
    return;
  } else
#line 2260
  if (a1 > 255U) {
    {
#line 2265
    addreply_noformat((int const   )501, (char const   */* const  */)"Syntax error in IP address");
    }
#line 2266
    return;
  } else
#line 2260
  if (a2 > 255U) {
    {
#line 2265
    addreply_noformat((int const   )501, (char const   */* const  */)"Syntax error in IP address");
    }
#line 2266
    return;
  } else
#line 2260
  if (a3 > 255U) {
    {
#line 2265
    addreply_noformat((int const   )501, (char const   */* const  */)"Syntax error in IP address");
    }
#line 2266
    return;
  } else
#line 2260
  if (a4 > 255U) {
    {
#line 2265
    addreply_noformat((int const   )501, (char const   */* const  */)"Syntax error in IP address");
    }
#line 2266
    return;
  } else
#line 2260
  if (p1 > 255U) {
    {
#line 2265
    addreply_noformat((int const   )501, (char const   */* const  */)"Syntax error in IP address");
    }
#line 2266
    return;
  } else
#line 2260
  if (p2 > 255U) {
    {
#line 2265
    addreply_noformat((int const   )501, (char const   */* const  */)"Syntax error in IP address");
    }
#line 2266
    return;
  } else
#line 2260
  if ((((a1 | a2) | a3) | a4) == 0U) {
    {
#line 2265
    addreply_noformat((int const   )501, (char const   */* const  */)"Syntax error in IP address");
    }
#line 2266
    return;
  } else
#line 2260
  if ((p1 | p2) == 0U) {
    {
#line 2265
    addreply_noformat((int const   )501, (char const   */* const  */)"Syntax error in IP address");
    }
#line 2266
    return;
  }
  {
#line 2268
  memset((void *)(& a), 0, sizeof(a));
#line 2269
  a.ss_family = (sa_family_t )2;
#line 2270
  tmp___0 = storage_sin_addr((struct sockaddr_storage  const  */* const  */)(& a));
#line 2270
  tmp___0->s_addr = htonl((((a1 << 24) | (a2 << 16)) | (a3 << 8)) | a4);
#line 2273
  doport2(a, (p1 << 8) | p2);
  }
#line 2274
  return;
}
}
#line 2351 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static int doport3(int const   protocol ) 
{ 


  {
  {
#line 2353
  datafd = privsep_bindresport(protocol, (struct sockaddr_storage  const  )ctrlconn);
  }
#line 2353
  if (datafd == -1) {
    {
#line 2354
    error(425, "Can\'t create the data socket");
    }
#line 2356
    return (-1);
  }
#line 2358
  return (0);
}
}
#line 2363 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void doport2(struct sockaddr_storage a , unsigned int p ) 
{ 
  int tmp ;
  int tmp___0 ;
  char hbuf[1025] ;
  char peerbuf[1025] ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 2365
  if ((int )loggedin == 0) {
    {
#line 2366
    addreply_noformat((int const   )530, (char const   */* const  */)"You aren\'t logged in");
    }
#line 2367
    return;
  }
#line 2369
  if ((int )epsv_all != 0) {
    {
#line 2370
    addreply_noformat((int const   )501, (char const   */* const  */)"Active mode is disabled");
    }
#line 2371
    return;
  }
#line 2373
  if (datafd != -1) {
    {
#line 2374
    close(datafd);
#line 2375
    datafd = -1;
    }
  }
#line 2377
  if (p < 1024U) {
    {
#line 2378
    addreply_noformat((int const   )501, (char const   */* const  */)"Sorry, but I won\'t connect to ports < 1024");
    }
#line 2379
    return;
  }
#line 2381
  if ((int )a.ss_family == 10) {
#line 2381
    tmp = 10;
  } else {
#line 2381
    tmp = 2;
  }
  {
#line 2381
  tmp___0 = doport3((int const   )tmp);
  }
#line 2381
  if (tmp___0 != 0) {
#line 2382
    return;
  }
  {
#line 2384
  peerdataport = (in_port_t )p;
#line 2385
  tmp___5 = addrcmp((struct sockaddr_storage  const  */* const  */)(& a), (struct sockaddr_storage  const  */* const  */)(& peer));
  }
#line 2385
  if (tmp___5 != 0) {
#line 2389
    if ((int )a.ss_family == 2) {
#line 2389
      tmp___1 = sizeof(struct sockaddr_in );
    } else {
#line 2389
      tmp___1 = sizeof(struct sockaddr_in6 );
    }
    {
#line 2389
    tmp___2 = getnameinfo((struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& a)),
                          (socklen_t )tmp___1, (char */* __restrict  */)(hbuf), (socklen_t )sizeof(hbuf),
                          (char */* __restrict  */)((void *)0), (socklen_t )((size_t )0U),
                          1);
    }
#line 2389
    if (tmp___2 != 0) {
#line 2395
      goto hu;
    } else {
#line 2389
      if ((int )peer.ss_family == 2) {
#line 2389
        tmp___3 = sizeof(struct sockaddr_in );
      } else {
#line 2389
        tmp___3 = sizeof(struct sockaddr_in6 );
      }
      {
#line 2389
      tmp___4 = getnameinfo((struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& peer)),
                            (socklen_t )tmp___3, (char */* __restrict  */)(peerbuf),
                            (socklen_t )sizeof(peerbuf), (char */* __restrict  */)((void *)0),
                            (socklen_t )((size_t )0U), 1);
      }
#line 2389
      if (tmp___4 != 0) {
#line 2395
        goto hu;
      }
    }
#line 2397
    if ((int )allowfxp == 0) {
#line 2397
      goto hu;
    } else
#line 2397
    if ((int )allowfxp == 1) {
#line 2397
      if ((int )guest != 0) {
        hu: 
        {
#line 2399
        close(datafd);
#line 2400
        datafd = -1;
#line 2401
        addreply((int const   )500, (char const   */* const  */)"I won\'t open a connection to %s (only to %s)",
                 hbuf, peerbuf);
        }
#line 2402
        return;
      } else {
        {
#line 2404
        addreply((int const   )0, (char const   */* const  */)"FXP transfer: from %s to %s",
                 peerbuf, hbuf);
#line 2405
        memcpy((void */* __restrict  */)(& peer), (void const   */* __restrict  */)(& a),
               sizeof(a));
        }
      }
    } else {
      {
#line 2404
      addreply((int const   )0, (char const   */* const  */)"FXP transfer: from %s to %s",
               peerbuf, hbuf);
#line 2405
      memcpy((void */* __restrict  */)(& peer), (void const   */* __restrict  */)(& a),
             sizeof(a));
      }
    }
  }
  {
#line 2408
  passive = (signed char)0;
#line 2410
  addreply_noformat((int const   )200, (char const   */* const  */)"PORT command successful");
  }
#line 2411
  return;
}
}
#line 2414 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void closedata(void) 
{ 
  int volatile   tmp_xferfd ;

  {
  {
#line 2416
  tmp_xferfd = xferfd;
#line 2422
  xferfd = (int volatile   )-1;
#line 2423
  close((int )tmp_xferfd);
  }
#line 2424
  return;
}
}
#line 2426 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void opendata(void) 
{ 
  struct sockaddr_storage dataconn ;
  int fd ;
  socklen_t socksize ;
  struct pollfd pfds[2] ;
  struct pollfd *pfd ;
  int pollret ;
  int tmp ;
  struct sockaddr_storage peer2 ;
  unsigned long tries ;
  in_port_t *tmp___0 ;
  in_port_t *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  unsigned long tmp___7 ;
  int tmp___8 ;
  int fodder ;

  {
#line 2432
  if (xferfd != (int volatile   )-1) {
    {
#line 2433
    closedata();
    }
  }
#line 2435
  if (datafd == -1) {
    {
#line 2436
    addreply_noformat((int const   )425, (char const   */* const  */)"No data connection");
    }
#line 2437
    return;
  }
#line 2439
  if ((int )passive != 0) {
    {
#line 2444
    pfd = & pfds[0];
#line 2445
    pfd->fd = clientfd;
#line 2446
    pfd->events = (short)24;
#line 2447
    pfd->revents = (short)0;
#line 2449
    pfd = & pfds[1];
#line 2450
    pfd->fd = datafd;
#line 2451
    pfd->events = (short)25;
#line 2452
    pfd->revents = (short)0;
#line 2454
    alarm((unsigned int )idletime);
    }
    {
#line 2455
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 2456
      pfds[1].revents = (short)0;
#line 2456
      pfds[0].revents = pfds[1].revents;
#line 2457
      pollret = poll(pfds, sizeof(pfds) / sizeof(pfds[0]), (int )(idletime * 1000UL));
      }
#line 2458
      if (pollret <= 0) {
        {
#line 2459
        die((int const   )421, (int const   )6, (char const   */* const  */)"Timeout (no new data for %lu seconds)",
            idletime);
        }
      }
#line 2461
      if (((int )pfds[0].revents & 56) != 0) {
        {
#line 2463
        die((int const   )221, (int const   )6, (char const   */* const  */)"Logout.");
        }
      } else
#line 2461
      if (((int )pfds[1].revents & 56) != 0) {
        {
#line 2463
        die((int const   )221, (int const   )6, (char const   */* const  */)"Logout.");
        }
      }
#line 2465
      if (((int )pfds[1].revents & 1) == 0) {
#line 2466
        goto __Cont;
      }
      {
#line 2468
      socksize = (socklen_t )sizeof(dataconn);
#line 2469
      memset((void *)(& dataconn), 0, sizeof(dataconn));
#line 2470
      fd = accept(datafd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& dataconn)),
                  (socklen_t */* __restrict  */)(& socksize));
      }
#line 2470
      if (fd == -1) {
        nope: 
        {
#line 2473
        close(datafd);
#line 2474
        datafd = -1;
#line 2475
        error(421, "The connection couldn\'t be accepted");
        }
#line 2476
        return;
      }
#line 2478
      if ((int )dataconn.ss_family != 2) {
#line 2478
        if ((int )dataconn.ss_family != 10) {
          {
#line 2480
          close(fd);
          }
#line 2481
          goto nope;
        }
      }
      {
#line 2483
      fourinsix(& dataconn);
#line 2484
      tmp = addrcmp((struct sockaddr_storage  const  */* const  */)(& peer), (struct sockaddr_storage  const  */* const  */)(& dataconn));
      }
#line 2484
      if (tmp == 0) {
#line 2485
        goto while_break;
      }
#line 2487
      if ((int )allowfxp == 0) {
        {
#line 2488
        shutdown(fd, 2);
#line 2489
        close(fd);
        }
      } else
#line 2487
      if ((int )allowfxp == 1) {
#line 2487
        if ((int )guest != 0) {
          {
#line 2488
          shutdown(fd, 2);
#line 2489
          close(fd);
          }
        } else {
#line 2491
          goto while_break;
        }
      } else {
#line 2491
        goto while_break;
      }
      __Cont: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2494
    addreply_noformat((int const   )150, (char const   */* const  */)"Accepted data connection");
    }
  } else {
#line 2497
    tries = 1UL + idletime / 2UL;
#line 2499
    peer2 = peer;
#line 2500
    if ((int )peer.ss_family == 10) {
      {
#line 2501
      tmp___0 = storage_port6((struct sockaddr_storage  const  */* const  */)(& peer2));
#line 2501
      *tmp___0 = htons(peerdataport);
      }
    } else {
      {
#line 2503
      tmp___1 = storage_port((struct sockaddr_storage  const  */* const  */)(& peer2));
#line 2503
      *tmp___1 = htons(peerdataport);
      }
    }
    again: 
#line 2506
    if ((int )peer2.ss_family == 2) {
#line 2506
      tmp___7 = sizeof(struct sockaddr_in );
    } else {
#line 2506
      tmp___7 = sizeof(struct sockaddr_in6 );
    }
    {
#line 2506
    tmp___8 = connect(datafd, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& peer2)),
                      (socklen_t )tmp___7);
    }
#line 2506
    if (tmp___8 != 0) {
      {
#line 2508
      tmp___2 = __errno_location();
      }
#line 2508
      if (*tmp___2 == 11) {
#line 2508
        goto _L;
      } else {
        {
#line 2508
        tmp___3 = __errno_location();
        }
#line 2508
        if (*tmp___3 == 4) {
#line 2508
          goto _L;
        } else {
          {
#line 2508
          tmp___4 = __errno_location();
          }
#line 2508
          if (*tmp___4 == 98) {
            _L: /* CIL Label */ 
#line 2508
            if (tries > 0UL) {
              {
#line 2513
              tries --;
#line 2514
              usleep2((unsigned long const   )1000000UL);
              }
#line 2515
              goto again;
            }
          }
        }
      }
      {
#line 2517
      tmp___5 = __errno_location();
#line 2517
      tmp___6 = strerror(*tmp___5);
#line 2517
      addreply((int const   )425, (char const   */* const  */)"Could not open data connection to port %d: %s",
               (int )peerdataport, tmp___6);
#line 2519
      close(datafd);
#line 2520
      datafd = -1;
      }
#line 2521
      return;
    }
    {
#line 2523
    fd = datafd;
#line 2524
    datafd = -1;
#line 2525
    addreply((int const   )150, (char const   */* const  */)"Connecting to port %d",
             (int )peerdataport);
    }
  }
  {
#line 2531
  fodder = 8;
#line 2532
  setsockopt(fd, 0, 1, (void const   *)((char *)(& fodder)), (socklen_t )sizeof(fodder));
#line 2535
  keepalive((int const   )fd, 1);
#line 2538
  xferfd = (int volatile   )fd;
#line 2539
  alarm(86400U);
  }
#line 2540
  return;
}
}
#line 2545 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static dev_t root_st_dev  ;
#line 2546 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static ino_t root_st_ino  ;
#line 2543 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void dochmod(char *name___0 , mode_t mode ) 
{ 
  struct stat st2 ;
  int fd ;
  int tmp ;
  struct stat st ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 2548
  fd = -1;
#line 2550
  if ((int )nochmod != 0) {
#line 2550
    if (authresult.uid != 0U) {
      {
#line 2551
      addreply((int const   )550, (char const   */* const  */)"Could not change perms on %s",
               name___0);
      }
#line 2552
      return;
    }
  }
#line 2555
  if ((int )guest != 0) {
    {
#line 2556
    addreply_noformat((int const   )550, (char const   */* const  */)"Anonymous users can not change perms");
    }
#line 2557
    return;
  }
#line 2560
  if ((unsigned long )name___0 == (unsigned long )((void *)0)) {
    {
#line 2561
    addreply_noformat((int const   )501, (char const   */* const  */)"No file name");
    }
#line 2562
    return;
  } else
#line 2560
  if ((int )*name___0 == 0) {
    {
#line 2561
    addreply_noformat((int const   )501, (char const   */* const  */)"No file name");
    }
#line 2562
    return;
  }
  {
#line 2564
  tmp = checknamesanity((char const   *)name___0, (int )dot_write_ok);
  }
#line 2564
  if (tmp != 0) {
    {
#line 2565
    addreply((int const   )553, (char const   */* const  */)"Prohibited file name: %s",
             name___0);
    }
#line 2566
    return;
  }
  {
#line 2568
  fd = open((char const   *)name___0, 0);
  }
#line 2569
  if (fd == -1) {
#line 2570
    goto failure;
  }
#line 2572
  if ((root_st_dev | root_st_ino) == 0UL) {
    {
#line 2575
    tmp___0 = stat((char const   */* __restrict  */)"/", (struct stat */* __restrict  */)(& st));
    }
#line 2575
    if (tmp___0 != 0) {
#line 2576
      goto failure;
    }
#line 2578
    root_st_dev = st.st_dev;
#line 2579
    root_st_ino = st.st_ino;
  }
  {
#line 2581
  tmp___1 = fstat(fd, & st2);
  }
#line 2581
  if (tmp___1 != 0) {
#line 2582
    goto failure;
  }
#line 2589
  if (st2.st_ino == root_st_ino) {
#line 2589
    if (st2.st_dev == root_st_dev) {
#line 2590
      mode |= 448U;
    } else {
#line 2589
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2591
  if ((int )be_customer_proof != 0) {
#line 2592
    if ((st2.st_mode & 61440U) == 16384U) {
#line 2592
      tmp___2 = 448;
    } else {
#line 2592
      tmp___2 = 384;
    }
#line 2592
    mode |= (unsigned int )tmp___2;
  }
  {
#line 2594
  tmp___5 = fchmod(fd, mode);
  }
#line 2594
  if (tmp___5 < 0) {
    {
#line 2594
    tmp___6 = chmod((char const   *)name___0, mode);
    }
#line 2594
    if (tmp___6 < 0) {
      failure: 
#line 2596
      if (fd != -1) {
        {
#line 2597
        close(fd);
        }
      }
      {
#line 2599
      tmp___3 = __errno_location();
#line 2599
      tmp___4 = strerror(*tmp___3);
#line 2599
      addreply((int const   )550, (char const   */* const  */)"Could not change perms on %s: %s",
               name___0, tmp___4);
      }
#line 2600
      return;
    }
  }
  {
#line 2602
  close(fd);
#line 2603
  addreply((int const   )200, (char const   */* const  */)"Permissions changed on %s",
           name___0);
  }
#line 2604
  return;
}
}
#line 2606 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void doutime(char *name___0 , char const   * const  wanted_time ) 
{ 
  struct tm tm ;
  time_t ts ;
  struct utimbuf tb ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 2613
  if ((int )guest != 0) {
    {
#line 2614
    addreply_noformat((int const   )550, (char const   */* const  */)"Anonymous users can not change perms");
    }
#line 2615
    return;
  }
#line 2618
  if ((unsigned long )name___0 == (unsigned long )((void *)0)) {
    {
#line 2619
    addreply_noformat((int const   )501, (char const   */* const  */)"No file name");
    }
#line 2620
    return;
  } else
#line 2618
  if ((int )*name___0 == 0) {
    {
#line 2619
    addreply_noformat((int const   )501, (char const   */* const  */)"No file name");
    }
#line 2620
    return;
  }
  {
#line 2622
  tmp = checknamesanity((char const   *)name___0, (int )dot_write_ok);
  }
#line 2622
  if (tmp != 0) {
    {
#line 2623
    addreply((int const   )553, (char const   */* const  */)"Prohibited file name: %s",
             name___0);
    }
#line 2624
    return;
  }
  {
#line 2626
  memset((void *)(& tm), 0, sizeof(tm));
#line 2627
  sscanf((char const   */* __restrict  */)wanted_time, (char const   */* __restrict  */)"%4d%2d%2d%2d%2d%2d",
         & tm.tm_year, & tm.tm_mon, & tm.tm_mday, & tm.tm_hour, & tm.tm_min, & tm.tm_sec);
#line 2629
  (tm.tm_mon) --;
#line 2630
  tm.tm_year -= 1900;
#line 2635
  ts = timegm(& tm);
  }
#line 2650
  if (tm.tm_mon < 0) {
    {
#line 2651
    addreply_noformat((int const   )501, (char const   */* const  */)"Can\'t get a time stamp");
    }
#line 2652
    return;
  } else
#line 2650
  if (tm.tm_year <= 0) {
    {
#line 2651
    addreply_noformat((int const   )501, (char const   */* const  */)"Can\'t get a time stamp");
    }
#line 2652
    return;
  } else
#line 2650
  if (ts == -1L) {
    {
#line 2651
    addreply_noformat((int const   )501, (char const   */* const  */)"Can\'t get a time stamp");
    }
#line 2652
    return;
  }
  {
#line 2654
  tb.modtime = ts;
#line 2654
  tb.actime = tb.modtime;
#line 2655
  tmp___2 = utime((char const   *)name___0, (struct utimbuf  const  *)(& tb));
  }
#line 2655
  if (tmp___2 < 0) {
    {
#line 2656
    tmp___0 = __errno_location();
#line 2656
    tmp___1 = strerror(*tmp___0);
#line 2656
    addreply((int const   )550, (char const   */* const  */)"utime(%s): %s", name___0,
             tmp___1);
    }
  } else {
    {
#line 2658
    addreply_noformat((int const   )213, (char const   */* const  */)"UTIME OK");
    }
  }
#line 2660
  return;
}
}
#line 2663 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void dodele(char *name___0 ) 
{ 
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___3 ;
  size_t tmp___4 ;
  char const   *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;

  {
#line 2666
  if ((int )guest != 0) {
    {
#line 2667
    addreply_noformat((int const   )550, (char const   */* const  */)"Anonymous users can not delete files");
    }
#line 2668
    return;
  }
#line 2671
  if ((unsigned long )name___0 == (unsigned long )((void *)0)) {
    {
#line 2672
    addreply_noformat((int const   )501, (char const   */* const  */)"No file name");
    }
#line 2673
    return;
  } else
#line 2671
  if ((int )*name___0 == 0) {
    {
#line 2672
    addreply_noformat((int const   )501, (char const   */* const  */)"No file name");
    }
#line 2673
    return;
  }
  {
#line 2675
  tmp = checknamesanity((char const   *)name___0, (int )dot_write_ok);
  }
#line 2675
  if (tmp != 0) {
    {
#line 2676
    addreply((int const   )553, (char const   */* const  */)"Prohibited file name: %s",
             name___0);
    }
#line 2677
    return;
  }
#line 2679
  if ((int )keepallfiles != 0) {
    {
#line 2681
    tmp___0 = __errno_location();
#line 2681
    *tmp___0 = 1;
    }
#line 2685
    goto denied;
  }
  {
#line 2766
  tmp___1 = unlink((char const   *)name___0);
  }
#line 2766
  if (tmp___1 < 0) {
#line 2767
    goto denied;
  }
  {
#line 2770
  addreply((int const   )250, (char const   */* const  */)"Deleted %s%s%s%s", "",
           "", "", name___0);
  }
#line 2771
  if ((int )*name___0 != 47) {
#line 2771
    if (! wd[0]) {
#line 2771
      tmp___3 = "/";
    } else {
      {
#line 2771
      tmp___4 = strlen((char const   *)(wd));
      }
#line 2771
      if ((int )wd[tmp___4 - 1UL] != 47) {
#line 2771
        tmp___3 = "/";
      } else {
#line 2771
        tmp___3 = "";
      }
    }
  } else {
#line 2771
    tmp___3 = "";
  }
#line 2771
  if ((int )*name___0 == 47) {
#line 2771
    tmp___5 = "";
  } else {
#line 2771
    tmp___5 = (char const   *)(wd);
  }
  {
#line 2771
  logfile((int const   )5, "Deleted %s%s%s%s", root_directory, tmp___5, tmp___3, name___0);
  }
#line 2775
  return;
  denied: 
  {
#line 2778
  tmp___6 = __errno_location();
#line 2778
  tmp___7 = strerror(*tmp___6);
#line 2778
  addreply((int const   )550, (char const   */* const  */)"Could not delete %s: %s",
           name___0, tmp___7);
  }
#line 2779
  return;
}
}
#line 2781 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static double get_usec_time(void) 
{ 
  struct timeval tv ;
  struct timezone tz ;
  int tmp ;

  {
  {
#line 2786
  tmp = gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )(& tz));
  }
#line 2786
  if (tmp < 0) {
#line 2787
    return (0.0);
  }
#line 2789
  return ((double )tv.tv_sec + (double )tv.tv_usec / 1000000.0);
}
}
#line 2792 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static void displayrate(char const   *word , off_t size , double const   started ,
                        char const   * const  name___0 , int up ) 
{ 
  double ended ;
  double t ;
  double speed ;
  char speedstring[64] ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 2801
  ended = get_usec_time();
#line 2803
  t = ended - (double )started;
  }
#line 2804
  if (t > 0.0) {
#line 2804
    if (size > 0L) {
#line 2805
      speed = (double )size / t;
    } else {
#line 2807
      speed = 0.0;
    }
  } else {
#line 2807
    speed = 0.0;
  }
#line 2809
  if (speed > 524288.0) {
    {
#line 2810
    addreply((int const   )0, (char const   */* const  */)"%.3f seconds (measured here), %.2f Mbytes per second",
             t, speed / 1048576.0);
    }
  } else
#line 2811
  if (speed > 512.0) {
    {
#line 2812
    addreply((int const   )0, (char const   */* const  */)"%.3f seconds (measured here), %.2f Kbytes per second",
             t, speed / 1024.0);
    }
  } else
#line 2813
  if (speed > 0.1) {
    {
#line 2814
    addreply((int const   )0, (char const   */* const  */)"%.3f seconds (measured here), %.2f bytes per second",
             t, speed);
    }
  }
  {
#line 2816
  tmp___3 = snprintf((char */* __restrict  */)(speedstring), sizeof(speedstring),
                     (char const   */* __restrict  */)" (%llu bytes, %.2fKB/sec)",
                     (unsigned long long )size, speed / 1024.0);
  }
#line 2816
  if (! (tmp___3 >= (int )sizeof(speedstring))) {
#line 2820
    if ((int const   )*name___0 != 47) {
#line 2820
      if (! wd[0]) {
#line 2820
        tmp___0 = "/";
      } else {
        {
#line 2820
        tmp___1 = strlen((char const   *)(wd));
        }
#line 2820
        if ((int )wd[tmp___1 - 1UL] != 47) {
#line 2820
          tmp___0 = "/";
        } else {
#line 2820
          tmp___0 = "";
        }
      }
    } else {
#line 2820
      tmp___0 = "";
    }
#line 2820
    if ((int const   )*name___0 == 47) {
#line 2820
      tmp___2 = "";
    } else {
#line 2820
      tmp___2 = (char const   *)(wd);
    }
    {
#line 2820
    logfile((int const   )5, "%s%s%s%s %s %s", root_directory, tmp___2, tmp___0, name___0,
            word, speedstring);
    }
  }
#line 2892
  return;
}
}
#line 2894 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static void displayopenfailure(char const   * const  name___0 ) 
{ 
  char buffer[4138U] ;
  int e ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 2897
  tmp = __errno_location();
#line 2897
  e = *tmp;
#line 2899
  tmp___0 = snprintf((char */* __restrict  */)(buffer), sizeof(buffer), (char const   */* __restrict  */)"Can\'t open %s",
                     name___0);
  }
#line 2899
  if (tmp___0 >= (int )sizeof(buffer)) {
    {
#line 2901
    _EXIT((int const   )1);
    }
  }
  {
#line 2903
  tmp___1 = __errno_location();
#line 2903
  *tmp___1 = e;
#line 2904
  error(550, (char const   *)(buffer));
  }
#line 2905
  return;
}
}
#line 2907 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static int dlhandler_throttle(DLHandler * const  dlhandler , off_t const   downloaded___0 ,
                              double const   ts_start , double *required_sleep ) 
{ 
  double ts_now ;
  double elapsed ;
  off_t would_be_downloaded ;
  double wanted_ts ;
  off_t previous_chunk_size ;

  {
#line 2917
  if (dlhandler->bandwidth <= 0UL) {
#line 2918
    *required_sleep = 0.0;
#line 2919
    return (0);
  } else
#line 2917
  if (downloaded___0 <= 0L) {
#line 2918
    *required_sleep = 0.0;
#line 2919
    return (0);
  }
  {
#line 2921
  ts_now = get_usec_time();
  }
#line 2921
  if (ts_now <= 0.0) {
#line 2922
    ts_now = (double )ts_start;
  }
#line 2924
  if (ts_start > (double const   )ts_now) {
#line 2925
    ts_now = (double )ts_start;
  }
#line 2927
  elapsed = ts_now - (double )ts_start;
#line 2928
  would_be_downloaded = dlhandler->total_downloaded + dlhandler->chunk_size;
#line 2929
  if (dlhandler->bandwidth > 0UL) {
#line 2930
    wanted_ts = (double )would_be_downloaded / (double )dlhandler->bandwidth;
  } else {
#line 2933
    wanted_ts = elapsed;
  }
#line 2935
  *required_sleep = wanted_ts - elapsed;
#line 2936
  previous_chunk_size = dlhandler->chunk_size;
#line 2937
  if (dlhandler->total_downloaded <= dlhandler->chunk_size) {
#line 2938
    return (0);
  }
#line 2940
  if (*required_sleep < dlhandler->min_sleep) {
#line 2941
    dlhandler->chunk_size = (dlhandler->max_chunk_size + dlhandler->chunk_size) / 2L;
  } else
#line 2943
  if (*required_sleep > dlhandler->max_sleep) {
#line 2944
    dlhandler->chunk_size = (dlhandler->min_chunk_size + dlhandler->chunk_size) / 2L;
  } else {
#line 2947
    dlhandler->chunk_size = dlhandler->default_chunk_size;
  }
#line 2949
  if (dlhandler->chunk_size <= 0L) {
#line 2950
    dlhandler->chunk_size = dlhandler->default_chunk_size;
  } else
#line 2949
  if (dlhandler->chunk_size > 2147483647L) {
#line 2950
    dlhandler->chunk_size = dlhandler->default_chunk_size;
  }
#line 2952
  if (previous_chunk_size != dlhandler->default_chunk_size) {
#line 2953
    would_be_downloaded = dlhandler->total_downloaded + dlhandler->chunk_size;
#line 2955
    if (dlhandler->bandwidth > 0UL) {
#line 2956
      wanted_ts = (double )would_be_downloaded / (double )dlhandler->bandwidth;
    } else {
#line 2959
      wanted_ts = elapsed;
    }
#line 2961
    *required_sleep = wanted_ts - elapsed;
  }
#line 2963
  return (0);
}
}
#line 2966 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static int dlhandler_init(DLHandler * const  dlhandler , int const   clientfd___0 ,
                          void * const  tls_clientfd , int const   xferfd___0 , char const   * const  name___0 ,
                          int const   f , void * const  tls_fd , off_t const   restartat___0 ,
                          int const   ascii_mode , unsigned long const   bandwidth ) 
{ 
  struct stat st ;
  struct pollfd *pfd ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 2978
  tmp = fstat((int )f, & st);
  }
#line 2978
  if (tmp < 0) {
    {
#line 2979
    error(451, "Can\'t find file size");
    }
#line 2980
    return (-1);
  } else
#line 2978
  if ((st.st_mode & 61440U) == 40960U) {
    {
#line 2978
    tmp___0 = stat((char const   */* __restrict  */)name___0, (struct stat */* __restrict  */)(& st));
    }
#line 2978
    if (tmp___0 < 0) {
      {
#line 2979
      error(451, "Can\'t find file size");
      }
#line 2980
      return (-1);
    }
  }
#line 2982
  if (! ((st.st_mode & 61440U) == 32768U)) {
    {
#line 2983
    addreply_noformat((int const   )550, (char const   */* const  */)"I can only retrieve regular files");
    }
#line 2984
    return (-1);
  }
#line 2986
  dlhandler->clientfd = (int )clientfd___0;
#line 2987
  dlhandler->tls_clientfd = (void *)tls_clientfd;
#line 2988
  dlhandler->xferfd = (int )xferfd___0;
#line 2989
  dlhandler->f = (int )f;
#line 2990
  dlhandler->tls_fd = (void *)tls_fd;
#line 2991
  dlhandler->file_size = st.st_size;
#line 2992
  dlhandler->ascii_mode = (int )ascii_mode;
#line 2993
  dlhandler->cur_pos = (off_t )restartat___0;
#line 2994
  dlhandler->total_downloaded = (off_t )0;
#line 2995
  dlhandler->min_sleep = 0.1;
#line 2996
  dlhandler->max_sleep = 5.0;
#line 2997
  dlhandler->bandwidth = (unsigned long )bandwidth;
#line 2998
  pfd = & dlhandler->pfds_f_in;
#line 2999
  pfd->fd = (int )clientfd___0;
#line 3003
  pfd->events = (short)27;
#line 3005
  pfd->revents = (short)0;
#line 3007
  if (restartat___0 > 0L) {
#line 3008
    if (restartat___0 == (off_t const   )st.st_size) {
      {
#line 3009
      addreply_noformat((int const   )226, (char const   */* const  */)"Nothing left to download");
      }
#line 3010
      return (-2);
    } else
#line 3011
    if (restartat___0 > (off_t const   )st.st_size) {
      {
#line 3012
      addreply((int const   )554, (char const   */* const  */)"Restart offset %lld is too large for file size %lld.\nRestart offset reset to 0",
               (long long )restartat___0, (long long )st.st_size);
      }
#line 3014
      return (-1);
    }
  }
  {
#line 3017
  tmp___1 = fcntl((int )xferfd___0, 3);
#line 3017
  tmp___2 = fcntl((int )xferfd___0, 4, tmp___1 | 2048);
  }
#line 3017
  if (tmp___2 == -1) {
    {
#line 3018
    error(451, "fcntl(F_SETFL, O_NONBLOCK)");
    }
#line 3019
    return (-1);
  }
#line 3021
  return (0);
}
}
#line 3024 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static int dlmap_init(DLHandler * const  dlhandler , int const   clientfd___0 , void * const  tls_clientfd ,
                      int const   xferfd___0 , char const   * const  name___0 , int const   f ,
                      void * const  tls_fd , off_t const   restartat___0 , int const   ascii_mode ,
                      unsigned long const   bandwidth ) 
{ 
  int tmp ;
  off_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 3030
  tmp = dlhandler_init(dlhandler, clientfd___0, tls_clientfd, xferfd___0, name___0,
                       f, tls_fd, restartat___0, ascii_mode, bandwidth);
  }
#line 3030
  if (tmp != 0) {
#line 3032
    return (-1);
  }
#line 3034
  dlhandler->min_chunk_size = (off_t )8192;
#line 3035
  if (ascii_mode > 0) {
#line 3036
    tmp___0 = (off_t )32768UL;
#line 3036
    dlhandler->max_chunk_size = tmp___0;
#line 3036
    dlhandler->default_chunk_size = tmp___0;
  } else {
#line 3039
    dlhandler->max_chunk_size = (off_t )131072UL;
#line 3040
    if (bandwidth <= 0UL) {
#line 3041
      dlhandler->default_chunk_size = dlhandler->max_chunk_size;
    } else {
#line 3043
      dlhandler->default_chunk_size = (off_t )49152UL;
    }
  }
  {
#line 3046
  dlhandler->chunk_size = dlhandler->default_chunk_size;
#line 3047
  dlhandler->dlmap_size = ((131072UL + page_size) - 1UL) & ~ (page_size - 1UL);
#line 3049
  dlhandler->cur_pos = (off_t )restartat___0;
#line 3050
  dlhandler->dlmap_pos = (off_t )0;
#line 3051
  dlhandler->dlmap_fdpos = (off_t )-1;
#line 3052
  dlhandler->sizeof_map = (size_t )0U;
#line 3053
  dlhandler->map_data = (unsigned char *)((void *)0);
#line 3054
  dlhandler->sizeof_map = dlhandler->dlmap_size;
#line 3055
  tmp___1 = malloc(dlhandler->sizeof_map);
#line 3055
  dlhandler->map = (unsigned char *)tmp___1;
  }
#line 3056
  if ((unsigned long )dlhandler->map == (unsigned long )((void *)0)) {
    {
#line 3057
    die_mem();
    }
  }
#line 3059
  return (0);
}
}
#line 3062 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static int _dlmap_read(DLHandler * const  dlhandler ) 
{ 
  ssize_t readnb ;
  __off_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 3066
  if (dlhandler->dlmap_size > dlhandler->sizeof_map) {
    {
#line 3067
    abort();
    }
  }
#line 3069
  if (dlhandler->dlmap_size <= 0UL) {
#line 3070
    return (0);
  }
#line 3072
  if (dlhandler->dlmap_pos != dlhandler->dlmap_fdpos) {
    {
#line 3073
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 3074
      tmp = lseek(dlhandler->f, dlhandler->dlmap_pos, 0);
      }
#line 3074
      if (tmp == -1L) {
#line 3076
        dlhandler->dlmap_fdpos = (off_t )-1;
#line 3077
        return (-1);
      }
      {
#line 3079
      dlhandler->dlmap_fdpos = dlhandler->dlmap_pos;
#line 3080
      readnb = read(dlhandler->f, (void *)dlhandler->map, dlhandler->dlmap_size);
      }
#line 3073
      if (readnb == -1L) {
        {
#line 3073
        tmp___0 = __errno_location();
        }
#line 3073
        if (! (*tmp___0 == 4)) {
#line 3073
          goto while_break;
        }
      } else {
#line 3073
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 3083
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 3084
      readnb = read(dlhandler->f, (void *)dlhandler->map, dlhandler->dlmap_size);
      }
#line 3083
      if (readnb == -1L) {
        {
#line 3083
        tmp___1 = __errno_location();
        }
#line 3083
        if (! (*tmp___1 == 4)) {
#line 3083
          goto while_break___0;
        }
      } else {
#line 3083
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 3087
  if (readnb <= 0L) {
#line 3088
    dlhandler->dlmap_fdpos = (off_t )-1;
#line 3089
    return (-1);
  }
#line 3091
  if (readnb != (ssize_t )dlhandler->dlmap_size) {
#line 3092
    dlhandler->dlmap_fdpos = (off_t )-1;
  } else {
#line 3094
    dlhandler->dlmap_fdpos += readnb;
  }
#line 3096
  return (0);
}
}
#line 3099 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static int _dlmap_remap(DLHandler * const  dlhandler ) 
{ 
  size_t min_dlmap_size ;
  off_t remaining ;
  int tmp ;

  {
#line 3104
  if ((unsigned long )dlhandler->map_data != (unsigned long )((void *)0)) {
#line 3105
    if (dlhandler->cur_pos >= dlhandler->dlmap_pos) {
#line 3105
      if (dlhandler->cur_pos + dlhandler->chunk_size <= dlhandler->dlmap_pos + (off_t )dlhandler->dlmap_size) {
#line 3108
        if (dlhandler->cur_pos < dlhandler->dlmap_pos) {
          {
#line 3111
          addreply_noformat((int const   )451, (char const   */* const  */)"remap");
          }
#line 3112
          return (-1);
        } else
#line 3108
        if (dlhandler->cur_pos - dlhandler->dlmap_pos > (off_t )dlhandler->dlmap_size) {
          {
#line 3111
          addreply_noformat((int const   )451, (char const   */* const  */)"remap");
          }
#line 3112
          return (-1);
        }
#line 3114
        dlhandler->map_data = (dlhandler->map + dlhandler->cur_pos) - dlhandler->dlmap_pos;
#line 3116
        return (0);
      }
    }
  }
#line 3119
  if (dlhandler->file_size - dlhandler->cur_pos < dlhandler->chunk_size) {
#line 3120
    dlhandler->chunk_size = dlhandler->file_size - dlhandler->cur_pos;
  }
#line 3122
  if (dlhandler->chunk_size <= 0L) {
#line 3123
    return (1);
  }
#line 3125
  dlhandler->dlmap_pos = dlhandler->cur_pos;
#line 3126
  min_dlmap_size = (size_t )dlhandler->chunk_size;
#line 3127
  if (dlhandler->dlmap_size < min_dlmap_size) {
#line 3128
    dlhandler->dlmap_size = min_dlmap_size;
  }
#line 3130
  dlhandler->dlmap_size = ((dlhandler->dlmap_size + page_size) - 1UL) & ~ (page_size - 1UL);
#line 3132
  if (dlhandler->dlmap_size < page_size) {
#line 3133
    dlhandler->dlmap_size = page_size;
  }
#line 3135
  remaining = dlhandler->file_size - dlhandler->dlmap_pos;
#line 3136
  if ((off_t )dlhandler->dlmap_size > remaining) {
#line 3137
    dlhandler->dlmap_size = (size_t )remaining;
  }
  {
#line 3139
  tmp = _dlmap_read(dlhandler);
  }
#line 3139
  if (tmp != 0) {
    {
#line 3140
    error(451, "Error during read from data connection");
    }
#line 3141
    return (-1);
  }
#line 3143
  dlhandler->map_data = dlhandler->map;
#line 3145
  return (0);
}
}
#line 3148 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static int dl_dowrite(DLHandler * const  dlhandler , unsigned char const   *buf_ ,
                      size_t const   size_ , off_t * const  downloaded___0 ) 
{ 
  size_t size ;
  unsigned char const   *buf___1 ;
  unsigned char *asciibuf ;
  int ret ;
  unsigned char *asciibufpnt ;
  size_t z ;
  void *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 3151
  size = (size_t )size_;
#line 3152
  buf___1 = buf_;
#line 3153
  asciibuf = (unsigned char *)((void *)0);
#line 3154
  ret = 0;
#line 3156
  if (size_ <= 0UL) {
#line 3157
    *downloaded___0 = (off_t )0;
#line 3158
    return (-1);
  }
#line 3161
  if (dlhandler->ascii_mode > 0) {
#line 3163
    z = (size_t )0U;
#line 3165
    if (size > (size_t )dlhandler->chunk_size) {
#line 3167
      return (-1);
    } else {
      {
#line 3165
      tmp = __builtin_alloca((size_t )dlhandler->chunk_size * 2UL);
#line 3165
      asciibuf = (unsigned char *)tmp;
      }
#line 3165
      if ((unsigned long )asciibuf == (unsigned long )((void *)0)) {
#line 3167
        return (-1);
      }
    }
#line 3169
    asciibufpnt = asciibuf;
    {
#line 3170
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3171
      if ((int const   )*(buf_ + z) == 10) {
#line 3172
        tmp___0 = asciibufpnt;
#line 3172
        asciibufpnt ++;
#line 3172
        *tmp___0 = (unsigned char )'\r';
      }
#line 3174
      tmp___1 = asciibufpnt;
#line 3174
      asciibufpnt ++;
#line 3174
      *tmp___1 = (unsigned char )*(buf_ + z);
#line 3175
      z ++;
#line 3170
      if (! (z < size)) {
#line 3170
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 3177
    buf___1 = (unsigned char const   *)asciibuf;
#line 3178
    size = (size_t )(asciibufpnt - asciibuf);
  }
  {
#line 3181
  tmp___2 = safe_nonblock_write((int const   )dlhandler->xferfd, (void */* const  */)dlhandler->tls_fd,
                                (void const   *)buf___1, size);
#line 3181
  ret = (int )tmp___2;
  }
#line 3182
  if ((unsigned long )asciibuf != (unsigned long )((void *)0)) {
    {
#line 3183
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3183
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 3185
  if (ret < 0) {
#line 3186
    *downloaded___0 = (off_t )0;
  } else {
#line 3188
    *downloaded___0 = (off_t )size;
  }
#line 3190
  return (ret);
}
}
#line 3193 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static int dlhandler_handle_commands(DLHandler * const  dlhandler , double const   required_sleep ) 
{ 
  int pollret ;
  char buf___1[100] ;
  char *bufpnt ;
  ssize_t readnb ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
  repoll: 
#line 3202
  dlhandler->pfds_f_in.revents = (short)0;
#line 3203
  if (required_sleep <= (double const   )0.0) {
#line 3203
    tmp = 0;
  } else {
#line 3203
    tmp = (int )(required_sleep * (double const   )1000.0);
  }
  {
#line 3203
  pollret = poll(& dlhandler->pfds_f_in, (nfds_t )1U, tmp);
  }
#line 3206
  if (pollret <= 0) {
#line 3207
    return (pollret);
  }
#line 3209
  if (((int )dlhandler->pfds_f_in.revents & 3) != 0) {
#line 3210
    if ((unsigned long )dlhandler->tls_clientfd != (unsigned long )((void *)0)) {
      {
#line 3215
      abort();
      }
    } else {
      {
#line 3218
      readnb = read(dlhandler->clientfd, (void *)(buf___1), sizeof(buf___1) - 1UL);
      }
    }
#line 3220
    if (readnb == 0L) {
#line 3221
      return (-2);
    }
#line 3223
    if (readnb < 0L) {
      {
#line 3224
      tmp___0 = __errno_location();
      }
#line 3224
      if (*tmp___0 == 11) {
#line 3225
        return (0);
      } else {
        {
#line 3224
        tmp___1 = __errno_location();
        }
#line 3224
        if (*tmp___1 == 4) {
#line 3225
          return (0);
        }
      }
#line 3227
      return (-1);
    }
    {
#line 3229
    buf___1[readnb] = (char)0;
#line 3230
    bufpnt = skip_telnet_controls((char const   *)(buf___1));
#line 3231
    tmp___4 = strchr((char const   *)bufpnt, '\n');
    }
#line 3231
    if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
      {
#line 3232
      tmp___2 = strncasecmp((char const   *)bufpnt, "ABOR", sizeof("ABOR") - 1UL);
      }
#line 3232
      if (tmp___2 != 0) {
        {
#line 3232
        tmp___3 = strncasecmp((char const   *)bufpnt, "QUIT", sizeof("QUIT") - 1UL);
        }
#line 3232
        if (tmp___3 != 0) {
          {
#line 3234
          addreply_noformat((int const   )500, (char const   */* const  */)"Unknown command");
#line 3235
          doreply();
          }
        } else {
          {
#line 3237
          addreply_noformat((int const   )426, (char const   */* const  */)"ABORT");
#line 3238
          doreply();
#line 3239
          addreply_noformat((int const   )226, (char const   */* const  */)"Transfer aborted");
          }
#line 3240
          return (1);
        }
      } else {
        {
#line 3237
        addreply_noformat((int const   )426, (char const   */* const  */)"ABORT");
#line 3238
        doreply();
#line 3239
        addreply_noformat((int const   )226, (char const   */* const  */)"Transfer aborted");
        }
#line 3240
        return (1);
      }
    }
#line 3243
    if (required_sleep > (double const   )0.0) {
#line 3244
      goto repoll;
    }
  } else
#line 3246
  if (((int )dlhandler->pfds_f_in.revents & 56) != 0) {
    {
#line 3248
    addreply_noformat((int const   )451, (char const   */* const  */)"Error during read from data connection");
    }
#line 3249
    return (1);
  }
#line 3251
  return (0);
}
}
#line 3254 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static int dlmap_send(DLHandler * const  dlhandler ) 
{ 
  int ret ;
  double ts_start ;
  double required_sleep ;
  off_t downloaded___0 ;
  int tmp ;

  {
#line 3257
  ts_start = 0.0;
#line 3261
  if (dlhandler->bandwidth > 0UL) {
    {
#line 3261
    ts_start = get_usec_time();
    }
#line 3261
    if (ts_start <= 0.0) {
      {
#line 3262
      error(451, "gettimeofday()");
      }
#line 3263
      return (-1);
    }
  }
#line 3265
  required_sleep = 0.0;
  {
#line 3266
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3267
    ret = _dlmap_remap(dlhandler);
    }
#line 3268
    if (ret < 0) {
#line 3269
      return (-1);
    }
#line 3271
    if (ret == 1) {
#line 3272
      goto while_break;
    }
    {
#line 3274
    tmp = dl_dowrite(dlhandler, (unsigned char const   *)dlhandler->map_data, (size_t const   )dlhandler->chunk_size,
                     (off_t */* const  */)(& downloaded___0));
    }
#line 3274
    if (tmp != 0) {
#line 3276
      return (-1);
    }
#line 3278
    dlhandler->cur_pos += dlhandler->chunk_size;
#line 3284
    dlhandler->total_downloaded += downloaded___0;
#line 3285
    required_sleep = 0.0;
#line 3286
    if (dlhandler->bandwidth > 0UL) {
      {
#line 3287
      dlhandler_throttle(dlhandler, (off_t const   )downloaded___0, (double const   )ts_start,
                         & required_sleep);
      }
    }
    {
#line 3290
    ret = dlhandler_handle_commands(dlhandler, (double const   )required_sleep);
    }
#line 3291
    if (ret != 0) {
#line 3292
      return (ret);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3295
  return (0);
}
}
#line 3298 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static int dlmap_exit(DLHandler * const  dlhandler ) 
{ 


  {
#line 3300
  if ((unsigned long )dlhandler->map != (unsigned long )((void *)0)) {
    {
#line 3301
    free((void *)dlhandler->map);
#line 3302
    dlhandler->map = (unsigned char *)((void *)0);
#line 3303
    dlhandler->sizeof_map = (size_t )0U;
#line 3304
    dlhandler->dlmap_size = (size_t )0U;
    }
  }
#line 3306
  return (0);
}
}
#line 3309 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void doretr(char *name___0 ) 
{ 
  DLHandler dlhandler ;
  int f ;
  struct stat st ;
  double started ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  time_t tmp___2 ;
  int tmp___3 ;

  {
#line 3314
  started = 0.0;
#line 3317
  if (! candownload) {
    {
#line 3318
    addreply((int const   )550, (char const   */* const  */)"The load was %3.2f when you connected. We do not allow downloads\nby anonymous users when the load is that high. Uploads are always\nallowed.",
             load);
    }
#line 3319
    goto end;
  }
#line 3321
  if ((int )type < 1) {
    {
#line 3322
    addreply_noformat((int const   )503, (char const   */* const  */)"ASCII resume is unsafe, please delete the file first");
    }
#line 3323
    goto end;
  } else
#line 3321
  if ((int )type == 1) {
#line 3321
    if (restartat > 1L) {
      {
#line 3322
      addreply_noformat((int const   )503, (char const   */* const  */)"ASCII resume is unsafe, please delete the file first");
      }
#line 3323
      goto end;
    }
  }
  {
#line 3325
  tmp = checknamesanity((char const   *)name___0, (int )dot_read_ok);
  }
#line 3325
  if (tmp != 0) {
    {
#line 3326
    addreply((int const   )553, (char const   */* const  */)"Prohibited file name: %s",
             name___0);
    }
#line 3327
    goto end;
  }
  {
#line 3329
  f = open((char const   *)name___0, 0);
  }
#line 3329
  if (f == -1) {
    {
#line 3330
    displayopenfailure((char const   */* const  */)name___0);
    }
#line 3331
    goto end;
  }
  {
#line 3333
  tmp___0 = fstat(f, & st);
  }
#line 3333
  if (tmp___0 < 0) {
    stat_failure: 
    {
#line 3335
    close(f);
#line 3336
    error(451, "Can\'t find file size");
    }
#line 3337
    goto end;
  }
#line 3339
  if ((st.st_mode & 61440U) == 40960U) {
    {
#line 3340
    tmp___1 = stat((char const   */* __restrict  */)name___0, (struct stat */* __restrict  */)(& st));
    }
#line 3340
    if (tmp___1 < 0) {
#line 3341
      goto stat_failure;
    }
  }
#line 3344
  if (restartat > st.st_size) {
    {
#line 3345
    close(f);
#line 3346
    addreply((int const   )554, (char const   */* const  */)"Restart offset %lld is too large for file size %lld.\nRestart offset reset to 0",
             (long long )restartat, (long long )st.st_size);
    }
#line 3348
    goto end;
  }
#line 3350
  if (! ((st.st_mode & 61440U) == 32768U)) {
    {
#line 3351
    close(f);
#line 3352
    addreply_noformat((int const   )550, (char const   */* const  */)"I can only retrieve regular files");
    }
#line 3353
    goto end;
  } else
#line 3350
  if (st.st_size != st.st_size) {
    {
#line 3351
    close(f);
#line 3352
    addreply_noformat((int const   )550, (char const   */* const  */)"I can only retrieve regular files");
    }
#line 3353
    goto end;
  }
#line 3355
  if (warez != 0U) {
#line 3355
    if (st.st_uid == warez) {
#line 3355
      if ((int )guest != 0) {
        {
#line 3356
        close(f);
#line 3357
        addreply((int const   )550, (char const   */* const  */)"This file has been uploaded by an anonymous user. It has not\nyet been approved for downloading by the site administrators.");
        }
#line 3358
        goto end;
      }
    }
  }
  {
#line 3372
  opendata();
  }
#line 3373
  if (xferfd == (int volatile   )-1) {
    {
#line 3374
    close(f);
    }
#line 3375
    goto end;
  }
  {
#line 3378
  tmp___2 = time((time_t *)((void *)0));
  }
#line 3378
  if (tmp___2 % 100L == 0L) {
    {
#line 3379
    addreply_noformat((int const   )0, (char const   */* const  */)"The computer is your friend. Trust the computer");
    }
  }
#line 3382
  if (st.st_size - restartat > 4096L) {
    {
#line 3383
    addreply((int const   )0, (char const   */* const  */)"%.1f kbytes to download",
             (double )(st.st_size - restartat) / 1024.0);
    }
  }
  {
#line 3385
  doreply();
#line 3391
  state_needs_update = (signed char)1;
#line 3392
  setprocessname((char const   */* const  */)"pure-ftpd (DOWNLOAD)");
#line 3416
  posix_fadvise(f, (off_t )0, st.st_size, 2);
#line 3419
  started = get_usec_time();
#line 3421
  tmp___3 = dlmap_init((DLHandler */* const  */)(& dlhandler), (int const   )clientfd,
                       (void */* const  */)tls_cnx, (int const   )xferfd, (char const   */* const  */)name___0,
                       (int const   )f, (void */* const  */)tls_data_cnx, (off_t const   )restartat,
                       (int const   )((int )type == 1), (unsigned long const   )throttling_bandwidth_dl);
  }
#line 3421
  if (tmp___3 == 0) {
    {
#line 3424
    ret = dlmap_send((DLHandler */* const  */)(& dlhandler));
#line 3425
    dlmap_exit((DLHandler */* const  */)(& dlhandler));
    }
  } else {
#line 3427
    ret = -1;
  }
  {
#line 3430
  close(f);
#line 3431
  closedata();
  }
#line 3432
  if (ret == 0) {
    {
#line 3433
    addreply_noformat((int const   )226, (char const   */* const  */)"File successfully transferred");
    }
  }
  {
#line 3435
  downloaded += (unsigned long long )dlhandler.total_downloaded;
#line 3436
  displayrate("downloaded", dlhandler.total_downloaded, (double const   )started,
              (char const   */* const  */)name___0, 0);
  }
  end: 
#line 3439
  restartat = (off_t )0;
#line 3440
  return;
}
}
#line 3442 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void dorest(char const   *name___0 ) 
{ 
  char *endptr ;
  unsigned long long tmp ;

  {
  {
#line 3446
  tmp = strtoull((char const   */* __restrict  */)name___0, (char **/* __restrict  */)(& endptr),
                 10);
#line 3446
  restartat = (off_t )tmp;
  }
#line 3447
  if ((int )*endptr != 0) {
    {
#line 3448
    restartat = (off_t )0;
#line 3449
    addreply((int const   )554, (char const   */* const  */)"REST needs a numeric parameter\nRestart offset reset to 0");
    }
  } else
#line 3447
  if (restartat < 0L) {
    {
#line 3448
    restartat = (off_t )0;
#line 3449
    addreply((int const   )554, (char const   */* const  */)"REST needs a numeric parameter\nRestart offset reset to 0");
    }
  } else
#line 3451
  if ((int )type == 1) {
#line 3451
    if (restartat != 0L) {
      {
#line 3455
      addreply((int const   )350, (char const   */* const  */)"Restarting at %lld. But we\'re in ASCII mode",
               (long long )restartat);
      }
    } else {
#line 3451
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 3459
    if (restartat != 0L) {
      {
#line 3460
      logfile((int const   )5, "Restarting at %lld", (long long )restartat);
      }
    }
    {
#line 3462
    addreply((int const   )350, (char const   */* const  */)"Restarting at %lld",
             (long long )restartat);
    }
  }
#line 3465
  return;
}
}
#line 3467 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void domkd(char *name___0 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 3474
  if ((int )guest != 0) {
#line 3474
    if (allow_anon_mkdir == 0) {
      {
#line 3475
      addreply_noformat((int const   )550, (char const   */* const  */)"Sorry, anonymous users are not allowed to create directories");
      }
#line 3476
      return;
    }
  }
  {
#line 3478
  tmp = checknamesanity((char const   *)name___0, (int )dot_write_ok);
  }
#line 3478
  if (tmp != 0) {
    {
#line 3479
    addreply_noformat((int const   )553, (char const   */* const  */)"Prohibited directory name");
    }
#line 3480
    return;
  }
  {
#line 3489
  tmp___0 = mkdir((char const   *)name___0, 511U & ~ u_mask_d);
  }
#line 3489
  if (tmp___0 < 0) {
    {
#line 3493
    error(550, "Can\'t create directory");
    }
  } else {
    {
#line 3495
    addreply((int const   )257, (char const   */* const  */)"\"%s\" : The directory was successfully created",
             name___0);
#line 3497
    cwd_failures = 0UL;
    }
  }
#line 3504
  return;
}
}
#line 3506 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void dormd(char *name___0 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 3513
  if ((int )guest != 0) {
    {
#line 3514
    addreply_noformat((int const   )550, (char const   */* const  */)"Sorry, anonymous users are not allowed to remove directories");
    }
#line 3515
    return;
  }
  {
#line 3518
  tmp = checknamesanity((char const   *)name___0, (int )dot_write_ok);
  }
#line 3518
  if (tmp != 0) {
    {
#line 3519
    addreply_noformat((int const   )553, (char const   */* const  */)"Prohibited directory name");
    }
#line 3520
    return;
  }
  {
#line 3522
  tmp___0 = rmdir((char const   *)name___0);
  }
#line 3522
  if (tmp___0 < 0) {
    {
#line 3523
    error(550, "Can\'t remove directory");
    }
  } else {
    {
#line 3530
    addreply_noformat((int const   )250, (char const   */* const  */)"The directory was successfully removed");
    }
  }
#line 3532
  return;
}
}
#line 3535 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void dofeat(void) 
{ 
  char feat[193] ;

  {
#line 3574
  feat[0] = (char )'E';
#line 3574
  feat[1] = (char )'x';
#line 3574
  feat[2] = (char )'t';
#line 3574
  feat[3] = (char )'e';
#line 3574
  feat[4] = (char )'n';
#line 3574
  feat[5] = (char )'s';
#line 3574
  feat[6] = (char )'i';
#line 3574
  feat[7] = (char )'o';
#line 3574
  feat[8] = (char )'n';
#line 3574
  feat[9] = (char )'s';
#line 3574
  feat[10] = (char )' ';
#line 3574
  feat[11] = (char )'s';
#line 3574
  feat[12] = (char )'u';
#line 3574
  feat[13] = (char )'p';
#line 3574
  feat[14] = (char )'p';
#line 3574
  feat[15] = (char )'o';
#line 3574
  feat[16] = (char )'r';
#line 3574
  feat[17] = (char )'t';
#line 3574
  feat[18] = (char )'e';
#line 3574
  feat[19] = (char )'d';
#line 3574
  feat[20] = (char )':';
#line 3574
  feat[21] = (char )'\r';
#line 3574
  feat[22] = (char )'\n';
#line 3574
  feat[23] = (char )' ';
#line 3574
  feat[24] = (char )'E';
#line 3574
  feat[25] = (char )'P';
#line 3574
  feat[26] = (char )'R';
#line 3574
  feat[27] = (char )'T';
#line 3574
  feat[28] = (char )'\r';
#line 3574
  feat[29] = (char )'\n';
#line 3574
  feat[30] = (char )' ';
#line 3574
  feat[31] = (char )'I';
#line 3574
  feat[32] = (char )'D';
#line 3574
  feat[33] = (char )'L';
#line 3574
  feat[34] = (char )'E';
#line 3574
  feat[35] = (char )'\r';
#line 3574
  feat[36] = (char )'\n';
#line 3574
  feat[37] = (char )' ';
#line 3574
  feat[38] = (char )'M';
#line 3574
  feat[39] = (char )'D';
#line 3574
  feat[40] = (char )'T';
#line 3574
  feat[41] = (char )'M';
#line 3574
  feat[42] = (char )'\r';
#line 3574
  feat[43] = (char )'\n';
#line 3574
  feat[44] = (char )' ';
#line 3574
  feat[45] = (char )'S';
#line 3574
  feat[46] = (char )'I';
#line 3574
  feat[47] = (char )'Z';
#line 3574
  feat[48] = (char )'E';
#line 3574
  feat[49] = (char )'\r';
#line 3574
  feat[50] = (char )'\n';
#line 3574
  feat[51] = (char )' ';
#line 3574
  feat[52] = (char )'M';
#line 3574
  feat[53] = (char )'F';
#line 3574
  feat[54] = (char )'M';
#line 3574
  feat[55] = (char )'T';
#line 3574
  feat[56] = (char )'\r';
#line 3574
  feat[57] = (char )'\n';
#line 3574
  feat[58] = (char )' ';
#line 3574
  feat[59] = (char )'R';
#line 3574
  feat[60] = (char )'E';
#line 3574
  feat[61] = (char )'S';
#line 3574
  feat[62] = (char )'T';
#line 3574
  feat[63] = (char )' ';
#line 3574
  feat[64] = (char )'S';
#line 3574
  feat[65] = (char )'T';
#line 3574
  feat[66] = (char )'R';
#line 3574
  feat[67] = (char )'E';
#line 3574
  feat[68] = (char )'A';
#line 3574
  feat[69] = (char )'M';
#line 3574
  feat[70] = (char )'\r';
#line 3574
  feat[71] = (char )'\n';
#line 3574
  feat[72] = (char )' ';
#line 3574
  feat[73] = (char )'M';
#line 3574
  feat[74] = (char )'L';
#line 3574
  feat[75] = (char )'S';
#line 3574
  feat[76] = (char )'T';
#line 3574
  feat[77] = (char )' ';
#line 3574
  feat[78] = (char )'t';
#line 3574
  feat[79] = (char )'y';
#line 3574
  feat[80] = (char )'p';
#line 3574
  feat[81] = (char )'e';
#line 3574
  feat[82] = (char )'*';
#line 3574
  feat[83] = (char )';';
#line 3574
  feat[84] = (char )'s';
#line 3574
  feat[85] = (char )'i';
#line 3574
  feat[86] = (char )'z';
#line 3574
  feat[87] = (char )'e';
#line 3574
  feat[88] = (char )'*';
#line 3574
  feat[89] = (char )';';
#line 3574
  feat[90] = (char )'s';
#line 3574
  feat[91] = (char )'i';
#line 3574
  feat[92] = (char )'z';
#line 3574
  feat[93] = (char )'d';
#line 3574
  feat[94] = (char )'*';
#line 3574
  feat[95] = (char )';';
#line 3574
  feat[96] = (char )'m';
#line 3574
  feat[97] = (char )'o';
#line 3574
  feat[98] = (char )'d';
#line 3574
  feat[99] = (char )'i';
#line 3574
  feat[100] = (char )'f';
#line 3574
  feat[101] = (char )'y';
#line 3574
  feat[102] = (char )'*';
#line 3574
  feat[103] = (char )';';
#line 3574
  feat[104] = (char )'U';
#line 3574
  feat[105] = (char )'N';
#line 3574
  feat[106] = (char )'I';
#line 3574
  feat[107] = (char )'X';
#line 3574
  feat[108] = (char )'.';
#line 3574
  feat[109] = (char )'m';
#line 3574
  feat[110] = (char )'o';
#line 3574
  feat[111] = (char )'d';
#line 3574
  feat[112] = (char )'e';
#line 3574
  feat[113] = (char )'*';
#line 3574
  feat[114] = (char )';';
#line 3574
  feat[115] = (char )'U';
#line 3574
  feat[116] = (char )'N';
#line 3574
  feat[117] = (char )'I';
#line 3574
  feat[118] = (char )'X';
#line 3574
  feat[119] = (char )'.';
#line 3574
  feat[120] = (char )'u';
#line 3574
  feat[121] = (char )'i';
#line 3574
  feat[122] = (char )'d';
#line 3574
  feat[123] = (char )'*';
#line 3574
  feat[124] = (char )';';
#line 3574
  feat[125] = (char )'U';
#line 3574
  feat[126] = (char )'N';
#line 3574
  feat[127] = (char )'I';
#line 3574
  feat[128] = (char )'X';
#line 3574
  feat[129] = (char )'.';
#line 3574
  feat[130] = (char )'g';
#line 3574
  feat[131] = (char )'i';
#line 3574
  feat[132] = (char )'d';
#line 3574
  feat[133] = (char )'*';
#line 3574
  feat[134] = (char )';';
#line 3574
  feat[135] = (char )'u';
#line 3574
  feat[136] = (char )'n';
#line 3574
  feat[137] = (char )'i';
#line 3574
  feat[138] = (char )'q';
#line 3574
  feat[139] = (char )'u';
#line 3574
  feat[140] = (char )'e';
#line 3574
  feat[141] = (char )'*';
#line 3574
  feat[142] = (char )';';
#line 3574
  feat[143] = (char )'\r';
#line 3574
  feat[144] = (char )'\n';
#line 3574
  feat[145] = (char )' ';
#line 3574
  feat[146] = (char )'M';
#line 3574
  feat[147] = (char )'L';
#line 3574
  feat[148] = (char )'S';
#line 3574
  feat[149] = (char )'D';
#line 3574
  feat[150] = (char )'\r';
#line 3574
  feat[151] = (char )'\n';
#line 3574
  feat[152] = (char )' ';
#line 3574
  feat[153] = (char )'T';
#line 3574
  feat[154] = (char )'V';
#line 3574
  feat[155] = (char )'F';
#line 3574
  feat[156] = (char )'S';
#line 3574
  feat[157] = (char )'\r';
#line 3574
  feat[158] = (char )'\n';
#line 3574
  feat[159] = (char )' ';
#line 3574
  feat[160] = (char )'E';
#line 3574
  feat[161] = (char )'S';
#line 3574
  feat[162] = (char )'T';
#line 3574
  feat[163] = (char )'A';
#line 3574
  feat[164] = (char )'\r';
#line 3574
  feat[165] = (char )'\n';
#line 3574
  feat[166] = (char )' ';
#line 3574
  feat[167] = (char )'P';
#line 3574
  feat[168] = (char )'A';
#line 3574
  feat[169] = (char )'S';
#line 3574
  feat[170] = (char )'V';
#line 3574
  feat[171] = (char )'\r';
#line 3574
  feat[172] = (char )'\n';
#line 3574
  feat[173] = (char )' ';
#line 3574
  feat[174] = (char )'E';
#line 3574
  feat[175] = (char )'P';
#line 3574
  feat[176] = (char )'S';
#line 3574
  feat[177] = (char )'V';
#line 3574
  feat[178] = (char )'\r';
#line 3574
  feat[179] = (char )'\n';
#line 3574
  feat[180] = (char )' ';
#line 3574
  feat[181] = (char )'S';
#line 3574
  feat[182] = (char )'P';
#line 3574
  feat[183] = (char )'S';
#line 3574
  feat[184] = (char )'V';
#line 3574
  feat[185] = (char )'\r';
#line 3574
  feat[186] = (char )'\n';
#line 3574
  feat[187] = (char )' ';
#line 3574
  feat[188] = (char )'E';
#line 3574
  feat[189] = (char )'S';
#line 3574
  feat[190] = (char )'T';
#line 3574
  feat[191] = (char )'P';
#line 3574
  feat[192] = (char )'\000';
#line 3576
  if ((int )disallow_passive != 0) {
#line 3577
    feat[sizeof("Extensions supported:\r\n EPRT\r\n IDLE\r\n MDTM\r\n SIZE\r\n MFMT\r\n REST STREAM\r\n MLST type*;size*;sizd*;modify*;UNIX.mode*;UNIX.uid*;UNIX.gid*;unique*;\r\n MLSD\r\n TVFS\r\n ESTA")] = (char)0;
  } else
#line 3580
  if ((int )force_passive_ip.ss_family != 0) {
#line 3581
    feat[sizeof("Extensions supported:\r\n EPRT\r\n IDLE\r\n MDTM\r\n SIZE\r\n MFMT\r\n REST STREAM\r\n MLST type*;size*;sizd*;modify*;UNIX.mode*;UNIX.uid*;UNIX.gid*;unique*;\r\n MLSD\r\n TVFS\r\n ESTA\r\n PASV\r\n EPSV\r\n SPSV")] = (char)0;
  }
  {
#line 3584
  addreply_noformat((int const   )0, (char const   */* const  */)(feat));
#line 3585
  addreply_noformat((int const   )211, (char const   */* const  */)"End.");
  }
#line 3586
  return;
}
}
#line 3593 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static unsigned int seq  =    0U;
#line 3590 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void dostou(void) 
{ 
  char file[64] ;
  struct timeval tv ;
  struct timezone tz ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 3597
  tmp = gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )(& tz));
  }
#line 3597
  if (tmp != 0) {
    {
#line 3598
    error(553, "Can\'t get a time stamp");
    }
#line 3599
    return;
  }
  {
#line 3601
  tmp___0 = snprintf((char */* __restrict  */)(file), sizeof(file), (char const   */* __restrict  */)"pureftpd.%08lx.%02lx.%04x",
                     (unsigned long )tv.tv_sec, (unsigned long )tv.tv_usec & 255UL,
                     seq);
  }
#line 3601
  if (tmp___0 >= (int )sizeof(file)) {
    {
#line 3605
    _EXIT((int const   )1);
    }
  }
  {
#line 3607
  seq ++;
#line 3608
  seq &= 65535U;
#line 3609
  addreply((int const   )150, (char const   */* const  */)"FILE: %s", file);
#line 3610
  dostor(file, (int const   )0, (int const   )1);
  }
#line 3611
  return;
}
}
#line 3617 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static char name2[4096]  ;
#line 3614 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static int tryautorename(char const   * const  atomic_file , char * const  name___0 ,
                         char const   ** const  name2_ ) 
{ 
  unsigned int gc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 3618
  gc = 0U;
#line 3620
  tmp = link((char const   *)atomic_file, (char const   *)name___0);
  }
#line 3620
  if (tmp == 0) {
    {
#line 3621
    *name2_ = (char const   *)((void *)0);
#line 3622
    unlink((char const   *)atomic_file);
    }
#line 3623
    return (0);
  }
#line 3625
  *name2_ = (char const   *)(name2);
  {
#line 3626
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3627
    gc ++;
#line 3628
    if (gc == 0U) {
#line 3637
      goto while_break;
    } else {
      {
#line 3628
      tmp___0 = snprintf((char */* __restrict  */)(name2), sizeof(name2), (char const   */* __restrict  */)"%s.%u",
                         name___0, gc);
      }
#line 3628
      if (tmp___0 >= (int )sizeof(name2)) {
#line 3637
        goto while_break;
      }
    }
    {
#line 3639
    tmp___1 = link((char const   *)atomic_file, (char const   *)(name2));
    }
#line 3639
    if (tmp___1 == 0) {
      {
#line 3640
      unlink((char const   *)atomic_file);
      }
#line 3641
      return (0);
    }
    {
#line 3643
    tmp___2 = __errno_location();
    }
    {
#line 3651
    if (*tmp___2 == 26) {
#line 3651
      goto case_26;
    }
#line 3651
    if (*tmp___2 == 21) {
#line 3651
      goto case_26;
    }
#line 3651
    if (*tmp___2 == 17) {
#line 3651
      goto case_26;
    }
#line 3643
    goto switch_break;
    case_26: /* CIL Label */ 
    case_21: /* CIL Label */ 
    case_17: /* CIL Label */ 
#line 3653
    goto __Cont;
    switch_break: /* CIL Label */ ;
    }
#line 3655
    goto while_break;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3657
  *name2_ = (char const   *)((void *)0);
#line 3659
  return (-1);
}
}
#line 3664 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static char res[4096]  ;
#line 3662 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static char *get_atomic_file(char const   * const  file ) 
{ 
  char *z ;
  size_t orig_len ;
  size_t slash ;
  size_t sizeof_atomic_prefix ;
  size_t tmp ;

  {
#line 3670
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 3671
    return (res);
  }
  {
#line 3673
  z = strrchr((char const   *)file, '/');
  }
#line 3673
  if ((unsigned long )z == (unsigned long )((void *)0)) {
#line 3674
    res[0] = (char)0;
#line 3675
    orig_len = (size_t )0U;
  } else {
#line 3677
    slash = (size_t )(z - (char *)file);
#line 3678
    if (slash >= sizeof(res) - 1UL) {
#line 3679
      return ((char *)((void *)0));
    }
#line 3681
    slash ++;
#line 3682
    if ((int const   )*(file + slash) == 0) {
#line 3683
      return ((char *)((void *)0));
    }
    {
#line 3685
    strncpy((char */* __restrict  */)(res), (char const   */* __restrict  */)file,
            slash);
#line 3686
    res[slash] = (char)0;
#line 3687
    orig_len = strlen((char const   *)(res));
    }
  }
  {
#line 3689
  tmp = strlen((char const   *)atomic_prefix);
#line 3689
  sizeof_atomic_prefix = tmp + 1UL;
  }
#line 3690
  if (sizeof(res) - orig_len < sizeof_atomic_prefix) {
#line 3691
    return ((char *)((void *)0));
  }
  {
#line 3693
  memcpy((void */* __restrict  */)(res + orig_len), (void const   */* __restrict  */)atomic_prefix,
         sizeof_atomic_prefix);
  }
#line 3695
  return (res);
}
}
#line 3698 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void delete_atomic_file(void) 
{ 
  char const   *atomic_file ;
  char *tmp ;

  {
  {
#line 3702
  tmp = get_atomic_file((char const   */* const  */)((void *)0));
#line 3702
  atomic_file = (char const   *)tmp;
  }
#line 3702
  if ((unsigned long )atomic_file == (unsigned long )((void *)0)) {
#line 3703
    return;
  } else
#line 3702
  if ((int const   )*atomic_file == 0) {
#line 3703
    return;
  }
  {
#line 3705
  unlink(atomic_file);
#line 3706
  atomic_file = (char const   *)((void *)0);
  }
#line 3707
  return;
}
}
#line 3709 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static off_t get_file_size(char const   * const  file ) 
{ 
  struct stat st ;
  int tmp ;

  {
  {
#line 3713
  tmp = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
  }
#line 3713
  if (tmp != 0) {
#line 3714
    return ((off_t )-1);
  }
#line 3716
  return (st.st_size);
}
}
#line 3749 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static int ulhandler_throttle(ULHandler * const  ulhandler , off_t const   uploaded___0 ,
                              double const   ts_start , double *required_sleep ) 
{ 
  double ts_now ;
  double elapsed ;
  off_t would_be_uploaded ;
  double wanted_ts ;
  off_t previous_chunk_size ;

  {
#line 3760
  if (ulhandler->bandwidth <= 0UL) {
#line 3761
    *required_sleep = 0.0;
#line 3762
    return (0);
  }
  {
#line 3764
  ts_now = get_usec_time();
  }
#line 3764
  if (ts_now <= 0.0) {
#line 3765
    ts_now = (double )ts_start;
  }
#line 3767
  if (ts_start > (double const   )ts_now) {
#line 3768
    ts_now = (double )ts_start;
  }
#line 3770
  elapsed = ts_now - (double )ts_start;
#line 3771
  would_be_uploaded = ulhandler->total_uploaded + ulhandler->chunk_size;
#line 3772
  if (ulhandler->bandwidth > 0UL) {
#line 3773
    wanted_ts = (double )would_be_uploaded / (double )ulhandler->bandwidth;
  } else {
#line 3775
    wanted_ts = elapsed;
  }
#line 3777
  *required_sleep = wanted_ts - elapsed;
#line 3778
  previous_chunk_size = ulhandler->chunk_size;
#line 3779
  if (ulhandler->total_uploaded > ulhandler->chunk_size) {
#line 3780
    if (*required_sleep < ulhandler->min_sleep) {
#line 3781
      ulhandler->chunk_size = (ulhandler->max_chunk_size + ulhandler->chunk_size) / 2L;
    } else
#line 3783
    if (*required_sleep > ulhandler->max_sleep) {
#line 3784
      ulhandler->chunk_size = (ulhandler->min_chunk_size + ulhandler->chunk_size) / 2L;
    } else {
#line 3787
      ulhandler->chunk_size = ulhandler->default_chunk_size;
    }
#line 3789
    if (ulhandler->chunk_size <= 0L) {
#line 3791
      ulhandler->chunk_size = ulhandler->default_chunk_size;
    } else
#line 3789
    if (ulhandler->chunk_size > (off_t )ulhandler->sizeof_buf) {
#line 3791
      ulhandler->chunk_size = ulhandler->default_chunk_size;
    }
#line 3793
    if (previous_chunk_size != ulhandler->default_chunk_size) {
#line 3794
      would_be_uploaded = ulhandler->total_uploaded + ulhandler->chunk_size;
#line 3796
      if (ulhandler->bandwidth > 0UL) {
#line 3797
        wanted_ts = (double )would_be_uploaded / (double )ulhandler->bandwidth;
      } else {
#line 3800
        wanted_ts = elapsed;
      }
#line 3802
      *required_sleep = wanted_ts - elapsed;
    }
  }
#line 3805
  return (0);
}
}
#line 3808 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static int ul_init(ULHandler * const  ulhandler , int const   clientfd___0 , void * const  tls_clientfd ,
                   int const   xferfd___0 , char const   * const  name___0 , int const   f ,
                   void * const  tls_fd , off_t const   restartat___0 , int const   ascii_mode ,
                   unsigned long const   bandwidth , off_t const   max_filesize ) 
{ 
  struct pollfd *pfd ;
  int tmp ;
  int tmp___0 ;
  off_t tmp___1 ;
  unsigned char *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 3817
  tmp = fcntl((int )xferfd___0, 3);
#line 3817
  tmp___0 = fcntl((int )xferfd___0, 4, tmp | 2048);
  }
#line 3817
  if (tmp___0 == -1) {
    {
#line 3818
    error(451, "fcntl(F_SETFL, O_NONBLOCK)");
    }
#line 3819
    return (-1);
  }
#line 3821
  ulhandler->buf = (unsigned char *)((void *)0);
#line 3822
  ulhandler->sizeof_buf = 0UL;
#line 3823
  ulhandler->clientfd = (int )clientfd___0;
#line 3824
  ulhandler->tls_clientfd = (void *)tls_clientfd;
#line 3825
  ulhandler->xferfd = (int )xferfd___0;
#line 3826
  ulhandler->f = (int )f;
#line 3827
  ulhandler->tls_fd = (void *)tls_fd;
#line 3828
  ulhandler->ascii_mode = (int )ascii_mode;
#line 3829
  ulhandler->cur_pos = (off_t )restartat___0;
#line 3830
  ulhandler->total_uploaded = (off_t )0;
#line 3831
  ulhandler->min_sleep = 0.1;
#line 3832
  ulhandler->max_sleep = 5.0;
#line 3833
  ulhandler->bandwidth = (unsigned long )bandwidth;
#line 3834
  ulhandler->max_filesize = (off_t )max_filesize;
#line 3835
  ulhandler->idletime = idletime;
#line 3836
  pfd = & ulhandler->pfds[0];
#line 3837
  pfd->fd = (int )xferfd___0;
#line 3838
  pfd->events = (short)25;
#line 3839
  pfd->revents = (short)0;
#line 3840
  pfd = & ulhandler->pfds[1];
#line 3841
  pfd->fd = (int )clientfd___0;
#line 3845
  pfd->events = (short)27;
#line 3847
  pfd->revents = (short)0;
#line 3848
  pfd = & ulhandler->pfds_command;
#line 3849
  pfd->fd = (int )clientfd___0;
#line 3853
  pfd->events = (short)27;
#line 3855
  pfd->revents = (short)0;
#line 3856
  ulhandler->min_chunk_size = (off_t )87380;
#line 3857
  if (ascii_mode > 0) {
#line 3858
    tmp___1 = (off_t )65536UL;
#line 3858
    ulhandler->max_chunk_size = tmp___1;
#line 3858
    ulhandler->default_chunk_size = tmp___1;
  } else {
#line 3861
    ulhandler->max_chunk_size = (off_t )524288UL;
#line 3862
    if (bandwidth <= 0UL) {
#line 3863
      ulhandler->default_chunk_size = ulhandler->max_chunk_size;
    } else {
#line 3865
      ulhandler->default_chunk_size = (off_t )174760;
    }
  }
  {
#line 3868
  ulhandler->chunk_size = ulhandler->default_chunk_size;
#line 3869
  ulhandler->cur_pos = (off_t )restartat___0;
#line 3870
  ulhandler->sizeof_buf = (size_t )ulhandler->max_chunk_size;
#line 3871
  tmp___3 = malloc(ulhandler->sizeof_buf);
#line 3871
  tmp___2 = (unsigned char *)tmp___3;
#line 3871
  ulhandler->buf = tmp___2;
  }
#line 3871
  if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 3872
    ulhandler->buf = (unsigned char *)((void *)0);
#line 3873
    ulhandler->sizeof_buf = (size_t )0U;
#line 3874
    return (-1);
  }
#line 3876
  return (0);
}
}
#line 3879 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static int ul_dowrite(ULHandler * const  ulhandler , unsigned char const   *buf_ ,
                      size_t const   size_ , off_t * const  uploaded___0 ) 
{ 
  size_t size ;
  ssize_t written ;
  unsigned char const   *buf___1 ;
  unsigned char *unasciibuf ;
  int ret ;
  unsigned char *unasciibufpnt ;
  size_t z ;
  void *tmp ;
  unsigned char *tmp___0 ;

  {
#line 3882
  size = (size_t )size_;
#line 3884
  buf___1 = buf_;
#line 3885
  unasciibuf = (unsigned char *)((void *)0);
#line 3886
  ret = 0;
#line 3888
  if (size_ <= 0UL) {
#line 3889
    *uploaded___0 = (off_t )0;
#line 3890
    return (-1);
  }
#line 3893
  if (ulhandler->ascii_mode > 0) {
#line 3895
    z = (size_t )0U;
#line 3897
    if (size > (size_t )ulhandler->chunk_size) {
#line 3899
      return (-1);
    } else {
      {
#line 3897
      tmp = __builtin_alloca((size_t )ulhandler->chunk_size);
#line 3897
      unasciibuf = (unsigned char *)tmp;
      }
#line 3897
      if ((unsigned long )unasciibuf == (unsigned long )((void *)0)) {
#line 3899
        return (-1);
      }
    }
#line 3901
    unasciibufpnt = unasciibuf;
    {
#line 3902
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3903
      if ((int const   )*(buf_ + z) != 13) {
#line 3904
        tmp___0 = unasciibufpnt;
#line 3904
        unasciibufpnt ++;
#line 3904
        *tmp___0 = (unsigned char )*(buf_ + z);
      }
#line 3906
      z ++;
#line 3902
      if (! (z < size)) {
#line 3902
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 3908
    buf___1 = (unsigned char const   *)unasciibuf;
#line 3909
    size = (size_t )(unasciibufpnt - unasciibuf);
  }
  {
#line 3912
  written = safe_write((int const   )ulhandler->f, (void const   */* const  */)buf___1,
                       size, (int const   )-1);
#line 3913
  ret = - (written != (ssize_t )size);
  }
#line 3914
  if ((unsigned long )unasciibuf != (unsigned long )((void *)0)) {
    {
#line 3915
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3915
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 3917
  if (ret < 0) {
#line 3918
    *uploaded___0 = (off_t )0;
  } else {
#line 3920
    *uploaded___0 = (off_t )size;
  }
#line 3922
  return (ret);
}
}
#line 3925 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static int ulhandler_handle_commands(ULHandler * const  ulhandler ) 
{ 
  char buf___1[100] ;
  char *bufpnt ;
  ssize_t readnb ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 3931
  if ((unsigned long )ulhandler->tls_clientfd != (unsigned long )((void *)0)) {
    {
#line 3936
    abort();
    }
  } else {
    {
#line 3939
    readnb = read(ulhandler->clientfd, (void *)(buf___1), sizeof(buf___1) - 1UL);
    }
  }
#line 3941
  if (readnb == 0L) {
#line 3942
    return (-2);
  }
#line 3944
  if (readnb < 0L) {
    {
#line 3945
    tmp = __errno_location();
    }
#line 3945
    if (*tmp == 11) {
#line 3946
      return (0);
    } else {
      {
#line 3945
      tmp___0 = __errno_location();
      }
#line 3945
      if (*tmp___0 == 4) {
#line 3946
        return (0);
      }
    }
#line 3948
    return (-1);
  }
  {
#line 3950
  buf___1[readnb] = (char)0;
#line 3951
  bufpnt = skip_telnet_controls((char const   *)(buf___1));
#line 3952
  tmp___3 = strchr((char const   *)(buf___1), '\n');
  }
#line 3952
  if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
    {
#line 3953
    tmp___1 = strncasecmp((char const   *)bufpnt, "ABOR", sizeof("ABOR") - 1UL);
    }
#line 3953
    if (tmp___1 != 0) {
      {
#line 3953
      tmp___2 = strncasecmp((char const   *)bufpnt, "QUIT", sizeof("QUIT") - 1UL);
      }
#line 3953
      if (tmp___2 != 0) {
        {
#line 3955
        addreply_noformat((int const   )500, (char const   */* const  */)"Unknown command");
#line 3956
        doreply();
        }
      } else {
        {
#line 3958
        addreply_noformat((int const   )426, (char const   */* const  */)"Transfer aborted");
#line 3959
        doreply();
        }
#line 3960
        return (1);
      }
    } else {
      {
#line 3958
      addreply_noformat((int const   )426, (char const   */* const  */)"Transfer aborted");
#line 3959
      doreply();
      }
#line 3960
      return (1);
    }
  }
#line 3963
  return (0);
}
}
#line 3966 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static int ul_handle_data(ULHandler * const  ulhandler , off_t * const  uploaded___0 ,
                          double const   ts_start ) 
{ 
  ssize_t readnb ;
  double required_sleep ;
  int pollret ;
  int ret ;
  off_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
#line 3970
  required_sleep = 0.0;
#line 3974
  if (ulhandler->max_filesize >= 0L) {
#line 3974
    if (ulhandler->total_uploaded > ulhandler->max_filesize) {
      {
#line 3976
      addreply((int const   )552, (char const   */* const  */)"Transfer aborted (quota)");
      }
#line 3977
      return (-2);
    }
  }
#line 3979
  if (ulhandler->chunk_size > (off_t )ulhandler->sizeof_buf) {
#line 3980
    tmp = (off_t )ulhandler->sizeof_buf;
#line 3980
    ulhandler->max_chunk_size = tmp;
#line 3980
    ulhandler->chunk_size = tmp;
  }
#line 3983
  if ((unsigned long )ulhandler->tls_fd != (unsigned long )((void *)0)) {
    {
#line 3988
    abort();
    }
  } else {
    {
#line 3991
    readnb = read(ulhandler->xferfd, (void *)ulhandler->buf, (size_t )ulhandler->chunk_size);
    }
  }
#line 3994
  if (readnb == 0L) {
#line 3995
    return (2);
  }
#line 3997
  if (readnb < 0L) {
    {
#line 3998
    tmp___0 = __errno_location();
    }
#line 3998
    if (*tmp___0 == 11) {
#line 3999
      return (0);
    } else {
      {
#line 3998
      tmp___1 = __errno_location();
      }
#line 3998
      if (*tmp___1 == 4) {
#line 3999
        return (0);
      }
    }
    {
#line 4001
    addreply_noformat((int const   )451, (char const   */* const  */)"Error during read from data connection");
    }
#line 4002
    return (-1);
  }
  {
#line 4004
  tmp___2 = ul_dowrite(ulhandler, (unsigned char const   *)ulhandler->buf, (size_t const   )readnb,
                       uploaded___0);
  }
#line 4004
  if (tmp___2 != 0) {
    {
#line 4005
    addreply_noformat((int const   )452, (char const   */* const  */)"Error during write to file");
    }
#line 4006
    return (-1);
  }
#line 4008
  ulhandler->cur_pos += *uploaded___0;
#line 4015
  ulhandler->total_uploaded += *uploaded___0;
#line 4016
  if (ulhandler->bandwidth > 0UL) {
    {
#line 4017
    ulhandler_throttle(ulhandler, (off_t const   )*uploaded___0, ts_start, & required_sleep);
    }
#line 4018
    if (required_sleep > 0.0) {
      repoll: 
      {
#line 4020
      ulhandler->pfds_command.revents = (short)0;
#line 4021
      pollret = poll(& ulhandler->pfds_command, (nfds_t )1, (int )(required_sleep * 1000.0));
      }
#line 4022
      if (pollret == 0) {
#line 4023
        return (0);
      }
#line 4025
      if (pollret < 0) {
        {
#line 4026
        tmp___3 = __errno_location();
        }
#line 4026
        if (*tmp___3 == 4) {
#line 4027
          goto repoll;
        }
#line 4029
        return (-1);
      }
#line 4031
      if (((int )ulhandler->pfds_command.revents & 56) != 0) {
#line 4033
        return (-1);
      }
#line 4035
      if (((int )ulhandler->pfds_command.revents & 3) != 0) {
        {
#line 4036
        ret = ulhandler_handle_commands(ulhandler);
        }
#line 4037
        if (ret != 0) {
#line 4038
          return (ret);
        }
#line 4040
        goto repoll;
      }
    }
  }
#line 4044
  return (0);
}
}
#line 4047 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static int ul_send(ULHandler * const  ulhandler ) 
{ 
  double ts_start ;
  off_t uploaded___0 ;
  int pollret ;
  int timeout ;
  int ret ;
  short tmp ;

  {
#line 4049
  ts_start = 0.0;
#line 4050
  uploaded___0 = (off_t )0;
#line 4055
  if (ulhandler->bandwidth > 0UL) {
    {
#line 4055
    ts_start = get_usec_time();
    }
#line 4055
    if (ts_start <= 0.0) {
      {
#line 4056
      error(451, "gettimeofday()");
      }
#line 4057
      return (-1);
    }
  }
  {
#line 4059
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4060
    if (ulhandler->idletime >= 2147483UL) {
#line 4061
      timeout = 2147483647;
    } else {
#line 4063
      timeout = (int )ulhandler->idletime * 1000;
    }
    {
#line 4065
    tmp = (short)0;
#line 4065
    ulhandler->pfds[1].revents = tmp;
#line 4065
    ulhandler->pfds[0].revents = tmp;
#line 4067
    pollret = poll(ulhandler->pfds, sizeof(ulhandler->pfds) / sizeof(ulhandler->pfds[0]),
                   timeout);
    }
#line 4070
    if (pollret < 0) {
      {
#line 4071
      addreply_noformat((int const   )451, (char const   */* const  */)"Error during read from data connection");
      }
#line 4072
      return (-1);
    }
#line 4074
    if (pollret == 0) {
      {
#line 4075
      addreply_noformat((int const   )421, (char const   */* const  */)"Timeout");
      }
#line 4076
      return (-1);
    }
#line 4078
    if (((int )ulhandler->pfds[0].revents & 1) != 0) {
      {
#line 4079
      ret = ul_handle_data(ulhandler, (off_t */* const  */)(& uploaded___0), (double const   )ts_start);
      }
      {
#line 4081
      if (ret == 1) {
#line 4081
        goto case_1;
      }
#line 4083
      if (ret == 2) {
#line 4083
        goto case_2;
      }
#line 4085
      if (ret == 0) {
#line 4085
        goto case_0;
      }
#line 4087
      goto switch_default;
      case_1: /* CIL Label */ 
#line 4082
      return (1);
      case_2: /* CIL Label */ 
#line 4084
      return (0);
      case_0: /* CIL Label */ 
#line 4086
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 4088
      if (ret > 2) {
        {
#line 4089
        abort();
        }
      }
#line 4091
      return (ret);
      switch_break: /* CIL Label */ ;
      }
    }
#line 4094
    if (((int )ulhandler->pfds[1].revents & 3) != 0) {
      {
#line 4095
      ret = ulhandler_handle_commands(ulhandler);
      }
#line 4096
      if (ret != 0) {
#line 4097
        return (ret);
      }
    }
#line 4100
    if (((int )ulhandler->pfds[0].revents & 40) != 0) {
#line 4103
      return (-1);
    } else
#line 4100
    if (((int )ulhandler->pfds[0].revents & 16) != 0) {
#line 4100
      if (((int )ulhandler->pfds[0].revents & 1) == 0) {
#line 4103
        return (-1);
      }
    }
#line 4105
    if (((int )ulhandler->pfds[1].revents & 56) != 0) {
      {
#line 4107
      addreply_noformat((int const   )221, (char const   */* const  */)"Logout.");
      }
#line 4108
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4112
  return (0);
}
}
#line 4115 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static int ul_exit(ULHandler * const  ulhandler ) 
{ 


  {
  {
#line 4117
  free((void *)ulhandler->buf);
#line 4118
  ulhandler->buf = (unsigned char *)((void *)0);
  }
#line 4120
  return (0);
}
}
#line 4123 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
int ul_check_free_space(char const   *name___0 , double const   min_space ) 
{ 
  struct statvfs64 statfsbuf ;
  char *z ;
  char *alloca_namedir ;
  size_t name_len ;
  double jam ;
  double space ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 4132
  if (maxdiskusagepct <= 0.0) {
#line 4132
    if (min_space <= (double const   )0.0) {
#line 4133
      return (1);
    }
  }
  {
#line 4140
  tmp = strlen(name___0);
#line 4140
  name_len = tmp + 1UL;
  }
#line 4141
  if (name_len < 2UL) {
#line 4143
    return (-1);
  } else {
    {
#line 4141
    tmp___0 = __builtin_alloca(name_len);
#line 4141
    alloca_namedir = (char *)tmp___0;
    }
#line 4141
    if ((unsigned long )alloca_namedir == (unsigned long )((void *)0)) {
#line 4143
      return (-1);
    }
  }
  {
#line 4145
  memcpy((void */* __restrict  */)alloca_namedir, (void const   */* __restrict  */)name___0,
         name_len);
#line 4146
  z = strrchr((char const   *)alloca_namedir, '/');
  }
#line 4146
  if ((unsigned long )z != (unsigned long )((void *)0)) {
#line 4147
    if ((unsigned long )z == (unsigned long )alloca_namedir) {
#line 4148
      tmp___1 = z;
#line 4148
      z ++;
#line 4148
      *tmp___1 = (char )'.';
    }
#line 4150
    *z = (char)0;
  } else {
#line 4152
    *(alloca_namedir + 0) = (char )'.';
#line 4153
    *(alloca_namedir + 1) = (char)0;
  }
  {
#line 4155
  tmp___2 = statvfs64((char const   */* __restrict  */)alloca_namedir, (struct statvfs64 */* __restrict  */)(& statfsbuf));
  }
#line 4155
  if (tmp___2 != 0) {
    {
#line 4156
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4156
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 4157
    return (-1);
  }
  {
#line 4159
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4159
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4164
  if ((double )statfsbuf.f_blocks <= 0.0) {
#line 4165
    return (1);
  }
#line 4167
  if (min_space >= (double const   )0.0) {
#line 4168
    space = (double )statfsbuf.f_bavail * (double )statfsbuf.f_frsize;
#line 4170
    if (space < (double )min_space) {
#line 4171
      return (0);
    }
  }
#line 4174
  jam = (double )statfsbuf.f_bavail / (double )statfsbuf.f_blocks;
#line 4176
  if (jam >= maxdiskusagepct) {
#line 4177
    return (1);
  }
#line 4179
  return (0);
}
}
#line 4182 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void dostor(char *name___0 , int const   append , int const   autorename___0 ) 
{ 
  ULHandler ulhandler ;
  int f ;
  char const   *ul_name ;
  char const   *atomic_file ;
  off_t filesize ;
  struct stat st ;
  double started ;
  signed char overwrite ;
  int overflow ;
  int ret ;
  off_t max_filesize ;
  char const   *name2___0 ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  __off_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  off_t atomic_file_size ;
  off_t original_file_size ;
  int files_count ;
  int tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;

  {
#line 4186
  ul_name = (char const   *)((void *)0);
#line 4187
  atomic_file = (char const   *)((void *)0);
#line 4188
  filesize = (off_t )0U;
#line 4190
  started = 0.0;
#line 4191
  overwrite = (signed char)0;
#line 4192
  overflow = 0;
#line 4193
  ret = -1;
#line 4194
  max_filesize = (off_t )-1;
#line 4198
  name2___0 = (char const   *)((void *)0);
#line 4200
  if ((int )type < 1) {
    {
#line 4201
    addreply_noformat((int const   )503, (char const   */* const  */)"ASCII resume is unsafe, please delete the file first");
    }
#line 4202
    goto end;
  } else
#line 4200
  if ((int )type == 1) {
#line 4200
    if (restartat > 1L) {
      {
#line 4201
      addreply_noformat((int const   )503, (char const   */* const  */)"ASCII resume is unsafe, please delete the file first");
      }
#line 4202
      goto end;
    }
  }
#line 4205
  if ((int )guest != 0) {
#line 4205
    if ((int )anon_noupload != 0) {
      {
#line 4206
      addreply_noformat((int const   )550, (char const   */* const  */)"Anonymous users may not overwrite existing files");
      }
#line 4207
      goto end;
    }
  }
  {
#line 4210
  tmp = ul_check_free_space((char const   *)name___0, (double const   )(- 1.0));
  }
#line 4210
  if (tmp == 0) {
    {
#line 4211
    addreply_noformat((int const   )552, (char const   */* const  */)"Disk full - please upload later");
    }
#line 4212
    goto end;
  }
  {
#line 4214
  tmp___0 = checknamesanity((char const   *)name___0, (int )dot_write_ok);
  }
#line 4214
  if (tmp___0 != 0) {
    {
#line 4215
    addreply((int const   )553, (char const   */* const  */)"Prohibited file name: %s",
             name___0);
    }
#line 4216
    goto end;
  }
#line 4218
  if (autorename___0 != 0) {
#line 4219
    no_truncate = (signed char)1;
  }
#line 4221
  if (restartat > 0L) {
#line 4221
    goto _L;
  } else
#line 4221
  if ((int )no_truncate != 0) {
    _L: /* CIL Label */ 
    {
#line 4222
    tmp___1 = get_atomic_file((char const   */* const  */)name___0);
#line 4222
    atomic_file = (char const   *)tmp___1;
    }
#line 4222
    if ((unsigned long )atomic_file == (unsigned long )((void *)0)) {
      {
#line 4223
      addreply((int const   )553, (char const   */* const  */)"Prohibited file name: %s",
               name___0);
      }
#line 4224
      goto end;
    }
#line 4226
    if (restartat > 0L) {
      {
#line 4226
      tmp___2 = rename((char const   *)name___0, atomic_file);
      }
#line 4226
      if (tmp___2 != 0) {
        {
#line 4226
        tmp___3 = __errno_location();
        }
#line 4226
        if (*tmp___3 != 2) {
          {
#line 4228
          error(553, "Rename/move failure");
#line 4229
          atomic_file = (char const   *)((void *)0);
          }
#line 4230
          goto end;
        }
      }
    }
  }
#line 4233
  if ((unsigned long )atomic_file != (unsigned long )((void *)0)) {
#line 4234
    ul_name = atomic_file;
  } else {
#line 4236
    ul_name = (char const   *)name___0;
  }
#line 4238
  if ((unsigned long )atomic_file == (unsigned long )((void *)0)) {
    {
#line 4238
    f = open(ul_name, 131073);
    }
#line 4238
    if (f != -1) {
#line 4240
      overwrite = (signed char )((int )overwrite + 1);
    } else {
#line 4238
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 4241
    f = open(ul_name, 131137, 511U & ~ u_mask);
    }
#line 4241
    if (f == -1) {
      {
#line 4243
      error(553, "Can\'t open that file");
      }
#line 4244
      goto end;
    }
  }
  {
#line 4246
  tmp___4 = fstat(f, & st);
  }
#line 4246
  if (tmp___4 < 0) {
    {
#line 4247
    close(f);
#line 4248
    error(553, "Can\'t check for file existence");
    }
#line 4249
    goto end;
  }
#line 4251
  if (! ((st.st_mode & 61440U) == 32768U)) {
    {
#line 4252
    close(f);
#line 4253
    addreply_noformat((int const   )550, (char const   */* const  */)"I can only retrieve regular files");
    }
#line 4254
    goto end;
  }
  {
#line 4256
  alarm(86400U);
  }
#line 4259
  if (st.st_size > 0L) {
#line 4261
    if ((int )guest != 0) {
      {
#line 4262
      addreply_noformat((int const   )550, (char const   */* const  */)"Anonymous users may not overwrite existing files");
#line 4263
      close(f);
      }
#line 4264
      goto end;
    }
#line 4267
    if (append != 0) {
#line 4268
      restartat = st.st_size;
    }
  } else {
#line 4271
    restartat = (off_t )0;
  }
#line 4273
  if (restartat > st.st_size) {
#line 4274
    restartat = st.st_size;
  }
#line 4276
  if (restartat > 0L) {
    {
#line 4276
    tmp___5 = lseek(f, restartat, 0);
    }
#line 4276
    if (tmp___5 < 0L) {
      {
#line 4277
      close(f);
#line 4278
      error(451, "seek");
      }
#line 4279
      goto end;
    }
  }
#line 4281
  if (restartat < st.st_size) {
    {
#line 4282
    tmp___6 = ftruncate(f, restartat);
    }
#line 4282
    if (tmp___6 < 0) {
      {
#line 4283
      close(f);
#line 4284
      error(451, "ftruncate");
      }
#line 4285
      goto end;
    }
  }
  {
#line 4306
  opendata();
  }
#line 4307
  if (xferfd == (int volatile   )-1) {
    {
#line 4308
    close(f);
    }
#line 4309
    goto end;
  }
  {
#line 4311
  doreply();
#line 4317
  state_needs_update = (signed char)1;
#line 4318
  setprocessname((char const   */* const  */)"pure-ftpd (UPLOAD)");
#line 4319
  filesize = restartat;
#line 4345
  started = get_usec_time();
#line 4347
  tmp___7 = ul_init((ULHandler */* const  */)(& ulhandler), (int const   )clientfd,
                    (void */* const  */)tls_cnx, (int const   )xferfd, (char const   */* const  */)name___0,
                    (int const   )f, (void */* const  */)tls_data_cnx, (off_t const   )restartat,
                    (int const   )((int )type == 1), (unsigned long const   )throttling_bandwidth_ul,
                    (off_t const   )max_filesize);
  }
#line 4347
  if (tmp___7 == 0) {
    {
#line 4350
    ret = ul_send((ULHandler */* const  */)(& ulhandler));
#line 4351
    ul_exit((ULHandler */* const  */)(& ulhandler));
    }
  } else {
#line 4353
    ret = -1;
  }
  {
#line 4355
  close(f);
#line 4356
  closedata();
#line 4374
  uploaded += (unsigned long long )ulhandler.total_uploaded;
  }
#line 4380
  if ((int )overwrite == 0) {
#line 4381
    files_count = 1;
  } else {
#line 4383
    files_count = 0;
  }
#line 4385
  if (autorename___0 != 0) {
#line 4385
    if (restartat == 0L) {
      {
#line 4386
      atomic_file_size = get_file_size((char const   */* const  */)atomic_file);
      }
#line 4386
      if (atomic_file_size < 0L) {
#line 4387
        goto afterquota;
      }
      {
#line 4389
      tmp___8 = tryautorename((char const   */* const  */)atomic_file, (char */* const  */)name___0,
                              (char const   **/* const  */)(& name2___0));
      }
#line 4389
      if (tmp___8 != 0) {
        {
#line 4390
        error(553, "Rename/move failure");
        }
#line 4391
        goto afterquota;
      } else {
#line 4396
        atomic_file = (char const   *)((void *)0);
      }
    } else {
#line 4385
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 4398
  if ((unsigned long )atomic_file != (unsigned long )((void *)0)) {
    {
#line 4399
    atomic_file_size = get_file_size((char const   */* const  */)atomic_file);
    }
#line 4399
    if (atomic_file_size < 0L) {
#line 4400
      goto afterquota;
    }
    {
#line 4402
    original_file_size = get_file_size((char const   */* const  */)name___0);
    }
#line 4402
    if (original_file_size < 0L) {
#line 4404
      original_file_size = restartat;
    } else
#line 4402
    if (restartat > original_file_size) {
#line 4404
      original_file_size = restartat;
    }
    {
#line 4406
    tmp___9 = rename(atomic_file, (char const   *)name___0);
    }
#line 4406
    if (tmp___9 != 0) {
      {
#line 4407
      error(553, "Rename/move failure");
      }
#line 4408
      goto afterquota;
    } else {
#line 4414
      atomic_file = (char const   *)((void *)0);
    }
  }
  afterquota: 
#line 4424
  if (overflow > 0) {
    {
#line 4425
    addreply((int const   )552, (char const   */* const  */)"Quota exceeded: [%s] won\'t be saved",
             name___0);
    }
  } else {
#line 4427
    if (ret == 0) {
      {
#line 4428
      addreply_noformat((int const   )226, (char const   */* const  */)"File successfully transferred");
      }
    } else {
      {
#line 4430
      addreply_noformat((int const   )226, (char const   */* const  */)"Transfer aborted");
      }
    }
#line 4432
    if (name2___0) {
#line 4432
      tmp___10 = name2___0;
    } else {
#line 4432
      tmp___10 = (char const   *)name___0;
    }
    {
#line 4432
    displayrate("uploaded", ulhandler.total_uploaded, (double const   )started, (char const   */* const  */)tmp___10,
                1);
    }
  }
  end: 
#line 4436
  restartat = (off_t )0;
#line 4437
  if ((unsigned long )atomic_file != (unsigned long )((void *)0)) {
    {
#line 4438
    unlink(atomic_file);
#line 4439
    atomic_file = (char const   *)((void *)0);
    }
  }
#line 4441
  return;
}
}
#line 4443 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void domdtm(char const   *name___0 ) 
{ 
  struct stat st ;
  struct tm *t ;
  int tmp ;

  {
#line 4448
  if (! name___0) {
    {
#line 4449
    addreply_noformat((int const   )501, (char const   */* const  */)"Missing argument");
    }
  } else
#line 4448
  if (! *name___0) {
    {
#line 4449
    addreply_noformat((int const   )501, (char const   */* const  */)"Missing argument");
    }
  } else {
    {
#line 4450
    tmp = stat((char const   */* __restrict  */)name___0, (struct stat */* __restrict  */)(& st));
    }
#line 4450
    if (tmp) {
      {
#line 4456
      addreply_noformat((int const   )550, (char const   */* const  */)"Can\'t check for file existence");
      }
    } else
#line 4457
    if (! ((st.st_mode & 61440U) == 32768U)) {
      {
#line 4458
      addreply_noformat((int const   )550, (char const   */* const  */)"I can only retrieve regular files");
      }
    } else {
      {
#line 4460
      t = gmtime((time_t const   *)(& st.st_mtim.tv_sec));
      }
#line 4461
      if (! t) {
        {
#line 4462
        addreply_noformat((int const   )451, (char const   */* const  */)"Couldn\'t get the local time");
        }
      } else {
        {
#line 4464
        addreply((int const   )213, (char const   */* const  */)"%04d%02d%02d%02d%02d%02d",
                 t->tm_year + 1900, t->tm_mon + 1, t->tm_mday, t->tm_hour, t->tm_min,
                 t->tm_sec);
        }
      }
    }
  }
#line 4469
  return;
}
}
#line 4471 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void dosize(char const   *name___0 ) 
{ 
  struct stat st ;
  int tmp ;

  {
#line 4475
  if (! name___0) {
    {
#line 4476
    addreply_noformat((int const   )501, (char const   */* const  */)"Missing argument");
    }
  } else
#line 4475
  if (! *name___0) {
    {
#line 4476
    addreply_noformat((int const   )501, (char const   */* const  */)"Missing argument");
    }
  } else {
    {
#line 4477
    tmp = stat((char const   */* __restrict  */)name___0, (struct stat */* __restrict  */)(& st));
    }
#line 4477
    if (tmp) {
      {
#line 4483
      addreply_noformat((int const   )550, (char const   */* const  */)"Can\'t check for file existence");
      }
    } else
#line 4484
    if (! ((st.st_mode & 61440U) == 32768U)) {
      {
#line 4485
      addreply_noformat((int const   )550, (char const   */* const  */)"I can only retrieve regular files");
      }
    } else {
      {
#line 4487
      addreply((int const   )213, (char const   */* const  */)"%llu", (unsigned long long )st.st_size);
      }
    }
  }
#line 4489
  return;
}
}
#line 4491 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void dotype(char const   *arg ) 
{ 
  unsigned short const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;

  {
#line 4493
  replycode = 200;
#line 4495
  if (! arg) {
    {
#line 4496
    addreply((int const   )501, (char const   */* const  */)"Missing argument\nA(scii) I(mage) L(ocal)");
    }
  } else
#line 4495
  if (! *arg) {
    {
#line 4496
    addreply((int const   )501, (char const   */* const  */)"Missing argument\nA(scii) I(mage) L(ocal)");
    }
  } else {
    {
#line 4497
    tmp___2 = tolower((int )((unsigned char )*arg));
    }
#line 4497
    if (tmp___2 == 97) {
#line 4498
      type = (signed char)1;
    } else {
      {
#line 4499
      tmp___1 = tolower((int )((unsigned char )*arg));
      }
#line 4499
      if (tmp___1 == 105) {
#line 4500
        type = (signed char)2;
      } else {
        {
#line 4501
        tmp___0 = tolower((int )((unsigned char )*arg));
        }
#line 4501
        if (tmp___0 == 108) {
#line 4502
          if ((int const   )*(arg + 1) == 56) {
#line 4503
            type = (signed char)2;
          } else {
            {
#line 4504
            tmp = __ctype_b_loc();
            }
#line 4504
            if ((int const   )*(*tmp + (int )((unsigned char )*(arg + 1))) & 2048) {
              {
#line 4505
              addreply_noformat((int const   )504, (char const   */* const  */)"Only 8-bit bytes are supported, we\'re not 10 years ago");
              }
            } else {
              {
#line 4507
              addreply_noformat((int const   )0, (char const   */* const  */)"Missing argument");
#line 4508
              type = (signed char)2;
              }
            }
          }
        } else {
          {
#line 4511
          addreply((int const   )504, (char const   */* const  */)"Unknown TYPE: %s",
                   arg);
          }
        }
      }
    }
  }
#line 4514
  if ((int )type > 1) {
#line 4514
    tmp___3 = "8-bit binary";
  } else {
#line 4514
    tmp___3 = "ASCII";
  }
  {
#line 4514
  addreply((int const   )0, (char const   */* const  */)"TYPE is now %s", tmp___3);
  }
#line 4515
  return;
}
}
#line 4517 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void dostru(char const   *arg ) 
{ 
  int tmp ;

  {
#line 4519
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
    {
#line 4520
    addreply_noformat((int const   )501, (char const   */* const  */)"Missing argument");
    }
  } else
#line 4519
  if (! *arg) {
    {
#line 4520
    addreply_noformat((int const   )501, (char const   */* const  */)"Missing argument");
    }
  } else {
    {
#line 4521
    tmp = strcasecmp(arg, "F");
    }
#line 4521
    if (tmp) {
      {
#line 4522
      addreply_noformat((int const   )504, (char const   */* const  */)"Only F(ile) is supported");
      }
    } else {
      {
#line 4524
      addreply_noformat((int const   )200, (char const   */* const  */)"F OK");
      }
    }
  }
#line 4526
  return;
}
}
#line 4528 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void domode(char const   *arg ) 
{ 
  int tmp ;

  {
#line 4530
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
    {
#line 4531
    addreply_noformat((int const   )501, (char const   */* const  */)"Missing argument");
    }
  } else
#line 4530
  if (! *arg) {
    {
#line 4531
    addreply_noformat((int const   )501, (char const   */* const  */)"Missing argument");
    }
  } else {
    {
#line 4532
    tmp = strcasecmp(arg, "S");
    }
#line 4532
    if (tmp) {
      {
#line 4533
      addreply_noformat((int const   )504, (char const   */* const  */)"Please use S(tream) mode");
      }
    } else {
      {
#line 4535
      addreply_noformat((int const   )200, (char const   */* const  */)"S OK");
      }
    }
  }
#line 4537
  return;
}
}
#line 4539 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void dornfr(char *name___0 ) 
{ 
  struct stat st ;
  int tmp ;
  int tmp___0 ;

  {
#line 4544
  if ((int )guest != 0) {
    {
#line 4545
    addreply_noformat((int const   )550, (char const   */* const  */)"Anonymous users are not allowed to move/rename files");
    }
#line 4546
    return;
  }
#line 4549
  if ((int )disallow_rename != 0) {
    {
#line 4550
    addreply_noformat((int const   )550, (char const   */* const  */)"Rename/move failure");
    }
#line 4551
    return;
  }
  {
#line 4553
  tmp = checknamesanity((char const   *)name___0, (int )dot_write_ok);
  }
#line 4553
  if (tmp != 0) {
    {
#line 4554
    addreply((int const   )553, (char const   */* const  */)"Prohibited file name: %s",
             name___0);
    }
#line 4555
    return;
  }
  {
#line 4557
  tmp___0 = lstat((char const   */* __restrict  */)name___0, (struct stat */* __restrict  */)(& st));
  }
#line 4557
  if (tmp___0 == 0) {
#line 4558
    if ((unsigned long )renamefrom != (unsigned long )((void *)0)) {
      {
#line 4559
      addreply_noformat((int const   )0, (char const   */* const  */)"Aborting previous rename operation");
#line 4560
      free((void *)renamefrom);
      }
    }
    {
#line 4562
    renamefrom = strdup((char const   *)name___0);
    }
#line 4562
    if ((unsigned long )renamefrom == (unsigned long )((void *)0)) {
      {
#line 4563
      die_mem();
      }
    }
    {
#line 4565
    addreply_noformat((int const   )350, (char const   */* const  */)"RNFR accepted - file exists, ready for destination");
    }
  } else {
    {
#line 4567
    addreply_noformat((int const   )550, (char const   */* const  */)"Sorry, but that file doesn\'t exist");
    }
  }
#line 4569
  return;
}
}
#line 4571 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void dornto(char *name___0 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 4581
  if ((int )guest != 0) {
    {
#line 4582
    addreply_noformat((int const   )550, (char const   */* const  */)"Anonymous users are not allowed to move/rename files");
    }
#line 4583
    goto bye;
  }
#line 4586
  if ((unsigned long )renamefrom == (unsigned long )((void *)0)) {
    {
#line 4587
    addreply_noformat((int const   )503, (char const   */* const  */)"Need RNFR before RNTO");
    }
#line 4588
    goto bye;
  }
  {
#line 4590
  tmp = checknamesanity((char const   *)name___0, (int )dot_write_ok);
  }
#line 4590
  if (tmp != 0) {
    {
#line 4591
    addreply((int const   )553, (char const   */* const  */)"Prohibited file name: %s",
             name___0);
    }
#line 4592
    return;
  }
  {
#line 4626
  tmp___0 = rename((char const   *)renamefrom, (char const   *)name___0);
  }
#line 4626
  if (tmp___0 < 0) {
    {
#line 4627
    error(451, "Rename/move failure");
    }
  } else {
    {
#line 4632
    addreply_noformat((int const   )250, (char const   */* const  */)"File successfully renamed or moved");
#line 4633
    logfile((int const   )5, "File successfully renamed or moved: [%s]->[%s]", renamefrom,
            name___0);
    }
  }
  bye: 
  {
#line 4637
  free((void *)renamefrom);
#line 4638
  renamefrom = (char *)((void *)0);
  }
#line 4639
  return;
}
}
#line 4642 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void doopts(char *args ) 
{ 
  char *cmdopts ;
  int tmp ;

  {
  {
#line 4646
  cmdopts = strchr((char const   *)args, ' ');
  }
#line 4646
  if ((unsigned long )cmdopts != (unsigned long )((void *)0)) {
#line 4647
    cmdopts ++;
  }
  {
#line 4668
  tmp = strncasecmp("mlst ", (char const   *)args, (size_t )5);
  }
#line 4668
  if (tmp == 0) {
    {
#line 4669
    addreply_noformat((int const   )200, (char const   */* const  */)" MLST OPTS type;size;sizd;modify;UNIX.mode;UNIX.uid;UNIX.gid;unique;");
    }
#line 4672
    return;
  }
  {
#line 4674
  addreply_noformat((int const   )504, (char const   */* const  */)"Unknown command");
  }
#line 4675
  return;
}
}
#line 4678 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
void error(int n , char const   *msg ) 
{ 
  char const   *e ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 4680
  tmp = __errno_location();
#line 4680
  tmp___0 = strerror(*tmp);
#line 4680
  e = (char const   *)tmp___0;
#line 4682
  logfile((int const   )3, "%s: %s", msg, e);
#line 4683
  addreply((int const   )n, (char const   */* const  */)"%s: %s", msg, e);
  }
#line 4684
  return;
}
}
#line 4689 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static struct rlimit lim  ;
#line 4686 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static void fixlimits(void) 
{ 


  {
  {
#line 4691
  lim.rlim_cur = (rlim_t )14400;
#line 4691
  lim.rlim_max = lim.rlim_cur;
#line 4692
  setrlimit((__rlimit_resource_t )0, (struct rlimit  const  *)(& lim));
#line 4693
  lim.rlim_cur = (rlim_t )8388608;
#line 4693
  lim.rlim_max = lim.rlim_cur;
#line 4694
  setrlimit((__rlimit_resource_t )2, (struct rlimit  const  *)(& lim));
#line 4696
  lim.rlim_cur = (rlim_t )0;
#line 4696
  lim.rlim_max = lim.rlim_cur;
#line 4697
  setrlimit((__rlimit_resource_t )4, (struct rlimit  const  *)(& lim));
  }
#line 4700
  return;
}
}
#line 4791 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static int check_standalone(void) 
{ 
  socklen_t socksize ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 4793
  socksize = (socklen_t )sizeof(ctrlconn);
#line 4794
  tmp = getsockname(0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& ctrlconn)),
                    (socklen_t */* __restrict  */)(& socksize));
  }
#line 4794
  if (tmp != 0) {
#line 4795
    clientfd = -1;
#line 4796
    return (1);
  }
  {
#line 4798
  tmp___0 = dup2(0, 1);
  }
#line 4798
  if (tmp___0 == -1) {
    {
#line 4799
    _EXIT((int const   )1);
    }
  }
#line 4801
  clientfd = 0;
#line 4803
  return (0);
}
}
#line 4807 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static void set_signals_client(void) 
{ 
  sigset_t sigs ;
  struct sigaction sa ;

  {
  {
#line 4812
  sigfillset(& sigs);
#line 4813
  sigemptyset(& sa.sa_mask);
#line 4815
  sa.sa_flags = 268435456;
#line 4817
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))1;
#line 4818
  sigaction(13, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 4819
  sigaction(23, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 4821
  sigaction(29, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 4824
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))0;
#line 4825
  sigdelset(& sigs, 17);
#line 4826
  sigaction(17, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 4828
  sigaction(8, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 4829
  sigdelset(& sigs, 8);
#line 4831
  sa.sa_flags = 0;
#line 4833
  sa.__sigaction_handler.sa_handler = & sigalarm;
#line 4834
  sigdelset(& sigs, 14);
#line 4835
  sigaction(14, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 4837
  sa.__sigaction_handler.sa_handler = & sigterm_client;
#line 4838
  sigdelset(& sigs, 15);
#line 4839
  sigaction(15, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 4840
  sigdelset(& sigs, 1);
#line 4841
  sigaction(1, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 4842
  sigdelset(& sigs, 3);
#line 4843
  sigaction(3, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 4844
  sigdelset(& sigs, 2);
#line 4845
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 4847
  sigdelset(& sigs, 24);
#line 4848
  sigaction(24, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 4850
  sigprocmask(2, (sigset_t const   */* __restrict  */)(& sigs), (sigset_t */* __restrict  */)((void *)0));
  }
#line 4851
  return;
}
}
#line 4853 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static void set_signals(void) 
{ 
  sigset_t sigs ;
  struct sigaction sa ;

  {
  {
#line 4859
  sigfillset(& sigs);
#line 4860
  sigemptyset(& sa.sa_mask);
#line 4862
  sa.sa_flags = 268435456;
#line 4863
  sa.__sigaction_handler.sa_handler = & sigchild;
#line 4864
  sigdelset(& sigs, 17);
#line 4865
  sigaction(17, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 4867
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))1;
#line 4868
  sigaction(13, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 4869
  sigaction(14, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 4870
  sigaction(23, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 4872
  sigaction(29, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 4875
  sa.sa_flags = 0;
#line 4876
  sa.__sigaction_handler.sa_handler = & sigterm;
#line 4877
  sigdelset(& sigs, 15);
#line 4878
  sigaction(15, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 4879
  sigdelset(& sigs, 1);
#line 4880
  sigaction(1, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 4881
  sigdelset(& sigs, 3);
#line 4882
  sigaction(3, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 4883
  sigdelset(& sigs, 2);
#line 4884
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 4886
  sigdelset(& sigs, 24);
#line 4887
  sigaction(24, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 4889
  sigprocmask(2, (sigset_t const   */* __restrict  */)(& sigs), (sigset_t */* __restrict  */)((void *)0));
  }
#line 4891
  return;
}
}
#line 4893 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static void dns_sanitize(char *z ) 
{ 


  {
  {
#line 4895
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4895
    if (! ((int )*z != 0)) {
#line 4895
      goto while_break;
    }
#line 4896
    if ((int )*z >= 97) {
#line 4896
      if (! ((int )*z <= 122)) {
#line 4896
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 4896
    if ((int )*z >= 48) {
#line 4896
      if (! ((int )*z <= 57)) {
#line 4896
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 4896
    if (! ((int )*z == 46)) {
#line 4896
      if (! ((int )*z == 45)) {
#line 4896
        if (! ((int )*z == 58)) {
#line 4896
          if ((int )*z >= 65) {
#line 4896
            if (! ((int )*z <= 90)) {
#line 4902
              *z = (char )'_';
            }
          } else {
#line 4902
            *z = (char )'_';
          }
        }
      }
    }
#line 4904
    z ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4906
  return;
}
}
#line 4908 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static void fill_atomic_prefix(void) 
{ 
  char tmp_atomic_prefix[4096] ;
  unsigned int tmp ;
  __pid_t tmp___0 ;

  {
  {
#line 4912
  tmp = zrand();
#line 4912
  tmp___0 = getpid();
#line 4912
  snprintf((char */* __restrict  */)(tmp_atomic_prefix), sizeof(tmp_atomic_prefix),
           (char const   */* __restrict  */)"%s%lx.%x.%lx.%x", ".pureftpd-upload.",
           (unsigned long )session_start_time, (unsigned int )serverport, (unsigned long )tmp___0,
           tmp);
#line 4919
  atomic_prefix = strdup((char const   *)(tmp_atomic_prefix));
  }
#line 4919
  if ((unsigned long )atomic_prefix == (unsigned long )((void *)0)) {
    {
#line 4920
    die_mem();
    }
  }
#line 4922
  return;
}
}
#line 4940 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static void doit(void) 
{ 
  socklen_t socksize ;
  unsigned int users ;
  int display_banner ;
  __pid_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  in_port_t *tmp___2 ;
  in_port_t *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int eai ;
  int tmp___9 ;
  unsigned long tmp___10 ;
  unsigned long tmp___11 ;
  int tmp___12 ;
  double load_[2] ;
  int tmp___13 ;
  int tmp___14 ;
  int fodder ;
  unsigned int tmp___15 ;
  struct tm *t ;
  int tmp___16 ;
  struct addrinfo hints ;
  struct addrinfo *res___0 ;
  int tmp___17 ;
  int tmp___18 ;

  {
  {
#line 4943
  users = 0U;
#line 4944
  display_banner = 1;
#line 4946
  client_init_reply_buf();
#line 4947
  session_start_time = time((time_t *)((void *)0));
#line 4948
  fixlimits();
#line 4950
  tmp = getpid();
#line 4950
  fcntl(clientfd, 8, tmp);
#line 4952
  set_signals_client();
#line 4956
  alt_arc4random_stir();
#line 4957
  umask((mode_t )0);
#line 4958
  socksize = (socklen_t )sizeof(ctrlconn);
#line 4959
  tmp___0 = getsockname(clientfd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& ctrlconn)),
                        (socklen_t */* __restrict  */)(& socksize));
  }
#line 4959
  if (tmp___0 != 0) {
    {
#line 4960
    die((int const   )421, (int const   )3, (char const   */* const  */)"Please run pure-ftpd within a super-server (like tcpserver)");
    }
  }
  {
#line 4962
  fourinsix(& ctrlconn);
#line 4963
  tmp___1 = checkvalidaddr((struct sockaddr_storage  const  */* const  */)(& ctrlconn));
  }
#line 4963
  if (tmp___1 == 0) {
    {
#line 4964
    die((int const   )425, (int const   )3, (char const   */* const  */)"Sorry, invalid address given");
    }
  }
#line 4966
  if ((int )ctrlconn.ss_family == 10) {
    {
#line 4967
    tmp___2 = storage_port6((struct sockaddr_storage  const  */* const  */)(& ctrlconn));
#line 4967
    serverport = ntohs(*tmp___2);
    }
  } else {
    {
#line 4969
    tmp___3 = storage_port((struct sockaddr_storage  const  */* const  */)(& ctrlconn));
#line 4969
    serverport = ntohs(*tmp___3);
    }
  }
#line 4971
  if ((unsigned long )trustedip != (unsigned long )((void *)0)) {
    {
#line 4971
    tmp___4 = addrcmp((struct sockaddr_storage  const  */* const  */)(& ctrlconn),
                      (struct sockaddr_storage  const  */* const  */)trustedip);
    }
#line 4971
    if (tmp___4 != 0) {
#line 4972
      anon_only = (signed char)1;
    }
  }
  {
#line 4974
  socksize = (socklen_t )sizeof(peer);
#line 4975
  tmp___7 = getpeername(clientfd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& peer)),
                        (socklen_t */* __restrict  */)(& socksize));
  }
#line 4975
  if (tmp___7) {
    {
#line 4976
    tmp___5 = __errno_location();
#line 4976
    tmp___6 = strerror(*tmp___5);
#line 4976
    die((int const   )421, (int const   )3, (char const   */* const  */)"Unable to identify the local socket: %s",
        tmp___6);
    }
  }
  {
#line 4978
  fourinsix(& peer);
#line 4979
  tmp___8 = checkvalidaddr((struct sockaddr_storage  const  */* const  */)(& peer));
  }
#line 4979
  if (tmp___8 == 0) {
    {
#line 4980
    die((int const   )425, (int const   )3, (char const   */* const  */)"Sorry, invalid address given");
    }
  }
  {
#line 4983
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4986
    if ((int )resolve_hostnames != 0) {
#line 4986
      tmp___9 = 0;
    } else {
#line 4986
      tmp___9 = 1;
    }
#line 4986
    if ((int )peer.ss_family == 2) {
#line 4986
      tmp___10 = sizeof(struct sockaddr_in );
    } else {
#line 4986
      tmp___10 = sizeof(struct sockaddr_in6 );
    }
    {
#line 4986
    eai = getnameinfo((struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& peer)),
                      (socklen_t )tmp___10, (char */* __restrict  */)(host), (socklen_t )sizeof(host),
                      (char */* __restrict  */)((void *)0), (socklen_t )((size_t )0U),
                      tmp___9);
    }
#line 4986
    if (eai == 0) {
#line 4990
      goto while_break;
    }
#line 4992
    if ((int )resolve_hostnames != 0) {
#line 4992
      if ((int )peer.ss_family == 2) {
#line 4992
        tmp___11 = sizeof(struct sockaddr_in );
      } else {
#line 4992
        tmp___11 = sizeof(struct sockaddr_in6 );
      }
      {
#line 4992
      tmp___12 = getnameinfo((struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& peer)),
                             (socklen_t )tmp___11, (char */* __restrict  */)(host),
                             (socklen_t )sizeof(host), (char */* __restrict  */)((void *)0),
                             (socklen_t )((size_t )0U), 1);
      }
#line 4992
      if (tmp___12 == 0) {
#line 4996
        goto while_break;
      }
    }
    {
#line 4998
    die((int const   )425, (int const   )3, (char const   */* const  */)"Sorry, invalid address given");
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5002
  dns_sanitize(host);
#line 5007
  logfile((int const   )6, "New connection from %s", host);
#line 5009
  replycode = 220;
#line 5011
  fill_atomic_prefix();
  }
#line 5013
  if (maxusers > 0U) {
#line 5020
    if (standalone) {
#line 5021
      users = (unsigned int )nb_children;
    } else {
      {
#line 5023
      users = daemons(serverport);
      }
    }
#line 5027
    if (users > maxusers) {
      {
#line 5028
      addreply((int const   )421, (char const   */* const  */)"%lu users (the maximum) are already logged in, sorry",
               (unsigned long )maxusers);
#line 5029
      doreply();
#line 5030
      _EXIT((int const   )1);
      }
    }
  }
  {
#line 5077
  tmp___13 = getloadavg(load_, (int )(sizeof(load_) / sizeof(load_[0])));
  }
#line 5077
  if (tmp___13 < 0) {
#line 5078
    load = 0.0;
  } else {
#line 5080
    load = load_[1];
  }
  {
#line 5084
  wd[0] = (char )'/';
#line 5085
  wd[1] = (char)0;
#line 5086
  tmp___14 = chdir((char const   *)(wd));
  }
#line 5086
  if (tmp___14) {
    {
#line 5087
    _EXIT((int const   )1);
    }
  }
  {
#line 5093
  fodder = 16;
#line 5094
  setsockopt(clientfd, 0, 1, (void const   *)((char *)(& fodder)), (socklen_t )sizeof(fodder));
#line 5097
  fodder = 1;
#line 5098
  setsockopt(clientfd, 1, 10, (void const   *)((char *)(& fodder)), (socklen_t )sizeof(fodder));
#line 5102
  fodder = 1;
#line 5103
  setsockopt(clientfd, 6, 1, (void const   *)((char *)(& fodder)), (socklen_t )sizeof(fodder));
#line 5106
  keepalive((int const   )clientfd, 0);
#line 5111
  tmp___15 = zrand();
#line 5111
  srandom((unsigned int )session_start_time ^ tmp___15);
  }
#line 5120
  if (display_banner) {
    {
#line 5128
    addreply_noformat((int const   )0, (char const   */* const  */)"--------- Welcome to Pure-FTPd [privsep] ----------");
    }
#line 5132
    if (users > 0U) {
      {
#line 5133
      addreply((int const   )0, (char const   */* const  */)"You are user number %u of %u allowed.",
               users, maxusers);
      }
    }
    {
#line 5138
    t = localtime((time_t const   *)(& session_start_time));
    }
#line 5138
    if ((unsigned long )t != (unsigned long )((void *)0)) {
      {
#line 5139
      addreply((int const   )220, (char const   */* const  */)"Local time is now %02d:%02d. Server port: %u.",
               t->tm_hour, t->tm_min, (unsigned int )serverport);
      }
    }
  }
#line 5144
  if ((int )anon_only > 0) {
    {
#line 5145
    addreply_noformat((int const   )220, (char const   */* const  */)"Only anonymous FTP is allowed here");
    }
  } else
#line 5146
  if ((int )anon_only < 0) {
    {
#line 5147
    addreply_noformat((int const   )220, (char const   */* const  */)"This is a private system - No anonymous login");
    }
  }
#line 5149
  if ((int )allowfxp == 2) {
    {
#line 5150
    addreply_noformat((int const   )220, (char const   */* const  */)"This server supports FXP transfers");
    }
  }
#line 5162
  if (display_banner) {
#line 5163
    if ((int )v6ready != 0) {
#line 5163
      if ((int )peer.ss_family != 10) {
        {
#line 5164
        addreply((int const   )0, (char const   */* const  */)"IPv6 connections are also welcome on this server.");
        }
      }
    }
#line 5166
    if (idletime >= 120UL) {
      {
#line 5167
      addreply((int const   )220, (char const   */* const  */)"You will be disconnected after %lu minutes of inactivity.",
               idletime / 60UL);
      }
    } else {
      {
#line 5169
      addreply((int const   )220, (char const   */* const  */)"You will be disconnected after %lu seconds of inactivity.",
               idletime);
      }
    }
  }
#line 5172
  if (maxload <= 0.0) {
#line 5172
    tmp___16 = 1;
  } else
#line 5172
  if (load < maxload) {
#line 5172
    tmp___16 = 1;
  } else {
#line 5172
    tmp___16 = 0;
  }
#line 5172
  candownload = (signed char )tmp___16;
#line 5174
  if ((unsigned long )force_passive_ip_s != (unsigned long )((void *)0)) {
    {
#line 5177
    memset((void *)(& hints), 0, sizeof(hints));
#line 5178
    hints.ai_family = 2;
#line 5179
    hints.ai_addr = (struct sockaddr *)((void *)0);
#line 5180
    tmp___17 = getaddrinfo((char const   */* __restrict  */)force_passive_ip_s, (char const   */* __restrict  */)((void *)0),
                           (struct addrinfo  const  */* __restrict  */)(& hints),
                           (struct addrinfo **/* __restrict  */)(& res___0));
    }
#line 5180
    if (tmp___17 != 0) {
      {
#line 5183
      die((int const   )421, (int const   )3, (char const   */* const  */)"Illegal forced IP for passive connections");
      }
    } else
#line 5180
    if (res___0->ai_family != 2) {
      {
#line 5183
      die((int const   )421, (int const   )3, (char const   */* const  */)"Illegal forced IP for passive connections");
      }
    } else
#line 5180
    if ((unsigned long )res___0->ai_addrlen > sizeof(force_passive_ip)) {
      {
#line 5183
      die((int const   )421, (int const   )3, (char const   */* const  */)"Illegal forced IP for passive connections");
      }
    }
    {
#line 5185
    memcpy((void */* __restrict  */)(& force_passive_ip), (void const   */* __restrict  */)res___0->ai_addr,
           (size_t )res___0->ai_addrlen);
#line 5186
    freeaddrinfo(res___0);
    }
  }
  {
#line 5190
  tmp___18 = privsep_init();
  }
#line 5190
  if (tmp___18 != 0) {
    {
#line 5191
    die((int const   )421, (int const   )3, (char const   */* const  */)"privsep_init");
    }
  }
  {
#line 5195
  parser();
#line 5197
  addreply((int const   )0, (char const   */* const  */)"Logout.");
#line 5198
  logfile((int const   )6, "Logout.");
#line 5199
  doreply();
  }
#line 5203
  return;
}
}
#line 5205 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static void check_ipv6_support(void) 
{ 
  int p ;

  {
  {
#line 5210
  p = socket(10, 1, 6);
  }
#line 5210
  if (p != -1) {
    {
#line 5211
    close(p);
#line 5212
    v6ready = (signed char )((int )v6ready + 1);
    }
  }
#line 5215
  return;
}
}
#line 5218 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static void updatepidfile(void) 
{ 
  int fd ;
  char buf___1[42] ;
  size_t buf_len ;
  __pid_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  ssize_t tmp___3 ;

  {
  {
#line 5224
  tmp = getpid();
#line 5224
  tmp___0 = snprintf((char */* __restrict  */)(buf___1), sizeof(buf___1), (char const   */* __restrict  */)"%lu\n",
                     (unsigned long )tmp);
  }
#line 5224
  if (tmp___0 >= (int )sizeof(buf___1)) {
#line 5226
    return;
  }
  {
#line 5228
  tmp___1 = unlink(pid_file);
  }
#line 5228
  if (tmp___1 != 0) {
    {
#line 5228
    tmp___2 = __errno_location();
    }
#line 5228
    if (*tmp___2 != 2) {
#line 5229
      return;
    }
  }
  {
#line 5231
  fd = open(pid_file, 131649, (mode_t )420);
  }
#line 5231
  if (fd == -1) {
#line 5233
    return;
  }
  {
#line 5235
  buf_len = strlen((char const   *)(buf___1));
#line 5236
  tmp___3 = safe_write((int const   )fd, (void const   */* const  */)(buf___1), buf_len,
                       (int const   )-1);
  }
#line 5236
  if (tmp___3 != (ssize_t )buf_len) {
    {
#line 5237
    ftruncate(fd, (off_t )0);
    }
  }
  {
#line 5239
  close(fd);
  }
#line 5240
  return;
}
}
#line 5243 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static int closedesc_all(int const   closestdin ) 
{ 
  int fodder ;

  {
#line 5247
  if (closestdin != 0) {
    {
#line 5248
    close(0);
#line 5249
    fodder = open("/dev/null", 0);
    }
#line 5249
    if (fodder == -1) {
#line 5250
      return (-1);
    }
    {
#line 5252
    dup2(fodder, 0);
    }
#line 5253
    if (fodder > 0) {
      {
#line 5254
      close(fodder);
      }
    }
  }
  {
#line 5257
  fodder = open("/dev/null", 1);
  }
#line 5257
  if (fodder == -1) {
#line 5258
    return (-1);
  }
  {
#line 5260
  dup2(fodder, 1);
#line 5261
  dup2(1, 2);
  }
#line 5262
  if (fodder > 2) {
    {
#line 5263
    close(fodder);
    }
  }
#line 5266
  return (0);
}
}
#line 5269 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static void dodaemonize(void) 
{ 
  pid_t child ;
  unsigned int i ;
  int *tmp ;
  char *tmp___0 ;
  __pid_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 5275
  if ((int )daemonize != 0) {
    {
#line 5276
    child = fork();
    }
#line 5276
    if (child == -1) {
      {
#line 5277
      perror("Unable to start a standalone server - fork");
#line 5278
      tmp = __errno_location();
#line 5278
      tmp___0 = strerror(*tmp);
#line 5278
      logfile((int const   )3, "Unable to start a standalone server: [fork: %s]",
              tmp___0);
      }
#line 5279
      return;
    } else
#line 5280
    if (child != 0) {
      {
#line 5281
      _EXIT((int const   )0);
      }
    }
    {
#line 5283
    tmp___1 = setsid();
    }
#line 5283
    if (tmp___1 == -1) {
      {
#line 5284
      perror("Unable to start a standalone server - setsid");
      }
    }
    {
#line 5287
    tmp___2 = chdir("/");
    }
#line 5287
    if (tmp___2 != 0) {
      {
#line 5288
      perror("chdir");
#line 5289
      _EXIT((int const   )1);
      }
    }
    {
#line 5292
    i = open_max();
    }
    {
#line 5293
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 5294
      tmp___3 = isatty((int )i);
      }
#line 5294
      if (tmp___3) {
        {
#line 5295
        close((int )i);
        }
      }
#line 5297
      i --;
#line 5293
      if (! (i > 2U)) {
#line 5293
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 5299
    tmp___4 = closedesc_all((int const   )1);
    }
#line 5299
    if (tmp___4 != 0) {
      {
#line 5300
      perror("Unable to start a standalone server - /dev/null duplication");
#line 5301
      _EXIT((int const   )1);
      }
    }
  }
#line 5304
  return;
}
}
#line 5341 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static struct sockaddr_storage old_sa  ;
#line 5307 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static void accept_client(int const   active_listen_fd ) 
{ 
  sigset_t set ;
  struct sockaddr_storage sa ;
  socklen_t dummy ;
  pid_t child ;
  char line___1[1024] ;
  int tmp ;
  size_t tmp___0 ;
  char line___2[1024] ;
  char hbuf[1025] ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 5313
  memset((void *)(& sa), 0, sizeof(sa));
#line 5314
  dummy = (socklen_t )sizeof(sa);
#line 5315
  clientfd = accept((int )active_listen_fd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& sa)),
                    (socklen_t */* __restrict  */)(& dummy));
  }
#line 5315
  if (clientfd == -1) {
#line 5317
    return;
  }
#line 5319
  if ((int )sa.ss_family != 2) {
#line 5319
    if ((int )sa.ss_family != 10) {
      {
#line 5320
      close(clientfd);
#line 5321
      clientfd = -1;
      }
#line 5322
      return;
    }
  }
#line 5324
  if (maxusers > 0U) {
#line 5324
    if (nb_children >= (unsigned int volatile   )maxusers) {
      {
#line 5327
      snprintf((char */* __restrict  */)(line___1), sizeof(line___1), (char const   */* __restrict  */)"421 %lu users (the maximum) are already logged in, sorry\r\n",
               (unsigned long )maxusers);
#line 5330
      tmp = fcntl(clientfd, 3);
#line 5330
      fcntl(clientfd, 4, tmp | 2048);
#line 5331
      tmp___0 = strlen((char const   *)(line___1));
#line 5331
      write(clientfd, (void const   *)(line___1), tmp___0);
#line 5332
      close(clientfd);
#line 5333
      clientfd = -1;
      }
#line 5334
      return;
    }
  }
#line 5336
  if (maxip > 0U) {
    {
#line 5337
    fourinsix(& sa);
#line 5338
    tmp___7 = iptrack_get((struct sockaddr_storage  const  */* const  */)(& sa));
    }
#line 5338
    if (tmp___7 >= maxip) {
      {
#line 5343
      tmp___1 = fcntl(clientfd, 3);
#line 5343
      fcntl(clientfd, 4, tmp___1 | 2048);
#line 5344
      tmp___3 = snprintf((char */* __restrict  */)(line___2), sizeof(line___2), (char const   */* __restrict  */)"421 Too many connections (%lu) from this IP\r\n",
                         (unsigned long )maxip);
      }
#line 5344
      if (! (tmp___3 >= (int )sizeof(line___2))) {
        {
#line 5347
        tmp___2 = strlen((char const   *)(line___2));
#line 5347
        write(clientfd, (void const   *)(line___2), tmp___2);
        }
      }
      {
#line 5349
      tmp___6 = addrcmp((struct sockaddr_storage  const  */* const  */)(& old_sa),
                        (struct sockaddr_storage  const  */* const  */)(& sa));
      }
#line 5349
      if (tmp___6 != 0) {
#line 5350
        old_sa = sa;
#line 5351
        if ((int )sa.ss_family == 2) {
#line 5351
          tmp___4 = sizeof(struct sockaddr_in );
        } else {
#line 5351
          tmp___4 = sizeof(struct sockaddr_in6 );
        }
        {
#line 5351
        tmp___5 = getnameinfo((struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& sa)),
                              (socklen_t )tmp___4, (char */* __restrict  */)(hbuf),
                              (socklen_t )sizeof(hbuf), (char */* __restrict  */)((void *)0),
                              (socklen_t )((size_t )0U), 1);
        }
#line 5351
        if (tmp___5 == 0) {
          {
#line 5355
          logfile((int const   )4, "Too many connections (%lu) from this IP: [%s]",
                  (unsigned long )maxip, hbuf);
          }
        }
      }
      {
#line 5359
      close(clientfd);
#line 5360
      clientfd = -1;
      }
#line 5361
      return;
    }
  }
  {
#line 5364
  sigemptyset(& set);
#line 5365
  sigaddset(& set, 17);
#line 5366
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& set), (sigset_t */* __restrict  */)((void *)0));
#line 5367
  nb_children += (unsigned int volatile   )1;
#line 5368
  child = fork();
  }
#line 5369
  if (child == 0) {
    {
#line 5370
    tmp___8 = isatty(2);
    }
#line 5370
    if (tmp___8) {
      {
#line 5371
      close(2);
      }
    }
#line 5374
    if ((int )no_syslog == 0) {
      {
#line 5375
      closelog();
#line 5376
      openlog("pure-ftpd", 8 | log_pid, syslog_facility);
      }
    }
    {
#line 5379
    doit();
#line 5380
    _EXIT((int const   )0);
    }
  } else
#line 5381
  if (child == -1) {
#line 5382
    if (nb_children > (unsigned int volatile   )0U) {
#line 5383
      nb_children -= (unsigned int volatile   )1;
    }
  } else
#line 5386
  if (maxip > 0U) {
    {
#line 5387
    iptrack_add((struct sockaddr_storage  const  */* const  */)(& sa), (pid_t const   )child);
    }
  }
  {
#line 5390
  close(clientfd);
#line 5391
  clientfd = -1;
#line 5392
  sigprocmask(1, (sigset_t const   */* __restrict  */)(& set), (sigset_t */* __restrict  */)((void *)0));
  }
#line 5393
  return;
}
}
#line 5395 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
static void standalone_server(void) 
{ 
  int on ;
  struct addrinfo hints ;
  struct addrinfo *res___0 ;
  struct addrinfo *res6 ;
  fd_set rs___1 ;
  int max_fd ;
  int old_errno ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  unsigned int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  int __d0 ;
  int __d1 ;
  int *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
  {
#line 5403
  standalone = (signed char)1;
#line 5405
  memset((void *)(& hints), 0, sizeof(hints));
#line 5406
  hints.ai_flags = 1;
#line 5407
  hints.ai_family = 2;
#line 5408
  hints.ai_socktype = 1;
#line 5409
  hints.ai_addr = (struct sockaddr *)((void *)0);
#line 5410
  on = 1;
  }
#line 5411
  if (listenfd == (int volatile   )-1) {
#line 5411
    if ((int )no_ipv4 == 0) {
      {
#line 5411
      tmp___6 = getaddrinfo((char const   */* __restrict  */)standalone_ip, (char const   */* __restrict  */)standalone_port,
                            (struct addrinfo  const  */* __restrict  */)(& hints),
                            (struct addrinfo **/* __restrict  */)(& res___0));
      }
#line 5411
      if (tmp___6 == 0) {
        {
#line 5413
        tmp___1 = socket(2, 1, 6);
#line 5413
        listenfd = (int volatile   )tmp___1;
        }
#line 5413
        if (listenfd == (int volatile   )-1) {
#line 5413
          goto cant_bind;
        } else {
          {
#line 5413
          tmp___2 = setsockopt((int )listenfd, 1, 2, (void const   *)((char *)(& on)),
                               (socklen_t )sizeof(on));
          }
#line 5413
          if (tmp___2 != 0) {
            cant_bind: 
            {
#line 5419
            tmp = __errno_location();
#line 5419
            old_errno = *tmp;
#line 5420
            perror("Unable to start a standalone server");
#line 5421
            tmp___0 = strerror(old_errno);
#line 5421
            logfile((int const   )3, "Unable to start a standalone server: [%s]",
                    tmp___0);
            }
#line 5423
            return;
          }
        }
        {
#line 5425
        tmp___3 = bind((int )listenfd, (struct sockaddr  const  */* __restrict  */)res___0->ai_addr,
                       res___0->ai_addrlen);
        }
#line 5425
        if (tmp___3 != 0) {
#line 5428
          goto cant_bind;
        } else {
#line 5425
          if (maxusers > 0U) {
#line 5425
            tmp___4 = 3U + maxusers / 8U;
          } else {
#line 5425
            tmp___4 = 42U;
          }
          {
#line 5425
          tmp___5 = listen((int )listenfd, (int )tmp___4);
          }
#line 5425
          if (tmp___5 != 0) {
#line 5428
            goto cant_bind;
          }
        }
        {
#line 5430
        freeaddrinfo(res___0);
#line 5431
        set_cloexec_flag((int const   )listenfd);
        }
      }
    }
  }
#line 5433
  if (listenfd6 == (int volatile   )-1) {
#line 5433
    if ((int )v6ready != 0) {
      {
#line 5434
      hints.ai_family = 10;
#line 5435
      tmp___12 = getaddrinfo((char const   */* __restrict  */)standalone_ip, (char const   */* __restrict  */)standalone_port,
                             (struct addrinfo  const  */* __restrict  */)(& hints),
                             (struct addrinfo **/* __restrict  */)(& res6));
      }
#line 5435
      if (tmp___12 == 0) {
        {
#line 5436
        tmp___7 = socket(10, 1, 6);
#line 5436
        listenfd6 = (int volatile   )tmp___7;
        }
#line 5436
        if (listenfd6 == (int volatile   )-1) {
#line 5440
          goto cant_bind;
        } else {
          {
#line 5436
          tmp___8 = setsockopt((int )listenfd6, 1, 2, (void const   *)((char *)(& on)),
                               (socklen_t )sizeof(on));
          }
#line 5436
          if (tmp___8 != 0) {
#line 5440
            goto cant_bind;
          }
        }
        {
#line 5443
        setsockopt((int )listenfd6, 41, 26, (void const   *)((char *)(& on)), (socklen_t )sizeof(on));
#line 5446
        tmp___9 = bind((int )listenfd6, (struct sockaddr  const  */* __restrict  */)res6->ai_addr,
                       res6->ai_addrlen);
        }
#line 5446
        if (tmp___9 != 0) {
#line 5450
          goto cant_bind;
        } else {
#line 5446
          if (maxusers > 0U) {
#line 5446
            tmp___10 = 3U + maxusers / 8U;
          } else {
#line 5446
            tmp___10 = 42U;
          }
          {
#line 5446
          tmp___11 = listen((int )listenfd6, (int )tmp___10);
          }
#line 5446
          if (tmp___11 != 0) {
#line 5450
            goto cant_bind;
          }
        }
        {
#line 5452
        freeaddrinfo(res6);
#line 5453
        set_cloexec_flag((int const   )listenfd6);
        }
      }
    }
  }
#line 5456
  if (listenfd == (int volatile   )-1) {
#line 5456
    if (listenfd6 == (int volatile   )-1) {
      {
#line 5458
      tmp___13 = __errno_location();
#line 5458
      *tmp___13 = 99;
      }
#line 5460
      goto cant_bind;
    }
  }
  {
#line 5462
  updatepidfile();
#line 5463
  setprocessname((char const   */* const  */)"pure-ftpd (SERVER)");
  }
  {
#line 5464
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5464
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& rs___1.fds_bits[0]): "memory");
#line 5464
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 5465
  if (listenfd > listenfd6) {
#line 5466
    max_fd = (int )listenfd;
  } else {
#line 5468
    max_fd = (int )listenfd6;
  }
#line 5470
  max_fd ++;
  {
#line 5471
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5471
    if (! (stop_server == (sig_atomic_t volatile   )0)) {
#line 5471
      goto while_break___0;
    }
    {
#line 5472
    safe_fd_set((int const   )listenfd, (fd_set */* const  */)(& rs___1));
#line 5473
    safe_fd_set((int const   )listenfd6, (fd_set */* const  */)(& rs___1));
#line 5474
    tmp___15 = select(max_fd, (fd_set */* __restrict  */)(& rs___1), (fd_set */* __restrict  */)((void *)0),
                      (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
    }
#line 5474
    if (tmp___15 <= 0) {
      {
#line 5475
      tmp___14 = __errno_location();
      }
#line 5475
      if (*tmp___14 != 4) {
        {
#line 5476
        sleep(1U);
        }
      }
#line 5478
      goto while_continue___0;
    }
    {
#line 5480
    tmp___16 = safe_fd_isset((int const   )listenfd, (fd_set const   */* const  */)(& rs___1));
    }
#line 5480
    if (tmp___16) {
      {
#line 5481
      accept_client((int const   )listenfd);
      }
    }
    {
#line 5483
    tmp___17 = safe_fd_isset((int const   )listenfd6, (fd_set const   */* const  */)(& rs___1));
    }
#line 5483
    if (tmp___17) {
      {
#line 5484
      accept_client((int const   )listenfd6);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 5487
  return;
}
}
#line 5506 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/ftpd.c"
int pureftpd_start(int argc , char **argv , char const   *home_directory_ ) 
{ 
  int option_index ;
  int fodder ;
  int bypass_ipv6 ;
  struct passwd *pw ;
  int tmp ;
  char *struck ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char const   *nptr ;
  char *endptr ;
  unsigned long tmp___3 ;
  char const   *nptr___0 ;
  char *endptr___0 ;
  unsigned long tmp___4 ;
  char const   *nptr___1 ;
  char *endptr___1 ;
  unsigned long tmp___5 ;
  int n ;
  int tmp___6 ;
  int tmp___7 ;
  Authentication const   *auth_list_pnt ;
  char const   *opt ;
  Authentications *new_auth ;
  size_t auth_name_len ;
  char *file ;
  void *tmp___8 ;
  int tmp___9 ;
  char const   *nptr___2 ;
  char *endptr___2 ;
  int ret ;
  int ret___0 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char const   *nptr___3 ;
  char *endptr___3 ;
  unsigned long tmp___12 ;
  char const   *nptr___4 ;
  char *endptr___4 ;
  double tmp___13 ;
  char const   *nptr___5 ;
  char *endptr___5 ;
  long tmp___14 ;
  char *optarg_copy ;
  char *struck___0 ;
  char const   *tr_umask ;
  char const   *tr_umask_d ;
  unsigned long tmp___15 ;
  unsigned long tmp___16 ;
  __uid_t tmp___17 ;
  struct option  const  *options ;
  char const   *tmp___18 ;
  void *tmp___19 ;
  unsigned int portmax ;
  int tmp___20 ;
  Authentications *auth_scan ;
  Authentications *previous ;

  {
  {
#line 5509
  option_index = 0;
#line 5512
  bypass_ipv6 = 0;
#line 5519
  client_init_reply_buf();
#line 5522
  tmp = getpagesize();
#line 5522
  page_size = (size_t )tmp;
#line 5533
  setlocale(5, "en_GB");
#line 5536
  setlocale(0, "C");
#line 5539
  setlocale(3, "C");
#line 5543
  init_tz___0();
#line 5544
  strerror(2);
#line 5547
  openlog("pure-ftpd", 8 | log_pid, 11 << 3);
#line 5553
  set_signals();
#line 5555
  loggedin = (signed char)0;
  }
  {
#line 5569
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 5569
    fodder = getopt_long(argc, (char * const  *)argv, GETOPT_OPTIONS, (struct option  const  *)(long_options),
                         & option_index);
    }
#line 5569
    if (! (fodder != -1)) {
#line 5569
      goto while_break;
    }
    {
#line 5577
    if (fodder == 115) {
#line 5577
      goto case_115;
    }
#line 5585
    if (fodder == 48) {
#line 5585
      goto case_48;
    }
#line 5589
    if (fodder == 52) {
#line 5589
      goto case_52;
    }
#line 5593
    if (fodder == 54) {
#line 5593
      goto case_54;
    }
#line 5611
    if (fodder == 49) {
#line 5611
      goto case_49;
    }
#line 5616
    if (fodder == 83) {
#line 5616
      goto case_83;
    }
#line 5640
    if (fodder == 68) {
#line 5640
      goto case_68;
    }
#line 5689
    if (fodder == 97) {
#line 5689
      goto case_97;
    }
#line 5702
    if (fodder == 120) {
#line 5702
      goto case_120;
    }
#line 5706
    if (fodder == 88) {
#line 5706
      goto case_88;
    }
#line 5710
    if (fodder == 122) {
#line 5710
      goto case_122;
    }
#line 5714
    if (fodder == 90) {
#line 5714
      goto case_90;
    }
#line 5718
    if (fodder == 65) {
#line 5718
      goto case_65;
    }
#line 5722
    if (fodder == 119) {
#line 5722
      goto case_119;
    }
#line 5726
    if (fodder == 87) {
#line 5726
      goto case_87;
    }
#line 5730
    if (fodder == 100) {
#line 5730
      goto case_100;
    }
#line 5736
    if (fodder == 98) {
#line 5736
      goto case_98;
    }
#line 5740
    if (fodder == 99) {
#line 5740
      goto case_99;
    }
#line 5753
    if (fodder == 66) {
#line 5753
      goto case_66;
    }
#line 5757
    if (fodder == 67) {
#line 5757
      goto case_67;
    }
#line 5799
    if (fodder == 101) {
#line 5799
      goto case_101;
    }
#line 5803
    if (fodder == 69) {
#line 5803
      goto case_69;
    }
#line 5816
    if (fodder == 102) {
#line 5816
      goto case_102;
    }
#line 5835
    if (fodder == 108) {
#line 5835
      goto case_108;
    }
#line 5882
    if (fodder == 109) {
#line 5882
      goto case_109;
    }
#line 5895
    if (fodder == 77) {
#line 5895
      goto case_77;
    }
#line 5899
    if (fodder == 78) {
#line 5899
      goto case_78;
    }
#line 5950
    if (fodder == 112) {
#line 5950
      goto case_112;
    }
#line 5961
    if (fodder == 76) {
#line 5961
      goto case_76;
    }
#line 5984
    if (fodder == 80) {
#line 5984
      goto case_80;
    }
#line 6006
    if (fodder == 114) {
#line 6006
      goto case_114;
    }
#line 6010
    if (fodder == 82) {
#line 6010
      goto case_82;
    }
#line 6014
    if (fodder == 75) {
#line 6014
      goto case_75;
    }
#line 6019
    if (fodder == 103) {
#line 6019
      goto case_103;
    }
#line 6026
    if (fodder == 71) {
#line 6026
      goto case_71;
    }
#line 6030
    if (fodder == 72) {
#line 6030
      goto case_72;
    }
#line 6034
    if (fodder == 73) {
#line 6034
      goto case_73;
    }
#line 6046
    if (fodder == 105) {
#line 6046
      goto case_105;
    }
#line 6050
    if (fodder == 106) {
#line 6050
      goto case_106;
    }
#line 6054
    if (fodder == 107) {
#line 6054
      goto case_107;
    }
#line 6066
    if (fodder == 117) {
#line 6066
      goto case_117;
    }
#line 6080
    if (fodder == 85) {
#line 6080
      goto case_85;
    }
#line 6144
    if (fodder == 104) {
#line 6144
      goto case_104;
    }
#line 6164
    goto switch_default;
    case_115: /* CIL Label */ 
    {
#line 5578
    pw = getpwnam("ftp");
    }
#line 5578
    if (pw) {
#line 5579
      warez = pw->pw_uid;
    } else {
      {
#line 5581
      logfile((int const   )3, "Unable to find the \'ftp\' account");
      }
    }
#line 5583
    goto switch_break;
    case_48: /* CIL Label */ 
#line 5586
    no_truncate = (signed char)1;
#line 5587
    goto switch_break;
    case_52: /* CIL Label */ 
#line 5590
    bypass_ipv6 = 1;
#line 5591
    goto switch_break;
    case_54: /* CIL Label */ 
#line 5594
    no_ipv4 = (signed char)1;
#line 5595
    goto switch_break;
    case_49: /* CIL Label */ 
#line 5612
    log_pid = 1;
#line 5613
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 5619
    struck = strchr((char const   *)optarg, ',');
    }
#line 5619
    if ((unsigned long )struck != (unsigned long )((void *)0)) {
#line 5620
      *struck = (char)0;
#line 5621
      if ((int )*optarg != 0) {
        {
#line 5622
        tmp___0 = strdup((char const   *)optarg);
#line 5622
        standalone_ip = (char const   *)tmp___0;
        }
#line 5622
        if ((unsigned long )standalone_ip == (unsigned long )((void *)0)) {
          {
#line 5623
          die_mem();
          }
        }
      }
#line 5626
      *struck = (char )',';
#line 5627
      if ((int )*(struck + 1) != 0) {
        {
#line 5628
        tmp___1 = strdup((char const   *)(struck + 1));
#line 5628
        standalone_port = (char const   *)tmp___1;
        }
#line 5628
        if ((unsigned long )standalone_port == (unsigned long )((void *)0)) {
          {
#line 5629
          die_mem();
          }
        }
      }
    } else {
      {
#line 5633
      tmp___2 = strdup((char const   *)optarg);
#line 5633
      standalone_port = (char const   *)tmp___2;
      }
#line 5633
      if ((unsigned long )standalone_port == (unsigned long )((void *)0)) {
        {
#line 5634
        die_mem();
        }
      }
    }
#line 5637
    goto switch_break;
    case_68: /* CIL Label */ 
#line 5641
    force_ls_a = (signed char)1;
#line 5642
    goto switch_break;
    case_97: /* CIL Label */ 
    {
#line 5693
    nptr = (char const   *)optarg;
#line 5694
    endptr = (char *)((void *)0);
#line 5695
    tmp___3 = strtoul((char const   */* __restrict  */)nptr, (char **/* __restrict  */)(& endptr),
                      0);
#line 5695
    chroot_trustedgid = (uid_t )tmp___3;
    }
#line 5696
    if (! nptr) {
      {
#line 5697
      die((int const   )421, (int const   )3, (char const   */* const  */)"Configuration error: Illegal trusted gid for chroot: %s",
          optarg);
      }
    } else
#line 5696
    if (! *nptr) {
      {
#line 5697
      die((int const   )421, (int const   )3, (char const   */* const  */)"Configuration error: Illegal trusted gid for chroot: %s",
          optarg);
      }
    } else
#line 5696
    if (! endptr) {
      {
#line 5697
      die((int const   )421, (int const   )3, (char const   */* const  */)"Configuration error: Illegal trusted gid for chroot: %s",
          optarg);
      }
    } else
#line 5696
    if (*endptr) {
      {
#line 5697
      die((int const   )421, (int const   )3, (char const   */* const  */)"Configuration error: Illegal trusted gid for chroot: %s",
          optarg);
      }
    }
#line 5699
    userchroot = (signed char)1;
#line 5700
    goto switch_break;
    case_120: /* CIL Label */ 
#line 5703
    dot_write_ok = (signed char)0;
#line 5704
    goto switch_break;
    case_88: /* CIL Label */ 
#line 5707
    dot_read_ok = (signed char)0;
#line 5707
    dot_write_ok = dot_read_ok;
#line 5708
    goto switch_break;
    case_122: /* CIL Label */ 
#line 5711
    dot_read_anon_ok = (signed char)1;
#line 5712
    goto switch_break;
    case_90: /* CIL Label */ 
#line 5715
    be_customer_proof = (signed char)1;
#line 5716
    goto switch_break;
    case_65: /* CIL Label */ 
#line 5719
    userchroot = (signed char)2;
#line 5720
    goto switch_break;
    case_119: /* CIL Label */ 
#line 5723
    allowfxp = (signed char)1;
#line 5724
    goto switch_break;
    case_87: /* CIL Label */ 
#line 5727
    allowfxp = (signed char)2;
#line 5728
    goto switch_break;
    case_100: /* CIL Label */ 
#line 5731
    if ((int volatile   )logging < (int volatile   )2) {
#line 5732
      logging = (signed char volatile   )((int volatile   )logging + (int volatile   )1);
    }
#line 5734
    goto switch_break;
    case_98: /* CIL Label */ 
#line 5737
    broken_client_compat = (signed char)1;
#line 5738
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 5744
    nptr___0 = (char const   *)optarg;
#line 5745
    endptr___0 = (char *)((void *)0);
#line 5746
    tmp___4 = strtoul((char const   */* __restrict  */)nptr___0, (char **/* __restrict  */)(& endptr___0),
                      0);
#line 5746
    maxusers = (unsigned int )tmp___4;
    }
#line 5747
    if (! nptr___0) {
      {
#line 5748
      die((int const   )421, (int const   )3, (char const   */* const  */)"Configuration error: Illegal user limit: %s",
          optarg);
      }
    } else
#line 5747
    if (! *nptr___0) {
      {
#line 5748
      die((int const   )421, (int const   )3, (char const   */* const  */)"Configuration error: Illegal user limit: %s",
          optarg);
      }
    } else
#line 5747
    if (! endptr___0) {
      {
#line 5748
      die((int const   )421, (int const   )3, (char const   */* const  */)"Configuration error: Illegal user limit: %s",
          optarg);
      }
    } else
#line 5747
    if (*endptr___0) {
      {
#line 5748
      die((int const   )421, (int const   )3, (char const   */* const  */)"Configuration error: Illegal user limit: %s",
          optarg);
      }
    } else
#line 5747
    if (! maxusers) {
      {
#line 5748
      die((int const   )421, (int const   )3, (char const   */* const  */)"Configuration error: Illegal user limit: %s",
          optarg);
      }
    }
#line 5750
    goto switch_break;
    case_66: /* CIL Label */ 
#line 5754
    daemonize = (signed char)1;
#line 5755
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 5761
    nptr___1 = (char const   *)optarg;
#line 5762
    endptr___1 = (char *)((void *)0);
#line 5763
    tmp___5 = strtoul((char const   */* __restrict  */)nptr___1, (char **/* __restrict  */)(& endptr___1),
                      0);
#line 5763
    maxip = (unsigned int )tmp___5;
    }
#line 5764
    if (! nptr___1) {
      {
#line 5765
      die((int const   )421, (int const   )3, (char const   */* const  */)"Configuration error: Illegal user limit: %s",
          optarg);
      }
    } else
#line 5764
    if (! *nptr___1) {
      {
#line 5765
      die((int const   )421, (int const   )3, (char const   */* const  */)"Configuration error: Illegal user limit: %s",
          optarg);
      }
    } else
#line 5764
    if (! endptr___1) {
      {
#line 5765
      die((int const   )421, (int const   )3, (char const   */* const  */)"Configuration error: Illegal user limit: %s",
          optarg);
      }
    } else
#line 5764
    if (*endptr___1) {
      {
#line 5765
      die((int const   )421, (int const   )3, (char const   */* const  */)"Configuration error: Illegal user limit: %s",
          optarg);
      }
    } else
#line 5764
    if (! maxip) {
      {
#line 5765
      die((int const   )421, (int const   )3, (char const   */* const  */)"Configuration error: Illegal user limit: %s",
          optarg);
      }
    }
#line 5767
    goto switch_break;
    case_101: /* CIL Label */ 
#line 5800
    anon_only = (signed char)1;
#line 5801
    goto switch_break;
    case_69: /* CIL Label */ 
#line 5804
    anon_only = (signed char)-1;
#line 5805
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 5817
    n = 0;
#line 5819
    tmp___6 = strcasecmp((char const   *)optarg, "none");
    }
#line 5819
    if (tmp___6 == 0) {
#line 5820
      no_syslog = (signed char)1;
#line 5821
      goto switch_break;
    }
    {
#line 5823
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 5823
      if (facilitynames[n].c_name) {
        {
#line 5823
        tmp___7 = strcasecmp((char const   *)facilitynames[n].c_name, (char const   *)optarg);
        }
#line 5823
        if (! (tmp___7 != 0)) {
#line 5823
          goto while_break___0;
        }
      } else {
#line 5823
        goto while_break___0;
      }
#line 5825
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 5827
    if (facilitynames[n].c_name) {
#line 5828
      syslog_facility = facilitynames[n].c_val;
    } else {
      {
#line 5830
      logfile((int const   )3, "Configuration error: Unknown facility name: %s", optarg);
      }
    }
#line 5833
    goto switch_break;
    case_108: /* CIL Label */ 
#line 5836
    auth_list_pnt = (Authentication const   *)(auth_list);
#line 5837
    opt = (char const   *)optarg;
    {
#line 5841
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 5842
      auth_name_len = strlen((char const   *)auth_list_pnt->name);
#line 5843
      tmp___9 = strncasecmp(opt, (char const   *)auth_list_pnt->name, auth_name_len);
      }
#line 5843
      if (tmp___9 == 0) {
#line 5845
        file = (char *)((void *)0);
#line 5847
        opt += auth_name_len;
#line 5848
        if ((int const   )*opt == 58) {
#line 5849
          opt ++;
#line 5850
          if ((int const   )*opt != 0) {
            {
#line 5851
            file = strdup(opt);
            }
#line 5851
            if ((unsigned long )file == (unsigned long )((void *)0)) {
              {
#line 5852
              die_mem();
              }
            }
          }
        }
#line 5856
        if ((unsigned long )auth_list_pnt->parse != (unsigned long )((void *)0)) {
          {
#line 5857
          (*(auth_list_pnt->parse))((char const   */* const  */)file);
          }
        }
        {
#line 5859
        tmp___8 = malloc(sizeof(*new_auth));
#line 5859
        new_auth = (Authentications *)tmp___8;
        }
#line 5859
        if ((unsigned long )new_auth == (unsigned long )((void *)0)) {
          {
#line 5860
          die_mem();
          }
        }
#line 5862
        new_auth->auth = auth_list_pnt;
#line 5863
        new_auth->conf_file = file;
#line 5864
        new_auth->next = (struct Authentications_ *)((void *)0);
#line 5865
        if ((unsigned long )last_authentications == (unsigned long )((void *)0)) {
#line 5866
          first_authentications = new_auth;
        } else {
#line 5868
          last_authentications->next = new_auth;
        }
#line 5870
        last_authentications = new_auth;
#line 5872
        goto while_break___1;
      }
#line 5874
      auth_list_pnt ++;
#line 5875
      if ((unsigned long )auth_list_pnt->name == (unsigned long )((void *)0)) {
        {
#line 5876
        die((int const   )421, (int const   )3, (char const   */* const  */)"Unknown authentication method: %s",
            opt);
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 5880
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 5886
    nptr___2 = (char const   *)optarg;
#line 5887
    endptr___2 = (char *)((void *)0);
#line 5888
    maxload = strtod((char const   */* __restrict  */)nptr___2, (char **/* __restrict  */)(& endptr___2));
    }
#line 5889
    if (! nptr___2) {
      {
#line 5890
      die((int const   )421, (int const   )3, (char const   */* const  */)"Configuration error: Illegal load limit: %s",
          optarg);
      }
    } else
#line 5889
    if (! *nptr___2) {
      {
#line 5890
      die((int const   )421, (int const   )3, (char const   */* const  */)"Configuration error: Illegal load limit: %s",
          optarg);
      }
    } else
#line 5889
    if (! endptr___2) {
      {
#line 5890
      die((int const   )421, (int const   )3, (char const   */* const  */)"Configuration error: Illegal load limit: %s",
          optarg);
      }
    } else
#line 5889
    if (*endptr___2) {
      {
#line 5890
      die((int const   )421, (int const   )3, (char const   */* const  */)"Configuration error: Illegal load limit: %s",
          optarg);
      }
    } else
#line 5889
    if (maxload <= 0.0) {
      {
#line 5890
      die((int const   )421, (int const   )3, (char const   */* const  */)"Configuration error: Illegal load limit: %s",
          optarg);
      }
    }
#line 5893
    goto switch_break;
    case_77: /* CIL Label */ 
#line 5896
    allow_anon_mkdir = 1;
#line 5897
    goto switch_break;
    case_78: /* CIL Label */ 
#line 5900
    disallow_passive = (signed char)1;
#line 5901
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 5953
    ret = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%u:%u",
                 & firstport, & lastport);
    }
#line 5954
    if (ret != 2) {
      {
#line 5957
      die((int const   )421, (int const   )3, (char const   */* const  */)"Configuration error: Illegal ports range: %s",
          optarg);
      }
    } else
#line 5954
    if (firstport < 1024U) {
      {
#line 5957
      die((int const   )421, (int const   )3, (char const   */* const  */)"Configuration error: Illegal ports range: %s",
          optarg);
      }
    } else
#line 5954
    if (lastport > 65535U) {
      {
#line 5957
      die((int const   )421, (int const   )3, (char const   */* const  */)"Configuration error: Illegal ports range: %s",
          optarg);
      }
    } else
#line 5954
    if (lastport < firstport) {
      {
#line 5957
      die((int const   )421, (int const   )3, (char const   */* const  */)"Configuration error: Illegal ports range: %s",
          optarg);
      }
    }
#line 5959
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 5964
    ret___0 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%u:%u",
                     & max_ls_files, & max_ls_depth);
    }
#line 5965
    if (ret___0 != 2) {
      {
#line 5967
      die((int const   )421, (int const   )3, (char const   */* const  */)"Configuration error: Illegal \'ls\' limits: %s",
          optarg);
      }
    } else
#line 5965
    if (max_ls_files < 1U) {
      {
#line 5967
      die((int const   )421, (int const   )3, (char const   */* const  */)"Configuration error: Illegal \'ls\' limits: %s",
          optarg);
      }
    } else
#line 5965
    if (max_ls_depth < 1U) {
      {
#line 5967
      die((int const   )421, (int const   )3, (char const   */* const  */)"Configuration error: Illegal \'ls\' limits: %s",
          optarg);
      }
    }
#line 5969
    goto switch_break;
    case_80: /* CIL Label */ 
    {
#line 5985
    tmp___10 = strdup((char const   *)optarg);
#line 5985
    force_passive_ip_s = (char const   *)tmp___10;
    }
#line 5985
    if ((unsigned long )force_passive_ip_s == (unsigned long )((void *)0)) {
      {
#line 5986
      die_mem();
      }
    }
#line 5988
    goto switch_break;
    case_114: /* CIL Label */ 
#line 6007
    autorename = (signed char)1;
#line 6008
    goto switch_break;
    case_82: /* CIL Label */ 
#line 6011
    nochmod = (signed char)1;
#line 6012
    goto switch_break;
    case_75: /* CIL Label */ 
#line 6015
    keepallfiles = (signed char)1;
#line 6016
    goto switch_break;
    case_103: /* CIL Label */ 
    {
#line 6020
    tmp___11 = strdup((char const   *)optarg);
#line 6020
    pid_file = (char const   *)tmp___11;
    }
#line 6020
    if ((unsigned long )pid_file == (unsigned long )((void *)0)) {
      {
#line 6021
      die_mem();
      }
    }
#line 6023
    goto switch_break;
    case_71: /* CIL Label */ 
#line 6027
    disallow_rename = (signed char)1;
#line 6028
    goto switch_break;
    case_72: /* CIL Label */ 
#line 6031
    resolve_hostnames = (signed char)0;
#line 6032
    goto switch_break;
    case_73: /* CIL Label */ 
    {
#line 6038
    nptr___3 = (char const   *)optarg;
#line 6039
    endptr___3 = (char *)((void *)0);
#line 6040
    tmp___12 = strtoul((char const   */* __restrict  */)nptr___3, (char **/* __restrict  */)(& endptr___3),
                       0);
#line 6040
    idletime = tmp___12 * 60UL;
    }
#line 6041
    if (idletime <= 0UL) {
#line 6042
      idletime = 900UL;
    }
#line 6044
    goto switch_break;
    case_105: /* CIL Label */ 
#line 6047
    anon_noupload = (signed char)1;
#line 6048
    goto switch_break;
    case_106: /* CIL Label */ 
#line 6051
    create_home = (signed char)1;
#line 6052
    goto switch_break;
    case_107: /* CIL Label */ 
    {
#line 6058
    nptr___4 = (char const   *)optarg;
#line 6059
    endptr___4 = (char *)((void *)0);
#line 6060
    tmp___13 = strtod((char const   */* __restrict  */)nptr___4, (char **/* __restrict  */)(& endptr___4));
#line 6060
    maxdiskusagepct = 1.0 - tmp___13 / 100.0;
    }
#line 6061
    if (maxdiskusagepct >= 1.0) {
#line 6062
      maxdiskusagepct = 0.0;
    } else
#line 6061
    if (maxdiskusagepct < 0.0) {
#line 6062
      maxdiskusagepct = 0.0;
    }
#line 6064
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 6071
    nptr___5 = (char const   *)optarg;
#line 6072
    endptr___5 = (char *)((void *)0);
#line 6073
    tmp___14 = strtol((char const   */* __restrict  */)nptr___5, (char **/* __restrict  */)(& endptr___5),
                      10);
    }
#line 6074
    if (! nptr___5) {
      {
#line 6075
      die((int const   )421, (int const   )3, (char const   */* const  */)"Configuration error: Illegal uid limit: %s",
          optarg);
      }
    } else
#line 6074
    if (! *nptr___5) {
      {
#line 6075
      die((int const   )421, (int const   )3, (char const   */* const  */)"Configuration error: Illegal uid limit: %s",
          optarg);
      }
    } else
#line 6074
    if (! endptr___5) {
      {
#line 6075
      die((int const   )421, (int const   )3, (char const   */* const  */)"Configuration error: Illegal uid limit: %s",
          optarg);
      }
    } else
#line 6074
    if (*endptr___5) {
      {
#line 6075
      die((int const   )421, (int const   )3, (char const   */* const  */)"Configuration error: Illegal uid limit: %s",
          optarg);
      }
    } else
#line 6074
    if (tmp___14 < 0L) {
      {
#line 6075
      die((int const   )421, (int const   )3, (char const   */* const  */)"Configuration error: Illegal uid limit: %s",
          optarg);
      }
    }
#line 6077
    useruid = (uid_t )tmp___14;
#line 6078
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 6083
    tr_umask = (char const   *)((void *)0);
#line 6084
    tr_umask_d = (char const   *)((void *)0);
#line 6086
    optarg_copy = strdup((char const   *)optarg);
    }
#line 6086
    if ((unsigned long )optarg_copy == (unsigned long )((void *)0)) {
      {
#line 6087
      die_mem();
      }
    }
    {
#line 6089
    struck___0 = strchr((char const   *)optarg_copy, ':');
    }
#line 6089
    if ((unsigned long )struck___0 != (unsigned long )((void *)0)) {
#line 6090
      *struck___0 = (char)0;
#line 6091
      if ((int )*optarg_copy != 0) {
#line 6092
        tr_umask = (char const   *)optarg_copy;
      }
#line 6094
      if ((int )*(struck___0 + 1) != 0) {
#line 6095
        tr_umask_d = (char const   *)(struck___0 + 1);
      }
    } else {
#line 6098
      tr_umask_d = (char const   *)optarg_copy;
#line 6098
      tr_umask = tr_umask_d;
    }
#line 6100
    if ((unsigned long )tr_umask == (unsigned long )((void *)0)) {
#line 6100
      goto _L___0;
    } else
#line 6100
    if ((int const   )*tr_umask == 0) {
      _L___0: /* CIL Label */ 
#line 6100
      if ((unsigned long )tr_umask_d == (unsigned long )((void *)0)) {
#line 6100
        goto bad_umask;
      } else
#line 6100
      if ((int const   )*tr_umask_d == 0) {
        bad_umask: 
        {
#line 6103
        die((int const   )421, (int const   )3, (char const   */* const  */)"Configuration error: Invalid umask: %s",
            optarg_copy);
        }
      }
    }
#line 6106
    if ((unsigned long )tr_umask != (unsigned long )((void *)0)) {
      {
#line 6107
      tmp___15 = strtoul((char const   */* __restrict  */)tr_umask, (char **/* __restrict  */)((void *)0),
                         8);
#line 6107
      u_mask = (mode_t )tmp___15;
      }
#line 6107
      if (u_mask > 511U) {
#line 6109
        goto bad_umask;
      }
    }
#line 6112
    if ((unsigned long )tr_umask_d != (unsigned long )((void *)0)) {
      {
#line 6113
      tmp___16 = strtoul((char const   */* __restrict  */)tr_umask_d, (char **/* __restrict  */)((void *)0),
                         8);
#line 6113
      u_mask_d = (mode_t )tmp___16;
      }
#line 6113
      if (u_mask_d > 511U) {
#line 6115
        goto bad_umask;
      }
    }
    {
#line 6118
    free((void *)optarg_copy);
    }
#line 6119
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 6146
    tmp___17 = geteuid();
    }
#line 6146
    if (tmp___17 == 0U) {
      {
#line 6149
      puts("pure-ftpd v1.0.36 [privsep]\n");
      }
    }
#line 6153
    options = (struct option  const  *)(long_options);
    {
#line 6155
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 6156
      if (options->has_arg) {
#line 6156
        tmp___18 = "<opt>";
      } else {
#line 6156
        tmp___18 = "";
      }
      {
#line 6156
      printf((char const   */* __restrict  */)"-%c\t--%s\t%s\n", options->val, options->name,
             tmp___18);
#line 6158
      options ++;
      }
#line 6155
      if (! ((unsigned long )options->name != (unsigned long )((void *)0))) {
#line 6155
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 6162
    exit(0);
    }
    switch_default: /* CIL Label */ 
    {
#line 6165
    logfile((int const   )4, "Unknown run-time option");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 6205
  if ((unsigned long )first_authentications == (unsigned long )((void *)0)) {
    {
#line 6206
    tmp___19 = malloc(sizeof(*first_authentications));
#line 6206
    first_authentications = (Authentications *)tmp___19;
    }
#line 6206
    if ((unsigned long )first_authentications == (unsigned long )((void *)0)) {
      {
#line 6208
      die_mem();
      }
    }
#line 6210
    first_authentications->auth = (Authentication const   *)(& auth_list[0]);
#line 6211
    first_authentications->conf_file = (char *)((void *)0);
#line 6212
    first_authentications->next = (struct Authentications_ *)((void *)0);
  }
  {
#line 6215
  dodaemonize();
  }
#line 6218
  if ((int )no_syslog == 0) {
#line 6218
    if (log_pid) {
      {
#line 6219
      closelog();
#line 6220
      openlog("pure-ftpd", 8 | log_pid, syslog_facility);
      }
    } else
#line 6218
    if (syslog_facility != 11 << 3) {
      {
#line 6219
      closelog();
#line 6220
      openlog("pure-ftpd", 8 | log_pid, syslog_facility);
      }
    }
  }
  {
#line 6223
  umask((mode_t )0);
#line 6224
  clearargs(argc, argv);
#line 6225
  idletime_noop = (double )idletime * 2.0;
  }
#line 6226
  if (firstport) {
#line 6229
    portmax = ((lastport - firstport) + 1U) / 2U;
#line 6230
    if (! maxusers) {
#line 6231
      maxusers = portmax;
    } else
#line 6230
    if (maxusers > portmax) {
#line 6231
      maxusers = portmax;
    }
  }
#line 6234
  if (bypass_ipv6 == 0) {
    {
#line 6235
    check_ipv6_support();
    }
  }
  {
#line 6253
  tmp___20 = check_standalone();
  }
#line 6253
  if (tmp___20 != 0) {
    {
#line 6254
    standalone_server();
    }
  } else {
    {
#line 6256
    doit();
    }
  }
#line 6270
  auth_scan = first_authentications;
  {
#line 6273
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 6273
    if (! ((unsigned long )auth_scan != (unsigned long )((void *)0))) {
#line 6273
      goto while_break___3;
    }
#line 6274
    if ((unsigned long )(auth_scan->auth)->exit != (unsigned long )((void *)0)) {
      {
#line 6275
      (*((auth_scan->auth)->exit))();
      }
    }
    {
#line 6277
    free((void *)auth_scan->conf_file);
#line 6278
    previous = auth_scan;
#line 6279
    auth_scan = auth_scan->next;
#line 6280
    free((void *)previous);
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 6283
  last_authentications = (Authentications *)((void *)0);
#line 6283
  first_authentications = last_authentications;
#line 6284
  free((void *)trustedip);
#line 6300
  iptrack_free();
#line 6301
  unlink(pid_file);
#line 6303
  closelog();
#line 6307
  alt_arc4random_close();
#line 6309
  _EXIT((int const   )0);
  }
#line 6311
  return (0);
}
}
#line 14 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/dynamic.c"
static IPTrack *iptrack_list  ;
#line 16 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/dynamic.c"
void iptrack_delete_pid(pid_t const   pid ) 
{ 
  unsigned int c ;

  {
#line 18
  c = 0U;
#line 20
  if ((unsigned long )iptrack_list == (unsigned long )((void *)0)) {
#line 21
    return;
  }
  {
#line 23
  while (1) {
    while_continue: /* CIL Label */ ;
#line 24
    if ((iptrack_list + c)->pid == (pid_t )pid) {
#line 25
      (iptrack_list + c)->pid = 0;
#line 26
      return;
    }
#line 28
    c ++;
#line 23
    if (! (c < maxusers)) {
#line 23
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 30
  return;
}
}
#line 32 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/dynamic.c"
void iptrack_free(void) 
{ 


  {
  {
#line 34
  free((void *)iptrack_list);
#line 35
  iptrack_list = (IPTrack *)((void *)0);
  }
#line 36
  return;
}
}
#line 38 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/dynamic.c"
static unsigned int iptrack_find_ip_or_shift(struct sockaddr_storage  const  * const  ip ) 
{ 
  unsigned int c ;
  struct in6_addr  const  *__a ;
  struct in6_addr *tmp ;
  struct in6_addr  const  *__b ;
  struct in6_addr *tmp___0 ;
  int tmp___1 ;
  struct in_addr *tmp___2 ;
  struct in_addr *tmp___3 ;

  {
#line 41
  c = 0U;
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if ((iptrack_list + c)->pid != 0) {
#line 44
      if ((int )(iptrack_list + c)->ip.ss_family != (int )ip->ss_family) {
#line 46
        if ((int )(iptrack_list + c)->ip.ss_family == 2) {
          {
#line 46
          tmp___2 = storage_sin_addr((struct sockaddr_storage  const  */* const  */)(& (iptrack_list + c)->ip));
#line 46
          tmp___3 = storage_sin_addr((struct sockaddr_storage  const  */* const  */)ip);
          }
#line 46
          if (tmp___2->s_addr == tmp___3->s_addr) {
#line 48
            return (c);
          } else {
#line 46
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 50
        if ((int )(iptrack_list + c)->ip.ss_family == 10) {
          {
#line 50
          tmp = storage_sin_addr6((struct sockaddr_storage  const  */* const  */)(& (iptrack_list + c)->ip));
#line 50
          __a = (struct in6_addr  const  *)tmp;
#line 50
          tmp___0 = storage_sin_addr6((struct sockaddr_storage  const  */* const  */)ip);
#line 50
          __b = (struct in6_addr  const  *)tmp___0;
          }
#line 50
          if (__a->__in6_u.__u6_addr32[0] == __b->__in6_u.__u6_addr32[0]) {
#line 50
            if (__a->__in6_u.__u6_addr32[1] == __b->__in6_u.__u6_addr32[1]) {
#line 50
              if (__a->__in6_u.__u6_addr32[2] == __b->__in6_u.__u6_addr32[2]) {
#line 50
                if (__a->__in6_u.__u6_addr32[3] == __b->__in6_u.__u6_addr32[3]) {
#line 50
                  tmp___1 = 1;
                } else {
#line 50
                  tmp___1 = 0;
                }
              } else {
#line 50
                tmp___1 = 0;
              }
            } else {
#line 50
              tmp___1 = 0;
            }
          } else {
#line 50
            tmp___1 = 0;
          }
#line 50
          if (tmp___1) {
#line 53
            return (c);
          }
        }
      }
    }
#line 56
    c ++;
#line 43
    if (! (c < maxusers)) {
#line 43
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 58
  c --;
#line 59
  if (c != 0U) {
    {
#line 60
    memmove((void *)(iptrack_list + 0), (void const   *)(iptrack_list + 1), sizeof(*(iptrack_list + 0)) * (unsigned long )c);
    }
  }
#line 63
  return (c);
}
}
#line 66 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/dynamic.c"
unsigned int iptrack_get(struct sockaddr_storage  const  * const  ip ) 
{ 
  unsigned int c ;
  unsigned int nb ;
  struct in6_addr  const  *__a ;
  struct in6_addr *tmp ;
  struct in6_addr  const  *__b ;
  struct in6_addr *tmp___0 ;
  int tmp___1 ;
  struct in_addr *tmp___2 ;
  struct in_addr *tmp___3 ;

  {
#line 68
  c = 0U;
#line 69
  nb = 0U;
#line 71
  if ((unsigned long )iptrack_list == (unsigned long )((void *)0)) {
#line 72
    return (0U);
  }
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if ((iptrack_list + c)->pid != 0) {
#line 75
      if ((int )(iptrack_list + c)->ip.ss_family == (int )ip->ss_family) {
#line 77
        if ((int )(iptrack_list + c)->ip.ss_family == 2) {
          {
#line 77
          tmp___2 = storage_sin_addr((struct sockaddr_storage  const  */* const  */)(& (iptrack_list + c)->ip));
#line 77
          tmp___3 = storage_sin_addr((struct sockaddr_storage  const  */* const  */)ip);
          }
#line 77
          if (tmp___2->s_addr == tmp___3->s_addr) {
#line 79
            nb ++;
          } else {
#line 77
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 81
        if ((int )(iptrack_list + c)->ip.ss_family == 10) {
          {
#line 81
          tmp = storage_sin_addr6((struct sockaddr_storage  const  */* const  */)(& (iptrack_list + c)->ip));
#line 81
          __a = (struct in6_addr  const  *)tmp;
#line 81
          tmp___0 = storage_sin_addr6((struct sockaddr_storage  const  */* const  */)ip);
#line 81
          __b = (struct in6_addr  const  *)tmp___0;
          }
#line 81
          if (__a->__in6_u.__u6_addr32[0] == __b->__in6_u.__u6_addr32[0]) {
#line 81
            if (__a->__in6_u.__u6_addr32[1] == __b->__in6_u.__u6_addr32[1]) {
#line 81
              if (__a->__in6_u.__u6_addr32[2] == __b->__in6_u.__u6_addr32[2]) {
#line 81
                if (__a->__in6_u.__u6_addr32[3] == __b->__in6_u.__u6_addr32[3]) {
#line 81
                  tmp___1 = 1;
                } else {
#line 81
                  tmp___1 = 0;
                }
              } else {
#line 81
                tmp___1 = 0;
              }
            } else {
#line 81
              tmp___1 = 0;
            }
          } else {
#line 81
            tmp___1 = 0;
          }
#line 81
          if (tmp___1) {
#line 84
            nb ++;
          }
        }
      }
    }
#line 87
    c ++;
#line 74
    if (! (c < maxusers)) {
#line 74
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  return (nb);
}
}
#line 93 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/dynamic.c"
void iptrack_add(struct sockaddr_storage  const  * const  ip , pid_t const   pid ) 
{ 
  unsigned int c ;
  unsigned int ci ;
  void *tmp ;

  {
#line 96
  c = 0U;
#line 98
  if ((unsigned long )iptrack_list == (unsigned long )((void *)0)) {
    {
#line 99
    ci = 0U;
#line 101
    tmp = malloc((unsigned long )maxusers * sizeof(*iptrack_list));
#line 101
    iptrack_list = (IPTrack *)tmp;
    }
#line 101
    if ((unsigned long )iptrack_list == (unsigned long )((void *)0)) {
#line 102
      return;
    }
    {
#line 104
    while (1) {
      while_continue: /* CIL Label */ ;
#line 105
      (iptrack_list + ci)->pid = 0;
#line 106
      ci ++;
#line 104
      if (! (ci < maxusers)) {
#line 104
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 109
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 110
    if ((iptrack_list + c)->pid == 0) {
      force: 
#line 112
      (iptrack_list + c)->pid = (pid_t )pid;
#line 113
      (iptrack_list + c)->ip = (struct sockaddr_storage )*ip;
#line 114
      return;
    }
#line 116
    c ++;
#line 109
    if (! (c < maxusers)) {
#line 109
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 118
  c = iptrack_find_ip_or_shift(ip);
  }
#line 119
  goto force;
}
}
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 580
extern int putchar(int __c ) ;
#line 10 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-statsdecode.c"
static void usage(void) 
{ 


  {
  {
#line 12
  puts("Usage: pure-statsdecode [stats log file] [-]");
  }
#line 13
  return;
}
}
#line 306 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 1120 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) crypt)(char const   *__key ,
                                                                                                char const   *__salt ) ;
#line 105 "/usr/include/grp.h"
extern struct group *getgrgid(__gid_t __gid ) ;
#line 88 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-pw.h"
char *newpasswd_filename(char const   * const  file ) ;
#line 66 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 30 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-pw.c"
static void disable_echo(void) 
{ 
  int tmp ;
  struct termios p ;
  int tmp___0 ;

  {
  {
#line 32
  tmp = isatty(0);
  }
#line 32
  if (! tmp) {
#line 33
    return;
  }
  {
#line 40
  tmp___0 = tcgetattr(0, & p);
  }
#line 40
  if (tmp___0 != 0) {
#line 41
    return;
  }
  {
#line 43
  p.c_lflag &= 4294967287U;
#line 47
  tcsetattr(0, 2, (struct termios  const  *)(& p));
  }
#line 71
  return;
}
}
#line 73 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-pw.c"
static void enable_echo(void) 
{ 
  int tmp ;
  struct termios p ;
  int tmp___0 ;

  {
  {
#line 75
  tmp = isatty(0);
  }
#line 75
  if (! tmp) {
#line 76
    return;
  }
  {
#line 83
  tmp___0 = tcgetattr(0, & p);
  }
#line 83
  if (tmp___0 != 0) {
#line 84
    return;
  }
  {
#line 86
  p.c_lflag |= 8U;
#line 90
  tcsetattr(0, 2, (struct termios  const  *)(& p));
  }
#line 114
  return;
}
}
#line 125 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-pw.c"
static char *s  ;
#line 126 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-pw.c"
static char save  ;
#line 123 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-pw.c"
static char *my_strtok2(char *str , char const   delim ) 
{ 


  {
#line 128
  if ((unsigned long )str != (unsigned long )((void *)0)) {
#line 129
    if ((int )*str == 0) {
#line 130
      return ((char *)((void *)0));
    }
#line 132
    s = str;
    scan: 
    {
#line 134
    while (1) {
      while_continue: /* CIL Label */ ;
#line 134
      if ((int )*s != 0) {
#line 134
        if (! ((int )*s != (int )delim)) {
#line 134
          goto while_break;
        }
      } else {
#line 134
        goto while_break;
      }
#line 135
      s ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 137
    save = *s;
#line 138
    *s = (char)0;
#line 140
    return (str);
  }
#line 142
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 143
    return ((char *)((void *)0));
  } else
#line 142
  if ((int )save == 0) {
#line 143
    return ((char *)((void *)0));
  }
#line 145
  s ++;
#line 146
  str = s;
#line 148
  goto scan;
}
}
#line 151 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-pw.c"
static void filter_pw_line_sep(char *str ) 
{ 


  {
#line 153
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 154
    return;
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! ((int )*str != 0)) {
#line 156
      goto while_break;
    }
#line 157
    if ((int )*str == (int )*":") {
#line 158
      *str = (char )'_';
    }
#line 160
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  return;
}
}
#line 164 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-pw.c"
static void help___0(void) 
{ 


  {
  {
#line 166
  puts("\nUsage :\n\npure-pw useradd <login> [-f <passwd file>] -u <uid> [-g <gid>]\n                -D/-d <home directory> [-c <gecos>]\n                [-t <download bandwidth>] [-T <upload bandwidth>]\n                [-n <max number of files>] [-N <max Mbytes>]\n                [-q <upload ratio>] [-Q <download ratio>]\n                [-r <allow client ip>/<mask>] [-R <deny client ip>/<mask>]\n                [-i <allow local ip>/<mask>] [-I <deny local ip>/<mask>]\n                [-y <max number of concurrent sessions>]\n                [-z <hhmm>-<hhmm>] [-m]\n\npure-pw usermod <login> -f <passwd file> -u <uid> [-g <gid>]\n                -D/-d <home directory> -[c <gecos>]\n                [-t <download bandwidth>] [-T <upload bandwidth>]\n                [-n <max number of files>] [-N <max Mbytes>]\n                [-q <upload ratio>] [-Q <download ratio>]\n                [-r <allow client ip>/<mask>] [-R <deny client ip>/<mask>]\n                [-i <allow local ip>/<mask>] [-I <deny local ip>/<mask>]\n                [-y <max number of concurrent sessions>]\n                [-z <hhmm>-<hhmm>] [-m]\n\npure-pw userdel <login> [-f <passwd file>] [-m]\n\npure-pw passwd  <login> [-f <passwd file>] [-m]\n\npure-pw show    <login> [-f <passwd file>]\n\npure-pw mkdb    [<puredb database file> [-f <passwd file>]]\n                [-F <puredb file>]\n\npure-pw list    [-f <passwd file>]\n\n-d <home directory> : chroot user (recommended)\n-D <home directory> : don\'t chroot user\n-<option> \'\' : set this option to unlimited\n-m : also update the /etc/pureftpd.pdb database\nFor a 1:10 ratio, use -q 1 -Q 10\nTo allow access only between 9 am and 6 pm, use -z 0900-1800\n\n");
#line 206
  puts("*WARNING* : that pure-ftpd server hasn\'t been compiled with puredb support\n");
#line 208
  exit(0);
  }
}
}
#line 211 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-pw.c"
static void no_mem(void) 
{ 
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 213
  tmp = __errno_location();
#line 213
  tmp___0 = strerror(*tmp);
#line 213
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory : [%s]\n",
          tmp___0);
#line 214
  exit(1);
  }
}
}
#line 217 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-pw.c"
static unsigned int pw_zrand(void) 
{ 
  unsigned int tmp ;

  {
  {
#line 219
  tmp = alt_arc4random();
  }
#line 219
  return (tmp);
}
}
#line 224
static char *best_crypt(char const   * const  pwd___0 ) ;
#line 224 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-pw.c"
static char const   crcars[64]  = 
#line 224
  {      (char const   )'a',      (char const   )'b',      (char const   )'c',      (char const   )'d', 
        (char const   )'e',      (char const   )'f',      (char const   )'g',      (char const   )'h', 
        (char const   )'i',      (char const   )'j',      (char const   )'k',      (char const   )'l', 
        (char const   )'m',      (char const   )'n',      (char const   )'o',      (char const   )'p', 
        (char const   )'q',      (char const   )'r',      (char const   )'s',      (char const   )'t', 
        (char const   )'u',      (char const   )'v',      (char const   )'w',      (char const   )'x', 
        (char const   )'y',      (char const   )'z',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F', 
        (char const   )'G',      (char const   )'H',      (char const   )'I',      (char const   )'J', 
        (char const   )'K',      (char const   )'L',      (char const   )'M',      (char const   )'N', 
        (char const   )'O',      (char const   )'P',      (char const   )'Q',      (char const   )'R', 
        (char const   )'S',      (char const   )'T',      (char const   )'U',      (char const   )'V', 
        (char const   )'W',      (char const   )'X',      (char const   )'Y',      (char const   )'Z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'.',      (char const   )'/'};
#line 222 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-pw.c"
static char *best_crypt(char const   * const  pwd___0 ) 
{ 
  char const   *crypted ;
  char salt[30] ;
  int c ;
  unsigned int tmp ;
  char *tmp___0 ;
  char salt___0[12] ;
  int c___0 ;
  unsigned int tmp___1 ;
  char *tmp___2 ;
  char salt___1[10] ;
  int c___1 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char salt___2[3] ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 228
  tmp___9 = crypt("test", "$2a$07$1234567890123456789012");
#line 228
  crypted = (char const   *)tmp___9;
  }
#line 228
  if ((unsigned long )crypted != (unsigned long )((void *)0)) {
    {
#line 228
    tmp___10 = strcmp(crypted, "$2a$07$123456789012345678901uKO4/IReKqBzRzT6YaajGvw20UBdHW7m");
    }
#line 228
    if (tmp___10 == 0) {
#line 232
      salt[0] = (char )'$';
#line 232
      salt[1] = (char )'2';
#line 232
      salt[2] = (char )'a';
#line 232
      salt[3] = (char )'$';
#line 232
      salt[4] = (char )'0';
#line 232
      salt[5] = (char )'7';
#line 232
      salt[6] = (char )'$';
#line 232
      salt[7] = (char )'0';
#line 232
      salt[8] = (char )'0';
#line 232
      salt[9] = (char )'0';
#line 232
      salt[10] = (char )'0';
#line 232
      salt[11] = (char )'0';
#line 232
      salt[12] = (char )'0';
#line 232
      salt[13] = (char )'0';
#line 232
      salt[14] = (char )'0';
#line 232
      salt[15] = (char )'0';
#line 232
      salt[16] = (char )'0';
#line 232
      salt[17] = (char )'0';
#line 232
      salt[18] = (char )'0';
#line 232
      salt[19] = (char )'0';
#line 232
      salt[20] = (char )'0';
#line 232
      salt[21] = (char )'0';
#line 232
      salt[22] = (char )'0';
#line 232
      salt[23] = (char )'0';
#line 232
      salt[24] = (char )'0';
#line 232
      salt[25] = (char )'0';
#line 232
      salt[26] = (char )'0';
#line 232
      salt[27] = (char )'0';
#line 232
      salt[28] = (char )'0';
#line 232
      salt[29] = (char )'\000';
#line 233
      c = 28;
      {
#line 235
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 236
        c --;
#line 237
        tmp = pw_zrand();
#line 237
        salt[c] = (char )crcars[tmp & 63U];
        }
#line 235
        if (! (c > 7)) {
#line 235
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 240
      tmp___0 = crypt((char const   *)pwd___0, (char const   *)(salt));
      }
#line 240
      return (tmp___0);
    } else {
#line 228
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 241
    tmp___7 = crypt("test", "$1$12345678$");
#line 241
    crypted = (char const   *)tmp___7;
    }
#line 241
    if ((unsigned long )crypted != (unsigned long )((void *)0)) {
      {
#line 241
      tmp___8 = strcmp(crypted, "$1$12345678$oEitTZYQtRHfNGmsFvTBA/");
      }
#line 241
      if (tmp___8 == 0) {
#line 244
        salt___0[0] = (char )'$';
#line 244
        salt___0[1] = (char )'1';
#line 244
        salt___0[2] = (char )'$';
#line 244
        salt___0[3] = (char )'0';
#line 244
        salt___0[4] = (char )'0';
#line 244
        salt___0[5] = (char )'0';
#line 244
        salt___0[6] = (char )'0';
#line 244
        salt___0[7] = (char )'0';
#line 244
        salt___0[8] = (char )'0';
#line 244
        salt___0[9] = (char )'0';
#line 244
        salt___0[10] = (char )'0';
#line 244
        salt___0[11] = (char )'\000';
#line 245
        c___0 = 10;
        {
#line 247
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 248
          c___0 --;
#line 249
          tmp___1 = pw_zrand();
#line 249
          salt___0[c___0] = (char )crcars[tmp___1 & 63U];
          }
#line 247
          if (! (c___0 > 3)) {
#line 247
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 252
        tmp___2 = crypt((char const   *)pwd___0, (char const   *)(salt___0));
        }
#line 252
        return (tmp___2);
      } else {
#line 241
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 253
      tmp___5 = crypt("test", "_.../1234");
#line 253
      crypted = (char const   *)tmp___5;
      }
#line 253
      if ((unsigned long )crypted != (unsigned long )((void *)0)) {
        {
#line 253
        tmp___6 = strcmp(crypted, "_.../1234PAPUVmqGzpU");
        }
#line 253
        if (tmp___6 == 0) {
#line 256
          salt___1[0] = (char )'_';
#line 256
          salt___1[1] = (char )'.';
#line 256
          salt___1[2] = (char )'.';
#line 256
          salt___1[3] = (char )'.';
#line 256
          salt___1[4] = (char )'/';
#line 256
          salt___1[5] = (char )'0';
#line 256
          salt___1[6] = (char )'0';
#line 256
          salt___1[7] = (char )'0';
#line 256
          salt___1[8] = (char )'0';
#line 256
          salt___1[9] = (char )'\000';
#line 257
          c___1 = 8;
          {
#line 259
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 260
            c___1 --;
#line 261
            tmp___3 = pw_zrand();
#line 261
            salt___1[c___1] = (char )crcars[tmp___3 & 63U];
            }
#line 259
            if (! (c___1 > 5)) {
#line 259
              goto while_break___1;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 264
          tmp___4 = crypt((char const   *)pwd___0, (char const   *)(salt___1));
          }
#line 264
          return (tmp___4);
        }
      }
    }
  }
  {
#line 268
  salt___2[0] = (char )'0';
#line 268
  salt___2[1] = (char )'0';
#line 268
  salt___2[2] = (char )'\000';
#line 270
  tmp___11 = pw_zrand();
#line 270
  salt___2[0] = (char )crcars[tmp___11 & 63U];
#line 271
  tmp___12 = pw_zrand();
#line 271
  salt___2[1] = (char )crcars[tmp___12 & 63U];
#line 273
  tmp___13 = crypt((char const   *)pwd___0, (char const   *)(salt___2));
  }
#line 273
  return (tmp___13);
}
}
#line 277 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-pw.c"
char *newpasswd_filename(char const   * const  file ) 
{ 
  size_t sizeof_file2 ;
  char *file2 ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 282
  tmp = strlen((char const   *)file);
#line 282
  sizeof_file2 = tmp + sizeof(".tmp");
#line 283
  tmp___0 = malloc(sizeof_file2);
#line 283
  file2 = (char *)tmp___0;
  }
#line 283
  if ((unsigned long )file2 == (unsigned long )((void *)0)) {
#line 284
    return ((char *)((void *)0));
  }
  {
#line 286
  snprintf((char */* __restrict  */)file2, sizeof_file2, (char const   */* __restrict  */)"%s%s",
           file, ".tmp");
  }
#line 288
  return (file2);
}
}
#line 291 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-pw.c"
static void strip_lf(char *str ) 
{ 
  char *f ;

  {
#line 295
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 296
    return;
  }
  {
#line 298
  f = strchr((char const   *)str, '\r');
  }
#line 298
  if ((unsigned long )f != (unsigned long )((void *)0)) {
#line 299
    *f = (char)0;
  }
  {
#line 301
  f = strchr((char const   *)str, '\n');
  }
#line 301
  if ((unsigned long )f != (unsigned long )((void *)0)) {
#line 302
    *f = (char)0;
  }
#line 304
  return;
}
}
#line 306 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-pw.c"
static int parse_pw_line(char *line___1 , PWInfo * const  pwinfo ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  int tmp___7 ;

  {
  {
#line 308
  pwinfo->login = (char *)((void *)0);
#line 309
  pwinfo->pwd = (char *)((void *)0);
#line 310
  pwinfo->gecos = (char *)((void *)0);
#line 311
  pwinfo->home = (char *)((void *)0);
#line 312
  tmp = (char *)((void *)0);
#line 312
  pwinfo->deny_local_ip = tmp;
#line 312
  pwinfo->allow_local_ip = tmp;
#line 313
  tmp___0 = (char *)((void *)0);
#line 313
  pwinfo->deny_client_ip = tmp___0;
#line 313
  pwinfo->allow_client_ip = tmp___0;
#line 314
  pwinfo->has_bw_dl = 0;
#line 315
  pwinfo->has_bw_ul = 0;
#line 316
  pwinfo->has_quota_files = 0;
#line 317
  pwinfo->has_quota_size = 0;
#line 318
  pwinfo->has_ul_ratio = 0;
#line 319
  pwinfo->has_dl_ratio = 0;
#line 320
  pwinfo->has_time = 0;
#line 321
  tmp___1 = 0U;
#line 321
  pwinfo->time_end = tmp___1;
#line 321
  pwinfo->time_begin = tmp___1;
#line 322
  pwinfo->uid = (uid_t )0;
#line 323
  pwinfo->gid = (gid_t )0;
#line 324
  pwinfo->has_per_user_max = 0;
#line 325
  pwinfo->per_user_max = 0U;
#line 327
  line___1 = my_strtok2(line___1, *":");
  }
#line 327
  if ((unsigned long )line___1 == (unsigned long )((void *)0)) {
#line 328
    return (-1);
  } else
#line 327
  if ((int )*line___1 == 0) {
#line 328
    return (-1);
  }
  {
#line 330
  pwinfo->login = line___1;
#line 331
  line___1 = my_strtok2((char *)((void *)0), *":");
  }
#line 331
  if ((unsigned long )line___1 == (unsigned long )((void *)0)) {
#line 332
    return (-1);
  } else
#line 331
  if ((int )*line___1 == 0) {
#line 332
    return (-1);
  }
  {
#line 334
  pwinfo->pwd = line___1;
#line 335
  line___1 = my_strtok2((char *)((void *)0), *":");
  }
#line 335
  if ((unsigned long )line___1 == (unsigned long )((void *)0)) {
#line 336
    return (-1);
  } else
#line 335
  if ((int )*line___1 == 0) {
#line 336
    return (-1);
  }
  {
#line 338
  tmp___2 = strtoul((char const   */* __restrict  */)line___1, (char **/* __restrict  */)((void *)0),
                    10);
#line 338
  pwinfo->uid = (uid_t )tmp___2;
#line 339
  line___1 = my_strtok2((char *)((void *)0), *":");
  }
#line 339
  if ((unsigned long )line___1 == (unsigned long )((void *)0)) {
#line 340
    return (-1);
  } else
#line 339
  if ((int )*line___1 == 0) {
#line 340
    return (-1);
  }
  {
#line 342
  tmp___3 = strtoul((char const   */* __restrict  */)line___1, (char **/* __restrict  */)((void *)0),
                    10);
#line 342
  pwinfo->gid = (gid_t )tmp___3;
  }
#line 343
  if (pwinfo->uid <= 0U) {
#line 344
    return (-1);
  } else
#line 343
  if (pwinfo->gid <= 0U) {
#line 344
    return (-1);
  }
  {
#line 346
  line___1 = my_strtok2((char *)((void *)0), *":");
  }
#line 346
  if ((unsigned long )line___1 == (unsigned long )((void *)0)) {
#line 347
    return (-1);
  }
  {
#line 349
  pwinfo->gecos = line___1;
#line 350
  line___1 = my_strtok2((char *)((void *)0), *":");
  }
#line 350
  if ((unsigned long )line___1 == (unsigned long )((void *)0)) {
#line 351
    return (-1);
  } else
#line 350
  if ((int )*line___1 == 0) {
#line 351
    return (-1);
  }
#line 353
  if ((int )*line___1 != 47) {
#line 354
    return (-1);
  }
  {
#line 356
  pwinfo->home = line___1;
#line 357
  line___1 = my_strtok2((char *)((void *)0), *":");
  }
#line 357
  if ((unsigned long )line___1 == (unsigned long )((void *)0)) {
#line 358
    return (0);
  }
#line 360
  if ((int )*line___1 != 0) {
    {
#line 361
    pwinfo->has_bw_ul = 1;
#line 362
    pwinfo->bw_ul = strtoul((char const   */* __restrict  */)line___1, (char **/* __restrict  */)((void *)0),
                            10);
    }
  }
  {
#line 364
  line___1 = my_strtok2((char *)((void *)0), *":");
  }
#line 364
  if ((unsigned long )line___1 == (unsigned long )((void *)0)) {
#line 365
    return (0);
  }
#line 367
  if ((int )*line___1 != 0) {
    {
#line 368
    pwinfo->has_bw_dl = 1;
#line 369
    pwinfo->bw_dl = strtoul((char const   */* __restrict  */)line___1, (char **/* __restrict  */)((void *)0),
                            10);
    }
  }
  {
#line 371
  line___1 = my_strtok2((char *)((void *)0), *":");
  }
#line 371
  if ((unsigned long )line___1 == (unsigned long )((void *)0)) {
#line 372
    return (0);
  }
#line 374
  if ((int )*line___1 != 0) {
    {
#line 375
    tmp___4 = strtoul((char const   */* __restrict  */)line___1, (char **/* __restrict  */)((void *)0),
                      10);
#line 375
    pwinfo->ul_ratio = (unsigned int )tmp___4;
    }
#line 376
    if (pwinfo->ul_ratio > 0U) {
#line 377
      pwinfo->has_ul_ratio = 1;
    }
  }
  {
#line 380
  line___1 = my_strtok2((char *)((void *)0), *":");
  }
#line 380
  if ((unsigned long )line___1 == (unsigned long )((void *)0)) {
#line 381
    return (0);
  }
#line 383
  if ((int )*line___1 != 0) {
    {
#line 384
    tmp___5 = strtoul((char const   */* __restrict  */)line___1, (char **/* __restrict  */)((void *)0),
                      10);
#line 384
    pwinfo->dl_ratio = (unsigned int )tmp___5;
    }
#line 385
    if (pwinfo->dl_ratio > 0U) {
#line 386
      pwinfo->has_dl_ratio = 1;
    }
  }
  {
#line 389
  line___1 = my_strtok2((char *)((void *)0), *":");
  }
#line 389
  if ((unsigned long )line___1 == (unsigned long )((void *)0)) {
#line 390
    return (0);
  }
#line 392
  if ((int )*line___1 != 0) {
    {
#line 393
    tmp___6 = strtoul((char const   */* __restrict  */)line___1, (char **/* __restrict  */)((void *)0),
                      10);
#line 393
    pwinfo->per_user_max = (unsigned int )tmp___6;
    }
#line 394
    if (pwinfo->per_user_max > 0U) {
#line 395
      pwinfo->has_per_user_max = 1;
    }
  }
  {
#line 398
  line___1 = my_strtok2((char *)((void *)0), *":");
  }
#line 398
  if ((unsigned long )line___1 == (unsigned long )((void *)0)) {
#line 399
    return (0);
  }
#line 401
  if ((int )*line___1 != 0) {
    {
#line 402
    pwinfo->has_quota_files = 1;
#line 403
    pwinfo->quota_files = strtoull((char const   */* __restrict  */)line___1, (char **/* __restrict  */)((void *)0),
                                   10);
    }
  }
  {
#line 405
  line___1 = my_strtok2((char *)((void *)0), *":");
  }
#line 405
  if ((unsigned long )line___1 == (unsigned long )((void *)0)) {
#line 406
    return (0);
  }
#line 408
  if ((int )*line___1 != 0) {
    {
#line 409
    pwinfo->has_quota_size = 1;
#line 410
    pwinfo->quota_size = strtoull((char const   */* __restrict  */)line___1, (char **/* __restrict  */)((void *)0),
                                  10);
    }
  }
  {
#line 412
  line___1 = my_strtok2((char *)((void *)0), *":");
  }
#line 412
  if ((unsigned long )line___1 == (unsigned long )((void *)0)) {
#line 413
    return (0);
  }
  {
#line 415
  pwinfo->allow_local_ip = line___1;
#line 416
  line___1 = my_strtok2((char *)((void *)0), *":");
  }
#line 416
  if ((unsigned long )line___1 == (unsigned long )((void *)0)) {
#line 417
    return (0);
  }
  {
#line 419
  pwinfo->deny_local_ip = line___1;
#line 420
  line___1 = my_strtok2((char *)((void *)0), *":");
  }
#line 420
  if ((unsigned long )line___1 == (unsigned long )((void *)0)) {
#line 421
    return (0);
  }
  {
#line 423
  pwinfo->allow_client_ip = line___1;
#line 424
  line___1 = my_strtok2((char *)((void *)0), *":");
  }
#line 424
  if ((unsigned long )line___1 == (unsigned long )((void *)0)) {
#line 425
    return (0);
  }
  {
#line 427
  pwinfo->deny_client_ip = line___1;
#line 428
  line___1 = my_strtok2((char *)((void *)0), *":");
  }
#line 428
  if ((unsigned long )line___1 == (unsigned long )((void *)0)) {
#line 429
    return (0);
  }
  {
#line 431
  tmp___7 = sscanf((char const   */* __restrict  */)line___1, (char const   */* __restrict  */)"%u-%u",
                   & pwinfo->time_begin, & pwinfo->time_end);
  }
#line 431
  if (tmp___7 == 2) {
#line 431
    if (pwinfo->time_begin < 2360U) {
#line 431
      if (pwinfo->time_begin % 100U < 60U) {
#line 431
        if (pwinfo->time_end < 2360U) {
#line 431
          if (pwinfo->time_end % 100U < 60U) {
#line 434
            pwinfo->has_time = 1;
          }
        }
      }
    }
  }
#line 437
  return (0);
}
}
#line 440 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-pw.c"
static int fetch_pw_account(char const   * const  file , PWInfo * const  pwinfo ,
                            char * const  line___1 , size_t const   sizeof_line ,
                            char const   * const  login ) 
{ 
  FILE *fp ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 445
  ret = -1;
#line 447
  if ((unsigned long )file == (unsigned long )((void *)0)) {
    {
#line 450
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad arguments to fetch account\n");
    }
#line 451
    return (-1);
  } else
#line 447
  if ((unsigned long )pwinfo == (unsigned long )((void *)0)) {
    {
#line 450
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad arguments to fetch account\n");
    }
#line 451
    return (-1);
  } else
#line 447
  if ((unsigned long )line___1 == (unsigned long )((void *)0)) {
    {
#line 450
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad arguments to fetch account\n");
    }
#line 451
    return (-1);
  } else
#line 447
  if (sizeof_line < 2UL) {
    {
#line 450
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad arguments to fetch account\n");
    }
#line 451
    return (-1);
  } else
#line 447
  if ((unsigned long )login == (unsigned long )((void *)0)) {
    {
#line 450
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad arguments to fetch account\n");
    }
#line 451
    return (-1);
  } else
#line 447
  if ((int const   )*login == 0) {
    {
#line 450
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad arguments to fetch account\n");
    }
#line 451
    return (-1);
  }
  {
#line 453
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
  }
#line 453
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 454
    perror("Unable to open the passwd file");
    }
#line 455
    return (-1);
  }
  {
#line 457
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 457
    tmp___1 = fgets((char */* __restrict  */)line___1, (int )((unsigned int )((int )sizeof_line) - 1U),
                    (FILE */* __restrict  */)fp);
    }
#line 457
    if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
#line 457
      goto while_break;
    }
    {
#line 458
    strip_lf((char *)line___1);
    }
#line 459
    if ((int )*line___1 == 0) {
#line 460
      goto while_continue;
    } else
#line 459
    if ((int )*line___1 == 35) {
#line 460
      goto while_continue;
    }
    {
#line 462
    tmp = parse_pw_line((char *)line___1, pwinfo);
    }
#line 462
    if (tmp != 0) {
      {
#line 463
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: invalid line [%s]\n",
              line___1);
      }
#line 464
      goto while_continue;
    }
    {
#line 466
    tmp___0 = strcmp((char const   *)login, (char const   *)pwinfo->login);
    }
#line 466
    if (tmp___0 != 0) {
#line 467
      goto while_continue;
    }
#line 469
    ret = 0;
#line 470
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 472
  fclose(fp);
  }
#line 474
  return (ret);
}
}
#line 477 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-pw.c"
static FILE *create_newpasswd(char const   * const  file , char const   * const  file2 ,
                              char const   * const  skip_login , int error_if_user_exists ,
                              int error_if_not_found ) 
{ 
  FILE *fp ;
  FILE *fp2 ;
  int fd2 ;
  int found ;
  size_t skip_login_len ;
  char line___1[2048] ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 486
  found = 0;
#line 490
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
#line 491
  fd2 = open((char const   *)file2, 131265, (mode_t )448);
  }
#line 491
  if (fd2 == -1) {
#line 493
    if ((unsigned long )fp != (unsigned long )((void *)0)) {
      {
#line 494
      fclose(fp);
      }
    }
#line 496
    return ((FILE *)((void *)0));
  }
  {
#line 498
  fp2 = fdopen(fd2, "w");
  }
#line 498
  if ((unsigned long )fp2 == (unsigned long )((void *)0)) {
#line 499
    if ((unsigned long )fp != (unsigned long )((void *)0)) {
      {
#line 500
      fclose(fp);
      }
    }
    {
#line 502
    close(fd2);
    }
#line 504
    return ((FILE *)((void *)0));
  }
#line 506
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 507
    if ((unsigned long )skip_login != (unsigned long )((void *)0)) {
      {
#line 508
      skip_login_len = strlen((char const   *)skip_login);
      }
    } else {
#line 510
      skip_login_len = (size_t )0U;
    }
    {
#line 512
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 512
      tmp___1 = fgets((char */* __restrict  */)(line___1), (int )((unsigned int )((int )sizeof(line___1)) - 1U),
                      (FILE */* __restrict  */)fp);
      }
#line 512
      if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
#line 512
        goto while_break;
      }
#line 513
      if (skip_login_len > 0UL) {
        {
#line 514
        tmp = strncmp((char const   *)(line___1), (char const   *)skip_login, skip_login_len);
        }
#line 514
        if (tmp == 0) {
#line 514
          if ((int )line___1[skip_login_len] == (int )*":") {
#line 516
            if (error_if_user_exists != 0) {
#line 517
              goto err;
            }
#line 519
            found = 1;
#line 520
            goto while_continue;
          }
        }
      }
      {
#line 523
      tmp___0 = fputs((char const   */* __restrict  */)(line___1), (FILE */* __restrict  */)fp2);
      }
#line 523
      if (tmp___0 < 0) {
        err: 
        {
#line 525
        fclose(fp2);
#line 526
        unlink((char const   *)file2);
        }
#line 527
        if ((unsigned long )fp != (unsigned long )((void *)0)) {
          {
#line 528
          fclose(fp);
          }
        }
#line 530
        return ((FILE *)((void *)0));
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 533
    fflush(fp2);
#line 534
    fsync(fd2);
    }
  }
#line 536
  if (error_if_not_found != 0) {
#line 536
    if (found == 0) {
#line 537
      goto err;
    }
  }
#line 539
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 540
    fclose(fp);
    }
  }
#line 543
  return (fp2);
}
}
#line 546 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-pw.c"
static int add_new_pw_line(FILE * const  fp2 , PWInfo const   * const  pwinfo ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
#line 548
  if ((unsigned long )fp2 == (unsigned long )((void *)0)) {
#line 549
    return (-1);
  }
  {
#line 551
  tmp = fprintf((FILE */* __restrict  */)fp2, (char const   */* __restrict  */)"%s:%s:%lu:%lu:%s:%s:",
                pwinfo->login, pwinfo->pwd, (unsigned long )pwinfo->uid, (unsigned long )pwinfo->gid,
                pwinfo->gecos, pwinfo->home);
  }
#line 551
  if (tmp < 0) {
#line 561
    return (-1);
  }
#line 563
  if (pwinfo->has_bw_ul != 0) {
    {
#line 564
    tmp___0 = fprintf((FILE */* __restrict  */)fp2, (char const   */* __restrict  */)"%lu",
                      (unsigned long )pwinfo->bw_ul);
    }
#line 564
    if (tmp___0 < 0) {
#line 566
      return (-1);
    }
  }
  {
#line 569
  tmp___1 = fprintf((FILE */* __restrict  */)fp2, (char const   */* __restrict  */)":");
  }
#line 569
  if (tmp___1 < 0) {
#line 570
    return (-1);
  }
#line 572
  if (pwinfo->has_bw_dl != 0) {
    {
#line 573
    tmp___2 = fprintf((FILE */* __restrict  */)fp2, (char const   */* __restrict  */)"%lu",
                      (unsigned long )pwinfo->bw_dl);
    }
#line 573
    if (tmp___2 < 0) {
#line 575
      return (-1);
    }
  }
  {
#line 578
  tmp___3 = fprintf((FILE */* __restrict  */)fp2, (char const   */* __restrict  */)":");
  }
#line 578
  if (tmp___3 < 0) {
#line 579
    return (-1);
  }
#line 581
  if (pwinfo->has_ul_ratio != 0) {
    {
#line 582
    tmp___4 = fprintf((FILE */* __restrict  */)fp2, (char const   */* __restrict  */)"%u",
                      pwinfo->ul_ratio);
    }
#line 582
    if (tmp___4 < 0) {
#line 584
      return (-1);
    }
  }
  {
#line 587
  tmp___5 = fprintf((FILE */* __restrict  */)fp2, (char const   */* __restrict  */)":");
  }
#line 587
  if (tmp___5 < 0) {
#line 588
    return (-1);
  }
#line 590
  if (pwinfo->has_dl_ratio != 0) {
    {
#line 591
    tmp___6 = fprintf((FILE */* __restrict  */)fp2, (char const   */* __restrict  */)"%u",
                      pwinfo->dl_ratio);
    }
#line 591
    if (tmp___6 < 0) {
#line 593
      return (-1);
    }
  }
  {
#line 596
  tmp___7 = fprintf((FILE */* __restrict  */)fp2, (char const   */* __restrict  */)":");
  }
#line 596
  if (tmp___7 < 0) {
#line 597
    return (-1);
  }
#line 599
  if (pwinfo->has_per_user_max != 0) {
    {
#line 600
    tmp___8 = fprintf((FILE */* __restrict  */)fp2, (char const   */* __restrict  */)"%u",
                      pwinfo->per_user_max);
    }
#line 600
    if (tmp___8 < 0) {
#line 601
      return (-1);
    }
  }
  {
#line 604
  tmp___9 = fprintf((FILE */* __restrict  */)fp2, (char const   */* __restrict  */)":");
  }
#line 604
  if (tmp___9 < 0) {
#line 605
    return (-1);
  }
#line 607
  if (pwinfo->has_quota_files != 0) {
    {
#line 608
    tmp___10 = fprintf((FILE */* __restrict  */)fp2, (char const   */* __restrict  */)"%llu",
                       pwinfo->quota_files);
    }
#line 608
    if (tmp___10 < 0) {
#line 610
      return (-1);
    }
  }
  {
#line 613
  tmp___11 = fprintf((FILE */* __restrict  */)fp2, (char const   */* __restrict  */)":");
  }
#line 613
  if (tmp___11 < 0) {
#line 614
    return (-1);
  }
#line 616
  if (pwinfo->has_quota_size != 0) {
    {
#line 617
    tmp___12 = fprintf((FILE */* __restrict  */)fp2, (char const   */* __restrict  */)"%llu",
                       pwinfo->quota_size);
    }
#line 617
    if (tmp___12 < 0) {
#line 619
      return (-1);
    }
  }
  {
#line 622
  tmp___13 = fprintf((FILE */* __restrict  */)fp2, (char const   */* __restrict  */)":");
  }
#line 622
  if (tmp___13 < 0) {
#line 623
    return (-1);
  }
#line 625
  if ((unsigned long )pwinfo->allow_local_ip != (unsigned long )((void *)0)) {
    {
#line 626
    fprintf((FILE */* __restrict  */)fp2, (char const   */* __restrict  */)"%s", pwinfo->allow_local_ip);
    }
  }
  {
#line 628
  tmp___14 = fprintf((FILE */* __restrict  */)fp2, (char const   */* __restrict  */)":");
  }
#line 628
  if (tmp___14 < 0) {
#line 629
    return (-1);
  }
#line 631
  if ((unsigned long )pwinfo->deny_local_ip != (unsigned long )((void *)0)) {
    {
#line 632
    fprintf((FILE */* __restrict  */)fp2, (char const   */* __restrict  */)"%s", pwinfo->deny_local_ip);
    }
  }
  {
#line 634
  tmp___15 = fprintf((FILE */* __restrict  */)fp2, (char const   */* __restrict  */)":");
  }
#line 634
  if (tmp___15 < 0) {
#line 635
    return (-1);
  }
#line 637
  if ((unsigned long )pwinfo->allow_client_ip != (unsigned long )((void *)0)) {
    {
#line 638
    fprintf((FILE */* __restrict  */)fp2, (char const   */* __restrict  */)"%s", pwinfo->allow_client_ip);
    }
  }
  {
#line 640
  tmp___16 = fprintf((FILE */* __restrict  */)fp2, (char const   */* __restrict  */)":");
  }
#line 640
  if (tmp___16 < 0) {
#line 641
    return (-1);
  }
#line 643
  if ((unsigned long )pwinfo->deny_client_ip != (unsigned long )((void *)0)) {
    {
#line 644
    fprintf((FILE */* __restrict  */)fp2, (char const   */* __restrict  */)"%s", pwinfo->deny_client_ip);
    }
  }
  {
#line 646
  tmp___17 = fprintf((FILE */* __restrict  */)fp2, (char const   */* __restrict  */)":");
  }
#line 646
  if (tmp___17 < 0) {
#line 647
    return (-1);
  }
#line 649
  if (pwinfo->has_time != 0) {
    {
#line 650
    tmp___18 = fprintf((FILE */* __restrict  */)fp2, (char const   */* __restrict  */)"%u-%u",
                       pwinfo->time_begin, pwinfo->time_end);
    }
#line 650
    if (tmp___18 < 0) {
#line 652
      return (-1);
    }
  }
  {
#line 655
  tmp___19 = fprintf((FILE */* __restrict  */)fp2, (char const   */* __restrict  */)"\n");
  }
#line 655
  if (tmp___19 < 0) {
#line 656
    return (-1);
  }
#line 659
  return (0);
}
}
#line 664 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-pw.c"
static char pwd[2048]  ;
#line 662 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-pw.c"
static char *do_get_passwd(void) 
{ 
  char pwd2[2048] ;
  int tries ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;

  {
#line 666
  tries = 3;
#line 668
  pwd[0] = (char)0;
#line 669
  pwd2[0] = (char)0;
  again: 
  {
#line 672
  printf((char const   */* __restrict  */)"Password: ");
#line 673
  fflush(stdout);
#line 674
  disable_echo();
#line 675
  tmp = fgets((char */* __restrict  */)(pwd), (int )(sizeof(pwd) - 1UL), (FILE */* __restrict  */)stdin);
  }
#line 675
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 676
    enable_echo();
    }
#line 677
    return ((char *)((void *)0));
  }
  {
#line 679
  strip_lf(pwd);
#line 680
  printf((char const   */* __restrict  */)"\nEnter it again: ");
#line 681
  fflush(stdout);
#line 682
  disable_echo();
#line 683
  tmp___0 = fgets((char */* __restrict  */)(pwd2), (int )(sizeof(pwd2) - 1UL), (FILE */* __restrict  */)stdin);
  }
#line 683
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
#line 684
    enable_echo();
    }
#line 685
    return ((char *)((void *)0));
  }
  {
#line 687
  strip_lf(pwd2);
#line 688
  puts("");
#line 689
  tmp___3 = strcmp((char const   *)(pwd), (char const   *)(pwd2));
  }
#line 689
  if (tmp___3 != 0) {
#line 690
    if ((int )pwd2[0] != 0) {
      {
#line 691
      tmp___1 = strlen((char const   *)(pwd2));
#line 691
      memset((void *)(pwd2), 0, tmp___1);
      }
    }
#line 693
    if ((int )pwd[0] != 0) {
      {
#line 694
      tmp___2 = strlen((char const   *)(pwd));
#line 694
      memset((void *)(pwd), 0, tmp___2);
      }
    }
    {
#line 696
    puts("You didn\'t enter the same password");
#line 697
    tries --;
    }
#line 697
    if (tries > 0) {
#line 698
      goto again;
    }
    {
#line 700
    enable_echo();
    }
#line 702
    return ((char *)((void *)0));
  }
#line 704
  if ((int )pwd2[0] != 0) {
    {
#line 705
    tmp___4 = strlen((char const   *)(pwd2));
#line 705
    memset((void *)(pwd2), 0, tmp___4);
    }
  }
  {
#line 707
  enable_echo();
  }
#line 709
  return (pwd);
}
}
#line 712 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-pw.c"
static int do_list(char const   * const  file ) 
{ 
  FILE *fp ;
  PWInfo pwinfo ;
  char line___1[2048] ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 718
  if ((unsigned long )file == (unsigned long )((void *)0)) {
    {
#line 719
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"missing file to list accounts\n");
    }
#line 720
    return (1 << 1);
  }
  {
#line 722
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
  }
#line 722
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 723
    perror("Unable to open the passwd file");
    }
#line 724
    return (1 << 1);
  }
  {
#line 726
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 726
    tmp___1 = fgets((char */* __restrict  */)(line___1), (int )((unsigned int )((int )sizeof(line___1)) - 1U),
                    (FILE */* __restrict  */)fp);
    }
#line 726
    if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
#line 726
      goto while_break;
    }
    {
#line 727
    strip_lf(line___1);
    }
#line 728
    if ((int )line___1[0] == 0) {
#line 729
      goto while_continue;
    } else
#line 728
    if ((int )line___1[0] == 35) {
#line 729
      goto while_continue;
    }
    {
#line 731
    tmp = parse_pw_line(line___1, (PWInfo */* const  */)(& pwinfo));
    }
#line 731
    if (tmp != 0) {
      {
#line 732
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: invalid line [%s]\n",
              line___1);
      }
#line 733
      goto while_continue;
    }
    {
#line 735
    tmp___0 = isatty(1);
    }
#line 735
    if (tmp___0) {
      {
#line 736
      printf((char const   */* __restrict  */)"%-19s %-39s %-19s\n", pwinfo.login,
             pwinfo.home, pwinfo.gecos);
      }
    } else {
      {
#line 738
      printf((char const   */* __restrict  */)"%s\t%s\t%s\n", pwinfo.login, pwinfo.home,
             pwinfo.gecos);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 741
  fclose(fp);
  }
#line 743
  return (0);
}
}
#line 746 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-pw.c"
static int do_useradd(char const   * const  file , PWInfo const   * const  pwinfo_ ) 
{ 
  char *file2 ;
  FILE *fp2 ;
  PWInfo pwinfo ;
  char *cleartext ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 751
  pwinfo = *pwinfo_;
#line 753
  if ((unsigned long )pwinfo.login == (unsigned long )((void *)0)) {
    {
#line 754
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing login\n");
    }
#line 755
    return (1);
  } else
#line 753
  if ((int )*(pwinfo.login) == 0) {
    {
#line 754
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing login\n");
    }
#line 755
    return (1);
  }
#line 757
  if ((unsigned long )file == (unsigned long )((void *)0)) {
    {
#line 758
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing passwd file\n");
    }
#line 759
    return (1 << 1);
  }
#line 762
  if (pwinfo.uid <= 0U) {
    {
#line 763
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"You must give (non-root) uid and gid\n");
    }
#line 764
    return (1 << 5);
  } else
#line 762
  if (pwinfo.gid <= 0U) {
    {
#line 763
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"You must give (non-root) uid and gid\n");
    }
#line 764
    return (1 << 5);
  }
#line 767
  if ((unsigned long )pwinfo.home == (unsigned long )((void *)0)) {
    {
#line 768
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing home directory\n");
    }
#line 769
    return (1 << 6);
  }
#line 771
  if ((unsigned long )pwinfo.gecos == (unsigned long )((void *)0)) {
    {
#line 772
    pwinfo.gecos = strdup("");
    }
#line 772
    if ((unsigned long )pwinfo.gecos == (unsigned long )((void *)0)) {
      {
#line 773
      no_mem();
      }
    }
  }
  {
#line 776
  pwinfo.pwd = do_get_passwd();
  }
#line 776
  if ((unsigned long )pwinfo.pwd == (unsigned long )((void *)0)) {
    {
#line 777
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error with entering password - aborting\n");
    }
#line 778
    return (1 << 3);
  }
  {
#line 781
  cleartext = pwinfo.pwd;
#line 783
  pwinfo.pwd = best_crypt((char const   */* const  */)cleartext);
  }
#line 784
  if ((int )*cleartext != 0) {
    {
#line 785
    tmp = strlen((char const   *)cleartext);
#line 785
    memset((void *)cleartext, 0, tmp);
    }
  }
  {
#line 788
  file2 = newpasswd_filename(file);
  }
#line 788
  if ((unsigned long )file2 == (unsigned long )((void *)0)) {
    {
#line 789
    no_mem();
    }
  }
  {
#line 791
  fp2 = create_newpasswd(file, (char const   */* const  */)file2, (char const   */* const  */)pwinfo.login,
                         1, 0);
  }
#line 791
  if ((unsigned long )fp2 == (unsigned long )((void *)0)) {
    {
#line 792
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error.\nCheck that [%s] doesn\'t already exist,\nand that [%s] can be written.\n",
            pwinfo.login, file2);
#line 796
    free((void *)file2);
    }
#line 797
    return (1 << 2);
  }
  {
#line 799
  tmp___0 = add_new_pw_line((FILE */* const  */)fp2, (PWInfo const   */* const  */)(& pwinfo));
  }
#line 799
  if (tmp___0 != 0) {
    {
#line 800
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to append a line\n");
    }
#line 801
    goto bye;
  }
  {
#line 803
  fflush(fp2);
#line 805
  tmp___1 = fileno(fp2);
#line 805
  fsync(tmp___1);
#line 807
  tmp___2 = fclose(fp2);
  }
#line 807
  if (tmp___2 != 0) {
    {
#line 808
    perror("Unable to close the file");
    }
#line 809
    goto bye2;
  }
  {
#line 811
  tmp___3 = rename((char const   *)file2, (char const   *)file);
  }
#line 811
  if (tmp___3 != 0) {
    {
#line 812
    perror("Unable to rename the file");
    }
#line 813
    goto bye2;
  }
  {
#line 815
  free((void *)file2);
  }
#line 816
  return (0);
  bye: 
  {
#line 819
  fclose(fp2);
  }
  bye2: 
  {
#line 821
  unlink((char const   *)file2);
#line 822
  free((void *)file2);
  }
#line 824
  return (255);
}
}
#line 833 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-pw.c"
static char line[2048]  ;
#line 827 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-pw.c"
static int do_usermod(char const   * const  file , PWInfo const   *pwinfo ) 
{ 
  char *file2 ;
  FILE *fp2 ;
  PWInfo fetched_info ;
  int tmp ;
  char *cleartext ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 835
  if ((unsigned long )pwinfo->login == (unsigned long )((void *)0)) {
    {
#line 836
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing login\n");
    }
#line 837
    return (1);
  } else
#line 835
  if ((int )*(pwinfo->login) == 0) {
    {
#line 836
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing login\n");
    }
#line 837
    return (1);
  }
#line 839
  if ((unsigned long )file == (unsigned long )((void *)0)) {
    {
#line 840
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing passwd file\n");
    }
#line 841
    return (1 << 1);
  }
  {
#line 843
  tmp = fetch_pw_account(file, (PWInfo */* const  */)(& fetched_info), (char */* const  */)(line),
                         (size_t const   )sizeof(line), (char const   */* const  */)pwinfo->login);
  }
#line 843
  if (tmp != 0) {
    {
#line 845
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to fetch info about user [%s] in file [%s]\n",
            pwinfo->login, file);
    }
#line 847
    return (1 << 4);
  }
#line 849
  if ((unsigned long )pwinfo->pwd != (unsigned long )((void *)0)) {
    {
#line 850
    cleartext = (char *)pwinfo->pwd;
#line 852
    fetched_info.pwd = best_crypt((char const   */* const  */)cleartext);
    }
#line 853
    if ((int )*cleartext != 0) {
      {
#line 854
      tmp___0 = strlen((char const   *)cleartext);
#line 854
      memset((void *)cleartext, 0, tmp___0);
      }
    }
  }
#line 857
  if (pwinfo->uid > 0U) {
#line 858
    fetched_info.uid = (uid_t )pwinfo->uid;
  }
#line 860
  if (pwinfo->gid > 0U) {
#line 861
    fetched_info.gid = (gid_t )pwinfo->gid;
  }
#line 863
  if ((unsigned long )pwinfo->home != (unsigned long )((void *)0)) {
#line 864
    fetched_info.home = (char *)pwinfo->home;
  }
#line 866
  if ((unsigned long )pwinfo->gecos != (unsigned long )((void *)0)) {
#line 867
    fetched_info.gecos = (char *)pwinfo->gecos;
  }
#line 869
  if (pwinfo->has_bw_dl != 0) {
#line 870
    if (pwinfo->has_bw_dl < 0) {
#line 871
      fetched_info.has_bw_dl = 0;
    } else {
#line 873
      fetched_info.has_bw_dl = (int )pwinfo->has_bw_dl;
#line 874
      fetched_info.bw_dl = (unsigned long )pwinfo->bw_dl;
    }
  }
#line 877
  if (pwinfo->has_bw_ul != 0) {
#line 878
    if (pwinfo->has_bw_ul < 0) {
#line 879
      fetched_info.has_bw_ul = 0;
    } else {
#line 881
      fetched_info.has_bw_ul = (int )pwinfo->has_bw_ul;
#line 882
      fetched_info.bw_ul = (unsigned long )pwinfo->bw_ul;
    }
  }
#line 885
  if (pwinfo->has_quota_files != 0) {
#line 886
    if (pwinfo->has_quota_files < 0) {
#line 887
      fetched_info.has_quota_files = 0;
    } else {
#line 889
      fetched_info.has_quota_files = (int )pwinfo->has_quota_files;
#line 890
      fetched_info.quota_files = (unsigned long long )pwinfo->quota_files;
    }
  }
#line 893
  if (pwinfo->has_quota_size != 0) {
#line 894
    if (pwinfo->has_quota_size < 0) {
#line 895
      fetched_info.has_quota_size = 0;
    } else {
#line 897
      fetched_info.has_quota_size = (int )pwinfo->has_quota_size;
#line 898
      fetched_info.quota_size = (unsigned long long )pwinfo->quota_size;
    }
  }
#line 901
  if (pwinfo->has_ul_ratio != 0) {
#line 902
    if (pwinfo->has_ul_ratio < 0) {
#line 903
      fetched_info.has_ul_ratio = 0;
    } else {
#line 905
      fetched_info.has_ul_ratio = (int )pwinfo->has_ul_ratio;
#line 906
      fetched_info.ul_ratio = (unsigned int )pwinfo->ul_ratio;
    }
  }
#line 909
  if (pwinfo->has_dl_ratio != 0) {
#line 910
    if (pwinfo->has_dl_ratio < 0) {
#line 911
      fetched_info.has_dl_ratio = 0;
    } else {
#line 913
      fetched_info.has_dl_ratio = (int )pwinfo->has_dl_ratio;
#line 914
      fetched_info.dl_ratio = (unsigned int )pwinfo->dl_ratio;
    }
  }
#line 917
  if ((unsigned long )pwinfo->allow_local_ip != (unsigned long )((void *)0)) {
#line 918
    fetched_info.allow_local_ip = (char *)pwinfo->allow_local_ip;
  }
#line 920
  if ((unsigned long )pwinfo->deny_local_ip != (unsigned long )((void *)0)) {
#line 921
    fetched_info.deny_local_ip = (char *)pwinfo->deny_local_ip;
  }
#line 923
  if ((unsigned long )pwinfo->allow_client_ip != (unsigned long )((void *)0)) {
#line 924
    fetched_info.allow_client_ip = (char *)pwinfo->allow_client_ip;
  }
#line 926
  if ((unsigned long )pwinfo->deny_client_ip != (unsigned long )((void *)0)) {
#line 927
    fetched_info.deny_client_ip = (char *)pwinfo->deny_client_ip;
  }
#line 929
  if (pwinfo->has_time != 0) {
#line 930
    if (pwinfo->has_time < 0) {
#line 931
      fetched_info.has_time = 0;
    } else {
#line 933
      fetched_info.has_time = (int )pwinfo->has_time;
    }
#line 935
    fetched_info.time_begin = (unsigned int )pwinfo->time_begin;
#line 936
    fetched_info.time_end = (unsigned int )pwinfo->time_end;
  }
#line 938
  if (pwinfo->has_per_user_max != 0) {
#line 939
    if (pwinfo->has_per_user_max < 0) {
#line 940
      fetched_info.has_per_user_max = 0;
    } else {
#line 942
      fetched_info.has_per_user_max = (int )pwinfo->has_per_user_max;
#line 943
      fetched_info.per_user_max = (unsigned int )pwinfo->per_user_max;
    }
  }
  {
#line 946
  file2 = newpasswd_filename(file);
  }
#line 946
  if ((unsigned long )file2 == (unsigned long )((void *)0)) {
    {
#line 947
    no_mem();
    }
  }
  {
#line 949
  fp2 = create_newpasswd(file, (char const   */* const  */)file2, (char const   */* const  */)pwinfo->login,
                         0, 1);
  }
#line 949
  if ((unsigned long )fp2 == (unsigned long )((void *)0)) {
    {
#line 950
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error.\nCheck that [%s] already exists,\nand that [%s] can be written.\n",
            pwinfo->login, file2);
#line 953
    free((void *)file2);
    }
#line 954
    return (1 << 2);
  }
  {
#line 956
  tmp___1 = add_new_pw_line((FILE */* const  */)fp2, (PWInfo const   */* const  */)(& fetched_info));
  }
#line 956
  if (tmp___1 != 0) {
    {
#line 957
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to append a line\n");
    }
#line 958
    goto bye;
  }
  {
#line 960
  fflush(fp2);
#line 962
  tmp___2 = fileno(fp2);
#line 962
  fsync(tmp___2);
#line 964
  tmp___3 = fclose(fp2);
  }
#line 964
  if (tmp___3 != 0) {
    {
#line 965
    perror("Unable to close the file");
    }
#line 966
    goto bye2;
  }
  {
#line 968
  tmp___4 = rename((char const   *)file2, (char const   *)file);
  }
#line 968
  if (tmp___4 != 0) {
    {
#line 969
    perror("Unable to rename the file");
    }
#line 970
    goto bye2;
  }
  {
#line 972
  free((void *)file2);
  }
#line 973
  return (0);
  bye: 
  {
#line 976
  fclose(fp2);
  }
  bye2: 
  {
#line 978
  unlink((char const   *)file2);
#line 979
  free((void *)file2);
  }
#line 981
  return (255);
}
}
#line 984 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-pw.c"
static int do_userdel(char const   * const  file , PWInfo const   * const  pwinfo ) 
{ 
  char *file2 ;
  FILE *fp2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 990
  if ((unsigned long )pwinfo->login == (unsigned long )((void *)0)) {
    {
#line 991
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing login\n");
    }
#line 992
    return (-1);
  } else
#line 990
  if ((int )*(pwinfo->login) == 0) {
    {
#line 991
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing login\n");
    }
#line 992
    return (-1);
  }
#line 994
  if ((unsigned long )file == (unsigned long )((void *)0)) {
    {
#line 995
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing passwd file\n");
    }
#line 996
    return (1 << 1);
  }
  {
#line 998
  file2 = newpasswd_filename(file);
  }
#line 998
  if ((unsigned long )file2 == (unsigned long )((void *)0)) {
    {
#line 999
    no_mem();
    }
  }
  {
#line 1001
  fp2 = create_newpasswd(file, (char const   */* const  */)file2, (char const   */* const  */)pwinfo->login,
                         0, 1);
  }
#line 1001
  if ((unsigned long )fp2 == (unsigned long )((void *)0)) {
    {
#line 1002
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error.\nCheck that [%s] already exists,\nand that [%s] can be written.\n",
            pwinfo->login, file2);
#line 1005
    free((void *)file2);
    }
#line 1006
    return (1 << 2);
  }
  {
#line 1008
  fflush(fp2);
#line 1010
  tmp = fileno(fp2);
#line 1010
  fsync(tmp);
#line 1012
  tmp___0 = fclose(fp2);
  }
#line 1012
  if (tmp___0 != 0) {
    {
#line 1013
    perror("Unable to close the file");
    }
#line 1014
    goto bye2;
  }
  {
#line 1016
  tmp___1 = rename((char const   *)file2, (char const   *)file);
  }
#line 1016
  if (tmp___1 != 0) {
    {
#line 1017
    perror("Unable to rename the file");
    }
#line 1018
    goto bye2;
  }
  {
#line 1020
  free((void *)file2);
  }
#line 1021
  return (0);
  bye2: 
  {
#line 1024
  unlink((char const   *)file2);
#line 1025
  free((void *)file2);
  }
#line 1027
  return (255);
}
}
#line 1037 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-pw.c"
static char line___0[2048]  ;
#line 1030 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-pw.c"
static int do_show(char const   * const  file , PWInfo const   * const  pwinfo ) 
{ 
  PWInfo fetched_info ;
  struct passwd *pwd___0 ;
  struct group *grp ;
  char const   *pwd_name ;
  char const   *grp_name ;
  int tmp ;
  char const   *tmp___0 ;
  unsigned int tmp___1 ;
  char const   *tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  char const   *tmp___13 ;
  unsigned long long tmp___14 ;
  char const   *tmp___15 ;
  unsigned long long tmp___16 ;
  char const   *tmp___17 ;
  unsigned long tmp___18 ;
  char const   *tmp___19 ;
  unsigned long tmp___20 ;

  {
#line 1035
  pwd_name = "-";
#line 1036
  grp_name = "-";
#line 1039
  if ((unsigned long )pwinfo->login == (unsigned long )((void *)0)) {
    {
#line 1040
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing login\n");
    }
#line 1041
    return (1);
  } else
#line 1039
  if ((int )*(pwinfo->login) == 0) {
    {
#line 1040
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing login\n");
    }
#line 1041
    return (1);
  }
#line 1043
  if ((unsigned long )file == (unsigned long )((void *)0)) {
    {
#line 1044
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing passwd file\n");
    }
#line 1045
    return (1 << 1);
  }
  {
#line 1047
  tmp = fetch_pw_account(file, (PWInfo */* const  */)(& fetched_info), (char */* const  */)(line___0),
                         (size_t const   )sizeof(line___0), (char const   */* const  */)pwinfo->login);
  }
#line 1047
  if (tmp != 0) {
    {
#line 1049
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to fetch info about user [%s] in file [%s]\n",
            pwinfo->login, file);
    }
#line 1051
    return (1 << 4);
  }
  {
#line 1053
  pwd___0 = getpwuid(fetched_info.uid);
  }
#line 1053
  if ((unsigned long )pwd___0 != (unsigned long )((void *)0)) {
#line 1053
    if ((unsigned long )pwd___0->pw_name != (unsigned long )((void *)0)) {
#line 1054
      pwd_name = (char const   *)pwd___0->pw_name;
    }
  }
  {
#line 1056
  grp = getgrgid(fetched_info.gid);
  }
#line 1056
  if ((unsigned long )grp != (unsigned long )((void *)0)) {
#line 1056
    if ((unsigned long )grp->gr_name != (unsigned long )((void *)0)) {
#line 1057
      grp_name = (char const   *)grp->gr_name;
    }
  }
#line 1059
  if (fetched_info.per_user_max != 0U) {
#line 1059
    tmp___0 = "enabled";
  } else {
#line 1059
    tmp___0 = "unlimited";
  }
#line 1059
  if (fetched_info.has_per_user_max != 0) {
#line 1059
    tmp___1 = fetched_info.per_user_max;
  } else {
#line 1059
    tmp___1 = 0U;
  }
#line 1059
  if (fetched_info.has_time != 0) {
#line 1059
    tmp___2 = "enabled";
  } else {
#line 1059
    tmp___2 = "unlimited";
  }
#line 1059
  if (fetched_info.has_time != 0) {
#line 1059
    tmp___3 = fetched_info.time_end;
  } else {
#line 1059
    tmp___3 = 0U;
  }
#line 1059
  if (fetched_info.has_time != 0) {
#line 1059
    tmp___4 = fetched_info.time_begin;
  } else {
#line 1059
    tmp___4 = 0U;
  }
#line 1059
  if ((unsigned long )fetched_info.deny_client_ip != (unsigned long )((void *)0)) {
#line 1059
    tmp___5 = (char const   *)fetched_info.deny_client_ip;
  } else {
#line 1059
    tmp___5 = "-";
  }
#line 1059
  if ((unsigned long )fetched_info.allow_client_ip != (unsigned long )((void *)0)) {
#line 1059
    tmp___6 = (char const   *)fetched_info.allow_client_ip;
  } else {
#line 1059
    tmp___6 = "-";
  }
#line 1059
  if ((unsigned long )fetched_info.deny_local_ip != (unsigned long )((void *)0)) {
#line 1059
    tmp___7 = (char const   *)fetched_info.deny_local_ip;
  } else {
#line 1059
    tmp___7 = "-";
  }
#line 1059
  if ((unsigned long )fetched_info.allow_local_ip != (unsigned long )((void *)0)) {
#line 1059
    tmp___8 = (char const   *)fetched_info.allow_local_ip;
  } else {
#line 1059
    tmp___8 = "-";
  }
#line 1059
  if (fetched_info.has_dl_ratio != 0) {
#line 1059
    tmp___9 = "enabled";
  } else {
#line 1059
    tmp___9 = "unlimited";
  }
#line 1059
  if (fetched_info.has_ul_ratio != 0) {
#line 1059
    tmp___10 = "enabled";
  } else {
#line 1059
    tmp___10 = "unlimited";
  }
#line 1059
  if (fetched_info.has_dl_ratio != 0) {
#line 1059
    tmp___11 = fetched_info.dl_ratio;
  } else {
#line 1059
    tmp___11 = 0U;
  }
#line 1059
  if (fetched_info.has_ul_ratio != 0) {
#line 1059
    tmp___12 = fetched_info.ul_ratio;
  } else {
#line 1059
    tmp___12 = 0U;
  }
#line 1059
  if (fetched_info.has_quota_size != 0) {
#line 1059
    tmp___13 = "enabled";
  } else {
#line 1059
    tmp___13 = "unlimited";
  }
#line 1059
  if (fetched_info.has_quota_size != 0) {
#line 1059
    tmp___14 = fetched_info.quota_size / 1048576ULL;
  } else {
#line 1059
    tmp___14 = 0ULL;
  }
#line 1059
  if (fetched_info.has_quota_files != 0) {
#line 1059
    tmp___15 = "enabled";
  } else {
#line 1059
    tmp___15 = "unlimited";
  }
#line 1059
  if (fetched_info.has_quota_files != 0) {
#line 1059
    tmp___16 = fetched_info.quota_files;
  } else {
#line 1059
    tmp___16 = 0ULL;
  }
#line 1059
  if (fetched_info.has_bw_ul != 0) {
#line 1059
    tmp___17 = "enabled";
  } else {
#line 1059
    tmp___17 = "unlimited";
  }
#line 1059
  if (fetched_info.has_bw_ul != 0) {
#line 1059
    tmp___18 = fetched_info.bw_ul / 1024UL;
  } else {
#line 1059
    tmp___18 = 0UL;
  }
#line 1059
  if (fetched_info.has_bw_dl != 0) {
#line 1059
    tmp___19 = "enabled";
  } else {
#line 1059
    tmp___19 = "unlimited";
  }
#line 1059
  if (fetched_info.has_bw_dl != 0) {
#line 1059
    tmp___20 = fetched_info.bw_dl / 1024UL;
  } else {
#line 1059
    tmp___20 = 0UL;
  }
  {
#line 1059
  printf((char const   */* __restrict  */)"\nLogin              : %s\nPassword           : %s\nUID                : %lu (%s)\nGID                : %lu (%s)\nDirectory          : %s\nFull name          : %s\nDownload bandwidth : %lu Kb (%s)\nUpload   bandwidth : %lu Kb (%s)\nMax files          : %llu (%s)\nMax size           : %llu Mb (%s)\nRatio              : %u:%u (%s:%s)\nAllowed local  IPs : %s\nDenied  local  IPs : %s\nAllowed client IPs : %s\nDenied  client IPs : %s\nTime restrictions  : %04u-%04u (%s)\nMax sim sessions   : %u (%s)\n\n",
         fetched_info.login, fetched_info.pwd, (unsigned long )fetched_info.uid, pwd_name,
         (unsigned long )fetched_info.gid, grp_name, fetched_info.home, fetched_info.gecos,
         tmp___20, tmp___19, tmp___18, tmp___17, tmp___16, tmp___15, tmp___14, tmp___13,
         tmp___12, tmp___11, tmp___10, tmp___9, tmp___8, tmp___7, tmp___6, tmp___5,
         tmp___4, tmp___3, tmp___2, tmp___1, tmp___0);
  }
#line 1106
  return (0);
}
}
#line 1109 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-pw.c"
static int do_passwd(char const   * const  file , PWInfo * const  pwinfo ) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
#line 1112
  if ((unsigned long )pwinfo->login == (unsigned long )((void *)0)) {
    {
#line 1113
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing login\n");
    }
#line 1114
    return (1);
  } else
#line 1112
  if ((int )*(pwinfo->login) == 0) {
    {
#line 1113
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing login\n");
    }
#line 1114
    return (1);
  }
#line 1116
  if ((unsigned long )file == (unsigned long )((void *)0)) {
    {
#line 1117
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing passwd file\n");
    }
#line 1118
    return (1 << 1);
  }
  {
#line 1120
  tmp = do_get_passwd();
#line 1120
  pwinfo->pwd = tmp;
  }
#line 1120
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 1121
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error with entering password - aborting\n");
    }
#line 1122
    return (1 << 3);
  }
  {
#line 1124
  tmp___0 = do_usermod(file, (PWInfo const   *)pwinfo);
  }
#line 1124
  return (tmp___0);
}
}
#line 1127 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-pw.c"
static int do_mkdb(char const   *dbfile , char const   * const  file ) 
{ 
  FILE *fp ;
  char *index_dbfile ;
  size_t sizeof_index_dbfile ;
  char *data_dbfile ;
  size_t sizeof_data_dbfile ;
  char *s___0 ;
  PureDBW dbw ;
  int ret ;
  char line___1[2048] ;
  char *dbfile_ ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
#line 1136
  ret = 255;
#line 1139
  if ((unsigned long )dbfile == (unsigned long )((void *)0)) {
#line 1139
    goto _L;
  } else
#line 1139
  if ((int const   )*dbfile == 0) {
    _L: /* CIL Label */ 
    {
#line 1142
    dbfile_ = getenv("PURE_DBFILE");
    }
#line 1142
    if ((unsigned long )dbfile_ != (unsigned long )((void *)0)) {
#line 1142
      if ((int )*dbfile_ != 0) {
#line 1143
        dbfile = (char const   *)dbfile_;
      } else {
#line 1145
        dbfile = "/etc/pureftpd.pdb";
      }
    } else {
#line 1145
      dbfile = "/etc/pureftpd.pdb";
    }
  }
#line 1148
  if ((unsigned long )file == (unsigned long )((void *)0)) {
    {
#line 1149
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing passwd file\n");
    }
#line 1150
    return (1 << 1);
  }
  {
#line 1152
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
  }
#line 1152
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 1153
    perror("Unable to open the passwd file");
    }
#line 1154
    return (1 << 1);
  }
  {
#line 1156
  tmp = strlen(dbfile);
#line 1156
  sizeof_index_dbfile = tmp + sizeof(".index");
#line 1157
  tmp___0 = __builtin_alloca(sizeof_index_dbfile);
#line 1157
  index_dbfile = (char *)tmp___0;
  }
#line 1157
  if ((unsigned long )index_dbfile == (unsigned long )((void *)0)) {
    {
#line 1158
    fclose(fp);
#line 1159
    no_mem();
    }
  }
  {
#line 1161
  tmp___1 = strlen(dbfile);
#line 1161
  sizeof_data_dbfile = tmp___1 + sizeof(".data");
#line 1162
  tmp___2 = __builtin_alloca(sizeof_data_dbfile);
#line 1162
  data_dbfile = (char *)tmp___2;
  }
#line 1162
  if ((unsigned long )data_dbfile == (unsigned long )((void *)0)) {
    {
#line 1163
    fclose(fp);
    }
    {
#line 1164
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1164
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1165
    no_mem();
    }
  }
  {
#line 1167
  snprintf((char */* __restrict  */)index_dbfile, sizeof_index_dbfile, (char const   */* __restrict  */)"%s%s",
           dbfile, ".index");
#line 1169
  snprintf((char */* __restrict  */)data_dbfile, sizeof_data_dbfile, (char const   */* __restrict  */)"%s%s",
           dbfile, ".data");
#line 1171
  tmp___3 = puredbw_open((PureDBW */* const  */)(& dbw), (char const   */* const  */)index_dbfile,
                         (char const   */* const  */)data_dbfile, (char const   */* const  */)dbfile);
  }
#line 1171
  if (tmp___3 != 0) {
    {
#line 1172
    perror("Unable to create the database");
    }
#line 1173
    goto err;
  }
  {
#line 1175
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1175
    tmp___6 = fgets((char */* __restrict  */)(line___1), (int )((unsigned int )((int )sizeof(line___1)) - 1U),
                    (FILE */* __restrict  */)fp);
    }
#line 1175
    if (! ((unsigned long )tmp___6 != (unsigned long )((void *)0))) {
#line 1175
      goto while_break___0;
    }
    {
#line 1176
    strip_lf(line___1);
    }
#line 1177
    if ((int )line___1[0] == 35) {
#line 1178
      goto while_continue___0;
    }
#line 1180
    if ((int )line___1[0] == 0) {
#line 1182
      goto while_continue___0;
    } else {
      {
#line 1180
      s___0 = strchr((char const   *)(line___1), (int )*":");
      }
#line 1180
      if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1182
        goto while_continue___0;
      } else
#line 1180
      if ((int )*(s___0 + 1) == 0) {
#line 1182
        goto while_continue___0;
      }
    }
    {
#line 1184
    tmp___4 = s___0;
#line 1184
    s___0 ++;
#line 1184
    *tmp___4 = (char)0;
#line 1185
    tmp___5 = puredbw_add_s((PureDBW */* const  */)(& dbw), (char const   */* const  */)(line___1),
                            (char const   */* const  */)s___0);
    }
#line 1185
    if (tmp___5 != 0) {
      {
#line 1186
      perror("Error while indexing a new entry");
      }
#line 1187
      goto err;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1190
  tmp___7 = puredbw_close((PureDBW */* const  */)(& dbw));
  }
#line 1190
  if (tmp___7 != 0) {
    {
#line 1191
    perror("Unable to close the database");
    }
  } else {
#line 1193
    ret = 0;
  }
  err: 
  {
#line 1196
  puredbw_free((PureDBW */* const  */)(& dbw));
  }
  {
#line 1197
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1197
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1198
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1198
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1199
  fclose(fp);
  }
#line 1201
  return (ret);
}
}
#line 1204 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/pure-pw.c"
static void init_zrand(void) 
{ 
  struct timeval tv ;
  struct timezone tz ;
  __pid_t tmp ;

  {
  {
#line 1209
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )(& tz));
#line 1213
  tmp = getpid();
#line 1213
  srandom((unsigned int )((tv.tv_sec ^ tv.tv_usec) ^ (long )(tmp << 16)));
  }
#line 1217
  return;
}
}
#line 54 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/alt_arc4random.c"
static int rs_initialized___0  ;
#line 55 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/alt_arc4random.c"
static struct alt_arc4_stream rs___0  ;
#line 56 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/alt_arc4random.c"
static pid_t alt_arc4_stir_pid___0  ;
#line 57 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/alt_arc4random.c"
static int alt_arc4_count___0  ;
#line 58 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/alt_arc4random.c"
static int random_data_source_fd___0  =    -1;
#line 59
static unsigned char alt_arc4_getbyte___0(void) ;
#line 72
static int alt_arc4_random_dev_open___0(void) ;
#line 72 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/alt_arc4random.c"
static char const   * const  devices___0[4]  = {      (char const   */* const  */)"/dev/arandom",      (char const   */* const  */)"/dev/urandom",      (char const   */* const  */)"/dev/random",      (char const   */* const  */)((void *)0)};
#line 69 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/alt_arc4random.c"
static int alt_arc4_random_dev_open___0(void) 
{ 
  char const   * const  *device ;
  int tmp ;
  int tmp___0 ;

  {
#line 75
  device = devices___0;
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 78
    tmp___0 = access((char const   *)*device, 4);
    }
#line 78
    if (tmp___0 == 0) {
      {
#line 79
      tmp = open((char const   *)*device, 0);
      }
#line 79
      return (tmp);
    }
#line 81
    device ++;
#line 77
    if (! ((unsigned long )*device != (unsigned long )((void *)0))) {
#line 77
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  return (-1);
}
}
#line 87 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/alt_arc4random.c"
static void alt_arc4_init___0(void) 
{ 
  int n ;

  {
#line 92
  n = 0;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! (n < 256)) {
#line 92
      goto while_break;
    }
#line 93
    rs___0.s[n] = (unsigned char )n;
#line 92
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  rs___0.i = (unsigned char)0;
#line 96
  rs___0.j = (unsigned char)0;
#line 98
  if (random_data_source_fd___0 != -1) {
#line 99
    return;
  }
  {
#line 101
  random_data_source_fd___0 = alt_arc4_random_dev_open___0();
  }
#line 102
  return;
}
}
#line 104 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/alt_arc4random.c"
static void alt_arc4_addrandom___0(unsigned char *dat , int datlen ) 
{ 
  int n ;
  unsigned char si ;

  {
#line 110
  rs___0.i = (unsigned char )((int )rs___0.i - 1);
#line 111
  n = 0;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! (n < 256)) {
#line 111
      goto while_break;
    }
#line 112
    rs___0.i = (unsigned char )((int )rs___0.i + 1);
#line 113
    si = rs___0.s[rs___0.i];
#line 114
    rs___0.j = (unsigned char )(((int )rs___0.j + (int )si) + (int )*(dat + n % datlen));
#line 115
    rs___0.s[rs___0.i] = rs___0.s[rs___0.j];
#line 116
    rs___0.s[rs___0.j] = si;
#line 111
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  rs___0.j = rs___0.i;
#line 119
  return;
}
}
#line 121 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/alt_arc4random.c"
static void alt_arc4_stir___0(void) 
{ 
  int i ;
  unsigned char rnd[128] ;

  {
#line 127
  if (! rs_initialized___0) {
    {
#line 128
    alt_arc4_init___0();
#line 129
    rs_initialized___0 = 1;
    }
  }
#line 132
  if (random_data_source_fd___0 != -1) {
    {
#line 133
    safe_read((int const   )random_data_source_fd___0, (void */* const  */)(rnd),
              sizeof(rnd));
    }
  } else {
    {
#line 136
    _exit(1);
    }
  }
  {
#line 163
  alt_arc4_addrandom___0(rnd, (int )sizeof(rnd));
#line 169
  i = 0;
  }
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (! (i < 256)) {
#line 169
      goto while_break;
    }
    {
#line 170
    alt_arc4_getbyte___0();
#line 169
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 172
  alt_arc4_count___0 = 1600000;
#line 173
  return;
}
}
#line 175 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/alt_arc4random.c"
static void alt_arc4_stir_if_needed___0(void) 
{ 
  pid_t pid ;
  __pid_t tmp ;

  {
  {
#line 178
  tmp = getpid();
#line 178
  pid = tmp;
  }
#line 180
  if (alt_arc4_count___0 <= 0) {
    {
#line 181
    alt_arc4_stir_pid___0 = pid;
#line 182
    alt_arc4_stir___0();
    }
  } else
#line 180
  if (! rs_initialized___0) {
    {
#line 181
    alt_arc4_stir_pid___0 = pid;
#line 182
    alt_arc4_stir___0();
    }
  } else
#line 180
  if (alt_arc4_stir_pid___0 != pid) {
    {
#line 181
    alt_arc4_stir_pid___0 = pid;
#line 182
    alt_arc4_stir___0();
    }
  }
#line 184
  return;
}
}
#line 186 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/alt_arc4random.c"
static unsigned char alt_arc4_getbyte___0(void) 
{ 
  unsigned char si ;
  unsigned char sj ;

  {
#line 191
  rs___0.i = (unsigned char )((int )rs___0.i + 1);
#line 192
  si = rs___0.s[rs___0.i];
#line 193
  rs___0.j = (unsigned char )((int )rs___0.j + (int )si);
#line 194
  sj = rs___0.s[rs___0.j];
#line 195
  rs___0.s[rs___0.i] = sj;
#line 196
  rs___0.s[rs___0.j] = si;
#line 198
  return (rs___0.s[((int )si + (int )sj) & 255]);
}
}
#line 201 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/src/alt_arc4random.c"
static unsigned int alt_arc4_getword___0(void) 
{ 
  unsigned int val ;
  unsigned char tmp ;
  unsigned char tmp___0 ;
  unsigned char tmp___1 ;
  unsigned char tmp___2 ;

  {
  {
#line 205
  tmp = alt_arc4_getbyte___0();
#line 205
  val = (unsigned int )tmp << 24;
#line 206
  tmp___0 = alt_arc4_getbyte___0();
#line 206
  val |= (unsigned int )tmp___0 << 16;
#line 207
  tmp___1 = alt_arc4_getbyte___0();
#line 207
  val |= (unsigned int )tmp___1 << 8;
#line 208
  tmp___2 = alt_arc4_getbyte___0();
#line 208
  val |= (unsigned int )tmp___2;
  }
#line 210
  return (val);
}
}
#line 26 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_write.c"
static puredb_u32_t puredbw_hash___1(char const   * const  msg , size_t len ) 
{ 
  puredb_u32_t j ;

  {
#line 28
  j = 5381U;
  {
#line 30
  while (1) {
    while_continue: /* CIL Label */ ;
#line 30
    if (! (len != 0UL)) {
#line 30
      goto while_break;
    }
#line 31
    len --;
#line 32
    j += j << 5;
#line 33
    j ^= (unsigned int )((unsigned char )*(msg + len));
  }
  while_break: /* CIL Label */ ;
  }
#line 35
  j &= 4294967295U;
#line 37
  return (j);
}
}
#line 143 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_write.c"
static int hash1_cmp_hook___1(void const   * const  a , void const   * const  b ) 
{ 
  puredb_u32_t ha ;
  puredb_u32_t hb ;

  {
#line 145
  ha = (puredb_u32_t )((Hash1 const   *)a)->hash;
#line 146
  hb = (puredb_u32_t )((Hash1 const   *)b)->hash;
#line 148
  if (ha < hb) {
#line 149
    return (-1);
  } else
#line 150
  if (ha > hb) {
#line 151
    return (1);
  }
#line 153
  ha = (puredb_u32_t )((Hash1 const   *)a)->offset_data;
#line 154
  hb = (puredb_u32_t )((Hash1 const   *)b)->offset_data;
#line 155
  if (ha < hb) {
#line 156
    return (-1);
  } else
#line 157
  if (ha > hb) {
#line 158
    return (1);
  }
#line 160
  return (0);
}
}
#line 163 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_write.c"
static int writekeys___1(PureDBW * const  dbw ) 
{ 
  int hash_cnt ;
  Hash0 const   *hash0 ;
  puredb_u32_t offset ;
  puredb_u32_t offset_ ;
  uint32_t tmp ;
  size_t tmp___0 ;
  puredb_u32_t null_ ;
  uint32_t tmp___1 ;
  size_t tmp___2 ;
  Hash1 *hash1 ;
  size_t list_size ;
  puredb_u32_t null____0 ;
  uint32_t tmp___3 ;
  size_t tmp___4 ;
  puredb_u32_t hash_ ;
  uint32_t tmp___5 ;
  size_t tmp___6 ;
  puredb_u32_t offset_data_ ;
  uint32_t tmp___7 ;
  size_t tmp___8 ;

  {
#line 165
  hash_cnt = (int )(sizeof(dbw->hash_table0) / sizeof(dbw->hash_table0[0]));
#line 167
  hash0 = (Hash0 const   *)(dbw->hash_table0);
#line 169
  offset = (puredb_u32_t )(((1UL + sizeof(dbw->hash_table0) / sizeof(dbw->hash_table0[0])) * sizeof(puredb_u32_t ) + sizeof("PDB2")) - 1UL);
  {
#line 172
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 174
    tmp = htonl(offset);
#line 174
    offset_ = tmp;
#line 176
    tmp___0 = fwrite((void const   */* __restrict  */)(& offset_), sizeof(offset_),
                     (size_t )1U, (FILE */* __restrict  */)dbw->fpindex);
    }
#line 176
    if (tmp___0 != 1UL) {
#line 179
      return (-1);
    }
#line 182
    if (hash0->hash1_list_size <= 0UL) {
#line 183
      offset = (puredb_u32_t )((unsigned long )offset + sizeof(puredb_u32_t ));
#line 184
      dbw->offset_first_data = (puredb_u32_t )((unsigned long )dbw->offset_first_data + sizeof(puredb_u32_t ));
    } else {
#line 186
      offset = (puredb_u32_t )((size_t const   )offset + (hash0->hash1_list_size / (size_t const   )sizeof(Hash1 )) * (size_t const   )(sizeof(puredb_u32_t ) + sizeof(puredb_u32_t )));
    }
#line 189
    hash0 ++;
#line 190
    hash_cnt --;
#line 172
    if (! (hash_cnt != 0)) {
#line 172
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 193
  tmp___1 = htonl(offset);
#line 193
  null_ = tmp___1;
#line 194
  tmp___2 = fwrite((void const   */* __restrict  */)(& null_), sizeof(null_), (size_t )1U,
                   (FILE */* __restrict  */)dbw->fpindex);
  }
#line 194
  if (tmp___2 != 1UL) {
#line 196
    return (-1);
  }
#line 200
  hash_cnt = (int )(sizeof(dbw->hash_table0) / sizeof(dbw->hash_table0[0]));
#line 201
  hash0 = (Hash0 const   *)(dbw->hash_table0);
  {
#line 202
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 203
    hash1 = (Hash1 *)hash0->hash1_list;
#line 204
    list_size = (size_t )hash0->hash1_list_size;
#line 206
    if ((unsigned long )hash1 == (unsigned long )((void *)0)) {
      {
#line 207
      tmp___3 = htonl((uint32_t )((hash0 - (Hash0 const   *)(dbw->hash_table0)) + 1L));
#line 207
      null____0 = tmp___3;
#line 210
      tmp___4 = fwrite((void const   */* __restrict  */)(& null____0), sizeof(null____0),
                       (size_t )1U, (FILE */* __restrict  */)dbw->fpindex);
      }
#line 210
      if (tmp___4 != 1UL) {
#line 212
        return (-1);
      }
#line 214
      goto next;
    }
    {
#line 216
    qsort((void *)hash1, (size_t )(hash0->hash1_list_size / (size_t const   )sizeof(Hash1 )),
          sizeof(Hash1 ), (int (*)(void const   * , void const   * ))(& hash1_cmp_hook___1));
    }
    {
#line 218
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 220
      tmp___5 = htonl(hash1->hash);
#line 220
      hash_ = tmp___5;
#line 222
      tmp___6 = fwrite((void const   */* __restrict  */)(& hash_), sizeof(hash_),
                       (size_t )1U, (FILE */* __restrict  */)dbw->fpindex);
      }
#line 222
      if (tmp___6 != 1UL) {
#line 224
        return (-1);
      }
      {
#line 228
      tmp___7 = htonl(hash1->offset_data + dbw->offset_first_data);
#line 228
      offset_data_ = tmp___7;
#line 231
      tmp___8 = fwrite((void const   */* __restrict  */)(& offset_data_), sizeof(offset_data_),
                       (size_t )1U, (FILE */* __restrict  */)dbw->fpindex);
      }
#line 231
      if (tmp___8 != 1UL) {
#line 233
        return (-1);
      }
#line 236
      hash1 ++;
#line 237
      list_size -= sizeof(Hash1 );
#line 218
      if (! (list_size > 0UL)) {
#line 218
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    next: 
#line 240
    hash0 ++;
#line 241
    hash_cnt --;
#line 202
    if (! (hash_cnt != 0)) {
#line 202
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 244
  return (0);
}
}
#line 247 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_write.c"
static int freestructs___1(PureDBW * const  dbw ) 
{ 
  Hash0 *hash0 ;
  int hash0_cnt ;

  {
#line 249
  hash0 = dbw->hash_table0;
#line 250
  hash0_cnt = (int )(sizeof(dbw->hash_table0) / sizeof(dbw->hash_table0[0]));
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 253
    free((void *)hash0->hash1_list);
#line 254
    hash0->hash1_list = (Hash1 *)((void *)0);
#line 255
    hash0 ++;
#line 256
    hash0_cnt --;
    }
#line 252
    if (! (hash0_cnt > 0)) {
#line 252
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 259
  return (0);
}
}
#line 262 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_write.c"
static int mergefiles___1(PureDBW * const  dbw ) 
{ 
  size_t readnb ;
  char buf___1[4096] ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 267
  rewind(dbw->fpdata);
  }
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 268
    readnb = fread((void */* __restrict  */)(buf___1), (size_t )1U, sizeof(buf___1),
                   (FILE */* __restrict  */)dbw->fpdata);
    }
#line 268
    if (! (readnb > 0UL)) {
#line 268
      goto while_break;
    }
    {
#line 270
    tmp = fwrite((void const   */* __restrict  */)(buf___1), (size_t )1U, readnb,
                 (FILE */* __restrict  */)dbw->fpindex);
    }
#line 270
    if (tmp != readnb) {
#line 271
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 274
  tmp___0 = fclose(dbw->fpdata);
  }
#line 274
  if (tmp___0 != 0) {
#line 275
    return (-1);
  }
  {
#line 277
  dbw->fpdata = (FILE *)((void *)0);
#line 278
  fflush(dbw->fpindex);
#line 280
  tmp___1 = fileno(dbw->fpindex);
#line 280
  fsync(tmp___1);
#line 282
  tmp___2 = fclose(dbw->fpindex);
  }
#line 282
  if (tmp___2 != 0) {
#line 283
    return (-1);
  }
  {
#line 285
  dbw->fpindex = (FILE *)((void *)0);
#line 286
  unlink((char const   *)dbw->file_data);
#line 287
  tmp___4 = rename((char const   *)dbw->file_index, (char const   *)dbw->file_final);
  }
#line 287
  if (tmp___4 < 0) {
    {
#line 289
    unlink((char const   *)dbw->file_final);
#line 290
    tmp___3 = rename((char const   *)dbw->file_index, (char const   *)dbw->file_final);
    }
#line 290
    if (tmp___3 < 0) {
#line 291
      return (-1);
    }
  }
#line 295
  return (0);
}
}
#line 298 "/home/wheatley/newnew/temp/pure-ftpd-1.0.36/puredb/src/puredb_write.c"
static void freeall___1(PureDBW * const  dbw ) 
{ 


  {
#line 300
  if ((unsigned long )dbw->fpindex != (unsigned long )((void *)0)) {
    {
#line 301
    fclose(dbw->fpindex);
#line 302
    dbw->fpindex = (FILE *)((void *)0);
    }
  }
#line 304
  if ((unsigned long )dbw->fpdata != (unsigned long )((void *)0)) {
    {
#line 305
    fclose(dbw->fpdata);
#line 306
    dbw->fpdata = (FILE *)((void *)0);
    }
  }
  {
#line 308
  free((void *)dbw->file_index);
#line 309
  dbw->file_index = (char *)((void *)0);
#line 310
  free((void *)dbw->file_data);
#line 311
  dbw->file_data = (char *)((void *)0);
#line 312
  free((void *)dbw->file_final);
#line 313
  dbw->file_final = (char *)((void *)0);
  }
#line 314
  return;
}
}
