/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 7 "/home/wheatley/newnew/temp/mktorrent-1.0/sha1.h"
struct __anonstruct_SHA_CTX_2 {
   uint32_t state[5] ;
   uint32_t count[2] ;
   uint8_t buffer[64] ;
};
#line 7 "/home/wheatley/newnew/temp/mktorrent-1.0/sha1.h"
typedef struct __anonstruct_SHA_CTX_2 SHA_CTX;
#line 71 "/home/wheatley/newnew/temp/mktorrent-1.0/sha1.c"
union __anonunion_CHAR64LONG16_3 {
   uint8_t c[64] ;
   uint32_t l[16] ;
};
#line 71 "/home/wheatley/newnew/temp/mktorrent-1.0/sha1.c"
typedef union __anonunion_CHAR64LONG16_3 CHAR64LONG16;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 86 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 13 "/home/wheatley/newnew/temp/mktorrent-1.0/mktorrent.h"
struct slist_s;
#line 14 "/home/wheatley/newnew/temp/mktorrent-1.0/mktorrent.h"
typedef struct slist_s slist_t;
#line 15 "/home/wheatley/newnew/temp/mktorrent-1.0/mktorrent.h"
struct slist_s {
   char *s ;
   slist_t *next ;
};
#line 21
struct llist_s;
#line 22 "/home/wheatley/newnew/temp/mktorrent-1.0/mktorrent.h"
typedef struct llist_s llist_t;
#line 23 "/home/wheatley/newnew/temp/mktorrent-1.0/mktorrent.h"
struct llist_s {
   slist_t *l ;
   llist_t *next ;
};
#line 29
struct flist_s;
#line 30 "/home/wheatley/newnew/temp/mktorrent-1.0/mktorrent.h"
typedef struct flist_s flist_t;
#line 31 "/home/wheatley/newnew/temp/mktorrent-1.0/mktorrent.h"
struct flist_s {
   char *path ;
   off_t size ;
   flist_t *next ;
};
#line 37 "/home/wheatley/newnew/temp/mktorrent-1.0/mktorrent.h"
struct __anonstruct_metafile_t_28 {
   unsigned int piece_length ;
   llist_t *announce_list ;
   char *comment ;
   char const   *torrent_name ;
   char *metainfo_file_path ;
   slist_t *web_seed_list ;
   int target_is_directory ;
   int no_creation_date ;
   int private ;
   int verbose ;
   off_t size ;
   flist_t *file_list ;
   unsigned int pieces ;
};
#line 37 "/home/wheatley/newnew/temp/mktorrent-1.0/mktorrent.h"
typedef struct __anonstruct_metafile_t_28 metafile_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 40 "/home/wheatley/newnew/temp/mktorrent-1.0/ftw.c"
struct dir_state {
   struct dir_state *next ;
   struct dir_state *prev ;
   size_t length ;
   DIR *dir ;
   off_t offset ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 16 "/home/wheatley/newnew/temp/mktorrent-1.0/sha1.h"
void SHA1_Init(SHA_CTX *context ) ;
#line 17
void SHA1_Update(SHA_CTX *context , uint8_t const   *data , unsigned long len ) ;
#line 18
void SHA1_Final(uint8_t *digest , SHA_CTX *context ) ;
#line 68 "/home/wheatley/newnew/temp/mktorrent-1.0/sha1.c"
static void SHA1_Transform(uint32_t *state , uint8_t const   *buffer ) 
{ 
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  uint32_t d ;
  uint32_t e ;
  CHAR64LONG16 *block ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;
  uint32_t tmp___7 ;
  uint32_t tmp___8 ;
  uint32_t tmp___9 ;
  uint32_t tmp___10 ;
  uint32_t tmp___11 ;
  uint32_t tmp___12 ;
  uint32_t tmp___13 ;
  uint32_t tmp___14 ;
  uint32_t tmp___15 ;
  uint32_t tmp___16 ;
  uint32_t tmp___17 ;
  uint32_t tmp___18 ;
  uint32_t tmp___19 ;
  uint32_t tmp___20 ;
  uint32_t tmp___21 ;
  uint32_t tmp___22 ;
  uint32_t tmp___23 ;
  uint32_t tmp___24 ;
  uint32_t tmp___25 ;
  uint32_t tmp___26 ;
  uint32_t tmp___27 ;
  uint32_t tmp___28 ;
  uint32_t tmp___29 ;
  uint32_t tmp___30 ;
  uint32_t tmp___31 ;
  uint32_t tmp___32 ;
  uint32_t tmp___33 ;
  uint32_t tmp___34 ;
  uint32_t tmp___35 ;
  uint32_t tmp___36 ;
  uint32_t tmp___37 ;
  uint32_t tmp___38 ;
  uint32_t tmp___39 ;
  uint32_t tmp___40 ;
  uint32_t tmp___41 ;
  uint32_t tmp___42 ;
  uint32_t tmp___43 ;
  uint32_t tmp___44 ;
  uint32_t tmp___45 ;
  uint32_t tmp___46 ;
  uint32_t tmp___47 ;
  uint32_t tmp___48 ;
  uint32_t tmp___49 ;
  uint32_t tmp___50 ;
  uint32_t tmp___51 ;
  uint32_t tmp___52 ;
  uint32_t tmp___53 ;
  uint32_t tmp___54 ;
  uint32_t tmp___55 ;
  uint32_t tmp___56 ;
  uint32_t tmp___57 ;
  uint32_t tmp___58 ;
  uint32_t tmp___59 ;
  uint32_t tmp___60 ;
  uint32_t tmp___61 ;
  uint32_t tmp___62 ;
  uint32_t tmp___63 ;
  uint32_t tmp___64 ;
  uint32_t tmp___65 ;
  uint32_t tmp___66 ;
  uint32_t tmp___67 ;
  uint32_t tmp___68 ;
  uint32_t tmp___69 ;
  uint32_t tmp___70 ;
  uint32_t tmp___71 ;
  uint32_t tmp___72 ;
  uint32_t tmp___73 ;
  uint32_t tmp___74 ;
  uint32_t tmp___75 ;
  uint32_t tmp___76 ;
  uint32_t tmp___77 ;
  uint32_t tmp___78 ;

  {
#line 82
  block = (CHAR64LONG16 *)buffer;
#line 86
  a = *(state + 0);
#line 87
  b = *(state + 1);
#line 88
  c = *(state + 2);
#line 89
  d = *(state + 3);
#line 90
  e = *(state + 4);
#line 93
  tmp = (((block->l[0] << 24) | (block->l[0] >> 8)) & 4278255360U) | (((block->l[0] << 8) | (block->l[0] >> 24)) & 16711935U);
#line 93
  block->l[0] = tmp;
#line 93
  e += ((((b & (c ^ d)) ^ d) + tmp) + 1518500249U) + ((a << 5) | (a >> 27));
#line 93
  b = (b << 30) | (b >> 2);
#line 93
  tmp___0 = (((block->l[1] << 24) | (block->l[1] >> 8)) & 4278255360U) | (((block->l[1] << 8) | (block->l[1] >> 24)) & 16711935U);
#line 93
  block->l[1] = tmp___0;
#line 93
  d += ((((a & (b ^ c)) ^ c) + tmp___0) + 1518500249U) + ((e << 5) | (e >> 27));
#line 93
  a = (a << 30) | (a >> 2);
#line 93
  tmp___1 = (((block->l[2] << 24) | (block->l[2] >> 8)) & 4278255360U) | (((block->l[2] << 8) | (block->l[2] >> 24)) & 16711935U);
#line 93
  block->l[2] = tmp___1;
#line 93
  c += ((((e & (a ^ b)) ^ b) + tmp___1) + 1518500249U) + ((d << 5) | (d >> 27));
#line 93
  e = (e << 30) | (e >> 2);
#line 93
  tmp___2 = (((block->l[3] << 24) | (block->l[3] >> 8)) & 4278255360U) | (((block->l[3] << 8) | (block->l[3] >> 24)) & 16711935U);
#line 93
  block->l[3] = tmp___2;
#line 93
  b += ((((d & (e ^ a)) ^ a) + tmp___2) + 1518500249U) + ((c << 5) | (c >> 27));
#line 93
  d = (d << 30) | (d >> 2);
#line 94
  tmp___3 = (((block->l[4] << 24) | (block->l[4] >> 8)) & 4278255360U) | (((block->l[4] << 8) | (block->l[4] >> 24)) & 16711935U);
#line 94
  block->l[4] = tmp___3;
#line 94
  a += ((((c & (d ^ e)) ^ e) + tmp___3) + 1518500249U) + ((b << 5) | (b >> 27));
#line 94
  c = (c << 30) | (c >> 2);
#line 94
  tmp___4 = (((block->l[5] << 24) | (block->l[5] >> 8)) & 4278255360U) | (((block->l[5] << 8) | (block->l[5] >> 24)) & 16711935U);
#line 94
  block->l[5] = tmp___4;
#line 94
  e += ((((b & (c ^ d)) ^ d) + tmp___4) + 1518500249U) + ((a << 5) | (a >> 27));
#line 94
  b = (b << 30) | (b >> 2);
#line 94
  tmp___5 = (((block->l[6] << 24) | (block->l[6] >> 8)) & 4278255360U) | (((block->l[6] << 8) | (block->l[6] >> 24)) & 16711935U);
#line 94
  block->l[6] = tmp___5;
#line 94
  d += ((((a & (b ^ c)) ^ c) + tmp___5) + 1518500249U) + ((e << 5) | (e >> 27));
#line 94
  a = (a << 30) | (a >> 2);
#line 94
  tmp___6 = (((block->l[7] << 24) | (block->l[7] >> 8)) & 4278255360U) | (((block->l[7] << 8) | (block->l[7] >> 24)) & 16711935U);
#line 94
  block->l[7] = tmp___6;
#line 94
  c += ((((e & (a ^ b)) ^ b) + tmp___6) + 1518500249U) + ((d << 5) | (d >> 27));
#line 94
  e = (e << 30) | (e >> 2);
#line 95
  tmp___7 = (((block->l[8] << 24) | (block->l[8] >> 8)) & 4278255360U) | (((block->l[8] << 8) | (block->l[8] >> 24)) & 16711935U);
#line 95
  block->l[8] = tmp___7;
#line 95
  b += ((((d & (e ^ a)) ^ a) + tmp___7) + 1518500249U) + ((c << 5) | (c >> 27));
#line 95
  d = (d << 30) | (d >> 2);
#line 95
  tmp___8 = (((block->l[9] << 24) | (block->l[9] >> 8)) & 4278255360U) | (((block->l[9] << 8) | (block->l[9] >> 24)) & 16711935U);
#line 95
  block->l[9] = tmp___8;
#line 95
  a += ((((c & (d ^ e)) ^ e) + tmp___8) + 1518500249U) + ((b << 5) | (b >> 27));
#line 95
  c = (c << 30) | (c >> 2);
#line 95
  tmp___9 = (((block->l[10] << 24) | (block->l[10] >> 8)) & 4278255360U) | (((block->l[10] << 8) | (block->l[10] >> 24)) & 16711935U);
#line 95
  block->l[10] = tmp___9;
#line 95
  e += ((((b & (c ^ d)) ^ d) + tmp___9) + 1518500249U) + ((a << 5) | (a >> 27));
#line 95
  b = (b << 30) | (b >> 2);
#line 95
  tmp___10 = (((block->l[11] << 24) | (block->l[11] >> 8)) & 4278255360U) | (((block->l[11] << 8) | (block->l[11] >> 24)) & 16711935U);
#line 95
  block->l[11] = tmp___10;
#line 95
  d += ((((a & (b ^ c)) ^ c) + tmp___10) + 1518500249U) + ((e << 5) | (e >> 27));
#line 95
  a = (a << 30) | (a >> 2);
#line 96
  tmp___11 = (((block->l[12] << 24) | (block->l[12] >> 8)) & 4278255360U) | (((block->l[12] << 8) | (block->l[12] >> 24)) & 16711935U);
#line 96
  block->l[12] = tmp___11;
#line 96
  c += ((((e & (a ^ b)) ^ b) + tmp___11) + 1518500249U) + ((d << 5) | (d >> 27));
#line 96
  e = (e << 30) | (e >> 2);
#line 96
  tmp___12 = (((block->l[13] << 24) | (block->l[13] >> 8)) & 4278255360U) | (((block->l[13] << 8) | (block->l[13] >> 24)) & 16711935U);
#line 96
  block->l[13] = tmp___12;
#line 96
  b += ((((d & (e ^ a)) ^ a) + tmp___12) + 1518500249U) + ((c << 5) | (c >> 27));
#line 96
  d = (d << 30) | (d >> 2);
#line 96
  tmp___13 = (((block->l[14] << 24) | (block->l[14] >> 8)) & 4278255360U) | (((block->l[14] << 8) | (block->l[14] >> 24)) & 16711935U);
#line 96
  block->l[14] = tmp___13;
#line 96
  a += ((((c & (d ^ e)) ^ e) + tmp___13) + 1518500249U) + ((b << 5) | (b >> 27));
#line 96
  c = (c << 30) | (c >> 2);
#line 96
  tmp___14 = (((block->l[15] << 24) | (block->l[15] >> 8)) & 4278255360U) | (((block->l[15] << 8) | (block->l[15] >> 24)) & 16711935U);
#line 96
  block->l[15] = tmp___14;
#line 96
  e += ((((b & (c ^ d)) ^ d) + tmp___14) + 1518500249U) + ((a << 5) | (a >> 27));
#line 96
  b = (b << 30) | (b >> 2);
#line 97
  tmp___15 = ((((block->l[13] ^ block->l[8]) ^ block->l[2]) ^ block->l[0]) << 1) | ((((block->l[13] ^ block->l[8]) ^ block->l[2]) ^ block->l[0]) >> 31);
#line 97
  block->l[0] = tmp___15;
#line 97
  d += ((((a & (b ^ c)) ^ c) + tmp___15) + 1518500249U) + ((e << 5) | (e >> 27));
#line 97
  a = (a << 30) | (a >> 2);
#line 97
  tmp___16 = ((((block->l[14] ^ block->l[9]) ^ block->l[3]) ^ block->l[1]) << 1) | ((((block->l[14] ^ block->l[9]) ^ block->l[3]) ^ block->l[1]) >> 31);
#line 97
  block->l[1] = tmp___16;
#line 97
  c += ((((e & (a ^ b)) ^ b) + tmp___16) + 1518500249U) + ((d << 5) | (d >> 27));
#line 97
  e = (e << 30) | (e >> 2);
#line 97
  tmp___17 = ((((block->l[15] ^ block->l[10]) ^ block->l[4]) ^ block->l[2]) << 1) | ((((block->l[15] ^ block->l[10]) ^ block->l[4]) ^ block->l[2]) >> 31);
#line 97
  block->l[2] = tmp___17;
#line 97
  b += ((((d & (e ^ a)) ^ a) + tmp___17) + 1518500249U) + ((c << 5) | (c >> 27));
#line 97
  d = (d << 30) | (d >> 2);
#line 97
  tmp___18 = ((((block->l[0] ^ block->l[11]) ^ block->l[5]) ^ block->l[3]) << 1) | ((((block->l[0] ^ block->l[11]) ^ block->l[5]) ^ block->l[3]) >> 31);
#line 97
  block->l[3] = tmp___18;
#line 97
  a += ((((c & (d ^ e)) ^ e) + tmp___18) + 1518500249U) + ((b << 5) | (b >> 27));
#line 97
  c = (c << 30) | (c >> 2);
#line 98
  tmp___19 = ((((block->l[1] ^ block->l[12]) ^ block->l[6]) ^ block->l[4]) << 1) | ((((block->l[1] ^ block->l[12]) ^ block->l[6]) ^ block->l[4]) >> 31);
#line 98
  block->l[4] = tmp___19;
#line 98
  e += ((((b ^ c) ^ d) + tmp___19) + 1859775393U) + ((a << 5) | (a >> 27));
#line 98
  b = (b << 30) | (b >> 2);
#line 98
  tmp___20 = ((((block->l[2] ^ block->l[13]) ^ block->l[7]) ^ block->l[5]) << 1) | ((((block->l[2] ^ block->l[13]) ^ block->l[7]) ^ block->l[5]) >> 31);
#line 98
  block->l[5] = tmp___20;
#line 98
  d += ((((a ^ b) ^ c) + tmp___20) + 1859775393U) + ((e << 5) | (e >> 27));
#line 98
  a = (a << 30) | (a >> 2);
#line 98
  tmp___21 = ((((block->l[3] ^ block->l[14]) ^ block->l[8]) ^ block->l[6]) << 1) | ((((block->l[3] ^ block->l[14]) ^ block->l[8]) ^ block->l[6]) >> 31);
#line 98
  block->l[6] = tmp___21;
#line 98
  c += ((((e ^ a) ^ b) + tmp___21) + 1859775393U) + ((d << 5) | (d >> 27));
#line 98
  e = (e << 30) | (e >> 2);
#line 98
  tmp___22 = ((((block->l[4] ^ block->l[15]) ^ block->l[9]) ^ block->l[7]) << 1) | ((((block->l[4] ^ block->l[15]) ^ block->l[9]) ^ block->l[7]) >> 31);
#line 98
  block->l[7] = tmp___22;
#line 98
  b += ((((d ^ e) ^ a) + tmp___22) + 1859775393U) + ((c << 5) | (c >> 27));
#line 98
  d = (d << 30) | (d >> 2);
#line 99
  tmp___23 = ((((block->l[5] ^ block->l[0]) ^ block->l[10]) ^ block->l[8]) << 1) | ((((block->l[5] ^ block->l[0]) ^ block->l[10]) ^ block->l[8]) >> 31);
#line 99
  block->l[8] = tmp___23;
#line 99
  a += ((((c ^ d) ^ e) + tmp___23) + 1859775393U) + ((b << 5) | (b >> 27));
#line 99
  c = (c << 30) | (c >> 2);
#line 99
  tmp___24 = ((((block->l[6] ^ block->l[1]) ^ block->l[11]) ^ block->l[9]) << 1) | ((((block->l[6] ^ block->l[1]) ^ block->l[11]) ^ block->l[9]) >> 31);
#line 99
  block->l[9] = tmp___24;
#line 99
  e += ((((b ^ c) ^ d) + tmp___24) + 1859775393U) + ((a << 5) | (a >> 27));
#line 99
  b = (b << 30) | (b >> 2);
#line 99
  tmp___25 = ((((block->l[7] ^ block->l[2]) ^ block->l[12]) ^ block->l[10]) << 1) | ((((block->l[7] ^ block->l[2]) ^ block->l[12]) ^ block->l[10]) >> 31);
#line 99
  block->l[10] = tmp___25;
#line 99
  d += ((((a ^ b) ^ c) + tmp___25) + 1859775393U) + ((e << 5) | (e >> 27));
#line 99
  a = (a << 30) | (a >> 2);
#line 99
  tmp___26 = ((((block->l[8] ^ block->l[3]) ^ block->l[13]) ^ block->l[11]) << 1) | ((((block->l[8] ^ block->l[3]) ^ block->l[13]) ^ block->l[11]) >> 31);
#line 99
  block->l[11] = tmp___26;
#line 99
  c += ((((e ^ a) ^ b) + tmp___26) + 1859775393U) + ((d << 5) | (d >> 27));
#line 99
  e = (e << 30) | (e >> 2);
#line 100
  tmp___27 = ((((block->l[9] ^ block->l[4]) ^ block->l[14]) ^ block->l[12]) << 1) | ((((block->l[9] ^ block->l[4]) ^ block->l[14]) ^ block->l[12]) >> 31);
#line 100
  block->l[12] = tmp___27;
#line 100
  b += ((((d ^ e) ^ a) + tmp___27) + 1859775393U) + ((c << 5) | (c >> 27));
#line 100
  d = (d << 30) | (d >> 2);
#line 100
  tmp___28 = ((((block->l[10] ^ block->l[5]) ^ block->l[15]) ^ block->l[13]) << 1) | ((((block->l[10] ^ block->l[5]) ^ block->l[15]) ^ block->l[13]) >> 31);
#line 100
  block->l[13] = tmp___28;
#line 100
  a += ((((c ^ d) ^ e) + tmp___28) + 1859775393U) + ((b << 5) | (b >> 27));
#line 100
  c = (c << 30) | (c >> 2);
#line 100
  tmp___29 = ((((block->l[11] ^ block->l[6]) ^ block->l[0]) ^ block->l[14]) << 1) | ((((block->l[11] ^ block->l[6]) ^ block->l[0]) ^ block->l[14]) >> 31);
#line 100
  block->l[14] = tmp___29;
#line 100
  e += ((((b ^ c) ^ d) + tmp___29) + 1859775393U) + ((a << 5) | (a >> 27));
#line 100
  b = (b << 30) | (b >> 2);
#line 100
  tmp___30 = ((((block->l[12] ^ block->l[7]) ^ block->l[1]) ^ block->l[15]) << 1) | ((((block->l[12] ^ block->l[7]) ^ block->l[1]) ^ block->l[15]) >> 31);
#line 100
  block->l[15] = tmp___30;
#line 100
  d += ((((a ^ b) ^ c) + tmp___30) + 1859775393U) + ((e << 5) | (e >> 27));
#line 100
  a = (a << 30) | (a >> 2);
#line 101
  tmp___31 = ((((block->l[13] ^ block->l[8]) ^ block->l[2]) ^ block->l[0]) << 1) | ((((block->l[13] ^ block->l[8]) ^ block->l[2]) ^ block->l[0]) >> 31);
#line 101
  block->l[0] = tmp___31;
#line 101
  c += ((((e ^ a) ^ b) + tmp___31) + 1859775393U) + ((d << 5) | (d >> 27));
#line 101
  e = (e << 30) | (e >> 2);
#line 101
  tmp___32 = ((((block->l[14] ^ block->l[9]) ^ block->l[3]) ^ block->l[1]) << 1) | ((((block->l[14] ^ block->l[9]) ^ block->l[3]) ^ block->l[1]) >> 31);
#line 101
  block->l[1] = tmp___32;
#line 101
  b += ((((d ^ e) ^ a) + tmp___32) + 1859775393U) + ((c << 5) | (c >> 27));
#line 101
  d = (d << 30) | (d >> 2);
#line 101
  tmp___33 = ((((block->l[15] ^ block->l[10]) ^ block->l[4]) ^ block->l[2]) << 1) | ((((block->l[15] ^ block->l[10]) ^ block->l[4]) ^ block->l[2]) >> 31);
#line 101
  block->l[2] = tmp___33;
#line 101
  a += ((((c ^ d) ^ e) + tmp___33) + 1859775393U) + ((b << 5) | (b >> 27));
#line 101
  c = (c << 30) | (c >> 2);
#line 101
  tmp___34 = ((((block->l[0] ^ block->l[11]) ^ block->l[5]) ^ block->l[3]) << 1) | ((((block->l[0] ^ block->l[11]) ^ block->l[5]) ^ block->l[3]) >> 31);
#line 101
  block->l[3] = tmp___34;
#line 101
  e += ((((b ^ c) ^ d) + tmp___34) + 1859775393U) + ((a << 5) | (a >> 27));
#line 101
  b = (b << 30) | (b >> 2);
#line 102
  tmp___35 = ((((block->l[1] ^ block->l[12]) ^ block->l[6]) ^ block->l[4]) << 1) | ((((block->l[1] ^ block->l[12]) ^ block->l[6]) ^ block->l[4]) >> 31);
#line 102
  block->l[4] = tmp___35;
#line 102
  d += ((((a ^ b) ^ c) + tmp___35) + 1859775393U) + ((e << 5) | (e >> 27));
#line 102
  a = (a << 30) | (a >> 2);
#line 102
  tmp___36 = ((((block->l[2] ^ block->l[13]) ^ block->l[7]) ^ block->l[5]) << 1) | ((((block->l[2] ^ block->l[13]) ^ block->l[7]) ^ block->l[5]) >> 31);
#line 102
  block->l[5] = tmp___36;
#line 102
  c += ((((e ^ a) ^ b) + tmp___36) + 1859775393U) + ((d << 5) | (d >> 27));
#line 102
  e = (e << 30) | (e >> 2);
#line 102
  tmp___37 = ((((block->l[3] ^ block->l[14]) ^ block->l[8]) ^ block->l[6]) << 1) | ((((block->l[3] ^ block->l[14]) ^ block->l[8]) ^ block->l[6]) >> 31);
#line 102
  block->l[6] = tmp___37;
#line 102
  b += ((((d ^ e) ^ a) + tmp___37) + 1859775393U) + ((c << 5) | (c >> 27));
#line 102
  d = (d << 30) | (d >> 2);
#line 102
  tmp___38 = ((((block->l[4] ^ block->l[15]) ^ block->l[9]) ^ block->l[7]) << 1) | ((((block->l[4] ^ block->l[15]) ^ block->l[9]) ^ block->l[7]) >> 31);
#line 102
  block->l[7] = tmp___38;
#line 102
  a += ((((c ^ d) ^ e) + tmp___38) + 1859775393U) + ((b << 5) | (b >> 27));
#line 102
  c = (c << 30) | (c >> 2);
#line 103
  tmp___39 = ((((block->l[5] ^ block->l[0]) ^ block->l[10]) ^ block->l[8]) << 1) | ((((block->l[5] ^ block->l[0]) ^ block->l[10]) ^ block->l[8]) >> 31);
#line 103
  block->l[8] = tmp___39;
#line 103
  e += (((((b | c) & d) | (b & c)) + tmp___39) + 2400959708U) + ((a << 5) | (a >> 27));
#line 103
  b = (b << 30) | (b >> 2);
#line 103
  tmp___40 = ((((block->l[6] ^ block->l[1]) ^ block->l[11]) ^ block->l[9]) << 1) | ((((block->l[6] ^ block->l[1]) ^ block->l[11]) ^ block->l[9]) >> 31);
#line 103
  block->l[9] = tmp___40;
#line 103
  d += (((((a | b) & c) | (a & b)) + tmp___40) + 2400959708U) + ((e << 5) | (e >> 27));
#line 103
  a = (a << 30) | (a >> 2);
#line 103
  tmp___41 = ((((block->l[7] ^ block->l[2]) ^ block->l[12]) ^ block->l[10]) << 1) | ((((block->l[7] ^ block->l[2]) ^ block->l[12]) ^ block->l[10]) >> 31);
#line 103
  block->l[10] = tmp___41;
#line 103
  c += (((((e | a) & b) | (e & a)) + tmp___41) + 2400959708U) + ((d << 5) | (d >> 27));
#line 103
  e = (e << 30) | (e >> 2);
#line 103
  tmp___42 = ((((block->l[8] ^ block->l[3]) ^ block->l[13]) ^ block->l[11]) << 1) | ((((block->l[8] ^ block->l[3]) ^ block->l[13]) ^ block->l[11]) >> 31);
#line 103
  block->l[11] = tmp___42;
#line 103
  b += (((((d | e) & a) | (d & e)) + tmp___42) + 2400959708U) + ((c << 5) | (c >> 27));
#line 103
  d = (d << 30) | (d >> 2);
#line 104
  tmp___43 = ((((block->l[9] ^ block->l[4]) ^ block->l[14]) ^ block->l[12]) << 1) | ((((block->l[9] ^ block->l[4]) ^ block->l[14]) ^ block->l[12]) >> 31);
#line 104
  block->l[12] = tmp___43;
#line 104
  a += (((((c | d) & e) | (c & d)) + tmp___43) + 2400959708U) + ((b << 5) | (b >> 27));
#line 104
  c = (c << 30) | (c >> 2);
#line 104
  tmp___44 = ((((block->l[10] ^ block->l[5]) ^ block->l[15]) ^ block->l[13]) << 1) | ((((block->l[10] ^ block->l[5]) ^ block->l[15]) ^ block->l[13]) >> 31);
#line 104
  block->l[13] = tmp___44;
#line 104
  e += (((((b | c) & d) | (b & c)) + tmp___44) + 2400959708U) + ((a << 5) | (a >> 27));
#line 104
  b = (b << 30) | (b >> 2);
#line 104
  tmp___45 = ((((block->l[11] ^ block->l[6]) ^ block->l[0]) ^ block->l[14]) << 1) | ((((block->l[11] ^ block->l[6]) ^ block->l[0]) ^ block->l[14]) >> 31);
#line 104
  block->l[14] = tmp___45;
#line 104
  d += (((((a | b) & c) | (a & b)) + tmp___45) + 2400959708U) + ((e << 5) | (e >> 27));
#line 104
  a = (a << 30) | (a >> 2);
#line 104
  tmp___46 = ((((block->l[12] ^ block->l[7]) ^ block->l[1]) ^ block->l[15]) << 1) | ((((block->l[12] ^ block->l[7]) ^ block->l[1]) ^ block->l[15]) >> 31);
#line 104
  block->l[15] = tmp___46;
#line 104
  c += (((((e | a) & b) | (e & a)) + tmp___46) + 2400959708U) + ((d << 5) | (d >> 27));
#line 104
  e = (e << 30) | (e >> 2);
#line 105
  tmp___47 = ((((block->l[13] ^ block->l[8]) ^ block->l[2]) ^ block->l[0]) << 1) | ((((block->l[13] ^ block->l[8]) ^ block->l[2]) ^ block->l[0]) >> 31);
#line 105
  block->l[0] = tmp___47;
#line 105
  b += (((((d | e) & a) | (d & e)) + tmp___47) + 2400959708U) + ((c << 5) | (c >> 27));
#line 105
  d = (d << 30) | (d >> 2);
#line 105
  tmp___48 = ((((block->l[14] ^ block->l[9]) ^ block->l[3]) ^ block->l[1]) << 1) | ((((block->l[14] ^ block->l[9]) ^ block->l[3]) ^ block->l[1]) >> 31);
#line 105
  block->l[1] = tmp___48;
#line 105
  a += (((((c | d) & e) | (c & d)) + tmp___48) + 2400959708U) + ((b << 5) | (b >> 27));
#line 105
  c = (c << 30) | (c >> 2);
#line 105
  tmp___49 = ((((block->l[15] ^ block->l[10]) ^ block->l[4]) ^ block->l[2]) << 1) | ((((block->l[15] ^ block->l[10]) ^ block->l[4]) ^ block->l[2]) >> 31);
#line 105
  block->l[2] = tmp___49;
#line 105
  e += (((((b | c) & d) | (b & c)) + tmp___49) + 2400959708U) + ((a << 5) | (a >> 27));
#line 105
  b = (b << 30) | (b >> 2);
#line 105
  tmp___50 = ((((block->l[0] ^ block->l[11]) ^ block->l[5]) ^ block->l[3]) << 1) | ((((block->l[0] ^ block->l[11]) ^ block->l[5]) ^ block->l[3]) >> 31);
#line 105
  block->l[3] = tmp___50;
#line 105
  d += (((((a | b) & c) | (a & b)) + tmp___50) + 2400959708U) + ((e << 5) | (e >> 27));
#line 105
  a = (a << 30) | (a >> 2);
#line 106
  tmp___51 = ((((block->l[1] ^ block->l[12]) ^ block->l[6]) ^ block->l[4]) << 1) | ((((block->l[1] ^ block->l[12]) ^ block->l[6]) ^ block->l[4]) >> 31);
#line 106
  block->l[4] = tmp___51;
#line 106
  c += (((((e | a) & b) | (e & a)) + tmp___51) + 2400959708U) + ((d << 5) | (d >> 27));
#line 106
  e = (e << 30) | (e >> 2);
#line 106
  tmp___52 = ((((block->l[2] ^ block->l[13]) ^ block->l[7]) ^ block->l[5]) << 1) | ((((block->l[2] ^ block->l[13]) ^ block->l[7]) ^ block->l[5]) >> 31);
#line 106
  block->l[5] = tmp___52;
#line 106
  b += (((((d | e) & a) | (d & e)) + tmp___52) + 2400959708U) + ((c << 5) | (c >> 27));
#line 106
  d = (d << 30) | (d >> 2);
#line 106
  tmp___53 = ((((block->l[3] ^ block->l[14]) ^ block->l[8]) ^ block->l[6]) << 1) | ((((block->l[3] ^ block->l[14]) ^ block->l[8]) ^ block->l[6]) >> 31);
#line 106
  block->l[6] = tmp___53;
#line 106
  a += (((((c | d) & e) | (c & d)) + tmp___53) + 2400959708U) + ((b << 5) | (b >> 27));
#line 106
  c = (c << 30) | (c >> 2);
#line 106
  tmp___54 = ((((block->l[4] ^ block->l[15]) ^ block->l[9]) ^ block->l[7]) << 1) | ((((block->l[4] ^ block->l[15]) ^ block->l[9]) ^ block->l[7]) >> 31);
#line 106
  block->l[7] = tmp___54;
#line 106
  e += (((((b | c) & d) | (b & c)) + tmp___54) + 2400959708U) + ((a << 5) | (a >> 27));
#line 106
  b = (b << 30) | (b >> 2);
#line 107
  tmp___55 = ((((block->l[5] ^ block->l[0]) ^ block->l[10]) ^ block->l[8]) << 1) | ((((block->l[5] ^ block->l[0]) ^ block->l[10]) ^ block->l[8]) >> 31);
#line 107
  block->l[8] = tmp___55;
#line 107
  d += (((((a | b) & c) | (a & b)) + tmp___55) + 2400959708U) + ((e << 5) | (e >> 27));
#line 107
  a = (a << 30) | (a >> 2);
#line 107
  tmp___56 = ((((block->l[6] ^ block->l[1]) ^ block->l[11]) ^ block->l[9]) << 1) | ((((block->l[6] ^ block->l[1]) ^ block->l[11]) ^ block->l[9]) >> 31);
#line 107
  block->l[9] = tmp___56;
#line 107
  c += (((((e | a) & b) | (e & a)) + tmp___56) + 2400959708U) + ((d << 5) | (d >> 27));
#line 107
  e = (e << 30) | (e >> 2);
#line 107
  tmp___57 = ((((block->l[7] ^ block->l[2]) ^ block->l[12]) ^ block->l[10]) << 1) | ((((block->l[7] ^ block->l[2]) ^ block->l[12]) ^ block->l[10]) >> 31);
#line 107
  block->l[10] = tmp___57;
#line 107
  b += (((((d | e) & a) | (d & e)) + tmp___57) + 2400959708U) + ((c << 5) | (c >> 27));
#line 107
  d = (d << 30) | (d >> 2);
#line 107
  tmp___58 = ((((block->l[8] ^ block->l[3]) ^ block->l[13]) ^ block->l[11]) << 1) | ((((block->l[8] ^ block->l[3]) ^ block->l[13]) ^ block->l[11]) >> 31);
#line 107
  block->l[11] = tmp___58;
#line 107
  a += (((((c | d) & e) | (c & d)) + tmp___58) + 2400959708U) + ((b << 5) | (b >> 27));
#line 107
  c = (c << 30) | (c >> 2);
#line 108
  tmp___59 = ((((block->l[9] ^ block->l[4]) ^ block->l[14]) ^ block->l[12]) << 1) | ((((block->l[9] ^ block->l[4]) ^ block->l[14]) ^ block->l[12]) >> 31);
#line 108
  block->l[12] = tmp___59;
#line 108
  e += ((((b ^ c) ^ d) + tmp___59) + 3395469782U) + ((a << 5) | (a >> 27));
#line 108
  b = (b << 30) | (b >> 2);
#line 108
  tmp___60 = ((((block->l[10] ^ block->l[5]) ^ block->l[15]) ^ block->l[13]) << 1) | ((((block->l[10] ^ block->l[5]) ^ block->l[15]) ^ block->l[13]) >> 31);
#line 108
  block->l[13] = tmp___60;
#line 108
  d += ((((a ^ b) ^ c) + tmp___60) + 3395469782U) + ((e << 5) | (e >> 27));
#line 108
  a = (a << 30) | (a >> 2);
#line 108
  tmp___61 = ((((block->l[11] ^ block->l[6]) ^ block->l[0]) ^ block->l[14]) << 1) | ((((block->l[11] ^ block->l[6]) ^ block->l[0]) ^ block->l[14]) >> 31);
#line 108
  block->l[14] = tmp___61;
#line 108
  c += ((((e ^ a) ^ b) + tmp___61) + 3395469782U) + ((d << 5) | (d >> 27));
#line 108
  e = (e << 30) | (e >> 2);
#line 108
  tmp___62 = ((((block->l[12] ^ block->l[7]) ^ block->l[1]) ^ block->l[15]) << 1) | ((((block->l[12] ^ block->l[7]) ^ block->l[1]) ^ block->l[15]) >> 31);
#line 108
  block->l[15] = tmp___62;
#line 108
  b += ((((d ^ e) ^ a) + tmp___62) + 3395469782U) + ((c << 5) | (c >> 27));
#line 108
  d = (d << 30) | (d >> 2);
#line 109
  tmp___63 = ((((block->l[13] ^ block->l[8]) ^ block->l[2]) ^ block->l[0]) << 1) | ((((block->l[13] ^ block->l[8]) ^ block->l[2]) ^ block->l[0]) >> 31);
#line 109
  block->l[0] = tmp___63;
#line 109
  a += ((((c ^ d) ^ e) + tmp___63) + 3395469782U) + ((b << 5) | (b >> 27));
#line 109
  c = (c << 30) | (c >> 2);
#line 109
  tmp___64 = ((((block->l[14] ^ block->l[9]) ^ block->l[3]) ^ block->l[1]) << 1) | ((((block->l[14] ^ block->l[9]) ^ block->l[3]) ^ block->l[1]) >> 31);
#line 109
  block->l[1] = tmp___64;
#line 109
  e += ((((b ^ c) ^ d) + tmp___64) + 3395469782U) + ((a << 5) | (a >> 27));
#line 109
  b = (b << 30) | (b >> 2);
#line 109
  tmp___65 = ((((block->l[15] ^ block->l[10]) ^ block->l[4]) ^ block->l[2]) << 1) | ((((block->l[15] ^ block->l[10]) ^ block->l[4]) ^ block->l[2]) >> 31);
#line 109
  block->l[2] = tmp___65;
#line 109
  d += ((((a ^ b) ^ c) + tmp___65) + 3395469782U) + ((e << 5) | (e >> 27));
#line 109
  a = (a << 30) | (a >> 2);
#line 109
  tmp___66 = ((((block->l[0] ^ block->l[11]) ^ block->l[5]) ^ block->l[3]) << 1) | ((((block->l[0] ^ block->l[11]) ^ block->l[5]) ^ block->l[3]) >> 31);
#line 109
  block->l[3] = tmp___66;
#line 109
  c += ((((e ^ a) ^ b) + tmp___66) + 3395469782U) + ((d << 5) | (d >> 27));
#line 109
  e = (e << 30) | (e >> 2);
#line 110
  tmp___67 = ((((block->l[1] ^ block->l[12]) ^ block->l[6]) ^ block->l[4]) << 1) | ((((block->l[1] ^ block->l[12]) ^ block->l[6]) ^ block->l[4]) >> 31);
#line 110
  block->l[4] = tmp___67;
#line 110
  b += ((((d ^ e) ^ a) + tmp___67) + 3395469782U) + ((c << 5) | (c >> 27));
#line 110
  d = (d << 30) | (d >> 2);
#line 110
  tmp___68 = ((((block->l[2] ^ block->l[13]) ^ block->l[7]) ^ block->l[5]) << 1) | ((((block->l[2] ^ block->l[13]) ^ block->l[7]) ^ block->l[5]) >> 31);
#line 110
  block->l[5] = tmp___68;
#line 110
  a += ((((c ^ d) ^ e) + tmp___68) + 3395469782U) + ((b << 5) | (b >> 27));
#line 110
  c = (c << 30) | (c >> 2);
#line 110
  tmp___69 = ((((block->l[3] ^ block->l[14]) ^ block->l[8]) ^ block->l[6]) << 1) | ((((block->l[3] ^ block->l[14]) ^ block->l[8]) ^ block->l[6]) >> 31);
#line 110
  block->l[6] = tmp___69;
#line 110
  e += ((((b ^ c) ^ d) + tmp___69) + 3395469782U) + ((a << 5) | (a >> 27));
#line 110
  b = (b << 30) | (b >> 2);
#line 110
  tmp___70 = ((((block->l[4] ^ block->l[15]) ^ block->l[9]) ^ block->l[7]) << 1) | ((((block->l[4] ^ block->l[15]) ^ block->l[9]) ^ block->l[7]) >> 31);
#line 110
  block->l[7] = tmp___70;
#line 110
  d += ((((a ^ b) ^ c) + tmp___70) + 3395469782U) + ((e << 5) | (e >> 27));
#line 110
  a = (a << 30) | (a >> 2);
#line 111
  tmp___71 = ((((block->l[5] ^ block->l[0]) ^ block->l[10]) ^ block->l[8]) << 1) | ((((block->l[5] ^ block->l[0]) ^ block->l[10]) ^ block->l[8]) >> 31);
#line 111
  block->l[8] = tmp___71;
#line 111
  c += ((((e ^ a) ^ b) + tmp___71) + 3395469782U) + ((d << 5) | (d >> 27));
#line 111
  e = (e << 30) | (e >> 2);
#line 111
  tmp___72 = ((((block->l[6] ^ block->l[1]) ^ block->l[11]) ^ block->l[9]) << 1) | ((((block->l[6] ^ block->l[1]) ^ block->l[11]) ^ block->l[9]) >> 31);
#line 111
  block->l[9] = tmp___72;
#line 111
  b += ((((d ^ e) ^ a) + tmp___72) + 3395469782U) + ((c << 5) | (c >> 27));
#line 111
  d = (d << 30) | (d >> 2);
#line 111
  tmp___73 = ((((block->l[7] ^ block->l[2]) ^ block->l[12]) ^ block->l[10]) << 1) | ((((block->l[7] ^ block->l[2]) ^ block->l[12]) ^ block->l[10]) >> 31);
#line 111
  block->l[10] = tmp___73;
#line 111
  a += ((((c ^ d) ^ e) + tmp___73) + 3395469782U) + ((b << 5) | (b >> 27));
#line 111
  c = (c << 30) | (c >> 2);
#line 111
  tmp___74 = ((((block->l[8] ^ block->l[3]) ^ block->l[13]) ^ block->l[11]) << 1) | ((((block->l[8] ^ block->l[3]) ^ block->l[13]) ^ block->l[11]) >> 31);
#line 111
  block->l[11] = tmp___74;
#line 111
  e += ((((b ^ c) ^ d) + tmp___74) + 3395469782U) + ((a << 5) | (a >> 27));
#line 111
  b = (b << 30) | (b >> 2);
#line 112
  tmp___75 = ((((block->l[9] ^ block->l[4]) ^ block->l[14]) ^ block->l[12]) << 1) | ((((block->l[9] ^ block->l[4]) ^ block->l[14]) ^ block->l[12]) >> 31);
#line 112
  block->l[12] = tmp___75;
#line 112
  d += ((((a ^ b) ^ c) + tmp___75) + 3395469782U) + ((e << 5) | (e >> 27));
#line 112
  a = (a << 30) | (a >> 2);
#line 112
  tmp___76 = ((((block->l[10] ^ block->l[5]) ^ block->l[15]) ^ block->l[13]) << 1) | ((((block->l[10] ^ block->l[5]) ^ block->l[15]) ^ block->l[13]) >> 31);
#line 112
  block->l[13] = tmp___76;
#line 112
  c += ((((e ^ a) ^ b) + tmp___76) + 3395469782U) + ((d << 5) | (d >> 27));
#line 112
  e = (e << 30) | (e >> 2);
#line 112
  tmp___77 = ((((block->l[11] ^ block->l[6]) ^ block->l[0]) ^ block->l[14]) << 1) | ((((block->l[11] ^ block->l[6]) ^ block->l[0]) ^ block->l[14]) >> 31);
#line 112
  block->l[14] = tmp___77;
#line 112
  b += ((((d ^ e) ^ a) + tmp___77) + 3395469782U) + ((c << 5) | (c >> 27));
#line 112
  d = (d << 30) | (d >> 2);
#line 112
  tmp___78 = ((((block->l[12] ^ block->l[7]) ^ block->l[1]) ^ block->l[15]) << 1) | ((((block->l[12] ^ block->l[7]) ^ block->l[1]) ^ block->l[15]) >> 31);
#line 112
  block->l[15] = tmp___78;
#line 112
  a += ((((c ^ d) ^ e) + tmp___78) + 3395469782U) + ((b << 5) | (b >> 27));
#line 112
  c = (c << 30) | (c >> 2);
#line 115
  *(state + 0) += a;
#line 116
  *(state + 1) += b;
#line 117
  *(state + 2) += c;
#line 118
  *(state + 3) += d;
#line 119
  *(state + 4) += e;
#line 124
  return;
}
}
#line 127 "/home/wheatley/newnew/temp/mktorrent-1.0/sha1.c"
void SHA1_Init(SHA_CTX *context ) 
{ 
  uint32_t tmp ;

  {
#line 130
  context->state[0] = (uint32_t )1732584193;
#line 131
  context->state[1] = 4023233417U;
#line 132
  context->state[2] = 2562383102U;
#line 133
  context->state[3] = (uint32_t )271733878;
#line 134
  context->state[4] = 3285377520U;
#line 135
  tmp = (uint32_t )0;
#line 135
  context->count[1] = tmp;
#line 135
  context->count[0] = tmp;
#line 136
  return;
}
}
#line 139 "/home/wheatley/newnew/temp/mktorrent-1.0/sha1.c"
void SHA1_Update(SHA_CTX *context , uint8_t const   *data , unsigned long len ) 
{ 
  size_t i ;
  size_t j ;
  uint32_t tmp ;

  {
#line 146
  j = (size_t )((context->count[0] >> 3) & 63U);
#line 148
  tmp = (uint32_t )((unsigned long )context->count[0] + (len << 3));
#line 148
  context->count[0] = tmp;
#line 148
  if ((unsigned long )tmp < len << 3) {
#line 149
    (context->count[1]) ++;
  }
#line 151
  context->count[1] = (uint32_t )((unsigned long )context->count[1] + (len >> 29));
#line 153
  if (j + len > 63UL) {
    {
#line 154
    i = 64UL - j;
#line 154
    memcpy((void */* __restrict  */)(& context->buffer[j]), (void const   */* __restrict  */)data,
           i);
#line 155
    SHA1_Transform((uint32_t *)(context->state), (uint8_t const   *)(context->buffer));
    }
    {
#line 156
    while (1) {
      while_continue: /* CIL Label */ ;
#line 156
      if (! (i + 63UL < len)) {
#line 156
        goto while_break;
      }
      {
#line 157
      SHA1_Transform((uint32_t *)(context->state), (uint8_t const   *)(data + i));
#line 156
      i += 64UL;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 159
    j = (size_t )0;
  } else {
#line 161
    i = (size_t )0;
  }
  {
#line 163
  memcpy((void */* __restrict  */)(& context->buffer[j]), (void const   */* __restrict  */)(data + i),
         len - i);
  }
#line 168
  return;
}
}
#line 171 "/home/wheatley/newnew/temp/mktorrent-1.0/sha1.c"
void SHA1_Final(uint8_t *digest , SHA_CTX *context ) 
{ 
  uint32_t i ;
  uint8_t finalcount[8] ;
  int tmp ;

  {
#line 176
  i = (uint32_t )0;
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! (i < 8U)) {
#line 176
      goto while_break;
    }
#line 178
    if (i >= 4U) {
#line 178
      tmp = 0;
    } else {
#line 178
      tmp = 1;
    }
#line 178
    finalcount[i] = (uint8_t )((context->count[tmp] >> (3U - (i & 3U)) * 8U) & 255U);
#line 176
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 183
  SHA1_Update(context, (uint8_t const   *)((uint8_t *)"\200"), 1UL);
  }
  {
#line 184
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 184
    if (! ((context->count[0] & 504U) != 448U)) {
#line 184
      goto while_break___0;
    }
    {
#line 185
    SHA1_Update(context, (uint8_t const   *)((uint8_t *)"\000"), 1UL);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 187
  SHA1_Update(context, (uint8_t const   *)(finalcount), 8UL);
#line 188
  i = (uint32_t )0;
  }
  {
#line 188
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 188
    if (! (i < 20U)) {
#line 188
      goto while_break___1;
    }
#line 189
    *(digest + i) = (uint8_t )((context->state[i >> 2] >> (3U - (i & 3U)) * 8U) & 255U);
#line 188
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 204
  return;
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 511
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 8 "/home/wheatley/newnew/temp/mktorrent-1.0/ftw.h"
int file_tree_walk(char const   *dirname , unsigned int nfds , int (*callback)(char const   *name ,
                                                                               struct stat  const  *sbuf ,
                                                                               void *data ) ,
                   void *data ) ;
#line 43 "/home/wheatley/newnew/temp/mktorrent-1.0/init.c"
static void strip_ending_dirseps(char *s ) 
{ 
  char *end ;

  {
#line 45
  end = s;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (! *end) {
#line 47
      goto while_break;
    }
#line 48
    end ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 50
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 50
    if ((unsigned long )end > (unsigned long )s) {
#line 50
      end --;
#line 50
      if (! ((int )*end == 47)) {
#line 50
        goto while_break___0;
      }
    } else {
#line 50
      goto while_break___0;
    }
#line 51
    *end = (char )'\000';
  }
  while_break___0: /* CIL Label */ ;
  }
#line 52
  return;
}
}
#line 54 "/home/wheatley/newnew/temp/mktorrent-1.0/init.c"
static char const   *basename(char const   *s ) 
{ 
  char const   *r ;

  {
#line 56
  r = s;
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! ((int const   )*s != 0)) {
#line 58
      goto while_break;
    }
#line 59
    if ((int const   )*s == 47) {
#line 60
      s ++;
#line 60
      r = s;
    } else {
#line 62
      s ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 65
  return (r);
}
}
#line 68 "/home/wheatley/newnew/temp/mktorrent-1.0/init.c"
static void set_absolute_file_path(metafile_t *m ) 
{ 
  char *string ;
  size_t length ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;

  {
#line 71
  length = (size_t )32;
#line 75
  if (m->metainfo_file_path) {
#line 75
    if ((int )*(m->metainfo_file_path) == 47) {
#line 76
      return;
    }
  }
  {
#line 81
  tmp = malloc(length);
#line 81
  string = (char *)tmp;
  }
#line 82
  if ((unsigned long )string == (unsigned long )((void *)0)) {
    {
#line 83
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory.\n");
#line 84
    exit(1);
    }
  }
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 87
    tmp___1 = getcwd(string, length);
    }
#line 87
    if (! ((unsigned long )tmp___1 == (unsigned long )((void *)0))) {
#line 87
      goto while_break;
    }
    {
#line 89
    length *= 2UL;
#line 91
    free((void *)string);
#line 93
    tmp___0 = malloc(length);
#line 93
    string = (char *)tmp___0;
    }
#line 94
    if ((unsigned long )string == (unsigned long )((void *)0)) {
      {
#line 95
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory.\n");
#line 96
      exit(1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 101
  length = strlen((char const   *)string);
  }
#line 103
  if ((unsigned long )m->metainfo_file_path == (unsigned long )((void *)0)) {
    {
#line 105
    tmp___2 = strlen(m->torrent_name);
#line 105
    tmp___3 = realloc((void *)string, (length + tmp___2) + 10UL);
#line 105
    string = (char *)tmp___3;
    }
#line 107
    if ((unsigned long )string == (unsigned long )((void *)0)) {
      {
#line 108
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory.\n");
#line 109
      exit(1);
      }
    }
    {
#line 111
    sprintf((char */* __restrict  */)(string + length), (char const   */* __restrict  */)"/%s.torrent",
            m->torrent_name);
    }
  } else {
    {
#line 114
    tmp___4 = strlen((char const   *)m->metainfo_file_path);
#line 114
    tmp___5 = realloc((void *)string, (length + tmp___4) + 2UL);
#line 114
    string = (char *)tmp___5;
    }
#line 117
    if ((unsigned long )string == (unsigned long )((void *)0)) {
      {
#line 118
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory.\n");
#line 119
      exit(1);
      }
    }
    {
#line 121
    sprintf((char */* __restrict  */)(string + length), (char const   */* __restrict  */)"/%s",
            m->metainfo_file_path);
    }
  }
#line 124
  m->metainfo_file_path = string;
#line 125
  return;
}
}
#line 131 "/home/wheatley/newnew/temp/mktorrent-1.0/init.c"
static slist_t *get_slist(char *s ) 
{ 
  slist_t *list ;
  slist_t *last ;
  char *e ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 137
  tmp = malloc(sizeof(slist_t ));
#line 137
  last = (slist_t *)tmp;
#line 137
  list = last;
  }
#line 138
  if ((unsigned long )list == (unsigned long )((void *)0)) {
    {
#line 139
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory.\n");
#line 140
    exit(1);
    }
  }
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 144
    e = strchr((char const   *)s, ',');
    }
#line 144
    if (! e) {
#line 144
      goto while_break;
    }
    {
#line 147
    *e = (char )'\000';
#line 148
    last->s = s;
#line 151
    s = e + 1;
#line 154
    tmp___0 = malloc(sizeof(slist_t ));
#line 154
    last->next = (slist_t *)tmp___0;
#line 155
    last = last->next;
    }
#line 156
    if ((unsigned long )last == (unsigned long )((void *)0)) {
      {
#line 157
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory.\n");
#line 158
      exit(1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 163
  last->s = s;
#line 164
  last->next = (slist_t *)((void *)0);
#line 167
  return (list);
}
}
#line 174 "/home/wheatley/newnew/temp/mktorrent-1.0/init.c"
static int is_dir(metafile_t *m , char *target ) 
{ 
  struct stat s ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 179
  tmp___1 = stat((char const   */* __restrict  */)target, (struct stat */* __restrict  */)(& s));
  }
#line 179
  if (tmp___1) {
    {
#line 180
    tmp = __errno_location();
#line 180
    tmp___0 = strerror(*tmp);
#line 180
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error stat\'ing \'%s\': %s\n",
            target, tmp___0);
#line 182
    exit(1);
    }
  }
#line 186
  if ((s.st_mode & 61440U) == 16384U) {
#line 187
    return (1);
  }
#line 190
  if (! ((s.st_mode & 61440U) == 32768U)) {
    {
#line 191
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\'%s\' is neither a directory nor regular file.\n",
            target);
#line 194
    exit(1);
    }
  }
  {
#line 199
  tmp___2 = malloc(sizeof(flist_t ));
#line 199
  m->file_list = (flist_t *)tmp___2;
  }
#line 200
  if ((unsigned long )m->file_list == (unsigned long )((void *)0)) {
    {
#line 201
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory.\n");
#line 202
    exit(1);
    }
  }
#line 204
  (m->file_list)->path = target;
#line 205
  (m->file_list)->size = s.st_size;
#line 206
  (m->file_list)->next = (flist_t *)((void *)0);
#line 208
  m->size = s.st_size;
#line 211
  return (0);
}
}
#line 219 "/home/wheatley/newnew/temp/mktorrent-1.0/init.c"
static int process_node(char const   *path , struct stat  const  *sb , void *data ) 
{ 
  flist_t **p ;
  flist_t *new_node ;
  metafile_t *m ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;

  {
#line 223
  m = (metafile_t *)data;
#line 226
  if (! ((sb->st_mode & 61440U) == 32768U)) {
#line 227
    return (0);
  }
  {
#line 230
  path += 2;
#line 234
  tmp = access(path, 4);
  }
#line 234
  if (tmp) {
    {
#line 235
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Cannot read \'%s\', skipping.\n",
            path);
    }
#line 236
    return (0);
  }
#line 239
  if (m->verbose) {
    {
#line 240
    printf((char const   */* __restrict  */)"Adding %s\n", path);
    }
  }
#line 243
  m->size += (off_t )sb->st_size;
#line 247
  p = & m->file_list;
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
#line 248
    if (*p) {
      {
#line 248
      tmp___0 = strcmp(path, (char const   *)(*p)->path);
      }
#line 248
      if (! (tmp___0 > 0)) {
#line 248
        goto while_break;
      }
    } else {
#line 248
      goto while_break;
    }
#line 249
    p = & (*p)->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 252
  tmp___1 = malloc(sizeof(flist_t ));
#line 252
  new_node = (flist_t *)tmp___1;
  }
#line 253
  if ((unsigned long )new_node == (unsigned long )((void *)0)) {
    {
#line 255
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory.\n");
    }
#line 256
    return (-1);
  } else {
    {
#line 253
    tmp___2 = strdup(path);
#line 253
    new_node->path = tmp___2;
    }
#line 253
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
      {
#line 255
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory.\n");
      }
#line 256
      return (-1);
    }
  }
#line 258
  new_node->size = (off_t )sb->st_size;
#line 261
  new_node->next = *p;
#line 262
  *p = new_node;
#line 267
  return (0);
}
}
#line 273 "/home/wheatley/newnew/temp/mktorrent-1.0/init.c"
static void print_help(void) 
{ 


  {
  {
#line 275
  printf((char const   */* __restrict  */)"Usage: mktorrent [OPTIONS] <target directory or filename>\n\nOptions:\n-a <url>[,<url>]* : specify the full announce URLs\n                    at least one is required\n                    additional -a adds backup trackers\n-c <comment>      : add a comment to the metainfo\n-d                : don\'t write the creation date\n-h                : show this help screen\n-l <n>            : set the piece length to 2^n bytes,\n                    default is 18, that is 2^18 = 256kb\n-n <name>         : set the name of the torrent,\n                    default is the basename of the target\n-o <filename>     : set the path and filename of the created file\n                    default is <name>.torrent\n-p                : set the private flag\n-v                : be verbose\n-w <url>[,<url>]* : add web seed URLs\n                    additional -w adds more URLs\n\nPlease send bug reports, patches, feature requests, praise and\ngeneral gossip about the program to: esmil@users.sourceforge.net\n");
  }
#line 323
  return;
}
}
#line 328 "/home/wheatley/newnew/temp/mktorrent-1.0/init.c"
static void print_announce_list(llist_t *list ) 
{ 
  unsigned int n ;
  slist_t *l ;

  {
#line 332
  n = 1U;
  {
#line 332
  while (1) {
    while_continue: /* CIL Label */ ;
#line 332
    if (! list) {
#line 332
      goto while_break;
    }
    {
#line 333
    l = list->l;
#line 335
    printf((char const   */* __restrict  */)"    %u : %s\n", n, l->s);
#line 336
    l = l->next;
    }
    {
#line 336
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 336
      if (! l) {
#line 336
        goto while_break___0;
      }
      {
#line 337
      printf((char const   */* __restrict  */)"        %s\n", l->s);
#line 336
      l = l->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 332
    list = list->next;
#line 332
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 339
  return;
}
}
#line 344 "/home/wheatley/newnew/temp/mktorrent-1.0/init.c"
static void print_web_seed_list(slist_t *list ) 
{ 


  {
  {
#line 346
  printf((char const   */* __restrict  */)"  Web Seed URL: ");
  }
#line 348
  if ((unsigned long )list == (unsigned long )((void *)0)) {
    {
#line 349
    printf((char const   */* __restrict  */)"none\n");
    }
#line 350
    return;
  }
  {
#line 353
  printf((char const   */* __restrict  */)"%s\n", list->s);
#line 354
  list = list->next;
  }
  {
#line 354
  while (1) {
    while_continue: /* CIL Label */ ;
#line 354
    if (! list) {
#line 354
      goto while_break;
    }
    {
#line 355
    printf((char const   */* __restrict  */)"                %s\n", list->s);
#line 354
    list = list->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 356
  return;
}
}
#line 361 "/home/wheatley/newnew/temp/mktorrent-1.0/init.c"
static void dump_options(metafile_t *m ) 
{ 


  {
  {
#line 363
  printf((char const   */* __restrict  */)"Options:\n  Announce URLs:\n");
#line 366
  print_announce_list(m->announce_list);
#line 368
  printf((char const   */* __restrict  */)"  Torrent name: %s\n  Metafile:     %s\n  Piece length: %u\n  Be verbose:   yes\n",
         m->torrent_name, m->metainfo_file_path, m->piece_length);
#line 374
  printf((char const   */* __restrict  */)"  Write date:   ");
  }
#line 375
  if (m->no_creation_date) {
    {
#line 376
    printf((char const   */* __restrict  */)"no\n");
    }
  } else {
    {
#line 378
    printf((char const   */* __restrict  */)"yes\n");
    }
  }
  {
#line 380
  print_web_seed_list(m->web_seed_list);
#line 382
  printf((char const   */* __restrict  */)"  Comment:      ");
  }
#line 383
  if ((unsigned long )m->comment == (unsigned long )((void *)0)) {
    {
#line 384
    printf((char const   */* __restrict  */)"none\n\n");
    }
  } else {
    {
#line 386
    printf((char const   */* __restrict  */)"\"%s\"\n\n", m->comment);
    }
  }
#line 387
  return;
}
}
#line 394 "/home/wheatley/newnew/temp/mktorrent-1.0/init.c"
void init(metafile_t *m , int argc , char **argv ) 
{ 
  int c ;
  llist_t *announce_last ;
  slist_t *web_seed_last ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 397
  announce_last = (llist_t *)((void *)0);
#line 398
  web_seed_last = (slist_t *)((void *)0);
  {
#line 429
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 429
    c = getopt(argc, (char * const  *)argv, "a:c:dhl:n:o:pvw:");
    }
#line 429
    if (! (c != -1)) {
#line 429
      goto while_break;
    }
    {
#line 433
    if (c == 97) {
#line 433
      goto case_97;
    }
#line 449
    if (c == 99) {
#line 449
      goto case_99;
    }
#line 452
    if (c == 100) {
#line 452
      goto case_100;
    }
#line 455
    if (c == 104) {
#line 455
      goto case_104;
    }
#line 458
    if (c == 108) {
#line 458
      goto case_108;
    }
#line 461
    if (c == 110) {
#line 461
      goto case_110;
    }
#line 464
    if (c == 111) {
#line 464
      goto case_111;
    }
#line 467
    if (c == 112) {
#line 467
      goto case_112;
    }
#line 475
    if (c == 118) {
#line 475
      goto case_118;
    }
#line 478
    if (c == 119) {
#line 478
      goto case_119;
    }
#line 490
    if (c == 63) {
#line 490
      goto case_63;
    }
#line 432
    goto switch_break;
    case_97: /* CIL Label */ 
#line 434
    if ((unsigned long )announce_last == (unsigned long )((void *)0)) {
      {
#line 435
      tmp = malloc(sizeof(llist_t ));
#line 435
      announce_last = (llist_t *)tmp;
#line 435
      m->announce_list = announce_last;
      }
    } else {
      {
#line 438
      tmp___0 = malloc(sizeof(llist_t ));
#line 438
      announce_last->next = (llist_t *)tmp___0;
#line 440
      announce_last = announce_last->next;
      }
    }
#line 443
    if ((unsigned long )announce_last == (unsigned long )((void *)0)) {
      {
#line 444
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory.\n");
#line 445
      exit(1);
      }
    }
    {
#line 447
    announce_last->l = get_slist(optarg);
    }
#line 448
    goto switch_break;
    case_99: /* CIL Label */ 
#line 450
    m->comment = optarg;
#line 451
    goto switch_break;
    case_100: /* CIL Label */ 
#line 453
    m->no_creation_date = 1;
#line 454
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 456
    print_help();
#line 457
    exit(0);
    }
    case_108: /* CIL Label */ 
    {
#line 459
    tmp___1 = atoi((char const   *)optarg);
#line 459
    m->piece_length = (unsigned int )tmp___1;
    }
#line 460
    goto switch_break;
    case_110: /* CIL Label */ 
#line 462
    m->torrent_name = (char const   *)optarg;
#line 463
    goto switch_break;
    case_111: /* CIL Label */ 
#line 465
    m->metainfo_file_path = optarg;
#line 466
    goto switch_break;
    case_112: /* CIL Label */ 
#line 468
    m->private = 1;
#line 469
    goto switch_break;
    case_118: /* CIL Label */ 
#line 476
    m->verbose = 1;
#line 477
    goto switch_break;
    case_119: /* CIL Label */ 
#line 479
    if ((unsigned long )web_seed_last == (unsigned long )((void *)0)) {
      {
#line 480
      web_seed_last = get_slist(optarg);
#line 480
      m->web_seed_list = web_seed_last;
      }
    } else {
      {
#line 483
      web_seed_last->next = get_slist(optarg);
#line 485
      web_seed_last = web_seed_last->next;
      }
    }
    {
#line 487
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 487
      if (! web_seed_last->next) {
#line 487
        goto while_break___0;
      }
#line 488
      web_seed_last = web_seed_last->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 489
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 491
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Use -h for help.\n");
#line 492
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 498
  if (m->piece_length < 15U) {
    {
#line 499
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The piece length must be a number between 15 and 28.\n");
#line 502
    exit(1);
    }
  } else
#line 498
  if (m->piece_length > 28U) {
    {
#line 499
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The piece length must be a number between 15 and 28.\n");
#line 502
    exit(1);
    }
  }
#line 504
  m->piece_length = (unsigned int )(1 << m->piece_length);
#line 508
  if ((unsigned long )m->announce_list == (unsigned long )((void *)0)) {
    {
#line 509
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Must specify an announce URL. Use -h for help.\n");
#line 511
    exit(1);
    }
  }
#line 513
  announce_last->next = (llist_t *)((void *)0);
#line 516
  if (optind >= argc) {
    {
#line 517
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Must specify the contents, use -h for help\n");
#line 519
    exit(1);
    }
  }
  {
#line 532
  strip_ending_dirseps(*(argv + optind));
  }
#line 535
  if ((unsigned long )m->torrent_name == (unsigned long )((void *)0)) {
    {
#line 536
    m->torrent_name = basename((char const   *)*(argv + optind));
    }
  }
  {
#line 539
  set_absolute_file_path(m);
  }
#line 543
  if (m->verbose) {
    {
#line 544
    dump_options(m);
    }
  }
  {
#line 547
  m->target_is_directory = is_dir(m, *(argv + optind));
  }
#line 548
  if (m->target_is_directory) {
    {
#line 550
    tmp___4 = chdir((char const   *)*(argv + optind));
    }
#line 550
    if (tmp___4) {
      {
#line 551
      tmp___2 = __errno_location();
#line 551
      tmp___3 = strerror(*tmp___2);
#line 551
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error changing directory to \'%s\': %s\n",
              *(argv + optind), tmp___3);
#line 553
      exit(1);
      }
    }
    {
#line 556
    tmp___5 = file_tree_walk("./", 100U, & process_node, (void *)m);
    }
#line 556
    if (tmp___5) {
      {
#line 557
      exit(1);
      }
    }
  }
#line 562
  m->pieces = (unsigned int )(((m->size + (off_t )m->piece_length) - 1L) / (off_t )m->piece_length);
#line 565
  if (m->verbose) {
    {
#line 566
    printf((char const   */* __restrict  */)"\n%ld bytes in all.\nThat\'s %u pieces of %u bytes each.\n\n",
           m->size, m->pieces, m->piece_length);
    }
  }
#line 569
  return;
}
}
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 214
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) seekdir)(DIR *__dirp ,
                                                                                               long __pos ) ;
#line 217
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) telldir)(DIR *__dirp ) ;
#line 48 "/home/wheatley/newnew/temp/mktorrent-1.0/ftw.c"
static struct dir_state *dir_state_new(struct dir_state *prev , struct dir_state *next ) 
{ 
  struct dir_state *ds ;
  void *tmp ;

  {
  {
#line 51
  tmp = malloc(sizeof(struct dir_state ));
#line 51
  ds = (struct dir_state *)tmp;
  }
#line 53
  if ((unsigned long )ds == (unsigned long )((void *)0)) {
    {
#line 54
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory.\n");
    }
#line 55
    return ((struct dir_state *)((void *)0));
  }
#line 58
  ds->prev = prev;
#line 59
  ds->next = next;
#line 61
  return (ds);
}
}
#line 64 "/home/wheatley/newnew/temp/mktorrent-1.0/ftw.c"
static unsigned int dir_state_open(struct dir_state *ds , char const   *name , size_t length ) 
{ 
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 67
  ds->dir = opendir(name);
  }
#line 68
  if ((unsigned long )ds->dir == (unsigned long )((void *)0)) {
    {
#line 69
    tmp = __errno_location();
#line 69
    tmp___0 = strerror(*tmp);
#line 69
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error opening \'%s\': %s\n",
            name, tmp___0);
    }
#line 71
    return (1U);
  }
#line 74
  ds->length = length;
#line 76
  return (0U);
}
}
#line 79 "/home/wheatley/newnew/temp/mktorrent-1.0/ftw.c"
static unsigned int dir_state_reopen(struct dir_state *ds , char *name ) 
{ 
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 81
  *(name + ds->length) = (char )'\000';
#line 82
  ds->dir = opendir((char const   *)name);
  }
#line 83
  if ((unsigned long )ds->dir == (unsigned long )((void *)0)) {
    {
#line 84
    tmp = __errno_location();
#line 84
    tmp___0 = strerror(*tmp);
#line 84
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error opening \'%s\': %s\n",
            name, tmp___0);
    }
#line 86
    return (1U);
  }
  {
#line 89
  *(name + ds->length) = (char )'/';
#line 91
  seekdir(ds->dir, ds->offset);
  }
#line 93
  return (0U);
}
}
#line 96 "/home/wheatley/newnew/temp/mktorrent-1.0/ftw.c"
static unsigned int dir_state_close(struct dir_state *ds ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 98
  ds->offset = telldir(ds->dir);
  }
#line 99
  if (ds->offset < 0L) {
    {
#line 100
    tmp = __errno_location();
#line 100
    tmp___0 = strerror(*tmp);
#line 100
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error getting dir offset: %s\n",
            tmp___0);
    }
#line 102
    return (1U);
  }
  {
#line 105
  tmp___3 = closedir(ds->dir);
  }
#line 105
  if (tmp___3) {
    {
#line 106
    tmp___1 = __errno_location();
#line 106
    tmp___2 = strerror(*tmp___1);
#line 106
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error closing directory: %s\n",
            tmp___2);
    }
#line 108
    return (1U);
  }
#line 111
  ds->dir = (DIR *)((void *)0);
#line 113
  return (0U);
}
}
#line 116 "/home/wheatley/newnew/temp/mktorrent-1.0/ftw.c"
static unsigned int cleanup(struct dir_state *ds , char *path , int ret ) 
{ 
  struct dir_state *next ;

  {
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    if (! ds->prev) {
#line 118
      goto while_break;
    }
#line 119
    ds = ds->prev;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 121
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 122
    next = ds->next;
#line 123
    free((void *)ds);
#line 124
    ds = next;
    }
#line 121
    if (! ds) {
#line 121
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 127
  if (path) {
    {
#line 128
    free((void *)path);
    }
  }
#line 130
  return ((unsigned int )ret);
}
}
#line 133 "/home/wheatley/newnew/temp/mktorrent-1.0/ftw.c"
int file_tree_walk(char const   *dirname , unsigned int nfds , int (*callback)(char const   *name ,
                                                                               struct stat  const  *sbuf ,
                                                                               void *data ) ,
                   void *data ) 
{ 
  size_t path_size ;
  char *path ;
  char *path_max ;
  char *end ;
  struct dir_state *ds ;
  struct dir_state *tmp ;
  struct dir_state *first_open ;
  unsigned int nopen ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  char *new_path ;
  void *tmp___2 ;
  unsigned int tmp___3 ;
  char tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  struct dirent *de ;
  struct dirent *tmp___7 ;
  struct stat sbuf ;
  char const   *p ;
  int r ;
  char *new_path___0 ;
  void *tmp___8 ;
  unsigned int tmp___9 ;
  char tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  unsigned int tmp___13 ;
  int tmp___14 ;
  unsigned int tmp___15 ;
  unsigned int tmp___16 ;
  struct dir_state *tmp___17 ;
  unsigned int tmp___18 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;
  unsigned int tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  unsigned int tmp___24 ;
  int tmp___25 ;
  unsigned int tmp___26 ;
  unsigned int tmp___27 ;
  unsigned int tmp___28 ;

  {
  {
#line 136
  path_size = (size_t )256;
#line 140
  tmp = dir_state_new((struct dir_state *)((void *)0), (struct dir_state *)((void *)0));
#line 140
  ds = tmp;
  }
#line 144
  if ((unsigned long )ds == (unsigned long )((void *)0)) {
#line 145
    return (-1);
  }
  {
#line 147
  tmp___0 = malloc(path_size);
#line 147
  path = (char *)tmp___0;
  }
#line 148
  if ((unsigned long )path == (unsigned long )((void *)0)) {
    {
#line 149
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory.\n");
#line 150
    tmp___1 = cleanup(ds, (char *)((void *)0), -1);
    }
#line 150
    return ((int )tmp___1);
  }
#line 152
  path_max = path + path_size;
#line 155
  end = path;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    tmp___4 = (char )*dirname;
#line 156
    *end = tmp___4;
#line 156
    if (! tmp___4) {
#line 156
      goto while_break;
    }
#line 157
    dirname ++;
#line 158
    end ++;
#line 159
    if ((unsigned long )end == (unsigned long )path_max) {
      {
#line 162
      tmp___2 = realloc((void *)path, 2UL * path_size);
#line 162
      new_path = (char *)tmp___2;
      }
#line 163
      if ((unsigned long )new_path == (unsigned long )((void *)0)) {
        {
#line 164
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory.\n");
#line 165
        tmp___3 = cleanup(ds, path, -1);
        }
#line 165
        return ((int )tmp___3);
      }
#line 167
      end = new_path + path_size;
#line 168
      path_size *= 2UL;
#line 169
      path = new_path;
#line 170
      path_max = path + path_size;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 175
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 175
    if ((unsigned long )end > (unsigned long )path) {
#line 175
      if (! ((int )*(end - 1) == 47)) {
#line 175
        goto while_break___0;
      }
    } else {
#line 175
      goto while_break___0;
    }
#line 176
    end --;
#line 177
    *end = (char )'\000';
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 180
  tmp___6 = dir_state_open(ds, (char const   *)path, (size_t )(end - path));
  }
#line 180
  if (tmp___6) {
    {
#line 181
    tmp___5 = cleanup(ds, path, -1);
    }
#line 181
    return ((int )tmp___5);
  }
#line 183
  first_open = ds;
#line 184
  nopen = 1U;
#line 186
  *end = (char )'/';
  {
#line 188
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 189
    tmp___7 = readdir(ds->dir);
#line 189
    de = tmp___7;
    }
#line 191
    if (de) {
#line 196
      if ((int )de->d_name[0] == 46) {
#line 196
        if ((int )de->d_name[1] == 0) {
#line 200
          goto while_continue___1;
        } else
#line 196
        if ((int )de->d_name[1] == 46) {
#line 196
          if ((int )de->d_name[2] == 0) {
#line 200
            goto while_continue___1;
          }
        }
      }
#line 203
      end = (path + ds->length) + 1;
#line 204
      p = (char const   *)(de->d_name);
      {
#line 205
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 205
        tmp___10 = (char )*p;
#line 205
        *end = tmp___10;
#line 205
        if (! tmp___10) {
#line 205
          goto while_break___2;
        }
#line 206
        p ++;
#line 207
        end ++;
#line 208
        if ((unsigned long )end == (unsigned long )path_max) {
          {
#line 211
          tmp___8 = realloc((void *)path, 2UL * path_size);
#line 211
          new_path___0 = (char *)tmp___8;
          }
#line 212
          if ((unsigned long )new_path___0 == (unsigned long )((void *)0)) {
            {
#line 213
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory.\n");
#line 214
            tmp___9 = cleanup(ds, path, -1);
            }
#line 214
            return ((int )tmp___9);
          }
#line 216
          end = new_path___0 + path_size;
#line 217
          path_size *= 2UL;
#line 218
          path = new_path___0;
#line 219
          path_max = path + path_size;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 223
      tmp___14 = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& sbuf));
      }
#line 223
      if (tmp___14) {
        {
#line 224
        tmp___11 = __errno_location();
#line 224
        tmp___12 = strerror(*tmp___11);
#line 224
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error stat\'ing \'%s\': %s\n",
                path, tmp___12);
#line 226
        tmp___13 = cleanup(ds, path, -1);
        }
#line 226
        return ((int )tmp___13);
      }
      {
#line 229
      r = (*callback)((char const   *)path, (struct stat  const  *)(& sbuf), data);
      }
#line 230
      if (r) {
        {
#line 231
        tmp___15 = cleanup(ds, path, r);
        }
#line 231
        return ((int )tmp___15);
      }
#line 233
      if ((sbuf.st_mode & 61440U) == 16384U) {
#line 234
        if ((unsigned long )ds->next == (unsigned long )((void *)0)) {
          {
#line 234
          tmp___17 = dir_state_new(ds, (struct dir_state *)((void *)0));
#line 234
          ds->next = tmp___17;
          }
#line 234
          if ((unsigned long )tmp___17 == (unsigned long )((void *)0)) {
            {
#line 236
            tmp___16 = cleanup(ds, path, -1);
            }
#line 236
            return ((int )tmp___16);
          }
        }
#line 238
        ds = ds->next;
#line 240
        if (nopen == nfds) {
          {
#line 241
          tmp___19 = dir_state_close(first_open);
          }
#line 241
          if (tmp___19) {
            {
#line 242
            tmp___18 = cleanup(ds, path, -1);
            }
#line 242
            return ((int )tmp___18);
          }
#line 243
          first_open = first_open->next;
#line 244
          nopen --;
        }
        {
#line 247
        tmp___21 = dir_state_open(ds, (char const   *)path, (size_t )(end - path));
        }
#line 247
        if (tmp___21) {
          {
#line 248
          tmp___20 = cleanup(ds, path, -1);
          }
#line 248
          return ((int )tmp___20);
        }
#line 250
        nopen ++;
#line 252
        *end = (char )'/';
      }
    } else {
      {
#line 255
      tmp___25 = closedir(ds->dir);
      }
#line 255
      if (tmp___25) {
        {
#line 256
        *(path + ds->length) = (char )'\000';
#line 257
        tmp___22 = __errno_location();
#line 257
        tmp___23 = strerror(*tmp___22);
#line 257
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error closing \'%s\': %s\n",
                path, tmp___23);
#line 259
        tmp___24 = cleanup(ds, path, -1);
        }
#line 259
        return ((int )tmp___24);
      }
#line 262
      if ((unsigned long )ds->prev == (unsigned long )((void *)0)) {
#line 263
        goto while_break___1;
      }
#line 265
      ds = ds->prev;
#line 266
      nopen --;
#line 268
      if ((unsigned long )ds->dir == (unsigned long )((void *)0)) {
        {
#line 269
        tmp___27 = dir_state_reopen(ds, path);
        }
#line 269
        if (tmp___27) {
          {
#line 270
          tmp___26 = cleanup(ds, path, -1);
          }
#line 270
          return ((int )tmp___26);
        }
#line 271
        first_open = ds;
#line 272
        nopen ++;
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 277
  tmp___28 = cleanup(ds, path, 0);
  }
#line 277
  return ((int )tmp___28);
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 39 "/home/wheatley/newnew/temp/mktorrent-1.0/output.c"
static void write_announce_list(FILE *f , llist_t *list ) 
{ 
  slist_t *l ;
  size_t tmp ;

  {
  {
#line 42
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"13:announce-listl");
  }
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! list) {
#line 44
      goto while_break;
    }
    {
#line 48
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"l");
#line 49
    l = list->l;
    }
    {
#line 49
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 49
      if (! l) {
#line 49
        goto while_break___0;
      }
      {
#line 50
      tmp = strlen((char const   *)l->s);
#line 50
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%lu:%s",
              tmp, l->s);
#line 49
      l = l->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 52
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"e");
#line 44
    list = list->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 54
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"e");
  }
#line 55
  return;
}
}
#line 60 "/home/wheatley/newnew/temp/mktorrent-1.0/output.c"
static void write_file_list(FILE *f , flist_t *list ) 
{ 
  char *a ;
  char *b ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 64
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"5:filesl");
  }
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! list) {
#line 67
      goto while_break;
    }
    {
#line 71
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"d6:lengthi%lde4:pathl",
            list->size);
#line 75
    a = list->path;
    }
    {
#line 77
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 77
      b = strchr((char const   *)a, '/');
      }
#line 77
      if (! ((unsigned long )b != (unsigned long )((void *)0))) {
#line 77
        goto while_break___0;
      }
      {
#line 80
      *b = (char )'\000';
#line 82
      tmp = strlen((char const   *)a);
#line 82
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%lu:%s",
              tmp, a);
#line 84
      *b = (char )'/';
#line 87
      a = b + 1;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 91
    tmp___0 = strlen((char const   *)a);
#line 91
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%lu:%see",
            tmp___0, a);
#line 67
    list = list->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 95
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"e");
  }
#line 96
  return;
}
}
#line 101 "/home/wheatley/newnew/temp/mktorrent-1.0/output.c"
static void write_web_seed_list(FILE *f , slist_t *list ) 
{ 
  size_t tmp ;

  {
  {
#line 104
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"8:url-listl");
  }
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (! list) {
#line 106
      goto while_break;
    }
    {
#line 107
    tmp = strlen((char const   *)list->s);
#line 107
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%lu:%s",
            tmp, list->s);
#line 106
    list = list->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 109
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"e");
  }
#line 110
  return;
}
}
#line 116 "/home/wheatley/newnew/temp/mktorrent-1.0/output.c"
void write_metainfo(FILE *f , metafile_t *m , unsigned char *hash_string ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  time_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 119
  printf((char const   */* __restrict  */)"Writing metainfo file... ");
#line 120
  fflush(stdout);
#line 124
  tmp = strlen((char const   *)((m->announce_list)->l)->s);
#line 124
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"d8:announce%lu:%s",
          tmp, ((m->announce_list)->l)->s);
  }
#line 129
  if ((m->announce_list)->next) {
    {
#line 130
    write_announce_list(f, m->announce_list);
    }
  } else
#line 129
  if (((m->announce_list)->l)->next) {
    {
#line 130
    write_announce_list(f, m->announce_list);
    }
  }
#line 132
  if ((unsigned long )m->comment != (unsigned long )((void *)0)) {
    {
#line 133
    tmp___0 = strlen((char const   *)m->comment);
#line 133
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"7:comment%lu:%s",
            tmp___0, m->comment);
    }
  }
  {
#line 137
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"10:created by13:mktorrent 1.0");
  }
#line 139
  if (! m->no_creation_date) {
    {
#line 140
    tmp___1 = time((time_t *)((void *)0));
#line 140
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"13:creation datei%lde",
            tmp___1);
    }
  }
  {
#line 145
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"4:infod");
  }
#line 148
  if (! m->target_is_directory) {
    {
#line 149
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"6:lengthi%lde",
            (m->file_list)->size);
    }
  } else {
    {
#line 151
    write_file_list(f, m->file_list);
    }
  }
  {
#line 155
  tmp___2 = strlen(m->torrent_name);
#line 155
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"4:name%lu:%s12:piece lengthi%ue6:pieces%u:",
          tmp___2, m->torrent_name, m->piece_length, m->pieces * 20U);
#line 158
  fwrite((void const   */* __restrict  */)hash_string, (size_t )1, (size_t )(m->pieces * 20U),
         (FILE */* __restrict  */)f);
  }
#line 161
  if (m->private) {
    {
#line 162
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"7:privatei1e");
    }
  }
  {
#line 165
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"e");
  }
#line 168
  if ((unsigned long )m->web_seed_list != (unsigned long )((void *)0)) {
#line 169
    if ((unsigned long )(m->web_seed_list)->next == (unsigned long )((void *)0)) {
      {
#line 170
      tmp___3 = strlen((char const   *)(m->web_seed_list)->s);
#line 170
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"8:url-list%lu:%s",
              tmp___3, (m->web_seed_list)->s);
      }
    } else {
      {
#line 174
      write_web_seed_list(f, m->web_seed_list);
      }
    }
  }
  {
#line 178
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"e");
#line 181
  printf((char const   */* __restrict  */)"done.\n");
#line 182
  fflush(stdout);
  }
#line 183
  return;
}
}
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 50 "/home/wheatley/newnew/temp/mktorrent-1.0/hash.c"
unsigned char *make_hash(metafile_t *m ) 
{ 
  flist_t *f ;
  unsigned char *hash_string ;
  unsigned char *pos ;
  unsigned char *read_buf ;
  int fd ;
  ssize_t r ;
  SHA_CTX c ;
  off_t counter ;
  void *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  ssize_t d ;
  ssize_t tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 61
  counter = (off_t )0;
#line 67
  tmp = malloc((size_t )(m->pieces * 20U));
#line 67
  hash_string = (unsigned char *)tmp;
#line 69
  tmp___0 = malloc((size_t )m->piece_length);
#line 69
  read_buf = (unsigned char *)tmp___0;
  }
#line 72
  if ((unsigned long )hash_string == (unsigned long )((void *)0)) {
    {
#line 73
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory.\n");
#line 74
    exit(1);
    }
  } else
#line 72
  if ((unsigned long )read_buf == (unsigned long )((void *)0)) {
    {
#line 73
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory.\n");
#line 74
    exit(1);
    }
  }
#line 78
  pos = hash_string;
#line 80
  r = (ssize_t )0;
#line 82
  f = m->file_list;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! f) {
#line 82
      goto while_break;
    }
    {
#line 88
    fd = open((char const   *)f->path, 0);
    }
#line 88
    if (fd == -1) {
      {
#line 90
      tmp___1 = __errno_location();
#line 90
      tmp___2 = strerror(*tmp___1);
#line 90
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error opening \'%s\' for reading: %s\n",
              f->path, tmp___2);
#line 92
      exit(1);
      }
    }
    {
#line 94
    printf((char const   */* __restrict  */)"Hashing %s.\n", f->path);
#line 95
    fflush(stdout);
    }
    {
#line 101
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 102
      tmp___3 = read(fd, (void *)(read_buf + r), (size_t )((ssize_t )m->piece_length - r));
#line 102
      d = tmp___3;
      }
#line 104
      if (d < 0L) {
        {
#line 105
        tmp___4 = __errno_location();
#line 105
        tmp___5 = strerror(*tmp___4);
#line 105
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error reading from \'%s\': %s\n",
                f->path, tmp___5);
#line 107
        exit(1);
        }
      }
#line 110
      if (d == 0L) {
#line 111
        goto while_break___0;
      }
#line 113
      r += d;
#line 115
      if (r == (ssize_t )m->piece_length) {
        {
#line 116
        SHA1_Init(& c);
#line 117
        SHA1_Update(& c, (uint8_t const   *)read_buf, (unsigned long )m->piece_length);
#line 118
        SHA1_Final(pos, & c);
#line 119
        pos += 20;
#line 121
        counter += r;
#line 123
        r = (ssize_t )0;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 128
    tmp___8 = close(fd);
    }
#line 128
    if (tmp___8) {
      {
#line 129
      tmp___6 = __errno_location();
#line 129
      tmp___7 = strerror(*tmp___6);
#line 129
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error closing \'%s\': %s\n",
              f->path, tmp___7);
#line 131
      exit(1);
      }
    }
#line 82
    f = f->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  if (r) {
    {
#line 137
    SHA1_Init(& c);
#line 138
    SHA1_Update(& c, (uint8_t const   *)read_buf, (unsigned long )r);
#line 139
    SHA1_Final(pos, & c);
    }
  }
#line 143
  counter += r;
#line 144
  if (counter != m->size) {
    {
#line 145
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Counted %ld bytes, but hashed %ld bytes. Something is wrong...\n",
            m->size, counter);
#line 148
    exit(1);
    }
  }
  {
#line 153
  free((void *)read_buf);
  }
#line 155
  return (hash_string);
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 93 "/home/wheatley/newnew/temp/mktorrent-1.0/main.c"
static FILE *open_file(char const   *path ) 
{ 
  int fd ;
  FILE *f ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 99
  fd = open(path, 193, (384 | (256 >> 3)) | ((256 >> 3) >> 3));
  }
#line 101
  if (fd < 0) {
    {
#line 102
    tmp = __errno_location();
#line 102
    tmp___0 = strerror(*tmp);
#line 102
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error creating \'%s\': %s\n",
            path, tmp___0);
#line 104
    exit(1);
    }
  }
  {
#line 108
  f = fdopen(fd, "wb");
  }
#line 109
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 110
    tmp___1 = __errno_location();
#line 110
    tmp___2 = strerror(*tmp___1);
#line 110
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error creating stream for \'%s\': %s\n",
            path, tmp___2);
#line 112
    exit(1);
    }
  }
#line 115
  return (f);
}
}
#line 121 "/home/wheatley/newnew/temp/mktorrent-1.0/main.c"
static void close_file(FILE *f ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 124
  tmp___1 = fclose(f);
  }
#line 124
  if (tmp___1) {
    {
#line 125
    tmp = __errno_location();
#line 125
    tmp___0 = strerror(*tmp);
#line 125
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error closing stream: %s\n",
            tmp___0);
#line 127
    exit(1);
    }
  }
#line 129
  return;
}
}
#line 134 "/home/wheatley/newnew/temp/mktorrent-1.0/main.c"
int main(int argc , char **argv ) 
{ 
  FILE *file ;
  metafile_t m ;
  unsigned char *tmp ;

  {
  {
#line 137
  m.piece_length = 18U;
#line 137
  m.announce_list = (llist_t *)((void *)0);
#line 137
  m.comment = (char *)((void *)0);
#line 137
  m.torrent_name = (char const   *)((void *)0);
#line 137
  m.metainfo_file_path = (char *)((void *)0);
#line 137
  m.web_seed_list = (slist_t *)((void *)0);
#line 137
  m.target_is_directory = 0;
#line 137
  m.no_creation_date = 0;
#line 137
  m.private = 0;
#line 137
  m.verbose = 0;
#line 137
  m.size = (off_t )0;
#line 137
  m.file_list = (flist_t *)((void *)0);
#line 137
  m.pieces = 0U;
#line 160
  printf((char const   */* __restrict  */)"mktorrent 1.0 (c) 2007, 2009 Emil Renner Berthing\n\n");
#line 163
  init(& m, argc, argv);
#line 167
  file = open_file((char const   *)m.metainfo_file_path);
#line 170
  tmp = make_hash(& m);
#line 170
  write_metainfo(file, & m, tmp);
#line 173
  close_file(file);
  }
#line 176
  return (0);
}
}
