/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 61 "/home/june/collector/temp/aprsdigi-2.4.4/mic_e.c"
enum __anonenum_rev_19 {
    none = 0,
    BETA = 1,
    REV1 = 2
} ;
#line 69 "/usr/include/netax25/ax25.h"
struct __anonstruct_ax25_address_1 {
   char ax25_call[7] ;
};
#line 69 "/usr/include/netax25/ax25.h"
typedef struct __anonstruct_ax25_address_1 ax25_address;
#line 9 "/home/june/collector/temp/aprsdigi-2.4.4/libax25ext.h"
struct ax_calls {
   ax25_address ax_to_call ;
   ax25_address ax_from_call ;
   int ax_n_digis ;
   ax25_address ax_digi_call[8] ;
   int ax_next_digi ;
   unsigned char ax_type ;
   unsigned char ax_pid ;
};
#line 24
enum __anonenum_pk_val_3 {
    PK_INVALID = -1,
    PK_VALID = 0,
    PK_VALDIGI = 1
} ;
#line 24 "/home/june/collector/temp/aprsdigi-2.4.4/libax25ext.h"
typedef enum __anonenum_pk_val_3 pk_val;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 580
extern int putchar(int __c ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 695
extern int puts(char const   *__s ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 459
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) bzero)(void *__s ,
                                                                                             size_t __n ) ;
#line 5 "/home/june/collector/temp/aprsdigi-2.4.4/mic_e.h"
int fmt_mic_e(u_char const   *t , u_char const   *i , int const   l , u_char *buf1 ,
              int *l1 , u_char *buf2 , int *l2 , time_t tick ) ;
#line 14
int fmt_x1j4(u_char const   *t , u_char const   *i , int const   l , u_char *buf1 ,
             int *l1 , u_char *buf2 , int *l2 , time_t tick ) ;
#line 9 "/home/june/collector/temp/aprsdigi-2.4.4/mic_e_test.c"
void main(int argc , char **argv ) 
{ 
  char b[100] ;
  char ob1[512] ;
  char ob2[512] ;
  int ol1 ;
  int ol2 ;
  int tl ;
  size_t tmp ;
  u_char *to ;
  char *tmp___0 ;
  u_char *i ;
  char *tmp___1 ;
  time_t tick ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 18
  bzero((void *)(b), sizeof(b));
  }
  {
#line 19
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 19
    tmp___6 = fgets((char */* __restrict  */)(b), (int )sizeof(b), (FILE */* __restrict  */)stdin);
    }
#line 19
    if (! tmp___6) {
#line 19
      goto while_break;
    }
    {
#line 20
    tmp = strlen((char const   *)(b));
#line 20
    tl = (int )tmp;
#line 21
    tmp___0 = strchr((char const   *)(b), '>');
#line 21
    to = (u_char *)tmp___0;
#line 22
    tmp___1 = strchr((char const   *)(b), ':');
#line 22
    i = (u_char *)tmp___1;
    }
#line 25
    if ((unsigned long )tl < sizeof(b)) {
#line 25
      if ((int )b[tl - 1] == 10) {
#line 26
        b[tl - 1] = (char )'\000';
      }
    }
#line 27
    if (! to) {
      {
#line 28
      putchar('?');
#line 29
      puts((char const   *)(b));
      }
#line 30
      goto while_continue;
    } else
#line 27
    if (! i) {
      {
#line 28
      putchar('?');
#line 29
      puts((char const   *)(b));
      }
#line 30
      goto while_continue;
    }
    {
#line 32
    to ++;
#line 33
    i ++;
#line 34
    time(& tick);
#line 36
    tmp___2 = strlen((char const   *)i);
#line 36
    tmp___3 = fmt_mic_e((u_char const   *)to, (u_char const   *)i, (int const   )tmp___2,
                        (u_char *)(ob1), & ol1, (u_char *)(ob2), & ol2, tick);
    }
#line 36
    if (tmp___3) {
#line 36
      goto _L;
    } else {
      {
#line 36
      tmp___4 = strlen((char const   *)i);
#line 36
      tmp___5 = fmt_x1j4((u_char const   *)to, (u_char const   *)i, (int const   )tmp___4,
                         (u_char *)(ob1), & ol1, (u_char *)(ob2), & ol2, tick);
      }
#line 36
      if (tmp___5) {
        _L: /* CIL Label */ 
#line 38
        if (ol2) {
          {
#line 39
          fwrite((void const   */* __restrict  */)(ob2), (size_t )ol2, (size_t )1,
                 (FILE */* __restrict  */)stdout);
#line 40
          putchar('\n');
          }
        }
#line 42
        if (ol1) {
          {
#line 43
          fwrite((void const   */* __restrict  */)(ob1), (size_t )ol1, (size_t )1,
                 (FILE */* __restrict  */)stdout);
#line 44
          putchar('\n');
          }
        }
      } else {
        {
#line 47
        putchar('#');
#line 48
        puts((char const   *)(b));
        }
      }
    }
    {
#line 50
    bzero((void *)(b), sizeof(b));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return;
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 239 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 96
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 33 "/home/june/collector/temp/aprsdigi-2.4.4/mic_e.c"
static char *msgname[8]  = 
#line 33 "/home/june/collector/temp/aprsdigi-2.4.4/mic_e.c"
  {      (char *)"Off duty..",      (char *)"Enroute...",      (char *)"In Service",      (char *)"Returning.", 
        (char *)"Committed.",      (char *)"Special...",      (char *)"PRIORITY..",      (char *)"EMERGENCY."};
#line 44
static unsigned int hex2i(u_char a , u_char b ) ;
#line 46 "/home/june/collector/temp/aprsdigi-2.4.4/mic_e.c"
int fmt_mic_e(u_char const   *t , u_char const   *i , int const   l , u_char *buf1 ,
              int *l1 , u_char *buf2 , int *l2 , time_t tick ) 
{ 
  u_int msg ;
  u_int sp ;
  u_int dc ;
  u_int se ;
  u_int spd ;
  u_int cse ;
  char north ;
  char west ;
  int lon1 ;
  int lonDD ;
  int lonMM ;
  int lonHH ;
  char *bp ;
  struct tm *gmt ;
  enum __anonenum_rev_19 rev ;
  int gps_valid ;
  char symtbl ;
  char symbol ;
  char etype ;
  int buf2_n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  size_t tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  char *tmp___16 ;

  {
#line 61
  rev = (enum __anonenum_rev_19 )0;
#line 62
  gps_valid = 0;
#line 63
  symtbl = (char )'/';
#line 63
  symbol = (char )'$';
#line 63
  etype = (char )'E';
#line 64
  buf2_n = 0;
#line 66
  tmp = 0;
#line 66
  *l2 = tmp;
#line 66
  *l1 = tmp;
  {
#line 69
  if ((int const   )*(i + 0) == 96) {
#line 69
    goto case_96;
  }
#line 73
  if ((int const   )*(i + 0) == 39) {
#line 73
    goto case_39;
  }
#line 77
  if ((int const   )*(i + 0) == 28) {
#line 77
    goto case_28;
  }
#line 81
  if ((int const   )*(i + 0) == 29) {
#line 81
    goto case_29;
  }
#line 85
  goto switch_default;
  case_96: /* CIL Label */ 
#line 70
  gps_valid = 1;
#line 71
  rev = (enum __anonenum_rev_19 )2;
#line 72
  goto switch_break;
  case_39: /* CIL Label */ 
#line 74
  gps_valid = 0;
#line 75
  rev = (enum __anonenum_rev_19 )2;
#line 76
  goto switch_break;
  case_28: /* CIL Label */ 
#line 78
  gps_valid = 1;
#line 79
  rev = (enum __anonenum_rev_19 )1;
#line 80
  goto switch_break;
  case_29: /* CIL Label */ 
#line 82
  gps_valid = 0;
#line 83
  rev = (enum __anonenum_rev_19 )1;
#line 84
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 86
  gps_valid = 0;
#line 87
  rev = (enum __anonenum_rev_19 )0;
#line 88
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 90
  if (l >= 7) {
#line 90
    if ((unsigned int )rev != 0U) {
#line 91
      if ((int const   )*(t + 0) & 64) {
#line 91
        tmp___0 = 0;
      } else {
#line 91
        tmp___0 = 4;
      }
#line 91
      if ((int const   )*(t + 1) & 64) {
#line 91
        tmp___1 = 0;
      } else {
#line 91
        tmp___1 = 2;
      }
#line 91
      if ((int const   )*(t + 2) & 64) {
#line 91
        tmp___2 = 0;
      } else {
#line 91
        tmp___2 = 1;
      }
#line 91
      msg = (u_int )((tmp___0 + tmp___1) + tmp___2);
#line 92
      if ((int const   )*(t + 3) & 64) {
#line 92
        north = (char )'N';
      } else {
#line 92
        north = (char )'S';
      }
#line 93
      if ((int const   )*(t + 5) & 64) {
#line 93
        west = (char )'W';
      } else {
#line 93
        west = (char )'E';
      }
#line 94
      lon1 = (int )((int const   )*(t + 4) & 64);
#line 95
      lonDD = (int )((int const   )*(i + 1) - 28);
#line 96
      lonMM = (int )((int const   )*(i + 2) - 28);
#line 97
      lonHH = (int )((int const   )*(i + 3) - 28);
#line 103
      if ((unsigned int )rev >= 2U) {
#line 104
        if (lon1) {
#line 105
          lonDD += 100;
        }
#line 106
        if (180 <= lonDD) {
#line 106
          if (lonDD <= 189) {
#line 107
            lonDD -= 80;
          }
        }
#line 108
        if (190 <= lonDD) {
#line 108
          if (lonDD <= 199) {
#line 109
            lonDD -= 190;
          }
        }
#line 110
        if (lonMM >= 60) {
#line 111
          lonMM -= 60;
        }
      }
#line 116
      sp = (u_int )((int const   )*(i + 4) - 28);
#line 117
      dc = (u_int )((int const   )*(i + 5) - 28);
#line 118
      se = (u_int )((int const   )*(i + 6) - 28);
#line 119
      buf2_n = 6;
#line 123
      spd = sp * 10U + dc / 10U;
#line 124
      cse = (dc % 10U) * 100U + se;
#line 125
      if ((unsigned int )rev >= 2U) {
#line 126
        if (spd >= 800U) {
#line 127
          spd -= 800U;
        }
#line 128
        if (cse >= 400U) {
#line 129
          cse -= 400U;
        }
      }
      {
#line 131
      gmt = gmtime((time_t const   *)(& tick));
      }
#line 135
      if (l >= 8) {
#line 135
        if ((unsigned int )rev >= 2U) {
#line 135
          symtbl = (char )*(i + 8);
        } else {
#line 135
          symtbl = (char )'/';
        }
      } else {
#line 135
        symtbl = (char )'/';
      }
#line 137
      if ((int )symtbl != 47) {
#line 137
        if ((int )symtbl != 92) {
#line 137
          if (48 <= (int )symtbl) {
#line 137
            if (! ((int )symtbl <= 57)) {
#line 137
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 137
          if (65 <= (int )symtbl) {
#line 137
            if (! ((int )symtbl <= 74)) {
#line 137
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 137
          if ((int )symtbl != 42) {
#line 137
            if ((int )symtbl != 33) {
#line 141
              symtbl = (char )'/';
            }
          }
        }
      }
      {
#line 142
      symbol = (char )*(i + 7);
#line 143
      tmp___3 = __ctype_b_loc();
      }
#line 143
      if (! ((int const   )*(*tmp___3 + (int )symbol) & 16384)) {
#line 144
        symbol = (char )'$';
      }
#line 146
      if ((unsigned int )rev == 1U) {
#line 146
        buf2_n = 8;
      } else {
#line 146
        buf2_n = 9;
      }
#line 147
      if (l >= 10) {
#line 148
        if ((unsigned int )rev == 1U) {
#line 148
          buf2_n = 8;
        } else {
#line 148
          buf2_n = 9;
        }
        {
#line 150
        if ((int const   )*(i + buf2_n) == 62) {
#line 150
          goto case_62;
        }
#line 154
        if ((int const   )*(i + buf2_n) == 96) {
#line 154
          goto case_96___0;
        }
#line 161
        if ((int const   )*(i + buf2_n) == 39) {
#line 161
          goto case_39___0;
        }
#line 171
        if ((int const   )*(i + buf2_n) == 29) {
#line 171
          goto case_29___0;
        }
#line 177
        goto switch_default___0;
        case_62: /* CIL Label */ 
#line 151
        etype = (char )'T';
#line 152
        buf2_n ++;
#line 153
        goto switch_break___0;
        case_96___0: /* CIL Label */ 
        {
#line 155
        tmp___4 = hex2i((u_char )*(i + (buf2_n + 3)), (u_char )*(i + (buf2_n + 4)));
#line 155
        tmp___5 = hex2i((u_char )*(i + (buf2_n + 1)), (u_char )*(i + (buf2_n + 2)));
#line 155
        sprintf((char */* __restrict  */)buf2, (char const   */* __restrict  */)"T#MIC%03d,%03d",
                tmp___5, tmp___4);
#line 158
        buf2_n += 5;
#line 159
        tmp___6 = strlen((char const   *)buf2);
#line 159
        *l2 = (int )tmp___6;
        }
#line 160
        goto switch_break___0;
        case_39___0: /* CIL Label */ 
        {
#line 162
        tmp___7 = hex2i((u_char )*(i + (buf2_n + 9)), (u_char )*(i + (buf2_n + 10)));
#line 162
        tmp___8 = hex2i((u_char )*(i + (buf2_n + 7)), (u_char )*(i + (buf2_n + 8)));
#line 162
        tmp___9 = hex2i((u_char )*(i + (buf2_n + 5)), (u_char )*(i + (buf2_n + 6)));
#line 162
        tmp___10 = hex2i((u_char )*(i + (buf2_n + 3)), (u_char )*(i + (buf2_n + 4)));
#line 162
        tmp___11 = hex2i((u_char )*(i + (buf2_n + 1)), (u_char )*(i + (buf2_n + 2)));
#line 162
        sprintf((char */* __restrict  */)buf2, (char const   */* __restrict  */)"T#MIC%03d,%03d,%03d,%03d,%03d",
                tmp___11, tmp___10, tmp___9, tmp___8, tmp___7);
#line 168
        buf2_n += 11;
#line 169
        tmp___12 = strlen((char const   *)buf2);
#line 169
        *l2 = (int )tmp___12;
        }
#line 170
        goto switch_break___0;
        case_29___0: /* CIL Label */ 
        {
#line 172
        sprintf((char */* __restrict  */)buf2, (char const   */* __restrict  */)"T#MIC%03d,%03d,%03d,%03d,%03d",
                (int const   )*(i + (buf2_n + 1)), (int const   )*(i + (buf2_n + 2)),
                (int const   )*(i + (buf2_n + 3)), (int const   )*(i + (buf2_n + 4)),
                (int const   )*(i + (buf2_n + 5)));
#line 174
        buf2_n += 6;
#line 175
        tmp___13 = strlen((char const   *)buf2);
#line 175
        *l2 = (int )tmp___13;
        }
#line 176
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
#line 178
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
      }
      {
#line 181
      sprintf((char */* __restrict  */)buf1, (char const   */* __restrict  */)"@%02d%02d%02dz%d%d%d%d.%d%d%c%c%03d%02d.%02d%c%c%03d/%03d/%c>mon/M%d/%s",
              gmt->tm_mday, gmt->tm_hour, gmt->tm_min, (int const   )*(t + 0) & 15,
              (int const   )*(t + 1) & 15, (int const   )*(t + 2) & 15, (int const   )*(t + 3) & 15,
              (int const   )*(t + 4) & 15, (int const   )*(t + 5) & 15, (int )north,
              (int )symtbl, lonDD, lonMM, lonHH, (int )west, (int )symbol, cse, spd,
              (int )etype, msg, msgname[msg]);
#line 191
      tmp___15 = strlen((char const   *)buf1);
#line 191
      tmp___14 = (int )tmp___15;
#line 191
      *l1 = tmp___14;
#line 191
      bp = (char *)(buf1 + tmp___14);
      }
#line 192
      if (buf2_n < (int )l) {
        {
#line 193
        tmp___16 = bp;
#line 193
        bp ++;
#line 193
        *tmp___16 = (char )' ';
#line 194
        (*l1) ++;
#line 195
        memcpy((void */* __restrict  */)bp, (void const   */* __restrict  */)(i + buf2_n),
               (size_t )(l - (int const   )buf2_n));
#line 196
        *l1 += (int )(l - (int const   )buf2_n);
        }
      }
    }
  }
#line 199
  return ((*l1 > 0) + (*l2 > 0));
}
}
#line 210 "/home/june/collector/temp/aprsdigi-2.4.4/mic_e.c"
static u_char x1j4prefix[13]  = 
#line 210
  {      (u_char )'T',      (u_char )'h',      (u_char )'e',      (u_char )'N', 
        (u_char )'e',      (u_char )'t',      (u_char )' ',      (u_char )'X', 
        (u_char )'-',      (u_char )'1',      (u_char )'J',      (u_char )'4', 
        (u_char )'\000'};
#line 213 "/home/june/collector/temp/aprsdigi-2.4.4/mic_e.c"
int fmt_x1j4(u_char const   *t , u_char const   *i , int const   l , u_char *buf1 ,
             int *l1 , u_char *buf2 , int *l2 , time_t tick ) 
{ 
  u_char const   *cp ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 224
  tmp = 0;
#line 224
  *l2 = tmp;
#line 224
  *l1 = tmp;
#line 225
  if (l < 14) {
#line 226
    return (0);
  } else {
    {
#line 225
    tmp___0 = memcmp((void const   *)i, (void const   *)(x1j4prefix), sizeof(x1j4prefix) - 1UL);
    }
#line 225
    if (tmp___0 != 0) {
#line 226
      return (0);
    }
  }
  {
#line 229
  tmp___1 = memchr((void const   *)(i + 14), ')', (size_t )8);
#line 229
  cp = (u_char const   *)tmp___1;
  }
#line 230
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 231
    cp = i + 14;
  } else {
#line 233
    cp ++;
  }
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    if ((unsigned long )cp <= (unsigned long )(i + (l - 1))) {
#line 234
      if (! ((int const   )*cp == 32)) {
#line 234
        goto while_break;
      }
    } else {
#line 234
      goto while_break;
    }
#line 234
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 235
  tmp___2 = (int )((i + (l - 1)) - cp);
#line 235
  *l1 = tmp___2;
#line 235
  memcpy((void */* __restrict  */)buf1, (void const   */* __restrict  */)cp, (size_t )tmp___2);
  }
#line 236
  return (1);
}
}
#line 239 "/home/june/collector/temp/aprsdigi-2.4.4/mic_e.c"
static unsigned int hex2i(u_char a , u_char b ) 
{ 
  unsigned int r ;

  {
#line 241
  r = 0U;
#line 243
  if ((int )a >= 48) {
#line 243
    if ((int )a <= 57) {
#line 244
      r = (unsigned int )(((int )a - 48) << 4);
    } else {
#line 243
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 245
  if ((int )a >= 65) {
#line 245
    if ((int )a <= 70) {
#line 246
      r = (unsigned int )((((int )a - 65) + 10) << 4);
    }
  }
#line 248
  if ((int )b >= 48) {
#line 248
    if ((int )b <= 57) {
#line 249
      r += (unsigned int )((int )b - 48);
    } else {
#line 248
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 250
  if ((int )b >= 65) {
#line 250
    if ((int )b <= 70) {
#line 251
      r += (unsigned int )(((int )b - 65) + 10);
    }
  }
#line 253
  return (r);
}
}
#line 25 "/home/june/collector/temp/aprsdigi-2.4.4/libax25ext.h"
pk_val parse_raw_ax25(unsigned char **frame , int *len , struct ax_calls *calls ) ;
#line 27
pk_val parse_cooked_ax25(unsigned char **frame , int *len , struct ax_calls *calls ) ;
#line 29
int gen_raw_ax25(unsigned char **frame , int *len , struct ax_calls *calls ) ;
#line 31
int gen_cooked_ax25(unsigned char **frame , int *len , struct ax_calls *calls ) ;
#line 34
char *ax25_ntoa_pretty(ax25_address const   *a ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 315
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 455
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1,2), __leaf__)) bcopy)(void const   *__src ,
                                                                                               void *__dest ,
                                                                                               size_t __n ) ;
#line 28 "/home/june/collector/temp/aprsdigi-2.4.4/libax25ext.c"
pk_val parse_raw_ax25(unsigned char **frame , int *len , struct ax_calls *calls ) 
{ 
  unsigned char *tmp ;
  unsigned char *tmp___0 ;

  {
#line 31
  if (((int )*(*frame) & 15) != 0) {
#line 32
    return ((pk_val )-1);
  } else
#line 31
  if (*len < 15) {
#line 32
    return ((pk_val )-1);
  }
  {
#line 33
  (*frame) ++;
#line 34
  (*len) --;
#line 35
  bzero((void *)calls, sizeof(*calls));
#line 36
  calls->ax_next_digi = 0;
#line 37
  bcopy((void const   *)*frame, (void *)(calls->ax_to_call.ax25_call), (size_t )7);
#line 38
  *frame += 7;
#line 39
  *len -= 7;
#line 40
  bcopy((void const   *)*frame, (void *)(calls->ax_from_call.ax25_call), (size_t )7);
#line 41
  *frame += 7;
#line 42
  *len -= 7;
  }
#line 43
  if (*len <= 0) {
#line 44
    return ((pk_val )0);
  }
#line 45
  if (! ((int )calls->ax_from_call.ax25_call[6] & 1)) {
#line 46
    calls->ax_n_digis = 0;
    {
#line 46
    while (1) {
      while_continue: /* CIL Label */ ;
#line 46
      if (calls->ax_n_digis < 8) {
#line 46
        if (! (*len > 0)) {
#line 46
          goto while_break;
        }
      } else {
#line 46
        goto while_break;
      }
      {
#line 49
      bcopy((void const   *)*frame, (void *)(calls->ax_digi_call[calls->ax_n_digis].ax25_call),
            (size_t )7);
      }
#line 50
      if ((int )*(*frame + 6) & 128) {
#line 51
        calls->ax_next_digi = calls->ax_n_digis + 1;
      }
#line 52
      if ((int )*(*frame + 6) & 1) {
#line 53
        *frame += 7;
#line 54
        *len -= 7;
#line 55
        (calls->ax_n_digis) ++;
#line 56
        goto while_break;
      }
#line 46
      (calls->ax_n_digis) ++;
#line 46
      *len -= 7;
#line 46
      *frame += 7;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 60
  (*len) --;
#line 60
  if (*len >= 0) {
#line 61
    tmp = *frame;
#line 61
    (*frame) ++;
#line 61
    calls->ax_type = *tmp;
  }
#line 62
  (*len) --;
#line 62
  if (*len >= 0) {
#line 63
    tmp___0 = *frame;
#line 63
    (*frame) ++;
#line 63
    calls->ax_pid = *tmp___0;
  }
#line 64
  if ((int )calls->ax_type == 3) {
#line 64
    if (! ((int )calls->ax_pid == 240)) {
#line 65
      return ((pk_val )-1);
    }
  } else {
#line 65
    return ((pk_val )-1);
  }
#line 66
  if (calls->ax_n_digis == 0) {
#line 68
    return ((pk_val )0);
  } else
#line 66
  if (calls->ax_next_digi >= calls->ax_n_digis) {
#line 68
    return ((pk_val )0);
  } else {
#line 70
    return ((pk_val )1);
  }
}
}
#line 101
extern int ( /* missing proto */  ax25_aton_entry)() ;
#line 82 "/home/june/collector/temp/aprsdigi-2.4.4/libax25ext.c"
pk_val parse_cooked_ax25(unsigned char **frame , int *len , struct ax_calls *calls ) 
{ 
  unsigned char *tok ;
  int state ;
  int next_state ;
  int switchtok ;
  int i ;
  char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  char *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  char *tmp___11 ;
  unsigned char *tmp___12 ;
  unsigned char *tmp___13 ;

  {
#line 86
  next_state = 0;
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! (next_state <= 99)) {
#line 88
      goto while_break;
    }
#line 90
    state = next_state;
    {
#line 92
    if (state == 0) {
#line 92
      goto case_0;
    }
#line 114
    if (state == 1) {
#line 114
      goto case_1;
    }
#line 122
    if (state == 11) {
#line 122
      goto case_11;
    }
#line 129
    if (state == 3) {
#line 129
      goto case_3;
    }
#line 163
    if (state == 5) {
#line 163
      goto case_5;
    }
#line 166
    if (state == 7) {
#line 166
      goto case_7;
    }
#line 173
    if (state == 2) {
#line 173
      goto case_2;
    }
#line 218
    if (state == 4) {
#line 218
      goto case_4;
    }
#line 221
    if (state == 6) {
#line 221
      goto case_6;
    }
#line 248
    if (state == 8) {
#line 248
      goto case_8;
    }
#line 251
    if (state == 10) {
#line 251
      goto case_10;
    }
#line 266
    if (state == 99) {
#line 266
      goto case_99;
    }
#line 280
    goto switch_default___1;
    case_0: /* CIL Label */ 
    {
#line 94
    bzero((void *)calls, sizeof(*calls));
#line 95
    calls->ax_n_digis = 0;
#line 97
    tmp = strpbrk((char const   *)*frame, "*>");
#line 97
    tok = (unsigned char *)tmp;
    }
#line 97
    if ((unsigned long )tok == (unsigned long )((void *)0)) {
#line 98
      return ((pk_val )-1);
    }
    {
#line 99
    switchtok = (int )*tok;
#line 100
    tmp___0 = tok;
#line 100
    tok ++;
#line 100
    *tmp___0 = (unsigned char )'\000';
#line 101
    ax25_aton_entry(*frame, calls->ax_from_call.ax25_call);
#line 102
    *len = (int )((long )*len - (tok - *frame));
#line 103
    *frame = tok;
    }
    {
#line 105
    if (switchtok == 42) {
#line 105
      goto case_42;
    }
#line 109
    if (switchtok == 62) {
#line 109
      goto case_62;
    }
#line 104
    goto switch_break___0;
    case_42: /* CIL Label */ 
#line 106
    calls->ax_from_call.ax25_call[6] = (char )((int )calls->ax_from_call.ax25_call[6] | 128);
#line 107
    next_state = 1;
#line 108
    goto switch_break___0;
    case_62: /* CIL Label */ 
#line 110
    next_state = 2;
#line 111
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 113
    goto switch_break;
    case_1: /* CIL Label */ 
#line 115
    tmp___1 = tok;
#line 115
    tok ++;
#line 115
    if ((int )*tmp___1 == 62) {
#line 116
      next_state = 3;
#line 117
      *len = (int )((long )*len - (tok - *frame));
#line 118
      *frame = tok;
    } else {
#line 120
      return ((pk_val )-1);
    }
#line 121
    goto switch_break;
    case_11: /* CIL Label */ 
#line 123
    tmp___2 = tok;
#line 123
    tok ++;
#line 123
    if ((int )*tmp___2 != 62) {
#line 124
      return ((pk_val )-1);
    }
#line 125
    *frame = tok;
#line 126
    (*len) --;
#line 127
    next_state = 3;
#line 128
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 130
    tmp___3 = strpbrk((char const   *)*frame, ">*:");
#line 130
    tok = (unsigned char *)tmp___3;
    }
#line 130
    if ((unsigned long )tok == (unsigned long )((void *)0)) {
#line 131
      return ((pk_val )-1);
    }
#line 132
    switchtok = (int )*tok;
#line 133
    tmp___4 = tok;
#line 133
    tok ++;
#line 133
    *tmp___4 = (unsigned char )'\000';
    {
#line 136
    if (switchtok == 42) {
#line 136
      goto case_42___0;
    }
#line 136
    if (switchtok == 62) {
#line 136
      goto case_42___0;
    }
#line 153
    if (switchtok == 58) {
#line 153
      goto case_58;
    }
#line 159
    goto switch_default;
    case_42___0: /* CIL Label */ 
    case_62___0: /* CIL Label */ 
#line 137
    if (calls->ax_n_digis >= 8) {
#line 138
      return ((pk_val )-1);
    }
    {
#line 139
    ax25_aton_entry(*frame, calls->ax_digi_call[calls->ax_n_digis].ax25_call);
#line 140
    *len = (int )((long )*len - (tok - *frame));
#line 141
    *frame = tok;
#line 142
    (calls->ax_n_digis) ++;
    }
#line 143
    if (switchtok == 62) {
#line 144
      next_state = 3;
    } else {
#line 147
      i = 0;
      {
#line 147
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 147
        if (! (i < calls->ax_n_digis)) {
#line 147
          goto while_break___0;
        }
#line 148
        calls->ax_digi_call[i].ax25_call[6] = (char )((int )calls->ax_digi_call[i].ax25_call[6] | 128);
#line 147
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 149
      calls->ax_next_digi = calls->ax_n_digis;
#line 150
      next_state = 7;
    }
#line 152
    goto switch_break___1;
    case_58: /* CIL Label */ 
    {
#line 154
    ax25_aton_entry(*frame, calls->ax_to_call.ax25_call);
#line 155
    *len = (int )((long )*len - (tok - *frame));
#line 156
    *frame = tok;
#line 157
    next_state = 99;
    }
#line 158
    goto switch_break___1;
    switch_default: /* CIL Label */ 
#line 160
    return ((pk_val )-1);
    switch_break___1: /* CIL Label */ ;
    }
#line 162
    goto switch_break;
    case_5: /* CIL Label */ 
#line 164
    return ((pk_val )-1);
#line 165
    goto switch_break;
    case_7: /* CIL Label */ 
#line 167
    tmp___5 = tok;
#line 167
    tok ++;
#line 167
    if ((int )*tmp___5 != 62) {
#line 168
      return ((pk_val )-1);
    }
#line 169
    (*len) --;
#line 170
    *frame = tok;
#line 171
    next_state = 3;
#line 172
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 174
    tmp___6 = strpbrk((char const   *)*frame, ">*:,");
#line 174
    tok = (unsigned char *)tmp___6;
    }
#line 174
    if ((unsigned long )tok == (unsigned long )((void *)0)) {
#line 175
      return ((pk_val )-1);
    }
#line 176
    switchtok = (int )*tok;
    {
#line 178
    if (switchtok == 62) {
#line 178
      goto case_62___1;
    }
#line 188
    if (switchtok == 42) {
#line 188
      goto case_42___1;
    }
#line 202
    if (switchtok == 58) {
#line 202
      goto case_58___0;
    }
#line 209
    if (switchtok == 44) {
#line 209
      goto case_44;
    }
#line 177
    goto switch_break___2;
    case_62___1: /* CIL Label */ 
#line 179
    tmp___7 = tok;
#line 179
    tok ++;
#line 179
    *tmp___7 = (unsigned char )'\000';
#line 180
    if (calls->ax_n_digis >= 8) {
#line 181
      return ((pk_val )-1);
    }
    {
#line 182
    ax25_aton_entry(*frame, calls->ax_digi_call[calls->ax_n_digis].ax25_call);
#line 183
    *len = (int )((long )*len - (tok - *frame));
#line 184
    *frame = tok;
#line 185
    (calls->ax_n_digis) ++;
#line 186
    next_state = 3;
    }
#line 187
    goto switch_break___2;
    case_42___1: /* CIL Label */ 
#line 189
    tmp___8 = tok;
#line 189
    tok ++;
#line 189
    *tmp___8 = (unsigned char )'\000';
#line 190
    if (calls->ax_n_digis >= 8) {
#line 191
      return ((pk_val )-1);
    }
    {
#line 192
    ax25_aton_entry(*frame, calls->ax_digi_call[calls->ax_n_digis].ax25_call);
#line 193
    *len = (int )((long )*len - (tok - *frame));
#line 194
    *frame = tok;
#line 195
    (calls->ax_n_digis) ++;
#line 197
    i = 0;
    }
    {
#line 197
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 197
      if (! (i < calls->ax_n_digis)) {
#line 197
        goto while_break___1;
      }
#line 198
      calls->ax_digi_call[i].ax25_call[6] = (char )((int )calls->ax_digi_call[i].ax25_call[6] | 128);
#line 197
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 199
    calls->ax_next_digi = calls->ax_n_digis;
#line 200
    next_state = 11;
#line 201
    goto switch_break___2;
    case_58___0: /* CIL Label */ 
    {
#line 203
    tmp___9 = tok;
#line 203
    tok ++;
#line 203
    *tmp___9 = (unsigned char )'\000';
#line 204
    ax25_aton_entry(*frame, calls->ax_to_call.ax25_call);
#line 205
    *len = (int )((long )*len - (tok - *frame));
#line 206
    *frame = tok;
#line 207
    next_state = 99;
    }
#line 208
    goto switch_break___2;
    case_44: /* CIL Label */ 
    {
#line 210
    tmp___10 = tok;
#line 210
    tok ++;
#line 210
    *tmp___10 = (unsigned char )'\000';
#line 211
    ax25_aton_entry(*frame, calls->ax_to_call.ax25_call);
#line 212
    *len = (int )((long )*len - (tok - *frame));
#line 213
    *frame = tok;
#line 214
    next_state = 6;
    }
#line 215
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
#line 217
    goto switch_break;
    case_4: /* CIL Label */ 
#line 219
    return ((pk_val )-1);
#line 220
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 222
    tmp___11 = strpbrk((char const   *)*frame, ":*,");
#line 222
    tok = (unsigned char *)tmp___11;
    }
#line 222
    if ((unsigned long )tok == (unsigned long )((void *)0)) {
#line 223
      return ((pk_val )-1);
    }
#line 224
    switchtok = (int )*tok;
#line 225
    tmp___12 = tok;
#line 225
    tok ++;
#line 225
    *tmp___12 = (unsigned char )'\000';
#line 226
    if (calls->ax_n_digis >= 8) {
#line 227
      return ((pk_val )-1);
    }
    {
#line 228
    ax25_aton_entry(*frame, calls->ax_digi_call[calls->ax_n_digis].ax25_call);
#line 229
    *len = (int )((long )*len - (tok - *frame));
#line 230
    *frame = tok;
#line 231
    (calls->ax_n_digis) ++;
    }
    {
#line 233
    if (switchtok == 58) {
#line 233
      goto case_58___1;
    }
#line 236
    if (switchtok == 42) {
#line 236
      goto case_42___2;
    }
#line 243
    if (switchtok == 44) {
#line 243
      goto case_44___0;
    }
#line 232
    goto switch_break___3;
    case_58___1: /* CIL Label */ 
#line 234
    next_state = 99;
#line 235
    goto switch_break___3;
    case_42___2: /* CIL Label */ 
#line 238
    i = 0;
    {
#line 238
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 238
      if (! (i < calls->ax_n_digis)) {
#line 238
        goto while_break___2;
      }
#line 239
      calls->ax_digi_call[i].ax25_call[6] = (char )((int )calls->ax_digi_call[i].ax25_call[6] | 128);
#line 238
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 240
    calls->ax_next_digi = calls->ax_n_digis;
#line 241
    next_state = 10;
#line 242
    goto switch_break___3;
    case_44___0: /* CIL Label */ 
#line 244
    next_state = 6;
#line 245
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
#line 247
    goto switch_break;
    case_8: /* CIL Label */ 
#line 249
    return ((pk_val )-1);
#line 250
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 253
    if ((int )*tok == 44) {
#line 253
      goto case_44___1;
    }
#line 256
    if ((int )*tok == 58) {
#line 256
      goto case_58___2;
    }
#line 259
    goto switch_default___0;
    case_44___1: /* CIL Label */ 
#line 254
    next_state = 6;
#line 255
    goto switch_break___4;
    case_58___2: /* CIL Label */ 
#line 257
    next_state = 99;
#line 258
    goto switch_break___4;
    switch_default___0: /* CIL Label */ 
#line 260
    return ((pk_val )-1);
    switch_break___4: /* CIL Label */ ;
    }
#line 262
    tmp___13 = tok;
#line 262
    tok ++;
#line 262
    *tmp___13 = (unsigned char )'\000';
#line 263
    (*len) --;
#line 264
    *frame = tok;
#line 265
    goto switch_break;
    case_99: /* CIL Label */ 
#line 267
    calls->ax_type = (unsigned char)3;
#line 269
    if (calls->ax_n_digis == 0) {
#line 270
      calls->ax_from_call.ax25_call[6] = (char )((int )calls->ax_from_call.ax25_call[6] | 1);
    } else {
#line 272
      calls->ax_digi_call[calls->ax_n_digis - 1].ax25_call[6] = (char )((int )calls->ax_digi_call[calls->ax_n_digis - 1].ax25_call[6] | 1);
    }
#line 274
    if (calls->ax_n_digis == 0) {
#line 276
      return ((pk_val )0);
    } else
#line 274
    if (calls->ax_next_digi >= calls->ax_n_digis) {
#line 276
      return ((pk_val )0);
    } else {
#line 278
      return ((pk_val )1);
    }
#line 279
    goto switch_break;
    switch_default___1: /* CIL Label */ 
#line 281
    return ((pk_val )-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 286
  return ((enum __anonenum_pk_val_3 )0);
}
}
#line 290 "/home/june/collector/temp/aprsdigi-2.4.4/libax25ext.c"
int gen_raw_ax25(unsigned char **frame , int *len , struct ax_calls *calls ) 
{ 
  int minsize ;
  int i ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;

  {
#line 293
  minsize = (15 + calls->ax_n_digis * 7) + 2;
#line 296
  if (*len < minsize) {
#line 297
    return (-1);
  }
#line 298
  *len -= minsize;
#line 299
  if (calls->ax_n_digis == 0) {
#line 300
    calls->ax_from_call.ax25_call[6] = (char )((int )calls->ax_from_call.ax25_call[6] | 1);
  } else {
#line 302
    calls->ax_from_call.ax25_call[6] = (char )((int )calls->ax_from_call.ax25_call[6] & -2);
  }
  {
#line 304
  tmp = *frame;
#line 304
  (*frame) ++;
#line 304
  *tmp = (unsigned char )'\000';
#line 305
  bcopy((void const   *)(calls->ax_to_call.ax25_call), (void *)*frame, (size_t )7);
#line 306
  *frame += 7;
#line 307
  bcopy((void const   *)(calls->ax_from_call.ax25_call), (void *)*frame, (size_t )7);
#line 308
  *frame += 7;
#line 309
  i = 0;
  }
  {
#line 309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 309
    if (! (i < calls->ax_n_digis)) {
#line 309
      goto while_break;
    }
    {
#line 310
    calls->ax_digi_call[i].ax25_call[6] = (char )((int )calls->ax_digi_call[i].ax25_call[6] & -2);
#line 311
    bcopy((void const   *)(calls->ax_digi_call[i].ax25_call), (void *)*frame, (size_t )7);
#line 309
    i ++;
#line 309
    *frame += 7;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 313
  if (i > 0) {
#line 314
    *((*frame - 7) + 6) = (unsigned char )((int )*((*frame - 7) + 6) | 1);
  }
#line 315
  tmp___0 = *frame;
#line 315
  (*frame) ++;
#line 315
  *tmp___0 = calls->ax_type;
#line 316
  tmp___1 = *frame;
#line 316
  (*frame) ++;
#line 316
  *tmp___1 = calls->ax_pid;
#line 317
  return (0);
}
}
#line 322 "/home/june/collector/temp/aprsdigi-2.4.4/libax25ext.c"
int gen_cooked_ax25(unsigned char **frame , int *len , struct ax_calls *calls ) 
{ 
  int minsize ;
  int i ;
  int l ;
  char *tmp ;
  size_t tmp___0 ;
  unsigned char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  unsigned char *tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;

  {
#line 325
  minsize = (22 + calls->ax_n_digis * 11) + 2;
#line 328
  if (*len < minsize) {
#line 329
    return (-1);
  }
  {
#line 331
  tmp = ax25_ntoa_pretty((ax25_address const   *)(& calls->ax_from_call));
#line 331
  strncpy((char */* __restrict  */)*frame, (char const   */* __restrict  */)tmp, (size_t )10);
#line 332
  tmp___0 = strlen((char const   *)*frame);
#line 332
  l = (int )tmp___0;
#line 333
  *frame += l;
#line 334
  tmp___1 = *frame;
#line 334
  (*frame) ++;
#line 334
  *tmp___1 = (unsigned char )'>';
#line 335
  *len -= l + 1;
#line 336
  tmp___2 = ax25_ntoa_pretty((ax25_address const   *)(& calls->ax_to_call));
#line 336
  strncpy((char */* __restrict  */)*frame, (char const   */* __restrict  */)tmp___2,
          (size_t )10);
#line 337
  tmp___3 = strlen((char const   *)*frame);
#line 337
  l = (int )tmp___3;
#line 338
  *frame += l;
#line 339
  *len -= l;
#line 340
  i = 0;
  }
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 340
    if (! (i < calls->ax_n_digis)) {
#line 340
      goto while_break;
    }
    {
#line 341
    tmp___4 = *frame;
#line 341
    (*frame) ++;
#line 341
    *tmp___4 = (unsigned char )',';
#line 342
    (*len) --;
#line 343
    tmp___5 = ax25_ntoa_pretty((ax25_address const   *)(& calls->ax_digi_call[i]));
#line 343
    strncpy((char */* __restrict  */)*frame, (char const   */* __restrict  */)tmp___5,
            (size_t )10);
#line 344
    tmp___6 = strlen((char const   *)*frame);
#line 344
    l = (int )tmp___6;
#line 345
    *frame += l;
#line 346
    *len -= l;
    }
#line 348
    if (calls->ax_n_digis) {
#line 348
      if (calls->ax_next_digi - 1 == i) {
#line 349
        tmp___7 = *frame;
#line 349
        (*frame) ++;
#line 349
        *tmp___7 = (unsigned char )'*';
#line 350
        (*len) --;
      }
    }
#line 340
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 353
  tmp___8 = *frame;
#line 353
  (*frame) ++;
#line 353
  *tmp___8 = (unsigned char )':';
#line 354
  (*len) --;
#line 355
  return (0);
}
}
#line 368 "/home/june/collector/temp/aprsdigi-2.4.4/libax25ext.c"
static char buf[11]  ;
#line 366 "/home/june/collector/temp/aprsdigi-2.4.4/libax25ext.c"
char *ax25_ntoa_pretty(ax25_address const   *a ) 
{ 
  char c ;
  char *s ;
  int n ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 372
  n = 0;
#line 372
  s = buf;
  {
#line 372
  while (1) {
    while_continue: /* CIL Label */ ;
#line 372
    if (! (n < 6)) {
#line 372
      goto while_break;
    }
#line 373
    c = (char )(((int )a->ax25_call[n] >> 1) & 127);
#line 375
    if ((int )c != 32) {
#line 375
      tmp = s;
#line 375
      s ++;
#line 375
      *tmp = c;
    }
#line 372
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 378
  n = ((int )a->ax25_call[6] >> 1) & 15;
#line 378
  if (n) {
#line 379
    tmp___0 = s;
#line 379
    s ++;
#line 379
    *tmp___0 = (char )'-';
#line 381
    if (n > 9) {
#line 382
      tmp___1 = s;
#line 382
      s ++;
#line 382
      *tmp___1 = (char )'1';
#line 383
      n -= 10;
    }
#line 386
    tmp___2 = s;
#line 386
    s ++;
#line 386
    *tmp___2 = (char )(n + 48);
  }
#line 389
  tmp___3 = s;
#line 389
  s ++;
#line 389
  *tmp___3 = (char )'\000';
#line 391
  return (buf);
}
}
